1B,0xA8,0x4F,0xA3,0x14,
    0xFA,0xBE,0x12,0xFB,0xD7,0x19,0x4C,0xED,
    0xAD,0xA2,0x95,0x8F,0x39,0x8C,0xC4,0x69,
    0x0F,0x7D,0xB8,0x84,0x0A,0x99,0x5C,0x53,
    0x2F,0xDE,0xF2,0x1B,0xC5,0x1D,0x4C,0x43,
    0x3C,0x97,0xA7,0xBA,0x8F,0xC3,0x22,0x67,
    0x39,0xC2,0x62,0x74,0x3A,0x0C,0xB5,0x57,
    0x01,0x3A,0x67,0xC6,0xDE,0x0C,0x0B,0xF6,
    0x08,0x01,0x64,0xDB,0xBD,0x81,0xE4,0xDC,
    0x09,0x2E,0xD0,0xF1,0xD0,0xD6,0x1E,0xBA,
    0x38,0x36,0xF4,0x4A,0xDD,0xCA,0x39,0xEB,
    0x76,0xCF,0x95,0xDC,0x48,0x4C,0xF2,0x43,
    0x8C,0xD9,0x44,0x26,0x7A,0x9E,0xEB,0x99,
    0xA3,0xD8,0xFB,0x30,0xA8,0x14,0x42,0x82,
    0x8D,0xB4,0x31,0xB3,0x1A,0xD5,0x2B,0xF6,
    0x32,0xBC,0x62,0xC0,0xFE,0x81,0x20,0x49,
    0xE7,0xF7,0x58,0x2F,0x2D,0xA6,0x1B,0x41,
    0x62,0xC7,0xE0,0x32,0x02,0x5D,0x82,0xEC,
    0xA3,0xE4,0x6C,0x9B,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00*/
//## -- retail public key
	0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,0x00,0x08,0x00,0x00,0xff,
	0x00,0x00,0x00,0x01,0x00,0x01,0x00,0xd3,0xd7,0x4e,0xe5,0x66,0x3d,
	0xd7,0xe6,0xc2,0xd4,0xa3,0xa1,0xf2,0x17,0x36,0xd4,0x2e,0x52,0xf6,
	0xd2,0x02,0x10,0xf5,0x64,0x9c,0x34,0x7b,0xff,0xef,0x7f,0xc2,0xee,
	0xbd,0x05,0x8b,0xde,0x79,0xb4,0x77,0x8e,0x5b,0x8c,0x14,0x99,0xe3,
	0xae,0xc6,0x73,0x72,0x73,0xb5,0xfb,0x01,0x5b,0x58,0x46,0x6d,0xfc,
	0x8a,0xd6,0x95,0xda,0xed,0x1b,0x2e,0x2f,0xa2,0x29,0xe1,0x3f,0xf1,
	0xb9,0x5b,0x64,0x51,0x2e,0xa2,0xc0,0xf7,0xba,0xb3,0x3e,0x8a,0x75,
	0xff,0x06,0x92,0x5c,0x07,0x26,0x75,0x79,0x10,0x5d,0x47,0xbe,0xd1,
	0x6a,0x52,0x90,0x0b,0xae,0x6a,0x0b,0x33,0x44,0x93,0x5e,0xf9,0x9d,
	0xfb,0x15,0xd9,0xa4,0x1c,0xcf,0x6f,0xe4,0x71,0x94,0xbe,0x13,0x00,
	0xa8,0x52,0xca,0x07,0xbd,0x27,0x98,0x01,0xa1,0x9e,0x4f,0xa3,0xed,
	0x9f,0xa0,0xaa,0x73,0xc4,0x71,0xf3,0xe9,0x4e,0x72,0x42,0x9c,0xf0,
	0x39,0xce,0xbe,0x03,0x76,0xfa,0x2b,0x89,0x14,0x9a,0x81,0x16,0xc1,
	0x80,0x8c,0x3e,0x6b,0xaa,0x05,0xec,0x67,0x5a,0xcf,0xa5,0x70,0xbd,
	0x60,0x0c,0xe8,0x37,0x9d,0xeb,0xf4,0x52,0xea,0x4e,0x60,0x9f,0xe4,
	0x69,0xcf,0x52,0xdb,0x68,0xf5,0x11,0xcb,0x57,0x8f,0x9d,0xa1,0x38,
	0x0a,0x0c,0x47,0x1b,0xb4,0x6c,0x5a,0x53,0x6e,0x26,0x98,0xf1,0x88,
	0xae,0x7c,0x96,0xbc,0xf6,0xbf,0xb0,0x47,0x9a,0x8d,0xe4,0xb3,0xe2,
	0x98,0x85,0x61,0xb1,0xca,0x5f,0xf7,0x98,0x51,0x2d,0x83,0x81,0x76,
	0x0c,0x88,0xba,0xd4,0xc2,0xd5,0x3c,0x14,0xc7,0x72,0xda,0x7e,0xbd,
	0x1b,0x4b,0xa4,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
#endif

//
// Stores the name of the image file.
//
OBJECT_STRING XeImageFileName;

//
// Guards multiple threads attempting to load or unload image sections.
//
INITIALIZED_CRITICAL_SECTION(XepLoaderLock);

//
// Name of the default Xbox executable to load from the CD-ROM device.
//
const OCHAR XepDefaultImagePath[] = OTEXT("\\Device\\CdRom0\\default.xbe");

//## -- load 3 variants
// Name of the default dashboard Xbox executable to load from the disk device.
//
const OCHAR XepDashboardImagePath1[] = OTEXT("\\Device\\Harddisk0\\Partition2\\cpxdash.xbe");
const OCHAR XepDashboardImagePath2[] = OTEXT("\\Device\\Harddisk0\\Partition2\\evoxdash.xbe");
const OCHAR XepDashboardImagePath3[] = OTEXT("\\Device\\Harddisk0\\Partition2\\xboxdash.xbe");

//
// Name of the DOS device symbolic link for the CD-ROM device.
//
INITIALIZED_OBJECT_STRING_RDATA(XepCdRomDosDevice, "\\??\\D:");

#ifdef DEVKIT
//
// Static loader data table entry for the Xbox executable image.
//
LDR_DATA_TABLE_ENTRY XepDataTableEntry;

//
// Indicates whether or not section load and unload debugger notifications
// should be sent.
//
BOOLEAN XepSendSectionDebugNotifications;
//## -- #endif moved here
#endif

//
// Name of the dashboard direction file used to specify an alternate dashboard.
//
INITIALIZED_OBJECT_STRING_RDATA(XepDashboardRedirectionPath, "\\Device\\Harddisk0\\Partition1\\dashboard.xbx");

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, XeLoadImageAfterTrayEjectBoot)
#endif

//
// Stores the title identifier for the media located in the CD-ROM device.  The
// loader only allows a single title identifier to be launched from a single
// media.
//
DECLSPEC_STICKY ULONG XeCdRomMediaTitleID;

NTSTATUS
XepOpenImageFile(
    OUT PHANDLE ImageFileHandle
    )
/*++

Routine Description:

    This routine opens the image file with the appropriate options.

Arguments:

    ImageFileHandle - Specifies the buffer to receive the handle to the image
        file.

Return Value:

    Status of operation.

--*/
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;

    InitializeObjectAttributes(&ObjectAttributes, &XeImageFileName,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    return NtOpenFile(ImageFileHandle, GENERIC_READ, &ObjectAttributes,
        &IoStatusBlock, FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT |
        FILE_NON_DIRECTORY_FILE);
}

NTSTATUS
XepReadImageFile(
    IN HANDLE ImageFileHandle,
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG ByteOffset
    )
/*++

Routine Description:

    This routine reads the requested number of bytes from the file to the
    supplied buffer from the starting file byte offset.

Arguments:

    ImageFileHandle - Specifies the handle to the image file.

    Buffer - Specifies the address of the buffer to receive the image file data.

    Length - Specifies the number of bytes to transfer to the buffer.

    ByteOffset - Specifies the byte offset within the file to begin the read
        operation.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    LARGE_INTEGER ByteOffsetLarge;
    IO_STATUS_BLOCK IoStatusBlock;

    ByteOffsetLarge.QuadPart = ByteOffset;

    status = NtReadFile(ImageFileHandle, NULL, NULL, NULL, &IoStatusBlock,
        Buffer, Length, &ByteOffsetLarge);

    if (NT_SUCCESS(status)) {

        if (IoStatusBlock.Information != Length) {
            status = STATUS_FILE_CORRUPT_ERROR;
        }
    }

    return status;
}

NTSTATUS
XepCommitSectionPages(
    IN PXBEIMAGE_SECTION Section
    )
/*++

Routine Description:

    This routine commits the pages assigned to the supplied section.

Arguments:

    Section - Specifies the section to commit pages for.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVOID BaseAddress;
    SIZE_T RegionSize;

    //
    // Commit the pages for the section.  Note that NtAllocateVirtualMemory is
    // serving double duty if the pages are already committed: the pages may be
    // marked as PAGE_EXECUTE_READ, but we need to change them to
    // PAGE_EXECUTE_READWRITE in order to transfer data to the page.
    //

    BaseAddress = (PVOID)Section->VirtualAddress;
    RegionSize = Section->VirtualSize;

    status = NtAllocateVirtualMemory(&BaseAddress, 0, &RegionSize,
        MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    if (!NT_SUCCESS(status)) {
        LdrxDbgPrint(("LDRX: failed to commit memory for section %s (size=%08x).\n",
            Section->SectionName, Section->VirtualSize));
        return status;
    }

    //
    // Increment the shared page reference counts.
    //

    (*Section->HeadSharedPageReferenceCount)++;
    (*Section->TailSharedPageReferenceCount)++;

    return STATUS_SUCCESS;
}

VOID
XepMarkSectionPagesReadOnly(
    IN PXBEIMAGE_SECTION Section
    )
/*++

Routine Description:

    This routine changes the protection of a section's page to be read-only.

Arguments:

    Section - Specifies the section to change the protection for.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    PVOID BaseAddress;
    PVOID EndingAddress;
    SIZE_T RegionSize;
    ULONG OldProtect;

    ASSERT(Section->SectionReferenceCount > 0);
    ASSERT(LdrxIsFlagClear(Section->SectionFlags, XBEIMAGE_SECTION_WRITEABLE));

    //
    // Compute the pointers to the first and last byte, exclusive, of the
    // section.
    //

    BaseAddress = (PVOID)Section->VirtualAddress;
    EndingAddress = (PVOID)(Section->VirtualAddress + Section->VirtualSize);

    //
    // If the tail page of the section can't be marked as read-only, then align
    // the pointer down to the nearest page boundary so that we don't change the
    // protection of this page.
    //

    if (LdrxIsFlagClear(Section->SectionFlags, XBEIMAGE_SECTION_TAIL_PAGE_READONLY)) {
        EndingAddress = PAGE_ALIGN(EndingAddress);
    }

    //
    // If the head page of the section can't be marked as read-only, then align
    // the pointer up to the next page boundary so that we don't change the
    // protection of this page.
    //

    if (LdrxIsFlagClear(Section->SectionFlags, XBEIMAGE_SECTION_HEAD_PAGE_READONLY)) {
        BaseAddress = PAGE_ALIGN((PUCHAR)BaseAddress + PAGE_SIZE);
    }

    //
    // If the ending address is still beyond the base address, then there's at
    // least one page that can be marked as read-only.  Note that
    // NtProtectVirtualMemory can handle the base address not being page aligned
    // and the region size not being an integral number of pages.
    //

    if (EndingAddress > BaseAddress) {

        RegionSize = (ULONG)EndingAddress - (ULONG)BaseAddress;

        status = NtProtectVirtualMemory(&BaseAddress, &RegionSize,
            PAGE_EXECUTE_READ, &OldProtect);

        ASSERT(NT_SUCCESS(status));
    }
}

VOID
XepDecommitSectionPages(
    IN PXBEIMAGE_SECTION Section
    )
/*++

Routine Description:

    This routine decommits the pages assigned to the supplied section.

Arguments:

    Section - Specifies the section to decommit pages for.

Return Value:

    None.

--*/
{
    PVOID BaseAddress;
    PVOID EndingAddress;
    SIZE_T RegionSize;

    ASSERT(*Section->HeadSharedPageReferenceCount > 0);
    ASSERT(*Section->TailSharedPageReferenceCount > 0);

    //
    // Compute the pointers to the first and last byte, exclusive, of the
    // section.
    //

    BaseAddress = (PVOID)Section->VirtualAddress;
    EndingAddress = (PVOID)(Section->VirtualAddress + Section->VirtualSize);

    //
    // Decrement the shared page reference counts.
    //

    (*Section->HeadSharedPageReferenceCount)--;
    (*Section->TailSharedPageReferenceCount)--;

    //
    // If the tail page still has references, then align the pointer down to the
    // nearest page boundary so that we don't free the page.
    //

    if ((*Section->TailSharedPageReferenceCount) != 0) {
        EndingAddress = PAGE_ALIGN(EndingAddress);
    }

    //
    // If the head page still has references, then align the pointer up to the
    // next page boundary so that we don't free the page.
    //

    if ((*Section->HeadSharedPageReferenceCount) != 0) {
        BaseAddress = PAGE_ALIGN((PUCHAR)BaseAddress + PAGE_SIZE);
    }

    //
    // If the ending address is still beyond the base address, then there's at
    // least one page that can be decommitted.  Note that NtFreeVirtualMemory
    // can handle the base address not being page aligned and the region size
    // not being an integral number of pages.
    //

    if (EndingAddress > BaseAddress) {

        RegionSize = (ULONG)EndingAddress - (ULONG)BaseAddress;

        NtFreeVirtualMemory(&BaseAddress, &RegionSize, MEM_DECOMMIT);
    }
}

NTSTATUS
XepLoadSection(
    IN HANDLE ImageFileHandle,
    IN PXBEIMAGE_SECTION Section,
    IN BOOLEAN Preloading
    )
/*++

Routine Description:

    This routine loads the supplied section into memory.

Arguments:

    ImageFileHandle - Specifies the handle of the file that the section can be
        loaded from.

    Section - Specifies the section to be loaded.

    Preloading - Specifies TRUE if the section is being loaded from inside
        XeLoadImage, else FALSE.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    //UCHAR SectionDigest[XC_DIGEST_LEN];

    ASSERT(Section->SectionReferenceCount == 0);
    ASSERT(Section->SizeOfRawData <= Section->VirtualSize);

    //
    // Commit the pages assigned to the section.  Note that if this fails, then
    // we'll always allow the error to propagate back to the caller.
    //

    status = XepCommitSectionPages(Section);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Read the raw data from the image file.
    //

    status = XepReadImageFile(ImageFileHandle, (PVOID)Section->VirtualAddress,
        Section->SizeOfRawData, Section->PointerToRawData);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Zero the rest of the section.
    //

    RtlZeroMemory((PUCHAR)Section->VirtualAddress + Section->SizeOfRawData,
        Section->VirtualSize - Section->SizeOfRawData);

    //
    // Verify that the digest of the data that was read from the file matches
    // the digest stored in the section header.
    //
/*## -- section hash check
    XCCalcDigest((PUCHAR)Section->VirtualAddress, Section->SizeOfRawData,
        SectionDigest);

    if (memcmp(Section->SectionDigest, SectionDigest, XC_DIGEST_LEN) != 0) {
        LdrxDbgPrint(("LDRX: failed to verify section digest.\n"));
        status = STATUS_TRUST_FAILURE;
        goto CleanupAndExit;
    }*/

    //
    // The section is now loaded.
    //

    Section->SectionReferenceCount = 1;

    status = STATUS_SUCCESS;

#ifdef DEVKIT
    //
    // Notify the debugger that the section has been loaded.
    //

    if (XepSendSectionDebugNotifications) {
        DebugService(BREAKPOINT_LOAD_XESECTION, Section, NULL);
    }
#endif

CleanupAndExit:
    if (!NT_SUCCESS(status)) {

        //
        // Decommit the pages assigned to the section.
        //

        XepDecommitSectionPages(Section);

        //
        // If a section fails to load due to a device I/O error or the section
        // digest not matching and we're not inside XeLoadImage, then halt the
        // system.  If the current title is the dashboard, then the disk is
        // probably corrupt, so we'll display the universal error message.  We
        // don't simply return an error to the caller, because we can't trust
        // that the title will properly handle the error and the title will
        // likely crash anyway.
        //

        if (!Preloading) {

            LdrxDbgPrint(("LDRX: failed to read section %08x (status=%08x).\n",
                Section, status));

            if (XeImageHeader()->Certificate->TitleID == LDR_DASHBOARD_TITLE_ID) {
                HalReturnToFirmware(HalFatalErrorRebootRoutine);
            } else {
                HalHaltSystem();
            }
        }
    }


    return status;
}

NTSTATUS
XeLoadSection(
    IN PXBEIMAGE_SECTION Section
    )
/*++

Routine Description:

    This routine loads the supplied section into memory or increments the
    reference count for the section if the section is already loaded.

Arguments:

    Section - Specifies the section to be loaded.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    HANDLE ImageFileHandle;

    ImageFileHandle = NULL;

    RtlEnterCriticalSectionAndRegion(&XepLoaderLock);

    //
    // Check if the section is already loaded and if so, just increment the
    // section's reference count and bail out.
    //

    if (Section->SectionReferenceCount > 0) {
        Section->SectionReferenceCount++;
        status = STATUS_SUCCESS;
        goto CleanupAndExit;
    }

    //
    // Open the image file.
    //

    status = XepOpenImageFile(&ImageFileHandle);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Delegate the actual section loading to a common worker routine.
    //

    status = XepLoadSection(ImageFileHandle, Section, FALSE);

    if (NT_SUCCESS(status)) {

        //
        // Change the protection of the section to PAGE_EXECUTE_READ if the
        // section is not a writeable section.
        //

        if (LdrxIsFlagClear(Section->SectionFlags, XBEIMAGE_SECTION_WRITEABLE)) {
            XepMarkSectionPagesReadOnly(Section);
        }
    }

CleanupAndExit:
    //
    // Close the image file handle.
    //

    if (ImageFileHandle != NULL) {
        NtClose(ImageFileHandle);
    }

    RtlLeaveCriticalSectionAndRegion(&XepLoaderLock);

    return status;
}

NTSTATUS
XeUnloadSection(
    IN PXBEIMAGE_SECTION Section
    )
/*++

Routine Description:

    This routine decrements the reference count for the supplied section and if
    the count reaches zero, unloads the section from memory.

Arguments:

    Section - Specifies the section to be unloaded.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;

    RtlEnterCriticalSectionAndRegion(&XepLoaderLock);

    //
    // Check if the section has been loaded.  If not, return an error.
    //

    if (Section->SectionReferenceCount == 0) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Decrement the section's reference count and check if there are still
    // references to the section.  If so, bail out.
    //

    Section->SectionReferenceCount--;

    if (Section->SectionReferenceCount > 0) {
        status = STATUS_SUCCESS;
        goto CleanupAndExit;
    }

#ifdef DEVKIT
    //
    // Notify the debugger that the section is unloading.
    //

    if (XepSendSectionDebugNotifications) {
        DebugService(BREAKPOINT_UNLOAD_XESECTION, Section, NULL);
    }
#endif

    //
    // Decommit the pages that are used by the section.
    //

    XepDecommitSectionPages(Section);

    status = STATUS_SUCCESS;

CleanupAndExit:
    RtlLeaveCriticalSectionAndRegion(&XepLoaderLock);

    return status;
}

/*## -- this whole function is unnecessary
NTSTATUS
XepVerifyImageHeaderEncryptedDigest(
    VOID
    )
*++

Routine Description:

    This routine verifies that the encrypted header digest stored in the image
    header matches the digest of the data in the rest of the image headers.

Arguments:

    None.

Return Value:

    Status of operation.

--*
{
    PUCHAR PublicKeyData;
    PUCHAR Workspace;
    ULONG HeaderDigestLength;
    UCHAR HeaderDigest[XC_DIGEST_LEN];
    BOOLEAN Verified;

    PublicKeyData = XePublicKeyData;

    //
    // Allocate a workspace to do the digest verification.
    //

    Workspace = (PUCHAR)ExAllocatePoolWithTag(XCCalcKeyLen(PublicKeyData) * 2,
        'sWeX');

    if (Workspace == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // The encrypted header digest starts at the field after the encrypted
    // header field in the main image header.
    //

    HeaderDigestLength = XeImageHeader()->SizeOfHeaders -
        FIELD_OFFSET(XBEIMAGE_HEADER, BaseAddress);

    //
    // Calculate the SHA1 digest for the headers.
    //

    XCCalcDigest((PUCHAR)&XeImageHeader()->BaseAddress, HeaderDigestLength,
        HeaderDigest);

    //
    // Verify that the SHA1 digest matches the encrypted header digest.
    //

    Verified = XCVerifyDigest(XeImageHeader()->EncryptedDigest, PublicKeyData,
        Workspace, HeaderDigest);

    ExFreePool(Workspace);

    if (Verified) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_TRUST_FAILURE;
    }
}*/

/*## -- this one too
NTSTATUS
XepComputeImageMediaTypes(
    IN HANDLE ImageFileHandle,
    OUT PULONG ReturnedImageMediaTypes
    )
*++

Routine Description:

    This routine computes the type of image media that the supplied file handle
    references.

Arguments:

    ImageFileHandle - Specifies the handle of the image file.

    ReturnedImageMediaTypes - Specifies the buffer to receive the type of media
        that the supplied file handle references.

Return Value:

    Status of operation.

--*
{
    NTSTATUS status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_DEVICE_INFORMATION DeviceInformation;
#if !defined(ARCADE) || defined(DEVKIT)
    DVD_READ_STRUCTURE ReadStructure;
    UCHAR ReadStructureOutput[ALIGN_UP(sizeof(DVD_DESCRIPTOR_HEADER) +
        sizeof(DVD_LAYER_DESCRIPTOR), ULONG)];
    PDVD_DESCRIPTOR_HEADER DescriptorHeader;
    PDVD_LAYER_DESCRIPTOR LayerDescriptor;
    ULONG ImageMediaTypes;
#endif

    //
    // Query the file's volume to find out what type of device we have.
    //

    status = NtQueryVolumeInformationFile(ImageFileHandle, &IoStatusBlock,
        &DeviceInformation, sizeof(FILE_FS_DEVICE_INFORMATION),
        FileFsDeviceInformation);

    if (!NT_SUCCESS(status)) {
        LdrxDbgPrint(("LDRX: failed to query device information (status=%08x).\n",
            status));
        return status;
    }

#ifdef ARCADE
    //
    // Check if this is a handle to a file loaded from the media board.
    //

    if (DeviceInformation.DeviceType == FILE_DEVICE_MEDIA_BOARD) {
        *ReturnedImageMediaTypes = XBEIMAGE_MEDIA_TYPE_MEDIA_BOARD;
        return STATUS_SUCCESS;
    }
#endif

#if !defined(ARCADE) || defined(DEVKIT)
    //
    // If this isn't a handle to a file from the CD-ROM device, then it must be
    // a file from the hard disk device.
    //

    if (DeviceInformation.DeviceType != FILE_DEVICE_CD_ROM) {
        ASSERT(DeviceInformation.DeviceType == FILE_DEVICE_DISK);
        *ReturnedImageMediaTypes = XBEIMAGE_MEDIA_TYPE_HARD_DISK;
        return STATUS_SUCCESS;
    }

    //
    // If the device has already passed DVD-X2 authentication, then we only
    // return this media type flag.
    //

    if (IdexCdRomDVDX2Authenticated) {
        *ReturnedImageMediaTypes = XBEIMAGE_MEDIA_TYPE_DVD_X2;
        return STATUS_SUCCESS;
    }

    //
    // Read the DVD physical descriptor structure.  If the device reports back
    // that this is an unrecognized media, then assume that we have a CD media.
    //

    RtlZeroMemory(&ReadStructure, sizeof(DVD_READ_STRUCTURE));

    ReadStructure.Format = DvdPhysicalDescriptor;

    RtlZeroMemory(ReadStructureOutput, sizeof(ReadStructureOutput));

    status = NtDeviceIoControlFile(ImageFileHandle, NULL, NULL, NULL,
        &IoStatusBlock, IOCTL_DVD_READ_STRUCTURE, &ReadStructure,
        sizeof(DVD_READ_STRUCTURE), &ReadStructureOutput,
        sizeof(ReadStructureOutput));

    if (status == STATUS_UNRECOGNIZED_MEDIA) {
        *ReturnedImageMediaTypes = XBEIMAGE_MEDIA_TYPE_DVD_CD |
            XBEIMAGE_MEDIA_TYPE_CD;
        return STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Decode the DVD physical descriptor structure.
    //

    DescriptorHeader = (PDVD_DESCRIPTOR_HEADER)ReadStructureOutput;
    LayerDescriptor = (PDVD_LAYER_DESCRIPTOR)DescriptorHeader->Data;

    if (LayerDescriptor->LayerType == 0x01) {

        if (LayerDescriptor->NumberOfLayers == 0x00) {
            ImageMediaTypes = XBEIMAGE_MEDIA_TYPE_DVD_CD |
                XBEIMAGE_MEDIA_TYPE_DVD_5_RO;
        } else {
            ImageMediaTypes = XBEIMAGE_MEDIA_TYPE_DVD_CD |
                XBEIMAGE_MEDIA_TYPE_DVD_9_RO;
        }

    } else {

        if (LayerDescriptor->NumberOfLayers == 0x00) {
            ImageMediaTypes = XBEIMAGE_MEDIA_TYPE_DVD_CD |
                XBEIMAGE_MEDIA_TYPE_DVD_5_RW;
        } else {
            ImageMediaTypes = XBEIMAGE_MEDIA_TYPE_DVD_CD |
                XBEIMAGE_MEDIA_TYPE_DVD_9_RW;
        }
    }

    *ReturnedImageMediaTypes = ImageMediaTypes;
    return STATUS_SUCCESS;
#else
    //
    // The only media type that is supported is the media board.  Don't allow
    // executables to be loaded from any other type of media.
    //

    return STATUS_UNSUCCESSFUL;
#endif
}*/

NTSTATUS
XepResolveImageImports(
    IN PVOID ExportBaseAddress,
    IN PIMAGE_THUNK_DATA ImageThunkData
    )
/*++

Routine Description:

    This routine resolves ordinal imports from the supplied export executable.

Arguments:

    ExportBaseAddress - Specifies the base address of the image that is
        providing the exports.

    ImageThunkData - Specifies the pointer to the array of ordinal import thunks
        that are to be replaced by pointers to functions in the export image.

Return Value:

    Status of operation.

--*/
{
    PIMAGE_EXPORT_DIRECTORY ExportDirectory;
    ULONG ExportDirectorySize;
    PULONG AddressOfFunctions;
    ULONG OrdinalNumber;

    //
    // Lookup the export directory from the export executable.
    //

    ExportDirectory =
        (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(ExportBaseAddress,
        TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT, &ExportDirectorySize);

    if (ExportDirectory == NULL) {
        LdrxDbgPrint(("LDRX: cannot import from image %p.\n", ExportBaseAddress));
        return STATUS_ORDINAL_NOT_FOUND;
    }

    AddressOfFunctions = (PULONG)((ULONG)ExportBaseAddress +
        (ULONG)ExportDirectory->AddressOfFunctions);

    //
    // Loop over the image thunks and resolve the ordinals against the export
    // directory.
    //

    while (ImageThunkData->u1.Ordinal != 0) {

        ASSERT(IMAGE_SNAP_BY_ORDINAL(ImageThunkData->u1.Ordinal));

        OrdinalNumber = IMAGE_ORDINAL(ImageThunkData->u1.Ordinal) -
            ExportDirectory->Base;

        if ((OrdinalNumber >= ExportDirectory->NumberOfFunctions) ||
            (AddressOfFunctions[OrdinalNumber] == 0)) {
            LdrxDbgPrint(("LDRX: cannot import ordinal %d from image %p.\n",
                IMAGE_ORDINAL(ImageThunkData->u1.Ordinal), ExportBaseAddress));
            return STATUS_ORDINAL_NOT_FOUND;
        }

        ImageThunkData->u1.Function = (ULONG)ExportBaseAddress +
            AddressOfFunctions[OrdinalNumber];

        ImageThunkData++;
    }

    return STATUS_SUCCESS;
}

#ifdef DEVKIT

NTSTATUS
XepResolveNonKernelImageImports(
    VOID
    )
/*++

Routine Description:

    This routine resolves imports for modules other than the kernel.

Arguments:

    None.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PXBEIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
    UNICODE_STRING ImageName;
    PLIST_ENTRY NextListEntry;
    PLDR_DATA_TABLE_ENTRY DataTableEntry;

    ASSERT(XeImageHeader()->ImportDirectory != NULL);

    //
    // Loop over each import descriptor in the import directory.  Stop when we
    // find an import descriptor with a NULL thunk data.
    //

    ImportDescriptor = XeImageHeader()->ImportDirectory;

    while (ImportDescriptor->ImageThunkData != NULL) {

        RtlInitUnicodeString(&ImageName, ImportDescriptor->ImageName);

        //
        // Search the loaded module list for the image name.
        //

        NextListEntry = KdLoadedModuleList.Flink;

        while (NextListEntry != &KdLoadedModuleList) {

            DataTableEntry = CONTAINING_RECORD(NextListEntry, LDR_DATA_TABLE_ENTRY,
                InLoadOrderLinks);

            if (RtlEqualUnicodeString(&ImageName, &DataTableEntry->BaseDllName,
                TRUE)) {

                //
                // Resolve the imports from this module.
                //

                status = XepResolveImageImports(DataTableEntry->DllBase,
                    ImportDescriptor->ImageThunkData);

                if (!NT_SUCCESS(status)) {
                    return status;
                }

                break;
            }

            NextListEntry = DataTableEntry->InLoadOrderLinks.Flink;
        }

        if (NextListEntry == &KdLoadedModuleList) {
            LdrxDbgPrint(("LDRX: cannot import from module %wZ.\n", &ImageName));
            return STATUS_DLL_NOT_FOUND;
        }

        ImportDescriptor++;
    }

    return STATUS_SUCCESS;
}

VOID
XepNotifyDebuggerOfImageLoad(
    VOID
    )
/*++

Routine Description:

    This routine notifies the debugger that an Xbox executable image has been
    loaded and sends the section load notifications for the preload sections.

Arguments:

    ImageFileName - Specifies the name of the Xbox executable image to load.

Return Value:

    Status of operation.

--*/
{
    PVOID BaseAddress;
    KD_SYMBOLS_INFO SymbolInfo;
    STRING SymbolFileName;
    PXBEIMAGE_SECTION Section;
    PXBEIMAGE_SECTION EndingSection;

    //
    // The Xbox executable has NtBaseOfDll set to where the portable executable
    // (PE) headers would have been located given the base address of the first
    // section of this executable.  There may or may not actually be PE headers
    // at this address.  However, we don't allow the base address to be located
    // below the Xbox executable header.
    //

    BaseAddress = XeImageHeader()->NtBaseOfDll;

    if (BaseAddress < (PVOID)XeImageHeader()) {
        BaseAddress = XeImageHeader();
    }

    //
    // Initialize the loader data table for the Xbox executable and attach it to
    // the loaded module list.
    //

    RtlInitUnicodeString(&XepDataTableEntry.FullDllName,
        XeImageHeader()->DebugUnicodeFileName);

    XepDataTableEntry.DllBase = BaseAddress;
    XepDataTableEntry.SizeOfImage = XeImageHeader()->NtSizeOfImage;
    XepDataTableEntry.CheckSum = XeImageHeader()->NtCheckSum;
    XepDataTableEntry.Flags = LDRP_ENTRY_XE_IMAGE;
    XepDataTableEntry.LoadedImports = (PVOID)MAXULONG_PTR;
    XepDataTableEntry.BaseDllName = XepDataTableEntry.FullDllName;

    ExInterlockedInsertTailList(&KdLoadedModuleList,
        &XepDataTableEntry.InLoadOrderLinks);

    //
    // Notify the debugger that the module has been loaded.
    //

    SymbolInfo.BaseOfDll = BaseAddress;
    SymbolInfo.ProcessId = (ULONG_PTR)-1;
    SymbolInfo.SizeOfImage = XeImageHeader()->NtSizeOfImage;
    SymbolInfo.CheckSum = XeImageHeader()->NtCheckSum;

    RtlInitAnsiString(&SymbolFileName, XeImageHeader()->DebugFileName);

    DebugLoadImageSymbols(&SymbolFileName, &SymbolInfo);

    //
    // Notify the debugger that all of the preload sections have been loaded.
    //

    Section = XeImageHeader()->SectionHeaders;
    EndingSection = Section + XeImageHeader()->NumberOfSections;

    while (Section < EndingSection) {

        if (LdrxIsFlagSet(Section->SectionFlags, XBEIMAGE_SECTION_PRELOAD)) {
            DebugService(BREAKPOINT_LOAD_XESECTION, Section, NULL);
        }

        Section++;
    }

    //
    // Allow debugger notifications to be sent from the normal section load and
    // unload code paths.
    //

    XepSendSectionDebugNotifications = TRUE;
}

#endif

VOID
XepExtractCertificateKey(
    IN XBEIMAGE_CERTIFICATE_KEY InputKey,
    OUT PUCHAR OutputKey
    )
/*++

Routine Description:

    This routine extracts the raw data from the supplied input key and stores
    the result in the supplied output key.

Arguments:

    InputKey - Specifies the raw data to use as input for generating the output
        key.

    OutputKey - Specifies the location to receive the output key.

Return Value:

    None.

--*/
{
    UCHAR Digest[XC_DIGEST_LEN];

    //
    // Generate the output key from the input key and the certificate key stored
    // in the ROM.
    //

    XcHMAC(XboxCERTKey, XBOX_KEY_LENGTH, InputKey,
        XBEIMAGE_CERTIFICATE_KEY_LENGTH, NULL, 0, Digest);

    RtlCopyMemory(OutputKey, Digest, XBOX_KEY_LENGTH);
}

VOID
XepExtractCertificateKeys(
    VOID
    )
/*++

Routine Description:

    This routine extracts the raw keys stored in the Xbox executable and stores
    them in global data.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PXBEIMAGE_CERTIFICATE Certificate;
    ULONG Index;

    Certificate = XeImageHeader()->Certificate;

    //
    // Extract the LAN key.
    //

    XepExtractCertificateKey(Certificate->LANKey, XboxLANKey);

    //
    // Extract the signature key.
    //

    XepExtractCertificateKey(Certificate->SignatureKey, XboxSignatureKey);

    //
    // Extract the alternate signature keys.
    //

    for (Index = 0; Index < XBEIMAGE_ALTERNATE_TITLE_ID_COUNT; Index++) {
        XepExtractCertificateKey(Certificate->AlternateSignatureKeys[Index],
            XboxAlternateSignatureKeys[Index]);
    }
}

NTSTATUS
XeLoadImage(
    IN PCOSTR ImageFileName,
    IN BOOLEAN LoadingDashboard,
    IN ULONG SettingsError
    )
/*++

Routine Description:

    This routine loads and verifies an Xbox executable image.

Arguments:

    ImageFileName - Specifies the name of the Xbox executable image to load.

    LoadingDashboard - Specifies TRUE if we're attempting to load the dashboard.

    SettingsError - If non-zero, specifies what settings are invalid and should
        be fixed via the dashboard.  Used as a flag to indicate whether or not
        the executable image needs to be signed to run from the manufacturing
        region.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    HANDLE ImageFileHandle;
    PXBEIMAGE_HEADER ImageHeader;
    BOOLEAN ReleaseBaseAddress;
    SIZE_T ImageFileNameLength;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER ByteOffset;
    PVOID BaseAddress;
    SIZE_T RegionSize;
    ULONG HeaderBytesRemaining;
    PVOID EndOfHeaders;
//    PULONG ConfoundingKey;
    PXBEIMAGE_CERTIFICATE Certificate;
    ULONG TitleGameRegion;
//    ULONG ImageMediaTypes;
    PXBEIMAGE_SECTION Section;
    PXBEIMAGE_SECTION EndingSection;
#ifdef DEVKIT
    PXBEIMAGE_LIBRARY_VERSION LibraryVersion;
    PXBEIMAGE_LIBRARY_VERSION EndingLibraryVersion;
#endif
    BOOLEAN ChangeResetOnTrayOpen;
    ULONG ResetOnTrayOpen;

    ImageFileHandle = NULL;
    ImageHeader = NULL;
    ReleaseBaseAddress = FALSE;

    //
    // Duplicate the image file name.
    //

    ImageFileNameLength = ocslen(ImageFileName) * sizeof(OCHAR);

    ASSERT(ImageFileNameLength <= USHRT_MAX);

    XeImageFileName.Buffer = (POCHAR)ExAllocatePoolWithTag(ImageFileNameLength,
        'nFeX');

    if (XeImageFileName.Buffer == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanupAndExit;
    }

    RtlCopyMemory(XeImageFileName.Buffer, ImageFileName, ImageFileNameLength);
    XeImageFileName.Length = (USHORT)ImageFileNameLength;
    XeImageFileName.MaximumLength = (USHORT)ImageFileNameLength;

#ifdef DEVKIT
    //
    // On DEVKIT systems, we assume that the system is never so messed up that
    // system settings cannot be restored in the dash.  So if we've been called
    // to find something to run instead of the dash when system settings are
    // bad, we won't even bother to do any work.
    //
/*## -- bad assumption

    if (SettingsError != 0) {
        status = STATUS_OBJECT_PATH_NOT_FOUND;
        goto CleanupAndExit;
    }*/
#endif

    //
    // Open the image file.
    //

    status = XepOpenImageFile(&ImageFileHandle);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Allocate a buffer to read the first page of the image header.
    //

    ImageHeader = (PXBEIMAGE_HEADER)ExAllocatePoolWithTag(PAGE_SIZE, 'hIeX');

    if (ImageHeader == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanupAndExit;
    }

    //
    // Read the first page of the image header.
    //

    ByteOffset.QuadPart = 0;

    status = NtReadFile(ImageFileHandle, NULL, NULL, NULL, &IoStatusBlock,
        ImageHeader, PAGE_SIZE, &ByteOffset);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Verify that we read at least an entire image header.
    //

    if (IoStatusBlock.Information < XBEIMAGE_HEADER_BASE_SIZEOF) {
        LdrxDbgPrint(("LDRX: image too small.\n"));
        status = STATUS_INVALID_IMAGE_FORMAT;
        goto CleanupAndExit;
    }

    //
    // Validate that the signature is correct, that the size of the headers is
    // at least large enough to contain the image header, that the size of the
    // image is greater than the size of the headers, and that the image is
    // based at the expected address.
    //

    if ((ImageHeader->Signature != XBEIMAGE_SIGNATURE) ||
        (ImageHeader->SizeOfHeaders <= XBEIMAGE_HEADER_BASE_SIZEOF) ||
        (ImageHeader->SizeOfHeaders > ImageHeader->SizeOfImage) ||
        (ImageHeader->BaseAddress != (PVOID)XBEIMAGE_STANDARD_BASE_ADDRESS)) {
        LdrxDbgPrint(("LDRX: invalid image header.\n"));
        status = STATUS_INVALID_IMAGE_FORMAT;
        goto CleanupAndExit;
    }

    //
    // Reserve the address space used to map the XBE image.
    //

    BaseAddress = (PVOID)XBEIMAGE_STANDARD_BASE_ADDRESS;
    RegionSize = ImageHeader->SizeOfImage;

    status = NtAllocateVirtualMemory(&BaseAddress, 0, &RegionSize, MEM_RESERVE,
        PAGE_READWRITE);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    ReleaseBaseAddress = TRUE;

    //
    // Commit the address space used to map the XBE headers.
    //

    BaseAddress = (PVOID)XBEIMAGE_STANDARD_BASE_ADDRESS;
    RegionSize = ImageHeader->SizeOfHeaders;

    status = NtAllocateVirtualMemory(&BaseAddress, 0, &RegionSize, MEM_COMMIT,
        PAGE_READWRITE);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Copy the first page of the image header to its actual base address and
    // free the temporary buffer.
    //

    RtlCopyMemory((PVOID)XBEIMAGE_STANDARD_BASE_ADDRESS, ImageHeader, PAGE_SIZE);

    ExFreePool(ImageHeader);
    ImageHeader = NULL;

    //
    // Read in the rest of the image headers if the headers are larger than a
    // single sector.
    //

    if (XeImageHeader()->SizeOfHeaders > PAGE_SIZE) {

        HeaderBytesRemaining = XeImageHeader()->SizeOfHeaders - PAGE_SIZE;

        status = XepReadImageFile(ImageFileHandle,
            (PVOID)(XBEIMAGE_STANDARD_BASE_ADDRESS + PAGE_SIZE),
            HeaderBytesRemaining, PAGE_SIZE);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }
    }

    //
    // Validate that all of the important header data is present and part of the
    // signed headers.
    //

    EndOfHeaders = (PUCHAR)XeImageHeader() + XeImageHeader()->SizeOfHeaders;

    if ((PVOID)XeImageHeader()->Certificate < (PVOID)XeImageHeader() ||
        (PVOID)((ULONG_PTR)XeImageHeader()->Certificate + XBEIMAGE_CERTIFICATE_BASE_SIZEOF) > EndOfHeaders ||
        (PVOID)XeImageHeader()->SectionHeaders < (PVOID)XeImageHeader() ||
        (PVOID)(XeImageHeader()->SectionHeaders + XeImageHeader()->NumberOfSections) >
        EndOfHeaders) {
        status = STATUS_INVALID_IMAGE_FORMAT;
        goto CleanupAndExit;
    }

    //
    // Verify that the encrypted digest stored in the image header is valid.
    //
/*## -- i *don't* think so

    status = XepVerifyImageHeaderEncryptedDigest();

    if (!NT_SUCCESS(status)) {
        LdrxDbgPrint(("LDRX: failed to verify header digest.\n"));
        goto CleanupAndExit;
    }*/

    //
    // Cache the pointer to the certificate and the title game region in locals.
    //

    Certificate = XeImageHeader()->Certificate;
    TitleGameRegion = Certificate->GameRegion;

#ifndef DEVKIT
#ifndef ARCADE
    //
    // Verify that we have a valid locked hard drive unless the title is
    // willing to run without one, or we're in the manufacturing region.
    //

//######## -- Well I'd like to not check this at all
/*
    if (!IdexDiskSecurityUnlocked &&
        LdrxIsFlagClear(XboxGameRegion, XC_GAME_REGION_MANUFACTURING) &&
        LdrxIsFlagClear(Certificate->AllowedMediaTypes,
        XBEIMAGE_MEDIA_TYPE_NONSECURE_HARD_DISK)) {
        IdexDiskFatalError(FATAL_ERROR_HDD_NOT_LOCKED);
    }
*/
#endif

    //
    // Verify that the image isn't attempting to bind to any imports that aren't
    // available in a non-DEVKIT version of the kernel.
    //

//## -- not a security check, leave it!!!
    if (XeImageHeader()->ImportDirectory != NULL) {
        LdrxDbgPrint(("LDRX: cannot import from modules other than kernel.\n"));
        status = STATUS_INVALID_IMAGE_FORMAT;
        goto CleanupAndExit;
    }

    //
    // If we have invalid settings, then make sure this image is signed to run
    // in the manufacturing region before proceeding.
    //
//## -- this is a security feature but we can accept it.  just make evox
//         have the 0x80000000 region bit set.

    if ((SettingsError != 0) &&
        LdrxIsFlagClear(TitleGameRegion, XBEIMAGE_GAME_REGION_MANUFACTURING)) {
        status = STATUS_OBJECT_PATH_NOT_FOUND;
        goto CleanupAndExit;
    }
#endif

    //
    // Unconfound portions of the header data.
    //


//######## -- need to put the retail bytes in there, for entrypoint and thunk addr (can we make this run both debug AND retail ?)
//## -- yes we can!! <3
//         The kernel thunk xor differs in the high bit between debug and
//         retail.  This is very important.  Clearly, the thunk address is
//         always less than 80000000.  So when xored with the debug key,
//         the high bit is set.  When xored with the retail key, it's not!

    //
    // Confound THIS!
    //
    if (((LONG) (ULONG_PTR) XeImageHeader()->XboxKernelThunkData) < 0)
    {
        // Debug
        *((PULONG) &XeImageHeader()->AddressOfEntryPoint) ^= 0x94859D4B;
        *((PULONG) &XeImageHeader()->XboxKernelThunkData) ^= 0xEFB1F152;
    }
    else
    {
        // Retail
        *((PULONG) &XeImageHeader()->AddressOfEntryPoint) ^= 0xA8FC57AB;
        *((PULONG) &XeImageHeader()->XboxKernelThunkData) ^= 0x5B6D40B6;
    }

    //
    // Check if the game region is supported by the console.  If the console is
    // configured to run manufacturing content, then only allow manufacturing
    // content to run.
    //

/*## -- don't need region checks ^-^

    if (LdrxIsFlagSet(XboxGameRegion, XC_GAME_REGION_MANUFACTURING)) {
        TitleGameRegion &= XBEIMAGE_GAME_REGION_MANUFACTURING;
    }

    if ((TitleGameRegion & XboxGameRegion) == 0) {
        LdrxDbgPrint(("LDRX: game region mismatch; cannot run image.\n"));
        status = STATUS_IMAGE_GAME_REGION_VIOLATION;
        goto CleanupAndExit;
    } */

    //
    // Check if the image is allowed to run from this type of media.
    //
/*## -- bye bye media checks

    status = XepComputeImageMediaTypes(ImageFileHandle, &ImageMediaTypes);

    if (!NT_SUCCESS(status)) {
        LdrxDbgPrint(("LDRX: failed to compute media types.\n"));
        goto CleanupAndExit;
    }

    if ((Certificate->AllowedMediaTypes & ImageMediaTypes) == 0) {
        LdrxDbgPrint(("LDRX: media types mismatch; cannot run image.\n"));
        status = STATUS_IMAGE_MEDIA_TYPE_VIOLATION;
        goto CleanupAndExit;
    }*/

    // ##:
    // Set the lower media type bits so that the XDK security check doesn't
    // happen.
    //

    Certificate->AllowedMediaTypes |= XBEIMAGE_MEDIA_TYPE_MEDIA_MASK;

    // ##:
    // Also, clear the new security flag.  Note that this field may not exist
    // in old games, so we look before we leap.
    //
    if ((Certificate->SizeOfCertificate >= XBEIMAGE_CERTIFICATE_SECURITY_SIZEOF) &&
        ((PVOID)((ULONG_PTR)Certificate + XBEIMAGE_CERTIFICATE_SECURITY_SIZEOF)
            <= EndOfHeaders))
    {
        Certificate->RuntimeSecurityFlags &= ~XBEIMAGE_SECURITY_FLAG_DVD_X2;
    }

    //
    // For images loaded from the CD-ROM device, verify that this executable's
    // title identifier matches the title identifier of previously loaded
    // media.
    //
    // If this is the first title that has run from this media, then remember
    // it's title identifier.
    //

/*## -- i think that this was some thing microsoft was testing out.  it's
//         a security check that is not in any kernels, even recent ones.
    if ((ImageMediaTypes & (XBEIMAGE_MEDIA_TYPE_DVD_X2 |
        XBEIMAGE_MEDIA_TYPE_DVD_CD)) != 0) {

        if ((XeCdRomMediaTitleID != 0) &&
            (XeCdRomMediaTitleID != Certificate->TitleID)) {
            LdrxDbgPrint(("LDRX: title ID mismatch; cannot run image.\n"));
            status = STATUS_IMAGE_MEDIA_TYPE_VIOLATION;
            goto CleanupAndExit;
        }

        XeCdRomMediaTitleID = Certificate->TitleID;
    }*/


    //
    // Pass the Microsoft logo embedded in the Xbox executable to the animation
    // code so that it can be displayed as long as possible.
    //

//## -- if you want to change the logo, here's your chance! ^-^
    if (!KeHasQuickBooted) {
        AniSetLogo(XeImageHeader()->MicrosoftLogo, XeImageHeader()->SizeOfMicrosoftLogo);
    }

    //
    // Bring in all of the preload sections.
    //

    Section = XeImageHeader()->SectionHeaders;
    EndingSection = Section + XeImageHeader()->NumberOfSections;

    while (Section < EndingSection) {

        if (LdrxIsFlagSet(Section->SectionFlags, XBEIMAGE_SECTION_PRELOAD)) {

            status = XepLoadSection(ImageFileHandle, Section, TRUE);

            if (!NT_SUCCESS(status)) {
                goto CleanupAndExit;
            }
        }

        Section++;
    }

    //
    // Now that we've loaded a candidate Xbox executable, disable the option of
    // hitting the tray eject button without causing a reboot to occur.  If a
    // tray eject has occurred before this routine is called and we're not
    // loading the dashboard, then pretend like the file wasn't found and fail
    // this image load.
    //
    // Note that if we're loading the dashboard and we're not already in
    // non-secure mode, then this call will switch us to non-secure mode.  This
    // is done to close a window where tray ejects are causing a reboot, but
    // the HAL doesn't yet think that we're going to be running trusted code.
    //

//## -- leave alone
    if (HalEnableTrayEjectRequiresReboot(LoadingDashboard)) {

        ASSERT(!KeHasQuickBooted);
        ASSERT(LdrxIsFlagSet(XboxBootFlags, XBOX_BOOTFLAG_NONSECUREMODE));

        if (!LoadingDashboard) {
            status = STATUS_OBJECT_PATH_NOT_FOUND;
            goto CleanupAndExit;
        }
    }

    //
    // Resolve the image imports from the kernel.
    //

    if (XeImageHeader()->XboxKernelThunkData != NULL) {

        status = XepResolveImageImports(PsNtosImageBase,
            XeImageHeader()->XboxKernelThunkData);

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }
    }

#ifdef DEVKIT
    //
    // Resolve the image imports from outside the kernel.
    //

    if (XeImageHeader()->ImportDirectory != NULL) {

        status = XepResolveNonKernelImageImports();

        if (!NT_SUCCESS(status)) {
            goto CleanupAndExit;
        }
    }

    //
    // Notify the debugger that the image has been loaded.
    //
    // Note that this has to be done before marking the section pages as
    // read-only.  The debug monitor may change the attributes of the sections
    // to not be read-only in order to support components like VTune.
    //

    XepNotifyDebuggerOfImageLoad();
#endif

    //
    // Change the protection of all of the preload non-writeable sections to
    // PAGE_EXECUTE_READ.  This is done after resolving the image imports
    // because the image imports are typically merged into the read-only .text
    // section.
    //

    Section = XeImageHeader()->SectionHeaders;
    EndingSection = Section + XeImageHeader()->NumberOfSections;

    while (Section < EndingSection) {

        if (LdrxIsFlagSet(Section->SectionFlags, XBEIMAGE_SECTION_PRELOAD) &&
            LdrxIsFlagClear(Section->SectionFlags, XBEIMAGE_SECTION_WRITEABLE)) {
            XepMarkSectionPagesReadOnly(Section);
        }

        Section++;
    }

#ifdef DEVKIT
    //
    // Print out the path to the Xbox executable that has been loaded.
    //

    DbgPrint("Xbox image loaded: %Z\n", &XeImageFileName);

    //
    // Print out the library versions that this Xbox executable linked against.
    //

    LibraryVersion = XeImageHeader()->LibraryVersions;
    EndingLibraryVersion = LibraryVersion + XeImageHeader()->NumberOfLibraryVersions;

    while (LibraryVersion < EndingLibraryVersion) {
        DbgPrint("This XBE was linked with %8.8s.LIB version %d.%02d.%d.%02d%s\n",
            LibraryVersion->LibraryName, LibraryVersion->MajorVersion,
            LibraryVersion->MinorVersion, LibraryVersion->BuildVersion,
            LibraryVersion->QFEVersion, LibraryVersion->DebugBuild ? " (Debug)" : "");
        LibraryVersion++;
    }

#ifndef ARCADE
    //
    // Check if the title wants extra memory in the development kit to be
    // automatically used for memory manager allocations or not.
    //

    if (LdrxIsFlagClear(XeImageHeader()->InitFlags, XINIT_LIMIT_DEVKIT_MEMORY)) {
        MmReleaseDeveloperKitMemory();
    }
#endif
#endif

    //
    // Extract the raw certificate keys.
    //

    XepExtractCertificateKeys();

    //
    // If we're not loading a title that's enabled to run from the manufacturing
    // content, then zero out the EEPROM key.  The console may not be configured
    // to allow manufacturing content, but we still allow some titles to access
    // the EEPROM key as long as they're marked as being able to run from the
    // manufacturing region.
    //

/*## -- never delete EEPROM key
    if (LdrxIsFlagClear(TitleGameRegion, XBEIMAGE_GAME_REGION_MANUFACTURING)) {
        RtlZeroMemory(XboxEEPROMKey, XBOX_KEY_LENGTH);
    }*/

    //
    // If we're loading the dashboard, booting a kernel from the CD-ROM (such as
    // recovery), or if we're in the manufacturing region, then switch the SMC
    // to non-secure mode, where tray open events do not force a reboot.  In all
    // other cases, switch the SMC to secure mode.
    //
    // Note that the SMC only allows us to set non-secure mode once and this
    // must be the first override request to the SMC after a power cycle.  Once
    // the SMC is configured to run as secure mode, it cannot be switched back,
    // so this command may have no effect on the actual state of the SMC.
    //

    ResetOnTrayOpen = SMC_RESET_ON_TRAY_OPEN_SECURE_MODE;
    ChangeResetOnTrayOpen = FALSE;

//## -- never enable reset-on-eject
/*    if (LoadingDashboard ||
        LdrxIsFlagSet(Certificate->AllowedMediaTypes, XBEIMAGE_MEDIA_TYPE_NONSECURE_MODE) ||
        LdrxIsFlagSet(XboxBootFlags, XBOX_BOOTFLAG_CDBOOT) ||
        LdrxIsFlagSet(XboxGameRegion, XC_GAME_REGION_MANUFACTURING)) {*/

        if (!KeHasQuickBooted &&
            LdrxIsFlagClear(XboxBootFlags, XBOX_BOOTFLAG_NONSECUREMODE)) {
            XboxBootFlags |= XBOX_BOOTFLAG_NONSECUREMODE;
            ResetOnTrayOpen = SMC_RESET_ON_TRAY_OPEN_NONSECURE_MODE;
            ChangeResetOnTrayOpen = TRUE;
        }

/*    } else {

        if (!KeHasQuickBooted ||
            LdrxIsFlagSet(XboxBootFlags, XBOX_BOOTFLAG_NONSECUREMODE)) {
            XboxBootFlags &= ~XBOX_BOOTFLAG_NONSECUREMODE;
            ChangeResetOnTrayOpen = TRUE;
        }
    }*/

    if (ChangeResetOnTrayOpen) {

        do {
            status = HalWriteSMBusByte(SMC_SLAVE_ADDRESS,
                SMC_COMMAND_OVERRIDE_RESET_ON_TRAY_OPEN, ResetOnTrayOpen);
        } while (!NT_SUCCESS(status));
    }

#ifdef ARCADE
    //
    // Force all Xbox executables to run with the "no setup hard disk" flag for
    // the arcade build.  This turns off the XAPI startup code that attempts to
    // create title and user directories as well as mounting a utility drive.
    //

    XeImageHeader()->InitFlags |= XINIT_NO_SETUP_HARD_DISK;
#endif

    //
    // The image is successfully loaded.
    //

    status = STATUS_SUCCESS;

CleanupAndExit:
    //
    // Free the temporary buffer used to hold the first sector of the image
    // header.
    //

    if (ImageHeader != NULL) {
        ExFreePool(ImageHeader);
    }

    //
    // Close the image file handle.
    //

    if (ImageFileHandle != NULL) {
        NtClose(ImageFileHandle);
    }

    if (!NT_SUCCESS(status)) {

        //
        // Release the virtual address range used to map the XBE image.
        //

        if (ReleaseBaseAddress) {

            BaseAddress = (PVOID)XBEIMAGE_STANDARD_BASE_ADDRESS;
            RegionSize = 0;

            NtFreeVirtualMemory(&BaseAddress, &RegionSize, MEM_RELEASE);
        }

        //
        // Delete the image file name string.  Note that if
        // XeImageFileName.Buffer is NULL, then this call does nothing.
        //

        RtlFreeObjectString(&XeImageFileName);
    }

    return status;
}

//## -- we like this function in retail kernels!
//#ifdef DEVKIT

NTSTATUS
XeLoadAlternateDashboardImage(
    VOID
    )
/*++

Routine Description:

    This routine attempts to load the dashboard as specified in the dashboard
    redirection file.

Arguments:

    None.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE RedirectionFileHandle;
    OCHAR RedirectionBuffer[MAX_LAUNCH_PATH + 1];
    POSTR Delimiter;

    //
    // Attempt to open the dashboard redirection file.
    //

    InitializeObjectAttributes(&ObjectAttributes, &XepDashboardRedirectionPath,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenFile(&RedirectionFileHandle, GENERIC_READ, &ObjectAttributes,
        &IoStatusBlock, FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT |
        FILE_NON_DIRECTORY_FILE);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Read in the dashboard redirection file and close the handle to the file.
    //

    status = NtReadFile(RedirectionFileHandle, NULL, NULL, NULL, &IoStatusBlock,
        RedirectionBuffer, MAX_LAUNCH_PATH * sizeof(OCHAR), NULL);

    NtClose(RedirectionFileHandle);

    if (!NT_SUCCESS(status)) {
        return status;
    } else if (IoStatusBlock.Information != (MAX_LAUNCH_PATH * sizeof(OCHAR))) {
        return STATUS_FILE_CORRUPT_ERROR;
    }

    //
    // Search for the title path delimiter and replace it with a backslash.  The
    // first portion of the string used to specify the object manager path for
    // the D: symbolic link, but the dashboard and XDK launcher don't require
    // that drive letter to be set up, so we no longer do that.
    //

    RedirectionBuffer[MAX_LAUNCH_PATH] = OTEXT('\0');

    Delimiter = ocschr(RedirectionBuffer, TITLE_PATH_DELIMITER);

    if (Delimiter != NULL) {
        *Delimiter = OTEXT('\\');
    }

    //
    // Attempt to load the alternate dashboard image.
    //

    status = XeLoadImage(RedirectionBuffer, TRUE, 0);

    return status;
}

//## -- #endif

VOID
XeLoadDashboardImage(
    VOID
    )
/*++

Routine Description:

    This routine attempts to load the dashboard from the shell partition.  This
    routine will not return if the dashboard cannot be loaded.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    ULONG FatalErrorCode;
    PLD_LAUNCH_DASHBOARD LaunchDashboard;

#ifdef DEVKIT
    //
    // Tell the debug monitor that we're going to be running the dashboard.
    //

    if (DmGetCurrentDmi() != NULL) {
        DmGetCurrentDmi()->Flags |= DMIFLAG_RUNSHELL;
    }
//## -- #endif moved here
#endif

    //
    // Attempt to load the dashboard as specified in the dashboard redirection
    // file and return if successful.
    //

    status = XeLoadAlternateDashboardImage();

    if (NT_SUCCESS(status)) {
        return;
    }

    //
    // Attempt to load the standard dashboard image and return if successful.
    //

	// ##: try cpxdash.xbe, then evoxdash.xbe, then finally xboxdash.xbe
    if (!NT_SUCCESS(status = XeLoadImage(XepDashboardImagePath1, TRUE, 0)))
    if (!NT_SUCCESS(status = XeLoadImage(XepDashboardImagePath2, TRUE, 0)))
    if (!NT_SUCCESS(status = XeLoadImage(XepDashboardImagePath3, TRUE, 0))) {

        LdrxDbgPrint(("INIT: Failed to launch an XBE (status=%08x).\n", status));
        LdrxDbgBreakPoint();

        //
        // Display the universal error message.
        //

        if (!KeHasQuickBooted) {

            HalWriteSMCLEDStates(SMC_LED_STATES_GREEN_STATE0 | SMC_LED_STATES_RED_STATE1 |
                SMC_LED_STATES_RED_STATE2 | SMC_LED_STATES_RED_STATE3);

            FatalErrorCode = FATAL_ERROR_XBE_DASH_GENERIC;

            //
            // If the launch data is available and there is a dashboard error,
            // change the fatal error code to indicate the dashboard error.
            // Otherwise, indicate if DVD-X2 authentication has passed.
            //

            if (LaunchDataPage != NULL &&
                LaunchDataPage->Header.dwLaunchDataType == LDT_LAUNCH_DASHBOARD) {

                LaunchDashboard = (PLD_LAUNCH_DASHBOARD)&(LaunchDataPage->LaunchData[0]);

                FatalErrorCode += LaunchDashboard->dwReason;

            } else {

#ifndef ARCADE
                if (IdexCdRomDVDX2Authenticated) {
                    FatalErrorCode = FATAL_ERROR_XBE_DASH_X2_PASS;
                }
#endif
            }

            ExDisplayFatalError(FatalErrorCode);

        } else {
            HalReturnToFirmware(HalFatalErrorRebootRoutine);
        }
    }
}

VOID
XeLoadDashboardImageWithReason(
    IN ULONG Reason,
    IN ULONG Parameter1
    )
/*++

Routine Description:

    This routine attempts to load the dashboard from the shell partition.  The
    dashboard is given a launch data page with the supplied reason and parameter
    codes.  This routine will not return if the dashboard cannot be loaded.

Arguments:

    Reason - Specifies the reason that the dashboard is being loaded.

    Parameter1 - Specifies more information about the reason that the dashboard
        is being loaded.

Return Value:

    None.

--*/
{
    PLD_LAUNCH_DASHBOARD LaunchDashboard;

    //
    // If a launch data page is not already allocated, then allocate a new page.
    //

    if (LaunchDataPage == NULL) {
        LaunchDataPage = MmAllocateContiguousMemory(PAGE_SIZE);
    }

    //
    // If a launch data page is available, then zero it out and fill it in with
    // supplied error codes.  If there's not enough memory to obtain a launch
    // data page, then we'll still try to launch the dashboard, but we'll likely
    // fail and end up displaying the universal error message.
    //

    if (LaunchDataPage != NULL) {

        MmPersistContiguousMemory(LaunchDataPage, PAGE_SIZE, TRUE);

        RtlZeroMemory(LaunchDataPage, PAGE_SIZE);

        LaunchDataPage->Header.dwLaunchDataType = LDT_LAUNCH_DASHBOARD;

        LaunchDashboard = (PLD_LAUNCH_DASHBOARD)&(LaunchDataPage->LaunchData[0]);
        LaunchDashboard->dwReason = Reason;
        LaunchDashboard->dwParameter1 = Parameter1;
    }

    //
    // Attempt to load the dashboard.  This will not return if the dashboard
    // cannot be loaded.
    //

    XeLoadDashboardImage();
}

VOID
XeLoadTitleImage(
    IN ULONG SettingsError
    )
/*++

Routine Description:

    This routine attempts to load a title as by either using the launch data
    page or the default Xbox executable path.  If the title load fails, then the
    dashboard is loaded instead.  This routine will not return if no image can
    be loaded.

Arguments:

    SettingsError - If non-zero, specifies what settings are invalid and should
        be fixed via the dashboard.  However, instead of immediately loading the
        dashboard, a check is made to see if a title can be loaded from the
        default Xbox executable path.  If a title can be loaded and the title
        is enabled to run from the manufacturing region, then that title is
        allowed to run.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    OCHAR CapturedLaunchPath[MAX_LAUNCH_PATH + 1];
    PLAUNCH_DATA_PAGE SavedLaunchDataPage;
    POSTR Delimiter;
    OBJECT_STRING LinkTarget;
    BOOLEAN CreatedSymbolicLink;
    ULONG TrayState;
    ULONG TrayStateChangeCount1;
    ULONG TrayStateChangeCount2;
    ULONG DashboardError;

    //
    // Check to see if there is launch data has already been read by the kernel
    // during a previous reboot, and if so, free it now and ignore the data.
    //

    if ((SettingsError == 0) && (LaunchDataPage != NULL) &&
        LdrxIsFlagSet(LaunchDataPage->Header.dwFlags, LDF_HAS_BEEN_READ)) {
        SavedLaunchDataPage = LaunchDataPage;
        LaunchDataPage = NULL;
        MmFreeContiguousMemory(SavedLaunchDataPage);
    }

    //
    // Check if there's a settings error.  If so, then force a load from the
    // default Xbox executable path and ignore the launch data page (this should
    // only occur from a cold boot, so the launch data page is probably NULL).
    //
    // Check if there's a launch data page available.  If so, this page will
    // specify what Xbox executable image should be loaded.
    //

    if ((SettingsError == 0) && (LaunchDataPage != NULL)) {

        //
        // Immediately mark the launch data as having been read by the kernel.
        //

        LaunchDataPage->Header.dwFlags |= LDF_HAS_BEEN_READ;

        //
        // Copy out the launch path and ensure that the buffer is
        // null-terminated.
        //

        RtlCopyMemory(CapturedLaunchPath, LaunchDataPage->Header.szLaunchPath,
            MAX_LAUNCH_PATH * sizeof(OCHAR));
        CapturedLaunchPath[MAX_LAUNCH_PATH] = OTEXT('\0');

        //
        // Free the launch data page now if it only specified a launch path.
        //

        if (LaunchDataPage->Header.dwLaunchDataType == LDT_NONE) {
            SavedLaunchDataPage = LaunchDataPage;
            LaunchDataPage = NULL;
            MmFreeContiguousMemory(SavedLaunchDataPage);
        }

        //
        // If the launch path is empty, then this is an alias for loading the
        // dashboard.
        //

        if (CapturedLaunchPath[0] == OTEXT('\0')) {
            XeLoadDashboardImage();
            return;
        }

        //
        // Check for a path delimiter in the launch path.  If present, then the
        // first part of the string is the object manager path to use for the D:
        // symbolic link.  The second half of the string is a path relative to
        // the first half of the string.
        //
        // If no delimiter is present, then this is an absolute object manager
        // path and no D: symbolic link is created.
        //

        CreatedSymbolicLink = FALSE;
        Delimiter = ocschr(CapturedLaunchPath, TITLE_PATH_DELIMITER);

        if (Delimiter != NULL) {

            *Delimiter = OTEXT('\\');

            LinkTarget.Buffer = CapturedLaunchPath;
            LinkTarget.Length = (USHORT)(Delimiter - CapturedLaunchPath);
            LinkTarget.MaximumLength = LinkTarget.Length;

            status = IoCreateSymbolicLink(&XepCdRomDosDevice, &LinkTarget);

            if (NT_SUCCESS(status)) {
                CreatedSymbolicLink = TRUE;
            }
        }

        //
        // Attempt to load the specified image and return if successful.
        //

        status = XeLoadImage(CapturedLaunchPath, FALSE, 0);

        if (NT_SUCCESS(status)) {
            return;
        }

        //
        // Delete the symbolic link created above.
        //

        if (CreatedSymbolicLink) {
            IoDeleteSymbolicLink(&XepCdRomDosDevice);
        }

    } else {

        //
        // Read the initial tray state change count so that we can check below
        // if anything has changed.
        //

        HalReadSMCTrayState(&TrayState, &TrayStateChangeCount1);

        //
        // Attempt to load the default image and return if successful.  Note
        // that this can return an error if there is a settings error and the
        // default image isn't signed to run from the manufacturing region.
        //

        status = XeLoadImage(XepDefaultImagePath, FALSE, SettingsError);

        if (NT_SUCCESS(status)) {
            return;
        }

        //
        // If there's a settings error and the default title couldn't be found
        // or wasn't signed to run from the manufacturing region, then launch
        // the dashboard to handle the settings error.
        //

        if (SettingsError != 0) {
            XeLoadDashboardImageWithReason(XLD_LAUNCH_DASHBOARD_SETTINGS,
                SettingsError);
            return;
        }

        //
        // We failed to load the default image; check if it's due to the tray
        // state changing while we were attempting to load that image.  If so,
        // then normalize the error so that we don't disable an invalid XBE
        // message just because the user ejected the tray while we were reading
        // from the file.  Also, if the tray appears to be empty, then don't
        // send device errors to the dashboard.
        //

        HalReadSMCTrayState(&TrayState, &TrayStateChangeCount2);

        if (TrayState != SMC_TRAY_STATE_MEDIA_DETECT) {
            status = STATUS_NO_MEDIA_IN_DEVICE;
        } else if (TrayStateChangeCount1 != TrayStateChangeCount2) {
            status = STATUS_DEVICE_NOT_READY;
        }

        //
        // If this is a non-critical error, such as the drive being empty or
        // containing media without a title, then simply launch the dashboard
        // with no error code.
        //

        switch (status) {

            case STATUS_OBJECT_NAME_NOT_FOUND:
            case STATUS_OBJECT_PATH_NOT_FOUND:
            case STATUS_NO_MEDIA_IN_DEVICE:
            case STATUS_INVALID_DEVICE_REQUEST:
            case STATUS_UNRECOGNIZED_VOLUME:
            case STATUS_DEVICE_NOT_READY:
            case STATUS_NONEXISTENT_SECTOR:
                XeLoadDashboardImage();
                return;
        }
    }

    //
    // We failed to load a title.  Convert the error code to a dashboard error
    // code and load the dashboard to handle the error.
    //

    ASSERT(!NT_SUCCESS(status));

    LdrxDbgPrint(("LDRX: failed to load title image (status=%08x).\n", status));

    switch (status) {

        case STATUS_IMAGE_GAME_REGION_VIOLATION:
            DashboardError = XLD_ERROR_XBE_REGION;
            break;

        case STATUS_IMAGE_MEDIA_TYPE_VIOLATION:
            DashboardError = XLD_ERROR_XBE_MEDIA_TYPE;
            break;

        default:
            DashboardError = XLD_ERROR_INVALID_XBE;
            break;
    }

    XeLoadDashboardImageWithReason(XLD_LAUNCH_DASHBOARD_ERROR, DashboardError);
}

VOID
XeLoadImageAfterTrayEjectBoot(
    VOID
    )
/*++

Routine Description:

    This routine is called when the console was either powered on by hitting the
    tray eject button or if the tray eject button is hit shortly after hitting
    the power on button.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    ULONG TrayState;
    LARGE_INTEGER Interval;

    //
    // Block until the boot animation has completed and is ready to display the
    // Microsoft logo.
    //
    // Note that the time that it typically takes for the tray to eject, for
    // media to be put in the drive, the tray closed, and for the media to be
    // detected by the drive is approximately the length required to display the
    // boot animation, so we don't bother blocking on a media detected event.
    //

    AniBlockOnAnimation();

    for (;;) {

        //
        // Read the tray state from the SMC.
        //
        // Note that we can't use HalReadSMCTrayState here because that routine
        // can't tell us if the tray is in process of being closed.
        //

        status = HalReadSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_TRAY_STATE,
            &TrayState);

        if (!NT_SUCCESS(status)) {
            TrayState = SMC_TRAY_STATE_OPEN;
            break;
        }

        //
        // Check if the tray is in the process of closing or detecting media.
        // If we're in either of these states, then keep looping until we're out
        // of these states.
        //

        TrayState &= SMC_TRAY_STATE_STATE_MASK;

        if ((TrayState != SMC_TRAY_STATE_CLOSING) &&
            (TrayState != SMC_TRAY_STATE_CLOSED)) {
            break;
        }

        //
        // Delay for 250 milliseconds.
        //

        Interval.QuadPart = -250 * 10000;
        KeDelayExecutionThread(KernelMode, FALSE, &Interval);
    }

    //
    // If media was detected, then attempt to load a title image, otherwise load
    // the dashboard image.  Note that we might need to dismount the CD-ROM
    // device, especially for DEVKIT systems, if a file system was mounted
    // before the XBOX_BOOTFLAG_TRAYEJECT flag was checked by the calling
    // routine.
    //

    if (TrayState == SMC_TRAY_STATE_MEDIA_DETECT) {
        IoDismountVolume(IdexCdRomDeviceObject);
        XeLoadTitleImage(0);
    } else {
        XeLoadDashboardImage();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\mmx\debugsup.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    debugsup.c

Abstract:

    This module implements routines which provide support for the debugger.

--*/

#include "mi.h"

PVOID
MmDbgWriteCheck(
    IN PVOID VirtualAddress,
    IN PHARDWARE_PTE Opaque
    )
/*++

Routine Description:

    i386/486 implementation specific:

    This routine checks the specified virtual address and if it is
    valid and writable, it returns that virtual address, otherwise
    it returns NULL.

Arguments:

    VirtualAddress - Supplies the virtual address to check.

    Opaque - Supplies an opaque pointer.

Return Value:

    Returns NULL if the address is not valid or writable, otherwise
    returns the virtual address.

Environment:

    Kernel mode IRQL at DISPATCH_LEVEL or greater.

--*/
{
    PMMPTE InputPte;
    PMMPTE PointerPte;
    MMPTE TempPte;

    InputPte = (PMMPTE)Opaque;
    InputPte->Long = 0;

    if (!MmIsAddressValid(VirtualAddress)) {
        return NULL;
    }

    PointerPte = MiGetPdeAddress(VirtualAddress);
    if (PointerPte->Hard.LargePage == 0) {
        PointerPte = MiGetPteAddress(VirtualAddress);
    }

    if (PointerPte->Hard.Write == 0) {

        TempPte = *PointerPte;

        *InputPte = TempPte;

        TempPte.Hard.Write = 1;

        MI_WRITE_AND_FLUSH_PTE(PointerPte, TempPte);
    }

    return VirtualAddress;
}

VOID
MmDbgReleaseAddress(
    IN PVOID VirtualAddress,
    IN PHARDWARE_PTE Opaque
    )
/*++

Routine Description:

    i386/486 implementation specific:

    This routine resets the specified virtual address access permissions
    to its original state.

Arguments:

    VirtualAddress - Supplies the virtual address to check.

    Opaque - Supplies an opaque pointer.

Return Value:

    None.

Environment:

    Kernel mode IRQL at DISPATCH_LEVEL or greater.

--*/
{
    MMPTE TempPte;
    PMMPTE PointerPte;
    PMMPTE InputPte;

    InputPte = (PMMPTE)Opaque;

    ASSERT(MmIsAddressValid(VirtualAddress));

    if (InputPte->Long != 0) {

        PointerPte = MiGetPdeAddress(VirtualAddress);
        if (PointerPte->Hard.LargePage == 0) {
            PointerPte = MiGetPteAddress(VirtualAddress);
        }

        TempPte = *InputPte;

        MI_WRITE_AND_FLUSH_PTE(PointerPte, TempPte);
    }
}

PVOID64
MmDbgTranslatePhysicalAddress64(
    IN PHYSICAL_ADDRESS PhysicalAddress
    )
/*++

Routine Description:

    i386/486 implementation specific:

    This routine maps the specified physical address and returns
    the virtual address which maps the physical address.

    The next call to MmDbgTranslatePhysicalAddress removes the
    previous physical address translation, hence only a single
    physical address can be examined at a time (can't cross page
    boundaries).

Arguments:

    PhysicalAddress - Supplies the physical address to map and translate.

Return Value:

    The virtual address which corresponds to the physical address.

Environment:

    Kernel mode IRQL at DISPATCH_LEVEL or greater.

--*/
{
    PMMPTE DebugPde;
    MMPTE TempPte;

    DebugPde = MiGetPdeAddress(MM_DEBUG_VA);

    TempPte.Long = MiGetValidKernelPteBits();
    MI_DISABLE_CACHING(TempPte);
    TempPte.Long |= (PhysicalAddress.LowPart & (~((1 << PAGE_SHIFT_LARGE) - 1)));
    TempPte.Hard.LargePage = 1;

    MI_WRITE_PTE(DebugPde, TempPte);
    MI_FLUSH_VA((PVOID)MM_DEBUG_VA);

    return (PVOID64)((ULONG)MM_DEBUG_VA + BYTE_OFFSET_LARGE(PhysicalAddress.LowPart));
}

#ifdef DEVKIT

PVOID
MmDbgAllocateMemory(
    IN SIZE_T NumberOfBytes,
    IN ULONG Protect
    )
/*++

Routine Description:

    This routine allocates a range of memory in the debugger portion of the
    address space.  The pages are allocated from the extra memory pool available
    on development systems.

Arguments:

    NumberOfBytes - Supplies the number of bytes to allocate.

    Protect - Supplies the type of protection and cache mapping to use for the
              allocation.

Return Value:

    NON-NULL - Returns a pointer (virtual address in the nonpaged portion
               of the system) to the allocated physically contiguous
               memory.

    NULL - The specified request could not be satisfied.

Environment:

    Kernel mode, <= DISPATCH_LEVEL

--*/
{
    return MiAllocateMappedMemory(&MmDeveloperKitPteRange, MmDebuggerUsage,
        Protect, NumberOfBytes, MmDeveloperKitPteRange.RemovePageRoutine, FALSE);
}

ULONG
MmDbgFreeMemory(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    )
/*++

Routine Description:

    This routine deallocates a range of memory in the debugger portion of the
    address space.  This is designed to free pages acquired via
    MmDbgAllocateMemory only.

Arguments:

    BaseAddress - Supplies the base virtual address where the system memory
                  resides.

    NumberOfBytes - Supplies the number of bytes allocated to the request.
                    This number can be zero to free the original size passed to
                    MmDbgAllocateMemory.

Return Value:

    Returns the number of pages deallocated.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    return MiFreeMappedMemory(&MmDeveloperKitPteRange, BaseAddress, NumberOfBytes);
}

PFN_COUNT
MmDbgQueryAvailablePages(
    VOID
    )
/*++

Routine Description:

    This routine returns the number of available pages in the extra memory
    region available on development kits.

Arguments:

    None.

Return Value:

    Number of available pages.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    //
    // Instead of using MmDeveloperKitPfnRegion, indirect through
    // MmDeveloperKitPteRange so that we handle the case of the DVT with only
    // 64 megabytes of memory.
    //

    return *MmDeveloperKitPteRange.AvailablePages;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\mmx\fscache.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fscache.c

Abstract:

    This module implements the file system cache services.

--*/

#include "mi.h"

//
// Macro to convert from a physical byte offset to a physical block number.
//

#define FscByteOffsetToBlockNumber(byteoffset) \
    ((ULONG)((ULONGLONG)(byteoffset) >> PAGE_SHIFT))

//
// Macro to round a size in bytes up to a multiple of the sector size.
//

#define FscRoundToSectors(volume, size) \
    (((ULONG)(size) + ((volume)->SectorSize - 1)) & \
        ~((volume)->SectorSize - 1))

//
// Array of cache elements.
//
PFSCACHE_ELEMENT FscElementArray;

//
// Number of elements allocated to the array of cache elements.
//
ULONG FscNumberOfCachePages;

//
// Linked list of cache elements ordered by least recently used.
//
LIST_ENTRY FscLruList;

//
// Page table entries used by FscWriteFFs to bulk write a range of 0xFF bytes
// using a single page.
//
PMMPTE FscWriteFFsPtes;

//
// Synchronization event to guard against multiple threads executing
// FscSetCacheSize at the same time.
//
INITIALIZED_KEVENT(FscSetCacheSizeEvent, SynchronizationEvent, TRUE);

//
// Notification event for when a read for a cache buffer has completed and there
// are threads waiting for the I/O completion.
//
INITIALIZED_KEVENT(FscCollidedMapBufferEvent, NotificationEvent, FALSE);

//
// Synchronization event for when the number of free elements is non-zero.
//
INITIALIZED_KEVENT(FscWaitingForElementEvent, SynchronizationEvent, FALSE);

//
// Guards multiple threads attempting to enter FscWriteFFs and access
// FscWriteFFsPtes.
//
INITIALIZED_CRITICAL_SECTION(FscWriteFFsLock);

VOID
FscBuildElementLruList(
    VOID
    )
/*++

Routine Description:

    This routine rebuilds the global element lists after the number of pages
    allocated to the cache has changed.  No assumptions are made about the order
    that pages should be placed in the LRU list.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PFSCACHE_ELEMENT ElementArray;
    ULONG NumberOfCachePages;
    ULONG Index;

    MI_ASSERT_LOCK_MM();

    //
    // Initialize the LRU list head.
    //

    InitializeListHead(&FscLruList);

    //
    // Move these globals into locals to keep the compiler happy.
    //

    ElementArray = FscElementArray;
    NumberOfCachePages = FscNumberOfCachePages;

    //
    // Loop over all of the elements and insert them into the appropriate lists.
    //

    for (Index = 0; Index < NumberOfCachePages; Index++) {

        if (ElementArray[Index].CacheExtension == NULL) {

            //
            // The element doesn't reference valid data, so place it at the
            // front of the LRU list so that we grab this type of page first.
            //

            InsertHeadList(&FscLruList, &ElementArray[Index].ListEntry);

        } else {

            //
            // The element references valid data, so place it at the tail of the
            // LRU list so that we don't start reclaiming any elements with
            // valid data until all "free" elements from above are allocated.
            //

            InsertTailList(&FscLruList, &ElementArray[Index].ListEntry);
        }
    }
}

NTSTATUS
FscGrowCacheSize(
    IN PFN_COUNT NumberOfCachePages
    )
/*++

Routine Description:

    This routine grows the number of pages allocated to the file system cache.

Arguments:

    NumberOfCachePages - Specifies the number of pages that should be allocated
        to the file system cache.

Return Value:

    Status of operation.

--*/
{
    PFSCACHE_ELEMENT NewElementArray;
    PCHAR CacheBuffer;
    ULONG Index;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;

    MI_ASSERT_LOCK_MM();

    ASSERT(NumberOfCachePages > FscNumberOfCachePages);

    //
    // Allocate the new array of cache elements.
    //

    NewElementArray = (PFSCACHE_ELEMENT)ExAllocatePoolWithTag(
        sizeof(FSCACHE_ELEMENT) * NumberOfCachePages, 'AcsF');

    if (NewElementArray == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

#if DBG
    RtlFillMemoryUlong(NewElementArray, sizeof(FSCACHE_ELEMENT) *
        NumberOfCachePages, 'looP');
#endif

    //
    // Allocate the additional cache pages as one virtually contiguous chunk.
    //

    CacheBuffer = (PCHAR)MiAllocateMappedMemory(&MmSystemPteRange,
        MmFsCacheUsage, PAGE_READONLY,
        (NumberOfCachePages - FscNumberOfCachePages) << PAGE_SHIFT,
        MiRemoveAnyPage, FALSE);

    if (CacheBuffer == NULL) {
        ExFreePool(NewElementArray);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the old array of cache elements to the new array.
    //

    RtlCopyMemory(NewElementArray, FscElementArray, sizeof(FSCACHE_ELEMENT) *
        FscNumberOfCachePages);

    //
    // Fill in the new cache elements.
    //

    for (Index = FscNumberOfCachePages; Index < NumberOfCachePages; Index++) {

        NewElementArray[Index].CacheExtension = NULL;
        NewElementArray[Index].CacheBuffer = CacheBuffer;

        //
        // Override the PTE index that's currently in the page frame with the
        // buffer's index into the FscElementArray so that we can quickly map
        // from a buffer's virtual address to it's cache element.
        //

        PageFrameNumber = MiGetPteAddress(CacheBuffer)->Hard.PageFrameNumber;
        PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

        ASSERT(PageFrame->Busy.Busy != 0);
        ASSERT(PageFrame->Busy.BusyType == MmFsCacheUsage);

        PageFrame->FsCache.ElementIndex = Index;

        CacheBuffer += PAGE_SIZE;
    }

    //
    // Switch to the new array of cache elements.
    //

    if (FscElementArray != NULL) {
        ExFreePool(FscElementArray);
    }

    FscElementArray = NewElementArray;
    FscNumberOfCachePages = NumberOfCachePages;

    //
    // Relink the LRU list of cache elements.
    //

    FscBuildElementLruList();

    return STATUS_SUCCESS;
}

NTSTATUS
FscShrinkCacheSize(
    IN PFN_COUNT NumberOfCachePages
    )
/*++

Routine Description:

    This routine shrinks the number of pages allocated to the file system cache.

Arguments:

    NumberOfCachePages - Specifies the number of pages that should be allocated
        to the file system cache.

Return Value:

    Status of operation.

--*/
{
    PFSCACHE_ELEMENT NewElementArray;
    ULONG PagesToRelease;
    ULONG Index;
    PFSCACHE_ELEMENT Element;
    KIRQL OldIrql;
    ULONG NewIndex;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;

    MI_ASSERT_LOCK_MM();

    ASSERT(NumberOfCachePages < FscNumberOfCachePages);

    //
    // Allocate the new array of cache elements.
    //

    if (NumberOfCachePages != 0) {

        NewElementArray = (PFSCACHE_ELEMENT)ExAllocatePoolWithTag(
            sizeof(FSCACHE_ELEMENT) * NumberOfCachePages, 'AcsF');

        if (NewElementArray == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

#if DBG
        RtlFillMemoryUlong(NewElementArray, sizeof(FSCACHE_ELEMENT) *
            NumberOfCachePages, 'looP');
#endif

    } else {
        NewElementArray = NULL;
    }

    //
    // Compute the number of pages that we need to grab from the existing cache.
    //

    PagesToRelease = FscNumberOfCachePages - NumberOfCachePages;

    //
    // Loop over the file system cache and grab as many free pages as we can.
    //

ReleaseMoreElements:
    for (Index = FscNumberOfCachePages; Index > 0; Index--) {

        Element = &FscElementArray[Index - 1];

        //
        // Check if this element is free and not already marked for deletion.
        //

        if (Element->UsageCount == 0 && !Element->DeletePending) {

            //
            // Mark the element as pending deletion.
            //

            Element->DeletePending = TRUE;
            Element->CacheExtension = NULL;

            //
            // Remove the entry from the LRU list so that other routines no
            // longer can access the element.
            //

            RemoveEntryList(&Element->ListEntry);
            InitializeListHead(&Element->ListEntry);

            //
            // Decrement the number of pages that we've released and check if
            // we've discovered enough free pages.
            //

            PagesToRelease--;

            if (PagesToRelease == 0) {
                break;
            }
        }
    }

    //
    // If we still need to release more pages, then block until more elements
    // become available.  We own FscSetCacheSizeEvent, so we don't have to worry
    // about another thread growing or shrinking the cache out from under us.
    //

    if (PagesToRelease != 0) {

        MI_UNLOCK_MM_AND_THEN_WAIT(PASSIVE_LEVEL);

        KeWaitForSingleObject(&FscWaitingForElementEvent, Executive, KernelMode,
            FALSE, NULL);

        MI_LOCK_MM(&OldIrql);

        goto ReleaseMoreElements;
    }

    //
    // We've now marked the necessary number of pages to delete.  Walk through
    // the array and free up the entries marked for deletion and copy the
    // surviving elements to the new array of cache elements.
    //

    NewIndex = 0;

    for (Index = 0; Index < FscNumberOfCachePages; Index++) {

        Element = &FscElementArray[Index];

        if (Element->DeletePending) {

            //
            // Free the cache buffer.
            //

            MiFreeMappedMemory(&MmSystemPteRange, PAGE_ALIGN(Element->CacheBuffer),
                PAGE_SIZE);

        } else {

            //
            // Transfer the cache buffer to the new array of cache elements.
            //

            NewElementArray[NewIndex] = *Element;

            //
            // Change the index stored in the page frame to be the new array's
            // index.
            //

            PageFrameNumber =
                MiGetPteAddress(Element->CacheBuffer)->Hard.PageFrameNumber;
            PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

            ASSERT(PageFrame->Busy.Busy != 0);
            ASSERT(PageFrame->Busy.BusyType == MmFsCacheUsage);

            PageFrame->FsCache.ElementIndex = NewIndex;

            NewIndex++;
        }
    }

    ASSERT(NewIndex == NumberOfCachePages);

    //
    // Switch to the new array of cache elements.
    //

    ExFreePool(FscElementArray);

    FscElementArray = NewElementArray;
    FscNumberOfCachePages = NumberOfCachePages;

    //
    // Relink the LRU list of cache elements.
    //

    FscBuildElementLruList();

    //
    // Notify as many waiters for free elements as we can so that other threads
    // try to grab free elements given the new element count, which could be
    // zero now.
    //

    while (!IsListEmpty(&FscWaitingForElementEvent.Header.WaitListHead)) {
        KeSetEvent(&FscWaitingForElementEvent, 0, FALSE);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FscSetCacheSize(
    IN PFN_COUNT NumberOfCachePages
    )
/*++

Routine Description:

    This routine changes the number of pages allocated to the file system cache.

Arguments:

    NumberOfCachePages - Specifies the number of pages that should be allocated
        to the file system cache.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    KIRQL OldIrql;

    KeWaitForSingleObject(&FscSetCacheSizeEvent, Executive, KernelMode, FALSE,
        NULL);

    MI_LOCK_MM(&OldIrql);

    if (NumberOfCachePages > FSCACHE_MAXIMUM_NUMBER_OF_CACHE_PAGES) {
        status = STATUS_INVALID_PARAMETER;
    } else if (NumberOfCachePages > FscNumberOfCachePages) {
        status = FscGrowCacheSize(NumberOfCachePages);
    } else if (NumberOfCachePages < FscNumberOfCachePages) {
        status = FscShrinkCacheSize(NumberOfCachePages);
    } else {
        status = STATUS_SUCCESS;
    }

    MI_UNLOCK_MM(OldIrql);

    KeSetEvent(&FscSetCacheSizeEvent, 0, FALSE);

    return status;
}

PFN_COUNT
FscGetCacheSize(
    VOID
    )
/*++

Routine Description:

    This routine returns the number of pages allocated to the file system cache.

Arguments:

    None.

Return Value:

    Number of pages currently allocated to the file system cache.

--*/
{
    return FscNumberOfCachePages;
}

PFSCACHE_ELEMENT
FscLookupElement(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN ULONG BlockNumber
    )
/*++

Routine Description:

    This routine searches the file system cache for an element that maps the
    block with the supplied block number from the supplied target device.

Arguments:

    CacheExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    The pointer to the element if found, else NULL.

--*/
{
    PLIST_ENTRY NextListEntry;
    PFSCACHE_ELEMENT Element;

    NextListEntry = FscLruList.Blink;

    while (NextListEntry != &FscLruList) {

        Element = CONTAINING_RECORD(NextListEntry, FSCACHE_ELEMENT, ListEntry);

        //
        // Check if this element satisfies the search criteria.
        //

        if ((Element->BlockNumber == BlockNumber) &&
            (Element->CacheExtension == CacheExtension)) {

            //
            // Move the element to the end of the LRU list.
            //

            RemoveEntryList(&Element->ListEntry);
            InsertTailList(&FscLruList, &Element->ListEntry);

            return Element;
        }

        //
        // If we find an element with an empty cache extension, then the element
        // doesn't reference valid data.  All free elements are at the front of
        // the LRU list, so we know that we can stop the search now.
        //

        if (Element->CacheExtension == NULL) {
            break;
        }

        NextListEntry = Element->ListEntry.Blink;
    }

    return NULL;
}

PFSCACHE_ELEMENT
FscAllocateElement(
    VOID
    )
/*++

Routine Description:

    This routine allocates an element from the file system cache.  If no
    elements are currently available, it will block until elements do become
    available.

Arguments:

    None.

Return Value:

    The pointer to the allocated element.

--*/
{
    PLIST_ENTRY NextListEntry;
    PFSCACHE_ELEMENT Element;
    KIRQL OldIrql;

    MI_ASSERT_LOCK_MM();

RetryOperation:
    //
    // If the cache doesn't have any pages allocated to it, then we're never
    // going to be able to allocate an element, so bail out now.
    //

    if (FscNumberOfCachePages == 0) {
        MiDbgPrint(("FSCACHE: cache page required by file system, but cache size is zero.\n"));
        return NULL;
    }

    //
    // Search the LRU list for an unreferenced element.
    //

    NextListEntry = FscLruList.Flink;

    while (NextListEntry != &FscLruList) {

        Element = CONTAINING_RECORD(NextListEntry, FSCACHE_ELEMENT, ListEntry);

        //
        // Check if this element is free.  If so, detach the element from the
        // LRU list and give it back to the caller.
        //

        if (Element->UsageCount == 0) {
            RemoveEntryList(&Element->ListEntry);
            ASSERT(MiGetPteAddress(Element->CacheBuffer)->Hard.Write == 0);
            return Element;
        }

        NextListEntry = Element->ListEntry.Flink;
    }

    //
    // There aren't any unused pages in the LRU list.  We'll have to block until
    // a page becomes available.
    //

    MI_UNLOCK_MM_AND_THEN_WAIT(APC_LEVEL);

    KeWaitForSingleObject(&FscWaitingForElementEvent, Executive, KernelMode,
        FALSE, NULL);

    MI_LOCK_MM(&OldIrql);

    goto RetryOperation;
}

PFSCACHE_ELEMENT
FscElementFromCacheBuffer(
    PVOID CacheBuffer
    )
/*++

Routine Description:

    This routine returns the element corresponding to the supplied cache buffer
    pointer.

Arguments:

    CacheBuffer - Supplies the pointer to the cache buffer.

Return Value:

    The pointer to the corresponding element.

--*/
{
    PFSCACHE_ELEMENT Element;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;

    MI_ASSERT_LOCK_MM();

    //
    // From any cache virtual address, we can get back to its cache element by
    // going through the page frame database.  We have to acquire the memory
    // manager lock here to make sure the page doesn't move while we're doing
    // the conversion.
    //

    PageFrameNumber = MiGetPteAddress(CacheBuffer)->Hard.PageFrameNumber;
    PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

    ASSERT(PageFrame->Busy.Busy != 0);
    ASSERT(PageFrame->Busy.BusyType == MmFsCacheUsage);

    Element = &FscElementArray[PageFrame->FsCache.ElementIndex];

    ASSERT(PAGE_ALIGN(Element->CacheBuffer) == PAGE_ALIGN(CacheBuffer));

    return Element;
}

VOID
FASTCALL
FscSetCacheBufferProtection(
    IN PVOID CacheBuffer,
    IN BOOLEAN MapAsReadWrite
    )
/*++

Routine Description:

    This routine is called to change the page protection of the supplied cache
    buffer.

Arguments:

    CacheBuffer - Specifies the cache buffer to change the page protection for.

    MapAsReadWrite - Specifies whether the page should be mapped as read-only or
        read/write.

Return Value:

    None.

--*/
{
    PMMPTE PointerPte;
    MMPTE TempPte;

    MI_ASSERT_LOCK_MM();

    PointerPte = MiGetPteAddress(CacheBuffer);

    TempPte = *PointerPte;

    TempPte.Hard.Write = MapAsReadWrite ? 1 : 0;

    MI_WRITE_AND_FLUSH_PTE(PointerPte, TempPte);
}

NTSTATUS
FscSignalIoEventCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called to signal an event when a thread is blocked on an
    I/O operation inside an IRP dispatch routine.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Context - Specifies the context that was supplied to IoSetCompletionRoutine.

Return Value:

    Status of operation.

--*/
{
    KeSetEvent((PKEVENT)Context, IO_DISK_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
FscMapBuffer(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN PIRP Irp,
    IN ULONGLONG ByteOffset,
    IN BOOLEAN MapAsReadWrite,
    OUT PVOID *ReturnedCacheBuffer
    )
/*++

Routine Description:

    This routine maps the page buffer at the supplied byte offset into the file
    system cache.

    The returned cache buffer will have the same page byte offset as the
    supplied byte offset.

Arguments:

    CacheExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    ByteOffset - Specifies the byte offset to map into the cache.

    MapAsReadWrite - Specifies whether the page should be mapped as read-only or
        read/write.

    CacheBuffer - Specifies the buffer to receive the pointer to the cache
        buffer.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    KIRQL OldIrql;
    ULONG BlockNumber;
    PFSCACHE_ELEMENT Element;
    PVOID CacheBuffer;
    KEVENT IoEvent;
    PIO_STACK_LOCATION IrpSp;
    ULONG EndingBlockNumber;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    ASSERT(Irp->CurrentLocation > CacheExtension->TargetDeviceObject->StackSize);
    ASSERT(ByteOffset < (ULONGLONG)CacheExtension->PartitionLength.QuadPart);

RetryOperation:
    MI_LOCK_MM(&OldIrql);

    //
    // Attempt to find the requested block number in the file system cache.
    //

    BlockNumber = FscByteOffsetToBlockNumber(ByteOffset);
    Element = FscLookupElement(CacheExtension, BlockNumber);

    if (Element != NULL) {

        //
        // The element was found.  If there's I/O in progress for the element,
        // then we need to block until the I/O is complete.  Most likely,
        // another thread is in the process of reading the block we need.
        //

        if (!Element->ReadInProgress) {

            Element->UsageCount++;

            CacheBuffer = PAGE_ALIGN(Element->CacheBuffer);

            if (MapAsReadWrite) {
                FscSetCacheBufferProtection(CacheBuffer, TRUE);
            } else {
                ASSERT(MiGetPteAddress(CacheBuffer)->Hard.Write == 0);
            }

            *ReturnedCacheBuffer = (PCHAR)CacheBuffer + BYTE_OFFSET(ByteOffset);

            MI_UNLOCK_MM(OldIrql);

            return STATUS_SUCCESS;
        }

        //
        // Mark the element so that the original thread knows that somebody is
        // waiting for a read operation to complete.
        //

        Element->ReadWaiters = TRUE;

        //
        // Contention should happen fairly infrequently since file system access
        // will likely happen on a small number of threads.  So we use one event
        // for all collided calls to FscMapBuffer.
        //

        MI_UNLOCK_MM_AND_THEN_WAIT(OldIrql);

        KeWaitForSingleObject(&FscCollidedMapBufferEvent, Executive, KernelMode,
            FALSE, NULL);

        goto RetryOperation;
    }

    //
    // Allocate an element to receive the page.  We could get a NULL back from
    // this routine if the cache has been scaled back to zero pages.
    //

    Element = FscAllocateElement();

    if (Element == NULL) {
        MI_UNLOCK_MM(OldIrql);
        return STATUS_NO_MEMORY;
    }

    //
    // Initialize the element with our block number and cache extension and
    // insert the element at the tail of the LRU list.  The element is marked so
    // that other threads know that we're currently reading the cache buffer
    // into memory.
    //

    Element->BlockNumber = BlockNumber;
    Element->CacheExtension = CacheExtension;
    Element->UsageCount = 1;
    Element->ReadInProgress = TRUE;
    ASSERT(!Element->ReadWaiters);

    InsertTailList(&FscLruList, &Element->ListEntry);

    //
    // Lock down the cache buffer.
    //

    CacheBuffer = PAGE_ALIGN(Element->CacheBuffer);
    MmLockUnlockBufferPages(CacheBuffer, PAGE_SIZE, FALSE);

    //
    // Leave the memory manager lock so that we can block for the I/O operation.
    //

    MI_UNLOCK_MM(OldIrql);

    //
    // Initialize the event used to block for completion of the I/O operation
    // and set the completion routine that will signal this event.
    //

    KeInitializeEvent(&IoEvent, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp, FscSignalIoEventCompletion, &IoEvent, TRUE,
        TRUE, TRUE);

    //
    // Initialize the next IRP stack location for the I/O operation.
    //

    IrpSp = IoGetNextIrpStackLocation(Irp);

    IrpSp->MajorFunction = IRP_MJ_READ;
    IrpSp->Flags = SL_FSCACHE_REQUEST;
    IrpSp->Parameters.Read.ByteOffset.QuadPart = (ULONGLONG)BlockNumber <<
        PAGE_SHIFT;
    IrpSp->Parameters.Read.CacheBuffer = CacheBuffer;

    //
    // Compute the number of bytes that we're going to read.  The length of the
    // partition is not necessarily page aligned, so we have to be careful to
    // request a legal number of bytes.
    //

    EndingBlockNumber =
        FscByteOffsetToBlockNumber(CacheExtension->PartitionLength.QuadPart);

    if (BlockNumber < EndingBlockNumber) {
        IrpSp->Parameters.Read.Length = PAGE_SIZE;
    } else {
        IrpSp->Parameters.Read.Length =
            BYTE_OFFSET(CacheExtension->PartitionLength.LowPart);
        ASSERT(BlockNumber == EndingBlockNumber);
        ASSERT(IrpSp->Parameters.Read.Length != 0);
    }

    //
    // Submit the request to the target device and wait for the I/O operation to
    // complete.
    //

    status = IoCallDriver(CacheExtension->TargetDeviceObject, Irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&IoEvent, WrFsCacheIn, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    MI_LOCK_MM(&OldIrql);

    //
    // Unlock the cache buffer.
    //

    MmLockUnlockBufferPages(CacheBuffer, PAGE_SIZE, TRUE);

    //
    // Recompute the pointer to the cache element to guard against somebody
    // changing the size of the cache out from under us and causing the old
    // cache element pointer to become invalid.
    //

    Element = FscElementFromCacheBuffer(CacheBuffer);

    ASSERT(Element->BlockNumber == BlockNumber);
    ASSERT(Element->UsageCount == 1);
    ASSERT(Element->ReadInProgress);

    //
    // Clear the read in progress flag from the cache element.  If anybody is
    // waiting for this buffer to be mapped, then signal the collision event so
    // that everybody goes and checks if their page is available.  If an error
    // occurred reading in the page, the other threads won't see that error but
    // will have to call down to the lower driver themselves.  That's equivalent
    // to the same thread attempting to read in the same page multiple times and
    // failing.
    //

    Element->ReadInProgress = FALSE;

    if (Element->ReadWaiters) {
        KePulseEvent(&FscCollidedMapBufferEvent, IO_DISK_INCREMENT, FALSE);
        Element->ReadWaiters = FALSE;
    }

    //
    // If we successfully read the page in, then return the address of the cache
    // buffer to the caller.  Otherwise, discard the cache buffer.
    //

    if (NT_SUCCESS(status)) {

        if (MapAsReadWrite) {
            FscSetCacheBufferProtection(CacheBuffer, TRUE);
        } else {
            ASSERT(MiGetPteAddress(CacheBuffer)->Hard.Write == 0);
        }

        *ReturnedCacheBuffer = (PCHAR)CacheBuffer + BYTE_OFFSET(ByteOffset);

    } else {
        FscDiscardBuffer(CacheBuffer);
    }

    MI_UNLOCK_MM(OldIrql);

    return status;
}

NTSTATUS
FscMapEmptyBuffer(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN ULONGLONG ByteOffset,
    OUT PVOID *CacheBuffer
    )
/*++

Routine Description:

    This routine maps the page buffer at the supplied byte offset into the file
    system cache if the buffer is already present in the cache.  If the buffer
    is not present in the cache, then an uninitialized page is returned instead.
    This routine is intended for writes of page sized buffers through the cache.

    The supplied byte offset must be page aligned.

Arguments:

    CacheExtension - Specifies the extension that the I/O request is for.

    ByteOffset - Specifies the byte offset to map into the cache.

    CacheBuffer - Specifies the buffer to receive the pointer to the cache
        buffer.

Return Value:

    Status of operation.

--*/
{
    KIRQL OldIrql;
    ULONG BlockNumber;
    PFSCACHE_ELEMENT Element;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    ASSERT(ByteOffset < (ULONGLONG)CacheExtension->PartitionLength.QuadPart);
    ASSERT(BYTE_OFFSET(ByteOffset) == 0);

    MI_LOCK_MM(&OldIrql);

    //
    // Attempt to find the requested block number in the file system cache.
    //

    BlockNumber = FscByteOffsetToBlockNumber(ByteOffset);
    Element = FscLookupElement(CacheExtension, BlockNumber);

    if (Element != NULL) {

        ASSERT(!Element->ReadInProgress);

        Element->UsageCount++;

        //
        // Make the cache buffer writable.
        //

        FscSetCacheBufferProtection(Element->CacheBuffer, TRUE);

        //
        // Fill the cache buffer with 0xFFs to reduce signal noise when writing
        // to a memory unit (MU) device.
        //

        RtlFillMemory(PAGE_ALIGN(Element->CacheBuffer), PAGE_SIZE, (ULONG)-1);

        *CacheBuffer = PAGE_ALIGN(Element->CacheBuffer);

        MI_UNLOCK_MM(OldIrql);

        return STATUS_SUCCESS;
    }

    //
    // Allocate an element to receive the page.  We could get a NULL back from
    // this routine if the cache has been scaled back to zero pages.
    //

    Element = FscAllocateElement();

    if (Element == NULL) {
        MI_UNLOCK_MM(OldIrql);
        return STATUS_NO_MEMORY;
    }

    //
    // All we want is an empty page, so we just need to initialize the element
    // with our block number and cache extension and insert the element at the
    // tail of the LRU list.
    //

    Element->BlockNumber = BlockNumber;
    Element->CacheExtension = CacheExtension;
    Element->UsageCount = 1;
    ASSERT(!Element->ReadInProgress);
    ASSERT(!Element->ReadWaiters);

    InsertTailList(&FscLruList, &Element->ListEntry);

    //
    // Make the cache buffer writable.
    //

    FscSetCacheBufferProtection(Element->CacheBuffer, TRUE);

    //
    // Fill the cache buffer with 0xFFs to reduce signal noise when writing to a
    // memory unit (MU) device.
    //

    RtlFillMemory(PAGE_ALIGN(Element->CacheBuffer), PAGE_SIZE, (ULONG)-1);

    *CacheBuffer = PAGE_ALIGN(Element->CacheBuffer);

    MI_UNLOCK_MM(OldIrql);

    return STATUS_SUCCESS;
}

NTSTATUS
FscWriteBuffer(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN PIRP Irp,
    IN ULONGLONG ByteOffset,
    IN ULONG WriteLength,
    IN PVOID CacheBuffer
    )
/*++

Routine Description:

    This routine writes out the contents of the supplied cache buffer to the
    target device.

    Although the cache buffer is PAGE_SIZE bytes in length, this routine may
    only write enough sectors to contain the starting byte offset and the
    specified number of bytes.

Arguments:

    CacheExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    ByteOffset - Specifies the byte offset to start writing to.

    WriteLength - Specifies the number of bytes that have been dirtied in the
        cache.

    CacheBuffer - Specifies the address of the cache buffer to start writing
        from.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG SectorMask;
    ULONGLONG EndingByteOffset;
    KEVENT IoEvent;
    PIO_STACK_LOCATION IrpSp;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    ASSERT(Irp->CurrentLocation > CacheExtension->TargetDeviceObject->StackSize);
    ASSERT(ByteOffset < (ULONGLONG)CacheExtension->PartitionLength.QuadPart);
    ASSERT((ByteOffset + WriteLength) <= (ULONGLONG)CacheExtension->PartitionLength.QuadPart);
    ASSERT((BYTE_OFFSET(ByteOffset) + WriteLength) <= PAGE_SIZE);
    ASSERT(MiGetPteAddress(CacheBuffer)->Hard.Write != 0);

    //
    // Align the byte offset and length to sector boundaries.
    //

    SectorMask = CacheExtension->SectorSize - 1;
    EndingByteOffset = (ByteOffset + WriteLength + SectorMask) & ~((ULONGLONG)SectorMask);
    ByteOffset = ByteOffset & ~((ULONGLONG)SectorMask);
    WriteLength = (ULONG)(EndingByteOffset - ByteOffset);
    CacheBuffer = (PCHAR)PAGE_ALIGN(CacheBuffer) + BYTE_OFFSET(ByteOffset);

    ASSERT(EndingByteOffset <= (ULONGLONG)CacheExtension->PartitionLength.QuadPart);
    ASSERT((BYTE_OFFSET(ByteOffset) + WriteLength) <= PAGE_SIZE);

    //
    // Lock down the cache buffer.
    //

    MmLockUnlockBufferPages(CacheBuffer, WriteLength, FALSE);

    //
    // Initialize the event used to block for completion of the I/O operation
    // and set the completion routine that will signal this event.
    //

    KeInitializeEvent(&IoEvent, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp, FscSignalIoEventCompletion, &IoEvent, TRUE,
        TRUE, TRUE);

    //
    // Initialize the next IRP stack location for the I/O operation.
    //

    IrpSp = IoGetNextIrpStackLocation(Irp);

    IrpSp->MajorFunction = IRP_MJ_WRITE;
    IrpSp->Flags = SL_FSCACHE_REQUEST;
    IrpSp->Parameters.Write.ByteOffset.QuadPart = ByteOffset;
    IrpSp->Parameters.Write.Length = WriteLength;
    IrpSp->Parameters.Write.CacheBuffer = CacheBuffer;

    //
    // Submit the request to the target device and wait for the I/O operation to
    // complete.
    //

    status = IoCallDriver(CacheExtension->TargetDeviceObject, Irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&IoEvent, WrFsCacheOut, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    //
    // Unlock the cache buffer.
    //

    MmLockUnlockBufferPages(CacheBuffer, WriteLength, TRUE);

    //
    // Unmap or discard the buffer.
    //

    if (NT_SUCCESS(status)) {
        FscUnmapBuffer(CacheBuffer);
    } else {
        FscDiscardBuffer(CacheBuffer);
    }

    return status;
}

VOID
FscUnmapBuffer(
    PVOID CacheBuffer
    )
/*++

Routine Description:

    This routine unmaps the supplied page buffer that was obtained from a call
    to FscMapBuffer.  The buffer remains in the file system cache until another
    request reclaims the memory.

Arguments:

    CacheBuffer - Specifies the cache buffer to unmap.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    PFSCACHE_ELEMENT Element;

    MI_LOCK_MM(&OldIrql);

    //
    // Change the protection of the cache buffer back to read-only if necessary.
    //

    if (MiGetPteAddress(CacheBuffer)->Hard.Write != 0) {
        FscSetCacheBufferProtection(CacheBuffer, FALSE);
    }

    //
    // Obtain the element corresponding to the supplied cache buffer.
    //

    Element = FscElementFromCacheBuffer(CacheBuffer);

    ASSERT(Element->UsageCount > 0);

    //
    // Decrement the reference count for the element and signal anybody waiting
    // for a cache page.
    //
    // Note that setting the cache buffer back to its page aligned address
    // zeroes out the usage count and various flags.
    //

    Element->UsageCount--;

    if (Element->UsageCount == 0) {

        Element->CacheBuffer = PAGE_ALIGN(Element->CacheBuffer);

        if (!IsListEmpty(&FscWaitingForElementEvent.Header.WaitListHead)) {
            KeSetEvent(&FscWaitingForElementEvent, 0, FALSE);
        }
    }

    MI_UNLOCK_MM(OldIrql);
}

VOID
FscDiscardBuffer(
    PVOID CacheBuffer
    )
/*++

Routine Description:

    This routine unmaps and discards the supplied page buffer that was obtained
    from a call to FscMapBuffer or FscMapEmptyBuffer.  The buffer is marked as
    being free in the system cache.  This is intended to be called after failing
    to write out a dirty cache buffer so that a subsequent mapping obtains the
    original buffer.

    Note that this routine is also called in the error path of FscMapBuffer.

Arguments:

    CacheBuffer - Specifies the cache buffer to discard.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    PFSCACHE_ELEMENT Element;

    MI_LOCK_MM(&OldIrql);

    //
    // Change the protection of the cache buffer back to read-only.
    //

    FscSetCacheBufferProtection(CacheBuffer, FALSE);

    //
    // Obtain the element corresponding to the supplied cache buffer.
    //

    Element = FscElementFromCacheBuffer(CacheBuffer);

    ASSERT(!Element->DeletePending);
    ASSERT(Element->UsageCount == 1);

    //
    // Release the reference on the page, null out the cache extension so that
    // we don't try to map the page again, and insert it at the front of the LRU
    // list.
    //
    // Note that setting the cache buffer back to its page aligned address
    // zeroes out the usage count and various flags.
    //

    Element->CacheBuffer = PAGE_ALIGN(Element->CacheBuffer);
    Element->CacheExtension = NULL;

    ASSERT(Element->UsageCount == 0);

    RemoveEntryList(&Element->ListEntry);
    InsertHeadList(&FscLruList, &Element->ListEntry);

    if (!IsListEmpty(&FscWaitingForElementEvent.Header.WaitListHead)) {
        KeSetEvent(&FscWaitingForElementEvent, 0, FALSE);
    }

    MI_UNLOCK_MM(OldIrql);
}

NTSTATUS
FscWriteFFs(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN PIRP Irp,
    IN ULONGLONG ByteOffset,
    IN ULONG WriteLength
    )
/*++

Routine Description:

    This routine writes out the supplied number of 0xFF bytes to the target
    device.  Only a single cache buffer at the supplied byte offset is dirtied
    for the I/O operation.

Arguments:

    CacheExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    ByteOffset - Specifies the byte offset to start writing to.

    WriteLength - Specifies the number of 0xFF bytes to write out; this number
        should be a multiple of the sector size.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVOID CacheBuffer;
    MMPTE TempPte;
    PMMPTE PointerPte;
    ULONG Index;
    ULONG WriteBytesRemaining;
    KEVENT IoEvent;
    PIO_STACK_LOCATION IrpSp;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    ASSERT(ByteOffset < (ULONGLONG)CacheExtension->PartitionLength.QuadPart);
    ASSERT((ByteOffset + WriteLength) <= (ULONGLONG)CacheExtension->PartitionLength.QuadPart);
    ASSERT(BYTE_OFFSET(ByteOffset) == 0);
    ASSERT(WriteLength > 0);
    ASSERT((WriteLength & (CacheExtension->SectorSize - 1)) == 0);

    //
    // Synchronize access to FscWriteFFsPtes.
    //

    RtlEnterCriticalSection(&FscWriteFFsLock);

    //
    // Allocate a cache buffer for the operation.
    //

    status = FscMapEmptyBuffer(CacheExtension, ByteOffset, &CacheBuffer);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // If we're writing out more than a page worth of data, then invalidate any
    // other pages from the dirty byte range.
    //

    if (WriteLength > PAGE_SIZE) {
        FscInvalidateByteRange(CacheExtension, ByteOffset + PAGE_SIZE,
            WriteLength - PAGE_SIZE);
    }

    //
    // Initialize the contents of this cache buffer.
    //

    RtlFillMemory(CacheBuffer, PAGE_SIZE, (ULONG)-1);

    //
    // Lock down the cache buffer.
    //

    MmLockUnlockBufferPages(CacheBuffer, PAGE_SIZE, FALSE);

    //
    // Copy the page table entry for the cache buffer to the "write 0xFF" PTEs.
    // The cache buffer is locked down, so we can safely map the page multiple
    // times without fear that the page will be relocated out from under us.
    //

    TempPte = *MiGetPteAddress(CacheBuffer);
    PointerPte = FscWriteFFsPtes;

    for (Index = 0; Index < FSCACHE_NUMBER_OF_WRITE_FF_PTES; Index++) {
        MI_WRITE_PTE(PointerPte, TempPte);
        PointerPte++;
    }

    //
    // Write out chunks of pages until we've exhausted the requested write
    // length.
    //

    WriteBytesRemaining = WriteLength;

    do {

        //
        // Compute the number of bytes to write out in this iteration.
        //

        WriteLength = PAGE_SIZE * FSCACHE_NUMBER_OF_WRITE_FF_PTES;

        if (WriteLength > WriteBytesRemaining) {
            WriteLength = WriteBytesRemaining;
        }

        //
        // Initialize the event used to block for completion of the I/O operation
        // and set the completion routine that will signal this event.
        //

        KeInitializeEvent(&IoEvent, NotificationEvent, FALSE);

        IoSetCompletionRoutine(Irp, FscSignalIoEventCompletion, &IoEvent, TRUE,
            TRUE, TRUE);

        //
        // Initialize the next IRP stack location for the I/O operation.
        //

        IrpSp = IoGetNextIrpStackLocation(Irp);

        IrpSp->MajorFunction = IRP_MJ_WRITE;
        IrpSp->Flags = SL_FSCACHE_REQUEST;
        IrpSp->Parameters.Write.ByteOffset.QuadPart = ByteOffset;
        IrpSp->Parameters.Write.Length = WriteLength;
        IrpSp->Parameters.Write.CacheBuffer =
            MiGetVirtualAddressMappedByPte(FscWriteFFsPtes);

        //
        // Submit the request to the target device and wait for the I/O operation to
        // complete.
        //

        status = IoCallDriver(CacheExtension->TargetDeviceObject, Irp);

        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&IoEvent, WrFsCacheOut, KernelMode, FALSE, NULL);
            status = Irp->IoStatus.Status;
        }

        if (!NT_SUCCESS(status)) {
            break;
        }

        ByteOffset += WriteLength;
        WriteBytesRemaining -= WriteLength;

    } while (WriteBytesRemaining > 0);

    //
    // Clear the double mapping from the "write 0xFF" PTEs.
    //

    MiZeroAndFlushPtes(FscWriteFFsPtes, FSCACHE_NUMBER_OF_WRITE_FF_PTES);

    //
    // Unlock the cache buffer.
    //

    MmLockUnlockBufferPages(CacheBuffer, PAGE_SIZE, TRUE);

    //
    // Unmap or discard the buffer.
    //

    if (NT_SUCCESS(status)) {
        FscUnmapBuffer(CacheBuffer);
    } else {
        FscDiscardBuffer(CacheBuffer);
    }

CleanupAndExit:
    RtlLeaveCriticalSection(&FscWriteFFsLock);

    return status;
}

BOOLEAN
FscTestForFullyCachedIo(
    IN PIRP Irp,
    IN ULONG ByteOffsetLowPart,
    IN ULONG IoLength,
    IN BOOLEAN NonCachedEndOfFileTransfer
    )
/*++

Routine Description:

    This routine tests the supplied transfer parameters to see if the transfer
    should be handled through a fully cached path, where all bytes are
    transferred using the file system cache, or a partially cached path, where
    whole pages are transferred using non-cached I/O requests and partial pages
    are transferered using the file system cache.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

    ByteOffsetLowPart - Specifies the lower 32-bits of the transfer byte offset.

    IoLength - Specifies the number of bytes to transfer.

    NonCachedEndOfFileTransfer - Specifies TRUE if the read is to the end of
        file and the output buffer is large enough to hold the transfer length
        rounded up to a sector boundary.

Return Value:

    Returns TRUE if the transfer should go through a fully cached path, else
    FALSE.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    ULONG AlignmentRequirement;
    ULONG EndingByteOffsetLowPart;

    ASSERT(IoLength != 0);

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Check if the file object was opened for random access.  If so, then we'll
    // copy through the cache so that the pages stay resident in the cache as
    // long as possible.
    //

    if (MiIsFlagClear(IrpSp->FileObject->Flags, FO_RANDOM_ACCESS)) {

        //
        // Check if the starting file byte offset or user buffer are misaligned.
        // If so, then we need to go through the fully cached path since the
        // hardware won't be able to directly deal with these buffers.
        //

        AlignmentRequirement = IrpSp->DeviceObject->AlignmentRequirement;

        if (((IrpSp->Parameters.Read.ByteOffset.LowPart & AlignmentRequirement) == 0) &&
            ((BYTE_OFFSET(Irp->UserBuffer) & AlignmentRequirement) == 0)) {

            if (NonCachedEndOfFileTransfer) {

                //
                // Compute the ending byte offset truncated down to the nearest
                // page and the starting byte offset truncated down to the
                // nearest page.  If these aren't the same byte offsets, then
                // there's some number of bytes on a different cache page than
                // the starting byte offset, so use the partially cached paths
                // to avoid using the cache for any middle pages or the partial
                // tail page.
                //
                // If we've reached this code, then we already know that this is
                // a read request and that the transfer buffer is large enough
                // to handle a partial sector I/O transfer.
                //

                if (BYTE_OFFSET(ByteOffsetLowPart) == 0) {
                    return FALSE;
                }

                EndingByteOffsetLowPart = ByteOffsetLowPart + IoLength;

                if ((BYTE_OFFSET(EndingByteOffsetLowPart) != 0) &&
                    (PAGE_ALIGN(ByteOffsetLowPart) != PAGE_ALIGN(EndingByteOffsetLowPart))) {
                    return FALSE;
                }

            } else if (IoLength >= PAGE_SIZE) {

                //
                // Compute the ending byte offset truncated down to the nearest
                // page and the starting byte offset rounded up to the nearest
                // page.  If these aren't the same byte offsets, then the
                // transfer contains at least one whole page, so use the
                // partially cached paths to avoid using the cache for these
                // middle pages.
                //
                // We only go through this code for the case where the transfer
                // length is greater than a page to handle the case of the
                // starting and ending byte offset residing on the same cache
                // page.
                //

                EndingByteOffsetLowPart = (ULONG)PAGE_ALIGN(ByteOffsetLowPart + IoLength);
                ByteOffsetLowPart = ROUND_TO_PAGES(ByteOffsetLowPart);

                if (ByteOffsetLowPart != EndingByteOffsetLowPart) {
                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}

NTSTATUS
FscPartiallyCachedRead(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN PIRP Irp,
    IN ULONGLONG ByteOffset,
    IN ULONG ReadLength,
    IN ULONG BufferByteOffset,
    IN BOOLEAN NonCachedEndOfFileTransfer
    )
/*++

Routine Description:

    This routine reads the supplied number of bytes from the supplied starting
    byte offset to IRP.UserBuffer plus the supplied buffer byte offset.  This
    routine reads whole pages using direct I/O into the read buffer and,
    if necessary, reads the tail page using a file system cache buffer.

Arguments:

    CacheExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    ByteOffset - Specifies the byte offset to start reading from.  The byte
        offset must be page aligned.

    ReadLength - Specifies the number of bytes to read.  The number of bytes
        must be greater than or equal to the page size.

    BufferByteOffset - Specifies the offset into IRP.UserBuffer to start reading
        the data.

    NonCachedEndOfFileTransfer - Specifies TRUE if the read is to the end of
        file and the output buffer is large enough to hold the transfer length
        rounded up to a sector boundary.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG PartialReadLength;
    KEVENT IoEvent;
    PIO_STACK_LOCATION IrpSp;
    PVOID CacheBuffer;

    ASSERT(BYTE_OFFSET(ByteOffset) == 0);

    //
    // If NonCachedEndOfFileTransfer is TRUE, then we're reading to the end of
    // the file and the transfer buffer is large enough to hold the transfer
    // length rounded up to a sector boundary.
    //

    if (NonCachedEndOfFileTransfer) {
        ReadLength = FscRoundToSectors(CacheExtension, ReadLength);
        PartialReadLength = ReadLength;
    } else {
        ASSERT(ReadLength >= PAGE_SIZE);
        PartialReadLength = (ULONG)PAGE_ALIGN(ReadLength);
    }

    //
    // Initialize the event used to block for completion of the I/O operation
    // and set the completion routine that will signal this event.
    //

    KeInitializeEvent(&IoEvent, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp, FscSignalIoEventCompletion, &IoEvent, TRUE,
        TRUE, TRUE);

    //
    // Initialize the next IRP stack location for the I/O operation.
    //

    IrpSp = IoGetNextIrpStackLocation(Irp);

    IrpSp->MajorFunction = IRP_MJ_READ;
    IrpSp->Parameters.Read.ByteOffset.QuadPart = ByteOffset;
    IrpSp->Parameters.Read.Length = PartialReadLength;
    IrpSp->Parameters.Read.BufferOffset = BufferByteOffset;

    //
    // Submit the request to the target device and wait for the I/O operation to
    // complete.
    //

    status = IoCallDriver(CacheExtension->TargetDeviceObject, Irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&IoEvent, WrFsCacheIn, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    //
    // Transfer the remaining non whole page of the request if necessary.
    //

    if (NT_SUCCESS(status)) {

        ReadLength -= PartialReadLength;

        if (ReadLength > 0) {

            ByteOffset += PartialReadLength;
            BufferByteOffset += PartialReadLength;

            status = FscMapBuffer(CacheExtension, Irp, ByteOffset, FALSE,
                &CacheBuffer);

            if (NT_SUCCESS(status)) {
                RtlCopyMemory((PUCHAR)Irp->UserBuffer + BufferByteOffset,
                    CacheBuffer, ReadLength);
                FscUnmapBuffer(CacheBuffer);
            }
        }
    }

    return status;
}

NTSTATUS
FscCachedRead(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN PIRP Irp,
    IN ULONGLONG ByteOffset,
    IN ULONG ReadLength,
    IN BOOLEAN NonCachedEndOfFileTransfer
    )
/*++

Routine Description:

    This routine reads the supplied number of bytes from the supplied starting
    byte offset to IRP.UserBuffer.

Arguments:

    CacheExtension - Specifies the extension that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    ByteOffset - Specifies the byte offset to start reading from.

    ReadLength - Specifies the number of bytes to read.

    NonCachedEndOfFileTransfer - Specifies TRUE if the read is to the end of
        file and the output buffer is large enough to hold the transfer length
        rounded up to a sector boundary.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;
    PVOID UserBuffer;
    ULONG BytesRemaining;
    PVOID CacheBuffer;
    ULONG BytesToCopy;
    ULONG BufferByteOffset;
    ULONG PartialIoLength;
    PFILE_OBJECT FileObject;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    UserBuffer = Irp->UserBuffer;
    BytesRemaining = ReadLength;

    //
    // Check if this transfer should use the fully or partially cached path.
    //

    if (FscTestForFullyCachedIo(Irp, (ULONG)ByteOffset, ReadLength,
        NonCachedEndOfFileTransfer)) {

        //
        // Map each page into the cache and copy the contents into the user's
        // buffer.
        //

        do {

            //
            // Map the physical byte offset into the cache.
            //

            status = FscMapBuffer(CacheExtension, Irp, ByteOffset, FALSE,
                &CacheBuffer);

            if (!NT_SUCCESS(status)) {
                return status;
            }

            //
            // Compute the number of bytes to copy from this cache page.
            //

            BytesToCopy = PAGE_SIZE - BYTE_OFFSET(ByteOffset);

            if (BytesToCopy > BytesRemaining) {
                BytesToCopy = BytesRemaining;
            }

            //
            // Copy the bytes from the cache page and unmap the cache buffer.
            //

            RtlCopyMemory(UserBuffer, CacheBuffer, BytesToCopy);
            FscUnmapBuffer(CacheBuffer);

            //
            // Advance to the next physical byte offset, which now will be page
            // aligned, and adjust our other loop variables.
            //

            ByteOffset = (ByteOffset + PAGE_SIZE) & ~(PAGE_SIZE - 1);
            UserBuffer = (PUCHAR)UserBuffer + BytesToCopy;
            BytesRemaining -= BytesToCopy;

        } while (BytesRemaining > 0);

    } else {

        //
        // Lock the user's buffer into memory if necessary.
        //

        IoLockUserBuffer(Irp,
            IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length);

        //
        // Transfer the head of the request if it's not page aligned.
        //

        if (BYTE_OFFSET(ByteOffset) != 0) {

            PartialIoLength = PAGE_SIZE - BYTE_OFFSET(ByteOffset);

            ASSERT(PartialIoLength < BytesRemaining);

            //
            // Map the physical byte offset into the cache.
            //

            status = FscMapBuffer(CacheExtension, Irp, ByteOffset, FALSE,
                &CacheBuffer);

            if (!NT_SUCCESS(status)) {
                return status;
            }

            //
            // Copy the bytes from the cache page and unmap the cache buffer.
            //

            RtlCopyMemory(UserBuffer, CacheBuffer, PartialIoLength);
            FscUnmapBuffer(CacheBuffer);

            //
            // Advance to the next physical byte offset, which now will be page
            // aligned.
            //

            BytesRemaining -= PartialIoLength;
            ByteOffset += PartialIoLength;
            BufferByteOffset = PartialIoLength;

        } else {
            BufferByteOffset = 0;
        }

        ASSERT(BYTE_OFFSET(ByteOffset) == 0);

        //
        // Transfer the body and tail of the request using the file system
        // cache to handle the tail page.
        //

        status = FscPartiallyCachedRead(CacheExtension, Irp, ByteOffset,
            BytesRemaining, BufferByteOffset, NonCachedEndOfFileTransfer);

        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    //
    // If the file is open for synchronous I/O, then we need to update the
    // current file position.
    //

    FileObject = IrpSp->FileObject;

    if (MiIsFlagSet(FileObject->Flags, FO_SYNCHRONOUS_IO)) {
        FileObject->CurrentByteOffset.QuadPart =
            IrpSp->Parameters.Read.ByteOffset.QuadPart + ReadLength;
    }

    //
    // Fill in the number of bytes actually read.
    //

    Irp->IoStatus.Information = ReadLength;

    return STATUS_SUCCESS;
}

VOID
FscInvalidateBlocks(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN ULONG BlockNumber,
    IN ULONG EndingBlockNumber
    )
/*++

Routine Description:

    This routine invalidates any buffers in the supplied byte range for the
    supplied cache extension.

Arguments:

    CacheExtension - Specifies the cache extension to invalidate.

    BlockNumber - Specifies the block number to start invalidating buffers from.

    EndingBlockNumber - Specifies the block number, inclusive, to stop
        invalidating buffers from.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    PLIST_ENTRY NextListEntry;
    PFSCACHE_ELEMENT Element;

    MI_LOCK_MM(&OldIrql);

    NextListEntry = FscLruList.Blink;

    while (NextListEntry != &FscLruList) {

        Element = CONTAINING_RECORD(NextListEntry, FSCACHE_ELEMENT, ListEntry);
        NextListEntry = Element->ListEntry.Blink;

        //
        // If we find an element with an empty cache extension, then the element
        // doesn't reference valid data.  All free elements are at the front of
        // the LRU list, so we know that we can stop the search now.
        //

        if (Element->CacheExtension == NULL) {
            break;
        }

        //
        // Does this element hold data from the given cache extension and block
        // number range and is the element idle?
        //

        if ((Element->CacheExtension == CacheExtension) &&
            (Element->BlockNumber >= BlockNumber) &&
            (Element->BlockNumber <= EndingBlockNumber) &&
            (Element->UsageCount == 0)) {

            ASSERT(!Element->DeletePending);
            ASSERT(Element->UsageCount == 0);

            //
            // We found a cache element with the desired attributes.  Mark the
            // element as free and move it to the beginning of the LRU list.
            //

            Element->CacheExtension = NULL;

            RemoveEntryList(&Element->ListEntry);
            InsertHeadList(&FscLruList, &Element->ListEntry);

            //
            // Release another waiter for a free element if necessary.
            //

            if (!IsListEmpty(&FscWaitingForElementEvent.Header.WaitListHead)) {
                KeSetEvent(&FscWaitingForElementEvent, 0, FALSE);
            }
        }
    }

    MI_UNLOCK_MM(OldIrql);
}

VOID
FscInvalidateDevice(
    IN PFSCACHE_EXTENSION CacheExtension
    )
/*++

Routine Description:

    This routine invalidates any buffers for the supplied cache extension.

Arguments:

    CacheExtension - Specifies the cache extension to invalidate.

Return Value:

    None.

--*/
{
    //
    // Invalidate all blocks for the supplied cache extension.
    //

    FscInvalidateBlocks(CacheExtension, 0, MAXULONG);
}

VOID
FscInvalidateByteRange(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN ULONGLONG ByteOffset,
    IN ULONG Length
    )
/*++

Routine Description:

    This routine invalidates any buffers in the supplied byte range for the
    supplied cache extension.

    This routine assumes that it is called from within an exclusive writer lock
    for the supplied cache extension.  No buffers from the supplied cache
    extension map be actively mapped.

Arguments:

    CacheExtension - Specifies the cache extension to invalidate.

    ByteOffset - Specifies the byte offset to start invalidating buffers from.

    Length - Specifies the number of bytes to invalidate.

Return Value:

    None.

--*/
{
    ULONG BlockNumber;
    ULONG EndingBlockNumber;

    ASSERT(Length != 0);

    BlockNumber = FscByteOffsetToBlockNumber(ByteOffset);
    EndingBlockNumber = FscByteOffsetToBlockNumber(ByteOffset + Length - 1);

    FscInvalidateBlocks(CacheExtension, BlockNumber, EndingBlockNumber);
}

VOID
FscInvalidateIdleBlocks(
    VOID
    )
/*++

Routine Description:

    This routine invalidates any buffers that are not currently marked as busy.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    PLIST_ENTRY NextListEntry;
    PFSCACHE_ELEMENT Element;

    MI_LOCK_MM(&OldIrql);

    NextListEntry = FscLruList.Blink;

    while (NextListEntry != &FscLruList) {

        Element = CONTAINING_RECORD(NextListEntry, FSCACHE_ELEMENT, ListEntry);
        NextListEntry = Element->ListEntry.Blink;

        //
        // If we find an element with an empty cache extension, then the element
        // doesn't reference valid data.  All free elements are at the front of
        // the LRU list, so we know that we can stop the search now.
        //

        if (Element->CacheExtension == NULL) {
            break;
        }

        //
        // Is the element idle?
        //

        if (Element->UsageCount == 0) {

            ASSERT(!Element->DeletePending);

            //
            // We found a cache element with the desired attributes.  Mark the
            // element as free and move it to the beginning of the LRU list.
            //

            Element->CacheExtension = NULL;

            RemoveEntryList(&Element->ListEntry);
            InsertHeadList(&FscLruList, &Element->ListEntry);

            //
            // Release another waiter for a free element if necessary.
            //

            if (!IsListEmpty(&FscWaitingForElementEvent.Header.WaitListHead)) {
                KeSetEvent(&FscWaitingForElementEvent, 0, FALSE);
            }
        }
    }

    MI_UNLOCK_MM(OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\mmx\addrsup.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    addrsup.c

Abstract:

    This module implements routines to manipulate the virtual address
    descriptor tree.

--*/

#include "mi.h"

VOID
MiReorderTree (
    IN PMMADDRESS_NODE Node,
    IN OUT PMMADDRESS_NODE *Root
    );

VOID
MiReorderTree (
    IN PMMADDRESS_NODE Node,
    IN OUT PMMADDRESS_NODE *Root
    )
/*++

Routine Description:

    This function reorders the Node tree by applying various splay functions
    to the tree. This is a local function that is called by the insert Node
    routine.

Arguments:

    Node - Supplies a pointer to a virtual address descriptor.

Return Value:

    None.

--*/
{
    PMMADDRESS_NODE GrandParent;
    PMMADDRESS_NODE Parent;
    PMMADDRESS_NODE SplayNode;

    //
    // Reorder Node tree to make it as balanced as possible with as little
    // work as possible.
    //

    SplayNode = Node;

    while (SplayNode != *Root) {

        Parent = SplayNode->Parent;
        if (Parent == *Root) {

            //
            // Splay node's parent is the root of the tree. Rotate the tree
            // left or right depending on whether the splay node is the left
            // of right child of its parent.
            //
            // Pictorially:
            //
            //            Right                 Left
            //
            //          P        X          P          X
            //         / \      / \        / \        / \
            //        X   C -> A   P      C   X  ->  P   A
            //       / \          / \        / \    / \
            //      A   B        B   C      B   A  C   B
            //

            *Root = SplayNode;
            SplayNode->Parent = (PMMADDRESS_NODE)NULL;
            Parent->Parent = SplayNode;
            if (SplayNode == Parent->LeftChild) {

                //
                // Splay node is the left child of its parent. Rotate tree
                // right.
                //

                Parent->LeftChild = SplayNode->RightChild;
                if (SplayNode->RightChild) {
                    SplayNode->RightChild->Parent = Parent;
                }
                SplayNode->RightChild = Parent;
            } else {

                //
                // Splay node is the right child of its parent. Rotate tree
                // left.
                //

                Parent->RightChild = SplayNode->LeftChild;
                if (SplayNode->LeftChild) {
                    SplayNode->LeftChild->Parent = Parent;
                }
                SplayNode->LeftChild = Parent;
            }
            break;
        } else {
            GrandParent = Parent->Parent;
            if ((SplayNode == Parent->LeftChild) &&
               (Parent == GrandParent->LeftChild)) {

                //
                // Both the splay node and the parent node are left children
                // of their parents. Rotate tree right and make the parent
                // the root of the new subtree.
                //
                // Pictorially:
                //
                //        G                 P
                //       / \              /   \
                //      P   D            X     G
                //     / \       ->     / \   / \
                //    X   C            A   B C   D
                //   / \
                //  A   B
                //

                if (GrandParent == *Root) {
                    *Root = Parent;
                    Parent->Parent = (PMMADDRESS_NODE)NULL;
                } else {
                    Parent->Parent = GrandParent->Parent;
                    if (GrandParent == GrandParent->Parent->LeftChild) {
                        GrandParent->Parent->LeftChild = Parent;
                    } else {
                        GrandParent->Parent->RightChild = Parent;
                    }
                }
                GrandParent->LeftChild = Parent->RightChild;
                if (Parent->RightChild) {
                    Parent->RightChild->Parent = GrandParent;
                }
                GrandParent->Parent = Parent;
                Parent->RightChild = GrandParent;
                SplayNode = Parent;
            } else if ((SplayNode == Parent->RightChild) &&
                      (Parent == GrandParent->RightChild)) {

                //
                // Both the splay node and the parent node are right children
                // of their parents. Rotate tree left and make the parent
                // the root of the new subtree.
                //
                // Pictorially:
                //
                //        G                 P
                //       / \              /   \
                //      D   P            G     X
                //         / \   ->     / \   / \
                //        C   X        D   C B   A
                //           / \
                //          A   B
                //

                if (GrandParent == *Root) {
                    *Root = Parent;
                    Parent->Parent = (PMMADDRESS_NODE)NULL;
                } else {
                    Parent->Parent = GrandParent->Parent;
                    if (GrandParent == GrandParent->Parent->LeftChild) {
                        GrandParent->Parent->LeftChild = Parent;
                    } else {
                        GrandParent->Parent->RightChild = Parent;
                    }
                }
                GrandParent->RightChild = Parent->LeftChild;
                if (Parent->LeftChild) {
                    Parent->LeftChild->Parent = GrandParent;
                }
                GrandParent->Parent = Parent;
                Parent->LeftChild = GrandParent;
                SplayNode = Parent;
            } else if ((SplayNode == Parent->LeftChild) &&
                      (Parent == GrandParent->RightChild)) {

                //
                // Splay node is the left child of its parent and parent is
                // the right child of its parent. Rotate tree left and make
                // splay node the root of the new subtree.
                //
                // Pictorially:
                //
                //      G                 X
                //     / \              /   \
                //    A   P            G     P
                //       / \    ->    / \   / \
                //      X   D        A   B C   D
                //     / \
                //    B   C
                //

                if (GrandParent == *Root) {
                    *Root = SplayNode;
                    SplayNode->Parent = (PMMADDRESS_NODE)NULL;
                } else {
                    SplayNode->Parent = GrandParent->Parent;
                    if (GrandParent == GrandParent->Parent->LeftChild) {
                        GrandParent->Parent->LeftChild = SplayNode;
                    } else {
                        GrandParent->Parent->RightChild = SplayNode;
                    }
                }
                Parent->LeftChild = SplayNode->RightChild;
                if (SplayNode->RightChild) {
                    SplayNode->RightChild->Parent = Parent;
                }
                GrandParent->RightChild = SplayNode->LeftChild;
                if (SplayNode->LeftChild) {
                    SplayNode->LeftChild->Parent = GrandParent;
                }
                Parent->Parent = SplayNode;
                GrandParent->Parent = SplayNode;
                SplayNode->LeftChild = GrandParent;
                SplayNode->RightChild = Parent;
            } else {

                //
                // Splay node is the right child of its parent and parent is
                // the left child of its parent. Rotate tree right and make
                // splay node the root of the new subtree.
                //
                // Pictorially:
                //
                //       G                 X
                //      / \              /   \
                //     P   A            P     G
                //    / \        ->    / \   / \
                //   D   X            D   C B   A
                //      / \
                //     C   B
                //

                if (GrandParent == *Root) {
                    *Root = SplayNode;
                    SplayNode->Parent = (PMMADDRESS_NODE)NULL;
                } else {
                    SplayNode->Parent = GrandParent->Parent;
                    if (GrandParent == GrandParent->Parent->LeftChild) {
                        GrandParent->Parent->LeftChild = SplayNode;
                    } else {
                        GrandParent->Parent->RightChild = SplayNode;
                    }
                }
                Parent->RightChild = SplayNode->LeftChild;
                if (SplayNode->LeftChild) {
                    SplayNode->LeftChild->Parent = Parent;
                }
                GrandParent->LeftChild = SplayNode->RightChild;
                if (SplayNode->RightChild) {
                    SplayNode->RightChild->Parent = GrandParent;
                }
                Parent->Parent = SplayNode;
                GrandParent->Parent = SplayNode;
                SplayNode->LeftChild = Parent;
                SplayNode->RightChild = GrandParent;
            }
        }
    }
    return;
}

PMMADDRESS_NODE
FASTCALL
MiGetNextNode (
    IN PMMADDRESS_NODE Node
    )
/*++

Routine Description:

    This function locates the virtual address descriptor which contains
    the address range which logically follows the specified address range.

Arguments:

    Node - Supplies a pointer to a virtual address descriptor.

Return Value:

    Returns a pointer to the virtual address descriptor containing the
    next address range, NULL if none.

--*/
{
    PMMADDRESS_NODE Next;
    PMMADDRESS_NODE Parent;
    PMMADDRESS_NODE Left;

    Next = Node;

    if (Next->RightChild == (PMMADDRESS_NODE)NULL) {

        while ((Parent = Next->Parent) != (PMMADDRESS_NODE)NULL) {

            //
            // Locate the first ancestor of this node of which this
            // node is the left child of and return that node as the
            // next element.
            //

            if (Parent->LeftChild == Next) {
                return Parent;
            }

            Next = Parent;

        }

        return (PMMADDRESS_NODE)NULL;
    }

    //
    // A right child exists, locate the left most child of that right child.
    //

    Next = Next->RightChild;

    while ((Left = Next->LeftChild) != (PMMADDRESS_NODE)NULL) {
        Next = Left;
    }
    return Next;

}

PMMADDRESS_NODE
FASTCALL
MiGetPreviousNode (
    IN PMMADDRESS_NODE Node
    )
/*++

Routine Description:

    This function locates the virtual address descriptor which contains
    the address range which logically precedes the specified virtual
    address descriptor.

Arguments:

    Node - Supplies a pointer to a virtual address descriptor.

Return Value:

    Returns a pointer to the virtual address descriptor containing the
    next address range, NULL if none.

--*/
{
    PMMADDRESS_NODE Previous;

    Previous = Node;

    if (Previous->LeftChild == (PMMADDRESS_NODE)NULL) {


        while (Previous->Parent != (PMMADDRESS_NODE)NULL) {

            //
            // Locate the first ancestor of this node of which this
            // node is the right child of and return that node as the
            // Previous element.
            //

            if (Previous->Parent->RightChild == Previous) {
                return Previous->Parent;
            }

            Previous = Previous->Parent;

        }
        return (PMMADDRESS_NODE)NULL;
    }

    //
    // A left child exists, locate the right most child of that left child.
    //

    Previous = Previous->LeftChild;
    while (Previous->RightChild != (PMMADDRESS_NODE)NULL) {
        Previous = Previous->RightChild;
    }
    return Previous;
}

PMMADDRESS_NODE
FASTCALL
MiGetFirstNode (
    IN PMMADDRESS_NODE Root
    )
/*++

Routine Description:

    This function locates the virtual address descriptor which contains
    the address range which logically is first within the address space.

Arguments:

    None.

Return Value:

    Returns a pointer to the virtual address descriptor containing the
    first address range, NULL if none.

--*/
{
    PMMADDRESS_NODE First;

    First = Root;

    if (First == (PMMADDRESS_NODE)NULL) {
        return (PMMADDRESS_NODE)NULL;
    }

    while (First->LeftChild != (PMMADDRESS_NODE)NULL) {
        First = First->LeftChild;
    }

    return First;
}

VOID
FASTCALL
MiInsertNode (
    IN PMMADDRESS_NODE Node,
    IN OUT PMMADDRESS_NODE *Root
    )
/*++

Routine Description:

    This function inserts a virtual address descriptor into the tree and
    reorders the splay tree as appropriate.

Arguments:

    Node - Supplies a pointer to a virtual address descriptor


Return Value:

    None.

--*/
{
    ULONG Level = 0;
    PMMADDRESS_NODE Parent;

    //
    // Initialize virtual address descriptor child links.
    //

    Node->LeftChild = (PMMADDRESS_NODE)NULL;
    Node->RightChild = (PMMADDRESS_NODE)NULL;

    //
    // If the tree is empty, then establish this virtual address descriptor
    // as the root of the tree.
    // Otherwise descend the tree to find the correct place to
    // insert the descriptor.
    //

    Parent = *Root;
    if (!Parent) {
        *Root = Node;
        Node->Parent = (PMMADDRESS_NODE)NULL;
    } else {

        for (;;) {

            Level += 1;
            if (Level == 15) {
                MiReorderTree(Parent, Root);
            }

            //
            // If the starting address for this virtual address descriptor
            // is less than the parent starting address, then
            // follow the left child link. Else follow the right child link.
            //

            if (Node->StartingVpn < Parent->StartingVpn) {

                //
                // Starting address of the virtual address descriptor is less
                // than the parent starting virtual address.
                // Follow left child link if not null. Otherwise
                // insert the descriptor as the left child of the parent and
                // reorder the tree.
                //

                if (Parent->LeftChild) {
                    Parent = Parent->LeftChild;
                } else {
                    Parent->LeftChild = Node;
                    Node->Parent = Parent;
                    // MiReorderTree(Node, Root);
                    break;
                }
            } else {

                //
                // Starting address of the virtual address descriptor is greater
                // than the parent starting virtual address.
                // Follow right child link if not null. Otherwise
                // insert the descriptor as the right child of the parent and
                // reorder the tree.
                //

                if (Parent->RightChild) {
                    Parent = Parent->RightChild;
                } else {
                    Parent->RightChild = Node;
                    Node->Parent = Parent;
                    // MiReorderTree(Node, Root);
                    break;
                }
            }
        }
    }
    return;
}

VOID
FASTCALL
MiRemoveNode (
    IN PMMADDRESS_NODE Node,
    IN OUT PMMADDRESS_NODE *Root
    )
/*++

Routine Description:

    This function removes a virtual address descriptor from the tree and
    reorders the splay tree as appropriate.

Arguments:

    Node - Supplies a pointer to a virtual address descriptor.

Return Value:

    None.

--*/
{

    PMMADDRESS_NODE LeftChild;
    PMMADDRESS_NODE RightChild;
    PMMADDRESS_NODE SplayNode;


    LeftChild = Node->LeftChild;
    RightChild = Node->RightChild;


    //
    // If the Node is the root of the tree, then establish new root. Else
    // isolate splay case and perform splay tree transformation.
    //

    if (Node == *Root) {

        //
        // This Node is the root of the tree. There are four cases to
        // handle:
        //
        //  1. the descriptor has no children
        //  2. the descriptor has a left child but no right child
        //  3. the descriptor has a right child but no left child
        //  4. the descriptor has both a right child and a left child
        //

        if (LeftChild) {
            if (RightChild) {

                //
                // The descriptor has both a left child and a right child.
                //

                if (LeftChild->RightChild) {

                    //
                    // The left child has a right child. Make the right most
                    // descendent of the right child of the left child the
                    // new root of the tree.
                    //
                    // Pictorially:
                    //
                    //      R          R
                    //      |          |
                    //      X          Z
                    //     / \        / \
                    //    A   B  ->  A   B
                    //     \          \
                    //      .          .
                    //       \
                    //        Z
                    //

                    SplayNode = LeftChild->RightChild;
                    while (SplayNode->RightChild) {
                        SplayNode = SplayNode->RightChild;
                    }
                    *Root = SplayNode;
                    SplayNode->Parent->RightChild = SplayNode->LeftChild;
                    if (SplayNode->LeftChild) {
                        SplayNode->LeftChild->Parent = SplayNode->Parent;
                    }
                    SplayNode->Parent = (PMMADDRESS_NODE)NULL;
                    LeftChild->Parent = SplayNode;
                    RightChild->Parent = SplayNode;
                    SplayNode->LeftChild = LeftChild;
                    SplayNode->RightChild = RightChild;
                } else if (RightChild->LeftChild) {

                    //
                    // The right child has a left child. Make the left most
                    // descendent of the left child of the right child the
                    // new root of the tree.
                    //
                    // Pictorially:
                    //
                    //      R          R
                    //      |          |
                    //      X          Z
                    //     / \        / \
                    //    A   B  ->  A   B
                    //       /          /
                    //      .          .
                    //     /
                    //    Z
                    //

                    SplayNode = RightChild->LeftChild;
                    while (SplayNode->LeftChild) {
                        SplayNode = SplayNode->LeftChild;
                    }
                    *Root = SplayNode;
                    SplayNode->Parent->LeftChild = SplayNode->RightChild;
                    if (SplayNode->RightChild) {
                        SplayNode->RightChild->Parent = SplayNode->Parent;
                    }
                    SplayNode->Parent = (PMMADDRESS_NODE)NULL;
                    LeftChild->Parent = SplayNode;
                    RightChild->Parent = SplayNode;
                    SplayNode->LeftChild = LeftChild;
                    SplayNode->RightChild = RightChild;
                } else {

                    //
                    // The left child of the descriptor does not have a right child,
                    // and the right child of the descriptor does not have a left
                    // child. Make the left child of the descriptor the new root of
                    // the tree.
                    //
                    // Pictorially:
                    //
                    //      R          R
                    //      |          |
                    //      X          A
                    //     / \        / \
                    //    A   B  ->  .   B
                    //   /          /
                    //  .
                    //

                    *Root = LeftChild;
                    LeftChild->Parent = (PMMADDRESS_NODE)NULL;
                    LeftChild->RightChild = RightChild;
                    LeftChild->RightChild->Parent = LeftChild;
                }
            } else {

                //
                // The descriptor has a left child, but does not have a right child.
                // Make the left child the new root of the tree.
                //
                // Pictorially:
                //
                //       R      R
                //       |      |
                //       X  ->  A
                //      /
                //     A
                //

                *Root = LeftChild;
                LeftChild->Parent = (PMMADDRESS_NODE)NULL;
            }
        } else if (RightChild) {

            //
            // The descriptor has a right child, but does not have a left child.
            // Make the right child the new root of the tree.
            //
            // Pictorially:
            //
            //       R         R
            //       |         |
            //       X    ->   A
            //        \
            //         A
            //

            *Root = RightChild;
            RightChild->Parent = (PMMADDRESS_NODE)NULL;
            while (RightChild->LeftChild) {
                RightChild = RightChild->LeftChild;
            }
        } else {

            //
            // The descriptor has neither a left child nor a right child. The
            // tree will be empty after removing the descriptor.
            //
            // Pictorially:
            //
            //      R      R
            //      |  ->
            //      X
            //

            *Root = NULL;
        }
    } else if (LeftChild) {
        if (RightChild) {

            //
            // The descriptor has both a left child and a right child.
            //

            if (LeftChild->RightChild) {

                //
                // The left child has a right child. Make the right most
                // descendent of the right child of the left child the new
                // root of the subtree.
                //
                // Pictorially:
                //
                //        P      P
                //       /        \
                //      X          X
                //     / \        / \
                //    A   B  or  A   B
                //     \          \
                //      .          .
                //       \          \
                //        Z          Z
                //
                //           |
                //           v
                //
                //        P      P
                //       /        \
                //      Z          Z
                //     / \        / \
                //    A   B  or  A   B
                //     \          \
                //      .          .
                //

                SplayNode = LeftChild->RightChild;
                while (SplayNode->RightChild) {
                    SplayNode = SplayNode->RightChild;
                }
                SplayNode->Parent->RightChild = SplayNode->LeftChild;
                if (SplayNode->LeftChild) {
                    SplayNode->LeftChild->Parent = SplayNode->Parent;
                }
                SplayNode->Parent = Node->Parent;
                if (Node == Node->Parent->LeftChild) {
                    Node->Parent->LeftChild = SplayNode;
                } else {
                    Node->Parent->RightChild = SplayNode;
                }
                LeftChild->Parent = SplayNode;
                RightChild->Parent = SplayNode;
                SplayNode->LeftChild = LeftChild;
                SplayNode->RightChild = RightChild;
            } else if (RightChild->LeftChild) {

                //
                // The right child has a left child. Make the left most
                // descendent of the left child of the right child the
                // new root of the subtree.
                //
                // Pictorially:
                //
                //        P      P
                //       /        \
                //      X          X
                //     / \        / \
                //    A   B  or  A   B
                //       /          /
                //      .          .
                //     /          /
                //    Z          Z
                //
                //           |
                //           v
                //
                //        P      P
                //       /        \
                //      Z          Z
                //     / \        / \
                //    A   B  or  A   B
                //       /          /
                //      .          .
                //

                SplayNode = RightChild->LeftChild;
                while (SplayNode->LeftChild) {
                    SplayNode = SplayNode->LeftChild;
                }
                SplayNode->Parent->LeftChild = SplayNode->RightChild;
                if (SplayNode->RightChild) {
                    SplayNode->RightChild->Parent = SplayNode->Parent;
                }
                SplayNode->Parent = Node->Parent;
                if (Node == Node->Parent->LeftChild) {
                    Node->Parent->LeftChild = SplayNode;
                } else {
                    Node->Parent->RightChild = SplayNode;
                }
                LeftChild->Parent = SplayNode;
                RightChild->Parent = SplayNode;
                SplayNode->LeftChild = LeftChild;
                SplayNode->RightChild = RightChild;
            } else {

                //
                // The left child of the descriptor does not have a right child,
                // and the right child of the descriptor does node have a left
                // child. Make the left child of the descriptor the new root of
                // the subtree.
                //
                // Pictorially:
                //
                //        P      P
                //       /        \
                //      X          X
                //     / \        / \
                //    A   B  or  A   B
                //   /          /
                //  .          .
                //
                //           |
                //           v
                //
                //        P      P
                //       /        \
                //      A          A
                //     / \        / \
                //    .   B  or  .   B
                //   /          /
                //

                SplayNode = LeftChild;
                SplayNode->Parent = Node->Parent;
                if (Node == Node->Parent->LeftChild) {
                    Node->Parent->LeftChild = SplayNode;
                } else {
                    Node->Parent->RightChild = SplayNode;
                }
                SplayNode->RightChild = RightChild;
                RightChild->Parent = SplayNode;
            }
        } else {

            //
            // The descriptor has a left child, but does not have a right child.
            // Make the left child the new root of the subtree.
            //
            // Pictorially:
            //
            //        P   P
            //       /     \
            //      X   or  X
            //     /       /
            //    A       A
            //
            //          |
            //          v
            //
            //        P   P
            //       /     \
            //      A       A
            //

            LeftChild->Parent = Node->Parent;
            if (Node == Node->Parent->LeftChild) {
                Node->Parent->LeftChild = LeftChild;
            } else {
                Node->Parent->RightChild = LeftChild;
            }
        }
    } else if (RightChild) {

        //
        // descriptor has a right child, but does not have a left child. Make
        // the right child the new root of the subtree.
        //
        // Pictorially:
        //
        //        P   P
        //       /     \
        //      X   or  X
        //       \       \
        //        A       A
        //
        //          |
        //          v
        //
        //        P   P
        //       /     \
        //      A       A
        //

        RightChild->Parent = Node->Parent;
        if (Node == Node->Parent->LeftChild) {
            Node->Parent->LeftChild = RightChild;
        } else {
            Node->Parent->RightChild = RightChild;
        }
    } else {

        //
        // The descriptor has neither a left child nor a right child. Delete
        // the descriptor from the tree and adjust its parent right or left
        // link.
        //
        // Pictorially:
        //
        //        P   P
        //       /     \
        //      X   or  X
        //
        //          |
        //          v
        //
        //        P   P
        //

        if (Node == Node->Parent->LeftChild) {
            Node->Parent->LeftChild = (PMMADDRESS_NODE)NULL;
        } else {
            Node->Parent->RightChild = (PMMADDRESS_NODE)NULL;
        }
    }
    return;
}

PMMADDRESS_NODE
FASTCALL
MiLocateAddressInTree (
    IN ULONG_PTR Vpn,
    IN PMMADDRESS_NODE *Root
    )
/*++

Routine Description:

    The function locates the virtual address descriptor which describes
    a given address.

Arguments:

    Vpn - Supplies the virtual page number to locate a descriptor
                     for.

Return Value:

    Returns a pointer to the virtual address descriptor which contains
    the supplied virtual address or NULL if none was located.

--*/
{

    PMMADDRESS_NODE Parent;
    ULONG Level = 0;

    Parent = *Root;

    for (;;) {

        if (Parent == (PMMADDRESS_NODE)NULL) {
            return (PMMADDRESS_NODE)NULL;
        }

        if (Level == 20) {

            //
            // There are 20 nodes above this point, reorder the
            // tree with this node as the root.
            //

            MiReorderTree(Parent, Root);
        }

        if (Vpn < Parent->StartingVpn) {
            Parent = Parent->LeftChild;
            Level += 1;

        } else if (Vpn > Parent->EndingVpn) {
            Parent = Parent->RightChild;
            Level += 1;

        } else {

            //
            // The address is within the start and end range.
            //

            return Parent;
        }
    }
}

PMMADDRESS_NODE
MiCheckForConflictingNode (
    IN ULONG_PTR StartVpn,
    IN ULONG_PTR EndVpn,
    IN PMMADDRESS_NODE Root
    )
/*++

Routine Description:

    The function determines if any addresses between a given starting and
    ending address is contained within a virtual address descriptor.

Arguments:

    StartVpn - Supplies the virtual address to locate a containing
                      descriptor.

    EndVpn - Supplies the virtual address to locate a containing
                      descriptor.

Return Value:

    Returns a pointer to the first conflicting virtual address descriptor
    if one is found, otherwise a NULL value is returned.

--*/
{
    PMMADDRESS_NODE Node;

    Node = Root;

    for (;;) {

        if (Node == (PMMADDRESS_NODE)NULL) {
            return (PMMADDRESS_NODE)NULL;
        }

        if (StartVpn > Node->EndingVpn) {
            Node = Node->RightChild;

        } else if (EndVpn < Node->StartingVpn) {
            Node = Node->LeftChild;

        } else {

            //
            // The starting address is less than or equal to the end VA
            // and the ending address is greater than or equal to the
            // start va.  Return this node.
            //

            return Node;
        }
    }
}

PVOID
MiFindEmptyAddressRangeInTree (
    IN SIZE_T SizeOfRange,
    IN ULONG_PTR Alignment,
    IN PMMADDRESS_NODE Root,
    OUT PMMADDRESS_NODE *PreviousVad
    )
/*++

Routine Description:

    The function examines the virtual address descriptors to locate
    an unused range of the specified size and returns the starting
    address of the range.

Arguments:

    SizeOfRange - Supplies the size in bytes of the range to locate.

    Alignment - Supplies the alignment for the address.  Must be
                 a power of 2 and greater than the page_size.

    Root - Supplies the root of the tree to search through.

    PreviousVad - Supplies the Vad which is before this the found
                  address range.

Return Value:

    Returns the starting address of a suitable range.

--*/
{
    PMMADDRESS_NODE Node;
    PMMADDRESS_NODE NextNode;
    ULONG_PTR AlignmentVpn;

    AlignmentVpn = Alignment >> PAGE_SHIFT;

    //
    // Locate the Node with the lowest starting address.
    //

    SizeOfRange = (SizeOfRange + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
    ASSERT (SizeOfRange != 0);

    Node = Root;

    if (Node == (PMMADDRESS_NODE)NULL) {
        return MM_LOWEST_USER_ADDRESS;
    }
    while (Node->LeftChild != (PMMADDRESS_NODE)NULL) {
        Node = Node->LeftChild;
    }

    //
    // Check to see if a range exists between the lowest address VAD
    // and lowest user address.
    //

    if (Node->StartingVpn > MI_VA_TO_VPN (MM_LOWEST_USER_ADDRESS)) {
        if ( SizeOfRange <
            (Node->StartingVpn - MI_VA_TO_VPN (MM_LOWEST_USER_ADDRESS))) {

            *PreviousVad = NULL;
            return MM_LOWEST_USER_ADDRESS;
        }
    }

    for (;;) {

        NextNode = MiGetNextNode (Node);

        if (NextNode != (PMMADDRESS_NODE)NULL) {

            if (SizeOfRange <=
                ((ULONG_PTR)NextNode->StartingVpn -
                                MI_ROUND_TO_SIZE(1 + Node->EndingVpn,
                                                 AlignmentVpn))) {

                //
                // Check to ensure that the ending address aligned upwards
                // is not greater than the starting address.
                //

                if ((ULONG_PTR)NextNode->StartingVpn >
                        MI_ROUND_TO_SIZE(1 + Node->EndingVpn,
                                         AlignmentVpn)) {

                    *PreviousVad = Node;
                    return (PMMADDRESS_NODE)MI_ROUND_TO_SIZE(
                                   (ULONG_PTR)MI_VPN_TO_VA_ENDING(Node->EndingVpn),
                                          Alignment);
                }
            }

        } else {

            //
            // No more descriptors, check to see if this fits into the remainder
            // of the address space.
            //

            if ((((ULONG_PTR)Node->EndingVpn + MI_VA_TO_VPN(X64K)) <
                    MI_VA_TO_VPN (MM_HIGHEST_VAD_ADDRESS))
                        &&
                (SizeOfRange <=
                    ((ULONG_PTR)MM_HIGHEST_VAD_ADDRESS -
                         (ULONG_PTR)MI_ROUND_TO_SIZE(
                         (ULONG_PTR)MI_VPN_TO_VA(Node->EndingVpn), Alignment)))) {

                *PreviousVad = Node;
                return (PMMADDRESS_NODE)MI_ROUND_TO_SIZE(
                                    (ULONG_PTR)MI_VPN_TO_VA_ENDING(Node->EndingVpn),
                                    Alignment);
            } else {
                ExRaiseStatus (STATUS_NO_MEMORY);
            }
        }
        Node = NextNode;
    }
}

PVOID
MiFindEmptyAddressRangeDownTree (
    IN SIZE_T SizeOfRange,
    IN PVOID HighestAddressToEndAt,
    IN ULONG_PTR Alignment,
    IN PMMADDRESS_NODE Root
    )
/*++

Routine Description:

    The function examines the virtual address descriptors to locate
    an unused range of the specified size and returns the starting
    address of the range.  The function examines from the high
    addresses down and ensures that starting address is less than
    the specified address.

Arguments:

    SizeOfRange - Supplies the size in bytes of the range to locate.

    HighestAddressToEndAt - Supplies the virtual address that limits
                            the value of the ending address.  The ending
                            address of the located range must be less
                            than this address.

    Alignment - Supplies the alignment for the address.  Must be
                 a power of 2 and greater than the page_size.

    Root - Supplies the root of the tree to search through.

Return Value:

    Returns the starting address of a suitable range.

--*/
{
    PMMADDRESS_NODE Node;
    PMMADDRESS_NODE PreviousNode;
    ULONG_PTR AlignedEndingVa;
    PVOID OptimalStart;
    ULONG_PTR OptimalStartVpn;
    ULONG_PTR HighestVpn;
    ULONG_PTR AlignmentVpn;

    SizeOfRange = MI_ROUND_TO_SIZE (SizeOfRange, PAGE_SIZE);

    ASSERT (HighestAddressToEndAt != NULL);
    ASSERT (HighestAddressToEndAt <= (PVOID)((ULONG_PTR)MM_HIGHEST_VAD_ADDRESS + 1));

    HighestVpn = MI_VA_TO_VPN (HighestAddressToEndAt);

    //
    // Locate the Node with the highest starting address.
    //

    OptimalStart = (PVOID)(MI_ALIGN_TO_SIZE(
                           (((ULONG_PTR)HighestAddressToEndAt + 1) - SizeOfRange),
                           Alignment));
    Node = Root;

    if (Node == (PMMADDRESS_NODE)NULL) {

        //
        // The tree is empty, any range is okay.
        //

        return (PMMADDRESS_NODE)(OptimalStart);
    }

    //
    // See if an empty slot exists to hold this range, locate the largest
    // element in the tree.
    //

    while (Node->RightChild != (PMMADDRESS_NODE)NULL) {
        Node = Node->RightChild;
    }

    //
    // Check to see if a range exists between the highest address VAD
    // and the highest address to end at.
    //

    AlignedEndingVa = (ULONG_PTR)MI_ROUND_TO_SIZE ((ULONG_PTR)MI_VPN_TO_VA_ENDING (Node->EndingVpn),
                                               Alignment);

    if (AlignedEndingVa < (ULONG_PTR)HighestAddressToEndAt) {

        if ( SizeOfRange < ((ULONG_PTR)HighestAddressToEndAt - AlignedEndingVa)) {

            return (PMMADDRESS_NODE)(MI_ALIGN_TO_SIZE(
                                  ((ULONG_PTR)HighestAddressToEndAt - SizeOfRange),
                                  Alignment));
        }
    }

    //
    // Walk the tree backwards looking for a fit.
    //

    OptimalStartVpn = MI_VA_TO_VPN (OptimalStart);
    AlignmentVpn = MI_VA_TO_VPN (Alignment);

    for (;;) {

        PreviousNode = MiGetPreviousNode (Node);

        if (PreviousNode != (PMMADDRESS_NODE)NULL) {

            //
            // Is the ending Va below the top of the address to end at.
            //

            if (PreviousNode->EndingVpn < OptimalStartVpn) {
                if ((SizeOfRange >> PAGE_SHIFT) <=
                    ((ULONG_PTR)Node->StartingVpn -
                    (ULONG_PTR)MI_ROUND_TO_SIZE(1 + PreviousNode->EndingVpn,
                                            AlignmentVpn))) {

                    //
                    // See if the optimal start will fit between these
                    // two VADs.
                    //

                    if ((OptimalStartVpn > PreviousNode->EndingVpn) &&
                        (HighestVpn < Node->StartingVpn)) {
                        return (PMMADDRESS_NODE)(OptimalStart);
                    }

                    //
                    // Check to ensure that the ending address aligned upwards
                    // is not greater than the starting address.
                    //

                    if ((ULONG_PTR)Node->StartingVpn >
                            (ULONG_PTR)MI_ROUND_TO_SIZE(1 + PreviousNode->EndingVpn,
                                                    AlignmentVpn)) {

                        return (PMMADDRESS_NODE)MI_ALIGN_TO_SIZE(
                                            (ULONG_PTR)MI_VPN_TO_VA (Node->StartingVpn) - SizeOfRange,
                                            Alignment);
                    }
                }
            }
        } else {

            //
            // No more descriptors, check to see if this fits into the remainder
            // of the address space.
            //

            if (Node->StartingVpn > MI_VA_TO_VPN (MM_LOWEST_USER_ADDRESS)) {
                if ((SizeOfRange >> PAGE_SHIFT) <=
                    ((ULONG_PTR)Node->StartingVpn - MI_VA_TO_VPN (MM_LOWEST_USER_ADDRESS))) {

                    //
                    // See if the optimal start will fit between these
                    // two VADs.
                    //

                    if (HighestVpn < Node->StartingVpn) {
                        return (PMMADDRESS_NODE)(OptimalStart);
                    }

                    return (PMMADDRESS_NODE)MI_ALIGN_TO_SIZE(
                                  (ULONG_PTR)MI_VPN_TO_VA (Node->StartingVpn) - SizeOfRange,
                                  Alignment);
                }
            } else {
                ExRaiseStatus (STATUS_NO_MEMORY);
            }
        }
        Node = PreviousNode;
    }
}

#if DBG
VOID
NodeTreeWalk (
    PMMADDRESS_NODE Start
    )

{
    if (Start == (PMMADDRESS_NODE)NULL) {
        return;
    }

    NodeTreeWalk(Start->LeftChild);

    DbgPrint("Node at 0x%lx start 0x%lx  end 0x%lx \n",
                    (ULONG_PTR)Start, MI_VPN_TO_VA(Start->StartingVpn),
                    (ULONG_PTR)MI_VPN_TO_VA (Start->EndingVpn) | (PAGE_SIZE - 1));


    NodeTreeWalk(Start->RightChild);
    return;
}
#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\mmx\mi.h ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    mi.h

Abstract:

    This module contains the private data structures and procedure
    prototypes for the memory management system.

--*/

#ifndef _MI_
#define _MI_

#include <ntos.h>
#include <bldr.h>
#include <ki.h>
#include <pool.h>
#include <pci.h>
#include <av.h>
#include <xlaunch.h>

//
// Break DEVKIT functionality into CONSOLE versus ARCADE features with the
// following macro.
//

#if defined(DEVKIT) && !defined(ARCADE)
#define CONSOLE_DEVKIT
#endif

//
// DBG sensitive DbgPrint wrapper.
//

#if DBG
#define MiDbgPrint(x)               DbgPrint x
#else
#define MiDbgPrint(x)
#endif

//
// Bit flag macros.
//

#define MiIsFlagSet(flagset, flag)              (((flagset) & (flag)) != 0)
#define MiIsFlagClear(flagset, flag)            (((flagset) & (flag)) == 0)

//
// Returns the index of the supplied element relative to the supplied base
// address.
//

#define ARRAY_ELEMENT_NUMBER(base, type, element)                             \
    ((ULONG)(((type *)(element)) - (base)))

//
// Returns the number of elements in the supplied array.
//

#define ARRAY_ELEMENTS(array)                                                 \
    (sizeof((array)) / sizeof((array)[0]))

//
// Shortcuts to common multiplication factors.
//

#define X64K                        ((ULONG)64*1024)
#define X1024K                      ((ULONG)1024*1024)

//
// Define the NVIDIA NV2A constants for controlling the last accessible byte of
// memory.  These are accessed from the host bridge device.
//

#define CR_CPU_MEMTOP_LIMIT         0x87
#define CR_CPU_MEMTOP_LIMIT_64MB    0x03
#define CR_CPU_MEMTOP_LIMIT_128MB   0x07

//
// Define the lowest physical page available in the system.
//

#define MM_LOWEST_PHYSICAL_PAGE     0x00000

//
// Define the highest physical page available in the system.
//

#if defined(ARCADE)
#define MM_HIGHEST_PHYSICAL_PAGE    0x07FFF
#elif defined(DEVKIT)
#define MM_HIGHEST_PHYSICAL_PAGE    MmHighestPhysicalPage
#else
#define MM_HIGHEST_PHYSICAL_PAGE    0x03FFF
#endif

//
// Define the physical page that's reserved for use by D3D.  D3D needs the first
// ULONG in the system in order to initialize the push buffer, so we reserve the
// entire page for D3D's use.
//

#define MM_D3D_PHYSICAL_PAGE        0x00000

//
// Define the highest physical page that's allowed for a contiguous memory
// allocation.  All contiguous memory allocations are constrained to the memory
// available on a retail system.
//
// Additionally, the NVIDIA NV2A can use up to 128K of instance memory that must
// be allocated from the top of memory.  In order to leave the maximum amount of
// instance memory available from quick boot to quick boot, we don't allow
// anybody to allocate contiguous pages from the upper 128K (64K of which is
// already consumed by the PFN database).  This prevents somebody from
// persisting a contiguous allocation in this range across a quick reboot and
// screwing up the next title.
//
// For ARCADE, we require a 128K PFN database to describe the 128M retail
// system.  With 64K reserved for NVIDIA NV2A instance memory, this pushes the
// contiguous memory limit to 196K from the top of memory.
//

#ifdef ARCADE
#define MM_CONTIGUOUS_MEMORY_LIMIT  0x07FCF
#else
#define MM_CONTIGUOUS_MEMORY_LIMIT  0x03FDF
#endif

//
// Define the first physical page that's used to hold the PFN database.  The
// page number is selected such that the first 64M's half of the database sits
// at the end of the first 64M and the second 64M's half of the database sits
// at the start of the second 64M.
//
// For ARCADE, the PFN database is always 128K.  NVIDIA NV2A instance memory
// must be located in the top 128K of memory, but we only reserve 64K of
// instance memory.  The PFN database is instead located below the reserved
// instance memory.
//

#ifdef ARCADE
#define MM_DATABASE_PHYSICAL_PAGE   0x07FD0
#else
#define MM_DATABASE_PHYSICAL_PAGE   0x03FF0
#endif

//
// Define the bottom of the region that is reserved at system startup for NVIDIA
// NV2A instance memory.  These pages may be made available for other use when
// the D3D library calls MmClaimGpuInstanceMemory.
//
// For ARCADE, the PFN database is always 128K.  This would consume all of the
// usable pages for NVIDIA NV2A instance memory, so instead this instance memory
// is reserved at the top of memory and the PFN database is located below this
// instance memory.
//

#ifdef ARCADE
#define MM_INSTANCE_PHYSICAL_PAGE   0x07FF0
#else
#define MM_INSTANCE_PHYSICAL_PAGE   0x03FE0
#endif

#define MM_INSTANCE_PAGE_COUNT      16

//
// Define the first physical page that's available only on a development kit
// system.
//

#define MM_64M_PHYSICAL_PAGE        0x04000

//
// Define the write combine system memory aperture that's exposed by the NVIDIA
// NV2A.  PAGE_VIDEO allocations are mapped through this aperture instead of the
// standard system memory aperture starting at physical page zero.
//

#define MM_WRITE_COMBINE_APERTURE   0x40000

//
// Fixed addresses for memory manager data structures.
//

#define MM_PHYSICAL_MAP_BASE        ((ULONG)0x80000000)
#define MM_PHYSICAL_MAP_END         ((ULONG)0x8FFFFFFF)

#define MM_DEVKIT_PTE_BASE          ((ULONG)0xB0000000)
#define MM_DEVKIT_PTE_END           ((ULONG)0xBFFFFFFF)

#define MM_PAGE_TABLES_BASE         ((ULONG)0xC0000000)
#define MM_PAGE_TABLES_END          ((ULONG)0xC03FFFFF)

#define MM_DEBUG_VA                 ((ULONG)0xC0800000)

#define MM_SYSTEM_PTE_BASE          ((ULONG)0xD0000000)
#define MM_SYSTEM_PTE_END           ((ULONG)0xEFFFFFFF)

#define MM_DEVICE_WC_BASE           ((ULONG)0xF0000000)
#define MM_DEVICE_WC_END            ((ULONG)0xF7FFFFFF)
#define MM_DEVICE_UC_BASE           ((ULONG)0xF8000000)
#define MM_DEVICE_UC_END            ((ULONG)0xFFBFFFFF)

#define MM_HIGHEST_VAD_ADDRESS      ((PVOID)((ULONG_PTR)MM_HIGHEST_USER_ADDRESS - X64K))
#define MM_USER_ADDRESS_RANGE_LIMIT 0xFFFFFFFF
#define MM_MAXIMUM_ZERO_BITS        21

//
// Page color support.
//

#define MM_NUMBER_OF_COLORS_BITS    5
#define MM_NUMBER_OF_COLORS         (1 << MM_NUMBER_OF_COLORS_BITS)
#define MM_NUMBER_OF_COLORS_MASK    (MM_NUMBER_OF_COLORS - 1)

typedef ULONG MMCOLOR;

//
// Macros to lock and unlock the memory manager data structures.
//

#define MI_LOCK_MM(OldIrql)         (*OldIrql) = KeRaiseIrqlToDpcLevel()
#define MI_UNLOCK_MM(OldIrql)       KeLowerIrql(OldIrql)
#define MI_ASSERT_LOCK_MM()         ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)

#define MI_UNLOCK_MM_AND_THEN_WAIT(OldIrql) {                                 \
    PKTHREAD Thread = KeGetCurrentThread();                                   \
    MI_ASSERT_LOCK_MM();                                                      \
    ASSERT((OldIrql) <= APC_LEVEL);                                           \
    Thread->WaitIrql = (OldIrql);                                             \
    Thread->WaitNext = TRUE;                                                  \
}

//
// Page table entry data structure as overloaded by the memory manager.
//

typedef struct _MMPTE {
    union {
        ULONG Long;
        HARDWARE_PTE Hard;
        struct {
            ULONG Valid : 1;
            ULONG OneEntry : 1;
            ULONG NextEntry : 30;
        } List;
    };
} MMPTE, *PMMPTE;

#define PTE_PER_PAGE                (PAGE_SIZE / sizeof(MMPTE))
#define PDE_PER_PAGE                (PAGE_SIZE / sizeof(MMPTE))

//
// Define masks for fields within the PTE.
//

#define MM_PTE_VALID_MASK           0x00000001
#define MM_PTE_WRITE_MASK           0x00000002
#define MM_PTE_OWNER_MASK           0x00000004
#define MM_PTE_WRITE_THROUGH_MASK   0x00000008
#define MM_PTE_CACHE_DISABLE_MASK   0x00000010
#define MM_PTE_ACCESS_MASK          0x00000020
#define MM_PTE_DIRTY_MASK           0x00000040
#define MM_PTE_LARGE_PAGE_MASK      0x00000080
#define MM_PTE_GLOBAL_MASK          0x00000100
#define MM_PTE_GUARD_MASK           0x00000200
#define MM_PTE_NEXT_ENTRY_MASK      0xFFFFFFFC

//
// Bit fields to or into PTE to make a PTE valid based on the protection field
// of the invalid PTE.
//
// Note that for guard pages, we overload the supervisor/user PTE flag to mean
// that the page is a guard page.  Because we never go to user mode, this flag
// is effectively unused by hardware.
//

#define MM_PTE_NOACCESS             0x000   // not expressable on i386
#define MM_PTE_READONLY             0x000
#define MM_PTE_READWRITE            MM_PTE_WRITE_MASK
#define MM_PTE_NOCACHE              MM_PTE_CACHE_DISABLE_MASK
#define MM_PTE_GUARD                MM_PTE_GUARD_MASK
#define MM_PTE_CACHE                0x000

//
// Define the set of bits that MiMakePteProtectionMask will return.  This mask
// can be used to check if an existing PTE has compatible attributes.
//

#define MM_PTE_PROTECTION_MASK      0x0000021B

//
// Define the set of bits that MiMakeSystemPteProtectionMask will return.  This
// mask can be used to check if an existing PTE has compatible attributes.
//

#define MM_SYSTEM_PTE_PROTECTION_MASK 0x0000001B

//
// Define the end of list marker for the linked list contained in a PTE.
//

#define MM_EMPTY_PTE_LIST           ((ULONG)0x3FFFFFFF)

//
// Enumeration to identify what a busy page frame is being used for.
//

typedef enum _MMPFN_BUSY_TYPE {
    MmUnknownUsage,
    MmStackUsage,
    MmVirtualPageTableUsage,
    MmSystemPageTableUsage,
    MmPoolUsage,
    MmVirtualMemoryUsage,
    MmSystemMemoryUsage,
    MmImageUsage,
    MmFsCacheUsage,
    MmContiguousUsage,
    MmDebuggerUsage,
    MmMaximumUsage
} MMPFN_BUSY_TYPE;

//
// PFN free page element.
//
// The low bit of PackedPfnFlink must be clear so that the overloaded
// MMPFN.Pte.Valid is clear.
//
// The low bit of PackedPfnBlink must be clear so that the overloaded
// MMPFN.Busy.Busy is clear.
//

typedef struct _MMPFNFREE {
    USHORT PackedPfnFlink;              // low bit must be clear
    USHORT PackedPfnBlink;              // low bit must be clear
} MMPFNFREE, *PMMPFNFREE;

//
// PFN database element.
//

typedef struct _MMPFN {
    union {
        ULONG Long;
        MMPTE Pte;
        MMPFNFREE Free;
        struct {
            ULONG LockCount : 16;       // low bit must be clear
            ULONG Busy : 1;
            ULONG Reserved : 1;
            ULONG PteIndex : 10;
            ULONG BusyType : 4;
        } Busy;
        struct {
            ULONG LockCount : 16;       // low bit must be clear
            ULONG Busy : 1;
            ULONG ElementIndex : 11;
            ULONG BusyType : 4;
        } FsCache;
        struct {
            ULONG LockCount : 16;       // low bit must be clear
            ULONG Busy : 1;
            ULONG NumberOfUsedPtes : 11;
            ULONG BusyType : 4;
        } Directory;
    };
} MMPFN, *PMMPFN;

#define MM_PFN_NULL                 ((PFN_NUMBER)-1)
#define MM_PACKED_PFN_NULL          ((USHORT)0xFFFE)

#define MM_PFN_DATABASE             ((PMMPFN)MI_CONVERT_PFN_TO_PHYSICAL(MM_DATABASE_PHYSICAL_PAGE))

#define MI_PFN_ELEMENT(pfn)         (&MM_PFN_DATABASE[pfn])
#define MI_PFN_NUMBER(pmmpfn)       ((PFN_NUMBER)ARRAY_ELEMENT_NUMBER(MM_PFN_DATABASE, MMPFN, pmmpfn))

//
// Define the basic unit for the MMPFN.Busy.LockCount field.  The low bit must
// always be clear in order for the entry to not be viewed by the processor as a
// valid PTE, so we always increment or decrement the LockCount field in units
// of two.
//

#define MI_LOCK_COUNT_UNIT          2
#define MI_LOCK_COUNT_MAXIMUM       0xFFFE

//
// PFN region descriptor.
//

typedef struct _MMPFNREGION {
    MMPFNFREE FreePagesByColor[MM_NUMBER_OF_COLORS];
    PFN_COUNT AvailablePages;
} MMPFNREGION, *PMMPFNREGION;

#ifdef CONSOLE_DEVKIT
#define MI_PFN_REGION_SHIFT         14
#define MI_PAGES_IN_PFN_REGION      (1 << MI_PFN_REGION_SHIFT)
#define MI_BYTES_IN_PFN_REGION      (MI_PAGES_IN_PFN_REGION << PAGE_SHIFT)
#define MI_NUMBER_OF_REGIONS        (MM_PAGES_IN_PHYSICAL_MAP / MI_PAGES_IN_PFN_REGION)
#define MI_PFN_REGION(pfn)          (MmPfnRegions[((pfn) >> MI_PFN_REGION_SHIFT)])
#else
#define MI_PAGES_IN_PFN_REGION      (MM_PAGES_IN_PHYSICAL_MAP)
#define MI_BYTES_IN_PFN_REGION      (MI_PAGES_IN_PFN_REGION << PAGE_SHIFT)
#define MI_PFN_REGION(pfn)          &MmRetailPfnRegion
#endif

//
// Define the function signature for a routine that removes a page with the
// supplied busy type code and target page table entry address.
//

typedef
PFN_NUMBER
(FASTCALL *PMMREMOVE_PAGE_ROUTINE)(
    IN MMPFN_BUSY_TYPE BusyType,
    IN PMMPTE TargetPte
    );

//
// Page table entry range structure.
//

typedef struct _MMPTERANGE {
    MMPTE HeadPte;
    PMMPTE FirstCommittedPte;
    PMMPTE LastCommittedPte;
    PMMPTE LastReservedPte;
    PFN_COUNT *AvailablePages;
    PMMREMOVE_PAGE_ROUTINE RemovePageRoutine;
} MMPTERANGE, *PMMPTERANGE;

//
// Address node.
//

typedef struct _MMADDRESS_NODE {
    ULONG_PTR StartingVpn;
    ULONG_PTR EndingVpn;
    struct _MMADDRESS_NODE *Parent;
    struct _MMADDRESS_NODE *LeftChild;
    struct _MMADDRESS_NODE *RightChild;
} MMADDRESS_NODE, *PMMADDRESS_NODE;

//
// Virtual address descriptor.
//

#ifdef __cplusplus
typedef struct _MMVAD : public MMADDRESS_NODE {
#else
typedef struct _MMVAD {
    MMADDRESS_NODE;
#endif
    ULONG AllocationProtect;
} MMVAD, *PMMVAD;

//
// Macros to guard access to the virtual memory space.
//

#define MI_LOCK_ADDRESS_SPACE()     RtlEnterCriticalSectionAndRegion(&MmAddressSpaceLock)
#define MI_UNLOCK_ADDRESS_SPACE()   RtlLeaveCriticalSectionAndRegion(&MmAddressSpaceLock)

//
// Macros to convert between virtual address and virtual page numbers.
//

#define MI_VA_TO_PAGE(va)           ((ULONG_PTR)(va) >> PAGE_SHIFT)
#define MI_VA_TO_VPN(va)            ((ULONG_PTR)(va) >> PAGE_SHIFT)
#define MI_VPN_TO_VA(vpn)           (PVOID)((vpn) << PAGE_SHIFT)
#define MI_VPN_TO_VA_ENDING(vpn)    (PVOID)(((vpn) << PAGE_SHIFT) | (PAGE_SIZE - 1))

//++
//ULONG
//MI_ROUND_TO_SIZE (
//    IN ULONG LENGTH,
//    IN ULONG ALIGNMENT
//    )
//
// Routine Description:
//
//    The ROUND_TO_SIZE macro takes a LENGTH in bytes and rounds it up to a
//    multiple of the alignment.
//
// Arguments:
//
//    LENGTH - LENGTH in bytes to round up to.
//
//    ALIGNMENT - alignment to round to, must be a power of 2, e.g, 2**n.
//
// Return Value:
//
//    Returns the LENGTH rounded up to a multiple of the alignment.
//
//--

#define MI_ROUND_TO_SIZE(LENGTH,ALIGNMENT)                                    \
    (((LENGTH) + ((ALIGNMENT) - 1)) & ~((ALIGNMENT) - 1))

//++
//PVOID
//MI_ALIGN_TO_SIZE (
//    IN PVOID VA
//    IN ULONG ALIGNMENT
//    );
//
// Routine Description:
//
//    The MI_ALIGN_TO_SIZE macro takes a virtual address and returns a
//    virtual address for that page with the specified alignment.
//
// Arguments:
//
//    VA - Virtual address.
//
//    ALIGNMENT - alignment to round to, must be a power of 2, e.g, 2**n.
//
// Return Value:
//
//    Returns the aligned virtual address.
//
//--

#define MI_ALIGN_TO_SIZE(VA,ALIGNMENT)                                        \
    ((PVOID)((ULONG_PTR)(VA) & ~((ULONG_PTR) ALIGNMENT - 1)))

//++
//VOID
//MI_WRITE_PTE (
//    IN PMMPTE PointerPte,
//    IN MMPTE PteContents
//    );
//
// Routine Description:
//
//    MI_WRITE_PTE fills in the specified PTE with the specified contents.
//
// Arguments
//
//    PointerPte - Supplies a PTE to fill.
//
//    PteContents - Supplies the contents to put in the PTE.
//
// Return Value:
//
//    None.
//
//--

#define MI_WRITE_PTE(_PointerPte, _PteContents)                               \
    (*(_PointerPte) = (_PteContents))

//++
//VOID
//MI_WRITE_ZERO_PTE (
//    IN PMMPTE PointerPte
//    );
//
// Routine Description:
//
//    MI_WRITE_PTE fills in the specified PTE with zero.
//
// Arguments
//
//    PointerPte - Supplies a PTE to fill.
//
// Return Value:
//
//    None.
//
//--

#define MI_WRITE_ZERO_PTE(_PointerPte)                                        \
    ((_PointerPte)->Long = 0)

//++
//VOID
//MI_WRITE_AND_FLUSH_PTE(
//    IN PMMPTE PointerPte,
//    IN MMPTE PteContents
//    );
//
// Routine Description:
//
//    MI_WRITE_AND_FLUSH_PTE fills in the specified PTE with the specified
//    contents and invalidates the TLB line associated with the page.
//
// Arguments:
//
//    PointerPte - Supplies a PTE to fill.
//
//    PteContents - Supplies the contents to put in the PTE.
//
// Return Value:
//
//    None.
//
//--

__inline
VOID
MI_WRITE_AND_FLUSH_PTE(
    PMMPTE PointerPte,
    MMPTE PteContents
    )
{
    MI_WRITE_PTE(PointerPte, PteContents);

    __asm {
        mov     eax, PointerPte
        shl     eax, 10             ; eax = MiGetVirtualAddressMappedByPte(eax)
        invlpg  [eax]
    }
}

//++
//VOID
//MI_FLUSH_VA(
//    IN PVOID VirtualAddress
//    );
//
// Routine Description:
//
//    MI_FLUSH_VA invalidates the TLB line associated with the page.
//
// Arguments:
//
//    VirtualAddress - Supplies the virtual address to flush.
//
// Return Value:
//
//    None.
//
//--

__inline
VOID
MI_FLUSH_VA(
    PVOID VirtualAddress
    )
{
    __asm {
        mov     ecx, VirtualAddress
        invlpg  [ecx]
    }
}

//++
//VOID
//MI_DISABLE_CACHING (
//    IN MMPTE PTE
//    );
//
// Routine Description:
//
//    This macro takes a valid PTE and sets the caching state to be
//    disabled.  This is performed by setting the PCD and PWT bits in the PTE.
//
//    Semantics of the overlap between PCD, PWT, and the
//    USWC memory type in the MTRR are:
//
//    PCD   PWT   Mtrr Mem Type      Effective Memory Type
//     1     0    USWC               USWC
//     1     1    USWC               UC
//
//    Since an effective memory type of UC is desired here,
//    the WT bit is set.
//
// Arguments
//
//    PTE - Supplies a pointer to the valid PTE.
//
// Return Value:
//
//    None.
//
//--

#define MI_DISABLE_CACHING(PTE) {                                             \
    ((PTE).Hard.CacheDisable = 1);                                            \
    ((PTE).Hard.WriteThrough = 1);                                            \
}

//++
//VOID
//MI_SET_PTE_WRITE_COMBINE (
//    IN MMPTE PTE
//    );
//
// Routine Description:
//
//    This macro takes a valid PTE and enables WriteCombining as the
//    caching state.  Note that the PTE bits may only be set this way
//    if the Page Attribute Table is present and the PAT has been
//    initialized to provide Write Combining.
//
//    If either of the above conditions is not satisfied, then
//    the macro enables WEAK UC (PCD = 1, PWT = 0) in the PTE.
//
// Arguments
//
//    PTE - Supplies a valid PTE.
//
// Return Value:
//
//    None.
//
//--

#define MI_SET_PTE_WRITE_COMBINE(PTE) {                                       \
    ((PTE).Hard.CacheDisable = 0);                                            \
    ((PTE).Hard.WriteThrough = 1);                                            \
}

//++
//PMMPTE
//MiGetPdeAddress (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPdeAddress returns the address of the PDE which maps the
//    given virtual address.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the PDE for.
//
// Return Value:
//
//    The address of the PDE.
//
//--

#define MiGetPdeAddress(va) ((PMMPTE)(((((ULONG)(va)) >> 22) << 2) + PDE_BASE))

//++
//PMMPTE
//MiGetPteAddress (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPteAddress returns the address of the PTE which maps the
//    given virtual address.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the PTE for.
//
// Return Value:
//
//    The address of the PTE.
//
//--

#define MiGetPteAddress(va) ((PMMPTE)(((((ULONG)(va)) >> 12) << 2) + PTE_BASE))

//++
//ULONG
//MiGetPdeOffset (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPdeOffset returns the offset into a page directory
//    for a given virtual address.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the offset for.
//
// Return Value:
//
//    The offset into the page directory table the corresponding PDE is at.
//
//--

#define MiGetPdeOffset(va) (((ULONG)(va)) >> 22)

//++
//ULONG
//MiGetPteOffset (
//    IN PVOID va
//    );
//
// Routine Description:
//
//    MiGetPteOffset returns the offset into a page table page
//    for a given virtual address.
//
// Arguments
//
//    Va - Supplies the virtual address to locate the offset for.
//
// Return Value:
//
//    The offset into the page table page table the corresponding PTE is at.
//
//--

#define MiGetPteOffset(va) ((((ULONG)(va)) << 10) >> 22)

//++
//PVOID
//MiGetVirtualAddressMappedByPde (
//    IN PMMPTE PTE
//    );
//
// Routine Description:
//
//    MiGetVirtualAddressMappedByPde returns the virtual address
//    which is mapped by a given PDE address.
//
// Arguments
//
//    PDE - Supplies the PDE to get the virtual address for.
//
// Return Value:
//
//    Virtual address mapped by the PDE.
//
//--

#define MiGetVirtualAddressMappedByPde(PDE) ((PVOID)((ULONG)(PDE) << 20))

//++
//PVOID
//MiGetVirtualAddressMappedByPte (
//    IN PMMPTE PTE
//    );
//
// Routine Description:
//
//    MiGetVirtualAddressMappedByPte returns the virtual address
//    which is mapped by a given PTE address.
//
// Arguments
//
//    PTE - Supplies the PTE to get the virtual address for.
//
// Return Value:
//
//    Virtual address mapped by the PTE.
//
//--

#define MiGetVirtualAddressMappedByPte(PTE) ((PVOID)((ULONG)(PTE) << 10))

//++
//LOGICAL
//MiIsPteOnPdeBoundary (
//    IN PVOID PTE
//    );
//
// Routine Description:
//
//    MiIsPteOnPdeBoundary returns TRUE if the PTE is
//    on a page directory entry boundary.
//
// Arguments
//
//    PTE - Supplies the PTE to check.
//
// Return Value:
//
//    TRUE if on a 4MB PDE boundary, FALSE if not.
//
//--

#define MiIsPteOnPdeBoundary(PTE) (((ULONG_PTR)(PTE) & (PAGE_SIZE - 1)) == 0)

//++
//MMPTE
//MiGetValidKernelPdeBits (
//    VOID
//    );
//
// Routine Description:
//
//    MiGetValidKernelPde returns the basic bits for a valid kernel PDE.
//
// Return Value:
//
//    The bits for the PDE.
//
//--

#define MiGetValidKernelPdeBits() \
    (MM_PTE_VALID_MASK | MM_PTE_WRITE_MASK | MM_PTE_OWNER_MASK | MM_PTE_DIRTY_MASK | MM_PTE_ACCESS_MASK)

//++
//MMPTE
//MiGetValidKernelPteBits (
//    VOID
//    );
//
// Routine Description:
//
//    MiGetValidKernelPde returns the basic bits for a valid kernel PTE.
//
// Return Value:
//
//    The bits for the PTE.
//
//--

#define MiGetValidKernelPteBits() \
    (MM_PTE_VALID_MASK | MM_PTE_WRITE_MASK | MM_PTE_DIRTY_MASK | MM_PTE_ACCESS_MASK)

//++
//MMPTE
//MiGetValidCachePteBits (
//    VOID
//    );
//
// Routine Description:
//
//    MiGetValidKernelPde returns the basic bits for a valid cache PTE.
//
// Return Value:
//
//    The bits for the PTE.
//
//--

#define MiGetValidCachePteBits() \
    (MM_PTE_VALID_MASK | MM_PTE_WRITE_MASK | MM_PTE_ACCESS_MASK)

//++
//BOOLEAN
//MI_IS_PHYSICAL_ADDRESS (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro determines if a given virtual address is really a
//    physical address.
//
// Arguments
//
//    VA - Supplies the virtual address.
//
// Return Value:
//
//    FALSE if it is not a physical address, TRUE if it is.
//
//--

#define MI_IS_PHYSICAL_ADDRESS(Va) \
    (((ULONG)(Va) - MM_PHYSICAL_MAP_BASE) <= (MM_PHYSICAL_MAP_END - MM_PHYSICAL_MAP_BASE))

//++
//ULONG
//MI_CONVERT_PHYSICAL_TO_PFN (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro converts a physical address (see MI_IS_PHYSICAL_ADDRESS)
//    to its corresponding physical frame number.
//
// Arguments
//
//    VA - Supplies a pointer to the physical address.
//
// Return Value:
//
//    Returns the PFN for the page.
//
//--

#define MI_CONVERT_PHYSICAL_TO_PFN(Va)                                        \
    (((ULONG)(Va) & (MM_BYTES_IN_PHYSICAL_MAP - 1)) >> PAGE_SHIFT)

//++
//PCHAR
//MI_CONVERT_PFN_TO_PHYSICAL (
//    IN PAGE_FRAME_NUMBER Pfn
//    );
//
// Routine Description:
//
//    This macro converts a physical frame number to its corresponding
//    physical address.
//
// Arguments
//
//    Pfn - Supplies the physical frame number.
//
// Return Value:
//
//    Returns the physical address for the page number.
//
//--

#define MI_CONVERT_PFN_TO_PHYSICAL(Pfn)                                       \
    ((PCHAR)MM_SYSTEM_PHYSICAL_MAP + ((ULONG)(Pfn) << PAGE_SHIFT))

//++
//BOOLEAN
//MI_IS_SYSTEM_PTE_ADDRESS (
//    IN PVOID VA
//    );
//
// Routine Description:
//
//    This macro takes a virtual address and determines if
//    it is an address in the system PTE space.
//
// Arguments
//
//    VA - Supplies a virtual address.
//
// Return Value:
//
//    TRUE if the address is in the system PTE space, FALSE if not.
//
//--

#define MI_IS_SYSTEM_PTE_ADDRESS(Va)                                          \
    (((ULONG)(Va) - MM_SYSTEM_PTE_BASE) <= (MM_SYSTEM_PTE_END - MM_SYSTEM_PTE_BASE))

//++
//BOOLEAN
//MI_SIZE_OF_MDL (
//    IN PVOID BASE,
//    IN SIZE_T LENGTH
//    );
//
// Routine Description:
//
//    This function returns the number of bytes required for an MDL for a
//    given buffer and size.
//
// Arguments:
//
//    Base - Supplies the base virtual address for the buffer.
//
//    Length - Supplies the size of the buffer in bytes.
//
// Return Value:
//
//    Returns the number of bytes required to contain the MDL.
//
//--

#define MI_SIZE_OF_MDL(BASE,LENGTH)                                           \
    (sizeof(MDL) + (ADDRESS_AND_SIZE_TO_SPAN_PAGES((BASE), (LENGTH)) * sizeof(PFN_NUMBER)))

//++
//USHORT
//MiPackFreePfn(
//    IN PFN_NUMBER PFN
//    );
//
// Routine Description:
//
//    This function packs a page frame number for storage in the MMPFN free
//    link fields.  The returned number must have the low bit clear in order
//    to make the entry appear as non-busy.
//
// Arguments:
//
//    PFN - Supplies the page frame number.
//
// Return Value:
//
//    Returns the packed form of the page frame number.
//
//--

#define MiPackFreePfn(PFN)                                                \
    ((USHORT)((((PFN_NUMBER)(PFN)) >> MM_NUMBER_OF_COLORS_BITS) << 1))

//++
//PFN_NUMBER
//MiUnpackFreePfn(
//    IN USHORT CPFN,
//    IN ULONG COLOR
//    );
//
// Routine Description:
//
//    This function unpacks a MMPFN free link field to obtain the original
//    page frame number.  The low bit of the packed page frame number will
//    have the low bit clear.
//
// Arguments:
//
//    CPFN - Supplies the packed page frame number.
//
//    COLOR - Supplies the color of the original page frame number.
//
// Return Value:
//
//    Returns the unpacked page frame number.
//
//--

#define MiUnpackFreePfn(CPFN,COLOR)                                           \
    ((((ULONG)(CPFN)) << (MM_NUMBER_OF_COLORS_BITS - 1)) + (ULONG)(COLOR))

//++
//PMMPFN
//MiUnpackFreePfnElement(
//    IN USHORT CPFN,
//    IN ULONG COLOR
//    );
//
// Routine Description:
//
//    This function unpacks a MMPFN free link field to obtain the original
//    page frame element.  The low bit of the packed page frame number will
//    have the low bit clear.
//
// Arguments:
//
//    CPFN - Supplies the packed page frame number.
//
//    COLOR - Supplies the color of the original page frame number.
//
// Return Value:
//
//    Returns the unpacked page frame element.
//
//--

#define MiUnpackFreePfnElement(CPFN,COLOR)                                    \
    MI_PFN_ELEMENT(MiUnpackFreePfn((CPFN),(COLOR)))

//++
//MMCOLOR
//MiGetPfnColor(
//    IN ULONG PFN
//    );
//
// Routine Description:
//
//    This function computes the color of the supplied page frame number.
//
// Arguments:
//
//    PFN - Supplies the page frame number.
//
// Return Value:
//
//    Returns the color of the page frame number.
//
//--

#define MiGetPfnColor(PFN)                                                    \
    ((PFN_NUMBER)(PFN) & (MM_NUMBER_OF_COLORS - 1))

// PVOID
// MiFindEmptyAddressRangeDown (
//    IN ULONG_PTR SizeOfRange,
//    IN PVOID HighestAddressToEndAt,
//    IN ULONG_PTR Alignment
//    )
//
// Routine Description:
//
//    The function examines the virtual address descriptors to locate
//    an unused range of the specified size and returns the starting
//    address of the range.  This routine looks from the top down.
//
// Arguments:
//
//    SizeOfRange - Supplies the size in bytes of the range to locate.
//
//    HighestAddressToEndAt - Supplies the virtual address to begin looking
//                            at.
//
//    Alignment - Supplies the alignment for the address.  Must be
//                 a power of 2 and greater than the page_size.
//
//Return Value:
//
//    Returns the starting address of a suitable range.
//

#define MiFindEmptyAddressRangeDown(SizeOfRange,HighestAddressToEndAt,Alignment) \
               (MiFindEmptyAddressRangeDownTree(                             \
                    (SizeOfRange),                                           \
                    (HighestAddressToEndAt),                                 \
                    (Alignment),                                             \
                    MmVadRoot))

// PMMVAD
// MiGetPreviousVad (
//     IN PMMVAD Vad
//     )
//
// Routine Description:
//
//     This function locates the virtual address descriptor which contains
//     the address range which logically precedes the specified virtual
//     address descriptor.
//
// Arguments:
//
//     Vad - Supplies a pointer to a virtual address descriptor.
//
// Return Value:
//
//     Returns a pointer to the virtual address descriptor containing the
//     next address range, NULL if none.
//
//

#define MiGetPreviousVad(VAD) ((PMMVAD)MiGetPreviousNode((PMMADDRESS_NODE)(VAD)))

// PMMVAD
// MiGetNextVad (
//     IN PMMVAD Vad
//     )
//
// Routine Description:
//
//     This function locates the virtual address descriptor which contains
//     the address range which logically follows the specified address range.
//
// Arguments:
//
//     VAD - Supplies a pointer to a virtual address descriptor.
//
// Return Value:
//
//     Returns a pointer to the virtual address descriptor containing the
//     next address range, NULL if none.
//

#define MiGetNextVad(VAD) ((PMMVAD)MiGetNextNode((PMMADDRESS_NODE)(VAD)))

// PMMVAD
// MiCheckForConflictingVad (
//     IN PVOID StartingAddress,
//     IN PVOID EndingAddress
//     )
//
// Routine Description:
//
//     The function determines if any addresses between a given starting and
//     ending address is contained within a virtual address descriptor.
//
// Arguments:
//
//     StartingAddress - Supplies the virtual address to locate a containing
//                       descriptor.
//
//     EndingAddress - Supplies the virtual address to locate a containing
//                       descriptor.
//
// Return Value:
//
//     Returns a pointer to the first conflicting virtual address descriptor
//     if one is found, otherwise a NULL value is returned.
//

#define MiCheckForConflictingVad(StartingAddress,EndingAddress)           \
    ((PMMVAD)MiCheckForConflictingNode(                                   \
                    MI_VA_TO_VPN(StartingAddress),                        \
                    MI_VA_TO_VPN(EndingAddress),                          \
                    MmVadRoot))

//++
//LOGICAL
//MiIsRetryIoStatus(
//    IN NTSTATUS S
//    );
//
// Routine Description:
//
//    This function tests the supplied status code to see if the error might
//    have been caused by a verifier induced error or by temporarily being out
//    of system resources.
//
// Arguments:
//
//    S - Supplies the status code to test.
//
// Return Value:
//
//    Returns TRUE if the I/O operation should be retried, else FALSE.
//
//--

#define MiIsRetryIoStatus(S)                                                  \
    (((S) == STATUS_INSUFFICIENT_RESOURCES) || ((S) == STATUS_NO_MEMORY))

//
// Routines which operate on the page frame database.
//

VOID
MiInitializePfnDatabase(
    VOID
    );

VOID
MiReinitializePfnDatabase(
    VOID
    );

VOID
FASTCALL
MiInsertPageInFreeList(
    IN PFN_NUMBER PageFrameNumber,
    IN BOOLEAN InsertAtHeadList
    );

VOID
MiInsertPhysicalMemoryInFreeList(
    IN PFN_NUMBER PageFrameNumber,
    IN PFN_NUMBER EndingPageFrameNumberExclusive
    );

VOID
FASTCALL
MiRemovePageFromFreeList(
    IN PFN_NUMBER PageFrameNumber
    );

PFN_NUMBER
FASTCALL
MiRemoveAnyPage(
    IN MMPFN_BUSY_TYPE BusyType,
    IN PMMPTE TargetPte
    );

PFN_NUMBER
FASTCALL
MiRemoveZeroPage(
    IN MMPFN_BUSY_TYPE BusyType,
    IN PMMPTE TargetPte
    );

PFN_NUMBER
FASTCALL
MiRemoveDebuggerPage(
    IN MMPFN_BUSY_TYPE BusyType,
    IN PMMPTE TargetPte
    );

VOID
FASTCALL
MiRelocateBusyPage(
    IN PFN_NUMBER PageFrameNumber
    );

VOID
FASTCALL
MiReleasePageOwnership(
    IN PFN_NUMBER PageFrameNumber
    );

//
// Routines to obtain and release system PTEs.
//

PMMPTE
MiReserveSystemPtes(
    IN PMMPTERANGE PteRange,
    IN PFN_COUNT NumberOfPtes
    );

VOID
MiReleaseSystemPtes(
    IN PMMPTERANGE PteRange,
    IN PMMPTE StartingPte,
    IN PFN_COUNT NumberOfPtes
    );

VOID
FASTCALL
MiZeroAndFlushPtes(
    IN PMMPTE StartingPte,
    IN PFN_COUNT NumberOfPtes
    );

//
// Routines which operate on an address tree.
//

PMMADDRESS_NODE
FASTCALL
MiGetNextNode(
   IN PMMADDRESS_NODE Node
   );

PMMADDRESS_NODE
FASTCALL
MiGetPreviousNode(
   IN PMMADDRESS_NODE Node
   );

VOID
FASTCALL
MiInsertNode(
   IN PMMADDRESS_NODE Node,
   IN OUT PMMADDRESS_NODE *Root
   );

VOID
FASTCALL
MiRemoveNode(
   IN PMMADDRESS_NODE Node,
   IN OUT PMMADDRESS_NODE *Root
   );

PMMADDRESS_NODE
FASTCALL
MiLocateAddressInTree(
   IN ULONG_PTR Vpn,
   IN PMMADDRESS_NODE *Root
   );

PMMADDRESS_NODE
MiCheckForConflictingNode(
   IN ULONG_PTR StartVpn,
   IN ULONG_PTR EndVpn,
   IN PMMADDRESS_NODE Root
   );

PVOID
MiFindEmptyAddressRangeInTree(
   IN SIZE_T SizeOfRange,
   IN ULONG_PTR Alignment,
   IN PMMADDRESS_NODE Root,
   OUT PMMADDRESS_NODE *PreviousVad
   );

PVOID
MiFindEmptyAddressRangeDownTree(
   IN SIZE_T SizeOfRange,
   IN PVOID HighestAddressToEndAt,
   IN ULONG_PTR Alignment,
   IN PMMADDRESS_NODE Root
   );

//
// Routines which operate on the tree of virtual address descriptors.
//

VOID
MiInsertVad(
    IN PMMVAD Vad
    );

VOID
MiRemoveVad(
    IN PMMVAD Vad
    );

PMMVAD
FASTCALL
MiLocateAddress(
    IN PVOID Vad
    );

PVOID
MiFindEmptyAddressRange(
    IN SIZE_T SizeOfRange,
    IN ULONG_PTR Alignment,
    IN ULONG QuickCheck
    );

//
// Miscellaneous routines.
//

PVOID
MiAllocateMappedMemory(
    IN PMMPTERANGE PteRange,
    IN MMPFN_BUSY_TYPE BusyType,
    IN ULONG Protect,
    IN SIZE_T NumberOfBytes,
    IN PMMREMOVE_PAGE_ROUTINE RemovePageRoutine,
    IN BOOLEAN AddBarrierPage
    );

PFN_COUNT
MiFreeMappedMemory(
    IN PMMPTERANGE PteRange,
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes OPTIONAL
    );

BOOLEAN
FASTCALL
MiMakePteProtectionMask(
    IN ULONG Protect,
    OUT PULONG PteProtectionMask
    );

BOOLEAN
FASTCALL
MiMakeSystemPteProtectionMask(
    IN ULONG Protect,
    OUT PMMPTE ProtoPte
    );

ULONG
FASTCALL
MiDecodePteProtectionMask(
    IN ULONG PteProtectionMask
    );

//
// Global data structure.
//

typedef struct _MMGLOBALDATA {
    PMMPFNREGION RetailPfnRegion;
    PMMPTERANGE SystemPteRange;
    PULONG AvailablePages;
    PFN_COUNT *AllocatedPagesByUsage;
    PRTL_CRITICAL_SECTION AddressSpaceLock;
    PMMADDRESS_NODE *VadRoot;
    PMMADDRESS_NODE *VadHint;
    PMMADDRESS_NODE *VadFreeHint;
} MMGLOBALDATA, *PMMGLOBALDATA;

//
// External symbols.
//

extern PFN_COUNT MmNumberOfPhysicalPages;
extern PMMPFNREGION MmPfnRegions[];
extern MMPFNREGION MmRetailPfnRegion;
extern MMPFNREGION MmDeveloperKitPfnRegion;
extern PFN_COUNT MmAvailablePages;
extern PFN_COUNT MmAllocatedPagesByUsage[MmMaximumUsage];
extern RTL_CRITICAL_SECTION MmAddressSpaceLock;
extern SIZE_T MmVirtualMemoryBytesReserved;
extern PMMADDRESS_NODE MmVadRoot;
extern PMMADDRESS_NODE MmVadHint;
extern PMMADDRESS_NODE MmVadFreeHint;
extern MMPTERANGE MmSystemPteRange;
extern MMPTERANGE MmDeveloperKitPteRange;
extern PFSCACHE_ELEMENT FscElementArray;
extern ULONG FscNumberOfCachePages;
extern PMMPTE FscWriteFFsPtes;

#endif  // MI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\mmx\mmfault.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    mmfault.c

Abstract:

    This module contains the handlers for access check, page faults
    and write faults.

--*/

#include "mi.h"

NTSTATUS
MmAccessFault(
    IN BOOLEAN StoreInstruction,
    IN PVOID VirtualAddress,
    IN PVOID TrapInformation
    )
/*++

Routine Description:

    This function is called by the kernel on data or instruction
    access faults.  The access fault was detected due to either
    an access violation, a PTE with the present bit clear, or a
    valid PTE with the dirty bit clear and a write operation.

    Also note that the access violation and the page fault could
    occur because of the Page Directory Entry contents as well.

    This routine determines what type of fault it is and calls
    the appropriate routine to handle the page fault or the write
    fault.

Arguments:

    StoreInstruction - Supplies TRUE (1) if the operation causes a write into
                       memory.  Note this value must be 1 or 0.

    VirtualAddress - Supplies the virtual address which caused the fault.

    TrapInformation - Opaque information about the trap, interpreted by the
                      kernel, not Mm.  Needed to allow fast interlocked access
                      to operate correctly.

Return Value:

    Returns the status of the fault handling operation.  Can be one of:
        - Success.
        - Access Violation.
        - Guard Page Violation.
        - In-page Error.

Environment:

    Kernel mode, APCs disabled.

--*/
{
    NTSTATUS status;
    KIRQL OldIrql;
    PMMPTE PointerPte;
    MMPTE TempPte;
    ULONG PteProtectionMask;
    ULONG Protect;

    //
    // No page fault can be handled at DISPATCH_LEVEL or greater.
    //

    if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {
        status = STATUS_IN_PAGE_ERROR | 0x10000000;
        goto ReturnStatusCode;
    }

    //
    // Determine if this is an access violation or a guard page violation.
    //

    status = STATUS_ACCESS_VIOLATION;

    if ((VirtualAddress >= MM_LOWEST_USER_ADDRESS) &&
        (VirtualAddress <= MM_HIGHEST_VAD_ADDRESS)) {

        MI_LOCK_ADDRESS_SPACE();

        MI_LOCK_MM(&OldIrql);

        if (MiGetPdeAddress(VirtualAddress)->Hard.Valid == 1) {

            PointerPte = MiGetPteAddress(VirtualAddress);
            TempPte = *PointerPte;

            //
            // Check if the PTE is marked committed.  Note that we don't just
            // check the Valid bit because the page may be a PAGE_NOACCESS or
            // PAGE_GUARD protected page.
            //

            if (TempPte.Long != 0) {

                PteProtectionMask = (TempPte.Long & MM_PTE_PROTECTION_MASK);
                Protect = MiDecodePteProtectionMask(PteProtectionMask);

                if (Protect & PAGE_GUARD) {

                    //
                    // This is a guard page.  Clear the guard page protection
                    // for this page and return the correct violation status.
                    //

                    MiMakePteProtectionMask(Protect & ~PAGE_GUARD,
                        &PteProtectionMask);

                    TempPte.Long = ((TempPte.Long & ~MM_PTE_PROTECTION_MASK) |
                        PteProtectionMask);

                    MI_WRITE_AND_FLUSH_PTE(PointerPte, TempPte);

                    status = STATUS_GUARD_PAGE_VIOLATION;
                }
            }
        }

        MI_UNLOCK_MM(OldIrql);

        MI_UNLOCK_ADDRESS_SPACE();
    }

ReturnStatusCode:
    if (!NT_SUCCESS(status) && status != STATUS_GUARD_PAGE_VIOLATION) {
        if (TrapInformation != NULL) {
            MiDbgPrint(("MM: page fault touching %p, trap frame %p, eip %p\n",
                VirtualAddress, TrapInformation,
                ((PKTRAP_FRAME)TrapInformation)->Eip));
        } else {
            MiDbgPrint(("MM: page fault touching %p, trap frame %p\n",
                VirtualAddress, TrapInformation));
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\mmx\mminit.c ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    mminit.c

Abstract:

    This module implements the initialization for the memory management system.

--*/

#include "mi.h"

//
// Export the data structures used by the memory manager implementation.
//
DECLSPEC_RDATA MMGLOBALDATA MmGlobalData = {
    &MmRetailPfnRegion,
    &MmSystemPteRange,
    &MmAvailablePages,
    MmAllocatedPagesByUsage,
    &MmAddressSpaceLock,
    &MmVadRoot,
    &MmVadHint,
    &MmVadFreeHint
};

//
// Stores the physical address of the top byte, not inclusive, of the kernel
// image.
//
DECLSPEC_STICKY ULONG_PTR MmTopOfKernelPhysicalAddress;

//
// Local support.
//

#ifdef DEVKIT
VOID
MiCopyShadowROMDataSection(
    VOID
    );
#endif

#ifdef ALLOC_PRAGMA
#ifdef DEVKIT
#pragma alloc_text(INIT, MiCopyShadowROMDataSection)
#endif
#endif

#ifdef DEVKIT

VOID
MiCopyShadowROMDataSection(
    VOID
    )
/*++

Routine Description:

    This routine takes a snapshot of the initialized .data section from the
    shadow ROM and fixes up the kernel's headers to point at this copy.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    PXDATA_SECTION_HEADER DataSectionHeader;
    PFN_COUNT DataSectionSizeInPages;
    PFN_COUNT PfnDatabaseSizeInPages;
    PUCHAR DataSectionCopy;

    //
    // Compute how many pages will be required to hold the copy of the
    // initialized data.
    //

    DataSectionHeader = (PXDATA_SECTION_HEADER)((PIMAGE_DOS_HEADER)PsNtosImageBase)->e_res2;
    DataSectionSizeInPages = BYTES_TO_PAGES(DataSectionHeader->SizeOfInitializedData);

    //
    // Compute how many pages will be required to hold the PFN database.
    //

    PfnDatabaseSizeInPages = BYTES_TO_PAGES((MM_HIGHEST_PHYSICAL_PAGE + 1) *
        sizeof(MMPFN));

#ifdef ARCADE
    //
    // Always place the copy of the initialized data below the PFN database and
    // NVIDIA NV2A instance memory.
    //

    DataSectionCopy = MI_CONVERT_PFN_TO_PHYSICAL(MM_DATABASE_PHYSICAL_PAGE -
        DataSectionSizeInPages);
#else
    //
    // Figure out where we're going to put the copy of the initialized data.  If
    // this is a machine with 64M of memory, then the copy is placed below the
    // PFN database and NVIDIA NV2A instance memory.  Otherwise, the copy is
    // placed after the PFN database in the upper 64M.
    //

    if (MM_DATABASE_PHYSICAL_PAGE + PfnDatabaseSizeInPages +
        DataSectionSizeInPages >= MM_HIGHEST_PHYSICAL_PAGE) {
        DataSectionCopy = MI_CONVERT_PFN_TO_PHYSICAL(MM_INSTANCE_PHYSICAL_PAGE -
            DataSectionSizeInPages);
    } else {
        DataSectionCopy = MI_CONVERT_PFN_TO_PHYSICAL(MM_DATABASE_PHYSICAL_PAGE +
            PfnDatabaseSizeInPages);
    }
#endif

    //
    // Copy the initialized data to the private copy.
    //

    RtlCopyMemory(DataSectionCopy, (PUCHAR)DataSectionHeader->PointerToRawData,
        DataSectionHeader->SizeOfInitializedData);

    //
    // Update the image header to point at the private copy of the data.
    //

    DataSectionHeader->PointerToRawData = (ULONG_PTR)DataSectionCopy;
}

#endif // DEVKIT

VOID
MmInitSystem(
    VOID
    )
/*++

Routine Description:

    This routine initializes the memory manager.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    MMPTE TempPte;
    PMMPTE PointerPde;
#ifndef ARCADE
    PCI_SLOT_NUMBER PCISlotNumber;
    UCHAR MemoryTop;
#endif
    PMMPTE EndingPointerPde;

    //
    // Verify that the page attribute table (PAT) is initialized correctly by
    // the boot loader.  Specifically, we want to be able to mark pages as USWC.
    //

    ASSERT(RDMSR(0x277) == 0x0007010600070106ui64);

    //
    // Unmap the lower two gigabytes of memory.
    //

    for (PointerPde = MiGetPdeAddress(0); PointerPde <
        MiGetPdeAddress(MM_PHYSICAL_MAP_BASE); PointerPde++) {
        MI_WRITE_ZERO_PTE(PointerPde);
    }

    //
    // Unmap the boot ROM from its identity mapping at the top of memory.
    //

    PointerPde = MiGetPdeAddress((PVOID)MAXULONG_PTR);
    MI_WRITE_ZERO_PTE(PointerPde);

    //
    // Map the MM_DEVICE_WC_BASE window.
    //

    TempPte.Long = MiGetValidKernelPteBits();
    TempPte.Hard.LargePage = 1;
    TempPte.Hard.PageFrameNumber = MM_DEVICE_WC_BASE >> PAGE_SHIFT;
    MI_SET_PTE_WRITE_COMBINE(TempPte);

    for (PointerPde = MiGetPdeAddress(MM_DEVICE_WC_BASE); PointerPde <=
        MiGetPdeAddress(MM_DEVICE_WC_END); PointerPde++) {
        MI_WRITE_PTE(PointerPde, TempPte);
        TempPte.Long += PAGE_SIZE_LARGE;
    }

    //
    // Map the MM_DEVICE_UC_BASE window.
    //

    TempPte.Hard.PageFrameNumber = MM_DEVICE_UC_BASE >> PAGE_SHIFT;
    MI_DISABLE_CACHING(TempPte);

    for (PointerPde = MiGetPdeAddress(MM_DEVICE_UC_BASE); PointerPde <=
        MiGetPdeAddress(MM_DEVICE_UC_END); PointerPde++) {
        MI_WRITE_PTE(PointerPde, TempPte);
        TempPte.Long += PAGE_SIZE_LARGE;
    }

#ifndef ARCADE
    //
    // Access the host bridge's configuration space.
    //

    PCISlotNumber.u.AsULONG = 0;
    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_HOSTBRIDGE_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_HOSTBRIDGE_FUNCTION_ID;

#ifdef DEVKIT
    //
    // Configure the memory manager to use the page count configured in the host
    // bridge.  Each increment of the memory top is equal to 16 megabytes, or
    // 4096 pages.
    //

    HalReadPCISpace(0, PCISlotNumber.u.AsULONG, CR_CPU_MEMTOP_LIMIT,
        &MemoryTop, sizeof(UCHAR));

    MmHighestPhysicalPage = (((ULONG)MemoryTop + 1) * 4096) - 1;

    //
    // If the system only has 64 megabytes of memory, then allow pages in the
    // developer kit range to use memory from standard system memory.
    //

    if (MM_HIGHEST_PHYSICAL_PAGE < MM_64M_PHYSICAL_PAGE) {
        MmDeveloperKitPteRange.AvailablePages = &MmAvailablePages;
        MmDeveloperKitPteRange.RemovePageRoutine = MiRemoveZeroPage;
    }
#else
    //
    // Configure the host bridge's top of memory to a hardwired 64 megabytes.
    //

    MemoryTop = CR_CPU_MEMTOP_LIMIT_64MB;

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, CR_CPU_MEMTOP_LIMIT,
        &MemoryTop, sizeof(UCHAR));
#endif
#endif

#ifdef DEVKIT
    //
    // If this is the first boot and we booted from a ROM image loaded in RAM,
    // then make a copy of the initialized .data section so that we can throw
    // away the rest of the shadow ROM.
    //

    if (!KeHasQuickBooted && (XboxBootFlags & XBOX_BOOTFLAG_SHADOW)) {
        MiCopyShadowROMDataSection();
    }
#endif

    //
    // Initialize the page frame database.
    //

    if (!KeHasQuickBooted) {
        MiInitializePfnDatabase();
    } else {
        MiReinitializePfnDatabase();
    }

    //
    // Switch from the large pages used by the boot loader to the page tables
    // contained in the page frame database.
    //

    TempPte.Long = MiGetValidKernelPdeBits();
    TempPte.Hard.PageFrameNumber = MM_DATABASE_PHYSICAL_PAGE;

    PointerPde = MiGetPdeAddress(MM_SYSTEM_PHYSICAL_MAP);
    EndingPointerPde = MiGetPdeAddress(MI_CONVERT_PFN_TO_PHYSICAL(MM_HIGHEST_PHYSICAL_PAGE));

    while (PointerPde <= EndingPointerPde) {
        MI_WRITE_PTE(PointerPde, TempPte);
        TempPte.Hard.PageFrameNumber++;
        PointerPde++;
    }

    //
    // Unmap the rest of the system RAM physical window.
    //

    EndingPointerPde = MiGetPdeAddress(MM_SYSTEM_PHYSICAL_MAP +
        MM_BYTES_IN_PHYSICAL_MAP - 1);

    while (PointerPde <= EndingPointerPde) {
        MI_WRITE_ZERO_PTE(PointerPde);
        PointerPde++;
    }

    //
    // Flush the TLB now that the switch over is complete.
    //

    KeFlushCurrentTb();

    //
    // Initialize the pool support.
    //

    InitializePool();

    //
    // Allocate the "write 0xFF" PTEs for the file system cache.  We're called
    // early enough in the boot process that this shouldn't fail.
    //

    FscWriteFFsPtes = MiReserveSystemPtes(&MmSystemPteRange,
        FSCACHE_NUMBER_OF_WRITE_FF_PTES);

    ASSERT(FscWriteFFsPtes != NULL);

    //
    // Set the file system cache to the default boot size.
    //

    FscSetCacheSize(16);
}

VOID
MmDiscardInitSection(
    VOID
    )
/*++

Routine Description:

    This routine frees the INIT section of the kernel.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_SECTION_HEADER InitSectionHeader;
    PUCHAR VirtualAddress;
    PUCHAR EndingVirtualAddress;
    PFN_NUMBER PageFrameNumber;
    PFN_NUMBER EndingPageFrameNumberExclusive;
    KIRQL OldIrql;

    //
    // Find the NT headers for XBOXKRNL.EXE.
    //

    NtHeader = RtlImageNtHeader(PsNtosImageBase);

    ASSERT(NtHeader != NULL);
    ASSERT(NtHeader->FileHeader.NumberOfSections > 0);

    //
    // Find the last section of XBOXKRNL.EXE, which by convention should be the
    // discardable INIT section.
    //

    InitSectionHeader = IMAGE_FIRST_SECTION(NtHeader) +
        NtHeader->FileHeader.NumberOfSections - 1;

    ASSERT((*(PULONG)InitSectionHeader->Name) == 'TINI');
    ASSERT((InitSectionHeader->Characteristics & IMAGE_SCN_MEM_DISCARDABLE) != 0);

    //
    // Insert the pages of the INIT section into the free lists.  The starting
    // page of the INIT section may be shared with other code or data but
    // everything on the ending page of the INIT section is discardable.
    //

    VirtualAddress = (PUCHAR)PsNtosImageBase + InitSectionHeader->VirtualAddress;
    EndingVirtualAddress = VirtualAddress + InitSectionHeader->SizeOfRawData;

#if DBG
    RtlFillMemory(VirtualAddress, InitSectionHeader->SizeOfRawData, 0xCC);
#endif

    VirtualAddress = (PUCHAR)PAGE_ALIGN((ULONG_PTR)VirtualAddress + PAGE_SIZE - 1);
    EndingVirtualAddress = (PUCHAR)PAGE_ALIGN((ULONG_PTR)EndingVirtualAddress + PAGE_SIZE - 1);

    PageFrameNumber = MI_CONVERT_PHYSICAL_TO_PFN(VirtualAddress);
    EndingPageFrameNumberExclusive = MI_CONVERT_PHYSICAL_TO_PFN(EndingVirtualAddress);

    MmTopOfKernelPhysicalAddress = MmGetPhysicalAddress(VirtualAddress);

    MI_LOCK_MM(&OldIrql);

    while (PageFrameNumber < EndingPageFrameNumberExclusive) {

        //
        // MmAllocateContiguousMemorySpecifyCache searches for free pages from
        // the highest page to the lowest page, so insert pages such that the
        // lowest pages are at the front of the free lists.  This avoids
        // unnecessary page relocation in order to satisfy a contiguous memory
        // allocation.
        //

        MmAllocatedPagesByUsage[MmContiguousUsage]--;

        MiInsertPageInFreeList(PageFrameNumber, FALSE);

        PageFrameNumber++;
    }

    MI_UNLOCK_MM(OldIrql);

    ASSERT(EndingVirtualAddress == (PUCHAR)PsNtosImageBase +
        ROUND_TO_PAGES(RtlImageNtHeader(PsNtosImageBase)->OptionalHeader.SizeOfImage));

    //
    // Flush the TLB now that we've cleared several page table entries.
    //

    KeFlushCurrentTb();
}

VOID
MmRelocatePersistentMemory(
    VOID
    )
/*++

Routine Description:

    This routine relocates the contiguous memory allocations used by the launch
    data page and the persisted frame buffer.  This is done in order to make the
    memory layout at entry to an Xbox executable consistent between various
    methods of invocation (cold boot, warm boot from title, warm boot from
    Dashboard, etc.).

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    PLAUNCH_DATA_PAGE NewLaunchDataPage;
    PLAUNCH_DATA_PAGE OldLaunchDataPage;
    PVOID OldSurface;
    ULONG_PTR OldSurfacePhysicalAddress;
    ULONG NumberOfBytes;
    PVOID NewSurface;

    //
    // First, attempt to relocate the launch data page at the bottom of memory
    // in the region below the base of the kernel.  This region should be
    // available at this point unless we've collided with other persisted
    // contiguous memory.
    //

    OldLaunchDataPage = LaunchDataPage;

    if (OldLaunchDataPage != NULL) {

        NewLaunchDataPage = MmAllocateContiguousMemoryEx(PAGE_SIZE, 0,
            MmGetPhysicalAddress(PsNtosImageBase) - 1, 0, PAGE_READWRITE);

        if (NewLaunchDataPage != NULL) {

            RtlCopyMemory(NewLaunchDataPage, OldLaunchDataPage, PAGE_SIZE);
            MmPersistContiguousMemory(NewLaunchDataPage, PAGE_SIZE, TRUE);

            LaunchDataPage = NewLaunchDataPage;

            MmFreeContiguousMemory(OldLaunchDataPage);

        } else {
            MiDbgPrint(("MM: cannot relocate launch data page\n"));
        }
    }

    //
    // Second, attempt to relocate the frame buffer created by
    // D3DDevice::PersistDisplay at the location immediately above the kernel
    // image.  If no surface exists or the surface is already at the desired
    // address, then bail out now.
    //

    OldSurface = AvGetSavedDataAddress();

    if (OldSurface == NULL) {
        return;
    }

    OldSurfacePhysicalAddress = MmGetPhysicalAddress(OldSurface);

    if (OldSurfacePhysicalAddress == MmTopOfKernelPhysicalAddress) {
        return;
    }

    //
    // Check if the surface overlaps the target surface physical address.  If
    // so, then we'll try to first relocate the surface to a higher physical
    // address.  If this fails, we'll fall into the below code path which will
    // fail due to the existing allocation.
    //

    NumberOfBytes = MmQueryAllocationSize(OldSurface);

    if (OldSurfacePhysicalAddress < MmTopOfKernelPhysicalAddress + NumberOfBytes) {

        NewSurface = MmAllocateContiguousMemoryEx(NumberOfBytes,
            MmTopOfKernelPhysicalAddress, MAXULONG_PTR, 0, PAGE_READWRITE |
            PAGE_WRITECOMBINE);

        if (NewSurface != NULL) {
            AvRelocateSavedDataAddress(NewSurface, NumberOfBytes);
            OldSurface = NewSurface;
        }
    }

    //
    // Attempt to relocate the surface to the physical memory immediately above
    // the kernel image.
    //

    NewSurface = MmAllocateContiguousMemoryEx(NumberOfBytes,
        MmTopOfKernelPhysicalAddress, MmTopOfKernelPhysicalAddress +
        NumberOfBytes - 1, 0, PAGE_READWRITE | PAGE_WRITECOMBINE);

    if (NewSurface != NULL) {
        AvRelocateSavedDataAddress(NewSurface, NumberOfBytes);
    } else {
        MiDbgPrint(("MM: cannot relocate persist display surface\n"));
    }
}

VOID
MmPrepareToQuickRebootSystem(
    VOID
    )
/*++

Routine Description:

    This routine is called by the HAL immediately before quick rebooting the
    system.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    ULONG PageFrameNumber;
    ULONG EndingPageFrameNumber;
    MMPFN TempPageFrame;
    MMPTE TempPte;
    PMMPTE PointerPde;

    //
    // Convert the page frames that hold NV2A instance memory to page table
    // entries.  When the memory manager reinitializes itself in the next
    // instance of the kernel, we want all of the pages that can be used for
    // instance memory to be reserved again until the D3D drivers calls
    // MmClaimGpuInstanceMemory.
    //

    PageFrameNumber = MM_INSTANCE_PHYSICAL_PAGE;
    EndingPageFrameNumber = MM_INSTANCE_PHYSICAL_PAGE + MM_INSTANCE_PAGE_COUNT;

    while (PageFrameNumber < EndingPageFrameNumber) {

        TempPageFrame.Pte.Long = MiGetValidKernelPteBits();
        MI_DISABLE_CACHING(TempPageFrame.Pte);
        TempPageFrame.Pte.Hard.PersistAllocation = 1;
        TempPageFrame.Pte.Hard.PageFrameNumber = PageFrameNumber;

        *MI_PFN_ELEMENT(PageFrameNumber) = TempPageFrame;

        PageFrameNumber++;
    }

#ifdef CONSOLE_DEVKIT
    //
    // On a development kit system, the NVIDIA NV2A instance memory must be
    // relative to the top of memory, so we also reserve the instance memory
    // pages in the upper half of memory.
    //

    if (MM_HIGHEST_PHYSICAL_PAGE != MM_64M_PHYSICAL_PAGE - 1) {

        PageFrameNumber = MM_INSTANCE_PHYSICAL_PAGE + MM_64M_PHYSICAL_PAGE;
        EndingPageFrameNumber = MM_DATABASE_PHYSICAL_PAGE + MM_64M_PHYSICAL_PAGE;

        while (PageFrameNumber < EndingPageFrameNumber) {

            TempPageFrame.Pte.Long = MiGetValidKernelPteBits();
            MI_DISABLE_CACHING(TempPageFrame.Pte);
            TempPageFrame.Pte.Hard.PersistAllocation = 1;
            TempPageFrame.Pte.Hard.PageFrameNumber = PageFrameNumber;

            *MI_PFN_ELEMENT(PageFrameNumber) = TempPageFrame;

            PageFrameNumber++;
        }
    }
#endif

    //
    // Unmap the lower two gigabytes of memory.
    //

    for (PointerPde = MiGetPdeAddress(0); PointerPde <
        MiGetPdeAddress(MM_PHYSICAL_MAP_BASE); PointerPde++) {
        MI_WRITE_ZERO_PTE(PointerPde);
    }

    //
    // Unmap the system PTE space.
    //

    for (PointerPde = MiGetPdeAddress(MM_SYSTEM_PTE_BASE); PointerPde <=
        MiGetPdeAddress(MM_SYSTEM_PTE_END); PointerPde++) {
        MI_WRITE_ZERO_PTE(PointerPde);
    }

    //
    // Switch back to large pages for the physical mapping window.  When the
    // memory manager reinitializes, the PFN database will be modified causing
    // the existing page tables to become invalid.  Also, this causes the ROM
    // shadow physical address to be visible for KeQuickRebootSystem.
    //

    TempPte.Long = MiGetValidKernelPteBits();
    TempPte.Hard.LargePage = 1;

    for (PointerPde = MiGetPdeAddress(MM_PHYSICAL_MAP_BASE); PointerPde <=
        MiGetPdeAddress(MM_PHYSICAL_MAP_END); PointerPde++) {
        MI_WRITE_PTE(PointerPde, TempPte);
        TempPte.Long += PAGE_SIZE_LARGE;
    }

    //
    // Map the boot ROM to its identity mapping at the top of memory.
    //

    TempPte.Long = MiGetValidKernelPteBits();
    TempPte.Hard.LargePage = 1;
    TempPte.Hard.PageFrameNumber = (ULONG_PTR)PAGE_ALIGN_LARGE(MAXULONG_PTR) >>
        PAGE_SHIFT;

    PointerPde = MiGetPdeAddress((PVOID)MAXULONG_PTR);
    MI_WRITE_PTE(PointerPde, TempPte);

    //
    // Flush the TLB now that the switch over is complete.
    //

    KeFlushCurrentTb();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\mmx\mmsup.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    mmsup.c

Abstract:

    This module implements the various routines for miscellaneous support
    operations for memory management.

--*/

#include "mi.h"

//
// Table to convert external protection codes to internal memory manager codes.
//

const CCHAR MmProtectToPteProtectionMask[16] = {
    -1,
    MM_PTE_READONLY,
    MM_PTE_READONLY,
    -1,
    MM_PTE_READWRITE,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
};

BOOLEAN
MmIsAddressValid(
    IN PVOID VirtualAddress
    )
/*++

Routine Description:

    For a given virtual address this function returns TRUE if no page fault
    will occur for a read operation on the address, FALSE otherwise.

    Note that after this routine was called, if appropriate locks are not
    held, a non-faulting address could fault.

Arguments:

    VirtualAddress - Supplies the virtual address to check.

Return Value:

    TRUE if a no page fault would be generated reading the virtual address,
    FALSE otherwise.

Environment:

    Kernel mode.

--*/
{
    PMMPTE PointerPte;

    PointerPte = MiGetPdeAddress (VirtualAddress);
    if (PointerPte->Hard.Valid == 0) {
        return FALSE;
    }

    if (PointerPte->Hard.LargePage != 0) {
        return TRUE;
    }

    PointerPte = MiGetPteAddress (VirtualAddress);
    if (PointerPte->Hard.Valid == 0) {
        return FALSE;
    }

    //
    // Make sure we're not treating a page directory as a page table here for
    // the case where the page directory is mapping a large page.  This is
    // because the large page bit is valid in PDE formats, but reserved in
    // PTE formats and will cause a trap.  A virtual address like c0200000
    // triggers this case.  It's not enough to just check the large page bit
    // in the PTE below because of course that bit's been reused by other
    // steppings of the processor so we have to look at the address too.
    //
    if (PointerPte->Hard.LargePage != 0) {
        PVOID Va;

        Va = MiGetVirtualAddressMappedByPde (PointerPte);
        if (MI_IS_PHYSICAL_ADDRESS(Va)) {
            return FALSE;
        }
    }

    return TRUE;
}

PVOID
MiAllocateMappedMemory(
    IN PMMPTERANGE PteRange,
    IN MMPFN_BUSY_TYPE BusyType,
    IN ULONG Protect,
    IN SIZE_T NumberOfBytes,
    IN PMMREMOVE_PAGE_ROUTINE RemovePageRoutine,
    IN BOOLEAN AddBarrierPage
    )
/*++

Routine Description:

    This routine allocates a number of pages in the system part of the address
    space.  The page frames are marked with the supplied busy type code and the
    PTEs are configured with the supplied cache type.  The RemovePageRoutine
    parameter is used to specify the source of the pages (non-zeroed, zeroed,
    etc.).

Arguments:

    PteRange - Supplies the PTE range to allocate the pages from.

    BusyType - Usage code to place in allocated page frame.

    Protect - Supplies the type of protection and cache mapping to use for the
              allocation.

    NumberOfBytes - Supplies the number of byte to allocate.

    RemovePageRoutine - Supplies the allocator routine to use grab pages.

    AddBarrierPage - Supplies whether or not to add an extra barrier page.

Return Value:

    Returns the virtual address of the allocated memory.  When AddBarrierPage is
    TRUE, the returned address points at the barrier page.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    MMPTE TempPte;
    KIRQL OldIrql;
    PFN_COUNT NumberOfPages;
    PFN_COUNT NumberOfPtes;
    PMMPTE StartingPte;
    PMMPTE PointerPte;
    PMMPTE EndingPte;

    //
    // Convert the protect code to a PTE mask.
    //

    if (!MiMakeSystemPteProtectionMask(Protect, &TempPte)) {
        return NULL;
    }

    MI_LOCK_MM(&OldIrql);

    //
    // Compute the number of pages to allocate.
    //

    NumberOfPages = BYTES_TO_PAGES(NumberOfBytes);
    ASSERT(NumberOfPages != 0);

    //
    // Verify that there are enough pages available to satisfy the request.
    // This check doesn't take into account the pages that may be taken when we
    // reserve system PTEs below.
    //

    if (*PteRange->AvailablePages < NumberOfPages) {
        MI_UNLOCK_MM(OldIrql);
        return NULL;
    }

    //
    // Compute the number of PTEs that will be required to map the allocated
    // memory.
    //

    NumberOfPtes = NumberOfPages;

    if (AddBarrierPage) {
        NumberOfPtes++;
    }

    //
    // Reserve the PTEs for the allocated memory.
    //

    StartingPte = MiReserveSystemPtes(PteRange, NumberOfPtes);

    if (StartingPte == NULL) {
        MI_UNLOCK_MM(OldIrql);
        return NULL;
    }

    PointerPte = StartingPte;

    //
    // Verify that there are enough pages available to satisfy the request.  We
    // have to check again after reserving the system PTEs because that may have
    // consumed the pages that we thought we had available above.
    //

    if (*PteRange->AvailablePages < NumberOfPages) {
        MiReleaseSystemPtes(PteRange, StartingPte, NumberOfPtes);
        MI_UNLOCK_MM(OldIrql);
        return NULL;
    }

    if (AddBarrierPage) {

        //
        // Fill in the barrier page to protect against stack overflow errors.
        //

        MI_WRITE_ZERO_PTE(PointerPte);
        PointerPte++;
    }

    //
    // Allocate the pages.
    //

    EndingPte = PointerPte + NumberOfPages - 1;

    while (PointerPte <= EndingPte) {
        TempPte.Hard.PageFrameNumber = RemovePageRoutine(BusyType, PointerPte);
        MI_WRITE_PTE(PointerPte, TempPte);
        PointerPte++;
    }

    //
    // Mark the last page of the allocation so that we can find it later if we
    // need to free the buffer without knowing the original size.
    //

    EndingPte->Hard.GuardOrEndOfAllocation = 1;

    //
    // Write combined accesses may not check the processor's cache, so force a
    // flush of the TLB and cache now to ensure coherency.
    //
    // Flush the cache for uncached allocations so that all cache lines from the
    // page are out of the processor's caches.  The pages are likely to be
    // shared with an external device and the external device may not snoop the
    // cache lines.
    //

    if (Protect & (PAGE_WRITECOMBINE | PAGE_NOCACHE)) {
        KeFlushCurrentTbAndInvalidateAllCaches();
    }

    MI_UNLOCK_MM(OldIrql);

    return MiGetVirtualAddressMappedByPte(StartingPte);
}

PFN_COUNT
MiFreeMappedMemory(
    IN PMMPTERANGE PteRange,
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes OPTIONAL
    )
/*++

Routine Description:

    This routine deallocates a number of pages in the system part of the address
    space.  This is designed to free pages acquired via MiAllocateMappedMemory.

    For stack allocations, the BaseAddress parameter should be pointing at the
    barrier page and NumberOfBytes should include the size of the barrier page.

Arguments:

    PteRange - Supplies the PTE range to free the pages to.

    BaseAddress - Supplies the virtual address of the buffer.

    NumberOfBytes - Supplies the number of bytes in the buffer.  If the count is
                    zero, then the routine attempts to determine the size of the
                    buffer by finding the page frame with the "end of
                    allocation" flag set.

Return Value:

    Returns the number of pages deallocated.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    KIRQL OldIrql;
    PMMPTE StartingPte;
    PMMPTE PointerPte;
    MMPTE TempPte;
    PMMPTE EndingPte;
    PFN_NUMBER PageFrameNumber;
    ULONG EndOfAllocation;
    PFN_COUNT NumberOfPages;

    ASSERT(MiGetPteAddress(BaseAddress) >= PteRange->FirstCommittedPte);
    ASSERT(MiGetPteAddress(BaseAddress) < PteRange->LastCommittedPte);
    ASSERT(((ULONG_PTR)BaseAddress & (PAGE_SIZE - 1)) == 0);

    //
    // Free the pages.
    //

    MI_LOCK_MM(&OldIrql);

    StartingPte = MiGetPteAddress(BaseAddress);
    PointerPte = StartingPte;
    TempPte.Long = 0;

    if (NumberOfBytes != 0) {

        EndingPte = StartingPte + BYTES_TO_PAGES(NumberOfBytes) - 1;

        while (PointerPte <= EndingPte) {

            //
            // If we know the size of the original allocation, then the caller
            // is allowed to free any pages in the original allocation.  For
            // example, the loader may have freed pages used at initialization
            // time only.
            //

            if (PointerPte->Hard.Valid != 0) {
                PageFrameNumber = PointerPte->Hard.PageFrameNumber;
                MI_WRITE_AND_FLUSH_PTE(PointerPte, TempPte);
                MiReleasePageOwnership(PageFrameNumber);
            }

            PointerPte++;
        }

    } else {

        do {

            //
            // If we don't know the size of the original allocation, then the
            // caller must not free any of the pages since the page frame is
            // used to store the "end of allocation" flag.
            //

            ASSERT(PointerPte->Hard.Valid != 0);

            PageFrameNumber = PointerPte->Hard.PageFrameNumber;
            EndOfAllocation = PointerPte->Hard.GuardOrEndOfAllocation;
            MI_WRITE_AND_FLUSH_PTE(PointerPte, TempPte);
            MiReleasePageOwnership(PageFrameNumber);

            PointerPte++;

        } while (!EndOfAllocation);
    }

    //
    // Release the PTEs for the allocated memory.
    //

    NumberOfPages = PointerPte - StartingPte;
    MiReleaseSystemPtes(PteRange, StartingPte, NumberOfPages);

    MI_UNLOCK_MM(OldIrql);

    return NumberOfPages;
}

BOOLEAN
FASTCALL
MiMakePteProtectionMask(
    IN ULONG Protect,
    OUT PULONG PteProtectionMask
    )
/*++

Routine Description:

    This routine translates the access protection code used by external APIs
    to the PTE bit mask that implements that policy.

Arguments:

    Protect - Supplies the protection code (e.g., PAGE_READWRITE).

    PteProtectionMask - Supplies a pointer to the variable that will receive
                        the PTE protection mask (e.g., MM_PTE_READWRITE).

Return Value:

    TRUE if the protection code was successfully decoded, else FALSE.

Environment:

    Kernel mode.

--*/
{
    ULONG Field1;
    ULONG Field2;
    ULONG Mask;

    //
    // Check for unknown protection bits.
    //

    if (Protect & ~(PAGE_GUARD | PAGE_NOCACHE | PAGE_WRITECOMBINE | 0xFF)) {
        return FALSE;
    }

    //
    // None of the protection attributes are valid for "no access" pages.
    //

    if (Protect & PAGE_NOACCESS) {

        if (Protect & (PAGE_GUARD | PAGE_NOCACHE | PAGE_WRITECOMBINE)) {
            return FALSE;
        }
    }

    //
    // Only one of the cache protection attributes may be specified.
    //

    if ((Protect & PAGE_NOCACHE) && (Protect & PAGE_WRITECOMBINE)) {
        return FALSE;
    }

    //
    // One of the nibbles must be non-zero and the other must be zero.
    //

    Field1 = Protect & 0xF;
    Field2 = (Protect >> 4) & 0xF;

    if ((Field1 == 0 && Field2 == 0) || (Field1 != 0 && Field2 != 0)) {
        return FALSE;
    }

    //
    // Check if the table knows how to translate the protection code.
    //

    Mask = (ULONG)(LONG)(CCHAR)MmProtectToPteProtectionMask[Field1 | Field2];

    if (Mask == (ULONG)-1) {
        return FALSE;
    }

    //
    // Apply the rest of the protection attributes to the PTE mask.
    //

    if ((Protect & (PAGE_NOACCESS | PAGE_GUARD)) == 0) {
        Mask |= MM_PTE_VALID_MASK;
    } else if (Protect & PAGE_GUARD) {
        Mask |= MM_PTE_GUARD;
    }

    if (Protect & PAGE_NOCACHE) {
        Mask |= MM_PTE_CACHE_DISABLE_MASK;
    } else if (Protect & PAGE_WRITECOMBINE) {
        Mask |= MM_PTE_WRITE_THROUGH_MASK;
    }

    ASSERT((Mask & ~(MM_PTE_PROTECTION_MASK)) == 0);

    *PteProtectionMask = Mask;

    return TRUE;
}

BOOLEAN
FASTCALL
MiMakeSystemPteProtectionMask(
    IN ULONG Protect,
    OUT PMMPTE ProtoPte
    )
/*++

Routine Description:

    This routine translates the access protection code used by external APIs
    to the PTE bit mask that implements that policy.

Arguments:

    Protect - Supplies the protection code (e.g., PAGE_READWRITE).

    ProtoPte - Supplies a pointer to the variable that will receive
               the PTE protection mask (e.g., MM_PTE_READWRITE).

Return Value:

    TRUE if the protection code was successfully decoded, else FALSE.

Environment:

    Kernel mode.

--*/
{
    ULONG Mask;

    Mask = 0;

    //
    // Check for unknown protection bits.
    //

    if (Protect & ~(PAGE_NOCACHE | PAGE_WRITECOMBINE | PAGE_READWRITE |
        PAGE_READONLY)) {
        return FALSE;
    }

    //
    // Only one of the page protection attributes may be specified.
    //

    switch (Protect & (PAGE_READONLY | PAGE_READWRITE)) {

        case PAGE_READONLY:
            Mask = (MM_PTE_VALID_MASK | MM_PTE_DIRTY_MASK | MM_PTE_ACCESS_MASK);
            break;

        case PAGE_READWRITE:
            Mask = (MM_PTE_VALID_MASK | MM_PTE_WRITE_MASK | MM_PTE_DIRTY_MASK |
                MM_PTE_ACCESS_MASK);
            break;

        default:
            return FALSE;
    }

    //
    // Only one of the cache protection attributes may be specified.
    //

    switch (Protect & (PAGE_NOCACHE | PAGE_WRITECOMBINE)) {

        case 0:
            break;

        case PAGE_NOCACHE:
            Mask |= MM_PTE_CACHE_DISABLE_MASK;
            break;

        case PAGE_WRITECOMBINE:
            Mask |= MM_PTE_WRITE_THROUGH_MASK;
            break;

        default:
            return FALSE;
    }

    ProtoPte->Long = Mask;

    return TRUE;
}

ULONG
FASTCALL
MiDecodePteProtectionMask(
    IN ULONG PteProtectionMask
    )
/*++

Routine Description:

    This routine translate a PTE protection bit mask into the external access
    protection code used by external APIs.

Arguments:

    PteProtectionMask - Supplies the PTE protection bit mask.

Return Value:

    The protection code equivalent (e.g., PAGE_READWRITE).

Environment:

    Kernel mode.

--*/
{
    ULONG Protect;

    if (PteProtectionMask & MM_PTE_READWRITE) {
        Protect = PAGE_READWRITE;
    } else {
        Protect = PAGE_READONLY;
    }

    if ((PteProtectionMask & MM_PTE_VALID_MASK) == 0) {

        if (PteProtectionMask & MM_PTE_GUARD) {
            Protect |= PAGE_GUARD;
        } else {
            Protect = PAGE_NOACCESS;
        }
    }

    if (PteProtectionMask & MM_PTE_CACHE_DISABLE_MASK) {
        Protect |= PAGE_NOCACHE;
    } else if (PteProtectionMask & MM_PTE_WRITE_THROUGH_MASK) {
        Protect |= PAGE_WRITECOMBINE;
    }

    return Protect;
}

ULONG
MmQueryAddressProtect(
    IN PVOID VirtualAddress
    )
/*++

Routine Description:

    This routine queries the protection code associated with the specified base
    address.

Arguments:

    VirtualAddress - Supplies the virtual address to return the protection code
                     for.

Return Value:

    Returns the page protection code.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    ULONG Protect;
    KIRQL OldIrql;
    PMMPTE PointerPte;
    MMPTE TempPte;

    MI_LOCK_MM(&OldIrql);

    PointerPte = MiGetPdeAddress(VirtualAddress);
    TempPte = *PointerPte;

    if (TempPte.Hard.Valid != 0) {

        if (TempPte.Hard.LargePage == 0) {

            PointerPte = MiGetPteAddress(VirtualAddress);
            TempPte = *PointerPte;

            //
            // Addresses in system space must be marked as valid.  Addresses in
            // user space may be marked invalid if they are PAGE_NOACCESS or
            // PAGE_GUARD pages.
            //

            if ((TempPte.Hard.Valid != 0) ||
                ((TempPte.Long != 0) && (VirtualAddress <= MM_HIGHEST_USER_ADDRESS))) {
                Protect = MiDecodePteProtectionMask(TempPte.Long);
            } else {
                Protect = 0;
            }

        } else {
            Protect = MiDecodePteProtectionMask(TempPte.Long);
        }

    } else {
        Protect = 0;
    }

    MI_UNLOCK_MM(OldIrql);

    return Protect;
}

VOID
MmSetAddressProtect(
    IN PVOID BaseAddress,
    IN ULONG NumberOfBytes,
    IN ULONG NewProtect
    )
/*++

Routine Description:

    This routine applies the protection code to the specified address range.

Arguments:

    BaseAddress - Supplies the starting virtual address to change the protection
                  code for.

    NumberOfBytes - Supplies the number of bytes to change.

    NewProtect - Supplies the type of protection and cache mapping to use for
                 the allocation.

Return Value:

    None.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    MMPTE ProtoPte;
    KIRQL OldIrql;
    PMMPTE PointerPte;
    PMMPTE EndingPte;
    MMPTE TempPte;

    ASSERT(MI_IS_PHYSICAL_ADDRESS(BaseAddress) || MI_IS_SYSTEM_PTE_ADDRESS(BaseAddress));
    ASSERT(NumberOfBytes != 0);

    //
    // Convert the protect code to a PTE mask.
    //

    if (!MiMakeSystemPteProtectionMask(NewProtect, &ProtoPte)) {
        return;
    }

    MI_LOCK_MM(&OldIrql);

    PointerPte = MiGetPteAddress(BaseAddress);
    EndingPte = MiGetPteAddress((PUCHAR)BaseAddress + NumberOfBytes - 1);

    while (PointerPte <= EndingPte) {

        TempPte = *PointerPte;

        ASSERT(TempPte.Hard.Valid != 0);

        if ((TempPte.Long & MM_SYSTEM_PTE_PROTECTION_MASK) != ProtoPte.Long) {

            TempPte.Long = ((TempPte.Long & ~MM_SYSTEM_PTE_PROTECTION_MASK) |
                ProtoPte.Long);

            MI_WRITE_AND_FLUSH_PTE(PointerPte, TempPte);
        }

        PointerPte++;
    }

    //
    // Write combined accesses may not check the processor's cache, so force a
    // flush of the TLB and cache now to ensure coherency.
    //
    // Flush the cache for uncached allocations so that all cache lines from the
    // page are out of the processor's caches.  The pages are likely to be
    // shared with an external device and the external device may not snoop the
    // cache lines.
    //

    if (NewProtect & (PAGE_WRITECOMBINE | PAGE_NOCACHE)) {
        KeFlushCurrentTbAndInvalidateAllCaches();
    }

    MI_UNLOCK_MM(OldIrql);
}

NTSTATUS
MmQueryStatistics(
    IN OUT PMM_STATISTICS MemoryStatistics
    )
/*++

Routine Description:

    This routine returns various statistics about the state of the memory
    manager subsystem.

Arguments:

    MemoryStatistics - Supplies the buffer to fill with the memory manager's
        statistics.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    KIRQL OldIrql;

    if (MemoryStatistics->Length == sizeof(MM_STATISTICS)) {

        MI_LOCK_MM(&OldIrql);

        MemoryStatistics->TotalPhysicalPages = MmNumberOfPhysicalPages;
        MemoryStatistics->AvailablePages = MmAvailablePages;
        MemoryStatistics->VirtualMemoryBytesCommitted =
            ((MmAllocatedPagesByUsage[MmVirtualMemoryUsage] +
            MmAllocatedPagesByUsage[MmImageUsage]) << PAGE_SHIFT);
        MemoryStatistics->VirtualMemoryBytesReserved = MmVirtualMemoryBytesReserved;
        MemoryStatistics->CachePagesCommitted = MmAllocatedPagesByUsage[MmFsCacheUsage];
        MemoryStatistics->PoolPagesCommitted = MmAllocatedPagesByUsage[MmPoolUsage];
        MemoryStatistics->StackPagesCommitted = MmAllocatedPagesByUsage[MmStackUsage];
        MemoryStatistics->ImagePagesCommitted = MmAllocatedPagesByUsage[MmImageUsage];

        MI_UNLOCK_MM(OldIrql);

        status = STATUS_SUCCESS;

    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    return status;
}

PVOID
MmAllocateSystemMemory(
    IN SIZE_T NumberOfBytes,
    IN ULONG Protect
    )
/*++

Routine Description:

    This function allocates a range of memory in the non-paged portion of the
    system address space.

    This routine is designed to be used by a driver's initialization
    routine to allocate a noncached block of virtual memory for various device
    specific buffers.

Arguments:

    NumberOfBytes - Supplies the number of bytes to allocate.

    Protect - Supplies the type of protection and cache mapping to use for the
              allocation.

Return Value:

    NON-NULL - Returns a pointer (virtual address in the nonpaged portion
               of the system) to the allocated physically contiguous
               memory.

    NULL - The specified request could not be satisfied.

Environment:

    Kernel mode, <= DISPATCH_LEVEL

--*/
{
    return MiAllocateMappedMemory(&MmSystemPteRange, MmSystemMemoryUsage,
        Protect, NumberOfBytes, MiRemoveAnyPage, FALSE);
}

ULONG
MmFreeSystemMemory(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    )
/*++

Routine Description:

    This function deallocates a range of memory in the non-paged portion of the
    system address space.  This is designed to free pages acquired via
    MmAllocateSystemMemory only.

Arguments:

    BaseAddress - Supplies the base virtual address where the system memory
                  resides.

    NumberOfBytes - Supplies the number of bytes allocated to the request.
                    This must be the same number that was obtained with
                    the MmAllocateSystemMemory call.

Return Value:

    Returns the number of pages deallocated.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    return MiFreeMappedMemory(&MmSystemPteRange, BaseAddress, NumberOfBytes);
}

PVOID
MmAllocatePoolPages(
    IN SIZE_T NumberOfBytes
    )
/*++

Routine Description:

    This function allocates a set of pages from the specified pool
    and returns the starting virtual address to the caller.

Arguments:

    NumberOfBytes - Supplies the size of the request in bytes.  The actual
                    size returned is rounded up to a page boundary.

Return Value:

    Returns a pointer to the allocated pool, or NULL if no more pool is
    available.

Environment:

    These functions are used by the general pool allocation routines
    and should not be called directly.

    Mutexes guarding the pool databases must be held when calling
    these functions.

    Kernel mode, IRQL at DISPATCH_LEVEL.

--*/
{
    PVOID StartingAddress;

    StartingAddress = MiAllocateMappedMemory(&MmSystemPteRange, MmPoolUsage,
        PAGE_READWRITE, NumberOfBytes, MiRemoveAnyPage, FALSE);

#if DBG
    if (StartingAddress != NULL) {
        RtlFillMemoryUlong(StartingAddress, NumberOfBytes, 'looP');
    }
#endif

    return StartingAddress;
}

ULONG
MmFreePoolPages(
    IN PVOID StartingAddress
    )
/*++

Routine Description:

    This function returns a set of pages back to the pool from
    which they were obtained.  Once the pages have been deallocated
    the region provided by the allocation becomes available for
    allocation to other callers, i.e. any data in the region is now
    trashed and cannot be referenced.

Arguments:

    StartingAddress - Supplies the starting address which was returned
                      in a previous call to MmAllocatePoolPages.

Return Value:

    Returns the number of pages deallocated.

Environment:

    These functions are used by the general pool allocation routines
    and should not be called directly.

    Mutexes guarding the pool databases must be held when calling
    these functions.

--*/
{
#if DBG
    //
    // The number of pages may exceed one for a large pool allocation, but we'll
    // do the simple thing and just assume a single page here.
    //

    RtlFillMemoryUlong(StartingAddress, PAGE_SIZE, 'daeD');
#endif

    return MiFreeMappedMemory(&MmSystemPteRange, StartingAddress, 0);
}

PVOID
MmCreateKernelStack(
    IN SIZE_T NumberOfBytes,
    IN BOOLEAN DebuggerThread
    )
/*++

Routine Description:

    This routine allocates a kernel stack and a no-access page within
    the non-pagable portion of the system address space.

Arguments:

    NumberOfBytes - Supplies the size of the request in bytes.  The actual
                    size returned is rounded up to a page boundary.

    DebuggerThread - Supplies TRUE if this thread's stack should be allocated
                     from the extra memory available on a development kit or
                     from the retail memory region.

Return Value:

    Returns a pointer to the base of the kernel stack.  Note, that the
    base address points to the guard page, so space must be allocated
    on the stack before accessing the stack.

    If a kernel stack cannot be created, the value NULL is returned.

Environment:

    Kernel mode.  APCs Disabled.

--*/
{
    PMMPTERANGE PteRange;
    PMMREMOVE_PAGE_ROUTINE RemovePageRoutine;
    MMPFN_BUSY_TYPE BusyType;
    PVOID KernelStackBottom;
    SIZE_T ActualNumberOfBytes;

    ASSERT(NumberOfBytes != 0);
    ASSERT((NumberOfBytes & (PAGE_SIZE - 1)) == 0);

    //
    // Determine which PTE address range to allocate the stack from.
    //

    PteRange = &MmSystemPteRange;
    RemovePageRoutine = MiRemoveAnyPage;
    BusyType = MmStackUsage;

#ifdef DEVKIT
    if (DebuggerThread) {
        PteRange = &MmDeveloperKitPteRange;
        RemovePageRoutine = MmDeveloperKitPteRange.RemovePageRoutine;
        BusyType = MmDebuggerUsage;
    }
#endif

    //
    // Allocate the stack.  Note that an extra barrier page will be added to the
    // allocation.
    //

    KernelStackBottom = MiAllocateMappedMemory(PteRange, BusyType,
        PAGE_READWRITE, NumberOfBytes, RemovePageRoutine, TRUE);
    ActualNumberOfBytes = NumberOfBytes + PAGE_SIZE;

    if (KernelStackBottom == NULL) {
        return NULL;
    }

#if DBG
    RtlFillMemoryUlong((PCHAR)KernelStackBottom + PAGE_SIZE, NumberOfBytes,
        'katS');
#endif

    return (PCHAR)KernelStackBottom + ActualNumberOfBytes;
}

VOID
MmDeleteKernelStack(
    IN PVOID KernelStackBase,
    IN PVOID KernelStackLimit
    )
/*++

Routine Description:

    This routine deletes a kernel stack and the no-access page within
    the non-pagable portion of the system address space.

Arguments:

    KernelStackBase - Supplies a pointer to the base of the kernel stack.

    KernelStackLimit - Supplies a pointer to the limit of the kernel stack.

Return Value:

    None.

Environment:

    Kernel mode.  APCs Disabled.

--*/
{
    PMMPTERANGE PteRange;
    SIZE_T ActualNumberOfBytes;
    PVOID KernelStackBottom;

    //
    // Determine which PTE range allocated the stack.
    //

    PteRange = &MmSystemPteRange;

#ifdef DEVKIT
    if (!MI_IS_SYSTEM_PTE_ADDRESS(KernelStackLimit)) {
        PteRange = &MmDeveloperKitPteRange;
    }
#endif

    //
    // Free the stack.  Note that an extra barrier page had been added to the
    // allocation.
    //

    ActualNumberOfBytes = ((PCHAR)KernelStackBase - (PCHAR)KernelStackLimit) +
        PAGE_SIZE;

    ASSERT((ActualNumberOfBytes & (PAGE_SIZE - 1)) == 0);

    KernelStackBottom = (PCHAR)KernelStackBase - ActualNumberOfBytes;

    MiFreeMappedMemory(PteRange, KernelStackBottom, ActualNumberOfBytes);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\mmx\physical.c ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    physical.c

Abstract:

    This module implements the kernel physical memory management services.

--*/

#include "mi.h"

//
// Number of bytes that have been reserved for instance memory allocation.
//
ULONG MmNumberOfInstanceMemoryBytes = MM_INSTANCE_PAGE_COUNT << PAGE_SHIFT;

ULONG_PTR
MmGetPhysicalAddress(
    IN PVOID BaseAddress
    )
/*++

Routine Description:

    This function returns the corresponding physical address for a
    valid virtual address.

Arguments:

    BaseAddress - Supplies the virtual address for which to return the
                  physical address.

Return Value:

    Returns the corresponding physical address.

Environment:

    Kernel mode.  Any IRQL level.

--*/
{
    ULONG_PTR PhysicalAddress;
    PMMPTE PointerPte;
#if DBG
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;
#endif

    PointerPte = MiGetPdeAddress(BaseAddress);
    if (PointerPte->Hard.Valid == 0) {
        goto InvalidAddress;
    }

    if (PointerPte->Hard.LargePage == 0) {

        PointerPte = MiGetPteAddress(BaseAddress);
        if (PointerPte->Hard.Valid == 0) {
            goto InvalidAddress;
        }

        PhysicalAddress = BYTE_OFFSET(BaseAddress);

    } else {

        PhysicalAddress = BYTE_OFFSET_LARGE(BaseAddress);
    }

    PhysicalAddress += (PointerPte->Hard.PageFrameNumber << PAGE_SHIFT);

#if DBG
    //
    // Verify that the base address is either a physically mapped page (either a
    // contiguous memory allocation or part of XBOXKRNL.EXE) or that it's I/O
    // lock count is non-zero (a page that's been liked with a service like
    // MmLockUnlockBufferPages).
    //

    PageFrameNumber = PhysicalAddress >> PAGE_SHIFT;

    if (PageFrameNumber <= MM_HIGHEST_PHYSICAL_PAGE) {

        PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

        if (PageFrame->Pte.Hard.Valid == 0) {
            ASSERT(PageFrame->Busy.LockCount != 0);
        }
    }
#endif

    return PhysicalAddress;

InvalidAddress:
    MiDbgPrint(("MmGetPhysicalAddress failed, base address was %p", BaseAddress));
    return 0;
}

PVOID
MmAllocateContiguousMemory(
    IN SIZE_T NumberOfBytes
    )
/*++

Routine Description:

    This function allocates a range of physically contiguous non-paged pool.

    This routine is designed to be used by a driver's initialization
    routine to allocate a contiguous block of physical memory for
    issuing DMA requests from.

Arguments:

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NULL - a contiguous range could not be found to satisfy the request.

    NON-NULL - Returns a pointer (virtual address in the nonpaged portion
               of the system) to the allocated physically contiguous
               memory.

Environment:

    Kernel mode, IRQL of APC_LEVEL or below.

--*/
{
    return MmAllocateContiguousMemoryEx(NumberOfBytes, 0, MAXULONG_PTR, 0,
        PAGE_READWRITE);
}

PVOID
MmAllocateContiguousMemoryEx(
    IN SIZE_T NumberOfBytes,
    IN ULONG_PTR LowestAcceptableAddress,
    IN ULONG_PTR HighestAcceptableAddress,
    IN ULONG_PTR Alignment,
    IN ULONG Protect
    )
/*++

Routine Description:

    This function allocates a range of physically contiguous non-cached,
    non-paged memory.  This is accomplished by using MmAllocateContiguousMemory
    which uses nonpaged pool virtual addresses to map the found memory chunk.

    Then this function establishes another map to the same physical addresses,
    but this alternate map is initialized as non-cached.  All references by
    our caller will be done through this alternate map.

    This routine is designed to be used by a driver's initialization
    routine to allocate a contiguous block of noncached physical memory for
    things like the AGP GART.

Arguments:

    NumberOfBytes - Supplies the number of bytes to allocate.

    LowestAcceptableAddress - Supplies the lowest physical address
                              which is valid for the allocation.  For
                              example, if the device can only reference
                              physical memory in the 8M to 16MB range, this
                              value would be set to 0x800000 (8Mb).

    HighestAcceptableAddress - Supplies the highest physical address
                               which is valid for the allocation.  For
                               example, if the device can only reference
                               physical memory below 16MB, this
                               value would be set to 0xFFFFFF (16Mb - 1).

    Alignment - Supplies the desired page alignment for the allocation.  The
                alignment is treated as a power of two.  The minimum alignment
                is PAGE_SIZE.

    Protect - Supplies the type of protection and cache mapping to use for the
              allocation.

Return Value:

    NULL - a contiguous range could not be found to satisfy the request.

    NON-NULL - Returns a pointer (virtual address in the nonpaged portion
               of the system) to the allocated physically contiguous
               memory.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    ULONG PhysicalAperture;
    MMPTE TempPte;
    PFN_NUMBER LowestAcceptablePageFrameNumber;
    PFN_NUMBER HighestAcceptablePageFrameNumber;
    PFN_COUNT PfnAlignment;
    PFN_COUNT PfnAlignmentMask;
    PFN_COUNT NumberOfPages;
    PFN_COUNT PfnAlignmentSubtraction;
    KIRQL OldIrql;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;
    PFN_COUNT ContiguousCandidatePagesFound;
    PFN_NUMBER EndingPageFrameNumber;
    PFN_NUMBER PageFrameNumberToGrab;

    ASSERT(NumberOfBytes != 0);

    //
    // Determine which system memory aperature to use.  If this is a video
    // memory request, use the write-combined memory aperture, otherwise use the
    // standard memory aperture.
    //

    if (Protect & PAGE_OLD_VIDEO) {
        PhysicalAperture = MM_WRITE_COMBINE_APERTURE;
        Protect = (Protect & ~PAGE_OLD_VIDEO);
    } else {
        PhysicalAperture = 0;
    }

    //
    // Convert the protect code to a PTE mask.
    //

    if (!MiMakeSystemPteProtectionMask(Protect, &TempPte)) {
        return NULL;
    }

    //
    // Convert the supplied physical addresses into page frame numbers.
    //

    LowestAcceptablePageFrameNumber =
        (PFN_NUMBER)(LowestAcceptableAddress >> PAGE_SHIFT);
    HighestAcceptablePageFrameNumber =
        (PFN_NUMBER)(HighestAcceptableAddress >> PAGE_SHIFT);

    if (HighestAcceptablePageFrameNumber > MM_CONTIGUOUS_MEMORY_LIMIT) {
        HighestAcceptablePageFrameNumber = MM_CONTIGUOUS_MEMORY_LIMIT;
    }

    if (LowestAcceptablePageFrameNumber > HighestAcceptablePageFrameNumber) {
        LowestAcceptablePageFrameNumber = HighestAcceptablePageFrameNumber;
    }

    //
    // Compute the alignment of the allocation in terms of pages.  The alignment
    // should be a power of two.
    //

    ASSERT((Alignment & (Alignment - 1)) == 0);

    PfnAlignment = (PFN_COUNT)(Alignment >> PAGE_SHIFT);

    if (PfnAlignment == 0) {
        PfnAlignment = 1;
    }

    //
    // Compute the alignment mask to round a page frame number down to the
    // nearest alignment boundary.
    //

    PfnAlignmentMask = ~(PfnAlignment - 1);

    //
    // Compute the number of pages to allocate.
    //

    NumberOfPages = BYTES_TO_PAGES(NumberOfBytes);

    //
    // Compute the number of pages to subtract from an aligned page frame number
    // to get to the prior candidate ending page frame number.
    //

    PfnAlignmentSubtraction = ((NumberOfPages + PfnAlignment - 1) &
        PfnAlignmentMask) - NumberOfPages + 1;

    //
    // Now ensure that we can allocate the required number of pages.
    //

    MI_LOCK_MM(&OldIrql);

    if (MmAvailablePages < NumberOfPages) {
        MI_UNLOCK_MM(OldIrql);
        return NULL;
    }

    //
    // Search the page frame database for a range that satisfies the size and
    // alignment requirements.
    //

    PageFrameNumber = HighestAcceptablePageFrameNumber + 1;

InvalidCandidatePageFound:
    PageFrameNumber = (PageFrameNumber & PfnAlignmentMask) -
        PfnAlignmentSubtraction;
    ContiguousCandidatePagesFound = 0;

    while ((SPFN_NUMBER)PageFrameNumber >= (SPFN_NUMBER)LowestAcceptablePageFrameNumber) {

        PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

        //
        // If we have a page frame that's already being used for a physical
        // mapping, then this is an invalid candidate page.
        //

        if (PageFrame->Pte.Hard.Valid != 0) {
            goto InvalidCandidatePageFound;
        }

        //
        // If we have a page frame that's busy and is locked for I/O, then we
        // can't relocate the page, so this is an invalid candidate page.
        //

        if ((PageFrame->Busy.Busy != 0) && (PageFrame->Busy.LockCount != 0)) {
            goto InvalidCandidatePageFound;
        }

        //
        // This page can be used to help satisfy the request.  If we haven't
        // found the required number of physical pages yet, then continue the
        // search.
        //

        ContiguousCandidatePagesFound++;

        if (ContiguousCandidatePagesFound < NumberOfPages) {
            PageFrameNumber--;
            continue;
        }

        //
        // Verify that the starting page frame number is correctly aligned.
        //

        ASSERT((PageFrameNumber & (PfnAlignment - 1)) == 0);

        //
        // We found a range of physical pages of the requested size.
        //

        EndingPageFrameNumber = PageFrameNumber + NumberOfPages - 1;

        //
        // First, allocate all of the free pages in the range so that any
        // relocations we do won't go into our target range.
        //

        for (PageFrameNumberToGrab = PageFrameNumber;
            PageFrameNumberToGrab <= EndingPageFrameNumber;
            PageFrameNumberToGrab++) {

            PageFrame = MI_PFN_ELEMENT(PageFrameNumberToGrab);

            if (PageFrame->Busy.Busy == 0) {

                //
                // Detach the page from the free list.
                //

                MiRemovePageFromFreeList(PageFrameNumberToGrab);

                //
                // Convert the page frame to a physically mapped page.
                //

                TempPte.Hard.PageFrameNumber = PageFrameNumberToGrab +
                    PhysicalAperture;
                MI_WRITE_PTE(&PageFrame->Pte, TempPte);

                //
                // Increment the number of physically mapped pages.
                //

                MmAllocatedPagesByUsage[MmContiguousUsage]++;
            }
        }

        //
        // Second, relocate any non-pinned pages in the range.  The above loop
        // will allocate physically mapped pages and there won't be any pinned
        // pages already existing in the range due to the above candidate page
        // checks.
        //

        for (PageFrameNumberToGrab = PageFrameNumber;
            PageFrameNumberToGrab <= EndingPageFrameNumber;
            PageFrameNumberToGrab++) {

            PageFrame = MI_PFN_ELEMENT(PageFrameNumberToGrab);

            if (PageFrame->Pte.Hard.Valid == 0) {

                //
                // Relocate the page.
                //

                MiRelocateBusyPage(PageFrameNumberToGrab);

                //
                // Convert the page frame to a physically mapped page.
                //

                TempPte.Hard.PageFrameNumber = PageFrameNumberToGrab +
                    PhysicalAperture;
                MI_WRITE_PTE(&PageFrame->Pte, TempPte);

                //
                // Increment the number of physically mapped pages.
                //

                MmAllocatedPagesByUsage[MmContiguousUsage]++;
            }
        }

        //
        // Mark the last page of the allocation with a flag so that we
        // can later determine the size of this allocation.
        //

        MI_PFN_ELEMENT(EndingPageFrameNumber)->Pte.Hard.GuardOrEndOfAllocation = 1;

        //
        // Write combined accesses may not check the processor's cache, so force
        // a flush of the TLB and cache now to ensure coherency.
        //
        // Flush the cache for uncached allocations so that all cache lines from
        // the page are out of the processor's caches.  The pages are likely to
        // be shared with an external device and the external device may not
        // snoop cache lines.
        //

        if (Protect & (PAGE_WRITECOMBINE | PAGE_NOCACHE)) {
            KeFlushCurrentTbAndInvalidateAllCaches();
        }

        MI_UNLOCK_MM(OldIrql);

        return MI_CONVERT_PFN_TO_PHYSICAL(PageFrameNumber);
    }

    MI_UNLOCK_MM(OldIrql);

    return NULL;
}

VOID
MmFreeContiguousMemory(
    IN PVOID BaseAddress
    )
/*++

Routine Description:

    This function deallocates a range of physically contiguous non-paged
    pool which was allocated with the MmAllocateContiguousMemory function.

Arguments:

    BaseAddress - Supplies the base virtual address where the physical
                  address was previously mapped.

Return Value:

    None.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    KIRQL OldIrql;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;
    ULONG EndOfAllocation;

    ASSERT(MI_IS_PHYSICAL_ADDRESS(BaseAddress));

    //
    // Release each page in the buffer while looking for the end of allocation
    // marker bit in the PTE.
    //

    MI_LOCK_MM(&OldIrql);

    PageFrameNumber = MI_CONVERT_PHYSICAL_TO_PFN(BaseAddress);

    do {

        PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

        ASSERT(PageFrame->Pte.Hard.Valid != 0);

        EndOfAllocation = MI_PFN_ELEMENT(PageFrameNumber)->Pte.Hard.GuardOrEndOfAllocation;

        //
        // Insert the page at the tail of the free lists so that we keep this
        // range of contiguous pages free as long as possible in order to
        // satisfy another contiguous memory allocation request.
        //

        MiInsertPageInFreeList(PageFrameNumber, FALSE);

        //
        // Flush the system RAM physical mapping.
        //

        MI_FLUSH_VA(MI_CONVERT_PFN_TO_PHYSICAL(PageFrameNumber));

        //
        // Decrement the number of physically mapped pages.
        //

        MmAllocatedPagesByUsage[MmContiguousUsage]--;

        PageFrameNumber++;

    } while (!EndOfAllocation);

    MI_UNLOCK_MM(OldIrql);
}

SIZE_T
MmQueryAllocationSize(
    IN PVOID BaseAddress
    )
/*++

Routine Description:

    This function attempts to query the number of bytes allocated to a range of
    memory.  This is designed to work with memory allocated by
    MmAllocateContiguousMemory or MmAllocateSystemMemory.

Arguments:

    BaseAddress - Supplies the base virtual address where the system memory
                  resides.

Return Value:

    Number of bytes allocated to the base address.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    KIRQL OldIrql;
    PFN_COUNT NumberOfPages;
    PMMPTE PointerPte;

    MI_LOCK_MM(&OldIrql);

    //
    // Start with one page for the page of the base address.  Loop over the PTEs
    // of the buffer looking for the end of allocation marker.
    //

    NumberOfPages = 1;
    PointerPte = MiGetPteAddress(BaseAddress);

    while (PointerPte->Hard.GuardOrEndOfAllocation == 0) {

        ASSERT(PointerPte->Hard.Valid != 0);

        NumberOfPages++;
        PointerPte++;
    }

    MI_UNLOCK_MM(OldIrql);

    return NumberOfPages << PAGE_SHIFT;
}

VOID
MmPersistContiguousMemory(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes,
    IN BOOLEAN Persist
    )
/*++

Routine Description:

    This function marks a contiguous memory allocation as needing to be
    preserved across a quick reboot.

Arguments:

    BaseAddress - Supplies the base virtual address where the system memory
                  resides.

    NumberOfBytes - Supplies the number of bytes to be preserved.

    Persist - Supplies TRUE if the memory should be persisted, else FALSE.

Return Value:

    None.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    KIRQL OldIrql;
    PMMPTE PointerPte;
    PMMPTE EndingPte;

    ASSERT(MI_IS_PHYSICAL_ADDRESS(BaseAddress));
    ASSERT(NumberOfBytes != 0);

    MI_LOCK_MM(&OldIrql);

    PointerPte = MiGetPteAddress(BaseAddress);
    EndingPte = MiGetPteAddress((PCHAR)BaseAddress + NumberOfBytes - 1);
    Persist = Persist ? TRUE : FALSE;

    while (PointerPte <= EndingPte) {

        ASSERT(PointerPte->Hard.Valid != 0);

        PointerPte->Hard.PersistAllocation = Persist;
        PointerPte++;
    }

    MI_UNLOCK_MM(OldIrql);
}

PVOID
MmMapIoSpace(
    IN ULONG_PTR PhysicalAddress,
    IN SIZE_T NumberOfBytes,
    IN ULONG Protect
    )
/*++

Routine Description:

    This function maps the specified physical address into the non-pagable
    portion of the system address space.

Arguments:

    PhysicalAddress - Supplies the starting physical address to map.

    NumberOfBytes - Supplies the number of bytes to map.

    Protect - Supplies the type of protection and cache mapping to use for the
              allocation.

Return Value:

    Returns the virtual address which maps the specified physical addresses.
    The value NULL is returned if sufficient virtual address space for
    the mapping could not be found.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    MMPTE TempPte;
    PFN_COUNT NumberOfPtes;
    PMMPTE StartingPte;
    PMMPTE PointerPte;
    PFN_NUMBER PageFrameNumber;
    PMMPTE EndingPte;
    PVOID BaseAddress;

    ASSERT (NumberOfBytes != 0);

    //
    // Convert the protect code to a PTE mask.
    //

    if (!MiMakeSystemPteProtectionMask(Protect, &TempPte)) {
        return NULL;
    }

    //
    // If the mapping is for device memory, then use one of the physical device
    // mappings if we recoginze the cache type.  These device mappings are
    // identity mapped, so the base address is simply the physical address.
    //

    if ((Protect == (PAGE_READWRITE | PAGE_NOCACHE)) &&
        (PhysicalAddress >= MM_DEVICE_UC_BASE) &&
        (PhysicalAddress + NumberOfBytes <= MM_DEVICE_UC_END)) {
        BaseAddress = (PVOID)PhysicalAddress;
        return BaseAddress;
    }

    if ((Protect == (PAGE_READWRITE | PAGE_WRITECOMBINE)) &&
        (PhysicalAddress >= MM_DEVICE_WC_BASE) &&
        (PhysicalAddress + NumberOfBytes <= MM_DEVICE_WC_END)) {
        BaseAddress = (PVOID)PhysicalAddress;
        goto ReturnWriteCombinedAddress;
    }

    //
    // Reserve the PTEs for the mapped memory.
    //

    NumberOfPtes = COMPUTE_PAGES_SPANNED(PhysicalAddress, NumberOfBytes);

    StartingPte = MiReserveSystemPtes(&MmSystemPteRange, NumberOfPtes);
    if (StartingPte == NULL) {
        return NULL;
    }

    //
    // Fill in the PTEs.
    //

    PageFrameNumber = (PFN_NUMBER)(PhysicalAddress >> PAGE_SHIFT);
    EndingPte = StartingPte + NumberOfPtes;

    for (PointerPte = StartingPte; PointerPte < EndingPte; PointerPte++,
        PageFrameNumber++) {
        TempPte.Hard.PageFrameNumber = PageFrameNumber;
        MI_WRITE_PTE(PointerPte, TempPte);
    }

    //
    // Compute the offset into the mapped region for the requested address.
    //

    BaseAddress = (PCHAR)MiGetVirtualAddressMappedByPte(StartingPte) +
        BYTE_OFFSET(PhysicalAddress);

    //
    // Write combined accesses may not check the processor's cache, so force a
    // flush of the TLB and cache now to ensure coherency.
    //
    // Flush the cache for uncached allocations so that all cache lines from the
    // page are out of the processor's caches.  The pages are likely to be
    // shared with an external device and the external device may not snoop the
    // cache lines.
    //

    if (Protect & (PAGE_WRITECOMBINE | PAGE_NOCACHE)) {
ReturnWriteCombinedAddress:
        KeFlushCurrentTbAndInvalidateAllCaches();
    }

    return BaseAddress;
}

VOID
MmUnmapIoSpace(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    )
/*++

Routine Description:

    This function unmaps a range of physical address which were previously
    mapped via an MmMapIoSpace function call.

Arguments:

    BaseAddress - Supplies the base virtual address where the physical
                  address was previously mapped.

    NumberOfBytes - Supplies the number of bytes which were mapped.

Return Value:

    None.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    PFN_COUNT NumberOfPtes;
    PMMPTE StartingPte;

    ASSERT(NumberOfBytes != 0);

    if (MI_IS_SYSTEM_PTE_ADDRESS(BaseAddress)) {

        //
        // The physical address was not mapped into a physical mapping window.
        // Free the PTEs that were allocated to map the memory.
        //

        NumberOfPtes = COMPUTE_PAGES_SPANNED(BaseAddress, NumberOfBytes);
        StartingPte = MiGetPteAddress(BaseAddress);

        MiZeroAndFlushPtes(StartingPte, NumberOfPtes);
        MiReleaseSystemPtes(&MmSystemPteRange, StartingPte, NumberOfPtes);
    }
}

VOID
MmLockUnlockBufferPages(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes,
    IN BOOLEAN UnlockPages
    )
/*++

Routine Description:

    This function locks or unlocks the physical pages backing the specified
    buffer.  The routine may be called multiple times for a given buffer and
    buffer ranges may overlap.  Every lock call must be matched by an unlock
    call.

Arguments:

    BaseAddress - Supplies the base virtual address to lock or unlock.

    NumberOfBytes - Supplies the number of bytes to lock or unlock.

    UnlockPages - If TRUE, the pages are unlocked, else the pages are locked.

Return Value:

    None.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    KIRQL OldIrql;
    ULONG LockCountAdjustment;
    PFN_NUMBER PageFrameNumber;
    PMMPTE PointerPte;
    PMMPTE EndingPte;
    PMMPFN PageFrame;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(NumberOfBytes != 0);

    MI_LOCK_MM(&OldIrql);

    ASSERT(MiGetPdeAddress(BaseAddress)->Hard.Valid != 0);

    //
    // If this is a physically mapped address, then there's nothing to lock or
    // unlock.  Locking is used to prevent virtually mapped pages from being
    // relocated while a device is accessing the page.
    //
    // If this is an address backed by a large page, then there's nothing to
    // lock or unlock.  Large pages are used for memory mapped I/O.
    //

    if (!MI_IS_PHYSICAL_ADDRESS(BaseAddress) &&
        (MiGetPdeAddress(BaseAddress)->Hard.LargePage == 0)) {

        LockCountAdjustment = UnlockPages ? (-MI_LOCK_COUNT_UNIT) :
            MI_LOCK_COUNT_UNIT;

        PointerPte = MiGetPteAddress(BaseAddress);
        EndingPte = MiGetPteAddress((PCHAR)BaseAddress + NumberOfBytes - 1);

        do {

            ASSERT(PointerPte->Hard.Valid != 0);

            PageFrameNumber = PointerPte->Hard.PageFrameNumber;

            if (PageFrameNumber <= MM_HIGHEST_PHYSICAL_PAGE) {

                PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

                ASSERT(PageFrame->Pte.Hard.Valid == 0);
                ASSERT(PageFrame->Busy.Busy != 0);
                ASSERT(PageFrame->Busy.BusyType != MmUnknownUsage);
                ASSERT(PageFrame->Busy.BusyType < MmMaximumUsage);

                if (UnlockPages) {
                    ASSERT(PageFrame->Busy.LockCount != 0);
                } else {
                    ASSERT(PageFrame->Busy.LockCount != MI_LOCK_COUNT_MAXIMUM);
                }

                PageFrame->Busy.LockCount += LockCountAdjustment;
            }

            PointerPte++;

        } while (PointerPte <= EndingPte);
    }

    MI_UNLOCK_MM(OldIrql);
}

VOID
MmLockUnlockPhysicalPage(
    IN ULONG_PTR PhysicalAddress,
    IN BOOLEAN UnlockPage
    )
/*++

Routine Description:

    This function locks or unlocks the specified physical page.

Arguments:

    BaseAddress - Supplies the physical page to lock or unlock.

    UnlockPage - If TRUE, the page is unlocked, else the page is locked.

Return Value:

    None.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    KIRQL OldIrql;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    MI_LOCK_MM(&OldIrql);

    PageFrameNumber = PhysicalAddress >> PAGE_SHIFT;

    //
    // If this is a physically mapped page or a memory mapped I/O page, then
    // there's nothing to lock or unlock.  Physically mapped pages are by
    // definition always locked and memory mapped I/O addresses are not managed
    // by this code.
    //

    if ((MI_PFN_ELEMENT(PageFrameNumber)->Pte.Hard.Valid == 0) &&
        (PageFrameNumber <= MM_HIGHEST_PHYSICAL_PAGE)) {

        PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

        ASSERT(PageFrame->Pte.Hard.Valid == 0);
        ASSERT(PageFrame->Busy.Busy != 0);
        ASSERT(PageFrame->Busy.BusyType != MmUnknownUsage);
        ASSERT(PageFrame->Busy.BusyType < MmMaximumUsage);

        if (UnlockPage) {
            ASSERT(PageFrame->Busy.LockCount != 0);
            PageFrame->Busy.LockCount -= MI_LOCK_COUNT_UNIT;
        } else {
            ASSERT(PageFrame->Busy.LockCount != MI_LOCK_COUNT_MAXIMUM);
            PageFrame->Busy.LockCount += MI_LOCK_COUNT_UNIT;
        }
    }

    MI_UNLOCK_MM(OldIrql);
}

NTSTATUS
MmLockSelectedIoPages(
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN OUT PIRP Irp,
    IN BOOLEAN MapUserBuffer
    )
/*++

Routine Description:

    This function locks the pages described by the supplied file segment element
    array.  A copy of the array is placed in the supplied I/O request packet.
    Optionally, the file segment element array is mapped to a virtual buffer in
    system space for target devices that do not support scatter/gather I/O.

Arguments:

    SegmentArray - Supplies the list of file segments to be locked.

    Length - Supplies the number of bytes contained in the segment array.

    Irp - Supplies a pointer to the I/O request packet to receive a copy of the
        segment array as well as the optional virtual mapping.

    MapUserBuffer - Supplies whether or not to map a virtual user buffer for the
        segment array.

Return Value:

    Status of operation.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    PFN_COUNT NumberOfPages;
    PFILE_SEGMENT_ELEMENT SegmentArrayClone;
    PMMPTE MappingPte;
    KIRQL OldIrql;
    PFILE_SEGMENT_ELEMENT EndingSegmentArray;
    PVOID BufferAddress;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;
    MMPTE TempPte;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(Length != 0);

    NumberOfPages = ROUND_TO_PAGES(Length) >> PAGE_SHIFT;

    //
    // Allocate the array to hold the copy of the segment array and perform the
    // copy.
    //

    SegmentArrayClone = (PFILE_SEGMENT_ELEMENT)ExAllocatePoolWithTag(
        sizeof(FILE_SEGMENT_ELEMENT) * NumberOfPages, 'aSmM');

    if (SegmentArrayClone == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(SegmentArrayClone, SegmentArray,
        sizeof(FILE_SEGMENT_ELEMENT) * NumberOfPages);

    //
    // If we need to map a virtual buffer for the segment array, then reserve
    // the PTEs now.
    //

    if (MapUserBuffer) {

        MappingPte = MiReserveSystemPtes(&MmSystemPteRange, NumberOfPages);

        if (MappingPte == NULL) {
            ExFreePool(SegmentArrayClone);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Fill the I/O request packet with the mapped user buffer and set a
        // flag so that MmUnlockSelectedIoPages knows to release the mapping.
        //

        Irp->UserBuffer = MiGetVirtualAddressMappedByPte(MappingPte);
        Irp->Flags |= IRP_UNMAP_SEGMENT_ARRAY;

    } else {
        MappingPte = NULL;
    }

    //
    // Loop over the segment array and lock down each of the page buffers.
    //

    MI_LOCK_MM(&OldIrql);

    EndingSegmentArray = SegmentArray + NumberOfPages;

    while (SegmentArray < EndingSegmentArray) {

        BufferAddress = SegmentArray->Buffer;

        ASSERT(MiGetPdeAddress(BufferAddress)->Hard.Valid != 0);
        ASSERT(MiGetPdeAddress(BufferAddress)->Hard.LargePage == 0);

        if (!MI_IS_PHYSICAL_ADDRESS(BufferAddress)) {

            ASSERT(MiGetPteAddress(BufferAddress)->Hard.Valid != 0);

            PageFrameNumber = MiGetPteAddress(BufferAddress)->Hard.PageFrameNumber;

            if (PageFrameNumber <= MM_HIGHEST_PHYSICAL_PAGE) {

                PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

                ASSERT(PageFrame->Pte.Hard.Valid == 0);
                ASSERT(PageFrame->Busy.Busy != 0);
                ASSERT(PageFrame->Busy.BusyType != MmUnknownUsage);
                ASSERT(PageFrame->Busy.BusyType < MmMaximumUsage);
                ASSERT(PageFrame->Busy.LockCount != MI_LOCK_COUNT_MAXIMUM);

                PageFrame->Busy.LockCount += MI_LOCK_COUNT_UNIT;
            }

        } else {
            PageFrameNumber = MI_CONVERT_PHYSICAL_TO_PFN(BufferAddress);
        }

        //
        // If we need to map a virtual buffer for the segment array, then fill
        // in the next mapping PTE.
        //

        if (MappingPte != NULL) {
            TempPte.Long = MiGetValidKernelPteBits();
            TempPte.Hard.PageFrameNumber = PageFrameNumber;
            MI_WRITE_PTE(MappingPte, TempPte);
            MappingPte++;
        }

        SegmentArray++;
    }

    MI_UNLOCK_MM(OldIrql);

    //
    // Fill the I/O request packet with the copy of the segment array and the
    // number of bytes that are locked down.  These are used by
    // MmUnlockSelectedIoPages.
    //

    Irp->SegmentArray = SegmentArrayClone;
    Irp->LockedBufferLength = Length;

    return STATUS_SUCCESS;
}

VOID
MmUnlockSelectedIoPages(
    IN PIRP Irp
    )
/*++

Routine Description:

    This function unlocks the pages described by the file segment element
    pointed to by the supplied I/O request packet.  Optionally, the virtual
    mapping created by MmLockSelectedPages is unmapped.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    PFN_COUNT NumberOfPages;
    PMMPTE MappingPte;
    KIRQL OldIrql;
    PFILE_SEGMENT_ELEMENT SegmentArray;
    PFILE_SEGMENT_ELEMENT EndingSegmentArray;
    PVOID BufferAddress;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(Irp->SegmentArray != NULL);
    ASSERT(Irp->LockedBufferLength != 0);

    NumberOfPages = ROUND_TO_PAGES(Irp->LockedBufferLength) >> PAGE_SHIFT;

    //
    // If we mapped a virtual buffer for the segment array, then release the
    // PTEs now.
    //

    if (Irp->Flags & IRP_UNMAP_SEGMENT_ARRAY) {

        ASSERT(Irp->UserBuffer != NULL);

        MappingPte = MiGetPteAddress(Irp->UserBuffer);

        MiZeroAndFlushPtes(MappingPte, NumberOfPages);
        MiReleaseSystemPtes(&MmSystemPteRange, MappingPte, NumberOfPages);

        Irp->UserBuffer = NULL;
        Irp->Flags &= ~IRP_UNMAP_SEGMENT_ARRAY;
    }

    //
    // Loop over the segment array and unlock each of the page buffers.
    //

    MI_LOCK_MM(&OldIrql);

    SegmentArray = Irp->SegmentArray;
    EndingSegmentArray = SegmentArray + NumberOfPages;

    while (SegmentArray < EndingSegmentArray) {

        BufferAddress = SegmentArray->Buffer;

        ASSERT(MiGetPdeAddress(BufferAddress)->Hard.Valid != 0);
        ASSERT(MiGetPdeAddress(BufferAddress)->Hard.LargePage == 0);

        if (!MI_IS_PHYSICAL_ADDRESS(BufferAddress)) {

            ASSERT(MiGetPteAddress(BufferAddress)->Hard.Valid != 0);

            PageFrameNumber = MiGetPteAddress(BufferAddress)->Hard.PageFrameNumber;

            if (PageFrameNumber <= MM_HIGHEST_PHYSICAL_PAGE) {

                PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

                ASSERT(PageFrame->Pte.Hard.Valid == 0);
                ASSERT(PageFrame->Busy.Busy != 0);
                ASSERT(PageFrame->Busy.BusyType != MmUnknownUsage);
                ASSERT(PageFrame->Busy.BusyType < MmMaximumUsage);
                ASSERT(PageFrame->Busy.LockCount != 0);

                PageFrame->Busy.LockCount -= MI_LOCK_COUNT_UNIT;
            }
        }

        SegmentArray++;
    }

    MI_UNLOCK_MM(OldIrql);

    //
    // Free the memory for the copied segment array.
    //

    ExFreePool(Irp->SegmentArray);

    Irp->SegmentArray = NULL;
}

PVOID
MmClaimGpuInstanceMemory(
    IN SIZE_T NumberOfBytes,
    OUT SIZE_T *NumberOfPaddingBytes
    )
/*++

Routine Description:

    This function returns the ending physical address and number of instance
    padding bytes for instance memory used by the NVIDIA NV2A.

Arguments:

    NumberOfBytes - Specifies the number of bytes to leave allocated for
        instance memory, or MAXULONG_PTR if no change in instance memory
        allocation should be made (used by the startup animation).

    NumberOfPaddingBytes - Specifies the location to receive the number of bytes
        that are reserved from the top of memory for other system use.

Return Value:

    Returns the virtual address of the pointer to the last byte, not inclusive,
    of the instance memory.

Environment:

    Kernel mode, <= DISPATCH_LEVEL.

--*/
{
    KIRQL OldIrql;
    PFN_NUMBER PageFrameNumber;
    PFN_NUMBER EndingPageFrameNumber;

    //
    // The number of padding bytes indicates the number of bytes that must be
    // skipped over in order to reach the first byte of the instance memory.
    //
    // For a retail console configuration, the top 64K of memory is used to
    // store the PFN database.  For a 128M configuration, we'll also reserve the
    // top 64K of memory in order to make the code simpler.
    //

#ifdef ARCADE
    *NumberOfPaddingBytes = 0;
#else
    *NumberOfPaddingBytes = MI_CONVERT_PFN_TO_PHYSICAL(MM_64M_PHYSICAL_PAGE) -
        MI_CONVERT_PFN_TO_PHYSICAL(MM_INSTANCE_PHYSICAL_PAGE + MM_INSTANCE_PAGE_COUNT);
#endif

    //
    // The startup animation code will call us with a number of bytes set to
    // MAXULONG_PTR.  At this point, don't free any of the instance memory
    // pages.
    //

    if (NumberOfBytes != MAXULONG_PTR) {

        MI_LOCK_MM(&OldIrql);

        NumberOfBytes = ROUND_TO_PAGES(NumberOfBytes);

        //
        // Verify that the requested allocation size is equal to or less than
        // the number of bytes already set aside for instance memory.
        //

        ASSERT(NumberOfBytes <= MmNumberOfInstanceMemoryBytes);

        //
        // Compute the number of pages that can be freed as instance memory and
        // made available for other use.
        //

        PageFrameNumber = MM_INSTANCE_PHYSICAL_PAGE + MM_INSTANCE_PAGE_COUNT -
            BYTES_TO_PAGES(MmNumberOfInstanceMemoryBytes);
        EndingPageFrameNumber = MM_INSTANCE_PHYSICAL_PAGE +
            MM_INSTANCE_PAGE_COUNT - BYTES_TO_PAGES(NumberOfBytes);

        while (PageFrameNumber < EndingPageFrameNumber) {

            ASSERT(MI_PFN_ELEMENT(PageFrameNumber)->Pte.Hard.Valid != 0);

            //
            // Insert the page at the head of the free lists.  We don't allow
            // contiguous memory allocations to cross into the instance memory
            // region, so these pages might as well be allocated ahead of other
            // pages that could be used for contiguous memory allocations.
            //

            MiInsertPageInFreeList(PageFrameNumber, TRUE);

            MI_FLUSH_VA(MI_CONVERT_PFN_TO_PHYSICAL(PageFrameNumber));

            MmAllocatedPagesByUsage[MmContiguousUsage]--;

#ifdef CONSOLE_DEVKIT
            //
            // On a development kit system, the NVIDIA NV2A instance memory must
            // be relative to the top of memory, so we also reserve the instance
            // memory pages in the upper half of memory.
            //

            if (MM_HIGHEST_PHYSICAL_PAGE != MM_64M_PHYSICAL_PAGE - 1) {

                ASSERT(MI_PFN_ELEMENT(MM_64M_PHYSICAL_PAGE + PageFrameNumber)->Pte.Hard.Valid != 0);

                MiInsertPageInFreeList(MM_64M_PHYSICAL_PAGE + PageFrameNumber,
                    TRUE);

                MI_FLUSH_VA(MI_CONVERT_PFN_TO_PHYSICAL(MM_64M_PHYSICAL_PAGE +
                    PageFrameNumber));

                MmAllocatedPagesByUsage[MmContiguousUsage]--;
            }
#endif

            PageFrameNumber++;
        }

        MmNumberOfInstanceMemoryBytes = NumberOfBytes;

        MI_UNLOCK_MM(OldIrql);
    }

    //
    // Return the virtual address of the non-inclusive ending byte of the
    // instance memory allocation.  This pointer is always relative to the top
    // of memory.
    //

    return (PUCHAR)MI_CONVERT_PFN_TO_PHYSICAL(MM_HIGHEST_PHYSICAL_PAGE + 1) -
        *NumberOfPaddingBytes;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\mmx\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=mm

TARGETPATH=$(BASEDIR)\private\ntos\obj
TARGETTYPE=LIBRARY

INCLUDES=..;$(BASEDIR)\private\ntos\inc;$(BASEDIR)\private\ntos\ke;$(BASEDIR)\private\inc

MSC_WARNING_LEVEL=/W4 /WX

C_DEFINES=$(C_DEFINES) -D_NTSYSTEM_

!if defined(ARCADE)
C_DEFINES=$(C_DEFINES) -DARCADE
!endif

SOURCES=..\addrsup.c  \
        ..\debugsup.c \
        ..\fscache.c  \
        ..\mmfault.c  \
        ..\mminit.c   \
        ..\mmsup.c    \
        ..\mmsupa.asm \
        ..\pfnsup.c   \
        ..\physical.c \
        ..\sysptes.c  \
        ..\vadtree.c  \
        ..\virtual.c

PRECOMPILED_INCLUDE=..\mi.h
PRECOMPILED_PCH=mi.pch
PRECOMPILED_OBJ=mi.obj
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\mmx\sysptes.c ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    sysptes.c

Abstract:

    This module implements the functions to manipulate the system PTE space.
    These PTES are used to map kernel stacks, pool pages, and I/O devices.

--*/

#include "mi.h"

//
// Define a macro to access the size for free blocks larger than one entry.
//
#define MI_PTE_LIST_LARGE_BLOCK_SIZE(ppte) (((ppte)+1)->List.NextEntry)

//
// Define a macro to get the next entry from a PTE list.
//
#define MI_PTE_LIST_NEXT_ENTRY(ppte) ((PMMPTE)((ppte)->Long & MM_PTE_NEXT_ENTRY_MASK))

//
// Define a macro to encode the next entry value for the supplied PTE.
//
#define MI_PTE_LIST_ENCODE_NEXT_ENTRY(ppte) (((ULONG)(ppte)) >> 2)

//
// PTE range starting at MM_SYSTEM_PTE_BASE.
//
MMPTERANGE MmSystemPteRange = {
    { MM_EMPTY_PTE_LIST << 2 },
    MiGetPteAddress(MM_SYSTEM_PTE_BASE),
    MiGetPteAddress(MM_SYSTEM_PTE_BASE),
    MiGetPteAddress(MM_SYSTEM_PTE_END + 1),
    &MmAvailablePages,
    MiRemoveZeroPage
};

#ifdef DEVKIT
//
// PTE range starting at MM_DEVKIT_PTE_BASE.
//
// To allow consoles with only 64 megabytes to still be able to load the debug
// monitor, fall back on using the retail allocators.
//
// Arcade retail and DEVKIT units have the same amount of memory, so always use
// the retail allocators.
//
MMPTERANGE MmDeveloperKitPteRange = {
    { MM_EMPTY_PTE_LIST << 2 },
    MiGetPteAddress(MM_DEVKIT_PTE_BASE),
    MiGetPteAddress(MM_DEVKIT_PTE_BASE),
    MiGetPteAddress(MM_DEVKIT_PTE_END + 1),
#ifdef ARCADE
    &MmAvailablePages,
    MiRemoveZeroPage
#else
    &MmDeveloperKitPfnRegion.AvailablePages,
    MiRemoveDebuggerPage
#endif
};
#endif

PMMPTE
MiReserveSystemPtes(
    IN PMMPTERANGE PteRange,
    IN PFN_COUNT NumberOfPtes
    )
/*++

Routine Description:

    This routine allocates the specified number of contiguous PTE slots from the
    system page tables.

Arguments:

    PteRange - Supplies the PTE range to allocate the PTEs from.

    NumberOfPtes - Supplies the number of contiguous PTE slots to allocate.

Return Value:

    Returns a pointer to the first allocated PTE.

Environment:

    Kernel mode.

--*/
{
    KIRQL OldIrql;
    PMMPTE LastPointerPte;
    PMMPTE PointerPte;
    PFN_COUNT ExtraPtes;
    PFN_COUNT PtesToCommit;
    PFN_COUNT NumberOfPtesInBlock;
    MMPTE TempPte;
    PFN_COUNT PtesCommitted;
    PMMPTE PointerPde;

    ASSERT(NumberOfPtes != 0);

    MI_LOCK_MM(&OldIrql);

    //
    // Scan the free list for a block that can satisfy the requested size.
    //

RetryOperation:
    LastPointerPte = &PteRange->HeadPte;

    while (LastPointerPte->List.NextEntry != MM_EMPTY_PTE_LIST) {

        PointerPte = MI_PTE_LIST_NEXT_ENTRY(LastPointerPte);

        //
        // Verify that the list is ordered by free address.
        //

        if (LastPointerPte != &PteRange->HeadPte) {
            ASSERT(PointerPte > LastPointerPte);
        }

        if (PointerPte->List.OneEntry) {

            if (NumberOfPtes == 1) {
                LastPointerPte->List.NextEntry = PointerPte->List.NextEntry;
                goto ReturnPointerPte;
            }

        } else if (MI_PTE_LIST_LARGE_BLOCK_SIZE(PointerPte) == NumberOfPtes) {

            //
            // A single PTE can't be encoded in a format where Link.OneEntry is
            // clear.
            //

            ASSERT(NumberOfPtes != 1);

            LastPointerPte->List.NextEntry = PointerPte->List.NextEntry;
            goto ReturnPointerPte;

        } else if (MI_PTE_LIST_LARGE_BLOCK_SIZE(PointerPte) > NumberOfPtes) {

            //
            // The block has more PTEs that we need so shuffle the free count
            // into the next PTE or convert the PTE to the single PTE format.
            //

            ExtraPtes = MI_PTE_LIST_LARGE_BLOCK_SIZE(PointerPte) - NumberOfPtes;

            if (ExtraPtes > 1) {
                PointerPte[NumberOfPtes].List.OneEntry = 0;
                MI_PTE_LIST_LARGE_BLOCK_SIZE(&PointerPte[NumberOfPtes]) = ExtraPtes;
            } else {
                PointerPte[NumberOfPtes].List.OneEntry = 1;
            }

            PointerPte[NumberOfPtes].List.NextEntry = PointerPte->List.NextEntry;
            LastPointerPte->List.NextEntry += NumberOfPtes;
            goto ReturnPointerPte;
        }

        LastPointerPte = PointerPte;
    }

    //
    // The PTE list doesn't have a block that can satisfy the request.  See how
    // many PTEs we'll need to commit to make enough space.
    //

    PtesToCommit = NumberOfPtes;

    if (LastPointerPte != &PteRange->HeadPte) {

        NumberOfPtesInBlock = LastPointerPte->List.OneEntry ? 1 :
            MI_PTE_LIST_LARGE_BLOCK_SIZE(LastPointerPte);

        if (LastPointerPte + NumberOfPtesInBlock == PteRange->LastCommittedPte) {
            PtesToCommit -= NumberOfPtesInBlock;
        }
    }

    PtesToCommit = MI_ROUND_TO_SIZE(PtesToCommit, PTE_PER_PAGE);
    ASSERT(PtesToCommit > 0);

    //
    // Commit the additional page tables if there's enough virtual address space
    // to hold them.
    //

    if ((ULONG)(PteRange->LastReservedPte - PteRange->LastCommittedPte) >
        PtesToCommit) {

        if (*PteRange->AvailablePages >= (PtesToCommit / PTE_PER_PAGE)) {

            PointerPte = PteRange->LastCommittedPte;

            for (PtesCommitted = 0; PtesCommitted < PtesToCommit;
                PtesCommitted += PTE_PER_PAGE) {

                PointerPde = MiGetPteAddress(PteRange->LastCommittedPte);

                TempPte.Long = MiGetValidKernelPdeBits();
                TempPte.Hard.PageFrameNumber =
                    PteRange->RemovePageRoutine(MmSystemPageTableUsage, PointerPde);

                MI_WRITE_PTE(PointerPde, TempPte);

                PteRange->LastCommittedPte += PTE_PER_PAGE;
            }

            MiReleaseSystemPtes(PteRange, PointerPte, PtesToCommit);
            goto RetryOperation;
        }
    }

    PointerPte = NULL;

ReturnPointerPte:
    MI_UNLOCK_MM(OldIrql);

    return PointerPte;
}

VOID
MiReleaseSystemPtes(
    IN PMMPTERANGE PteRange,
    IN PMMPTE StartingPte,
    IN PFN_COUNT NumberOfPtes
    )
/*++

Routine Description:

    This routine frees the specified number of contiguous PTE slots from the
    system page tables.

Arguments:

    PteRange - Supplies the PTE range to free the PTEs to.

    StartingPte - Supplies the pointer to the first PTE to free.

    NumberOfPtes - Supplies the number of contiguous PTE slots to fre.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    KIRQL OldIrql;
    PMMPTE LastPointerPte;
    PMMPTE PointerPte;
    PFN_COUNT NumberOfPtesInBlock;

    ASSERT(NumberOfPtes != 0);
    ASSERT(StartingPte >= PteRange->FirstCommittedPte);
    ASSERT(StartingPte + NumberOfPtes <= PteRange->LastCommittedPte);

    MI_LOCK_MM(&OldIrql);

    //
    // Zero the PTEs.  The caller is responsible for deleting any pages attached
    // to these PTEs and flushing the TLB.
    //

    RtlFillMemoryUlong(StartingPte, NumberOfPtes * sizeof(MMPTE), 0);

    //
    // Scan the free list for the position to insert the PTE block.
    //

    LastPointerPte = &PteRange->HeadPte;

    while (LastPointerPte->List.NextEntry != MM_EMPTY_PTE_LIST) {

        PointerPte = MI_PTE_LIST_NEXT_ENTRY(LastPointerPte);

        //
        // Verify that the list is ordered by free address.
        //

        if (LastPointerPte != &PteRange->HeadPte) {
            ASSERT(PointerPte > LastPointerPte);
        }

        if (PointerPte > StartingPte) {

            //
            // Verify that the end of the block we're freeing up doesn't overlap
            // the start of the current block.
            //
            ASSERT(PointerPte >= StartingPte + NumberOfPtes);

            //
            // If the current block is contiguous with the block we're freeing
            // up, then combine the two blocks.
            //
            if (StartingPte + NumberOfPtes == PointerPte) {
                NumberOfPtesInBlock = PointerPte->List.OneEntry ? 1 :
                    MI_PTE_LIST_LARGE_BLOCK_SIZE(PointerPte);
                NumberOfPtes += NumberOfPtesInBlock;
                LastPointerPte->List.NextEntry = PointerPte->List.NextEntry;
            }

            break;
        }

        //
        // Verify that the end of the current block doesn't overlap the start of
        // the block we're freeing up.
        //

        ASSERT((PointerPte + (PointerPte->List.OneEntry ? 1 :
            MI_PTE_LIST_LARGE_BLOCK_SIZE(PointerPte))) <= StartingPte);

        LastPointerPte = PointerPte;
    }

    //
    // Set the number of PTEs in the freed block and link it into the free list.
    //

    if (NumberOfPtes > 1) {
        StartingPte->List.OneEntry = 0;
        StartingPte[1].List.NextEntry = NumberOfPtes;
    } else {
        StartingPte->List.OneEntry = 1;
    }

    StartingPte->List.NextEntry = LastPointerPte->List.NextEntry;
    LastPointerPte->List.NextEntry = MI_PTE_LIST_ENCODE_NEXT_ENTRY(StartingPte);

    //
    // If the previous block is contiguous with the block we're freeing up,
    // then combine the two blocks.
    //

    if (LastPointerPte != &PteRange->HeadPte) {

        NumberOfPtesInBlock = LastPointerPte->List.OneEntry ? 1 :
            MI_PTE_LIST_LARGE_BLOCK_SIZE(LastPointerPte);

        if (LastPointerPte + NumberOfPtesInBlock == StartingPte) {
            LastPointerPte->List.OneEntry = 0;
            LastPointerPte->List.NextEntry = StartingPte->List.NextEntry;
            MI_PTE_LIST_LARGE_BLOCK_SIZE(LastPointerPte) = NumberOfPtes +
                NumberOfPtesInBlock;
        }
    }

    MI_UNLOCK_MM(OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\mmx\pfnsup.c ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    pfnsup.c

Abstract:

    This module implements routines which provide support for managing the page
    frame database.

--*/

#include "mi.h"

//
// Define a macro to statically initialize a PFN region.
//
#define MI_PFN_REGION_INITIALIZER() {                                         \
    {                                                                         \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
        { MM_PACKED_PFN_NULL, MM_PACKED_PFN_NULL },                           \
    },                                                                        \
    0,                                                                        \
}

//
// Total number of physical pages available on the system.
//
DECLSPEC_STICKY PFN_COUNT MmNumberOfPhysicalPages;

//
// Highest physical page number in the system.
//
#ifdef CONSOLE_DEVKIT
PFN_NUMBER MmHighestPhysicalPage;
#else
DECLSPEC_RDATA PFN_NUMBER MmHighestPhysicalPage = MM_HIGHEST_PHYSICAL_PAGE;
#endif

//
// Database that contains the use of each allocatable physical page in the
// system.  Exposed here for the kernel debugger.
//
DECLSPEC_SELECTANY PMMPFN MmPfnDatabase = MM_PFN_DATABASE;

//
// Region for general use pages, such as code, pool, and stacks.
//
MMPFNREGION MmRetailPfnRegion = MI_PFN_REGION_INITIALIZER();

#ifdef CONSOLE_DEVKIT
//
// Region for the extra memory available in the development kits.
//
MMPFNREGION MmDeveloperKitPfnRegion = MI_PFN_REGION_INITIALIZER();

//
// Mapping from MI_PFN_REGION to the corresponding PMMPFNREGION.
//
PMMPFNREGION MmPfnRegions[MI_NUMBER_OF_REGIONS] = {
    &MmRetailPfnRegion,
    &MmDeveloperKitPfnRegion,
    &MmDeveloperKitPfnRegion,
    &MmDeveloperKitPfnRegion,
};

//
// Set if MmReleaseDeveloperKitMemory has been called to place all of the extra
// pages available on a developer kit in the general free lists.
//
BOOLEAN MmDeveloperKitMemoryReleased;
#endif

//
// Page color to use for the next allocation without a specified page color.
//
MMCOLOR MmNextDefaultPageColor;

//
// Number of pages that can be allocated for general use.
//
PFN_COUNT MmAvailablePages;

//
// Number of pages that have been allocated for the various usage types.
//
PFN_COUNT MmAllocatedPagesByUsage[MmMaximumUsage];

//
// Local support.
//

VOID
MiRelocateBusyPageHelper(
    IN PVOID OldPhysicalAddress,
    IN PVOID NewPhysicalAddress,
    IN PMMPTE PointerPte,
    IN MMPTE NewPteContents,
    IN BOOLEAN FullTlbFlush
    );

#if DBG
VOID
MiAssertFreeListsValid(
    VOID
    );
#define MI_ASSERT_FREE_LISTS_VALID()    MiAssertFreeListsValid()
#else
#define MI_ASSERT_FREE_LISTS_VALID()
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, MiInitializePfnDatabase)
#endif

VOID
MiInitializePfnDatabase(
    VOID
    )
/*++

Routine Description:

    This routine initializes the database used to track busy and free pages.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    KIRQL OldIrql;
    PIMAGE_NT_HEADERS NtHeader;
    ULONG NtosImageSize;
    PFN_COUNT PfnDatabaseSizeInPages;
    MMPFN TempPageFrame;
    ULONG PageFrameNumber;
    ULONG EndingPageFrameNumber;
#ifdef DEVKIT
    PXDATA_SECTION_HEADER DataSectionHeader;
#endif
    PIMAGE_SECTION_HEADER TextSectionHeader;

    MI_LOCK_MM(&OldIrql);

    //
    // Verify that the highest physical page doesn't exceed the limits of the
    // physical mapping window.
    //

    ASSERT(MM_HIGHEST_PHYSICAL_PAGE < MM_PAGES_IN_PHYSICAL_MAP);

    //
    // Find the NT headers for XBOXKRNL.EXE.
    //

    NtHeader = RtlImageNtHeader(PsNtosImageBase);

    ASSERT(NtHeader != NULL);
    ASSERT(NtHeader->FileHeader.NumberOfSections > 0);

    //
    // Get the size of the XBOXKRNL.EXE image.
    //

    NtosImageSize = ROUND_TO_PAGES(NtHeader->OptionalHeader.SizeOfImage);

    //
    // Compute how many pages will be required to hold the PFN database.
    //

    PfnDatabaseSizeInPages = BYTES_TO_PAGES((MM_HIGHEST_PHYSICAL_PAGE + 1) *
        sizeof(MMPFN));

    //
    // Initialize all entries in the PFN database as unknown usage with a
    // maximum reference count so that MmAllocateContiguousMemoryEx doesn't
    // consider the page when finding a candidate range.
    //

    TempPageFrame.Long = 0;
    TempPageFrame.Busy.Busy = 1;
    TempPageFrame.Busy.LockCount = MI_LOCK_COUNT_MAXIMUM;
    TempPageFrame.Busy.BusyType = MmUnknownUsage;

    RtlFillMemoryUlong(MM_PFN_DATABASE, PfnDatabaseSizeInPages * PAGE_SIZE,
        TempPageFrame.Long);

    //
    // Insert all of the pages from the bottom of memory to the base of
    // XBOXKRNL.EXE into the free lists.
    //

    MiInsertPhysicalMemoryInFreeList(MM_LOWEST_PHYSICAL_PAGE,
        MI_CONVERT_PHYSICAL_TO_PFN(PsNtosImageBase));

#ifdef ARCADE
    //
    // Insert all of the pages from the end of XBOXKRNL.EXE to the base of the
    // PFN database into the free lists.
    //

    MiInsertPhysicalMemoryInFreeList(
        MI_CONVERT_PHYSICAL_TO_PFN((PUCHAR)PsNtosImageBase + NtosImageSize),
        MM_DATABASE_PHYSICAL_PAGE);
#else
    //
    // Insert all of the pages from the end of XBOXKRNL.EXE to the base of the
    // NVIDIA NV2A instance memory into the free lists.
    //

    MiInsertPhysicalMemoryInFreeList(
        MI_CONVERT_PHYSICAL_TO_PFN((PUCHAR)PsNtosImageBase + NtosImageSize),
        MM_INSTANCE_PHYSICAL_PAGE);
#endif

#ifdef CONSOLE_DEVKIT
    //
    // Insert all of the pages from the end of the PFN database to the top of
    // memory into the free lists.
    //

    MiInsertPhysicalMemoryInFreeList(MM_DATABASE_PHYSICAL_PAGE +
        PfnDatabaseSizeInPages, MM_HIGHEST_PHYSICAL_PAGE + 1);
#endif

#ifdef DEVKIT
    //
    // If we booted from a shadow copy of the ROM, then we need to remove the
    // pages that were used to make a copy of the kernel's initialized data.
    //

    if (XboxBootFlags & XBOX_BOOTFLAG_SHADOW) {

        DataSectionHeader = (PXDATA_SECTION_HEADER)((PIMAGE_DOS_HEADER)PsNtosImageBase)->e_res2;

        PageFrameNumber = MI_CONVERT_PHYSICAL_TO_PFN(DataSectionHeader->PointerToRawData);
        EndingPageFrameNumber = PageFrameNumber +
            BYTES_TO_PAGES(DataSectionHeader->SizeOfInitializedData);

        while (PageFrameNumber < EndingPageFrameNumber) {

            MiRemovePageFromFreeList(PageFrameNumber);

            TempPageFrame.Pte.Long = MiGetValidKernelPteBits();
            TempPageFrame.Pte.Hard.Write = 0;
            TempPageFrame.Pte.Hard.PersistAllocation = 1;
            TempPageFrame.Pte.Hard.PageFrameNumber = PageFrameNumber;

            *MI_PFN_ELEMENT(PageFrameNumber) = TempPageFrame;

            MmAllocatedPagesByUsage[MmContiguousUsage]++;

            PageFrameNumber++;
        }
    }
#endif

    //
    // Convert the page frame that holds the page directory to a page table
    // entry.
    //

    PageFrameNumber = MI_CONVERT_PHYSICAL_TO_PFN(PAGE_DIRECTORY_PHYSICAL_ADDRESS);

    MiRemovePageFromFreeList(PageFrameNumber);

    TempPageFrame.Pte.Long = MiGetValidKernelPteBits();
    TempPageFrame.Pte.Hard.PersistAllocation = 1;
    TempPageFrame.Pte.Hard.GuardOrEndOfAllocation = 1;
    TempPageFrame.Pte.Hard.PageFrameNumber = PageFrameNumber;;

    *MI_PFN_ELEMENT(PageFrameNumber) = TempPageFrame;

    MmAllocatedPagesByUsage[MmContiguousUsage]++;

    //
    // Convert the page frames that hold XBOXKRNL.EXE to page table entries.
    //

    PageFrameNumber = MI_CONVERT_PHYSICAL_TO_PFN(PsNtosImageBase);
    EndingPageFrameNumber = MI_CONVERT_PHYSICAL_TO_PFN((PUCHAR)PsNtosImageBase +
        NtosImageSize);

    while (PageFrameNumber < EndingPageFrameNumber) {

        TempPageFrame.Pte.Long = MiGetValidKernelPteBits();
        TempPageFrame.Pte.Hard.PersistAllocation = 1;
        TempPageFrame.Pte.Hard.PageFrameNumber = PageFrameNumber;

        *MI_PFN_ELEMENT(PageFrameNumber) = TempPageFrame;

        MmNumberOfPhysicalPages++;
        MmAllocatedPagesByUsage[MmContiguousUsage]++;

        PageFrameNumber++;
    }

    //
    // Find the first section of XBOXKRNL.EXE, which by convention should be the
    // text section.
    //

    TextSectionHeader = IMAGE_FIRST_SECTION(NtHeader);

    ASSERT((*(PULONG)TextSectionHeader->Name) == 'xet.');
    ASSERT((TextSectionHeader->Characteristics & IMAGE_SCN_CNT_CODE) != 0);

    //
    // Convert the image headers and .text section of XBOXKRNL.EXE to read-only.
    //

    PageFrameNumber = MI_CONVERT_PHYSICAL_TO_PFN(PsNtosImageBase);
    EndingPageFrameNumber = MI_CONVERT_PHYSICAL_TO_PFN((PUCHAR)PsNtosImageBase +
        TextSectionHeader->Misc.VirtualSize);

    while (PageFrameNumber < EndingPageFrameNumber) {
        MI_PFN_ELEMENT(PageFrameNumber)->Pte.Hard.Write = 0;
        PageFrameNumber++;
    }

    //
    // Convert the page frames that hold the PFN database to page table entries.
    // The pages persist across a quick reboot.
    //

    PageFrameNumber = MM_DATABASE_PHYSICAL_PAGE;
    EndingPageFrameNumber = MM_DATABASE_PHYSICAL_PAGE + PfnDatabaseSizeInPages;

    while (PageFrameNumber < EndingPageFrameNumber) {

        TempPageFrame.Pte.Long = MiGetValidKernelPteBits();
        TempPageFrame.Pte.Hard.PersistAllocation = 1;
        TempPageFrame.Pte.Hard.PageFrameNumber = PageFrameNumber;

        *MI_PFN_ELEMENT(PageFrameNumber) = TempPageFrame;

        MmNumberOfPhysicalPages++;
        MmAllocatedPagesByUsage[MmContiguousUsage]++;

        PageFrameNumber++;
    }

    //
    // Convert the page frames that hold NV2A instance memory to page table
    // entries.
    //

    PageFrameNumber = MM_INSTANCE_PHYSICAL_PAGE;
    EndingPageFrameNumber = MM_INSTANCE_PHYSICAL_PAGE + MM_INSTANCE_PAGE_COUNT;

    while (PageFrameNumber < EndingPageFrameNumber) {

        TempPageFrame.Pte.Long = MiGetValidKernelPteBits();
        MI_DISABLE_CACHING(TempPageFrame.Pte);
        TempPageFrame.Pte.Hard.PageFrameNumber = PageFrameNumber;

        *MI_PFN_ELEMENT(PageFrameNumber) = TempPageFrame;

        MmNumberOfPhysicalPages++;
        MmAllocatedPagesByUsage[MmContiguousUsage]++;

        PageFrameNumber++;
    }

#ifdef CONSOLE_DEVKIT
    //
    // On a development kit system, the NVIDIA NV2A instance memory must be
    // relative to the top of memory, so we also reserve the instance memory
    // pages in the upper half of memory.
    //

    if (MM_HIGHEST_PHYSICAL_PAGE != MM_64M_PHYSICAL_PAGE - 1) {

        PageFrameNumber = MM_INSTANCE_PHYSICAL_PAGE + MM_64M_PHYSICAL_PAGE;
        EndingPageFrameNumber = MM_INSTANCE_PHYSICAL_PAGE +
            MM_INSTANCE_PAGE_COUNT + MM_64M_PHYSICAL_PAGE;

        while (PageFrameNumber < EndingPageFrameNumber) {

            MiRemovePageFromFreeList(PageFrameNumber);

            TempPageFrame.Pte.Long = MiGetValidKernelPteBits();
            MI_DISABLE_CACHING(TempPageFrame.Pte);
            TempPageFrame.Pte.Hard.PageFrameNumber = PageFrameNumber;

            *MI_PFN_ELEMENT(PageFrameNumber) = TempPageFrame;

            MmAllocatedPagesByUsage[MmContiguousUsage]++;

            PageFrameNumber++;
        }
    }
#endif

    //
    // Reserve the first physical page in the system for D3D's use.
    //

    MiRemovePageFromFreeList(MM_D3D_PHYSICAL_PAGE);

    TempPageFrame.Pte.Long = MiGetValidKernelPteBits();
    TempPageFrame.Pte.Hard.PersistAllocation = 1;
    TempPageFrame.Pte.Hard.GuardOrEndOfAllocation = 1;
    TempPageFrame.Pte.Hard.PageFrameNumber = MM_D3D_PHYSICAL_PAGE;

    *MI_PFN_ELEMENT(MM_D3D_PHYSICAL_PAGE) = TempPageFrame;

    MmAllocatedPagesByUsage[MmContiguousUsage]++;

    MI_UNLOCK_MM(OldIrql);
}

VOID
MiReinitializePfnDatabase(
    VOID
    )
/*++

Routine Description:

    This routine reinitializes the database used to track busy and free pages
    after a quick reboot has occurred.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    KIRQL OldIrql;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;

    MI_LOCK_MM(&OldIrql);

    //
    // Loop over the page frame database and either keep persistent pages or
    // insert pages into the free lists.
    //

    for (PageFrameNumber = MM_LOWEST_PHYSICAL_PAGE; PageFrameNumber <=
        MM_HIGHEST_PHYSICAL_PAGE; PageFrameNumber++) {

        PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

        if (PageFrame->Pte.Hard.Valid != 0) {

            //
            // The page was a contiguous memory allocation in the previous
            // instance of the kernel.  If the page is marked as being
            // peristent, then keep the allocation alive.
            //

            if (PageFrame->Pte.Hard.PersistAllocation != 0) {
                MmAllocatedPagesByUsage[MmContiguousUsage]++;
                continue;
            }

        } else if (PageFrame->Busy.Busy != 0) {

            //
            // The page was marked as an unknown page type in the previous
            // instance of the kernel.  Keep the page in this state since we
            // can't manage the page.
            //

            if (PageFrame->Busy.BusyType == MmUnknownUsage) {
                continue;
            }

        } else {

            //
            // The page was free in the previous instance of the kernel.
            //
        }

        //
        // MmAllocateContiguousMemorySpecifyCache searches for free pages from
        // the highest page to the lowest page, so insert pages such that the
        // lowest pages are at the front of the free lists.  This avoids
        // unnecessary page relocation in order to satisfy a contiguous memory
        // allocation.
        //

        MiInsertPageInFreeList(PageFrameNumber, FALSE);
    }

    MI_UNLOCK_MM(OldIrql);
}

VOID
FASTCALL
MiInsertPageInFreeList(
    IN PFN_NUMBER PageFrameNumber,
    IN BOOLEAN InsertAtHeadList
    )
/*++

Routine Description:

    This routine inserts the supplied physical page into the appropriate free
    list.  No assumptions are made about the current status of the page.

Arguments:

    PageFrameNumber - Supplies the physical page frame to insert.

    InsertAtHeadList - If TRUE, insert the page at the front of the free lists,
        else insert the page at the end of the free lists.

Return Value:

    None.

Environment:

    Kernel mode, DISPATCH_LEVEL.

--*/
{
    MMCOLOR Color;
    USHORT PackedPfn;
    PMMPFN PageFrame;
    PMMPFNREGION PfnRegion;
    PMMPFN OldLinkPageFrame;

    MI_ASSERT_LOCK_MM();

    ASSERT(PageFrameNumber <= MM_HIGHEST_PHYSICAL_PAGE);

    Color = MiGetPfnColor(PageFrameNumber);
    PackedPfn = MiPackFreePfn(PageFrameNumber);

    //
    // Verify that the caller is not attempting to free the page frame number
    // used as the end of list marker.
    //

    ASSERT(PackedPfn != MM_PACKED_PFN_NULL);

    //
    // Copy the list head to the freed page frame.  We'll clear out the forward
    // or backward link below depending on the list insertion direction.
    //

    PageFrame = MI_PFN_ELEMENT(PageFrameNumber);
    PfnRegion = MI_PFN_REGION(PageFrameNumber);
    PageFrame->Free = PfnRegion->FreePagesByColor[Color];

    if (PfnRegion->FreePagesByColor[Color].PackedPfnFlink != MM_PACKED_PFN_NULL) {

        //
        // The page color list was not empty, so link the new page list head or
        // tail to the old page list head or tail.
        //

        if (InsertAtHeadList) {

            PageFrame->Free.PackedPfnBlink = MM_PACKED_PFN_NULL;
            PfnRegion->FreePagesByColor[Color].PackedPfnFlink = PackedPfn;

            OldLinkPageFrame = MiUnpackFreePfnElement(PageFrame->Free.PackedPfnFlink,
                Color);

            ASSERT(OldLinkPageFrame->Free.PackedPfnBlink == MM_PACKED_PFN_NULL);
            OldLinkPageFrame->Free.PackedPfnBlink = PackedPfn;

        } else {

            PageFrame->Free.PackedPfnFlink = MM_PACKED_PFN_NULL;
            PfnRegion->FreePagesByColor[Color].PackedPfnBlink = PackedPfn;

            OldLinkPageFrame = MiUnpackFreePfnElement(PageFrame->Free.PackedPfnBlink,
                Color);

            ASSERT(OldLinkPageFrame->Free.PackedPfnFlink == MM_PACKED_PFN_NULL);
            OldLinkPageFrame->Free.PackedPfnFlink = PackedPfn;
        }

        ASSERT(OldLinkPageFrame->Busy.Busy == 0);

    } else {

        //
        // The page color list was empty, so make both the head and tail
        // pointer reference this page.
        //

        ASSERT(PageFrame->Free.PackedPfnFlink == MM_PACKED_PFN_NULL);
        ASSERT(PageFrame->Free.PackedPfnBlink == MM_PACKED_PFN_NULL);

        PfnRegion->FreePagesByColor[Color].PackedPfnBlink = PackedPfn;
        PfnRegion->FreePagesByColor[Color].PackedPfnFlink = PackedPfn;
    }

    //
    // Verify that the packed page frame numbers are structurally correct-- the
    // low bits must be clear to mark the page as free.
    //

    ASSERT(PageFrame->Pte.Hard.Valid == 0);
    ASSERT(PageFrame->Busy.Busy == 0);

    //
    // Update the number of available pages in the region.
    //

    PfnRegion->AvailablePages++;

#ifdef CONSOLE_DEVKIT
    //
    // Update the number of available pages in the system if the page is from
    // the retail PFN region or if the extra memory on a development kit is
    // available for general use.
    //

    if (PfnRegion == &MmRetailPfnRegion || MmDeveloperKitMemoryReleased) {
        MmAvailablePages++;
    }
#else
    //
    // Update the number of available pages in the system.
    //

    MmAvailablePages++;
#endif
}

VOID
MiInsertPhysicalMemoryInFreeList(
    IN PFN_NUMBER PageFrameNumber,
    IN PFN_NUMBER EndingPageFrameNumberExclusive
    )
/*++

Routine Description:

    This routine inserts a range of physical pages into the appropriate free
    lists.  No assumptions are made about the current status of the pages.

Arguments:

    PageFrameNumber - Supplies the first physical page frame to insert.

    EndingPageFrameNumberExclusive - Supplies the last physical page frame to
                                     insert, not including the page itself.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    MI_ASSERT_LOCK_MM();

    while (PageFrameNumber < EndingPageFrameNumberExclusive) {

        //
        // MmAllocateContiguousMemorySpecifyCache searches for free pages from
        // the highest page to the lowest page, so insert pages such that the
        // lowest pages are at the front of the free lists.  This avoids
        // unnecessary page relocation in order to satisfy a contiguous memory
        // allocation.
        //

        MiInsertPageInFreeList(PageFrameNumber, FALSE);

        MmNumberOfPhysicalPages++;

        PageFrameNumber++;
    }
}

VOID
FASTCALL
MiRemovePageFromFreeList(
    IN PFN_NUMBER PageFrameNumber
    )
/*++

Routine Description:

    This routine removes the supplied physical page from the free page list
    that it is currently attached to.

    The returned page frame is not initialized.

Arguments:

    PageFrameNumber - Supplies the physical page frame to remove.

Return Value:

    None.

Environment:

    Kernel mode, DISPATCH_LEVEL.

--*/
{
    MMCOLOR Color;
    USHORT PackedPfn;
    PMMPFN PageFrame;
    PMMPFNREGION PfnRegion;
    PMMPFN LinkPageFrame;

    MI_ASSERT_LOCK_MM();

    ASSERT(PageFrameNumber <= MM_HIGHEST_PHYSICAL_PAGE);

    Color = MiGetPfnColor(PageFrameNumber);
    PackedPfn = MiPackFreePfn(PageFrameNumber);

    PageFrame = MI_PFN_ELEMENT(PageFrameNumber);
    PfnRegion = MI_PFN_REGION(PageFrameNumber);

    ASSERT(PageFrame->Pte.Hard.Valid == 0);
    ASSERT(PageFrame->Busy.Busy == 0);

    //
    // Detach the page from its backward link.
    //

    if (PageFrame->Free.PackedPfnBlink != MM_PACKED_PFN_NULL) {

        LinkPageFrame = MiUnpackFreePfnElement(PageFrame->Free.PackedPfnBlink,
            Color);

        ASSERT(LinkPageFrame->Pte.Hard.Valid == 0);
        ASSERT(LinkPageFrame->Busy.Busy == 0);
        ASSERT(LinkPageFrame->Free.PackedPfnFlink == PackedPfn);

        LinkPageFrame->Free.PackedPfnFlink = PageFrame->Free.PackedPfnFlink;

        ASSERT(LinkPageFrame->Busy.Busy == 0);

    } else {

        //
        // The page is the head of the list.
        //

        ASSERT(PfnRegion->FreePagesByColor[Color].PackedPfnFlink == PackedPfn);
        PfnRegion->FreePagesByColor[Color].PackedPfnFlink =
            PageFrame->Free.PackedPfnFlink;
    }

    //
    // Detach the page from its forward link.
    //

    if (PageFrame->Free.PackedPfnFlink != MM_PACKED_PFN_NULL) {

        LinkPageFrame = MiUnpackFreePfnElement(PageFrame->Free.PackedPfnFlink,
            Color);

        ASSERT(LinkPageFrame->Pte.Hard.Valid == 0);
        ASSERT(LinkPageFrame->Busy.Busy == 0);
        ASSERT(LinkPageFrame->Free.PackedPfnBlink == PackedPfn);

        LinkPageFrame->Free.PackedPfnBlink = PageFrame->Free.PackedPfnBlink;

        ASSERT(LinkPageFrame->Busy.Busy == 0);

    } else {

        //
        // The page is the tail of the list.
        //

        ASSERT(PfnRegion->FreePagesByColor[Color].PackedPfnBlink == PackedPfn);
        PfnRegion->FreePagesByColor[Color].PackedPfnBlink =
            PageFrame->Free.PackedPfnBlink;
    }

    //
    // Update the number of available pages in the region.
    //

    PfnRegion->AvailablePages--;

#ifdef CONSOLE_DEVKIT
    //
    // Update the number of available pages in the system if the page is from
    // the retail PFN region or if the extra memory on a development kit is
    // available for general use.
    //

    if (PfnRegion == &MmRetailPfnRegion || MmDeveloperKitMemoryReleased) {
        MmAvailablePages--;
    }
#else
    //
    // Update the number of available pages in the system.
    //

    MmAvailablePages--;
#endif
}

PFN_NUMBER
FASTCALL
MiRemoveAnyPageFromFreeList(
    VOID
    )
/*++

Routine Description:

    This routine removes any physical page from the free page lists.

    The returned page frame is not initialized.

Arguments:

    None.

Return Value:

    The allocated physical page frame number.

Environment:

    Kernel mode, DISPATCH_LEVEL.

--*/
{
    PMMPFNREGION PfnRegion;
    MMCOLOR Color;
    USHORT PackedPfn;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;
    PMMPFN NewLinkPageFrame;

    MI_ASSERT_LOCK_MM();

    //
    // Verify that there are pages available.  The caller is responsible for
    // first checking that a page can be allocated.
    //

    ASSERT(MmAvailablePages > 0);

    //
    // Look for the first region with a free page.
    //

    PfnRegion = &MmRetailPfnRegion;

#ifdef CONSOLE_DEVKIT
    if (PfnRegion->AvailablePages == 0) {
        PfnRegion = &MmDeveloperKitPfnRegion;
        ASSERT(MmDeveloperKitMemoryReleased);
    }
#endif

    ASSERT(PfnRegion->AvailablePages > 0);

    //
    // Look for the first colored free list with a free page.
    //

    ASSERT(MmNextDefaultPageColor < MM_NUMBER_OF_COLORS);

    for (Color = MmNextDefaultPageColor; NOTHING;
        Color = ((Color + 1) & MM_NUMBER_OF_COLORS_MASK)) {

        if (PfnRegion->FreePagesByColor[Color].PackedPfnFlink !=
            MM_PACKED_PFN_NULL) {

            PackedPfn = PfnRegion->FreePagesByColor[Color].PackedPfnFlink;
            PageFrameNumber = MiUnpackFreePfn(PackedPfn, Color);

            ASSERT(PageFrameNumber <= MM_HIGHEST_PHYSICAL_PAGE);
            ASSERT(MI_PFN_REGION(PageFrameNumber) == PfnRegion);

            PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

            ASSERT(PageFrame->Pte.Hard.Valid == 0);
            ASSERT(PageFrame->Busy.Busy == 0);

            //
            // Unlink the page from the free list.
            //

            if (PageFrame->Free.PackedPfnFlink != MM_PACKED_PFN_NULL) {

                NewLinkPageFrame = MiUnpackFreePfnElement(PageFrame->Free.PackedPfnFlink,
                    Color);
                ASSERT(NewLinkPageFrame->Busy.Busy == 0);

                ASSERT(NewLinkPageFrame->Free.PackedPfnBlink ==
                    PfnRegion->FreePagesByColor[Color].PackedPfnFlink);
                NewLinkPageFrame->Free.PackedPfnBlink = MM_PACKED_PFN_NULL;

            } else {

                //
                // The page is the tail of the list.
                //

                ASSERT(PfnRegion->FreePagesByColor[Color].PackedPfnBlink == PackedPfn);
                PfnRegion->FreePagesByColor[Color].PackedPfnBlink = MM_PACKED_PFN_NULL;
            }

            ASSERT(PageFrame->Free.PackedPfnBlink == MM_PACKED_PFN_NULL);
            PfnRegion->FreePagesByColor[Color].PackedPfnFlink =
                PageFrame->Free.PackedPfnFlink;

            break;
        }
    }

    MmNextDefaultPageColor = ((Color + 1) & MM_NUMBER_OF_COLORS_MASK);

    //
    // Update the number of available pages in the region.
    //

    PfnRegion->AvailablePages--;

#ifdef CONSOLE_DEVKIT
    //
    // Update the number of available pages in the system if the page is from
    // the retail PFN region or if the extra memory on a development kit is
    // available for general use.
    //

    if (PfnRegion == &MmRetailPfnRegion || MmDeveloperKitMemoryReleased) {
        MmAvailablePages--;
    }
#else
    //
    // Update the number of available pages in the system.
    //

    MmAvailablePages--;
#endif

    return PageFrameNumber;
}

PFN_NUMBER
FASTCALL
MiRemoveAnyPage(
    IN MMPFN_BUSY_TYPE BusyType,
    IN PMMPTE TargetPte
    )
/*++

Routine Description:

    This routine removes one page from the free list and initializes it as a
    busy page with the supplied busy type.

    The contents of the page are uninitialized.

Arguments:

    BusyType - Usage code to place in allocated page frame.

    TargetPte - Supplies the address of the PDE/PTE that will receive the page
        frame.

Return Value:

    The allocated physical page frame number.

Environment:

    Kernel mode, DISPATCH_LEVEL.

--*/
{
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;

    ASSERT(BusyType < MmMaximumUsage);

    MI_ASSERT_LOCK_MM();

    //
    // Allocate any page from a free list.
    //

    PageFrameNumber = MiRemoveAnyPageFromFreeList();
    PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

    //
    // Initialize the page frame as busy.  Page tables created for the lower
    // half of the address space (user space) are always allocated via
    // MiRemoveZeroPage, so we don't need to handle that special case here.
    //

    ASSERT(BusyType != MmVirtualPageTableUsage);

    PageFrame->Long = 0;                // Also zeroes LockCount
    PageFrame->Busy.Busy = 1;
    PageFrame->Busy.BusyType = BusyType;

    PageFrame->Busy.PteIndex = MiGetPteOffset(MiGetVirtualAddressMappedByPte(TargetPte));

    //
    // Increment the number of pages of this type.
    //

    MmAllocatedPagesByUsage[BusyType]++;

    return PageFrameNumber;
}

PFN_NUMBER
FASTCALL
MiRemoveZeroPage(
    IN MMPFN_BUSY_TYPE BusyType,
    IN PMMPTE TargetPte
    )
/*++

Routine Description:

    This routine removes one page from the free list and initializes it as a
    busy page with the supplied busy type.

    The contents of the page are zeroed.

Arguments:

    BusyType - Usage code to place in allocated page frame.

    TargetPte - Supplies the address of the PDE/PTE that will receive the page
        frame.

Return Value:

    The allocated physical page frame number.

Environment:

    Kernel mode, DISPATCH_LEVEL.

--*/
{
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;
    MMPTE TempPte;

    ASSERT(BusyType < MmMaximumUsage);

    MI_ASSERT_LOCK_MM();

    //
    // Allocate any page from a free list.
    //

    PageFrameNumber = MiRemoveAnyPageFromFreeList();
    PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

    //
    // Zero the page's contents by temporarily exposing it through the system
    // RAM physical mapping.
    //
    // The below "nop" serves as a fake write barrier to ensure that
    // MI_WRITE_PTE is not optimized away because we end up changing PageFrame
    // below.
    //

    TempPte.Long = MiGetValidKernelPteBits();
    TempPte.Hard.PageFrameNumber = PageFrameNumber;

    MI_WRITE_PTE(&((volatile MMPFN*)PageFrame)->Pte, TempPte);

    __asm nop;

    RtlZeroMemory(MI_CONVERT_PFN_TO_PHYSICAL(PageFrameNumber), PAGE_SIZE);

    //
    // Initialize the page frame as busy.
    //

    PageFrame->Long = 0;                // Also zeroes LockCount
    PageFrame->Busy.Busy = 1;
    PageFrame->Busy.BusyType = BusyType;

    if (BusyType != MmVirtualPageTableUsage) {
        PageFrame->Busy.PteIndex =
            MiGetPteOffset(MiGetVirtualAddressMappedByPte(TargetPte));
    }

    //
    // Increment the number of pages of this type.
    //

    MmAllocatedPagesByUsage[BusyType]++;

    //
    // Flush the system RAM physical mapping created above.
    //

    MI_FLUSH_VA(MI_CONVERT_PFN_TO_PHYSICAL(PageFrameNumber));

    return PageFrameNumber;
}

VOID
FASTCALL
MiRelocateBusyPage(
    IN PFN_NUMBER PageFrameNumber
    )
/*++

Routine Description:

    This routine relocates the contents of the supplied physical page to another
    physical page.

    The original page frame is left in an uninitialized state.

Arguments:

    PageFrameNumber - Supplies the physical page frame to relocate.

Return Value:

    None.

Environment:

    Kernel mode, DISPATCH_LEVEL.

--*/
{
    PMMPFN PageFrame;
    BOOLEAN FullTlbFlush;
    PMMPTE PointerPte;
    PMMPTE PointerPde;
    PVOID CacheBuffer;
    PFN_NUMBER NewPageFrameNumber;
    PMMPFN NewPageFrame;
    MMPTE TempPte;

    MI_ASSERT_LOCK_MM();

    PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

    ASSERT(PageFrame->Pte.Hard.Valid == 0);
    ASSERT(PageFrame->Busy.Busy != 0);
    ASSERT(PageFrame->Busy.BusyType != MmUnknownUsage);
    ASSERT(PageFrame->Busy.LockCount == 0);

    //
    // Locate the pointer to the PTE for the page frame.
    //

    FullTlbFlush = FALSE;

    switch (PageFrame->Busy.BusyType) {

        case MmVirtualPageTableUsage:
            //
            // Busy.PteIndex isn't valid for a MmVirtualPageTableUsage page.
            // Instead, scan through the PDE for the page table.
            //

            PointerPde = MiGetPdeAddress(MM_LOWEST_USER_ADDRESS);

            for (;;) {

                if ((PointerPde->Hard.Valid != 0) &&
                    (PointerPde->Hard.PageFrameNumber == PageFrameNumber)) {
                    PointerPte = PointerPde;
                    break;
                }

                PointerPde++;

                //
                // Verify that we haven't run off the end of the page directory.
                //

                ASSERT(PointerPde <= MiGetPdeAddress(MM_HIGHEST_USER_ADDRESS));
            }

            FullTlbFlush = TRUE;

            break;

        case MmSystemPageTableUsage:
            //
            // Busy.PteIndex is valid for a MmSystemPageTableUsage page, but
            // it's relative to the page directory, not a page table.
            //

            PointerPte = (PMMPTE)PDE_BASE + PageFrame->Busy.PteIndex;

            ASSERT(PointerPte->Hard.Valid != 0);
            ASSERT(PointerPte->Hard.PageFrameNumber == PageFrameNumber);

            FullTlbFlush = TRUE;

            break;

        case MmFsCacheUsage:
            //
            // FsCache.ElementIndex is the index into the FscElementArray which
            // can be used to find the virtual address of the cache page.
            //

            ASSERT(PageFrame->FsCache.ElementIndex < FscNumberOfCachePages);
            CacheBuffer = PAGE_ALIGN(FscElementArray[PageFrame->FsCache.ElementIndex].CacheBuffer);
            PointerPte = MiGetPteAddress(CacheBuffer);
            break;

        case MmVirtualMemoryUsage:
        case MmImageUsage:
            //
            // Busy.PteIndex is valid for a MmVirtualMemoryUsage page.  Scan
            // through each page table in the application virtual memory space.
            //

            PointerPde = MiGetPdeAddress(MM_LOWEST_USER_ADDRESS);

            for (;;) {

                if (PointerPde->Hard.Valid != 0) {

                    ASSERT(PointerPde->Hard.LargePage == 0);

                    PointerPte = (PMMPTE)MiGetVirtualAddressMappedByPte(PointerPde) +
                        PageFrame->Busy.PteIndex;

                    //
                    // The page may be protected as PAGE_NOACCESS or PAGE_GUARD,
                    // so we can't just check the Valid bit here.
                    //

                    if ((PointerPte->Long != 0) &&
                        (PointerPte->Hard.PageFrameNumber == PageFrameNumber)) {
                        break;
                    }
                }

                PointerPde++;

                //
                // Verify that we haven't run off the end of the page directory.
                // If we hit this, then that means that a page either has an
                // invalid PTE index.
                //

                ASSERT(PointerPde <= MiGetPdeAddress(MM_HIGHEST_USER_ADDRESS));
            }
            break;

#ifdef DEVKIT
        case MmDebuggerUsage:
#ifdef CONSOLE_DEVKIT
            //
            // Relocatable pages only exist in the first 64 megabytes of memory
            // and debugger pages can only be allocated in this memory if the
            // system only has 64 megabytes of memory.
            //

            ASSERT(MM_HIGHEST_PHYSICAL_PAGE < MM_64M_PHYSICAL_PAGE);
#endif

            //
            // Busy.PteIndex is valid for a MmDebuggerUsage page.  Scan through
            // each page table in the development kit PTE space.
            //

            PointerPde = MiGetPdeAddress(MM_DEVKIT_PTE_BASE);

            for (;;) {

                if (PointerPde->Hard.Valid != 0) {

                    ASSERT(PointerPde->Hard.LargePage == 0);

                    PointerPte = (PMMPTE)MiGetVirtualAddressMappedByPte(PointerPde) +
                        PageFrame->Busy.PteIndex;

                    if ((PointerPte->Hard.Valid != 0) &&
                        (PointerPte->Hard.PageFrameNumber == PageFrameNumber)) {
                        break;
                    }
                }

                PointerPde++;

                //
                // Verify that we haven't run off the end of the page directory.
                // If we hit this, then that means that a page either has an
                // invalid PTE index.
                //

                ASSERT(PointerPde <= MiGetPdeAddress(MM_DEVKIT_PTE_END));
            }
            break;
#endif

        default:
#ifdef CONSOLE_DEVKIT
            //
            // For non-DEVKIT builds or builds with more than 64 megabytes of
            // memory, make sure that we don't hit a debugger page.
            //

            ASSERT(PageFrame->Busy.BusyType != MmDebuggerUsage);
#endif

            //
            // Busy.PteIndex is valid for all other types.  Scan through each
            // page table in the system PTE space.
            //

            PointerPde = MiGetPdeAddress(MM_SYSTEM_PTE_BASE);

            for (;;) {

                if (PointerPde->Hard.Valid != 0) {

                    ASSERT(PointerPde->Hard.LargePage == 0);

                    PointerPte = (PMMPTE)MiGetVirtualAddressMappedByPte(PointerPde) +
                        PageFrame->Busy.PteIndex;

                    if ((PointerPte->Hard.Valid != 0) &&
                        (PointerPte->Hard.PageFrameNumber == PageFrameNumber)) {
                        break;
                    }
                }

                PointerPde++;

                //
                // Verify that we haven't run off the end of the page directory.
                // If we hit this, then that means that a page either has an
                // invalid PTE index.
                //

                ASSERT(PointerPde <= MiGetPdeAddress(MM_SYSTEM_PTE_END));
            }
            break;
    }

    //
    // Allocate another page to hold the contents of the page.  Attempt to
    // obtain the same color page so that virtual buffers are still spaced
    // nicely in the cache.
    //

    MmNextDefaultPageColor = MiGetPfnColor(PageFrameNumber);
    NewPageFrameNumber = MiRemoveAnyPageFromFreeList();
    NewPageFrame = MI_PFN_ELEMENT(NewPageFrameNumber);

    //
    // Temporarily expose the new page through the system RAM physical mapping
    // so that we can copy the page from the old address to the new address.
    //

    TempPte.Long = MiGetValidKernelPteBits();
    TempPte.Hard.PageFrameNumber = NewPageFrameNumber;

    MI_WRITE_PTE(&((volatile MMPFN*)NewPageFrame)->Pte, TempPte);

    //
    // Build the PTE contents for the virtual address to point at the new page.
    //

    TempPte = *PointerPte;
    ASSERT(PointerPte->Hard.PageFrameNumber == PageFrameNumber);
    TempPte.Hard.PageFrameNumber = NewPageFrameNumber;

    //
    // Invoke a helper to copy the contents of the page from the old page to the
    // new page, to update the page tables, and to flush the appropriate TLB
    // entries.  This is done in an assembly routine in order to ensure the
    // stack is updated properly if we're relocating the current stack's pages.
    //

    MiRelocateBusyPageHelper(MiGetVirtualAddressMappedByPte(PointerPte),
        MI_CONVERT_PFN_TO_PHYSICAL(NewPageFrameNumber), PointerPte, TempPte,
        FullTlbFlush);

    //
    // Copy the page frame attributes from the old page frame to the new.
    //

    NewPageFrame->Long = PageFrame->Long;

    //
    // Flush the system RAM physical mapping created above.
    //

    MI_FLUSH_VA(MI_CONVERT_PFN_TO_PHYSICAL(NewPageFrameNumber));

    //
    // If caching is disabled or is write combined for the page's old virtual
    // address, then force a flush of the TLB and cache now to ensure coherency.
    //

    if (TempPte.Hard.WriteThrough) {
        KeFlushCurrentTbAndInvalidateAllCaches();
    }
}

VOID
FASTCALL
MiReleasePageOwnership(
    IN PFN_NUMBER PageFrameNumber
    )
/*++

Routine Description:

    This routine is called when the original use of an allocated page is
    complete.

Arguments:

    PageFrameNumber - Supplies the physical page frame to release.

Return Value:

    None.

Environment:

    Kernel mode, DISPATCH_LEVEL.

--*/
{
    PMMPFN PageFrame;

    MI_ASSERT_LOCK_MM();

    ASSERT(PageFrameNumber <= MM_HIGHEST_PHYSICAL_PAGE);

    PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

    ASSERT(PageFrame->Pte.Hard.Valid == 0);
    ASSERT(PageFrame->Busy.Busy != 0);
    ASSERT(PageFrame->Busy.BusyType != MmUnknownUsage);
    ASSERT(PageFrame->Busy.BusyType < MmMaximumUsage);

    //
    // If the page is still locked for I/O, then this is a bug in the client
    // code.  Pages should never be released with pending I/O.
    //

    ASSERT(PageFrame->Busy.LockCount == 0);

    //
    // Decrement the number of pages of this type.
    //

    MmAllocatedPagesByUsage[PageFrame->Busy.BusyType]--;

    //
    // Insert the page at the head of the free lists so that this page is
    // more likely to be allocated before a previously pinned page.
    //

    MiInsertPageInFreeList(PageFrameNumber, TRUE);
}

#ifdef CONSOLE_DEVKIT

VOID
MmReleaseDeveloperKitMemory(
    VOID
    )
/*++

Routine Description:

    This routine places all of the available pages in the extra memory PFN
    region back in the general available pages pool.  All of the other virtual
    memory manager services can start using these pages.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    KIRQL OldIrql;

    MI_LOCK_MM(&OldIrql);

    MmAvailablePages += MmDeveloperKitPfnRegion.AvailablePages;

    MmDeveloperKitMemoryReleased = TRUE;

    MI_UNLOCK_MM(OldIrql);
}

PFN_NUMBER
FASTCALL
MiRemoveDebuggerPage(
    IN MMPFN_BUSY_TYPE BusyType,
    IN PMMPTE TargetPte
    )
/*++

Routine Description:

    This routine removes one page from the free list and initializes it as a
    busy page with the supplied busy type.

    The contents of the page are zeroed.

Arguments:

    BusyType - Ignored.  MmDebuggerUsage is used for all pages allocated by
        this routine.

    TargetPte - Supplies the address of the PDE/PTE that will receive the page
        frame.

Return Value:

    The allocated physical page frame number.

Environment:

    Kernel mode, DISPATCH_LEVEL.

--*/
{
    MMCOLOR Color;
    USHORT PackedPfn;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;
    MMPTE TempPte;

    MI_ASSERT_LOCK_MM();

    //
    // Verify that there are pages available.  The caller is responsible for
    // first checking that a page can be allocated.
    //

    ASSERT(MmDeveloperKitPfnRegion.AvailablePages > 0);

    //
    // Look for the first colored free list with a free page.
    //

    ASSERT(MmNextDefaultPageColor < MM_NUMBER_OF_COLORS);

    for (Color = MmNextDefaultPageColor; NOTHING;
        Color = ((Color + 1) & MM_NUMBER_OF_COLORS_MASK)) {

        if (MmDeveloperKitPfnRegion.FreePagesByColor[Color].PackedPfnFlink !=
            MM_PACKED_PFN_NULL) {

            PackedPfn = MmDeveloperKitPfnRegion.FreePagesByColor[Color].PackedPfnFlink;
            PageFrameNumber = MiUnpackFreePfn(PackedPfn, Color);

            //
            // MiRemoveAnyPage is optimized for speed and detaches the page from
            // the free list itself knowing that the page is at the head of the
            // list.  Here, we optimize for size and delegate the list
            // detachment to a common routine.
            //

            MiRemovePageFromFreeList(PageFrameNumber);

            break;
        }
    }

    MmNextDefaultPageColor = ((Color + 1) & MM_NUMBER_OF_COLORS_MASK);

    PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

    //
    // Zero the page's contents by temporarily exposing it through the system
    // RAM physical mapping.
    //
    // The below "nop" serves as a fake write barrier to ensure that
    // MI_WRITE_PTE is not optimized away because we end up changing PageFrame
    // below.
    //

    TempPte.Long = MiGetValidKernelPteBits();
    TempPte.Hard.PageFrameNumber = PageFrameNumber;

    MI_WRITE_PTE(&((volatile MMPFN*)PageFrame)->Pte, TempPte);

    __asm nop;

    RtlZeroMemory(MI_CONVERT_PFN_TO_PHYSICAL(PageFrameNumber), PAGE_SIZE);

    //
    // Initialize the page frame as busy.
    //

    PageFrame->Long = 0;                // Also zeroes LockCount
    PageFrame->Busy.Busy = 1;
    PageFrame->Busy.BusyType = MmDebuggerUsage;
    PageFrame->Busy.PteIndex =
        MiGetPteOffset(MiGetVirtualAddressMappedByPte(TargetPte));

    //
    // Increment the number of pages of this type.
    //

    MmAllocatedPagesByUsage[MmDebuggerUsage]++;

    //
    // Flush the system RAM physical mapping created above.
    //

    MI_FLUSH_VA(MI_CONVERT_PFN_TO_PHYSICAL(PageFrameNumber));

    return PageFrameNumber;
}

#endif

#if DBG

VOID
MiAssertPfnRegionFreeListsValid(
    IN PMMPFNREGION PfnRegion
    )
/*++

Routine Description:

    This routine analyzes the free lists of a PFN region to verify that they are
    structurally correct.

Arguments:

    PfnRegion - Supplies the PFN region to verify.

Return Value:

    None.

Environment:

    Kernel mode, DISPATCH_LEVEL.

--*/
{
    PFN_COUNT FreePagesFound;
    MMCOLOR Color;
    USHORT PackedPfnBlink;
    USHORT PackedPfn;
    PFN_NUMBER PageFrameNumber;
    PMMPFN PageFrame;

    MI_ASSERT_LOCK_MM();

    FreePagesFound = 0;

    for (Color = 0; Color < MM_NUMBER_OF_COLORS; Color++) {

        PackedPfnBlink = MM_PACKED_PFN_NULL;
        PackedPfn = PfnRegion->FreePagesByColor[Color].PackedPfnFlink;

        while (PackedPfn != MM_PACKED_PFN_NULL) {

            ASSERT((PackedPfn & 1) == 0);

            PageFrameNumber = MiUnpackFreePfn(PackedPfn, Color);

            ASSERT(PageFrameNumber <= MM_HIGHEST_PHYSICAL_PAGE);
            ASSERT(MI_PFN_REGION(PageFrameNumber) == PfnRegion);

            PageFrame = MI_PFN_ELEMENT(PageFrameNumber);

            ASSERT(PageFrame->Pte.Hard.Valid == 0);
            ASSERT(PageFrame->Busy.Busy == 0);
            ASSERT(PageFrame->Free.PackedPfnBlink == PackedPfnBlink);

            FreePagesFound++;

            PackedPfnBlink = PackedPfn;
            PackedPfn = PageFrame->Free.PackedPfnFlink;

            ASSERT(FreePagesFound <= MmAvailablePages);
        }

        ASSERT(PfnRegion->FreePagesByColor[Color].PackedPfnBlink == PackedPfnBlink);
    }

    ASSERT(PfnRegion->AvailablePages == FreePagesFound);
}

VOID
MiAssertFreeListsValid(
    VOID
    )
/*++

Routine Description:

    This routine analyzes the free lists to verify that they are structurally
    correct.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode, DISPATCH_LEVEL.

--*/
{
    MiAssertPfnRegionFreeListsValid(&MmRetailPfnRegion);
#ifdef CONSOLE_DEVKIT
    MiAssertPfnRegionFreeListsValid(&MmDeveloperKitPfnRegion);
#endif
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\mmx\vadtree.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    vadtree.c

Abstract:

    This module implements the routines to manipulate the virtual address
    descriptor tree.

--*/

#include "mi.h"

VOID
MiInsertVad (
    IN PMMVAD Vad
    )
/*++

Routine Description:

    This function inserts a virtual address descriptor into the tree and
    reorders the splay tree as appropriate.

Arguments:

    Vad - Supplies a pointer to a virtual address descriptor


Return Value:

    None - An exception is raised if quota is exceeded.

--*/
{
    PMMADDRESS_NODE *Root;

    ASSERT (Vad->EndingVpn >= Vad->StartingVpn);

    Root = &MmVadRoot;

    //
    // Set the hint field in the process to this Vad.
    //

    MmVadHint = (PMMADDRESS_NODE)Vad;

    if (MmVadFreeHint != NULL) {
        if (((ULONG)((PMMVAD)MmVadFreeHint)->EndingVpn +
                MI_VA_TO_VPN (X64K)) >=
                Vad->StartingVpn) {
            MmVadFreeHint = (PMMADDRESS_NODE)Vad;
        }
    }

    MiInsertNode ( (PMMADDRESS_NODE)Vad, Root);
    return;
}

VOID
MiRemoveVad (
    IN PMMVAD Vad
    )
/*++

Routine Description:

    This function removes a virtual address descriptor from the tree and
    reorders the splay tree as appropriate.  If any quota or commitment
    was charged by the VAD (as indicated by the CommitCharge field) it
    is released.

Arguments:

    Vad - Supplies a pointer to a virtual address descriptor.

Return Value:

    None.

--*/
{
    PMMADDRESS_NODE *Root;

    if (Vad == (PMMVAD)MmVadFreeHint) {
        MmVadFreeHint = (PMMADDRESS_NODE)MiGetPreviousVad (Vad);
    }

    Root = &MmVadRoot;

    MiRemoveNode ( (PMMADDRESS_NODE)Vad, Root);

    //
    // If the VadHint was the removed Vad, change the Hint.

    if (MmVadHint == (PMMADDRESS_NODE)Vad) {
        MmVadHint = MmVadRoot;
    }

    return;
}

PMMVAD
FASTCALL
MiLocateAddress (
    IN PVOID VirtualAddress
    )
/*++

Routine Description:

    The function locates the virtual address descriptor which describes
    a given address.

Arguments:

    VirtualAddress - Supplies the virtual address to locate a descriptor
                     for.

Return Value:

    Returns a pointer to the virtual address descriptor which contains
    the supplied virtual address or NULL if none was located.

--*/
{
    PMMVAD FoundVad;
    ULONG_PTR Vpn;

    if (MmVadHint == NULL) {
        return NULL;
    }

    Vpn = MI_VA_TO_VPN (VirtualAddress);
    if ((Vpn >= MmVadHint->StartingVpn) &&
        (Vpn <= MmVadHint->EndingVpn)) {

        return (PMMVAD)MmVadHint;
    }

    FoundVad = (PMMVAD)MiLocateAddressInTree ( Vpn, &MmVadRoot );

    if (FoundVad != NULL) {
        MmVadHint = (PMMADDRESS_NODE)FoundVad;
    }
    return FoundVad;
}

PVOID
MiFindEmptyAddressRange (
    IN SIZE_T SizeOfRange,
    IN ULONG_PTR Alignment,
    IN ULONG QuickCheck
    )
/*++

Routine Description:

    The function examines the virtual address descriptors to locate
    an unused range of the specified size and returns the starting
    address of the range.

Arguments:

    SizeOfRange - Supplies the size in bytes of the range to locate.

    Alignment - Supplies the alignment for the address.  Must be
                 a power of 2 and greater than the page_size.

    QuickCheck - Supplies a zero if a quick check for free memory
                 after the VadFreeHint exists, non-zero if checking
                 should start at the lowest address.

Return Value:

    Returns the starting address of a suitable range.

--*/
{
    PMMVAD NextVad;
    PMMVAD FreeHint;
    PVOID StartingVa;
    PVOID EndingVa;

    FreeHint = (PMMVAD)MmVadFreeHint;

    if ((QuickCheck == 0) && (FreeHint != NULL)) {

        EndingVa = MI_VPN_TO_VA_ENDING (FreeHint->EndingVpn);
        NextVad = MiGetNextVad (FreeHint);
        if (NextVad == NULL) {

            if (SizeOfRange <
                (((ULONG_PTR)MM_HIGHEST_USER_ADDRESS + 1) -
                         MI_ROUND_TO_SIZE((ULONG_PTR)EndingVa, Alignment))) {
                return (PMMADDRESS_NODE)MI_ROUND_TO_SIZE((ULONG_PTR)EndingVa,
                                                         Alignment);
            }
        } else {
            StartingVa = MI_VPN_TO_VA (NextVad->StartingVpn);

            if (SizeOfRange <
                ((ULONG_PTR)StartingVa -
                         MI_ROUND_TO_SIZE((ULONG_PTR)EndingVa, Alignment))) {

                //
                // Check to ensure that the ending address aligned upwards
                // is not greater than the starting address.
                //

                if ((ULONG_PTR)StartingVa >
                         MI_ROUND_TO_SIZE((ULONG_PTR)EndingVa,Alignment)) {
                    return (PMMADDRESS_NODE)MI_ROUND_TO_SIZE((ULONG_PTR)EndingVa,
                                                           Alignment);
                }
            }
        }
    }

    return (PMMVAD)MiFindEmptyAddressRangeInTree (
                   SizeOfRange,
                   Alignment,
                   MmVadRoot,
                   &MmVadFreeHint);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\mmx\i386\mmsupa.asm ===
TITLE   "Memory Management Support Routines"
;++
;
;  Copyright (c) 2000-2001  Microsoft Corporation
;
;  Module Name:
;
;     mmsupa.asm
;
;  Abstract:
;
;     This module implements the various routines for miscellaneous support
;     operations for memory management.
;
;  Environment:
;
;     Kernel mode only.
;
;--

        .586p
        .xlist
INCLUDE ks386.inc
INCLUDE callconv.inc
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; FASTCALL
; MiZeroAndFlushPtes(
;     IN PMMPTE StartingPte,
;     IN PFN_COUNT NumberOfPtes
;     )
;
; Routine Description:
;
;     This function zeroes a range of PTEs and flushes its corresponding TLB
;     entries.  The NumberOfPtes must be greater than zero.
;
; Arguments:
;
;     StartingPte - Supplies the first PTE to zero.
;
;     NumberOfPtes - Supplies the number of PTEs to zero.
;
; Return Value:
;
;     None.
;
;--
cPublicFastCall MiZeroAndFlushPtes, 2

IF DBG
        test    edx, edx
        jnz     @F
        int     3
@@:
ENDIF

        mov     eax, ecx
        shl     eax, 10             ; eax = MiGetVirtualAddressMappedByPte(ecx)

FlushNextPte:
        mov     [ecx], 0
        invlpg  [eax]
        add     ecx, 4
        add     eax, PAGE_SIZE
        dec     edx
        jnz     FlushNextPte

        fstRET  MiZeroAndFlushPtes

fstENDP MiZeroAndFlushPtes

;++
;
; VOID
; MiRelocateBusyPageHelper(
;     IN PVOID OldPhysicalAddress,
;     IN PVOID NewPhysicalAddress,
;     IN PMMPTE PointerPte OPTIONAL,
;     IN MMPTE NewPteContents OPTIONAL,
;     IN BOOLEAN FullTlbFlush
;     )
;
; Routine Description:
;
;     This function is called by MiRelocateBusyPage to handle the work of
;     copying a page's contents, updating the page tables, and flushing the
;     appropriate TLB entries.  This routine is implemented in assembly to
;     ensure that the stack is touched properly in the case of relocating the
;     current stack's pages.
;
; Arguments:
;
;     OldPhysicalAddress - Supplies a KSEG0 pointer to the old page's contents.
;
;     NewPhysicalAddress - Supplies a KSEG0 pointer to the new location for the
;         page.
;
;     PointerPte - Supplies an optional pointer to the PTE to update after doing
;         the page copy.
;
;     NewPteContents - Supplies the value to write to PointerPte.
;
;     FullTlbFlush - Specifies whether the entire TLB should be flushed after
;         updating PointerPte or only the virtual address mapped by the PTE.
;
; Return Value:
;
;     None.
;
;--
cPublicProc _MiRelocateBusyPageHelper, 5

        push    esi
        mov     esi, [esp+8]        ; esi = OldPhysicalAddress
        push    edi
        mov     edi, [esp+16]       ; edi = NewPhysicalAddress
        mov     edx, [esp+20]       ; edx = PointerPte
        mov     ecx, PAGE_SIZE / 4
        mov     eax, [esp+24]       ; eax = NewPteContents

;
; Disable interrupts during the rest of the operation.  The page we're moving
; could be modified by an interrupt service routine while we're copying it.
;

        cli

;
; Copy the old page to the new page.
;

        rep     movsd

;
; Grab the last value from the stack before we start changing the page tables.
;

        mov     ecx, [esp+28]       ; cl = FullTlbFlush

;
; Update the page table entry.
;

        mov     [edx], eax          ; MI_WRITE_PTE(edx, eax)

;
; Check if we should flush just a single TLB entry or the entire TLB.
;

        test    cl, cl
        jnz     FlushEntireTlb

FlushSingleTlb:
        shl     edx, 10             ; edx = MiGetVirtualAddressMappedByPte(edx)
        invlpg  [edx]
        jmp     ReenableInterrupts

FlushEntireTlb:
        mov     eax, cr3
        mov     cr3, eax

;
; The page tables now point at the new page and the TLB has been flushed.  It's
; safe to allow interrupts to fire again.
;

ReenableInterrupts:
        sti

        pop     edi
        pop     esi

        stdRET  _MiRelocateBusyPageHelper

stdENDP _MiRelocateBusyPageHelper

_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\base.cpp ===
tag// ---------------------------------------------------------------------------------------
// base.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_XBDM_SERVER
#define XNET_TRACE_PREFIX   "XBDM"
#elif defined(XNET_FEATURE_ONLINE)
#define XNET_TRACE_PREFIX   "XONLINE"
#else
#define XNET_TRACE_PREFIX   "XNET"
#endif

DefineTag(Timer,    0);
DefineTag(poolWarn, TAG_ENABLE);
DefineTag(poolDump, 0);

// ---------------------------------------------------------------------------------------
// Crypto Constants
// ---------------------------------------------------------------------------------------

extern "C" const BYTE g_abOakleyGroup1Mod[CBDHG1] =
{
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xc9, 0x0f, 0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34,
    0xc4, 0xc6, 0x62, 0x8b, 0x80, 0xdc, 0x1c, 0xd1,
    0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67, 0xcc, 0x74,
    0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
    0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd,
    0xef, 0x95, 0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b,
    0x30, 0x2b, 0x0a, 0x6d, 0xf2, 0x5f, 0x14, 0x37,
    0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51, 0xc2, 0x45,
    0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
    0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x3a, 0x36, 0x20,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

extern "C" const BYTE g_abOakleyGroup1Base[CBDHG1] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02
};

// ---------------------------------------------------------------------------------------
// CXnBase (Params)
// ---------------------------------------------------------------------------------------

#undef  DEFINE_PARAM_
#define DEFINE_PARAM_(idx, name, def, min, max) typedef int _farf_##name[offsetof(XNetStartupParams, name) == idx];
#undef  DEFINE_PARAM
#define DEFINE_PARAM(name, def, min, max)
XNETPARAMDEFS()     // If this barfs, XNETPARAMDEFS is out of sync with XNetStartupParams
#undef  DEFINE_PARAM_
#define DEFINE_PARAM_(idx, name, def, min, max) def,
#undef  DEFINE_PARAM
#define DEFINE_PARAM(name, def, min, max) def,
const XNetParams CXnBase::s_XNetParamsDef = { XNETPARAMDEFS() };
#undef  DEFINE_PARAM_
#define DEFINE_PARAM_(idx, name, def, min, max) min,
#undef  DEFINE_PARAM
#define DEFINE_PARAM(name, def, min, max) min,
const XNetParams CXnBase::s_XNetParamsMin = { XNETPARAMDEFS() };
#undef  DEFINE_PARAM_
#define DEFINE_PARAM_(idx, name, def, min, max) max,
#undef  DEFINE_PARAM
#define DEFINE_PARAM(name, def, min, max)  max,
const XNetParams CXnBase::s_XNetParamsMax = { XNETPARAMDEFS() };
#undef DEFINE_PARAM

// ---------------------------------------------------------------------------------------
// CLeakTracker
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ASSERT

#define LEAKS_PER_ALLOC     128

DefineTag(LeakWarn, TAG_ENABLE);

void * CXnBase::LeakAdd(CLeakInfo * pli, void * pv, UINT cb, ULONG tag)
{
    ICHECK(BASE, USER|UDPC|SDPC);

    if (pv && !pli->_fLeakDisable)
    {
        RaiseToDpc();

        CLeak * pLeak = NULL;

        if (pli->_cLeak == pli->_cLeakAlloc)
        {
            pLeak = (CLeak *)HalAlloc((pli->_cLeakAlloc + LEAKS_PER_ALLOC) * sizeof(CLeak), 0);

            if (pLeak == NULL)
            {
                if (pli->_pLeak)
                {
                    HalFree(pli->_pLeak);
                    pli->_pLeak = NULL;
                    pli->_cLeak = 0;
                }

                TraceSz(LeakWarn, "Leak tracker ran out of memory.  Tracking disabled.");
                pli->_fLeakDisable = TRUE;
                return(pv);
            }

            if (pli->_pLeak)
            {
                memcpy(pLeak, pli->_pLeak, pli->_cLeakAlloc * sizeof(CLeak));
                HalFree(pli->_pLeak);
            }

            pli->_pLeak = pLeak;
            pli->_cLeakAlloc += LEAKS_PER_ALLOC;
        }

        if (LeakFind(pli, pv, &pLeak))
        {
            AssertSz(FALSE, "Attempt to leak track the same memory more than once.  Tracking disabled.");
            HalFree(pli->_pLeak);
            pli->_pLeak = NULL;
            pli->_cLeak = 0;
            pli->_fLeakDisable = TRUE;
            return(pv);
        }

        UINT cbMov = (pli->_cLeak - (pLeak - pli->_pLeak)) * sizeof(CLeak);

        if (cbMov > 0)
        {
            memmove(pLeak + 1, pLeak, cbMov);
        }

        pLeak->_pv   = pv;
        pLeak->_cb   = cb;
        pLeak->_tag  = tag;
        pli->_cLeak += 1;
    }

    return(pv);
}

void * CXnBase::LeakDel(CLeakInfo * pli, void * pv)
{
    ICHECK(BASE, USER|UDPC|SDPC);

    if (pv && !pli->_fLeakDisable)
    {
        RaiseToDpc();

        CLeak * pLeak = NULL;

        if (LeakFind(pli, pv, &pLeak))
        {
            Assert(pLeak->_pv == pv);

            int cbMov = (pli->_cLeak - (pLeak - pli->_pLeak) - 1) * sizeof(CLeak);

            if (cbMov > 0)
            {
                memmove(pLeak, pLeak + 1, cbMov);
            }

            pli->_cLeak -= 1;
        }
        else
        {
            AssertSz(FALSE, "Leak tracker can't find memory block in its table");
        }
    }

    return(pv);
}

BOOL CXnBase::LeakFind(CLeakInfo * pli, void * pv, CLeak ** ppLeak)
{
    ICHECK(BASE, UDPC|SDPC);

    int     iLo     = 0;
    int     iHi     = (int)pli->_cLeak;
    int     iMid;
    CLeak * pLeak   = pli->_pLeak;
    BOOL    fFound  = FALSE;

    while (iLo < iHi)
    {
        iMid  = (iLo + iHi) >> 1;
        pLeak = pli->_pLeak + iMid;

        if (pLeak->_pv == pv)
        {
            iLo = iMid;
            fFound = TRUE;
            break;
        }
        else if (pLeak->_pv < pv)
            iLo = iMid + 1;
        else
            iHi = iMid;
    }

    *ppLeak = pli->_pLeak + iLo;

    return(fFound);
}

void CXnBase::LeakTerm(CLeakInfo * pli)
{
    if (pli->_cLeak > 0)
    {
        CLeak * pLeak   = pli->_pLeak;
        UINT cLeak      = pli->_cLeak;
        UINT cbLeak     = 0;

        for (; cLeak > 0; --cLeak, ++pLeak)
        {
            cbLeak += pLeak->_cb;
            TraceSz3(LeakWarn, "Leaked %5d bytes at %08lX - %s", pLeak->_cb, pLeak->_pv,
                     pli->_pfnLeakTag(pLeak->_tag));
        }

        TraceSz1(LeakWarn, "Leaked %5d bytes total", cbLeak);
    }

    if (pli->_pLeak)
    {
        HalFree(pli->_pLeak);
        pli->_pLeak = NULL;
    }
}

const char * XnLeakTagToString(ULONG tag)
{
    switch (tag)
    {
        #undef  XNETPTAG
        #define XNETPTAG(_name, _tag) case PTAG_##_name: return(#_name); break;
        XNETPTAGLIST()
    }

    return("?");
}

#endif

// ---------------------------------------------------------------------------------------
// CXnBase (Pool Allocator)
// ---------------------------------------------------------------------------------------

//
// Pool allocation block header: We intentionally let this have
// the same size as the system pool header. But we've restructured
// the fields in such a way that if you try to free a memory block
// that was allocated out of our private pool to the system pool,
// you'd get a bugcheck.
//

struct PoolEntry
{
    BYTE bOver;
        // if busy, the amount of overhead in the block
    BYTE bBusy;
        // Whether the block is allocated or free

    WORD tag;
        // We're only using 2 bytes for pool tag,
        // since all of our pool tags have the form NET*.

    WORD blockSize;
    WORD previousSize;
        // Size of this block and the previous block in 32-bit units

    LIST_ENTRY links;
        // A free pool entry has two additional pointer fields
        // for maintaining a doubly-linked list of free blocks.
};

#define POOL_BLOCK_SHIFT 5
#define POOL_BLOCK_SIZE (1 << POOL_BLOCK_SHIFT)
#define MAX_POOL_SIZE (POOL_BLOCK_SIZE * 0xffff)
#define POOL_HEADER_SIZE offsetof(PoolEntry, links)

#define MarkPoolEntryBusy(_entry) ((_entry)->bBusy = 1)
#define MarkPoolEntryFree(_entry) ((_entry)->bBusy = 0)
#define IsPoolEntryBusy(_entry) ((_entry)->bBusy != 0)
#define IsPoolEntryFree(_entry) ((_entry)->bBusy == 0)
#define TagPoolEntry(_entry, _tag) ((_entry)->tag = (WORD) ((_tag) >> 16))

#define GetPoolEntryHeader(_ptr) \
        ((PoolEntry*) ((BYTE*) (_ptr) - POOL_HEADER_SIZE))
#define GetPoolEntryNext(_entry) \
        ((PoolEntry*) ((BYTE*) (_entry) + ((UINT) (_entry)->blockSize << POOL_BLOCK_SHIFT)))
#define GetPoolEntryPrev(_entry) \
        ((PoolEntry*) ((BYTE*) (_entry) - ((UINT) (_entry)->previousSize << POOL_BLOCK_SHIFT)))

//
// Beginning and ending address of the entire pool
//

#define IsPoolEntryValid(_entry) ((_entry) >= _pvPoolStart && (_entry) < _pvPoolEnd)

#define InsertFreePoolEntry(_entry) { \
            LIST_ENTRY* _head; \
            _head = &_aleFree[ \
                        (_entry)->blockSize <= MAX_SMALL_BLOCKS ? \
                            (_entry)->blockSize - 1 : \
                            MAX_SMALL_BLOCKS]; \
            InsertHeadList(_head, &(_entry)->links); \
        }


void * CXnBase::PoolAlloc(size_t size, ULONG tag)
{
    ICHECK(BASE, USER|UDPC|SDPC);

#ifdef XNET_FEATURE_VMEM
    if (VMemIsEnabled())
    {
        return(LeakAdd(&_leakinfo, VMemAlloc(size), size, tag));
    }
#endif

    PoolEntry* entry;

    Assert(size > 0 && size <= MAX_POOL_SIZE - POOL_HEADER_SIZE);
    size_t size_orig = size;
    size = (size + (POOL_HEADER_SIZE + POOL_BLOCK_SIZE - 1)) >> POOL_BLOCK_SHIFT;

    RaiseToDpc();

    // Find a free pool block that's large enough for us.
    // Handle small block allocation with the quick lookup.
    if (size <= MAX_SMALL_BLOCKS)
    {
        UINT index;

        for (index=size-1; index <= MAX_SMALL_BLOCKS; index++)
        {
            if (!IsListEmpty(&_aleFree[index]))
            {
                entry = GetPoolEntryHeader(_aleFree[index].Flink);
                goto found;
            }
        }
    }
    else
    {
        LIST_ENTRY* head;
        LIST_ENTRY* list;

        head = &_aleFree[MAX_SMALL_BLOCKS];
        list = head->Flink;
        while (list != head)
        {
            entry = GetPoolEntryHeader(list);
            if ((WORD) size <= entry->blockSize)
                goto found;
            list = list->Flink;
        }
    }

    TraceSz1(poolWarn, "Pool allocation failed: %d blocks", size);
    TraceSz(poolWarn, "Make sure you promptly call recv() to receive incoming data.");
    TraceSz(poolWarn, "You may also want to consider setting a larger pool size.");

#if DBG
    if (Tag(poolDump))
        PoolDump();
#endif

    return(NULL);

found:
    // Take it out of the free list
    RemoveEntryList(&entry->links);

    // If we didn't use up the entire free block,
    // put the remaining portion back on the free list.
    if (entry->blockSize > size) {
        UINT leftover = entry->blockSize - size;
        PoolEntry* next;

        entry->blockSize = (WORD) size;

        next = GetPoolEntryNext(entry);
        next->blockSize = (WORD) leftover;
        next->previousSize = (WORD) size;
        next->tag = entry->tag;
        MarkPoolEntryFree(next);
        InsertFreePoolEntry(next);

        next = GetPoolEntryNext(next);
        Assert(IsPoolEntryValid(next));
        next->previousSize = (WORD) leftover;
    }

    MarkPoolEntryBusy(entry);
    TagPoolEntry(entry, tag);
    entry->bOver = (BYTE)((size << POOL_BLOCK_SHIFT) - size_orig);

#ifdef XNET_FEATURE_ASSERT
    LeakAdd(&_leakinfo, (BYTE *)entry + POOL_HEADER_SIZE, size_orig, tag);
#endif

    return (BYTE*) entry + POOL_HEADER_SIZE;
}

void * CXnBase::PoolAllocZ(size_t size, ULONG tag)
{
    ICHECK(BASE, USER|UDPC|SDPC);

    void * pv = PoolAlloc(size, tag);

    if (pv)
    {
        memset(pv, 0, size);
    }

    return(pv);
}

void CXnBase::PoolFree(void * ptr)
{
    ICHECK(BASE, USER|UDPC|SDPC);

    if (ptr == NULL)
    {
        return;
    }

#ifdef XNET_FEATURE_ASSERT
    LeakDel(&_leakinfo, ptr);
#endif

#ifdef XNET_FEATURE_VMEM
    if (VMemIsEnabled())
    {
        VMemFree(ptr);
        return;
    }
#endif

    PoolEntry* entry;
    PoolEntry* prev;
    PoolEntry* next;
    WORD blockSize;

    entry = GetPoolEntryHeader(ptr);
    Assert(IsPoolEntryValid(entry) && IsPoolEntryBusy(entry));

    RaiseToDpc();

    MarkPoolEntryFree(entry);
    blockSize = entry->blockSize;

    //
    // Check to see if the block before this one is free
    // If so, collapse the two free blocks together
    //
    prev = GetPoolEntryPrev(entry);
    Assert(IsPoolEntryValid(prev));
    if (IsPoolEntryFree(prev)) {
        RemoveEntryList(&prev->links);
        prev->blockSize = (WORD) (prev->blockSize + blockSize);
        entry = prev;
    }

    //
    // Check if the block after this one is free
    // If so, collapse the two free blocks together
    //
    next = GetPoolEntryNext(entry);
    Assert(IsPoolEntryValid(next) && next->previousSize == blockSize);
    if (IsPoolEntryFree(next)) {
        RemoveEntryList(&next->links);
        entry->blockSize = (WORD) (entry->blockSize + next->blockSize);
    }

    //
    // If we performed any collapsing, 
    // update the previousSize field of the next block.
    //
    if (entry->blockSize != blockSize) {
        next = GetPoolEntryNext(entry);
        Assert(IsPoolEntryValid(next));
        next->previousSize = entry->blockSize;
    }

    InsertFreePoolEntry(entry);
}

#if DBG

void CXnBase::PoolDump()
{
    ICHECK(BASE, USER|UDPC|SDPC);

    PoolEntry* entry;
    PoolEntry* prev;
    UINT cbFree = 0;
    UINT cbBusy = 0;
    UINT cbOver = 0;
    UINT cbPool = (BYTE *)_pvPoolEnd - (BYTE *)_pvPoolStart;

    TraceSz(poolWarn, "+\n-------------------------------------------------------------------------");
    TraceSz2(poolWarn, "Private Pool Dump (%08lX - %08lX)", _pvPoolStart, _pvPoolEnd);
    TraceSz(poolWarn, "");

    prev = NULL;
    entry = (PoolEntry *)_pvPoolStart;

    while (entry < _pvPoolEnd)
    {
        BOOL fIsFree = IsPoolEntryFree(entry);
        BOOL fIsOver = (entry == _pvPoolStart) || ((BYTE *)entry + (1 << POOL_BLOCK_SHIFT)) == (BYTE *)_pvPoolEnd;
        UINT cb      = (entry->blockSize << POOL_BLOCK_SHIFT);

        if (fIsFree)
        {
            cb -= POOL_HEADER_SIZE;
            cbFree += cb;
            cbOver += POOL_HEADER_SIZE;
            TraceSz3(poolWarn, "%08lX f %7d (+%2d) bytes",
                     (UINT_PTR)entry + POOL_HEADER_SIZE, cb, POOL_HEADER_SIZE);
        }
        else
        {
            cb -= entry->bOver;
            cbBusy += cb;
            cbOver += entry->bOver;

            TraceSz4(poolWarn, "%08lX   %7d (+%2d) bytes %s",
                     (UINT_PTR)entry + POOL_HEADER_SIZE, cb, entry->bOver,
                     XnLeakTagToString(('xTEN' & 0xFFFF) | (entry->tag << 16)));
        }

        if (prev)
        {
            Assert(prev->blockSize == entry->previousSize);
            prev = entry;
        }

        entry = GetPoolEntryNext(entry);
    }

    Assert(entry == _pvPoolEnd);

    TraceSz(poolWarn, "");
    TraceSz1(poolWarn, "%7d bytes used", cbBusy);
    TraceSz1(poolWarn, "%7d bytes free", cbFree);
    TraceSz1(poolWarn, "%7d bytes overhead", cbOver);
    TraceSz1(poolWarn, "%7d bytes entire pool", cbPool);
    TraceSz(poolWarn, "+-------------------------------------------------------------------------\n");

    Assert(cbBusy + cbFree + cbOver == cbPool);

    if (Tag(poolDump) >= TAG_BREAK)
    {
        DbgBreak();
    }
}

#endif // DBG

// ---------------------------------------------------------------------------------------
// CXnBase (Rand)
// ---------------------------------------------------------------------------------------

void CXnBase::RandInit(XNetInitParams * pxnip)
{
    TCHECK(USER);

    BYTE    abSha1Ctx[XC_SERVICE_SHA_CONTEXT_SIZE];
    BYTE    abRand[512];
    BYTE    abHash[XC_SERVICE_DIGEST_SIZE];
    UINT    cbRand = 0;

    // Gather system randomness into the abRand vector

    cbRand = HalRandGather(abRand, sizeof(abRand));
    Assert(cbRand <= sizeof(abRand));

    // Compute a SHA1 digest of all of the gathered random bits

    XcSHAInit(abSha1Ctx);
    XcSHAUpdate(abSha1Ctx, pxnip->abSeed, sizeof(pxnip->abSeed));
    XcSHAUpdate(abSha1Ctx, (BYTE *)&pxnip->liTime, sizeof(pxnip->liTime));
    XcSHAUpdate(abSha1Ctx, abRand, cbRand);
    XcSHAFinal(abSha1Ctx, abHash);

    // Initialize an RC4 machine with the given digest as a key

    XcRC4Key(_abRandRc4Struct, sizeof(abHash), abHash);
    
    // Throw away the first 256 bytes of the RC4 machine

    XcRC4Crypt(_abRandRc4Struct, 256, abRand);

    // Update the seed value with the next 20 bytes of the RC4 machine

    XcRC4Crypt(_abRandRc4Struct, sizeof(pxnip->abSeed), pxnip->abSeed);
}

void CXnBase::Rand(BYTE * pb, UINT cb)
{
    ICHECK(BASE, USER|UDPC|SDPC);
    RaiseToDpc();
    XcRC4Crypt(_abRandRc4Struct, cb, pb);
}

ULONG CXnBase::RandLong()
{
    ICHECK(BASE, USER|UDPC|SDPC);
    ULONG ul;
    Rand((BYTE *)&ul, sizeof(ULONG));
    return(ul);
}

// ---------------------------------------------------------------------------------------
// CXnBase (Packet)
// ---------------------------------------------------------------------------------------

CPacket * CXnBase::PacketAlloc(ULONG tag, UINT uiFlags, UINT cbPayload, UINT cbPkt, PFNPKTFREE pfn)
{
    ICHECK(BASE, USER|UDPC|SDPC);

    Assert(sizeof(PFNPKTFREE) == sizeof(void *));

    CPacket *   ppkt;
    UINT        cbPtr;
    UINT        cbPad = 0;
    UINT        cbHdr = 0;

    // We shouldn't be creating CPacket classes that aren't four-byte aligned

    if (cbPkt == 0)
        cbPkt = sizeof(CPacket);

    Assert(cbPkt == ROUNDUP4(cbPkt));

    // Add in the ethernet header

    cbPkt += ROUNDUP4(sizeof(CEnetHdr));

    // This offset tells us where the [Payload] begins.

    cbPtr = cbPkt;

    // Add in the size of all the headers in the packet based on its type.

    cbPkt += CPacket::_abPktTypeInfo[((uiFlags & PKTF_TYPE_MASK) >> PKTF_TYPE_SHIFT) * PKTI_MAX + PKTI_SIZE];

    if (uiFlags & PKTF_TYPE_ESP)
    {
        cbHdr  = (uiFlags & PKTF_TYPE_UDP) ? sizeof(CUdpHdr) : (uiFlags & PKTF_TYPE_TCP) ? sizeof(CTcpHdr) : 0;
        cbPkt -= cbHdr;
        cbPad  = cbPkt;

        if (uiFlags & PKTF_CRYPT)
        {
            cbPkt += ROUNDUP8(XC_SERVICE_DES_BLOCKLEN + cbHdr + cbPayload + offsetof(CEspTail, _abHash));
            cbPad  = cbPkt - cbPad - (XC_SERVICE_DES_BLOCKLEN + cbHdr + cbPayload + offsetof(CEspTail, _abHash));
        }
        else
        {
            cbPkt += ROUNDUP4(cbPayload + cbHdr + offsetof(CEspTail, _abHash));
            cbPad  = cbPkt - cbPad - (cbPayload + cbHdr + offsetof(CEspTail, _abHash));
        }

        cbPkt += sizeof(CEspTail) - offsetof(CEspTail, _abHash);
    }
    else
    {
        // Add in the size of the user-specified payload

        cbPkt += cbPayload;
    }

    // Allocate the packet and initialize it

    if (uiFlags & PKTF_POOLALLOC)
        ppkt = (CPacket *)PoolAlloc(cbPkt, tag);
    else 
        ppkt = (CPacket *)SysAlloc(cbPkt, tag);

    if (ppkt)
    {
        ppkt->Init(uiFlags, (BYTE *)ppkt + cbPtr, cbPkt - cbPtr, pfn ? pfn : (PFNPKTFREE)PacketFree);

        // If this is an [ESP] packet, we need to store the _bPadLen field now since
        // we just went through a lot of trouble to compute it.

        if (uiFlags & PKTF_TYPE_ESP)
        {
            CEspTail * pEspTail = ppkt->GetEspTail();
            
            pEspTail->_bPadLen = (BYTE)cbPad;

            // Fill the padding (if any) with the byte series 1, 2, 3, ...

            for (BYTE * pb = (BYTE *)pEspTail; cbPad > 0; )
            {
                *--pb = (BYTE)cbPad--;
            }
        }

        IFDBG(ppkt->SetAllocated();)

        ppkt->Validate();
    }
    else
    {
        TraceSz1(Warning, "Out of memory allocating a CPacket of size %ld bytes", cbPkt);
    }

    return(ppkt);
}

void CXnBase::PacketFree(CPacket * ppkt)
{
    ICHECK(BASE, USER|UDPC|SDPC);
    Assert(!ppkt->TestFlags(PKTF_RECV_LOOPBACK));

#if DBG
    Assert(ppkt->IsAllocated());
#endif

    if (ppkt->TestFlags(PKTF_POOLALLOC))
        PoolFree(ppkt);
    else
        SysFree(ppkt);
}

void * CPacket::GetHdr(int iHdr)
{
    Assert(IsIp());
    Assert(PKTF_IHL_SHIFT == 2);
    Assert(iHdr == PKTI_ESP || iHdr == PKTI_UDP_TCP);
    Assert(PKTI_UDP_TCP == 1);
    return(     (BYTE *)_pv
            +   (_wFlags & PKTF_IHL_MASK)
            +   _abPktTypeInfo[(GetType() >> PKTF_TYPE_SHIFT) * PKTI_MAX + iHdr]
            +   (((!!(_wFlags & PKTF_CRYPT)) & iHdr) << 3));
}

#if DBG

const char * const CPacket::_aszPktTypeName[] =
{
    "[ENET]^[IP][Payload]",
    "[ENET]^[IP][ESP][Payload][ESPT]",
    "[ENET]^[IP][UDP][Payload]",
    "[ENET]^[IP][ESP][UDP][Payload][ESPT]",
    "[ENET]^[IP][TCP][Payload]",
    "[ENET]^[IP][ESP][TCP][Payload][ESPT]",
    "[ENET]^[Payload]",
    "[ENET]^[IP][Payload]",
    "[ENET]^[IP][ESP][IV][Payload][ESPT]",
    "[ENET]^[IP][UDP][Payload]",
    "[ENET]^[IP][ESP][IV][UDP][Payload][ESPT]",
    "[ENET]^[IP][TCP][Payload]",
    "[ENET]^[IP][ESP][IV][TCP][Payload][ESPT]",
    "[ENET]^[Payload]",
};

void CPacket::DbgSetSpy()
{
    int iType = (int)((_wFlags & PKTF_TYPE_MASK) >> PKTF_TYPE_SHIFT);

    _pchSpy = _aszPktTypeName[iType + ((_wFlags & PKTF_CRYPT) ? 7 : 0)];

    memset(&_spy, 0, sizeof(CSpy));

    _spy._pEnetHdr = (CEnetHdr *)((BYTE *)_pv - sizeof(CEnetHdr));

    if ((_wFlags & PKTF_TYPE_MASK) != PKTF_TYPE_ENET)
    {
        _spy._pIpHdr = (CIpHdr *)_pv;

        if (_wFlags & PKTF_TYPE_ESP)
        {
            _spy._pEspHdr  = GetEspHdr();
            _spy._pEspTail = GetEspTail();
        }

        if (_wFlags & PKTF_TYPE_UDP)
        {
            _spy._pUdpHdr = GetUdpHdr();
        }

        if (_wFlags & PKTF_TYPE_TCP)
        {
            _spy._pTcpHdr = GetTcpHdr();
        }
    }
}

void CPacket::Validate()
{
    if (IsEsp())
    {
        CEspTail *  pEspTail = GetEspTail();
        UINT        cbPad    = pEspTail->_bPadLen;
        BYTE *      pbPad    = (BYTE *)pEspTail;

        // Verify that the padding is the series of bytes 1, 2, 3, ...

        while (cbPad > 0 && *--pbPad == (BYTE)cbPad)
            cbPad--;
    
        AssertSz1(cbPad == 0, "Packet padding has been overwritten (ppkt=%08lX)", this);
    }
}

#endif

const BYTE CPacket::_abPktTypeInfo[] =
{
    // [ENET]^[IP][Payload]

    0,                                                                      // [ESP]
    0,                                                                      // [UDP]/[TCP]
    sizeof(CIpHdr),                                                         // Size

    // [ENET]^[IP][ESP][Payload][ESPT]

    sizeof(CIpHdr),                                                         // [ESP]
    0,                                                                      // [UDP]/[TCP]
    sizeof(CIpHdr) + sizeof(CEspHdr),                                       // Size

    // [ENET]^[IP][UDP][Payload]

    0,                                                                      // [ESP]
    sizeof(CIpHdr),                                                         // [UDP]/[TCP]
    sizeof(CIpHdr) + sizeof(CUdpHdr),                                       // Size

    // [ENET]^[IP][ESP][UDP][Payload][ESPT]

    sizeof(CIpHdr),                                                         // [ESP]
    sizeof(CIpHdr) + sizeof(CEspHdr),                                       // [UDP]/[TCP]
    sizeof(CIpHdr) + sizeof(CEspHdr) + sizeof(CUdpHdr),                     // Size

    // [ENET]^[IP][TCP][Payload]

    0,                                                                      // [ESP]
    sizeof(CIpHdr),                                                         // [UDP]/[TCP]
    sizeof(CIpHdr) + sizeof(CTcpHdr),                                       // Size

    // [ENET]^[IP][ESP][TCP][Payload][ESPT]

    sizeof(CIpHdr),                                                         // [ESP]
    sizeof(CIpHdr) + sizeof(CEspHdr),                                       // [UDP]/[TCP]
    sizeof(CIpHdr) + sizeof(CEspHdr) + sizeof(CTcpHdr),                     // Size
    
    // [ENET]^[Payload]
    0,                                                                      // [ESP]
    0,                                                                      // [UDP]/[TCP]
    0                                                                       // Size

};

// ---------------------------------------------------------------------------------------
// CPacketQueue
// ---------------------------------------------------------------------------------------

void CPacketQueue::InsertHead(CPacket * ppkt)
{
    if ((ppkt->_ppktNext = _ppktHead) == NULL)
        _ppktTail = ppkt;
    _ppktHead = ppkt;
}

void CPacketQueue::InsertTail(CPacket * ppkt)
{
    if (_ppktTail)
        _ppktTail->_ppktNext = ppkt;
    else
        _ppktHead = ppkt;

    _ppktTail = ppkt;
    ppkt->_ppktNext = NULL;
}

void CPacketQueue::InsertHead(CPacketQueue * ppq)
{
    Assert(!ppq->IsEmpty());
    if (_ppktTail == NULL)
        _ppktTail = ppq->_ppktTail;
    ppq->_ppktTail->_ppktNext = _ppktHead;
    _ppktHead = ppq->_ppktHead;
    ppq->Init();
}

CPacket * CPacketQueue::RemoveHead()
{
    Assert(!IsEmpty());

    CPacket * ppkt = _ppktHead;

    if ((_ppktHead = ppkt->_ppktNext) == NULL)
        _ppktTail = NULL;
    else
        ppkt->_ppktNext = NULL;

    return(ppkt);
}

void CPacketQueue::Complete(CXnBase * pXnBase)
{
    while (!IsEmpty())
    {
        RemoveHead()->Complete(pXnBase);
    }
}

void CPacketQueue::Discard(CXnBase * pXnBase)
{
    while (!IsEmpty())
    {
        pXnBase->PacketFree(RemoveHead());
    }
}

void CPacketQueue::Dequeue(CPacket * ppktDequeue)
{
    CPacket **  pppkt    = &_ppktHead;
    CPacket *   ppktPrev = NULL;
    CPacket *   ppkt;

    for (; (ppkt = *pppkt) != NULL; ppktPrev = ppkt, pppkt = &ppkt->_ppktNext)
    {
        if (ppkt == ppktDequeue)
        {
            *pppkt = ppkt->_ppktNext;

            if (_ppktHead == NULL)
                _ppktTail = NULL;
            else if (_ppktTail == ppkt)
                _ppktTail = ppktPrev;
            return;
        }
    }

    AssertSz1(0, "CPacketQueue::Dequeue(%08lX) - Packet not found in queue", ppktDequeue);
}

UINT CPacketQueue::Count()
{
    CPacket * ppkt;
    UINT c;

    for (c = 0, ppkt = _ppktHead; ppkt; ppkt = ppkt->_ppktNext)
    {
        c += 1;
    }

    return(c);
}

// ---------------------------------------------------------------------------------------
// CIpAddr
// ---------------------------------------------------------------------------------------

CIpAddr CIpAddr::DefaultMask() const
{
    if (IsClassA()) return(IPADDR_CLASSA_NETMASK);
    if (IsClassB()) return(IPADDR_CLASSB_NETMASK);
    if (IsClassC()) return(IPADDR_CLASSC_NETMASK);
    if (IsClassD()) return(IPADDR_CLASSD_NETMASK);

    TraceSz1(Warning, "CIpAddr:DefaultMask(): Invalid host IP address: %s", Str());

    return(0);
}

BOOL CIpAddr::IsValidUnicast() const
{
    return(_dw != 0 && !IsSecure() && !IsBroadcast() && !IsMulticast() && !IsLoopback());
}

BOOL CIpAddr::IsValidAddr() const
{
    return(     ((BYTE)(_ab[0] - 1)) <  254     // 1 ... 254
            &&  _ab[1]               <= 254     // 0 ... 254
            &&  _ab[2]               <= 254     // 0 ... 254
            &&  ((BYTE)(_ab[3] - 1)) <  254);   // 1 ... 254
}

#if DBG || defined(XNET_FEATURE_ASSERT) || defined(XNET_FEATURE_TRACE)

char * CIpAddr::Str() const
{
    #define IPADDR_STR_BUFFS    32
    #define IPADDR_BUF_SIZE     16
    static char g_chBufIpAddr[IPADDR_STR_BUFFS * IPADDR_BUF_SIZE];
    static LONG g_lBufIndexIpAddr = 0;
    char * pch = &g_chBufIpAddr[(InterlockedIncrement(&g_lBufIndexIpAddr) % IPADDR_STR_BUFFS) * IPADDR_BUF_SIZE];
    XnInAddrToString(*(IN_ADDR *)&_dw, pch, IPADDR_BUF_SIZE);
    return(pch);
}

#endif

// ---------------------------------------------------------------------------------------
// HexStr
// ---------------------------------------------------------------------------------------

#if DBG || defined(XNET_FEATURE_ASSERT) || defined(XNET_FEATURE_TRACE)

char * HexStr(const void * pv, size_t cb)
{
    #define HEXSTR_BUFFS        8
    #define HEXSTR_CBMAX        128
    #define HEXSTR_BUF_SIZE     (HEXSTR_CBMAX * 2 + 1)
    static char g_chHexBuf[HEXSTR_BUFFS * HEXSTR_BUF_SIZE];
    static LONG g_lHexBufIndex = 0;
    char * pch = &g_chHexBuf[(InterlockedIncrement(&g_lHexBufIndex) % HEXSTR_BUFFS) * HEXSTR_BUF_SIZE];
    char * pchDst = pch;
    BYTE * pb = (BYTE *)pv;
    UINT   ui;

    if (cb > HEXSTR_CBMAX)
        cb = HEXSTR_CBMAX;

    for (; cb > 0; --cb, ++pb)
    {
        ui = (*pb) >> 4;
        *pchDst++ = ui < 10 ? '0' + ui : 'A' + (ui - 10);
        ui = (*pb) & 0x0F;
        *pchDst++ = ui < 10 ? '0' + ui : 'A' + (ui - 10);
    }

    *pchDst = 0;

    return(pch);
}

#endif

// ---------------------------------------------------------------------------------------
// XnInAddrToString
// ---------------------------------------------------------------------------------------

void XnInAddrToString(const IN_ADDR ina, char * pchBuf, INT cchBuf)
{
    char    ach[16];
    BYTE *  pbSrc = (BYTE *)&ina;
    BYTE *  pbEnd = pbSrc + 4;
    char *  pbDst = (cchBuf < sizeof(ach)) ? ach : pchBuf;
    UINT    b;

    while (pbSrc < pbEnd)
    {
        b = *pbSrc++;

        if (b >= 10)
        {
            if (b >= 100) { *pbDst++ = '0' + (b / 100); b %= 100; }
            *pbDst++ = '0' + (b / 10); b %= 10;
        }

        *pbDst++ = '0' + b;
        *pbDst++ = '.';
    }

    pbDst[-1] = 0;

    if (cchBuf < sizeof(ach) && cchBuf > 0)
    {
        memcpy(pchBuf, ach, cchBuf);
        pchBuf[cchBuf - 1] = 0;
    }
}

// ---------------------------------------------------------------------------------------
// XnAddrStr
// ---------------------------------------------------------------------------------------

#if DBG || defined(XNET_FEATURE_ASSERT) || defined(XNET_FEATURE_TRACE)

char * XnAddrStr(const XNADDR * pxnaddr)
{
    #define XNADDR_STR_BUFFS    4
    #define XNADDR_BUF_SIZE     128
    static char g_chXnAddrBuf[XNADDR_STR_BUFFS * XNADDR_BUF_SIZE];
    static LONG g_lXnAddrBufIndex = 0;
    char * pch = &g_chXnAddrBuf[(InterlockedIncrement(&g_lXnAddrBufIndex) % XNADDR_STR_BUFFS) * XNADDR_BUF_SIZE];

    memset(pch, 0, XNADDR_BUF_SIZE);

    _snprintf(pch, XNADDR_BUF_SIZE - strlen(pch) - 2, "{ %s ", ((CEnetAddr *)pxnaddr->abEnet)->Str());

    if (pxnaddr->ina.s_addr != 0)
    {
        _snprintf(&pch[strlen(pch)], XNADDR_BUF_SIZE - strlen(pch) - 2, "%s ",
                  CIpAddr(pxnaddr->ina.s_addr).Str());

        if (pxnaddr->inaOnline.s_addr != 0)
        {
            _snprintf(&pch[strlen(pch)], XNADDR_BUF_SIZE - strlen(pch) - 2, "NAT %s:%d SG %s ",
                      CIpAddr(pxnaddr->inaOnline.s_addr).Str(), NTOHS(pxnaddr->wPortOnline),
                      HexStr(pxnaddr->abOnline, sizeof(pxnaddr->abOnline)));
        }
    }

    _snprintf(&pch[strlen(pch)], XNADDR_BUF_SIZE - strlen(pch) - 2, "}");

    return(pch);
}

#endif

// ---------------------------------------------------------------------------------------
// CEnetAddr
// ---------------------------------------------------------------------------------------

#if DBG || defined(XNET_FEATURE_ASSERT) || defined(XNET_FEATURE_TRACE)

char * CEnetAddr::Str() const
{
    #define ENETADDR_STR_BUFFS    32
    #define ENETADDR_BUF_SIZE     18
    static char g_chBuf[ENETADDR_STR_BUFFS * ENETADDR_BUF_SIZE];
    static LONG g_lBufIndex = 0;
    char * pch = &g_chBuf[(InterlockedIncrement(&g_lBufIndex) % ENETADDR_STR_BUFFS) * ENETADDR_BUF_SIZE];
    _snprintf(pch, ENETADDR_BUF_SIZE, "%02X-%02X-%02X-%02X-%02X-%02X", _ab[0], _ab[1], _ab[2], _ab[3], _ab[4], _ab[5]);
    return(pch);
}

#endif

// ---------------------------------------------------------------------------------------
// CXnBase (Timer)
// ---------------------------------------------------------------------------------------

void CXnBase::TimerSet(CTimer * pt, DWORD dwTick)
{
    ICHECK(BASE, UDPC|SDPC);

    Assert(sizeof(PFNTIMER) == sizeof(void *));
    AssertSz(dwTick >= _dwTick, "Attempt to set timer in the past");

    TraceSz2(Timer, "TimerSet %08lX dwTick=%08lX", pt, dwTick);

    if (pt->_le.Flink != NULL)
    {
        TraceSz1(Timer, "TimerDequeue %08lX", pt);
        AssertListEntry(&_leTimers, &pt->_le);
        RemoveEntryList(&pt->_le);
        pt->_le.Flink = NULL;
    }

    AssertList(&_leTimers);

    pt->_dwTick = dwTick;

    if (dwTick < 0xFFFFFFFF)
    {
        if (IsListEmpty(&_leTimers) || dwTick <= ((CTimer *)_leTimers.Flink)->_dwTick)
        {
            TraceSz1(Timer, "TimerEnqueue %08lX (Head)", pt);
            InsertHeadList(&_leTimers, &pt->_le)
        }
        else
        {
            CTimer * ptPrev = (CTimer *)_leTimers.Blink;

            while (dwTick < ptPrev->_dwTick)
            {
                ptPrev = (CTimer *)ptPrev->_le.Blink;
                Assert(ptPrev != (CTimer *)&_leTimers);
            }

            pt->_le.Flink = ptPrev->_le.Flink;
            pt->_le.Blink = &ptPrev->_le;
            ptPrev->_le.Flink->Blink = &pt->_le;
            ptPrev->_le.Flink = &pt->_le;

            TraceSz2(Timer, "TimerEnqueue %08lX (after %08lX)", pt, ptPrev);
        }

        AssertListEntry(&_leTimers, &pt->_le);
    }
}

DWORD CXnBase::TimerSetRelative(CTimer * pt, DWORD dwTicksFromNow)
{
    ICHECK(BASE, UDPC|SDPC);

    DWORD dwTick = _dwTick + dwTicksFromNow;

    if (dwTick < pt->_dwTick)
    {
        TimerSet(pt, dwTick);
    }

    return(dwTick);
}

void CXnBase::TimerDpc(PKDPC pkdpc, void * pvContext, void * pvParam1, void * pvParam2)
{
    ((CXnBase *)pvContext)->TimerPush();
}

void CXnBase::TimerPush()
{
    ICHECK(BASE, SDPC);

    _dwTickKe = KeQueryTickCount();
    DWORD dwTick = ++_dwTick;

    while (1)
    {
        AssertList(&_leTimers);

        CTimer * pt = (CTimer *)_leTimers.Flink;

        if (pt == (CTimer *)&_leTimers)
            break;

        if (dwTick < pt->_dwTick)
            break;

        TraceSz2(Timer, "TimerPush %08lX dwTick=%08lX", pt, dwTick);

        RemoveEntryList(&pt->_le);

        pt->_le.Flink = NULL;
        pt->_dwTick = TIMER_INFINITE;

        (this->*(pt->_pfn))(pt);
    }

    SecRegProbe();

    NicTimer();
}

// ---------------------------------------------------------------------------------------
// CXnBase
// ---------------------------------------------------------------------------------------

NTSTATUS CXnBase::BaseInit(XNetInitParams * pxnip)
{
    TCHECK(USER);

    NTSTATUS status = HalInit(pxnip);
    if (!NT_SUCCESS(status))
        return(status);

    SetInitFlag(INITF_BASE);

    memcpy(&cfgSizeOfStruct, &s_XNetParamsDef.cfgSizeOfStruct, sizeof(XNetParams));

    if (pxnip->pxnp != NULL)
    {
        if (    pxnip->pxnp->cfgSizeOfStruct != sizeof(XNetStartupParams)
            &&  pxnip->pxnp->cfgSizeOfStruct != sizeof(XNetParams))
        {
            TraceSz(Warning, "Ignoring parameters because cfgSizeOfStruct is invalid");
        }
        else
        {
            BYTE * pbDef = (BYTE *)&s_XNetParamsDef.cfgSizeOfStruct;
            BYTE * pbMin = (BYTE *)&s_XNetParamsMin.cfgSizeOfStruct;
            BYTE * pbMax = (BYTE *)&s_XNetParamsMax.cfgSizeOfStruct;
            BYTE * pbSrc = (BYTE *)&pxnip->pxnp->cfgSizeOfStruct;
            BYTE * pbDst = (BYTE *)&cfgSizeOfStruct;
            int    c     = pxnip->pxnp->cfgSizeOfStruct;

            for (; --c >= 0; ++pbDef, ++pbMin, ++pbMax, ++pbSrc, ++pbDst)
            {
                if (*pbSrc == 0)
                    *pbDst = *pbDef;
                else if (*pbSrc < *pbMin)
                    *pbDst = *pbMin;
                else if (*pbSrc > *pbMax)
                    *pbDst = *pbMax;
                else
                    *pbDst = *pbSrc;
            }
        }
    }

#ifdef XNET_FEATURE_XBDM_SERVER
    cfgFlags |= XNET_STARTUP_BYPASS_SECURITY;
#endif

    RandInit(pxnip);

    InitializeListHead(&_leTimers);
    KeInitializeDpc(&_dpcTimer, TimerDpc, this);
    KeInitializeTimer(&_timerTimer);

    // Start the current timer tick at one day to allow timer routines to compute times
    // in the past and not have to worry about going negative.

    _dwTick = 24 * 60 * 60 * TICKS_PER_SECOND;
    _dwTickKe = KeQueryTickCount();

#ifdef XNET_FEATURE_ASSERT
    _leakinfo._pfnLeakTag = XnLeakTagToString;
#endif

    SetInitFlag(INITF_BASE_1);

    UINT        cbPool = cfgPrivatePoolSizeInPages * 4096;
    PoolEntry * ppe;
    UINT        n;

    ppe = (PoolEntry *)SysAlloc(cbPool, PTAG_Pool);

    if (ppe == NULL)
    {
        return(NETERR_MEMORY);
    }

    _pvPoolStart = ppe;
    _pvPoolEnd   = ((BYTE *)ppe + cbPool);

    SetInitFlag(INITF_BASE_2);

    // Initialize the free lists with a single big block

    for (n = 0; n <= MAX_SMALL_BLOCKS; n++)
    {
        InitializeListHead(&_aleFree[n]);
    }

    // NOTE: we reserved the very first and the very last
    // pool blocks. This saves us from a couple of extra checks
    // during alloc and free.

    MarkPoolEntryBusy(ppe);
    TagPoolEntry(ppe, PTAG_PoolStart);
    ppe->bOver = (1 << POOL_BLOCK_SHIFT);
    ppe->previousSize = 0;
    ppe->blockSize = 1;

    ppe = GetPoolEntryNext(ppe);
    n = (cbPool >> POOL_BLOCK_SHIFT) - 2;
    MarkPoolEntryFree(ppe);
    TagPoolEntry(ppe, 0);
    ppe->previousSize = 1;
    ppe->blockSize = (WORD)n;
    InsertFreePoolEntry(ppe);

    ppe = GetPoolEntryNext(ppe);
    MarkPoolEntryBusy(ppe);
    TagPoolEntry(ppe, PTAG_PoolEnd);
    ppe->bOver = (1 << POOL_BLOCK_SHIFT);
    ppe->previousSize = (WORD)n;
    ppe->blockSize = 1;

    return(NETERR_OK);
}

void CXnBase::BaseStart()
{
    ICHECK(BASE, USER);

    HalStart();

    Assert(!TestInitFlag(INITF_BASE_STOP));

    LARGE_INTEGER liDue;
    liDue.QuadPart = -10000000 / TICKS_PER_SECOND;
    KeSetTimerEx(&_timerTimer, liDue, 1000 / TICKS_PER_SECOND, &_dpcTimer);
}

void CXnBase::BaseStop()
{
    TCHECK(UDPC|SDPC);

    if (!TestInitFlag(INITF_BASE_STOP))
    {
        if (TestInitFlag(INITF_BASE_1))
        {
            KeCancelTimer(&_timerTimer);
            KeRemoveQueueDpc(&_dpcTimer);
        }

        SetInitFlag(INITF_BASE_STOP);
    }

    HalStop();
}

void CXnBase::BaseTerm()
{
    TCHECK(UDPC);

    BaseStop();

    Assert(IsListEmpty(&_leTimers));

    if (TestInitFlag(INITF_BASE_2))
    {
        SysFree(_pvPoolStart);
        _pvPoolStart = NULL;
        _pvPoolEnd = NULL;
    }

#ifdef XNET_FEATURE_ASSERT
    if (_leakinfo._cLeak > 0)
    {
        LeakTerm(&_leakinfo);
    }
#endif

    SetInitFlag(INITF_BASE_TERM);

    HalTerm();
}

// ---------------------------------------------------------------------------------------
// Assert
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ASSERT

char * __cdecl DbgAssertFmt(char const * pszFmt, ...)
{
    #define ASSERT_ENTRY_SIZE   512
    #define ASSERT_ENTRY_COUNT  8
    static char s_achAssert[ASSERT_ENTRY_SIZE * ASSERT_ENTRY_COUNT];
    static LONG s_lAssert = 0;
    char * pchBuf = &s_achAssert[(InterlockedIncrement(&s_lAssert) % ASSERT_ENTRY_COUNT) * ASSERT_ENTRY_SIZE];
    pchBuf[0] = 0;
    va_list va;
    va_start(va, pszFmt);
    _vsnprintf(pchBuf, ASSERT_ENTRY_SIZE - 1, pszFmt, va);
    va_end(va);
    pchBuf[ASSERT_ENTRY_SIZE - 1] = 0;
    return(pchBuf);
}

#endif

// ---------------------------------------------------------------------------------------
// Trace
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_TRACE

void __cdecl DbgTrace(const char * pszTag, const char * pszFmt, ...)
{
    char ach[256];
    char * pchBuf = ach;
    int cchBuf = sizeof(ach);
    char * psz = (char *)pszFmt;
    va_list va;

    memset(ach, 0, sizeof(ach));

    if (*psz == '+')
        ++psz;
    else 
    {
        if (*psz == '\n')
        {
            *pchBuf++ = *psz++;
            cchBuf -= 1;
        }
#ifdef XNET_FEATURE_XBOX
        _snprintf(pchBuf, cchBuf - 2, "[" XNET_TRACE_PREFIX "] %s: ", pszTag);
#else
        _snprintf(pchBuf, cchBuf - 3, "[" XNET_TRACE_PREFIX ".%03X] %s: ", GetCurrentThreadId(), pszTag);
#endif
    }

    va_start(va, pszFmt);
    int cch = strlen(pchBuf);
    _vsnprintf(&pchBuf[cch], cchBuf - cch - 2, psz, va);
    va_end(va);

    cch = strlen(pchBuf);

    if (cch > 0 && *pszFmt && pszFmt[strlen(pszFmt) - 1] == '+')
        pchBuf[cch - 1] = 0;
    else
        strcpy(pchBuf + cch, "\n");

#ifdef XNET_FEATURE_XBDM_SERVER
    DbgPrintToKd(ach);
#else
    DbgPrint("%s", ach);
#endif
}

#endif

// ---------------------------------------------------------------------------------------
// DbgVerifyList
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ASSERT

const char * DbgVerifyList(LIST_ENTRY * ple, LIST_ENTRY * pleRequire)
{
    LIST_ENTRY * plePrev;
    LIST_ENTRY * pleThis;
    BOOL fFound = FALSE;
    UINT cEnt = 0;

    if (ple->Flink == NULL || ple->Blink == NULL)
        return("List Flink is NULL");
    else if (ple->Blink == NULL)
        return("List Blink is NULL");

    if (ple->Flink == ple || ple->Blink == ple)
    {
        if (ple->Flink != ple->Blink)
        {
            return("List head corrupt");
        }

        return((!pleRequire) ? NULL : "Required entry not found");
    }

    plePrev = ple;
    pleThis = ple->Flink;

    while (1)
    {
        if (pleThis == NULL)
        {
            return("List entry has an Flink that points to NULL");
        }

        if (plePrev != pleThis->Blink)
        {
            return("List entry has a Blink that doesn't point to previous entry");
            return(FALSE);
        }

        if (pleThis == ple)
            break;

        if (pleThis == pleRequire)
        {
            if (fFound)
            {
                return("List has required entry twice.  Cycle detected.");
            }

            fFound = TRUE;
        }

        plePrev = pleThis;
        pleThis = plePrev->Flink;

        if (++cEnt > 100000)
        {
            return("List has cycle");
        }
    }

    return((!pleRequire || fFound) ? NULL : "Required entry not found");
}

// ---------------------------------------------------------------------------------------
// DataToString
// ---------------------------------------------------------------------------------------

#if defined(XNET_FEATURE_TRACE)  || defined(XNET_FEATURE_ASSERT)

char * DataToString(BYTE * pb, UINT cb)
{
    #define DTS_ENTRY_SIZE   32
    #define DTS_ENTRY_COUNT  8
    static char s_achDts[DTS_ENTRY_SIZE * DTS_ENTRY_COUNT];
    static LONG s_lDts = 0;
    char * pbBuf = &s_achDts[(InterlockedIncrement(&s_lDts) % DTS_ENTRY_COUNT) * DTS_ENTRY_SIZE];
    char * pbDst = pbBuf;

    if (cb > DTS_ENTRY_SIZE - 1)
        cb = DTS_ENTRY_SIZE - 1;

    for (; cb > 0; ++pbDst, ++pb, --cb)
    {
        if (*pb >= 31 && *pb < 127)
            *pbDst = *pb;
        else
            *pbDst = '.';
    }

    *pbDst = 0;

    return(pbBuf);
}

#endif

// ---------------------------------------------------------------------------------------
// Push/Pop Recv Tags
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_TRACE

void CXnBase::PushPktRecvTags(BOOL fBroadcast)
{
    ICHECK(BASE, UDPC|SDPC);

    Assert(_cbPushPop < sizeof(_abPushPop));

    _abPushPop[_cbPushPop++] = !!fBroadcast;

    if (fBroadcast && ++_cPushPopBroadcast == 1)
    {
        _pktRecvPushPop = Tag(pktRecv);
        _pktWarnPushPop = Tag(pktWarn);
        Tag(pktRecv)    = Tag(pktBroadcast);
        Tag(pktWarn)    = Tag(pktBroadcast);
    }
}

void CXnBase::PopPktRecvTags()
{
    ICHECK(BASE, UDPC|SDPC);

    Assert(_cbPushPop > 0);

    if (_abPushPop[--_cbPushPop])
    {
        Assert(_cPushPopBroadcast > 0);

        if (--_cPushPopBroadcast == 0)
        {
            Tag(pktRecv) = _pktRecvPushPop;
            Tag(pktWarn) = _pktWarnPushPop;
        }
    }
}

#endif

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\mmx\virtual.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    virtual.c

Abstract:

    This module implements the kernel virtual memory management services.

--*/

#include "mi.h"

//
// Guards multiple threads attempting to commit, reserve, or change the page
// protections for the application virtual memory space.
//
INITIALIZED_CRITICAL_SECTION(MmAddressSpaceLock);

//
// Root pointer and hints into the virtual address descriptor tree.
//
PMMADDRESS_NODE MmVadRoot;
PMMADDRESS_NODE MmVadHint;
PMMADDRESS_NODE MmVadFreeHint;

//
// Number of bytes that have been reserved in the application virtual memory
// space.
//
SIZE_T MmVirtualMemoryBytesReserved;

NTSTATUS
NtAllocateVirtualMemory(
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    )
/*++

Routine Description:

    This function creates a region of pages within the virtual address
    space of a subject process.

Arguments:

    BaseAddress - Supplies a pointer to a variable that will receive
                  the base address of the allocated region of pages.
                  If the initial value of this argument is not null,
                  then the region will be allocated starting at the
                  specified virtual address rounded down to the next
                  host page size address boundary. If the initial
                  value of this argument is null, then the operating
                  system will determine where to allocate the region.

    ZeroBits - Supplies the number of high order address bits that
               must be zero in the base address of the section view. The
               value of this argument must be less than or equal to the
               maximum number of zero bits and is only used when memory
               management determines where to allocate the view (i.e. when
               BaseAddress is null).

               If ZeroBits is zero, then no zero bit constraints are applied.

               If ZeroBits is greater than 0 and less than 32, then it is
               the number of leading zero bits from bit 31.  Bits 63:32 are
               also required to be zero.  This retains compatibility
               with 32-bit systems.

               If ZeroBits is greater than 32, then it is considered as
               a mask and then number of leading zero are counted out
               in the mask.  This then becomes the zero bits argument.

    RegionSize - Supplies a pointer to a variable that will receive
                 the actual size in bytes of the allocated region
                 of pages. The initial value of this argument
                 specifies the size in bytes of the region and is
                 rounded up to the next host page size boundary.

    AllocationType - Supplies a set of flags that describe the type
                     of allocation that is to be performed for the
                     specified region of pages. Flags are:

         MEM_COMMIT - The specified region of pages is to be committed.

         MEM_RESERVE - The specified region of pages is to be reserved.

         MEM_TOP_DOWN - The specified region should be created at the
                        highest virtual address possible based on ZeroBits.

         MEM_RESET - Reset the state of the specified region so
                     that if the pages are in page paging file, they
                     are discarded and pages of zeroes are brought in.
                     If the pages are in memory and modified, they are marked
                     as not modified so they will not be written out to
                     the paging file.  The contents are NOT zeroed.

                     The Protect argument is ignored, but a valid protection
                     must be specified.

         MEM_PHYSICAL - The specified region of pages will map physical memory
                        directly via the AWE APIs.

         MEM_WRITE_WATCH - The specified private region is to be used for
                           write-watch purposes.

         MEM_NOZERO - The specified memory pages are not zero filled.

    Protect - Supplies the protection desired for the committed region of pages.

         PAGE_NOACCESS - No access to the committed region
                         of pages is allowed. An attempt to read,
                         write, or execute the committed region
                         results in an access violation.

         PAGE_EXECUTE - Execute access to the committed
                        region of pages is allowed. An attempt to
                        read or write the committed region results in
                        an access violation.

         PAGE_READONLY - Read only and execute access to the
                         committed region of pages is allowed. An
                         attempt to write the committed region results
                         in an access violation.

         PAGE_READWRITE - Read, write, and execute access to
                          the committed region of pages is allowed. If
                          write access to the underlying section is
                          allowed, then a single copy of the pages are
                          shared. Otherwise the pages are shared read
                          only/copy on write.

         PAGE_NOCACHE - The region of pages should be allocated
                        as non-cachable.

Return Value:

    Status of operation.

Environment:

    Kernel mode, PASSIVE_LEVEL.

--*/
{
    NTSTATUS status;
    ULONG PteProtectionMask;
    PVOID CapturedBase;
    SIZE_T CapturedRegionSize;
    PMMVAD Vad;
    BOOLEAN DeleteVadOnFailure;
    PCHAR TopAddress;
    PCHAR EndingAddress;
    PCHAR StartingAddress;
    PMMPTE StartingPte;
    PMMPTE EndingPte;
    PMMPTE PointerPte;
    PFN_COUNT PagesToCommit;
    PMMPFN PdePageFrame;
    PMMPTE PointerPde;
    PMMPTE NextPointerPte;
    KIRQL OldIrql;
    PMMREMOVE_PAGE_ROUTINE RemovePageRoutine;
    MMPFN_BUSY_TYPE BusyType;
    BOOLEAN ChangeProtection;
    MMPTE TempPte;
    ULONG OldProtect;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Check the zero bits argument for correctness.
    //

    if (ZeroBits > MM_MAXIMUM_ZERO_BITS) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Check the AllocationType for correctness.
    //

    if ((AllocationType & ~(MEM_COMMIT | MEM_RESERVE | MEM_TOP_DOWN |
                            MEM_RESET | MEM_NOZERO)) != 0) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // One of MEM_COMMIT, MEM_RESET or MEM_RESERVE must be set.
    //

    if ((AllocationType & (MEM_COMMIT | MEM_RESERVE | MEM_RESET)) == 0) {
        return STATUS_INVALID_PARAMETER;
    }

    if ((AllocationType & MEM_RESET) && (AllocationType != MEM_RESET)) {

        //
        // MEM_RESET may not be used with any other flag.
        //

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Check the protection field.
    //

    if (!MiMakePteProtectionMask(Protect, &PteProtectionMask)) {
        return STATUS_INVALID_PAGE_PROTECTION;
    }

    //
    // Capture the base address.
    //

    CapturedBase = *BaseAddress;

    //
    // Capture the region size.
    //

    CapturedRegionSize = *RegionSize;

    //
    // Make sure the specified starting and ending addresses are within the user
    // part of the virtual address space.
    //

    if (CapturedBase > MM_HIGHEST_VAD_ADDRESS) {

        //
        // Invalid base address.
        //

        return STATUS_INVALID_PARAMETER;
    }

    if ((((ULONG_PTR)MM_HIGHEST_VAD_ADDRESS + 1) - (ULONG_PTR)CapturedBase) <
        CapturedRegionSize) {

        //
        // Invalid region size.
        //

        return STATUS_INVALID_PARAMETER;
    }

    if (CapturedRegionSize == 0) {

        //
        // Region size cannot be 0.
        //

        return STATUS_INVALID_PARAMETER;
    }

    MI_LOCK_ADDRESS_SPACE();

    //
    // Handle the case of reserving an address range.
    //

    Vad = NULL;
    DeleteVadOnFailure = FALSE;

    if ((CapturedBase == NULL) || (AllocationType & MEM_RESERVE)) {

        //
        // Reserve the address space.
        //

        if (CapturedBase == NULL) {

            //
            // No base address was specified.  This MUST be a reserve or
            // reserve and commit.
            //

            CapturedRegionSize = ROUND_TO_PAGES(CapturedRegionSize);

            //
            // If the number of zero bits is greater than zero, then calculate
            // the highest address.
            //

            if (ZeroBits != 0) {
                TopAddress = (PCHAR)(((ULONG_PTR)MM_USER_ADDRESS_RANGE_LIMIT) >> ZeroBits);

                //
                // Keep the top address below the highest user vad address
                // regardless.
                //

                if (TopAddress > (PCHAR)MM_HIGHEST_VAD_ADDRESS) {
                    status = STATUS_INVALID_PARAMETER;
                    goto ErrorReturn;
                }

            } else {
                TopAddress = MM_HIGHEST_VAD_ADDRESS;
            }

            //
            // Establish exception handler as MiFindEmptyAddressRange will raise
            // an exception if it fails.
            //

            try {

                if (AllocationType & MEM_TOP_DOWN) {

                    //
                    // Start from the top of memory downward.
                    //

                    StartingAddress = MiFindEmptyAddressRangeDown(
                        CapturedRegionSize, TopAddress, X64K);

                } else {

                    StartingAddress = MiFindEmptyAddressRange(
                        CapturedRegionSize, X64K, (ULONG)ZeroBits);
                }

            } except (EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
                goto ErrorReturn;
            }

            //
            // Calculate the ending address based on the top address.
            //

            EndingAddress = (PVOID)(((ULONG_PTR)StartingAddress +
                CapturedRegionSize - 1L) | (PAGE_SIZE - 1L));

            if (EndingAddress > TopAddress) {

                //
                // The allocation does not honor the zero bits argument.
                //

                status = STATUS_NO_MEMORY;
                goto ErrorReturn;
            }

        } else {

            //
            // A non-NULL base address was specified. Check to make sure the
            // specified base address to ending address is currently unused.
            //

            EndingAddress = (PVOID)(((ULONG_PTR)CapturedBase +
                CapturedRegionSize - 1L) | (PAGE_SIZE - 1L));

            //
            // Align the starting address on a 64k boundary.
            //

            StartingAddress = (PVOID)MI_ALIGN_TO_SIZE(CapturedBase, X64K);

            //
            // See if a VAD overlaps with this starting/ending address pair.
            //

            if (MiCheckForConflictingVad(StartingAddress, EndingAddress) != NULL) {
                status = STATUS_CONFLICTING_ADDRESSES;
                goto ErrorReturn;
            }
        }

        Vad = ExAllocatePoolWithTag(sizeof(MMVAD), 'SdaV');

        if (Vad == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorReturn;
        }

        Vad->StartingVpn = MI_VA_TO_VPN(StartingAddress);
        Vad->EndingVpn = MI_VA_TO_VPN(EndingAddress);
        Vad->AllocationProtect = Protect;

        MiInsertVad(Vad);

        CapturedBase = StartingAddress;
        CapturedRegionSize = EndingAddress - StartingAddress + 1;

        MmVirtualMemoryBytesReserved += CapturedRegionSize;

        if ((AllocationType & MEM_COMMIT) == 0) {

            //
            // Don't commit the pages, so bail out now.
            //

            MI_UNLOCK_ADDRESS_SPACE();

            *RegionSize = CapturedRegionSize;
            *BaseAddress = CapturedBase;

            return STATUS_SUCCESS;
        }

        //
        // Fall into the commit path.
        //

        DeleteVadOnFailure = TRUE;
    }

    //
    // Handle the case of committing or resetting the pages contained in an
    // address range.
    //

    EndingAddress = (PCHAR)(((ULONG_PTR)CapturedBase + CapturedRegionSize - 1) |
        (PAGE_SIZE - 1));
    StartingAddress = (PCHAR)PAGE_ALIGN(CapturedBase);

    CapturedRegionSize = EndingAddress - StartingAddress + 1;

    //
    // Locate the virtual address descriptor for the specified addresses.
    //

    Vad = MiCheckForConflictingVad(StartingAddress, EndingAddress);

    if (Vad == NULL) {

        //
        // No virtual address is reserved at the specified base address, return
        // an error.
        //

        status = STATUS_CONFLICTING_ADDRESSES;
        goto ErrorReturn;
    }

    //
    // Ensure that the starting and ending addresses are all within the same
    // virtual address descriptor.
    //

    if ((MI_VA_TO_VPN(StartingAddress) < Vad->StartingVpn) ||
        (MI_VA_TO_VPN(EndingAddress) > Vad->EndingVpn)) {

        //
        // Not within the section virtual address descriptor,
        // return an error.
        //

        status = STATUS_CONFLICTING_ADDRESSES;
        goto ErrorReturn;
    }

    //
    // Handle the case of resetting the pages contained in an address range.
    // We wait until this point to ensure that a virtual address descriptor
    // really exists for the input arguments.
    //

    if (AllocationType == MEM_RESET) {

        //
        // There's no pagefile support, so this flag is a no-op.
        //

        status = STATUS_SUCCESS;
        goto ErrorReturn;
    }

    //
    // Compute the starting and ending PTE addresses.
    //

    StartingPte = MiGetPteAddress(StartingAddress);
    EndingPte = MiGetPteAddress(EndingAddress);

    //
    // Make a pass through the PTEs to determine the number of pages that we'll
    // need to commit.
    //

    PagesToCommit = 0;
    PointerPte = StartingPte;

    while (PointerPte <= EndingPte) {

        //
        // If this is the first pass through the loop or the current PTE pointer
        // is on a PDE boundary, then ensure that the page table is committed.
        //

        if ((PointerPte == StartingPte) || MiIsPteOnPdeBoundary(PointerPte)) {

            PointerPde = MiGetPteAddress(PointerPte);

            if (PointerPde->Hard.Valid == 0) {

                //
                // The PDE is not committed.  Add in one page for the page table
                // and all of the pages that need to be committed for this PDE.
                //

                NextPointerPte = MiGetVirtualAddressMappedByPte(PointerPde + 1);

                PagesToCommit++;

                if (NextPointerPte > EndingPte) {
                    PagesToCommit += (EndingPte - PointerPte + 1);
                } else {
                    PagesToCommit += (NextPointerPte - PointerPte);
                }

                PointerPte = NextPointerPte;

                continue;
            }
        }

        //
        // Add in one page if the PTE is zero.  Note that we don't just check
        // the Valid bit because the page may be a PAGE_NOACCESS or PAGE_GUARD
        // protected page.
        //

        if (PointerPte->Long == 0) {
            PagesToCommit++;
        }

        PointerPte++;
    }

    //
    // Now ensure that we can allocate the required number of pages.
    //

    MI_LOCK_MM(&OldIrql);

    if (MmAvailablePages < PagesToCommit) {
        MI_UNLOCK_MM(OldIrql);
        status = STATUS_NO_MEMORY;
        goto ErrorReturn;
    }

    //
    // Make another pass through the PTEs to actually commit the pages.
    //

    RemovePageRoutine = (AllocationType & MEM_NOZERO) ? MiRemoveAnyPage :
        MiRemoveZeroPage;
    BusyType = (Protect & (PAGE_EXECUTE | PAGE_EXECUTE_READ |
        PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)) ? MmImageUsage :
        MmVirtualMemoryUsage;
    ChangeProtection = FALSE;
    PointerPte = StartingPte;
    PdePageFrame = NULL;

    while (PointerPte <= EndingPte) {

        //
        // If this is the first pass through the loop or the current PTE pointer
        // is on a PDE boundary, then ensure that the page table is committed.
        //

        if ((PointerPte == StartingPte) || MiIsPteOnPdeBoundary(PointerPte)) {

            PointerPde = MiGetPteAddress(PointerPte);

            if (PointerPde->Hard.Valid == 0) {

                PagesToCommit--;

                TempPte.Long = MiGetValidKernelPdeBits();
                TempPte.Hard.PageFrameNumber =
                    MiRemoveZeroPage(MmVirtualPageTableUsage, PointerPde);

                MI_WRITE_PTE(PointerPde, TempPte);
            }

            PdePageFrame = MI_PFN_ELEMENT(PointerPde->Hard.PageFrameNumber);

            ASSERT(PdePageFrame->Busy.Busy == 1);
            ASSERT(PdePageFrame->Busy.BusyType == MmVirtualPageTableUsage);
        }

        if (PointerPte->Long == 0) {

            PagesToCommit--;

            TempPte.Long = PteProtectionMask;
            TempPte.Hard.PageFrameNumber = RemovePageRoutine(BusyType, PointerPte);

            MI_WRITE_PTE(PointerPte, TempPte);

            PdePageFrame->Directory.NumberOfUsedPtes++;

            ASSERT(PdePageFrame->Directory.NumberOfUsedPtes <= PTE_PER_PAGE);

        } else if ((PointerPte->Long & MM_PTE_PROTECTION_MASK) != PteProtectionMask) {

            ChangeProtection = TRUE;
        }

        PointerPte++;
    }

    ASSERT(PagesToCommit == 0);
    ASSERT(PdePageFrame != NULL && PdePageFrame->Directory.NumberOfUsedPtes > 0);

    //
    // Write combined accesses may not check the processor's cache, so force a
    // flush of the TLB and cache now to ensure coherency.
    //
    // Flush the cache for uncached allocations so that all cache lines from the
    // page are out of the processor's caches.  The pages are likely to be
    // shared with an external device and the external device may not snoop the
    // cache lines.
    //

    if (Protect & (PAGE_WRITECOMBINE | PAGE_NOCACHE)) {
        KeFlushCurrentTbAndInvalidateAllCaches();
    }

    MI_UNLOCK_MM(OldIrql);

    MI_UNLOCK_ADDRESS_SPACE();

    *RegionSize = CapturedRegionSize;
    *BaseAddress = StartingAddress;

    //
    // If we found a page that was already committed but had the wrong page
    // protection, then make a call to NtProtectVirtualMemory to make all of
    // the pages have the right attributes.
    //

    if (ChangeProtection) {
        NtProtectVirtualMemory(&StartingAddress, &CapturedRegionSize, Protect,
            &OldProtect);
    }

    return STATUS_SUCCESS;

ErrorReturn:
    if (!NT_SUCCESS(status) && DeleteVadOnFailure) {

        MmVirtualMemoryBytesReserved -= CapturedRegionSize;

        MiRemoveVad(Vad);
        ExFreePool(Vad);
    }

    MI_UNLOCK_ADDRESS_SPACE();
    return status;
}

NTSTATUS
NtFreeVirtualMemory(
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
    )
/*++

Routine Description:

    This function deletes a region of pages within the virtual address
    space of a subject process.

Arguments:

    BaseAddress - The base address of the region of pages
                  to be freed. This value is rounded down to the
                  next host page address boundary.

    RegionSize - A pointer to a variable that will receive
                 the actual size in bytes of the freed region of
                 pages. The initial value of this argument is
                 rounded up to the next host page size boundary.

    FreeType - A set of flags that describe the type of
               free that is to be performed for the specified
               region of pages.

       FreeType Flags

        MEM_DECOMMIT - The specified region of pages is to
             be decommitted.

        MEM_RELEASE - The specified region of pages is to
             be released.

Return Value:

    Status of operation.

Environment:

    Kernel mode, PASSIVE_LEVEL.

--*/
{
    NTSTATUS status;
    PVOID CapturedBase;
    SIZE_T CapturedRegionSize;
    PCHAR EndingAddress;
    PCHAR StartingAddress;
    PMMVAD Vad;
    PMMVAD NewVad;
    KIRQL OldIrql;
    PMMPTE StartingPte;
    PMMPTE EndingPte;
    MMPTE TempPte;
    PMMPTE PointerPte;
    PMMPFN PdePageFrame;
    PMMPTE PointerPde;
    PFN_NUMBER PageFrameNumber;
    BOOLEAN FullTlbFlush;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Check to make sure FreeType is good.
    //

    if ((FreeType & ~(MEM_DECOMMIT | MEM_RELEASE)) != 0) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // One of MEM_DECOMMIT or MEM_RELEASE must be specified, but not both.
    //

    if (((FreeType & (MEM_DECOMMIT | MEM_RELEASE)) == 0) ||
        ((FreeType & (MEM_DECOMMIT | MEM_RELEASE)) ==
                            (MEM_DECOMMIT | MEM_RELEASE))) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Capture the base address.
    //

    CapturedBase = *BaseAddress;

    //
    // Capture the region size.
    //

    CapturedRegionSize = *RegionSize;

    //
    // Make sure the specified starting and ending addresses are within the user
    // part of the virtual address space.
    //

    if (CapturedBase > MM_HIGHEST_USER_ADDRESS) {

        //
        // Invalid base address.
        //

        return STATUS_INVALID_PARAMETER;
    }

    if ((ULONG_PTR)MM_HIGHEST_USER_ADDRESS - (ULONG_PTR)CapturedBase <
        CapturedRegionSize) {

        //
        // Invalid region size.
        //

        return STATUS_INVALID_PARAMETER;
    }

    EndingAddress = (PCHAR)(((ULONG_PTR)CapturedBase + CapturedRegionSize - 1) |
        (PAGE_SIZE - 1));
    StartingAddress = (PCHAR)PAGE_ALIGN(CapturedBase);

    MI_LOCK_ADDRESS_SPACE();

    Vad = (PMMVAD)MiLocateAddress(StartingAddress);

    if (Vad == NULL) {

        //
        // No virtual address descriptor located for base address.
        //

        status = STATUS_MEMORY_NOT_ALLOCATED;
        goto ErrorReturn;
    }

    //
    // Found the associated virtual address descriptor.
    //

    if (Vad->EndingVpn < MI_VA_TO_VPN(EndingAddress)) {

        //
        // The entire range to delete is not contained within a single
        // virtual address descriptor.  Return an error.
        //

        status = STATUS_UNABLE_TO_FREE_VM;
        goto ErrorReturn;
    }

    //
    // Handle the case of releasing an address range.
    //

    if (FreeType & MEM_RELEASE) {

        //
        // If the region size is zero, remove the whole VAD.
        //

        if (CapturedRegionSize == 0) {

            //
            // If the region size is specified as 0, the base address
            // must be the starting address for the region.
            //

            if (MI_VA_TO_VPN(CapturedBase) != Vad->StartingVpn) {
                status = STATUS_FREE_VM_NOT_AT_BASE;
                goto ErrorReturn;
            }

            //
            // Delete the VAD.
            //

            StartingAddress = MI_VPN_TO_VA(Vad->StartingVpn);
            EndingAddress = MI_VPN_TO_VA_ENDING(Vad->EndingVpn);

            MiRemoveVad(Vad);
            ExFreePool(Vad);

        } else {

            //
            // Region's size was not specified as zero, delete the whole VAD or
            // split the VAD.
            //

            if (MI_VA_TO_VPN(StartingAddress) == Vad->StartingVpn) {

                if (MI_VA_TO_VPN(EndingAddress) == Vad->EndingVpn) {

                    //
                    // Delete the VAD.
                    //

                    MiRemoveVad(Vad);
                    ExFreePool(Vad);

                } else {

                    //
                    // Change the starting address of the VAD.
                    //

                    Vad->StartingVpn = MI_VA_TO_VPN(EndingAddress + 1);
                }

            } else {

                //
                // Starting address is greater than start of VAD.
                //

                if (MI_VA_TO_VPN(EndingAddress) == Vad->EndingVpn) {

                    //
                    // Change the ending address of the VAD.
                    //

                    Vad->EndingVpn = MI_VA_TO_VPN(StartingAddress - 1);

                } else {

                    //
                    // Split this VAD as the address range is within the VAD.
                    //

                    NewVad = ExAllocatePoolWithTag(sizeof(MMVAD), 'SdaV');

                    if (NewVad == NULL) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto ErrorReturn;
                    }

                    *NewVad = *Vad;

                    Vad->EndingVpn = MI_VA_TO_VPN(StartingAddress - 1);
                    NewVad->StartingVpn = MI_VA_TO_VPN(EndingAddress + 1);

                    MiInsertVad(NewVad);
                }
            }
        }

        MmVirtualMemoryBytesReserved -= (1 + EndingAddress - StartingAddress);

        //
        // Fall into the decommit path.
        //
    }

    //
    // Handle the case of decomitting pages in an address range.
    //

    MI_LOCK_MM(&OldIrql);

    //
    // Compute the starting and ending PTE addresses.
    //

    StartingPte = MiGetPteAddress(StartingAddress);
    EndingPte = MiGetPteAddress(EndingAddress);

    //
    // Make a pass through the PTEs to decommit pages.
    //

    TempPte.Long = 0;
    PointerPte = StartingPte;
    PdePageFrame = NULL;
    FullTlbFlush = FALSE;

    while (PointerPte <= EndingPte) {

        //
        // If this is the first pass through the loop or the current PTE pointer
        // is on a PDE boundary, then ensure that the page table is committed.
        //

        if ((PointerPte == StartingPte) || MiIsPteOnPdeBoundary(PointerPte)) {

            PointerPde = MiGetPteAddress(PointerPte);

            if (PointerPde->Hard.Valid == 0) {
                PointerPte = MiGetVirtualAddressMappedByPte(PointerPde + 1);
                continue;
            }

            PdePageFrame = MI_PFN_ELEMENT(PointerPde->Hard.PageFrameNumber);
        }

        //
        // Check if the PTE is marked committed.  Note that we don't just check
        // the Valid bit because the page may be a PAGE_NOACCESS or PAGE_GUARD
        // protected page.
        //

        if (PointerPte->Long != 0) {

            PageFrameNumber = PointerPte->Hard.PageFrameNumber;

            MI_WRITE_AND_FLUSH_PTE(PointerPte, TempPte);

            MiReleasePageOwnership(PageFrameNumber);

            //
            // Decrement the number of PTEs allocated to this page directory and
            // free the page directory if the count is zero.
            //

            PdePageFrame->Directory.NumberOfUsedPtes--;

            if (PdePageFrame->Directory.NumberOfUsedPtes == 0) {

                PointerPde = MiGetPteAddress(PointerPte);
                PageFrameNumber = PointerPde->Hard.PageFrameNumber;

                MI_WRITE_PTE(PointerPde, TempPte);

                FullTlbFlush = TRUE;

                MiReleasePageOwnership(PageFrameNumber);

                PointerPte = MiGetVirtualAddressMappedByPte(PointerPde + 1);
                continue;
            }
        }

        PointerPte++;
    }

    //
    // If any page table pages were discarded above, then do a full flush of the
    // TLB.
    //

    if (FullTlbFlush) {
        KeFlushCurrentTb();
    }

    MI_UNLOCK_MM(OldIrql);

    MI_UNLOCK_ADDRESS_SPACE();

    *RegionSize = 1 + EndingAddress - StartingAddress;
    *BaseAddress = StartingAddress;

    return STATUS_SUCCESS;

ErrorReturn:
    MI_UNLOCK_ADDRESS_SPACE();
    return status;
}

NTSTATUS
NtQueryVirtualMemory(
    IN PVOID BaseAddress,
    OUT PMEMORY_BASIC_INFORMATION MemoryInformation
    )
/*++

Routine Description:

    This function provides the capability to determine the state,
    protection, and type of a region of pages within the virtual address
    space of the subject process.

    The state of the first page within the region is determined and then
    subsequent entries in the process address map are scanned from the
    base address upward until either the entire range of pages has been
    scanned or until a page with a nonmatching set of attributes is
    encountered. The region attributes, the length of the region of pages
    with matching attributes, and an appropriate status value are
    returned.

    If the entire region of pages does not have a matching set of
    attributes, then the returned length parameter value can be used to
    calculate the address and length of the region of pages that was not
    scanned.

Arguments:

    BaseAddress - The base address of the region of pages to be
        queried. This value is rounded down to the next host-page-
        address boundary.

    MemoryInformation - A pointer to a buffer that receives the
        specified information.  The format and content of the buffer
        depend on the specified information class.

        MemoryBasicInformation - Data type is PMEMORY_BASIC_INFORMATION.

            MEMORY_BASIC_INFORMATION Structure

            ULONG RegionSize - The size of the region in bytes
                beginning at the base address in which all pages have
                identical attributes.

            ULONG State - The state of the pages within the region.

                State Values

                MEM_COMMIT - The state of the pages within the region
                    is committed.

                MEM_FREE - The state of the pages within the region
                    is free.

                MEM_RESERVE - The state of the pages within the
                    region is reserved.

            ULONG Protect - The protection of the pages within the
                region.

                Protect Values

                PAGE_NOACCESS - No access to the region of pages is
                    allowed. An attempt to read, write, or execute
                    within the region results in an access violation
                    (i.e., a GP fault).

                PAGE_EXECUTE - Execute access to the region of pages
                    is allowed. An attempt to read or write within
                    the region results in an access violation.

                PAGE_READONLY - Read-only and execute access to the
                    region of pages is allowed. An attempt to write
                    within the region results in an access violation.

                PAGE_READWRITE - Read, write, and execute access to
                    the region of pages is allowed. If write access
                    to the underlying section is allowed, then a
                    single copy of the pages are shared. Otherwise,
                    the pages are shared read-only/copy-on-write.

                PAGE_GUARD - Read, write, and execute access to the
                    region of pages is allowed; however, access to
                    the region causes a "guard region entered"
                    condition to be raised in the subject process.

                PAGE_NOCACHE - Disable the placement of committed
                    pages into the data cache.

            ULONG Type - The type of pages within the region.

                Type Values

                MEM_PRIVATE - The pages within the region are
                    private.

                MEM_MAPPED - The pages within the region are mapped
                    into the view of a section.

                MEM_IMAGE - The pages within the region are mapped
                    into the view of an image section.

Return Value:

    Status of operation.

Environment:

    Kernel mode, PASSIVE_LEVEL.

--*/
{
    PMMVAD Vad;
    ULONG_PTR BaseVpn;
    BOOLEAN Found;
    SIZE_T RegionSize;
    PMMPTE StartingPte;
    PMMPTE EndingPte;
    PMMPTE PointerPte;
    PMMPTE PointerPde;
    ULONG AllocationProtect;
    ULONG Protect;
    ULONG PteProtectionMask;
    ULONG State;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    if (BaseAddress > MM_HIGHEST_VAD_ADDRESS) {

        //
        // Invalid base address.
        //

        return STATUS_INVALID_PARAMETER;
    }

    MI_LOCK_ADDRESS_SPACE();

    //
    // Locate the VAD that contains the base address or the VAD which follows
    // the base address.
    //

    Vad = (PMMVAD)MmVadRoot;
    BaseVpn = MI_VA_TO_VPN(BaseAddress);
    Found = FALSE;

    for (;;) {

        if (Vad == NULL) {
            break;
        }

        if ((BaseVpn >= Vad->StartingVpn) && (BaseVpn <= Vad->EndingVpn)) {
            Found = TRUE;
            break;
        }

        if (BaseVpn < Vad->StartingVpn) {
            if (Vad->LeftChild == NULL) {
                break;
            }
            Vad = (PMMVAD)Vad->LeftChild;

        } else {
            if (BaseVpn < Vad->EndingVpn) {
                break;
            }
            if (Vad->RightChild == NULL) {
                break;
            }
            Vad = (PMMVAD)Vad->RightChild;
        }
    }

    if (!Found) {

        //
        // There is no virtual address allocated at the base address.  Return
        // the size of the hole starting at the base address.
        //

        if (Vad == NULL) {
            RegionSize = ((PCHAR)MM_HIGHEST_VAD_ADDRESS + 1) -
                (PCHAR)PAGE_ALIGN(BaseAddress);
        } else {
            if (Vad->StartingVpn < BaseVpn) {

                //
                // We are looking at the Vad which occupies the range just
                // before the desired range.  Get the next Vad.
                //

                Vad = MiGetNextVad(Vad);
                if (Vad == NULL) {
                    RegionSize = ((PCHAR)MM_HIGHEST_VAD_ADDRESS + 1) -
                        (PCHAR)PAGE_ALIGN(BaseAddress);
                } else {
                    RegionSize = (PCHAR)MI_VPN_TO_VA (Vad->StartingVpn) -
                        (PCHAR)PAGE_ALIGN(BaseAddress);
                }
            } else {
                RegionSize = (PCHAR)MI_VPN_TO_VA (Vad->StartingVpn) -
                    (PCHAR)PAGE_ALIGN(BaseAddress);
            }
        }

        MI_UNLOCK_ADDRESS_SPACE();

        MemoryInformation->AllocationBase = NULL;
        MemoryInformation->AllocationProtect = 0;
        MemoryInformation->BaseAddress = PAGE_ALIGN(BaseAddress);
        MemoryInformation->RegionSize = RegionSize;
        MemoryInformation->State = MEM_FREE;
        MemoryInformation->Protect = PAGE_NOACCESS;
        MemoryInformation->Type = 0;

        return STATUS_SUCCESS;
    }

    //
    // There is a virtual address allocated at the base address.
    //

    StartingPte = MiGetPteAddress(BaseAddress);
    EndingPte = MiGetPteAddress(MI_VPN_TO_VA(Vad->EndingVpn));

    AllocationProtect = Vad->AllocationProtect;

    //
    // Determine the state and protection attributes of the base address.
    //

    Protect = 0;
    PteProtectionMask = 0;
    PointerPte = StartingPte;
    PointerPde = MiGetPteAddress(PointerPte);

    if (PointerPde->Hard.Valid != 0) {

        //
        // Check if the PTE is marked committed.  Note that we don't just check
        // the Valid bit because the page may be a PAGE_NOACCESS or PAGE_GUARD
        // protected page.
        //

        if (PointerPte->Long == 0) {
            State = MEM_RESERVE;
        } else {
            State = MEM_COMMIT;
            PteProtectionMask = (PointerPte->Long & MM_PTE_PROTECTION_MASK);
            Protect = MiDecodePteProtectionMask(PteProtectionMask);
        }

    } else {

        State = MEM_RESERVE;
    }

    //
    // Make a pass through the PTEs to compute the number of pages with the same
    // state and protection attributes as the base address.
    //

    while (PointerPte <= EndingPte) {

        //
        // If this is the first pass through the loop or the current PTE pointer
        // is on a PDE boundary, then ensure that the page table is committed.
        //

        if ((PointerPte == StartingPte) || MiIsPteOnPdeBoundary(PointerPte)) {

            PointerPde = MiGetPteAddress(PointerPte);

            if (PointerPde->Hard.Valid == 0) {

                if (State == MEM_COMMIT) {
                    break;
                }

                PointerPte = MiGetVirtualAddressMappedByPte(PointerPde + 1);
                continue;
            }
        }

        if (PointerPte->Long != 0) {

            if (State == MEM_RESERVE) {
                break;
            }

            if ((PointerPte->Long & MM_PTE_PROTECTION_MASK) != PteProtectionMask) {
                break;
            }

        } else {

            if (State == MEM_COMMIT) {
                break;
            }
        }

        PointerPte++;
    }

    if (PointerPte > EndingPte) {
        PointerPte = EndingPte + 1;
    }

    RegionSize = (PCHAR)MiGetVirtualAddressMappedByPte(PointerPte) -
        (PCHAR)PAGE_ALIGN(BaseAddress);

    //
    // We should have found at least one valid page worth of data.
    //

    ASSERT(RegionSize > 0);

    MI_UNLOCK_ADDRESS_SPACE();

    MemoryInformation->AllocationBase = MI_VPN_TO_VA(Vad->StartingVpn);
    MemoryInformation->AllocationProtect = AllocationProtect;
    MemoryInformation->BaseAddress = PAGE_ALIGN(BaseAddress);
    MemoryInformation->RegionSize = RegionSize;
    MemoryInformation->State = State;
    MemoryInformation->Protect = Protect;
    MemoryInformation->Type = MEM_PRIVATE;

    return STATUS_SUCCESS;
}

NTSTATUS
NtProtectVirtualMemory(
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG NewProtect,
    OUT PULONG OldProtect
    )
/*++

Routine Description:

    This routine changes the protection on a region of committed pages
    within the virtual address space of the subject process.  Setting
    the protection on a range of pages causes the old protection to be
    replaced by the specified protection value.

Arguments:

    BaseAddress - The base address of the region of pages
          whose protection is to be changed. This value is
          rounded down to the next host page address
          boundary.

    RegionSize - A pointer to a variable that will receive
          the actual size in bytes of the protected region
          of pages. The initial value of this argument is
          rounded up to the next host page size boundary.

    NewProtect - The new protection desired for the
          specified region of pages.

     Protect Values

          PAGE_NOACCESS - No access to the specified region
               of pages is allowed. An attempt to read,
               write, or execute the specified region
               results in an access violation (i.e. a GP
               fault).

          PAGE_EXECUTE - Execute access to the specified
               region of pages is allowed. An attempt to
               read or write the specified region results in
               an access violation.

          PAGE_READONLY - Read only and execute access to the
               specified region of pages is allowed. An
               attempt to write the specified region results
               in an access violation.

          PAGE_READWRITE - Read, write, and execute access to
               the specified region of pages is allowed. If
               write access to the underlying section is
               allowed, then a single copy of the pages are
               shared. Otherwise the pages are shared read
               only/copy on write.

          PAGE_GUARD - Read, write, and execute access to the
               specified region of pages is allowed,
               however, access to the region causes a "guard
               region entered" condition to be raised in the
               subject process. If write access to the
               underlying section is allowed, then a single
               copy of the pages are shared. Otherwise the
               pages are shared read only/copy on write.

          PAGE_NOCACHE - The page should be treated as uncached.
               This is only valid for non-shared pages.

     OldProtect - A pointer to a variable that will receive
          the old protection of the first page within the
          specified region of pages.

Return Value:

    Status of operation.

Environment:

    Kernel mode, PASSIVE_LEVEL.

--*/
{
    NTSTATUS status;
    ULONG PteProtectionMask;
    PVOID CapturedBase;
    SIZE_T CapturedRegionSize;
    PCHAR EndingAddress;
    PCHAR StartingAddress;
    PMMVAD Vad;
    PMMPTE StartingPte;
    PMMPTE EndingPte;
    PMMPTE PointerPte;
    PMMPTE PointerPde;
    KIRQL OldIrql;
    ULONG OldPteProtectionMask;
    MMPTE TempPte;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Check the protection field.
    //

    if (!MiMakePteProtectionMask(NewProtect, &PteProtectionMask)) {
        return STATUS_INVALID_PAGE_PROTECTION;
    }

    //
    // Capture the base address.
    //

    CapturedBase = *BaseAddress;

    //
    // Capture the region size.
    //

    CapturedRegionSize = *RegionSize;

    //
    // Make sure the specified starting and ending addresses are within the user
    // part of the virtual address space.
    //

    if (CapturedBase > MM_HIGHEST_USER_ADDRESS) {

        //
        // Invalid base address.
        //

        return STATUS_INVALID_PARAMETER;
    }

    if ((ULONG_PTR)MM_HIGHEST_USER_ADDRESS - (ULONG_PTR)CapturedBase <
        CapturedRegionSize) {

        //
        // Invalid region size.
        //

        return STATUS_INVALID_PARAMETER;
    }

    if (CapturedRegionSize == 0) {
        return STATUS_INVALID_PARAMETER;
    }

    MI_LOCK_ADDRESS_SPACE();

    EndingAddress = (PCHAR)(((ULONG_PTR)CapturedBase + CapturedRegionSize - 1) |
        (PAGE_SIZE - 1));
    StartingAddress = (PCHAR)PAGE_ALIGN(CapturedBase);

    //
    // Locate the virtual address descriptor for the specified addresses.
    //

    Vad = MiCheckForConflictingVad(StartingAddress, EndingAddress);

    if (Vad == NULL) {

        //
        // No virtual address is reserved at the specified base address,
        // return an error.
        //

        status = STATUS_CONFLICTING_ADDRESSES;
        goto ErrorReturn;
    }

    //
    // Ensure that the starting and ending addresses are all within the same
    // virtual address descriptor.
    //

    if ((MI_VA_TO_VPN(StartingAddress) < Vad->StartingVpn) ||
        (MI_VA_TO_VPN(EndingAddress) > Vad->EndingVpn)) {

        //
        // Not within the section virtual address descriptor,
        // return an error.
        //

        status = STATUS_CONFLICTING_ADDRESSES;
        goto ErrorReturn;
    }

    //
    // Compute the starting and ending PTE addresses.
    //

    StartingPte = MiGetPteAddress(StartingAddress);
    EndingPte = MiGetPteAddress(EndingAddress);

    //
    // Make a pass through the PTEs to verify that all of the pages are
    // committed.
    //

    PointerPte = StartingPte;

    while (PointerPte <= EndingPte) {

        //
        // If this is the first pass through the loop or the current PTE pointer
        // is on a PDE boundary, then ensure that the page table is committed.
        //

        if ((PointerPte == StartingPte) || MiIsPteOnPdeBoundary(PointerPte)) {

            PointerPde = MiGetPteAddress(PointerPte);

            if (PointerPde->Hard.Valid == 0) {
                status = STATUS_NOT_COMMITTED;
                goto ErrorReturn;
            }
        }

        //
        // Check if the PTE is marked committed.  Note that we don't just check
        // the Valid bit because the page may be a PAGE_NOACCESS or PAGE_GUARD
        // protected page.
        //

        if (PointerPte->Long == 0) {
            status = STATUS_NOT_COMMITTED;
            goto ErrorReturn;
        }

        PointerPte++;
    }

    //
    // Make another pass through the PTEs to change the page permissions.
    //

    MI_LOCK_MM(&OldIrql);

    OldPteProtectionMask = PteProtectionMask;
    PointerPte = StartingPte;

    while (PointerPte <= EndingPte) {

        if (PointerPte->Long != 0) {

            TempPte = *PointerPte;

            if ((TempPte.Long & MM_PTE_PROTECTION_MASK) != PteProtectionMask) {

                //
                // Save off the attributes of the first non-matching page that
                // we find so that we can return the old protection code to the
                // caller.
                //

                if (OldPteProtectionMask == PteProtectionMask) {
                    OldPteProtectionMask = (TempPte.Long & MM_PTE_PROTECTION_MASK);
                }

                TempPte.Long = ((TempPte.Long & ~MM_PTE_PROTECTION_MASK) |
                    PteProtectionMask);

                MI_WRITE_AND_FLUSH_PTE(PointerPte, TempPte);
            }
        }

        PointerPte++;
    }

    //
    // Write combined accesses may not check the processor's cache, so force a
    // flush of the TLB and cache now to ensure coherency.
    //
    // Flush the cache for uncached allocations so that all cache lines from the
    // page are out of the processor's caches.  The pages are likely to be
    // shared with an external device and the external device may not snoop the
    // cache lines.
    //

    if (NewProtect & (PAGE_WRITECOMBINE | PAGE_NOCACHE)) {
        KeFlushCurrentTbAndInvalidateAllCaches();
    }

    MI_UNLOCK_MM(OldIrql);

    MI_UNLOCK_ADDRESS_SPACE();

    *RegionSize = 1 + EndingAddress - StartingAddress;
    *BaseAddress = StartingAddress;
    *OldProtect = MiDecodePteProtectionMask(OldPteProtectionMask);

    return STATUS_SUCCESS;

ErrorReturn:
    MI_UNLOCK_ADDRESS_SPACE();
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\halw.cpp ===
// ---------------------------------------------------------------------------------------
// halw.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

#ifdef XNET_FEATURE_WINDOWS

#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <rsa.h>
#include <rc4.h>
#include <sha.h>
#include <modes.h>
#include <des.h>
#include <tripldes.h>
#include <benaloh.h>
#include <shahmac.h>
#include <cryptkeys.h>

// ---------------------------------------------------------------------------------------
// Hal Dpc Support
// ---------------------------------------------------------------------------------------

struct CHalDpc
{
    LONG                _lInitLock;             // Spin lock to synchronize VLanInit/VLanTerm
    UINT                _cRefs;                 // Number of times HalDpcInit called
    HANDLE              _hEvent;                // Handle to signalling event for dispatch thread
    HANDLE              _hThread;               // Thread handle for dispatch thread
    BOOL                _fShutdown;             // TRUE to shutdown the dispatch thread
    DWORD               _dwThreadId;            // Thread Id of dispatch thread
    DWORD               _dwDpcThreadId;         // Thread Id of thread currently at dispatch level
    INT                 _iThreadPriority;       // Old thread priority of thread at dispatch level
    LIST_ENTRY          _dpcq;                  // Queued KDPCs
    LIST_ENTRY          _timerq;                // Queued KTIMERs
    CRITICAL_SECTION    _cs;                    // Synchronization
};

CHalDpc                 g_HalDpc;

DWORD WINAPI HalDpcThreadProc(void *)
{
    PKDPC       pkdpc;
    PKTIMER     pktimer;
    DWORD       dwNow;
    DWORD       dwWait;
    LONG        lWait;

    while (1)
    {
        EnterCriticalSection(&g_HalDpc._cs);

        if (g_HalDpc._fShutdown)
            break;

        Assert(g_HalDpc._dwThreadId == GetCurrentThreadId());
        Assert(g_HalDpc._dwDpcThreadId == 0);
        g_HalDpc._dwDpcThreadId = g_HalDpc._dwThreadId;
        Assert(g_HalDpc._dwDpcThreadId != 0);

        while (!IsListEmpty(&g_HalDpc._dpcq))
        {
            pkdpc = (PKDPC)RemoveHeadList(&g_HalDpc._dpcq);
            pkdpc->DpcListEntry.Flink = NULL;
            pkdpc->DeferredRoutine(pkdpc,
                                   pkdpc->DeferredContext,
                                   pkdpc->SystemArgument1,
                                   pkdpc->SystemArgument2);
        }

        dwWait = INFINITE;

        if (!IsListEmpty(&g_HalDpc._timerq))
        {
            while (1)
            {
                dwNow   = GetTickCount();
                dwWait  = INFINITE;
                pktimer = (PKTIMER)g_HalDpc._timerq.Flink;
                pkdpc   = NULL;

                while (pktimer != (PKTIMER)&g_HalDpc._timerq)
                {
                    lWait = (LONG)(pktimer->DueTime - dwNow);

                    if (lWait <= 0)
                    {
                        pktimer->DueTime = dwNow + pktimer->Period;
                        pkdpc = pktimer->Dpc;
                        break;
                    }

                    if (dwWait > (DWORD)lWait)
                        dwWait = (DWORD)lWait;

                    pktimer = (PKTIMER)pktimer->TimerListEntry.Flink;
                }

                if (pkdpc == NULL)
                    break;

                pkdpc->DeferredRoutine(pkdpc,
                                       pkdpc->DeferredContext,
                                       pkdpc->SystemArgument1,
                                       pkdpc->SystemArgument2);
            }
        }

        Assert(g_HalDpc._dwThreadId == GetCurrentThreadId());
        Assert(g_HalDpc._dwDpcThreadId == g_HalDpc._dwThreadId);
        g_HalDpc._dwDpcThreadId = 0;
        LeaveCriticalSection(&g_HalDpc._cs);
        WaitForSingleObject(g_HalDpc._hEvent, dwWait);
    }

    return(0);
}

void HalDpcCleanup()
{
    BOOL fResult = FALSE;

    if (g_HalDpc._hThread)
    {
        Assert(g_HalDpc._dwDpcThreadId == GetCurrentThreadId());
        g_HalDpc._fShutdown = TRUE;
        LeaveCriticalSection(&g_HalDpc._cs);
        SetEvent(g_HalDpc._hEvent);
        WaitForSingleObject(g_HalDpc._hThread, INFINITE);
        CloseHandle(g_HalDpc._hThread);
    }

    if (g_HalDpc._hEvent)
    {
        CloseHandle(g_HalDpc._hEvent);
    }

    DeleteCriticalSection(&g_HalDpc._cs);

    memset(&g_HalDpc, 0, sizeof(g_HalDpc));
}

BOOL HalDpcInit()
{
    BOOL fResult = FALSE;

    while (InterlockedCompareExchange(&g_HalDpc._lInitLock, 1, 0))
    {
        Sleep(10);
    }

    if (g_HalDpc._cRefs == 0)
    {
        InitializeCriticalSection(&g_HalDpc._cs);
        InitializeListHead(&g_HalDpc._dpcq);
        InitializeListHead(&g_HalDpc._timerq);

        g_HalDpc._hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (g_HalDpc._hEvent == NULL)
        {
            TraceSz1(Warning, "HalDpcInit - CreateEvent failed (%d)", GetLastError());
            goto ret;
        }

        g_HalDpc._hThread = CreateThread(NULL, 0, HalDpcThreadProc, NULL, 0, &g_HalDpc._dwThreadId);

        if (g_HalDpc._hThread == NULL)
        {
            TraceSz1(Warning, "HalDpcInit - CreateThread failed (%d)", GetLastError());
            goto ret;
        }

        // Increase the priority of the DPC thread so that is preempts any user thread, 
        // and also preempts the VLan thread (which runs at THREAD_PRIORITY_ABOVE_NORMAL).

        SetThreadPriority(g_HalDpc._hThread, THREAD_PRIORITY_HIGHEST);
    }

    g_HalDpc._cRefs += 1;
    fResult = TRUE;

ret:

    if (!fResult)
    {
        HalDpcCleanup();
    }

    g_HalDpc._lInitLock = 0;

    return(fResult);
}

BOOL HalDpcTerm()
{
    BOOL fResult = FALSE;

    while (InterlockedCompareExchange(&g_HalDpc._lInitLock, 1, 0))
    {
        Sleep(10);
    }

    Assert(g_HalDpc._cRefs > 0);

    if (--g_HalDpc._cRefs == 0)
    {
        HalDpcCleanup();
        fResult = TRUE;
    }

    g_HalDpc._lInitLock = 0;

    return(fResult);
}

// ---------------------------------------------------------------------------------------
// CXnHal
// ---------------------------------------------------------------------------------------

NTSTATUS CXnHal::HalInit(XNetInitParams * pxnip)
{
    TCHECK(USER);

    if (!HalDpcInit())
    {
        return(NETERR_MEMORY);
    }

    strncpy(_achXbox, pxnip->pszXbox ? pxnip->pszXbox : "xb1@Lan", sizeof(_achXbox) - 1);

    SetInitFlag(INITF_HAL);

    return(NETERR_OK);
}

void CXnHal::HalTerm()
{
    TCHECK(UDPC);

    SetInitFlag(INITF_HAL_TERM);

    if (TestInitFlag(INITF_HAL))
    {
        if (HalDpcTerm())
        {
            SetInitFlag(INITF_HAL_STOP);
        }
    }
}

KIRQL CXnHal::KeGetCurrentIrql()
{
    ICHECK(HAL, USER|UDPC|SDPC);

    DWORD dwThreadId = GetCurrentThreadId();

    if (dwThreadId == g_HalDpc._dwDpcThreadId)
        return(DISPATCH_LEVEL);
    else
    {
        Assert(dwThreadId != g_HalDpc._dwThreadId);
        return(PASSIVE_LEVEL);
    }
}

KIRQL CXnHal::KeRaiseIrqlToDpcLevel()
{
    ICHECK(HAL, USER|UDPC|SDPC);

    DWORD dwThreadId = GetCurrentThreadId();

    EnterCriticalSection(&g_HalDpc._cs);

    Assert(dwThreadId != g_HalDpc._dwThreadId || dwThreadId == g_HalDpc._dwDpcThreadId);

    if (dwThreadId == g_HalDpc._dwDpcThreadId)
    {
        LeaveCriticalSection(&g_HalDpc._cs);
        Assert(DISPATCH_LEVEL != PASSIVE_LEVEL);
        return(DISPATCH_LEVEL);
    }

    g_HalDpc._dwDpcThreadId = dwThreadId;
    Assert(g_HalDpc._dwDpcThreadId != 0);
    Assert(dwThreadId != g_HalDpc._dwThreadId);

    if (dwThreadId != g_HalDpc._dwThreadId)
    {
        g_HalDpc._iThreadPriority = GetThreadPriority(GetCurrentThread());
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
    }

    return(PASSIVE_LEVEL);
}

void CXnHal::KeLowerIrql(KIRQL kirql)
{
    TCHECK(USER|UDPC|SDPC);

    if (TestInitFlag(INITF_HAL_STOP))
    {
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
    }
    else if (kirql == PASSIVE_LEVEL)
    {
        DWORD dwThreadId = GetCurrentThreadId();
        Assert(dwThreadId != g_HalDpc._dwThreadId);
        Assert(dwThreadId == g_HalDpc._dwDpcThreadId);
        g_HalDpc._dwDpcThreadId = 0;

        if (dwThreadId != g_HalDpc._dwThreadId)
        {
            SetThreadPriority(GetCurrentThread(), g_HalDpc._iThreadPriority);
        }

        LeaveCriticalSection(&g_HalDpc._cs);
    }
}

void CXnHal::KeInitializeDpc(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOID DeferredContext)
{
    ICHECK(HAL, USER|UDPC|SDPC);

    Dpc->DeferredRoutine    = DeferredRoutine;
    Dpc->DeferredContext    = DeferredContext;
    Dpc->DpcListEntry.Flink = NULL;
}

BOOLEAN CXnHal::KeInsertQueueDpc(PRKDPC Dpc, PVOID SystemArgument1, PVOID SystemArgument2)
{
    ICHECK(HAL, USER|UDPC|SDPC);

    if (Dpc->DpcListEntry.Flink == NULL)
    {
        EnterCriticalSection(&g_HalDpc._cs);

        if (Dpc->DpcListEntry.Flink == NULL)
        {
            Dpc->SystemArgument1 = SystemArgument1;
            Dpc->SystemArgument2 = SystemArgument2;
            AssertList(&g_HalDpc._dpcq);
            InsertTailList(&g_HalDpc._dpcq, &Dpc->DpcListEntry);
        }

        LeaveCriticalSection(&g_HalDpc._cs);

        SetEvent(g_HalDpc._hEvent);
    }

    return(TRUE);
}

BOOLEAN CXnHal::KeRemoveQueueDpc(PRKDPC Dpc)
{
    ICHECK(HAL, USER|UDPC|SDPC);

    if (Dpc->DpcListEntry.Flink != NULL)
    {
        EnterCriticalSection(&g_HalDpc._cs);

        if (Dpc->DpcListEntry.Flink != NULL)
        {
            AssertListEntry(&g_HalDpc._dpcq, &Dpc->DpcListEntry);
            RemoveEntryList(&Dpc->DpcListEntry);
            Dpc->DpcListEntry.Flink = NULL;
        }

        LeaveCriticalSection(&g_HalDpc._cs);
    }

    return(TRUE);
}

void CXnHal::KeInitializeTimer(PKTIMER Timer)
{
    ICHECK(HAL, USER|UDPC|SDPC);

    Timer->TimerListEntry.Flink = NULL;
}

BOOLEAN CXnHal::KeSetTimerEx(PKTIMER Timer, LARGE_INTEGER DueTime, LONG Period, PKDPC Dpc)
{
    ICHECK(HAL, USER|UDPC|SDPC);

    EnterCriticalSection(&g_HalDpc._cs);

    if (Timer->TimerListEntry.Flink == NULL)
    {
        AssertList(&g_HalDpc._timerq);
        Timer->DueTime = GetTickCount() + (DWORD)(DueTime.QuadPart / -10000);
        Timer->Period  = Period;
        Timer->Dpc     = Dpc;
        InsertTailList(&g_HalDpc._timerq, &Timer->TimerListEntry);
    }

    LeaveCriticalSection(&g_HalDpc._cs);

    SetEvent(g_HalDpc._hEvent);

    return(TRUE);
}

BOOLEAN CXnHal::KeCancelTimer(PKTIMER Timer)
{
    ICHECK(HAL, USER|UDPC|SDPC);

    if (Timer->TimerListEntry.Flink != NULL)
    {
        EnterCriticalSection(&g_HalDpc._cs);

        if (Timer->TimerListEntry.Flink != NULL)
        {
            AssertListEntry(&g_HalDpc._timerq, &Timer->TimerListEntry);
            RemoveEntryList(&Timer->TimerListEntry);
            Timer->TimerListEntry.Flink = NULL;
        }

        LeaveCriticalSection(&g_HalDpc._cs);
    }

    return(TRUE);
}

CRaiseToDpc::CRaiseToDpc(CXnHal * pXnHal)
{
    _pXnHal = pXnHal;
    _irql = pXnHal->KeRaiseIrqlToDpcLevel();
    Assert(_irql == PASSIVE_LEVEL || _irql == DISPATCH_LEVEL);
    Assert(GetCurrentThreadId() != g_HalDpc._dwThreadId || _irql == DISPATCH_LEVEL);
}

CRaiseToDpc::~CRaiseToDpc()
{
    Assert(GetCurrentThreadId() != g_HalDpc._dwThreadId || _irql == DISPATCH_LEVEL);
    Assert(_irql == PASSIVE_LEVEL || _irql == DISPATCH_LEVEL);
    _pXnHal->KeLowerIrql((KIRQL)_irql);
}

#ifdef XNET_FEATURE_ASSERT

BOOL CXnHal::HalThreadCheck(UINT uiCheck)
{
    DWORD dwThreadId = GetCurrentThreadId();

    if (dwThreadId != g_HalDpc._dwDpcThreadId)
        return(uiCheck & USER);
    else if (dwThreadId == g_HalDpc._dwThreadId)
        return(uiCheck & SDPC);
    else
        return(uiCheck & UDPC);
}

#endif

void CXnHal::HalEnterDpc()
{
    EnterCriticalSection(&g_HalDpc._cs);
}

BOOL CXnHal::HalTryEnterDpc()
{
    return(TryEnterCriticalSection(&g_HalDpc._cs));
}

void CXnHal::HalLeaveDpc()
{
    LeaveCriticalSection(&g_HalDpc._cs);
}

// ---------------------------------------------------------------------------------------
// CXnHal::SetInitFlag
// ---------------------------------------------------------------------------------------

void CXnHal::SetInitFlag(DWORD dwFlag)
{
    DWORD dwFlagsOld, dwFlagsNew;

    while (1)
    {
        dwFlagsOld = _dwInitFlags;

        Assert((dwFlagsOld & dwFlag) == 0);

        dwFlagsNew = dwFlagsOld | dwFlag;

        if (InterlockedCompareExchange((LONG *)&_dwInitFlags, (LONG)dwFlagsNew, (LONG)dwFlagsOld) == (LONG)dwFlagsOld)
            break;

        TraceSz(Warning, "CXnHal::SetInitFlag: Thread/DPC contention.  Retrying.");
    }
}

// ---------------------------------------------------------------------------------------
// Hal System Memory
// ---------------------------------------------------------------------------------------

DefineTag(VMem, 0);
DefineTag(VMemFront, 0);

DWORD g_dwVMem = 0;

BOOL VMemIsEnabled()
{
#ifdef XNET_FEATURE_VMEM
    if (g_dwVMem == 0)
    {
        char * pszVMem = getenv("VMEM");

        g_dwVMem = VMEM_CHECKED;

        if (pszVMem)
        {
            g_dwVMem |= VMEM_ENABLED;

            if (lstrcmpiA(pszVMem, "frontside") != 0)
            {
                g_dwVMem |= VMEM_BACKSIDESTRICT;
            }
        }
        else if (Tag(VMem))
        {
            g_dwVMem |= VMEM_ENABLED;

            if (!Tag(VMemFront))
                g_dwVMem |= VMEM_BACKSIDESTRICT;

        }

        if (g_dwVMem & VMEM_ENABLED)
        {
            TraceSz1(VMem, "Enabled for %s byte faults", (g_dwVMem & VMEM_BACKSIDESTRICT) ? "next" : "prev");
        }
    }

    return(g_dwVMem & VMEM_ENABLED);
#else
    return(FALSE);
#endif
}

void * HalAlloc(size_t cb, ULONG tag)
{
#ifdef XNET_FEATURE_VMEM
    if (VMemIsEnabled())
    {
        return(VMemAlloc(cb));
    }
#endif

    return(LocalAlloc(LMEM_FIXED, cb));
}

void * HalAllocZ(size_t cb, ULONG tag)
{
#ifdef XNET_FEATURE_VMEM
    if (VMemIsEnabled())
    {
        void * pv = VMemAlloc(cb);

        if (pv)
        {
            memset(pv, 0, cb);
        }

        return(pv);
    }
#endif

    return(LocalAlloc(LPTR, cb));
}

void HalFree(void * pv)
{
#ifdef XNET_FEATURE_VMEM
    if (VMemIsEnabled())
    {
        VMemFree(pv);
        return;
    }
#endif

    if (pv)
    {
        LocalFree(pv);
    }
}

// ---------------------------------------------------------------------------------------
// Hal Randomness
// ---------------------------------------------------------------------------------------

UINT CXnHal::HalRandGather(BYTE * pb, UINT cb)
{
    memset(pb, 0xAA, cb);
    QueryPerformanceCounter((LARGE_INTEGER *)pb);
    GetSystemTimeAsFileTime((FILETIME *)(pb + sizeof(LARGE_INTEGER)));
    return(cb);
}

// ---------------------------------------------------------------------------------------
// Hal Crypto
// ---------------------------------------------------------------------------------------

void
XcSHAInit(
    IN PUCHAR pbSHAContext
    )
{
    A_SHAInit((A_SHA_CTX*)pbSHAContext);
}
   
void
XcSHAUpdate(
    IN PUCHAR pbSHAContext,
    IN PUCHAR pbInput,
    IN ULONG dwInputLength
    )
{
    A_SHAUpdate((A_SHA_CTX*)pbSHAContext, pbInput, dwInputLength);
}
   
void
XcSHAFinal(
    IN PUCHAR pbSHAContext,
    IN PUCHAR pbDigest
    )
{
    A_SHAFinal((A_SHA_CTX*)pbSHAContext, pbDigest);
}
   
void
XcRC4Key(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwKeyLength,
    IN PUCHAR pbKey
    )
{
    rc4_key((RC4_KEYSTRUCT*)pbKeyStruct, dwKeyLength, pbKey);
}
   
void
XcRC4Crypt(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwInputLength,
    IN PUCHAR pbInput
    )
{
    rc4((RC4_KEYSTRUCT*)pbKeyStruct, dwInputLength, pbInput);
}
   
void
XcHMAC(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    )
{
#define HMAC_K_PADSIZE              64
#define HMAC_KI_XOR_FACTOR            ((DWORD)0x36363636)
#define HMAC_KO_XOR_FACTOR            ((DWORD)0x5C5C5C5C)
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= HMAC_KI_XOR_FACTOR;
        ((DWORD*)Kopad)[dwBlock] ^= HMAC_KO_XOR_FACTOR;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        A_SHAUpdate(&shaHash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    }

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}

// compute A = B ^ C mod D, N = len of params in DWORDs
ULONG
XcModExp(
    IN LPDWORD pA,
    IN LPDWORD pB,
    IN LPDWORD pC,
    IN LPDWORD pD,
    IN ULONG dwN
    )
{
    //
    // compute A = B ^ C mod D
    //
    return BenalohModExp(pA, pB, pC, pD, dwN);
}
   
void
XcDESKeyParity(
    IN PUCHAR pbKey,
    IN ULONG dwKeyLength
    )
{
    desparityonkey(pbKey, dwKeyLength);
}
   
void
XcKeyTable(
    IN ULONG dwCipher,
    OUT PUCHAR pbKeyTable,
    IN PUCHAR pbKey
    )
{
    if (dwCipher == XC_SERVICE_DES_CIPHER)
    {
        deskey((DESTable*)pbKeyTable, pbKey);
    }
    else
    {
        // Assume XC_SERVICE_DES3_CIPHER:
        tripledes3key((PDES3TABLE)pbKeyTable, pbKey);
    }
}
   
void
XcBlockCrypt(
    IN ULONG dwCipher,
    IN PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp
    )
{
    void (RSA32API *pCipher)(BYTE *, BYTE *, void *, int) = (dwCipher == XC_SERVICE_DES_CIPHER) ? des : tripledes;
    (*pCipher)( pbOutput, pbInput, pbKeyTable, dwOp );
}
   
void
XcBlockCryptCBC(
    IN ULONG dwCipher,
    IN ULONG dwInputLength,
    IN PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp,
    IN PUCHAR pbFeedback
    )
{
    BYTE *pbInputEnd = pbInput + dwInputLength;
    void (RSA32API *pCipher)(BYTE *, BYTE *, void *, int) = (dwCipher == XC_SERVICE_DES_CIPHER) ? des : tripledes;
    while (pbInput < pbInputEnd)
    {
        CBC(pCipher, XC_SERVICE_DES_BLOCKLEN, pbOutput, pbInput, pbKeyTable, dwOp, pbFeedback);
        pbInput += XC_SERVICE_DES_BLOCKLEN;
        pbOutput += XC_SERVICE_DES_BLOCKLEN;
    }
}

DWORD
XcCalcKeyLen(
    IN  PBYTE  pbPublicKey
    )
{
    LPBSAFE_PUB_KEY pPubKey = (LPBSAFE_PUB_KEY)pbPublicKey;

    return pPubKey->keylen;
}

//
// Reverse ASN.1 Encodings of possible hash identifiers.  
//
static char * shaEncodings[] = {
            //      1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
            "\x0f\x14\x04\x00\x05\x1a\x02\x03\x0e\x2b\x05\x06\x09\x30\x21\x30",
            "\x0d\x14\x04\x1a\x02\x03\x0e\x2b\x05\x06\x07\x30\x1f\x30",
            "\x00" };

BOOL XcVerifyPKCS1SigningFmt(
    IN  BSAFE_PUB_KEY* pKey,
    IN  BYTE* pbDigest,
    IN  BYTE* pbPKCS1Format
    )
{
    BYTE**    rgEncOptions;
    BYTE      rgbTmpHash[A_SHA_DIGEST_LEN + 16];
    DWORD     i;
    DWORD     cb;
    BYTE*     pbStart;
    DWORD     cbTmp;

    rgEncOptions = (BYTE **)shaEncodings;

    // 
    // reverse the hash to match the signature.
    //
    for (i = 0; i < A_SHA_DIGEST_LEN; i++) {
        rgbTmpHash[i] = pbDigest[A_SHA_DIGEST_LEN - (i + 1)];
    }

    // 
    // see if it matches.
    //
    if (memcmp(rgbTmpHash, pbPKCS1Format, A_SHA_DIGEST_LEN)) {
        return FALSE;
    }

    cb = A_SHA_DIGEST_LEN;

    //
    // check for any signature type identifiers
    //
    for (i = 0; 0 != *rgEncOptions[i]; i += 1) {
        pbStart = (LPBYTE)rgEncOptions[i];
        cbTmp = *pbStart++;
        if (0 == memcmp(&pbPKCS1Format[cb], pbStart, cbTmp)) {
            // adjust the end of the hash data. 
            cb += cbTmp;   
            break;
        }
    }

    // 
    // check to make sure the rest of the PKCS #1 padding is correct
    //
    if ((0x00 != pbPKCS1Format[cb]) || (0x00 != pbPKCS1Format[pKey->datalen]) ||
         (0x1 != pbPKCS1Format[pKey->datalen - 1])) {
        return FALSE;
    }

    for (i = cb + 1; i < (DWORD)pKey->datalen - 1; i++) {
        if (0xff != pbPKCS1Format[i]) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOLEAN
XcVerifyDigest(
    IN   PBYTE   pbSig,
    IN   PBYTE   pbPublicKey,
    IN   PBYTE   pbWorkspace,
    IN   PBYTE   pbCompareDigest
    )
{
    LPBSAFE_PUB_KEY pPubKey = (LPBSAFE_PUB_KEY)pbPublicKey;
    PBYTE           pbOutput;
    PBYTE           pbInput;
    DWORD           dwSigLen;

    dwSigLen = (pPubKey->bitlen + 7) / 8;

    pbOutput = pbWorkspace;
    pbInput = (PBYTE)((ULONG_PTR)pbWorkspace + pPubKey->keylen);

    memset(pbInput, 0, pPubKey->keylen);
    memcpy(pbInput, pbSig, dwSigLen);

    if (!BSafeEncPublic(pPubKey, pbInput, pbOutput)) {
        return FALSE;
    }


    if (!XcVerifyPKCS1SigningFmt(pPubKey, pbCompareDigest, pbOutput)) {
        return FALSE;
    }

    return TRUE;
}

ULONG
XcPKGetKeyLen(
    IN PUCHAR pbPubKey
    )
{
    return XcCalcKeyLen(pbPubKey);
}

BOOLEAN
XcVerifyPKCS1Signature(
    IN PUCHAR pbSig,
    IN PUCHAR pbPubKey,
    IN PUCHAR pbDigest
    )
{
    BYTE* pbWorkspace = (BYTE *)_alloca( 2 * XcCalcKeyLen(pbPubKey) );
    if ( pbWorkspace == NULL )
    {
        return FALSE;
    }
    return XcVerifyDigest(pbSig, pbPubKey, pbWorkspace, pbDigest);
}
   
VOID WINAPI XShaHmacInitialize(
            IN PBYTE                pbKey,
            IN DWORD                cbKey,
            IN OUT XSHAHMAC_CONTEXT Shactx
            )
{
    HRESULT        hr = S_OK;
    BYTE        rgbKipad[HMAC_K_PADSIZE];
    ULONG        dwBlock;

    // Shorten length if longer than our K padding
    if (cbKey > HMAC_K_PADSIZE)
        cbKey = HMAC_K_PADSIZE;

    // Build our Kipad
    memset(rgbKipad, 0, HMAC_K_PADSIZE);
    memcpy(rgbKipad, pbKey, cbKey);
    for (dwBlock = 0; 
         dwBlock < (HMAC_K_PADSIZE/sizeof(DWORD)); 
         dwBlock++)
    {
        ((DWORD*)rgbKipad)[dwBlock] ^= HMAC_KI_XOR_FACTOR;
    }

    // Initialize our SHA1 Hmac context
    XcSHAInit(Shactx);

    // Run our Kipad through this ...
    XcSHAUpdate(Shactx, rgbKipad, HMAC_K_PADSIZE);
}

//
// Function to update the Hmac
//
VOID WINAPI XShaHmacUpdate(
            IN XSHAHMAC_CONTEXT Shactx,
            IN PBYTE            pbData,
            IN DWORD            cbData
            )
{
    XcSHAUpdate(Shactx, pbData, cbData);
}
            
//
// Function to calculate the final Hmac
//
VOID WINAPI XShaHmacComputeFinal(
            IN XSHAHMAC_CONTEXT Shactx,
            IN PBYTE            pbKey,
            IN DWORD            cbKey,
            OUT PBYTE           pbHmac
            )
{
    HRESULT        hr = S_OK;
    BYTE        rgbKopad[HMAC_K_PADSIZE + A_SHA_DIGEST_LEN];
    ULONG        dwBlock;

    // Shorten length if longer than our K padding
    if (cbKey > HMAC_K_PADSIZE)
        cbKey = HMAC_K_PADSIZE;

    // Build our Kipad
    memset(rgbKopad, 0, HMAC_K_PADSIZE);
    memcpy(rgbKopad, pbKey, cbKey);
    for (dwBlock = 0; 
         dwBlock < (HMAC_K_PADSIZE/sizeof(DWORD)); 
         dwBlock++)
    {
        ((DWORD*)rgbKopad)[dwBlock] ^= HMAC_KO_XOR_FACTOR;
    }

    // Finish off the hash, and place the result right
    // after the Kopad data
    XcSHAFinal(Shactx, rgbKopad + HMAC_K_PADSIZE);

    // Do another hash, now with the Kopad data
    XcSHAInit(Shactx);
    XcSHAUpdate(Shactx, rgbKopad, sizeof(rgbKopad));
    XcSHAFinal(Shactx, pbHmac);
}            

// ---------------------------------------------------------------------------------------
// VMem
//
// VMem allocates memory using the operating system's low-level virtual allocator. It
// arranges for an allocation to start at the very beginning of a page, with a non-
// accessable page just before it, or for it to end at the very end of a page, with a
// non-accessible page just after it.  The idea is to catch memory overwrites quickly.
//
// The layout of an allocation is as follows:
//
//  +--- page VMEMINFO structure
//  |
//  |                 +--- pv if using front-side-strict memory allocations
//  |                 |
//  |                 |                   +--- filled with pattern to detect back-side overwrite
//  v                 v                   v
// +--------+--------+--------+--------+--------+--------+
// |VMEMINFO|   NO   |[User's memory area]XXXXXX|   NO   |
// |        | ACCESS |XXXXXX[User's memory area]| ACCESS |
// +--------+--------+--------+--------+--------+--------+
//                    ^     ^
//                    |     +--- pv if using back-side-strict memory allocations
//                    |
//                    +--- filled with pattern to detect front-side overwrite
//
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_VMEM

#define PAGE_SIZE       4096

DWORD
VMemQueryProtect(void * pv, DWORD cb)
{
    MEMORY_BASIC_INFORMATION mbi = { 0 };
    VirtualQuery(pv, &mbi, sizeof(mbi));
    return (mbi.Protect ? mbi.Protect : mbi.AllocationProtect);
}

VMEMINFO *
VMemIsValid(void * pv)
{
    VMEMINFO * pvmi;
    BYTE * pb;
    UINT cb;

    if (pv == NULL)
    {
        return NULL;
    }

    pvmi = (VMEMINFO *)(((DWORD_PTR)pv & ~(PAGE_SIZE - 1)) - PAGE_SIZE * 2);

    if (VMemQueryProtect(pvmi, PAGE_SIZE) != PAGE_READONLY)
    {
        Rip("VMemIsValid - VMEMINFO page is not marked READONLY");
        return NULL;
    }

    if (pv != pvmi->pv)
    {
        Rip("VMemIsValid - VMEMINFO doesn't point back to pv");
        return NULL;
    }

    if (VMemQueryProtect((BYTE *)pvmi + PAGE_SIZE, PAGE_SIZE) != PAGE_NOACCESS)
    {
        Rip("VMemIsValid - can't detect first no-access page");
        return NULL;
    }

    if (VMemQueryProtect((BYTE *)pvmi + PAGE_SIZE * 2, pvmi->cbFill1 + pvmi->cb + pvmi->cbFill2) != PAGE_READWRITE)
    {
        Rip("VMemIsValid - user memory block is not all writable");
        return NULL;
    }

    if (pvmi->cbFill1)
    {
        pb = (BYTE *)pvmi + PAGE_SIZE * 2;
        cb = pvmi->cbFill1;

        for (; cb > 0; --cb, ++pb)
        {
            if (*pb != 0x1A)
            {
                Rip("VMemIsValid - detected user memory pre-data overwrite");
                return NULL;
            }
        }
    }

    if (pvmi->cbFill2)
    {
        pb = (BYTE *)pvmi + PAGE_SIZE * 2 + pvmi->cbFill1 + pvmi->cb;
        cb = pvmi->cbFill2;

        for (; cb > 0; --cb, ++pb)
        {
            if (*pb != 0x3A)
            {
                Rip("VMemIsValid - detected user memory post-data overwrite");
                return NULL;
            }
        }
    }

    if (VMemQueryProtect((BYTE *)pvmi + PAGE_SIZE * 2 + pvmi->cbFill1 + pvmi->cb + pvmi->cbFill2, PAGE_SIZE) != PAGE_NOACCESS)
    {
        Rip("VMemIsValid - can't detect second no-access page");
        return NULL;
    }

    return(pvmi);
}

void *
VMemAlloc(size_t cb)
{
    DWORD dwFlags = g_dwVMem;
    void * pv1, * pv2, * pv3;
    size_t cbUser, cbPage;
    DWORD dwOldProtect;
    VMEMINFO * pvmi;

    if (cb == 0)
    {
        cb = 1;
    }

    if (    (dwFlags & VMEM_BACKSIDESTRICT)
        &&  (dwFlags & VMEM_BACKSIDEALIGN8))
        cbUser = (cb + 7) & ~7;
    else
        cbUser = cb;

    cbPage = (cbUser + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);

	pv1 = VirtualAlloc(0, cbPage + PAGE_SIZE * 3, MEM_RESERVE, PAGE_NOACCESS);

    if (pv1 == NULL)
    {
        return(NULL);
    }

	pv2 = VirtualAlloc(pv1, PAGE_SIZE, MEM_COMMIT, PAGE_READWRITE);

    if (pv2 == NULL)
    {
        return(NULL);
    }

    pvmi          = (VMEMINFO *)pv2;
    pvmi->cb      = cb;
    pvmi->dwFlags = dwFlags;

    pv3 = VirtualAlloc((BYTE *)pv1 + PAGE_SIZE * 2, cbPage, MEM_COMMIT, PAGE_READWRITE);

    if (pv3 == NULL)
    {
        return(NULL);
    }

    if (dwFlags & VMEM_BACKSIDESTRICT)
    {
        pvmi->cbFill1 = cbPage - cbUser;
        pvmi->cbFill2 = cbUser - cb;
    }
    else
    {
        pvmi->cbFill1 = 0;
        pvmi->cbFill2 = cbPage - cbUser;
    }

    Assert(pvmi->cbFill1 + cb + pvmi->cbFill2 == cbPage);

    if (pvmi->cbFill1)
    {
        memset((BYTE *)pv3, 0x1A, pvmi->cbFill1);
    }

    memset((BYTE *)pv3 + pvmi->cbFill1, 0x2A, cb);

    if (pvmi->cbFill2)
    {
        memset((BYTE *)pv3 + pvmi->cbFill1 + cb, 0x3A, pvmi->cbFill2);
    }

    pvmi->pv = (BYTE *)pv3 + pvmi->cbFill1;

    VirtualProtect(pv1, PAGE_SIZE, PAGE_READONLY, &dwOldProtect);

    Assert(VMemIsValid(pvmi->pv));

    return(pvmi->pv);
}

void
VMemFree(void * pv)
{
    VMEMINFO * pvmi = VMemIsValid(pv);

    if (pvmi)
    {
        if (!VirtualFree(pvmi, 0, MEM_RELEASE))
        {
            Rip("VmemFree - VirtualFree failed");
        }
    }
}

#endif // XNET_FEATURE_VMEM

// ---------------------------------------------------------------------------------------
// Assert support
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ASSERT

struct MBOT { char * psz; int id; };

DWORD WINAPI DbgAssertPopOnThreadFn(MBOT * pmbot)
{
    pmbot->id = MessageBoxExA(NULL, pmbot->psz, "Assert",
                              MB_SYSTEMMODAL|MB_SETFOREGROUND|MB_OKCANCEL|MB_ICONWARNING|MB_DEFBUTTON2,
                              0);
    return(0);
}

int DbgAssertPop(const char * pszExpr, const char * pszFile, int iLine, const char * pszMsg)
{
    char ach[256];

    if (pszMsg)
        _snprintf(ach, sizeof(ach), "%s\n%s\n%s (%d)", pszExpr, pszMsg, pszFile, iLine);
    else
        _snprintf(ach, sizeof(ach), "%s\n%s (%d)", pszExpr, pszFile, iLine);

    MBOT  mbot = { ach, 0 };
    DWORD dwThread;
    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)DbgAssertPopOnThreadFn,
                                  &mbot, 0, &dwThread);
    if (!hThread)
        DbgAssertPopOnThreadFn(&mbot);
    else
    {
        WaitForSingleObject(hThread, INFINITE);
        CloseHandle(hThread);
    }

    return(mbot.id == IDCANCEL);
}

#endif

// ---------------------------------------------------------------------------------------
// Trace support
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_TRACE

CTagInit::CTagInit(int * pi, const char * pszTag)
{
    int i = GetPrivateProfileIntA("tags", pszTag, -1, "\\xnettags.ini");

    if (i != -1)
    {
        *pi = i;
    }
}

#endif

// ---------------------------------------------------------------------------------------
// XBox File System Abstraction Layer
// ---------------------------------------------------------------------------------------

BOOL HalCreateDirectory(const char * pszDir, BOOL fHidden, BOOL * pfAlreadyExists)
{
    WIN32_FIND_DATA fd;
    HANDLE          hFind = FindFirstFile(pszDir, &fd);

    *pfAlreadyExists = FALSE;

    if (hFind == INVALID_HANDLE_VALUE)
    {
        if (GetLastError() != ERROR_FILE_NOT_FOUND)
        {
            TraceSz2(Warning, "HalCreateDirectory: FindFirstFile '%s' failed (%08lX)", pszDir, GetLastError());
            return(FALSE);
        }

        if (!CreateDirectory(pszDir, NULL))
        {
            TraceSz2(Warning, "HalCreateDirectory: CreateDirectory '%s' failed (%08lX)", pszDir, GetLastError());
            return(FALSE);
        }

        if (fHidden && !SetFileAttributes(pszDir, FILE_ATTRIBUTE_HIDDEN))
        {
            TraceSz2(Warning, "HalCreateDirectory: SetFileAttributes '%s' failed (%08lX)", pszDir, GetLastError());
            return(FALSE);
        }
    }
    else
    {
        if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            TraceSz1(Warning, "HalCreateDirectory: Cannot create directory '%s' because file exists there", pszDir);
            return(FALSE);
        }

        FindClose(hFind);

        *pfAlreadyExists = TRUE;
    }

    return(TRUE);
}

BOOL HalGetPath(const char * pszXbox, const char * pszPathIn, char * pszPathOut)
{
    char achXbox[MAX_PATH];
    char achRoot[MAX_PATH];
    char achTemp[MAX_PATH];
    char * pch;
    BOOL fAlreadyExists;

    strncpy(achXbox, pszXbox, sizeof(achXbox));
    for (pch = achXbox; *pch && *pch != '@'; ++pch) ;
    *pch = 0;

    // Make sure directory c:\$xbox exists

    strcpy(achRoot, "c:\\$xbox");
    HalCreateDirectory(achRoot, TRUE, &fAlreadyExists);

    // Make sure directory c:\$xbox\<pszXbox> exists

    strcat(achRoot, "\\");
    strcat(achRoot, achXbox);
    HalCreateDirectory(achRoot, FALSE, &fAlreadyExists);

    if (!fAlreadyExists)
    {
        char achDir[MAX_PATH];

        strcpy(achDir, achRoot);
        strcat(achDir, "\\partition1");
        HalCreateDirectory(achDir, FALSE, &fAlreadyExists);

        strcpy(achDir, achRoot);
        strcat(achDir, "\\partition1\\TDATA");
        HalCreateDirectory(achDir, FALSE, &fAlreadyExists);

        strcpy(achDir, achRoot);
        strcat(achDir, "\\partition1\\CACHE");
        HalCreateDirectory(achDir, FALSE, &fAlreadyExists);

        strcpy(achDir, achRoot);
        strcat(achDir, "\\partition1\\devkit");
        HalCreateDirectory(achDir, FALSE, &fAlreadyExists);

        strcpy(achDir, achRoot);
        strcat(achDir, "\\partition2");
        HalCreateDirectory(achDir, FALSE, &fAlreadyExists);
    }

    // Handle special "eeprom" path

    if (lstrcmpiA(pszPathIn, "eeprom") == 0)
    {
        sprintf(pszPathOut, "%s\\eeprom.bin", achRoot);
        return(TRUE);
    }

    // Handle special "volume" path

    if (lstrcmpiA(pszPathIn, "\\Device\\Harddisk0\\partition0") == 0)
    {
        sprintf(pszPathOut, "%s\\config.bin", achRoot);

        // Make sure this file exists and has room for all the config sectors

        HANDLE hFile = CreateFile(pszPathOut, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            TraceSz2(Warning, "HalGetPath: CreateFile '%s' failed (%08lX)", pszPathOut, GetLastError());
            return(FALSE);
        }

        DWORD dwSize   = GetFileSize(hFile, NULL);
        DWORD dwExpect = (XBOX_CONFIG_SECTOR_INDEX + XBOX_NUM_CONFIG_SECTORS) * XBOX_HD_SECTOR_SIZE;

        if (dwSize != dwExpect)
        {
            if (dwSize != 0)
            {
                TraceSz3(Warning, "HalGetPath: '%s' has incorrect size (%d bytes); should be %d bytes.  Repairing.",
                         pszPathOut, dwSize, dwExpect);
            }

            BYTE ab[(XBOX_CONFIG_SECTOR_INDEX + XBOX_NUM_CONFIG_SECTORS) * XBOX_HD_SECTOR_SIZE];
            memset(ab, 0, sizeof(ab));

            if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF)
            {
                TraceSz2(Warning, "HalGetPath: SetFilePointer '%s' failed (%08lX)", pszPathOut, GetLastError());
                CloseHandle(hFile);
                return(FALSE);
            }

            if (!WriteFile(hFile, ab, sizeof(ab), &dwExpect, NULL))
            {
                TraceSz2(Warning, "HalGetPath: WriteFile '%s' failed (%08lX)", pszPathOut, GetLastError());
                CloseHandle(hFile);
                return(FALSE);
            }

            Assert(dwExpect == sizeof(ab));
        }

        CloseHandle(hFile);
        return(TRUE);
    }

    // Handle Harddisk0 paths

    if (_strnicmp(pszPathIn, "\\Device\\Harddisk0\\", 18) == 0)
    {
        sprintf(pszPathOut, "%s\\%s", achRoot, pszPathIn + 18);
        return(TRUE);
    }

    TraceSz1(Warning, "HalGetPath: Don't understand path '%s'", pszPathIn);
    return(FALSE);
}

HANDLE HalCreateFile(char * pszXbox, LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
    NTSTATUS    status = STATUS_UNSUCCESSFUL;
    char        achPath[MAX_PATH];

    if (!HalGetPath(pszXbox, lpFileName, achPath))
    {
        TraceSz2(Warning, "HalCreateFile: HalGetPath('%s','%s') failed", pszXbox, lpFileName);
        return(INVALID_HANDLE_VALUE);
    }
    
    return(CreateFile(achPath, dwDesiredAccess, dwShareMode, lpSecurityAttributes,
                      dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile));
}

NTSTATUS HalNtOpenFile(char * pszXbox, PHANDLE FileHandle, ACCESS_MASK DesiredAccess,
                       POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock,
                       ULONG ShareAccess, ULONG OpenOptions)
{
    NTSTATUS    status = STATUS_UNSUCCESSFUL;
    char        achPath[MAX_PATH];

    if (!HalGetPath(pszXbox, (char *)ObjectAttributes->ObjectName->Buffer, achPath))
    {
        TraceSz2(Warning, "HalNtOpenFile: HalGetPath('%s','%s') failed",
                 pszXbox, (char *)ObjectAttributes->ObjectName->Buffer);
        *FileHandle = INVALID_HANDLE_VALUE;
    }
    else
    {
        *FileHandle = CreateFile(achPath, DesiredAccess & (GENERIC_READ|GENERIC_WRITE),
                                 ShareAccess & (FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE),
                                 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }

    if (*FileHandle != INVALID_HANDLE_VALUE)
    {
        status = STATUS_SUCCESS;
    }

    return(status);
}

NTSTATUS HalNtCreateFile(char * pszXbox, PHANDLE FileHandle, ACCESS_MASK DesiredAccess,
                         POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock,
                         PLARGE_INTEGER AllocationSize, ULONG FileAttributes,
                         ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions)
{
    NTSTATUS    status = STATUS_UNSUCCESSFUL;
    char        achPath[MAX_PATH];

    if (!HalGetPath(pszXbox, (char *)ObjectAttributes->ObjectName->Buffer, achPath))
    {
        TraceSz2(Warning, "HalNtCreateFile: HalGetPath('%s','%s') failed",
                 pszXbox, (char *)ObjectAttributes->ObjectName->Buffer);
        *FileHandle = INVALID_HANDLE_VALUE;
    }
    else
    {
        DWORD dwDisposition = CREATE_ALWAYS;

        switch (CreateDisposition)
        {
            case FILE_SUPERSEDE:    dwDisposition = TRUNCATE_EXISTING;  break;
            case FILE_OPEN:         dwDisposition = OPEN_ALWAYS;        break;
            case FILE_CREATE:       dwDisposition = CREATE_NEW;         break;
            case FILE_OPEN_IF:      dwDisposition = CREATE_ALWAYS;      break;
            case FILE_OVERWRITE:    dwDisposition = CREATE_ALWAYS;      break;
            case FILE_OVERWRITE_IF: dwDisposition = TRUNCATE_EXISTING;  break;
        }

        *FileHandle = CreateFile(achPath, DesiredAccess & (GENERIC_READ|GENERIC_WRITE),
                                 ShareAccess & (FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE),
                                 NULL, dwDisposition, FILE_ATTRIBUTE_NORMAL, NULL);
    }

    if (*FileHandle != INVALID_HANDLE_VALUE)
    {
        status = STATUS_SUCCESS;
    }

    return(status);
}

NTSTATUS HalNtReadFile(char * pszXbox, HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine,
                       PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length,
                       PLARGE_INTEGER ByteOffset)
{
    if (SetFilePointer(FileHandle, ByteOffset->LowPart, &ByteOffset->HighPart, FILE_BEGIN) == 0xFFFFFFFF)
    {
        TraceSz1(Warning, "HalNtReadFile: SetFilePointer failed (%08lX)", GetLastError());
        return(STATUS_UNSUCCESSFUL);
    }

    DWORD dwRead;

    if (!ReadFile(FileHandle, Buffer, Length, &dwRead, NULL))
    {
        TraceSz1(Warning, "HalNtReadFile: ReadFile failed (%08lX)", GetLastError());
        return(STATUS_UNSUCCESSFUL);
    }

    if (dwRead != Length)
    {
        TraceSz2(Warning, "HalNtReadFile: ReadFile returned only %d bytes (%d requested)", dwRead, Length);
        return(STATUS_UNSUCCESSFUL);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS HalNtWriteFile(char * pszXbox, HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine,
                        PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer,
                        ULONG Length, PLARGE_INTEGER ByteOffset)
{
    if (SetFilePointer(FileHandle, ByteOffset->LowPart, &ByteOffset->HighPart, FILE_BEGIN) == 0xFFFFFFFF)
    {
        TraceSz1(Warning, "HalNtWriteFile: SetFilePointer failed (%08lX)", GetLastError());
        return(STATUS_UNSUCCESSFUL);
    }

    DWORD dwWrite;

    if (!WriteFile(FileHandle, Buffer, Length, &dwWrite, NULL))
    {
        TraceSz1(Warning, "HalNtWriteFile: WriteFile failed (%08lX)", GetLastError());
        return(STATUS_UNSUCCESSFUL);
    }

    if (dwWrite != Length)
    {
        TraceSz2(Warning, "HalNtWriteFile: WriteFile wrote only %d bytes (%d requested)", dwWrite, Length);
        return(STATUS_UNSUCCESSFUL);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS HalNtClose(char * pszXbox, HANDLE Handle)
{
    if (Handle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(Handle);
    }

    return(STATUS_SUCCESS);
}

// ---------------------------------------------------------------------------------------
// EEPROM
// ---------------------------------------------------------------------------------------

BOOL HalSaveEEPROM(char * pszXbox, EEPROM_LAYOUT * peeprom)
{
    HANDLE  hFile   = INVALID_HANDLE_VALUE;
    BOOL    fResult = FALSE;
    DWORD   dwSize;
    char    achPath[MAX_PATH];

    if (!HalGetPath(pszXbox, "eeprom", achPath))
    {
        TraceSz1(Warning, "HalSaveEEPROM: HalGetPath('%s','eeprom') failed", pszXbox);
        goto ret;
    }

    hFile = CreateFile(achPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,  NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        TraceSz2(Warning, "HalSaveEEPROM: CreateFile '%s' failed (%08lX)", achPath, GetLastError());
        goto ret;
    }

    if (!WriteFile(hFile, peeprom, sizeof(EEPROM_LAYOUT), &dwSize, NULL))
    {
        TraceSz2(Warning, "HalSaveEEPROM: WriteFile '%s' failed (%08lX)", achPath, GetLastError());
        goto ret;
    }

    fResult = TRUE;

ret:

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    return(fResult);
}

BOOL HalLoadEEPROM(char * pszXbox, EEPROM_LAYOUT * peeprom)
{
    HANDLE  hFile   = INVALID_HANDLE_VALUE;
    BOOL    fResult = FALSE;
    DWORD   dwSize;
    char    achPath[MAX_PATH];

    if (!HalGetPath(pszXbox, "eeprom", achPath))
    {
        TraceSz1(Warning, "HalLoadEEPROM: HalGetPath('%s','eeprom') failed", pszXbox);
        goto ret;
    }

    hFile = CreateFile(achPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL,  NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        TraceSz2(Warning, "HalLoadEEPROM: CreateFile '%s' failed (%08lX)", achPath, GetLastError());
        goto ret;
    }

    if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        TraceSz2(Warning, "HalLoadEEPROM: SetFilePointer '%s' failed (%08lX)", achPath, GetLastError());
        goto ret;
    }

    dwSize = GetFileSize(hFile, NULL);

    if (dwSize == sizeof(EEPROM_LAYOUT))
    {
        if (!ReadFile(hFile, peeprom, sizeof(EEPROM_LAYOUT), &dwSize, NULL))
        {
            TraceSz2(Warning, "HalLoadEEPROM: ReadFile '%s' failed (%08lX)", achPath, GetLastError());
            goto ret;
        }
    }
    else
    {
        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;

        if (dwSize != 0)
        {
            TraceSz3(Warning, "HalLoadEEPROM: '%s' is incorrect size (%d bytes); should be %d bytes.  Repairing.",
                     achPath, dwSize, sizeof(EEPROM_LAYOUT));
        }

        memset(peeprom, 0, sizeof(EEPROM_LAYOUT));

        XBOX_ENCRYPTED_SETTINGS *   pes = (XBOX_ENCRYPTED_SETTINGS *)&peeprom->EncryptedSection;
        XBOX_FACTORY_SETTINGS *     pfs = (XBOX_FACTORY_SETTINGS *)&peeprom->FactorySection;

        memset(pfs->SerialNumber, '9', sizeof(pfs->SerialNumber));

        Assert(sizeof(pfs->OnlineKey) == DEVKIT_ONLINE_RAND_KEY_LEN);
        memcpy(pfs->OnlineKey, DEVKIT_ONLINE_RAND_KEY, sizeof(pfs->OnlineKey));

        BYTE abHdKey[16] = { 0 };

        MorphKeyByHardDriveKeyEx(abHdKey, pfs->OnlineKey, sizeof(pfs->OnlineKey));

        HalSaveEEPROM(pszXbox, peeprom);
    }

    fResult = TRUE;

ret:

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    return(fResult);
}

NTSTATUS HalExQueryNonVolatileSetting(char * pszXbox, ULONG ValueIndex, ULONG * Type, VOID * Value, ULONG ValueLength, ULONG * ResultLength)
{
    EEPROM_LAYOUT   eeprom;
    NTSTATUS        status = STATUS_UNSUCCESSFUL;

    *Type = 0;
    *ResultLength = 0;

    if (HalLoadEEPROM(pszXbox, &eeprom))
    {
        XBOX_FACTORY_SETTINGS * pfs = (XBOX_FACTORY_SETTINGS *)&eeprom.FactorySection;

        switch (ValueIndex)
        {
            case XC_FACTORY_ETHERNET_ADDR:
            {
                if (ValueLength == sizeof(pfs->EthernetAddr))
                {
                    memcpy(Value, pfs->EthernetAddr, ValueLength);
                    *Type = REG_BINARY;
                    *ResultLength = ValueLength;
                    status = STATUS_SUCCESS;
                }
                break;
            }

            case XC_FACTORY_SERIAL_NUMBER:
            {
                if (ValueLength == sizeof(pfs->SerialNumber))
                {
                    memcpy(Value, pfs->SerialNumber, ValueLength);
                    *Type = REG_BINARY;
                    *ResultLength = ValueLength;
                    status = STATUS_SUCCESS;
                }
                break;
            }

            case XC_FACTORY_ONLINE_KEY:
            {
                if (ValueLength == sizeof(pfs->OnlineKey))
                {
                    memcpy(Value, pfs->OnlineKey, ValueLength);
                    *Type = REG_BINARY;
                    *ResultLength = ValueLength;
                    status = STATUS_SUCCESS;
                }
                break;
            }
        }

        AssertSz1(status == STATUS_SUCCESS, "HalExQueryNonVolatileSetting: Unrecognized ValueIndex (%d)", ValueIndex);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS HalExSaveNonVolatileSetting(char * pszXbox, ULONG ValueIndex, ULONG Type, const VOID * Value, ULONG ValueLength)
{
    EEPROM_LAYOUT   eeprom;
    NTSTATUS        status = STATUS_UNSUCCESSFUL;

    if (HalLoadEEPROM(pszXbox, &eeprom))
    {
        XBOX_FACTORY_SETTINGS * pfs = (XBOX_FACTORY_SETTINGS *)&eeprom.FactorySection;

        switch (ValueIndex)
        {
            case XC_FACTORY_ETHERNET_ADDR:
            {
                if (Type == REG_BINARY && ValueLength == sizeof(pfs->EthernetAddr))
                {
                    memcpy(pfs->EthernetAddr, Value, ValueLength);
                    status = STATUS_SUCCESS;
                }
                break;
            }

            case XC_FACTORY_SERIAL_NUMBER:
            {
                if (Type == REG_BINARY && ValueLength == sizeof(pfs->SerialNumber))
                {
                    memcpy(pfs->SerialNumber, Value, ValueLength);
                    status = STATUS_SUCCESS;
                }
                break;
            }

            case XC_FACTORY_ONLINE_KEY:
            {
                if (Type == REG_BINARY && ValueLength == sizeof(pfs->OnlineKey))
                {
                    memcpy(pfs->OnlineKey, Value, ValueLength);
                    status = STATUS_SUCCESS;
                }
                break;
            }
        }

        AssertSz2(status == STATUS_SUCCESS, "HalExSaveNonVolatileSetting: Unrecognized ValueIndex (%d) Type (%d)", ValueIndex, Type);
    }

    if (status == STATUS_SUCCESS && !HalSaveEEPROM(pszXbox, &eeprom))
    {
        status = STATUS_UNSUCCESSFUL;
    }

    return(status);
}

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\enet.cpp ===
// ---------------------------------------------------------------------------------------
// enet.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(Arp,          0);
DefineTag(ArpWarn,      TAG_ENABLE);

// ---------------------------------------------------------------------------------------
// CXnEnet - External Functions
// ---------------------------------------------------------------------------------------

NTSTATUS CXnEnet::EnetInit(XNetInitParams * pxnip)
{
    TCHECK(USER);

    NTSTATUS status = NicInit(pxnip);
    if (!NT_SUCCESS(status))
        return(status);

    SetInitFlag(INITF_ENET);

    KeInitializeDpc(&_dpcEnet, &EnetDpc, this);

#ifdef XNET_FEATURE_ARP
    _paeLast = _aae;
    _timerArp.Init((PFNTIMER)ArpTimer);
#endif

    return(NETERR_OK);
}

void CXnEnet::EnetTerm()
{
    TCHECK(UDPC);

    EnetStop();

    if (TestInitFlag(INITF_ENET))
    {
        KeRemoveQueueDpc(&_dpcEnet);

        if (!_pqXmit.IsEmpty())
        {
            TraceSz1(Warning, "Enet shutdown with %d packet(s) queued for transmit", _pqXmit.Count());
            _pqXmit.Discard(this);
        }

#ifdef XNET_FEATURE_ARP

        CArpEntry * pae = _aae;
        UINT        cae = dimensionof(_aae);

        for (; cae > 0; --cae, ++pae)
        {
            if (!pae->_pqWait.IsEmpty())
            {
                TraceSz2(Warning, "Enet shutdown with %d packet(s) queued for ARP %s",
                         pae->_pqWait.Count(), pae->_ipa.Str());
                pae->_pqWait.Discard(this);
            }
        }

        TimerSet(&_timerArp, TIMER_INFINITE);

#endif
    }

    SetInitFlag(INITF_ENET_TERM);

    NicTerm();
}

void CXnEnet::EnetXmit(CPacket * ppkt, CIpAddr ipaNext)
{
    ICHECK(ENET, UDPC|SDPC);

    if (!ppkt->TestFlags(PKTF_XMIT_FRAME))
    {
        Assert(ppkt->IsIp());
        *((CIpAddr *)ppkt->GetPv() - 1) = ipaNext;
    }

    if (ppkt->TestFlags(PKTF_XMIT_PRIORITY))
        _pqXmit.InsertHead(ppkt);
    else
        _pqXmit.InsertTail(ppkt);

    ppkt->ClearFlags(PKTF_XMIT_PRIORITY);

    EnetQueuePush();
}

#ifdef XNET_FEATURE_ARP

void CXnEnet::EnetXmitArp(CIpAddr ipa)
{
    ICHECK(ENET, UDPC|SDPC);

    _ipaCheck = ipa;

    if (_ipaCheck)
    {
        ArpXmit(ARP_OP_REQUEST, _ipaCheck, _ipaCheck, NULL);
    }
}

#endif

void CXnEnet::EnetStop()
{
    TCHECK(UDPC);

    if (TestInitFlag(INITF_ENET) && !TestInitFlag(INITF_ENET_STOP))
    {
        SetInitFlag(INITF_ENET_STOP);
    }

    NicStop();
}

// ---------------------------------------------------------------------------------------
// Virtual callbacks
// ---------------------------------------------------------------------------------------

void CXnEnet::EnetRecv(CPacket * ppkt, UINT uiType)
{
    ICHECK(ENET, UDPC|SDPC);

    Assert(ppkt->IsEnet());

    if (uiType == ENET_TYPE_IP)
    {
        ppkt->SetType(PKTF_TYPE_IP);
        IpRecv(ppkt);
    }
#ifdef XNET_FEATURE_ARP
    else if (uiType == ENET_TYPE_ARP)
    {
        ArpRecv(ppkt);
    }
#endif
    else
    {
        TraceSz1(pktRecv, "[DISCARD] No support for Ethernet type %04X", NTOHS((WORD)uiType));
    }
}

// ---------------------------------------------------------------------------------------
// CXnEnet - Internal Functions
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ARP

void CXnEnet::ArpXmit(WORD wOp, CIpAddr ipaTarget, CIpAddr ipaSender, CEnetAddr * peaTarget)
{
    ICHECK(ENET, UDPC|SDPC);

    CPacket *   ppkt;
    CEnetHdr *  pEnetHdr;
    CArpMsg *   pArpMsg;
    
    ppkt = PacketAlloc(PTAG_CArpPacket,
                       PKTF_POOLALLOC|PKTF_TYPE_ENET|PKTF_XMIT_FRAME|PKTF_XMIT_PRIORITY,
                       sizeof(CArpMsg));
    if (ppkt == NULL)
    {
        TraceSz(Warning, "Out of memory allocating ARP packet");
        return;
    }

    pEnetHdr = ppkt->GetEnetHdr();
    pArpMsg = (CArpMsg *)ppkt->GetPv();

    if (peaTarget)
    {
        pEnetHdr->_eaDst = *peaTarget;
        pArpMsg->_eaTarget = *peaTarget;
    }
    else
    {
        pEnetHdr->_eaDst.SetBroadcast();
        pArpMsg->_eaTarget.SetZero();
    }

    pEnetHdr->_eaSrc    = _ea;
    pEnetHdr->_wType    = ENET_TYPE_ARP;
    pArpMsg->_wHrd      = ARP_HWTYPE_ENET;
    pArpMsg->_wPro      = ENET_TYPE_IP;
    pArpMsg->_bHln      = sizeof(CEnetAddr);
    pArpMsg->_bPln      = sizeof(CIpAddr);
    pArpMsg->_wOp       = wOp;
    pArpMsg->_eaSender  = _ea;
    pArpMsg->_ipaSender = ipaSender;
    pArpMsg->_ipaTarget = ipaTarget;

    TraceSz5(Arp, "%s (%s) is %s %s (%s)",
             ipaSender.Str(), _ea.Str(), peaTarget ? "replying to" : "broadcasting request for",
             ipaTarget.Str(), pArpMsg->_eaTarget.Str());

    EnetXmit(ppkt);
}

CXnEnet::CArpEntry * CXnEnet::ArpLookup(CIpAddr ipa, ArpResolve eResolve)
{
    ICHECK(ENET, UDPC|SDPC);
    Assert(ipa.IsValidUnicast());

    CArpEntry * pae;
    CArpEntry * paeRetryEnd;
    CArpEntry * paeHash;
    UINT        uiHash;

    Assert(ipa != 0);

    if (_paeLast->_ipa == ipa)
    {
        Assert(!_paeLast->IsFree());
        return(_paeLast);
    }

    // Get the hash bucket for the specified address

    uiHash = ARP_HASH(ipa);
    pae    = &_aae[uiHash];

    // Found the target address in the cache via a direct hash hit

    if (pae->_ipa == ipa)
    {
        goto found;
    }

    // No direct hash hit, try linear search

    paeHash     = pae;
    paeRetryEnd = pae + ARP_HASH_RETRY;

    while (++pae < paeRetryEnd)
    {
        if (pae->_ipa == ipa)
            goto found;
    }

    if (eResolve == eNone)
    {
        return(NULL);
    }

    // The target IP address is not in the cache:
    //  send out an ARP request if specified;
    //  and make a new cache entry for the target
    
    // Check to see if the hash bucket is free

    pae = paeHash;

    if (!pae->IsFree())
    {
        while (++pae < paeRetryEnd)
        {
            if (pae->IsFree())
                break;
        }

        // Couldn't find a free entry
        //  fall back and try to find a non-busy entry

        if (pae == paeRetryEnd)
        {
            pae = paeHash;

            while (++pae < paeRetryEnd)
            {
                if (!pae->IsBusy())
                    break;
            }

            if (pae == paeRetryEnd)
            {
                // Too bad: couldn't find either a free or non-busy entry
                //  emit a warning and give up

                return(NULL);
            }

            // This entry is currently used for another address:
            // we'll just bump it off here.

            TraceSz1(Arp, "Bumped entry for %s", pae->_ipa.Str());
        }
    }

    TraceSz1(Arp, "Adding entry for %s", ipa.Str());

    pae->_ipa = ipa;
    Assert(pae->_pqWait.IsEmpty());

    if (eResolve == eSendRequest)
    {
        pae->_wState = ARP_STATE_BUSY + cfgEnetArpReqRetries;
        pae->_dwTick = TimerSetRelative(&_timerArp, cfgEnetArpRexmitTimeoutInSeconds * TICKS_PER_SECOND);
        ArpXmit(ARP_OP_REQUEST, ipa, _ipa, NULL);
    }
    else
    {
        // Remaining initialization of this entry happens in the caller which
        // changes the state to ARP_STATE_IDLE
        pae->_wState = ARP_STATE_BUSY;
    }

found:
    Assert(pae && !pae->IsFree());
    _paeLast = pae;
    return(pae);
}

void CXnEnet::ArpTimer(CTimer * pt)
{
    ICHECK(ENET, UDPC|SDPC);

    CArpEntry * pae;
    UINT        iae;
    DWORD       dwTickNow = TimerTick();
    DWORD       dwTickArp = TIMER_INFINITE;

    for (iae = 0, pae = _aae; iae < ARP_CACHE_SIZE; ++iae, ++pae)
    {
        if (pae->IsFree())
            continue;

        if (dwTickNow >= pae->_dwTick)
        {
            if (pae->_wState > ARP_STATE_BUSY)
            {
                TraceSz1(ArpWarn, "ArpTimer: %s didn't respond to request.  Trying again.", pae->_ipa.Str());
                pae->_dwTick = dwTickNow + cfgEnetArpRexmitTimeoutInSeconds * TICKS_PER_SECOND;
                pae->_wState -= 1;
                ArpXmit(ARP_OP_REQUEST, pae->_ipa, _ipa, NULL);
            }
            else if (pae->_wState == ARP_STATE_BUSY)
            {
                TraceSz3(ArpWarn, "ArpTimer: %s is unreachable.  Discarding %d waiting packet%s.",
                         pae->_ipa.Str(), pae->_pqWait.Count(), pae->_pqWait.Count() == 1 ? "" : "s");
                pae->_pqWait.Complete(this);
                pae->_dwTick = dwTickNow + (cfgEnetArpNegCacheTimeoutInMinutes * 60 * TICKS_PER_SECOND);
                pae->_wState = ARP_STATE_BAD;
            }
            else
            {
                TraceSz1(Arp, "%s has timed out", pae->_ipa.Str());
                pae->_dwTick = TIMER_INFINITE;
                pae->_wState = ARP_STATE_FREE;
                pae->_ipa    = 0;
            }
        }

        if (dwTickArp > pae->_dwTick)
            dwTickArp = pae->_dwTick;
    }

    Assert(pt == &_timerArp);
    TimerSet(pt, dwTickArp);
}

void CXnEnet::ArpRecv(CPacket * ppkt)
{
    ICHECK(ENET, UDPC|SDPC);

    Assert(ppkt->IsEnet());

    CEnetHdr *  pEnetHdr = ppkt->GetEnetHdr();
    CArpMsg *   pArpMsg  = (CArpMsg *)ppkt->GetPv();
    UINT        cbMsg    = ppkt->GetCb();
    WORD        wOp;
    CIpAddr     ipaSender;
    CEnetAddr   eaSender;
    CIpAddr     ipaTarget;
    CArpEntry * pae;
    ArpResolve  eResolve;

    TraceSz5(pktRecv, "[ARP %s %s %s %s %s]",
             pArpMsg->_wOp == ARP_OP_REQUEST ? "Request" :
             pArpMsg->_wOp == ARP_OP_REPLY ? "Reply" : "???",
             pArpMsg->_ipaSender.Str(), pArpMsg->_eaSender.Str(),
             pArpMsg->_ipaTarget.Str(), pArpMsg->_eaTarget.Str());

    if (_ea.IsEqual(pEnetHdr->_eaSrc))
    {
        // We received an ARP packet from someone who has the same Ethernet address
        // as us.  Issue a warning and discard the packet.  There's not a lot we
        // can do at this point.

        TraceSz(pktWarn, "[DISCARD] ARP sender has conflicting Ethernet address!");
        return;
    }

    if (cbMsg < sizeof(CArpMsg))
    {
        TraceSz1(pktRecv, "[DISCARD] ARP packet is too small (%d)", cbMsg);
        return;
    }

    wOp       = pArpMsg->_wOp;
    ipaSender = pArpMsg->_ipaSender;
    eaSender  = pArpMsg->_eaSender;
    ipaTarget = pArpMsg->_ipaTarget;

    if (    pArpMsg->_wHrd != ARP_HWTYPE_ENET && pArpMsg->_wHrd != ARP_HWTYPE_802
        ||  pArpMsg->_wPro != ENET_TYPE_IP
        ||  pArpMsg->_bHln != sizeof(CEnetAddr)
        ||  pArpMsg->_bPln != sizeof(CIpAddr)
        ||  wOp != ARP_OP_REQUEST && wOp != ARP_OP_REPLY
        ||  !ipaSender.IsValidUnicast()
        ||  !ipaTarget.IsValidUnicast()
        ||  eaSender.IsMulticast())
    {
        TraceSz9(pktRecv, "[DISCARD] ARP message is invalid (%d,%d,%d,%d,%d,%d,%d,%d,%d)",
                 pArpMsg->_wHrd != ARP_HWTYPE_ENET && pArpMsg->_wHrd != ARP_HWTYPE_802,
                 pArpMsg->_wPro != ENET_TYPE_IP,
                 pArpMsg->_bHln != sizeof(CEnetAddr),
                 pArpMsg->_bPln != sizeof(CIpAddr),
                 wOp != ARP_OP_REQUEST && wOp != ARP_OP_REPLY,
                 !ipaSender.IsValidUnicast(),
                 !ipaTarget.IsValidUnicast(),
                 eaSender.IsMulticast(),
                 eaSender.IsBroadcast());
        return;
    }

    // Check to see if we have an existing entry for the sender
    // in our ARP cache. If we're the target and there is no
    // existing entry, then we'll create a new entry.
    // This assumes that communication will likely be bidirectional.

    if (ipaSender == _ipaCheck)
    {
        TraceSz(Arp, "Auto-IP collision detected");
        _ipaCheck = 0;
        IpRecvArp(&eaSender);
    }

    // If we don't have an IP address yet, there is nothing more to do

    if (_ipa == 0)
        return;

    if (ipaSender != _ipa)
    {
        eResolve = (ipaTarget == _ipa) ? eCreateEntry : eNone;

        pae = ArpLookup(ipaSender, eResolve);

        if (pae)
        {
            if (pae->_wState != ARP_STATE_IDLE)
            {
                TraceSz2(Arp, "%s resolved to %s", pae->_ipa.Str(), eaSender.Str());
            }

            pae->_wState = ARP_STATE_IDLE;
            pae->_dwTick = TimerSetRelative(&_timerArp, cfgEnetArpPosCacheTimeoutInMinutes * 60 * TICKS_PER_SECOND);
            pae->_eaNext = eaSender;

            if (!pae->_pqWait.IsEmpty())
            {
                TraceSz3(Arp, "Sending %d packet%s waiting for %s", pae->_pqWait.Count(),
                         pae->_pqWait.Count() == 1 ? "" : "s", pae->_ipa.Str());

                _pqXmit.InsertHead(&pae->_pqWait);

                EnetQueuePush();
            }
        }
    }
    
    // If we're the target and the packet is an ARP request,
    // then send out an ARP reply.

    if (ipaTarget == _ipa && wOp == ARP_OP_REQUEST)
    {
        TraceSz(pktRecv, "[REPLY] Replying to ARP request");
        ArpXmit(ARP_OP_REPLY, ipaSender, _ipa, &eaSender);
    }
    else if (wOp == ARP_OP_REQUEST)
    {
        TraceSz(pktRecv, "[DISCARD] ARP request not for me");
        return;
    }
    else
    {
        TraceSz(pktRecv, "[ARPDONE] ARP reply processed");
        return;
    }
}

#endif

// ---------------------------------------------------------------------------------------
// EnetPush
// ---------------------------------------------------------------------------------------

void CXnEnet::EnetPush()
{
    ICHECK(ENET, UDPC|SDPC);

    CPacket *   ppkt;
    CIpAddr     ipaNext;

#ifdef XNET_FEATURE_ARP
    CArpEntry * pae;
#endif

    while (!_pqXmit.IsEmpty() && NicXmitReady())
    {
        ppkt = _pqXmit.RemoveHead();

        if (TestInitFlag(INITF_ENET_STOP))
        {
            TraceSz(pktWarn, "[DISCARD] Network is down");
            goto complete;
        }

        if (ppkt->TestFlags(PKTF_XMIT_FRAME))
        {
            ppkt->ClearFlags(PKTF_XMIT_FRAME);
            NicXmit(ppkt);
            continue;
        }

        Assert(ppkt->IsIp());

        ipaNext = *((CIpAddr *)ppkt->GetPv() - 1);

        if (ipaNext == 0)
        {
            // ipaNext set to zero from the caller means that this packet should be discarded
            // silently.  The purpose is to prevent calling back to the sender in the middle
            // of transmitting the packet to break potential recursion.
            goto complete;
        }

        if (ipaNext.IsBroadcast())
        {
            CEnetAddr eaNext;
            eaNext.SetBroadcast();
            EnetFillAndXmit(ppkt, &eaNext);
            continue;
        }

        if (ipaNext.IsLoopback() && ipaNext != IPADDR_LOOPBACK)
        {
            TraceSz1(pktWarn, "[DISCARD] Can't send to %s", ipaNext.Str());
            goto complete;
        }

        if (ipaNext == IPADDR_LOOPBACK || ipaNext == _ipa)
        {
            TraceSz1(pktRecv, "\n[LOOPBACK][%d]", ppkt->GetCb());
            ppkt->SetFlags(PKTF_RECV_LOOPBACK);
            IpRecv(ppkt);
            ppkt->ClearFlags(PKTF_RECV_LOOPBACK);
            ppkt->Complete(this);
            continue;
        }

#ifdef XNET_FEATURE_ARP

        pae = ArpLookup(ipaNext, eSendRequest);

        if (pae == NULL)
        {
            TraceSz(pktWarn, "[DISCARD] ARP cache is full");
            goto complete;
        }

        if (pae->IsIdle())
        {
            EnetFillAndXmit(ppkt, &pae->_eaNext);
            continue;
        }

        if (pae->IsBad())
        {
            TraceSz1(pktWarn, "[DISCARD] %s is unreachable", pae->_ipa.Str());
            goto complete;
        }

        Assert(pae->IsBusy());
        pae->_pqWait.InsertTail(ppkt);
        continue;

#else
        TraceSz1(pktWarn, "[DISCARD] %s is unreachable", ipaNext);
        goto complete;
#endif

complete:
        ppkt->Complete(this);
    }
}

void CXnEnet::EnetFillAndXmit(CPacket * ppkt, CEnetAddr * peaNext)
{
    ICHECK(ENET, UDPC|SDPC);
    Assert(ppkt->IsIp());
    Assert(peaNext);

    CEnetHdr * pEnetHdr = ppkt->GetEnetHdr();
    pEnetHdr->_eaDst = *peaNext;
    pEnetHdr->_eaSrc = _ea;
    pEnetHdr->_wType = ENET_TYPE_IP;

    NicXmit(ppkt);
}

void CXnEnet::EnetQueuePush()
{
    ICHECK(ENET, UDPC|SDPC);
    KeInsertQueueDpc(&_dpcEnet, NULL, NULL);
}

void CXnEnet::EnetDpc(PKDPC, void * pEnet, void *, void *)
{
    ((CXnEnet *)pEnet)->EnetPush();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\halx.cpp ===
// ---------------------------------------------------------------------------------------
// halx.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

#ifdef XNET_FEATURE_XBOX

//
// Linker directive to merge XNET_RD section into XNET section
//
#pragma comment(linker, "/merge:XNET_RD=XNET")

// ---------------------------------------------------------------------------------------
// TCHECK
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ASSERT

KIRQL CXnHal::KeRaiseIrqlToDpcLevel()
{
    KIRQL kirql = ::KeRaiseIrqlToDpcLevel();

    if (kirql == PASSIVE_LEVEL)
    {
        _fUserDpc = TRUE;
    }

    return(kirql);
}

void CXnHal::KeLowerIrql(KIRQL kirql)
{
    if (kirql == PASSIVE_LEVEL)
    {
        _fUserDpc = FALSE;
    }

    ::KeLowerIrql(kirql);
}

BOOL CXnHal::HalThreadCheck(UINT uiCheck)
{
    KIRQL kirql = KeGetCurrentIrql();

    if (kirql != DISPATCH_LEVEL)
        return(uiCheck & USER);
    else if (_fUserDpc)
        return(uiCheck & UDPC);
    else
        return(uiCheck & SDPC);
}

#endif

// ---------------------------------------------------------------------------------------
// SetInitFlag
// ---------------------------------------------------------------------------------------

void CXnHal::SetInitFlag(DWORD dwFlag)
{
    DWORD dwFlagsOld, dwFlagsNew;

    while (1)
    {
        dwFlagsOld = _dwInitFlags;

        Assert((dwFlagsOld & dwFlag) == 0);

        dwFlagsNew = dwFlagsOld | dwFlag;

        if (InterlockedCompareExchange((LONG *)&_dwInitFlags, (LONG)dwFlagsNew, (LONG)dwFlagsOld) == (LONG)dwFlagsOld)
            break;

        TraceSz(Warning, "CXnHal::SetInitFlag: Thread/DPC contention.  Retrying.");
    }
}

// ---------------------------------------------------------------------------------------
// QueryTsc, HalQueryTsc
// ---------------------------------------------------------------------------------------

__declspec(naked) static void QueryTsc(LARGE_INTEGER * pli)
{
    _asm {
        mov ecx, [esp+4]
        rdtsc
        mov [ecx], eax
        mov [ecx+4], edx
        ret 4
    }
}

void HalQueryTsc(LARGE_INTEGER * pli)
{
    QueryTsc(pli);
}

// ---------------------------------------------------------------------------------------
// HalRandGather
// ---------------------------------------------------------------------------------------

struct CRandBytes
{
    BYTE *  _pb;
    UINT    _cb;

    INLINE void Init(BYTE * pb, UINT cb) { _pb = pb; _cb = cb; }
    INLINE void AddDword(DWORD dw) { Add(&dw, sizeof(DWORD)); }
    INLINE void AddWord(WORD w) { Add(&w, sizeof(WORD)); }
    INLINE void AddByte(BYTE b) { Add(&b, sizeof(BYTE)); }
    void Add(void * pv, UINT cb);
};

void CRandBytes::Add(void * pv, UINT cb)
{
    AssertSz(_cb >= cb, "HalRandGather has more randomness than the buffer has room");

    if (_cb >= cb)
    {
        memcpy(_pb, pv, cb);
        _pb += cb;
        _cb -= cb;
    }
}

UINT CXnHal::HalRandGather(BYTE * pb, UINT cb)
{
    LARGE_INTEGER liPerfCount;
    CRandBytes  randbytes;

    // We shouldn't need to initialize liPerfCount, but the compiler is stupid,
    // and if we don't initialize it, the compiler will fail to computs its
    // live range and will put it in the same place on the stack as randbytes.
    liPerfCount.QuadPart = 0;
    randbytes.Init(pb, cb);

    // ** indicates US DoD's specific recommendations for password generation

    // ** ticks since boot (system clock)
    DWORD dwTickBegin = NtGetTickCount(); 
    randbytes.AddDword(dwTickBegin);
    
    // ** system time
    LARGE_INTEGER liTime;
    KeQuerySystemTime(&liTime);
    randbytes.Add(&liTime, sizeof(liTime));

    // ** hi-res performance counter (system counters)
    QueryTsc(&liPerfCount);
    randbytes.AddDword(liPerfCount.LowPart ^ liPerfCount.HighPart);

    // memory status
    MM_STATISTICS mstMemStat;
    MmQueryStatistics(&mstMemStat);
    randbytes.AddWord(LOWORD(mstMemStat.AvailablePages));
    randbytes.AddWord(LOWORD(mstMemStat.PoolPagesCommitted));
    randbytes.AddByte(HIBYTE(LOWORD(mstMemStat.VirtualMemoryBytesReserved)));

#ifndef XNET_FEATURE_XBDM_SERVER

    // Free disk space
    ULARGE_INTEGER  ulintDriveFreeSpace;
    ULARGE_INTEGER  ulintTemp;
    ULARGE_INTEGER  ulintDiskFreeSpace;

    if (GetDiskFreeSpaceEx("T:", &ulintDriveFreeSpace, &ulintTemp, &ulintDiskFreeSpace))
    {
        randbytes.Add(&ulintDriveFreeSpace, sizeof(ulintDriveFreeSpace));
        randbytes.Add(&ulintDiskFreeSpace, sizeof(ulintDiskFreeSpace));
    }

#endif // XBDM

    // EEPROM values
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    NTSTATUS status;
    DWORD type, size;

    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);
    if (NT_SUCCESS(status))
    {
        Assert(type == REG_BINARY);
        Assert(size == EEPROM_TOTAL_MEMORY_SIZE);
        randbytes.Add(buf, size);
    }

    // Use hard drive model and serial number
    randbytes.Add(HalDiskModelNumber->Buffer, HalDiskModelNumber->Length);
    randbytes.Add(HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length);

    return(cb - randbytes._cb);
}

// ---------------------------------------------------------------------------------------
// DbgPrintToKd
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_XBDM_SERVER

void DbgPrintToKd(const char * psz)
{
	STRING st, *pst;
	st.Buffer = (PCHAR)psz;
	st.Length = (USHORT)strlen(psz);
	st.MaximumLength = st.Length + 1;
	pst = &st;
	_asm {
		mov eax, BREAKPOINT_KDPRINT
		mov ecx, pst
		int 2dh
		int 3
	}
}

#endif

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\halw.h ===
// ---------------------------------------------------------------------------------------
// halw.h
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef _HALW_H_
#define _HALW_H_

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

typedef void (*PKDEFERRED_ROUTINE) (struct _KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2);

typedef struct _KDPC {
    LIST_ENTRY              DpcListEntry;
    PKDEFERRED_ROUTINE      DeferredRoutine;
    PVOID                   DeferredContext;
    PVOID                   SystemArgument1;
    PVOID                   SystemArgument2;
} KDPC, *PKDPC, *PRKDPC;

typedef struct _KTIMER {
    LIST_ENTRY              TimerListEntry;
    KDPC *                  Dpc;
    DWORD                   DueTime;
    LONG                    Period;
} KTIMER, *PKTIMER, *PRKTIMER;

// ---------------------------------------------------------------------------------------
// CXnHal
// ---------------------------------------------------------------------------------------

void *  HalAlloc(size_t cb, ULONG tag);
void *  HalAllocZ(size_t cb, ULONG tag);
void    HalFree(void * pv);

class CXnHal : public CXnVoid
{
    // Definitions -----------------------------------------------------------------------

    #define KEVENT                      HANDLE
    #define PRKEVENT                    HANDLE
    #define EvtInit(prke)               prke = CreateEvent(NULL, FALSE, FALSE, NULL)
    #define EvtTerm(prke)               CloseHandle(prke)
    #define EvtSet(prke, pri)           SetEvent(prke)
    #define EvtClear(prke)              ResetEvent(prke)
    #define EvtRef(ke)                  ke
    #define EvtFromHandle(hEvent)       hEvent
    #define EvtDereference(prke)
    #define KeQuerySystemTime(x)        GetSystemTimeAsFileTime((LPFILETIME)(x))
    #define KeQueryTickCount()          GetTickCount()

    #define PASSIVE_LEVEL               0
    #define DISPATCH_LEVEL              1
    #define USER                        0x0001
    #define UDPC                        0x0002
    #define SDPC                        0x0004

    #define XC_ONLINE_IP_ADDRESS                0
    #define XC_ONLINE_SUBNET_ADDRESS            1
    #define XC_ONLINE_DEFAULT_GATEWAY_ADDRESS   2

#ifdef XNET_FEATURE_ASSERT
    #define TCHECK_(pXnBase, lev)       AssertSz((pXnBase)->HalThreadCheck(lev), "Not allowed to execute this code at the current level")
#else
    #define TCHECK_(pXnBase, lev)
#endif
    #define TCHECK(lev)                 TCHECK_(this, lev)

#ifdef XNET_FEATURE_ASSERT
    #define ICHECK_(pXnBase, lay, lev)  AssertSz((pXnBase)->TestInitFlag(INITF_##lay), "This layer is not initialized"); \
                                        AssertSz(!(pXnBase)->TestInitFlag(INITF_##lay##_TERM), "This layer has been terminated."); \
                                        TCHECK_(pXnBase, lev)
#else
    #define ICHECK_(pXnBase, lay, lev)
#endif
    #define ICHECK(lay, lev)            ICHECK_(this, lay, lev)

    #define HAL_DECLARE_NEW_DELETE(class) \
       INLINE void * operator new(size_t cb) { return(HalAllocZ(cb, PTAG_##class)); } \
       INLINE void operator delete(void * pv) { HalFree(pv); } \
       INLINE class() {} \
       INLINE ~class() {}

    // External --------------------------------------------------------------------------

public:

    HAL_DECLARE_NEW_DELETE(CXnHal)

    KIRQL               KeGetCurrentIrql();
    KIRQL               KeRaiseIrqlToDpcLevel();
    VOID                KeLowerIrql(KIRQL kirql);
    VOID                KeInitializeDpc(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOID DeferredContext);
    BOOLEAN             KeInsertQueueDpc(PRKDPC Dpc, PVOID SystemArgument1, PVOID SystemArgument2);
    BOOLEAN             KeRemoveQueueDpc(PRKDPC Dpc);
    VOID                KeInitializeTimer(PKTIMER Timer);
    BOOLEAN             KeSetTimerEx(PKTIMER Timer, LARGE_INTEGER DueTime, LONG Period, PKDPC Dpc);
    BOOLEAN             KeCancelTimer(PKTIMER Timer);

    BOOL                HalThreadCheck(UINT uiCheck);
    void                HalEnterDpc();
    BOOL                HalTryEnterDpc();
    void                HalLeaveDpc();

    UINT                HalRandGather(BYTE * pb, UINT cb);    

    void                SetInitFlag(DWORD dwFlag);
    INLINE BOOL         TestInitFlag(DWORD dwFlag)      { return(!!(_dwInitFlags & dwFlag)); }
    INLINE BOOL         EvtWait(PRKEVENT prke, UINT uiTimeout);

    #undef  HALAPI
    #define HALAPI(ret, fname, arglist, paramlist)  INLINE ret fname arglist { return(Hal##fname paramlist); }
    HALAPILIST()

protected:

    NTSTATUS            HalInit(XNetInitParams * pxnip);
    INLINE void         HalStart()  {};
    INLINE void         HalStop()   {};
    void                HalTerm();

    // Data ------------------------------------------------------------------------------

private:

    DWORD               _dwInitFlags;           // Initialization flags (INITF_*)

protected:

    char                _achXbox[64];           // Name of this xbox

};

INLINE BOOL CXnHal::EvtWait(PRKEVENT prke, UINT uiTimeout)
{
    BOOL fResult = (WaitForSingleObject(prke, uiTimeout ? uiTimeout : INFINITE) != WAIT_TIMEOUT);

    // We need to wait for the DPC thread to finish because it most likely just signalled
    // this event, and on the Xbox the user thread would not get a chance to run until
    // the dispatch routine returned.  On windows we don't simulate dispatch
    // exclusivity, so we just raise/lower to DPC here to make sure the dispatch call
    // that signalled the event is done.

    HalEnterDpc();
    HalLeaveDpc();

    return(fResult);
}

class CRaiseToDpc
{
public:
    CRaiseToDpc(CXnHal * pXnHal);
    ~CRaiseToDpc();
private:
    CRaiseToDpc();
    CXnHal *    _pXnHal;
    UINT        _irql;
};

#define RaiseToDpc()  CRaiseToDpc __RaiseToDpc__(this)

#define HalQueryTsc(pli)    QueryPerformanceCounter(pli)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\ipdhcp.cpp ===
// ---------------------------------------------------------------------------------------
// ipdhcp.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

DefineTag(dhcp, 0);

#ifdef XNET_FEATURE_DHCP

//
// DHCP message format
// NOTE: default the options field to 64 bytes
// which is the size of BOOTP vendor-specified area
//

typedef struct _DhcpMessage {
    BYTE _op;                // message type
    BYTE _htype;             // hareware address type
    BYTE _hlen;              // hardware address length
    BYTE _hops;              // relay hops
    DWORD _xid;              // transaction ID
    WORD _secs;              // seconds since address acquisition process began
    WORD _flags;             // flags
    CIpAddr _ciaddr;          // client IP address
    CIpAddr _yiaddr;          // "your" (client) IP address
    CIpAddr _siaddr;          // server IP address
    CIpAddr _giaddr;          // relay agent IP address
    BYTE _chaddr[16];        // client hardware address
    BYTE _sname[64];         // optional server hostname
    BYTE _file[128];         // boot filename
    BYTE _options[64];       // optional parameters (variable length)
} DhcpMessage;

//
// Our default DHCP packet buffer is 576 bytes
//
#define BOOTP_MESSAGE_SIZE sizeof(DhcpMessage)
#define DEFAULT_DHCP_BUFSIZE 576
#define DHCPHDRLEN offsetof(DhcpMessage, _options)

//
// Minimum and maximum DHCP hardware address length
//
#define MIN_DHCP_HWADDRLEN 1
#define MAX_DHCP_HWADDRLEN 16

//
// BOOTP message type constants
//
#define BOOTREQUEST 1
#define BOOTREPLY   2

//
// Hardware type constants
//
#define HWTYPE_10MB_ETHERNET 1
#define HWTYPE_PPP           8

//
// Constants for DHCP_MESSAGE.flags
//
#define DHCP_BROADCAST 0x8000

//
// DHCP message type constants
//
#define DHCPDISCOVER    1
#define DHCPOFFER       2
#define DHCPREQUEST     3
#define DHCPDECLINE     4
#define DHCPACK         5
#define DHCPNAK         6
#define DHCPRELEASE     7
#define DHCPINFORM      8

//
// DHCP option tag constants
//

// Fixed-length options

#define DHCPOPT_PAD                     0
#define DHCPOPT_END                     255

// Standard options

#define DHCPOPT_SUBNET_MASK             1
#define DHCPOPT_TIME_OFFSET             2
#define DHCPOPT_ROUTERS                 3
#define DHCPOPT_TIME_SERVERS            4
#define DHCPOPT_IEN116_SERVERS          5
#define DHCPOPT_DNS_SERVERS             6
#define DHCPOPT_LOG_SERVERS             7
#define DHCPOPT_COOKIE_SERVERS          8
#define DHCPOPT_LPR_SERVERS             9
#define DHCPOPT_IMPRESS_SERVERS         10
#define DHCPOPT_RLP_SERVERS             11
#define DHCPOPT_HOST_NAME               12
#define DHCPOPT_BOOT_FILESIZE           13
#define DHCPOPT_DUMP_FILE               14
#define DHCPOPT_DOMAIN_NAME             15
#define DHCPOPT_SWAP_SERVER             16
#define DHCPOPT_ROOT_PATH               17
#define DHCPOPT_EXTENSIONS_PATH         18

// IP parameters (per host)

#define DHCPOPT_ENABLE_FORWARD          19
#define DHCPOPT_NONLOCAL_SRCROUTING     20
#define DHCPOPT_POLICY_FILTER           21
#define DHCPOPT_MAX_REASSEMBLY_SIZE     22
#define DHCPOPT_DEFAULT_IP_TTL          23
#define DHCPOPT_PMTU_AGING_TIMEOUT      24
#define DHCPOPT_PMTU_PLATEAU_TABLE      25

// IP parameters (per interface)

#define DHCPOPT_INTERFACE_MTU           26
#define DHCPOPT_ALL_SUBNETS_LOCAL       27
#define DHCPOPT_BROADCAST_ADDRESS       28
#define DHCPOPT_MASK_DISCOVERY          29
#define DHCPOPT_MASK_SUPPLIER           30
#define DHCPOPT_ROUTER_DISCOVERY        31
#define DHCPOPT_SOLICIT_ROUTER_ADDR     32
#define DHCPOPT_STATIC_ROUTES           33

// Link layer parameters

#define DHCPOPT_TRAILER_ENCAPS          34
#define DHCPOPT_ARP_CACHE_TIMEOUT       35
#define DHCPOPT_ETHERNET_ENCAPS         36

// TCP parameters

#define DHCPOPT_DEFAULT_TCP_TTL         37
#define DHCPOPT_KEEPALIVE_INTERVAL      38
#define DHCPOPT_KEEPALIVE_GARBAGE       39

// Application parameters

#define DHCPOPT_NIS_DOMAIN              40
#define DHCPOPT_NIS_SERVERS             41
#define DHCPOPT_NTP_SERVERS             42

// DHCP extensions

#define DHCPOPT_REQUESTED_CIpAddr        50
#define DHCPOPT_IPADDR_LEASE_TIME       51
#define DHCPOPT_FIELD_OVERLOAD          52
#define DHCPOPT_TFTP_SERVER_NAME        66
#define DHCPOPT_BOOT_FILENAME           67
#define DHCPOPT_DHCP_MESSAGE_TYPE       53
#define DHCPOPT_SERVERID                54
#define DHCPOPT_PARAM_REQUEST_LIST      55
#define DHCPOPT_MESSAGE                 56
#define DHCPOPT_MAX_DHCP_MESSAGESIZE    57
#define DHCPOPT_T1_INTERVAL             58
#define DHCPOPT_T2_INTERVAL             59
#define DHCPOPT_VENDOR_CLASSID          60
#define DHCPOPT_CLIENTID                61

// Vendor-specific information

#define DHCPOPT_VENDOR_INFO             43
#define DHCPOPT_NETBIOS_NAMESERVERS     44
#define DHCPOPT_NETBIOS_DATASERVERS     45
#define DHCPOPT_NETBIOS_NODETYPE        46
#define DHCPOPT_NETBIOS_SCOPE           47
#define DHCPOPT_X11_FONTSERVERS         48
#define DHCPOPT_X11_DISPLAYSERVERS      49
#define DHCPOPT_NIS2_DOMAIN             64
#define DHCPOPT_NIS2_SERVERS            65
#define DHCPOPT_MOBILEIP_HOME_AGENTS    68
#define DHCPOPT_SMTP_SERVERS            69
#define DHCPOPT_POP3_SERVERS            70
#define DHCPOPT_NNTP_SERVERS            71
#define DHCPOPT_WWW_SERVERS             72
#define DHCPOPT_FINGER_SERVERS          73
#define DHCPOPT_IRC_SERVERS             74
#define DHCPOPT_STREETTALK_SERVERS      75
#define DHCPOPT_STREETTALKDA_SERVERS    76

//
// DHCP magic cookie: 99, 130, 83, 99
//
//#define DHCPCOOKIELEN 4
//extern const BYTE DhcpMagicCookie[DHCPCOOKIELEN];

//
// DHCP time value (in seconds)
//
// NOTE: We use 32-bit unsigned interface to represent
// the number of seconds ellapsed since the start of 1/1/2000.
// This should last until year 2136 before overflowing.
//

#define DHCPTIME_INFINITE 0xffffffff

//
// Autonet address range: 169.254/16
//  don't use the first 256 and the last 256 addresses
//
#define AUTONET_ADDRMASK    0xffff0000
#define AUTONET_ADDRBASE    0xa9fe0100
#define AUTONET_ADDRRANGE   0x0000fcff

//
// States for an interface
//
enum {
    STATE_NONE,             // temporary wait state after startup
    STATE_STATIC_ADDR,      // statically assigned address
    STATE_INIT,             // sending discover
    STATE_REQUESTING,       // waiting for DHCPACK after selecting
    STATE_INIT_REBOOT,      // rebooting with valid lease
    STATE_BOUND,            // bound with valid address lease
    STATE_RENEWING,         // renewing after T1 expires
    STATE_REBINDING,        // rebinding after T2 expires
    STATE_DECLINING,        // temporary wait state after sending decline
    STATE_INIT_AUTOADDR,    // waiting for timer to kick off autonet
    STATE_SELECT_AUTOADDR   // checking autonet address conflicts
};

//
// Constants for the DhcpInfo.flags field:
//
#define FLAG_ACTIVE_DHCPADDR    0x00010000
#define FLAG_ACTIVE_AUTONETADDR 0x00020000
#define FLAG_ACTIVE_NOADDR      0x00040000
#define FLAG_ACTIVE_ADDRMASK    (FLAG_ACTIVE_DHCPADDR | FLAG_ACTIVE_AUTONETADDR | FLAG_ACTIVE_NOADDR)

BOOL CXnIp::ActiveDhcpAddr()
{
    return (_flags & FLAG_ACTIVE_DHCPADDR);
}

BOOL CXnIp::ActiveAutonetAddr()
{
    return (_flags & FLAG_ACTIVE_AUTONETADDR);
}

BOOL CXnIp::ActiveStaticAddr()
{
    return(_state == STATE_STATIC_ADDR);
}

BOOL CXnIp::ActiveNoAddr()
{
    return(_flags & FLAG_ACTIVE_NOADDR);
}

//
// Dump DHCP message in the debugger
//

#if DBG
VOID DhcpDumpMessage(DhcpMessage* msg, UINT msglen);
#else
#define DhcpDumpMessage(msg, msglen)
#endif

// ---------------------------------------------------------------------------------------

//
// First 4 bytes of the options field in a DHCP message
// must match the following magic cookie
//
const BYTE DhcpMagicCookie[] = { 99, 130, 83, 99 };

//
// Default address lease time requested:
//  let the server decide
//
//UINT cfgDefaultLeaseTime = 0;

//
// Minimum retransmission timeout while in
// RENEWING and REBINDING states: 60 seconds
//
//UINT cfgMinRenewTimeout = 60;

//
// Number of seconds to wait after reboot
// before we start sending out DHCPDISCOVER packets
//
// NOTE: RFC2131 recommends that we wait between 1 to 10 seconds.
// But we're only doing 1 seconds here for faster startup time.
//
//UINT cfgStartupWaitMin = 0;
//UINT cfgStartupWaitMax = 1;

//
// Number of times we'll attempt to resend
// DHCPDISCOVER and DHCPREQUEST packets
//
// NOTE: Non-standard behavior!!!
//  We're capping the timeout between retries to a maximum of 10 seconds.
//
//UINT cfgDhcpRetryCount = 3;
//UINT cfgDhcpRetryMaxTimeout = 10;

//
// Number of autonet addresses we'll attempt before giving up
//
//UINT cfgAutonetAddrRetries = 10;

//
// How frequently to look for DHCP server when in Autonet mode
//
//UINT cfgAutonetDhcpCheckInterval = 5*60;

//
// How many ARP requests to send
// when checking for address conflict
//
//UINT cfgConflictCheckRetries = 2;

// Check to see if we're forced to use autonet address
//  (without trying to find DHCP servers)
INLINE
BOOL CXnIp::DhcpForceAutonet(CIpAddr addr, CIpAddr mask)
{
    ICHECK(IP, USER|UDPC|SDPC);

    return (mask == HTONL(AUTONET_ADDRMASK)) && 
            (addr & mask) == (HTONL(AUTONET_ADDRBASE) & mask);
}

NTSTATUS CXnIp::DhcpInit()
{
    ICHECK(IP, USER);

    _state = STATE_NONE;
    _timerDhcp.Init((PFNTIMER)DhcpTimer);
    _dwXidNext = RandLong();

    return(NETERR_OK);
}

INT CXnIp::DhcpConfig(const XNetConfigParams * pxncp)
{
    ICHECK(IP, UDPC);

    //@@@ Cannot be reconfigured.  Need DHCP rewrite.

    _activeaddr = pxncp->ina.s_addr;

    if (_activeaddr != 0)
    {
        _activemask = pxncp->inaMask.s_addr;

        if (_activemask == 0 || !_activemask.IsValidMask())
            _activemask = _activeaddr.DefaultMask();

        _options._gatewayCount = 0;

        if (pxncp->inaGateway.s_addr != 0)
        {
            _options._gateways[_options._gatewayCount] = pxncp->inaGateway.s_addr;
            _options._gatewayCount += 1;
        }

        _options._dnsServerCount = 0;

        if (pxncp->inaDnsPrimary.s_addr != 0)
        {
            _options._dnsServers[_options._dnsServerCount] = pxncp->inaDnsPrimary.s_addr;
            _options._dnsServerCount += 1;
        }

        if (pxncp->inaDnsSecondary.s_addr != 0)
        {
            _options._dnsServers[_options._dnsServerCount] = pxncp->inaDnsSecondary.s_addr;
            _options._dnsServerCount += 1;
        }
    }

    if (!TestInitFlag(INITF_CONNECTED_BOOT))
    {
        TraceSz(Warning, "Ethernet cable not plugged in.  No IP address acquired.");
        _flags = (_flags & ~FLAG_ACTIVE_ADDRMASK) | FLAG_ACTIVE_NOADDR;
    }
#if defined(XNET_FEATURE_INSECURE) && !defined(XNET_FEATURE_SG)
    else if (!(cfgFlags & XNET_STARTUP_BYPASS_SECURITY))
    {
        // When operating in secure mode don't acquire an IP address so we behave
        // more like xnets.lib.

        _flags = (_flags & ~FLAG_ACTIVE_ADDRMASK) | FLAG_ACTIVE_NOADDR;
    }
#endif
    else if (_activeaddr != 0 && !DhcpForceAutonet(_activeaddr, _activemask))
    {
        // If we're using static address, inform the IP stack
        IpSetAddress(_activeaddr, _activemask);
        DhcpSetDefaultGateways();
        DhcpChangeState(STATE_STATIC_ADDR);
    }
    else if ((cfgFlags & XNET_STARTUP_BYPASS_DHCP) || _activeaddr != 0)
    {
        TraceSz(Warning, "Forcing autonet...");
        _activeaddr = _activemask = 0;
        DhcpChangeState(STATE_INIT_AUTOADDR);
    }
    else
    {
        // Obtain address via DHCP or Autonet.  Be quiet for a while after startup.
        DhcpTimerSetRelative(0, 0);
    }

    return(0);
}

void CXnIp::DhcpTerm()
{
    ICHECK(IP, UDPC);
    TimerSet(&_timerDhcp, TIMER_INFINITE);
}

void CXnIp::DhcpRecv(CPacket * ppkt, CUdpHdr * pUdpHdr, UINT msglen)
{
    ICHECK(IP, UDPC|SDPC);

    DhcpMessage * msg = (DhcpMessage *)(pUdpHdr + 1);
    CDhcpOptions * dhcpParams = NULL;
    BYTE* option;
    BYTE overload = 0;
    NTSTATUS status = NETERR_NOTIMPL;

    if (msglen < DHCPHDRLEN)
    {
        TraceSz1(pktRecv, "[DISCARD] DHCP packet is too short (%d)", msglen);
        return;
    }

    if (memcmp(msg->_chaddr, _ea._ab, sizeof(CEnetAddr)) != 0)
    {
        TraceSz(pktRecv, "[DISCARD] DHCP packet not meant for me");
        return;
    }

    if (    msg->_op != BOOTREPLY
        ||  msg->_htype != HWTYPE_10MB_ETHERNET
        ||  msg->_hlen != sizeof(CEnetAddr)
        ||  NTOHL(msg->_xid) != _xid)
    {
        TraceSz4(pktWarn, "[DISCARD] DHCP packet is invalid (%d,%d,%d,%d)",
                 msg->_op != BOOTREPLY,
                 msg->_htype != HWTYPE_10MB_ETHERNET,
                 msg->_hlen != sizeof(CEnetAddr),
                 NTOHL(msg->_xid) != _xid);
        return;
    }

    DhcpDumpMessage(msg, msglen);

    dhcpParams = (CDhcpOptions *)PoolAllocZ(sizeof(*dhcpParams), PTAG_CDhcpOptions);

    if (!dhcpParams)
    {
        TraceSz(pktWarn, "[DISCARD] Out of memory allocating CDhcpOptions");
        status = NETERR_MEMORY;
        goto exit;
    }

    //
    // Skip the DHCP magic cookie
    //
    option = msg->_options;
    msglen -= DHCPHDRLEN;
    if (    msglen < sizeof(DhcpMagicCookie)
        ||  memcmp(option, DhcpMagicCookie, sizeof(DhcpMagicCookie)) != 0)
    {
        TraceSz1(pktWarn, "[DISCARD] DHCP packet has invalid magic cookie (%d)", msglen);
        goto exit;
    }

    msglen -= sizeof(DhcpMagicCookie);
    option += sizeof(DhcpMagicCookie);

    //
    // Parse the regular options
    //
    status = DhcpParseOptionParams(dhcpParams, option, msglen, &overload);

    if (!NT_SUCCESS(status))
    {
        TraceSz(pktWarn, "[DISCARD] DHCP regular options are invalid");
        goto exit;
    }

    //
    // Parse overloaded options in the msg->_file field
    //
    if (overload & 1)
    {
        status = DhcpParseOptionParams(dhcpParams, msg->_file, sizeof(msg->_file), NULL);

        if (!NT_SUCCESS(status))
        {
            TraceSz(pktWarn, "[DISCARD] DHCP file options are invalid");
            goto exit;
        }
    }

    //
    // Parse overloaded options in the msg->_sname field
    //
    if (overload & 2)
    {
        status = DhcpParseOptionParams(dhcpParams, msg->_sname, sizeof(msg->_sname), NULL); 

        if (!NT_SUCCESS(status))
        {
            TraceSz(pktWarn, "[DISCARD] DHCP sname options are invalid");
            goto exit;
        }
    }

    //
    // The received packet must have a server identifier option
    //
    if (dhcpParams->_dhcpServer == 0)
    {
        TraceSz(pktWarn, "[DISCARD] DHCP packet lacks server identifier option");
        status = NETERR_PARAM;
        goto exit;
    }

    //
    // Now that we've parsed the option data,
    // use it appropriately
    //
    status = NETERR_NOTIMPL;

    switch (_state) {
    case STATE_INIT:
        // Expecting DHCPOFFER...
        if (dhcpParams->_recvMsgType == DHCPOFFER)
            status = DhcpProcessOffer(msg->_yiaddr, dhcpParams);
        break;

    case STATE_INIT_REBOOT:
    case STATE_REQUESTING:
    case STATE_RENEWING:
    case STATE_REBINDING:
        // Expecting DHCPACK or DHCPNAK...
        if (dhcpParams->_recvMsgType == DHCPACK)
            status = DhcpProcessAck(msg->_yiaddr, dhcpParams);
        else if (dhcpParams->_recvMsgType == DHCPNAK)
            status = DhcpProcessNak(dhcpParams->_dhcpServer);
        break;
    }

exit:

    if (!NT_SUCCESS(status) && status != NETERR_NOTIMPL)
    {
        TraceSz1(pktWarn, "[DISCARD] DhcpRecv failed: %08lX", status);
    }

    PoolFree(dhcpParams);
}

void CXnIp::DhcpNotifyAddressConflict()
{
    ICHECK(IP, UDPC|SDPC);

    if (_state == STATE_SELECT_AUTOADDR)
    {
        // the last autonet address we chose was no good
        // so we need to find another one
        DhcpSelectAutonetAddr();
    }
    else
    {
        TraceSz1(Warning, "!!! Address conflict: %s", _activeaddr.Str());
    }
}

//
// Number of seconds from start of 1601 to start of 2000
//
static const LONGLONG StartOf2000 = 0x2ee7dd480;

CXnIp::DHCPTIME CXnIp::DhcpTime()
{
    ICHECK(IP, UDPC|SDPC);

    LARGE_INTEGER currentTime;

    // Get the current UTC time
    //  = number of 100 nanoseconds since 1/1/1601
    KeQuerySystemTime(&currentTime);

    // Return the number of seconds since the start of 2000
    return (DHCPTIME) (currentTime.QuadPart / 10000000 - StartOf2000);
}


void CXnIp::DhcpTimerSetRelative(UINT minWait, UINT maxWait)
{
    ICHECK(IP, UDPC|SDPC);

    TimerSet(&_timerDhcp, TimerTick() + (minWait + RandScaled(maxWait - minWait)) * TICKS_PER_SECOND);
}

void CXnIp::DhcpTimerSetAbsolute(DHCPTIME dhcptime)
{
    ICHECK(IP, UDPC|SDPC);

    DWORD dwTick = TIMER_INFINITE;

    if (dhcptime != DHCPTIME_INFINITE)
    {
        DHCPTIME dhcptimeNow = DhcpTime();

        if (dhcptime > dhcptimeNow)
            dwTick = TimerTick() + (dhcptime - dhcptimeNow) * TICKS_PER_SECOND;
        else
            dwTick = TimerTick();
    }

    TimerSet(&_timerDhcp, dwTick);
}

void CXnIp::DhcpComputeTimeout()
{
    ICHECK(IP, UDPC|SDPC);

    UINT minWait, maxWait;

    switch (_state)
    {
    case STATE_INIT:
        if (ActiveAutonetAddr()) {
            //
            // Special case: we're currently using an Autonet address
            // and we're sending out periodic DHCPDISCOVER packets.
            //
            // DhcpSetIfTimerRelative(
            //     cfgAutonetDhcpCheckInterval,
            //     cfgAutonetDhcpCheckInterval);

            // NOTE: Non-standard behavior!!!
            //  We do not send out DHCPDISCOVER messages
            //  while we're using an active AutoNet address.
            DhcpTimerSetAbsolute(DHCPTIME_INFINITE);
            break;
        }

        // Fall through

    case STATE_REQUESTING:
    case STATE_INIT_REBOOT:
        //
        // timeout = 2**retry x 2 +/- 1, i.e.
        //  4 +/- 1
        //  8 +/- 1
        //  16 +/- 1
        //  32 +/- 1
        //

        minWait = 2 << _retries;
        if (minWait > cfgDhcpRetryMaxTimeoutInSeconds)
            minWait = cfgDhcpRetryMaxTimeoutInSeconds;

        minWait -= 1;
        maxWait = minWait + 2;
        DhcpTimerSetRelative(minWait, maxWait);
        break;

    case STATE_BOUND:
        //
        // timeout when T1 expires
        //
        DhcpTimerSetAbsolute(_options._t1time);
        break;

    case STATE_RENEWING:
    case STATE_REBINDING: {
        //
        // calculate retransmission timeout for
        // RENEWING and REBINDING states:
        //  1. half the time from now to T2 (renew) or expiration (rebind)
        //  2. make sure it's at least 60 seconds
        //

        DHCPTIME t1, t2;
        t1 = DhcpTime();
        t2 = (_state == STATE_RENEWING) ? _options._t2time : _options._exptime;

        if (t1 < t2) {
            minWait = (t2-t1) / 2;
            if (minWait >= cfgDhcpRenewMinTimeoutInSeconds)
                t1 += minWait;
            else {
                t1 += cfgDhcpRenewMinTimeoutInSeconds;
                if (t1 > t2) t1 = t2;
            }
        }

        DhcpTimerSetAbsolute(t1);
        }
        break;

    case STATE_DECLINING:
        //
        // Wait 10 seconds after sending DHCP decline
        //
        DhcpTimerSetRelative(cfgDhcpDeclineWaitInSeconds, cfgDhcpDeclineWaitInSeconds);
        break;
    
    case STATE_SELECT_AUTOADDR:
        //
        // Wait ~2 seconds for address conflict detection
        //
        DhcpTimerSetRelative(cfgAutoIpRexmitTimeoutInSeconds, cfgAutoIpRexmitTimeoutInSeconds);
        break;

    default:
        // Should not happen - shut off the timer just in case
        Assert(FALSE);

    case STATE_NONE:
    case STATE_STATIC_ADDR:
        DhcpTimerSetAbsolute(DHCPTIME_INFINITE);
        break;
    }
}

void CXnIp::DhcpTimer(CTimer * pt)
{
    ICHECK(IP, UDPC|SDPC);

    switch (_state) {
    case STATE_NONE:
        //
        // We got here because we just finished the quiet
        // period after startup
        //
        // If we had a valid lease before, start in
        // INIT-REBOOT state; otherwise, start in INIT state
        //
        DhcpChangeState(_dhcpaddr ? STATE_INIT_REBOOT : STATE_INIT);
        break;
    
    case STATE_INIT:
        //
        // We're sending DHCPDISCOVER messages
        //
        if (_retries >= cfgDhcpRetryCount && !ActiveAutonetAddr())
        {
            //
            // Too many retries, give up and
            // start Autonet address acquisition process
            //
            TraceSz(dhcp, "Couldn't discover DHCP server, trying autonet...");
            DhcpChangeState(STATE_SELECT_AUTOADDR);
        }
        else
        {
            //
            // Send out another DHCPDISCOVER packet
            //
            TraceSz(dhcp, "Retransmit DHCPDISCOVER");
            DhcpSendDiscover();
        }
        break;

    case STATE_INIT_REBOOT:
    case STATE_REQUESTING:
        //
        // We're sending DHCPREQUEST
        //
        if (_retries >= cfgDhcpRetryCount) {
            //
            // Too many retries, go back to INIT state
            //
            TraceSz(dhcp, _state == STATE_INIT_REBOOT ?
                        "Failed to reuse a prior lease" :
                        "No ack for an offered address");

            DhcpChangeState(STATE_INIT);
        } else {
            //
            // Send out another DHCPREQUEST packet
            //
            TraceSz(dhcp, "Retransmit DHCPREQUEST");
            DhcpSendRequest();
        }
        break;
    
    case STATE_DECLINING:
        //
        // We just finished waiting after sending DHCPDECLINE
        //
        DhcpChangeState(STATE_INIT);
        break;
    
    case STATE_BOUND:
        //
        // T1 expired, start the renewing process
        //
        TraceSz(dhcp, "Switching to RENEWING state");
        DhcpChangeState(STATE_RENEWING);
        break;

    case STATE_RENEWING:
        //
        // We're trying to renew a valid address.
        // If T2 expired, start the rebinding process.
        //
        if (DhcpTime() >= _options._t2time) {
            TraceSz(dhcp, "Switching to REBINDING state");
            DhcpChangeState(STATE_REBINDING);
        } else {
            // Send out another DHCPREQUEST
            TraceSz(dhcp, "Retransmit DHCPREQUEST");
            DhcpSendRequest();
        }
        break;

    case STATE_REBINDING:
        //
        // We're trying to rebind a valid lease
        //  did our lease expire?
        //
        if (DhcpTime() >= _options._exptime) {
            // Inform IP stack to discard the active address
            TraceSz(dhcp, "Address lease expired - start over");
            DhcpResetInterface();

            // Too bad, go back to INIT state
            DhcpChangeState(STATE_INIT);
        } else {
            // Send out another DHCPREQUEST
            TraceSz(dhcp, "Retransmit DHCPREQUEST");
            DhcpSendRequest();
        }
        break;

    case STATE_INIT_AUTOADDR:
        DhcpChangeState(STATE_SELECT_AUTOADDR);
        break;

    case STATE_SELECT_AUTOADDR:
        if (++_retries > cfgAutoIpRetriesPerAttempt)
        {
            // We've successfully picked an autonet address.
            TraceSz1(dhcp, "Selected autonet address: %s", _autonetaddr.Str());

            _activeaddr = _autonetaddr;
            _activemask = HTONL(AUTONET_ADDRMASK);
            _flags |= FLAG_ACTIVE_AUTONETADDR;
            IpSetAddress(_activeaddr, _activemask);

            // Switch to INIT state to continue looking
            // for a DHCP server
            _initRetryCount = 0;
            DhcpChangeState(STATE_INIT);
        }
        else
        {
            // No response to our previous ARP request.
            // Try again just to be sure.
            EnetXmitArp(_autonetaddr);
            DhcpComputeTimeout();
        }
        break;

    default:
        TraceSz(dhcp, "Unexpected timeout");
        DhcpTimerSetAbsolute(DHCPTIME_INFINITE);
        break;
    }
}


void CXnIp::DhcpChangeState(INT state)
{
    ICHECK(IP, UDPC|SDPC);

    INT oldstate = _state;

    _state = state;
    _retries = 0;

    // Assign a new transaction ID for the next outgoing message.

    _xid = _dwXidNext++;

    switch (state) {
    case STATE_INIT_REBOOT:
    case STATE_REQUESTING:
    case STATE_RENEWING:
    case STATE_REBINDING:
        // Send out DHCPREQUEST
        DhcpSendRequest();
        break;

    case STATE_INIT:
        if (oldstate == STATE_SELECT_AUTOADDR) {
            // We just selected an autonet address.
            // Continue to look for a DHCP server.
            DhcpComputeTimeout();
        }
        else if (++_initRetryCount > cfgDhcpRetryCount) {
            // We went through the INIT state too many times
            // without getting a valid address lease. Just give up.
            // We don't try Autonet because in this case there
            // is a DHCP server but somehow we can't work with it.
            TraceSz(Warning, "Couldn't get a valid DHCP address after many tries");
            DhcpChangeState(STATE_NONE);
            _flags = (_flags & ~FLAG_ACTIVE_ADDRMASK) | FLAG_ACTIVE_NOADDR;
        } else {
            // Send out DHCPDISCOVER
            DhcpSendDiscover();
        }
        break;

    case STATE_BOUND:
        DhcpComputeTimeout();
        TraceSz1(dhcp, "Sleep %d seconds till renewal...", _options._t1time - DhcpTime());
        break;

    case STATE_INIT_AUTOADDR:
        DhcpTimerSetAbsolute(0);
        break;

    case STATE_SELECT_AUTOADDR:
        _initRetryCount = 0;
        DhcpSelectAutonetAddr();
        break;

    case STATE_NONE:
    case STATE_STATIC_ADDR:
        DhcpTimerSetAbsolute(DHCPTIME_INFINITE);
        break;
    }
}

void CXnIp::DhcpResetInterface()
{
    ICHECK(IP, UDPC|SDPC);

    IpSetAddress(0, 0);
    _flags &= ~FLAG_ACTIVE_ADDRMASK;
    if (_state != STATE_STATIC_ADDR)
        _activeaddr = 0;
}


NTSTATUS CXnIp::DhcpSendMessage(CPacket * ppkt, UINT msglen, BOOL broadcast)
{
    ICHECK(IP, UDPC|SDPC);

    ppkt->SetCb(ppkt->GetCb() - DEFAULT_DHCP_BUFSIZE + msglen);

    CUdpHdr * pUdpHdr = ppkt->GetUdpHdr();
    DhcpMessage * msg = (DhcpMessage *)(pUdpHdr + 1);

    // Debug trace
    DhcpDumpMessage(msg, msglen);

    // Set broadcast flag if necessary
    if (!_activeaddr || ActiveAutonetAddr())
        msg->_flags |= HTONS(DHCP_BROADCAST);

    pUdpHdr->_ipportSrc = DHCP_CLIENT_PORT;
    pUdpHdr->_ipportDst = DHCP_SERVER_PORT;
    pUdpHdr->_wLen = HTONS(msglen + sizeof(CUdpHdr));

    // Call the IP layer to send out the packet
    IpFillAndXmit(ppkt, broadcast ? IPADDR_BROADCAST : _options._dhcpServer, IPPROTOCOL_UDP);

    // Calculate the timeout value
    _retries++;
    DhcpComputeTimeout();

    return(NETERR_OK);
}

//
// Append the 'parameter request list' option
//  !!! we assume the data buffer is large enough.
//
BYTE * DhcpAppendParamReqList(BYTE * option)
{
    *option++ = DHCPOPT_PARAM_REQUEST_LIST;
    *option++ = 4;
    *option++ = DHCPOPT_SUBNET_MASK;
    *option++ = DHCPOPT_ROUTERS;
    *option++ = DHCPOPT_DNS_SERVERS;
    *option++ = DHCPOPT_DOMAIN_NAME;
    return(option);
}

//
// Append an option whose value is a DWORD
//
BYTE * DhcpAppendDWordOption(BYTE * option, INT tag, DWORD val)
{
    option[0] = (BYTE) tag;
    option[1] = sizeof(DWORD);
    option += 2;

    memcpy(option, &val, sizeof(DWORD));
    return option + sizeof(DWORD);
}


//
// Append the 'address lease time' option
//
BYTE * CXnIp::DhcpAppendLeaseTimeOption(BYTE * option)
{
    ICHECK(IP, UDPC|SDPC);

    DWORD dwLeaseTime = cfgDhcpDefaultLeaseTimeInDays * (24 * 60 * 60);

    if (dwLeaseTime == 0)
        return option;

    return DhcpAppendDWordOption(option, DHCPOPT_IPADDR_LEASE_TIME, HTONL(dwLeaseTime));
}


BYTE * CXnIp::DhcpFillMessageHeader(BYTE * buf, INT msgtype)
{
    ICHECK(IP, UDPC|SDPC);

    DhcpMessage* msg = (DhcpMessage*) buf;
    BYTE* option = msg->_options;
    BYTE hwtype;

    memset(buf, 0, DEFAULT_DHCP_BUFSIZE);
    msg->_op = BOOTREQUEST;
    msg->_htype = hwtype = HWTYPE_10MB_ETHERNET;
    msg->_hlen = sizeof(CEnetAddr);
    memcpy(msg->_chaddr, _ea._ab, sizeof(CEnetAddr));

    //
    // Fill in the transaction ID field
    // NOTE: We reuse the same XID for retransmissions.
    //
    msg->_xid = HTONL(_xid);

    // Number of seconds since we started the address
    // acquisition process.
    msg->_secs = (WORD) HTONS((WORD)_secsSinceStart);

    // Start with the magic cookie
    memcpy(option, DhcpMagicCookie, sizeof(DhcpMagicCookie));
    option += sizeof(DhcpMagicCookie);

    // Append the message type option
    option[0] = DHCPOPT_DHCP_MESSAGE_TYPE;
    option[1] = 1;
    option[2] = (BYTE) msgtype;
    option += 3;

    // Append the client identifier option
    option[0] = DHCPOPT_CLIENTID;
    option[1] = (BYTE) (sizeof(CEnetAddr)+1);
    option[2] = hwtype;
    option += 3;
    memcpy(option, _ea._ab, sizeof(CEnetAddr));
    option += sizeof(CEnetAddr);

    return option;
}


void CXnIp::DhcpComputeSecsSinceStart()
{
    ICHECK(IP, UDPC|SDPC);

    DHCPTIME now = DhcpTime();

    if (_retries == 0)
        _acqtime = now;

    _secsSinceStart = now - _acqtime;
}

//
// Common prolog and epilog for SendDhcpXXX functions
//
#define SEND_DHCP_MESSAGE_PROLOG() \
        DhcpMessage* msg; \
        BYTE* buf; \
        BYTE* option; \
        CPacket * pkt = PacketAlloc(PTAG_CDhcpPacket, PKTF_TYPE_UDP|PKTF_XMIT_INSECURE|PKTF_POOLALLOC, DEFAULT_DHCP_BUFSIZE); \
        if (!pkt) return NETERR_MEMORY; \
        buf = (BYTE *)pkt->GetUdpHdr() + sizeof(CUdpHdr); \
        msg = (DhcpMessage*) buf

#define SEND_DHCP_MESSAGE_RETURN(_bcast) \
        return DhcpSendMessage(pkt, option - buf, _bcast)


NTSTATUS CXnIp::DhcpSendDiscover()
{
    ICHECK(IP, UDPC|SDPC);

    SEND_DHCP_MESSAGE_PROLOG();

    Assert(_state == STATE_INIT);

    DhcpComputeSecsSinceStart();

    // Fill in common header fields
    option = DhcpFillMessageHeader(buf, DHCPDISCOVER);

    // Fill in the parameter request list
    option = DhcpAppendParamReqList(option);

    // Fill in requested ip address and lease time option
    if (_dhcpaddr)
        option = DhcpAppendDWordOption(option, DHCPOPT_REQUESTED_CIpAddr, _dhcpaddr);

    // Fill in the lease time option
    option = DhcpAppendLeaseTimeOption(option);
    *option++ = DHCPOPT_END;

    // Emit the message
    SEND_DHCP_MESSAGE_RETURN(TRUE);
}


NTSTATUS CXnIp::DhcpSendRequest()
{
    ICHECK(IP, UDPC|SDPC);

    INT state = _state;
    SEND_DHCP_MESSAGE_PROLOG();

    Assert(state == STATE_REQUESTING ||
           state == STATE_RENEWING ||
           state == STATE_REBINDING ||
           state == STATE_INIT_REBOOT);

    //
    // If we're in REQUESTING state, then don't update
    // the secsSinceStart field. This is so that the
    // secs in DHCPREQUEST message will be the same as
    // what's in the original DHCPDISCOVER message.
    //
    if (state != STATE_REQUESTING) {
        DhcpComputeSecsSinceStart();
    }

    // Fill in common header fields
    option = DhcpFillMessageHeader(buf, DHCPREQUEST);

    // Fill in the ciaddr field and the 'requested ip addr' option
    if (state == STATE_RENEWING || state == STATE_REBINDING) {
        msg->_ciaddr = _dhcpaddr;
    } else if (_dhcpaddr) {
        // state == STATE_INIT_REBOOT || state == STATE_REQUESTING
        option = DhcpAppendDWordOption(option, DHCPOPT_REQUESTED_CIpAddr, _dhcpaddr);
    }

    // Fill in the parameter request list
    option = DhcpAppendParamReqList(option);

    // Fill in the lease time option
    option = DhcpAppendLeaseTimeOption(option);

    // Fill in the server identifier option
    if (state == STATE_REQUESTING)
        option = DhcpAppendDWordOption(option, DHCPOPT_SERVERID, _options._dhcpServer);

    *option++ = DHCPOPT_END;

    // Emit the message:
    //  unicast in RENEWING state, broadcast otherwise
    SEND_DHCP_MESSAGE_RETURN(state != STATE_RENEWING);
}

BOOL CXnIp::DhcpValidateOffer(CIpAddr yiaddr, CDhcpOptions* param)
{
    ICHECK(IP, UDPC|SDPC);

    if (    !yiaddr.IsValidUnicast()
        ||  !param->_dhcpServer.IsValidUnicast()
        ||  param->_exptime < (DHCPTIME)(8*cfgDhcpRenewMinTimeoutInSeconds))
        return FALSE;

    if (param->_dhcpmask == 0)
        param->_dhcpmask = yiaddr.DefaultMask();

    if (param->_t1time == 0 ||
        param->_t2time == 0 ||
        param->_t1time >= param->_t2time ||
        param->_t2time - param->_t1time < cfgDhcpRenewMinTimeoutInSeconds ||
        param->_t2time >= param->_exptime ||
        param->_exptime - param->_t2time < cfgDhcpRenewMinTimeoutInSeconds) {
        param->_t1time = param->_exptime / 2;
        param->_t2time = param->_exptime * 7 / 8;
    }

    return TRUE;
}


NTSTATUS CXnIp::DhcpProcessOffer(CIpAddr yiaddr, CDhcpOptions* param)
{
    ICHECK(IP, UDPC|SDPC);

    Assert(_state == STATE_INIT);

    TraceSz3(dhcp, "Received DHCPOFFER %s from %s @ time %d", yiaddr.Str(), param->_dhcpServer.Str(), DhcpTime());

    // Simply sanity check of offered parameters
    if (!DhcpValidateOffer(yiaddr, param))
        return(NETERR_PARAM);

    _options._dhcpServer = param->_dhcpServer;
    _dhcpaddr = yiaddr;

    // Send DHCPREQUEST and ignore error
    DhcpChangeState(STATE_REQUESTING);

    return(NETERR_OK);
}


void CXnIp::DhcpAddOrRemoveGateways(BOOL fDelete)
{
    ICHECK(IP, UDPC|SDPC);

    CIpAddr ipa;
    UINT    i;

    for (i = 0; i < _options._gatewayCount; i++)
    {
        ipa = _options._gateways[i];

        TraceSz2(dhcp, "%s gateway: %s", fDelete ? "Remove" : "Add", ipa.Str());

        if (fDelete)
            RouteDelete(0, 0, ipa);
        else
            RouteAdd(0, 0, ipa, RTEF_DEFAULT, (WORD)(RTE_DEFAULT_METRIC + i));
    }
}

void CXnIp::DhcpSetDefaultGateways()
{
    ICHECK(IP, USER|UDPC|SDPC);

    RaiseToDpc();
    DhcpAddOrRemoveGateways(FALSE);
}


void CXnIp::DhcpUseOptionParams(CDhcpOptions* param)
{
    ICHECK(IP, UDPC|SDPC);

    BOOL resetGateways;

    //
    // Remember the originating server address and lease info
    //
    _options._dhcpServer = param->_dhcpServer;

    if (param->_exptime == DHCPTIME_INFINITE) {
        _options._t1time =
        _options._t2time =
        _options._exptime = DHCPTIME_INFINITE;
    } else {
        _options._t1time = _acqtime + param->_t1time;
        _options._t2time = _acqtime + param->_t2time;
        _options._exptime = _acqtime + param->_exptime;
    }

    //
    // Set gateways in the IP stack
    //
    if (param->_gatewayCount == 0 || _options._gatewayCount == 0) {
        resetGateways = TRUE;
    } else {
        UINT oldcnt = _options._gatewayCount;
        UINT newcnt = param->_gatewayCount;
        UINT i, j;

        for (i=0; i < newcnt; i++) {
            for (j=0; j < oldcnt; j++)
                if (param->_gateways[i] != _options._gateways[j]) break;
            if (j < oldcnt) break;
        }
        resetGateways = (i < newcnt);
    }

    if (resetGateways) {
        //
        // Reset gateways if anything has changed
        //  first delete existing gateways
        //  then set new gateways
        //
        // NOTE: should we ping the new gateways here?
        //
        DhcpAddOrRemoveGateways(TRUE);

        _options._gatewayCount = param->_gatewayCount;
        memcpy(_options._gateways,
                param->_gateways,
                param->_gatewayCount * sizeof(CIpAddr));

        DhcpAddOrRemoveGateways(FALSE);
    }

    _options._dnsServerCount = param->_dnsServerCount;
    memcpy(_options._dnsServers,
           param->_dnsServers,
           param->_dnsServerCount * sizeof(CIpAddr));

#if DBG
    UINT i;

    TraceSz2(dhcp, "%d gateway%s configured", _options._gatewayCount, _options._gatewayCount == 1 ? "" : "s");
    for (i = 0; i < _options._gatewayCount; ++i)
        TraceSz1(dhcp, "  %s", _options._gateways[i].Str());
    TraceSz2(dhcp, "%d DNS server%s configured", _options._dnsServerCount, _options._dnsServerCount == 1 ? "" : "s");
    for (i = 0; i < _options._dnsServerCount; ++i)
        TraceSz1(dhcp, "  %s", _options._dnsServers[i].Str());
#endif

}

NTSTATUS CXnIp::DhcpProcessAck(CIpAddr yiaddr, CDhcpOptions* param)
{
    ICHECK(IP, UDPC|SDPC);

    TraceSz2(dhcp, "Received DHCPACK %s from %s", yiaddr.Str(), param->_dhcpServer.Str());

    Assert(_state == STATE_INIT_REBOOT ||
           _state == STATE_REQUESTING ||
           _state == STATE_RENEWING ||
           _state == STATE_REBINDING);

    // Simply sanity check of offered parameters
    if (!DhcpValidateOffer(yiaddr, param))
        return NETERR_PARAM;

    // Note: We're not checking for address conflicts
    // and just assume the offered address is valid.

    // If we're currently using a different address, give it up
    if ((_activeaddr != 0) &&
        (_activeaddr != yiaddr ||
         _activemask != param->_dhcpmask) ||
         ActiveAutonetAddr())
    {
        TraceSz1(dhcp, "Giving up old IP address %s", _activeaddr.Str());
        DhcpResetInterface();
    }

    // If we got a new address, set it down in the IP stack
    if (_activeaddr == 0)
    {
        IpSetAddress(yiaddr, param->_dhcpmask);
        _activeaddr = _dhcpaddr = yiaddr;
        _activemask = _options._dhcpmask = param->_dhcpmask;
        _flags |= FLAG_ACTIVE_DHCPADDR;
    }

    TraceSz2(dhcp, "Accepted IP address: %s from %s", yiaddr.Str(), param->_dhcpServer.Str());
    TraceSz3(dhcp, "Lease time: %d / %d / %d", param->_t1time, param->_t2time, param->_exptime);

    //
    // Set other option parameters
    //
    _initRetryCount = 0;
    DhcpUseOptionParams(param);

    // We're now in bound state.
    // Set timer to expire at T1 time.
    DhcpChangeState(STATE_BOUND);
    return NETERR_OK;
}

NTSTATUS CXnIp::DhcpProcessNak(CIpAddr dhcpServer)
{
    ICHECK(IP, UDPC|SDPC);

    TraceSz1(dhcp, "Received DHCPNAK from %s", dhcpServer.Str());

    Assert(_state == STATE_INIT_REBOOT ||
           _state == STATE_REQUESTING ||
           _state == STATE_RENEWING ||
           _state == STATE_REBINDING);

    // Barf if we got DHCPNAK from an unexpected server
    if (_state != STATE_INIT_REBOOT && dhcpServer != _options._dhcpServer)
    {
        TraceSz1(Warning, "Random DHCPNAK from %s?", dhcpServer.Str());
    }

    // If we're using an address, give it up
    if (_activeaddr) {
        DhcpResetInterface();
    }

    //
    // Go to INIT state to start over again
    // Send DHCPDISCOVER and ignore error
    //
    DhcpChangeState(STATE_INIT);
    return NETERR_OK;
}


// NOTE: we're assuming little-endian machine here.
#define EXTRACT_DWORD_OPTION(_result) \
        if (len != 4) goto exit; \
        if (_result == 0) { \
            _result = (((DWORD) buf[0] << 24) | \
                       ((DWORD) buf[1] << 16) | \
                       ((DWORD) buf[2] <<  8) | \
                       ((DWORD) buf[3]      )); \
        }

#define EXTRACT_IPADDR_OPTION(_result) \
        if (len != 4) goto exit; \
        if (_result == 0) _result = *((CIpAddr*) buf)

NTSTATUS CXnIp::DhcpParseOptionParams(CDhcpOptions* param, const BYTE* buf, UINT buflen, BYTE* overload)
{
    ICHECK(IP, UDPC|SDPC);

    while (buflen) {
        UINT tag, len;

        // Stop after seeing the 'end' option
        if ((tag = buf[0]) == DHCPOPT_END) break;

        // Skip the 'pad' option
        if (tag == DHCPOPT_PAD) {
            buf++; buflen--;
            continue;
        }

        // Is the option length field valid?
        if (buflen < 2 || buflen-2 < (len = buf[1])) goto exit;
        buf += 2; buflen -= 2;
    
        // Interpret option data
        switch (tag) {
        case DHCPOPT_DHCP_MESSAGE_TYPE:
            if (len != 1) goto exit;
            if (param->_recvMsgType == 0)
                param->_recvMsgType = *buf;
            break;

        case DHCPOPT_SERVERID:
            EXTRACT_IPADDR_OPTION(param->_dhcpServer);
            break;

        case DHCPOPT_SUBNET_MASK:
            EXTRACT_IPADDR_OPTION(param->_dhcpmask);
            break;

        case DHCPOPT_ROUTERS:
        case DHCPOPT_DNS_SERVERS:
        {
            UINT* pcount;
            CIpAddr* parray;
            UINT n;

            if (len == 0 || len % sizeof(CIpAddr) != 0) goto exit;
            if (tag == DHCPOPT_ROUTERS)
            {
                pcount = &param->_gatewayCount;
                parray = param->_gateways;
                n = MAX_DEFAULT_GATEWAYS * sizeof(CIpAddr);
            }
            else
            {
                pcount = &param->_dnsServerCount;
                parray = param->_dnsServers;
                n = MAX_DEFAULT_DNSSERVERS * sizeof(CIpAddr);
            }
        
            if (n > len) n = len;
            if (*pcount == 0) {
                *pcount = n / sizeof(CIpAddr);
                memcpy(parray, buf, n);
            }
            break;
        }

        case DHCPOPT_IPADDR_LEASE_TIME:
            EXTRACT_DWORD_OPTION(param->_exptime);
            break;

        case DHCPOPT_T1_INTERVAL:
            EXTRACT_DWORD_OPTION(param->_t1time);
            break;

        case DHCPOPT_T2_INTERVAL:
            EXTRACT_DWORD_OPTION(param->_t2time);
            break;

        case DHCPOPT_FIELD_OVERLOAD:
            if (len != 1) goto exit;
            if (overload && *overload == 0) *overload = *buf;
            break;
        }

        buf += len; buflen -= len;
    }

    return NETERR_OK;

exit:
    TraceSz(Warning, "Invalid option data");
    return NETERR_PARAM;
}

void CXnIp::DhcpSelectAutonetAddr()
{
    ICHECK(IP, UDPC|SDPC);

    CIpAddr addr;

    Assert(_state == STATE_SELECT_AUTOADDR);

    if (++_initRetryCount > cfgAutoIpMaxAttempts) {
        //
        // We tried too many autonet addresses without success.
        // Just give up.
        //
        _initRetryCount = 0;
        DhcpChangeState(STATE_NONE);

        // Signal that Xnet initialization was completed abnormally
        _flags = (_flags & ~FLAG_ACTIVE_ADDRMASK) | FLAG_ACTIVE_NOADDR;
        TraceSz(Warning, "Failed to pick an autonet address.");
        return;
    }

    // Generate a random autonet address
    addr = AUTONET_ADDRBASE + RandScaled(AUTONET_ADDRRANGE);
    _autonetaddr = addr = HTONL(addr);

    TraceSz1(dhcp, "Trying autonet address: %s", addr.Str());

    EnetXmitArp(addr);
    _retries = 0;
    DhcpComputeTimeout();
}

#if DBG

DefineTag(dhcpDump, 0);

//
// Whether to dump incoming and outgoing DHCP messages
//
VOID DhcpDumpByteArray(const BYTE* buf, UINT buflen)

/*++

Routine Description:

    Dump a byte array in hexdecimal format

Arguments:

    buf - Points to the data buffer
    buflen - Buffer length

Return Value:

    NONE

--*/

{
    for ( ; buflen--; buf++) {
        TraceSz1(dhcpDump, "+%02x+", *buf);
    }
}


VOID DhcpDumpOption(IN const BYTE* buf, IN UINT buflen, OUT BYTE* overload)

/*++

Routine Description:

    Dump DHCP options

Arguments:

    buf - Points to the option data buffer
    buflen - Data buffer length
    overload - Returns the option overload flags

Return Value:

    NONE

--*/

{
    static PCSTR dhcpMessageTypeStrs[] = {
        "***",
        "DHCPDISCOVER",
        "DHCPOFFER",
        "DHCPREQUEST",
        "DHCPDECLINE",
        "DHCPACK",
        "DHCPNAK",
        "DHCPRELEASE",
        "DHCPINFORM"
    };

    UINT tag, len, val;

    while (buflen && *buf != DHCPOPT_END) {
        // Special case for DHCPOPT_PAD - single byte
        if (*buf == DHCPOPT_PAD) {
            TraceSz(dhcpDump, "+    PAD");
            buflen--, buf++;
            continue;
        }

        // Check option length
        if (buflen < 2 || buflen-2 < (len = buf[1])) goto badopt;

        switch (tag = buf[0]) {
        case DHCPOPT_DHCP_MESSAGE_TYPE:
            if (len != 1) goto badopt;
            val = buf[2];
            if (val > 0 && val < dimensionof(dhcpMessageTypeStrs)) {
                TraceSz1(dhcpDump, "+    %s+", dhcpMessageTypeStrs[val]);
            } else {
                TraceSz1(dhcpDump, "+    Unknown DHCP message type: %d+", val);
            }
            break;

        case DHCPOPT_FIELD_OVERLOAD:
            if (len != 1) goto badopt;
            TraceSz1(dhcpDump, "+    OVERLOAD: %d+", buf[2]);
            if (overload)
                *overload = buf[2];
            else
                TraceSz(dhcpDump, "+ !!!+");
            break;

        case DHCPOPT_REQUESTED_CIpAddr:
        case DHCPOPT_SERVERID:
            if (len != 4) goto badopt;
            TraceSz5(dhcpDump, "+    %s %d.%d.%d.%d+",
                     (tag == DHCPOPT_SERVERID) ? "SERVERID" : "REQUEST IP ADDR",
                     buf[2], buf[3], buf[4], buf[5]);
            break;

        default:
            TraceSz1(dhcpDump, "+    %d - +", tag);
            DhcpDumpByteArray(buf+2, len);
            break;
        }

        TraceSz(dhcpDump, "+ ");
        buf += len+2;
        buflen -= len+2;
    }

    if (buflen == 0) {
        TraceSz(dhcpDump, "!!! Missing 'end' option");
    } else {
        do {
            buflen--, buf++;
        } while (buflen && *buf == 0);

        if (buflen != 0)
        {
            TraceSz(dhcpDump, "!!! Extra data after 'end' option");
        }
    }
    return;

badopt:
    TraceSz(dhcpDump, "!!! Bad DHCP option data");
}


void DhcpDumpMessage(DhcpMessage* msg, UINT msglen)

/*++

Routine Description:

    Dump the content of a DHCP message

Arguments:

    msg - Points to the DHCP message
    msglen - Message length

Return Value:

    NONE

--*/

{
    const BYTE* option;
    BYTE overload = 0;

    if (!Tag(dhcpDump))
        return;

    //
    // Sanity check
    //
    if (msglen < DHCPHDRLEN) {
        TraceSz1(dhcpDump, "!!! DHCP message too small: %d bytes", msglen);
        return;
    }

    //
    // Dump out fixed header information
    //
    TraceSz(dhcpDump, "DHCP message: ");
    if (msg->_op == BOOTREQUEST)
        TraceSz(dhcpDump, "BOOTREQUEST");
    else if (msg->_op == BOOTREPLY)
        TraceSz(dhcpDump, "BOOTREPLY");
    else
        TraceSz1(dhcpDump, "%d", msg->_op);

    TraceSz1(dhcpDump, "  htype: %d", msg->_htype);
    if (msg->_hlen > sizeof(msg->_chaddr)) {
        TraceSz1(dhcpDump, "!!! Invalid hardware address length: %d\n", msg->_hlen);
    } else if (msg->_hlen) {
        TraceSz(dhcpDump, "  chaddr: +");
        DhcpDumpByteArray(msg->_chaddr, msg->_hlen);
        TraceSz(dhcpDump, "+ ");
    }

    TraceSz1(dhcpDump, "  hops: %d", msg->_hops);
    TraceSz1(dhcpDump, "  xid: 0x%08x", NTOHL(msg->_xid));
    TraceSz1(dhcpDump, "  secs: %d", NTOHS(msg->_secs));
    TraceSz1(dhcpDump, "  flags: 0x%04x", NTOHS(msg->_flags));
    TraceSz1(dhcpDump, "  ciaddr: %s", msg->_ciaddr.Str());
    TraceSz1(dhcpDump, "  yiaddr: %s", msg->_yiaddr.Str());
    TraceSz1(dhcpDump, "  siaddr: %s", msg->_siaddr.Str());
    TraceSz1(dhcpDump, "  giaddr: %s", msg->_giaddr.Str());

    //
    // Dump options
    //
    option = msg->_options;
    msglen -= DHCPHDRLEN;

    if (msglen < sizeof(DhcpMagicCookie) ||
        memcmp(option, DhcpMagicCookie, sizeof(DhcpMagicCookie)) != 0) {
        TraceSz(dhcpDump, "!!! Invalid DHCP magic cookie");
        return;
    }
    msglen -= sizeof(DhcpMagicCookie);
    option += sizeof(DhcpMagicCookie);

    TraceSz(dhcpDump, "  options:");
    DhcpDumpOption(option, msglen, &overload);

    if (overload & 1) {
        TraceSz(dhcpDump, "  overload options (file):");
        DhcpDumpOption(msg->_file, sizeof(msg->_file), NULL);
    }

    if (overload & 2) {
        TraceSz(dhcpDump, "  overload options (sname):");
        DhcpDumpOption(msg->_sname, sizeof(msg->_sname), NULL);
    }
}

#endif // DBG

void CXnIp::IpRecvArp(CEnetAddr * pea)
{
    ICHECK(IP, UDPC|SDPC);
    DhcpNotifyAddressConflict();
}

#endif // XNET_FEATURE_DHCP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\halx.h ===
// ---------------------------------------------------------------------------------------
// halx.h
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef _HALX_H_
#define _HALX_H_

#ifdef XNET_FEATURE_XBDM_SERVER
#include <dm.h>
#endif

// ---------------------------------------------------------------------------------------
// CXnHal
// ---------------------------------------------------------------------------------------

class CXnHal : public CXnVoid
{
    // Definitions -----------------------------------------------------------------------

    #define EvtInit(prke)               KeInitializeEvent(prke, NotificationEvent, FALSE)
    #define EvtTerm(prke)
    #define EvtSet(prke, pri)           KeSetEvent((prke), (pri), FALSE)
    #define EvtClear(prke)              KeClearEvent(prke)
    #define EvtRef(ke)                  &(ke)
    #define EvtDereference(prke)        ObDereferenceObject(prke)

#ifdef XNET_FEATURE_ASSERT
    #define USER                        0x0001
    #define UDPC                        0x0002
    #define SDPC                        0x0004
    #define TCHECK_(pXnBase, lev)       AssertSz((pXnBase)->HalThreadCheck(lev), "Not allowed to execute this code at the current level")
#else
    #define TCHECK_(pXnBase, lev)
#endif
    #define TCHECK(lev)                 TCHECK_(this, lev)

#ifdef XNET_FEATURE_ASSERT
    #define ICHECK_(pXnBase, lay, lev)  AssertSz((pXnBase)->TestInitFlag(INITF_##lay), "The " #lay " layer is not initialized"); \
                                        AssertSz(!(pXnBase)->TestInitFlag(INITF_##lay##_TERM), "The " #lay " layer has been terminated."); \
                                        TCHECK_(pXnBase, lev)
#else
    #define ICHECK_(pXnBase, lay, lev)
#endif
    #define ICHECK(lay, lev)            ICHECK_(this, lay, lev)

    #define HAL_DECLARE_NEW_DELETE(class) \
       INLINE void * operator new(size_t cb) { return(HalAllocZ(cb, PTAG_##class)); } \
       INLINE void operator delete(void * pv) { HalFree(pv); } \
       INLINE class() {} \
       INLINE ~class() {}

    // External --------------------------------------------------------------------------

public:

    INLINE PRKEVENT EvtFromHandle(HANDLE hEvent)
    {
        PRKEVENT kEvent;
        return(hEvent && ObReferenceObjectByHandle(hEvent, ExEventObjectType, (VOID**)&kEvent) == STATUS_SUCCESS ? kEvent : NULL);
    }

    INLINE BOOL EvtWait(PRKEVENT prke, UINT timeout)
    {
        LARGE_INTEGER waittime;
        waittime.QuadPart = Int32x32To64(timeout, -10000);
        return(KeWaitForSingleObject(prke, UserRequest, UserMode, FALSE, timeout ? &waittime : NULL) == STATUS_SUCCESS);
    }

#ifdef XNET_FEATURE_ASSERT
    BOOL                HalThreadCheck(UINT uiLevel);
    KIRQL               KeRaiseIrqlToDpcLevel();
    void                KeLowerIrql(KIRQL kirql);
#endif

    void                SetInitFlag(DWORD dwFlag);
    INLINE BOOL         TestInitFlag(DWORD dwFlag)      { return(!!(_dwInitFlags & dwFlag)); }

    UINT                HalRandGather(BYTE * pb, UINT cb);
    void                HalRandPersist(BYTE * pb, UINT cb);

protected:

    NTSTATUS            HalInit(XNetInitParams * pxnip) { return(NETERR_OK); }
    INLINE void         HalStart()  {};
    void                HalStop()   {};
    void                HalTerm()   {};

    // Data ------------------------------------------------------------------------------

    DWORD                       _dwInitFlags;

#ifdef XNET_FEATURE_ASSERT
    BOOL                        _fUserDpc;              // TRUE when user raised IRQL to DPC
#endif

};

// ---------------------------------------------------------------------------------------
// HAL System Memory
// ---------------------------------------------------------------------------------------

INLINE void * HalAlloc(size_t size, ULONG tag)
{
    return(ExAllocatePoolWithTag(size, tag));
}

INLINE void * HalAllocZ(size_t size, ULONG tag)
{
    void * pv = HalAlloc(size, tag);

    if (pv)
    {
        memset(pv, 0, size);
    }

    return(pv);
}

INLINE void HalFree(void * pv)
{
    if (pv)
    {
        ExFreePool(pv);
    }
}

// ---------------------------------------------------------------------------------------
// HAL Dma Memory
// ---------------------------------------------------------------------------------------

INLINE void * HalDmaAlloc(UINT cb, ULONG ulMax = MAXULONG_PTR)
{
    return(MmAllocateContiguousMemoryEx(cb, 0, ulMax, 0, PAGE_READWRITE));
}

INLINE void HalDmaFree(void * pv)
{
    MmFreeContiguousMemory(pv);
}

// ---------------------------------------------------------------------------------------
// CRaiseToDpc
// ---------------------------------------------------------------------------------------

class CRaiseToDpc
{

public:

    INLINE CRaiseToDpc(CXnHal * pXnHal)
    {
#ifdef XNET_FEATURE_ASSERT
        _pXnHal = pXnHal;
        _irql = pXnHal->KeRaiseIrqlToDpcLevel();
#else
        _irql = KeRaiseIrqlToDpcLevel();
#endif
    }

    INLINE ~CRaiseToDpc()
    {
#ifdef XNET_FEATURE_ASSERT
        _pXnHal->KeLowerIrql(_irql);
#else
        KeLowerIrql(_irql);
#endif
    }

private:

#ifdef XNET_FEATURE_ASSERT
    CXnHal * _pXnHal;
#endif
    KIRQL    _irql;
};

#define RaiseToDpc()  CRaiseToDpc __RaiseToDpc__(this)

// ---------------------------------------------------------------------------------------
// Miscellaneous
// ---------------------------------------------------------------------------------------

void DbgPrintToKd(const char * psz);
void HalQueryTsc(LARGE_INTEGER * pli);

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\ip.cpp ===
// ---------------------------------------------------------------------------------------
// ip.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(secStat, 0);
DefineTag(tcpRetrans, 0);
DefineTag(pktPreAuth, 0);
DefineTag(keyExDrop, 0);

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

#define ESPUDP_REPLAY_WINDOW        1024                // How far ahead sender can get

// ---------------------------------------------------------------------------------------
// CXnIp External
// ---------------------------------------------------------------------------------------

NTSTATUS CXnIp::IpInit(XNetInitParams * pxnip)
{
    TCHECK(USER);

    NTSTATUS status = EnetInit(pxnip);
    if (!NT_SUCCESS(status))
        return(status);

    SetInitFlag(INITF_IP);

    status = RouteInit();
    if (!NT_SUCCESS(status))
        return(status);

    status = DhcpInit();
    if (!NT_SUCCESS(status))
        return(status);

    _pKeyReg = (CKeyReg *)SysAllocZ(cfgKeyRegMax * sizeof(CKeyReg), PTAG_CKeyReg);

    if (_pKeyReg == NULL)
    {
        TraceSz(Warning, "IpInit - Out of memory allocating CKeyReg vector");
        return(WSAENOBUFS);
    }

    _pSecReg = (CSecReg *)SysAllocZ(cfgSecRegMax * sizeof(CSecReg), PTAG_CSecReg);

    if (_pSecReg == NULL)
    {
        TraceSz(Warning, "IpInit - Out of memory allocating CSecReg vector");
        return(WSAENOBUFS);
    }

#if defined(XNET_FEATURE_XBOX) && !defined(XNET_FEATURE_XBDM_SERVER)

    // Generate the SHA and 3DES keys for LAN broadcast.  We do this by concatenating two digests:
    //
    //      HMAC(HMAC(ROM-LAN-KEY, CERT-LAN-KEY), 0 | CERT-LAN-KEY) |
    //      HMAC(HMAC(ROM-LAN-KEY, CERT-LAN-KEY), 1 | CERT-LAN-KEY)
    //
    // This produces 40 bytes of digest.  The first 16 bytes are used as a SHA key, and the
    // remaining 24 bytes as the 3DES key.

    BYTE    abCert[1 + XBEIMAGE_CERTIFICATE_KEY_LENGTH];
    BYTE    abHash[XC_SERVICE_DIGEST_SIZE * 2];

    memcpy(&abCert[1], XeImageHeader()->Certificate->LANKey, XBEIMAGE_CERTIFICATE_KEY_LENGTH);

    abCert[0] = 0;
    XcHMAC((BYTE *)*XboxLANKey, XBOX_KEY_LENGTH, abCert, sizeof(abCert), NULL, 0, &abHash[0]);
    abCert[0] = 1;
    XcHMAC((BYTE *)*XboxLANKey, XBOX_KEY_LENGTH, abCert, sizeof(abCert), NULL, 0, &abHash[XC_SERVICE_DIGEST_SIZE]);

    Assert(sizeof(abHash) == sizeof(_abKeyShaLan) + sizeof(_abKeyDesLan));
    memcpy(_abKeyShaLan, &abHash[0], sizeof(_abKeyShaLan));
    memcpy(_abKeyDesLan, &abHash[sizeof(_abKeyShaLan)], sizeof(_abKeyDesLan));
    XcDESKeyParity(_abKeyDesLan, sizeof(_abKeyDesLan));

#endif

    Rand((BYTE *)&_lNextDgramId, sizeof(_lNextDgramId));
    Rand((BYTE *)&_wSecRegUniq, sizeof(_wSecRegUniq));
    KeQuerySystemTime(&_liTime);

    _cSecRegProbeDenom = cfgSecRegVisitInSeconds * TICKS_PER_SECOND;

#if defined(XNET_FEATURE_SG) && defined(XNET_FEATURE_INSECURE)
    Rand(_abDhXNull, sizeof(_abDhXNull));
    XcModExp((DWORD *)_abDhGXNull, (DWORD *)g_abOakleyGroup1Base,
             (DWORD *)_abDhXNull, (DWORD *)g_abOakleyGroup1Mod, CBDHG1 / sizeof(DWORD));
#endif

    return(NETERR_OK);
}

void CXnIp::IpStop()
{
    TCHECK(UDPC);

    if (TestInitFlag(INITF_IP) && !TestInitFlag(INITF_IP_STOP))
    {
        SecRegShutdown(FALSE);
        NicFlush();
        SetInitFlag(INITF_IP_STOP);
    }

    EnetStop();
}

void CXnIp::IpTerm()
{
    TCHECK(UDPC);

    IpStop();

    if (TestInitFlag(INITF_IP))
    {
        DhcpTerm();
        RouteTerm();
        FragTerm();

        if (_pKeyReg)
        {
            CKeyReg * pKeyReg = &_pKeyReg[_cKeyReg - 1];
            UINT      cKeyReg = _cKeyReg;

            for (; cKeyReg > 0; --pKeyReg, --cKeyReg)
            {
                TraceSz1(Warning, "IpTerm - XNKID %s was not unregistered before shutdown",
                         HexStr(pKeyReg->_xnkid.ab, sizeof(pKeyReg->_xnkid.ab)));
                IpUnregisterKey(&pKeyReg->_xnkid);
            }

            SysFree(_pKeyReg);
        }

        if (_pSecReg)
        {
            CSecReg * pSecReg = _pSecReg;
            UINT      cSecReg = cfgSecRegMax;

            for (; cSecReg > 0; ++pSecReg, --cSecReg)
            {
                if (pSecReg->_dwSpiRecv)
                {
                    SecRegFree(pSecReg);
                }
            }

            SysFree(_pSecReg);
        }
    }

    SetInitFlag(INITF_IP_TERM);

    EnetTerm();
}

// ---------------------------------------------------------------------------------------
// IpConfig
// ---------------------------------------------------------------------------------------

INT CXnIp::IpConfig(const XNetConfigParams * pxncp, DWORD dwFlags)
{
    ICHECK(IP, USER|UDPC);

    RaiseToDpc();

    INT err = NicConfig(pxncp);

#ifdef XNET_FEATURE_DHCP
    if (err == 0)
    {
        err = DhcpConfig(pxncp);
    }
#endif

    return(err);
}

INT CXnIp::IpGetConfigStatus(XNetConfigStatus * pxncs)
{
    ICHECK(IP, USER);
    TraceSz(Warning, "IpGetConfigStatus not yet implemented");
    memset(pxncs, 0, sizeof(XNetConfigStatus));
    pxncs->dwFlags = XNET_STATUS_PENDING;
    return(0);
}

// ---------------------------------------------------------------------------------------
// Utilities
// ---------------------------------------------------------------------------------------

void CXnIp::IpSetAddress(CIpAddr ipa, CIpAddr ipaMask)
{
    ICHECK(IP, USER|UDPC|SDPC);

    RaiseToDpc();

    if (ipa == 0)
    {
        ipaMask = 0;
    }
    else if (!ipa.IsValidUnicast())
    {
        TraceSz4(Warning, "IpSetAddress - Cannot set IP address to %s (reason %d/%d/%d)",
                 ipa.Str, ipa.IsBroadcast(), ipa.IsMulticast(), ipa.IsLoopback());
        ipa = 0;
        ipaMask = 0;
    }
    else if (ipaMask == 0 || !ipaMask.IsValidMask())
    {
        ipaMask = ipa.DefaultMask();
    }

    _ipa        = ipa;
    _ipaMask    = ipaMask;
    _ipaSubnet  = (ipa & ipaMask);

    if (ipa)
    {
#if DBG
        TraceSz(Warning, "+\n-------------------------------------------------------------------------");
        #ifdef XNET_FEATURE_XBDM_SERVER
        TraceSz3(Warning, "+XBOX DEBUG IP: %s / %s [%s]", ipa.Str(), ipaMask.Str(), _ea.Str());
        #else
        TraceSz3(Warning, "+XBOX TITLE IP: %s / %s [%s]", ipa.Str(), ipaMask.Str(), _ea.Str());
        #endif
        TraceSz(Warning, "+-------------------------------------------------------------------------\n");
#endif

        // Add a route for the local subnet

        RouteAdd(_ipaSubnet, _ipaMask, _ipa, RTEF_LOCAL, RTE_DEFAULT_METRIC);
    }
    else
    {
        // We've lost our subnet so clear the route list

        RouteListOrphan();
    }
}

// ---------------------------------------------------------------------------------------
// CXnIp::IpRecv
// ---------------------------------------------------------------------------------------

void CXnIp::IpRecv(CPacket * ppkt)
{
    ICHECK(IP, UDPC|SDPC);

    Assert(ppkt->IsIp());

    CIpHdr *        pIpHdr;
    CIpAddr         ipaDst;
    CIpAddr         ipaSrc;
    UINT            cbHdrLen;
    UINT            cbLen;

    if (ppkt->GetCb() < sizeof(CIpHdr))
    {
        TraceSz(pktWarn, "[DISCARD] Ethernet frame smaller than IP header");
        return;
    }

    pIpHdr = ppkt->GetIpHdr();
    cbHdrLen = pIpHdr->_bVerHdr;
    cbLen = pIpHdr->GetLen();

    if ((cbHdrLen & 0xF0) != 0x40)
    {
        TraceSz1(pktWarn, "[DISCARD] IP version (%d) is not IPv4", cbHdrLen >> 4);
        return;
    }

    cbHdrLen = (cbHdrLen & 0x0F) << 2;

    if (cbHdrLen < sizeof(CIpHdr) || cbHdrLen > cbLen || cbLen > ppkt->GetCb())
    {
        TraceSz3(pktWarn, "[DISCARD] IP header length is bad (%d,%d,%d)",
                cbHdrLen < sizeof(CIpHdr), cbHdrLen > cbLen, cbLen > ppkt->GetCb());
        return;
    }

    // Change the size of the packet to match the size specified in the IP header.  An
    // ethernet frame, especially a small one, can sometimes be longer than the IP
    // packet length.  We've already checked above that the ethernet frame is at least
    // as big as cbLen.

    ppkt->SetCb(cbLen);

    ipaDst = pIpHdr->_ipaDst;
    ipaSrc = pIpHdr->_ipaSrc;

    if (cbHdrLen > sizeof(CIpHdr))
    {
        TraceSz9(pktRecv, "[IP %s %s (%d %d %04X %04X) %d]{%d}[%d]",
                 ipaDst.Str(), ipaSrc.Str(), pIpHdr->_bTos, pIpHdr->_bTtl,
                 NTOHS(pIpHdr->_wId), NTOHS(pIpHdr->_wFragOff), pIpHdr->_bProtocol,
                 cbHdrLen - sizeof(CIpHdr), cbLen - cbHdrLen);
        TraceSz(pktRecv, "IP header options are not supported.  Continuing as if no options.");
        ppkt->SetHdrOptLen(cbHdrLen - sizeof(CIpHdr));
    }
    else
    {
        TraceSz8(pktRecv, "[IP %s %s (%d %d %04X %04X) %d][%d]",
                 ipaDst.Str(), ipaSrc.Str(), pIpHdr->_bTos, pIpHdr->_bTtl,
                 NTOHS(pIpHdr->_wId), NTOHS(pIpHdr->_wFragOff), pIpHdr->_bProtocol,
                 cbLen - cbHdrLen);
    }

    if (tcpipxsum(0, pIpHdr, cbHdrLen) != 0xffff)
    {
        TraceSz(pktWarn, "[DISCARD] IP header checksum failed");
        return;
    }

    Assert(!_ipa.IsBroadcast());
    Assert(!_ipa.IsMulticast());
    Assert(!_ipa.IsLoopback());

    if (ipaDst == 0)
    {
        TraceSz(pktWarn, "[DISCARD] Destination address is zero");
        return;
    }

    if (ppkt->TestFlags(PKTF_RECV_BROADCAST) && !ipaDst.IsBroadcast())
    {
        TraceSz(pktRecv, "[DISCARD] IP-level unicast via link-level broadcast");
        return;
    }

    if (ipaSrc.IsBroadcast() || (ipaSrc == 0 && !IsGateway(0)))
    {
        TraceSz1(pktRecv, "[DISCARD] Source address is %s", ipaSrc == 0 ? "zero" : "broadcast");
        return;
    }

    if (!ppkt->TestFlags(PKTF_RECV_LOOPBACK))
    {
        if (ipaDst.IsLoopback() || ipaSrc.IsLoopback() || ipaSrc == _ipa)
        {
            TraceSz3(pktRecv, "[DISCARD] IP loopback addresses received via link-level (%d,%d,%d)",
                    ipaDst.IsLoopback(), ipaSrc.IsLoopback(), ipaSrc == _ipa);
            return;
        }

        if (!ppkt->TestFlags(PKTF_RECV_BROADCAST) && !ipaDst.IsBroadcast() && !IsGateway(0))
        {
            if (_ipa != ipaDst && (ipaDst != IPADDR_SECURE_DEFAULT || pIpHdr->_bProtocol != IPPROTOCOL_UDP))
            {
            #if DBG
                BYTE bProtocol = pIpHdr->_bProtocol;
                CUdpHdr * pUdpHdr = (bProtocol == IPPROTOCOL_UDP || bProtocol == IPPROTOCOL_TCP) ? (CUdpHdr *)(pIpHdr + 1) : NULL;
                TraceSz6(pktWarn, "[DISCARD] %s packet from %s:%d to %s:%d but my IP is %s",
                         bProtocol == IPPROTOCOL_UDP ? "UDP" : bProtocol == IPPROTOCOL_TCP ? "TCP " : "IP",
                         ipaSrc.Str(), pUdpHdr ? NTOHS(pUdpHdr->_ipportSrc) : bProtocol,
                         ipaDst.Str(), pUdpHdr ? NTOHS(pUdpHdr->_ipportDst) : bProtocol,
                         _ipa ? _ipa.Str() : "not yet acquired");
            #endif
                return;
            }
        }
    }

    if (pIpHdr->_wFragOff & HTONS(MORE_FRAGMENTS|FRAGOFFSET_MASK))
    {
#ifdef XNET_FEATURE_FRAG
    #ifdef XNET_FEATURE_FRAG_LOOPBACK
        if (ppkt->TestFlags(PKTF_RECV_BROADCAST))
    #else
        if (ppkt->TestFlags(PKTF_RECV_BROADCAST|PKTF_RECV_LOOPBACK))
    #endif
        {
            TraceSz1(pktWarn, "[DISCARD] Fragmented packet received via %s",
                    ppkt->TestFlags(PKTF_RECV_BROADCAST) ? "broadcast" : "loopback");
            return;
        }
        else
        {
            FragRecv(ppkt, pIpHdr, cbHdrLen, cbLen);
            return;
        }
#else
        TraceSz(pktWarn, "[DISCARD] No support for fragmented packets");
        return;
#endif
    }

    BYTE * pb = (BYTE *)pIpHdr + cbHdrLen;
    cbLen -= cbHdrLen;

    if (pIpHdr->_bProtocol == IPPROTOCOL_UDP)
    {
        ppkt->SetType(PKTF_TYPE_UDP);
        IpRecvUdp(ppkt, pIpHdr, (CUdpHdr *)pb, cbLen);
        return;
    }

    if (pIpHdr->_bProtocol == IPPROTOCOL_TCP)
    {
        ppkt->SetType(PKTF_TYPE_TCP);
        IpRecvTcp(ppkt, pIpHdr, (CTcpHdr *)pb, cbLen);
        return;
    }

    #ifdef XNET_FEATURE_ICMP

    if (pIpHdr->_bProtocol == IPPROTOCOL_ICMP)
    {
        IcmpRecv(ppkt, pIpHdr, pb, cbLen);
        return;
    }

    #endif

    TraceSz1(pktWarn, "[DISCARD] No support for protocol %d", pIpHdr->_bProtocol);
    return;
}

void CXnIp::IpRecvUdp(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    ICHECK(IP, UDPC|SDPC);

    Assert(ppkt->IsUdp());

    if (    cbLen < sizeof(CUdpHdr)
        ||  pUdpHdr->GetLen() != cbLen
        ||  pUdpHdr->_ipportDst == 0
        ||  pUdpHdr->_ipportSrc == 0)
    {
        TraceSz4(pktWarn, "[DISCARD] UDP header is invalid (%d,%d,%d,%d)",
                 cbLen < sizeof(CUdpHdr), pUdpHdr->GetLen() != cbLen,
                 pUdpHdr->_ipportDst == 0, pUdpHdr->_ipportSrc == 0);
        return;
    }

    if (!ppkt->IsEsp())
    {
        if (pUdpHdr->_ipportDst == ESPUDP_CLIENT_PORT && !IsGateway(pUdpHdr->_ipportDst))
        {
            IpRecvEsp(ppkt, pIpHdr, (CEspHdr *)pUdpHdr, cbLen);
            return;
        }

        if (pIpHdr->_ipaDst == IPADDR_SECURE_DEFAULT)
        {
            TraceSz5(pktWarn, "[DISCARD] UDP packet from %s:%d to %s:%d but my IP is %s",
                     pIpHdr->_ipaSrc.Str(), NTOHS(pUdpHdr->_ipportSrc),
                     pIpHdr->_ipaDst.Str(), NTOHS(pUdpHdr->_ipportDst),
                     _ipa ? _ipa.Str() : "not yet acquired");
            return;
        }

        if (!ppkt->TestFlags(PKTF_RECV_LOOPBACK))
        {
            if (pUdpHdr->_wChecksum)
            {
                CPseudoHeader ph;
                ph._ipaSrc    = pIpHdr->_ipaSrc;
                ph._ipaDst    = pIpHdr->_ipaDst;
                ph._bZero     = 0;
                ph._bProtocol = IPPROTOCOL_UDP;
                ph._wLen      = pUdpHdr->_wLen;

                Assert(cbLen == NTOHS(ph._wLen));

                if (tcpipxsum(tcpipxsum(0, &ph, sizeof(CPseudoHeader)), pUdpHdr, cbLen) != 0xFFFF)
                {
                    TraceSz(pktWarn, "[DISCARD] UDP header checksum failed");
                    return;
                }
            }

#ifdef XNET_FEATURE_DHCP
            if (pUdpHdr->_ipportDst == DHCP_CLIENT_PORT)
            {
                TraceSz(pktRecv, "[DHCPRECV]");
                DhcpRecv(ppkt, pUdpHdr, cbLen - sizeof(CUdpHdr));
                return;
            }
#endif

#ifdef XNET_FEATURE_DNS
            if (pUdpHdr->_ipportDst == DNS_CLIENT_PORT && !IsGateway(pUdpHdr->_ipportDst))
            {
                TraceSz(pktRecv, "[DNSRECV]");
                IpRecvDns(ppkt, pUdpHdr, cbLen - sizeof(CUdpHdr));
                return;
            }
#endif

            // This is an insecure packet.  If we are compiled for online, some sockets
            // can accept insecure packets, so we'll pass them up to UpdRecv and let it
            // decide.  Otherwise, unless we are compiled insecure and the client has
            // requested bypassing security, the insecure UDP packet stops right here.
            
#if !defined(XNET_FEATURE_ONLINE)
    #ifdef XNET_FEATURE_INSECURE
            if (!(cfgFlags & XNET_STARTUP_BYPASS_SECURITY))
    #endif
            {
                TraceSz3(pktWarn, "[DISCARD] Insecure UDP packet on port %d from %s:%d",
                         NTOHS(pUdpHdr->_ipportDst), pIpHdr->_ipaSrc.Str(),
                         NTOHS(pUdpHdr->_ipportSrc));
                return;
            }
#endif
        }
    }

    UdpRecv(ppkt, pIpHdr, pUdpHdr, cbLen - sizeof(CUdpHdr));
}

void CXnIp::IpRecvTcp(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbLen)
{
    ICHECK(IP, UDPC|SDPC);

    Assert(ppkt->IsTcp());

    if (ppkt->TestFlags(PKTF_RECV_BROADCAST) || pIpHdr->_ipaDst.IsBroadcast())
    {
        TraceSz(pktRecv, "[DISCARD] TCP packet with broadcast destination address");
        return;
    }

    UINT cbHdrLen;

    if (    cbLen < sizeof(CTcpHdr)
        || (cbHdrLen = pTcpHdr->GetHdrLen()) < sizeof(CTcpHdr)
        ||  cbHdrLen > cbLen
        ||  pTcpHdr->_ipportDst == 0
        ||  pTcpHdr->_ipportSrc == 0)
    {
        TraceSz5(pktWarn, "[DISCARD] TCP header is invalid (%d,%d,%d,%d,%d)",
                 cbLen < sizeof(CTcpHdr), cbHdrLen < sizeof(CTcpHdr),
                 cbHdrLen > cbLen, pTcpHdr->_ipportDst == 0, pTcpHdr->_ipportSrc == 0);
        return;
    }

    if (!ppkt->TestFlags(PKTF_TYPE_ESP|PKTF_RECV_LOOPBACK))
    {
        CPseudoHeader ph;
        ph._ipaSrc    = pIpHdr->_ipaSrc;
        ph._ipaDst    = pIpHdr->_ipaDst;
        ph._bZero     = 0;
        ph._bProtocol = IPPROTOCOL_TCP;
        ph._wLen      = HTONS((WORD)cbLen);

        if (tcpipxsum(tcpipxsum(0, &ph, sizeof(CPseudoHeader)), pTcpHdr, cbLen) != 0xFFFF)
        {
            TraceSz(pktWarn, "[DISCARD] TCP header checksum failed");
            return;
        }

        // This is an insecure packet.  If we are compiled for online, some sockets
        // can accept insecure packets, so we'll pass them up to TcpRecv and let it
        // decide.  Otherwise, unless we are compiled insecure and the client has
        // requested bypassing security, the insecure TCP packet stops right here.
            
#if !defined(XNET_FEATURE_ONLINE)
    #ifdef XNET_FEATURE_INSECURE
        if (!(cfgFlags & XNET_STARTUP_BYPASS_SECURITY))
    #endif
        {
            TraceSz3(pktWarn, "[DISCARD] Insecure TCP packet on port %d from %s:%d",
                     NTOHS(pTcpHdr->_ipportDst), pIpHdr->_ipaSrc.Str(), NTOHS(pTcpHdr->_ipportSrc));
            return;
        }
#endif
    }

    TcpRecv(ppkt, pIpHdr, pTcpHdr, cbHdrLen, cbLen - cbHdrLen);
}

void CXnIp::IpRecvEsp(CPacket * ppkt, CIpHdr * pIpHdr, CEspHdr * pEspHdr, UINT cbLen)
{
    ICHECK(IP, UDPC|SDPC);

    Assert(ppkt->IsUdp());
    Assert(pEspHdr->_ipportDst == ESPUDP_CLIENT_PORT);

    if (cbLen < sizeof(CEspHdr))
    {
        TraceSz(pktWarn, "[DISCARD] ESPUDP header length exceeds packet length");
        return;
    }

    if (pEspHdr->_dwSpi == 0)
    {
        if (ppkt->TestFlags(PKTF_RECV_BROADCAST|PKTF_RECV_LOOPBACK))
        {
            TraceSz1(pktWarn, "[DISCARD] KeyEx packet received via %s",
                     ppkt->TestFlags(PKTF_RECV_BROADCAST) ? "broadcast" : "loopback");
            return;
        }

        IpRecvKeyEx(ppkt, pIpHdr->_ipaSrc, pEspHdr->_ipportSrc,
                    (CKeyExHdr *)&pEspHdr->_dwSeq, cbLen - offsetof(CEspHdr, _dwSeq));
        return;
    }

    if ((cbLen & 3) != 0)
    {
        TraceSz1(pktWarn, "[DISCARD] ESPUDP packet is not four-byte aligned (%d)", cbLen);
        return;
    }

    ppkt->SetType(PKTF_TYPE_IP|PKTF_TYPE_ESP);

    CSecReg *   pSecReg     = NULL;
    CIpAddr     ipa         = pEspHdr->_dwSpi;
    BOOL        fBroadcast  = ipa.IsBroadcast();
    DWORD       dwSeq       = NTOHL(pEspHdr->_dwSeq);
    DWORD       dwBit       = 0;
    CEspTail *  pEspTail    = ppkt->GetEspTail();
    BYTE *      pb          = (BYTE *)(pEspHdr + 1);
    BYTE *      pbKeySha;
    UINT        cbKeySha;
    BYTE *      pbKeyDes;
    UINT        cbKeyDes;

    if (!!fBroadcast != !!pIpHdr->_ipaDst.IsBroadcast())
    {
        TraceSz2(pktWarn, "[DISCARD] ESPUDP packet has dwSpi %08X but ipaDst %s",
                 pEspHdr->_dwSpi, pIpHdr->_ipaDst.Str());
        return;
    }

    if (fBroadcast)
    {
        pbKeySha = _abKeyShaLan;
        cbKeySha = sizeof(_abKeyShaLan);
        pbKeyDes = _abKeyDesLan;
        cbKeyDes = sizeof(_abKeyDesLan);

        if (dwSeq != 0xFFFFFFFF)
        {
            TraceSz1(pktWarn, "[DISCARD] ESPUDP broadcast packet has invalid dwSeq (%08lX)", dwSeq);
            return;
        }
    }
    else
    {
        pSecReg = SecRegLookup(ipa);

        if (pSecReg == NULL)
        {
            TraceSz1(pktWarn, "[DISCARD] Secure packet sent to unregistered address (%s)",
                     ipa.Str());
            return;
        }

        if (!pSecReg->IsRecvReady())
        {
            TraceSz1(pktWarn, "[DISCARD] Secure packet to %s before key exchange is complete",
                     ipa.Str());
            return;
        }

        pbKeySha = pSecReg->_abKeyShaRecv;
        cbKeySha = sizeof(pSecReg->_abKeyShaRecv);
        pbKeyDes = pSecReg->_abKeyDesRecv;
        cbKeyDes = pSecReg->_cbKeyDesRecv;

        if (dwSeq < pSecReg->_dwSeqRecv)
        {
            TraceSz3(pktWarn, "[DISCARD] Secure packet to %s has dwSeq %d less than window base %d",
                     ipa.Str(), dwSeq, pSecReg->_dwSeqRecv);
            return;
        }

        dwBit = dwSeq - pSecReg->_dwSeqRecv;

        if (dwBit > ESPUDP_REPLAY_WINDOW)
        {
            TraceSz4(pktWarn, "[DISCARD] Secure packet to %s has dwSeq %d outside window (%d to %d)",
                     ipa.Str(), dwSeq, pSecReg->_dwSeqRecv, pSecReg->_dwSeqRecv + ESPUDP_REPLAY_WINDOW);
            return;
        }

        if (dwBit < 32 && (pSecReg->_dwSeqMask & (1 << dwBit)))
        {
            TraceSz2(pktWarn, "[DISCARD] Secure packet to %s has dwSeq %d which is replayed",
                     ipa.Str(), dwSeq);
            return;
        }
    }

    if (cbKeyDes)
    {
        ppkt->SetFlags(PKTF_CRYPT);

        if (cbLen < sizeof(CEspHdr) + ROUNDUP8(XC_SERVICE_DES_BLOCKLEN + offsetof(CEspTail, _abHash)) + sizeof(pEspTail->_abHash))
        {
            TraceSz1(pktWarn, "[DISCARD] ESPUDP crypt packet is too small (%d)", cbLen);
            return;
        }
    }
    else
    {
        if (cbLen < sizeof(CEspHdr) + ROUNDUP4(sizeof(CEspTail)))
        {
            TraceSz1(pktWarn, "[DISCARD] ESPUDP auth packet is too small (%d)", cbLen);
            return;
        }
    }

    cbLen -= sizeof(CEspHdr) + sizeof(pEspTail->_abHash);

    TraceSz4(pktRecv, "[ESP %s #%d]%s[%d][ESPT]",
             ipa.Str(), dwSeq, ppkt->TestFlags(PKTF_CRYPT) ? "[IV]" : "",
             cbLen - (ppkt->TestFlags(PKTF_CRYPT) ? XC_SERVICE_DES_BLOCKLEN : 0) - offsetof(CEspTail, _abHash));

    // Authenicate the packet from the [ESP] header to just before the _abHash in [ESPT]

    BYTE abHash[XC_SERVICE_DIGEST_SIZE];
    Assert(sizeof(pEspTail->_abHash) <= sizeof(abHash));
    XcHMAC(pbKeySha, cbKeySha, (BYTE *)&pEspHdr->_dwSpi, (sizeof(CEspHdr) - sizeof(CUdpHdr)) + cbLen,
           NULL, 0, abHash);

    if (memcmp(pEspTail->_abHash, abHash, sizeof(pEspTail->_abHash)) != 0)
    {
        TraceSz1(pktWarn, "[DISCARD] Secure packet to %s failed to authenticate", ipa.Str());
        return;
    }

    if (cbKeyDes)
    {
        // Decrypt the packet from just after the [ESP] header to just before the _abHash in [ESPT]

        if (cbLen != ROUNDUP8(cbLen))
        {
            TraceSz1(pktWarn, "[DISCARD] Secure crypt packet has invalid payload size (%d)", cbLen);
            return;
        }

        CryptDes(XC_SERVICE_DECRYPT, pbKeyDes, cbKeyDes, pb, pb + XC_SERVICE_DES_BLOCKLEN, cbLen);

        pb += XC_SERVICE_DES_BLOCKLEN;
        cbLen -= XC_SERVICE_DES_BLOCKLEN;
    }

    cbLen -= offsetof(CEspTail, _abHash);

    if (    pEspTail->_bNextHeader != IPPROTOCOL_UDP
        &&  pEspTail->_bNextHeader != IPPROTOCOL_TCP
        &&  pEspTail->_bNextHeader != IPPROTOCOL_SECMSG)
    {
        TraceSz2(pktWarn, "[DISCARD] Secure packet to %s failed bNextHeader test (%d)",
                ipa.Str(), pEspTail->_bNextHeader);
        return;
    }

    if (cbLen < pEspTail->_bPadLen)
    {
        TraceSz3(pktWarn, "[DISCARD] Secure packet to %s failed bPadLen test (%d/%d)",
                 ipa.Str(), cbLen, pEspTail->_bPadLen);
        return;
    }

    if (pEspTail->_bPadLen > 0)
    {
        UINT    cbPad = pEspTail->_bPadLen;
        BYTE *  pbPad = (BYTE *)pEspTail;

        // Verify that the padding is the series of bytes 1, 2, 3, ...

        while (cbPad > 0 && *--pbPad == (BYTE)cbPad)
            cbPad--;
    
        if (cbPad)
        {
            TraceSz1(pktWarn, "[DISCARD] Secure packet to %s failed padding test", ipa.Str());
            return;
        }

        cbLen -= pEspTail->_bPadLen;
    }

    if (!fBroadcast)
    {
        if (dwBit < 32)
        {
            // Sequence number is within the current window.  Just set the bit.

            Assert((pSecReg->_dwSeqMask & (1 << dwBit)) == 0);
            pSecReg->_dwSeqMask |= (1 << dwBit);
        }
        else
        {
            // Sequence number is beyond the edge of the window.  Slide window so that the
            // edge is at the sequence number.

            if (dwBit >= 63)
                pSecReg->_dwSeqMask = 0x80000000;
            else
                pSecReg->_dwSeqMask = 0x80000000 | (pSecReg->_dwSeqMask >> (dwBit - 31));

            pSecReg->_dwSeqRecv += dwBit - 31;
        }

        if (pSecReg->_bState != SR_STATE_READY)
        {
            Assert(pSecReg->_bState == SR_STATE_INITWAIT || pSecReg->_bState == SR_STATE_RESPSENT);

            // We have successfully authenticated a packet while in the INITWAIT or RESPSENT
            // state.  That means the other side definitely knows the keys.  Go into the
            // ready state and release any pending packets.

#ifdef XNET_FEATURE_SG

            if (pSecReg->TestFlags(SRF_ONLINEPEER))
            {
                // Capture the address of the sender of this packet.  This will be used
                // as the return address for packets sent on this security association.

                Assert(pIpHdr->_ipaSrc != 0 && pEspHdr->_ipportSrc != 0);

                pSecReg->_ipaDst    = pIpHdr->_ipaSrc;
                pSecReg->_ipportDst = pEspHdr->_ipportSrc;
            }

#endif

            pSecReg->_bState = SR_STATE_READY;
            TimerSet(&pSecReg->_timer, TIMER_INFINITE);
            SecRegXmitQueue(pSecReg);
        }

        // Change the return address in the IP header to the secure address of the sender

        pIpHdr->_ipaSrc = CIpAddr(pSecReg->_dwSpiRecv);

        // Remember the last time a packet was received on this security association

        pSecReg->_dwTickRecv = TimerTick();
    }

    pIpHdr->_bProtocol = pEspTail->_bNextHeader;

    if (pIpHdr->_bProtocol == IPPROTOCOL_UDP)
    {
        ppkt->SetType(PKTF_TYPE_ESP|PKTF_TYPE_UDP);
        IpRecvUdp(ppkt, pIpHdr, (CUdpHdr *)pb, cbLen);
    }
    else if (pIpHdr->_bProtocol == IPPROTOCOL_TCP)
    {
        ppkt->SetType(PKTF_TYPE_ESP|PKTF_TYPE_TCP);
        IpRecvTcp(ppkt, pIpHdr, (CTcpHdr *)pb, cbLen);
    }
    else
    {
        Assert(pIpHdr->_bProtocol == IPPROTOCOL_SECMSG);
        ppkt->SetType(PKTF_TYPE_ESP);
        IpRecvSecMsg(ppkt, pSecReg, dwSeq, (CSecMsgHdr *)pb, cbLen);
    }
}

void CXnIp::IpRecvKeyEx(CPacket * ppkt, CIpAddr ipaSrc, CIpPort ipportSrc, CKeyExHdr * pKeyExHdr, UINT cbKeyEx)
{
    ICHECK(IP, UDPC|SDPC);

    if (cbKeyEx < sizeof(CKeyExHdr) || pKeyExHdr->_cbEnt < sizeof(CKeyExHdr) || pKeyExHdr->_cbEnt > cbKeyEx)
    {
        TraceSz5(pktWarn, "[DISCARD] KeyEx from %s:%d header entry is invalid (%d,%d,%d)",
                 ipaSrc.Str(), NTOHS(ipportSrc), cbKeyEx < sizeof(CKeyExHdr),
                 pKeyExHdr->_cbEnt < sizeof(CKeyExHdr), pKeyExHdr->_cbEnt > cbKeyEx);
        return;
    }

    if (pKeyExHdr->_wType == KEYEX_TYPE_XBTOXB_INIT || pKeyExHdr->_wType == KEYEX_TYPE_XBTOXB_RESP)
    {
        IpRecvKeyExXbToXb(ppkt, ipaSrc, ipportSrc, (CKeyExXbToXb *)pKeyExHdr, cbKeyEx);
        return;
    }

#ifdef XNET_FEATURE_SG

    if (pKeyExHdr->_wType == KEYEX_TYPE_SGTOXB_RESP && ipaSrc != 0 && ipportSrc != 0)
    {
        IpRecvKeyExSgToXb(ppkt, ipaSrc, ipportSrc, (CKeyExSgToXbResp *)pKeyExHdr, cbKeyEx);
        return;
    }

    if (    (pKeyExHdr->_wType == KEYEX_TYPE_NATOPEN_INIT && ipaSrc == 0 && ipportSrc == 0)
        ||  (pKeyExHdr->_wType == KEYEX_TYPE_NATOPEN_RESP && ipaSrc != 0 && ipportSrc != 0))
    {
        IpRecvKeyExNatOpen(ppkt, ipaSrc, ipportSrc, (CKeyExNatOpen *)pKeyExHdr, cbKeyEx);
        return;
    }

#endif

    TraceSz3(pktWarn, "[DISCARD] KeyEx from %s:%d header type (%04X) is invalid",
             ipaSrc.Str(), NTOHS(ipportSrc), pKeyExHdr->_wType);
    return;
}

void CXnIp::IpRecvKeyExXbToXb(CPacket * ppkt, CIpAddr ipaSrc, CIpPort ipportSrc, CKeyExXbToXb * pKeyExXbToXb, UINT cbKeyEx)
{
    ICHECK(IP, UDPC|SDPC);
    Assert(cbKeyEx >= pKeyExXbToXb->_cbEnt);

    if (pKeyExXbToXb->_cbEnt != sizeof(CKeyExXbToXb))
    {
        TraceSz4(pktWarn, "[DISCARD] KeyExXbToXb from %s:%d entry has an incorrect size (%d,%d)",
                 ipaSrc.Str(), NTOHS(ipportSrc), pKeyExXbToXb->_cbEnt, sizeof(CKeyExXbToXb));
        return;
    }

#ifdef XNET_FEATURE_SG

    if (XNetXnKidIsOnlinePeer(&pKeyExXbToXb->_xnkid) && _pSecRegLogon == NULL)
    {
        TraceSz2(pktWarn, "[DISCARD] KeyExXbToXb from %s:%d ignoring request from online-peer while offline",
                 ipaSrc.Str(), NTOHS(ipportSrc));
        return;
    }

#endif

    CKeyReg * pKeyReg = NULL;
    CSecReg * pSecReg = NULL;

    if (pKeyExXbToXb->_wType == KEYEX_TYPE_XBTOXB_INIT)
    {
        pKeyReg = KeyRegLookup(&pKeyExXbToXb->_xnkid);

        if (pKeyReg == NULL)
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExXbToXbInit from %s:%d to unregistered XNKID %s",
                     ipaSrc.Str(), NTOHS(ipportSrc), HexStr(pKeyExXbToXb->_xnkid.ab, sizeof(pKeyExXbToXb->_xnkid.ab)));
            return;
        }
    }
    else
    {
        pSecReg = SecRegLookup(pKeyExXbToXb->_dwSpiInit);

        if (pSecReg == NULL)
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExXbToXbResp from %s:%d to unregistered address %s",
                     ipaSrc.Str(), NTOHS(ipportSrc), CIpAddr(pKeyExXbToXb->_dwSpiInit).Str());
            return;
        }

    #ifdef XNET_FEATURE_SG

        if (ipaSrc == 0 || ipportSrc == 0)
        {
            TraceSz2(pktWarn, "[DISCARD] KeyExXbToXbResp received via SG forwarding (%d,%d)",
                     ipaSrc == 0, ipportSrc == 0);
            return;
        }

        if (!pSecReg->TestFlags(SRF_SYSTEMLINK|SRF_ONLINEPEER))
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExXbToXbResp from %s:%d to non peer-to-peer address %s",
                     ipaSrc.Str(), NTOHS(ipportSrc), CIpAddr(pSecReg->_dwSpiRecv).Str());
            return;
        }

    #endif

        if (pKeyExXbToXb->_liTime.QuadPart <= pSecReg->_liTime.QuadPart)
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExXbToXbResp from %s:%d to %s was replayed",
                     ipaSrc.Str(), NTOHS(ipportSrc), pSecReg->Str());
            return;
        }

        if (pSecReg->_bState != SR_STATE_INITSENT && pSecReg->_bState != SR_STATE_INITWAIT)
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExXbToXbResp from %s:%d to %s while not in ISENT or IWAIT state",
                     ipaSrc.Str(), NTOHS(ipportSrc), pSecReg->Str());
            return;
        }

        Assert(sizeof(pSecReg->_abNonceInit) == sizeof(pKeyExXbToXb->_abNonceInit));

        if (memcmp(pSecReg->_abNonceInit, pKeyExXbToXb->_abNonceInit, sizeof(pSecReg->_abNonceInit)) != 0)
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExXbToXbResp from %s:%d to %s has incorrect nonce",
                     ipaSrc.Str(), NTOHS(ipportSrc), pSecReg->Str());
            return;
        }

        pKeyReg = pSecReg->_pKeyReg;

        if (memcmp(pKeyReg->_xnkid.ab, pKeyExXbToXb->_xnkid.ab, sizeof(pKeyReg->_xnkid.ab)) != 0)
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExXbToXbResp from %s:%d to %s has incorrect xnkid",
                     ipaSrc.Str(), NTOHS(ipportSrc), pSecReg->Str());
            return;
        }
    }

    // Advance to the next entry.  It must contain the diffie-hellman g^X value.

    cbKeyEx -= pKeyExXbToXb->_cbEnt;
    CKeyExHdr * pKeyExDh = (CKeyExHdr *)((BYTE *)pKeyExXbToXb + pKeyExXbToXb->_cbEnt);

    if (    cbKeyEx < sizeof(CKeyExHdr)
        ||  pKeyExDh->_wType != KEYEX_TYPE_DH_GX
        ||  pKeyExDh->_cbEnt != sizeof(CKeyExHdr) + CBDHG1
        ||  pKeyExDh->_cbEnt > cbKeyEx)
    {
        TraceSz6(pktWarn, "[DISCARD] KeyExXbToXb from %s:%d DH entry is invalid (%d,%d,%d,%d)",
                 ipaSrc.Str(), NTOHS(ipportSrc), cbKeyEx < sizeof(CKeyExHdr),
                 cbKeyEx >= sizeof(CKeyExHdr) && pKeyExDh->_wType != KEYEX_TYPE_DH_GX,
                 cbKeyEx >= sizeof(CKeyExHdr) && pKeyExDh->_cbEnt != sizeof(CKeyExHdr) + CBDHG1,
                 cbKeyEx >= sizeof(CKeyExHdr) && pKeyExDh->_cbEnt > cbKeyEx);
        return;
    }

    // Advance to the next entry.  It must contain the HMAC-SHA digest of the previous entries,
    // and it must also be the last entry.

    cbKeyEx -= pKeyExDh->_cbEnt;
    CKeyExHdr * pKeyExSha = (CKeyExHdr *)((BYTE *)pKeyExDh + pKeyExDh->_cbEnt);

    if (    cbKeyEx < sizeof(CKeyExHdr)
        ||  pKeyExSha->_wType != KEYEX_TYPE_HMAC_SHA
        ||  pKeyExSha->_cbEnt != sizeof(CKeyExHdr) + XC_SERVICE_DIGEST_SIZE
        ||  pKeyExSha->_cbEnt != cbKeyEx)
    {
        TraceSz6(pktWarn, "[DISCARD] KeyExXbToXb from %s:%d SHA entry is invalid (%d,%d,%d,%d)",
                 ipaSrc.Str(), NTOHS(ipportSrc), cbKeyEx < sizeof(CKeyExHdr),
                 cbKeyEx >= sizeof(CKeyExHdr) && pKeyExSha->_wType != KEYEX_TYPE_HMAC_SHA,
                 cbKeyEx >= sizeof(CKeyExHdr) && pKeyExSha->_cbEnt != sizeof(CKeyExHdr) + XC_SERVICE_DIGEST_SIZE,
                 cbKeyEx >= sizeof(CKeyExHdr) && pKeyExSha->_cbEnt != cbKeyEx);
        return;
    }

    // Authenticate the key exchange message (all entries except the last) using the key-exchange-key
    // corresponding to the XNKID in the message.

    BYTE abHash[XC_SERVICE_DIGEST_SIZE];

    XcHMAC(pKeyReg->_abKeySha, sizeof(pKeyReg->_abKeySha), (BYTE *)pKeyExXbToXb,
           (BYTE *)pKeyExSha - (BYTE *)pKeyExXbToXb, NULL, 0, abHash);

    Assert(pKeyExSha->_cbEnt == sizeof(CKeyExHdr) + sizeof(abHash));

    if (memcmp((BYTE *)(pKeyExSha + 1), abHash, sizeof(abHash)) != 0)
    {
        TraceSz2(pktWarn, "[DISCARD] KeyExXbToXb from %s:%d failed to authenticate",
                 ipaSrc.Str(), NTOHS(ipportSrc));
        return;
    }

    // Decrypt the portion of the first entry which contains the XNADDR structures

    CryptDes(XC_SERVICE_DECRYPT, pKeyReg->_abKeyDes, sizeof(pKeyReg->_abKeyDes),
             pKeyExXbToXb->_abIv, pKeyExXbToXb->_abIv + XC_SERVICE_DES_BLOCKLEN,
             sizeof(CKeyExXbToXb) - offsetof(CKeyExXbToXb, _abIv) - XC_SERVICE_DES_BLOCKLEN);

    // Verify that the sender knows the current XNADDR of this stack

    XNADDR xnaddr, * pxnaddr;
    IpGetXnAddr(&xnaddr);

    pxnaddr = (pKeyExXbToXb->_wType == KEYEX_TYPE_XBTOXB_INIT) ? &pKeyExXbToXb->_xnaddrResp : &pKeyExXbToXb->_xnaddrInit;

    if (memcmp(&xnaddr, pxnaddr, sizeof(XNADDR)) != 0)
    {
        TraceSz4(pktWarn, "[DISCARD] KeyExXbToXb from %s:%d target XNADDR mismatch; got %s expected %s",
                 ipaSrc.Str(), NTOHS(ipportSrc), XnAddrStr(pxnaddr), XnAddrStr(&xnaddr));
        return;
    }

    // Verify that the sender's XNADDR is valid

    pxnaddr = (pKeyExXbToXb->_wType == KEYEX_TYPE_XBTOXB_INIT) ? &pKeyExXbToXb->_xnaddrInit : &pKeyExXbToXb->_xnaddrResp;

    if (XNetXnKidIsSystemLink(&pKeyExXbToXb->_xnkid))
    {
        CEnetHdr * pEnetHdr = ppkt->GetEnetHdr();

        if (!pEnetHdr->_eaSrc.IsEqual(pxnaddr->abEnet))
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExXbToXb from %s:%d source XNADDR failed system-link test (%d)",
                     ipaSrc.Str(), NTOHS(ipportSrc), !pEnetHdr->_eaSrc.IsEqual(pxnaddr->abEnet));
            return;
        }
    }

#ifdef XNET_FEATURE_SG

    if (XNetXnKidIsOnlinePeer(&pKeyExXbToXb->_xnkid))
    {
        if (    !CIpAddr(pxnaddr->ina.s_addr).IsValidUnicast()
            ||  !CIpAddr(pxnaddr->inaOnline.s_addr).IsValidUnicast()
            ||  pxnaddr->wPortOnline == 0)
        {
            TraceSz5(pktWarn, "[DISCARD] KeyExXbToXb from %s:%d source XNADDR failed online-peer tests (%d,%d,%d)",
                     ipaSrc.Str(), NTOHS(ipportSrc), !CIpAddr(pxnaddr->ina.s_addr).IsValidUnicast(),
                     !CIpAddr(pxnaddr->inaOnline.s_addr).IsValidUnicast(), pxnaddr->wPortOnline == 0);
            return;
        }
    }
                    
#endif

    if (pKeyExXbToXb->_wType == KEYEX_TYPE_XBTOXB_INIT)
    {
        // Try to find an existing CSecReg given the XNADDR of the initiator and the XNKID

        pSecReg = SecRegLookup(&pKeyExXbToXb->_xnaddrInit, &pKeyExXbToXb->_xnkid);

        if (pSecReg == NULL)
        {
            // Not found.  Allocate a new CSecReg.

            pSecReg = SecRegAlloc(&pKeyExXbToXb->_xnaddrInit, pKeyReg);

            if (pSecReg == NULL)
            {
                TraceSz2(pktWarn, "[DISCARD] KeyExXbToXbInit from %s:%d reached CSecReg limit",
                         ipaSrc.Str(), NTOHS(ipportSrc));
                return;
            }
        }
        else if (pKeyExXbToXb->_liTime.QuadPart <= pSecReg->_liTime.QuadPart)
        {
            TraceSz2(pktWarn, "[DISCARD] KeyExXbToXbInit from %s:%d is obsolete or replayed",
                     ipaSrc.Str(), NTOHS(ipportSrc));
            return;
        }
#ifdef XNET_FEATURE_SG
        else if (pSecReg->TestFlags(SRF_ONLINEPEER))
        {
            // Update the XNADDR for this CSecReg.  Is is possible that the online information
            // has changed since the last time the peer contacted us.

            pSecReg->_xnaddr = pKeyExXbToXb->_xnaddrInit;
        }
#endif

        pSecReg->_liTime = pKeyExXbToXb->_liTime;

        // If we are in the INITSENT state, then we have simultaneous initiator packets
        // being sent.  To resolve this, the side which has the highest ethernet address
        // is the initiator and the other side becomes the responder.

        if (pSecReg->_bState == SR_STATE_INITSENT)
        {
            if (memcmp(_ea._ab, pKeyExXbToXb->_xnaddrInit.abEnet, sizeof(CEnetAddr)) > 0)
            {
                // This side wins.  The other side will run the same computation and will
                // respond to our initiator packet.  We just discard theirs.

                TraceSz2(pktRecv, "[DISCARD] KeyExXbToXbInit from %s:%d simultaneous initiators",
                         ipaSrc.Str(), NTOHS(ipportSrc));
                return;
            }
        }

        // If we are in the RESPSENT state, this could be a retransmit of the initiator packet.
        // We verify this by checking the nonce of the initiator that we remembered from before.

        if (    pSecReg->_bState != SR_STATE_RESPSENT
            ||  memcmp(pSecReg->_abNonceInit, pKeyExXbToXb->_abNonceInit, sizeof(pSecReg->_abNonceInit)) != 0)
        {
            // This is a new key exchange initiation sequence.  Reset the security association.

            SecRegSetIdle(pSecReg);

            pSecReg->_bState    = SR_STATE_RESPSENT;
            pSecReg->_bRetry    = SecRegRexmitRetries(pSecReg);
            pSecReg->_dwSpiXmit = pKeyExXbToXb->_dwSpiInit;

            // Remember the nonce of the initiator in case we need to retransmit this reponse.
            // Generate a random nonce for the responder.

            Assert(sizeof(pSecReg->_abNonceInit) == sizeof(pKeyExXbToXb->_abNonceInit));
            memcpy(pSecReg->_abNonceInit, pKeyExXbToXb->_abNonceInit, sizeof(pSecReg->_abNonceInit));
            Rand(pSecReg->_abNonceResp, sizeof(pSecReg->_abNonceResp));

            // Generate the SHA and DES keys for this security association

            SecRegSetKey(pSecReg, pKeyReg->_abKeySha, sizeof(pKeyReg->_abKeySha),
                         pKeyReg->_abDhX, sizeof(pKeyReg->_abDhX),
                         (BYTE *)(pKeyExDh + 1), pKeyExDh->_cbEnt - sizeof(CKeyExHdr),
                         FALSE);

            // Set the retransmission timer.  This side is responsible for retransmitting
            // the key exchange response until it gets a secure packet from the other side.

            TimerSet(&pSecReg->_timer, TimerTick() + SecRegRexmitTimeoutInSeconds(pSecReg) * TICKS_PER_SECOND);
        }

#ifdef XNET_FEATURE_SG
        if (pSecReg->TestFlags(SRF_ONLINEPEER) && ipaSrc != 0 && ipportSrc != 0)
        {
            // Capture the return address information from the initiator packet if the packet
            // arrived directly (versus being forwarded through the security gateways).

            pSecReg->_ipaDst    = ipaSrc;
            pSecReg->_ipportDst = ipportSrc;
        }
#endif

        // Send a KeyEx XbToXb response packet back to the initiator

        IpXmitKeyExXbToXb(pSecReg);
    }
    else
    {
#if DBG
        if (Tag(keyExDrop) && pSecReg->_bRetry == SecRegRexmitRetries(pSecReg))
        {
            // Drop the first key-exchange response for testing purposes
            TraceSz(pktWarn, "[DISCARD] Dropping first KeyExXbToXbResp (debug only)");
            return;
        }
#endif

        pSecReg->_liTime = pKeyExXbToXb->_liTime;

#ifdef XNET_FEATURE_SG
        if (pSecReg->TestFlags(SRF_ONLINEPEER))
        {
            // Capture the return address information from the responder packet.  Responses are
            // always sent directly (as opposed to being forwarded through the security gateways).

            Assert(ipaSrc != 0 && ipportSrc != 0);

            pSecReg->_ipaDst    = ipaSrc;
            pSecReg->_ipportDst = ipportSrc;
        }
#endif

        // If we are in the INITWAIT state, this could be a retransmit of the responder packet.
        // We verify this by checking the nonce of the responder that we remembered from before.

        if (    pSecReg->_bState != SR_STATE_INITWAIT
            ||  memcmp(pSecReg->_abNonceResp, pKeyExXbToXb->_abNonceResp, sizeof(pSecReg->_abNonceResp)) != 0)
        {
            // This is the first time we've gotten a response from the other side to this
            // key exchange initiation.  Remember the nonce of the responder and the dwSpiXmit.

            Assert(sizeof(pSecReg->_abNonceResp) == sizeof(pKeyExXbToXb->_abNonceResp));
            memcpy(pSecReg->_abNonceResp, pKeyExXbToXb->_abNonceResp, sizeof(pSecReg->_abNonceResp));
            pSecReg->_dwSpiXmit = pKeyExXbToXb->_dwSpiResp;

            // Generate the SHA and DES keys for this security association

            SecRegSetKey(pSecReg, pKeyReg->_abKeySha, sizeof(pKeyReg->_abKeySha),
                         pKeyReg->_abDhX, sizeof(pKeyReg->_abDhX),
                         (BYTE *)(pKeyExDh + 1), pKeyExDh->_cbEnt - sizeof(CKeyExHdr),
                         TRUE);

            // Switch to the INITWAIT state.  In this state, we know that the other side has computed
            // the same keys that we have, so we stop retransmitting the initiator packet.

            pSecReg->_bState = SR_STATE_INITWAIT;
            TimerSet(&pSecReg->_timer, TIMER_INFINITE);
        }

        // We must send a response.  If there are waiting packets, send those now.
        // Otherwise, send a SECMSG_TYPE_PULSE to let the other side know we're alive.

        if (pSecReg->_pqWait.IsEmpty())
            IpXmitSecMsg(pSecReg, SECMSG_TYPE_PULSE);
        else
            SecRegXmitQueue(pSecReg);
    }
}

#ifdef XNET_FEATURE_SG

void CXnIp::IpRecvKeyExNatOpen(CPacket * ppkt, CIpAddr ipaSrc, CIpPort ipportSrc, CKeyExNatOpen * pKeyExNatOpen, UINT cbKeyEx)
{
    ICHECK(IP, UDPC|SDPC);
    Assert(pKeyExNatOpen->_wType == KEYEX_TYPE_NATOPEN_INIT || pKeyExNatOpen->_wType == KEYEX_TYPE_NATOPEN_RESP);
    Assert(cbKeyEx >= pKeyExNatOpen->_cbEnt);

    if (pKeyExNatOpen->_cbEnt != sizeof(CKeyExNatOpen))
    {
        TraceSz4(pktWarn, "[DISCARD] KeyExNatOepn from %s:%d entry has an incorrect size (%d,%d)",
                 ipaSrc.Str(), NTOHS(ipportSrc), pKeyExNatOpen->_cbEnt, sizeof(CKeyExNatOpen));
        return;
    }

    CKeyReg * pKeyReg = KeyRegLookup(&pKeyExNatOpen->_xnkid);

    if (pKeyReg == NULL)
    {
        TraceSz3(pktWarn, "[DISCARD] KeyExNatOpen from %s:%d to unregistered XNKID %s",
                 ipaSrc.Str(), NTOHS(ipportSrc), HexStr(pKeyExNatOpen->_xnkid.ab, sizeof(pKeyExNatOpen->_xnkid.ab)));
        return;
    }

    // Authenticate the message including the header using the key-exchange-key corresponding to
    // the XNKID in the message.

    BYTE abHash[XC_SERVICE_DIGEST_SIZE];

    XcHMAC(pKeyReg->_abKeySha, sizeof(pKeyReg->_abKeySha), (BYTE *)pKeyExNatOpen,
           offsetof(CKeyExNatOpen, _abHash), NULL, 0, abHash);

    Assert(sizeof(pKeyExNatOpen->_abHash) == sizeof(abHash));

    if (memcmp(abHash, pKeyExNatOpen->_abHash, sizeof(abHash)) != 0)
    {
        TraceSz2(pktWarn, "[DISCARD] KeyExNatOpen from %s:%d failed to authenticate",
                 ipaSrc.Str(), NTOHS(ipportSrc));
        return;
    }

    if (pKeyExNatOpen->_wType == KEYEX_TYPE_NATOPEN_INIT)
    {
        Assert(ipaSrc == 0 && ipportSrc == 0);

        // Reply to this request by sending a CKeyExNatOpen packet to the destination address
        // specified.  We change the type to KEYEX_TYPE_NATOPEN_RESP and recompute the abHash
        // to prove to the requester that we know the key-exhcange-key associated with the xnkid.

        CPacket * ppktXmit = PacketAlloc(PTAG_CKeyExPacket, PKTF_TYPE_UDP|PKTF_POOLALLOC, sizeof(DWORD) + sizeof(CKeyExNatOpen));

        if (ppktXmit == NULL)
        {
            TraceSz(Warning, "IpRecvKeyExNatOpen - Out of memory allocating packet");
            return;
        }

        CEnetHdr *      pEnetHdr          = ppktXmit->GetEnetHdr();
        CIpHdr *        pIpHdr            = ppktXmit->GetIpHdr();
        CEspHdr *       pEspHdr           = (CEspHdr *)(pIpHdr + 1);
        CKeyExNatOpen * pKeyExNatOpenXmit = (CKeyExNatOpen *)&pEspHdr->_dwSeq;

        IpFillHdr(ppktXmit, pKeyExNatOpen->_ipaDst, IPPROTOCOL_UDP);

        pIpHdr->_ipaSrc     = _ipa;
        pEspHdr->_wLen      = NTOHS(sizeof(CUdpHdr) + sizeof(DWORD) + sizeof(CKeyExNatOpen));
        pEspHdr->_ipportSrc = ESPUDP_CLIENT_PORT;
        pEspHdr->_ipportDst = pKeyExNatOpen->_ipportDst;
        pEspHdr->_wChecksum = 0;
        pEspHdr->_dwSpi     = 0;

        memcpy(pKeyExNatOpenXmit, pKeyExNatOpen, offsetof(CKeyExNatOpen, _abHash));
        pKeyExNatOpenXmit->_wType = KEYEX_TYPE_NATOPEN_RESP;

        Assert(sizeof(pKeyExNatOpenXmit->_abHash) == XC_SERVICE_DIGEST_SIZE);
        XcHMAC(pKeyReg->_abKeySha, sizeof(pKeyReg->_abKeySha), (BYTE *)pKeyExNatOpenXmit,
               offsetof(CKeyExNatOpen, _abHash), NULL, 0, pKeyExNatOpenXmit->_abHash);

        TraceSz3(secStat, "Sending KeyExNatOpen RESP/%04X to %s:%d",
                 pKeyExNatOpenXmit->_wFlags, pIpHdr->_ipaDst.Str(), NTOHS(pEspHdr->_ipportDst));

        IpXmitIp(ppktXmit, NULL);
        return;
    }

    if (pKeyExNatOpen->_wType == KEYEX_TYPE_NATOPEN_RESP)
    {
        Assert(ipaSrc != 0 && ipportSrc != 0);

        if (pKeyExNatOpen->_wFlags & KNOF_XBTOXB_KEYEX)
        {
            // This message is the response from a NatOpen request we sent via the SG forwarding
            // mechanism.  Lookup the CSecReg associated from the _dwCtx.

            CSecReg * pSecReg = SecRegLookup(pKeyExNatOpen->_dwCtx);

            Assert(sizeof(pSecReg->_abNonceInit) == sizeof(pKeyExNatOpen->_abNonce));

            if (     pSecReg == NULL
                ||   pSecReg->_bState != SR_STATE_INITSENT
                ||  !pSecReg->TestFlags(SRF_ONLINEPEER)
                ||   memcmp(pSecReg->_abNonceInit, pKeyExNatOpen->_abNonce, sizeof(pSecReg->_abNonceInit)) != 0)
            {
                TraceSz6(pktWarn, "[DISCARD] KeyExNatOpen from %s:%d is obsolete or invalid (%d,%d,%d,%d)",
                         ipaSrc.Str(), NTOHS(ipportSrc), pSecReg == NULL,
                         pSecReg && pSecReg->_bState != SR_STATE_INITSENT,
                         pSecReg && !pSecReg->TestFlags(SRF_ONLINEPEER),
                         pSecReg && memcmp(pSecReg->_abNonceInit, pKeyExNatOpen->_abNonce, sizeof(pSecReg->_abNonceInit)) != 0);
                return;
            }

            // Capture the return address information from the sender, and retransmit the key exchange
            // initiator packet.  The hope is that the sender will have programmed his NAT to allow
            // this packet to get through.  It is still not guaranteed to get through, however, if our
            // NAT is agressively assigning ports and the other side is port filtering.

            pSecReg->_ipaDst    = ipaSrc;
            pSecReg->_ipportDst = ipportSrc;

            // Retransmit the key exchange initiator packet right now (instead of waiting for the
            // timeout to expire).  The second argument tells IpXmitKeyExXbToXb to not send a
            // CKeyExNatOpen message this time.  Sending it now could cause a storm of packets
            // flowing if communication is one-sided (i.e. this side can receive but not
            // transmit).

            IpXmitKeyExXbToXb(pSecReg, TRUE);
            return;
        }

        //@@@ Handle KNOF_XBTOXB_PROBE here
    }

    TraceSz4(pktWarn, "[DISCARD] KeyExNatOpen from %s:%d type %04X is invalid (wFlags %04X)",
             ipaSrc.Str(), NTOHS(ipportSrc), pKeyExNatOpen->_wType, pKeyExNatOpen->_wFlags);
    return;
}

void CXnIp::IpRecvKeyExSgToXb(CPacket * ppkt, CIpAddr ipaSrc, CIpPort ipportSrc, CKeyExSgToXbResp * pKeyExSgToXbResp, UINT cbKeyEx)
{
    ICHECK(IP, UDPC|SDPC);
    Assert(pKeyExSgToXbResp->_wType == KEYEX_TYPE_SGTOXB_RESP);
    Assert(cbKeyEx >= pKeyExSgToXbResp->_cbEnt);

    if (pKeyExSgToXbResp->_cbEnt != sizeof(CKeyExSgToXbResp))
    {
        TraceSz4(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d entry has an incorrect size (%d,%d)",
                 ipaSrc.Str(), NTOHS(ipportSrc), pKeyExSgToXbResp->_cbEnt, sizeof(CKeyExSgToXbResp));
        return;
    }

    CSecReg * pSecReg = SecRegLookup(pKeyExSgToXbResp->_dwSpiInit);

    if (pSecReg == NULL)
    {
        TraceSz3(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d to unregistered address %s",
                 ipaSrc.Str(), NTOHS(ipportSrc), CIpAddr(pKeyExSgToXbResp->_dwSpiInit).Str());
        return;
    }

    if (!pSecReg->TestFlags(SRF_ONLINESERVER))
    {
        TraceSz3(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d to non online-server address %s",
                 ipaSrc.Str(), NTOHS(ipportSrc), CIpAddr(pKeyExSgToXbResp->_dwSpiInit).Str());
        return;
    }

    if (pSecReg->_bState != SR_STATE_INITSENT)
    {
        TraceSz3(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d to %s while not in ISENT state",
                 ipaSrc.Str(), NTOHS(ipportSrc), pSecReg->Str());
        return;
    }

    Assert(sizeof(pSecReg->_abNonceInit) == sizeof(pKeyExSgToXbResp->_abNonceInit));

    if (memcmp(pSecReg->_abNonceInit, pKeyExSgToXbResp->_abNonceInit, sizeof(pSecReg->_abNonceInit)) != 0)
    {
        TraceSz2(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d has incorrect nonce",
                 ipaSrc.Str(), NTOHS(ipportSrc));
        return;
    }

    // Advance to the next entry.  It must contain the diffie-hellman g^X value.

    cbKeyEx -= pKeyExSgToXbResp->_cbEnt;
    CKeyExHdr * pKeyExDh = (CKeyExHdr *)((BYTE *)pKeyExSgToXbResp + pKeyExSgToXbResp->_cbEnt);

    if (    cbKeyEx < sizeof(CKeyExHdr)
        ||  pKeyExDh->_wType != KEYEX_TYPE_DH_GX
        ||  pKeyExDh->_cbEnt != sizeof(CKeyExHdr) + CBDHG1
        ||  pKeyExDh->_cbEnt > cbKeyEx)
    {
        TraceSz6(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d DH entry is invalid (%d,%d,%d,%d)",
                 ipaSrc.Str(), NTOHS(ipportSrc),
                 cbKeyEx < sizeof(CKeyExHdr),
                 cbKeyEx >= sizeof(CKeyExHdr) && pKeyExDh->_wType != KEYEX_TYPE_DH_GX,
                 cbKeyEx >= sizeof(CKeyExHdr) && pKeyExDh->_cbEnt != sizeof(CKeyExHdr) + CBDHG1,
                 cbKeyEx >= sizeof(CKeyExHdr) && pKeyExDh->_cbEnt > cbKeyEx);
        return;
    }

    // Advance to the next entry.  It must contain the KERB_APREP and it must also be the last entry.

    cbKeyEx -= pKeyExDh->_cbEnt;
    CKeyExHdr * pKeyExApRep = (CKeyExHdr *)((BYTE *)pKeyExDh + pKeyExDh->_cbEnt);

    if (cbKeyEx < sizeof(CKeyExHdr) || pKeyExApRep->_cbEnt != cbKeyEx)
    {
        TraceSz4(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d ApRep entry is invalid (%d,%d)",
                 ipaSrc.Str(), NTOHS(ipportSrc), cbKeyEx < sizeof(CKeyExHdr),
                 cbKeyEx >= sizeof(CKeyExHdr) && pKeyExApRep->_cbEnt != cbKeyEx);
        return;
    }

    // Crack the ApRep 

    BYTE *  pbKeyHmac;          // Key to use to compute HMAC-SHA of key-exchange message
    UINT    cbKeyHmac;          // Size of pbKeyHmac
    BYTE *  pbShaApRep;         // HMAC-SHA from the AP reply
    UINT    cbShaApRep;         // Size of pbShaApRep
    BYTE *  pbDhX;              // Diffie-hellman X
    UINT    cbDhX;              // Size of pbDhX

#ifdef XNET_FEATURE_ONLINE

    XOKERBINFO *    pxokerbinfo;
    BYTE            abShaApRep[XC_SERVICE_DIGEST_SIZE];

    if (pKeyExApRep->_wType == KEYEX_TYPE_KERB_APREP)
    {
        pxokerbinfo = _pXoBase ? _pXoBase->XoKerbGetInfo(pSecReg->_dwServiceId) : NULL;

        if (pxokerbinfo == NULL)
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d cannot find XOKERBINFO for service %08lX",
                     ipaSrc.Str(), NTOHS(ipportSrc), pSecReg->_dwServiceId);
            return;
        }

        if (!_pXoBase->XoKerbCrackApRep(pSecReg->_dwServiceId, &pSecReg->_liTime, abShaApRep,
                                        sizeof(abShaApRep), (BYTE *)(pKeyExApRep + 1),
                                        pKeyExApRep->_cbEnt - sizeof(CKeyExHdr)))
        {
            TraceSz2(Warning, "[DISCARD] KeyExSgToXbResp from %s:%d XoKerbCrackApRep failed",
                     ipaSrc.Str(), NTOHS(ipportSrc));
            return;
        }

        pbKeyHmac  = pxokerbinfo->_abKey;
        cbKeyHmac  = sizeof(pxokerbinfo->_abKey);
        pbShaApRep = abShaApRep;
        cbShaApRep = sizeof(abShaApRep);
        pbDhX      = pxokerbinfo->_abDhX;
        cbDhX      = sizeof(pxokerbinfo->_abDhX);

        goto ApRepDone;
    }
#endif

#ifdef XNET_FEATURE_INSECURE

    if (pKeyExApRep->_wType == KEYEX_TYPE_NULL_APREP)
    {
        CKeyExNullApRep * pKeyExNullApRep = (CKeyExNullApRep *)pKeyExApRep;

        if (pKeyExNullApRep->_cbEnt != sizeof(CKeyExNullApRep))
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d NULL_APREP has invalid size (%d bytes)",
                     ipaSrc.Str(), NTOHS(ipportSrc), pKeyExApRep->_cbEnt);
            return;
        }

        if (pSecReg->_dwServiceId != 0)
        {
            TraceSz3(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d NULL_APREP unexpected for service %08lX",
                     ipaSrc.Str(), NTOHS(ipportSrc), pSecReg->_dwServiceId);
            return;
        }

        pbKeyHmac   = _abKeyNull;
        cbKeyHmac   = sizeof(_abKeyNull);
        pbShaApRep  = pKeyExNullApRep->_abSha;
        cbShaApRep  = sizeof(pKeyExNullApRep->_abSha);
        pbDhX       = _abDhXNull;
        cbDhX       = sizeof(_abDhXNull);

        goto ApRepDone;
    }

#endif

    TraceSz3(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d APREP type (%d) not supported",
             ipaSrc.Str(), NTOHS(ipportSrc), pKeyExApRep->_wType);
    return;

ApRepDone:

    // Authenticate the key exchange message (all entries except the last).

    BYTE abSha[XC_SERVICE_DIGEST_SIZE];

    XcHMAC(pbKeyHmac, cbKeyHmac, (BYTE *)pKeyExSgToXbResp, (BYTE *)pKeyExApRep - (BYTE *)pKeyExSgToXbResp,
           NULL, 0, abSha);

    Assert(cbShaApRep <= sizeof(abSha));

    if (memcmp(abSha, pbShaApRep, cbShaApRep) != 0)
    {
        TraceSz2(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d failed to authenticate",
                 ipaSrc.Str(), NTOHS(ipportSrc));
        return;
    }

    if (pKeyExSgToXbResp->_dwFlags & SXRF_ENCRYPT_DES)
        pSecReg->_cbKeyDesRecv = pSecReg->_cbKeyDesXmit = XC_SERVICE_DES_KEYSIZE;
    else if (pKeyExSgToXbResp->_dwFlags & SXRF_ENCRYPT_3DES)
        pSecReg->_cbKeyDesRecv = pSecReg->_cbKeyDesXmit = XC_SERVICE_DES3_KEYSIZE;
    else
    {
        TraceSz2(pktWarn, "[DISCARD] KeyExSgToXbResp from %s:%d unrecognized encryption",
                 ipaSrc.Str(), NTOHS(ipportSrc));
        return;
    }

#if DBG
    if (Tag(keyExDrop) && pSecReg->_bRetry == SecRegRexmitRetries(pSecReg))
    {
        // Drop the first key-exchange response for testing purposes
        TraceSz(pktWarn, "[DISCARD] Dropping first KeyExSgToXbResp (debug only)");
        return;
    }
#endif

    pSecReg->_dwSpiXmit           = pKeyExSgToXbResp->_dwSpiResp;
    pSecReg->_dwTickPulseTimeout  = pKeyExSgToXbResp->_wXbToSgPulseTimeoutInSecs * TICKS_PER_SECOND;
    pSecReg->_dwTickTimeout       = pKeyExSgToXbResp->_wXbToSgTimeoutInSecs * TICKS_PER_SECOND;
    pSecReg->_sgaddr              = pKeyExSgToXbResp->_sgaddrInit;
    pSecReg->_ipaNat              = pKeyExSgToXbResp->_inaInit.s_addr;
    pSecReg->_ipportNat           = pKeyExSgToXbResp->_wPortInit;

    Assert(sizeof(pSecReg->_abNonceResp) == sizeof(pKeyExSgToXbResp->_abNonceResp));
    memcpy(pSecReg->_abNonceResp, pKeyExSgToXbResp->_abNonceResp, sizeof(pSecReg->_abNonceResp));

    SecRegSetKey(pSecReg, pbKeyHmac, cbKeyHmac, pbDhX, cbDhX, (BYTE *)(pKeyExDh + 1),
                 pKeyExDh->_cbEnt - sizeof(CKeyExHdr), TRUE);

    pSecReg->_bState = SR_STATE_INITWAIT;
    TimerSet(&pSecReg->_timer, TIMER_INFINITE);

    if (pSecReg == _pSecRegLogon)
    {
        Assert(_uiLogonState == XN_LOGON_STATE_PENDING);

        _uiLogonState = XN_LOGON_STATE_ONLINE;

        if (_pEventLogon)
        {
            EvtSet(_pEventLogon, EVENT_INCREMENT);
        }
    }

    // We must respond with to the initiator.  If there are waiting packets, send those now.
    // Otherwise, send a SECMSG_TYPE_PULSE to let the other side know we're alive.

    if (pSecReg->_pqWait.IsEmpty())
        IpXmitSecMsg(pSecReg, SECMSG_TYPE_PULSE);
    else
        SecRegXmitQueue(pSecReg);
}

#endif

void CXnIp::IpRecvSecMsg(CPacket * ppkt, CSecReg * pSecReg, DWORD dwSeq, CSecMsgHdr * pSecMsgHdr, UINT cb)
{
    ICHECK(IP, UDPC|SDPC);
    
    if (cb < sizeof(CSecMsgHdr) || cb != pSecMsgHdr->_cbEnt)
    {
        TraceSz3(pktWarn, "[DISCARD] SecMsg to %s has wrong size (%d,%d)",
                 pSecReg->Str(), cb < sizeof(CSecMsgHdr),
                 cb >= sizeof(CSecMsgHdr) && cb != pSecMsgHdr->_cbEnt);
        return;
    }

    TraceSz3(pktRecv, "[SecMsg %s %04X]{+%d}", pSecReg->Str(), pSecMsgHdr->_wType, pSecMsgHdr->_cbEnt - sizeof(CSecMsgHdr));

    if (pSecMsgHdr->_wType == SECMSG_TYPE_DELETE)
    {
        if (cb != sizeof(CSecMsgDelete))
        {
            TraceSz2(pktWarn, "[DISCARD] SecMsg SECMSG_TYPE_DELETE to %s has incorrect payload size (%d)",
                     pSecReg->Str(), cb);
            return;
        }

        // The other side has disconnected from us.  Reset the CSecReg so that KeyEx will
        // be reinitiated next time a packet is transmitted.

        if (!pSecReg->TestFlags(SRF_OWNED))
            SecRegFree(pSecReg);
        else
            SecRegSetIdle(pSecReg);

        return;
    }

    if (pSecMsgHdr->_wType == SECMSG_TYPE_PULSE)
    {
        if (cb != sizeof(CSecMsgPulse))
        {
            TraceSz2(pktWarn, "[DISCARD] SecMsg SECMSG_TYPE_PULSE to %s has incorrect payload size (%d)",
                     pSecReg->Str(), cb);
            return;
        }

        // Nothing else to do with this message.  It was only sent to let us know that the
        // other side is still alive.

        return;
    }

#ifdef XNET_FEATURE_SG

    if (pSecMsgHdr->_wType == SECMSG_TYPE_SGTOXB_PULSE)
    {
        if (cb < sizeof(CSecMsgSgToXbPulse))
        {
            TraceSz2(pktWarn, "[DISCARD] SecMsg SECMSG_TYPE_SGTOXB_PULSE to %s has incorrect payload size (%d)",
                     pSecReg->Str(), cb);
            return;
        }

        if (pSecReg == _pSecRegLogon)
        {
            CSecMsgSgToXbPulse * pSecMsgSgToXbPulse = (CSecMsgSgToXbPulse *)pSecMsgHdr;

            if (pSecMsgSgToXbPulse->_dwSeqAck && pSecMsgSgToXbPulse->_dwSeqAck >= _dwSeqXbToSg)
            {
                _dwSeqXbToSg = 0;
                *(DWORD *)_abXbToSgPulse = 0;
            }

            cb -= sizeof(CSecMsgSgToXbPulse);

            if (cb > 0)
            {
                BYTE * pb = (BYTE *)(pSecMsgSgToXbPulse + 1);

                while (cb > 0)
                {
                    BYTE b = *pb++;
                    cb -= 1;

                    if ((b & ~(SGPULSE_USER_INDEX_MASK|SGPULSE_QFLAGS_CHANGE)) != 0)
                    {
                        TraceSz2(pktWarn, "SecMsg SECMSG_TYPE_SGTOXB_PULSE to %s has bad control byte (%02X)",
                                 pSecReg->Str(), b);
                        break;
                    }

                    if (b & SGPULSE_QFLAGS_CHANGE)
                    {
                        if (cb < 2*sizeof(DWORD))
                        {
                            TraceSz3(pktWarn, "SecMsg SECMSG_TYPE_SGTOXB_PULSE to %s ends prematurely (cb=%d,cbReq=%d)",
                                     pSecReg->Str(), cb, 2*sizeof(DWORD));
                            break;
                        }

                        DWORD dwQFlags = *(DWORD *)pb;
                        pb += sizeof(DWORD);
                        cb -= sizeof(DWORD);

                        DWORD dwSeqQFlags = *(DWORD *)pb;
                        pb += sizeof(DWORD);
                        cb -= sizeof(DWORD);

                        XOUSERINFO * pxouserinfo = &_axouserinfo[b & SGPULSE_USER_INDEX_MASK];

                        if (pxouserinfo->_dwSeqQFlags < dwSeqQFlags)
                        {
                            pxouserinfo->_dwSeqQFlags = dwSeqQFlags;
                            pxouserinfo->_dwQFlags    = dwQFlags;

                            if (_pEventLogon)
                            {
                                EvtSet(_pEventLogon, EVENT_INCREMENT);
                            }
                        }
                    }
                }

                _dwSeqSgToXb = dwSeq;
            }
        }

        return;
    }

    if (pSecMsgHdr->_wType == SECMSG_TYPE_XBTOXB_FORWARD)
    {
        if (cb < sizeof(CSecMsgXbToXbForward))
        {
            TraceSz2(pktWarn, "[DISCARD] SecMsg SECMSG_TYPE_XBTOXB_FORWARD to %s has incorrect payload size (%d)",
                     pSecReg->Str(), cb);
            return;
        }

        if (pSecReg != _pSecRegLogon)
        {
            TraceSz4(pktWarn, "[DISCARD] SecMsg SECMSG_TYPE_XBTOXB_FORWARD to %s received %s%s",
                     pSecReg->Str(), _pSecRegLogon ? "from wrong SG (expected " : "while offline",
                     _pSecRegLogon ? _pSecRegLogon->Str() : "", _pSecRegLogon ? ")" : "");
            return;
        }

        CSecMsgXbToXbForward * pSecMsgXbToXbForward = (CSecMsgXbToXbForward *)pSecMsgHdr;

        Assert(pSecReg->TestFlags(SRF_ONLINESERVER));
        Assert(memcmp(&pSecMsgXbToXbForward->_sgaddr, &pSecReg->_sgaddr, sizeof(SGADDR)) == 0);

        IpRecvKeyEx(ppkt, 0, 0, (CKeyExHdr *)(pSecMsgXbToXbForward + 1), cb - sizeof(CSecMsgXbToXbForward));
        return;
    }

#endif

    TraceSz3(pktWarn, "[DISCARD] SecMsg to %s has unrecognized type (%d, cb=%d)",
             pSecReg->Str(), pSecMsgHdr->_wType, pSecMsgHdr->_cbEnt - sizeof(CSecMsgHdr));
    return;
}

// ---------------------------------------------------------------------------------------
// CXnIp (Xmit)
// ---------------------------------------------------------------------------------------

void CXnIp::IpXmit(CPacket * ppkt, CRouteEntry ** pprte)
{
    ICHECK(IP, UDPC|SDPC);
    Assert(ppkt->IsIp());

    ppkt->Validate();

    CIpHdr * pIpHdr = ppkt->GetIpHdr();
    CIpAddr  ipaDst = pIpHdr->_ipaDst;

    if (ipaDst.IsLoopback() || ipaDst == _ipa)
    {
        Assert(!ppkt->IsEsp());
        pIpHdr->_ipaSrc = ipaDst;
        IpXmitIp(ppkt, pprte);
        return;
    }

    if (ppkt->IsEsp())
    {
        if (ipaDst.IsBroadcast())
        {
            IpXmitEsp(ppkt, NULL, NULL);
            return;
        }

        CSecReg * pSecReg = SecRegLookup(ipaDst);
        
        if (pSecReg == NULL)
        {
            TraceSz1(pktWarn, "[DISCARD] %s is not a registered secure address", ipaDst.Str());
            EnetXmit(ppkt, 0);
            return;
        }

        if (pSecReg->IsXmitReady())
        {
            IpXmitEsp(ppkt, pSecReg, pprte);
            return;
        }

#ifdef XNET_FEATURE_SG

        if (pSecReg->TestFlags(SRF_ONLINESERVER) && _uiLogonState != XN_LOGON_STATE_ONLINE)
        {
            TraceSz2(pktWarn, "[DISCARD] Secure packet to %s %s", ipaDst.Str(),
                     _uiLogonState == XN_LOGON_STATE_IDLE ? "before XOnlineLogon" :
                     _uiLogonState == XN_LOGON_STATE_PENDING ? "before XOnlineLogon has connected" :
                     "after XOnlineLogon connection lost");
            EnetXmit(ppkt, 0);
            return;
        }

#endif

        SecRegEnqueue(pSecReg, ppkt);
        return;
    }

#ifdef XNET_FEATURE_INSECURE
    if (cfgFlags & XNET_STARTUP_BYPASS_SECURITY)
    {
        ppkt->SetFlags(PKTF_XMIT_INSECURE);
    }
#endif

#if defined(XNET_FEATURE_INSECURE) || defined(XNET_FEATURE_ICMP) || defined(XNET_FEATURE_DHCP) || defined(XNET_FEATURE_DNS) || defined(XNET_FEATURE_ONLINE)

    if (ppkt->TestFlags(PKTF_XMIT_INSECURE))
    {
        pIpHdr->_ipaSrc = _ipa;
        IpXmitIp(ppkt, pprte);
        return;
    }

#endif

    TraceSz1(pktWarn, "[DISCARD] %s is not a registered secure address", ipaDst.Str());
    EnetXmit(ppkt, 0);
}

void CXnIp::IpXmitEsp(CPacket * ppkt, CSecReg * pSecReg, CRouteEntry ** pprte)
{
    ICHECK(IP, UDPC|SDPC);
    Assert(ppkt->IsIp());

    ppkt->Validate();

    CIpHdr *    pIpHdr   = ppkt->GetIpHdr();
    CEspHdr *   pEspHdr  = ppkt->GetEspHdr();
    CEspTail *  pEspTail = ppkt->GetEspTail();
    CEnetHdr *  pEnetHdr = ppkt->GetEnetHdr();
    BYTE *      pbKeySha;
    UINT        cbKeySha;
    BYTE *      pbKeyDes;
    UINT        cbKeyDes;
    BYTE *      pb;
    UINT        cb;

    if (pSecReg == NULL)
    {
        ppkt->SetFlags(PKTF_XMIT_FRAME);

        pEnetHdr->_eaSrc = _ea;
        pEnetHdr->_eaDst.SetBroadcast();
        pEnetHdr->_wType = ENET_TYPE_IP;

        pIpHdr->_ipaSrc = IPADDR_SECURE_DEFAULT;
        Assert(pIpHdr->_ipaDst.IsBroadcast());

        pEspHdr->_ipportDst = ESPUDP_CLIENT_PORT;
        pEspHdr->_dwSpi     = 0xFFFFFFFF;
        pEspHdr->_dwSeq     = 0xFFFFFFFF;

        pbKeySha = _abKeyShaLan;
        cbKeySha = sizeof(_abKeyShaLan);
        pbKeyDes = _abKeyDesLan;
        cbKeyDes = sizeof(_abKeyDesLan);
    }
    else
    {
#ifdef XNET_FEATURE_SG
        if (pSecReg->TestFlags(SRF_ONLINESERVER|SRF_ONLINEPEER))
        {
            pIpHdr->_ipaSrc = _ipa;
        }
        else
#endif
        {
            pIpHdr->_ipaSrc = IPADDR_SECURE_DEFAULT;

            ppkt->SetFlags(PKTF_XMIT_FRAME);

            pEnetHdr->_eaDst = *(CEnetAddr *)pSecReg->_xnaddr.abEnet;
            pEnetHdr->_eaSrc = _ea;
            pEnetHdr->_wType = ENET_TYPE_IP;
        }

        Assert(pSecReg->_ipaDst != 0 && pSecReg->_ipportDst != 0);

        pIpHdr->_ipaDst     = pSecReg->_ipaDst;
        pEspHdr->_ipportDst = pSecReg->_ipportDst;
        pEspHdr->_dwSpi     = pSecReg->_dwSpiXmit;
        pEspHdr->_dwSeq     = HTONL(++pSecReg->_dwSeqXmit);

        pbKeySha = pSecReg->_abKeyShaXmit;
        cbKeySha = sizeof(pSecReg->_abKeyShaXmit);
        pbKeyDes = pSecReg->_abKeyDesXmit;
        cbKeyDes = pSecReg->_cbKeyDesXmit;

        pSecReg->_dwTickXmit = TimerTick();
    }

    Assert(!!(cbKeyDes != 0) == !!ppkt->IsCrypt());
    Assert(pIpHdr->GetOptLen() == 0);

    pb = (BYTE *)(pEspHdr + 1);
    cb = ppkt->GetCb() - sizeof(CIpHdr) - sizeof(CEspHdr) - sizeof(pEspTail->_abHash);

    Assert(cb == ROUNDUP4(cb));

    ppkt->Validate();

    pEspTail->_bNextHeader = pIpHdr->_bProtocol;
    pIpHdr->_bProtocol     = IPPROTOCOL_UDP;
    pEspHdr->_ipportSrc    = ESPUDP_CLIENT_PORT;
    pEspHdr->_wLen         = HTONS(ppkt->GetCb() - sizeof(CIpHdr));

    if (ppkt->IsCrypt())
    {
        // Encrypt the packet from just after the [ESP] header to just before the _abHash in [ESPT]

        if (pSecReg == NULL)
            Rand(pb, XC_SERVICE_DES_BLOCKLEN);
        else
            memcpy(pb, pSecReg->_abIv, XC_SERVICE_DES_BLOCKLEN);

        Assert(cb == ROUNDUP8(cb));

        CryptDes(XC_SERVICE_ENCRYPT, pbKeyDes, cbKeyDes,
                 pb, pb + XC_SERVICE_DES_BLOCKLEN, cb - XC_SERVICE_DES_BLOCKLEN);

        if (pSecReg)
        {
            // Remember the last DES block to initialize the next packet's IV.  This logically
            // extends the cipher-block-chaining and prevents us from having to call Rand
            // for each packet.

            memcpy(pSecReg->_abIv, pb + cb - XC_SERVICE_DES_BLOCKLEN, XC_SERVICE_DES_BLOCKLEN);
        }
    }

    // Authenicate the packet from the [ESP] header to just before the _abHash in [ESPT]

    BYTE abHash[XC_SERVICE_DIGEST_SIZE];
    Assert(sizeof(pEspTail->_abHash) <= sizeof(abHash));

    XcHMAC(pbKeySha, cbKeySha, (BYTE *)&pEspHdr->_dwSpi, (sizeof(CEspHdr) - sizeof(CUdpHdr)) + cb,
           NULL, 0, abHash);
    memcpy(pEspTail->_abHash, abHash, sizeof(pEspTail->_abHash));

    TraceSz4(pktXmit, "[ESP %s #%d]%s[%d][ESPT]",
             CIpAddr(pEspHdr->_dwSpi).Str(), NTOHL(pEspHdr->_dwSeq),
             ppkt->TestFlags(PKTF_CRYPT) ? "[IV]" : "",
             cb - offsetof(CEspTail, _abHash) - (ppkt->TestFlags(PKTF_CRYPT) ? XC_SERVICE_DES_BLOCKLEN : 0));

    IpXmitIp(ppkt, pprte);
}

void CXnIp::IpXmitKeyEx(CSecReg * pSecReg)
{
    if (pSecReg->_bState == SR_STATE_IDLE)
    {
        pSecReg->_bState = SR_STATE_INITSENT;
        pSecReg->_bRetry = SecRegRexmitRetries(pSecReg);
        SecRegSetTicks(pSecReg);
        Rand(pSecReg->_abNonceInit, sizeof(pSecReg->_abNonceInit));
        TimerSet(&pSecReg->_timer, TimerTick() + SecRegRexmitTimeoutInSeconds(pSecReg) * TICKS_PER_SECOND);
    }

#ifdef XNET_FEATURE_SG
    if (pSecReg->TestFlags(SRF_ONLINESERVER))
    {
        IpXmitKeyExXbToSg(pSecReg);
        return;
    }
#endif

    IpXmitKeyExXbToXb(pSecReg);
}

void CXnIp::IpXmitKeyExXbToXb(CSecReg * pSecReg, BOOL fInhibitNatOpen)
{
    ICHECK(IP, UDPC|SDPC);

    Assert(pSecReg->_bState == SR_STATE_INITSENT || pSecReg->_bState == SR_STATE_RESPSENT);
    Assert(pSecReg->_bState != SR_STATE_INITSENT || pSecReg->TestFlags(SRF_OWNED));

#ifdef XNET_FEATURE_SG
    if (pSecReg->TestFlags(SRF_ONLINEPEER) && _uiLogonState != XN_LOGON_STATE_ONLINE)
    {
        TraceSz2(pktWarn, "[DISCARD] KeyExXbToXb%s to online-peer %s while offline",
                 pSecReg->_bState == SR_STATE_INITSENT ? "Init" : "Resp", pSecReg->Str());
        return;
    }
#endif

    UINT cbKeyEx = sizeof(CKeyExXbToXb) + sizeof(CKeyExHdr) + CBDHG1 + sizeof(CKeyExHdr) + XC_SERVICE_DIGEST_SIZE;

    CPacket * ppkt = PacketAlloc(PTAG_CKeyExPacket, PKTF_TYPE_UDP|PKTF_POOLALLOC, sizeof(DWORD) + cbKeyEx);

    if (ppkt == NULL)
    {
        TraceSz(Warning, "IpXmitKeyExXbToXb - Out of memory allocating packet");
        return;
    }

    CEnetHdr *  pEnetHdr  = ppkt->GetEnetHdr();
    CIpHdr *    pIpHdr    = ppkt->GetIpHdr();
    CEspHdr *   pEspHdr   = (CEspHdr *)(pIpHdr + 1);

    IpFillHdr(ppkt, 0, IPPROTOCOL_UDP);

#ifdef XNET_FEATURE_SG
    if (pSecReg->TestFlags(SRF_ONLINEPEER))
    {
        pIpHdr->_ipaSrc = _ipa;

        if (pSecReg->_ipaDst != 0)
        {
            // We've received a packet directly from the other side at least once, so we'll
            // send the response back there.

            Assert(pSecReg->_ipaDst != 0 && pSecReg->_ipportDst != 0);

            pIpHdr->_ipaDst     = pSecReg->_ipaDst;
            pEspHdr->_ipportDst = pSecReg->_ipportDst;
        }
        else if (pSecReg->_xnaddr.inaOnline.s_addr == _pSecRegLogon->_ipaNat)
        {
            // The other side has the same IP address as this side from the perspective
            // of the security gateways.  This implies that the two sides are behind the same
            // NAT, so we should address packets to the inner IP address behind the NAT (i.e.
            // the actual IP address of the xbox).

            Assert(pSecReg->_xnaddr.ina.s_addr != 0);

            pIpHdr->_ipaDst     = pSecReg->_xnaddr.ina.s_addr;
            pEspHdr->_ipportDst = ESPUDP_CLIENT_PORT;
        }
        else
        {
            // Our best guess is to send a packet to the return IP address and port that the
            // security gateway the other side is connected to is reporting as its return address.
            // Depending on how strict a NAT device is in front of the xbox, if any, this
            // packet may or may not make it through.

            Assert(pSecReg->_xnaddr.inaOnline.s_addr != 0 && pSecReg->_xnaddr.wPortOnline != 0);

            pIpHdr->_ipaDst     = pSecReg->_xnaddr.inaOnline.s_addr;
            pEspHdr->_ipportDst = pSecReg->_xnaddr.wPortOnline;
        }

        if (    pSecReg->_bState == SR_STATE_INITSENT
            &&  pSecReg->_bRetry < cfgKeyExXbToXbRexmitRetries
            &&  pSecReg->_xnaddr.inaOnline.s_addr != _pSecRegLogon->_ipaNat
            && !fInhibitNatOpen)
        {
            // This is a retransmission of a key exchange initiator.  In case the other side
            // is behind a NAT (other than ours) that is not letting our packet through,
            // we'll transmit a CKeyExNatOpen message via the SG forwarding mechanism.  This
            // is guaranteed to arrive because every xbox that is online is maintaining a
            // bidirectional connection to a security gateway, and all security gateways have
            // direct access to each other.

            CKeyReg *       pKeyReg = pSecReg->_pKeyReg;
            CKeyExNatOpen   KeyExNatOpen;

            KeyExNatOpen._wType = KEYEX_TYPE_NATOPEN_INIT;
            KeyExNatOpen._cbEnt = sizeof(CKeyExNatOpen);
            KeyExNatOpen._xnkid = pSecReg->_pKeyReg->_xnkid;
            KeyExNatOpen._dwCtx = pSecReg->_dwSpiRecv;

            Assert(sizeof(KeyExNatOpen._abNonce) == sizeof(pSecReg->_abNonceInit));
            memcpy(KeyExNatOpen._abNonce, pSecReg->_abNonceInit, sizeof(KeyExNatOpen._abNonce));

            KeyExNatOpen._ipaDst    = _pSecRegLogon->_ipaNat;
            KeyExNatOpen._ipportDst = _pSecRegLogon->_ipportNat;
            KeyExNatOpen._wFlags    = KNOF_XBTOXB_KEYEX;

            Assert(sizeof(KeyExNatOpen._abHash) == XC_SERVICE_DIGEST_SIZE);
            XcHMAC(pKeyReg->_abKeySha, sizeof(pKeyReg->_abKeySha), (BYTE *)&KeyExNatOpen,
                   offsetof(CKeyExNatOpen, _abHash), NULL, 0, KeyExNatOpen._abHash);

            TraceSz3(secStat, "Sending KeyExNatOpen INIT/%04X packet to %s via SGADDR %s",
                     KeyExNatOpen._wFlags, pSecReg->Str(),
                     HexStr(pSecReg->_xnaddr.abOnline, sizeof(pSecReg->_xnaddr.abOnline)));

            IpXmitSecMsg(_pSecRegLogon, SECMSG_TYPE_XBTOXB_FORWARD,
                         pSecReg->_xnaddr.abOnline, sizeof(pSecReg->_xnaddr.abOnline),
                         &KeyExNatOpen, sizeof(CKeyExNatOpen));
        }
    }
    else
#endif
    {
        ppkt->SetFlags(PKTF_XMIT_FRAME);

        pEnetHdr->_eaDst    = *(CEnetAddr *)pSecReg->_xnaddr.abEnet;
        pEnetHdr->_eaSrc    = _ea;
        pEnetHdr->_wType    = ENET_TYPE_IP;

        pIpHdr->_ipaSrc     = IPADDR_SECURE_DEFAULT;
        pIpHdr->_ipaDst     = IPADDR_SECURE_DEFAULT;
        pEspHdr->_ipportDst = ESPUDP_CLIENT_PORT;
    }

    // Fill in the UDP header plus the SPI = 0 indicator of the ESP header

    pEspHdr->_wLen      = NTOHS(sizeof(CUdpHdr) + sizeof(DWORD) + cbKeyEx);
    pEspHdr->_ipportSrc = ESPUDP_CLIENT_PORT;
    pEspHdr->_wChecksum = 0;
    pEspHdr->_dwSpi     = 0;

    IpFillKeyExXbToXb(pSecReg, (CKeyExXbToXb *)&pEspHdr->_dwSeq);

    TraceSz4(secStat, "Sending KeyExXbToXb%s packet to %s via %s:%d",
             pSecReg->_bState == SR_STATE_INITSENT ? "Init" : "Resp", pSecReg->Str(),
             pIpHdr->_ipaDst.Str(), NTOHS(pEspHdr->_ipportDst));

    IpXmitIp(ppkt, NULL);
}

void CXnIp::IpFillKeyExXbToXb(CSecReg * pSecReg, CKeyExXbToXb * pKeyExXbToXb)
{
    memset(pKeyExXbToXb, 0, sizeof(CKeyExXbToXb));

    CKeyReg * pKeyReg = pSecReg->_pKeyReg;

    pKeyExXbToXb->_cbEnt   = sizeof(CKeyExXbToXb);
    pKeyExXbToXb->_xnkid   = pKeyReg->_xnkid;
    pKeyExXbToXb->_liTime  = _liTime;
    _liTime.QuadPart      += 1;

    if (pSecReg->_bState == SR_STATE_INITSENT)
    {
        pKeyExXbToXb->_wType     = KEYEX_TYPE_XBTOXB_INIT;
        pKeyExXbToXb->_dwSpiInit = pSecReg->_dwSpiRecv;

        Assert(sizeof(pKeyExXbToXb->_abNonceInit) == sizeof(pSecReg->_abNonceInit));
        memcpy(pKeyExXbToXb->_abNonceInit, pSecReg->_abNonceInit, sizeof(pKeyExXbToXb->_abNonceInit));

        IpGetXnAddr(&pKeyExXbToXb->_xnaddrInit);
        pKeyExXbToXb->_xnaddrResp = pSecReg->_xnaddr;
    }
    else
    {
        pKeyExXbToXb->_wType     = KEYEX_TYPE_XBTOXB_RESP;
        pKeyExXbToXb->_dwSpiInit = pSecReg->_dwSpiXmit;
        pKeyExXbToXb->_dwSpiResp = pSecReg->_dwSpiRecv;

        Assert(sizeof(pKeyExXbToXb->_abNonceInit) == sizeof(pSecReg->_abNonceInit));
        memcpy(pKeyExXbToXb->_abNonceInit, pSecReg->_abNonceInit, sizeof(pKeyExXbToXb->_abNonceInit));
        Assert(sizeof(pKeyExXbToXb->_abNonceResp) == sizeof(pSecReg->_abNonceResp));
        memcpy(pKeyExXbToXb->_abNonceResp, pSecReg->_abNonceResp, sizeof(pKeyExXbToXb->_abNonceResp));

        pKeyExXbToXb->_xnaddrInit = pSecReg->_xnaddr;
        IpGetXnAddr(&pKeyExXbToXb->_xnaddrResp);
    }

    // Encrypt the portion of this entry which contains the XNADDR structures to prevent
    // observers from seeing any addressing information

    Rand(pKeyExXbToXb->_abIv, sizeof(pKeyExXbToXb->_abIv));
    CryptDes(XC_SERVICE_ENCRYPT, pKeyReg->_abKeyDes, sizeof(pKeyReg->_abKeyDes),
             pKeyExXbToXb->_abIv, pKeyExXbToXb->_abIv + XC_SERVICE_DES_BLOCKLEN,
             sizeof(CKeyExXbToXb) - offsetof(CKeyExXbToXb, _abIv) - XC_SERVICE_DES_BLOCKLEN);

    // Fill in the DH key exchange entry next

    CKeyExHdr * pKeyExDh = (CKeyExHdr *)((BYTE *)pKeyExXbToXb + pKeyExXbToXb->_cbEnt);

    pKeyExDh->_wType = KEYEX_TYPE_DH_GX;
    pKeyExDh->_cbEnt = sizeof(CKeyExHdr) + CBDHG1;

    Assert(sizeof(pKeyReg->_abDhGX) == CBDHG1);
    memcpy(pKeyExDh + 1, pKeyReg->_abDhGX, CBDHG1);

    // Fill in the HMAC_SHA key exchange entry

    CKeyExHdr * pKeyExSha = (CKeyExHdr *)((BYTE *)pKeyExDh + pKeyExDh->_cbEnt);

    pKeyExSha->_wType = KEYEX_TYPE_HMAC_SHA;
    pKeyExSha->_cbEnt = sizeof(CKeyExHdr) + XC_SERVICE_DIGEST_SIZE;
    XcHMAC(pKeyReg->_abKeySha, sizeof(pKeyReg->_abKeySha),
           (BYTE *)pKeyExXbToXb, (BYTE *)pKeyExSha - (BYTE *)pKeyExXbToXb,
           NULL, 0, (BYTE *)(pKeyExSha + 1));
}

#ifdef XNET_FEATURE_SG

void CXnIp::IpXmitKeyExXbToSg(CSecReg * pSecReg)
{
    ICHECK(IP, UDPC|SDPC);
    Assert(pSecReg->_bState == SR_STATE_INITSENT);

    BYTE *  pbKeyHmac;
    UINT    cbKeyHmac;
    BYTE *  pbDhGX;
    UINT    cbDhGX;
    UINT    cbApReqMax;
    DWORD   dwUserPerm;
    
#ifdef XNET_FEATURE_INSECURE

    if (pSecReg->_dwServiceId == 0)
    {
        pbKeyHmac  = _abKeyNull;
        cbKeyHmac  = sizeof(_abKeyNull);
        pbDhGX     = _abDhGXNull;
        cbDhGX     = sizeof(_abDhGXNull);
        cbApReqMax = sizeof(CKeyExNullApReq); 
        dwUserPerm = 0xE0A06020;

        goto ServiceDone;
    }

#endif

#ifdef XNET_FEATURE_ONLINE
    {
        XOKERBINFO * pxokerbinfo = _pXoBase ? _pXoBase->XoKerbGetInfo(pSecReg->_dwServiceId) : NULL;

        if (pxokerbinfo != NULL)
        {
            pbKeyHmac  = pxokerbinfo->_abKey;
            cbKeyHmac  = sizeof(pxokerbinfo->_abKey);
            pbDhGX     = pxokerbinfo->_abDhGX;
            cbDhGX     = sizeof(pxokerbinfo->_abDhGX);
            cbApReqMax = sizeof(CKeyExHdr) + pxokerbinfo->_cbApReqMax;
            dwUserPerm = pxokerbinfo->_dwUserPerm;
            
            goto ServiceDone;
        }
    }

#endif

    TraceSz2(Warning, "IpXmitKeyExXbToSgInit to %s service %08lX is invalid",
             pSecReg->Str(), pSecReg->_dwServiceId);
    return;

ServiceDone:

    UINT cbKeyEx = sizeof(CKeyExXbToSgInit) + sizeof(CKeyExHdr) + CBDHG1 + cbApReqMax;

    CPacket * ppkt = PacketAlloc(PTAG_CKeyExPacket, PKTF_TYPE_UDP|PKTF_POOLALLOC, sizeof(DWORD) + cbKeyEx);

    if (ppkt == NULL)
    {
        TraceSz1(Warning, "IpXmitKeyExXbToSgInit to %s - Out of memory allocating packet", pSecReg->Str());
        return;
    }

    CIpHdr *    pIpHdr    = ppkt->GetIpHdr();
    CEspHdr *   pEspHdr   = (CEspHdr *)(pIpHdr + 1);
    CKeyExHdr * pKeyExHdr = (CKeyExHdr *)&pEspHdr->_dwSeq;

    // Fill in the IP header

    IpFillHdr(ppkt, pSecReg->_ipaDst, IPPROTOCOL_UDP);
    pIpHdr->_ipaSrc = _ipa;

    // Fill in the UDP header plus the SPI = 0 indicator of the ESP header

    pEspHdr->_ipportDst = ESPUDP_CLIENT_PORT;
    pEspHdr->_ipportSrc = ESPUDP_CLIENT_PORT;
    pEspHdr->_wChecksum = 0;
    pEspHdr->_dwSpi     = 0;

    // Fill in the first key exchange entry

    CKeyExXbToSgInit * pKeyExXbToSgInit = (CKeyExXbToSgInit *)pKeyExHdr;

    pKeyExXbToSgInit->_wType   = KEYEX_TYPE_XBTOSG_INIT;
    pKeyExXbToSgInit->_cbEnt   = sizeof(CKeyExXbToSgInit);
    pKeyExXbToSgInit->_dwFlags = 0;

#ifdef XNET_FEATURE_SG
    if (_pSecRegLogon == pSecReg)
    {
        pKeyExXbToSgInit->_dwFlags |= XSIF_CONNECTION_SERVICE;
    }
#endif

    pKeyExXbToSgInit->_dwSpiInit = pSecReg->_dwSpiRecv;
    pKeyExXbToSgInit->_dwUserPerm = dwUserPerm;

    Assert(sizeof(pKeyExXbToSgInit->_abNonceInit) == sizeof(pSecReg->_abNonceInit));
    memcpy(pKeyExXbToSgInit->_abNonceInit, pSecReg->_abNonceInit, sizeof(pKeyExXbToSgInit->_abNonceInit));

    // Fill in the DH key exchange entry next

    CKeyExHdr * pKeyExDh = (CKeyExHdr *)((BYTE *)pKeyExHdr + pKeyExHdr->_cbEnt);

    pKeyExDh->_wType = KEYEX_TYPE_DH_GX;
    pKeyExDh->_cbEnt = sizeof(CKeyExHdr) + CBDHG1;

    Assert(cbDhGX == CBDHG1);
    memcpy(pKeyExDh + 1, pbDhGX, CBDHG1);

    // Fill in the APREQ key exchange entry

    CKeyExHdr * pKeyExApReq = (CKeyExHdr *)((BYTE *)pKeyExDh + pKeyExDh->_cbEnt);

    BYTE abSha[XC_SERVICE_DIGEST_SIZE];

    XcHMAC(pbKeyHmac, cbKeyHmac, (BYTE *)pKeyExXbToSgInit, (BYTE *)pKeyExApReq - (BYTE *)pKeyExXbToSgInit,
           NULL, 0, abSha);

#ifdef XNET_FEATURE_INSECURE

    if (pSecReg->_dwServiceId == 0)
    {
        CKeyExNullApReq * pKeyExNullApReq = (CKeyExNullApReq *)pKeyExApReq;

        pKeyExNullApReq->_wType  = KEYEX_TYPE_NULL_APREQ;
        pKeyExNullApReq->_cbEnt  = sizeof(CKeyExNullApReq);
        pKeyExNullApReq->_liTime = _liTime;
        _liTime.QuadPart += 1;

        Assert(sizeof(pKeyExNullApReq->_abSha) == sizeof(abSha));
        memcpy(pKeyExNullApReq->_abSha, abSha, sizeof(pKeyExNullApReq->_abSha));

        memset(&pKeyExNullApReq->_AuthData, 0, sizeof(pKeyExNullApReq->_AuthData));
        pKeyExNullApReq->_AuthData.SetCb(sizeof(pKeyExNullApReq->_AuthData));
        pKeyExNullApReq->_AuthData.wAuthDataVersion = XONLINE_AUTHDATA_VERSION;
        pKeyExNullApReq->_AuthData.dwAuthDataSize = sizeof(XKERB_AD_XBOX);

        #ifdef XNET_FEATURE_ONLINE
        if (_pXoBase)
        {
            _pXoBase->XoKerbGetAuthData(&pKeyExNullApReq->_AuthData);
        }
        else
        #endif
        {
            memset(&pKeyExNullApReq->_AuthData.qwXboxID, 0xAA, sizeof(pKeyExNullApReq->_AuthData.qwXboxID));
            memcpy(&pKeyExNullApReq->_AuthData.qwXboxID, _ea._ab, sizeof(_ea));

            XOUSERINFO * pxouserinfo    = _axouserinfo;
            XOUSERINFO * pxouserinfoEnd = _axouserinfo + dimensionof(_axouserinfo);
            XUID *       pxuid          = pKeyExNullApReq->_AuthData.users;

            Assert(dimensionof(_axouserinfo) == dimensionof(pKeyExNullApReq->_AuthData.users));

            for (; pxouserinfo < pxouserinfoEnd; ++pxouserinfo, ++pxuid)
            {
                pxuid->qwUserID = pxouserinfo->_qwUserId;
            }
        }

        goto ApReqDone;
    }

#endif

#ifdef XNET_FEATURE_ONLINE

    {
        UINT cbApReq = cbApReqMax - sizeof(CKeyExHdr);

        if (!_pXoBase->XoKerbBuildApReq(pSecReg->_dwServiceId, &pSecReg->_liTime, abSha, sizeof(abSha),
                                    (BYTE *)(pKeyExApReq + 1), &cbApReq))
        {
            TraceSz1(Warning, "IpXmitKeyExXbToSgInit to %s - XoKerbBuildApReq failed", pSecReg->Str());
            return;
        }

        pKeyExApReq->_wType = KEYEX_TYPE_KERB_APREQ;
        pKeyExApReq->_cbEnt = sizeof(CKeyExHdr) + cbApReq;
        goto ApReqDone;
    }

#endif

ApReqDone:

    // Shrink the size of the packet if the ApReq is smaller than the space allocated

    Assert(cbApReqMax >= pKeyExApReq->_cbEnt);

    UINT cbExtra = cbApReqMax - pKeyExApReq->_cbEnt;
    ppkt->SetCb(ppkt->GetCb() - cbExtra);
    pEspHdr->_wLen = HTONS(sizeof(CUdpHdr) + sizeof(DWORD) + cbKeyEx - cbExtra);
    pIpHdr->_wLen = HTONS(pIpHdr->GetLen() - cbExtra);

    TraceSz3(secStat, "Sending KeyExXbToSgInit packet to %s via %s:%d",
             pSecReg->Str(), pIpHdr->_ipaDst.Str(), NTOHS(pEspHdr->_ipportDst));

    IpXmitIp(ppkt, NULL);
}

#endif

void CXnIp::IpXmitSecMsg(CSecReg * pSecReg, WORD wType, void * pv1, UINT cb1, void * pv2, UINT cb2)
{
    ICHECK(IP, UDPC|SDPC);

    TraceSz3(secStat, "Sending SecMsg packet to %s (%04X, cb=%d)", pSecReg->Str(), wType, cb1+cb2);

    CPacket * ppkt = PacketAlloc(PTAG_CSecMsgPacket, PKTF_POOLALLOC|PKTF_TYPE_ESP|PKTF_CRYPT, sizeof(CSecMsgHdr) + cb1 + cb2);

    if (ppkt == NULL)
    {
        TraceSz(Warning, "IpXmitSecMsg - Out of memory allocating packet");
        return;
    }

    // Fill in the IP header

    IpFillHdr(ppkt, pSecReg->_dwSpiRecv, IPPROTOCOL_SECMSG);

    // Fill in the payload

    CSecMsgHdr * pSecMsgHdr = (CSecMsgHdr *)((BYTE *)ppkt->GetEspHdr() + sizeof(CEspHdr) + XC_SERVICE_DES_BLOCKLEN);

    pSecMsgHdr->_wType = wType;
    pSecMsgHdr->_cbEnt = sizeof(CSecMsgHdr) + cb1 + cb2;

    if (cb1 > 0)
    {
        memcpy(pSecMsgHdr + 1, pv1, cb1);
    }

    if (cb2 > 0)
    {
        memcpy((BYTE *)(pSecMsgHdr + 1) + cb1, pv2, cb2);
    }

    TraceSz2(pktXmit, "[SecMsg %04X]{+%d}", wType, cb1 + cb2);

    IpXmitEsp(ppkt, pSecReg, NULL);
}

void CXnIp::IpXmitSecMsgDelete(CSecReg * pSecReg, DWORD dwReason)
{
    ICHECK(IP, UDPC|SDPC);

    IpXmitSecMsg(pSecReg, SECMSG_TYPE_DELETE, &dwReason, sizeof(dwReason));
}

#ifdef XNET_FEATURE_SG

void CXnIp::IpXmitSecMsgXbToSgPulse(CSecReg * pSecReg)
{
    ICHECK(IP, UDPC|SDPC);

    BYTE                    ab[sizeof(CSecMsgXbToSgPulse) + dimensionof(_axouserinfo) * (1 + sizeof(DWORD) + sizeof(XNKID) + 1 + sizeof(_axouserinfo[0]._abData))];
    DWORD                   dwSeqXmit           = pSecReg->_dwSeqXmit;
    CSecMsgXbToSgPulse *    pSecMsgXbToSgPulse  = (CSecMsgXbToSgPulse *)ab;
    BYTE *                  pb                  = &ab[sizeof(CSecMsgXbToSgPulse)];

    if (pSecReg == _pSecRegLogon)
    {
        pSecMsgXbToSgPulse->_dwSeqAck = _dwSeqSgToXb;

        if (*(DWORD *)_abXbToSgPulse != 0)
        {
            XOUSERINFO * pxouserinfo    = _axouserinfo;
            XOUSERINFO * pxouserinfoEnd = _axouserinfo + dimensionof(_axouserinfo);
            BYTE *       pbXbToSgPulse  = _abXbToSgPulse;

            for (; pxouserinfo < pxouserinfoEnd; ++pxouserinfo, ++pbXbToSgPulse)
            {
                BYTE b = *pbXbToSgPulse;

                if (b != 0)
                {
                    Assert((b &  (XBPULSE_USER_INDEX_MASK)) == pxouserinfo - _axouserinfo);
                    Assert((b & ~(XBPULSE_USER_INDEX_MASK|XBPULSE_STATE_CHANGE|XBPULSE_XNKID_CHANGE|XBPULSE_TDATA_CHANGE)) == 0);
                    Assert((b &  (XBPULSE_STATE_CHANGE|XBPULSE_XNKID_CHANGE|XBPULSE_TDATA_CHANGE)) != 0);

                    *pb++ = b;

                    if (b & XBPULSE_STATE_CHANGE)
                    {
                        *(DWORD *)pb = pxouserinfo->_dwPState;
                        pb += sizeof(DWORD);
                    }

                    if (b & XBPULSE_XNKID_CHANGE)
                    {
                        *(XNKID *)pb = pxouserinfo->_xnkid;
                        pb += sizeof(XNKID);
                    }

                    if (b & XBPULSE_TDATA_CHANGE)
                    {
                        Assert(pxouserinfo->_cbData <= sizeof(pxouserinfo->_abData));

                        *pb++ = (BYTE)pxouserinfo->_cbData;

                        if (pxouserinfo->_cbData > 0)
                        {
                            memcpy(pb, pxouserinfo->_abData, pxouserinfo->_cbData);
                            pb += pxouserinfo->_cbData;
                        }
                    }
                }
            }
        }
    }
    else
    {
        pSecMsgXbToSgPulse->_dwSeqAck = 0;
    }

    Assert(pb - ab <= sizeof(ab));

    IpXmitSecMsg(pSecReg, SECMSG_TYPE_XBTOSG_PULSE, &ab[sizeof(CSecMsgHdr)], pb - ab - sizeof(CSecMsgHdr));

    if (pSecReg->_dwSeqXmit > dwSeqXmit)
    {
        Assert(pSecReg->_dwSeqXmit == dwSeqXmit + 1);

        pSecReg->_dwTickPulse = TimerTick();

        if (pSecReg == _pSecRegLogon)
        {
            _dwSeqSgToXb = 0;

            if (*(DWORD *)_abXbToSgPulse != 0)
            {
                _dwSeqXbToSg = pSecReg->_dwSeqXmit;
            }
        }
    }
}

#endif

void CXnIp::IpXmitIp(CPacket * ppkt, CRouteEntry ** pprte)
{
    ICHECK(IP, UDPC|SDPC);
    Assert(ppkt->IsIp());
    
    CIpHdr *        pIpHdr   = ppkt->GetIpHdr();
    CIpAddr         ipaDst   = pIpHdr->_ipaDst;
    UINT            cbHdrLen = pIpHdr->GetHdrLen();
    UINT            cbLen    = ppkt->GetCb();
    UINT            uiChecksum;
    CPseudoHeader   ph;

    Assert(pIpHdr->_ipaSrc != 0 || _ipa == 0);
    Assert(pIpHdr->_ipaDst != 0);

    TraceIpHdr(pktXmit, pIpHdr, ppkt->GetCb() - pIpHdr->GetHdrLen());

    pIpHdr->_wChecksum = 0;
    pIpHdr->_wChecksum = (WORD)~tcpipxsum(0, pIpHdr, cbHdrLen);

    if (ppkt->IsUdp() || ppkt->IsEsp())
    {
        CUdpHdr * pUdpHdr   = (CUdpHdr *)((BYTE *)pIpHdr + cbHdrLen);
        ph._ipaSrc          = pIpHdr->_ipaSrc;
        ph._ipaDst          = ipaDst;
        ph._bZero           = 0;
        ph._bProtocol       = IPPROTOCOL_UDP;
        ph._wLen            = HTONS(cbLen - cbHdrLen);
        pUdpHdr->_wChecksum = 0;
        uiChecksum          = ~tcpipxsum(tcpipxsum(0, &ph, sizeof(ph)), pUdpHdr, cbLen - cbHdrLen);
        pUdpHdr->_wChecksum = uiChecksum - (uiChecksum == 0);
    }
#ifdef XNET_FEATURE_INSECURE
    else if (ppkt->IsTcp())
    {
        CTcpHdr * pTcpHdr   = (CTcpHdr *)((BYTE *)pIpHdr + cbHdrLen);
        ph._ipaSrc          = pIpHdr->_ipaSrc;
        ph._ipaDst          = ipaDst;
        ph._bZero           = 0;
        ph._bProtocol       = IPPROTOCOL_TCP;
        ph._wLen            = HTONS(cbLen - cbHdrLen);
        pTcpHdr->_wChecksum = 0;
        pTcpHdr->_wChecksum = ~tcpipxsum(tcpipxsum(0, &ph, sizeof(ph)), pTcpHdr, cbLen - cbHdrLen);
    }
#endif

#ifdef XNET_FEATURE_ROUTE

    if (    !ppkt->TestFlags(PKTF_XMIT_FRAME)
        &&   ipaDst != _ipa
        &&  !ipaDst.IsLoopback()
        &&  !ipaDst.IsBroadcast())
    {
        CRouteEntry * prte = pprte ? *pprte : NULL;

        Assert(!prte || prte->_ipaDst == (ipaDst & prte->_ipaMask));

        if (prte == NULL || prte->IsOrphan())
        {
            if (prte)
            {
                RouteRelease(prte);
            }

            prte = RouteLookup(ipaDst);

            if (pprte)
            {
                *pprte = prte;
            }

            if (prte == NULL)
            {
                TraceSz1(pktWarn, "[DISCARD] No route found to %s", ipaDst.Str());
                EnetXmit(ppkt, 0);
                return;
            }
        }

        if (!prte->IsLocal())
        {
            ipaDst = prte->_ipaNext;
        }

        if (prte && pprte == NULL)
        {
            RouteRelease(prte);
        }
    }

#endif

#ifdef XNET_FEATURE_TRACE
    if (Tag(tcpRetrans) && ppkt->IsTcp() && ppkt->IsEsp() && ppkt->IsCrypt() && !ppkt->TestFlags(PKTF_XMIT_PRIORITY))
    {
        // This causes encrypted TCP packets to fail on first transmit, and it used to
        // test the decrypt-before-retransmit code path.

        ppkt->ClearFlags(PKTF_XMIT_FRAME);
        ipaDst = 0;
    }
#endif

    EnetXmit(ppkt, ipaDst);
    return;
}

// --------------------------------------------------------------------------------------
// CXnIp (Xmit Helpers)
// --------------------------------------------------------------------------------------

void CXnIp::IpFillAndXmit(CPacket * ppkt, CIpAddr ipaDst, BYTE bProtocol, CRouteEntry ** pprte)
{
    ICHECK(IP, USER|UDPC|SDPC);
    IpFillHdr(ppkt, ipaDst, bProtocol);
    RaiseToDpc();
    IpXmit(ppkt, pprte);
}

void CXnIp::IpFillHdr(CPacket * ppkt, CIpAddr ipaDst, BYTE bProtocol)
{
    ICHECK(IP, USER|UDPC|SDPC);
    Assert(ppkt->IsIp());
    Assert(ppkt->GetHdrOptLen() == 0);

    CIpHdr * pIpHdr = ppkt->GetIpHdr();
    pIpHdr->SetHdrLen(sizeof(CIpHdr));
    pIpHdr->_bTos       = cfgIpDefaultTos;
    pIpHdr->_wLen       = HTONS((WORD)ppkt->GetCb());
    pIpHdr->_wId        = HTONS(GetNextDgramId());
    pIpHdr->_wFragOff   = 0;
    pIpHdr->_bTtl       = cfgIpDefaultTtl;
    pIpHdr->_bProtocol  = bProtocol;
    pIpHdr->_ipaSrc     = 0;
    pIpHdr->_ipaDst     = ipaDst;
}

// ---------------------------------------------------------------------------------------
// CXnIp (Frag)
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_FRAG

class CFragPacket : public CPacket
{
    friend class CXnIp;

    CTimer      _timer;         // reassembly timeout timer
    CIpAddr     _ipaSrc;        // source IP address
    CIpAddr     _ipaDst;        // destination IP address
    DWORD       _dwProtoId;     // protocol and datagram ID
    UINT        _cbHdrLen;      // length of reassembled datagram header
    UINT        _cbLen;         // length of reassembled datagram payload
    UINT        _cBitRecv;      // number of chunks of payload received so far
    UINT        _cBitTotal;     // total number of chunks of payload expected
    UINT        _iBitEnd;       // highest bit position filled so far
    BYTE        _abBits[1];     // vector of bit flags for which payload fragments have arrived

    INLINE void SetBit(UINT iBit)
    {
        BYTE * pb = &_abBits[iBit / 8];
        UINT iMask = (1 << (iBit % 8));
        _cBitRecv += !(*pb & iMask);
        *pb |= iMask;
    }
};

void CXnIp::FragTerm()
{
    TCHECK(UDPC);

    while (_cFrag > 0)
    {
        FragFree(_pqFrag.GetHead());
    }
}

void CXnIp::FragFree(CPacket * ppkt)
{
    ICHECK(IP, UDPC|SDPC);

    Assert(ppkt != NULL);
    Assert(_cFrag > 0);
    Assert(_cFrag == _pqFrag.Count());

    _pqFrag.Dequeue(ppkt);
    _cFrag -= 1;

    Assert(_cFrag == _pqFrag.Count());

    TimerSet(&((CFragPacket *)ppkt)->_timer, TIMER_INFINITE);

#ifdef XNET_FEATURE_FRAG_LOOPBACK
    ppkt->ClearFlags(PKTF_RECV_LOOPBACK);
#endif

    PacketFree(ppkt);
}

void CXnIp::FragTimer(CTimer * pt)
{
    ICHECK(IP, UDPC|SDPC);

    CFragPacket * ppktFrag = (CFragPacket *)((BYTE *)pt - offsetof(CFragPacket, _timer));
    TraceSz3(Warning, "FragTimer - Packet reassembly timeout [IP %s %s (%08lX)]",
             ppktFrag->_ipaDst.Str(), ppktFrag->_ipaSrc.Str(), ppktFrag->_dwProtoId);
    FragFree(ppktFrag);
}

void CXnIp::FragRecv(CPacket * ppkt, CIpHdr * pIpHdr, UINT cbHdrLen, UINT cbLen)
{
    ICHECK(IP, UDPC|SDPC);

    CFragPacket *   ppktFrag;
    DWORD           dwProtoId;
    UINT            uiFragOff;
    BOOL            fMoreFrag;
    UINT            cbPkt;
    UINT            ibEnd;
    UINT            iBit, iBitEnd;

    uiFragOff  = NTOHS(pIpHdr->_wFragOff);
    fMoreFrag  = !!(uiFragOff & MORE_FRAGMENTS);
    uiFragOff &= (uiFragOff & FRAGOFFSET_MASK);
    dwProtoId  = (NTOHS(pIpHdr->_wId) << 16) | pIpHdr->_bProtocol;
    ppktFrag   = (CFragPacket *)_pqFrag.GetHead();

    for (; ppktFrag; ppktFrag = (CFragPacket *)ppktFrag->GetNextPkt())
    {
        if (    ppktFrag->_dwProtoId == dwProtoId
            &&  ppktFrag->_ipaSrc == pIpHdr->_ipaSrc
            &&  ppktFrag->_ipaDst == pIpHdr->_ipaDst)
            break;
    }
    
    if (ppktFrag == NULL)
    {
        if (_cFrag >= cfgIpFragMaxSimultaneous)
        {
            TraceSz(pktWarn, "[DISCARD] Too many fragmented IP datagrams needing reassembly");
            return;
        }

        cbPkt  = offsetof(CFragPacket, _abBits);
        cbPkt += ((cfgIpFragMaxPacketDiv256 * 256) / 8 + 7) / 8;
        cbPkt  = ROUNDUP4(cbPkt);

        ppktFrag = (CFragPacket *)PacketAlloc(PTAG_CFragPacket, PKTF_TYPE_ENET|PKTF_POOLALLOC,
                                              cfgIpFragMaxPacketDiv256 * 256,
                                              cbPkt, (PFNPKTFREE)FragFree);

        if (ppktFrag == NULL)
        {
            TraceSz(pktWarn, "[DISCARD] Out of memory allocating CFragPacket");
            return;
        }

#ifdef XNET_FEATURE_FRAG_LOOPBACK
        if (ppkt->TestFlags(PKTF_RECV_LOOPBACK))
        {
            ppktFrag->SetFlags(PKTF_RECV_LOOPBACK);
        }
#endif

        ppktFrag->_timer.Init((PFNTIMER)FragTimer);
        ppktFrag->_ipaSrc    = pIpHdr->_ipaSrc;
        ppktFrag->_ipaDst    = pIpHdr->_ipaDst;
        ppktFrag->_dwProtoId = dwProtoId;
        ppktFrag->_cbHdrLen  = 0;
        ppktFrag->_cbLen     = 0;
        ppktFrag->_cBitRecv  = 0;
        ppktFrag->_cBitTotal = 0;
        ppktFrag->_iBitEnd   = 0;
        memset(ppktFrag->_abBits, 0, cbPkt - offsetof(CFragPacket, _abBits));
        TimerSet(&ppktFrag->_timer, TimerTick() + cfgIpFragTimeoutInSeconds * TICKS_PER_SECOND);

        Assert(_cFrag == _pqFrag.Count());
        _pqFrag.InsertTail(ppktFrag);
        _cFrag += 1;
        Assert(_cFrag == _pqFrag.Count());
    }

    if (uiFragOff == 0)
    {
        if (ppktFrag->_cbHdrLen > 0)
        {
            if (ppktFrag->_cbHdrLen != cbHdrLen)
            {
                TraceSz2(pktWarn, "[DISCARD] Duplicate first fragment and header sizes don't match (%d vs. %d)",
                         ppktFrag->_cbHdrLen, cbHdrLen);
                goto fragfree;
            }

            TraceSz(pktWarn, "[DISCARD] Ignoring duplicate first fragment");
            return;
        }

        memcpy((BYTE *)ppktFrag->GetPv() + MAXIPHDRLEN - cbHdrLen, pIpHdr, cbHdrLen);
        ppktFrag->_cbHdrLen = cbHdrLen;
    }

    cbLen -= cbHdrLen;

    if (cbLen > 0)
    {
        ibEnd   = (uiFragOff * 8) + cbLen;
        iBit    = uiFragOff;
        iBitEnd = iBit + (cbLen + 7) / 8;

        if (MAXIPHDRLEN + ibEnd > ppktFrag->GetCb())
        {
            TraceSz1(pktWarn, "[DISCARD] Maximum reassembly size exceeded (%d)", ibEnd);
            goto fragfree;
        }

        if (fMoreFrag)
        {
            if ((cbLen % 8) != 0)
            {
                TraceSz1(pktWarn, "[DISCARD] Fragment with MF flag has non 8-byte multiple payload (%d)", cbLen);
                goto fragfree;
            }
        }
        else
        {
            if (ppktFrag->_cbLen == 0)
            {
                if (ppktFrag->_iBitEnd >= iBitEnd)
                {
                    TraceSz(pktWarn, "[DISCARD] Fragments received past end of last fragment");
                    goto fragfree;
                }

                ppktFrag->_cbLen     = ibEnd;
                ppktFrag->_cBitTotal = iBitEnd;
            }
            else if (ppktFrag->_cbLen != ibEnd)
            {
                TraceSz2(pktWarn, "[DISCARD] Last fragment was duplicated and has a different size (%d vs. %d)",
                         ppktFrag->_cbLen, ibEnd);
                goto fragfree;
            }
        }

        memcpy((BYTE *)ppktFrag->GetPv() + MAXIPHDRLEN + (uiFragOff * 8), (BYTE *)pIpHdr + cbHdrLen, cbLen);

        if (ppktFrag->_cBitTotal && iBitEnd > ppktFrag->_cBitTotal)
        {
            TraceSz(pktWarn, "[DISCARD] Fragment received past end of last fragment");
            goto fragfree;
        }

        if (ppktFrag->_iBitEnd < iBitEnd)
            ppktFrag->_iBitEnd = iBitEnd;

        for (; iBit < iBitEnd; ++iBit)
        {
            ppktFrag->SetBit(iBit);
            Assert(ppktFrag->_cBitTotal == 0 || ppktFrag->_cBitRecv <= ppktFrag->_cBitTotal);
        }
    }

    if (ppktFrag->_cbHdrLen && ppktFrag->_cbLen && ppktFrag->_cBitRecv == ppktFrag->_cBitTotal)
    {
        ppktFrag->SetPv((BYTE *)ppktFrag->GetPv() + MAXIPHDRLEN - ppktFrag->_cbHdrLen);
        ppktFrag->SetCb(ppktFrag->_cbHdrLen + ppktFrag->_cbLen);
        ppktFrag->SetType(PKTF_TYPE_IP);

        pIpHdr              = ppktFrag->GetIpHdr();
        pIpHdr->_wLen       = HTONS((WORD)ppktFrag->GetCb());
        pIpHdr->_wFragOff   = 0;
        pIpHdr->_wChecksum  = 0;
        pIpHdr->_wChecksum  = (WORD)~tcpipxsum(0, pIpHdr, ppktFrag->_cbHdrLen);

        TraceSz(pktRecv, "Fragment processing complete.  Processing reassembled packet.");
        IpRecv(ppktFrag);
        goto fragfree;
    }

    TraceSz4(pktRecv, "[FRAGHOLD] Waiting for more fragments (cbHdrLen=%ld,cBitRecv=%ld,cBitTotal=%ld,cbLen=%ld)",
             ppktFrag->_cbHdrLen, ppktFrag->_cBitRecv, ppktFrag->_cBitTotal, ppktFrag->_cbLen);
    return;

fragfree:
    FragFree(ppktFrag);
    return;
}

#endif // XNET_FEATURE_FRAG

// ---------------------------------------------------------------------------------------
// CXnIp (Route)
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ROUTE

NTSTATUS CXnIp::RouteInit()
{
    TCHECK(USER);

    InitializeListHead(&_leRouteList);
    Assert(_ipaDstLast == 0);
    Assert(_prteLast == NULL);

    return(NETERR_OK);
}

void CXnIp::RouteTerm()
{
    TCHECK(UDPC);
    RouteListOrphan();
}

void CXnIp::RouteInvalidateCache()
{
    ICHECK(IP, UDPC|SDPC);
    _ipaDstLast = 0;
    _prteLast = NULL;
}

void CXnIp::RouteListOrphan()
{
    ICHECK(IP, UDPC|SDPC);

    if (!IsListNull(&_leRouteList))
    {
        CRouteEntry * prte = (CRouteEntry *)_leRouteList.Flink;
        CRouteEntry * prteNext;

        while (prte != (CRouteEntry *)&_leRouteList)
        {
            prteNext = (CRouteEntry *)prte->_le.Flink;
            RouteEntryOrphan(prte);
            prte = prteNext;
        }
    }
}

void CXnIp::RouteEntryOrphan(CRouteEntry * prte)
{
    ICHECK(IP, UDPC|SDPC);

    RouteInvalidateCache();

    AssertListEntry(&_leRouteList, &prte->_le);
    RemoveEntryList(&prte->_le);

    prte->SetFlags(RTEF_ORPHAN);
    RouteRelease(prte);
}

CRouteEntry * CXnIp::RouteLookup(CIpAddr ipaDst)
{
    ICHECK(IP, UDPC|SDPC);

    CRouteEntry *    prte;
    CRouteEntry *    prteNext;
    CRouteEntry *    prteFound;

    if (ipaDst == 0)
    {
        return(NULL);
    }

    if (ipaDst == _ipaDstLast)
    {
        // _prteLast may be NULL if the last successful lookup for this IP address
        // failed to find any route for it.  RouteAdd will invalidate the cache
        // and force a slow lookup.  Until then, quickly keep responding that
        // there is no route entry for this IP address.

        if (_prteLast)
            _prteLast->AddRef();

        return(_prteLast);
    }

    prte = (CRouteEntry *)_leRouteList.Flink;
    prteFound = NULL;

    while (prte != (CRouteEntry *)&_leRouteList)
    {
        prteNext = (CRouteEntry *)prte->_le.Flink;

        if ((ipaDst & prte->_ipaMask) == prte->_ipaDst)
        {
            prteFound = prte;
            prte->AddRef();
            break;
        }

        prte = prteNext;
    }

    _ipaDstLast = ipaDst;
    _prteLast = prteFound;

    return(prteFound);
}

void CXnIp::RouteAdd(CIpAddr ipaDst, CIpAddr ipaMask, CIpAddr ipaNext, WORD wFlags, WORD wMetric)
{
    ICHECK(IP, UDPC|SDPC);

    CRouteEntry *    prte;
    CRouteEntry *    prteNext;
    CRouteEntry *    prteNew;

    // Validate input parameters:
    //  - address mask must be of the form 111...000
    //      be careful about the byte order
    //  - next hop address cannot be a broadcast address

    ipaDst = ipaDst & ipaMask;

    if (    (!ipaDst.IsValidUnicast() && !(wFlags & RTEF_DEFAULT))
        ||  !ipaNext.IsValidUnicast()
        ||  !ipaMask.IsValidMask())
    {
        TraceSz1(Warning, "Bad route to %s:", ipaDst.Str());
        TraceSz1(Warning, "  mask = %s", ipaMask.Str());
        TraceSz1(Warning, "  nexthop = %s", ipaNext.Str());
        return;
    }

    // Find out if the specified route is already in the table
    
    AssertList(&_leRouteList);

    prte    = (CRouteEntry *)_leRouteList.Flink;
    prteNew = NULL;

    while (prte != (CRouteEntry *)&_leRouteList)
    {
        prteNext = (CRouteEntry *)prte->_le.Flink;

        if (    prte->_ipaDst == ipaDst
            &&  prte->_ipaMask == ipaMask
            &&  (ipaMask != 0 || prte->_ipaNext == ipaNext))
        {
            // Update the existing route information
            prteNew = prte;
            RemoveEntryList(&prte->_le);
            break;
        }

        prte = prteNext;
    }
    
    if (prteNew == NULL)
    {
        prteNew = (CRouteEntry *)PoolAllocZ(sizeof(CRouteEntry), PTAG_CRouteEntry);
        
        if (prteNew == NULL)
        {
            TraceSz(Warning, "CXnIp::RouteAdd - Out of memory allocating route entry");
            return;
        }

        prteNew->_cRefs = 1;
    }

    RouteInvalidateCache();

    prteNew->_wFlags  = wFlags;
    prteNew->_wMetric = wMetric;
    prteNew->_ipaDst  = ipaDst;
    prteNew->_ipaMask = ipaMask;
    prteNew->_ipaNext = ipaNext;

    // Insert the new route into the table
    //  sorted by the mask length and route metric

    AssertList(&_leRouteList);

    prte = (CRouteEntry *)_leRouteList.Flink;

    while (prte != (CRouteEntry *)&_leRouteList)
    {
        prteNext = (CRouteEntry *)prte->_le.Flink;

        if (    ipaMask > prte->_ipaMask
            ||  (   ipaMask == prte->_ipaMask
                 && wMetric < prte->_wMetric))
        {
            break;
        }

        prte = prteNext;
    }

    prteNew->_le.Flink = (LIST_ENTRY *)prte;
    prteNew->_le.Blink = prte->_le.Blink;
    prte->_le.Blink->Flink = (LIST_ENTRY *)prteNew;
    prte->_le.Blink = (LIST_ENTRY *)prteNew;

    AssertList(&_leRouteList);
}

void CXnIp::RouteDelete(CIpAddr ipaDst, CIpAddr ipaMask, CIpAddr ipaNext)
{
    ICHECK(IP, UDPC|SDPC);

    CRouteEntry *    prte;
    CRouteEntry *    prteNext;

    RaiseToDpc();

    AssertList(&_leRouteList);

    prte = (CRouteEntry *)_leRouteList.Flink;

    while (prte != (CRouteEntry *)&_leRouteList)
    {
        prteNext = (CRouteEntry *)prte->_le.Flink;

        if (    prte->_ipaDst == ipaDst
            &&  prte->_ipaMask == ipaMask
            &&  prte->_ipaNext == ipaNext)
        {
            RouteEntryOrphan(prte);
            break;
        }

        prte = prteNext;
    }
}

void CXnIp::RouteRedirect(CIpAddr ipaDst, CIpAddr ipaOldGateway, CIpAddr ipaNewGateway)
{
    ICHECK(IP, SDPC);

    CRouteEntry * prte;

    // The redirected destination must be a unicast address
    if (!ipaDst.IsValidUnicast())
        return;

    // Validate the new gateway address:
    //  must be a unicast address on the same subnet
    //  through which the redirect message arrived
    if (    !ipaNewGateway.IsValidUnicast()
        ||  _ipaSubnet != (ipaNewGateway & _ipaMask))
        return;

    // Find the current route to the destination
    // and see if the sender of the redirect message
    // is the current next-hop gateway

    prte = RouteLookup(ipaDst);

    if (prte == NULL)
    {
        return;
    }
    else if (prte->_ipaNext != ipaOldGateway)
    {
        RouteRelease(prte);
        return;
    }

    // Add a new host route
    RouteAdd(ipaDst, 0xFFFFFFFF, ipaNewGateway, RTEF_HOST, RTE_DEFAULT_METRIC);
}

void CXnIp::RouteRelease(CRouteEntry * prte)
{
    ICHECK(IP, USER|UDPC|SDPC);

    if (InterlockedDecrement(&prte->_cRefs) == 0)
    {
        Assert(prte->IsOrphan());
        PoolFree(prte);
    }
}

#if DBG

void CXnIp::RouteListDump()
{
    ICHECK(IP, USER|UDPC|SDPC);

    RaiseToDpc();

    TraceSz(Verbose, "\n*** Route table:\n");

    CRouteEntry * prte = (CRouteEntry *)_leRouteList.Flink;

    while (prte != (CRouteEntry *)&_leRouteList)
    {
        TraceSz6(Verbose, "%s/%s/%s %02X %d %d", prte->_ipaDst.Str(), prte->_ipaMask.Str(),
                 prte->_ipaNext.Str(), prte->_wFlags, prte->_wMetric, prte->_cRefs);
        prte = (CRouteEntry *)prte->_le.Flink;
    }
}

#endif

#endif

// ---------------------------------------------------------------------------------------
// CXnIp (Register / Unregister Key)
// ---------------------------------------------------------------------------------------

INT CXnIp::IpRegisterKey(const XNKID * pxnkid, const XNKEY * pxnkey)
{
    ICHECK(IP, USER);

#ifdef XNET_FEATURE_SG
    if (!XNetXnKidIsSystemLink(pxnkid) && !XNetXnKidIsOnlinePeer(pxnkid))
#else
    if (!XNetXnKidIsSystemLink(pxnkid))
#endif
    {
        TraceSz1(Warning, "IpRegisterKey - XNKID %s is not peer-to-peer", HexStr(pxnkid->ab, sizeof(pxnkid->ab)));
        return(WSAEINVAL);
    }

    BYTE abHash[XC_SERVICE_DIGEST_SIZE];
    BYTE abDhX[CBDHG1];
    BYTE abDhGX[CBDHG1];

    // HMAC the key with the LAN keys as a precaution against the title not keeping
    // its key private (by sending it in cleartext over the network, for example).
    // This means that even if you intercept an XNKEY you still need to figure
    // out the LAN key to make use of it.

    XcHMAC(_abKeyShaLan, sizeof(_abKeyShaLan), (BYTE *)pxnkid->ab, sizeof(pxnkid->ab),
           (BYTE *)pxnkey->ab, sizeof(pxnkey->ab), abHash);

    // Generate a diffie-hellman X and g^X for use in key-exchange

    Rand(abDhX, sizeof(abDhX));
    XcModExp((DWORD *)abDhGX, (DWORD *)g_abOakleyGroup1Base, (DWORD *)abDhX,
             (DWORD *)g_abOakleyGroup1Mod, CBDHG1 / sizeof(DWORD));

    RaiseToDpc();

    CKeyReg * pKeyReg = KeyRegLookup(pxnkid);

    if (pKeyReg != NULL)
    {
        TraceSz1(Warning, "IpRegisterKey - XNKID %s is already registered", HexStr(pxnkid->ab, sizeof(pxnkid->ab)));
        return(WSAEALREADY);
    }

    if (_cKeyReg == cfgKeyRegMax)
    {
        TraceSz1(Warning, "IpRegisterKey - Reached config limit for key registrations (%d)", cfgKeyRegMax);
        return(WSAENOMORE);
    }

    pKeyReg = &_pKeyReg[_cKeyReg++];
    pKeyReg->_xnkid = *pxnkid;
    memcpy(pKeyReg->_abKeySha, abHash, sizeof(pKeyReg->_abKeySha));
    memcpy(pKeyReg->_abKeyDes, &abHash[sizeof(abHash) - sizeof(pKeyReg->_abKeyDes)], sizeof(pKeyReg->_abKeyDes));
    memcpy(pKeyReg->_abDhX, abDhX, sizeof(pKeyReg->_abDhX));
    memcpy(pKeyReg->_abDhGX, abDhGX, sizeof(pKeyReg->_abDhGX));
    XcDESKeyParity(pKeyReg->_abKeyDes, sizeof(pKeyReg->_abKeyDes));
    pKeyReg->_pQosReg = NULL;

    TraceSz1(secStat, "XNKID %s: Registered", HexStr(pxnkid->ab, sizeof(pxnkid->ab)));

    return(0);
}

INT CXnIp::IpCreateKey(XNKID * pxnkid, XNKEY * pxnkey)
{
    ICHECK(IP, USER|UDPC);
    Rand((BYTE *)pxnkid, sizeof(XNKID));
    Rand((BYTE *)pxnkey, sizeof(XNKEY));
    pxnkid->ab[0] &= ~XNET_XNKID_MASK;
    pxnkid->ab[0] |=  XNET_XNKID_SYSTEM_LINK;
    return(0);
}

INT CXnIp::IpUnregisterKey(const XNKID * pxnkid)
{
    ICHECK(IP, USER|UDPC);

    RaiseToDpc();

    CKeyReg * pKeyReg = KeyRegLookup(pxnkid);

    if (pKeyReg == NULL)
    {
        TraceSz1(Warning, "IpUnregisterKey - XNKID %s is not registered", HexStr(pxnkid->ab, sizeof(pxnkid->ab)));
        return(WSAEINVAL);
    }

#if 0
//@@@
    if (pKeyReg->_pbQos)
    {
        SysFree(pKeyReg->_pbQos);
        pKeyReg->_pbQos = NULL;
        pKeyReg->_cbQos = 0;
    }
#endif

    TraceSz1(secStat, "XNKID %s: Unregistered", HexStr(pxnkid->ab, sizeof(pxnkid->ab)));

    CKeyReg *   pKeyRegLast = &_pKeyReg[--_cKeyReg];
    UINT        cSecReg     = cfgSecRegMax;
    CSecReg *   pSecReg     = _pSecReg;

    // Move the last entry to this spot to keep the table contiguous

    *pKeyReg = *pKeyRegLast;

    // Free any CSecReg that points at the deleted key entry.  Update any CSecReg that
    // pointed to the last CKeyReg that was just moved.

    for (; cSecReg > 0; ++pSecReg, --cSecReg)
    {
        if (pSecReg->_dwSpiRecv)
        {
            if (pSecReg->_pKeyReg == pKeyReg)
            {
                if (pSecReg->IsXmitReady() && !pSecReg->TestFlags(SRF_SECMSG_DELETE))
                {
                    pSecReg->SetFlags(SRF_SECMSG_DELETE);
                    IpXmitSecMsgDelete(pSecReg, SECMSG_DELETE_UNREGISTER);
                }

                SecRegFree(pSecReg);
            }
            else if (pSecReg->_pKeyReg == pKeyRegLast)
            {
                pSecReg->_pKeyReg = pKeyReg;
            }
        }
    }

    return(0);
}

// ---------------------------------------------------------------------------------------
// CXnIp (KeyRegLookup / KeyRegKey)
// ---------------------------------------------------------------------------------------

CXnIp::CKeyReg * CXnIp::KeyRegLookup(const XNKID * pxnkid)
{
    ICHECK(IP, UDPC|SDPC);

    CKeyReg *   pKeyReg = _pKeyReg;
    UINT        cKeyReg = _cKeyReg;

    for (; cKeyReg-- > 0; ++pKeyReg)
    {
        if (memcmp(pKeyReg->_xnkid.ab, pxnkid->ab, sizeof(XNKID)) == 0)
        {
            return(pKeyReg);
        }
    }

    return(NULL);
}

// ---------------------------------------------------------------------------------------
// CXnIp (DES Encrypt / Decrypt)
// ---------------------------------------------------------------------------------------

void CXnIp::CryptDes(DWORD dwOp, BYTE * pbKey, UINT cbKey, BYTE * pbIv, BYTE * pb, UINT cb)
{
    Assert(cbKey == XC_SERVICE_DES_KEYSIZE || cbKey == XC_SERVICE_DES3_KEYSIZE);
    BYTE abDesTable[XC_SERVICE_DES3_TABLESIZE];
    BYTE abFeedback[XC_SERVICE_DES_BLOCKLEN];

    XcKeyTable(cbKey == XC_SERVICE_DES_KEYSIZE ? XC_SERVICE_DES_CIPHER : XC_SERVICE_DES3_CIPHER,
               abDesTable, pbKey);
    memcpy(abFeedback, pbIv, XC_SERVICE_DES_BLOCKLEN);
    XcBlockCryptCBC(cbKey == XC_SERVICE_DES_KEYSIZE ? XC_SERVICE_DES_CIPHER : XC_SERVICE_DES3_CIPHER,
                    cb, pb, pb, abDesTable, dwOp, abFeedback);
}

// ---------------------------------------------------------------------------------------
// CXnIp (InAddr)
// ---------------------------------------------------------------------------------------

INT CXnIp::IpXnAddrToInAddr(const XNADDR * pxna, const XNKID * pxnkid, CIpAddr * pipa)
{
    ICHECK(IP, USER);

    // The InAddr for the local host is the loopback address

    if (_ea.IsEqual(pxna->abEnet))
    {
        *pipa = IPADDR_LOOPBACK;
        return(0);
    }

#ifdef XNET_FEATURE_SG

    if (XNetXnKidIsOnlinePeer(pxnkid) && pxna->inaOnline.s_addr == 0)
    {
        TraceSz2(Warning, "IpXnAddrToInAddr - XNKID %s is online-peer but XNADDR %s is system-link",
                 HexStr(pxnkid->ab, sizeof(pxnkid->ab)), XnAddrStr(pxna));
        return(WSAEINVAL);
    }

#endif

    RaiseToDpc();

    // See if we have a CSecReg already for this XNADDR and XNKID

    CSecReg * pSecReg = SecRegLookup(pxna, pxnkid);

    if (pSecReg == NULL)
    {
        CKeyReg * pKeyReg = KeyRegLookup(pxnkid);

        if (pKeyReg == NULL)
        {
            TraceSz1(Warning, "IpXnAddrToInAddr - XNKID %s is not registered", HexStr(pxnkid->ab, sizeof(pxnkid->ab)));
            return(WSAEINVAL);
        }

        pSecReg = SecRegAlloc(pxna, pKeyReg);

        if (pSecReg == NULL)
        {
            return(WSAENOMORE);
        }
    }
    else
    {
        // Update the XNADDR of the CSecReg in case it has been updated with new
        // online information.

        pSecReg->_xnaddr = *pxna;
    }

    pSecReg->SetFlags(SRF_OWNED);

    *pipa = CIpAddr(pSecReg->_dwSpiRecv);

    return(0);
}

INT CXnIp::IpServerToInAddr(const CIpAddr ipa, DWORD dwServiceId, CIpAddr * pipa)
{
    ICHECK(IP, USER);

    if (!ipa.IsValidUnicast())
    {
        TraceSz1(Warning, "IpServerToInAddr - %s is not a valid unicast IP address", ipa.Str());
        return(WSAEINVAL);
    }

    RaiseToDpc();

#ifdef XNET_FEATURE_SG

    XOKERBINFO * pxokerbinfo;

#ifdef XNET_FEATURE_INSECURE

    if (dwServiceId == 0)
    {
        pxokerbinfo = NULL;
        goto ServiceDone;
    }

#endif

#ifdef XNET_FEATURE_ONLINE

    pxokerbinfo = _pXoBase ? _pXoBase->XoKerbGetInfo(dwServiceId) : NULL;

    if (pxokerbinfo != NULL)
        goto ServiceDone;

#endif

#endif

    TraceSz1(Warning, "IpServerToInAddr - dwServiceId %08lX is not available", dwServiceId);
    return(WSAEINVAL);

#ifdef XNET_FEATURE_SG

ServiceDone:

    // See if we have a CSecReg already for this XNADDR and XOKERBINFO

    CSecReg * pSecReg = SecRegLookup(ipa, dwServiceId, pxokerbinfo);

    if (pSecReg == NULL)
    {
        pSecReg = SecRegAlloc(ipa, dwServiceId);

        if (pSecReg == NULL)
        {
            return(WSAENOMORE);
        }
    }

    *pipa = CIpAddr(pSecReg->_dwSpiRecv);

    return(0);

#endif

}

INT CXnIp::IpInAddrToXnAddr(const CIpAddr ipa, XNADDR * pxna, XNKID * pxnkid)
{
    ICHECK(IP, USER|UDPC|SDPC);

    if (pxna)
    {
        memset(pxna, 0, sizeof(XNADDR));
    }

    if (pxnkid)
    {
        memset(pxnkid, 0, sizeof(XNKID));
    }

    if (ipa == IPADDR_LOOPBACK)
    {
        if (pxna)
        {
            IpGetXnAddr(pxna);
        }

        return(0);
    }

    RaiseToDpc();

    CSecReg * pSecReg = ipa.IsSecure() ? SecRegLookup(ipa) : NULL;

    if (pSecReg == NULL)
    {
        TraceSz1(Warning, "IpInAddrToXnAddr - %s is not a registered secure address", ipa.Str());
        return(WSAEINVAL);
    }

#ifdef XNET_FEATURE_SG
    if (pSecReg->TestFlags(SRF_ONLINESERVER))
    {
        TraceSz1(Warning, "IpInAddrToXnAddr - %s is a secure address to a server.  Cannot convert to XNADDR.", ipa.Str());
        return(WSAEINVAL);
    }
#endif

    if (pxna)
    {
        *pxna = pSecReg->_xnaddr;
    }

    if (pxnkid)
    {
        *pxnkid = pSecReg->_pKeyReg->_xnkid;
    }

    return(0);
}

INT CXnIp::IpUnregisterInAddr(const CIpAddr ipa)
{
    ICHECK(IP, USER|UDPC|SDPC);
    
    RaiseToDpc();

    CSecReg * pSecReg = ipa.IsSecure() ? SecRegLookup(ipa) : NULL;

    if (pSecReg == NULL)
    {
        TraceSz1(Warning, "IpUnregisterInAddr - %s is not a registered secure address", ipa.Str());
        return(WSAEINVAL);
    }
    
#ifdef XNET_FEATURE_SG

    if (pSecReg == _pSecRegLogon)
    {
        TraceSz1(Warning, "IpUnregisterInAddr - %s cannot be manually unregistered", ipa.Str());
        return(WSAEINVAL);
    }

#endif

    if (pSecReg->_bState == SR_STATE_RESPSENT)
    {
        // The other side is in initiating key-exchange with us, so just forget that we have
        // seen this secure address.

        pSecReg->ClearFlags(SRF_OWNED);
    }
    else
    {
        // Shutdown the security association and let the other side know if necessary.

        if (pSecReg->IsXmitReady() && !pSecReg->TestFlags(SRF_SECMSG_DELETE))
        {
            IpXmitSecMsgDelete(pSecReg, SECMSG_DELETE_SHUTDOWN);
        }

        SecRegFree(pSecReg);
    }

    return(0);
}

// ---------------------------------------------------------------------------------------
// CXnIp (SecRegLookup / SecRegAlloc / SecRegFree)
// ---------------------------------------------------------------------------------------

CXnIp::CSecReg * CXnIp::SecRegLookup(const XNADDR * pxna, const XNKID * pxnkid)
{
    ICHECK(IP, UDPC|SDPC);

    CSecReg *   pSecReg = _pSecReg;
    UINT        cSecReg = cfgSecRegMax;

    for (; cSecReg > 0; ++pSecReg, --cSecReg)
    {
        if (pSecReg->_dwSpiRecv == 0 || pSecReg->TestFlags(SRF_ONLINESERVER))
            continue;

        if (memcmp(pSecReg->_xnaddr.abEnet, pxna->abEnet, sizeof(CEnetAddr)) != 0)
            continue;

        if (memcmp(&pSecReg->_pKeyReg->_xnkid, pxnkid, sizeof(XNKID)) != 0)
            continue;

        return(pSecReg);
    }

    return(NULL);
}

#ifdef XNET_FEATURE_SG

CXnIp::CSecReg * CXnIp::SecRegLookup(const CIpAddr ipa, DWORD dwServiceId, const XOKERBINFO * pxokerbinfo)
{
    ICHECK(IP, UDPC|SDPC);

    CSecReg *   pSecReg = _pSecReg;
    UINT        cSecReg = cfgSecRegMax;

    for (; cSecReg > 0; ++pSecReg, --cSecReg)
    {
        if (pSecReg->_dwSpiRecv == 0 || !pSecReg->TestFlags(SRF_ONLINESERVER))
            continue;

        if (pSecReg->_ipaDst != ipa)
            continue;

        if (pSecReg->_dwServiceId == dwServiceId)
            return(pSecReg);

#ifdef XNET_FEATURE_ONLINE
        XOKERBINFO * pxokerbinfoReg = _pXoBase ? _pXoBase->XoKerbGetInfo(pSecReg->_dwServiceId) : NULL;
        if (pxokerbinfoReg && pxokerbinfo->_dwTicketId == pxokerbinfoReg->_dwTicketId)
            return(pSecReg);
#endif
    }

    return(NULL);
}

#endif

CXnIp::CSecReg * CXnIp::SecRegLookup(DWORD dwSpiRecv)
{
    ICHECK(IP, UDPC|SDPC);

    CSecReg * pSecReg = NULL;

    if (_pSecReg && CIpAddr(dwSpiRecv).IsSecure())
    {
        UINT uiSlot = CIpAddr(dwSpiRecv).SecureSlot();

        if (uiSlot < cfgSecRegMax)
        {
            pSecReg = &_pSecReg[uiSlot];

            if (pSecReg->_dwSpiRecv != dwSpiRecv)
            {
                pSecReg = NULL;
            }
        }
    }

    return(pSecReg);
}

CXnIp::CSecReg * CXnIp::SecRegAlloc()
{
    ICHECK(IP, UDPC|SDPC);

    CSecReg *   pSecReg = _pSecReg;
    UINT        cSecReg = cfgSecRegMax;

    for (; cSecReg > 0; ++pSecReg, --cSecReg)
    {
        if (pSecReg->_dwSpiRecv == 0)
            break;
    }

    if (cSecReg == 0)
    {
        TraceSz1(Warning, "Reached config limit for secure address registrations (%d)", cfgSecRegMax);
        return(NULL);
    }

    pSecReg->_timer.Init((PFNTIMER)SecRegTimer);

    if (++_wSecRegUniq == 0)
        ++_wSecRegUniq;

    CIpAddr ipa(_wSecRegUniq, (BYTE)(pSecReg - _pSecReg));

    pSecReg->_dwSpiRecv = ipa;

    TraceSz1(secStat, "Allocated %s", pSecReg->Str());

    return(pSecReg);
}

CXnIp::CSecReg * CXnIp::SecRegAlloc(const XNADDR * pxna, CKeyReg * pKeyReg)
{
    ICHECK(IP, UDPC|SDPC);

    CSecReg * pSecReg = SecRegAlloc();

    if (pSecReg != NULL)
    {
        pSecReg->_wFlags       = SRF_SYSTEMLINK;
        pSecReg->_xnaddr       = *pxna;
        pSecReg->_pKeyReg      = pKeyReg;
        pSecReg->_cbKeyDesRecv = XC_SERVICE_DES_KEYSIZE;
        pSecReg->_cbKeyDesXmit = XC_SERVICE_DES_KEYSIZE;
        pSecReg->_ipaDst       = IPADDR_SECURE_DEFAULT;
        pSecReg->_ipportDst    = ESPUDP_CLIENT_PORT;

#ifdef XNET_FEATURE_SG
        // For an online peer we don't know for sure the address to send packets until the
        // key exchange process is complete.  During key exchange, the _ipaDst, _ipportDst,
        // and _ipportSrc fields of the CSecReg are updated as return address information
        // becomes available.

        if (XNetXnKidIsOnlinePeer(&pKeyReg->_xnkid))
        {
            pSecReg->_wFlags    = SRF_ONLINEPEER;
            pSecReg->_ipaDst    = 0;
            pSecReg->_ipportDst = 0;
        }
#endif
    }

    return(pSecReg);
}

#ifdef XNET_FEATURE_SG

CXnIp::CSecReg * CXnIp::SecRegAlloc(const CIpAddr ipa, DWORD dwServiceId)
{
    ICHECK(IP, UDPC|SDPC);

    CSecReg * pSecReg = SecRegAlloc();

    if (pSecReg != NULL)
    {
        pSecReg->_wFlags       = SRF_ONLINESERVER|SRF_OWNED;
        pSecReg->_dwServiceId  = dwServiceId;
        pSecReg->_cbKeyDesRecv = XC_SERVICE_DES3_KEYSIZE;
        pSecReg->_cbKeyDesXmit = XC_SERVICE_DES3_KEYSIZE;
        pSecReg->_ipaDst       = ipa;
        pSecReg->_ipportDst    = ESPUDP_CLIENT_PORT;
    }

    return(pSecReg);
}

#endif

void CXnIp::SecRegFree(CSecReg * pSecReg)
{
    ICHECK(IP, UDPC|SDPC);

    if (pSecReg->_dwSpiRecv)
    {
        TraceSz1(secStat, "Deallocated %s", pSecReg->Str());
        SecRegSetIdle(pSecReg);
        memset(pSecReg, 0, sizeof(CSecReg));
    }
}

// ---------------------------------------------------------------------------------------
// CXnIp (SecReg state machine)
// ---------------------------------------------------------------------------------------

void CXnIp::SecRegEnqueue(CSecReg * pSecReg, CPacket * ppkt)
{
    ICHECK(IP, UDPC|SDPC);

    Assert(     pSecReg->_bState == SR_STATE_IDLE
           ||   pSecReg->_bState == SR_STATE_INITSENT
           ||   pSecReg->_bState == SR_STATE_RESPSENT);

    if (pSecReg->_bState == SR_STATE_IDLE)
    {
        IpXmitKeyEx(pSecReg);
    }

    // Insert the packet into the wait queue until we make it into the ready state

    pSecReg->_pqWait.InsertTail(ppkt);

    TraceSz2(secStat, "Packet enqueued to %s (%d waiting)", pSecReg->Str(), pSecReg->_pqWait.Count());
}

void CXnIp::SecRegXmitQueue(CSecReg * pSecReg)
{
    if (!pSecReg->_pqWait.IsEmpty())
    {
        TraceSz3(secStat, "Sending %d waiting packet%s to %s",
                 pSecReg->_pqWait.Count(), pSecReg->_pqWait.Count() == 1 ? "" : "s", pSecReg->Str());

        do
        {
            CPacket * ppkt = pSecReg->_pqWait.RemoveHead();
            IpXmit(ppkt, NULL);
        }
        while (!pSecReg->_pqWait.IsEmpty());
    }
}

void CXnIp::SecRegShutdown(BOOL fOnlineOnly)
{
    ICHECK(IP, UDPC|SDPC);

    CSecReg *   pSecReg = _pSecReg;
    UINT        cSecReg = cfgSecRegMax;

    for (; cSecReg > 0; ++pSecReg, --cSecReg)
    {
        if (pSecReg->_dwSpiRecv == 0)
            continue;

        if (fOnlineOnly && !pSecReg->TestFlags(SRF_ONLINEPEER|SRF_ONLINESERVER))
            continue;

        if (pSecReg->IsXmitReady() && !pSecReg->TestFlags(SRF_SECMSG_DELETE))
        {
            pSecReg->SetFlags(SRF_SECMSG_DELETE);
            IpXmitSecMsgDelete(pSecReg, SECMSG_DELETE_SHUTDOWN);
        }

        if (fOnlineOnly)
        {
            SecRegFree(pSecReg);
        }
    }
}

void CXnIp::SecRegSetIdle(CSecReg * pSecReg)
{
    ICHECK(IP, UDPC|SDPC);

    // Tell the sockets layer that this secure IP address has being disconnected.
    // Any TCP socket connected to this address will be reset.

    SockReset(CIpAddr(pSecReg->_dwSpiRecv));

    pSecReg->_wFlags   &= SRF_SYSTEMLINK|SRF_ONLINEPEER|SRF_ONLINESERVER|SRF_OWNED;
    pSecReg->_bState    = SR_STATE_IDLE;
    pSecReg->_bRetry    = 0;
    pSecReg->_dwSeqXmit = 0;
    pSecReg->_dwSeqRecv = 0;
    pSecReg->_dwSeqMask = 0;
    memset(pSecReg->_abNonceInit, 0, sizeof(pSecReg->_abNonceInit));
    memset(pSecReg->_abNonceResp, 0, sizeof(pSecReg->_abNonceResp));
    Rand(pSecReg->_abIv, sizeof(pSecReg->_abIv));
    TimerSet(&pSecReg->_timer, TIMER_INFINITE);
    pSecReg->_pqWait.Complete(this);
    SecRegSetTicks(pSecReg);

#ifdef XNET_FEATURE_SG
    if (pSecReg->_wFlags & SRF_ONLINEPEER)
    {
        pSecReg->_ipaDst    = 0;
        pSecReg->_ipportDst = 0;
    }

    if (_pSecRegLogon == pSecReg && _uiLogonState != XN_LOGON_STATE_IDLE)
    {
        _uiLogonState = XN_LOGON_STATE_OFFLINE;

        if (_pEventLogon)
        {
            EvtSet(_pEventLogon, EVENT_INCREMENT);
        }
    }

#endif
}

void CXnIp::SecRegSetTicks(CSecReg * pSecReg)
{
    ICHECK(IP, UDPC|SDPC);

    pSecReg->_dwTickRecv         = TimerTick();
    pSecReg->_dwTickXmit         = TimerTick();
    pSecReg->_dwTickPulse        = TimerTick();
    pSecReg->_dwTickPulseTimeout = cfgSecRegPulseTimeoutInSeconds * TICKS_PER_SECOND;
    pSecReg->_dwTickTimeout      = cfgSecRegTimeoutInSecondsDiv10 * 10 * TICKS_PER_SECOND;
}

void CXnIp::SecRegSetOwned(CIpAddr ipa)
{
    ICHECK(IP, USER|UDPC|SDPC);

    if (ipa.IsSecure())
    {
        RaiseToDpc();

        CSecReg * pSecReg = SecRegLookup(ipa);

        if (pSecReg != NULL)
        {
            pSecReg->SetFlags(SRF_OWNED);
        }
    }
}

void CXnIp::SecRegSetKey(CSecReg * pSecReg, BYTE * pbKeyHmac, UINT cbKeyHmac, BYTE * pbDhX, UINT cbDhX,
                         BYTE * pbDhGY, UINT cbDhGY, BOOL fInitiator)
{
    ICHECK(IP, UDPC|SDPC);

    BYTE abDhGXY[CBDHG1];

    // Generate the diffie-hellman g^XY mod p = (g^Y)^X mod p

    Assert(cbDhX == CBDHG1);
    Assert(cbDhGY == CBDHG1);
    XcModExp((DWORD *)abDhGXY, (DWORD *)pbDhGY, (DWORD *)pbDhX, (DWORD *)g_abOakleyGroup1Mod, CBDHG1 / sizeof(DWORD));

    BYTE * pbKeyOut = fInitiator ? pSecReg->_abKeyShaXmit : pSecReg->_abKeyShaRecv;

    for (int i = 0; i < 2; ++i)
    {
        for (int j = 0; j < 2; ++j)
        {
            XcHMAC(pbKeyHmac, cbKeyHmac, abDhGXY, sizeof(abDhGXY), pSecReg->_abNonceInit,
                   sizeof(pSecReg->_abNonceInit) + sizeof(pSecReg->_abNonceResp), pbKeyOut);
            pbKeyOut += XC_SERVICE_DIGEST_SIZE;
            abDhGXY[0] += 1;
        }

        pbKeyOut = fInitiator ? pSecReg->_abKeyShaRecv : pSecReg->_abKeyShaXmit;
    }

    XcDESKeyParity(pSecReg->_abKeyDesXmit, sizeof(pSecReg->_abKeyDesXmit));
    XcDESKeyParity(pSecReg->_abKeyDesRecv, sizeof(pSecReg->_abKeyDesRecv));
}

void CXnIp::SecRegTimer(CTimer * pt)
{
    ICHECK(IP, SDPC);

    CSecReg * pSecReg = (CSecReg *)((BYTE *)pt - offsetof(CSecReg, _timer));

    Assert(pSecReg->_bState == SR_STATE_INITSENT || pSecReg->_bState == SR_STATE_RESPSENT);

    TraceSz2(secStat, "KeyEx timeout to %s (bRetry %d)", pSecReg->Str(), pSecReg->_bRetry);

    if (pSecReg->_bRetry == 0)
    {
        TraceSz3(secStat, "Failed KeyEx to %s (%d packet%s flushed)",
                 pSecReg->Str(), pSecReg->_pqWait.Count(),
                 pSecReg->_pqWait.Count() == 1 ? "" : "s");

        if (!pSecReg->TestFlags(SRF_OWNED))
            SecRegFree(pSecReg);
        else
            SecRegSetIdle(pSecReg);
    }
    else
    {
        pSecReg->_bRetry -= 1;
        TimerSet(&pSecReg->_timer, TimerTick() + SecRegRexmitTimeoutInSeconds(pSecReg) * TICKS_PER_SECOND);
        IpXmitKeyEx(pSecReg);
    }
}

void CXnIp::SecRegProbe()
{
    ICHECK(IP, SDPC);

    _cSecRegProbeNumer += cfgSecRegMax;

    if (_cSecRegProbeNumer < _cSecRegProbeDenom)
        return;

    DWORD dwTickNow = TimerTick();

    UINT cSecReg = _cSecRegProbeNumer / _cSecRegProbeDenom;
    _cSecRegProbeNumer -= cSecReg * _cSecRegProbeDenom;
    Assert(_cSecRegProbeNumer < _cSecRegProbeDenom);

    CSecReg * pSecReg     = _pSecRegProbe ? _pSecRegProbe : _pSecReg;
    CSecReg * pSecRegLast = _pSecReg + cfgSecRegMax;

    for (; cSecReg > 0; --cSecReg, ++pSecReg)
    {
        if (pSecReg == pSecRegLast)
        {
            // We've run off the end of the CSecReg vector.  Start back at the beginning.

            pSecReg = _pSecReg;
        }

        if (pSecReg->_dwSpiRecv == 0)
        {
            // This CSecReg is not in use.  Go on to the next one.

            continue;
        }

        if (pSecReg->_bState < SR_STATE_INITWAIT)
        {
            // This CSecReg is in the middle of key exchange.  That process handles its
            // own timeouts.  Go on to the next one.

            continue;
        }

        if (pSecReg->_dwTickRecv <= dwTickNow - pSecReg->_dwTickTimeout)
        {
            // This CSecReg hasn't received a packet in a long enough time that the other
            // side should be considered down.

            TraceSz2(secStat, "Timeout after %d secs of no incoming packets from %s",
                     (dwTickNow - pSecReg->_dwTickRecv) / TICKS_PER_SECOND, pSecReg->Str());

            if (!pSecReg->TestFlags(SRF_OWNED))
                SecRegFree(pSecReg);
            else
                SecRegSetIdle(pSecReg);

            continue;
        }

        DWORD dwTickPulse = dwTickNow - pSecReg->_dwTickPulseTimeout;

        if (pSecReg->_dwTickPulse <= dwTickPulse)
        {
            // This CSecReg hasn't sent a pulse in a long enough time that now might be
            // a good time to send it.  We only need to send it if there have been no
            // packets transmitted recently, or if we have something to say.

#ifdef XNET_FEATURE_SG
            if (pSecReg->TestFlags(SRF_ONLINESERVER))
            {
                if (    pSecReg->_dwTickXmit <= dwTickPulse
                    || (pSecReg == _pSecRegLogon && (_dwSeqSgToXb || *(DWORD *)_abXbToSgPulse)))
                {
                    TraceSz3(secStat, "Sending pulse to %s (last xmit/pulse %d/%d secs ago)",
                             pSecReg->Str(), (dwTickNow - pSecReg->_dwTickXmit) / TICKS_PER_SECOND,
                             (dwTickNow - pSecReg->_dwTickPulse) / TICKS_PER_SECOND);
                    IpXmitSecMsgXbToSgPulse(pSecReg);
                }
                continue;
            }
#endif
            if (pSecReg->_dwTickXmit <= dwTickPulse)
            {
                TraceSz2(secStat, "Sending pulse to %s (last xmit/pulse %d/%d secs ago)",
                         pSecReg->Str(), (dwTickNow - pSecReg->_dwTickXmit) / TICKS_PER_SECOND);
                IpXmitSecMsg(pSecReg, SECMSG_TYPE_PULSE);
                pSecReg->_dwTickPulse = dwTickNow;
                continue;
            }
        }
    }

    _pSecRegProbe = pSecReg;
}

#ifdef XNET_FEATURE_TRACE

char * CXnIp::CSecReg::Str()
{
    #define SECREG_STR_BUFFS    32
    #define SECREG_BUF_SIZE     24
    static char g_chBufSecReg[SECREG_STR_BUFFS * SECREG_BUF_SIZE];
    static LONG g_lBufIndexSecReg = 0;
    char * pch = &g_chBufSecReg[(InterlockedIncrement(&g_lBufIndexSecReg) % SECREG_STR_BUFFS) * SECREG_BUF_SIZE];
    XnInAddrToString(*(IN_ADDR *)&_dwSpiRecv, pch, SECREG_BUF_SIZE);
    strcat(pch, _bState == SR_STATE_IDLE ? "/IDLE" : _bState == SR_STATE_INITSENT ? "/ISENT" :
           _bState == SR_STATE_RESPSENT ? "/RSENT" : "/READY");
    return(pch);
}

#endif

// ---------------------------------------------------------------------------------------
// CXnIp (IpDecrypt)
// ---------------------------------------------------------------------------------------

BOOL CXnIp::IpDecrypt(CPacket * ppkt, CIpAddr ipaDst)
{
    ICHECK(IP, USER|UDPC|SDPC);

    Assert(ppkt->IsEsp() && ppkt->IsCrypt());
    
    CSecReg * pSecReg = SecRegLookup(ipaDst);

    if (pSecReg == NULL)
    {
        TraceSz1(pktWarn, "IpDecrypt: %s is not a valid secure address", ipaDst.Str());
        return(FALSE);
    }

    if (!pSecReg->IsXmitReady())
    {
        TraceSz1(pktWarn, "IpDecrypt: %s is not ready for transmit", ipaDst.Str());
        return(FALSE);
    }

    // Check that the packet authenticates with the transmit SHA key

    CEspHdr *   pEspHdr     = ppkt->GetEspHdr();
    CEspTail *  pEspTail    = ppkt->GetEspTail();

    BYTE abHash[XC_SERVICE_DIGEST_SIZE];
    Assert(sizeof(pEspTail->_abHash) <= sizeof(abHash));

    XcHMAC(pSecReg->_abKeyShaXmit, sizeof(pSecReg->_abKeyShaXmit),
           (BYTE *)&pEspHdr->_dwSpi,
           (BYTE *)&pEspTail->_abHash - (BYTE *)&pEspHdr->_dwSpi,
           NULL, 0, abHash);

    if (memcmp(pEspTail->_abHash, abHash, sizeof(pEspTail->_abHash)) != 0)
    {
        TraceSz(pktWarn, "IpDecrypt: packet failed to authenticate");
        return(FALSE);
    }

    // Decrypt the packet with the transmit DES key

    BYTE * pb = (BYTE *)(pEspHdr + 1);
    CryptDes(XC_SERVICE_DECRYPT, pSecReg->_abKeyDesXmit, pSecReg->_cbKeyDesXmit,
             pb, pb + XC_SERVICE_DES_BLOCKLEN, (BYTE *)&pEspTail->_abHash - pb);

    return(TRUE);
}

// ---------------------------------------------------------------------------------------
// CXnIp (GetXnAddr)
// ---------------------------------------------------------------------------------------

DWORD CXnIp::IpGetXnAddr(XNADDR * pxna)
{
    ICHECK(IP, USER|UDPC|SDPC);

    RaiseToDpc();

    memset(pxna, 0, sizeof(XNADDR));
    pxna->ina.s_addr = _ipa;
    memcpy(pxna->abEnet, _ea._ab, sizeof(_ea));

    DWORD dwFlags = 0;

#ifdef XNET_FEATURE_SG

    if (_uiLogonState == XN_LOGON_STATE_ONLINE && _pSecRegLogon != NULL)
    {
        pxna->inaOnline.s_addr = _pSecRegLogon->_ipaNat;
        pxna->wPortOnline = _pSecRegLogon->_ipportNat;
        Assert(sizeof(pxna->abOnline) == sizeof(SGADDR));
        memcpy(pxna->abOnline, &_pSecRegLogon->_sgaddr, sizeof(pxna->abOnline));
        dwFlags |= XNET_GET_XNADDR_ONLINE;
    }

#endif

#ifdef XNET_FEATURE_DHCP

    if (_options._gatewayCount > 0)
        dwFlags |= XNET_GET_XNADDR_GATEWAY;

    if (_options._dnsServerCount > 0)
        dwFlags |= XNET_GET_XNADDR_DNS;

    if (ActiveDhcpAddr())
        dwFlags |= XNET_GET_XNADDR_DHCP;
    else if (ActiveAutonetAddr())
        dwFlags |= XNET_GET_XNADDR_AUTO;
    else if (ActiveStaticAddr())
        dwFlags |= XNET_GET_XNADDR_STATIC;
    else if (ActiveNoAddr())
        dwFlags |= XNET_GET_XNADDR_ETHERNET;

#else

    // For now on the XBOX if we are not configured for using DHCP there is no
    // way to acquire an IP address.  This is the common codepath for the secure
    // xnets.lib to take for the XTL 1.0 release.

    Assert(_ipa == 0);

    dwFlags |= XNET_GET_XNADDR_ETHERNET;

#endif

    return(dwFlags);
}

// ---------------------------------------------------------------------------------------
// Online Support
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ONLINE

void CXnIp::IpSetXoBase(CXoBase * pXoBase)
{
    ICHECK(IP, USER);

    RaiseToDpc();

    if (pXoBase == NULL)
    {
        IpLogoff();
    }

    _pXoBase = pXoBase;
}

#endif

#ifdef XNET_FEATURE_SG

void CXnIp::IpLogon(CIpAddr ipaLogon, ULONGLONG * pqwUserId, WSAEVENT hEventLogon)
{
    ICHECK(IP, USER);

    RaiseToDpc();

    Assert(_uiLogonState == XN_LOGON_STATE_IDLE);

    _pEventLogon = hEventLogon ? EvtFromHandle(hEventLogon) : NULL;

    if (_pEventLogon == NULL && hEventLogon != NULL)
    {
        TraceSz1(Warning, "IpLogon - invalid hEvent %08lX", hEventLogon);
    }

    if (ipaLogon != 0)
    {
        _pSecRegLogon = SecRegLookup(ipaLogon);

        if (_pSecRegLogon == NULL || !_pSecRegLogon->TestFlags(SRF_ONLINESERVER))
        {
            TraceSz1(Warning, "IpLogon - %s is not a valid secure address to an SG", ipaLogon.Str());
            _pSecRegLogon = NULL;
        }
    }

    if (_pSecRegLogon == NULL)
    {
        // This logon is not connecting to an SG providing connection services.  Just mark
        // the state machine as online.

        _uiLogonState = XN_LOGON_STATE_ONLINE;

        if (_pEventLogon)
        {
            EvtSet(_pEventLogon, EVENT_INCREMENT);
        }
    }
    else
    {
        _uiLogonState = XN_LOGON_STATE_PENDING;

        if (pqwUserId != NULL)
        {
            XOUSERINFO * pxouserinfo    = _axouserinfo;
            XOUSERINFO * pxouserinfoEnd = pxouserinfo + dimensionof(_axouserinfo);

            for (; pxouserinfo < pxouserinfoEnd; ++pxouserinfo, ++pqwUserId)
            {
                pxouserinfo->_qwUserId = *pqwUserId;
            }
        }

        // Kick off key exchange to the SG providing connection services.

        Assert(_pSecRegLogon->_bState == SR_STATE_IDLE);
        IpXmitKeyEx(_pSecRegLogon);
    }
}

DWORD CXnIp::IpLogonGetStatus(SGADDR * psgaddr)
{
    ICHECK(IP, USER|UDPC);

    RaiseToDpc();

    if (psgaddr != NULL)
    {
        if (_pSecRegLogon != NULL && _uiLogonState == XN_LOGON_STATE_ONLINE)
            *psgaddr = _pSecRegLogon->_sgaddr;
        else
            memset(psgaddr, 0, sizeof(SGADDR));
    }

    return(_uiLogonState);
}

BOOL CXnIp::IpLogonGetQFlags(UINT iUserId, ULONGLONG * pqwUserId, DWORD * pdwQFlags, DWORD * pdwSeqQFlags)
{
    ICHECK(IP, USER|UDPC);

    RaiseToDpc();

    if (iUserId < dimensionof(_axouserinfo))
    {
        XOUSERINFO * pxouserinfo = &_axouserinfo[iUserId];

        if (pqwUserId != NULL)
        {
            *pqwUserId = pxouserinfo->_qwUserId;
        }

        if (pdwQFlags != NULL)
        {
            *pdwQFlags = pxouserinfo->_dwQFlags;
        }

        if (pdwSeqQFlags != NULL)
        {
            *pdwSeqQFlags = pxouserinfo->_dwSeqQFlags;
        }

        return(TRUE);
    }

    return(FALSE);
}

BOOL CXnIp::IpLogonSetQFlags(UINT iUserId, DWORD dwQFlags, DWORD dwSeqQFlags)
{
    ICHECK(IP, USER|UDPC);

    RaiseToDpc();

    if (iUserId < dimensionof(_axouserinfo))
    {
        XOUSERINFO * pxouserinfo = &_axouserinfo[iUserId];

        if (pxouserinfo->_dwSeqQFlags < dwSeqQFlags)
        {
            pxouserinfo->_dwSeqQFlags = dwSeqQFlags;
            pxouserinfo->_dwQFlags    = dwQFlags;

            if (_pEventLogon)
            {
                EvtSet(_pEventLogon, EVENT_INCREMENT);
            }
        }

        return(TRUE);
    }

    return(FALSE);
}

BOOL CXnIp::IpLogonSetPState(UINT iUserId, DWORD dwPState, const XNKID * pxnkid, UINT cbData, BYTE * pbData)
{
    ICHECK(IP, USER|UDPC);

    RaiseToDpc();

    if (iUserId < dimensionof(_axouserinfo) && cbData <= sizeof(_axouserinfo[0]._abData))
    {
        XOUSERINFO * pxouserinfo = &_axouserinfo[iUserId];
        BYTE *       pb          = &_abXbToSgPulse[iUserId];

        if (pxouserinfo->_dwPState != dwPState)
        {
            pxouserinfo->_dwPState = dwPState;

            *pb |= (BYTE)iUserId | XBPULSE_STATE_CHANGE;
        }

        if (memcmp(&pxouserinfo->_xnkid, pxnkid, sizeof(XNKID)) != 0)
        {
            pxouserinfo->_xnkid = *pxnkid;

            *pb |= (BYTE)iUserId | XBPULSE_XNKID_CHANGE;
        }

        if (cbData != pxouserinfo->_cbData || memcmp(pxouserinfo->_abData, pbData, cbData) != 0)
        {
            pxouserinfo->_cbData = cbData;

            if (cbData > 0)
            {
                memcpy(pxouserinfo->_abData, pbData, cbData);
            }

            *pb |= (BYTE)iUserId | XBPULSE_TDATA_CHANGE;
        }

        return(TRUE);
    }

    return(FALSE);
}

void CXnIp::IpLogoff()
{
    ICHECK(IP, USER|UDPC);

    RaiseToDpc();

    _uiLogonState = XN_LOGON_STATE_IDLE;
    _pSecRegLogon = NULL;

    if (_pEventLogon)
    {
        EvtDereference(_pEventLogon);
        _pEventLogon = NULL;
    }

    memset(&_axouserinfo, 0, sizeof(_axouserinfo));
    *(DWORD *)_abXbToSgPulse = 0;
    _dwSeqXbToSg = 0;
    _dwSeqSgToXb = 0;

    SecRegShutdown(TRUE);
}

#endif

// ---------------------------------------------------------------------------------------
// CXnIp::IpSetEventTimer / CXnIp::EventTimer
// ---------------------------------------------------------------------------------------

void CXnIp::IpSetEventTimer(CEventTimer * pEventTimer, WSAEVENT hEvent, DWORD dwTimeout)
{
    ICHECK(IP, USER);

    RaiseToDpc();

    if (pEventTimer->IsNull())
    {
        pEventTimer->Init((PFNTIMER)EventTimer);
    }

    // Release the reference to the existing event.

    if (pEventTimer->_pEvent != NULL)
    {
        EvtDereference(pEventTimer->_pEvent);
        pEventTimer->_pEvent = NULL;
    }

    if (dwTimeout != TIMER_INFINITE)
    {
        // Compute the number of milliseconds until our timer next fires.

        DWORD dwTickKe = KeQueryTickCount() - _dwTickKe;

        dwTickKe = MSEC_PER_TICK - min(MSEC_PER_TICK, dwTickKe);

        // In order to compensate for edge effects between the kernel timer and our timer
        // we add 25 ms to the requested timeout.  This will guarantee that we don't set
        // the event prematurely with respect to the kernel millisecond timer.

        dwTimeout += 25;

        // Now compute the number of whole timer ticks we need to wait beyond the partial
        // tick we are in right now.  Note that we round up to the next timer tick.

        if (dwTimeout < dwTickKe)
        {
            dwTimeout = 0;
        }
        else
        {
            dwTimeout -= dwTickKe;
            dwTimeout += MSEC_PER_TICK - 1;
            dwTimeout  = (dwTimeout * TICKS_PER_SECOND) / 1000;
        }

        // Finally, add in the current timer tick plus one, which is the tick of the next
        // firing of our timer.

        dwTimeout += TimerTick() + 1;

        // Add a reference to the event handle

        pEventTimer->_pEvent = EvtFromHandle(hEvent);

        if (pEventTimer->_pEvent == NULL)
        {
            TraceSz1(Warning, "IpSetEventTimer - invalid hEvent %08lX", hEvent);
        }
    }

    // Set or cancel the timer

    TimerSet(pEventTimer, dwTimeout);
}

void CXnIp::EventTimer(CTimer * pt)
{
    ICHECK(IP, SDPC);

    CEventTimer * pEventTimer = (CEventTimer *)pt;

    if (pEventTimer->_pEvent != NULL)
    {
        EvtSet(pEventTimer->_pEvent, EVENT_INCREMENT);
        EvtDereference(pEventTimer->_pEvent);
        pEventTimer->_pEvent = NULL;
    }
}

// ---------------------------------------------------------------------------------------
// CXnIp::IpRaiseToDpc
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ONLINE

void CXnIp::IpRaiseToDpc(BOOL fRaise)
{
    ICHECK(IP, USER|UDPC);

    Assert(KeGetCurrentIrql() == (fRaise ? PASSIVE_LEVEL : DISPATCH_LEVEL));

    if (fRaise)
        KeRaiseIrqlToDpcLevel();
    else
        KeLowerIrql(PASSIVE_LEVEL);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\ipdns.cpp ===
// ---------------------------------------------------------------------------------------
// ipdns.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(dns, 0);
DefineTag(dnsWarn, TAG_ENABLE);
DefineTag(dnsDump, 0);

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_DNS

struct CDnsName
{
    // Definitions -----------------------------------------------------------------------

    #define DNSMAXLABEL     63

    // External --------------------------------------------------------------------------

    INLINE          CDnsName() { _ab[0] = 0; }
    BOOL            InitFromString(const char * psz);
    BYTE *          InitFromLabels(BYTE * pbSrcBeg, BYTE * pbSrcEnd, BYTE * pbLabBeg);
    void            GenerateString(char * psz, UINT cb);
    BOOL            IsEqual(CDnsName * pdnsname);
    UINT            GetSize();

#if DBG
    char *          Str();
#endif

    // Data ------------------------------------------------------------------------------

    BYTE            _ab[255];           // Buffer of octet-prefixed labels
};

struct CDnsReg
{
    // Definitions -----------------------------------------------------------------------

    // External --------------------------------------------------------------------------

    INLINE CDnsReg() {}

    // Data ------------------------------------------------------------------------------

    CDnsReg *       _pdnsregNext;       // Next CDnsReg in linked list
    CTimer          _timer;             // Timer for scheduling timouts
    CDnsName *      _pdnsname;          // Parsed DNS name of host
    BYTE            _bRetry;            // Retry count
    BYTE            _fPending;          // TRUE while request in progress
    WORD            _wId;               // DNS message unique identifier
    PRKEVENT        _pEvent;            // Event reference (may be NULL)
    XNDNS           _xndns;             // XNDNS structure returned to client
};

struct CDnsHdr
{
    // Definitions -----------------------------------------------------------------------

    #define DNSF_RESPONSE       BIT(15) // 1 if response; 0 if query
    #define DNSF_QOP_MASK       0x7800  // 4 bits of query opcode
    #define DNSF_QOP_SQRY       0x0000  // Standard query opcode
    #define DNSF_QOP_IQRY       0x0800  // Inverse query opcode
    #define DNSF_QOP_STAT       0x1000  // Server status request
    #define DNSF_AA             BIT(10) // Authoritative answer
    #define DNSF_TC             BIT(9)  // Truncation
    #define DNSF_RD             BIT(8)  // Recursion desired
    #define DNSF_RA             BIT(7)  // Recursion available
    #define DNSF_ROP_MASK       0x000F  // 4 bits of response opcode
    #define DNSF_ROP_OK         0x0000  // No error response code
    #define DNSF_ROP_FMTERR     0x0001  // Format error response code
    #define DNSF_ROP_SRVFAIL    0x0002  // Server failure response code
    #define DNSF_ROP_NAMEERR    0x0003  // Name error response code
    #define DNSF_ROP_NOTIMPL    0x0004  // Not implemented response code
    #define DNSF_ROP_REFUSED    0x0005  // Refused response code

    #define DNSRT_A             1       // a host address
    #define DNSRT_NS            2       // an authoritative name server
    #define DNSRT_MD            3       // a mail destination (Obsolete - use MX)
    #define DNSRT_MF            4       // a mail forwarder (Obsolete - use MX)
    #define DNSRT_CNAME         5       // the canonical name for an alias
    #define DNSRT_SOA           6       // marks the start of a zone of authority
    #define DNSRT_MB            7       // a mailbox domain name (EXPERIMENTAL)
    #define DNSRT_MG            8       // a mail group member (EXPERIMENTAL)
    #define DNSRT_MR            9       // a mail rename domain name (EXPERIMENTAL)
    #define DNSRT_NULL          10      // a null RR (EXPERIMENTAL)
    #define DNSRT_WKS           11      // a well known service description
    #define DNSRT_PTR           12      // a domain name pointer
    #define DNSRT_HINFO         13      // host information
    #define DNSRT_MINFO         14      // mailbox or mail list information
    #define DNSRT_MX            15      // mail exchange
    #define DNSRT_TXT           16      // text strings

    #define DNSQT_AXFR          252     // a transfer of an entire zone
    #define DNSQT_MAILB         253     // mailbox-related records (MB, MG or MR)
    #define DNSQT_MAILA         254     // mail agent RRs (Obsolete - see MX)
    #define DNSQT_ALL           255     // all records

    #define DNSRC_IN            1       // the Internet
    #define DNSRC_CS            2       // the CSNET class (Obsolete)
    #define DNSRC_CH            3       // the CHAOS class
    #define DNSRC_HS            4       // the Hesiod class
    #define DNSRC_ANY           255     // any class

    // External --------------------------------------------------------------------------

    INLINE CDnsHdr() {}

    // Data ------------------------------------------------------------------------------

    WORD            _wId;               // DNS message unique identifier
    WORD            _wFlags;            // See DNSF_* above
    WORD            _cQd;               // Number of entries in questions section
    WORD            _cAn;               // Number of entries in answers section
    WORD            _cNs;               // Number of entries in authority section
    WORD            _cAr;               // Number of entries in additional section
    
};

// ---------------------------------------------------------------------------------------
// CDnsName
// ---------------------------------------------------------------------------------------

BOOL CDnsName::InitFromString(const char * psz)
{
    BYTE * pb = _ab;
    UINT cb = strlen(psz);

    if ((cb + 2) > sizeof(_ab))
    {
        TraceSz2(dnsWarn, "CDnsName::InitFromString - '%s': String is too %s",
                 psz, cb == 0 ? "small" : "big");
        goto err;
    }

    // Copy the entire string into the buffer offset by one byte.  Prepend a dot for
    // the first label, and copy the NULL string terminator into the buffer.

    _ab[0] = '.';
    memcpy(&_ab[1], psz, cb + 1);

    // Parse each label and prepend its size, overwriting each dot.

    while (*pb != 0)
    {
        // Find the next dot or end of string

        BYTE * pbDot = pb + 1;
        while (*pbDot != 0 && *pbDot != '.')
            ++pbDot;

        // The maximum size of a label is CB_DNSMAXLABEL

        UINT cbLabel = pbDot - (pb + 1);

        if (cbLabel > DNSMAXLABEL)
        {
            *pbDot = 0;
            TraceSz2(dnsWarn, "CDnsName::InitFromString - '%s': Label '%s' is too big",
                     psz, pb + 1);
            goto err;
        }

        if (cbLabel == 0 && *pbDot != 0)
        {
            TraceSz1(dnsWarn, "CDnsName::InitFromString - '%s': Empty label must be the last", psz);
            goto err;
        }

        // Prepend the length of the label and continue at the next dot

        *pb = (BYTE)cbLabel;
        pb  = pbDot;
    }

    // A valid name must contain at least one non-zero label

    if (_ab[0] == 0)
    {
        TraceSz1(dnsWarn, "CDnsName::InitFromString - '%s': Zero labels parsed", psz);
        goto err;
    }

    return(TRUE);

err:
    _ab[0] = 0;
    return(FALSE);
}

BYTE * CDnsName::InitFromLabels(BYTE * pbSrcBeg, BYTE * pbSrcEnd, BYTE * pbLabOrg)
{
    BYTE *  pbLabBeg    = pbLabOrg;
    BYTE *  pbDst       = _ab;
    BYTE *  pbDstEnd    = pbDst + sizeof(_ab);
    BYTE *  pbSrc;
    BYTE *  pbSrcHi     = NULL;
    BYTE    bLen;
    WORD    wLen;
    
chaselabel:

    if (pbLabBeg < pbSrcBeg || pbLabBeg >= pbSrcEnd)
    {
        TraceSz3(dnsWarn, "CDnsName::InitFromLabels - Label at %08lX is out of range [%08lX %08lX)",
                 pbLabBeg, pbSrcBeg, pbSrcEnd);
        goto err;
    }

    pbSrc = pbLabBeg;

nextlabel:

    bLen  = *pbSrc++;

    if ((bLen & 0xC0) == 0xC0)
    {
        // This is a pointer.  Compute the offset from pbSrcBeg and continue there.

        if (pbSrcEnd - pbSrc == 0)
        {
            TraceSz2(dnsWarn, "CDnsName::InitFromLabels - Label at %08lX has pointer spanning boundary (%08lX)",
                     pbLabBeg, pbSrcEnd);
            goto err;
        }

        wLen = ((bLen & 0x3F) << 8) | (*pbSrc++);

        // If this is the first pointer we've chased, then the result of this function
        // will be the current pbSrc pointer.

        if (pbSrcHi == NULL)
        {
            pbSrcHi = pbSrc;
        }

        // Compute the address of the chased label, and limit the pbSrcEnd so that the
        // range of acceptable addresses ends just before the current label.  Then jump
        // back to continue scanning.  Note that boundary conditions are checked later.

        pbSrcEnd = pbLabBeg;
        pbLabBeg = pbSrcBeg + wLen;

        goto chaselabel;
    }

    if ((bLen & 0xC0) != 0)
    {
        TraceSz3(dnsWarn, "CDnsName::InitFromLabels - Label at %08lX has bogus length byte (%02X) at %08lX",
                 pbLabBeg, bLen, pbSrc - 1);
        goto err;
    }

    if (pbDstEnd - pbDst <= bLen)
    {
        TraceSz1(dnsWarn, "CDnsName::InitFromLabels - Label at %08lX is too large", pbLabOrg);
        goto err;
    }

    *pbDst++ = bLen;

    if (bLen > 0)
    {
        memcpy(pbDst, pbSrc, bLen);
        pbDst += bLen;
        pbSrc += bLen;
        goto nextlabel;
    }

    // Finished copying the entire DNS name.  Return a pointer to just after the initial set of
    // bytes consumed.  This will be pbSrcHi if a pointer was chased, else it will be the current
    // pbSrc.

    return(pbSrcHi ? pbSrcHi : pbSrc);

err:
    _ab[0] = 0;
    return(NULL);
}

UINT CDnsName::GetSize()
{
    BYTE * pb = _ab;
    UINT   cb = 1;

    while (*pb != 0)
    {
        cb += *pb + 1;
        pb += *pb + 1;
    }

    return(cb);
}

BOOL CDnsName::IsEqual(CDnsName * pdnsname)
{
    BYTE * pb1 = _ab;
    BYTE * pb2 = pdnsname->_ab;

    while (*pb1 != 0 && *pb2 != 0)
    {
        if (*pb1 != *pb2)
        {
            return(FALSE);
        }

        if (_strnicmp((char *)(pb1 + 1), (char *)(pb2 + 1), *pb1) != 0)
        {
            return(FALSE);
        }

        pb1 += *pb1 + 1;
        pb2 += *pb2 + 1;
    }

    return(TRUE);
}

#if DBG

char * CDnsName::Str()
{
    #define DNSNAME_STR_BUFFS    4
    #define DNSNAME_BUF_SIZE     256
    static char g_chBufDnsName[DNSNAME_STR_BUFFS * DNSNAME_BUF_SIZE];
    static LONG g_lBufIndexDnsName = 0;
    char * pch = &g_chBufDnsName[(InterlockedIncrement(&g_lBufIndexDnsName) % DNSNAME_STR_BUFFS) * DNSNAME_BUF_SIZE];
    char * pchDst = pch;
    BYTE * pb = _ab;
    while (*pb != 0)
    {
        if (pch != pchDst)
        {
            *pchDst++ = '.';
        }

        memcpy(pchDst, pb + 1, *pb);
        pchDst += *pb;
        pb += *pb + 1;
    }
    *pchDst = 0;
    return(pch);
}

#endif

// ---------------------------------------------------------------------------------------
// CXnIp (DNS)
// ---------------------------------------------------------------------------------------

INT CXnIp::IpDnsLookup(const char * pszHost, WSAEVENT hEvent, XNDNS ** ppxndns)
{
    ICHECK(IP, USER);

    CDnsName dnsname;

    if (!dnsname.InitFromString(pszHost))
    {
        TraceSz1(dnsWarn, "%s is not a valid DNS domain name", pszHost);
        return(WSAEFAULT);
    }

    UINT        cbDnsName   = dnsname.GetSize();
    CDnsReg *   pdnsreg     = (CDnsReg *)PoolAllocZ(sizeof(CDnsReg) + cbDnsName, PTAG_CDnsReg);

    if (pdnsreg == NULL)
    {
        TraceSz(dnsWarn, "Out of memory allocating CDnsReg");
        return(WSAENOBUFS);
    }

    if (hEvent != NULL)
    {
        pdnsreg->_pEvent = EvtFromHandle(hEvent);

        if (pdnsreg->_pEvent == NULL)
        {
            TraceSz1(dnsWarn, "CXnIp::IpDnsLookup - Error referencing WSAEVENT %08lX", hEvent);
            PoolFree(pdnsreg);
            return(WSASYSCALLFAILURE);
        }
    }

    memcpy(pdnsreg + 1, dnsname._ab, cbDnsName);

    pdnsreg->_wId = HTONS(GetNextDgramId());
    pdnsreg->_pdnsname = (CDnsName *)(pdnsreg + 1);
    pdnsreg->_timer.Init((PFNTIMER)IpDnsTimer);
    pdnsreg->_fPending = TRUE;
    pdnsreg->_xndns.iStatus = WSAEINPROGRESS;

    *ppxndns = &pdnsreg->_xndns;

    RaiseToDpc();

    pdnsreg->_pdnsregNext = _pdnsreg;
    _pdnsreg = pdnsreg;

    IpXmitDns(pdnsreg);

    return(0);
}

INT CXnIp::IpDnsRelease(XNDNS * pxndns)
{
    ICHECK(IP, USER);

    RaiseToDpc();

    CDnsReg ** ppdnsreg = &_pdnsreg;
    CDnsReg *  pdnsreg;

    for (; (pdnsreg = *ppdnsreg) != NULL; ppdnsreg = &pdnsreg->_pdnsregNext)
        if (pxndns == &pdnsreg->_xndns)
            break;

    if (pdnsreg == NULL)
    {
        TraceSz1(Warning, "XNDNS %08lX is not valid", pxndns);
        return(WSAEINVAL);
    }

    TimerSet(&pdnsreg->_timer, TIMER_INFINITE);

    if (pdnsreg->_pEvent)
    {
        EvtDereference(pdnsreg->_pEvent);
    }

    *ppdnsreg = pdnsreg->_pdnsregNext;

    PoolFree(pdnsreg);

    return(0);
}

// ---------------------------------------------------------------------------------------
// CXnIp::IpDnsTimer
// ---------------------------------------------------------------------------------------

void CXnIp::IpDnsTimer(CTimer * pt)
{
    ICHECK(IP, UDPC|SDPC);

    CDnsReg * pdnsreg = (CDnsReg *)((BYTE *)pt - offsetof(CDnsReg, _timer));

    pdnsreg->_bRetry += 1;

    if (pdnsreg->_bRetry >= cfgDnsRetries)
    {
        TraceSz3(dns, "IpDnsTimer %04X '%s': Maximum retries exceeded (%d)",
                 NTOHS(pdnsreg->_wId), pdnsreg->_pdnsname->Str(), cfgDnsRetries);
        IpDnsSignal(pdnsreg, WSAETIMEDOUT);
        return;
    }

    IpXmitDns(pdnsreg);
}

// ---------------------------------------------------------------------------------------
// CXnIp::IpXmitDns
// ---------------------------------------------------------------------------------------

void CXnIp::IpXmitDns(CDnsReg * pdnsreg)
{
    ICHECK(IP, UDPC|SDPC);

    if (_options._dnsServerCount == 0)
    {
        TraceSz2(dnsWarn, "IpXmitDns %04X '%s': No DNS servers configured",
                 NTOHS(pdnsreg->_wId), pdnsreg->_pdnsname->Str());
        IpDnsSignal(pdnsreg, WSAHOST_NOT_FOUND);
        return;
    }

    CIpAddr ipaDst = _options._dnsServers[pdnsreg->_bRetry % _options._dnsServerCount];

    TraceSz4(dns, "IpXmitDns %04X '%s' to %s (try #%d)",
             NTOHS(pdnsreg->_wId), pdnsreg->_pdnsname->Str(), ipaDst.Str(), pdnsreg->_bRetry + 1);

    UINT cbDnsName = pdnsreg->_pdnsname->GetSize();
    UINT cbDnsMsg  = sizeof(CDnsHdr) + cbDnsName + 2 * sizeof(WORD);

    CPacket * ppkt = PacketAlloc(PTAG_CDnsPacket, PKTF_TYPE_UDP|PKTF_XMIT_INSECURE|PKTF_POOLALLOC, cbDnsMsg);

    if (ppkt == NULL)
    {
        TraceSz(dnsWarn, "Out of memory allocating DNS packet");
        return;
    }

    CUdpHdr *   pudphdr = ppkt->GetUdpHdr();
    CDnsHdr *   pdnshdr = (CDnsHdr *)(pudphdr + 1);
    BYTE *      pb      = (BYTE *)(pdnshdr + 1);

    pudphdr->_ipportSrc = DNS_CLIENT_PORT;
    pudphdr->_ipportDst = DNS_SERVER_PORT;
    pudphdr->_wLen      = HTONS(sizeof(CUdpHdr) + cbDnsMsg);

    memset(pdnshdr, 0, sizeof(CDnsHdr));
    pdnshdr->_wId       = pdnsreg->_wId;
    pdnshdr->_wFlags    = HTONS(DNSF_RD | DNSF_QOP_SQRY);
    pdnshdr->_cQd       = HTONS(1);

    memcpy(pb, pdnsreg->_pdnsname->_ab, cbDnsName);
    pb                 += cbDnsName;
    *(WORD *)pb         = HTONS(DNSRT_A);
    pb                 += sizeof(WORD);
    *(WORD *)pb         = HTONS(DNSRC_IN);

#ifdef XNET_FEATURE_TRACE
    if (Tag(dnsDump))
    {
        UINT dns = Tag(dns);
        Tag(dns) = Tag(dnsDump);
        IpDnsDump(pdnshdr, cbDnsMsg);
        Tag(dns) = dns;
    }
#endif

    TimerSetRelative(&pdnsreg->_timer, cfgDnsTimeoutInSeconds * TICKS_PER_SECOND);
    IpFillAndXmit(ppkt, ipaDst, IPPROTOCOL_UDP);
}

// ---------------------------------------------------------------------------------------
// CXnIp::IpRecvDns
// ---------------------------------------------------------------------------------------

void CXnIp::IpRecvDns(CPacket * ppkt, CUdpHdr * pUdpHdr, UINT cbLen)
{
    ICHECK(IP, SDPC);

    if (ppkt->TestFlags(PKTF_RECV_BROADCAST) || ppkt->GetIpHdr()->_ipaDst.IsBroadcast())
    {
        TraceSz(pktWarn, "[DISCARD] DNS packet received via broadcast");
        return;
    }

    CDnsHdr * pdnshdr = (CDnsHdr *)(pUdpHdr + 1);

    if (cbLen < sizeof(CDnsHdr))
    {
        TraceSz(pktWarn, "[DISCARD] DNS packet is too small");
        return;
    }

    WORD wFlags = NTOHS(pdnshdr->_wFlags);

    if (    (wFlags & DNSF_RESPONSE) == 0
        ||  (wFlags & DNSF_QOP_MASK) != DNSF_QOP_SQRY
        ||  pdnshdr->_cQd != HTONS(1))
    {
        TraceSz3(pktWarn, "[DISCARD] DNS packet has invalid response (%d,%d,%d)",
                 (wFlags & DNSF_RESPONSE) == 0,
                 (wFlags & DNSF_QOP_MASK) != DNSF_QOP_SQRY,
                 pdnshdr->_cQd != HTONS(1));
        return;
    }

    CDnsReg * pdnsreg = _pdnsreg;

    for (; pdnsreg != NULL; pdnsreg = pdnsreg->_pdnsregNext)
        if (pdnsreg->_wId == pdnshdr->_wId)
            break;
    
    if (pdnsreg == NULL)
    {
        TraceSz1(pktWarn, "[DISCARD] Unrecognized DNS packet with ID %04X", NTOHS(pdnshdr->_wId));
        return;
    }

    if (!pdnsreg->_fPending)
    {
        TraceSz2(pktRecv, "[DISCARD] Ignoring duplicate DNS packet with ID %04X (iStatus=%d)",
                 NTOHS(pdnsreg->_wId), pdnsreg->_xndns.iStatus);
        return;
    }

#ifdef XNET_FEATURE_TRACE
    if (Tag(dnsDump))
    {
        UINT dns = Tag(dns);
        Tag(dns) = Tag(dnsDump);
        IpDnsDump(pdnshdr, cbLen);
        Tag(dns) = dns;
    }
#endif

    if ((wFlags & DNSF_ROP_MASK) == DNSF_ROP_NAMEERR)
    {
        IpDnsSignal(pdnsreg, WSAHOST_NOT_FOUND);
        return;
    }
    else if ((wFlags & DNSF_ROP_MASK) != DNSF_ROP_OK)
    {
        TraceSz1(pktWarn, "[DISCARD] DNS packet with RCODE %d", wFlags & DNSF_ROP_MASK);
        return;
    }

    // Scan the Answer section for DNSRT_A/DNSRC_IN records

    BYTE *      pbBeg = (BYTE *)pdnshdr;
    BYTE *      pbEnd = pbBeg + cbLen;
    BYTE *      pb    = (BYTE *)(pdnshdr + 1);
    CDnsName    dnsname;
    WORD        wType, wClass, wRdLen;
    DWORD       dwTtl;

    // But first, skip over the Question section and verify that the name is correct

    if (pb - pbEnd == 0)
    {
        TraceSz(pktWarn, "[DISCARD] DNS packet has no Question section");
        return;
    }

    pb = dnsname.InitFromLabels(pbBeg, pbEnd, pb);

    if (pb == NULL)
    {
        TraceSz(pktWarn, "[DISCARD] DNS packet has invalid Question name");
        return;
    }
        
    if (pbEnd - pb < sizeof(WORD) + sizeof(WORD))
    {
        TraceSz(pktWarn, "[DISCARD] DNS packet has too small Question section");
        return;
    }

    wType  = NTOHS(*(WORD *)pb);    pb += sizeof(WORD);
    wClass = NTOHS(*(WORD *)pb);    pb += sizeof(WORD);

    if (!dnsname.IsEqual(pdnsreg->_pdnsname))
    {
        TraceSz(pktWarn, "[DISCARD] DNS packet has wrong query name in Question section");
        return;
    }

    // Now pb points to the Answer section.  Parse all the answers to find DNSRT_A records.

    WORD cAn = NTOHS(pdnshdr->_cAn);
    UINT cina = 0;

    for (; cAn > 0; --cAn)
    {
        pb = dnsname.InitFromLabels(pbBeg, pbEnd, pb);

        if (pb == NULL)
        {
            TraceSz(pktWarn, "[DISCARD] DNS packet has invalid Answer name");
            return;
        }

        if (pbEnd - pb < sizeof(WORD) + sizeof(WORD) + sizeof(DWORD) + sizeof(WORD))
        {
            TraceSz(pktWarn, "[DISCARD] DNS packet ended prematurely while parsing Answer section (1)");
            return;
        }

        wType  = NTOHS(*(WORD *)pb);    pb += sizeof(WORD);
        wClass = NTOHS(*(WORD *)pb);    pb += sizeof(WORD);
        dwTtl  = NTOHL(*(DWORD *)pb);   pb += sizeof(DWORD);
        wRdLen = NTOHS(*(WORD *)pb);    pb += sizeof(WORD);

        if (pbEnd - pb < wRdLen)
        {
            TraceSz(pktWarn, "[DISCARD] DNS packet ended prematurely while parsing Answer section (2)");
            return;
        }

        if (wType == DNSRT_A && wClass == DNSRC_IN && wRdLen == sizeof(CIpAddr))
        {
            pdnsreg->_xndns.aina[cina++] = *(IN_ADDR *)pb;

            if (cina == dimensionof(pdnsreg->_xndns.aina))
            {
                TraceSz(pktWarn, "DNS packet had more IN/A answers than XNDNS has room");
                break;
            }
        }

        pb += wRdLen;
    }

    if (cina == 0)
    {
        TraceSz(pktWarn, "[DISCARD] DNS packet had no A/IN answer records");
        return;
    }

    // Signal successful completion.

    pdnsreg->_xndns.cina = cina;
    IpDnsSignal(pdnsreg, 0);
}

// ---------------------------------------------------------------------------------------
// CXnIp::IpDnsSignal
// ---------------------------------------------------------------------------------------

void CXnIp::IpDnsSignal(CDnsReg * pdnsreg, INT iStatus)
{
    ICHECK(IP, UDPC|SDPC);

    Assert(pdnsreg->_fPending);
    Assert(pdnsreg->_xndns.iStatus == WSAEINPROGRESS);
    Assert(iStatus != WSAEINPROGRESS);

    pdnsreg->_fPending = FALSE;
    pdnsreg->_xndns.iStatus = iStatus;
    TimerSet(&pdnsreg->_timer, TIMER_INFINITE);

    if (pdnsreg->_pEvent)
    {
        EvtSet(pdnsreg->_pEvent, EVENT_INCREMENT);
    }
}

// ---------------------------------------------------------------------------------------
// CXnIp::IpDnsDump
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_TRACE

void CXnIp::IpDnsDump(CDnsHdr * pdnshdr, UINT cbDnsMsg)
{
    ICHECK(IP, USER|UDPC|SDPC);

    Assert(cbDnsMsg >= sizeof(CDnsHdr));

    WORD wFlags = NTOHS(pdnshdr->_wFlags);

    TraceSz14(dns, "[DNS %s %d/%s %d/%s%s%s%s%s %04X %d/Qd %d/An %d/Ns %d/Ar]",
              (wFlags & DNSF_RESPONSE) ? "RESP" : "QUERY",
              (wFlags & DNSF_QOP_MASK),
              (wFlags & DNSF_QOP_MASK) == DNSF_QOP_SQRY ? "SQRY" :
              (wFlags & DNSF_QOP_MASK) == DNSF_QOP_IQRY ? "IQRY" :
              (wFlags & DNSF_QOP_MASK) == DNSF_QOP_STAT ? "STAT" : "????",
              (wFlags & DNSF_ROP_MASK),
              (wFlags & DNSF_ROP_MASK) == DNSF_ROP_OK ? "OK" :
              (wFlags & DNSF_ROP_MASK) == DNSF_ROP_FMTERR ? "FMTERR" :
              (wFlags & DNSF_ROP_MASK) == DNSF_ROP_SRVFAIL ? "SRVFAIL" :
              (wFlags & DNSF_ROP_MASK) == DNSF_ROP_NAMEERR ? "NAMEERR" :
              (wFlags & DNSF_ROP_MASK) == DNSF_ROP_NOTIMPL ? "NOTIMPL" :
              (wFlags & DNSF_ROP_MASK) == DNSF_ROP_REFUSED ? "REFUSED" : "????",
              (wFlags & DNSF_AA) ? " AA" : "",
              (wFlags & DNSF_TC) ? " TC" : "",
              (wFlags & DNSF_RD) ? " RD" : "",
              (wFlags & DNSF_RA) ? " RA" : "",
              NTOHS(pdnshdr->_wId),
              NTOHS(pdnshdr->_cQd),
              NTOHS(pdnshdr->_cAn),
              NTOHS(pdnshdr->_cNs),
              NTOHS(pdnshdr->_cAr));

    BYTE * pbBeg = (BYTE *)pdnshdr;
    BYTE * pbEnd = pbBeg + cbDnsMsg;
    BYTE * pbSec = (BYTE *)(pdnshdr + 1);

    if (NTOHS(pdnshdr->_cQd) != 0)
        pbSec = IpDnsDumpSection(pbBeg, pbEnd, pbSec, NTOHS(pdnshdr->_cQd), "Qd");
    if (pbSec && NTOHS(pdnshdr->_cAn) != 0)
        pbSec = IpDnsDumpSection(pbBeg, pbEnd, pbSec, NTOHS(pdnshdr->_cAn), "An");
    if (pbSec && NTOHS(pdnshdr->_cNs) != 0)
        pbSec = IpDnsDumpSection(pbBeg, pbEnd, pbSec, NTOHS(pdnshdr->_cNs), "Ns");
    if (pbSec && NTOHS(pdnshdr->_cAr) != 0)
        pbSec = IpDnsDumpSection(pbBeg, pbEnd, pbSec, NTOHS(pdnshdr->_cAr), "Ar");
}

char * DnsTypeToStr(WORD wType)
{
    switch (wType)
    {
        case DNSRT_A:       return("A");
        case DNSRT_NS:      return("NS");
        case DNSRT_MD:      return("MD");
        case DNSRT_MF:      return("MF");
        case DNSRT_CNAME:   return("CNAME");
        case DNSRT_SOA:     return("SOA");
        case DNSRT_MB:      return("MB");
        case DNSRT_MG:      return("MG");
        case DNSRT_MR:      return("MR");
        case DNSRT_NULL:    return("NULL");
        case DNSRT_WKS:     return("WKS");
        case DNSRT_PTR:     return("PTR");
        case DNSRT_HINFO:   return("HINFO");
        case DNSRT_MINFO:   return("MINFO");
        case DNSRT_MX:      return("MX");
        case DNSRT_TXT:     return("TXT");
        case DNSQT_AXFR:    return("AXFR");
        case DNSQT_MAILB:   return("MAILB");
        case DNSQT_MAILA:   return("MAILA");
        case DNSQT_ALL:     return("ALL");
        default:            return("?");
    }
}

char * DnsClassToStr(WORD wClass)
{
    switch (wClass)
    {
        case DNSRC_IN:      return("IN");
        case DNSRC_CS:      return("CS");
        case DNSRC_CH:      return("CH");
        case DNSRC_HS:      return("HS");
        case DNSRC_ANY:     return("ANY");
        default:            return("?");
    }
}

BYTE * CXnIp::IpDnsDumpSection(BYTE * pbBeg, BYTE * pbEnd, BYTE * pb, UINT cSec, char * pszSec)
{
    CDnsName    dnsname1, dnsname2;
    UINT        iSec;
    WORD        wType, wClass, wRdLen;
    DWORD       dwTtl;
    
    for (iSec = 0; iSec < cSec; ++iSec)
    {
        if (pb - pbEnd == 0)
            goto err;

        pb = dnsname1.InitFromLabels(pbBeg, pbEnd, pb);
        if (pb == NULL)
            goto err;

        if (strcmp(pszSec, "Qd") == 0)
        {
            if (pbEnd - pb < sizeof(WORD) + sizeof(WORD))
                goto err;

            wType  = NTOHS(*(WORD *)pb);    pb += sizeof(WORD);
            wClass = NTOHS(*(WORD *)pb);    pb += sizeof(WORD);

            TraceSz7(dns, "  %s.%d: %-32s %d/%s %d/%s",
                     pszSec, iSec, dnsname1.Str(), wType, DnsTypeToStr(wType),
                     wClass, DnsClassToStr(wClass));
        }
        else
        {
            if (pbEnd - pb < sizeof(WORD) + sizeof(WORD) + sizeof(DWORD) + sizeof(WORD))
                goto err;

            wType  = NTOHS(*(WORD *)pb);    pb += sizeof(WORD);
            wClass = NTOHS(*(WORD *)pb);    pb += sizeof(WORD);
            dwTtl  = NTOHL(*(DWORD *)pb);   pb += sizeof(DWORD);
            wRdLen = NTOHS(*(WORD *)pb);    pb += sizeof(WORD);

            if (pbEnd - pb < wRdLen)
                goto err;

            if (wType == DNSRT_A && wClass == DNSRC_IN && wRdLen == sizeof(CIpAddr))
            {
                TraceSz8(dns, "  %s.%d: %-32s %d/%s %d/%s %s",
                         pszSec, iSec, dnsname1.Str(), wType, DnsTypeToStr(wType),
                         wClass, DnsClassToStr(wClass), ((CIpAddr *)pb)->Str());
            }
            else if (   wRdLen > 0
                     && (   wType == DNSRT_NS
                         || wType == DNSRT_MD
                         || wType == DNSRT_MF
                         || wType == DNSRT_CNAME
                         || wType == DNSRT_MB
                         || wType == DNSRT_MG
                         || wType == DNSRT_MR
                         || wType == DNSRT_PTR)
                     && dnsname2.InitFromLabels(pbBeg, pb + wRdLen, pb) == pb + wRdLen)
            {
                TraceSz8(dns, "  %s.%d: %-32s %d/%s %d/%s %s",
                         pszSec, iSec, dnsname1.Str(), wType, DnsTypeToStr(wType),
                         wClass, DnsClassToStr(wClass), dnsname2.Str());
            }
            else
            {
                TraceSz8(dns, "  %s.%d: %-32s %d/%s %d/%s [+%d bytes]",
                         pszSec, iSec, dnsname1.Str(), wType, DnsTypeToStr(wType),
                         wClass, DnsClassToStr(wClass), wRdLen);
                IpDnsDumpHex(pb, wRdLen);
            }

            pb += wRdLen;
        }

    }
        
    return(pb);

err:
    TraceSz2(dns, "  %s.%d: <Error processing record>", pszSec, iSec);
    return(NULL);
}

void CXnIp::IpDnsDumpHex(BYTE * pb, UINT cb)
{
    char * pch;
    char ach[256];
    UINT ib, ibEnd;
    BYTE b;

    while (cb > 0)
    {
        pch = ach;

        ibEnd = 16;
        if (ibEnd > cb)
            ibEnd = cb;

        for (ib = 0; ib < ibEnd; ++ib, ++pb)
        {
            b = (*pb) >> 4;
            *pch++ = (b < 10) ? '0' + b : 'A' + b - 10;
            b = (*pb) & 0xF;
            *pch++ = (b < 10) ? '0' + b : 'A' + b - 10;
            *pch++ = (ib == 7) ? '-' : ' ';
        }

        pb -= ibEnd;

        if (ibEnd < 16)
        {
            memset(pch, ' ', 3 * (16 - ibEnd));
            pch += 3 * (16 - ibEnd);
        }

        *pch++ = ' ';
        *pch++ = ' ';

        for (ib = 0; ib < ibEnd; ++ib, ++pb)
        {
            b = *pb;
            if (b >= 32 && b < 127)
                *pch++ = b;
            else
                *pch++ = '.';
        }

        *pch = 0;

        TraceSz1(dns, "    %s", ach);

        cb -= ibEnd;
    }
}

#endif

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\ipqos.cpp ===
// ---------------------------------------------------------------------------------------
// ipqos.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

#ifdef XNET_FEATURE_QOS

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(qosInfo, 0);
DefineTag(qosWarn, TAG_ENABLE);

// ---------------------------------------------------------------------------------------
// CXnIp (IpQos)
// ---------------------------------------------------------------------------------------

INT CXnIp::IpQosListen(const XNKID * pxnkid, const BYTE * pb, UINT cb, DWORD dwBitsPerSec, DWORD dwFlags)
{
    ICHECK(IP, USER);

    RaiseToDpc();

#if 0
    CKeyReg * pKeyReg = KeyRegLookup(pxnkid);

    if (pKeyReg == NULL)
    {
        TraceSz1(qosWarn, "IpQosListen - XNKID %s is not registered",
                 HexStr(pxnkid->ab, sizeof(pxnkid->ab)));
        return(WSAEINVAL);
    }

    if (dwFlags & XNET_QOS_LISTEN_SET_DATA)
    {
        if (cb > (UINT)(cfgQosDataLimitDiv4 * 4))
        {
            TraceSz3(qosWarn, "IpQosListen - cb is %d bytes but cfgQosDataLimit is %d (%d bytes)",
                     cb, cfgQosDataLimitDiv4, cfgQosDataLimitDiv4 * 4);
            return(WSAEMSGSIZE);
        }

        BYTE * pbQos = NULL;

        if (cb > 0)
        {
            pbQos = (BYTE *)SysAlloc(cb, PTAG_QosData);

            if (pbQos == NULL)
            {
                TraceSz1(qosWarn, "IpSetListen - Out of memory allocating QosData (%d bytes)", cb);
                return(WSAENOBUFS);
            }

            memcpy(pbQos, pb, cb);
        }

        SysFree(pKeyReg->_pbQos);

        pKeyReg->_pbQos = pbQos;
        pKeyReg->_cbQos = cb;
    }

    if (dwFlags & XNET_QOS_LISTEN_SET_BITSPERSEC)
    {
        //@@@ Implement me
    }

    if (dwFlags & XNET_QOS_LISTEN_ENABLE)
    {
        //@@@ Implement me
    }

    if (dwFlags & XNET_QOS_LISTEN_DISABLE)
    {
        //@@@ Implement me
    }
#endif

    return(0);
}

INT CXnIp::IpQosXnAddr(UINT cxnqos, const XNADDR * apxna[], const XNKID * apxnkid[], const XNKEY * apxnkey[], DWORD dwFlags, WSAEVENT hEvent, XNQOS ** ppxnqos)
{
    ICHECK(IP, USER);

    if (cxnqos == 0)
    {
        TraceSz(qosWarn, "IpQosXnAddr - Must specify one or more addresses");
        return(WSAEFAULT);
    }

    //@@@ Implement me

    return(WSAEACCES);
}

#ifdef XNET_FEATURE_SG

INT CXnIp::IpQosServer(UINT cxnqos, const IN_ADDR aina[], const DWORD adwServiceId[], DWORD dwFlags, WSAEVENT hEvent, XNQOS ** ppxnqos)
{
    ICHECK(IP, USER);

    if (cxnqos == 0)
    {
        TraceSz(qosWarn, "IpQosServer - Must specify one or more addresses");
        return(WSAEFAULT);
    }

    //@@@ Implement me

    return(WSAEACCES);
}

#endif

INT CXnIp::IpQosRelease(XNQOS * pxnqos)
{
    ICHECK(IP, USER);

    //@@@ Implement me

    return(WSAEACCES);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\ipicmp.cpp ===
// ---------------------------------------------------------------------------------------
// ipicmp.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

// ---------------------------------------------------------------------------------------
// CIcmpHdr
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ICMP

#include <pshpack1.h>

class CIcmpHdr
{

    // Definitions -----------------------------------------------------------------------

    #define ICMPTYPE_ECHO_REPLY                 0
    #define ICMPTYPE_DESTINATION_UNREACHABLE    3
    #define   ICMPCODE_NET_UNREACHABLE          0
    #define   ICMPCODE_HOST_UNREACHABLE         1
    #define   ICMPCODE_PROTOCOL_UNREACHABLE     2
    #define   ICMPCODE_PORT_UNREACHABLE         3
    #define   ICMPCODE_CANT_FRAGMENT_WITH_DF    4
    #define   ICMPCODE_SRCROUTE_FAILED          5
    #define   ICMPCODE_DEST_NET_UNKNOWN         6
    #define   ICMPCODE_DEST_HOST_UNKNOWN        7
    #define   ICMPCODE_SRC_HOST_ISOLATED        8
    #define   ICMPCODE_DEST_NET_PROHIBITED      9
    #define   ICMPCODE_DEST_HOST_PROHIBITED     10
    #define   ICMPCODE_NET_UNREACHABLE_TOS      11
    #define   ICMPCODE_HOST_UNREACHABLE_TOS     12
    #define ICMPTYPE_SOURCE_QUENCH              4
    #define ICMPTYPE_REDIRECT                   5
    #define   ICMPCODE_REDIRECT_NET             0
    #define   ICMPCODE_REDIRECT_HOST            1
    #define   ICMPCODE_REDIRECT_NET_TOS         2
    #define   ICMPCODE_REDIRECT_HOST_TOS        3
    #define ICMPTYPE_ECHO_REQUEST               8
    #define ICMPTYPE_ROUTER_ADVERTISEMENT       9
    #define ICMPTYPE_ROUTER_SOLICIATION         10
    #define ICMPTYPE_TIME_EXCEEDED              11
    #define   ICMPCODE_TTL_EXCEEDED             0
    #define   ICMPCODE_REASSEMBLY_TIMEOUT       1
    #define ICMPTYPE_PARAMETER_PROBLEM          12
    #define   ICMPCODE_PTR_INDICATES_ERROR      0
    #define   ICMPCODE_MISSING_REQD_OPTION      1
    #define ICMPTYPE_TIMESTAMP_REQUEST          13
    #define ICMPTYPE_TIMESTAMP_REPLY            14
    #define ICMPTYPE_INFORMATION_REQUEST        15
    #define ICMPTYPE_INFORMATION_REPLY          16
    #define ICMPTYPE_ADDRESSMASK_REQUEST        17
    #define ICMPTYPE_ADDRESSMASK_REPLY          18

    // Trace Support ---------------------------------------------------------------------

public:

    char * Str()
    {
        switch (_bType)
        {
            case ICMPTYPE_ECHO_REPLY:
                return("Echo Reply");
                break;
            case ICMPTYPE_DESTINATION_UNREACHABLE:
            {
                switch (_bCode)
                {
                    case ICMPCODE_NET_UNREACHABLE:
                        return("Net Unreachable");
                    case ICMPCODE_HOST_UNREACHABLE:
                        return("Host Unreachable");
                    case ICMPCODE_PROTOCOL_UNREACHABLE:
                        return("Protocol Unreachable");
                    case ICMPCODE_PORT_UNREACHABLE:
                        return("Port Unreachable");
                    case ICMPCODE_CANT_FRAGMENT_WITH_DF:
                        return("Can't Fragment With DF");
                    case ICMPCODE_SRCROUTE_FAILED:
                        return("Source Route Failed");
                    case ICMPCODE_DEST_NET_UNKNOWN:
                        return("Destination Net Unknown");
                    case ICMPCODE_DEST_HOST_UNKNOWN:
                        return("Destination Host Unknown");
                    case ICMPCODE_SRC_HOST_ISOLATED:
                        return("Source Host Isolated");
                    case ICMPCODE_DEST_NET_PROHIBITED:
                        return("Destination Net Prohibited");
                    case ICMPCODE_NET_UNREACHABLE_TOS:
                        return("Network Unreachable For Tos");
                    case ICMPCODE_HOST_UNREACHABLE_TOS:
                        return("Host Unreachable For Tos");
                    default:
                        return("Destination Unreachable");
                }
            }
            case ICMPTYPE_SOURCE_QUENCH:
                return("Source Quench");
                break;
            case ICMPTYPE_REDIRECT:
            {
                switch (_bCode)
                {
                    case ICMPCODE_REDIRECT_NET:
                        return("Redirect Datagrams For Net");
                    case ICMPCODE_REDIRECT_HOST:
                        return("Redirect Datagrams For Host");
                    case ICMPCODE_REDIRECT_NET_TOS:
                        return("Redirect Datagrams For Net And Tos");
                    case ICMPCODE_REDIRECT_HOST_TOS:
                        return("Redirect Datagrams For Host And Tos");
                    default:
                        return("Redirect");
                }
            }
            case ICMPTYPE_ECHO_REQUEST:
                return("Echo Request");
                break;
            case ICMPTYPE_ROUTER_ADVERTISEMENT:
                return("Router Advertisement");
                break;
            case ICMPTYPE_TIME_EXCEEDED:
            {
                switch (_bCode)
                {
                    case ICMPCODE_TTL_EXCEEDED:
                        return("Ttl Exceeded");
                    case ICMPCODE_REASSEMBLY_TIMEOUT:
                        return("Reassembly Timeout");
                    default:
                        return("Time Exceeded");
                }
            }
            case ICMPTYPE_PARAMETER_PROBLEM:
            {
                switch (_bCode)
                {
                    case ICMPCODE_MISSING_REQD_OPTION:
                        return("Missing Required Option");
                    default:
                        return("Parameter Problem");
                }
            }
            case ICMPTYPE_TIMESTAMP_REQUEST:
                return("Timestamp Request");
            case ICMPTYPE_TIMESTAMP_REPLY:
                return("Timestamp Reply");
            case ICMPTYPE_INFORMATION_REQUEST:
                return("Information Request");
            case ICMPTYPE_INFORMATION_REPLY:
                return("Information Reply");
            case ICMPTYPE_ADDRESSMASK_REQUEST:
                return("Address Mask Request");
            case ICMPTYPE_ADDRESSMASK_REPLY:
                return("Address Mask Reply");
            default:
                return("Unknown");
        }
    }

    // Data ------------------------------------------------------------------------------

public:

    BYTE            _bType;         // One of ICMPTYPE_* above
    BYTE            _bCode;         // One of ICMPCODE_* above
    WORD            _wChecksum;     // Checksum
    DWORD           _dwData;        // Data (depends on _bType)

};

#include <poppack.h>

// ---------------------------------------------------------------------------------------
// CXnIp::IcmpRecv
// ---------------------------------------------------------------------------------------

void CXnIp::IcmpRecv(CPacket* ppkt, CIpHdr * pIpHdr, void * pvData, UINT cbData)
{
    ICHECK(IP, UDPC|SDPC);

    if (cbData < sizeof(CIcmpHdr))
    {
        TraceSz1(pktWarn, "[DISCARD] ICMP header doesn't fit in the packet (%d bytes)", cbData);
        return;
    }

    if (tcpipxsum(0, pvData, cbData) != 0xFFFF)
    {
        TraceSz(pktWarn, "[DISCARD] ICMP header checksum failed");
        return;
    }

    CIcmpHdr * pIcmpHdr = (CIcmpHdr *)pvData;

    TraceSz4(pktRecv, "[ICMP <%d/%d> %s][cb=%d]",
             pIcmpHdr->_bType, pIcmpHdr->_bCode, pIcmpHdr->Str(),
             cbData - sizeof(CIcmpHdr));

    if (ppkt->TestFlags(PKTF_RECV_BROADCAST|PKTF_RECV_LOOPBACK))
    {
        TraceSz1(pktWarn, "[DISCARD] ICMP packet received via %s",
                 ppkt->TestFlags(PKTF_RECV_BROADCAST) ? "broadcast" : "loopback");
        return;
    }

#ifdef XNET_FEATURE_ROUTE

    if (    pIcmpHdr->_bType == ICMPTYPE_REDIRECT
        &&  (   pIcmpHdr->_bCode == ICMPCODE_REDIRECT_NET
             || pIcmpHdr->_bCode == ICMPCODE_REDIRECT_HOST
             || pIcmpHdr->_bCode == ICMPCODE_REDIRECT_NET_TOS
             || pIcmpHdr->_bCode == ICMPCODE_REDIRECT_HOST_TOS))
    {
        pvData  = (BYTE *)pvData + sizeof(CIcmpHdr);
        cbData -= sizeof(CIcmpHdr);

        if (cbData < sizeof(CIpHdr))
        {
            TraceSz(pktWarn, "[DISCARD] ICMP embedded IP header doesn't fit in the packet");
            return;
        }

        CIpHdr * pIpHdrIcmp = (CIpHdr *)pvData;
        UINT cbIpHdrIcmp = pIpHdrIcmp->VerifyHdrLen();

        if (cbIpHdrIcmp == 0)
        {
            TraceSz(pktWarn, "[DISCARD] ICMP embedded IP header version is incorrect");
            return;
        }

        if (cbData < (cbIpHdrIcmp + 8))
        {
            TraceSz(pktWarn, "[DISCARD] ICMP embedded IP header and 64-bits of data doesn't fit in the packet");
            return;
        }

        // The embedded IP header is supposed to have originated from this host, and
        // we would never have added IP options, so we can check that here.

        if (cbIpHdrIcmp != sizeof(CIpHdr))
        {
            TraceSz(pktWarn, "[DISCARD] ICMP embedded IP header has options");
            return;
        }

        TraceSz3(pktRecv, "[REDIRECT] Rerouting %s from gateway %s to gateway %s",
                 pIpHdrIcmp->_ipaDst.Str(), pIpHdr->_ipaSrc.Str(), CIpAddr(pIcmpHdr->_dwData).Str());

        RouteRedirect(pIpHdrIcmp->_ipaDst, pIpHdr->_ipaSrc, CIpAddr(pIcmpHdr->_dwData));
        return;
    }

#endif

    if (pIcmpHdr->_bType == ICMPTYPE_ECHO_REQUEST)
    {
        if (!pIpHdr->_ipaSrc.IsValidUnicast())
        {
            TraceSz1(pktWarn, "[DISCARD] ICMP echo from bad source address %s",
                     pIpHdr->_ipaSrc.Str());
            return;
        }

        if (pIpHdr->GetOptLen() > 0)
        {
            TraceSz(pktWarn, "[DISCARD] ICMP echo packet with IP header options");
            return;
        }

        // Don't allow Ping'er to make us consume gratuitous amounts of pool memory

        if (cbData > sizeof(CIcmpHdr) + 64)
        {
            TraceSz1(pktWarn, "[DISCARD] ICMP echo request with too much optional data (%d)",
                     cbData - sizeof(CIcmpHdr));
            return;
        }

        CPacket * ppktReply = PacketAlloc(PTAG_CIcmpEchoPacket,
                                          PKTF_TYPE_IP|PKTF_XMIT_INSECURE|PKTF_POOLALLOC,
                                          cbData);

        if (ppktReply == NULL)
        {
            TraceSz(pktWarn, "[DISCARD] Out of memory allocating ICMP echo reply packet");
            return;
        }

        CIpHdr * pIpHdrReply = ppktReply->GetIpHdr();

        memcpy(pIpHdrReply, pIpHdr, sizeof(CIpHdr) + cbData);

        CIcmpHdr * pIcmpHdrReply = (CIcmpHdr *)(pIpHdrReply + 1);

        pIcmpHdrReply->_bType     = ICMPTYPE_ECHO_REPLY;
        pIcmpHdrReply->_wChecksum = 0;
        pIcmpHdrReply->_wChecksum = (WORD)~tcpipxsum(0, pIcmpHdrReply, cbData);

        TraceSz(pktRecv, "[REPLY] Replying to ICMP echo request");

        IpFillAndXmit(ppktReply, pIpHdr->_ipaSrc, IPPROTOCOL_ICMP);
        return;
    }

    TraceSz3(pktWarn, "[DISCARD] No support ICMP <%d/%d> %s",
             pIcmpHdr->_bType, pIcmpHdr->_bCode, pIcmpHdr->Str());
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\nicw.h ===
// ----------------------------------------------------------------------------
// nicw.h
//
// Software implementation of a NIC for simulating an Ethernet network
//
// Copyright (C) Microsoft Corporation
// ----------------------------------------------------------------------------

#ifndef __NICW_H__
#define __NICW_H__

// ---------------------------------------------------------------------------------------
// CXnNic
// ---------------------------------------------------------------------------------------

class NOVTABLE CXnNic : public CXnBase
{
    friend void WINAPI VLanRecv(BYTE *, UINT, void *);

    // Definitions -----------------------------------------------------------------------

    struct RecvDesc
    {
        DWORD       cbDat;
        BYTE        rgbBuf[ENET_LINK_MAXSIZE + ENET_DATA_MAXSIZE];
    };

    // External --------------------------------------------------------------------------

public:

    HAL_DECLARE_NEW_DELETE(CXnNic)

    BOOL            NicXmitReady();
    void            NicXmit(CPacket * ppkt);
    VIRTUAL void    NicTimer() {}

protected:

    NTSTATUS        NicInit(XNetInitParams * pxnip);
    INT             NicConfig(const XNetConfigParams * pxncp);
    void            NicStart();
    void            NicFlush();
    void            NicStop();
    void            NicTerm();

    VIRTUAL void    NicRecvFrame(void * pv, DWORD cbData);

    VIRTUAL void    EnetRecv(CPacket * ppkt, UINT uiType) VPURE;
    VIRTUAL void    EnetPush() VPURE;

    // Internal --------------------------------------------------------------------------

private:

    RecvDesc *      NextPrd(RecvDesc * prd);
    void            XmitPush();
    void            RecvPush();
    void            SetInterrupts(BOOL fEnable);
    static void     DpcCallback(struct _KDPC *, void * pthis, void *, void *);

    INT             NicVLanAttach();
    void            NicVLanDetach(BOOL fTerm);

    // Data ------------------------------------------------------------------------------

protected:

    CEnetAddr       _ea;

private:

    LIST_ENTRY      _le;
    KDPC            _dpcRecv;
    BOOL            _fIntr;
    BOOL            _fXmitFull;
    LONG            _cxdBusy;
    LONG            _cxdPool;
    CPacketQueue    _pqXmit;
    LONG            _crdBusy;
    LONG            _crdPool;
    RecvDesc *      _prdFirst;
    RecvDesc *      _prdRead;
    RecvDesc *      _prdWrite;
    RecvDesc *      _prdLast;
    BOOL            _fVLanInit;
    BOOL            _fVLanAttach;

};

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\nicx.cpp ===
// ---------------------------------------------------------------------------------------
// nicx.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

#ifdef XNET_FEATURE_XBOX

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

KINTERRUPT CXnNic::s_InterruptObject;

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

#define HWADDR0(_hwaddr) ((const DWORD *)((BYTE *)(_hwaddr)))[0]
#define HWADDR1(_hwaddr) ((const WORD *)((BYTE *)(_hwaddr)))[2]

DefineTag(nicStats,     TAG_ENABLE);        // Trace Nic stats
DefineTag(nicStatsAll,  0);                 // Trace all Nic stats

// ---------------------------------------------------------------------------------------
// Internal
// ---------------------------------------------------------------------------------------

void CXnNic::NicStartXmitRecv()
{
    ICHECK(NIC, USER|UDPC|SDPC);

    PNICCSR pCsr    = PNicCsr();
    pCsr->rx_poll   = RXPOLL_EN | _dwRxPollFreq;
    pCsr->tx_en     = TXEN_ENABLE;
    pCsr->rx_en     = RXEN_ENABLE;
    pCsr->mode      = MODE_TXDM|MODE_RXDM;
}

void CXnNic::NicStopXmitRecv()
{
    ICHECK(NIC, USER|UDPC|SDPC);

    PNICCSR pCsr = PNicCsr();
    int timeout;

    // Turn off the transmitter and receiver

    pCsr->rx_poll = 0;
    pCsr->rx_en = 0;
    pCsr->tx_en = 0;

    // Wait for a max of 5msec until both the transmitter and receiver are idle

    for (timeout=500; timeout--; )
    {
        if (    !(pCsr->rx_sta & RXSTA_BUSY)
            &&  !(pCsr->tx_sta & TXSTA_BUSY))
            break;

        KeStallExecutionProcessor(10);
    }

    // Ensure there is no active DMA transfer in progress

    pCsr->mode = MODE_DISABLE_DMA;

    for (timeout=500; timeout--; )
    {
        if (pCsr->mode & MODE_DMA_IDLE)
            break;

        KeStallExecutionProcessor(10);
    }

    pCsr->mode = 0;
}

BOOLEAN CXnNic::NicIsr(PKINTERRUPT, PVOID pvContext)
{
    return(((CXnNic *)pvContext)->NicProcessIsr());
}

BOOLEAN CXnNic::NicProcessIsr()
{
    Assert(!TestInitFlag(INITF_NIC_STOP));

    // Disable interrupts

    PNicCsr()->intr_mk = 0;

    // Queue the dpc to handle the interrupt

    KeInsertQueueDpc(&_dpc, NULL, NULL);

#ifdef XNET_FEATURE_STATS
    _NicStats.isrCount += 1;
#endif

    return(TRUE);
}

void CXnNic::NicDpc(PKDPC dpc, void * pvContext, void * pvArg1, void * pvArg2)
{
    ((CXnNic *)pvContext)->NicProcessDpc();
}

void CXnNic::NicProcessDpc()
{
    ICHECK(NIC, SDPC);

    PNICCSR pCsr = PNicCsr();

    STATINC(dpcCount);

    while (1)
    {
        DWORD dwMintr = pCsr->mintr;
        DWORD dwIntr  = pCsr->intr;

        if (dwIntr == 0)
            break;

        // Process the MII interrupt before acknowledging it to prevent the auto-poll
        // of the PHY interfering with reading of the current link state

        if (dwIntr & INTR_MINT)
        {
            NicMiiInterrupt(dwMintr, FALSE);
        }

        // Acknowledge interrupts (MII interrupts first)

        pCsr->mintr = dwMintr;
        pCsr->intr  = dwIntr;

        // We always call these two interrupt handlers no matter what the interrupt
        // bits say.  They will do nothing if there isn't anything to receive or transmit.

        NicRecvInterrupt();
        NicXmitInterrupt();

        // If a receive frame was missed, tell the Nic to restart RX polling

        if (dwIntr & INTR_MISS)
        {
            STATINC(rxMissedFrames);
            pCsr->mode = MODE_RXDM;
        }

    }

    // Re-enable interrupts

    pCsr->intr_mk = INTR_ALL;
}

void CXnNic::NicMiiInterrupt(DWORD dwMintr, BOOL fInit)
{
    ICHECK(NIC, USER|UDPC|SDPC);

    PNICCSR pCsr        = PNicCsr();
    DWORD   dwMiics     = pCsr->mii_cs;
    DWORD   dwLinkState = PhyGetLinkState(!fInit);

    if (fInit || (dwLinkState != _dwLinkState))
    {
        TraceSz3(Warning, "+Ethernet link status: %s %dMbps %s-duplex",
            (dwLinkState & XNET_ETHERNET_LINK_ACTIVE) ? "up" : "down",
            (dwLinkState & XNET_ETHERNET_LINK_100MBPS) ? 100 :
                (dwLinkState & XNET_ETHERNET_LINK_10MBPS) ? 10 : 0,
            (dwLinkState & XNET_ETHERNET_LINK_FULL_DUPLEX) ? "full" :
                (dwLinkState & XNET_ETHERNET_LINK_HALF_DUPLEX) ? "half" : "?");

        // NOTE: When the link was up before, we need to stop  both Tx and Rx and then set
        // Rx polling frequency and Tx duplex mode according to the link status.

        if (!fInit)
        {
            NicStopXmitRecv();
        }

        _dwRxPollFreq = (dwLinkState & XNET_ETHERNET_LINK_10MBPS) ? RXPOLL_FREQ_10MPS : RXPOLL_FREQ_100MPS;

        if (dwLinkState & XNET_ETHERNET_LINK_FULL_DUPLEX)
            pCsr->tx_cntl &= ~TXCNTL_HDEN;
        else
            pCsr->tx_cntl |=  TXCNTL_HDEN;

        if (!fInit)
        {
            NicStartXmitRecv();
        }

        if (fInit && (dwLinkState & XNET_ETHERNET_LINK_ACTIVE))
        {
            SetInitFlag(INITF_CONNECTED_BOOT);
        }

        _dwLinkState = dwLinkState;
    }
}

void CXnNic::NicRecvInterrupt()
{
    ICHECK(NIC, UDPC|SDPC);

    CPacket     pkt;
    void *      pv;
    UINT        cb;
    CEnetHdr *  pEnetHdr;
    UINT        uiFlags;
    UINT        uiType;
    RecvDesc *  prd;
    DWORD       dwFlagsCount;

    prd = _prdPtr;

    while (1)
    {
        dwFlagsCount = prd->_dwFlagsCount;

        if (dwFlagsCount & RXDESC_OWN)
            break;
        
        if ((dwFlagsCount & RXDESC_REND) == 0)
        {
            STATINC(rxEndOfFrameErrors);
            goto nextframe;
        }

        if (dwFlagsCount & RXDESC_ERR)
        {
            STATINC_(dwFlagsCount & RXDESC_OFOL,    rxOverFlowErrors);
            STATINC_(dwFlagsCount & RXDESC_CRC,     rxCrcErrors);
            STATINC_(dwFlagsCount & RXDESC_LFER,    rxLengthErrors);
            STATINC_(dwFlagsCount & RXDESC_MAX,     rxMaxFrameErrors);
            STATINC_(dwFlagsCount & RXDESC_LCOL,    rxLateCollisions);
            STATINC_(dwFlagsCount & RXDESC_RUNT,    rxRunts);
            STATINC_(dwFlagsCount & RXDESC_FRAM,    rxFramingErrors);

            // Accept an error frame if RXDESC_FRAM is the only error bit turned on.
            // For all other errors we discard the frame.

            if ((dwFlagsCount & (RXDESC_OFOL|RXDESC_CRC|RXDESC_LFER|RXDESC_MAX|RXDESC_LCOL|RXDESC_RUNT|RXDESC_FRAM)) != RXDESC_FRAM)
                goto nextframe;
        }

        // Until NicStart is called we drop all incoming frames because the upper
        // layers of the stack are still initializing.

        if (!TestInitFlag(INITF_NIC_2))
            goto nextframe;

        pv       = VirAddr(prd->_dwPhyAddr);
        cb       = (dwFlagsCount & 0xFFFF);
        pEnetHdr = (CEnetHdr *)pv;
        uiFlags  = PKTF_TYPE_ENET;
        uiType   = pEnetHdr->_wType;

        PushPktRecvTags(pEnetHdr->_eaDst.IsBroadcast());

        if ((dwFlagsCount & (RXDESC_ERR|RXDESC_FRAM|RXDESC_EXTRA)) == (RXDESC_ERR|RXDESC_FRAM|RXDESC_EXTRA))
        {
            STATINC(rxExtraByteErrors);

            if (cb > 0)
            {
                cb -= 1;
            }
        }

        if (cb < ENET_DATA_MINSIZE)
        {
            STATINC(rxMinSizeErrors);
            goto nextframepop;
        }

        STATINC(rxGoodFrames);

        if (NTOHS((WORD)uiType) <= ENET_DATA_MAXSIZE)
        {
            CIeeeHdr * pIeeeHdr = (CIeeeHdr *)pEnetHdr;
            BYTE abEnetHdr[sizeof(CEnetAddr) * 2];

            if (!pIeeeHdr->IsEnetFrame())
            {
                TraceSz(pktRecv, "[DISCARD] IEEE frame type not supported");
                goto nextframepop;
            }

            // Convert the link header into a standard CEnetHdr

            uiType = pIeeeHdr->_wTypeIeee;
            pv     = (BYTE *)pv + (sizeof(CIeeeHdr) - sizeof(CEnetHdr));
            cb    -= (sizeof(CIeeeHdr) - sizeof(CEnetHdr));

            memcpy(abEnetHdr, pIeeeHdr, sizeof(abEnetHdr));
            memcpy(pv, abEnetHdr, sizeof(abEnetHdr));

            pEnetHdr = (CEnetHdr *)pv;
            pEnetHdr->_wType = (WORD)uiType;
        }

        pv  = (BYTE *)pv + sizeof(CEnetHdr);
        cb -= sizeof(CEnetHdr);

        TraceSz4(pktRecv, "[ENET %s %s %04X][%d]",
                 pEnetHdr->_eaDst.Str(), pEnetHdr->_eaSrc.Str(), NTOHS((WORD)uiType), cb);

        if (pEnetHdr->_eaDst.IsBroadcast())
        {
            uiFlags |= PKTF_RECV_BROADCAST;
        }
        else if (!pEnetHdr->_eaDst.IsEqual(_ea))
        {
#ifdef XNET_FEATURE_XBDM_SERVER
            if (!pEnetHdr->_eaDst.IsEqual(_eaClient))
#endif
            {
                TraceSz(pktWarn, "[DISCARD] Frame should not have been accepted by Nic hardware");
                goto nextframepop;
            }
        }

#ifdef XNET_FEATURE_XBDM_SERVER
        if ((uiFlags & PKTF_RECV_BROADCAST) || (pEnetHdr->_eaDst.IsEqual(_eaClient)))
        {
            if (_pXbdmClient)
            {
                _pXbdmClient->EnetRecv(uiFlags, pv, cb, uiType);
            }
            else if ((uiFlags & PKTF_RECV_BROADCAST) == 0)
            {
                TraceSz(pktRecv, "[DISCARD] Title stack not attached");
            }

            if ((uiFlags & PKTF_RECV_BROADCAST) == 0)
                goto nextframepop;
        }
#endif

        pkt.Init(uiFlags, pv, cb, NULL);
        EnetRecv(&pkt, uiType);

    nextframepop:

        PopPktRecvTags();

    nextframe:

        prd->_dwFlagsCount = RXDESC_OWN | (NIC_FRAME_SIZE - NIC_FRAME_ALIGNMENT - 1);
        prd = PrdNext(prd);
    }

    _prdPtr = prd;
}

void CXnNic::NicXmitInterrupt()
{
    ICHECK(NIC, UDPC|SDPC);

    XmitDesc *  pxd;
    CPacket *   ppkt;
    DWORD       dwFlagsCount;
    
    while (1)
    {
        ppkt = _pqXmit.GetHead();

        if (ppkt == NULL)
            break;

        pxd = _pxdBusy;

        if (ppkt->TestFlags(PKTF_XMIT_DUALPAGE))
        {
            Assert((pxd->_dwFlagsCount & TXDESC_TEND) == 0);
            pxd = PxdNext(pxd);
        }

        dwFlagsCount = pxd->_dwFlagsCount;

        Assert(dwFlagsCount & TXDESC_TEND);

        if (dwFlagsCount & TXDESC_OWN)
            break;

        _pqXmit.RemoveHead();
        _pxdBusy  = PxdNext(pxd);
        _cxdBusy -= (1 + !!ppkt->TestFlags(PKTF_XMIT_DUALPAGE));
        MmLockUnlockBufferPages(ppkt->GetEnetHdr(), sizeof(CEnetHdr) + ppkt->GetCb(), TRUE);

        if (dwFlagsCount & TXDESC_ERR)
        {
            STATINC_(dwFlagsCount & TXDESC_UFLO,    txUnderflowErrors);
            STATINC_(dwFlagsCount & TXDESC_LCOL,    txLateCollisions);
            STATINC_(dwFlagsCount & TXDESC_LCAR,    txLostCarriers);
            STATINC_(dwFlagsCount & TXDESC_DEF,     txDefers);
            STATINC_(dwFlagsCount & TXDESC_EXDEF,   txExcessiveDefers);
            STATINC_(dwFlagsCount & TXDESC_RTRY,    txRetryErrors);
        }
        else
        {
            STATINC(txGoodFrames);
        }

#ifdef XNET_FEATURE_XBDM_SERVER
        if (ppkt->TestFlags(PKTF_XMIT_XBDMCLIENT))
        {
            CXbdmPacket * ppktXbdm = (CXbdmPacket *)ppkt;

            if (_pXbdmClient)
                _pXbdmClient->XmitComplete(ppktXbdm->_pvPkt);
            else
                TraceSz(Warning, "XBDM client detached with active packets in the Xmit queue");
                
            _pqClient.InsertTail(ppktXbdm);
            continue;
        }
#endif

        ppkt->ClearFlags(PKTF_XMIT_DUALPAGE);
        ppkt->Complete(this);
    }

    if (_fXmitFull && _cxdBusy < _cxdPool)
    {
        _fXmitFull = FALSE;

#ifdef XNET_FEATURE_XBDM_SERVER
        if (_pXbdmClient)
            _pXbdmClient->EnetPush();
#endif

        EnetPush();
    }
}

BOOL CXnNic::NicXmitReady()
{
    ICHECK(NIC, UDPC|SDPC);

#ifdef XNET_FEATURE_XBDM_CLIENT
    if (_pXbdmServer)
    {
        return(_pXbdmServer->XmitReady());
    }
#endif

    BOOL fReady = (_cxdBusy < _cxdPool);

    if (!fReady)
    {
        _fXmitFull = TRUE;
    }

    return(fReady);
}

void CXnNic::NicXmit(CPacket * ppkt)
{
    ICHECK(NIC, UDPC|SDPC);

#ifdef XNET_FEATURE_XBDM_CLIENT
    if (_pXbdmServer)
    {
        _pXbdmServer->Xmit(ppkt, ppkt->GetEnetHdr(), ppkt->GetCb() + sizeof(CEnetHdr));
    }
    else
#endif
    {
        Assert(_cxdBusy < _cxdPool);
        Assert(ppkt->GetCb() <= ENET_DATA_MAXSIZE);

        void *      pv      = ppkt->GetEnetHdr();
        UINT        cb      = ppkt->GetCb() + sizeof(CEnetHdr);
        XmitDesc *  pxd     = _pxdFree;
        XmitDesc *  pxd0;
        UINT        cb0;

        TraceSz4(pktXmit, "[ENET dst=%s src=%s %04X][%d]",
                 ((CEnetHdr *)pv)->_eaDst.Str(), ((CEnetHdr *)pv)->_eaSrc.Str(),
                 NTOHS(((CEnetHdr *)pv)->_wType), ppkt->GetCb());

        _pqXmit.InsertTail(ppkt);

        MmLockUnlockBufferPages(pv, cb, FALSE);

        pxd->_dwPhyAddr = MmGetPhysicalAddress(pv);
        cb0 = PAGE_SIZE - (pxd->_dwPhyAddr & (PAGE_SIZE - 1));

        if (cb <= cb0)
        {
            // Entire frame is in a single physical page.  Only need one transmit destriptor.
            // Notice that the length in the _dwFlagsCount is the actual length minus one.
            // That is an odd requirement of the nVidia hardware.

            ppkt->ClearFlags(PKTF_XMIT_DUALPAGE);

            pxd->_dwFlagsCount = TXDESC_OWN | TXDESC_TEND | (cb - 1);
        }
        else
        {
            // The frame straddles a page boundary.  Use two transmit descriptors.  We set
            // up the second descriptor before the first one to prevent the Nic from trying
            // to transmit the frame before we are done setting up the two descriptors.

            ppkt->SetFlags(PKTF_XMIT_DUALPAGE);

            pxd0 = pxd;
            pxd  = PxdNext(pxd0);
            _cxdBusy += 1;

            pxd->_dwPhyAddr     = MmGetPhysicalAddress((BYTE *)pv + cb0);
            pxd->_dwFlagsCount  = TXDESC_OWN | TXDESC_TEND | (cb - cb0 - 1);
            pxd0->_dwFlagsCount = TXDESC_OWN | (cb0 - 1);
        }

        _pxdFree = PxdNext(pxd);
        _cxdBusy += 1;

        if (!TestInitFlag(INITF_NIC_STOP))
        {
            // Tell the Nic to check the transmit ring
            PNICCSR pCsr = PNicCsr();
            pCsr->mode = MODE_TXDM;
        }
    }
}

void CXnNic::NicTimer()
{
    ICHECK(NIC, SDPC);

#ifdef XNET_FEATURE_XBDM_CLIENT
    if (_pXbdmServer)
        return;
#endif

    // This function gets called every 200ms from the main timer.  Occasionally, the
    // transmitter will stall with frames on the queue.  If there are any frames queued,
    // we set the MODE_TXDM bit on the Nic hardware to tell it to check the queue.

    if (_cxdBusy > 0)
    {
        PNICCSR pCsr = PNicCsr();
        pCsr->mode = MODE_TXDM;
    }

    // In case we miss a receive interrupt, process any received frames now

    if ((_prdPtr->_dwFlagsCount & RXDESC_OWN) == 0)
    {
        NicRecvInterrupt();
    }
}

NTSTATUS CXnNic::NicInit(XNetInitParams * pxnip)
{
    TCHECK(USER);

    NTSTATUS status = BaseInit(pxnip);
    if (!NT_SUCCESS(status))
        return(status);

#ifdef XNET_FEATURE_XBDM_CLIENT

    _pXbdmServer = (CXbdmServer *)KeGetCurrentPrcb()->DmEnetFunc;

    if (_pXbdmServer)
    {
        if (!_pXbdmServer->IsValidServer())
        {
            TraceSz(Warning, "XBDM.DLL is incompatible with this version of XNET.");
            return(NETERR_SYSCALL);
        }

        BOOL fLinkIsUp = FALSE;

        status = _pXbdmServer->InitClient(cfgEnetReceiveQueueLength, cfgEnetTransmitQueueLength,
                                          &_ea, &fLinkIsUp);

        if (!NT_SUCCESS(status))
            return(status);

        SetInitFlag(INITF_NIC);

        if (fLinkIsUp)
        {
            SetInitFlag(INITF_CONNECTED_BOOT);
        }

        return(NETERR_OK);
    }

#elif !defined(XNET_FEATURE_XBDM_SERVER)

    // For xnets.lib (secure library), we cannot have XBDM owning the network stack.
    // If we find that it is running, we tell it to release the NIC hardware now.
    // Note that this code will execute on the retail box, but will have no effect
    // because pXbdmServer will be NULL always.  This code sequence makes it possible
    // to run an XBE linked with xnets.lib on a devkit.

    CXbdmServer * pXbdmServer = (CXbdmServer *)KeGetCurrentPrcb()->DmEnetFunc;

    if (pXbdmServer && pXbdmServer->IsValidServer())
        pXbdmServer->NicStop();

#endif

    SetInitFlag(INITF_NIC);

    StatInit();

    PNICCSR pCsr = PNicCsr();

    _ulIntrVector = HalGetInterruptVector(XPCICFG_NIC_IRQ, &_irqlIntr);

    KeInitializeDpc(&_dpc, NicDpc, this);
    KeInitializeInterrupt(&s_InterruptObject, NicIsr, this, _ulIntrVector,
                          _irqlIntr, LevelSensitive, TRUE);

    NicStopXmitRecv();

    // Reset buffer management

    pCsr->mode = MODE_RESET_BUFFERS;
    KeStallExecutionProcessor(10);
    pCsr->mode = 0;
    KeStallExecutionProcessor(10);

    pCsr->mintr_mk  = 0;
    pCsr->intr_mk   = 0;
    pCsr->pm_cntl   = 0;
    pCsr->swtr_cntl = 0;
    pCsr->tx_poll   = 0;
    pCsr->rx_poll   = 0;
    pCsr->tx_sta    = pCsr->tx_sta;
    pCsr->rx_sta    = pCsr->rx_sta;
    pCsr->mintr     = pCsr->mintr;
    pCsr->intr      = pCsr->intr;

    _crdPool = cfgEnetReceiveQueueLength;

    if (_crdPool > (PAGE_SIZE/2)/sizeof(RecvDesc))
        _crdPool = (PAGE_SIZE/2)/sizeof(RecvDesc);

    _cxdPool = cfgEnetTransmitQueueLength + 1;

    if (_cxdPool > (PAGE_SIZE/2)/sizeof(XmitDesc))
        _cxdPool = (PAGE_SIZE/2)/sizeof(XmitDesc);

    XmitDesc * pxd = NULL;
    UINT cbDma = PAGE_SIZE + (_crdPool * NIC_FRAME_SIZE);

#ifdef XNET_FEATURE_XBDM_SERVER
    // Try allocating the DMA memory in the first 64K if possible under XBDM.
    pxd = (XmitDesc *)HalDmaAlloc(cbDma, 64 * 1024);
#endif

    if (pxd == NULL)
        pxd = (XmitDesc *)HalDmaAlloc(cbDma);

    if (pxd == NULL)
    {
        TraceSz(Warning, "Out of memory allocating DMA receive buffers");
        return(NETERR_MEMORY);
    }

    // Clear the entire first page where the transmit and receive descriptors go

    memset(pxd, 0, PAGE_SIZE);

    // Compute the offset between virtual and physical memory for these descriptors

    _dwPhyOff = MmGetPhysicalAddress(pxd) - (DWORD_PTR)pxd;

    // Fill in the transmit descriptor pointers

    _pxdFirst = pxd;
    _pxdBusy  = pxd;
    _pxdFree  = pxd;
    _pxdLast  = pxd + _cxdPool - 1;

    // Decrement _cxdPool so that we can assume that two transmit descriptors are
    // available whenever _cxdBusy < _cxdPool.  This makes for an easier check later.

    _cxdPool -= 1;

    RecvDesc * prd = (RecvDesc *)((BYTE *)pxd + (PAGE_SIZE/2));

    _prdFirst = prd;
    _prdPtr   = prd;
    _prdLast  = prd + _crdPool - 1;

    // Fill in the RecvDesc to point to the frame buffers.  Notice that we bias the
    // frame pointer by NIC_FRAME_ALIGNMENT (2 bytes).  This is because the CEnetHdr
    // is 14 bytes long, and we'd like the start of the IP packet to be on a four-byte
    // boundary.

    DWORD dwPhyAddr = (DWORD_PTR)pxd + _dwPhyOff + PAGE_SIZE + NIC_FRAME_ALIGNMENT;

    for (; prd <= _prdLast; ++prd, dwPhyAddr += NIC_FRAME_SIZE)
    {
        prd->_dwPhyAddr = dwPhyAddr;
        prd->_dwFlagsCount = RXDESC_OWN | (NIC_FRAME_SIZE - NIC_FRAME_ALIGNMENT - 1);
    }

#ifdef XNET_FEATURE_XBDM_SERVER

    // Allocate and enqueue enough CXbdmPacket structures to satisfy the worst case
    // where the client has completely filled the transmit queue.

    CXbdmPacket * ppktXbdm = (CXbdmPacket *)SysAllocZ((_cxdPool + 1) * sizeof(CXbdmPacket), PTAG_CXbdmPacket);

    if (ppktXbdm == NULL)
    {
        TraceSz(Warning, "Out of memory allocating CXbdmPacket");
        return(NETERR_MEMORY);
    }

    _ppktXbdm = ppktXbdm;

    for (int cPkt = _cxdPool + 1; cPkt > 0; --cPkt, ++ppktXbdm)
    {
        _pqClient.InsertTail(ppktXbdm);
    }

#endif

    ULONG ulType, ulSize;
    status = ExQueryNonVolatileSetting(XC_FACTORY_ETHERNET_ADDR, &ulType, (BYTE *)&_ea, sizeof(CEnetAddr), &ulSize);

    if (!NT_SUCCESS(status) || ulSize != sizeof(CEnetAddr))
    {
        // If we failed to read Ethernet address from non-volatile memory,
        // pick a random even address among the first 64 addresses of
        // the 00-50-f2 address block. This is so that we can at least boot
        // on the manufacturing line and start communicating with the test server.

        TraceSz(Warning, "**************************************************************************");
        TraceSz2(Warning, "Unable to read Ethernet address from EEPROM (status=%08X,ulSize=%d).", status, ulSize);
        TraceSz(Warning, "Run the recovery CD to repair.  Continuing with a random Ethernet address.");
        TraceSz(Warning, "**************************************************************************");

        BYTE bAddr;
        Rand(&bAddr, sizeof(bAddr));
        _ea._ab[1] = 0x50;
        _ea._ab[2] = 0xF2;
        _ea._ab[5] = (BYTE)(bAddr & 0x3E);
    }

    _dwRxPollFreq = RXPOLL_FREQ_100MPS;

#ifdef XNET_FEATURE_XBDM_SERVER

    if (_ea._ab[5] & 1)
    {
        TraceSz(Warning, "***************************************************************************");
        TraceSz1(Warning, "Ethernet address of this Development Kit is incorrect (%s).", _ea.Str());
        TraceSz(Warning, "The last bit of the address should not be set.  Clearing last bit and");
        TraceSz(Warning, "continuing.  There may be conflicts with other network devices as a result.");
        TraceSz(Warning, "***************************************************************************");
        
        _ea._ab[5] &= ~1;
    }

    _eaClient = _ea;    // Title always gets EEPROM address
    _ea._ab[5] |= 1;    // Debug always gets next address

    // Enable unicast reception for the Ethernet address of the title stack

    pCsr->uni0 = HWADDR0(_eaClient._ab);
    pCsr->uni1 = HWADDR1(_eaClient._ab);

    // Enable multicast reception for the Ethernet address of the debug stack

    pCsr->mult_mk0 = 0xFFFFFFFF;
    pCsr->mult_mk1 = 0xFFFF;
    pCsr->mult0    = HWADDR0(_ea._ab);
    pCsr->mult1    = HWADDR1(_ea._ab);

#else

    // Enable unicast reception for the Ethernet address of the title stack

    pCsr->uni0 = HWADDR0(_ea._ab);
    pCsr->uni1 = HWADDR1(_ea._ab);

    // Disable multicast reception

    pCsr->mult_mk0 = 0xFFFFFFFF;
    pCsr->mult_mk1 = 0xFFFF;
    pCsr->mult0    = 0xFFFFFFFF;
    pCsr->mult1    = 0xFFFF;

#endif

    // Setup transmitter and receiver
    // NOTE: nVidia NIC somehow expects the maximum
    // receive buffer size is 1518 instead of 1514.
    Assert(NIC_FRAME_SIZE - NIC_FRAME_ALIGNMENT > 1518);
    pCsr->rx_cntl_1 = 1518;
    pCsr->rx_cntl_0 = RXCNTL_DEFAULT;
    pCsr->tx_cntl = TXCNTL_DEFAULT;

    // Randomly generate a backoff control timeout (single byte), but don't let it
    // be zero because that means no seed (aggressive retry).
    BYTE bBackoff;
    Rand(&bBackoff, sizeof(bBackoff));
    bBackoff += (bBackoff == 0);
    pCsr->bkoff_cntl = (BKOFFCNTL_DEFAULT & 0xFFFFFF00) | bBackoff;

    pCsr->tx_def = TXDEF_DEFAULT;
    pCsr->rx_def = RXDEF_DEFAULT;

    pCsr->tx_dadr = PhyAddr(_pxdFirst);
    pCsr->rx_dadr = PhyAddr(_prdFirst);
    pCsr->dlen = ((_crdPool-1) << 16) | (_cxdPool); // _cxdPool already decremented earlier
    pCsr->rx_fifo_wm = RXFIFOWM_DEFAULT;
    pCsr->tx_fifo_wm = TXFIFOWM_DEFAULT;

    // Enable MII auto-polling interrupt (delay auto-poll enable until after PhyInitialize)
    pCsr->mii_cs = MIICS_DEFAULT & ~MIICS_APEN;
    pCsr->mii_tm = MIITM_DEFAULT;
    KeStallExecutionProcessor(50);

    // Initialize the PHY
    status = PhyInitialize(FALSE, NULL);
    if (!NT_SUCCESS(status))
        return(status);

    pCsr->mii_cs |= MIICS_APEN;
    KeStallExecutionProcessor(50);

    NicMiiInterrupt(0, TRUE);
    NicStartXmitRecv();

    pCsr->mintr = pCsr->mintr;
    pCsr->intr = pCsr->intr;
    pCsr->mintr_mk = MINTR_MAPI;
    pCsr->intr_mk = INTR_ALL;

    if (!KeConnectInterrupt(&s_InterruptObject))
    {
        TraceSz(Warning, "Failed to connect NIC interrupt");
        return(STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT);
    }

    _HalShutdownReg.NotificationRoutine = (PHAL_SHUTDOWN_NOTIFICATION)HalShutdownNotification;
    HalRegisterShutdownNotification(&_HalShutdownReg, TRUE);
    SetInitFlag(INITF_NIC_1);

#ifdef XNET_FEATURE_XBDM_SERVER
    
    KeGetCurrentPrcb()->DmEnetFunc = &_XbdmServer;

#endif

    return(NETERR_OK);
}

void CXnNic::NicStart()
{
    ICHECK(NIC, USER);

    BaseStart();

    Assert(!TestInitFlag(INITF_NIC_STOP));

#ifdef XNET_FEATURE_XBDM_CLIENT
    if (_pXbdmServer)
    {
        _pXbdmServer->AttachClient(&_XbdmClient);
        return;
    }
#endif

    SetInitFlag(INITF_NIC_2);
}

void CXnNic::NicFlush()
{
    TCHECK(UDPC|SDPC);

#ifdef XNET_FEATURE_XBDM_CLIENT
    if (_pXbdmServer)
        return;
#endif

    if (!TestInitFlag(INITF_NIC) || TestInitFlag(INITF_NIC_STOP))
        return;

    // Wait up to half a second for packets queued for transmit to go

    EnetPush();

    PNICCSR pCsr = PNicCsr();

    for (UINT cTimeout = 10000; cTimeout > 0; --cTimeout)
    {
        pCsr->mode = MODE_TXDM;
        NicXmitInterrupt();

        if (_pqXmit.IsEmpty())
            break;

        KeStallExecutionProcessor(50);
    }
}

void CXnNic::NicStop()
{
    TCHECK(UDPC|SDPC);

    if (TestInitFlag(INITF_NIC) && !TestInitFlag(INITF_NIC_STOP))
    {
        if (TestInitFlag(INITF_NIC_1))
        {
            HalRegisterShutdownNotification(&_HalShutdownReg, FALSE);
        }

#ifdef XNET_FEATURE_XBDM_CLIENT
        if (_pXbdmServer)
        {
            _pXbdmServer->DetachClient();
        }
        else
#endif
        {
            if (s_InterruptObject.Connected)
            {
                KeDisconnectInterrupt(&s_InterruptObject);
            }

            KeRemoveQueueDpc(&_dpc);
        }

        SetInitFlag(INITF_NIC_STOP);
    }

    BaseStop();
}

void CXnNic::NicTerm()
{
    TCHECK(UDPC);

    NicStop();

    SetInitFlag(INITF_NIC_TERM);

    if (TestInitFlag(INITF_NIC))
    {
        StatTerm();

        if (!_pqXmit.IsEmpty())
        {
            TraceSz1(Warning, "Nic shutdown with %d packet(s) queued for transmit", _pqXmit.Count());
        }

        while (!_pqXmit.IsEmpty())
        {
            CPacket * ppkt = _pqXmit.RemoveHead();
            MmLockUnlockBufferPages(ppkt->GetEnetHdr(), sizeof(CEnetHdr) + ppkt->GetCb(), TRUE);
            Assert(!ppkt->TestFlags(PKTF_XMIT_XBDMCLIENT));
            PacketFree(ppkt);
        }

        if (_pxdFirst)
        {
            HalDmaFree(_pxdFirst);
        }

#ifdef XNET_FEATURE_XBDM_SERVER
        if (_ppktXbdm)
        {
            SysFree(_ppktXbdm);
        }

        KeGetCurrentPrcb()->DmEnetFunc = NULL;
        Assert(_pXbdmClient == NULL);
#endif

        Assert(!s_InterruptObject.Connected);
    }

    BaseTerm();
}

void CXnNic::HalShutdownNotification(HAL_SHUTDOWN_REGISTRATION * pHalShutdownReg)
{
    KIRQL kirql = ::KeRaiseIrqlToDpcLevel();
    CXnNic * pXnNic = (CXnNic *)((BYTE *)pHalShutdownReg - offsetof(CXnNic, _HalShutdownReg));
    ((CXnIp *)pXnNic)->SecRegShutdown(FALSE);
    pXnNic->NicFlush();
    pXnNic->NicStop();
    ::KeLowerIrql(kirql);
}

// ---------------------------------------------------------------------------------------
// Nic Statistics
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_STATS

void CXnNic::StatInit()
{
    _timerStats.Init((PFNTIMER)StatTimer);
}

void CXnNic::StatTerm()
{
    TimerSet(&_timerStats, TIMER_INFINITE);
}

void CXnNic::StatInc(UINT iStat)
{
    ICHECK(NIC, UDPC|SDPC);

    ULONG * pul = (ULONG *)((BYTE *)&_NicStats + iStat);

    *pul += 1;

#ifdef XNET_FEATURE_TRACE

    if (    Tag(nicStats)
        &&  (   Tag(nicStatsAll)
             || (iStat > offsetof(NICSTATS, rxGoodFrames))))
    {
        if (!_timerStats.IsActive())
        {
            TimerSetRelative(&_timerStats, 5 * TICKS_PER_SECOND);
        }
    }

#endif
}

void CXnNic::StatTimer(CTimer * pt)
{
    ICHECK(NIC, UDPC|SDPC);

    #define DUMPSTAT(n) if (_NicStatsLast.n != _NicStats.n) { TraceSz3(nicStats, "%5d [%5d] %s", _NicStats.n - _NicStatsLast.n, _NicStats.n, #n); }

    TraceSz7(nicStats, "[tx %d] [txq %d/%d] [rx %d] [rxq %d] [isr %d] [dpc %d]",
             _NicStats.txGoodFrames, _cxdBusy, _cxdPool, _NicStats.rxGoodFrames, _crdPool,
             _NicStats.isrCount, _NicStats.dpcCount);

    DUMPSTAT(txUnderflowErrors);
    DUMPSTAT(txLateCollisions);
    DUMPSTAT(txLostCarriers);
    DUMPSTAT(txDefers);
    DUMPSTAT(txExcessiveDefers);
    DUMPSTAT(txRetryErrors);
    DUMPSTAT(rxMinSizeErrors);
    DUMPSTAT(rxFramingErrors);
    DUMPSTAT(rxOverFlowErrors);
    DUMPSTAT(rxCrcErrors);
    DUMPSTAT(rxLengthErrors);
    DUMPSTAT(rxMaxFrameErrors);
    DUMPSTAT(rxLateCollisions);
    DUMPSTAT(rxRunts);
    DUMPSTAT(rxExtraByteErrors);
    DUMPSTAT(rxMissedFrames);
    DUMPSTAT(rxEndOfFrameErrors);
    
    _NicStatsLast = _NicStats;
}

#endif

// ---------------------------------------------------------------------------------------
// CXbdmClient
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_XBDM_CLIENT

INLINE CXnNic * CXnNic::CXbdmClient::GetXnNic()
{
    return((CXnNic *)((BYTE *)this - offsetof(CXnNic, _XbdmClient)));
}

void CXnNic::CXbdmClient::XmitComplete(void * pvPkt)
{
    ((CPacket *)pvPkt)->Complete(GetXnNic());
}

void CXnNic::CXbdmClient::EnetRecv(UINT uiFlags, void * pv, UINT cb, UINT uiType)
{
    CPacket pkt;

    pkt.Init(uiFlags, pv, cb, NULL);

    GetXnNic()->PushPktRecvTags(pkt.GetEnetHdr()->_eaDst.IsBroadcast());
    GetXnNic()->EnetRecv(&pkt, uiType);
    GetXnNic()->PopPktRecvTags();
}

void CXnNic::CXbdmClient::EnetPush()
{
    GetXnNic()->EnetPush();
}

DWORD CXnNic::CXbdmClient::GetXnAddr(XNADDRXBDM * pxnaXbdm)
{
    XNADDR xnaddr;
    DWORD dwFlags = ((CXnIp *)GetXnNic())->IpGetXnAddr(&xnaddr);
    memcpy(pxnaXbdm->abEnet, xnaddr.abEnet, sizeof(pxnaXbdm->abEnet));
    pxnaXbdm->ina = xnaddr.ina;
    return(dwFlags);
}

DWORD CXnNic::NicGetOtherXnAddr(XNADDR * pxna)
{
    XNADDRXBDM xnaddrXbdm = { 0 };
    DWORD dwFlags = _pXbdmServer ? _pXbdmServer->GetXnAddr(&xnaddrXbdm) : XNET_GET_XNADDR_NONE;
    memset(pxna, 0, sizeof(*pxna));
    memcpy(pxna->abEnet, xnaddrXbdm.abEnet, sizeof(pxna->abEnet));
    pxna->ina = xnaddrXbdm.ina;
    return(dwFlags);
}

#endif

// ---------------------------------------------------------------------------------------
// CXbdmServer
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_XBDM_SERVER

INLINE CXnNic * CXnNic::CXbdmServer::GetXnNic()
{
    return((CXnNic *)((BYTE *)this - offsetof(CXnNic, _XbdmServer)));
}

void CXnNic::CXbdmServer::NicStop()
{
    Assert(GetXnNic()->_pXbdmClient == NULL);
    KIRQL irql = ::KeRaiseIrqlToDpcLevel();
    GetXnNic()->NicStop();
    KeGetCurrentPrcb()->DmEnetFunc = NULL;
    ::KeLowerIrql(irql);
}

NTSTATUS CXnNic::CXbdmServer::InitClient(UINT cfgRecvQ, UINT cfgXmitQ, CEnetAddr * pea, BOOL * pfLinkIsUp)
{
    Assert(GetXnNic()->_pXbdmClient == NULL);
    *pea = GetXnNic()->_eaClient;
    *pfLinkIsUp = GetXnNic()->TestInitFlag(INITF_CONNECTED_BOOT);
    return(NETERR_OK);
}

void CXnNic::CXbdmServer::AttachClient(CXbdmClient * pXbdmClient)
{
    Assert(GetXnNic()->_pXbdmClient == NULL);
    KIRQL irql = ::KeRaiseIrqlToDpcLevel();
    GetXnNic()->_pXbdmClient = pXbdmClient;
    ::KeLowerIrql(irql);
}

void CXnNic::CXbdmServer::DetachClient()
{
    Assert(KeGetCurrentIrql() == DISPATCH_LEVEL);

    CXnNic * pXnNic = GetXnNic();
    PNICCSR pCsr = PNicCsr();
    UINT cTimeout = 0;

    while (!pXnNic->_pqXmit.IsEmpty())
    {
        pCsr->mode = MODE_TXDM;
        pXnNic->NicXmitInterrupt();
        KeStallExecutionProcessor(50);
        cTimeout++;
        AssertSz(cTimeout != 20000, "Taking too long to flush transmit queue");
    }

    pXnNic->_pXbdmClient = NULL;
}

void CXnNic::CXbdmServer::Xmit(void * pvPkt, void * pv, UINT cb)
{
    CXnNic * pXnNic = GetXnNic();
    Assert(pXnNic->_pXbdmClient != NULL);
    Assert(!pXnNic->_pqClient.IsEmpty());
    CXbdmPacket * ppktXbdm = (CXbdmPacket *)pXnNic->_pqClient.RemoveHead();
    ppktXbdm->Init(PKTF_XMIT_XBDMCLIENT, (BYTE *)pv + sizeof(CEnetHdr), cb - sizeof(CEnetHdr), NULL);
    ppktXbdm->_pvPkt = pvPkt;
    pXnNic->NicXmit(ppktXbdm);
}

BOOL CXnNic::CXbdmServer::XmitReady()
{
    Assert(GetXnNic()->_pXbdmClient != NULL);
    BOOL fReady = GetXnNic()->NicXmitReady();
    return(fReady);
}

DWORD CXnNic::CXbdmServer::GetXnAddr(XNADDRXBDM * pxnaXbdm)
{
    XNADDR xnaddr;
    DWORD dwFlags = ((CXnIp *)GetXnNic())->IpGetXnAddr(&xnaddr);
    memcpy(pxnaXbdm->abEnet, xnaddr.abEnet, sizeof(pxnaXbdm->abEnet));
    pxnaXbdm->ina = xnaddr.ina;
    return(dwFlags);
}

DWORD CXnNic::NicGetOtherXnAddr(XNADDR * pxna)
{
    XNADDRXBDM xnaddrXbdm = { 0 };
    DWORD dwFlags = _pXbdmClient ? _pXbdmClient->GetXnAddr(&xnaddrXbdm) : XNET_GET_XNADDR_NONE;
    memset(pxna, 0, sizeof(*pxna));
    memcpy(pxna->abEnet, xnaddrXbdm.abEnet, sizeof(pxna->abEnet));
    pxna->ina = xnaddrXbdm.ina;
    return(dwFlags);
}

#endif

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\nicx.h ===
// ---------------------------------------------------------------------------------------
// nicx.h
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef _NICX_H_
#define _NICX_H_

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

struct NICSTATS
{
    ULONG               isrCount;
    ULONG               dpcCount;
    ULONG               txGoodFrames;
    ULONG               rxGoodFrames;
    ULONG               txUnderflowErrors;
    ULONG               txLateCollisions;
    ULONG               txLostCarriers;
    ULONG               txDefers;
    ULONG               txExcessiveDefers;
    ULONG               txRetryErrors;
    ULONG               rxMinSizeErrors;
    ULONG               rxFramingErrors;
    ULONG               rxOverFlowErrors;
    ULONG               rxCrcErrors;
    ULONG               rxLengthErrors;
    ULONG               rxMaxFrameErrors;
    ULONG               rxLateCollisions;
    ULONG               rxRunts;
    ULONG               rxExtraByteErrors;
    ULONG               rxMissedFrames;
    ULONG               rxEndOfFrameErrors;

};

#define NIC_VENDORID    0x10DE      // nVidia Vendor ID
#define NIC_DEVICEID    0x01C3      // nVidia Device ID

#define RXDESC_OWN      BIT(31)     // 0 - host owns; 1 - controller owns
#define RXDESC_ERR      BIT(30)     // receive error
#define RXDESC_FRAM     BIT(29)     // framing error
#define RXDESC_OFOL     BIT(28)     // overflow error
#define RXDESC_CRC      BIT(27)     // CRC error
#define RXDESC_LFER     BIT(26)     // length field error
#define RXDESC_MAX      BIT(25)     // received frame larger than max size
#define RXDESC_LCOL     BIT(24)     // late collision
#define RXDESC_RUNT     BIT(23)     // runt packet received
#define RXDESC_PAM      BIT(22)     // physical address match
#define RXDESC_MAM      BIT(21)     // multicast address match
#define RXDESC_BAM      BIT(20)     // broadcast address match
#define RXDESC_EXTRA    BIT(18)     // received frame length has an extra byte
#define RXDESC_MISS     BIT(17)     // missed data reception
#define RXDESC_REND     BIT(16)     // end of receive frame

#define TXDESC_OWN      BIT(31)     // 0 - host owns; 1 - controller owns
#define TXDESC_ERR      BIT(30)     // transmit error
#define TXDESC_UFLO     BIT(29)     // underflow error
#define TXDESC_LCOL     BIT(28)     // late collision
#define TXDESC_LCAR     BIT(27)     // loss of carrier
#define TXDESC_DEF      BIT(26)     // deferred
#define TXDESC_EXDEF    BIT(25)     // excessive deferral
#define TXDESC_INTEN    BIT(24)     // interrupt override
#define TXDESC_RTRY     BIT(19)     // retry error (23-20: retry count)
#define TXDESC_TEND     BIT(16)     // end of transmit frame

struct XmitDesc
{
    DWORD       _dwPhyAddr;         // physical address of xmit buffer
    DWORD       _dwFlagsCount;      // HIWORD - control/status bits; LOWORD - byte count minus 1
};

struct RecvDesc
{
    DWORD       _dwPhyAddr;         // physical address of recv buffer
    DWORD       _dwFlagsCount;      // HIWORD - control/status bits; LOWORD - byte count
};

#define NIC_FRAME_SIZE      (PAGE_SIZE/2)
#define NIC_FRAME_ALIGNMENT 2

// ---------------------------------------------------------------------------------------
// CXnNic
// ---------------------------------------------------------------------------------------

class NOVTABLE CXnNic : public CXnBase
{
    // Definitions -----------------------------------------------------------------------

    struct XNADDRXBDM
    {
        BYTE        bSizeOfStruct;                  // sizeof(XNADDR)
        BYTE        bFlags;                         // XNET_XNADDR_* flags below
        BYTE        abEnet[6];                      // Ethernet MAC address
        IN_ADDR     ina;                            // IP address (zero if not static/DHCP)
        IN_ADDR     inaOnline;                      // Online IP address (zero if not online)
        WORD        wPortOnline;                    // Online port (zero if not online)
        BYTE        abIdOnline[20];                 // Online identifier (zero if not online)
    };

    // External --------------------------------------------------------------------------

public:

    HAL_DECLARE_NEW_DELETE(CXnNic)

    BOOL                NicXmitReady();
    void                NicXmit(CPacket * ppkt);
    VIRTUAL void        NicTimer();

#if defined(XNET_FEATURE_XBDM_CLIENT) || defined(XNET_FEATURE_XBDM_SERVER)
    DWORD               NicGetOtherXnAddr(XNADDR * pxna);
#endif

protected:

    NTSTATUS            NicInit(XNetInitParams * pxnip);
    INLINE INT          NicConfig(const XNetConfigParams * pxncp) { return(0); }
    void                NicStart();
    void                NicFlush();
    void                NicStop();
    void                NicTerm();

    VIRTUAL void        EnetRecv(CPacket * ppkt, UINT uiType) VPURE;
    VIRTUAL void        EnetPush() VPURE;

    // Internal --------------------------------------------------------------------------

private:

    INLINE XmitDesc *   PxdNext(XmitDesc * pxd) { return(pxd == _pxdLast ? _pxdFirst : (pxd + 1)); }
    INLINE RecvDesc *   PrdNext(RecvDesc * prd) { return(prd == _prdLast ? _prdFirst : (prd + 1)); }
    INLINE DWORD_PTR    PhyAddr(void * pv)      { return((DWORD_PTR)pv + _dwPhyOff); }
    INLINE void *       VirAddr(DWORD_PTR dw)   { return((void *)(dw - _dwPhyOff)); }

    void                NicStartXmitRecv();
    void                NicStopXmitRecv();
    static BOOLEAN      NicIsr(PKINTERRUPT, PVOID pvContext);
    BOOLEAN             NicProcessIsr();
    static void         NicDpc(PKDPC dpc, void * pvContext, void * pvArg1, void * pvArg2);
    void                NicProcessDpc();
    void                NicMiiInterrupt(DWORD dwMintr, BOOL fInit);
    void                NicRecvInterrupt();
    void                NicXmitInterrupt();

    static void         HalShutdownNotification(HAL_SHUTDOWN_REGISTRATION * pHalShutdownReg);

    class CXbdmClient
    {
    public:
        INLINE CXnNic *         GetXnNic();
        virtual void            XmitComplete(void * pvPkt);
        virtual void            EnetRecv(UINT uiFlags, void * pv, UINT cb, UINT uiType);
        virtual void            EnetPush();
        virtual DWORD           GetXnAddr(XNADDRXBDM * pxnaXbdm);
    };

    class CXbdmServer
    {
    public:
        // This magic cookie on the XBDM server CXnNic protects the client from connecting
        // to an incompatible version.  We only change it when this interface changes in
        // a non-backward compatible way.
        #define XBDM_SERVER_COOKIE 'XBD6'
        CXbdmServer() { _dwCookie = XBDM_SERVER_COOKIE; }
        BOOL                    IsValidServer() { return(_dwCookie == XBDM_SERVER_COOKIE); }
        INLINE CXnNic *         GetXnNic();
        virtual void            NicStop();
        virtual NTSTATUS        InitClient(UINT cfgRecvQ, UINT cfgXmitQ, CEnetAddr * pea, BOOL * pfLinkIsUp);
        virtual void            AttachClient(CXbdmClient * pXbdmClient);
        virtual void            DetachClient();
        virtual DWORD           GetXnAddr(XNADDRXBDM * pxnaXbdm);
        virtual void            Xmit(void * pvPkt, void * pv, UINT cb);
        virtual BOOL            XmitReady();
        DWORD                   _dwCookie;
    };

    class CXbdmPacket : public CPacket
    {

    public:

        void *          _pvPkt;                 // Client's packet pointer
    };

#ifdef XNET_FEATURE_STATS
    #define STATINC(n)          StatInc(offsetof(NICSTATS, n))
    #define STATINC_(x,n)       if (x) STATINC(n)
    void                        StatInit();
    void                        StatTerm();
    void                        StatInc(UINT iStat);
    void                        StatTimer(CTimer * pt);
#else
    #define STATINC(n)
    #define STATINC_(x,n)
    INLINE void                 StatInit() {};
    INLINE void                 StatTerm() {};
#endif

    // Data ------------------------------------------------------------------------------

public:

    CEnetAddr                   _ea;                // Ethernet address

private:

    KDPC                        _dpc;               // DPC object
    ULONG                       _ulIntrVector;      // interrupt vector
    KIRQL                       _irqlIntr;          // interrupt IRQ level
    DWORD                       _dwRxPollFreq;      // Rx polling frequency
    DWORD                       _dwLinkState;       // last known link state (from PhyGetLinkState)
    BOOL                        _fXmitFull;         // TRUE if _cxdBusy >= _cxdPool
    DWORD_PTR                   _dwPhyOff;          // virtual to physical offset
    LONG                        _cxdBusy;           // count of busy transmit descriptors
    LONG                        _cxdPool;           // number of transmit descriptors (minus 1)
    XmitDesc *                  _pxdFirst;          // first transmit descriptor
    XmitDesc *                  _pxdLast;           // last transmit descriptor
    XmitDesc *                  _pxdBusy;           // first busy transmit descriptor
    XmitDesc *                  _pxdFree;           // first free transmit descriptor
    CPacketQueue                _pqXmit;            // queue of packets being transmitted
    LONG                        _crdPool;           // number of receive descriptors available
    RecvDesc *                  _prdFirst;          // first receive descriptor
    RecvDesc *                  _prdLast;           // last receive descriptor
    RecvDesc *                  _prdPtr;            // current receive descriptor
    HAL_SHUTDOWN_REGISTRATION   _HalShutdownReg;    // registration for system shutdown

#ifdef XNET_FEATURE_XBDM_CLIENT
    CXbdmServer *               _pXbdmServer;       // Non-NULL when XBDM is running in this process
    CXbdmClient                 _XbdmClient;        // The object we give to the XBDM server
#endif

#ifdef XNET_FEATURE_XBDM_SERVER
    CXbdmClient *               _pXbdmClient;       // Non-NULL when the title stack is attached
    CXbdmServer                 _XbdmServer;        // The object we give to the XBDM client
    CEnetAddr                   _eaClient;          // Ethernet address of title stack
    CPacketQueue                _pqClient;          // Packet queue of client packets
    CXbdmPacket *               _ppktXbdm;          // Vector of CXbdmPacket structures
#endif

#ifdef XNET_FEATURE_STATS
    NICSTATS                    _NicStats;          // statistics
    NICSTATS                    _NicStatsLast;      // statistics at last report
    CTimer                      _timerStats;        // statistics timer
#endif

private:

    static KINTERRUPT           s_InterruptObject;

};

#endif  // _NICX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\nicw.cpp ===
// ----------------------------------------------------------------------------
// nicw.cpp
//
// Copyright (C) Microsoft Corporation
// ----------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

#ifdef XNET_FEATURE_WINDOWS

#include <vlan.h>

// ----------------------------------------------------------------------------
// CXnNic - External
// ----------------------------------------------------------------------------

NTSTATUS CXnNic::NicInit(XNetInitParams * pxnip)
{
    TCHECK(USER);

    NTSTATUS status = BaseInit(pxnip);
    if (!NT_SUCCESS(status))
        return(status);

    SetInitFlag(INITF_NIC_1);

    RecvDesc *  prd;
    BYTE *      pb;
    LONG        cb;

    prd = (RecvDesc *)SysAllocZ(cfgEnetReceiveQueueLength * sizeof(RecvDesc), PTAG_CXnNic);

    if (prd == NULL)
    {
        TraceSz(Warning, "NicInit: Unable to allocate memory");
        return(NETERR_MEMORY);
    }

    KeInitializeDpc(&_dpcRecv, DpcCallback, this);

    _cxdPool   = cfgEnetTransmitQueueLength;
    _crdPool   = cfgEnetReceiveQueueLength;
    _prdFirst  = prd;
    _prdRead   = prd;
    _prdWrite  = prd;
    _prdLast   = prd + cfgEnetReceiveQueueLength - 1;

    SetInitFlag(INITF_NIC|INITF_CONNECTED_BOOT);

    return(NETERR_OK);
}

INT CXnNic::NicVLanAttach()
{
    if (!_fVLanInit)
    {
        if (!VLanInit())
        {
            TraceSz(Warning, "NicVLanAttach: VLanInit failed");
            return(WSASYSCALLFAILURE);
        }

        _fVLanInit = TRUE;
    }

    Assert(!_fVLanAttach);

    if (!VLanAttach(_achXbox, _ea._ab, this))
    {
        TraceSz1(Warning, "NicVLanAttach: VLanAttach '%s' failed", _achXbox);
        return(WSASYSCALLFAILURE);
    }

    _fVLanAttach = TRUE;

    return(0);
}

void CXnNic::NicVLanDetach(BOOL fTerm)
{
    if (_fVLanAttach)
    {
        VLanDetach(_ea._ab);
        _fVLanAttach = FALSE;
    }

    if (fTerm && _fVLanInit)
    {
        VLanTerm();
        _fVLanInit = FALSE;
    }
}

INT CXnNic::NicConfig(const XNetConfigParams * pxncp)
{
    return(NicVLanAttach());
}

void CXnNic::NicStart()
{
    ICHECK(NIC, USER);

    BaseStart();

    Assert(!TestInitFlag(INITF_NIC_STOP));

    SetInterrupts(TRUE);
}

void CXnNic::NicFlush()
{
    if (!TestInitFlag(INITF_NIC) || TestInitFlag(INITF_NIC_STOP))
        return;

    // Wait up to half a second for packets queued for transmit to go

    EnetPush();

    for (UINT cTimeout = 500; cTimeout > 0; --cTimeout)
    {
        XmitPush();

        if (_pqXmit.IsEmpty())
            break;

        Sleep(1);
    }
}

void CXnNic::NicStop()
{
    TCHECK(UDPC);

    if (TestInitFlag(INITF_NIC) && !TestInitFlag(INITF_NIC_STOP))
    {
        SetInterrupts(FALSE);
        KeLowerIrql(PASSIVE_LEVEL);
        NicVLanDetach(FALSE);
        KeRaiseIrqlToDpcLevel();
        SetInitFlag(INITF_NIC_STOP);
    }

    BaseStop();
}

void CXnNic::NicTerm()
{
    TCHECK(UDPC);

    NicStop();

    SetInitFlag(INITF_NIC_TERM);

    NicVLanDetach(TRUE);

    if (TestInitFlag(INITF_NIC_1))
    {
        Assert(_dpcRecv.DpcListEntry.Flink == NULL);

        while (_cxdBusy > 0)
        {
            Assert((UINT)_pqXmit.Count() == (UINT)_cxdBusy);
            TraceSz1(Warning, "Nic shutdown with %d packet(s) queued for transmit", _cxdBusy);
            _pqXmit.Discard(this);
        }

        if (_prdFirst)
        {
            SysFree(_prdFirst);
        }
    }

    BaseTerm();
}

BOOL CXnNic::NicXmitReady()
{
    ICHECK(NIC, UDPC|SDPC);

    BOOL fReady = (_cxdBusy < _cxdPool);

    if (!fReady)
    {
        _fXmitFull = TRUE;
    }

    return(fReady);
}

void CXnNic::NicXmit(CPacket * ppkt)
{
    ICHECK(NIC, UDPC|SDPC);

    Assert(_cxdBusy < _cxdPool);
    Assert(ppkt->GetCb() <= ENET_DATA_MAXSIZE);

    _pqXmit.InsertTail(ppkt);
    _cxdBusy += 1;

    XmitPush();
}

// ---------------------------------------------------------------------------------------
// CXnNic - Internal
// ---------------------------------------------------------------------------------------

void CXnNic::XmitPush()
{
    ICHECK(NIC, UDPC|SDPC);

    if (!_fIntr)
    {
        TraceSz(Warning, "CXnNic::XmitPush - Interrupts are disabled");
        return;
    }

    while (_cxdBusy > 0)
    {
        CPacket * ppkt = _pqXmit.GetHead();

        if (!VLanXmit((BYTE *)ppkt->GetEnetHdr(), sizeof(CEnetHdr) + ppkt->GetCb()))
        {
            TraceSz(Warning, "CXnNic::XmitPush - VLanXmit failed");
        }

        _pqXmit.RemoveHead();
        _cxdBusy -= 1;
        ppkt->Complete(this);
    }

    if (_fXmitFull && _cxdBusy < _cxdPool)
    {
        _fXmitFull = FALSE;
        EnetPush();
    }
}

void CXnNic::NicRecvFrame(void * pv, DWORD cbDat)
{
    ICHECK(NIC, USER|UDPC|SDPC);

    Assert(cbDat >= sizeof(CEnetHdr));
    Assert(cbDat <= sizeof(CEnetHdr) + ENET_DATA_MAXSIZE);

    if (_crdBusy == _crdPool)
    {
        TraceSz(Warning, "CXnNic::NicRecvFrame - Receive queue is full");
    }
    else if (cbDat <  sizeof(CEnetHdr) || cbDat > sizeof(CIeeeHdr) + ENET_DATA_MAXSIZE)
    {
        TraceSz1(Warning, "CXnNic::NicRecvFrame - Invalid frame size (%ld bytes)", cbDat);
    }
    else
    {
        HalEnterDpc();

        if (_fIntr)
        {
            RecvDesc * prd = _prdWrite;
            _prdWrite = NextPrd(prd);
            prd->cbDat = cbDat;
            memcpy(prd->rgbBuf, pv, cbDat);
            _crdBusy += 1;

            KeInsertQueueDpc(&_dpcRecv, NULL, NULL);
        }

        HalLeaveDpc();
    }
}

void CXnNic::RecvPush()
{
    ICHECK(NIC, UDPC|SDPC);

    if (!_fIntr)
    {
        TraceSz(Warning, "CXnNic::RecvPush - Interrupts are disabled");
        return;
    }

    while (_crdBusy > 0)
    {
        CPacket     pkt;
        RecvDesc *  prd      = _prdRead;
        void *      pv       = prd->rgbBuf;
        UINT        cb       = prd->cbDat;
        CEnetHdr *  pEnetHdr = (CEnetHdr *)pv;
        UINT        uiFlags  = PKTF_TYPE_ENET;
        UINT        uiType   = pEnetHdr->_wType;

        PushPktRecvTags(pEnetHdr->_eaDst.IsBroadcast());

        if (NTOHS((WORD)uiType) <= ENET_DATA_MAXSIZE)
        {
            CIeeeHdr * pIeeeHdr = (CIeeeHdr *)pEnetHdr;
            BYTE abEnetHdr[sizeof(CEnetAddr) * 2];

            if (!pIeeeHdr->IsEnetFrame())
            {
                TraceSz(pktRecv, "[DISCARD] IEEE frame type not supported");
                goto nextframe;
            }

            // Convert the link header into a standard CEnetHdr

            uiType = pIeeeHdr->_wTypeIeee;
            pv     = (BYTE *)pv + (sizeof(CIeeeHdr) - sizeof(CEnetHdr));
            cb    -= (sizeof(CIeeeHdr) - sizeof(CEnetHdr));

            memcpy(abEnetHdr, pIeeeHdr, sizeof(abEnetHdr));
            memcpy(pv, abEnetHdr, sizeof(abEnetHdr));

            pEnetHdr = (CEnetHdr *)pv;
            pEnetHdr->_wType = (WORD)uiType;
        }

        pv  = (BYTE *)pv + sizeof(CEnetHdr);
        cb -= sizeof(CEnetHdr);

        TraceSz4(pktRecv, "[ENET %s %s %04X][%d]",
                 pEnetHdr->_eaDst.Str(), pEnetHdr->_eaSrc.Str(), NTOHS((WORD)uiType), cb);

        if (pEnetHdr->_eaDst.IsBroadcast())
        {
            uiFlags |= PKTF_RECV_BROADCAST;
        }
        else if (!pEnetHdr->_eaDst.IsEqual(_ea))
        {
            TraceSz(pktWarn, "[DISCARD] Frame should not have been accepted by Nic hardware");
            goto nextframe;
        }

#ifdef XNET_FEATURE_VMEM
        if (VMemIsEnabled())
        {
            void * pvNew = VMemAlloc(cb + sizeof(CEnetHdr));
            Assert(pvNew != NULL);
            memcpy(pvNew, (BYTE *)pv - sizeof(CEnetHdr), cb + sizeof(CEnetHdr));
            pv = (BYTE *)pvNew + sizeof(CEnetHdr);
        }
#endif

        pkt.Init(uiFlags, pv, cb, NULL);
        EnetRecv(&pkt, uiType);

#ifdef XNET_FEATURE_VMEM

        if (VMemIsEnabled())
        {
            VMemFree((BYTE *)pv - sizeof(CEnetHdr));
        }

#endif

    nextframe:
        
        _prdRead  = NextPrd(prd);
        _crdBusy -= 1;

        PopPktRecvTags();
    }
}

void CXnNic::DpcCallback(PRKDPC, void * pthis, void *, void *)
{
    ((CXnNic *)pthis)->RecvPush();
}

void CXnNic::SetInterrupts(BOOL fEnable)
{
    ICHECK(NIC, USER|UDPC|SDPC);

    RaiseToDpc();

    if (!!fEnable != !!_fIntr)
    {
        _fIntr = fEnable;

        if (fEnable)
        {   
            if (_crdBusy > 0)
            {
                KeInsertQueueDpc(&_dpcRecv, NULL, NULL);
            }
        }
        else
        {
            KeRemoveQueueDpc(&_dpcRecv);
        }
    }
}

CXnNic::RecvDesc * CXnNic::NextPrd(RecvDesc * prd)
{
    TCHECK(USER|UDPC|SDPC);
    return((prd == _prdLast) ? _prdFirst : prd + 1);
}

// ---------------------------------------------------------------------------------------
// VLanRecv
// ---------------------------------------------------------------------------------------

void WINAPI VLanRecv(BYTE * pb, UINT cb, void * pvArg)
{
    ((CXnNic *)pvArg)->NicRecvFrame(pb, cb);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\sock.cpp ===
// ---------------------------------------------------------------------------------------
// sock.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

#pragma warning(disable:4102)

// ---------------------------------------------------------------------------------------
// Trace tags
// ---------------------------------------------------------------------------------------

DefineTag(sock,     0);
DefineTag(sockWarn, TAG_ENABLE);

// ---------------------------------------------------------------------------------------
// socket
// ---------------------------------------------------------------------------------------

SOCKET CXnSock::socket(IN int af, IN int type, IN int protocol)
{
    WinsockApiProlog_(socket, INVALID_SOCKET);

    ICHECK(SOCK, USER);

    CSocket * pSocket;

    if (af != 0 && af != AF_INET)
        err = WSAEAFNOSUPPORT;
    else if (type != 0 && type != SOCK_STREAM && type != SOCK_DGRAM)
        err = WSAESOCKTNOSUPPORT;
    else if (protocol != 0 && protocol != IPPROTO_TCP && protocol != IPPROTO_UDP)
        err = WSAEPROTONOSUPPORT;
    else
    {
        if (type == 0)
            type = (protocol == IPPROTO_UDP) ? SOCK_DGRAM : SOCK_STREAM;
        if (protocol == 0)
            protocol = (type == SOCK_DGRAM) ? IPPROTO_UDP : IPPROTO_TCP;
        if ((type == SOCK_STREAM) != (protocol == IPPROTO_TCP))
            err = WSAEPROTONOSUPPORT;
    }

    WinsockApiCheckError_(INVALID_SOCKET);

    pSocket = SockAlloc(type == SOCK_STREAM, FALSE);

    if (pSocket == NULL)
    {
        WinsockApiReturnError_(WSAENOBUFS, INVALID_SOCKET);
    }

    RaiseToDpc();
    pSocket->SetFlags(SOCKF_OWNED);
    pSocket->Enqueue(&_leSockets);

    return((SOCKET)pSocket);
}

CSocket * CXnSock::SockAlloc(BOOL fTcp, BOOL fPoolAlloc)
{
    ICHECK(SOCK, USER|UDPC|SDPC);

    CSocket *   pSocket;
    UINT        cb  = fTcp ? sizeof(CTcpSocket) : sizeof(CSocket);
    ULONG       tag = fTcp ? PTAG_CTcpSocket : PTAG_CSocket;

    if (_cSockets >= cfgSockMaxSockets)
    {
        TraceSz(Warning, "Too many sockets");
        return NULL;
    }

    if (fPoolAlloc)
        pSocket = (CSocket *)PoolAllocZ(cb, tag);
    else
        pSocket = (CSocket *)SysAllocZ(cb, tag);

    if (pSocket)
    {
        pSocket->Init(this, fTcp, fPoolAlloc);

        if (fTcp)
        {
            ((CTcpSocket *)pSocket)->TcpInit(this);
        }

        InterlockedIncrement((LONG *)&_cSockets);
    }

    return(pSocket);
}

// ---------------------------------------------------------------------------------------
// closesocket
// ---------------------------------------------------------------------------------------

int CXnSock::closesocket(IN SOCKET s)
{
    WinsockApiPrologSockLock_(closesocket, SOCKET_ERROR);

    RaiseToDpc();

    if (pSocket == NULL)
        err = NETERR_PARAM;
    else if (pSocket->TestFlags(SOCKF_CLOSED))
    {
        SockFree(pSocket);
        err = 0;
    }
    else
    {
        pSocket->ClearFlags(SOCKF_OWNED);
        err = SockClose(pSocket, FALSE);
    }

    MapNtStatusToWinsockError_(err);

    // Don't call SockUnlock here because the socket is most likely deallocated by now

    WinsockApiCheckError_(SOCKET_ERROR);
    return NO_ERROR;
}

NTSTATUS CXnSock::SockClose(CSocket * pSocket, BOOL fForce)
{
    RaiseToDpc();

    // If a TCP is being gracefully closed, then we'll
    // leave the the CSocket structure in the global list
    // until the connection is really gone.
    if (pSocket->IsTcp() && !TcpClose((CTcpSocket *)pSocket, fForce))
    {
        pSocket->SetFlags(SOCKF_NOMORE_XMIT|SOCKF_NOMORE_RECV|SOCKF_LINGERING);
        pSocket->SetClosed();
        return(NETERR_OK);
    }

    pSocket->Dequeue();

    // Clean up the information associated with the CSocket
    SockCleanup(pSocket);

    Assert(!pSocket->IsTcp() || !((CTcpSocket *)pSocket)->GetTimer()->IsActive());

    EvtTerm(pSocket->GetEvent());

    InterlockedDecrement((LONG *)&_cSockets);

    if (pSocket->TestFlags(SOCKF_OWNED))
        pSocket->SetFlags(SOCKF_CLOSED);
    else
        SockFree(pSocket);

    return(NETERR_OK);
}

void CXnSock::SockFree(CSocket * pSocket)
{
    // Mark socket as closed even though we are freeing the memory just in case the
    // user tries to access it anyways.

    pSocket->SetClosed();

    if (pSocket->TestFlags(SOCKF_POOLALLOC))
        PoolFree(pSocket);
    else
        SysFree(pSocket);
}

void CXnSock::SockCleanup(CSocket * pSocket)
{
    ICHECK(SOCK, UDPC|SDPC);

    NTSTATUS status;

    status = NT_SUCCESS(pSocket->GetStatus()) ? NETERR_CANCELLED : pSocket->GetStatus();

    SockReqComplete(pSocket, pSocket->GetRecvReq(), status);
    SockReqComplete(pSocket, pSocket->GetSendReq(), status);

    // Flush receive buffers

    SockFlushRecvBuffers(pSocket);

    // Flush send buffers

    while (pSocket->HasSendBuf())
    {
        CSendBuf * pSendBuf = pSocket->DequeueSendBuf();
        SockReleaseSendBuf(pSendBuf);
    }

    pSocket->SetCbSendBuf(0);

    if (pSocket->_prte)
    {
        RouteRelease(pSocket->_prte);
        pSocket->_prte = NULL;
    }
}

void CXnSock::SockReleaseSendBuf(CSendBuf * pSendBuf)
{
    if (pSendBuf->Release() == 0)
        PacketFree(pSendBuf);
    else
        pSendBuf->SetPfn((PFNPKTFREE)PacketFree);
}

//
// Flush a socket's receive buffers
//
void CXnSock::SockFlushRecvBuffers(CSocket * pSocket)
{
    while (pSocket->HasRecvBuf())
    {
        PoolFree(pSocket->DequeueRecvBuf());
    }

    pSocket->SetCbRecvBuf(0);
}

// ---------------------------------------------------------------------------------------
// shutdown
// ---------------------------------------------------------------------------------------

int CXnSock::shutdown(IN SOCKET s, IN int how)
{
    DWORD dwFlags;
    WinsockApiPrologSockLock_(shutdown, SOCKET_ERROR);

    WinsockApiParamCheck_(
        how == SD_SEND ||
        how == SD_RECEIVE ||
        how == SD_BOTH);

    switch (how) {
    case SD_SEND:
        dwFlags = SOCKF_NOMORE_XMIT;
        break;

    case SD_RECEIVE:
        dwFlags = SOCKF_NOMORE_RECV;
        break;

    default:
        dwFlags = SOCKF_NOMORE_XMIT|SOCKF_NOMORE_RECV;
        break;
    }

    if (pSocket->IsUdp())
    {
        err = UdpShutdown(pSocket, dwFlags);
    }
    else
    {
        if (!pSocket->TestFlags(SOCKF_CONNECTED))
        {
            WinsockApiGotoExit_(WSAENOTCONN);
        }
        err = TcpShutdown((CTcpSocket*) pSocket, dwFlags, TRUE);
    }

    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// ioctlsocket
// ---------------------------------------------------------------------------------------

int CXnSock::ioctlsocket(SOCKET s, long cmd, u_long* argp)
{
    KIRQL irql;
    UINT bytesReady;

    WinsockApiPrologSockLock_(ioctlsocket, SOCKET_ERROR);
    WinsockApiParamCheck_(argp != NULL);

    switch (cmd) {
    case FIONBIO:
        pSocket->SetFlags((*argp) ? SOCKF_OPT_NONBLOCKING : 0, SOCKF_OPT_NONBLOCKING);
        break;

    case FIONREAD:
    {
        RaiseToDpc();

        if (pSocket->IsUdp())
        {
            // For UDP sockets, return the size of the first buffered datagram
            // NOTE: For compatibility with win2k behavior, if the first datagram
            // is 0-sized, we'll return 1.
            if (pSocket->IsUdpRecvBufEmpty())
            {
                bytesReady = 0;
            }
            else
            {
                bytesReady = ((CUdpRecvBuf *)pSocket->GetRecvBufFirst())->GetCbBuf();
                if (bytesReady == 0)
                    bytesReady = 1;
            }
        }
        else
        {
            // For TCP sockets, return the total number of bytes
            // available for reading.
            bytesReady = pSocket->GetCbRecvBuf();
        }
        *argp = bytesReady;
        break;
    }
    
    // case SIOCATMARK:
    default:
        WinsockApiGotoExit_(WSAENOPROTOOPT);
        break;
    }

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// setsockopt
// ---------------------------------------------------------------------------------------

int CXnSock::setsockopt(SOCKET s, int level, int optname, const char* optval, int optlen)
{
    INT val;
    WinsockApiPrologSockLock_(setsockopt, SOCKET_ERROR);
    WinsockApiParamCheck_(optval != NULL && optlen > 0);

    if (optlen < (INT) sizeof(INT))
        val = (UCHAR) *optval;
    else
        val = *((INT*) optval);

    switch (level)
    {
        case SOL_SOCKET:
        {
            RaiseToDpc();

            // NOTE: Some options may not be applicable to datagram sockets,
            // while others may not be applicable to stream sockets. But
            // we'll let apps set those options here anyway (to avoid extra
            // checking code). Downstream code just won't use those 

            switch (optname)
            {
                case SO_BROADCAST:
                    if (pSocket->IsTcp()) goto noopt;
                    pSocket->SetFlags(val ? SOCKF_OPT_BROADCAST : 0, SOCKF_OPT_BROADCAST);
                    break;

                case SO_DONTLINGER:
                    if (pSocket->IsUdp()) goto noopt;
                    ((CTcpSocket *)pSocket)->SetLingerOnOff(!val);
                    break;

                case SO_LINGER:
                    if (pSocket->IsUdp()) goto noopt;
                    WinsockApiParamCheck_(optlen >= sizeof(LINGER));
                    ((CTcpSocket *)pSocket)->SetLinger((LINGER *)optval);
                    break;

                case SO_REUSEADDR:
                    if (pSocket->TestFlags(SOCKF_OPT_REUSEADDR) && val != 0) goto inval;
                    pSocket->SetFlags(val? SOCKF_OPT_REUSEADDR : 0, SOCKF_OPT_REUSEADDR);
                    break;

                case SO_EXCLUSIVEADDRUSE:
                    if (pSocket->TestFlags(SOCKF_OPT_EXCLUSIVEADDR) && val != 0) goto inval;
                    pSocket->SetFlags(val ? SOCKF_OPT_EXCLUSIVEADDR : 0, SOCKF_OPT_EXCLUSIVEADDR);
                    break;

                case SO_RCVTIMEO:
                    // Timeout value is in milliseconds
                    WinsockApiParamCheck_(optlen >= sizeof(INT));
                    pSocket->_uiRecvTimeout = val;
                    break;

                case SO_SNDTIMEO:
                    // Timeout value is in milliseconds
                    WinsockApiParamCheck_(optlen >= sizeof(INT));
                    pSocket->_uiSendTimeout = val;
                    break;

                case SO_RCVBUF:
                    WinsockApiParamCheck_(optlen >= sizeof(INT));
                    err = SockUpdateBufferSize(pSocket, pSocket->_cbMaxSendBuf, val);
                    if (!NT_SUCCESS(err)) goto inval;
                    break;

                case SO_SNDBUF:
                    WinsockApiParamCheck_(optlen >= sizeof(INT));
                    err = SockUpdateBufferSize(pSocket, val, pSocket->_cbMaxRecvBuf);
                    if (!NT_SUCCESS(err)) goto inval;
                    break;

#ifdef XNET_FEATURE_ONLINE

                case SO_INSECURE:
                    if (optlen == sizeof(CXoBase *) && optval == (char *)IpGetXoBase())
                        pSocket->SetFlags(SOCKF_INSECURE);
                    break;

#endif

                default:
                    goto noopt;
            }
            break;
        }

        case IPPROTO_TCP:
        {
            if (pSocket->IsUdp()) goto noopt;

            switch (optname) {
            case TCP_NODELAY:
                pSocket->SetFlags(val ? SOCKF_OPT_NONAGLE : 0, SOCKF_OPT_NONAGLE);
                break;

            default:
                goto noopt;
            }
            break;
        }

        default:
            goto inval;
    }

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);

inval:
    err = WSAEINVAL;
    goto exit;

noopt:
    err = WSAENOPROTOOPT;
    goto exit;
}

NTSTATUS CXnSock::SockUpdateBufferSize(CSocket* pSocket, INT sendBufsize, INT recvBufsize)

/*++

Routine Description:

    Update the send and receive buffer sizes

Arguments:

    pSocket - Points to the CSocket structure
    sendBufsize, recvBufsize - 
        Specifies the new send and receive buffer sizes

Return Value:

    Status code

--*/

{
    ICHECK(SOCK, UDPC);

    NTSTATUS status;

    if (sendBufsize > (INT) cfgSockMaxSendBufsizeInK * 1024)
        sendBufsize = (INT) cfgSockMaxSendBufsizeInK * 1024;
    else if (sendBufsize <= 0) {
        // NOTE: we never set actual send buffer size to 0
        // because we don't support the no-buffering option.
        sendBufsize = 1;
    }

    if (recvBufsize > (INT) cfgSockMaxRecvBufsizeInK * 1024)
        recvBufsize = (INT) cfgSockMaxRecvBufsizeInK * 1024;
    else if (recvBufsize <= 0)
        recvBufsize = 0;

    status = NETERR_OK;

    if (pSocket->IsUdp())
    {
        // For datagram sockets, we'll just update the send and
        // receive buffers sizes. If the current buffers are bigger
        // than the specified limits, we'll leave the current data alone.
        pSocket->_cbMaxSendBuf = sendBufsize;
        pSocket->_cbMaxRecvBuf = recvBufsize;
    }
    else
    {
        CTcpSocket* pTcpSocket = (CTcpSocket*) pSocket;

        // Set the send buffer size. If the current send buffer size
        // is larger than the specified limit, leave the current data untouched.
        pTcpSocket->_cbMaxSendBuf = sendBufsize;
        
        // If the TCP socket is already connected,
        // don't allow the app to reduce the receive buffer size.
        if (!pTcpSocket->IsIdleState() && recvBufsize < (INT) pTcpSocket->_cbMaxRecvBuf)
        {
            status = NETERR_PARAM;
        }
        else
        {
            // NOTE: we don't update receive window to the connection peer
            // right away. The new window information will be sent
            // in the next outgoing ACK segment.
            pTcpSocket->_cbMaxRecvBuf = recvBufsize;
        }
    }

    // NOTE: If the send buffer has just opened up,
    // we don't check to see if there is any pending
    // overlapped send request that can be started.
    // Rather the overlapped send request will be started
    // by the normal process.

    return(status);
}

// ---------------------------------------------------------------------------------------
// getsockopt
// ---------------------------------------------------------------------------------------

int CXnSock::getsockopt(SOCKET s, int level, int optname, char * optval, int * optlen)
{
    INT val;
    WinsockApiPrologSockLock_(getsockopt, SOCKET_ERROR);

    WinsockApiParamCheck_(
        optval != NULL &&
        optlen != NULL &&
        *optlen > 0);

    memset(optval, 0, *optlen);

    switch (level) {
    case SOL_SOCKET:

        switch (optname) {
        case SO_BROADCAST:
            if (pSocket->IsTcp()) goto noopt;
            val = pSocket->TestFlags(SOCKF_OPT_BROADCAST);
            break;

        case SO_DONTLINGER:
            if (pSocket->IsUdp()) goto noopt;
            val = !((CTcpSocket *)pSocket)->GetLingerOnOff();
            break;

        case SO_LINGER:
            if (pSocket->IsUdp()) goto noopt;
            WinsockApiParamCheck_(*optlen >= sizeof(LINGER));
            ((CTcpSocket *)pSocket)->GetLinger((LINGER *)optval);
            *optlen = sizeof(LINGER);
            goto exit;

        case SO_REUSEADDR:
            val = pSocket->TestFlags(SOCKF_OPT_REUSEADDR);
            break;

        case SO_EXCLUSIVEADDRUSE:
            val = pSocket->TestFlags(SOCKF_OPT_EXCLUSIVEADDR);
            break;

        case SO_RCVTIMEO:
            WinsockApiParamCheck_(*optlen >= sizeof(INT));
            val = pSocket->_uiRecvTimeout;
            break;

        case SO_SNDTIMEO:
            WinsockApiParamCheck_(*optlen >= sizeof(INT));
            val = pSocket->_uiSendTimeout;
            break;

        case SO_RCVBUF:
            WinsockApiParamCheck_(*optlen >= sizeof(INT));
            val = pSocket->_cbMaxRecvBuf;
            break;

        case SO_SNDBUF:
            WinsockApiParamCheck_(*optlen >= sizeof(INT));
            val = pSocket->_cbMaxSendBuf;
            break;

        case SO_TYPE:
            val = pSocket->IsUdp() ? SOCK_DGRAM : SOCK_STREAM;
            break;

        case SO_ACCEPTCONN:
            if (pSocket->IsUdp()) goto noopt;
            val = ((CTcpSocket *)pSocket)->IsListenState();
            break;

        default:
            goto noopt;
        }
        break;

    case IPPROTO_TCP:
        if (pSocket->IsUdp())
            goto noopt;

        switch (optname) {
        case TCP_NODELAY:
            val = pSocket->TestFlags(SOCKF_OPT_NONAGLE);
            break;

        default:
            goto noopt;
        }
        break;

    default:
        err = WSAEINVAL;
        goto exit;
    }

    if (*optlen < sizeof(INT)) {
        *optval = (CHAR) val;
        *optlen = 1;
    } else {
        *((INT*) optval) = val;
        *optlen = sizeof(INT);
    }

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);

noopt:
    err = WSAENOPROTOOPT;
    goto exit;
}

// ---------------------------------------------------------------------------------------
// getsockname
// ---------------------------------------------------------------------------------------

int CXnSock::getsockname(SOCKET s, struct sockaddr* name, int* namelen)
{
    struct sockaddr_in* sin;
    WinsockApiPrologSockLock_(getsockname, SOCKET_ERROR);

    WinsockApiParamCheck_(
        name != NULL &&
        namelen != NULL &&
        *namelen >= SOCKADDRLEN);

    if (!pSocket->TestFlags(SOCKF_BOUND))
    {
        WinsockApiGotoExit_(WSAEINVAL);
    }

    sin = (struct sockaddr_in*) name;
    memset(sin, 0, SOCKADDRLEN);
    sin->sin_family = AF_INET;
    sin->sin_port = pSocket->_ipportSrc;
    sin->sin_addr.s_addr = 0;

    *namelen = SOCKADDRLEN;
    err = NO_ERROR;

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// getpeername
// ---------------------------------------------------------------------------------------

int CXnSock::getpeername(SOCKET s, struct sockaddr * name, int * namelen)
{
    struct sockaddr_in* sin;
    WinsockApiPrologSockLock_(getpeername, SOCKET_ERROR);

    WinsockApiParamCheck_(
        name != NULL &&
        namelen != NULL &&
        *namelen >= SOCKADDRLEN);

    if (!pSocket->TestFlags(SOCKF_CONNECTED)) {
        WinsockApiGotoExit_(WSAENOTCONN);
    }

    sin = (struct sockaddr_in*) name;
    sin->sin_family = AF_INET;
    sin->sin_port = pSocket->_ipportDst;
    sin->sin_addr.s_addr = pSocket->_ipaDst;
    memset(sin->sin_zero, 0, sizeof(sin->sin_zero));

    *namelen = SOCKADDRLEN;
    err = NO_ERROR;

    SecRegSetOwned(sin->sin_addr.s_addr);

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// bind
// ---------------------------------------------------------------------------------------

int CXnSock::bind(SOCKET s, const struct sockaddr * name, int namelen)
{
    const struct sockaddr_in* sin = (const struct sockaddr_in*) name;
    WinsockApiPrologSockLock_(bind, SOCKET_ERROR);

    WinsockApiParamCheck_(
        name != NULL &&
        namelen >= SOCKADDRLEN &&
        sin->sin_family == AF_INET &&
        sin->sin_addr.s_addr == 0);

    if (pSocket->TestFlags(SOCKF_BOUND))
    {
        WinsockApiGotoExit_(WSAEINVAL);
    }

    if (sin->sin_addr.s_addr != 0)
    {
        WinsockApiGotoExit_(WSAEADDRNOTAVAIL);
    }

    err = SockBind(pSocket, sin->sin_port);

    MapNtStatusToWinsockError_(err);

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

NTSTATUS CXnSock::SockBind(CSocket * pSocket, CIpPort ipportBind)

/*++

Routine Description:

    Bind a socket to the specified local address

Arguments:

    pSocket - Points to the protocol control block
    srcaddr, srcport - Specifies the local socket address

Return Value:

    Status code

--*/

{
    int cRetry = ipportBind ? 0 : min(cfgSockMaxSockets, TEMP_PORT_COUNT);
    CSocket * pSocketCur;

    RaiseToDpc();

    Assert(!pSocket->TestFlags(SOCKF_BOUND));

    while (1)
    {
        if (cRetry-- > 0)
        {
            while (1)
            {
                _ipportTempNext += 1;

                if (_ipportTempNext > MAX_TEMP_PORT)
                    _ipportTempNext = MIN_TEMP_PORT;

                if (_ipportTempNext != NTOHS(ESPUDP_CLIENT_PORT))
                    break;
            }

            ipportBind = HTONS((WORD)_ipportTempNext);
        }

        for (pSocketCur = GetFirstSocket(); pSocketCur; pSocketCur = GetNextSocket(pSocketCur))
        {
            if (pSocketCur->TestFlags(SOCKF_BOUND))
            {
                Assert(pSocketCur != pSocket);

                if (    (pSocketCur->IsUdp() == pSocket->IsUdp())
                    &&  (pSocketCur->_ipportSrc == ipportBind)
                    &&  (   pSocketCur->TestFlags(SOCKF_OPT_EXCLUSIVEADDR)
                        ||  pSocket->TestFlags(SOCKF_OPT_EXCLUSIVEADDR)
                        || !pSocket->TestFlags(SOCKF_OPT_REUSEADDR)))
                {
                    break;
                }
            }
        }

        if (pSocketCur == NULL)
        {
            pSocket->_ipportSrc = ipportBind;
            pSocket->SetFlags(SOCKF_BOUND);
            return(NETERR_OK);
        }

        if (cRetry <= 0)
        {
            return(NETERR_ADDRINUSE);
        }
    }
}

// ---------------------------------------------------------------------------------------
// connect
// ---------------------------------------------------------------------------------------

int CXnSock::connect(SOCKET s, const struct sockaddr * name, int namelen)
{
    const struct sockaddr_in* sin = (const struct sockaddr_in*) name;
    CIpAddr dstaddr;
    CIpPort dstport;
    WinsockApiPrologSockLock_(connect, SOCKET_ERROR);

    WinsockApiParamCheck_(
        name != NULL &&
        namelen >= SOCKADDRLEN &&
        sin->sin_family == AF_INET);

    if (pSocket->TestFlags(SOCKF_CONNECTED) && pSocket->IsTcp()) {
        WinsockApiGotoExit_(WSAEISCONN);
    }

    dstaddr = sin->sin_addr.s_addr;
    dstport = sin->sin_port;
    if (pSocket->IsUdp())
    {
        err = UdpConnect(pSocket, dstaddr, dstport);
    }
    else if (pSocket->TestFlags(SOCKF_OPT_NONBLOCKING))
    {
        err = TcpConnect((CTcpSocket*) pSocket, dstaddr, dstport, FALSE);

        // For nonblocking socket, we'll return WSAEWOULDBLOCK
        // error code but the operation proceeds.
        if (NT_SUCCESS(err)) err = NETERR_WOULDBLOCK;
    }
    else
    {
        err = TcpConnect((CTcpSocket*) pSocket, dstaddr, dstport, FALSE);
        if (NT_SUCCESS(err))
        {
            // For blocking socket, we need to wait here for
            // the operation to complete.
            err = SockWaitForEvent(pSocket, SOCKF_EVENT_CONNECT, 0);
            pSocket->SetFlags(SOCKF_CONNECT_SELECTED);
        }
    }

    MapNtStatusToWinsockError_(err);

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// listen
// ---------------------------------------------------------------------------------------

int CXnSock::listen(SOCKET s, int backlog)
{
    WinsockApiPrologSockLock_(listen, SOCKET_ERROR);

    WinsockApiParamCheck_(pSocket->IsTcp());

    if (pSocket->TestFlags(SOCKF_CONNECTED))
    {
        WinsockApiGotoExit_(WSAEISCONN);
    }

    if (!pSocket->TestFlags(SOCKF_BOUND))
    {
        WinsockApiGotoExit_(WSAEINVAL);
    }

    err = TcpListen((CTcpSocket*) pSocket, backlog);
    MapNtStatusToWinsockError_(err);

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// accept
// ---------------------------------------------------------------------------------------

SOCKET CXnSock::accept(SOCKET s, struct sockaddr * addr, int * addrlen)
{
    CTcpSocket * pTcpSocketChild = NULL;

    WinsockApiPrologSockLock_(accept, INVALID_SOCKET);

    WinsockApiParamCheck_(
        pSocket->IsTcp() &&
        (addr == NULL ||
         addrlen != NULL && *addrlen >= SOCKADDRLEN));

    CTcpSocket * pTcpSocket = (CTcpSocket *)pSocket;

    if (!pTcpSocket->IsTcp() || !pTcpSocket->IsListenState())
    {
        WinsockApiGotoExit_(WSAEINVAL);
    }

    while (1)
    {
        {
            RaiseToDpc();
            pTcpSocketChild = pTcpSocket->DequeueConnectedChild();
        }

        if (pTcpSocketChild)
            break;

        // For nonblocking socket, return an error code
        // if we don't have any pending connection requests.

        if (pTcpSocket->TestFlags(SOCKF_OPT_NONBLOCKING))
        {
            WinsockApiGotoExit_(WSAEWOULDBLOCK);
        }

        // For blocking sockets, wait until there
        // is a connection request.

        err = SockWaitForEvent(pSocket, SOCKF_EVENT_ACCEPT, 0);

        if (err != 0)
            break;
    }

    MapNtStatusToWinsockError_(err);

    if (pTcpSocketChild)
    {
        pTcpSocketChild->SetFlags(SOCKF_OWNED);

        if (addr && addrlen)
        {
            struct sockaddr_in* sin;

            sin = (struct sockaddr_in*) addr;
            sin->sin_family = AF_INET;
            sin->sin_port = pTcpSocketChild->_ipportDst;
            sin->sin_addr.s_addr = pTcpSocketChild->_ipaDst;
            memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
            *addrlen = SOCKADDRLEN;

            SecRegSetOwned(pTcpSocketChild->_ipaDst);
        }
    }

    WinsockApiExitSockUnlock_((SOCKET) pTcpSocketChild, INVALID_SOCKET);
}

// ---------------------------------------------------------------------------------------
// select
// ---------------------------------------------------------------------------------------

//
// Count the total number of socket handles
//
#define SOCKETS_IN_SET(_set) ((_set) ? ((_set)->fd_count & 0xffff) : 0)

//
// Select event masks
//
#define SELECT_READ_EVENTS (SOCKF_EVENT_READ|SOCKF_EVENT_ACCEPT|SOCKF_EVENT_CLOSE|SOCKF_EVENT_RESET)
#define SELECT_WRITE_EVENTS (SOCKF_EVENT_WRITE|SOCKF_EVENT_CONNECT)
#define SELECT_EXCEPT_EVENTS (SOCKF_EVENT_RESET)

//
// Number of KWAIT_BLOCKs allocated on the stack for select() calls.
//
#define SELECT_STACK_KWAIT_BLOCKS 3

int CXnSock::select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, const struct timeval* timeout)
{
    SELECTINFO tempinfo;
    PRKEVENT tempevent;
    SELECTINFO* selinfo;
    PRKEVENT* events;
    INT index, rdcnt, rwcnt, selcnt = 0;
    CSocket* pSocket;
    LARGE_INTEGER waittime;
    LARGE_INTEGER* pwait;
#ifdef XNET_FEATURE_XBOX
    KWAIT_BLOCK tempWaitBlocks[SELECT_STACK_KWAIT_BLOCKS];
    PKWAIT_BLOCK waitBlockArray = tempWaitBlocks;
#endif

    WinsockApiProlog_(select, SOCKET_ERROR);

    // Count the total number of sockets
    // (ignore the input nfds parameter)
    rdcnt = SOCKETS_IN_SET(readfds);
    rwcnt = rdcnt + SOCKETS_IN_SET(writefds);
    nfds = rwcnt + SOCKETS_IN_SET(exceptfds);

    if (nfds == 0) {
        WinsockApiReturnError_(WSAEINVAL, SOCKET_ERROR);
    }

    if (nfds == 1) {
        // Use temporary stack buffers for the special case
        // where there is only one socket. This saves us from
        // two extra memory allocations.
        events = &tempevent;
        selinfo = &tempinfo;
        memset(selinfo, 0, sizeof(SELECTINFO));
    } else {
        selinfo = (SELECTINFO*) SysAllocZ(nfds*sizeof(SELECTINFO), PTAG_select);
        events = (PRKEVENT*) SysAlloc(nfds*sizeof(PRKEVENT), PTAG_select);
        if (!selinfo || !events) {
            nfds = 0;
            WinsockApiGotoExit_(WSAENOBUFS);
        }
    }

    // Lock all the socket handles
    if ((err = SockLockSelectSockets(readfds, selinfo, 0, SELECT_READ_EVENTS)) != 0 ||
        (err = SockLockSelectSockets(writefds, selinfo, rdcnt, SELECT_WRITE_EVENTS)) != 0 ||
        (err = SockLockSelectSockets(exceptfds, selinfo, rwcnt, SELECT_EXCEPT_EVENTS)) != 0) {
        goto exit;
    }

    // Compute the wait time in 100ns unit
    if (timeout) {
        pwait = &waittime;
#ifdef XNET_FEATURE_XBOX
        waittime.QuadPart = Int32x32To64(timeout->tv_sec, -10000000) +
                            Int32x32To64(timeout->tv_usec, -10);
#else
        waittime.QuadPart = timeout->tv_sec * 1000 + timeout->tv_usec / 1000;
#endif
    } else {
        pwait = NULL;
    }

    // Check if we to wait:
    // if we do, set up the socket event flags
    if (!pwait || pwait->QuadPart) {
        INT waitCount = 0;
        for (index=0; index < nfds; index++) {
            pSocket = selinfo[index].pSocket;
            if (selinfo[index].pSocketMasks) {
                if (SockCheckSelectEvents(pSocket, selinfo[index].pSocketMasks, -1)) break;
                events[waitCount++] = pSocket->GetEvent();
            }
        }

        if (index == nfds) {

#ifdef XNET_FEATURE_XBOX
            if (waitCount > SELECT_STACK_KWAIT_BLOCKS) {
                waitBlockArray = (PKWAIT_BLOCK) SysAllocZ(waitCount * sizeof(KWAIT_BLOCK), PTAG_select);
                if (!waitBlockArray) {
                    WinsockApiGotoExit_(WSAENOBUFS);
                }
            }

#ifdef XNET_FEATURE_XBDM_SERVER

            do {
                err = KeWaitForMultipleObjects(
                            waitCount,
                            (void **)events,
                            WaitAny,
                            UserRequest,
                            KernelMode,
                            TRUE,
                            pwait,
                            waitBlockArray);
            } while(err == STATUS_KERNEL_APC);

            if(err == STATUS_ALERTED)
                err = STATUS_TIMEOUT; 

#else

            err = KeWaitForMultipleObjects(
                        waitCount,
                        (void **)events,
                        WaitAny,
                        UserRequest,
                        UserMode,
                        FALSE,
                        pwait,
                        waitBlockArray);

#endif // XBDM

            if ((err < 0 || err >= waitCount) && err != STATUS_TIMEOUT) {
                WinsockApiGotoExit_(WSAEFAULT);
            }
#else
            err = WaitForMultipleObjects(waitCount, (HANDLE *)events, FALSE, (DWORD)waittime.QuadPart);
            if (err == WAIT_FAILED)
                WinsockApiGotoExit_(WSAEFAULT);
#endif
        }
    }

    // Determine which socket events are ready
    // and return appropriate information

    if (readfds) { FD_ZERO(readfds); }
    if (writefds) { FD_ZERO(writefds); }
    if (exceptfds) { FD_ZERO(exceptfds); }

    for (index=selcnt=0; index < nfds; index++)
    {
        if (SockCheckSelectEvents(selinfo[index].pSocket, selinfo[index].eventMasks, 0))
        {
            FD_SET(selinfo[index].s, selinfo[index].fdset);
            selcnt++;
        }
    }

    err = NO_ERROR;

exit:

    for (index=0; index < nfds; index++)
    {
        pSocket = selinfo[index].pSocket;

        if (pSocket && selinfo[index].pSocketMasks)
        {
            pSocket->ClearFlags(SOCKF_EVENT_MASK);
            pSocket->Unlock();
        }
    }

#ifdef XNET_FEATURE_XBOX
    if (waitBlockArray != tempWaitBlocks) { SysFree(waitBlockArray); }
#endif
    if (selinfo != &tempinfo) { SysFree(selinfo); }
    if (events != &tempevent) { SysFree(events); }

    WinsockApiCheckError_(SOCKET_ERROR);
    return selcnt;
}

INT CXnSock::SockLockSelectSockets(fd_set* fdset, SELECTINFO* selinfo, INT offset, INT eventMasks)

/*++

Routine Description:

    Lock the socket handles that was passed to the select API

Arguments:

    fdset - Points to the socket set
    selinfo - Points to an array of SELECTINFO structures
        for storing the locked socket information
    eventMasks - Specifies the interested events

Return Value:

    Winsock error code

--*/

{
    INT i, count;

    // Nothing to do if the set is empty
    count = SOCKETS_IN_SET(fdset);

    for (i=0; i < count; i++) {
        SOCKET s = fdset->fd_array[i];
        INT j, k = offset + i;

        selinfo[k].s = s;
        selinfo[k].fdset = fdset;
        selinfo[k].eventMasks = eventMasks;

        // Check to see if the socket is already used
        // in the same select call
        for (j=0; j < k && selinfo[j].s != s; j++)
            ;

        if (j == k) {
            //
            // The socket isn't seen already
            //
            selinfo[k].pSocketMasks = eventMasks;
            selinfo[k].pSocket = CSocket::Lock(s);
            if (!selinfo[k].pSocket)
                return GetLastError();
        } else {
            //
            // The socket is already seen
            //
            selinfo[j].pSocketMasks |= eventMasks;
            selinfo[k].pSocketMasks = 0;
            selinfo[k].pSocket = selinfo[j].pSocket;
        }
    }

    return NO_ERROR;
}

INT CXnSock::SockCheckSelectEvents(CSocket * pSocket, INT eventMasks, INT setwait)

/*++

Routine Description:

    Check if the specified socket events are available
    and optionally set up the socket to wait for them

Arguments:

    pSocket - Points to the protocol control block
    eventMasks - Specifies the socket events the caller is interested in
    setwait - Whether to set up the sockets to wait if 
        none of the specified events are avaiable

Return Value:

    Set of event flags that are already available

--*/

{
    NTSTATUS status;
    INT readyMasks;

    RaiseToDpc();

    // Check to see if the specified event is already available
    // Since our checks are trivial, it's faster to check
    // everything instead of trying to check selectively
    // based on the flags specified by the caller.
    
    if (pSocket->IsTcp())
    {
        CTcpSocket * pTcpSocket = (CTcpSocket *)pSocket;

        // If the connection was reset, return reset status
        status = pSocket->GetStatus();

        if (!NT_SUCCESS(status))
        {
            // Note: If we already told the app that the socket was connected
            // and then the socket got resetted, we don't need to set the socket
            // in the exceptfds again to tell the app the connection has failed.

            if (eventMasks != SOCKF_EVENT_RESET || !pSocket->TestFlags(SOCKF_CONNECT_SELECTED))
            {
                return(SOCKF_EVENT_RESET);
            }
        }

        readyMasks = (pTcpSocket->IsTcpRecvBufEmpty() ? 0 : SOCKF_EVENT_READ) |
                     (pTcpSocket->HasConnectedChild() ? SOCKF_EVENT_ACCEPT : 0) |
                     (pTcpSocket->IsFinReceived() ? SOCKF_EVENT_READ|SOCKF_EVENT_CLOSE : 0);

        if (pSocket->TestFlags(SOCKF_CONNECTED))
        {
            if (!pSocket->IsSendBufFull())
            {
                readyMasks |= SOCKF_EVENT_WRITE;
            }

            // NOTE: we only signal the connect event exactly once
            if ((eventMasks & SOCKF_EVENT_CONNECT) && !pSocket->TestFlags(SOCKF_CONNECT_SELECTED))
            {
                readyMasks |= SOCKF_EVENT_CONNECT;
                if (setwait >= 0)
                {
                    pSocket->SetFlags(SOCKF_CONNECT_SELECTED);
                }
            }
        }
    } else {
        readyMasks = (pSocket->IsUdpRecvBufEmpty() ? 0 : SOCKF_EVENT_READ) |
                     (pSocket->IsSendBufFull() ? 0 : SOCKF_EVENT_WRITE);
    }

    if ((readyMasks &= eventMasks) == 0 && setwait)
    {
        // Indicate that we're interested in the specified event
        // and prepare to wait
        pSocket->SetFlags(eventMasks, SOCKF_EVENT_MASK);
        EvtClear(pSocket->GetEvent());
    }

    return(readyMasks);
}

// ---------------------------------------------------------------------------------------
// WSAGetOverlappedResult
// ---------------------------------------------------------------------------------------

BOOL CXnSock::WSAGetOverlappedResult(SOCKET s, LPWSAOVERLAPPED overlapped, LPDWORD byteCount, BOOL fWait, LPDWORD flags)
{
    WinsockApiPrologSockLock_(WSAGetOverlappedResult, FALSE);

    WinsockApiParamCheck_(
        overlapped != NULL &&
        overlapped->hEvent != NULL &&
        byteCount != NULL &&
        flags != NULL);

    //
    // Check if we need to wait for the I/O request to complete
    //
    if (overlapped->_iostatus == NETERR_PENDING && fWait)
    {
        WaitForSingleObject(overlapped->hEvent, INFINITE);

        RaiseToDpc();

        if (overlapped->_iostatus == NETERR_PENDING)
        {
            err = overlapped->_ioxfercnt ? NETERR_OK : NETERR_CANCELLED;
            SockReqComplete(pSocket, (CSockReq *)overlapped->_ioreq, err);
        }
    }

    //
    // If the I/O request was completed,
    // return the completion status information
    //
    if ((err = overlapped->_iostatus) != NETERR_PENDING && NT_SUCCESS(err))
    {
        *byteCount = overlapped->_ioxfercnt;
        *flags = overlapped->_ioflags;
    }

    if (err == NETERR_PENDING)
    {
        WinsockApiGotoExit_(WSA_IO_INCOMPLETE);
    }
    else
    {
        MapNtStatusToWinsockError_(err);
    }
    
    WinsockApiExitSockUnlock_(TRUE, FALSE);
}

// ---------------------------------------------------------------------------------------
// WSACancelOverlappedIO
// ---------------------------------------------------------------------------------------

INT CXnSock::WSACancelOverlappedIO(SOCKET s)
{
    WinsockApiPrologSockLock_(WSACancelOverlappedIO, SOCKET_ERROR);

    {
        RaiseToDpc();
        SockReqComplete(pSocket, pSocket->GetRecvReq(), NETERR_CANCELLED);
        SockReqComplete(pSocket, pSocket->GetSendReq(), NETERR_CANCELLED);
    }

    WinsockApiGotoExit_(NO_ERROR);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// recv
// ---------------------------------------------------------------------------------------

int CXnSock::recv(SOCKET s, char* buf, int len, int flags)
{
    CRecvReq pRecvReq;
    DWORD count;
    WinsockApiPrologSockLock_(recv, SOCKET_ERROR);

    WinsockApiParamCheck_(
        (len > 0 && buf != NULL || len == 0) &&
        flags == 0);

    pRecvReq.buf = (BYTE*) buf;
    pRecvReq.buflen = len;
    pRecvReq.flags = flags;
    pRecvReq.bytesRecv = &count;
    pRecvReq.fromaddr = NULL;
    pRecvReq._pWsaOverlapped = NULL;

    err = SockRead(pSocket, &pRecvReq);

    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(count, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// WSARecv
// ---------------------------------------------------------------------------------------

//
// Verify buffers passed to WSARecv API
// NOTE: we do not support more than 1 receive buffers.
//
INLINE
BOOL CheckRecvWsaBuf(WSABUF* bufs, UINT bufcnt)
{
    return (bufcnt == 1 && bufs != NULL && (bufs->len > 0 && bufs->buf != NULL || bufs->len == 0));
}

int CXnSock::WSARecv(SOCKET s, LPWSABUF bufs, DWORD bufcnt, LPDWORD bytesRecv, LPDWORD flags,
                     LPWSAOVERLAPPED overlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc)
{
    CRecvReq pRecvReq;
    WinsockApiPrologSockLock_(WSARecv, SOCKET_ERROR);

    WinsockApiParamCheck_(
        CheckRecvWsaBuf(bufs, bufcnt) &&
        bytesRecv != NULL &&
        flags != NULL && *flags == 0 &&
        completionproc == NULL);

    pRecvReq.buf = (BYTE*) bufs->buf;
    pRecvReq.buflen = bufs->len;
    pRecvReq.flags = *flags;
    pRecvReq.bytesRecv = bytesRecv;
    pRecvReq.fromaddr = NULL;
    pRecvReq._pWsaOverlapped = overlapped;

    err = SockRead(pSocket, &pRecvReq);

    *flags = pRecvReq.flags;

    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// recvfrom
// ---------------------------------------------------------------------------------------

int CXnSock::recvfrom(SOCKET s, char FAR * buf, int len, int flags, struct sockaddr * from, int * fromlen)
{
    DWORD count;
    INT err;
    WSABUF wsabuf;

    WinsockApiPrologLight_(recvfrom);
    WinsockApiParamCheck_(
        (len > 0 && buf != NULL || len == 0) &&
        (from == NULL ||
         fromlen != NULL && *fromlen >= SOCKADDRLEN));

    wsabuf.len = len;
    wsabuf.buf = buf;
    err = WSARecvFrom(s, &wsabuf, 1, &count, (DWORD*) &flags, from, fromlen, NULL, NULL);
    return (err == NO_ERROR) ? count : SOCKET_ERROR;
}

// ---------------------------------------------------------------------------------------
// WSARecvFrom
// ---------------------------------------------------------------------------------------

int CXnSock::WSARecvFrom(SOCKET s, LPWSABUF bufs, DWORD bufcnt, LPDWORD bytesRecv, LPDWORD flags,
                         struct sockaddr * fromaddr, LPINT fromlen, LPWSAOVERLAPPED overlapped,
                         LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc)
{
    CRecvReq pRecvReq;
    WinsockApiPrologSockLock_(WSARecvFrom, SOCKET_ERROR);

    WinsockApiParamCheck_(
        CheckRecvWsaBuf(bufs, bufcnt) &&
        bytesRecv != NULL &&
        (fromaddr == NULL ||
         fromlen != NULL && *fromlen >= SOCKADDRLEN) &&
        flags != NULL && *flags == 0 &&
        completionproc == NULL);

    // Winsock documentation on this call is extremely confusing
    // regarding the correct behavior for connection-oriented sockets
    // Here I've taken the liberty to treat WSARecvFrom the same way
    // as WSARecv for such cases.
    if (pSocket->IsTcp()) {
        TraceSz(Verbose, "WSARecvFrom called on stream socket!");
    }

    pRecvReq.buf = (BYTE*) bufs->buf;
    pRecvReq.buflen = bufs->len;
    pRecvReq.flags = *flags;
    pRecvReq.bytesRecv = bytesRecv;
    pRecvReq._pWsaOverlapped = overlapped;
    pRecvReq.fromaddr = (struct sockaddr_in*) fromaddr;

    if (fromaddr) 
    {
        memset(fromaddr, 0, SOCKADDRLEN);
        *fromlen = SOCKADDRLEN;
        pRecvReq.fromaddr->sin_family = AF_INET;
    }

    err = SockRead(pSocket, &pRecvReq);
    *flags = pRecvReq.flags;
    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// SockRead
// ---------------------------------------------------------------------------------------

NTSTATUS CXnSock::SockRead(CSocket * pSocket, CRecvReq * pRecvReq)
{
    WSAOVERLAPPED * pWsaOverlapped;
    WSAOVERLAPPED   WsaOverlappedTemp;
    NTSTATUS        status;

    if (pSocket->IsTcp())
    {
        if (!pSocket->TestFlags(SOCKF_CONNECTED))
        {
            return NETERR(WSAENOTCONN);
        }
    }
    else
    {
        if (!pSocket->TestFlags(SOCKF_BOUND))
        {
            return NETERR(WSAEINVAL);
        }
    }

    if (pSocket->TestFlags(SOCKF_NOMORE_RECV))
    {
        return(!NT_SUCCESS(pSocket->GetStatus()) ? pSocket->GetStatus() : NETERR(WSAESHUTDOWN));
    }

    // Since all our sockets are overlapped, we don't
    // enforce the Win32 behavior that the input socket
    // must be a non-overlapped socket.

    pWsaOverlapped = pRecvReq->_pWsaOverlapped;

    if (pWsaOverlapped != NULL)
    {
        pRecvReq->_pEvent = EvtFromHandle(pWsaOverlapped->hEvent);

        if (pRecvReq->_pEvent == NULL)
        {
            return(NETERR(WSASYSCALLFAILURE));
        }
    }
    else
    {
        pRecvReq->_pEvent = NULL;
    }

    // Check if we have any buffered data waiting to be read

    if (pSocket->IsRecvBufEmpty())
    {
        if (pWsaOverlapped)
        {
            // Overlapped call.  This used to clear the event here, but that breaks if the caller
            // is using the same event for multiple sockets and/or online tasks.  So now we
            // let the caller reset the event themselves before making the overlapped call.
            // Normally they would use an auto-reset event anyways, so there is nothing for them to do.
        }
        else if (pSocket->TestFlags(SOCKF_OPT_NONBLOCKING))
        {
            // Nonoverlapped call and socket is nonblocking:
            // just return WOULDBLOCK error code.
            //
            // Note: For TCP socket, if FIN has been received
            // we should return success with bytesRecv set to 0.
            if (pSocket->IsUdp() || !((CTcpSocket *)pSocket)->IsFinReceived())
            {
                return(NETERR(WSAEWOULDBLOCK));
            }
        }
        else
        {
            // Blocking call - prepare to wait
            pRecvReq->_pWsaOverlapped = &WsaOverlappedTemp;
            pRecvReq->_pEvent = pSocket->GetEvent();
            EvtClear(pRecvReq->_pEvent);
        }
    }

    status = pSocket->IsUdp() ?
                UdpRead(pSocket, pRecvReq) :
                TcpRead((CTcpSocket *) pSocket, pRecvReq);

    if (status == NETERR_PENDING)
    {
        if (pWsaOverlapped == NULL)
        {
            // A blocking call is still in progress
            EvtWait(pRecvReq->_pEvent, pSocket->_uiRecvTimeout);

            if (WsaOverlappedTemp._iostatus == NETERR_PENDING)
            {
                RaiseToDpc();

                if (WsaOverlappedTemp._iostatus == NETERR_PENDING)
                {
                    // We can use pRecvReq directly here because
                    // blocking recv call is treated as a special case
                    // in SockQueueOverlappedRecv 
                    SockReqComplete(pSocket, pRecvReq, NETERR_TIMEOUT);
                }
            }

            *pRecvReq->bytesRecv = WsaOverlappedTemp._ioxfercnt;
            pRecvReq->flags = WsaOverlappedTemp._ioflags;
            status = WsaOverlappedTemp._iostatus;
        }
    }
    else
    {
        if (pWsaOverlapped)
        {
            // An overlapped call was completed immediately
            pWsaOverlapped->_ioflags = pRecvReq->flags;
            pWsaOverlapped->_ioxfercnt = *pRecvReq->bytesRecv;
            pWsaOverlapped->_iostatus = status;

            // It would seem to be a waste to signal the event here.
            // But that's win2k behavior.
            EvtSet(pRecvReq->_pEvent, 0);
            EvtDereference(pRecvReq->_pEvent);
        }
    }

    return(status);
}

NTSTATUS CXnSock::RecvReqEnqueue(CSocket * pSocket, CRecvReq * pRecvReq)
{
    ICHECK(SOCK, UDPC|SDPC);

    CRecvReq * pRecvReqNew;

    if (pSocket->HasRecvReq())
    {
        TraceSz2(sockWarn, "[%08lX:%s] Can only have one overlapped read at a time",
                 pSocket, pSocket->TypeStr());
        return(NETERR_WOULDBLOCK);
    }
    else if (!pRecvReq->_pEvent)
    {
        TraceSz2(sockWarn, "[%08lX:%s] Overlapped read on nonblocking socket must supply an event",
                pSocket, pSocket->TypeStr());
        return(NETERR_WOULDBLOCK);
    }

    if (pRecvReq->_pEvent == pSocket->GetEvent())
    {
        // If the wait event is our internal per-CSocket event,
        // then this is a special case for implementing the
        // blocking recv call.
        //
        // In this case, we avoid an allocation by directly
        // queuing up the RECVREQ structure that was passed
        // in from the caller (winsock layer). This works because
        // the caller will wait for the recv to complete after
        // this function returns.

        pRecvReqNew = pRecvReq;
    }
    else
    {
        pRecvReqNew = (CRecvReq *)SysAlloc(sizeof(CRecvReq), PTAG_CRecvReq);

        if (pRecvReqNew == NULL)
        {
            TraceSz2(sockWarn, "[%08lX:%s] Out of memory allocating overlapped read control block",
                     pSocket, pSocket->TypeStr());
            return(NETERR_MEMORY);
        }

        *pRecvReqNew = *pRecvReq;
    }

    pSocket->SetRecvReq(pRecvReqNew);

    pRecvReqNew->_pWsaOverlapped->_ioxfercnt = 0;
    pRecvReqNew->_pWsaOverlapped->_ioflags = 0;
    pRecvReqNew->_pWsaOverlapped->_ioreq = (UINT_PTR)pRecvReqNew;
    pRecvReqNew->_pWsaOverlapped->_iostatus = (DWORD)NETERR_PENDING;

    TraceSz3(sock, "[%08lX:%s] Enqueued overlapped read of %ld bytes",
             pSocket, pSocket->TypeStr(), pRecvReq->GetCbBuf());

    return(NETERR_PENDING);
}

// ---------------------------------------------------------------------------------------
// Forward Declarations
// ---------------------------------------------------------------------------------------

UINT SockCountSendTotal(WSABUF * bufs, UINT bufcnt);
BOOL SockCheckSendWsaBuf(WSABUF * bufs, UINT bufcnt);

// ---------------------------------------------------------------------------------------
// send
// ---------------------------------------------------------------------------------------

int CXnSock::send(SOCKET s, const char* buf, int len, int flags)
{
    WSABUF wsabuf;
    CSendReq SendReq;
    WinsockApiPrologSockLock_(send, SOCKET_ERROR);

    WinsockApiParamCheck_(
        (len > 0 && buf != NULL || len == 0) &&
        (flags  == 0));

    wsabuf.len = len;
    wsabuf.buf = (char*) buf;
    SendReq._pWsaOverlapped = NULL;
    SendReq.bufs = &wsabuf;
    SendReq.bufcnt = 1;
    SendReq.sendtotal = len;
    SendReq.toaddr = NULL;

    err = SockSend(pSocket, &SendReq);
    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(SendReq.sendtotal, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// WSASend
// ---------------------------------------------------------------------------------------

int CXnSock::WSASend(SOCKET s, LPWSABUF bufs, DWORD bufcnt, LPDWORD bytesSent, DWORD flags,
                     LPWSAOVERLAPPED overlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc)
{
    CSendReq SendReq;
    WinsockApiPrologSockLock_(WSASend, SOCKET_ERROR);

    WinsockApiParamCheck_(
        SockCheckSendWsaBuf(bufs, bufcnt) &&
        bytesSent != NULL &&
        flags == 0 &&
        completionproc == NULL);

    SendReq._pWsaOverlapped = overlapped;
    SendReq.bufs = bufs;
    SendReq.bufcnt = (WORD)bufcnt;
    SendReq.sendtotal = SockCountSendTotal(bufs, bufcnt);
    SendReq.toaddr = NULL;

    err = SockSend(pSocket, &SendReq);
    if (NT_SUCCESS(err)) *bytesSent = SendReq.sendtotal;
    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

BOOL SockCheckSendWsaBuf(WSABUF* bufs, UINT bufcnt)
{
    if (bufs == NULL || bufcnt == 0 || bufcnt > 0xFFFF)
        return FALSE;

    while (bufcnt--) {
        if (bufs->len && bufs->buf == NULL)
            return FALSE;
        bufs++;
    }
    return TRUE;
}

UINT SockCountSendTotal(WSABUF* bufs, UINT bufcnt)
{
    UINT total = 0;

    while (bufcnt--)
    {
        total += bufs->len;
        bufs++;
    }

    return(total);
}

// ---------------------------------------------------------------------------------------
// sendto
// ---------------------------------------------------------------------------------------

int CXnSock::sendto(SOCKET s, const char* buf, int len, int flags, const struct sockaddr* to, int tolen)
{
    DWORD count;
    INT err;
    WSABUF wsabuf;

    WinsockApiPrologLight_(sendto);
    WinsockApiParamCheck_(len > 0 && buf != NULL || len == 0);

    wsabuf.len = len;
    wsabuf.buf = (char*) buf;
    err = WSASendTo(s, &wsabuf, 1, &count, flags, to, tolen, NULL, NULL);
    return (err == NO_ERROR) ? count : SOCKET_ERROR;
}

// ---------------------------------------------------------------------------------------
// WSASendTo
// ---------------------------------------------------------------------------------------

int CXnSock::WSASendTo(SOCKET s, LPWSABUF bufs, DWORD bufcnt, LPDWORD bytesSent, DWORD flags,
                       const struct sockaddr* toaddr, int tolen, LPWSAOVERLAPPED overlapped,        
                       LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc)
{
    struct sockaddr_in* sin = (struct sockaddr_in*) toaddr;
    CSendReq SendReq;
    WinsockApiPrologSockLock_(WSASendTo, SOCKET_ERROR);

    WinsockApiParamCheck_(
        SockCheckSendWsaBuf(bufs, bufcnt) &&
        bytesSent != NULL &&
        flags == 0 &&
        (toaddr == NULL ||
         tolen >= SOCKADDRLEN && sin->sin_family == AF_INET) &&
        completionproc == NULL);

    SendReq._pWsaOverlapped = overlapped;
    SendReq.bufs = bufs;
    SendReq.bufcnt = (WORD)bufcnt;
    SendReq.sendtotal = SockCountSendTotal(bufs, bufcnt);

    if (pSocket->IsTcp() || toaddr == NULL)
    {
        // For TCP sockets, WSASendTo is equivalent to WSASend.
        // We simply ignore lpTo and iToLen parameters.
        //
        // Also, if toaddr parameter is NULL, we treat WSASendTo
        // the same way as WSASend.

        SendReq.toaddr = NULL;
    }
    else
    {
        CIpAddr ipaDst = sin->sin_addr.s_addr;

        // Must do this check because downstream code
        // doesn't expect the destination address to be 0.
        // Also, we consider sending to UDP port 0 an error.
        if (    ipaDst == 0
            ||  sin->sin_port == 0
            ||  ipaDst.IsMulticast()
            || (ipaDst.IsLoopback() && ipaDst != IPADDR_LOOPBACK))
        {
            WinsockApiGotoExit_(WSAEADDRNOTAVAIL);
        }

        // Is this socket allowed to send broadcast
        // datagrams on this socket?
        if (ipaDst.IsBroadcast() && !pSocket->TestFlags(SOCKF_OPT_BROADCAST))
        {
            WinsockApiGotoExit_(WSAEACCES);
        }

        // If the socket is not bound, bind it here
        if (!pSocket->TestFlags(SOCKF_BOUND))
        {
            err = SockBind(pSocket, 0);

            if (!NT_SUCCESS(err))
            {
                MapNtStatusToWinsockError_(err);
                goto exit;
            }
        }

        // Send to the new destination
        SendReq.toaddr = sin;
    }
        
    err = SockSend(pSocket, &SendReq);

    if (NT_SUCCESS(err))
    {
        *bytesSent = SendReq.sendtotal;
    }

    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// SockSend
// ---------------------------------------------------------------------------------------

NTSTATUS CXnSock::SockSend(CSocket* pSocket, CSendReq* pSendReq)

/*++

Routine Description:

    Internal function for sending out data from a socket

Arguments:

    pSocket - Points to the protocol control block
    pSendReq - Points to send user request information

Return Value:

    Status code

--*/

{
    WSAOVERLAPPED * pWsaOverlapped;
    NTSTATUS        status;

    if (!pSocket->TestFlags(SOCKF_CONNECTED) && !pSendReq->toaddr)
        return NETERR(WSAENOTCONN);

    if (pSocket->TestFlags(SOCKF_NOMORE_XMIT))
    {
        return(!NT_SUCCESS(pSocket->GetStatus()) ? pSocket->GetStatus() : NETERR(WSAESHUTDOWN));
    }

    pWsaOverlapped = pSendReq->_pWsaOverlapped;

    if (pWsaOverlapped != NULL)
    {
        pSendReq->_pEvent = EvtFromHandle(pWsaOverlapped->hEvent);

        if (pSendReq->_pEvent == NULL)
        {
            return(NETERR(WSASYSCALLFAILURE));
        }
    }

    // Check if we have room in the send buffer

    if (pSocket->IsSendBufFull())
    {
        if (pWsaOverlapped)
        {
            // Overlapped call.  This used to clear the event here, but that breaks if the caller
            // is using the same event for multiple sockets and/or online tasks.  So now we
            // let the caller reset the event themselves before making the overlapped call.
            // Normally they would use an auto-reset event anyways, so there is nothing for them to do.

            status = SockQueueOverlappedSend(pSocket, pSendReq);

            // The overlapped request was successfully queued up
            if (status == NETERR_PENDING)
                return(status);

            // The overlapped send request wasn't queued
            // because of an error.
            if (!NT_SUCCESS(status))
                goto exit;

            // The send buffer has opened up and
            // the overlapped send request wasn't queued.
        }
        else if (pSocket->TestFlags(SOCKF_OPT_NONBLOCKING) || pSocket->HasSendReq())
        {
            return(NETERR_WOULDBLOCK);
        }
        else
        {
            status = SockWaitForEvent(pSocket, SOCKF_EVENT_WRITE, pSocket->_uiSendTimeout);

            if (!NT_SUCCESS(status))
                return(status);
        }
    }

    status = pSocket->IsUdp() ?
                UdpSend(pSocket, pSendReq, 0) :
                TcpSend((CTcpSocket *) pSocket, pSendReq, 0);

exit:

    if (pWsaOverlapped)
    {
        // An overlapped call was completed immediately
        pWsaOverlapped->_ioflags = 0;
        pWsaOverlapped->_ioxfercnt = pSendReq->sendtotal;
        pWsaOverlapped->_iostatus = status;

        // It would seem to be a waste to signal the event here.
        // But that's win2k behavior.

        EvtSet(pSendReq->_pEvent, 0);
        EvtDereference(pSendReq->_pEvent);
    }

    return(status);
}

NTSTATUS CXnSock::SockQueueOverlappedSend(CSocket * pSocket, CSendReq * pSendReq)

/*++

Routine Description:

    Queue up an overlapped send request

Arguments:

    pSocket - Points to the protocol control block
    pSendReq - Points to the overlapped send request

Return Value:

    Status code:
        NETERR_PENDING - the request was successfully queued up
        NETERR_OK - if the send buffer has opened up and
            there is no need to queue up the request
        otherwise - the request was not queued up due to an error

--*/

{
    NTSTATUS status;

    RaiseToDpc();

    if (pSocket->HasSendReq())
    {
        // We only support 1 outstanding overlapped send request.
        status = NETERR_WOULDBLOCK;
    }
    else if (!pSocket->IsSendBufFull())
    {
        // The send buffer opened up just as
        // we were raising to DPC level
        status = NETERR_OK;
    }
    else
    {
        CSendReq* newreq;
        UINT size = sizeof(CSendReq) +
                    (pSendReq->toaddr ? sizeof(*pSendReq->toaddr) : 0) +
                    sizeof(WSABUF) * pSendReq->bufcnt;

        newreq = (CSendReq*) SysAlloc(size, PTAG_CXmitReq);
        if (!newreq)
        {
            // Out of memory
            status = NETERR_MEMORY;
        }
        else
        {
            VOID* bufs;

            pSocket->SetSendReq(newreq);
            *newreq = *pSendReq;
            bufs = newreq+1;
            if (pSendReq->toaddr) {
                newreq->toaddr = (struct sockaddr_in*) bufs;
                *newreq->toaddr = *pSendReq->toaddr;
                bufs = newreq->toaddr + 1;
            }

            newreq->bufs = (WSABUF*) bufs;
            memcpy(bufs, pSendReq->bufs, sizeof(WSABUF) * pSendReq->bufcnt);

            newreq->_pWsaOverlapped->_ioxfercnt = 0;
            newreq->_pWsaOverlapped->_ioflags = 0;
            newreq->_pWsaOverlapped->_ioreq = (UINT_PTR) newreq;
            newreq->_pWsaOverlapped->_iostatus = status = NETERR_PENDING;
        }
    }

    return(status);
}

// ---------------------------------------------------------------------------------------
// inet_addr
// ---------------------------------------------------------------------------------------

ULONG _WSAAPI_ inet_addr(const char * pch)
{
    WinsockApiPrologTrivial_(inet_addr);
    WinsockApiParamCheck_(pch != NULL);

    // Convert the string representation of IP address to its binary form.
    // The following formats are recognized:
    //      a.b.c.d     8-8-8-8
    //      a.b.c       8-8-16
    //      a.b         8-24
    //      a           32
    // Each field can be in decimal, octal, or hex format.

    ULONG fields[4], addr;
    UINT fieldcnt = 0;
    const UCHAR* p = (const UCHAR *) pch;

    // NOTE: We don't handle overflow conditions.

    while (TRUE) {
        // skip leading spaces
        while (*p == ' ') p++;
        if (fieldcnt >= 4 || *p == 0) break;
    
        addr = 0;
        if (*p == '0' && (p[1] == 'x' || p[1] == 'X')) {
            // hex number
            const UCHAR* q = (p += 2);

            while (TRUE) {
                if (*p >= '0' && *p <= '9')
                    addr = (addr << 4) + (*p - '0');
                else if (*p >= 'a' && *p <= 'f')
                    addr = (addr << 4) + 10 + (*p - 'a');
                else if (*p >= 'A' && *p <= 'F')
                    addr = (addr << 4) + 10 + (*p - 'A');
                else
                    break;
                p++;
            }

            if (q == p)
            {
                return(INADDR_NONE);
            }

        } else if (*p == '0') {
            // octal number
            do {
                addr = (addr << 3) + (*p - '0');
                p++;
            } while (*p >= '0' && *p <= '7');
        } else if (*p >= '1' && *p <= '9') {
            // decimal number
            do {
                addr = addr*10 + (*p - '0');
                p++;
            } while (*p >= '0' && *p <= '9');
        } else {
            // invalid character
            break;
        }

        // skip trailing spaces and . separator
        while (*p == ' ') p++;
        if (*p == '.') p++;

        fields[fieldcnt++] = addr;
    }

    if (*p)
    {
        return(INADDR_NONE);
    }

    switch (fieldcnt) {
    case 1:
        addr = fields[0];
        break;
    case 2:
        addr = ((fields[0] & 0xff) << 24) |
               (fields[1] & 0xffffff);
        break;
    case 3:
        addr = ((fields[0] & 0xff) << 24) |
               ((fields[1] & 0xff) << 16) |
               (fields[2] & 0xffff);
        break;
    case 4:
        addr = ((fields[0] & 0xff) << 24) |
               ((fields[1] & 0xff) << 16) |
               ((fields[2] & 0xff) <<  8) |
               (fields[3] & 0xff);
        break;

    default:
        addr = 0;
        break;
    }

    return(HTONL(addr));
}

// ---------------------------------------------------------------------------------------
// Miscellanous
// ---------------------------------------------------------------------------------------

u_long      _WSAAPI_ htonl(IN u_long hostlong)            { return HTONL(hostlong); }
u_short     _WSAAPI_ htons(IN u_short hostshort)          { return HTONS(hostshort); }
u_long      _WSAAPI_ ntohl(IN u_long netlong)             { return NTOHL(netlong); }
u_short     _WSAAPI_ ntohs(IN u_short netshort)           { return NTOHS(netshort); }
int         _WSAAPI_ WSAGetLastError()                    { return(GetLastError()); }
void        _WSAAPI_ WSASetLastError(IN int error)        { SetLastError(error); }
WSAEVENT    _WSAAPI_ WSACreateEvent()                     { return(CreateEvent(NULL, TRUE, FALSE, NULL)); }
BOOL        _WSAAPI_ WSACloseEvent(IN WSAEVENT hEvent)    { return(CloseHandle(hEvent)); }
BOOL        _WSAAPI_ WSASetEvent(IN WSAEVENT hEvent)      { return(SetEvent(hEvent)); }
BOOL        _WSAAPI_ WSAResetEvent(IN WSAEVENT hEvent)    { return(ResetEvent(hEvent)); }

DWORD _WSAAPI_ WSAWaitForMultipleEvents(IN DWORD cEvents, IN const WSAEVENT* lphEvents,
                                        IN BOOL fWaitAll, IN DWORD dwTimeout, IN BOOL fAlertable)
{
    return(WaitForMultipleObjectsEx(cEvents, lphEvents, fWaitAll, dwTimeout, fAlertable));
}

int _WSAAPI_ __WSAFDIsSet(SOCKET fd, fd_set * set)
{
    int i = (set->fd_count & 0xffff);

    while (i--)
    {
        if (set->fd_array[i] == fd)
            return 1;
    }

    return 0;
}

// ---------------------------------------------------------------------------------------
// SockLock
// ---------------------------------------------------------------------------------------

CSocket * CSocket::Lock(SOCKET s)
{
    CSocket *   pSocket;
    LONG        lLock;
    int         err;

    // NOTE: We don't allow multiple threads to access the same
    // socket simultaneously. If the app tries to do that, the first
    // thread will succeed and other threads will get an error return.

    if (s == 0 || s == INVALID_SOCKET)
    {
        err = WSAENOTSOCK;
    }
    else
    {
        pSocket = (CSocket *)s;
        lLock   = InterlockedCompareExchange(&pSocket->_lLock, SOCK_LOCK_BUSY, SOCK_LOCK_ACTIVE);

        if (lLock == SOCK_LOCK_ACTIVE)
            return(pSocket);

        err = (lLock == SOCK_LOCK_BUSY) ? WSAEINPROGRESS : WSAENOTSOCK;
    }

#if defined(XNET_FEATURE_TRACE) && !defined(XNET_FEATURE_XBDM_SERVER)
    if (err == WSAEINPROGRESS)
    {
        TraceSz1(sockWarn, "[%X] Socket thread contention", s);
    }
#endif

    SetLastError(err);

    return(NULL);
}

// ---------------------------------------------------------------------------------------
// CXnSock::SockInit
// ---------------------------------------------------------------------------------------

NTSTATUS CXnSock::SockInit(XNetInitParams * pxnip)
{
    TCHECK(USER);

    LARGE_INTEGER dueTime;
    UINT period;

    NTSTATUS status = IpInit(pxnip);
    if (!NT_SUCCESS(status))
        return(status);

    SetInitFlag(INITF_SOCK);

    InitializeListHead(&_leSockets);
    InitializeListHead(&_leDeadSockets);
    _ipportTempNext = MAX_TEMP_PORT;

    return(NETERR_OK);
}

void CXnSock::SockTerm()
{
    TCHECK(USER);

    RaiseToDpc();

    if (TestInitFlag(INITF_SOCK))
    {
        SockStop();
        SockShutdown();
    }

    SetInitFlag(INITF_SOCK_TERM);

    IpTerm();
}

void CXnSock::SockShutdown()
{
    if (TestInitFlag(INITF_SOCK))
    {
        RaiseToDpc();

        while (!IsListEmpty(&_leSockets))
        {
            CSocket * pSocket = (CSocket*)_leSockets.Flink;

            if (pSocket->TestFlags(SOCKF_OWNED))
            {
                TraceSz1(LeakWarn, "Socket %08lX not closed before WSACleanup", pSocket);
            }

            SockClose(pSocket, TRUE);
        }

        while (!IsListEmpty(&_leDeadSockets))
        {
            CSocket * pSocket = (CSocket*) _leDeadSockets.Flink;

            SockClose(pSocket, TRUE);
        }
    }
}

// ---------------------------------------------------------------------------------------
// SockWaitForEvent
// ---------------------------------------------------------------------------------------

NTSTATUS CXnSock::SockWaitForEvent(CSocket* pSocket, INT eventMask, UINT timeout)

/*++

Routine Description:

    Block the current thread until the specified CSocket event is signalled

Arguments:

    pSocket - Points to the protocol control block
    eventMask - Flag bit to indicate which event to block on
    timeout - Specifies the wait timeout (in milliseconds, 0 means forever)

Return Value:

    Status code

--*/

{
    INT readyMask;
    NTSTATUS status = NETERR_OK;

    //
    // Check if the specified event is already available
    // or if the socket connection has been reset.
    //
    readyMask = SockCheckSelectEvents(pSocket, eventMask, 1);
    if (readyMask & SOCKF_EVENT_RESET) goto exit;
    if (readyMask != 0) return NETERR_OK;

    status = EvtWait(pSocket->GetEvent(), timeout) ? NETERR_OK : NETERR_TIMEOUT;

    pSocket->ClearFlags(SOCKF_EVENT_MASK);

exit:
    return NT_SUCCESS(status) ? pSocket->GetStatus() : status;
}


void CXnSock::SockReqComplete(CSocket * pSocket, CSockReq * pSockReq, NTSTATUS status)
{
    if (pSockReq)
    {
        if (pSocket->GetSendReq() == pSockReq)
            pSocket->SetSendReq(NULL);
        else if (pSocket->GetRecvReq() == pSockReq)
            pSocket->SetRecvReq(NULL);

        pSockReq->_pWsaOverlapped->_iostatus = status;

        EvtSet(pSockReq->_pEvent, EVENT_INCREMENT);

        if (pSockReq->_pEvent != pSocket->GetEvent())
        {
            EvtDereference(pSockReq->_pEvent);
            SysFree(pSockReq);
        }
    }
}


CSocket * CXnSock::SockFindMatch(CIpPort toport, CIpAddr fromaddr, CIpPort fromport, BYTE type)
{
    TCHECK(SDPC);

    CSocket *   pSocket;
    CSocket *   pSocketBest = NULL;
    BOOL        fIsUdp      = (type == SOCK_DGRAM);
    UINT        cWildMin    = 3;
    UINT        cWild;

    for (pSocket = GetFirstSocket(); pSocket; pSocket = GetNextSocket(pSocket))
    {
        if (!!pSocket->IsUdp() != fIsUdp)
            continue;

        if (pSocket->_ipportSrc != toport)
            continue;

        cWild = 0;

        if (pSocket->_ipaDst != fromaddr)
        {
            if (pSocket->_ipaDst)
                continue;

            cWild++;
        }

        if (pSocket->_ipportDst != fromport)
        {
            if (pSocket->_ipportDst)
                continue;

            cWild++;
        }

        if (cWild == 0)
        {
            pSocketBest = pSocket;
            break;
        }

        if (cWild < cWildMin)
        {
            pSocketBest = pSocket;
            cWildMin = cWild;
        }
    }

    return(pSocketBest);
}

void CSocket::SetFlagsAndOr(DWORD dwAnd, DWORD dwOr)
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);

    DWORD dwFlagsOld, dwFlagsNew;

    while (1)
    {
        dwFlagsOld = _dwFlags;
        dwFlagsNew = (dwFlagsOld & dwAnd) | dwOr;

        if (InterlockedCompareExchange((LONG *)&_dwFlags, (LONG)dwFlagsNew, (LONG)dwFlagsOld) == (LONG)dwFlagsOld)
            break;

        TraceSz(Warning, "CSocket::SetFlagsAndOr: Thread/DPC contention detected.  Retrying.");
    }
}

// ---------------------------------------------------------------------------------------
// SockReset
// ---------------------------------------------------------------------------------------

void CXnSock::SockReset(CIpAddr ipa)
{
    TCHECK(UDPC|SDPC);

    if (ipa != 0 && TestInitFlag(INITF_SOCK) && !TestInitFlag(INITF_SOCK_TERM))
    {
        CSocket *       pSocket;
        CSocket *       pSocketNext;
        CTcpSocket *    pTcpSocket;

        for (pSocket = GetFirstSocket(); pSocket; pSocket = pSocketNext)
        {
            pSocketNext = GetNextSocket(pSocket);

            if (pSocket->IsTcp() && pSocket->_ipaDst == ipa)
            {
                pTcpSocket = (CTcpSocket *)pSocket;

                if (!pTcpSocket->IsIdleState())
                {
                    TcpReset(pTcpSocket, NETERR_CONNRESET);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\sources.inc ===
C_DEFINES=$(C_DEFINES) -DNT -DXNET_BUILD_LIB$(LIBTAG)

INCLUDES=\
    $(BASEDIR)\public\sdk\inc; \
    $(BASEDIR)\private\ntos\net; \
    $(BASEDIR)\private\ntos\inc; \
    $(BASEDIR)\private\inc\crypto; \

!if "$(LIBTAG)"=="XW" || "$(LIBTAG)"=="OW"
INCLUDES=$(BASEDIR)\public\wsdk\inc;$(INCLUDES)
UMTYPE=windows
!endif

TARGETPATH=obj
TARGETTYPE=LIBRARY

!if "$(LIBTAG)"=="M"
TARGETNAME=xnetm$(D)
!endif

!if "$(LIBTAG)"=="X"
TARGETNAME=xnet$(D)
TARGETPATH=$(BASEDIR)\public\sdk\lib
!endif

!if "$(LIBTAG)"=="XS"
TARGETNAME=xnets$(D)
TARGETPATH=$(BASEDIR)\public\sdk\lib
!endif

!if "$(LIBTAG)"=="XW"
TARGETNAME=xnetw$(D)
TARGETPATH=$(BASEDIR)\public\sdk\lib
!endif

!if "$(LIBTAG)"=="O"
TARGETNAME=xneto$(D)
!endif

!if "$(LIBTAG)"=="OS"
TARGETNAME=xnetos$(D)
!endif

!if "$(LIBTAG)"=="OW"
TARGETNAME=xnetow$(D)
!endif

MSC_WARNING_LEVEL=/W3 /WX /Ob1

!if defined(GENASM)
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /Fa
!endif

!if $(FREEBUILD) == 0
MSC_OPTIMIZATION=/Odi /Ob1
!endif

PRECOMPILED_INCLUDE=..\xnp.h
PRECOMPILED_PCH=xnp.pch
PRECOMPILED_OBJ=xnp.obj
PRECOMPILED_CXX=1

SOURCES=\
    tcpipxsum.asm \
    base.cpp \
    enet.cpp \
    halw.cpp \
    halx.cpp \
    ip.cpp \
    ipdhcp.cpp \
    ipdns.cpp \
    ipicmp.cpp \
    ipqos.cpp \
    nicw.cpp \
    nicx.cpp \
    sock.cpp \
    socktcp.cpp \
    sockudp.cpp \
    xnet.cpp \
    xnetp.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\socktcp.cpp ===
// ---------------------------------------------------------------------------------------
// socktcp.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(tcpStat,  0);
DefineTag(tcpWarn,  TAG_ENABLE);

// ---------------------------------------------------------------------------------------
// TcpTimer
// ---------------------------------------------------------------------------------------

// TCP option length in our SYN segment
#define SYNTCPOPTLEN 4

void CXnSock::TcpTimer(CTimer * pt)
{
    CTcpSocket * pTcpSocket = CTcpSocket::TimerToSocket(pt);
    DWORD dwTickNow  = TimerTick();
    DWORD dwTickNext;

    if (pTcpSocket->delayedAcks)
    {
        TcpEmitACK(pTcpSocket);
    }

    if (pTcpSocket->dwTickSyn && dwTickNow >= pTcpSocket->dwTickSyn)
    {
        pTcpSocket->dwTickSyn = 0;
        if (TcpReset(pTcpSocket, NETERR_TIMEOUT) == NULL)
            return;
    }

    if (pTcpSocket->dwTickXmit && dwTickNow >= pTcpSocket->dwTickXmit)
    {
        pTcpSocket->dwTickXmit = 0;
        if (TcpXmitTimeout(pTcpSocket) == NULL)
            return;
    }

    if (pTcpSocket->dwTickWait && dwTickNow >= pTcpSocket->dwTickWait)
    {
        pTcpSocket->dwTickWait = 0;
        Assert(pTcpSocket->IsLingering());
        SockClose(pTcpSocket, TRUE);
        return;
    }

    dwTickNext = pTcpSocket->delayedAcks ? dwTickNow : TIMER_INFINITE;

    if (pTcpSocket->dwTickSyn > 0 && pTcpSocket->dwTickSyn < dwTickNext)
        dwTickNext = pTcpSocket->dwTickSyn;
    if (pTcpSocket->dwTickXmit > 0 && pTcpSocket->dwTickXmit < dwTickNext)
        dwTickNext = pTcpSocket->dwTickXmit;
    if (pTcpSocket->dwTickWait > 0 && pTcpSocket->dwTickWait < dwTickNext)
        dwTickNext = pTcpSocket->dwTickWait;

    TimerSet(pTcpSocket->GetTimer(), dwTickNext);
}

CTcpSocket * CXnSock::TcpXmitTimeout(CTcpSocket* pTcpSocket)

/*++

Routine Description:

    This function is called when the TCP retransmission timer expires.

Arguments:

    pTcpSocket - Points to the TCP control block

Return Value:

    NULL if the specified CTcpSocket was deleted inside this call.
    Otherwise, just return the input pTcpSocket parameter.

--*/

{
    if (pTcpSocket->IsSendBufEmpty())
        return(pTcpSocket);

    CTcpSendBuf* pTcpSendBuf = (CTcpSendBuf *)pTcpSocket->GetSendBufFirst();

    if (pTcpSendBuf->retries >= cfgSockRexmitRetries)
    {
        return(TcpReset(pTcpSocket, NETERR_TIMEOUT));
    }

    // Stop round-trip time measurement if there is retransmission
    pTcpSocket->rtt_tick = 0;

    // Retransmit the first segment
    if (pTcpSocket->TestFlags(SOCKF_PERSIST))
    {
        if (pTcpSendBuf->retries == 0)
        {
            // Send out the window probe segment for the first time.
            // BUGBUG: we always send out the whole segment instead
            // of just a single byte of data.

            Assert(pTcpSendBuf == pTcpSocket->GetSendBufPtr());
            TcpSendSegment(pTcpSocket, pTcpSendBuf, FALSE);
            pTcpSocket->snd_nxt = pTcpSendBuf->seqnext;
            pTcpSocket->SetSendBufPtr((CTcpSendBuf *)pTcpSocket->GetSendBufNext(pTcpSendBuf));
            return(pTcpSocket);
        }
    }
    else
    {
        TraceSz3(tcpStat, "[%X.t] Retransmission timeout seq %08lX (%d retries)",
                 pTcpSocket, pTcpSendBuf->seq, pTcpSendBuf->retries);
        Assert(pTcpSendBuf->retries != 0);
        // Congestion control:
        //  set the slow-start threshold to be half the flight size
        //  and set the congestion window to be 1 SMSS
        pTcpSocket->ResetSlowStartThresh();
        pTcpSocket->snd_cwnd = pTcpSocket->snd_mss;
        TcpStopFastRexmitMode(pTcpSocket);
    }

    TcpSendSegment(pTcpSocket, pTcpSendBuf, pTcpSendBuf->retries != 0);
    return(pTcpSocket);
}

CTcpSocket * CXnSock::TcpReset(CTcpSocket* pTcpSocket, NTSTATUS status)

/*++

Routine Description:

    Reset a TCP connection

Arguments:

    pTcpSocket - Points to the TCP control block
    status - Specifies the cause of the reset

Return Value:

    NULL if the specified CTcpSocket was deleted inside this call.
    Otherwise, just return the input pTcpSocket parameter.

--*/

{
    BOOL fRevivable;

    Assert(!pTcpSocket->IsIdleState());
    
    if (pTcpSocket->IsChild() || pTcpSocket->IsLingering())
    {
        SockClose(pTcpSocket, TRUE);
        return NULL;
    }

    // Remove the CTcpSocket from the active list
    // and move it to the zombie list.

    pTcpSocket->Dequeue();
    pTcpSocket->Enqueue(&_leDeadSockets);

    pTcpSocket->SetStatus((status != NETERR_CONNRESET || pTcpSocket->IsSyncState()) ? status : NETERR(WSAECONNREFUSED));

    fRevivable = !pTcpSocket->IsSyncState() && !pTcpSocket->TestFlags(SOCKF_NOMORE_XMIT|SOCKF_NOMORE_RECV);
    pTcpSocket->SetFlags(SOCKF_NOMORE_XMIT|SOCKF_NOMORE_RECV);
    TcpSetState(pTcpSocket, TCPST_CLOSED, "Reset");

    // Stop various timers
    // NOTE: This is a little hacky - we're clearing all the fields
    // from delayedAcks to rtt_tick in one shot. Be careful when you
    // add or remove fields from the CTcpSocket structure.

    memset(&pTcpSocket->delayedAcks, 0,
           offsetof(CTcpSocket, rtt_tick) + sizeof(pTcpSocket->rtt_tick) - offsetof(CTcpSocket, delayedAcks));

    TimerSet(pTcpSocket->GetTimer(), TIMER_INFINITE);
    pTcpSocket->TcpInit(this);
    pTcpSocket->ClearFlags(SOCKF_PERSIST|SOCKF_FAST_RETRANSMIT);
    pTcpSocket->SetDupAcks(0);
    pTcpSocket->SignalEvent(SOCKF_EVENT_MASK);

    SockCleanup(pTcpSocket);

    if (fRevivable)
    {
        pTcpSocket->SetFlags(SOCKF_REVIVABLE);
    }

    return(pTcpSocket);
}

CTcpSocket * CXnSock::TcpCloneChild(CTcpSocket * pTcpSocket)

/*++

Routine Description:

    Add a pending connection request to a listening socket

Arguments:

    pTcpSocket - Points to the listening socket

Return Value:

    Pointer to the child socket
    NULL if there is an error

--*/

{
    // Fail if the backlog is full
    Assert(pTcpSocket->IsListenState());

    if (pTcpSocket->GetBacklog() >= pTcpSocket->GetBacklogMax())
    {
        TraceSz2(Warning, "[%X.t] Reached backlog limit for listening socket (%d)",
                 pTcpSocket, pTcpSocket->GetBacklogMax());
        return(NULL);
    }
    
    // Allocate memory for the child socket
    CTcpSocket * pTcpSocketChild = (CTcpSocket *)SockAlloc(TRUE, TRUE);

    if (!pTcpSocketChild)
    {
        TraceSz1(Warning, "[%X.t] Out of memory allocating child of listening socket",
                 pTcpSocket);
        return(NULL);
    }

    pTcpSocket->EnqueueChild(pTcpSocketChild);

    return(pTcpSocketChild);
}
            
void CXnSock::TcpEmitRST(CTcpSocket * pTcpSocket, CIpAddr ipaDst, CIpPort ipportDst,
                         CIpPort ipportSrc, TCPSEQ seq, TCPSEQ ack, BYTE flags)
{
    CPacket * pkt = TcpPacketAlloc(pTcpSocket, ipaDst, PKTF_POOLALLOC);
    if (!pkt) return;

    CTcpHdr * pTcpHdr   = pkt->GetTcpHdr();
    pTcpHdr->SetHdrLen(sizeof(CTcpHdr));
    pTcpHdr->_ipportSrc = ipportSrc;
    pTcpHdr->_ipportDst = ipportDst;
    pTcpHdr->_dwSeqNum  = HTONL(seq);
    pTcpHdr->_dwAckNum  = HTONL(ack);
    pTcpHdr->_bFlags    = (BYTE)(TCP_RST | flags);
    pTcpHdr->_wWindow   = 0;
    pTcpHdr->_wUrgent   = 0;
    pTcpHdr->_wChecksum = 0;

    TraceTcpHdr(pktXmit, pTcpSocket, pTcpHdr, 0, 0);
    IpFillAndXmit(pkt, ipaDst, IPPROTOCOL_TCP);
}


// Return the effective snd_nxt value for a TCP connection
// NOTE: we cannot use CTcpSocket.snd_nxt field directly here
// because the way we're doing persisting causes snd_nxt
// to go past the send window.
TCPSEQ CXnSock::TcpSndNxt(CTcpSocket* pTcpSocket)
{
    TCPSEQ sndmax = pTcpSocket->snd_wl2 + pTcpSocket->snd_wnd;
    return (pTcpSocket->IsSyncState() && SEQ_GT(pTcpSocket->snd_nxt, sndmax)) ?
                sndmax :
                pTcpSocket->snd_nxt;
}

// Send a RST segment to the TCP connection peer
VOID CXnSock::TcpResetPeer(CTcpSocket* pTcpSocket)
{
    TcpEmitRST(pTcpSocket, pTcpSocket->_ipaDst, pTcpSocket->_ipportDst, pTcpSocket->_ipportSrc,
               TcpSndNxt(pTcpSocket), pTcpSocket->rcv_nxt, TCP_ACK);
}

NTSTATUS CXnSock::TcpEmitSYN(CTcpSocket* pTcpSocket, BOOL synAck)

/*++

Routine Description:

    Emit a TCP SYN segment

Arguments:

    pTcpSocket - Points to the TCP control block
    synAck - Whether to send ACK as well

Return Value:

    Status code

--*/

{
    CPacket* pkt;
    BYTE* opt;
    CTcpSendBuf* pTcpSendBuf;

    // Check if we're already trying to send out a SYN segment
    if (!pTcpSocket->IsSendBufEmpty())
    {
        pTcpSendBuf = (CTcpSendBuf *)pTcpSocket->DequeueSendBuf();
        SockReleaseSendBuf(pTcpSendBuf);
        Assert(pTcpSocket->IsSendBufEmpty());
        Assert(pTcpSocket->GetSendBufPtr() == NULL);
    }

    pTcpSocket->snd_una = pTcpSocket->snd_nxt = pTcpSocket->snd_end = pTcpSocket->snd_isn;

    // Allocate a TCP send buffer for possible retransmission
    pkt = TcpPacketAlloc(pTcpSocket, pTcpSocket->_ipaDst, synAck ? PKTF_POOLALLOC : 0, SYNTCPOPTLEN,
                         sizeof(CTcpSendBuf), (PFNPKTFREE)TcpPacketFree);
    if (!pkt)
    {
        // This is very bad - we failed to allocate memory
        // for the SYN segment. We'll mark the CTcpSocket as dead
        // and return an error code.
        TcpReset(pTcpSocket, NETERR_MEMORY);
        return NETERR_MEMORY;
    }

    pTcpSocket->dwTickSyn = TimerSetRelative(pTcpSocket->GetTimer(), cfgSockConnectTimeoutInSeconds * TICKS_PER_SECOND);

    opt = (BYTE *)pkt->GetTcpHdr() + sizeof(CTcpHdr);
    opt[0] = TCPOPT_MAX_SEGSIZE;
    opt[1] = SYNTCPOPTLEN;
    opt[2] = (BYTE) (pTcpSocket->rcv_mss >> 8);
    opt[3] = (BYTE) pTcpSocket->rcv_mss;

    TcpQueueSegment(pTcpSocket, pkt, (BYTE) (synAck ? TCP_SYN|TCP_ACK : TCP_SYN), 0);
    return NETERR_OK;
}


void CXnSock::TcpEmitACK(CTcpSocket* pTcpSocket)

/*++

Routine Description:

    Send out an ACK segment on a TCP connection

Arguments:

    pTcpSocket - Points to the TCP control block

Return Value:

    NONE

--*/

{
    CPacket * ppkt = TcpPacketAlloc(pTcpSocket, pTcpSocket->_ipaDst, PKTF_POOLALLOC);
    if (!ppkt)
        return;

    TCPSEQ seq = TcpSndNxt(pTcpSocket);
    pTcpSocket->delayedAcks = 0;

    CTcpHdr * pTcpHdr   = ppkt->GetTcpHdr();
    pTcpHdr->SetHdrLen(sizeof(CTcpHdr));
    pTcpHdr->_ipportSrc = pTcpSocket->_ipportSrc;
    pTcpHdr->_ipportDst = pTcpSocket->_ipportDst;
    pTcpHdr->_dwSeqNum  = HTONL(seq);
    pTcpHdr->_dwAckNum  = HTONL(pTcpSocket->rcv_nxt);
    pTcpHdr->_bFlags    = TCP_ACK;
    pTcpHdr->_wWindow   = HTONS((WORD)pTcpSocket->rcv_wnd);
    pTcpHdr->_wUrgent   = 0;
    pTcpHdr->_wChecksum = 0;

    TraceTcpHdr(pktXmit, pTcpSocket, pTcpHdr, 0, 0);
    IpFillAndXmit(ppkt, pTcpSocket->_ipaDst, IPPROTOCOL_TCP, &pTcpSocket->_prte);
}


NTSTATUS CXnSock::TcpEmitFIN(CTcpSocket * pTcpSocket)

/*++

Routine Description:

    Send out a FIN segment on a TCP connection

Arguments:

    pTcpSocket - Points to the TCP control block

Return Value:

    Status code

--*/

{
    ICHECK(SOCK, UDPC);
    CPacket * ppkt = TcpPacketAlloc(pTcpSocket, pTcpSocket->_ipaDst, 0, 0, sizeof(CTcpSendBuf), (PFNPKTFREE)TcpPacketFree);
    if (!ppkt) return NETERR_MEMORY;
    TcpQueueSegment(pTcpSocket, ppkt, TCP_ACK|TCP_FIN, 0);
    return(NETERR_OK);
}

//
// Update the receive window information after accepting
// the specified amount data from the connection peer.
//
void CXnSock::TcpSlideRecvWindow(CTcpSocket* pTcpSocket, UINT datalen)
{
    Assert(pTcpSocket->_cbMaxRecvBuf >= pTcpSocket->GetCbRecvBuf());

    UINT newwnd = pTcpSocket->_cbMaxRecvBuf - pTcpSocket->GetCbRecvBuf();

    // Here datalen must be <= rcv_wnd.
    Assert(datalen <= pTcpSocket->rcv_wnd);
    pTcpSocket->rcv_nxt += datalen;

    if ((datalen + newwnd) - pTcpSocket->rcv_wnd >= pTcpSocket->rcv_swsthresh) {
        // Enough space has freed up. Move the right edge of the receive window.
        pTcpSocket->rcv_wnd = newwnd;
    } else {
        // Implement receive side silly window avoidance:
        //  keep the right edge of the receive window unchanged.
        pTcpSocket->rcv_wnd -= datalen;
    }
}

void CXnSock::TcpUpdateRTO(CTcpSocket* pTcpSocket)

/*++

Routine Description:

    Update the round-trip time measurements for a TCP connection

Arguments:

    pTcpSocket - Points to the TCP control block

Return Value:

    NONE

--*/

{
    INT nticks, delta;

    // The computation is based on the following formula:
    //  delta = nticks - srtt
    //  srtt = srtt + delta / 8
    //  rttvar = rttvar + (|delta| - rttvar) / 4
    //  RTO = srtt + 4 * rttvar

    nticks = TimerTick() - pTcpSocket->rtt_tick;
    pTcpSocket->rtt_tick = 0;

    if (pTcpSocket->srtt_8 != 0) {
        delta = nticks - (pTcpSocket->srtt_8 >> SRTT_SHIFT);
        if ((pTcpSocket->srtt_8 += delta) <= 0)
            pTcpSocket->srtt_8 = 1;

        if (delta < 0) delta = -delta;
        delta -= (pTcpSocket->rttvar_4 >> RTTVAR_SHIFT);
        if ((pTcpSocket->rttvar_4 += delta) <= 0)
            pTcpSocket->rttvar_4 = 1;
    } else {
        // The very first measurement - use the unsmoothed data
        if (nticks == 0) {
            pTcpSocket->srtt_8 = pTcpSocket->rttvar_4 = 1;
        } else {
            pTcpSocket->srtt_8 = nticks << SRTT_SHIFT;
            pTcpSocket->rttvar_4 = nticks << (RTTVAR_SHIFT-1);
        }
    }

    pTcpSocket->RTO = (pTcpSocket->srtt_8 >> SRTT_SHIFT) + pTcpSocket->rttvar_4;
    if (pTcpSocket->RTO < (UINT)cfgSockRexmitMinTimeoutInSeconds * TICKS_PER_SECOND)
        pTcpSocket->RTO = (UINT)cfgSockRexmitMinTimeoutInSeconds * TICKS_PER_SECOND;
}


BOOL CXnSock::TcpUpdatePersistFlag(CTcpSocket* pTcpSocket)

/*++

Routine Description:

    This function is called after the send window information is updated.
    If we're currently sending out window probing segments, then
    we'll stop doing so if the send window has opened up.

Arguments:

    pTcpSocket - Points to the TCP control block

Return Value:

    FALSE if we got out of persist mode
    TRUE otherwise

--*/

{
    Assert(!pTcpSocket->IsSendBufEmpty());
    CTcpSendBuf* pTcpSendBuf = (CTcpSendBuf *)pTcpSocket->GetSendBufFirst();

    if (pTcpSendBuf->GetCbBuf() <= pTcpSocket->snd_wnd)
    {
        pTcpSocket->ClearFlags(SOCKF_PERSIST);

        if (pTcpSendBuf->retries)
        {
            TraceSz1(tcpStat, "[%X.t] Retransmit persisting segment...", pTcpSocket);
            pTcpSendBuf->retries = 0;
            TcpSendSegment(pTcpSocket, pTcpSendBuf, TRUE);
        }
        else
        {
            pTcpSocket->dwTickXmit = 0;
        }

        return(FALSE);
    }

    return(TRUE);
}


void CXnSock::TcpUpdateSndUna(CTcpSocket* pTcpSocket, TCPSEQ ack)

/*++

Routine Description:

    Update the snd.una variable for a TCP connection

Arguments:

    pTcpSocket - Points to the TCP connection block
    ack - The acknowledged sequence number

Return Value:

    NONE

--*/

{
    CTcpSendBuf *   pTcpSendBuf;
    CTcpSendBuf *   pTcpSendBufNext;
    UINT            ackedSends = 0;

    if (SEQ_GT(ack, pTcpSocket->snd_una))
    {
        pTcpSocket->snd_una = ack;

        // Update round-trip time measurements
        if (pTcpSocket->rtt_tick && SEQ_GT(ack, pTcpSocket->rtt_seq))
        {
            TcpUpdateRTO(pTcpSocket);
        }

        // Complete fully acknowledged send user requests

        pTcpSendBuf = (CTcpSendBuf *)pTcpSocket->GetSendBufFirst();

        while (pTcpSendBuf)
        {
            if (pTcpSendBuf->retries && SEQ_GE(ack, pTcpSendBuf->seqnext))
            {
                pTcpSendBufNext = (CTcpSendBuf *)pTcpSocket->GetSendBufNext(pTcpSendBuf);
                pTcpSocket->DequeueSendBuf();
                pTcpSocket->DecCbSendBuf(pTcpSendBuf->GetCbBuf());
                SockReleaseSendBuf(pTcpSendBuf);
                ackedSends++;
                pTcpSendBuf = pTcpSendBufNext;
            }
            else
            {
                break;
            }
        }
    }

    // Update congestion window
    if (pTcpSocket->TestFlags(SOCKF_FAST_RETRANSMIT))
    {
        if (ackedSends)
        {
            //
            // Getting out of fast retransmit / fast recovery mode:
            //  "deflate" the congestion window
            //
            pTcpSocket->snd_cwnd = pTcpSocket->snd_ssthresh;
        }
        else
        {
            //
            // In fast recovery mode:
            //  increment the congestion window by SMSS
            //  for every duplicate ACK received.
            //
            pTcpSocket->IncrementCongestionWindow(pTcpSocket->snd_mss);
        }
    }
    else
    {
        if (pTcpSocket->snd_cwnd < pTcpSocket->snd_ssthresh)
        {
            //
            // Slow-start mode:
            //  increment the congestion window by SMSS
            //
            pTcpSocket->IncrementCongestionWindow(pTcpSocket->snd_mss);
        }
        else
        {
            //
            // Congestion avoidance mode:
            //  increment the congestion window by ~SMSS per RTT
            //
            // NOTE: Overflow is not possible here because snd_mss
            // and snd_cwnd are 16-bit numbers. Also snd_cwnd is never 0.
            //
            UINT inc = pTcpSocket->snd_mss * pTcpSocket->snd_mss / pTcpSocket->snd_cwnd;
            pTcpSocket->IncrementCongestionWindow(max(1, inc));
        }
    }

    if (ackedSends)
    {
        pTcpSocket->ClearFlags(SOCKF_PERSIST);
        TcpStopFastRexmitMode(pTcpSocket);

        // Reset retransmission timer
        pTcpSocket->dwTickXmit = 0;

        if (pTcpSocket->snd_una != pTcpSocket->snd_nxt)
        {
            pTcpSendBuf = (CTcpSendBuf *)pTcpSocket->GetSendBufFirst();

            if (pTcpSendBuf->firstSendTime + pTcpSocket->RTO <= TimerTick())
            {
                TcpXmitTimeout(pTcpSocket);
            }
            else
            {
                pTcpSocket->dwTickXmit = TimerSetRelative(pTcpSocket->GetTimer(), pTcpSendBuf->firstSendTime + pTcpSocket->RTO - TimerTick());
            }
        }

        if (!pTcpSocket->IsSendBufFull())
        {
            if (pTcpSocket->HasSendReq())
            {
                CSendReq * pSendReq = pTcpSocket->GetSendReq();
                NTSTATUS status = TcpSend(pTcpSocket, pSendReq, PKTF_POOLALLOC);
                pSendReq->_pWsaOverlapped->_ioxfercnt = pSendReq->sendtotal;
                SockReqComplete(pTcpSocket, pSendReq, status);
            }
            else
            {
                pTcpSocket->SignalEvent(SOCKF_EVENT_WRITE);
            }
        }
    }
    else if (pTcpSocket->TestFlags(SOCKF_PERSIST))
    {
        // If we're probing the send window and the ack was for
        // the probe segment, then make sure we continue to probe
        // without timing out.

        pTcpSendBuf = (CTcpSendBuf *)pTcpSocket->GetSendBufFirst();

        if (SEQ_GE(ack, pTcpSendBuf->seq) &&
            pTcpSendBuf->retries >= cfgSockRexmitRetries-1)
        {
            pTcpSendBuf->retries--;
        }
    }
    else
    {
        if (pTcpSocket->snd_una != pTcpSocket->snd_nxt &&
            !pTcpSocket->TestFlags(SOCKF_FAST_RETRANSMIT) &&
            pTcpSocket->IncDupAcks() >= 4)
        {
            //
            // Too many duplicate ACK received:
            //  do fast retransmit / recovery
            //
            TcpDoFastRexmit(pTcpSocket);
        }
    }

    // If the send window has opened up and
    // we have pending data to send, try to do it now.
    if (!pTcpSocket->TestFlags(SOCKF_PERSIST) || !TcpUpdatePersistFlag(pTcpSocket))
    {
        while (pTcpSocket->GetSendBufPtr() && TcpStartOutput(pTcpSocket))
            NULL;
    }
}

void CXnSock::TcpDoFastRexmit(CTcpSocket* pTcpSocket)

/*++

Routine Description:

    Initiate the TCP fast retransmit / recovery procedure

Arguments:

    pTcpSocket - Points to the TCP control block

Return Value:

    NONE

--*/

{
    CTcpSendBuf* pTcpSendBuf;

    TraceSz2(tcpStat, "[%X.t] Fast rexmit mode: %08lX", pTcpSocket, pTcpSocket->snd_una);

    // Reset the slow-start threshold
    // and set the congestion window to be that plus 3*SMSS
    pTcpSocket->ResetSlowStartThresh();
    pTcpSocket->snd_cwnd = pTcpSocket->snd_ssthresh + 3*pTcpSocket->snd_mss;
    pTcpSocket->SetFlags(SOCKF_FAST_RETRANSMIT);
    pTcpSocket->SetDupAcks(0);

    // Retransmit the "lost" segment immediately
    Assert(pTcpSocket->HasSendBuf());
    pTcpSendBuf = (CTcpSendBuf *)pTcpSocket->GetSendBufFirst();
    Assert(pTcpSendBuf->retries);
    TcpSendSegment(pTcpSocket, pTcpSendBuf, TRUE);
}


// 
// Check if an acknowledged sequence number is valid for a TCP connection
//
#define IsValidACK(_pTcpSocket, _ack) \
        (SEQ_GT((_ack), (_pTcpSocket)->snd_una) && \
         SEQ_LE((_ack), (_pTcpSocket)->snd_nxt))

//
// Indicate whether we should send out an ACK immediately
// in response to an incoming segment.
//
//#define NeedSendACKNow(_pTcpSocket) ((_pTcpSocket)->delayedAcks += 0x20000)

void CXnSock::NeedSendACKNow(CTcpSocket * pTcpSocket)
{
    pTcpSocket->delayedAcks += 0x20000;
}

//
// Save the send window information from the connection peer
//
#define TcpUpdateSndWnd(_pTcpSocket, _wnd, _seq, _ack) { \
            (_pTcpSocket)->snd_wnd = (_wnd); \
            (_pTcpSocket)->snd_wl1 = (_seq); \
            (_pTcpSocket)->snd_wl2 = (_ack); \
        }


BOOL CXnSock::TcpValidateSeqs(CTcpSocket* pTcpSocket, TCPSEQ oldseq0, TCPSEQ oldseq1, TCPSEQ* newseq0, TCPSEQ* newseq1)

/*++

Routine Description:

    Check if the received sequence number is valid for a TCP connection

Arguments:

    pTcpSocket - Points to TCP control block
    oldseq0 - Starting sequence number from the received segment
    oldseq1 - Ending sequence number from the received segment (oldseq+seglen)
    newseq0 - Returns the effective starting sequence number inside the receive window
    newseq1 - Returns the effective ending sequence number

Return Value:

    FALSE if none of the received segment is inside the receive window,
    TRUE otherwise. In the latter case, seq0 and seq1 will return updated
    sequence numbers.

--*/

{
    TCPSEQ rcv_last;

    rcv_last = pTcpSocket->rcv_nxt + pTcpSocket->rcv_wnd;
    *newseq0 = SEQ_LT(oldseq0, pTcpSocket->rcv_nxt) ? pTcpSocket->rcv_nxt : oldseq0;
    *newseq1 = SEQ_GT(oldseq1, rcv_last) ? rcv_last : oldseq1;

    return SEQ_LT(*newseq0, *newseq1) ||
           (*newseq0 == *newseq1 && oldseq0 == oldseq1);
}


#if DBG

BOOL CXnSock::TcpVerifyRecvBuf(CTcpSocket* pTcpSocket)

/*++

Routine Description:

    Verify the current receive buffers for a CTcpSocket is good

Arguments:

    pTcpSocket - Points to the TCP control block

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    if (!pTcpSocket->HasRecvBuf())
        return(TRUE);

    CTcpRecvBuf * pTcpRecvBuf0 = (CTcpRecvBuf *)pTcpSocket->GetRecvBufFirst();
    CTcpRecvBuf * pTcpRecvBuf1;

    while (1)
    {
        pTcpRecvBuf1 = (CTcpRecvBuf *)pTcpSocket->GetRecvBufNext(pTcpRecvBuf0);

        if (pTcpRecvBuf1 == NULL)
            return(TRUE);

        if (SEQ_GT(pTcpRecvBuf0->seqnext, pTcpRecvBuf1->seqnext - pTcpRecvBuf1->GetCbBuf()))
            return(FALSE);

        pTcpRecvBuf0 = pTcpRecvBuf1;
    }
}

#endif // DBG


UINT CXnSock::TcpCorrectMisorderedSegments(CTcpSocket* pTcpSocket, TCPSEQ seq, CTcpRecvBuf* recvbuf)

/*++

Routine Description:

    This function is called when we receive a segment
    whose starting sequence number matches rcv_nxt and
    there are buffered out-of-order segments after this one.

Arguments:

    pTcpSocket - Points to TCP control block
    seq - Specifies the starting sequence number for this segment
    recvbuf - Points to the received data buffer

Return Value:

    Number of continuous bytes that can be acknowledged

--*/

{
    CTcpRecvBuf* buf0 = (CTcpRecvBuf *)pTcpSocket->GetRecvBufLast();
    CTcpRecvBuf* buf1;
    UINT count;

    do
    {
        buf0 = (CTcpRecvBuf *)pTcpSocket->GetRecvBufPrev(buf0);
    }
    while (buf0 && buf0->seqnext != seq);

    buf1 = (CTcpRecvBuf *)pTcpSocket->GetRecvBufNext(buf0);

    if (SEQ_GT(recvbuf->seqnext, buf1->seqnext - buf1->GetCbBuf())) {
        // Weird case: data in this segment overlapps with
        // data in the buffered out-of-order segments.
        // Chop off the overlapped data in the current receive buffer.
        TraceSz1(tcpStat, "[%X.t] TcpCorrectMisorderedSegments: overlapping segment", pTcpSocket);

        count = recvbuf->seqnext - (buf1->seqnext - buf1->GetCbBuf());
        Assert(count < recvbuf->GetCbBuf());

        recvbuf->DecCbBuf(count);
        recvbuf->seqnext -= count;
    }

    // Insert recvbuf after buf0 and before buf1
    pTcpSocket->InsertRecvBuf(recvbuf, buf0);

    count = recvbuf->GetCbBuf();
    buf0 = recvbuf;
    while (buf1 && buf0->seqnext == buf1->seqnext - buf1->GetCbBuf())
    {
        count += buf1->GetCbBuf();
        buf0 = buf1;
        buf1 = (CTcpRecvBuf *)pTcpSocket->GetRecvBufNext(buf1);
    }

    // If we filled up a hole, emit an ACK immediately
    if (count > recvbuf->GetCbBuf())
    {
        NeedSendACKNow(pTcpSocket);
    }

    // Assert(TcpVerifyRecvBuf(pTcpSocket));
    return count;
}


void CXnSock::TcpBufferMisorderedSegment(CTcpSocket* pTcpSocket, UINT seq, CTcpRecvBuf* recvbuf)


/*++

Routine Description:

    This function is called when we receive an out-of-order segment.

Arguments:

    pTcpSocket - Points to TCP control block
    seq - Specifies the starting sequence number for this segment
    recvbuf - Points to the received data buffer

Return Value:

    NONE

--*/

{
    CTcpRecvBuf* buf0 = (CTcpRecvBuf *)pTcpSocket->GetRecvBufLast();
    CTcpRecvBuf* buf1;
    UINT count;

    if (buf0 == NULL || SEQ_GE(seq, buf0->seqnext))
    {
        // The sequence number for this segment is larger
        // than everything in the receive buffer.
        pTcpSocket->EnqueueRecvBuf(recvbuf);
        return;
    }

    do
    {
        buf0 = (CTcpRecvBuf *)pTcpSocket->GetRecvBufPrev(buf0);
    }
    while (buf0 != NULL && SEQ_LT(seq, buf0->seqnext));

    // recvbuf should go in between buf0 and buf1

    buf1 = (CTcpRecvBuf *)pTcpSocket->GetRecvBufNext(buf0);

    if (SEQ_GT(recvbuf->seqnext, buf1->seqnext - buf1->GetCbBuf()))
    {
        // Data in this segment overlapps with
        // data in the buffered out-of-order segments.
        TraceSz1(tcpStat, "[%X.t] TcpBufferMisorderedSegment: overlapping segment", pTcpSocket);
        
        count= recvbuf->seqnext - (buf1->seqnext - buf1->GetCbBuf());

        if (count >= recvbuf->GetCbBuf())
        {
            PoolFree(recvbuf);
            return;
        }

        recvbuf->DecCbBuf(count);
        recvbuf->seqnext -= count;
    }

    pTcpSocket->InsertRecvBuf(recvbuf, buf0);

    // Assert(TcpVerifyRecvBuf(pTcpSocket));
}


UINT CXnSock::TcpCompletePendingRecvReqFast(CTcpSocket* pTcpSocket, BYTE tcpflags, BYTE * pbData, UINT cbData)

/*++

Routine Description:

    This function is called when we received data from a TCP connection
    and there is a pending overlapped receive request
    and there is currently no data in the receive buffer.
    In this case we can satisfy the request right away without
    allocating memory to store data in the receive buffer.

Arguments:

    pTcpSocket - Points to the TCP control block
    tcpflags - TCP segment flags

Return Value:

    Number of bytes used up in this call

--*/

{
    UINT copycnt;
    CRecvReq* pRecvReq = pTcpSocket->GetRecvReq();

    copycnt = min(cbData, pRecvReq->buflen);
    memcpy(pRecvReq->buf, pbData, copycnt);
    pRecvReq->_pWsaOverlapped->_ioxfercnt += copycnt;
    pRecvReq->buf += copycnt;
    pRecvReq->buflen -= copycnt;

    if ((pRecvReq->buflen == 0) || (tcpflags & TCP_PSH|TCP_URG)) {
        SockReqComplete(pTcpSocket, pRecvReq, NETERR_OK);
    }

    TcpSlideRecvWindow(pTcpSocket, copycnt);
    return copycnt;
}


CTcpSocket * CXnSock::TcpRecvData(CTcpSocket* pTcpSocket, CTcpHdr* tcphdr, BYTE * pbData, UINT cbData)

/*++

Routine Description:

    Process a received TCP data segment.
    And we assume the connection is in a synchronized state.

Arguments:

    pTcpSocket - Points to the TCP connection block
    tcphdr - Points to the TCP segment header information

Return Value:

    NULL if the CTcpSocket was deleted as a result of the incoming segment;
    Otherwise, just return the input pTcpSocket parameter

--*/

{
    TCPSEQ seq, ack, seq0, seq1;
    CTcpRecvBuf* recvbuf;
    DWORD dwTickWait;

    seq = SEG_SEQ(tcphdr);

    // Process ACK if it's present
    if (ISTCPSEG(tcphdr, ACK))
    {
        ack = SEG_ACK(tcphdr);
        if (SEQ_LT(ack, pTcpSocket->snd_una))
        {
            // ACK is an old duplicate, ignore it
        }
        else if (SEQ_GT(ack, pTcpSocket->snd_nxt))
        {
            // ACKing something that hasn't been sent.
            // Emit an ACK, drop the segment
            NeedSendACKNow(pTcpSocket);
            return pTcpSocket;
        }
        else
        {
            // update the send window information
            if (SEQ_LT(pTcpSocket->snd_wl1, seq) ||
                pTcpSocket->snd_wl1 == seq && SEQ_LE(pTcpSocket->snd_wl2, ack))
            {
                TcpUpdateSndWnd(pTcpSocket, SEG_WIN(tcphdr), seq, ack);
            }

            TcpUpdateSndUna(pTcpSocket, ack);

            // If we already sent FIN, check to see if FIN has been acknowledged
            if (pTcpSocket->IsFinSent() && pTcpSocket->IsSendBufEmpty())
            {
                switch (pTcpSocket->GetState())
                {
                case TCPST_FIN_WAIT_1:
                    TcpSetState(pTcpSocket, TCPST_FIN_WAIT_2, "FinAck");
                    break;

                case TCPST_CLOSING:
                    TcpSetState(pTcpSocket, TCPST_TIME_WAIT, "FinAck");

                    dwTickWait = TimerTick() + 2*cfgSockSegmentLifetimeInSeconds*TICKS_PER_SECOND;

                    if (pTcpSocket->dwTickWait == 0 || dwTickWait < pTcpSocket->dwTickWait)
                    {
                        pTcpSocket->dwTickWait = TimerSetRelative(pTcpSocket->GetTimer(), dwTickWait - TimerTick());
                    }
                    return NULL;

                case TCPST_LAST_ACK:
                    SockClose(pTcpSocket, TRUE);
                    return NULL;
                }
            }
        }
    }

    // If we already receive FIN from the peer,
    // we'll just ignore incoming data.
    if (pTcpSocket->IsFinReceived() || cbData == 0)
        return(pTcpSocket);

    pTcpSocket->delayedAcks += cbData;

    // Quick check to see if the data from incoming segment
    // fits entirely within the current receive window.
    if (seq != pTcpSocket->rcv_nxt || cbData > pTcpSocket->rcv_wnd)
    {
        // If the receive sequence number is outside of
        // the current receive window, send an ACK right away.
        if (!TcpValidateSeqs(pTcpSocket, seq, seq+cbData, &seq0, &seq1))
        {
            TraceSz4(tcpStat, "[%X.t] Sequence number out-of-range: %08lX %08lX %d",
                     pTcpSocket, seq, pTcpSocket->rcv_nxt, pTcpSocket->rcv_wnd);
            NeedSendACKNow(pTcpSocket);
            return pTcpSocket;
        }

        pbData += (seq0 - seq);
        cbData = (seq1 - seq0);
        Assert((INT)cbData > 0);
        seq = seq0;
    }

    if (pTcpSocket->TestFlags(SOCKF_NOMORE_RECV))
    {
        TcpResetPeer(pTcpSocket);
        TcpReset(pTcpSocket, NETERR_CONNRESET);
        return NULL;
    }

    // Special fast path: there is a pending overlapped receive request
    // and there is no data in the receive buffer.
    if (    pTcpSocket->HasRecvReq()
        &&  seq == pTcpSocket->rcv_nxt
        &&  !pTcpSocket->HasRecvBuf())
    {
        UINT copied = TcpCompletePendingRecvReqFast(pTcpSocket, tcphdr->_bFlags, pbData, cbData);
        if (copied == cbData) return pTcpSocket;

        pbData += copied;
        cbData -= copied;
        seq += copied;
    }

    // Make a copy of the incoming segment and buffer it up
    recvbuf = (CTcpRecvBuf*) PoolAlloc(sizeof(CTcpRecvBuf) + cbData, PTAG_CTcpRecvBuf);

    if (!recvbuf)
    {
        TraceSz2(tcpWarn, "[%X.t] Out of memory allocating receive buffer.  %ld bytes lost.",
                 pTcpSocket, cbData);
        return(pTcpSocket);
    }

    recvbuf->Init(this);

    recvbuf->seqnext = seq + cbData;
    recvbuf->dataoffset = sizeof(CTcpRecvBuf);
    recvbuf->tcpflags = tcphdr->_bFlags;
    recvbuf->SetCbBuf(cbData);
    memcpy(recvbuf+1, pbData, cbData);

    // Fast case: the receive segment is in sequence
    if (seq == pTcpSocket->rcv_nxt)
    {
        CTcpRecvBuf* lastbuf = (CTcpRecvBuf *)pTcpSocket->GetRecvBufLast();
        UINT datarun;

        if (lastbuf == NULL || lastbuf->seqnext == seq)
        {
            // We haven't buffered any out-of-order segments behind this one.
            datarun = cbData;
            pTcpSocket->EnqueueRecvBuf(recvbuf);
        }
        else
        {
            // Figure out if this segment fills out holes
            // in the receive buffer.
            Assert(SEQ_LT(seq, lastbuf->seqnext));
            datarun = TcpCorrectMisorderedSegments(pTcpSocket, seq, recvbuf);
        }

        pTcpSocket->SetCbRecvBuf(pTcpSocket->GetCbRecvBuf() + datarun);
        TcpSlideRecvWindow(pTcpSocket, datarun);

        if (pTcpSocket->HasRecvReq())
        {
            // If we have a pending overlapped receive request, satisfy it now
            CRecvReq* pRecvReq = pTcpSocket->GetRecvReq();
            pRecvReq->_pWsaOverlapped->_ioxfercnt += TcpCopyRecvData(pTcpSocket, pRecvReq);

            if (pRecvReq->buflen == 0)
            {
                SockReqComplete(pTcpSocket, pRecvReq, NETERR_OK);
            }

            TcpSlideRecvWindow(pTcpSocket, 0);
        }
        else
        {
            pTcpSocket->SignalEvent(SOCKF_EVENT_READ);
        }
    }
    else
    {
        // Slow case: a segment arrived out of order.
        // Buffer up this segment for later processing.
        TraceSz3(tcpStat, "[%X.t] Out-of-order segment: %08lX %08lX", pTcpSocket, SEG_SEQ(tcphdr), pTcpSocket->rcv_nxt);
        NeedSendACKNow(pTcpSocket);
        TcpBufferMisorderedSegment(pTcpSocket, seq, recvbuf);
    }

    return(pTcpSocket);
}


void CXnSock::TcpProcessFIN(CTcpSocket* pTcpSocket, CTcpHdr* tcphdr, TCPSEQ seqfin)

/*++

Routine Description:

    Process an incoming TCP FIN segment

Arguments:

    pTcpSocket - Points to the TCP control block
    tcphdr - Points to the TCP segment header
    seqfin - Sequence number for the FIN

Return Value:

    NONE

--*/

{
    DWORD dwTickWait;

    if (seqfin != pTcpSocket->rcv_nxt)
        return;

    pTcpSocket->rcv_nxt = seqfin+1;
    NeedSendACKNow(pTcpSocket);
    pTcpSocket->SignalEvent(SOCKF_EVENT_CLOSE);

    switch (pTcpSocket->GetState()) {
    case TCPST_SYN_RECEIVED:
    case TCPST_ESTABLISHED:
        SockReqComplete(pTcpSocket, pTcpSocket->GetRecvReq(), NETERR_OK);
        pTcpSocket->SignalEvent(SOCKF_EVENT_READ);
        TcpSetState(pTcpSocket, TCPST_CLOSE_WAIT, "FinRecv");
        break;

    case TCPST_FIN_WAIT_1:
        if (pTcpSocket->IsSendBufEmpty()) {
            TcpSetState(pTcpSocket, TCPST_CLOSING, "FinRecv");
            break;
        }

        // If our FIN has been acknowledged,
        // fall through and change to TIME-WAIT state.

    case TCPST_FIN_WAIT_2:
        TcpSetState(pTcpSocket, TCPST_TIME_WAIT, "FinRecv");

        // Fall through

    case TCPST_TIME_WAIT:
        dwTickWait = TimerTick() + 2*cfgSockSegmentLifetimeInSeconds*TICKS_PER_SECOND;

        if (pTcpSocket->dwTickWait == 0  || dwTickWait < pTcpSocket->dwTickWait)
        {
            pTcpSocket->dwTickWait = TimerSetRelative(pTcpSocket->GetTimer(), dwTickWait - TimerTick());
        }
        break;
    }
}


//
// Structure for storing TCP option parameters
// from an incoming SYN segment
//
typedef struct _TcpOptions {
    UINT mss;
    // other TCP option parameters ...
} TcpOptions;

BOOL CXnSock::TcpParseOptions(CTcpSocket * pTcpSocket, CTcpHdr * tcphdr, struct _TcpOptions * opts)

/*++

Routine Description:

    Parse the option information in an incoming TCP SYN segment

Arguments:

    tcphdr - Points to the TCP segment header
    opts - Returns the parsed option information

Return Value:

    TRUE if successful, FALSE if the TCP options are not well-formed

--*/

{
    const BYTE* buf;
    UINT buflen;

    // We ignore any data that's sent in the initial SYN segment.
    // Not sure if this case actually happens in real-life.
    // In any case, the sender should retransmit the data.
#if 0
    if (ISTCPSEG(tcphdr, SYN) && cbData > 0) {
        TraceSz(Warning, "Ignoring data in SYN segment.");
    }
#endif

    // Use default values if no options are present
    opts->mss = TCP_DEFAULT_MSS;

    buflen = tcphdr->GetHdrLen() - sizeof(CTcpHdr);
    buf = (const BYTE*) (tcphdr+1);

    while (buflen) {
        BYTE opt, optlen;

        if ((opt = *buf) == TCPOPT_EOL) break;
        if (opt == TCPOPT_NOP) {
            buf++; buflen--; 
            continue;
        }

        // Verify option length field
        if (buflen < 2 || (optlen = buf[1]) < 2 || optlen > buflen)
            return FALSE;

        switch (opt) {
        case TCPOPT_MAX_SEGSIZE:
            if (optlen != 4) return FALSE;
            opts->mss = ((UINT) buf[2] << 8) | buf[3];
            if (opts->mss < TCP_MINIMUM_MSS)
                opts->mss = TCP_DEFAULT_MSS;
            break;

        default:
            TraceSz1(tcpStat, "TCP option ignored: %d", opt);
            break;
        }

        buf += optlen;
        buflen -= optlen;
    }
    return TRUE;
}


//
// Save the relevant information in an incoming connection request
//
#define TcpSaveConnReqParams(_pTcpSocket, _tcphdr, _opts) { \
            (_pTcpSocket)->rcv_isn = SEG_SEQ(_tcphdr); \
            (_pTcpSocket)->rcv_nxt = (_pTcpSocket)->rcv_isn+1; \
            (_pTcpSocket)->snd_mss = (_opts)->mss; \
        }

BOOL CXnSock::TcpAcceptConnReqPassive(CTcpSocket* pTcpSocket, CTcpHdr* tcphdr, CIpAddr ipaSrc)

/*++

Routine Description:

    Process an incoming TCP connection request
    that was made to a listening (passively opened) socket

Arguments:

    pTcpSocket - TCP control block
    tcphdr - Points to the TCP segment header

Return Value:

    FALSE if the incoming connection request is bad and
    the caller should send out a RST in response; TRUE otherwise

--*/

{
    NTSTATUS status;
    CTcpSocket* pTcpSocketChild;
    TcpOptions opts;

    // Parse TCP options
    if (!TcpParseOptions(pTcpSocket, tcphdr, &opts)) return FALSE;

    pTcpSocketChild = TcpCloneChild(pTcpSocket);
    if (!pTcpSocketChild) return TRUE;

    TcpSetState(pTcpSocketChild, TCPST_SYN_RECEIVED, "Connection request");
    TcpSaveConnReqParams(pTcpSocketChild, tcphdr, &opts);

    status = TcpConnect(pTcpSocketChild, ipaSrc, tcphdr->_ipportSrc, TRUE);
    if (!NT_SUCCESS(status)) {
        SockClose(pTcpSocketChild, TRUE);
        return TRUE;
    }

    pTcpSocketChild->Enqueue(&_leSockets);

    return(TRUE);
}


void CXnSock::TcpConnectionEstablished(CTcpSocket* pTcpSocket, CTcpHdr* tcphdr)

/*++

Routine Description:

    Change a TCP connection to established state

Arguments:

    pTcpSocket - Points to the TCP control block
    tcphdr - Points to the incoming SYN/ACK segment

Return Value:

    NONE

--*/

{
    TCPSEQ ack;
    CTcpSendBuf* pTcpSendBuf;

    TraceSz4(tcpStat, "[%X.t] Connection established on %d to %s:%d ", pTcpSocket,
             NTOHS(pTcpSocket->_ipportSrc), pTcpSocket->_ipaDst.Str(),
             NTOHS(pTcpSocket->_ipportDst));

    //
    // The incoming segment must acknowledge our SYN
    //
    pTcpSendBuf = (CTcpSendBuf *)pTcpSocket->GetSendBufFirst();
    ack = SEG_ACK(tcphdr);
    Assert(pTcpSendBuf->tcpflags & TCP_SYN);
    Assert(ISTCPSEG(tcphdr, ACK));
    Assert(ack == pTcpSocket->snd_nxt);

    pTcpSocket->snd_una = ack;
    TcpUpdateSndWnd(pTcpSocket, SEG_WIN(tcphdr), SEG_SEQ(tcphdr), ack);

    if (pTcpSocket->rtt_tick)
    {
        TcpUpdateRTO(pTcpSocket);
    }

    pTcpSocket->DequeueSendBuf(pTcpSendBuf);
    SockReleaseSendBuf(pTcpSendBuf);

    pTcpSocket->dwTickXmit = pTcpSocket->dwTickSyn = 0;

    // NOTE: Since we don't fragment outgoing IP datagrams, we need
    // to limit snd_mss to be less than the first-hop interface MTU
    // minus the TCP and IP headers.
    if (pTcpSocket->snd_mss > pTcpSocket->rcv_mss)
        pTcpSocket->snd_mss = pTcpSocket->rcv_mss;

    pTcpSocket->snd_cwnd = 2*pTcpSocket->snd_mss;
    pTcpSocket->snd_ssthresh = max(pTcpSocket->snd_wnd, pTcpSocket->snd_cwnd);
    pTcpSocket->rcv_swsthresh = min(pTcpSocket->_cbMaxSendBuf>>1, pTcpSocket->snd_mss);
    if (pTcpSocket->rcv_swsthresh < 1)
        pTcpSocket->rcv_swsthresh = 1;

    TcpSetState(pTcpSocket, TCPST_ESTABLISHED, "Connected");
    pTcpSocket->SetFlags(SOCKF_CONNECTED);
    pTcpSocket->SignalEvent(SOCKF_EVENT_CONNECT);

    if (pTcpSocket->IsChild())
    {
        // Signal the connection request is ready for acceptance
        pTcpSocket->GetParent()->SignalEvent(SOCKF_EVENT_ACCEPT);
    }
}


BOOL CXnSock::TcpAcceptConnReqActive(CTcpSocket* pTcpSocket, CTcpHdr* tcphdr)

/*++

Routine Description:

    Process an incoming TCP connection request
    that was made to an actively opened socket

Arguments:

    pTcpSocket - TCP control block
    tcphdr - Points to the TCP segment header

Return Value:

    FALSE if the incoming connection request is bad and
    the caller should send out a RST in response; TRUE otherwise

--*/

{
    TcpOptions opts;
    NTSTATUS status;

    // Parse TCP options and save connection request information
    if (!TcpParseOptions(pTcpSocket, tcphdr, &opts)) return FALSE;
    TcpSaveConnReqParams(pTcpSocket, tcphdr, &opts);

    if (ISTCPSEG(tcphdr, ACK)) {
        TcpConnectionEstablished(pTcpSocket, tcphdr);
        NeedSendACKNow(pTcpSocket);
        status = NETERR_OK;
    } else {
        TcpSetState(pTcpSocket, TCPST_SYN_RECEIVED, "Simultaneous open");
        status = TcpEmitSYN(pTcpSocket, TRUE);
    }

    return NT_SUCCESS(status);
}


void CXnSock::TcpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbHdrLen, UINT cbData)
{
    CTcpSocket *    pTcpSocket;
    BYTE *          pbData = (BYTE *)pTcpHdr + cbHdrLen;
    BOOL            isAck;
    TCPSEQ          ack;

    pTcpSocket = (CTcpSocket *)SockFindMatch(pTcpHdr->_ipportDst, pIpHdr->_ipaSrc,
                                             pTcpHdr->_ipportSrc, SOCK_STREAM);

#if defined(XNET_FEATURE_ONLINE) && !defined(XNET_FEATURE_INSECURE)
    if (!ppkt->IsEsp() && !ppkt->TestFlags(PKTF_RECV_LOOPBACK) && !pTcpSocket->TestFlags(SOCKF_INSECURE))
    {
        // An insecure, non-loopback TCP packet will only be sent to a socket in the
        // secure online stack if the socket has explicitly allowed insecure packets.

        pTcpSocket = NULL;
    }
#endif

    if (!pTcpSocket)
    {
#ifdef XNET_FEATURE_TRACE
        if (ppkt->IsEsp())
            TraceSz3(pktWarn, "[DISCARD] No TCP socket listening on port %d from %s:%d",
                     NTOHS(pTcpHdr->_ipportDst), pIpHdr->_ipaSrc.Str(), NTOHS(pTcpHdr->_ipportSrc));
        else
            TraceSz3(pktRecv, "[DISCARD] No TCP socket listening on port %d from %s:%d",
                     NTOHS(pTcpHdr->_ipportDst), pIpHdr->_ipaSrc.Str(), NTOHS(pTcpHdr->_ipportSrc));
#endif

#if defined(XNET_FEATURE_ONLINE) && !defined(XNET_FEATURE_INSECURE)
        if (!ppkt->IsEsp())
        {
            // An insecure TCP packet will not be sent a RST because we want to be "stealthy" and
            // not let a PC get any sort of response from us by sending random TCP packets.

            return;
        }
#endif

        goto sendrst;
    }

    TraceTcpHdr(pktRecv, pTcpSocket, pTcpHdr, cbHdrLen - sizeof(CTcpHdr), cbData);

    if (pTcpSocket->IsSyncState() && (pTcpHdr->_bFlags & TCP_CONTROLS) == 0)
    {
        // Common case of receiving data in a synchronized state

        pTcpSocket = TcpRecvData(pTcpSocket, pTcpHdr, pbData, cbData);

        goto rcvdone;
    }

    if (pTcpSocket->GetState() == TCPST_CLOSED)
    {
        TraceSz1(tcpWarn, "[%X.t] Received packet on closed socket.  Sending RST.", pTcpSocket);
        goto sendrst;
    }

    Assert(!pIpHdr->_ipaDst.IsBroadcast());
    Assert(!pIpHdr->_ipaSrc.IsBroadcast());

    isAck = ISTCPSEG(pTcpHdr, ACK);

    switch (pTcpSocket->GetState())
    {
        case TCPST_LISTEN:

            if (ISTCPSEG(pTcpHdr, RST))
            {
                TraceSz1(pktRecv, "[%X.t] Received RST while in LISTEN state.  Packet discarded.",
                         pTcpSocket);
                return;
            }

            if (isAck)
            {
                TraceSz1(tcpWarn, "[%X.t] Received ACK while in LISTEN state.  Sending RST.",
                         pTcpSocket);
                goto sendrst;
            }

            if (!ISTCPSEG(pTcpHdr, SYN))
            {
                TraceSz1(tcpWarn, "[%X.t] Received non-SYN while in LISTEN state.  Packet discarded.",
                         pTcpSocket);
                return;
            }

            // Process an incoming connection request on a listening socket
            if (!TcpAcceptConnReqPassive(pTcpSocket, pTcpHdr, pIpHdr->_ipaSrc))
            {
                TraceSz1(tcpWarn, "[%X.t] Failed to accept connection on listening socket", pTcpSocket);
                goto sendrst;
            }
            break;

        case TCPST_SYN_SENT:

            if (isAck)
            {
                ack = SEG_ACK(pTcpHdr);

                if (!IsValidACK(pTcpSocket, ack))
                {
                    TraceSz1(tcpWarn, "[%X.t] Received bad ACK seq while in SYN_SENT state.  Sending RST.",
                             pTcpSocket);
                    goto sendrst;
                }
            }

            if (ISTCPSEG(pTcpHdr, RST))
            {
                if (isAck)
                {
                    TraceSz1(tcpWarn, "[%X.t] Received RST while in SYN_SENT state.  Resetting connection.",
                             pTcpSocket);
                    TcpReset(pTcpSocket, NETERR_CONNRESET);
                }
                else
                {
                    TraceSz1(tcpWarn, "[%X.t] Ignoring RST without ACK in SYN_SENT state.",
                             pTcpSocket);
                }
                return;
            }

            if (!ISTCPSEG(pTcpHdr, SYN))
            {
                TraceSz1(tcpWarn, "[%X.t] Ignoring non-SYN while in SYN_SENT state.",
                         pTcpSocket);
                return;
            }

            // Simultaneous active open
            if (!TcpAcceptConnReqActive(pTcpSocket, pTcpHdr))
            {
                TraceSz1(tcpWarn, "[%X.t] Failed to accept simultaneous connection", pTcpSocket);
                goto sendrst;
            }
            break;

        default:
        {
            TCPSEQ oldseq0 = SEG_SEQ(pTcpHdr);
            TCPSEQ oldseq1 = oldseq0 + SEG_LEN(pTcpHdr, cbData);
            TCPSEQ seq0, seq1;

            // Make sure the sequence number is correct.
            // If not and the incoming segment is not RST, we'll emit an ACK.
            if (!TcpValidateSeqs(pTcpSocket, oldseq0, oldseq1, &seq0, &seq1))
            {
                if (!ISTCPSEG(pTcpHdr, RST))
                {
                    NeedSendACKNow(pTcpSocket);
                }
                break;
            }

            // If RST is on, then we'll reset the connection:
            //  - if the socket corresponds to a pending connection
            //    request, then we'll just close it and destroy the CTcpSocket.
            if (ISTCPSEG(pTcpHdr, RST))
            {
                TcpReset(pTcpSocket, NETERR_CONNRESET);
                goto discard;
            }

            // If SYN is set, there is an error.
            // We send out a RST as well as reset the connection.
            if (ISTCPSEG(pTcpHdr, SYN))
            {
                if (oldseq0 == seq0)
                {
                    TcpReset(pTcpSocket, NETERR_CONNRESET);
                    goto sendrst;
                }

                goto discard;
            }

            if (!ISTCPSEG(pTcpHdr, ACK))
            {
                goto discard;
            }

            if (pTcpSocket->GetState() == TCPST_SYN_RECEIVED)
            {
                ack = SEG_ACK(pTcpHdr);

                if (!IsValidACK(pTcpSocket, ack))
                {
                    // The acknowledgement number is bad, emit an RST
                    goto sendrst;
                }

                // NOTE: The ACK for our SYN will be processed
                // inside the TcpProcessDataAck call below.
                TcpConnectionEstablished(pTcpSocket, pTcpHdr);
            }

            // Process the data and acknowledgement information
            // and continue to process the FIN flag if necessary
            pTcpSocket = TcpRecvData(pTcpSocket, pTcpHdr, pbData, cbData);

            if (pTcpSocket && ISTCPSEG(pTcpHdr, FIN))
            {
                TcpProcessFIN(pTcpSocket, pTcpHdr, seq1-1);
            }
        }
        break;
    }

rcvdone:

    if (pTcpSocket && pTcpSocket->delayedAcks > 0)
    {
        // If we've delayed more than two maximum packets worth of data,
        // of if the receive window just closed, send an ACK now.

        if (    pTcpSocket->delayedAcks >= (pTcpSocket->rcv_mss << 1)
            ||  pTcpSocket->rcv_wnd == 0)
        {
            TcpEmitACK(pTcpSocket);
        }
        else
        {
            // If we aren't forced to send an ACK now, just queue up the timer and
            // wait for the very next tick.  This will come back anywhere from zero to
            // 200ms from now, depending on how far into a "tick" we happen to be.

            TimerSet(pTcpSocket->GetTimer(), TimerTick());
        }
    }
    return;

sendrst:

    // If the received segment is a RST, do nothing
    if ((pTcpHdr->_bFlags & TCP_RST) == 0) {
        TCPSEQ seq;
        BYTE flags;

        if (ISTCPSEG(pTcpHdr, ACK)) {
            ack = 0;
            seq = SEG_ACK(pTcpHdr);
            flags = 0;
        } else {
            ack = SEG_SEQ(pTcpHdr) + SEG_LEN(pTcpHdr, cbData);
            seq = 0;
            flags  = TCP_ACK;
        }

        TcpEmitRST(pTcpSocket, pIpHdr->_ipaSrc, pTcpHdr->_ipportSrc, pTcpHdr->_ipportDst,
                   seq, ack, flags);
        return;
    }

discard:
    return;
}

#ifdef XNET_FEATURE_TRACE

VOID CXnSock::TcpSetState(CTcpSocket* pTcpSocket, BYTE state, const CHAR* caller)
{
    static const CHAR* stateNames[] = {
        "CLOSED",
        "LISTEN",
        "SYN_SENT",
        "SYN_RECEIVED",
        "ESTABLISHED",
        "FIN_WAIT_1",
        "FIN_WAIT_2",
        "CLOSING",
        "TIME_WAIT",
        "CLOSE_WAIT",
        "LAST_ACK"
    };

    UINT oldstate = pTcpSocket->GetState();

    pTcpSocket->SetState(state);

    TraceSz7(tcpStat, "[%X.t] %s %d - %s:%d: %s => %s",
             pTcpSocket, caller, NTOHS(pTcpSocket->_ipportSrc),
             pTcpSocket->_ipaDst.Str(), NTOHS(pTcpSocket->_ipportDst),
             stateNames[oldstate], stateNames[state]);
}

#endif

BOOL CXnSock::TcpClose(CTcpSocket* pTcpSocket, BOOL forceful)

/*++

Routine Description:

    Close a TCP connection

Arguments:

    pTcpSocket - Points to the CTcpSocket structure
    forceful - Forceful close, always succeed and no wait

Return Value:

    TRUE if the CTcpSocket structure can be deleted immediately.
    FALSE if the connection is being gracefully closed
    and the CTcpSocket structure should be kept around until
    the connection is really closed.

--*/

{
    ICHECK(SOCK, UDPC|SDPC);

    //
    // Try to gracefully close the socket if requested by the caller
    //
    if (    !forceful
        &&  pTcpSocket->GetState() >= TCPST_SYN_RECEIVED
        &&  (!pTcpSocket->GetLingerOnOff() || pTcpSocket->GetLingerTimeout() > 0))
    {
        NTSTATUS status = TcpShutdown(pTcpSocket, SOCKF_NOMORE_XMIT|SOCKF_NOMORE_RECV, FALSE);

        if (NT_SUCCESS(status))
        {
            DWORD dwLingerSecs = pTcpSocket->GetLingerOnOff() ?
                                   pTcpSocket->GetLingerTimeout() :
                                   cfgSockLingerTimeoutInSeconds;

            // TIME-WAIT and linger timers are the same
            pTcpSocket->dwTickWait = TimerSetRelative(pTcpSocket->GetTimer(),
                dwLingerSecs * TICKS_PER_SECOND);

            return(FALSE);
        }
    }

    if (pTcpSocket->HasParent())
    {
        pTcpSocket->GetParent()->DequeueChild(pTcpSocket);
    }
    else
    {
        TcpTrimBacklog(pTcpSocket, 0);
    }

    TimerSet(pTcpSocket->GetTimer(), TIMER_INFINITE);

    return(TRUE);
}

VOID CXnSock::TcpTrimBacklog(CTcpSocket * pTcpSocket, UINT cBacklogMax)
{
    while (pTcpSocket->GetBacklog() > cBacklogMax)
    {
        CTcpSocket * pTcpSocketChild = pTcpSocket->GetLastChild();
        Assert(pTcpSocketChild != NULL);

        pTcpSocket->DequeueChild(pTcpSocketChild);
        SockClose(pTcpSocketChild, TRUE);
    }
}

NTSTATUS CXnSock::TcpShutdown(CTcpSocket* pTcpSocket, DWORD dwFlags, BOOL apicall)

/*++

Routine Description:

    Gracefully shutdown a TCP connection

Arguments:

    pTcpSocket - Points to the TCP control block
    flags - Shutdown flags: PCBFLAG_SEND_SHUTDOWN and/or PCBFLAG_RECV_SHUTDOWN
    apicall - Whether this is called by shutdown API

Return Value:

    Status code

--*/

{
    NTSTATUS status = NETERR_OK;

    RaiseToDpc();

    if ((dwFlags & SOCKF_NOMORE_RECV) && !pTcpSocket->TestFlags(SOCKF_NOMORE_RECV))
    {
        pTcpSocket->SetFlags(SOCKF_NOMORE_RECV);

        if (!pTcpSocket->IsTcpRecvBufEmpty())
        {
            //
            // If the receive buffer is not empty,
            // we'll send a RST to the connection peer
            // and reset the connection.
            //
            TcpResetPeer(pTcpSocket);
            status = apicall ? NETERR_OK : NETERR_CONNRESET;
            pTcpSocket = TcpReset(pTcpSocket, NETERR_CONNRESET);
            Assert(pTcpSocket != NULL);
        }
        else if (pTcpSocket->HasRecvReq())
        {
            // Cancel any pending overlapped receive requests
            TraceSz1(tcpStat, "[%X.t] TcpShutdown: Cancelling pending recv request", pTcpSocket);
            SockReqComplete(pTcpSocket, pTcpSocket->GetRecvReq(), NETERR(WSAESHUTDOWN));
        }
    }

    if ((dwFlags & SOCKF_NOMORE_XMIT) && !pTcpSocket->TestFlags(SOCKF_NOMORE_XMIT))
    {
        if (pTcpSocket->HasSendReq())
        {
            // Cancel any pending overlapped send requests
            TraceSz1(tcpStat, "[%X.t] TcpShutdown: Cancelling pending send request", pTcpSocket);
            SockReqComplete(pTcpSocket, pTcpSocket->GetSendReq(), NETERR(WSAESHUTDOWN));
        }

        switch (pTcpSocket->GetState()) {
        case TCPST_SYN_RECEIVED:
        case TCPST_ESTABLISHED:
            status = TcpEmitFIN(pTcpSocket);
            if (NT_SUCCESS(status)) {
                TcpSetState(pTcpSocket, TCPST_FIN_WAIT_1, "Shutdown");
                pTcpSocket->SetFlags(SOCKF_NOMORE_XMIT);
            }
            break;

        case TCPST_CLOSE_WAIT:
            status = TcpEmitFIN(pTcpSocket);
            if (NT_SUCCESS(status)) {
                TcpSetState(pTcpSocket, TCPST_LAST_ACK, "Shutdown");
                pTcpSocket->SetFlags(SOCKF_NOMORE_XMIT);
            }
            break;

        default:
            Assert(pTcpSocket->GetState() < TCPST_SYN_RECEIVED);
            status = NETERR(WSAENOTCONN);
            break;
        }
    }

    pTcpSocket->ClearFlags(SOCKF_REVIVABLE);

    return(status);
}

NTSTATUS CXnSock::TcpConnect(CTcpSocket* pTcpSocket, CIpAddr dstaddr, CIpPort dstport, BOOL synAck)

/*++

Routine Description:

    Make a TCP connection to the specified foreign address

Arguments:

    pTcpSocket - Points to the TCP control block
    dstaddr, dstport - Specifies the foreign address to connect to
    synAck - Whether we're acknowledging a received SYN request

Return Value:

    Status code

--*/

{
    NTSTATUS status;

    if (    dstport == 0
        ||  dstaddr == 0
        ||  dstaddr.IsBroadcast()
        ||  dstaddr.IsMulticast()
        || (dstaddr.IsLoopback() && dstaddr != IPADDR_LOOPBACK))
    {
        return(NETERR(WSAEADDRNOTAVAIL));
    }

    if (pTcpSocket->IsListenState())
        return NETERR_PARAM;

    // Bind to a local address if necessary
    if (!pTcpSocket->TestFlags(SOCKF_BOUND))
    {
        status = SockBind(pTcpSocket, 0);
        if (!NT_SUCCESS(status))
            return status;
    }

    RaiseToDpc();

    if (pTcpSocket->TestFlags(SOCKF_REVIVABLE))
    {
        // Revive a CTcpSocket that has been reset
        pTcpSocket->Dequeue();
        pTcpSocket->TcpInit(this);
        pTcpSocket->ClearFlags(SOCKF_CONNECT_SELECTED|SOCKF_REVIVABLE|SOCKF_NOMORE_RECV|SOCKF_NOMORE_XMIT|SOCKF_EVENT_MASK);
        EvtClear(pTcpSocket->GetEvent());
        pTcpSocket->SetStatus(NETERR_OK);
        pTcpSocket->Enqueue(&_leSockets);
    }
    else
    {
        status = pTcpSocket->GetStatus();
        if (!NT_SUCCESS(status))
            return(status);
    }

    if (!pTcpSocket->IsIdleState() && !synAck)
    {
        return(NETERR(WSAEALREADY));
    }

    // If this is an active open, go to SYN-SENT state.
    // Otherwise, we should already be in SYN-RECEIVED state.
    if (!synAck)
    {
        TcpSetState(pTcpSocket, TCPST_SYN_SENT, "Connect");
    }

    // Set up MSS to make sure we don't have to
    // fragment on the first hop. We assume the first hop
    // interface won't change during the life of the connection.
    pTcpSocket->rcv_mss = TCP_MAXIMUM_MSS;
    pTcpSocket->_cbMaxRecvBuf = 
        ((pTcpSocket->_cbMaxRecvBuf + pTcpSocket->rcv_mss - 1) / pTcpSocket->rcv_mss) * pTcpSocket->rcv_mss;
    if (pTcpSocket->_cbMaxRecvBuf > (UINT)(cfgSockMaxRecvBufsizeInK * 1024))
        pTcpSocket->_cbMaxRecvBuf = (UINT)(cfgSockMaxRecvBufsizeInK * 1024);

    pTcpSocket->_ipaDst = dstaddr;
    pTcpSocket->_ipportDst = dstport;

    // Get the initial sequence number for a new TCP connection.

    LARGE_INTEGER time;
    HalQueryTsc(&time);
    pTcpSocket->snd_isn = (TCPSEQ)time.QuadPart;

    pTcpSocket->rcv_wnd = pTcpSocket->_cbMaxRecvBuf;
    Assert(pTcpSocket->IsTcpRecvBufEmpty());

    // send out a SYN or SYN/ACK segment
    return(TcpEmitSYN(pTcpSocket, synAck));
}

NTSTATUS CXnSock::TcpListen(CTcpSocket* pTcpSocket, INT cBacklog)

/*++

Routine Description:

    Switch a TCP socket into listening state

Arguments:

    pTcpSocket - Points to the TCP control block
    backlog - Maximum number of pending connections

Return Value:

    Status code

--*/

{
    if (!pTcpSocket->IsIdleState())
    {
        return(NETERR(WSAEISCONN));
    }
    
    RaiseToDpc();

    NTSTATUS status = pTcpSocket->GetStatus();
    if (!NT_SUCCESS(status))
        return(status);

    TcpSetState(pTcpSocket, TCPST_LISTEN, "Listen");

    if (cBacklog < 1)
        cBacklog = 1;
    else if (cBacklog > cfgSockMaxListenBacklog)
        cBacklog = cfgSockMaxListenBacklog;

    pTcpSocket->SetBacklogMax(cBacklog);

    TcpTrimBacklog(pTcpSocket, cBacklog);

    return(NETERR_OK);
}

// ---------------------------------------------------------------------------------------
// TcpRead
// ---------------------------------------------------------------------------------------

NTSTATUS CXnSock::TcpRead(CTcpSocket* pTcpSocket, CRecvReq* pRecvReq)

/*++

Routine Description:

    Handle a user request to receive data from a TCP socket

Arguments:

    pTcpSocket - Points to the TCP control block
    pRecvReq - Points to the receive request information

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    UINT oldrcvwnd;

    RaiseToDpc();

    // Only segments from the connection peer are accepted
    pRecvReq->SetFromAddrPort(pTcpSocket->_ipaDst, pTcpSocket->_ipportDst);
    SecRegSetOwned(pTcpSocket->_ipaDst);
    *pRecvReq->bytesRecv = 0;

    if (!pTcpSocket->IsTcpRecvBufEmpty()) {

        // If the receive buffer is not empty, return as much data
        // as possible from the receive buffer.

        (*pRecvReq->bytesRecv) += TcpCopyRecvData(pTcpSocket, pRecvReq);
        status = NETERR_OK;

        // If the receive window was closed and there is
        // now enough free spce in the receive buffer,
        // then we'll send out a gratuitous ACK here.

        oldrcvwnd = pTcpSocket->rcv_wnd;
        TcpSlideRecvWindow(pTcpSocket, 0);
        if (oldrcvwnd < pTcpSocket->rcv_swsthresh &&
            pTcpSocket->rcv_wnd >= pTcpSocket->rcv_swsthresh) {
            TcpEmitACK(pTcpSocket);
        }
    } else if (pTcpSocket->IsFinReceived()) {
        // The connection has been gracefully closed
        status = NETERR_OK;
    } else {
        status = pTcpSocket->GetStatus();
        if (NT_SUCCESS(status)) {
            status = RecvReqEnqueue(pTcpSocket, pRecvReq);
        }
    }

    return(status);
}

//
// Copy data from the CTcpSocket receive buffer to the user's receive buffer
//
UINT CXnSock::TcpCopyRecvData(CTcpSocket* pTcpSocket, CRecvReq* pRecvReq)
{
    CTcpRecvBuf* recvbuf;
    UINT copycnt, total = 0;
    BYTE tcpflags = 0;

    do {
        recvbuf = (CTcpRecvBuf *) pTcpSocket->GetRecvBufFirst();
        Assert(SEQ_LE(recvbuf->seqnext, pTcpSocket->rcv_nxt));

        copycnt = min(recvbuf->GetCbBuf(), pRecvReq->buflen);
        memcpy(pRecvReq->buf, (BYTE*) recvbuf + recvbuf->dataoffset, copycnt);
        total += copycnt;
        pTcpSocket->SetCbRecvBuf(pTcpSocket->GetCbRecvBuf() - copycnt);
        pRecvReq->buf += copycnt;
        pRecvReq->buflen -= copycnt;

        tcpflags |= recvbuf->tcpflags;
        if (copycnt == recvbuf->GetCbBuf())
        {
            pTcpSocket->DequeueRecvBuf(recvbuf);
            PoolFree(recvbuf);
        }
        else
        {
            recvbuf->dataoffset = (WORD) (recvbuf->dataoffset + copycnt);
            recvbuf->DecCbBuf(copycnt);
        }
    } while (pRecvReq->buflen && !pTcpSocket->IsTcpRecvBufEmpty());

    if (tcpflags & (TCP_PSH|TCP_URG))
        pRecvReq->buflen = 0;

    return total;
}

// ---------------------------------------------------------------------------------------
// TcpSend
// ---------------------------------------------------------------------------------------

NTSTATUS CXnSock::TcpSend(CTcpSocket* pTcpSocket, CSendReq * pSendReq, UINT uiFlags)

/*++

Routine Description:

    Handle a user request to send data from a TCP socket

Arguments:

    pTcpSocket - Points to the TCP control block
    pSendReq - Points to the send request information

Return Value:

    Status code

Note:

    This function always return immediately. For blocking operation,
    we assume the caller has taken care of any necessary wait.

--*/

{
    NTSTATUS status = NETERR_OK;
    CPacket* pkt = NULL;
    WSABUF* bufs = pSendReq->bufs;
    UINT bytesToSend = pSendReq->sendtotal;
    UINT mss = pTcpSocket->snd_mss;
    UINT n, datalen;
    BYTE* data;

    // Make sure we don't overflow the send buffer too much.
    // In the following case:
    //  old pTcpSendBuf size + the datagram size > max pTcpSendBuf size
    // we'll temporarily exceed the send buffer size limit a little bit.
    Assert(!pTcpSocket->IsSendBufFull());
    Assert(pTcpSocket->_cbMaxSendBuf >= pTcpSocket->GetCbSendBuf());
    n = pTcpSocket->_cbMaxSendBuf - pTcpSocket->GetCbSendBuf();
    if (bytesToSend > max(n, mss))
        pSendReq->sendtotal = bytesToSend = mss;

    data = (BYTE *)bufs->buf;
    datalen = bufs->len;

    while (bytesToSend > 0)
    {
        UINT segsize = min(mss, bytesToSend);
        BYTE* p;

        pkt = TcpPacketAlloc(pTcpSocket, pTcpSocket->_ipaDst, uiFlags, segsize, sizeof(CTcpSendBuf), (PFNPKTFREE)TcpPacketFree);

        if (!pkt)
        {
            if ((pSendReq->sendtotal -= bytesToSend) == 0)
            {
                // If we've already send out some data,
                // then return success with partial byte count.
                // Otherwise, return error code.
                status = NETERR_MEMORY;
            }
            break;
        }

        bytesToSend -= segsize;
        p = (BYTE *)pkt->GetTcpHdr() + sizeof(CTcpHdr);
        if (segsize <= datalen)
        {
            // Fast case: all the data for this segment
            // comes from the same user buffer.
            memcpy(p, data, segsize);
            data += segsize;
            datalen -= segsize;
        }
        else
        {
            // Slow case: need to gather data for this segment
            // from multiple user buffers.
            
            UINT segremain = segsize;

            while (segremain)
            {
                while (datalen == 0)
                {
                    bufs++;
                    data = (BYTE *)bufs->buf;
                    datalen = bufs->len;
                }
                n = min(segremain, datalen);
                memcpy(p, data, n);
                p += n;
                data += n;
                datalen -= n;
                segremain -= n;
            }
        }

        {
            RaiseToDpc();

            status = pTcpSocket->GetStatus();

            if (NT_SUCCESS(status))
            {
                TcpQueueSegment(pTcpSocket, pkt, (BYTE)(bytesToSend ? TCP_ACK : (TCP_ACK|TCP_PSH)),
                                segsize);
            }
            else
            {
                PacketFree(pkt);
                break;
            }
        }
    }

    // If the app calls connect() on a non-blocking socket, and then calls send()
    // without calling select(), then we need to reset the connectSelected flag
    // so future select() calls will ignore SOCKF_EVENT_CONNECT.

    pTcpSocket->SetFlags(SOCKF_CONNECT_SELECTED);

    return(status);
}

CPacket * CXnSock::TcpPacketAlloc(CTcpSocket * pTcpSocket, CIpAddr ipaDst, UINT uiFlags, UINT cbDat, UINT cbPkt, PFNPKTFREE pfn)
{
    Assert((uiFlags & ~PKTF_POOLALLOC) == 0);

    uiFlags |= PKTF_TYPE_TCP;

    if (ipaDst.IsSecure())
    {
        uiFlags |= PKTF_TYPE_ESP|PKTF_CRYPT;
    }
    else
    {
    #ifdef XNET_FEATURE_ONLINE
        if (pTcpSocket && pTcpSocket->TestFlags(SOCKF_INSECURE))
        {
            uiFlags |= PKTF_XMIT_INSECURE;
        }
    #endif
    }

    return(PacketAlloc(PTAG_CTcpPacket, uiFlags, cbDat, cbPkt, pfn));
}

void CXnSock::TcpPacketFree(CPacket * ppkt)
{
    ICHECK(SOCK, UDPC|SDPC);

    if (((CTcpSendBuf *)ppkt)->Release() == 0)
    {
        PacketFree(ppkt);
    }
}

void CXnSock::TcpQueueSegment(CTcpSocket* pTcpSocket, CPacket* pkt, BYTE tcpflags, UINT datalen)

/*++

Routine Description:

    Initialize the header information for an outgoing TCP packet

Arguments:

    pTcpSocket - Points to the TCP control block
    pkt - Points to the outgoing TCP packet
    tcpflags - Specifies the TCP segment flags

Return Value:

    NONE

--*/

{
    TCHECK(UDPC|SDPC);

    CTcpSendBuf* pTcpSendBuf = (CTcpSendBuf *)pkt;
    pTcpSendBuf->Init(pTcpSocket, 0, 1);
    pTcpSendBuf->retries = 0;
    pTcpSendBuf->tcpflags = tcpflags;
    pTcpSendBuf->tcphdrlen = (BYTE) ((tcpflags & TCP_SYN) ?
                                    sizeof(CTcpHdr)+SYNTCPOPTLEN :
                                    sizeof(CTcpHdr));
    pTcpSendBuf->seq = pTcpSocket->snd_end;

    if (tcpflags & (TCP_SYN|TCP_FIN))
    {
        Assert(datalen == 0);
        pTcpSendBuf->seqnext = pTcpSendBuf->seq + 1;
    }
    else
    {
        pTcpSendBuf->SetCbBuf(datalen);
        pTcpSendBuf->seqnext = pTcpSendBuf->seq + datalen;
    }

    pTcpSocket->snd_end = pTcpSendBuf->seqnext;

    pTcpSocket->IncCbSendBuf(pTcpSendBuf->GetCbBuf());
    pTcpSocket->EnqueueSendBuf(pTcpSendBuf);

    if (pTcpSocket->GetSendBufPtr() == NULL)
    {
        pTcpSocket->SetSendBufPtr(pTcpSendBuf);
        TcpStartOutput(pTcpSocket);
    }
}

BOOL CXnSock::TcpStartOutput(CTcpSocket* pTcpSocket)

/*++

Routine Description:

    Called when we have buffered data to send on a TCP socket. 

Arguments:

    pTcpSocket - Points to the TCP control block
    pTcpSendBuf - Specifies the segment to be sent

Return Value:

    TRUE if a segment was sent; FALSE otherwise.

--*/

{
    TCHECK(UDPC|SDPC);

    INT sndwndAvail;
    CTcpSendBuf* pTcpSendBuf;
    TCPSEQ cwndmax, swndmax;

    pTcpSendBuf = pTcpSocket->GetSendBufPtr();
    Assert(pTcpSocket->snd_nxt == pTcpSendBuf->seq);
    Assert(pTcpSendBuf->retries == 0);

    // We always send SYN or FIN segments without delay
    if (pTcpSendBuf->GetCbBuf() == 0)
        goto sendnow;

    // NOTE: We're using signed integer here in case
    // the send window was shrunk by the receiver.
    swndmax = pTcpSocket->snd_wl2 + pTcpSocket->snd_wnd;
    cwndmax = pTcpSocket->snd_una + pTcpSocket->snd_cwnd;
    sndwndAvail = (SEQ_LE(swndmax, cwndmax) ? swndmax : cwndmax) - pTcpSocket->snd_nxt;

    if ((INT) pTcpSendBuf->GetCbBuf() <= sndwndAvail) {
        // Send window is large enough. Perform send-side
        // SWS avoidance. Note that if the PSH flag is not set,
        // then we must be sending a full-sized data segment.
        // Check the logic in TcpSend().

        // BUGBUG: Since we don't yet combine data from
        // multiple send calls into a single segment, it's
        // meaningless to delay the send.
        goto sendnow;
    }

    // Cannot send due to window constraints
    //  set up persist timers
    if (pTcpSocket->snd_nxt == pTcpSocket->snd_una)
    {
        TraceSz1(tcpStat, "[%X.t] Setting persist timer...", pTcpSocket);
        pTcpSocket->SetFlags(SOCKF_PERSIST);
        pTcpSocket->dwTickXmit = TimerSetRelative(pTcpSocket->GetTimer(), max(pTcpSocket->RTO, (UINT)(cfgSockPersistTimeoutInSeconds * TICKS_PER_SECOND)));
    }
    return FALSE;

sendnow:

    // Use this segment to measure round-trip time if possible
    pTcpSocket->ClearFlags(SOCKF_PERSIST);
    if (pTcpSocket->rtt_tick == 0) {
        pTcpSocket->rtt_tick = TimerTick();
        pTcpSocket->rtt_seq = pTcpSendBuf->seq;
    }
    
    pTcpSendBuf->firstSendTime = TimerTick();
    TcpSendSegment(pTcpSocket, pTcpSendBuf, pTcpSendBuf->retries != 0);
    pTcpSocket->snd_nxt = pTcpSendBuf->seqnext;
    pTcpSocket->SetSendBufPtr((CTcpSendBuf *)pTcpSocket->GetSendBufNext(pTcpSendBuf));
    return(TRUE);
}

void CXnSock::TcpSendSegment(CTcpSocket* pTcpSocket, CTcpSendBuf* pTcpSendBuf, BOOL fRetransmit)
{
    if (!pTcpSendBuf->IsActive())
    {
        CPacket * ppkt = pTcpSendBuf;

        pTcpSocket->delayedAcks = 0;

        Assert(     (pTcpSendBuf->tcpflags & TCP_FIN)
               ||   pTcpSocket->TestFlags(SOCKF_PERSIST)
               ||   SEQ_LE(pTcpSendBuf->seq, TcpSndNxt(pTcpSocket)));

        // If this packet is encrypted, we need to make sure it decrypts properly before
        // attempting to retransmit.  If it fails for any reason, just continue without
        // retransmitting and allow the timeouts to reset the socket.

        if (    !fRetransmit
            ||  !ppkt->IsEsp()
            ||  !ppkt->IsCrypt()
            ||  IpDecrypt(ppkt, pTcpSocket->_ipaDst))
        {
            CTcpHdr * pTcphdr   = ppkt->GetTcpHdr();
            pTcphdr->SetHdrLen(pTcpSendBuf->tcphdrlen);
            pTcphdr->_ipportSrc = pTcpSocket->_ipportSrc;
            pTcphdr->_ipportDst = pTcpSocket->_ipportDst;
            pTcphdr->_dwSeqNum  = HTONL(pTcpSendBuf->seq),
            pTcphdr->_dwAckNum  = HTONL(pTcpSocket->rcv_nxt);
            pTcphdr->_bFlags    = (BYTE)pTcpSendBuf->tcpflags;
            pTcphdr->_wWindow   = HTONS((WORD)pTcpSocket->rcv_wnd);
            pTcphdr->_wUrgent   = 0;
            pTcphdr->_wChecksum = 0;

            pTcpSendBuf->AddRef();

            TraceTcpHdr(pktXmit, pTcpSocket, pTcphdr, pTcpSendBuf->tcphdrlen - sizeof(CTcpHdr), pTcpSendBuf->GetCbBuf());
            IpFillAndXmit(ppkt, pTcpSocket->_ipaDst, IPPROTOCOL_TCP, &pTcpSocket->_prte);
        }
    }

    if (pTcpSendBuf == pTcpSocket->GetSendBufFirst())
    {
        // Set up the retransmisssion or persist timer

        UINT minTimeout = pTcpSocket->TestFlags(SOCKF_PERSIST) ?
                            cfgSockPersistTimeoutInSeconds :
                            cfgSockRexmitMinTimeoutInSeconds;

        minTimeout *= TICKS_PER_SECOND;

        pTcpSocket->dwTickXmit = (pTcpSocket->RTO << pTcpSendBuf->retries);
        if (pTcpSocket->dwTickXmit < minTimeout)
            pTcpSocket->dwTickXmit = minTimeout;
        if (pTcpSocket->dwTickXmit > (UINT)cfgSockRexmitMaxTimeoutInSeconds * TICKS_PER_SECOND)
            pTcpSocket->dwTickXmit = (UINT)cfgSockRexmitMaxTimeoutInSeconds * TICKS_PER_SECOND;

        pTcpSocket->dwTickXmit = TimerSetRelative(pTcpSocket->GetTimer(), pTcpSocket->dwTickXmit);
    }

    pTcpSendBuf->retries++;
}

// ---------------------------------------------------------------------------------------
// CTcpSocket
// ---------------------------------------------------------------------------------------

void CTcpSocket::EnqueueChild(CTcpSocket * pTcpSocketChild)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(_pTcpSocketParent == NULL);
    Assert(pTcpSocketChild->_pTcpSocketParent == NULL);

    _bBacklog += 1;
    pTcpSocketChild->_pTcpSocketParent = this;

    AssertList(&_le);
    InsertTailList(&_le, &pTcpSocketChild->_le);

    // Copy the local address bindings
    pTcpSocketChild->SetFlags(GetFlags() | SOCKF_BOUND, SOCKF_OPT_MASK | SOCKF_BOUND);
    pTcpSocketChild->_ipportSrc      = _ipportSrc;
    pTcpSocketChild->_uiSendTimeout  = _uiSendTimeout;
    pTcpSocketChild->_uiRecvTimeout  = _uiRecvTimeout;
    pTcpSocketChild->_cbMaxSendBuf   = _cbMaxSendBuf;
    pTcpSocketChild->_cbMaxRecvBuf   = _cbMaxRecvBuf;
    pTcpSocketChild->_Linger         = _Linger;
}

void CTcpSocket::DequeueChild(CTcpSocket * pTcpSocketChild)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);

    Assert(_pTcpSocketParent == NULL);
    Assert(pTcpSocketChild->_pTcpSocketParent == this);

    AssertListEntry(&_le, &pTcpSocketChild->_le);
    RemoveEntryList(&pTcpSocketChild->_le);
    InitializeListHead(&pTcpSocketChild->_le);
    pTcpSocketChild->_pTcpSocketParent = NULL;

    Assert(_bBacklog > 0);
    _bBacklog -= 1;
}

CTcpSocket * CTcpSocket::GetConnectedChild()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    
    Assert(_pTcpSocketParent == NULL);

    CTcpSocket * pTcpSocketChild = GetFirstChild();
    while (pTcpSocketChild && !pTcpSocketChild->TestFlags(SOCKF_CONNECTED))
        pTcpSocketChild = GetNextChild(pTcpSocketChild);

    return(pTcpSocketChild);
}

CTcpSocket * CTcpSocket::DequeueConnectedChild()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);

    CTcpSocket * pTcpSocketChild = GetConnectedChild();

    if (pTcpSocketChild)
    {
        DequeueChild(pTcpSocketChild);
    }

    return(pTcpSocketChild);
}

void CSocket::InsertRecvBuf(CRecvBuf * pRecvBuf, CRecvBuf * pRecvBufPrev)
{
    ICHECK_(GetXnBase(), SOCK, SDPC);
    Assert(offsetof(CRecvBuf, _le) == 0);
    Assert(pRecvBuf != NULL);

    AssertList(&_leRecvBufs);

    if (pRecvBufPrev == NULL)
    {
        InsertHeadList(&_leRecvBufs, &pRecvBuf->_le);
    }
    else
    {
        pRecvBuf->_le.Flink = pRecvBufPrev->_le.Flink;
        pRecvBuf->_le.Blink = &pRecvBufPrev->_le;
        pRecvBufPrev->_le.Flink->Blink = &pRecvBuf->_le;
        pRecvBufPrev->_le.Flink = &pRecvBuf->_le;
        AssertList(&_leRecvBufs);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\xn.h ===
// ---------------------------------------------------------------------------------------
// xn.h
//
// Exported shared definitions for use by xnet.lib and xonline.lib
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef __XN_H__
#define __XN_H__

#ifndef __cplusplus
#error "xn.h must only be included by a C++ file"
#endif

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

#define INLINE __forceinline

#if DBG
#define IFDBG(x)    x
#define IFNDBG(x)
#else
#define IFDBG(x)
#define IFNDBG(x)   x
#endif

// ---------------------------------------------------------------------------------------
// Asserts
// ---------------------------------------------------------------------------------------

INLINE void DbgBreak()
{
    _asm int 3;
}

#ifdef XNET_FEATURE_ASSERT
#ifdef _XBOX
#define DbgAssert(expr,file,line,msg) RtlAssert((PVOID)((msg)?(msg):(expr)),file,line,NULL)
#else
int DbgAssertPop(const char * pszExpr, const char * pszFile, int iLine, const char * pszMsg);
#define DbgAssert(expr,file,line,msg) do { if (DbgAssertPop(expr,file,line,msg)) { DbgBreak(); } } while (0)
#endif
char * __cdecl DbgAssertFmt(char const * pszFmt, ...);
#define ASSERT_BEG(x)   do { if (!(x)) { char * __pch__ = DbgAssertFmt(
#define ASSERT_END(x)   ); DbgAssert(#x,__FILE__,__LINE__,__pch__); } } while (0)
#define Assert(x) \
        do { if (!(x)) { DbgAssert(#x,__FILE__,__LINE__,NULL); } } while (0)
#define AssertSz(x,sz) \
        ASSERT_BEG(x) sz ASSERT_END(x)
#define AssertSz1(x,sz,a1) \
        ASSERT_BEG(x) sz,a1 ASSERT_END(x)
#define AssertSz2(x,sz,a1,a2) \
        ASSERT_BEG(x) sz,a1,a2 ASSERT_END(x)
#define AssertSz3(x,sz,a1,a2,a3) \
        ASSERT_BEG(x) sz,a1,a2,a3 ASSERT_END(x)
#define AssertSz4(x,sz,a1,a2,a3,a4) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4 ASSERT_END(x)
#define AssertSz5(x,sz,a1,a2,a3,a4,a5) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4,a5 ASSERT_END(x)
#define AssertSz6(x,sz,a1,a2,a3,a4,a5,a6) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6 ASSERT_END(x)
#define AssertSz7(x,sz,a1,a2,a3,a4,a5,a6,a7) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6,a7 ASSERT_END(x)
#define AssertSz8(x,sz,a1,a2,a3,a4,a5,a6,a7,a8) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6,a7,a8 ASSERT_END(x)
#define AssertSz9(x,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9 ASSERT_END(x)
#define AssertList(ple) \
        do { const char * __psz__ = DbgVerifyList(ple,NULL); \
        if (__psz__) { DbgAssert("AssertList("#ple")",__FILE__,__LINE__,__psz__); } } while (0)
#define AssertListEntry(ple,pleReq) \
        do { const char * __psz__ = DbgVerifyList(ple,pleReq); \
        if (__psz__) { DbgAssert("AssertListEntry("#ple","#pleReq")",__FILE__,__LINE__,__psz__); } } while (0)
#else
#define Assert(x)
#define AssertSz(x,sz)
#define AssertSz1(x,sz,a1)
#define AssertSz2(x,sz,a1,a2)
#define AssertSz3(x,sz,a1,a2,a3)
#define AssertSz4(x,sz,a1,a2,a3,a4)
#define AssertSz5(x,sz,a1,a2,a3,a4,a5)
#define AssertSz6(x,sz,a1,a2,a3,a4,a5,a6)
#define AssertSz7(x,sz,a1,a2,a3,a4,a5,a6,a7)
#define AssertSz8(x,sz,a1,a2,a3,a4,a5,a6,a7,a8)
#define AssertSz9(x,sz, a1,a2,a3,a4,a5,a6,a7,a8,a9)
#define AssertList(ple)
#define AssertListEntry(ple,pleReq)
#endif

#undef  ASSERT
#define ASSERT(x)   Assert(x)

// ---------------------------------------------------------------------------------------
// Traces
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_TRACE
void __cdecl DbgTrace(const char * szTag, const char * szFmt, ...);
#ifdef XNET_FEATURE_XBDM_SERVER
#define Tag(t)  m_##t
#else
#define Tag(t)  t_##t
#endif
#if defined(_XBOX) || !defined(__cplusplus)
#define TAGINIT(t)
#else
class CTagInit { public: CTagInit(int * pi, const char * pszTag); int i; };
#define TAGINIT(t)          ; CTagInit __init__##t(&Tag(t),#t)
#endif
#define TAG_ENABLE      1
#define TAG_BREAK       2
#define DefineTag(t,i)      int Tag(t) = i TAGINIT(t)
#define ExternTag(t)        extern int Tag(t)
#define TRACE_BEG(t)        do { if (Tag(t) > 0) { DbgTrace(#t,
#define TRACE_END(t)        ); if (Tag(t) > 1) DbgBreak(); } } while (0)
#define TraceSz(t,sz) \
        TRACE_BEG(t) sz TRACE_END(t)
#define TraceSz1(t,sz,a1) \
        TRACE_BEG(t) sz,a1 TRACE_END(t)
#define TraceSz2(t,sz,a1,a2) \
        TRACE_BEG(t) sz,a1,a2 TRACE_END(t)
#define TraceSz3(t,sz,a1,a2,a3) \
        TRACE_BEG(t) sz,a1,a2,a3 TRACE_END(t)
#define TraceSz4(t,sz,a1,a2,a3,a4) \
        TRACE_BEG(t) sz,a1,a2,a3,a4 TRACE_END(t)
#define TraceSz5(t,sz,a1,a2,a3,a4,a5) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5 TRACE_END(t)
#define TraceSz6(t,sz,a1,a2,a3,a4,a5,a6) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6 TRACE_END(t)
#define TraceSz7(t,sz,a1,a2,a3,a4,a5,a6,a7) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7 TRACE_END(t)
#define TraceSz8(t,sz,a1,a2,a3,a4,a5,a6,a7,a8) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8 TRACE_END(t)
#define TraceSz9(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9 TRACE_END(t)
#define TraceSz10(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10 TRACE_END(t)
#define TraceSz11(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11 TRACE_END(t)
#define TraceSz12(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12 TRACE_END(t)
#define TraceSz13(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13 TRACE_END(t)
#define TraceSz14(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14 TRACE_END(t)
#define TraceSz15(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15 TRACE_END(t)
#define TraceSz16(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16 TRACE_END(t)
#else
#define DefineTag(t,i)
#define ExternTag(t)
#define TraceSz(t,sz)
#define TraceSz1(t,sz,a1)
#define TraceSz2(t,sz,a1,a2)
#define TraceSz3(t,sz,a1,a2,a3)
#define TraceSz4(t,sz,a1,a2,a3,a4)
#define TraceSz5(t,sz,a1,a2,a3,a4,a5)
#define TraceSz6(t,sz,a1,a2,a3,a4,a5,a6)
#define TraceSz7(t,sz,a1,a2,a3,a4,a5,a6,a7)
#define TraceSz8(t,sz,a1,a2,a3,a4,a5,a6,a7,a8)
#define TraceSz9(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9)
#define TraceSz10(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
#define TraceSz11(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)
#define TraceSz12(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12)
#define TraceSz13(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13)
#define TraceSz14(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14)
#define TraceSz15(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15)
#define TraceSz16(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16)
#endif

ExternTag(Warning);
ExternTag(Verbose);

// ---------------------------------------------------------------------------------------
// Rip
// ---------------------------------------------------------------------------------------

#ifdef _XBOX
#define Rip(sz) RIP(sz)
#elif defined(XNET_FEATURE_ASSERT)
#define Rip(sz) AssertSz1(0, "RIP: %s", sz)
#else
#define Rip(sz) { DbgPrint("%s", sz); DbgBreak(); }
#endif

// ---------------------------------------------------------------------------------------
// Leak Tracker
// ---------------------------------------------------------------------------------------

typedef const char * (*PFNLEAKTAG)(ULONG tag);

struct CLeakInfo
{
    PFNLEAKTAG      _pfnLeakTag;
    BOOL            _fLeakDisable;
    UINT            _cLeakAlloc;
    UINT            _cLeak;
    struct CLeak *  _pLeak;
};

// ---------------------------------------------------------------------------------------
// VMem (Windows)
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_VMEM

struct VMEMINFO
{
    size_t      cb;
    DWORD       dwFlags;
    size_t      cbFill1;
    size_t      cbFill2;
    void *      pv;
};

#define     VMEM_CHECKED            0x00000001
#define     VMEM_ENABLED            0x00000002
#define     VMEM_BACKSIDESTRICT     0x00000004
#define     VMEM_BACKSIDEALIGN8     0x00000008

BOOL        VMemIsEnabled();
void *      VMemAlloc(size_t cb);
void        VMemFree(void * pv);

#endif

// ---------------------------------------------------------------------------------------
// Utilities
// ---------------------------------------------------------------------------------------

char * HexStr(const void * pv, size_t cb);

#define HTONL_(ul) \
    ((ULONG)((((ul) >> 24) & 0x000000FFL) | (((ul) >>  8) & 0x0000FF00L) | \
             (((ul) <<  8) & 0x00FF0000L) | (((ul) << 24))))

#define NTOHL_(ul) HTONL_(ul)

#define HTONS_(us) \
    ((USHORT)((((us) >> 8) & 0x00FF) | (((us) << 8) & 0xFF00)))

#define NTOHS_(us) HTONS_(us)

INLINE ULONG  HTONL(ULONG  ul) { return(HTONL_(ul)); }
INLINE ULONG  NTOHL(ULONG  ul) { return(NTOHL_(ul)); }
INLINE USHORT HTONS(USHORT us) { return(HTONS_(us)); }
INLINE USHORT NTOHS(USHORT us) { return(NTOHS_(us)); }

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

#define CBDHG1 96
extern "C" const BYTE g_abOakleyGroup1Mod[CBDHG1];
extern "C" const BYTE g_abOakleyGroup1Base[CBDHG1];

struct XOKERBINFO;

#define CBEVENTTIMER    (5 * sizeof(DWORD)) // sizeof(CEventTimer)

// ---------------------------------------------------------------------------------------
// Windows Support
// ---------------------------------------------------------------------------------------

#ifndef _XBOX
    typedef STRING OBJECT_STRING;
    #define RtlInitObjectString RtlInitAnsiString
    #define __OTEXT(quote) quote
    #define OTEXT(quote) __OTEXT(quote)
    #undef InitializeObjectAttributes
    #define InitializeObjectAttributes( p, n, a, r, s ) { (p)->RootDirectory = (r); (p)->Attributes = (a); (p)->ObjectName = (PUNICODE_STRING)(n); }
    #define XBOX_KEY_LENGTH 16
    #define XBOXAPI
    typedef struct _XINPUT_STATE * PXINPUT_STATE;
#endif

#include <xconfig.h>
#include <xonlinep.h>

// ---------------------------------------------------------------------------------------
// Online Support
// ---------------------------------------------------------------------------------------

#if defined(XNET_FEATURE_SG) || defined(XNET_FEATURE_ONLINE)

struct XOUSERINFO
{
    ULONGLONG       _qwUserId;              // User Id
    DWORD           _dwQFlags;              // Queue flags
    DWORD           _dwSeqQFlags;           // Sequence number of queue flags
    DWORD           _dwPState;              // Presence state
    XNKID           _xnkid;                 // Game session user is currently playing
    UINT            _cbData;                // Count of bytes of title data
    BYTE            _abData[MAX_TITLE_STATE_BYTES]; // Custom presence title data
};

#define XN_LOGON_STATE_IDLE         0x0000  // XnLogon not called yet
#define XN_LOGON_STATE_PENDING      0x0001  // XnLogon connection to SG is in progress
#define XN_LOGON_STATE_ONLINE       0x0002  // XnLogon connection to SG is successful
#define XN_LOGON_STATE_OFFLINE      0x0003  // XnLogon connection to SG has been lost

#endif

#ifdef XNET_FEATURE_ONLINE

struct XOKERBINFO
{
    BYTE            _abDhX[CBDHG1];         // Diffie-hellman X
    BYTE            _abDhGX[CBDHG1];        // Diffie-hellman g^X
    BYTE            _abKey[16];             // Session key from ticket
    DWORD           _dwTicketId;            // Ticket identifier
    UINT            _cbApReqMax;            // Maximum size of AP request
    DWORD           _dwUserPerm;            // User permutation and guest bits
};

class CXoBase : public CXNet
{

public:

    // Definitions -----------------------------------------------------------------------

    #define SO_INSECURE                 0x4001  // Special socket option to set socket insecure

    // XNet Support for XOnline ----------------------------------------------------------

    void            XnSetXoBase(CXoBase * pXoBase);
    INLINE void     XnSetInsecure(SOCKET s) { setsockopt(s, SOL_SOCKET, SO_INSECURE, (char *)this, sizeof(CXoBase *)); }
    void            XnLogon(IN_ADDR inaLogon, ULONGLONG * pqwUserId, WSAEVENT hEventLogon);
    DWORD           XnLogonGetStatus(SGADDR * psgaddr);
    BOOL            XnLogonGetQFlags(UINT iUserId, ULONGLONG * pqwUserId, DWORD * pdwQFlags, DWORD * pdwSeqQFlags);
    BOOL            XnLogonSetQFlags(UINT iUserId, DWORD dwQFlags, DWORD dwSeqQFlags);
    BOOL            XnLogonSetPState(UINT iUserId, DWORD dwPState, const XNKID * pxnkid, UINT cbData, BYTE * pbData);
    void            XnLogoff();

    void *          XnLeakAdd(CLeakInfo * pli, void * pv, UINT cb, ULONG tag);
    void *          XnLeakDel(CLeakInfo * pli, void * pv);
    void            XnLeakTerm(CLeakInfo * pli);

    void            XnSetEventTimer(BYTE * pbEventTimer, WSAEVENT hEvent, DWORD dwTimeout);
    void            XnRaiseToDpc(BOOL fRaise);

    // XOnline Support for XNet ----------------------------------------------------------

    BOOL            XoKerbBuildApReq(DWORD dwServiceId, LARGE_INTEGER * pliTime, BYTE * pbSha, UINT cbSha, BYTE * pbApReq, UINT * pcbApReq);
    BOOL            XoKerbCrackApRep(DWORD dwServiceId, LARGE_INTEGER * pliTime, BYTE * pbSha, UINT cbSha, BYTE * pbApRep, UINT cbApRep);
    void            XoKerbGetAuthData(XKERB_AD_XBOX * pAuthData);
    XOKERBINFO *    XoKerbGetInfo(DWORD dwServiceId);

};

#endif

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\libx\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\libxs\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\xnp.h ===
// ---------------------------------------------------------------------------------------
// xnp.h
//
// Private header file for the XNet Secure Networking Library
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef _XNP_H
#define _XNP_H

// ---------------------------------------------------------------------------------------
// To Do List
//
// @@@ Probing support
// @@@ DHCP rewrite (sync with XP client, gratuitous ARP, host name support, yank auto-ip)
// @@@ PPPoE support
// @@@ Network troubleshooter support
// ---------------------------------------------------------------------------------------

#pragma code_seg("XNET")
#pragma const_seg("XNET_RD")

// ---------------------------------------------------------------------------------------
// System Includes
// ---------------------------------------------------------------------------------------

#ifndef DBG
#define DBG 0
#endif

#ifdef _XBOX
    extern "C" {
        #include <ntos.h>
        #include <init.h>
        #include <hal.h>
        #include <nturtl.h>
        #include <xtl.h>
        #include <xboxp.h>
        #include <xdbg.h>
        #include <phy.h>
        #include <xbeimage.h>
        #include <ldr.h>
    };
#else
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <windows.h>
    #include <winsockx.h>
    #include <xboxp.h>
#endif

#include <winsockp.h>

// ---------------------------------------------------------------------------------------
// Configuration
// ---------------------------------------------------------------------------------------

#if DBG
    #define XNET_FEATURE_ASSERT
    #define XNET_FEATURE_TRACE
    #define XNET_FEATURE_STATS
#endif

#if defined(XNET_BUILD_LIBXS)
    #define XNET_FEATURE_XBOX
    #if DBG
        #pragma message("Building xnetsd.lib")
        #define XNET_FEATURE_XBDM_CLIENT
    #else
        #pragma message("Building xnets.lib")
    #endif
#elif defined(XNET_BUILD_LIBX)
    #define XNET_FEATURE_ARP
    #define XNET_FEATURE_DHCP
    #define XNET_FEATURE_DNS
    #define XNET_FEATURE_FRAG
    #define XNET_FEATURE_ICMP
    #define XNET_FEATURE_INSECURE
    #define XNET_FEATURE_ROUTE
    #define XNET_FEATURE_XBDM_CLIENT
    #define XNET_FEATURE_XBOX
    #if DBG
        #pragma message("Building xnetd.lib")
    #else
        #pragma message("Building xnet.lib")
    #endif
#elif defined(XNET_BUILD_LIBOS)
    #define XNET_FEATURE_ARP
    #define XNET_FEATURE_DHCP
    #define XNET_FEATURE_DNS
    #define XNET_FEATURE_FRAG
    #define XNET_FEATURE_ICMP
    #define XNET_FEATURE_ONLINE
    #define XNET_FEATURE_QOS
    #define XNET_FEATURE_ROUTE
    #define XNET_FEATURE_SG
    #define XNET_FEATURE_XBOX
    #if DBG
        #pragma message("Building xnetosd.lib")
        #define XNET_FEATURE_XBDM_CLIENT
    #else
        #pragma message("Building xnetos.lib")
    #endif
#elif defined(XNET_BUILD_LIBO)
    #define XNET_FEATURE_ARP
    #define XNET_FEATURE_DHCP
    #define XNET_FEATURE_DNS
    #define XNET_FEATURE_ICMP
    #define XNET_FEATURE_FRAG
    #define XNET_FEATURE_INSECURE
    #define XNET_FEATURE_ONLINE
    #define XNET_FEATURE_QOS
    #define XNET_FEATURE_ROUTE
    #define XNET_FEATURE_SG
    #define XNET_FEATURE_XBDM_CLIENT
    #define XNET_FEATURE_XBOX
    #if DBG
        #pragma message("Building xnetod.lib")
    #else
        #pragma message("Building xneto.lib")
    #endif
#elif defined(XNET_BUILD_LIBM)
    #define XNET_FEATURE_ARP
    #define XNET_FEATURE_DHCP
    #define XNET_FEATURE_ICMP
    #define XNET_FEATURE_FRAG
    #define XNET_FEATURE_INSECURE
    #define XNET_FEATURE_ROUTE
    #define XNET_FEATURE_XBDM_SERVER
    #define XNET_FEATURE_XBOX
    #if DBG
        #pragma message("Building xnetmd.lib")
    #else
        #pragma message("Building xnetm.lib")
    #endif
#elif defined(XNET_BUILD_LIBXW)
    #define XNET_FEATURE_ARP
    #define XNET_FEATURE_DHCP
    #define XNET_FEATURE_DNS
    #define XNET_FEATURE_FRAG
    #define XNET_FEATURE_FRAG_LOOPBACK
    #define XNET_FEATURE_ICMP
    #define XNET_FEATURE_INSECURE
    #define XNET_FEATURE_QOS
    #define XNET_FEATURE_ROUTE
    #define XNET_FEATURE_SG
    #define XNET_FEATURE_WINDOWS
    #define XNET_FEATURE_VIRTUAL
    #if DBG
        #pragma message("Building xnetwd.lib")
        #define XNET_FEATURE_VMEM
    #else
        #pragma message("Building xnetw.lib")
    #endif
#elif defined(XNET_BUILD_LIBOW)
    #define XNET_FEATURE_ARP
    #define XNET_FEATURE_DHCP
    #define XNET_FEATURE_DNS
    #define XNET_FEATURE_FRAG
    #define XNET_FEATURE_FRAG_LOOPBACK
    #define XNET_FEATURE_ICMP
    #define XNET_FEATURE_INSECURE
    #define XNET_FEATURE_ONLINE
    #define XNET_FEATURE_QOS
    #define XNET_FEATURE_ROUTE
    #define XNET_FEATURE_SG
    #define XNET_FEATURE_WINDOWS
    #define XNET_FEATURE_VIRTUAL
    #if DBG
        #pragma message("Building xnetwd.lib")
        #define XNET_FEATURE_VMEM
    #else
        #pragma message("Building xnetw.lib")
    #endif
#else
    #error "Don't know which xnet library to build"
#endif

#ifdef XNET_FEATURE_ARP
#pragma message("  XNET_FEATURE_ARP")
#endif

#ifdef XNET_FEATURE_ASSERT
#pragma message("  XNET_FEATURE_ASSERT")
#endif

#ifdef XNET_FEATURE_DHCP
#pragma message("  XNET_FEATURE_DHCP")
#endif

#ifdef XNET_FEATURE_DNS
#pragma message("  XNET_FEATURE_DNS")
#endif

#ifdef XNET_FEATURE_FRAG
#pragma message("  XNET_FEATURE_FRAG")
#endif

#ifdef XNET_FEATURE_FRAG_LOOPBACK
#pragma message("  XNET_FEATURE_FRAG_LOOPBACK")
#endif

#ifdef XNET_FEATURE_ICMP
#pragma message("  XNET_FEATURE_ICMP")
#endif

#ifdef XNET_FEATURE_INSECURE
#pragma message("  XNET_FEATURE_INSECURE")
#endif

#ifdef XNET_FEATURE_ONLINE
#pragma message("  XNET_FEATURE_ONLINE")
#endif

#ifdef XNET_FEATURE_QOS
#pragma message("  XNET_FEATURE_QOS")
#endif

#ifdef XNET_FEATURE_ROUTE
#pragma message("  XNET_FEATURE_ROUTE")
#endif

#ifdef XNET_FEATURE_SG
#pragma message("  XNET_FEATURE_SG")
#endif

#ifdef XNET_FEATURE_TRACE
#pragma message("  XNET_FEATURE_TRACE")
#endif

#ifdef XNET_FEATURE_VIRTUAL
#pragma message("  XNET_FEATURE_VIRTUAL")
#endif

#ifdef XNET_FEATURE_VMEM
#pragma message("  XNET_FEATURE_VMEM")
#endif

#ifdef XNET_FEATURE_WINDOWS
#pragma message("  XNET_FEATURE_WINDOWS")
#endif

#ifdef XNET_FEATURE_XBDM_CLIENT
#pragma message("  XNET_FEATURE_XBDM_CLIENT")
#endif

#ifdef XNET_FEATURE_XBDM_SERVER
#pragma message("  XNET_FEATURE_XBDM_SERVER")
#endif

#ifdef XNET_FEATURE_XBOX
#pragma message("  XNET_FEATURE_XBOX")
#endif

// ---------------------------------------------------------------------------------------
// Debugging
// ---------------------------------------------------------------------------------------

#include <xn.h>

ExternTag(LeakWarn);
ExternTag(pktXmit);
ExternTag(pktRecv);
ExternTag(pktBroadcast);
ExternTag(pktWarn);
ExternTag(secStat);
ExternTag(sock);
ExternTag(sockWarn);

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_VIRTUAL
#define VIRTUAL                 virtual
#define NOVTABLE
#define VPURE                   = 0
#else
#define NOVTABLE                __declspec(novtable)
#define VIRTUAL
#define VPURE
#endif

#define XNETPTAGLIST() \
    XNETPTAG(CXnHal,            'NET0') \
    XNETPTAG(CXnBase,           'NET1') \
    XNETPTAG(CXnNic,            'NET2') \
    XNETPTAG(CXnEnet,           'NET3') \
    XNETPTAG(CXnIp,             'NET4') \
    XNETPTAG(CXnSock,           'NET5') \
    XNETPTAG(CDhcpOptions,      'NET6') \
    XNETPTAG(CRouteEntry,       'NET7') \
    XNETPTAG(CSocket,           'NET8') \
    XNETPTAG(CUdpRecvBuf,       'NET9') \
    XNETPTAG(CTcpSocket,        'NETa') \
    XNETPTAG(CTcpRecvBuf,       'NETb') \
    XNETPTAG(CRecvReq,          'NETc') \
    XNETPTAG(CXmitReq,          'NETd') \
    XNETPTAG(Pool,              'NETe') \
    XNETPTAG(PoolStart,         'NETf') \
    XNETPTAG(PoolEnd,           'NETg') \
    XNETPTAG(select,            'NETh') \
    XNETPTAG(CArpPacket,        'NETi') \
    XNETPTAG(CDhcpPacket,       'NETj') \
    XNETPTAG(CIcmpEchoPacket,   'NETk') \
    XNETPTAG(CFragPacket,       'NETl') \
    XNETPTAG(CTcpPacket,        'NETm') \
    XNETPTAG(CUdpPacket,        'NETn') \
    XNETPTAG(CKeyReg,           'NETo') \
    XNETPTAG(CSecReg,           'NETp') \
    XNETPTAG(CKeyExPacket,      'NETq') \
    XNETPTAG(CPacket,           'NETr') \
    XNETPTAG(CXbdmPacket,       'NETs') \
    XNETPTAG(CDnsReg,           'NETt') \
    XNETPTAG(CDnsPacket,        'NETu') \
    XNETPTAG(CSecMsgPacket,     'NETv') \
    XNETPTAG(CXnNat,            'NETw') \
    XNETPTAG(CXnIpNat,          'NETx') \
    XNETPTAG(CDhcpLease,        'NETy') \
    XNETPTAG(CNatPacket,        'NETz') \
    XNETPTAG(CNatPort,          'NETA') \
    XNETPTAG(CNatFilt,          'NETB') \
    XNETPTAG(QosData,           'NETC') \

#undef  XNETPTAG
#define XNETPTAG(_name, _tag) PTAG_##_name = NTOHL_(_tag),

enum { XNETPTAGLIST() };

#define INITF_HAL               0x00000001
#define INITF_HAL_1             0x00000002
#define INITF_HAL_2             0x00000004
#define INITF_HAL_STOP          0x00000008
#define INITF_HAL_TERM          0x00000010
#define INITF_BASE              0x00000020
#define INITF_BASE_1            0x00000040
#define INITF_BASE_2            0x00000080
#define INITF_BASE_STOP         0x00000100
#define INITF_BASE_TERM         0x00000200
#define INITF_NIC               0x00000400
#define INITF_NIC_1             0x00000800
#define INITF_NIC_2             0x00001000
#define INITF_NIC_STOP          0x00002000
#define INITF_NIC_TERM          0x00004000
#define INITF_ENET              0x00008000
#define INITF_ENET_1            0x00010000
#define INITF_ENET_2            0x00020000
#define INITF_ENET_STOP         0x00040000
#define INITF_ENET_TERM         0x00080000
#define INITF_IP                0x00100000
#define INITF_IP_1              0x00200000
#define INITF_IP_2              0x00400000
#define INITF_IP_STOP           0x00800000
#define INITF_IP_TERM           0x01000000
#define INITF_SOCK              0x02000000
#define INITF_SOCK_1            0x04000000
#define INITF_SOCK_2            0x08000000
#define INITF_SOCK_STOP         0x10000000
#define INITF_SOCK_TERM         0x20000000
#define INITF_CONNECTED_BOOT    0x80000000

#define NETERR(_err)            HRESULT_FROM_WIN32(_err)
#define NETERR_OK               STATUS_SUCCESS
#define NETERR_PARAM            NETERR(WSAEINVAL)
#define NETERR_MEMORY           NETERR(WSAENOBUFS)
#define NETERR_SYSCALL          NETERR(WSASYSCALLFAILURE)
#define NETERR_FAULT            NETERR(WSAEFAULT)
#define NETERR_CANCELLED        NETERR(WSAECANCELLED)
#define NETERR_PENDING          NETERR(WSA_IO_PENDING)
#define NETERR_WOULDBLOCK       NETERR(WSAEWOULDBLOCK)
#define NETERR_MSGSIZE          NETERR(WSAEMSGSIZE)
#define NETERR_TIMEOUT          NETERR(WSAETIMEDOUT)
#define NETERR_NOTIMPL          NETERR(ERROR_CALL_NOT_IMPLEMENTED)
#define NETERR_UNREACHABLE      NETERR(WSAEHOSTUNREACH)
#define NETERR_NETDOWN          NETERR(WSAENETDOWN)
#define NETERR_ADDRINUSE        NETERR(WSAEADDRINUSE)
#define NETERR_ADDRCONFLICT     NETERR(ERROR_DHCP_ADDRESS_CONFLICT)
#define NETERR_CONNRESET        NETERR(WSAECONNRESET)

#define IPPROTOCOL_SECMSG       0
#define IPPROTOCOL_ICMP         1
#define IPPROTOCOL_TCP          6
#define IPPROTOCOL_UDP          17

#define DNS_SERVER_PORT         HTONS_(53)
#define DNS_CLIENT_PORT         HTONS_(53)
#define DHCP_CLIENT_PORT        HTONS_(68)
#define DHCP_SERVER_PORT        HTONS_(67)
#define ESPUDP_CLIENT_PORT      HTONS_(3074)

#define dimensionof(x)          (sizeof((x))/sizeof(*(x)))
#define BIT(n)                  (1u << (n))
#define ROUNDUP4(count)         (((count) + 3) & ~3)
#define ROUNDUP8(count)         (((count) + 7) & ~7)
#define IsListNull(_ple)        ((_ple)->Flink == NULL)

// ---------------------------------------------------------------------------------------
// XNetParams
// ---------------------------------------------------------------------------------------

#define XNETPARAMDEFS() \
    DEFINE_PARAM_( 0, cfgSizeOfStruct,                         0, 0,   0) \
    DEFINE_PARAM_( 1, cfgFlags,                                0, 0, 255) \
    DEFINE_PARAM_( 2, cfgPrivatePoolSizeInPages,              12, 4, 255) \
    DEFINE_PARAM_( 3, cfgEnetReceiveQueueLength,               8, 4, 255) \
    DEFINE_PARAM_( 4, cfgIpFragMaxSimultaneous,                4, 1, 255) \
    DEFINE_PARAM_( 5, cfgIpFragMaxPacketDiv256,                8, 4, 255) \
    DEFINE_PARAM_( 6, cfgSockMaxSockets,                      64, 1, 255) \
    DEFINE_PARAM_( 7, cfgSockDefaultRecvBufsizeInK,           16, 1,  63) \
    DEFINE_PARAM_( 8, cfgSockDefaultSendBufsizeInK,           16, 1,  63) \
    DEFINE_PARAM_( 9, cfgKeyRegMax,                            4, 1, 255) \
    DEFINE_PARAM_(10, cfgSecRegMax,                           32, 1, 255) \
    DEFINE_PARAM_(11, cfgQosDataLimitDiv4,                   128, 0, 255) \
    DEFINE_PARAM (    cfgEnetTransmitQueueLength,             10, 4, 255) \
    DEFINE_PARAM (    cfgEnetArpReqRetries,                    2, 1, 255) \
    DEFINE_PARAM (    cfgEnetArpRexmitTimeoutInSeconds,        1, 1, 255) \
    DEFINE_PARAM (    cfgEnetArpPosCacheTimeoutInMinutes,     10, 1, 255) \
    DEFINE_PARAM (    cfgEnetArpNegCacheTimeoutInMinutes,      1, 1, 255) \
    DEFINE_PARAM (    cfgIpFragTimeoutInSeconds,              60, 1, 255) \
    DEFINE_PARAM (    cfgIpDefaultTos,                         0, 0, 255) \
    DEFINE_PARAM (    cfgIpDefaultTtl,                        64, 1, 255) \
    DEFINE_PARAM (    cfgAutoIpMaxAttempts,                   10, 1, 255) \
    DEFINE_PARAM (    cfgAutoIpRexmitTimeoutInSeconds,         2, 1, 255) \
    DEFINE_PARAM (    cfgAutoIpRetriesPerAttempt,              2, 1, 255) \
    DEFINE_PARAM (    cfgDhcpRetryCount,                       3, 1, 255) \
    DEFINE_PARAM (    cfgDhcpRetryMaxTimeoutInSeconds,        10, 1, 255) \
    DEFINE_PARAM (    cfgDhcpDefaultLeaseTimeInDays,           0, 0, 255) \
    DEFINE_PARAM (    cfgDhcpRenewMinTimeoutInSeconds,        60, 1, 255) \
    DEFINE_PARAM (    cfgDhcpDeclineWaitInSeconds,            10, 1, 255) \
    DEFINE_PARAM (    cfgSockMaxListenBacklog,                 5, 1, 255) \
    DEFINE_PARAM (    cfgSockMaxSendBufsizeInK,               63, 1,  63) \
    DEFINE_PARAM (    cfgSockMaxRecvBufsizeInK,               63, 1,  63) \
    DEFINE_PARAM (    cfgSockSegmentLifetimeInSeconds,        30, 1, 255) \
    DEFINE_PARAM (    cfgSockConnectTimeoutInSeconds,         20, 1, 255) \
    DEFINE_PARAM (    cfgSockLingerTimeoutInSeconds,         120, 1, 255) \
    DEFINE_PARAM (    cfgSockRexmitRetries,                    5, 1, 255) \
    DEFINE_PARAM (    cfgSockRexmitTimeoutInSeconds,           3, 1, 255) \
    DEFINE_PARAM (    cfgSockRexmitMinTimeoutInSeconds,        1, 1, 255) \
    DEFINE_PARAM (    cfgSockRexmitMaxTimeoutInSeconds,        8, 1, 255) \
    DEFINE_PARAM (    cfgSockPersistTimeoutInSeconds,          5, 1, 255) \
    DEFINE_PARAM (    cfgKeyExXbToXbRexmitRetries,             9, 1, 255) \
    DEFINE_PARAM (    cfgKeyExXbToXbRexmitTimeoutInSeconds,    1, 1, 255) \
    DEFINE_PARAM (    cfgKeyExXbToSgRexmitRetries,             4, 1, 255) \
    DEFINE_PARAM (    cfgKeyExXbToSgRexmitTimeoutInSeconds,    2, 1, 255) \
    DEFINE_PARAM (    cfgDnsRetries,                           4, 1, 255) \
    DEFINE_PARAM (    cfgDnsTimeoutInSeconds,                  2, 1, 255) \
    DEFINE_PARAM (    cfgSecRegVisitInSeconds,                 5, 1, 255) \
    DEFINE_PARAM (    cfgSecRegPulseTimeoutInSeconds,         20, 1, 255) \
    DEFINE_PARAM (    cfgSecRegTimeoutInSecondsDiv10,         13, 1, 255) \

#define DEFINE_PARAM_(idx, name, def, min, max) BYTE name;
#define DEFINE_PARAM(name, def, min, max) BYTE name;

#include <pshpack1.h>
struct XNetParams { XNETPARAMDEFS() };
#include <poppack.h>

struct XNetInitParams
{
    XNetParams *    pxnp;
    char *          pszXbox;
    LARGE_INTEGER   liTime;
    BYTE            abSeed[20];
};

// ---------------------------------------------------------------------------------------
// CXnVoid
// ---------------------------------------------------------------------------------------

class NOVTABLE CXnVoid
{
    VIRTUAL void VoidInit() {};
};

// ---------------------------------------------------------------------------------------
// CXnHal
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_WINDOWS
#include "halw.h"
#endif

#ifdef XNET_FEATURE_XBOX
#include "halx.h"
#endif

#include <stdio.h>
#include <stddef.h>
#include <stdarg.h>

// ---------------------------------------------------------------------------------------
// Crypto
// ---------------------------------------------------------------------------------------

#include <xcrypt.h>

#ifdef XNET_FEATURE_ASSERT
#define XCRYPT_VERIFY(x)    do { BOOL __fOK__ = (x); if (!__fOK__) AssertSz(FALSE, "XCRYPT_SERVICE failed"); } while (0)
#else
#define XCRYPT_VERIFY(x)    x
#endif

// ---------------------------------------------------------------------------------------
// CTimer
// ---------------------------------------------------------------------------------------

typedef void (CXnVoid::*PFNPKTFREE)(class CPacket * ppkt);
typedef void (CXnVoid::*PFNTIMER)(class CTimer * pt);

class CTimer
{
    friend class CXnBase;

    // Definitions -------------------------------------------------------------------

    #define TICKS_PER_SECOND    5       // 200 ms per tick (25 years before DWORD wraps)
    #define MSEC_PER_TICK       (1000 / TICKS_PER_SECOND)
    #define TIMER_INFINITE      0xFFFFFFFF

    // External ----------------------------------------------------------------------

public:

    INLINE void Init(PFNTIMER pfn)  { _le.Flink = NULL; _pfn = pfn; _dwTick = TIMER_INFINITE; }
    INLINE BOOL IsActive()          { return(_le.Flink != NULL); }
    INLINE BOOL IsNull()            { return(_pfn == NULL); }

    // Data --------------------------------------------------------------------------

private:

    LIST_ENTRY  _le;
    DWORD       _dwTick;
    PFNTIMER    _pfn;

};

struct CEventTimer : public CTimer
{
    PRKEVENT    _pEvent;
};

C_ASSERT(sizeof(CEventTimer) == CBEVENTTIMER);

// ---------------------------------------------------------------------------------------
// CXnBase
// ---------------------------------------------------------------------------------------

struct CLeak
{
    void *  _pv;
    UINT    _cb;
    ULONG   _tag;
};

class NOVTABLE CXnBase : public CXnHal
{
    // Definitions -----------------------------------------------------------------------

public:

    #define MAX_SMALL_BLOCKS 5

private:

    // External --------------------------------------------------------------------------

public:

    HAL_DECLARE_NEW_DELETE(CXnBase)

    NTSTATUS        BaseInit(XNetInitParams * pxnip);
    void            BaseStart();
    void            BaseStop();
    void            BaseTerm();

    void *          LeakAdd(CLeakInfo * pli, void * pv, UINT cb, ULONG tag);
    void *          LeakDel(CLeakInfo * pli, void * pv);
    BOOL            LeakFind(CLeakInfo * pli, void * pv, CLeak ** ppLeak);
    void            LeakTerm(CLeakInfo * pli);

    void *          SysAlloc(size_t size, ULONG tag);
    void *          SysAllocZ(size_t size, ULONG tag);
    void            SysFree(void * pv);

    void *          PoolAlloc(size_t size, ULONG tag);
    void *          PoolAllocZ(size_t size, ULONG tag);
    void            PoolFree(void * pv);

    CPacket *       PacketAlloc(ULONG tag, UINT uiFlags, UINT cbPayload = 0, UINT cbPkt = 0, PFNPKTFREE pfn = NULL);
    void            PacketFree(CPacket * ppkt);

    void            Rand(BYTE * pb, UINT cb);
    ULONG           RandLong();
    INLINE ULONG    RandScaled(ULONG ulMax);

    void            TimerSet(CTimer * pt, DWORD dwTick);
    DWORD           TimerSetRelative(CTimer * pt, DWORD dwTicksFromNow);
    INLINE DWORD    TimerTick()         { TCHECK(UDPC|SDPC); return(_dwTick); }

    void            PushPktRecvTags(BOOL fBroadcast);
    void            PopPktRecvTags();

    VIRTUAL void    SecRegProbe() VPURE;
    VIRTUAL void    NicTimer() VPURE;

    // Internal --------------------------------------------------------------------------

private:

    void            RandInit(XNetInitParams * pxnip);

    void            PoolDump();

    static void     TimerDpc(PKDPC pkdpc, void * pvContext, void * pvParam1, void * pvParam2);
    void            TimerPush();

    // Data ------------------------------------------------------------------------------

public:

    XNETPARAMDEFS()

    void *          _pvPoolStart;
    void *          _pvPoolEnd;
    LIST_ENTRY      _aleFree[MAX_SMALL_BLOCKS + 1];
    BYTE            _abRandRc4Struct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];
    KDPC            _dpcTimer;
    KTIMER          _timerTimer;
    LIST_ENTRY      _leTimers;
    DWORD           _dwTickKe;
    DWORD           _dwTick;

#ifdef XNET_FEATURE_ASSERT
    CLeakInfo       _leakinfo;
#endif

#ifdef XNET_FEATURE_TRACE
    BYTE            _abPushPop[32];
    UINT            _cbPushPop;
    UINT            _cPushPopBroadcast;
    UINT            _pktRecvPushPop;
    UINT            _pktWarnPushPop;
#endif

private:

    static const XNetParams s_XNetParamsDef;
    static const XNetParams s_XNetParamsMin;
    static const XNetParams s_XNetParamsMax;

};

INLINE void * CXnBase::SysAlloc(size_t size, ULONG tag)
{
    ICHECK(BASE, USER|UDPC);
    void * pv = HalAlloc(size, tag);
#ifdef XNET_FEATURE_ASSERT
    LeakAdd(&_leakinfo, pv, size, tag);
#endif
    return(pv);
}

INLINE void * CXnBase::SysAllocZ(size_t size, ULONG tag)
{
    ICHECK(BASE, USER|UDPC);
    void * pv = HalAllocZ(size, tag);
#ifdef XNET_FEATURE_ASSERT
    LeakAdd(&_leakinfo, pv, size, tag);
#endif
    return(pv);
}

INLINE void CXnBase::SysFree(void * pv)
{
    ICHECK(BASE, USER|UDPC|SDPC);
#ifdef XNET_FEATURE_ASSERT
    LeakDel(&_leakinfo, pv);
#endif
    HalFree(pv);
}

INLINE ULONG CXnBase::RandScaled(ULONG ulMax)
{
    ICHECK(BASE, USER|UDPC|SDPC);
    return(RandLong() % (ulMax + 1));
}

#ifndef XNET_FEATURE_TRACE

INLINE void CXnBase::PushPktRecvTags(BOOL fBroadcast) {}
INLINE void CXnBase::PopPktRecvTags() {}

#endif

// ---------------------------------------------------------------------------------------
// Utilities
// ---------------------------------------------------------------------------------------

extern "C" UINT tcpipxsum(UINT xsum, const void * buf, UINT buflen);
const char * DbgVerifyList(LIST_ENTRY * ple, LIST_ENTRY * pleRequire);
char * XnAddrStr(const XNADDR * pxnaddr);
void XnInAddrToString(const IN_ADDR ina, char * pchBuf, INT cchBuf);

// Ethernet Address ----------------------------------------------------------------------

#include <pshpack1.h>

struct CEnetAddr
{
    BYTE _ab[6];

    INLINE BOOL IsEqual(const CEnetAddr & ea) const { return(memcmp(_ab, ea._ab, sizeof(_ab)) == 0); }
    INLINE BOOL IsEqual(const BYTE * pb) const { return(memcmp(_ab, pb, sizeof(_ab)) == 0); }
    INLINE void SetBroadcast()                { *(DWORD *)&_ab[0] = 0xFFFFFFFF; *(WORD *)&_ab[4] = 0xFFFF; }
    INLINE void SetZero()                     { *(DWORD *)&_ab[0] = 0x00000000; *(WORD *)&_ab[4] = 0x0000; }
    INLINE BOOL IsBroadcast() const           { return(*(DWORD *)&_ab[0] == 0xFFFFFFFF && *(WORD *)&_ab[4] == 0xFFFF); }
    INLINE BOOL IsMulticast() const           { return((_ab[0] & 1) != 0); }
    INLINE BOOL IsZero() const                { return(*(DWORD *)&_ab[0] == 0 && *(WORD *)&_ab[4] == 0); }
    char * Str() const;
};

#include <poppack.h>

// Ethernet Link Headers -----------------------------------------------------------------

#define ENET_LINK_MAXSIZE   ROUNDUP4(sizeof(CIeeeHdr))
#define ENET_DATA_MAXSIZE   1500
#define ENET_DATA_MINSIZE   42
#define ENET_TYPE_IP        HTONS_(0x0800)
#define ENET_TYPE_ARP       HTONS_(0x0806)

#include <pshpack1.h>

struct CEnetHdr
{
    CEnetAddr       _eaDst;
    CEnetAddr       _eaSrc;
    WORD            _wType;
};

struct CIeeeHdr : public CEnetHdr
{
    BYTE            _bDsap;         // 0xAA
    BYTE            _bSsap;         // 0xAA
    BYTE            _bControl;      // 0x03
    BYTE            _bOrgCode[3];   // 0x00 0x00 0x00
    WORD            _wTypeIeee;

    INLINE BOOL IsEnetFrame()   { return(*(DWORD *)&_bDsap == 0x0003AAAA && *(WORD *)&_bOrgCode[1] == 0); }
    INLINE BOOL IsValid()       { return(NTOHS(_wType) > ENET_DATA_MAXSIZE || IsEnetFrame()); }
};

#include <poppack.h>

// IP Address in Network Byte Order ------------------------------------------------------

struct CIpAddr                      // IP Address in Network Byte Order
{
    union
    {
        BYTE        _ab[4];
        DWORD       _dw;
    };

    #define IPADDR_BROADCAST            CIpAddr(HTONL_(0xFFFFFFFF))
    #define IPADDR_LOOPBACK             CIpAddr(HTONL_(0x7F000001))
    #define IPADDR_ALLHOSTS             CIpAddr(HTONL_(0xE0000001))
    #define IPADDR_ALLROUTERS           CIpAddr(HTONL_(0xE0000002))
    #define IPADDR_CLASSA_NETMASK       CIpAddr(HTONL_(0xFF000000))
    #define IPADDR_CLASSB_NETMASK       CIpAddr(HTONL_(0xFFFF0000))
    #define IPADDR_CLASSC_NETMASK       CIpAddr(HTONL_(0xFFFFFF00))
    #define IPADDR_CLASSD_NETMASK       CIpAddr(HTONL_(0xF0000000))
    #define IPADDR_CLASSD_NETID         CIpAddr(HTONL_(0xE0000000))
    #define IPADDR_LOOPBACK_NETID       CIpAddr(HTONL_(0x7F000000))
    #define IPADDR_SECURE_NETID         CIpAddr(HTONL_(0x00000000))
    #define IPADDR_SECURE_NETMASK       CIpAddr(HTONL_(0xFF000000))
    #define IPADDR_SECURE_DEFAULT       CIpAddr(HTONL_(0x00000001))

    INLINE operator DWORD () const { return(_dw); }
    INLINE DWORD operator = (DWORD & dw) { return(_dw = dw); }
    INLINE CIpAddr(DWORD dw) { _dw = dw; }
    INLINE CIpAddr(WORD wUniq, BYTE bSlot) { Assert(wUniq > 0); _dw = HTONL((wUniq << 8) | bSlot); Assert(IsSecure()); }
    INLINE CIpAddr() {}

    INLINE BOOL IsBroadcast() const { return(_dw == IPADDR_BROADCAST); }
    INLINE BOOL IsMulticast() const { return(IsClassD() && !IsBroadcast()); }
    INLINE BOOL IsLoopback() const { return((_dw & IPADDR_CLASSA_NETMASK) == IPADDR_LOOPBACK_NETID); }
    INLINE BOOL IsSecure() const { return(_dw && (_dw & IPADDR_SECURE_NETMASK) == IPADDR_SECURE_NETID); }
    INLINE UINT SecureSlot() const { Assert(IsSecure()); return(_dw >> 24); }
    INLINE BOOL IsClassA() const { return((_dw & HTONL_(0x80000000)) == HTONL_(0x00000000)); }
    INLINE BOOL IsClassB() const { return((_dw & HTONL_(0xC0000000)) == HTONL_(0x80000000)); }
    INLINE BOOL IsClassC() const { return((_dw & HTONL_(0xE0000000)) == HTONL_(0xC0000000)); }
    INLINE BOOL IsClassD() const { return((_dw & HTONL_(0xF0000000)) == HTONL_(0xE0000000)); }
    INLINE BOOL IsValidMask() const { DWORD dw = ~NTOHL(_dw); return((dw & (dw + 1)) == 0); }
    BOOL IsValidUnicast() const;
    BOOL IsValidAddr() const;
    CIpAddr DefaultMask() const;
    char * Str() const;
};

// IP Port in Network Byte Order ---------------------------------------------------------

struct CIpPort
{
    WORD            _w;

    INLINE operator WORD () { return (_w); }
    INLINE WORD operator = (WORD & w) { return(_w = w); }
    INLINE CIpPort(WORD w) { _w = w; }
    INLINE CIpPort() {}
};

// IP Header in Network Byte Order -------------------------------------------------------

#include <pshpack1.h>

struct CIpHdr
{
    BYTE            _bVerHdr;       // Version & header length
    BYTE            _bTos;          // Type of service
    WORD            _wLen;          // Total length including IP header
    WORD            _wId;           // Identification
    WORD            _wFragOff;      // Flags and fragment offset
    BYTE            _bTtl;          // Time to live
    BYTE            _bProtocol;     // Protocol
    WORD            _wChecksum;     // Header checksum
    CIpAddr         _ipaSrc;        // Source address
    CIpAddr         _ipaDst;        // Destination address

    INLINE UINT     GetHdrLen()         { return((_bVerHdr & 0xF) << 2); }
    INLINE void     SetHdrLen(UINT cb)  { _bVerHdr = (BYTE)(0x40 | (cb >> 2)); } 
    INLINE UINT     GetOptLen()         { return(GetHdrLen() - sizeof(CIpHdr)); }
    INLINE UINT     GetLen()            { return(NTOHS(_wLen)); }
    INLINE UINT     VerifyHdrLen()      { return((_bVerHdr & 0xF0) == 0x40 ? GetHdrLen() : 0); }

};

#include <poppack.h>

#define MAXIPHDRLEN         (15*4)
#define DONT_FRAGMENT       BIT(14)
#define MORE_FRAGMENTS      BIT(13)
#define FRAGOFFSET_MASK     0x1FFF

#define TraceIpHdr(tag, pIpHdr, cbDat) \
    TraceSz9(tag, "[IP %s %s (%d %d %04X %04X) %d]{%d}[%d]", \
             (pIpHdr)->_ipaDst.Str(), (pIpHdr)->_ipaSrc.Str(), (pIpHdr)->_bTos, (pIpHdr)->_bTtl, \
             NTOHS((pIpHdr)->_wId), NTOHS((pIpHdr)->_wFragOff), (pIpHdr)->_bProtocol, \
             (pIpHdr)->GetOptLen(), (cbDat))

// UDP/TCP Pseudo Header in Network Byte Order -------------------------------------------

#include <pshpack1.h>

struct CPseudoHeader
{
    CIpAddr         _ipaSrc;
    CIpAddr         _ipaDst;
    BYTE            _bZero;
    BYTE            _bProtocol;
    WORD            _wLen;
};

#include <poppack.h>

// UDP Header in Network Byte Order ------------------------------------------------------

#include <pshpack1.h>

struct CUdpHdr
{
    CIpPort         _ipportSrc;     // Source port
    CIpPort         _ipportDst;     // Destination port
    WORD            _wLen;          // Datagram length including UDP header
    WORD            _wChecksum;     // Datagram checksum

    INLINE UINT GetLen()            { return(NTOHS(_wLen)); }
};

#include <poppack.h>

#define TraceUdpHdr(tag, pSocket, pUdpHdr, cbDat) \
        TraceSz5(tag, "[%X.u] [UDP %d %d][%d] %s", (pSocket), \
                  NTOHS((pUdpHdr)->_ipportDst), NTOHS((pUdpHdr)->_ipportSrc), \
                  (cbDat), DataToString((BYTE *)(pUdpHdr) + sizeof(CUdpHdr), cbDat)) \

// TCP Header in Network Byte Order ------------------------------------------------------

#include <pshpack1.h>

struct CTcpHdr
{
    // Definitions -----------------------------------------------------------------------

    #define TCPSEQ  DWORD

    // External --------------------------------------------------------------------------

    INLINE void SetHdrLen(UINT cb)  { _bHdrLen = (BYTE)(ROUNDUP4(cb) << 2); }
    INLINE UINT GetHdrLen()         { return((_bHdrLen & 0xF0) >> 2); }

    // Data ------------------------------------------------------------------------------

    CIpPort         _ipportSrc;     // Source port
    CIpPort         _ipportDst;     // Destination port
    TCPSEQ          _dwSeqNum;      // Sequence number
    TCPSEQ          _dwAckNum;      // Ack number
    BYTE            _bHdrLen;       // Header length (number of DWORDs)
    BYTE            _bFlags;        // Flags
    WORD            _wWindow;       // Window
    WORD            _wChecksum;     // Checksum
    WORD            _wUrgent;       // Urgent pointer

};

#include <poppack.h>

// Return the sequence numbers in a TCP segment (in host byte order)
#define SEG_SEQ(_tcphdr) NTOHL((_tcphdr)->_dwSeqNum)
#define SEG_ACK(_tcphdr) NTOHL((_tcphdr)->_dwAckNum)
#define SEG_WIN(_tcphdr) NTOHS((_tcphdr)->_wWindow)
#define SEG_URG(_tcphdr) NTOHS((_tcphdr)->_wUrgent)

// Return the length of a TCP segment (counting SYN and FIN)
#define SEG_LEN(_tcphdr, _datalen) \
        ((_datalen) + \
         (((_tcphdr)->_bFlags & TCP_SYN) ? 1 : 0) + \
         (((_tcphdr)->_bFlags & TCP_FIN) ? 1 : 0))

// convenience macro for checking segment flags
#define ISTCPSEG(_tcphdr, _flag) ((_tcphdr)->_bFlags & TCP_##_flag)

#define MAXTCPHDRLEN (4*15)
// TCP segment flag bits
#define TCP_FIN 0x01
#define TCP_SYN 0x02
#define TCP_RST 0x04
#define TCP_PSH 0x08
#define TCP_ACK 0x10
#define TCP_URG 0x20

// Control flags
#define TCP_CONTROLS (TCP_SYN|TCP_FIN|TCP_RST) 

//
// TCP option tags
//
#define TCPOPT_EOL              0x00
#define TCPOPT_NOP              0x01
#define TCPOPT_MAX_SEGSIZE      0x02
#define TCPOPT_WINDOW_SCALE     0x03
#define TCPOPT_SACK_PERMITTED   0x04
#define TCPOPT_SACK             0x05
#define TCPOPT_TIMESTAMP        0x08

char * DataToString(BYTE * pb, UINT cb);

#define TraceTcpHdr(tag, pTcpSocket, pTcpHdr, cbOpt, cbDat) \
        TraceSz16(tag, "[%X.t] [TCP %d %d %08lX %08lX %d %d%s%s%s%s%s%s]{%d}[%d] %s", (pTcpSocket), \
                  NTOHS((pTcpHdr)->_ipportDst), NTOHS((pTcpHdr)->_ipportSrc), \
                  NTOHL((pTcpHdr)->_dwSeqNum), NTOHL((pTcpHdr)->_dwAckNum), \
                  NTOHS((pTcpHdr)->_wWindow), NTOHS((pTcpHdr)->_wUrgent), \
                  ((pTcpHdr)->_bFlags & TCP_FIN) ? " FIN" : "", \
                  ((pTcpHdr)->_bFlags & TCP_SYN) ? " SYN" : "", \
                  ((pTcpHdr)->_bFlags & TCP_RST) ? " RST" : "", \
                  ((pTcpHdr)->_bFlags & TCP_PSH) ? " PSH" : "", \
                  ((pTcpHdr)->_bFlags & TCP_ACK) ? " ACK" : "", \
                  ((pTcpHdr)->_bFlags & TCP_URG) ? " URG" : "", \
                  (cbOpt), (cbDat), DataToString((BYTE *)(pTcpHdr) + sizeof(CTcpHdr) + (cbOpt), cbDat)) \

// ESP Header in Network Byte Order ------------------------------------------------------

#include <pshpack1.h>

struct CEspHdr : public CUdpHdr
{
    DWORD           _dwSpi;         // Security parameters index
    DWORD           _dwSeq;         // Sequence number
};

struct CEspTail
{
    BYTE            _bPadLen;       // Length of padding
    BYTE            _bNextHeader;   // Protocol
    BYTE            _abHash[12];    // HMAC-SHA-1-96 digest
};

#include <poppack.h>

#define ESP_OVERHEAD_1      (sizeof(CIpHdr) + sizeof(CEspHdr) + (sizeof(CEspTail) - offsetof(CEspTail, _abHash)))
#define ESP_OVERHEAD_8      (offsetof(CEspTail, _abHash))
#define ESP_MSS(n,p)        (((((n) - ESP_OVERHEAD_1) / 8) * 8) - XC_SERVICE_DES_BLOCKLEN - (p) - ESP_OVERHEAD_8)

// ---------------------------------------------------------------------------------------
// CPacket
// ---------------------------------------------------------------------------------------

class CPacket
{
    friend class CPacketQueue;

    // Definitions -----------------------------------------------------------------------

public:

    #define PKTF_RECV_BROADCAST     0x0001      // Packet was received via link-level broadcast
    #define PKTF_RECV_LOOPBACK      0x0002      // Packet was received via local loopback
    #define PKTF_IHL_MASK           0x003C      // Number of DWORD's of IP header options
    #define PKTF_POOLALLOC          0x0040      // Packet was allocated with pool allocator
    #define PKTF_CRYPT              0x0080      // Packet is encrypted on the wire
    #define PKTF_TYPE_MASK          0x0700      // PKTF_TYPE_* mask
    #define PKTF_XMIT_FRAME         0x0800      // Tells ENET layer to send packet without ARP
    #define PKTF_XMIT_PRIORITY      0x1000      // Tells ENET layer to queue packet before others
    #define PKTF_XMIT_DUALPAGE      0x2000      // Used by NIC layer during transmit
    #define PKTF_XMIT_XBDMCLIENT    0x4000      // Used by NIC layer during transmit
    #define PKTF_XMIT_INSECURE      0x8000      // Tells IP layer to bypass security

    #define PKTF_IHL_SHIFT          2
    #define PKTF_TYPE_SHIFT         8

    #define PKTFT(i)                ((i) << PKTF_TYPE_SHIFT)

    #define PKTF_TYPE_IP            PKTFT(0)    // [ENET]^[IP][Payload]
    #define PKTF_TYPE_IP_ESP        PKTFT(1)    // [ENET]^[IP][ESP][Payload][ESPT]
    #define PKTF_TYPE_UDP           PKTFT(2)    // [ENET]^[IP][UDP][Payload]
    #define PKTF_TYPE_UDP_ESP       PKTFT(3)    // [ENET]^[IP][ESP][UDP][Payload][ESPT]
    #define PKTF_TYPE_TCP           PKTFT(4)    // [ENET]^[IP][TCP][Payload]
    #define PKTF_TYPE_TCP_ESP       PKTFT(5)    // [ENET]^[IP][ESP][TCP][Payload][ESPT]
    #define PKTF_TYPE_ENET          PKTFT(6)    // [ENET]^[Payload]
    #define PKTF_TYPE_ESP           PKTFT(1)    // Bit common to all [ESP] types

    #define PKTI_ESP                0           // [ESP]
    #define PKTI_UDP_TCP            1           // [UDP]/[TCP]
    #define PKTI_SIZE               2           // Size of frame excluding [ENET] and [Payload]
    #define PKTI_MAX                3           // Number of PKTI_* defined

    // Allocate / Deallocate -------------------------------------------------------------

public:

    INLINE void Init(UINT uiFlags, void * pv, UINT cb, PFNPKTFREE pfn)
    {
        _pv         = pv;
        _cb         = (WORD)cb;
        _wFlags     = (WORD)uiFlags;
        _ppktNext   = NULL;
        _pfn        = pfn;
#if DBG
        _fAllocated = FALSE;
        DbgSetSpy();
#endif
    }

    INLINE void Complete(CXnVoid * pXnVoid)
    {
        (pXnVoid->*_pfn)(this);
    }

    // Member Functions ------------------------------------------------------------------

public:

    INLINE WORD        GetFlags()              { return(_wFlags); }
    INLINE void        SetFlags(WORD wFlags)   { _wFlags |= wFlags; IFDBG(DbgSetSpy();) }
    INLINE void        ClearFlags(WORD wFlags) { _wFlags &= ~wFlags; IFDBG(DbgSetSpy();) }
    INLINE BOOL        TestFlags(WORD wFlags)  { return(!!(_wFlags & wFlags)); }
    INLINE WORD        GetType()               { return(_wFlags & PKTF_TYPE_MASK); }
    INLINE void        SetType(WORD wFlags)    { _wFlags = (_wFlags & ~PKTF_TYPE_MASK) | (wFlags & PKTF_TYPE_MASK); IFDBG(DbgSetSpy();) }

    INLINE void *      GetPv()                 { return(_pv); }
    INLINE void        SetPv(void * pv)        { _pv = pv; }
    INLINE UINT        GetCb()                 { return(_cb); }
    INLINE void        SetCb(UINT cb)          { _cb = (WORD)cb; }
    INLINE void        SetPfn(PFNPKTFREE pfn)  { _pfn = pfn; }
    INLINE UINT        GetHdrOptLen()          { Assert(PKTF_IHL_SHIFT == 2); return(_wFlags & PKTF_IHL_MASK); }
    INLINE void        SetHdrOptLen(UINT cb)   { Assert(PKTF_IHL_SHIFT == 2); Assert(ROUNDUP4(cb) == cb); _wFlags = (_wFlags & ~PKTF_IHL_MASK) | cb; }

    INLINE BOOL        IsEnet()                { return(GetType() == PKTF_TYPE_ENET); }
    INLINE BOOL        IsIp()                  { return(GetType() <  PKTF_TYPE_ENET); }
    INLINE BOOL        IsEsp()                 { return(TestFlags(PKTF_TYPE_ESP)); }
    INLINE BOOL        IsCrypt()               { Assert(IsEsp()); return(TestFlags(PKTF_CRYPT)); }
    INLINE BOOL        IsUdp()                 { return(TestFlags(PKTF_TYPE_UDP)); }
    INLINE BOOL        IsTcp()                 { return(TestFlags(PKTF_TYPE_TCP)); }

           void *      GetHdr(int iHdr);
    INLINE CEnetHdr *  GetEnetHdr()            { return((CEnetHdr *)((BYTE *)_pv - sizeof(CEnetHdr))); }
    INLINE CIpHdr *    GetIpHdr()              { Assert(IsIp()); return((CIpHdr *)_pv); }
    INLINE CEspHdr *   GetEspHdr()             { Assert(IsEsp()); return((CEspHdr *)GetHdr(PKTI_ESP)); }
    INLINE CUdpHdr *   GetUdpHdr()             { Assert(IsUdp()); return((CUdpHdr *)GetHdr(PKTI_UDP_TCP)); }
    INLINE CTcpHdr *   GetTcpHdr()             { Assert(IsTcp()); return((CTcpHdr *)GetHdr(PKTI_UDP_TCP)); }
    INLINE CEspTail *  GetEspTail()            { Assert(IsEsp()); return((CEspTail *)((BYTE *)_pv + _cb - sizeof(CEspTail))); }
    
    INLINE CPacket *   GetNextPkt()            { return(_ppktNext); }

    // Data ------------------------------------------------------------------------------

private:

    void *              _pv;                // [LINK]^[Payload]
    WORD                _cb;                // Size of [Payload]
    WORD                _wFlags;            // See PKTF_* above
    CPacket *           _ppktNext;          // Next packet in packet queue
    PFNPKTFREE          _pfn;               // Function which frees the packet

#if DBG

    struct CSpy
    {
        CEnetHdr *      _pEnetHdr;          // Pointer to CEnetHdr (if any)
        CIpHdr *        _pIpHdr;            // Pointer to CIpHdr (if any)
        CEspHdr *       _pEspHdr;           // Pointer to CEspHdr (if any)
        CUdpHdr *       _pUdpHdr;           // Pointer to CUdpHdr (if any)
        CTcpHdr *       _pTcpHdr;           // Pointer to CTcpHdr (if any)
        CEspTail *      _pEspTail;          // Pointer to CEspTail (if any)
    };

private:

    const char *        _pchSpy;            // String describing packet format
    CSpy                _spy;               // Spy structure
    BOOL                _fAllocated;        // Packet was allocated via PacketAlloc

public:

    void                DbgSetSpy();
    void                SetAllocated()      { _fAllocated = TRUE; }
    BOOL                IsAllocated()       { return(_fAllocated); }
    void                Validate();

#else

public:

    INLINE void         Validate()          {}

#endif

public:

    static const BYTE         _abPktTypeInfo[];
    static const char * const _aszPktTypeName[];

};

// ---------------------------------------------------------------------------------------
// CPacketQueue
// ---------------------------------------------------------------------------------------

class CPacketQueue
{

public:

    void                InsertHead(CPacket * ppkt);
    void                InsertTail(CPacket * ppkt);
    void                InsertHead(CPacketQueue * ppq);
    CPacket *           RemoveHead();
    void                Dequeue(CPacket * ppktDequeue);
    void                Complete(CXnBase * pXnBase);
    void                Discard(CXnBase * pXnBase);
    UINT                Count();

    INLINE void         Init()      { _ppktHead = NULL; _ppktTail = NULL; }
    INLINE BOOL         IsEmpty()   { return(_ppktHead == NULL); }
    INLINE CPacket *    GetHead()   { return(_ppktHead); }

private:

    CPacket *           _ppktHead;
    CPacket *           _ppktTail;

};

// ---------------------------------------------------------------------------------------
// CXnNic
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_WINDOWS
#include "nicw.h"
#endif

#ifdef XNET_FEATURE_XBOX
#include "nicx.h"
#endif

// ---------------------------------------------------------------------------------------
// CXnEnet
// ---------------------------------------------------------------------------------------

class NOVTABLE CXnEnet : public CXnNic
{
    friend void CXnNic::EnetRecv(CPacket * ppkt, UINT uiType);
    friend void CXnNic::EnetPush();

    // Definitions -----------------------------------------------------------------------

#ifdef XNET_FEATURE_ARP

    #define ARP_STATE_FREE      0           // entry is free
    #define ARP_STATE_IDLE      1           // entry is good
    #define ARP_STATE_BAD       2           // target is unreachable
    #define ARP_STATE_BUSY      3           // entry is being resolved

    #define ARP_OP_REQUEST      HTONS_(1)   // opcodes
    #define ARP_OP_REPLY        HTONS_(2)

    #define ARP_HWTYPE_ENET     HTONS_(1)   // hardware address spaces
    #define ARP_HWTYPE_802      HTONS_(6)

    enum ArpResolve
    {
        eNone,
        eCreateEntry,
        eSendRequest
    };

    #define ARP_CACHE_SIZE      64          // cache parametes (modulo should be prime)
    #define ARP_HASH_RETRY      5
    #define ARP_HASH_MODULO     (ARP_CACHE_SIZE-ARP_HASH_RETRY)
    #define ARP_HASH(_addr)     ((_addr) % ARP_HASH_MODULO)

    struct CArpEntry
    {
        CIpAddr         _ipa;
        DWORD           _dwTick;
        CPacketQueue    _pqWait;
        CEnetAddr       _eaNext;
        WORD            _wState;

        INLINE CArpEntry() {}
        INLINE BOOL IsFree()   { return(_wState == ARP_STATE_FREE); }
        INLINE BOOL IsIdle()   { return(_wState == ARP_STATE_IDLE); }
        INLINE BOOL IsBad()    { return(_wState == ARP_STATE_BAD); }
        INLINE BOOL IsBusy()   { return(_wState >= ARP_STATE_BUSY); }
    };

    #include <pshpack1.h>

    struct CArpMsg
    {
        WORD            _wHrd;      // hardware address space
        WORD            _wPro;      // protocol address space (ENET_TYPE_IP)
        BYTE            _bHln;      // hardware address length (6)
        BYTE            _bPln;      // protocol address length (4)
        WORD            _wOp;       // opcode
        CEnetAddr       _eaSender;  // sender's hardware address
        CIpAddr         _ipaSender; // sender's protocol address
        CEnetAddr       _eaTarget;  // target's hardware address
        CIpAddr         _ipaTarget; // target's protocol address
    };

    #include <poppack.h>

#endif

    // External --------------------------------------------------------------------------

public:

    HAL_DECLARE_NEW_DELETE(CXnEnet)

    void            EnetXmit(CPacket * ppkt, CIpAddr ipaNext = 0);
    void            EnetXmitArp(CIpAddr ipa);
    void            EnetPush();

protected:

    NTSTATUS        EnetInit(XNetInitParams * pxnip);
    INLINE void     EnetStart()     { NicStart(); }
    void            EnetStop();
    void            EnetTerm();

    VIRTUAL void    IpRecv(CPacket * ppkt) VPURE;
    VIRTUAL void    IpRecvArp(CEnetAddr * pea) VPURE;

    VIRTUAL void    EnetRecv(CPacket * ppkt, UINT uiType);
    VIRTUAL void    EnetQueuePush();

    // Internal --------------------------------------------------------------------------

private:

#ifdef XNET_FEATURE_ARP

    void            ArpXmit(WORD wOp, CIpAddr ipaTarget, CIpAddr ipaSender, CEnetAddr * peaTarget);
    CArpEntry *     ArpLookup(CIpAddr ipa, ArpResolve eResolve);
    void            ArpTimer(CTimer * pt);
    void            ArpRecv(CPacket * ppkt);

#endif

    void            EnetFillAndXmit(CPacket * ppkt, CEnetAddr * peaNext);

    static void     EnetDpc(PKDPC, void *, void *, void *);
    void            EnetProcessDpc();

    // Data ------------------------------------------------------------------------------
    
public:

    CIpAddr         _ipa;                   // IP address of this interface
    CIpAddr         _ipaMask;               // IP address mask
    CIpAddr         _ipaSubnet;             // IP subnet address

private:

    CPacketQueue    _pqXmit;                // Transmit packet queue
    KDPC            _dpcEnet;               // DPC

#ifdef XNET_FEATURE_ARP

    CIpAddr         _ipaCheck;              // IP address we are checking for uniqueness
    CArpEntry *     _paeLast;               // Last entry fetched
    CArpEntry       _aae[ARP_CACHE_SIZE];   // Arp cache
    CTimer          _timerArp;              // Arp timer

#endif

};    

// ---------------------------------------------------------------------------------------
// CRouteEntry
// ---------------------------------------------------------------------------------------

class CRouteEntry
{
    friend class CXnIp;

    // Definitions -----------------------------------------------------------------------

    #define RTEF_ORPHAN         0x0001             // the route entry is orphaned
    #define RTEF_HOST           0x0002             // host route
    #define RTEF_DEFAULT        0x0004             // default gateway route
    #define RTEF_LOCAL          0x0008             // local route

    #define RTE_DEFAULT_METRIC  1

    // External --------------------------------------------------------------------------

private:

    HAL_DECLARE_NEW_DELETE(CRouteEntry)

    void            AddRef()                    { InterlockedIncrement(&_cRefs); }

    // Internal --------------------------------------------------------------------------

    INLINE void     SetFlags(WORD wFlags)       { _wFlags |= wFlags; }
    INLINE void     ClearFlags(WORD wFlags)     { _wFlags &= ~wFlags; }
    INLINE BOOL     TestFlags(WORD wFlags)      { return(!!(_wFlags & wFlags)); }

    INLINE BOOL     IsOrphan()                  { return(TestFlags(RTEF_ORPHAN)); }
    INLINE BOOL     IsLocal()                   { return(TestFlags(RTEF_LOCAL)); }
    INLINE BOOL     IsHost()                    { return(TestFlags(RTEF_HOST)); }

    // Data ------------------------------------------------------------------------------

    LIST_ENTRY      _le;                        // Doubly linked list entry
    LONG            _cRefs;                     // Reference count
    WORD            _wFlags;                    // See RTEF_*
    WORD            _wMetric;                   // Route metrics (smaller is higher priority)
    CIpAddr         _ipaDst;                    // Destination IP address
    CIpAddr         _ipaMask;                   // Destination IP address mask
    CIpAddr         _ipaNext;                   // Next hop IP address

};

// ---------------------------------------------------------------------------------------
// CXnIp
// ---------------------------------------------------------------------------------------

struct CDnsReg;
struct CDnsHdr;

class NOVTABLE CXnIp : public CXnEnet
{
    friend void CXnBase::SecRegProbe();
    friend void CXnEnet::IpRecv(CPacket * ppkt);
    friend void CXnEnet::IpRecvArp(CEnetAddr * pea);

    #define MAX_DEFAULT_GATEWAYS 4
    #define MAX_DEFAULT_DNSSERVERS 4

    typedef DWORD DHCPTIME;

    struct CSecReg;

    struct CDhcpOptions
    {
        INLINE CDhcpOptions() {}
        INT         _recvMsgType;           // type message received
        CIpAddr     _dhcpmask;              // subnet mask
        CIpAddr     _dhcpServer;            // dhcp server address
        DHCPTIME    _t1time;                // when to enter renewing state
        DHCPTIME    _t2time;                // when to enter rebinding state
        DHCPTIME    _exptime;               // lease expiration time
        UINT        _gatewayCount;          // number of gateways
        CIpAddr     _gateways[MAX_DEFAULT_GATEWAYS];
        UINT        _dnsServerCount;
        CIpAddr     _dnsServers[MAX_DEFAULT_DNSSERVERS];
    };

    struct CQosPkt : public CPacket
    {
        void *          _pvQos;             // Pointer to CQosReq or CQosListen owning this packet
        BOOL            _fQosReq;           // TRUE if packet belongs to CQosReq; FALSE for CQosListen
        BOOL            _fInXmit;           // TRUE if packet is being transmitted
    };

    struct CQosInfo
    {
        LIST_ENTRY      _le;                // Link into _leXmit{Wait} or _leOpen{Wait}
        XNADDR          _xnaddr;            // XNet Address (XbToXb)
        XNKID           _xnkid;             // Key identifier (XbToXb)
        XNKEY           _xnkey;             // Key exchange key (XbToXb)
        CSecReg *       _pSecReg;           // Pointer to CSecReg (XbToSg)
        BYTE            _bState;            // Current state of this Qos item
        BYTE            _bRetry;            // Retries remaining at current state
        CIpPort         _ipportDst;         // Destination port
        CIpAddr         _ipaDst;            // Destination IP address
        UINT            _cbQos;             // Size of Qos data
        BYTE *          _pbQos;             // Qos data buffer
    };

    struct CQosReq
    {
        CQosReq *       _pQosReqNext;       // Next CQosReq item in the list
        BOOL            _fXbToSg;           // TRUE if XB to SG; FALSE if XB to XB
        PRKEVENT        _pEvent;            // Event to signal whenever progress is made
        DWORD           _dwFlags;           // XNET_QOS_* flags from request
        BYTE            _abNonce[8];        // Nonce for this request
        LIST_ENTRY      _leXmit;            // Queue of CQosInfo ready to xmit
        LIST_ENTRY      _leWait;            // Queue of CQosInfo waiting for response
        UINT            _iQosInfo;          // Index of CQosInfo to process next
        UINT            _cQosInfo;          // Count of CQosInfo items
        CQosInfo *      _pQosInfo;          // Array of CQosInfo items
        CQosPkt *       _pQosPkt1;          // Pointer to first Qos packet in packet pair
        CQosPkt *       _pQosPkt2;          // Pointer to second Qos packet in packet pair
        BYTE *          _pbQosData;         // Pointer to Qos data buffer for all CQosInfo
        XNQOS           _xnqos;             // User-visible XNQOS structure
    };

    struct CQosReg
    {
        DWORD           _dwBitsPerSec;      // Bandwidth limit for responses
        CQosPkt *       _pQosPkt1;          // Pointer to first Qos packet in packet pair
        CQosPkt *       _pQosPkt2;          // Pointer to second Qos packet in packet pair
        UINT            _cbQos;             // Size of Qos data
        BYTE            _abQos[1];          // Qos data buffer
    };

    struct CKeyReg
    {
        // External ----------------------------------------------------------------------

        INLINE CKeyReg() {}

        // Data --------------------------------------------------------------------------

        XNKID           _xnkid;             // key identifier
        BYTE            _abKeySha[16];      // key exchange SHA auth key
        BYTE            _abKeyDes[8];       // key exchange DES key
        BYTE            _abDhX[CBDHG1];     // diffie-hellman X value
        BYTE            _abDhGX[CBDHG1];    // diffie-hellman g^X value
        CQosReg *       _pQosReg;           // Pointer to CQosReg if listening
    };

    #include <pshpack1.h>

    struct CKeyExXbToXb : public CKeyExHdr
    {
        XNKID           _xnkid;             // key identifier of key-exchange-key
        DWORD           _dwSpiInit;         // SPI of the initiator
        DWORD           _dwSpiResp;         // SPI of the responder
        BYTE            _abNonceInit[8];    // Nonce of the initiator
        BYTE            _abNonceResp[8];    // Nonce of the responder
        LARGE_INTEGER   _liTime;            // Increasing time-value of the sender
        BYTE            _abIv[8];           // Initialization vector for DES encryption
        XNADDR          _xnaddrInit;        // XNADDR of the initiator (encrypted)
        XNADDR          _xnaddrResp;        // XNADDR of the responder (encrypted)
    };

    struct CKeyExNatOpen : public CKeyExHdr
    {
        // Definitions -------------------------------------------------------------------
        
        #define KNOF_XBTOXB_KEYEX   0x0001  // Request occuring for key exchange
        #define KNOF_XBTOXB_PROBE   0x0002  // Request occuring for probing

        // Data --------------------------------------------------------------------------

        XNKID           _xnkid;             // key identifier of key-exhcange-key
        DWORD           _dwCtx;             // Context identifier from the sender
        BYTE            _abNonce[8];        // Nonce from the sender
        CIpAddr         _ipaDst;            // IP address of the sender
        CIpPort         _ipportDst;         // IP port of the sender
        WORD            _wFlags;            // See KNOF_* above
        BYTE            _abHash[20];        // SHA hash of this message (including header)
    };

    struct CKeyExQos : public CKeyExHdr
    {
        DWORD           _dwReserved;        // Placeholder
    };

    #include <poppack.h>

    struct CSecReg
    {
        // Definitions -------------------------------------------------------------------

        #define SR_STATE_IDLE       0       // key exchange not started by either side
        #define SR_STATE_INITSENT   1       // initiator packet has been sent
        #define SR_STATE_RESPSENT   2       // response packet has been sent
        #define SR_STATE_INITWAIT   3       // initiator waiting for responder to synchronize
        #define SR_STATE_READY      4       // key exchange is complete

        #define SRF_SYSTEMLINK      0x0001  // Other side is an XB via system link
        #define SRF_ONLINEPEER      0x0002  // Other side is an XB that is online
        #define SRF_ONLINESERVER    0x0004  // Other side is an SG
        #define SRF_SECMSG_DELETE   0x0008  // SECMSG_TYPE_DELETE has been sent
        #define SRF_OWNED           0x0010  // This side owns this CSecReg

        // External ----------------------------------------------------------------------

        INLINE      CSecReg() {}
        INLINE      IsXmitReady() { return(_bState >= SR_STATE_INITWAIT); }
        INLINE      IsRecvReady() { return(_bState >= SR_STATE_RESPSENT); }
        char *      CSecReg::Str();

        INLINE BOOL TestFlags(WORD wFlags)  { return(!!(_wFlags & wFlags)); }
        INLINE void SetFlags(WORD wFlags)   { _wFlags |= wFlags; }
        INLINE void ClearFlags(WORD wFlags) { _wFlags &= ~wFlags; }

        // Data --------------------------------------------------------------------------

        BYTE            _wFlags;                // See SRF_* above
        BYTE            _bState;                // See SR_STATE_* above
        BYTE            _bRetry;                // Number of retries remaining
        DWORD           _dwSpiRecv;             // SPI assigned by this side
        DWORD           _dwSpiXmit;             // SPI assigned by other side
        DWORD           _dwSeqRecv;             // Base sequence of receive window
        DWORD           _dwSeqMask;             // Bit mask of sequence numbers received
        DWORD           _dwSeqXmit;             // Highest sequence number transmitted
        DWORD           _dwTickRecv;            // TimerTick when last packet recv
        DWORD           _dwTickXmit;            // TimerTick when last packet xmit
        DWORD           _dwTickPulse;           // TimerTick when last pulse xmit
        DWORD           _dwTickPulseTimeout;    // Outbound inactivity before sending pulse
        DWORD           _dwTickTimeout;         // Inbound inactivity before timing out connection
        CPacketQueue    _pqWait;                // Queue of packets waiting
        CTimer          _timer;                 // Timer for scheduling timeouts
        BYTE            _abIv[8];               // Next IV to use for encrypted packets
        BYTE            _abNonceInit[8];        // Nonce generated by the initiator
        BYTE            _abNonceResp[8];        // Nonce generated by the responder
        BYTE            _abKeyShaRecv[16];      // Negotiated incoming SHA auth key
        BYTE            _abKeyDesRecv[24];      // Negotiated incoming DES crypt key
        WORD            _cbKeyDesRecv;          // Size of incoming DES crypt key
        BYTE            _abKeyShaXmit[16];      // Negotiated outgoing SHA auth key
        BYTE            _abKeyDesXmit[24];      // Negotiated outgoing DES crypt key
        WORD            _cbKeyDesXmit;          // Size of outgoing DES crypt key
        CIpAddr         _ipaDst;                // Destination IP address for ONLINEPEER or ONLINESERVER
        CIpPort         _ipportDst;             // Destination port for ONLINEPEER or ONLINESERVER
        LARGE_INTEGER   _liTime;                // [XB] Highest time value, [SG] Kerberos time
        union {
            struct {
                CKeyReg *       _pKeyReg;       // [XB] Pointer to corresponding CKeyReg
                XNADDR          _xnaddr;        // [XB] XNADDR of the destination
            };
            struct {
                DWORD           _dwServiceId;   // [SG] Service Identifier
                SGADDR          _sgaddr;        // [SG] SGADDR assigned by SG
                CIpAddr         _ipaNat;        // [SG] NAT'd source IP address as seen by SG
                CIpPort         _ipportNat;     // [SG] NAT'd source port as seen by SG
            };
        };
    };

    // External --------------------------------------------------------------------------

public:

    INLINE          CXnIp() {};

    void            IpXmit(CPacket * ppkt, CRouteEntry ** pprte = NULL);
    void            IpFillAndXmit(CPacket * ppkt, CIpAddr ipaDst, BYTE bProtocol, CRouteEntry ** pprte = NULL);
    void            IpFillHdr(CPacket * ppkt, CIpAddr ipaDst, BYTE bProtocol);
    void            IpSetAddress(CIpAddr ipa, CIpAddr ipaMask);

    BOOL            IpDecrypt(CPacket * ppkt, CIpAddr ipaDst);

    INT             IpCreateKey(XNKID * pxnkid, XNKEY * pxnkey);
    INT             IpRegisterKey(const XNKID * pxnkid, const XNKEY * pxnkey);
    INT             IpUnregisterKey(const XNKID * pxnkid);
    INT             IpXnAddrToInAddr(const XNADDR * pxna, const XNKID * pxnkid, CIpAddr * pipa);
    INT             IpServerToInAddr(const CIpAddr ipa, DWORD dwServiceId, CIpAddr * pipa);
    INT             IpInAddrToXnAddr(const CIpAddr ipa, XNADDR * pxna, XNKID * pxnkid);
    INT             IpUnregisterInAddr(const CIpAddr ipa);
    DWORD           IpGetXnAddr(XNADDR * pxna);

    void            RouteRelease(CRouteEntry * prte);
    INLINE WORD     GetNextDgramId()    { return((WORD)InterlockedIncrement(&_lNextDgramId)); }

#ifdef XNET_FEATURE_DNS
    INT             IpDnsLookup(const char * pszHost, WSAEVENT hEvent, XNDNS ** ppxndns);
    INT             IpDnsRelease(XNDNS * pxndns);
#endif

#ifndef XNET_FEAUTRE_QOS
    INT             IpQosListen(const XNKID * pxnkid, const BYTE * pb, UINT cb, DWORD dwBitsPerSec, DWORD dwFlags);
    INT             IpQosXnAddr(UINT cxnqos, const XNADDR * apxna[], const XNKID * apxnkid[], const XNKEY * apxnkey[], DWORD dwFlags, WSAEVENT hEvent, XNQOS ** ppxnqos);
    INT             IpQosServer(UINT cxnqos, const IN_ADDR aina[], const DWORD adwServiceId[], DWORD dwFlags, WSAEVENT hEvent, XNQOS ** ppxnqos);
    INT             IpQosRelease(XNQOS * pxnqos);
#endif

    void            SecRegSetOwned(CIpAddr ipa);
    void            SecRegShutdown(BOOL fOnlineOnly);
    INLINE BYTE     SecRegRexmitRetries(CSecReg * pSecReg);
    INLINE BYTE     SecRegRexmitTimeoutInSeconds(CSecReg * pSecReg);

#ifdef XNET_FEATURE_ONLINE
    INLINE CXoBase *IpGetXoBase() { return(_pXoBase); }
    void            IpSetXoBase(CXoBase * pXoBase);
    void            IpRaiseToDpc(BOOL fRaise);
#endif

#ifdef XNET_FEATURE_SG
    void            IpLogon(CIpAddr ipaLogon, ULONGLONG * pqwUserId, WSAEVENT hEventLogon);
    DWORD           IpLogonGetStatus(SGADDR * psgaddr);
    BOOL            IpLogonGetQFlags(UINT iUserId, ULONGLONG * pqwUserId, DWORD * pdwQFlags, DWORD * pdwSeqQFlags);
    BOOL            IpLogonSetQFlags(UINT iUserId, DWORD dwQFlags, DWORD dwSeqQFlags);
    BOOL            IpLogonSetPState(UINT iUserId, DWORD dwPState, const XNKID * pxnkid, UINT cbData, BYTE * pbData);
    void            IpLogoff();
#endif

    void            IpSetEventTimer(CEventTimer * pEventTimer, WSAEVENT hEvent, DWORD dwTimeout);
    void            EventTimer(CTimer * pt);

protected:

    NTSTATUS        IpInit(XNetInitParams * pxnip);
    INT             IpConfig(const XNetConfigParams * pxncp, DWORD dwFlags);
    INT             IpGetConfigStatus(XNetConfigStatus * pxncs);
    INLINE void     IpStart()       { EnetStart(); }
    void            IpStop();
    void            IpTerm();

    VIRTUAL void    IpRecv(CPacket * ppkt);
    VIRTUAL void    IpRecvArp(CEnetAddr * pea);

    VIRTUAL void    UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen) VPURE;
    VIRTUAL void    TcpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbHdrLen, UINT cbLen) VPURE;
    VIRTUAL void    SockReset(CIpAddr ipa) VPURE;

#ifdef XNET_FEATURE_WINDOWS
    VIRTUAL void    EnetXmit(CPacket * ppkt, CIpAddr ipaNext = 0) { CXnEnet::EnetXmit(ppkt, ipaNext); }
    INLINE  void    IpXmitIp(CPacket * ppkt) { IpXmitIp(ppkt, NULL); }
    VIRTUAL BOOL    IsGateway(CIpPort ipport) { return(FALSE); }
#else
    INLINE  BOOL    IsGateway(CIpPort ipport) { return(FALSE); }
#endif

    // Internal --------------------------------------------------------------------------

private:
    
    void            IpXmitEsp(CPacket * ppkt, CSecReg * pSecReg, CRouteEntry ** pprte);
    void            IpXmitIp(CPacket * ppkt, CRouteEntry ** pprte);

    NTSTATUS        RouteInit();
    void            RouteTerm();
    CRouteEntry *   RouteLookup(CIpAddr ipaDst);
    void            RouteAdd(CIpAddr ipaDst, CIpAddr ipaMask, CIpAddr ipaNext, WORD wFlags, WORD wMetric);
    void            RouteRedirect(CIpAddr ipaDst, CIpAddr ipaOldGateway, CIpAddr ipNewGateway);
    void            RouteDelete(CIpAddr ipaDst, CIpAddr ipaMask, CIpAddr ipaNext);
    void            RouteListOrphan();
    void            RouteInvalidateCache();
    void            RouteEntryOrphan(CRouteEntry * prte);
    void            RouteListDump();

    void            FragTerm();
    void            FragRecv(CPacket * ppkt, CIpHdr * pIpHdr, UINT cbHdrLen, UINT cbLen);
    void            FragTimer(CTimer * pt);
    void            FragFree(CPacket * ppkt);

    void            IcmpRecv(CPacket* ppkt, CIpHdr * pIpHdr, void * pvData, UINT cbData);

    NTSTATUS        DhcpInit();
    INT             DhcpConfig(const XNetConfigParams * pxncp);
    void            DhcpTerm();
    void            DhcpTimer(CTimer * pt);
    void            DhcpRecv(CPacket * ppkt, CUdpHdr * pUdpHdr, UINT cbLen);
    void            DhcpNotifyAddressConflict();
    BOOL            DhcpForceAutonet(CIpAddr addr, CIpAddr mask);
    void            DhcpTimerSetRelative(UINT minWait, UINT maxWait);
    void            DhcpTimerSetAbsolute(DHCPTIME dhcptime);
    void            DhcpComputeTimeout();
    void            DhcpChangeState(INT state);
    void            DhcpResetInterface();
    NTSTATUS        DhcpSendMessage(CPacket * ppkt, UINT msglen, BOOL broadcast);
    BYTE *          DhcpFillMessageHeader(BYTE * buf, INT msgtype);
    void            DhcpComputeSecsSinceStart();
    NTSTATUS        DhcpSendDiscover();
    NTSTATUS        DhcpSendRequest();
    NTSTATUS        DhcpSendInform();
    NTSTATUS        DhcpSendRelease();
    NTSTATUS        DhcpProcessOffer(CIpAddr yiaddr, CDhcpOptions * param);
    void            DhcpAddOrRemoveGateways(BOOL doDelete);
    void            DhcpSetDefaultGateways();
    void            DhcpUseOptionParams(CDhcpOptions * param);
    NTSTATUS        DhcpProcessAck(CIpAddr yiaddr, CDhcpOptions * param);
    NTSTATUS        DhcpProcessNak(CIpAddr dhcpServer);
    void            DhcpSelectAutonetAddr();
    BYTE *          DhcpAppendLeaseTimeOption(BYTE * option);
    BOOL            DhcpValidateOffer(CIpAddr yiaddr, CDhcpOptions * param);
    BOOL            ActiveDhcpAddr();
    BOOL            ActiveAutonetAddr();
    BOOL            ActiveStaticAddr();
    BOOL            ActiveNoAddr();
    NTSTATUS        DhcpParseOptionParams(CDhcpOptions * param, const BYTE* buf, UINT buflen, BYTE* overload);
    DHCPTIME        DhcpTime();

    void            IpXmitDns(CDnsReg * pdnsreg);
    void            IpRecvDns(CPacket * ppkt, CUdpHdr * pUdpHdr, UINT cbLen);
    void            IpDnsTimer(CTimer * pt);
    void            IpDnsSignal(CDnsReg * pdnsreg, INT iStatus);
    void            IpDnsDump(CDnsHdr * pdnshdr, UINT cbDnsMsg);
    BYTE *          IpDnsDumpSection(BYTE * pbBeg, BYTE * pbEnd, BYTE * pb, UINT cSec, char * pszSec);
    void            IpDnsDumpHex(BYTE * pb, UINT cb);

    void            IpRecvUdp(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen);
    void            IpRecvTcp(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbLen);
    void            IpRecvEsp(CPacket * ppkt, CIpHdr * pIpHdr, CEspHdr * pEspHdr, UINT cbLen);
    void            IpRecvKeyEx(CPacket * ppkt, CIpAddr ipaSrc, CIpPort ipportSrc, CKeyExHdr * pKeyExHdr, UINT cbKeyEx);
    void            IpRecvKeyExXbToXb(CPacket * ppkt, CIpAddr ipaSrc, CIpPort ipportSrc, CKeyExXbToXb * pKeyExXbToXb, UINT cbKeyEx);
    void            IpRecvKeyExSgToXb(CPacket * ppkt, CIpAddr ipaSrc, CIpPort ipportSrc, CKeyExSgToXbResp * pKeyExSgToXbResp, UINT cbKeyEx);
    void            IpRecvKeyExNatOpen(CPacket * ppkt, CIpAddr ipaSrc, CIpPort ipportSrc, CKeyExNatOpen * pKeyExNatOpen, UINT cbKeyEx);
    void            IpRecvSecMsg(CPacket * ppkt, CSecReg * pSecReg, DWORD dwSeq, CSecMsgHdr * pSecMsgHdr, UINT cb);

    void            IpXmitKeyEx(CSecReg * pSecReg);
    void            IpXmitKeyExXbToXb(CSecReg * pSecReg, BOOL fInhibitNatOpen = FALSE);
    void            IpFillKeyExXbToXb(CSecReg * pSecReg, CKeyExXbToXb * pKeyExXbToXb);
    void            IpXmitKeyExXbToSg(CSecReg * pSecReg);
    void            IpXmitSecMsg(CSecReg * pSecReg, WORD wType, void * pv1 = NULL, UINT cb1 = 0, void * pv2 = 0, UINT cb2 = 0);
    void            IpXmitSecMsgDelete(CSecReg * pSecReg, DWORD dwReason);
    void            IpXmitSecMsgXbToSgPulse(CSecReg * pSecReg);

    CKeyReg *       KeyRegLookup(const XNKID * pxnkid);

    void            CryptDes(DWORD dwOp, BYTE * pbKey, UINT cbKey, BYTE * pbIv, BYTE * pb, UINT cb);

    CSecReg *       SecRegLookup(const XNADDR * pxna, const XNKID * pxnkid);
    CSecReg *       SecRegLookup(const CIpAddr ipa, DWORD dwServiceId, const XOKERBINFO * pxokerbinfo);
    CSecReg *       SecRegLookup(DWORD dwSpiRecv);
    CSecReg *       SecRegAlloc();
    CSecReg *       SecRegAlloc(const XNADDR * pxna, CKeyReg * pKeyReg);
    CSecReg *       SecRegAlloc(const CIpAddr ipa, DWORD dwServiceId);
    void            SecRegFree(CSecReg * ppSecReg);

    void            SecRegEnqueue(CSecReg * pSecReg, CPacket * ppkt);
    void            SecRegXmitQueue(CSecReg * pSecReg);
    void            SecRegSetIdle(CSecReg * pSecReg);
    void            SecRegSetTicks(CSecReg * pSecReg);
    void            SecRegSetKey(CSecReg * pSecReg, BYTE * pbKeyHmac, UINT cbKeyHmac, BYTE * pbDhX, UINT cbDhX, BYTE * pbDhGY, UINT cbDhGY, BOOL fInitiator);
    void            SecRegTimer(CTimer * pt);
    void            SecRegProbe();

    // Data ------------------------------------------------------------------------------

protected:

#ifdef XNET_FEATURE_DHCP
    CDhcpOptions    _options;
#endif

private:

    LONG            _lNextDgramId;

#ifdef XNET_FEATURE_ROUTE
    LIST_ENTRY      _leRouteList;
    CIpAddr         _ipaDstLast;
    CRouteEntry *   _prteLast;
#endif

#ifdef XNET_FEATURE_FRAG
    CPacketQueue    _pqFrag;
    UINT            _cFrag;
#endif

#ifdef XNET_FEATURE_DHCP
    INT             _state;             // current state of the interface
    INT             _flags;             // misc. flags (see constants below)
    CIpAddr         _activeaddr;        // active IP address
    CIpAddr         _activemask;        // active IP mask
    CIpAddr         _dhcpaddr;          // last DHCP address
    CIpAddr         _autonetaddr;       // last autonet address
    DHCPTIME        _acqtime;           // when lease acquisition started
    DWORD           _xid;               // XID for the next outgoing message
    UINT            _retries;           // number of retries for the current message
    UINT            _initRetryCount;    // how many retries into INIT state
    UINT            _secsSinceStart;    // secs since the address-req process started
    CTimer          _timerDhcp;
    DWORD           _dwXidNext;
#endif

#ifdef XNET_FEATURE_DNS
    CDnsReg *       _pdnsreg;           // Active DNS lookups
#endif

#if defined(XNET_FEATURE_SG) && defined(XNET_FEATURE_INSECURE)
    BYTE            _abDhXNull[CBDHG1]; // Diffie-hellman X for insecure XbToSg
    BYTE            _abDhGXNull[CBDHG1];// Diffie-hellman g^X for insecure XbToSg
    BYTE            _abKeyNull[16];     // Session key for insecure XbToSg
#endif

    BYTE            _abKeyShaLan[16];   // LAN broadcast SHA auth key
    BYTE            _abKeyDesLan[24];   // LAN broadcast DES crypt key (3des)
    CKeyReg *       _pKeyReg;           // Vector of CKeyReg structures
    CSecReg *       _pSecReg;           // Vector of CSecReg structures
    CSecReg *       _pSecRegProbe;      // Next CSecReg to process in SecRegProbeTimer
    WORD            _cKeyReg;           // Number of registered key slots in use
    WORD            _wSecRegUniq;       // Number cycled to generate next secure IP address
    UINT            _cSecRegProbeNumer; // Probe timer numer (cfgSecRegMax per tick)
    UINT            _cSecRegProbeDenom; // Probe timer denom (ticks per CSecReg visit)
    LARGE_INTEGER   _liTime;            // Highest system time sent during key exchange

#ifdef XNET_FEATURE_ONLINE
    CXoBase *       _pXoBase;           // Pointer to CXoBase implemented by the Online code
#endif

#ifdef XNET_FEATURE_SG
    UINT            _uiLogonState;      // One of the XN_LOGON_* states
    CSecReg *       _pSecRegLogon;      // Pointer to CSecReg from IpLogon
    PRKEVENT        _pEventLogon;       // Pointer to cracked WSAEVENT from IpLogon
    XOUSERINFO      _axouserinfo[4];    // Vector of XOUSERINFO
    BYTE            _abXbToSgPulse[4];  // Changes to transmit on next XbToSg pulse
    DWORD           _dwSeqXbToSg;       // Sequence number of latest XbToSg pulse with changes
    DWORD           _dwSeqSgToXb;       // Sequence number to acknowledge in next XbToSg pulse
#endif

};

INLINE BYTE CXnIp::SecRegRexmitRetries(CSecReg * pSecReg)
{
#ifdef XNET_FEATURE_SG
    if (pSecReg->TestFlags(SRF_ONLINESERVER))
    {
        return(cfgKeyExXbToSgRexmitRetries);
    }
#endif

    return(cfgKeyExXbToXbRexmitRetries);
}

INLINE BYTE CXnIp::SecRegRexmitTimeoutInSeconds(CSecReg * pSecReg)
{
#ifdef XNET_FEATURE_SG
    if (pSecReg->TestFlags(SRF_ONLINESERVER))
    {
        return(cfgKeyExXbToSgRexmitTimeoutInSeconds);
    }
#endif

    return(cfgKeyExXbToXbRexmitTimeoutInSeconds);
}

// ---------------------------------------------------------------------------------------
// CSocket
// ---------------------------------------------------------------------------------------

class CRecvReq;
class CRecvBuf;
class CSendReq;
class CSendBuf;

class CSocket
{
    // Definitions -----------------------------------------------------------------------

    #define SOCKF_POOLALLOC             0x00000001      // [ANY] Socket allocated with pool allocator
    #define SOCKF_TCP                   0x00000002      // [ANY] Socket is CTcpSocket
    #define SOCKF_NOMORE_XMIT           0x00000004      // [ANY] No more transmission of data allowed
    #define SOCKF_NOMORE_RECV           0x00000008      // [ANY] No more receiving of data allowed
    #define SOCKF_BOUND                 0x00000010      // [ANY] Socket is bound to a local address
    #define SOCKF_CONNECTED             0x00000020      // [ANY] Socket is connected
    #define SOCKF_REVIVABLE             0x00000040      // [TCP] Socket is revivable
    #define SOCKF_CONNECT_SELECTED      0x00000080      // [TCP] Select has been called for connect event
    #define SOCKF_PERSIST               0x00000100      // [TCP] Socket is persisting
    #define SOCKF_FAST_RETRANSMIT       0x00000200      // [TCP] Socket is in fast retransmit mode
    #define SOCKF_EVENT_READ            0x00000400      // [ANY] FD_READ event
    #define SOCKF_EVENT_WRITE           0x00000800      // [ANY] FD_WRITE event
    #define SOCKF_EVENT_ACCEPT          0x00001000      // [ANY] FD_ACCEPT event
    #define SOCKF_EVENT_CONNECT         0x00002000      // [ANY] FD_CONNECT event
    #define SOCKF_EVENT_CLOSE           0x00004000      // [ANY] FD_CLOSE event
    #define SOCKF_EVENT_RESET           0x00008000      // [ANY] Socket has been reset
    #define SOCKF_OPT_BROADCAST         0x00010000      // [UDP] Broadcast is allowed
    #define SOCKF_OPT_NONBLOCKING       0x00020000      // [ANY] Nonblocking socket
    #define SOCKF_OPT_REUSEADDR         0x00040000      // [ANY] Address reuse is allowed
    #define SOCKF_OPT_EXCLUSIVEADDR     0x00080000      // [ANY] Address reuse prohibited
    #define SOCKF_OPT_NONAGLE           0x00100000      // [TCP] Don't buffer data
    #define SOCKF_OWNED                 0x00200000      // [ANY] Socket belongs to user (socket() & accept())
    #define SOCKF_CLOSED                0x00400000      // [ANY] Socket is closed but not freed yet
    #define SOCKF_LINGERING             0x00800000      // [ANY] Socket is lingering
    #define SOCKF_INSECURE              0x01000000      // [ANY] Socket is insecure

    #define SOCKF_EVENT_MASK            (SOCKF_EVENT_READ|SOCKF_EVENT_WRITE|SOCKF_EVENT_ACCEPT|SOCKF_EVENT_CONNECT|SOCKF_EVENT_CLOSE|SOCKF_EVENT_RESET)
    #define SOCKF_OPT_MASK              (SOCKF_OPT_NONBLOCKING|SOCKF_OPT_BROADCAST|SOCKF_OPT_REUSEADDR|SOCKF_OPT_EXCLUSIVEADDR|SOCKF_OPT_NONAGLE)

    #define SOCK_LOCK_ACTIVE            '+COS'
    #define SOCK_LOCK_BUSY              '*COS'
    #define SOCK_LOCK_CLOSED            '-cos'

    // External --------------------------------------------------------------------------

public:

    INLINE void         Init(CXnBase * pXnBase, BOOL fTcp, BOOL fPoolAlloc);
    INLINE void         Enqueue(LIST_ENTRY * pleHead);
    INLINE void         Dequeue();
    INLINE LIST_ENTRY * GetFlink();
    static CSocket *    Lock(SOCKET s);
    INLINE void         Unlock();
    INLINE void         SetClosed();
    INLINE BOOL         IsLingering();
    INLINE PRKEVENT     GetEvent();
    INLINE void         SignalEvent(DWORD dwFlags);
    INLINE BOOL         TestFlags(DWORD dwFlags);
    INLINE DWORD        GetFlags(DWORD dwMask = 0xFFFFFFFF);
    INLINE void         SetFlags(DWORD dwFlags);
    INLINE void         SetFlags(DWORD dwFlags, DWORD dwMask);
           void         SetFlagsAndOr(DWORD dwAnd, DWORD dwOr);
    INLINE void         ClearFlags(DWORD dwFlags);
    INLINE BOOL         IsTcp();
    INLINE BOOL         IsUdp();
    INLINE const char * TypeStr();
    INLINE BOOL         HasRecvReq();
    INLINE CRecvReq *   GetRecvReq();
    INLINE void         SetRecvReq(CRecvReq * pRecvReq);
    INLINE BOOL         HasRecvBuf();
    INLINE CRecvBuf *   GetRecvBufFirst();
    INLINE CRecvBuf *   GetRecvBufNext(CRecvBuf * pRecvBuf);
    INLINE CRecvBuf *   GetRecvBufLast();
    INLINE CRecvBuf *   GetRecvBufPrev(CRecvBuf * pRecvBuf);
    INLINE CRecvBuf *   DequeueRecvBuf();
    INLINE void         DequeueRecvBuf(CRecvBuf * pRecvBuf);
    INLINE void         EnqueueRecvBuf(CRecvBuf * pRecvBuf);
           void         InsertRecvBuf(CRecvBuf * pRecvBuf, CRecvBuf * pRecvBufPrev);
    INLINE BOOL         IsRecvBufFull();
    INLINE BOOL         IsRecvBufEmpty();
    INLINE BOOL         IsUdpRecvBufEmpty();
    INLINE BOOL         IsTcpRecvBufEmpty();
    INLINE UINT         GetCbRecvBuf();
    INLINE void         SetCbRecvBuf(UINT cb);
    INLINE BOOL         HasSendReq();
    INLINE CSendReq *   GetSendReq();
    INLINE void         SetSendReq(CSendReq * pSendReq);
    INLINE BOOL         HasSendBuf();
    INLINE CSendBuf *   GetSendBufFirst();
    INLINE CSendBuf *   GetSendBufNext(CSendBuf * pSendBuf);
    INLINE CSendBuf *   DequeueSendBuf();
    INLINE void         DequeueSendBuf(CSendBuf * pSendBuf);
    INLINE void         EnqueueSendBuf(CSendBuf * pSendBuf);
    INLINE BOOL         IsSendBufFull();
    INLINE BOOL         IsSendBufEmpty();
    INLINE UINT         GetCbSendBuf();
    INLINE void         SetCbSendBuf(UINT cb);
    INLINE UINT         IncCbSendBuf(UINT cb);
    INLINE UINT         DecCbSendBuf(UINT cb);
    INLINE NTSTATUS     GetStatus();
    INLINE void         SetStatus(NTSTATUS status);

    // Data ------------------------------------------------------------------------------

private:

    LIST_ENTRY          _le;
    LONG                _lLock;
    DWORD               _dwFlags;
    KEVENT              _Event;
    CRecvReq *          _pRecvReq;
    LIST_ENTRY          _leRecvBufs;
    UINT                _cbRecvBuf;
    CSendReq *          _pSendReq;
    LIST_ENTRY          _leSendBufs;
    UINT                _cbSendBuf;
    NTSTATUS            _status;

public:

    CIpAddr             _ipaDst;
    CIpPort             _ipportDst;
    CIpPort             _ipportSrc;
    CRouteEntry *       _prte;
    UINT                _uiSendTimeout;
    UINT                _uiRecvTimeout;
    UINT                _cbMaxSendBuf;
    UINT                _cbMaxRecvBuf;

#ifdef XNET_FEATURE_ASSERT
private:
    CXnBase *           _pXnBase;
public:
    INLINE CXnBase *    GetXnBase() { return(_pXnBase); }
#endif

};

// ---------------------------------------------------------------------------------------
// CSockReq
// ---------------------------------------------------------------------------------------

class CSockReq
{
    // Definitions -----------------------------------------------------------------------

    // We use the WSAOVERLAPPED structure to keep track of the status of an overlapped I/O
    // request. When the request is pending, the fields are interpreted as follows:
    //      Internal     - pointer to the I/O request structure
    //      InternalHigh - unused
    //      Offset       - unused
    //      OffsetHigh   - status code = NETERR_PENDING
    // After a request is completed, the fields are interpreted differently:
    //      Internal     - unused
    //      InternalHigh - I/O request completion flags
    //      Offset       - number of bytes actually transferred
    //      OffsetHigh   - status code != NETERR_PENDING

    #define _ioreq      Internal
    #define _ioflags    InternalHigh
    #define _ioxfercnt  Offset
    #define _iostatus   OffsetHigh

    // Data ------------------------------------------------------------------------------

public:

    PRKEVENT            _pEvent;
    WSAOVERLAPPED *     _pWsaOverlapped;

};

// ---------------------------------------------------------------------------------------
// CRecvReq
// ---------------------------------------------------------------------------------------

class CRecvReq : public CSockReq
{

    // External --------------------------------------------------------------------------

public:

    INLINE void SetFromAddrPort(CIpAddr ipa, CIpPort ipport)
    {
        if (fromaddr)
        {
            fromaddr->sin_addr.s_addr = ipa;
            fromaddr->sin_port = ipport;
        }
    }

    INLINE UINT GetCbBuf()
    {
        return(buflen);
    }

    INLINE BYTE * GetPbBuf()
    {
        return(buf);
    }

    // Data ------------------------------------------------------------------------------

public:

    DWORD               flags;
    DWORD *             bytesRecv;
    BYTE *              buf;
    UINT                buflen;
    struct sockaddr_in* fromaddr;

};

// ---------------------------------------------------------------------------------------
// CRecvBuf
// ---------------------------------------------------------------------------------------

class CRecvBuf
{
    friend class CSocket;

    // External --------------------------------------------------------------------------

public:

    INLINE void         Init(CXnBase * pXnBase);
    INLINE UINT         GetCbBuf();
    INLINE void         SetCbBuf(UINT cb);
    INLINE UINT         IncCbBuf(UINT cb);
    INLINE UINT         DecCbBuf(UINT cb);

    // Data ------------------------------------------------------------------------------

private:

    LIST_ENTRY          _le;
    UINT                _cbBuf;

#ifdef XNET_FEATURE_ASSERT
    CXnBase *           _pXnBase;
public:
    INLINE CXnBase *    GetXnBase() { return(_pXnBase); }
#endif

};

INLINE void CRecvBuf::Init(CXnBase * pXnBase)
{
    ICHECK_(pXnBase, SOCK, USER|UDPC|SDPC);
#ifdef XNET_FEATURE_ASSERT
    _pXnBase = pXnBase;
#endif
}

INLINE UINT CRecvBuf::GetCbBuf()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(_cbBuf);
}

INLINE void CRecvBuf::SetCbBuf(UINT cb)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _cbBuf = cb;
}

INLINE UINT CRecvBuf::IncCbBuf(UINT cb)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_cbBuf += cb);
}

INLINE UINT CRecvBuf::DecCbBuf(UINT cb)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_cbBuf -= cb);
}

// ---------------------------------------------------------------------------------------
// CUdpRecvBuf
// ---------------------------------------------------------------------------------------

class CUdpRecvBuf : public CRecvBuf
{

    // Data ------------------------------------------------------------------------------

public:

    CIpAddr             fromaddr;
    CIpPort             fromport;
};

// ---------------------------------------------------------------------------------------
// CTcpRecvBuf
// ---------------------------------------------------------------------------------------

class CTcpRecvBuf : public CRecvBuf
{

    // Data ------------------------------------------------------------------------------

public:

    TCPSEQ              seqnext;
    WORD                dataoffset;
    BYTE                tcpflags;

};

// ---------------------------------------------------------------------------------------
// CSendReq
// ---------------------------------------------------------------------------------------

class CSendReq : public CSockReq
{

    // Data ------------------------------------------------------------------------------

public:

    WSABUF *            bufs;
    UINT                bufcnt;
    UINT                sendtotal;
    struct sockaddr_in* toaddr;

};

// ---------------------------------------------------------------------------------------
// CSendBuf
// ---------------------------------------------------------------------------------------

class CSendBuf : public CPacket
{
    friend class CSocket;

    // External --------------------------------------------------------------------------

public:

    INLINE void         Init(CSocket * pSocket, UINT cbData, UINT cRefs);
    INLINE void         AddRef();
    INLINE LONG         Release();
    INLINE BOOL         IsActive();
    INLINE UINT         GetCbBuf();
    INLINE void         SetCbBuf(UINT cb);
    INLINE UINT         DecCbBuf(UINT cb);
    INLINE CSocket *    GetSocket();

#ifdef XNET_FEATURE_ASSERT
    INLINE CXnBase *    GetXnBase()     { return(_pSocket->GetXnBase()); }
#endif

    // Data ------------------------------------------------------------------------------

private:

    LIST_ENTRY          _le;
    CSocket *           _pSocket;
    UINT                _cbBuf;
    LONG                _cRefs;

};

INLINE void CSendBuf::Init(CSocket * pSocket, UINT cbBuf, UINT cRefs)
{
    ICHECK_(pSocket->GetXnBase(), SOCK, USER|UDPC|SDPC);
    _pSocket    = pSocket;
    _cbBuf      = cbBuf;
    _cRefs      = cRefs;
}

INLINE void CSendBuf::AddRef()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _cRefs += 1;
}

INLINE LONG CSendBuf::Release()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(--_cRefs);
}

INLINE BOOL CSendBuf::IsActive()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_cRefs > 1);
}

INLINE UINT CSendBuf::GetCbBuf()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_cbBuf);
}

INLINE void CSendBuf::SetCbBuf(UINT cb)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _cbBuf = cb;
}

INLINE UINT CSendBuf::DecCbBuf(UINT cb)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _cbBuf -= cb;
}

INLINE CSocket * CSendBuf::GetSocket()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_pSocket);
}

// ---------------------------------------------------------------------------------------
// CTcpSendBuf
// ---------------------------------------------------------------------------------------

class CTcpSendBuf : public CSendBuf
{

    // Data ------------------------------------------------------------------------------

public:

    TCPSEQ              seq;            // starting sequence number for this TCP segment
    TCPSEQ              seqnext;        // the first seqno after this segment
    WORD                retries;        // number of times this segment has been rexmitted
    BYTE                tcpflags;       // TCP segment flags
    BYTE                tcphdrlen;      // TCP segment header length
    UINT                firstSendTime;  // the time this segment was first sent

};

// ---------------------------------------------------------------------------------------
// CSocket Inlines
// ---------------------------------------------------------------------------------------

INLINE void CSocket::Init(CXnBase * pXnBase, BOOL fTcp, BOOL fPoolAlloc)
{
    ICHECK_(pXnBase, SOCK, USER|UDPC|SDPC);

#ifdef XNET_FEATURE_ASSERT
    _pXnBase        = pXnBase;
#endif

    _lLock          = SOCK_LOCK_ACTIVE;
    _dwFlags        = (fPoolAlloc ? SOCKF_POOLALLOC : 0) | (fTcp ? SOCKF_TCP : 0);
    _cbMaxSendBuf   = pXnBase->cfgSockDefaultSendBufsizeInK * 1024;
    _cbMaxRecvBuf   = pXnBase->cfgSockDefaultRecvBufsizeInK * 1024;

    InitializeListHead(&_le);
    InitializeListHead(&_leRecvBufs);
    InitializeListHead(&_leSendBufs);
    EvtInit(EvtRef(_Event));
}

INLINE void CSocket::Enqueue(LIST_ENTRY * pleHead)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(!IsListNull(&_le));
    AssertList(pleHead);
    InsertTailList(pleHead, &_le);
}

INLINE void CSocket::Dequeue()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(!IsListNull(&_le));
    RemoveEntryList(&_le);
}

INLINE void CSocket::Unlock()
{
    ICHECK_(GetXnBase(), SOCK, USER);
    Assert(_lLock == SOCK_LOCK_BUSY);
    _lLock = SOCK_LOCK_ACTIVE;
}

INLINE void CSocket::SetClosed()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _lLock = SOCK_LOCK_CLOSED;
}

INLINE BOOL CSocket::IsLingering()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(TestFlags(SOCKF_LINGERING));
}

INLINE PRKEVENT CSocket::GetEvent()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(EvtRef(_Event));
}

INLINE void CSocket::SignalEvent(DWORD dwFlags)
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);

    if (TestFlags(dwFlags))
    {
        EvtSet(EvtRef(_Event), EVENT_INCREMENT);
    }
}

INLINE DWORD CSocket::GetFlags(DWORD dwMask)
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(_dwFlags & dwMask);
}

INLINE void CSocket::SetFlags(DWORD dwFlags)
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    SetFlagsAndOr(0xFFFFFFFF, dwFlags);
}

INLINE void CSocket::SetFlags(DWORD dwFlags, DWORD dwMask)
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    SetFlagsAndOr(~dwMask, dwFlags & dwMask);
}

INLINE void CSocket::ClearFlags(DWORD dwFlags)
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    SetFlagsAndOr(~dwFlags, 0);
}

INLINE BOOL CSocket::TestFlags(DWORD dwFlags)
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(!!(_dwFlags & dwFlags));
}

INLINE BOOL CSocket::IsTcp()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(TestFlags(SOCKF_TCP));
}

INLINE BOOL CSocket::IsUdp()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(!IsTcp());
}

INLINE const char * CSocket::TypeStr()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(IsUdp() ? "UDP" : "TCP");
}

INLINE BOOL CSocket::HasRecvReq()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_pRecvReq != NULL);
}

INLINE CRecvReq * CSocket::GetRecvReq()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_pRecvReq);
}

INLINE void CSocket::SetRecvReq(CRecvReq * pRecvReq)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _pRecvReq = pRecvReq;
}

INLINE BOOL CSocket::HasRecvBuf()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(!IsListEmpty(&_leRecvBufs));
}

INLINE CRecvBuf * CSocket::GetRecvBufNext(CRecvBuf * pRecvBuf)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);

    if (pRecvBuf == NULL)
        pRecvBuf = (CRecvBuf *)_leRecvBufs.Flink;
    else
        pRecvBuf = (CRecvBuf *)pRecvBuf->_le.Flink;

    return(pRecvBuf == (CRecvBuf *)&_leRecvBufs ? NULL : pRecvBuf);
}

INLINE CRecvBuf * CSocket::GetRecvBufFirst()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(GetRecvBufNext(NULL));
}

INLINE CRecvBuf * CSocket::GetRecvBufPrev(CRecvBuf * pRecvBuf)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(offsetof(CRecvBuf, _le) == 0);

    if (pRecvBuf == NULL)
        pRecvBuf = (CRecvBuf *)_leRecvBufs.Blink;
    else
        pRecvBuf = (CRecvBuf *)pRecvBuf->_le.Blink;

    return(pRecvBuf == (CRecvBuf *)&_leRecvBufs ? NULL : pRecvBuf);
}

INLINE CRecvBuf * CSocket::GetRecvBufLast()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(GetRecvBufPrev(NULL));
}

INLINE CRecvBuf * CSocket::DequeueRecvBuf()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(!IsListEmpty(&_leRecvBufs));
    Assert(offsetof(CRecvBuf, _le) == 0);
    CRecvBuf * pRecvBuf = (CRecvBuf *)RemoveHeadList(&_leRecvBufs);
    return(pRecvBuf);
}

INLINE void CSocket::DequeueRecvBuf(CRecvBuf * pRecvBuf)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(!IsListEmpty(&_leRecvBufs));
    AssertListEntry(&_leRecvBufs, &pRecvBuf->_le);
    RemoveEntryList(&pRecvBuf->_le);
}

INLINE void CSocket::EnqueueRecvBuf(CRecvBuf * pRecvBuf)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(pRecvBuf != NULL);
    AssertList(&_leRecvBufs);
    InsertTailList(&_leRecvBufs, &pRecvBuf->_le);
}

INLINE BOOL CSocket::IsRecvBufFull()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_cbRecvBuf >= _cbMaxRecvBuf);
}

INLINE BOOL CSocket::IsUdpRecvBufEmpty()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    Assert(IsUdp());
    return(IsListEmpty(&_leRecvBufs));
}

INLINE BOOL CSocket::IsTcpRecvBufEmpty()
{ 
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    Assert(IsTcp());
    return(_cbRecvBuf == 0);
}

INLINE BOOL CSocket::IsRecvBufEmpty()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(IsUdp() ? IsUdpRecvBufEmpty() : IsTcpRecvBufEmpty());
}

INLINE UINT CSocket::GetCbRecvBuf()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_cbRecvBuf);
}

INLINE void CSocket::SetCbRecvBuf(UINT cb)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _cbRecvBuf = cb;
}

INLINE BOOL CSocket::HasSendReq()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(_pSendReq != NULL);
}

INLINE CSendReq * CSocket::GetSendReq()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_pSendReq);
}

INLINE void CSocket::SetSendReq(CSendReq * pSendReq)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _pSendReq = pSendReq;
}

INLINE BOOL CSocket::HasSendBuf()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(!IsListEmpty(&_leSendBufs));
}

INLINE CSendBuf * CSocket::GetSendBufNext(CSendBuf * pSendBuf)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    LIST_ENTRY * ple = (pSendBuf == NULL) ? _leSendBufs.Flink : pSendBuf->_le.Flink;
    return(ple == &_leSendBufs ? NULL : (CSendBuf *)((BYTE *)ple - offsetof(CSendBuf, _le)));
}

INLINE CSendBuf * CSocket::GetSendBufFirst()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(GetSendBufNext(NULL));
}

INLINE CSendBuf * CSocket::DequeueSendBuf()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(!IsListEmpty(&_leSendBufs));
    AssertList(&_leSendBufs);
    LIST_ENTRY * ple = RemoveHeadList(&_leSendBufs);
    return((CSendBuf *)((BYTE *)ple - offsetof(CSendBuf, _le)));
}

INLINE void CSocket::DequeueSendBuf(CSendBuf * pSendBuf)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(!IsListEmpty(&_leSendBufs));
    AssertListEntry(&_leSendBufs, &pSendBuf->_le);
    RemoveEntryList(&pSendBuf->_le);
}

INLINE void CSocket::EnqueueSendBuf(CSendBuf * pSendBuf)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(pSendBuf != NULL);
    AssertList(&_leSendBufs);
    InsertTailList(&_leSendBufs, &pSendBuf->_le);
}

INLINE BOOL CSocket::IsSendBufFull()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(_cbSendBuf >= _cbMaxSendBuf);
}

INLINE BOOL CSocket::IsSendBufEmpty()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(IsListEmpty(&_leSendBufs));
}

INLINE UINT CSocket::GetCbSendBuf()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(_cbSendBuf);
}

INLINE void CSocket::SetCbSendBuf(UINT cb)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _cbSendBuf = cb;
}

INLINE UINT CSocket::IncCbSendBuf(UINT cb)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_cbSendBuf += cb);
}

INLINE UINT CSocket::DecCbSendBuf(UINT cb)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_cbSendBuf -= cb);
}

INLINE NTSTATUS CSocket::GetStatus()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(_status);
}

INLINE void CSocket::SetStatus(NTSTATUS status)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _status = status;
}

INLINE LIST_ENTRY * CSocket::GetFlink()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_le.Flink);
}

// ---------------------------------------------------------------------------------------
// CTcpSocket
// ---------------------------------------------------------------------------------------

class CTcpSocket : public CSocket
{
    // Definitions -----------------------------------------------------------------------

    #define TCPST_CLOSED            0
    #define TCPST_LISTEN            1
    #define TCPST_SYN_SENT          2
    #define TCPST_SYN_RECEIVED      3
    #define TCPST_ESTABLISHED       4
    #define TCPST_FIN_WAIT_1        5
    #define TCPST_FIN_WAIT_2        6
    #define TCPST_CLOSING           7
    #define TCPST_TIME_WAIT         8
    #define TCPST_CLOSE_WAIT        9
    #define TCPST_LAST_ACK          10
    #define TCPST_MAX               TCPST_LAST_ACK

    #define UDP_DEFAULT_MSS         ESP_MSS(576, sizeof(CUdpHdr))
    #define UDP_MAXIMUM_MSS         ESP_MSS(ENET_DATA_MAXSIZE, sizeof(CUdpHdr))

    #define TCP_MINIMUM_MSS         (MAXIPHDRLEN+MAXTCPHDRLEN+8-sizeof(CIpHdr)-sizeof(CTcpHdr))
    #define TCP_DEFAULT_MSS         ESP_MSS(576, sizeof(CTcpHdr))
    #define TCP_MAXIMUM_MSS         ESP_MSS(ENET_DATA_MAXSIZE, sizeof(CTcpHdr))
    #define MAX_TCP_WNDSIZE         0xFFFF

    #define MIN_TEMP_PORT           1024
    #define MAX_TEMP_PORT           4998
    #define TEMP_PORT_COUNT         (MAX_TEMP_PORT-MIN_TEMP_PORT+1)

    #define SEQ_LT(a, b)            ((INT) ((a) - (b)) < 0)
    #define SEQ_LE(a, b)            ((INT) ((a) - (b)) <= 0)
    #define SEQ_GT(a, b)            ((INT) ((a) - (b)) > 0)
    #define SEQ_GE(a, b)            ((INT) ((a) - (b)) >= 0)

    #define SRTT_SHIFT              3
    #define SRTT_SCALE              (1 << SRTT_SHIFT)
    #define RTTVAR_SHIFT            2
    #define RTTVAR_SCALE            (1 << RTTVAR_SHIFT)

    // External --------------------------------------------------------------------------

public:

    INLINE void                 TcpInit(CXnBase * pXnBase);
    INLINE static CTcpSocket *  TimerToSocket(CTimer * pt);
    INLINE BOOL                 HasParent();
    INLINE CTcpSocket *         GetParent();
    INLINE BOOL                 IsChild();
           void                 EnqueueChild(CTcpSocket * pTcpSocketChild);
           void                 DequeueChild(CTcpSocket * pTcpSocketChild);
    INLINE CTcpSocket *         GetNextChild(CTcpSocket * pTcpSocketPrev);
    INLINE CTcpSocket *         GetFirstChild();
    INLINE CTcpSocket *         GetPrevChild(CTcpSocket * pTcpSocketNext);
    INLINE CTcpSocket *         GetLastChild();
    INLINE BOOL                 HasConnectedChild();
           CTcpSocket *         GetConnectedChild();
           CTcpSocket *         DequeueConnectedChild();
    INLINE UINT                 GetBacklog();
    INLINE UINT                 GetBacklogMax();
    INLINE void                 SetBacklogMax(UINT cBacklogMax);
    INLINE UINT                 IncDupAcks();
    INLINE void                 SetDupAcks(UINT cDupAcks);
    INLINE UINT                 GetState();
    INLINE void                 SetState(UINT uiState);
    INLINE BOOL                 IsIdleState();
    INLINE BOOL                 IsListenState();
    INLINE BOOL                 IsSyncState();
    INLINE BOOL                 IsFinReceived();
    INLINE BOOL                 IsFinSent();
    INLINE void                 IncrementCongestionWindow(UINT uiIncr);
    INLINE void                 ResetSlowStartThresh();
    INLINE void                 GetLinger(LINGER * pLinger);
    INLINE void                 SetLinger(LINGER * pLinger);
    INLINE BOOL                 GetLingerOnOff();
    INLINE void                 SetLingerOnOff(BOOL fOn);
    INLINE UINT                 GetLingerTimeout();
    INLINE CTimer *             GetTimer();
    INLINE CTcpSendBuf *        GetSendBufPtr();
    INLINE void                 SetSendBufPtr(CTcpSendBuf * pTcpSendBuf);

    // Data ------------------------------------------------------------------------------

private:

    CTcpSocket *            _pTcpSocketParent;
    LIST_ENTRY              _le;
    CTimer                  _timer;
    BYTE                    _bState;
    BYTE                    _bBacklog;
    BYTE                    _bBacklogMax;
    BYTE                    _bDupAcks;
    LINGER                  _Linger;
    CTcpSendBuf *           _pTcpSendBufPtr;

public:

    //
    // TCP timers
    //  delayedAcks is the number of delay-acked segments;
    //
    // NOTE: Be careful when you add or remove fields between
    // delayedAcks and rtt_tick (inclusive). See comments in
    // function TcpReset().
    //
    UINT delayedAcks;
    UINT dwTickSyn;        // connection establishment timer
    UINT dwTickXmit;       // retransmission & persist timer
    UINT dwTickWait;       // TIME-WAIT & linger timer

    //
    // Send/receive state information
    //
    TCPSEQ snd_isn;         // initial send sequence number
    TCPSEQ snd_una;         // sent but not yet acknowledged
    TCPSEQ snd_nxt;         // buffered but not yet sent
    TCPSEQ snd_end;         // not yet buffered
    TCPSEQ snd_wl1;         // seq and ack numbers of the last ACK 
    TCPSEQ snd_wl2;         // that was used to update snd_wnd
    UINT snd_wnd;           // send window
    UINT snd_cwnd;          // congestion window
    UINT snd_ssthresh;      // slow-start threshold
    UINT snd_mss;           // send MSS
    TCPSEQ rcv_isn;         // initial receive sequence number
    TCPSEQ rcv_nxt;         // next expected receive sequence number
    UINT rcv_wnd;           // receive window
    UINT rcv_mss;           // receive MSS
    UINT rcv_swsthresh;     // receive SWS avoidance threshold

    //
    // Round-trip time measurements
    //
    INT srtt_8;             // smoothed round-trip time, in 1/8 ticks
    INT rttvar_4;           // round-trip time variance, in 1/4 ticks
    UINT RTO;               // retransmission timeout, in ticks
    TCPSEQ rtt_seq;         // the seqno of the segment being timed
    UINT rtt_tick;          // when the timed segment was sent

};

INLINE CTcpSocket * CTcpSocket::TimerToSocket(CTimer * pt)
{
    return((CTcpSocket *)((BYTE *)pt - offsetof(CTcpSocket, _timer)));
}

INLINE BOOL CTcpSocket::HasParent()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_pTcpSocketParent != NULL);
}

INLINE CTcpSocket * CTcpSocket::GetParent()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(_pTcpSocketParent != NULL);
    return(_pTcpSocketParent);
}

INLINE BOOL CTcpSocket::IsChild()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_pTcpSocketParent != NULL);
}

INLINE CTcpSocket * CTcpSocket::GetNextChild(CTcpSocket * pTcpSocketPrev)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    LIST_ENTRY * ple = pTcpSocketPrev ? pTcpSocketPrev->_le.Flink : _le.Flink;
    return(ple == &_le ? NULL : (CTcpSocket *)((BYTE *)ple - offsetof(CTcpSocket, _le)));
}

INLINE CTcpSocket * CTcpSocket::GetFirstChild()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(GetNextChild(NULL));
}
    
INLINE CTcpSocket * CTcpSocket::GetPrevChild(CTcpSocket * pTcpSocketNext)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    LIST_ENTRY * ple = pTcpSocketNext ? pTcpSocketNext->_le.Blink : _le.Blink;
    return(ple == &_le ? NULL : (CTcpSocket *)((BYTE *)ple - offsetof(CTcpSocket, _le)));
}

INLINE CTcpSocket * CTcpSocket::GetLastChild()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(GetPrevChild(NULL));
}

INLINE BOOL CTcpSocket::HasConnectedChild()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(GetConnectedChild() != NULL);
}

INLINE UINT CTcpSocket::GetBacklog()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_bBacklog);
}

INLINE UINT CTcpSocket::GetBacklogMax()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_bBacklogMax);
}

INLINE void CTcpSocket::SetBacklogMax(UINT cBacklogMax)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _bBacklogMax = (BYTE)cBacklogMax;
}

INLINE UINT CTcpSocket::IncDupAcks()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(++_bDupAcks);
}

INLINE void CTcpSocket::SetDupAcks(UINT cDupAcks)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(cDupAcks <= 255);
    _bDupAcks = (BYTE)cDupAcks;
}

INLINE UINT CTcpSocket::GetState()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_bState);
}

INLINE void CTcpSocket::SetState(UINT uiState)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(uiState <= TCPST_MAX);
    _bState = (BYTE)uiState;
}

INLINE BOOL CTcpSocket::IsIdleState()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    // CLOSED or LISTEN
    return(_bState <= TCPST_LISTEN);
}

INLINE BOOL CTcpSocket::IsListenState()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(_bState == TCPST_LISTEN);
}

INLINE BOOL CTcpSocket::IsSyncState()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    // ESTABLISHED, FIN_WAIT_1, FIN_WAIT_2, CLOSING, TIME_WAIT, CLOSE_WAIT, LAST_ACK
    return(_bState >= TCPST_ESTABLISHED);
}

INLINE BOOL CTcpSocket::IsFinReceived()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    // CLOSING, TIME_WAIT, CLOSE_WAIT, LAST_ACK
    return(_bState >= TCPST_CLOSING);
}

INLINE BOOL CTcpSocket::IsFinSent()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    // FIN_WAIT_1, FIND_WAIT_2, CLOSING, TIME_WAIT, LAST_ACK
    return(_bState >= TCPST_FIN_WAIT_1 && _bState != TCPST_CLOSE_WAIT);
}

INLINE void CTcpSocket::IncrementCongestionWindow(UINT uiIncr)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    snd_cwnd += uiIncr;
    if (snd_cwnd > MAX_TCP_WNDSIZE)
        snd_cwnd = MAX_TCP_WNDSIZE;
}

INLINE void CTcpSocket::ResetSlowStartThresh()
{
    snd_ssthresh = (snd_nxt - snd_una) >> 1;
    if (snd_ssthresh < 2*snd_mss)
        snd_ssthresh = 2*snd_mss;
}

INLINE void CTcpSocket::GetLinger(LINGER * pLinger)
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    *pLinger = _Linger;
}

INLINE void CTcpSocket::SetLinger(LINGER * pLinger)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _Linger = *pLinger;
}

INLINE BOOL CTcpSocket::GetLingerOnOff()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(!!_Linger.l_onoff);
}

INLINE void CTcpSocket::SetLingerOnOff(BOOL fOn)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _Linger.l_onoff = !!fOn;
}

INLINE UINT CTcpSocket::GetLingerTimeout()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_Linger.l_linger);
}

INLINE CTimer * CTcpSocket::GetTimer()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(&_timer);
}

INLINE CTcpSendBuf * CTcpSocket::GetSendBufPtr()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_pTcpSendBufPtr);
}

INLINE void CTcpSocket::SetSendBufPtr(CTcpSendBuf * pTcpSendBuf)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _pTcpSendBufPtr = pTcpSendBuf;
}

//
// Socket address length
//
#define SOCKADDRLEN ((INT) sizeof(SOCKADDR_IN))

//------------------------------------------------------------------------
// Prolog and epilog code for Winsock API functions
//------------------------------------------------------------------------

#if DBG

ExternTag(sock);

#define WinsockApiProlog_(_apiname, _result) \
        static const CHAR* fname_ = #_apiname; \
        INT err = (!this || SockGetRefs() <= 0) ? WSANOTINITIALISED : NO_ERROR; \
        WinsockApiCheckError_(_result) \
        TCHECK(USER); \

#define WinsockApiPrologLight_(_apiname) \
        static const CHAR* fname_ = #_apiname; \
        TCHECK(USER); \

#define WinsockApiPrologTrivial_(_apiname) \
        static const CHAR* fname_ = #_apiname; \

#define WinsockApiWarnError_(_err) { \
            if ((_err) != WSA_IO_PENDING && \
                (_err) != WSA_IO_INCOMPLETE && \
                (_err) != WSAETIMEDOUT && \
                (_err) != WSAEWOULDBLOCK) { \
                TraceSz2(Warning, "%s failed: %d", fname_, _err); \
            } \
        }

#define WinsockApiParamCheck_(_exp) { \
            if (!(_exp)) { \
                TraceSz2(Warning, "%s: %s", fname_, #_exp); \
                Rip("bad winsock parameters\n"); \
            } \
        }

#else // !DBG

#define WinsockApiProlog_(_apiname, _result) \
        INT err = (!this || SockGetRefs() <= 0) ? WSANOTINITIALISED : NO_ERROR; \
        WinsockApiCheckError_(_result) \
        TCHECK(USER); \

#define WinsockApiPrologLight_(_apiname)
#define WinsockApiPrologTrivial_(_apiname)
#define WinsockApiWarnError_(_err)
#define WinsockApiParamCheck_(_exp)

#endif // !DBG

#define WinsockApiReturnError_(_err, _result) { \
            WinsockApiWarnError_(_err); \
            SetLastError(_err); \
            return (_result); \
        }

#define WinsockApiCheckError_(_result) { \
            if (err != NO_ERROR) { \
                WinsockApiReturnError_(err, _result); \
            } \
        }

#define WinsockApiPrologSockLock_(_apiname, _result) \
        WinsockApiProlog_(_apiname, _result); \
        CSocket * pSocket = CSocket::Lock(s); \
        if (!pSocket) return (_result)

#define WinsockApiExitSockUnlock_(_resultOk, _resultErr) \
        exit: pSocket->Unlock(); \
        WinsockApiCheckError_(_resultErr); \
        return (_resultOk)

#define WinsockApiGotoExit_(_err) \
        { err = (_err); goto exit; }

#define MapNtStatusToWinsockError_(_err) \
        ((_err) = NT_SUCCESS(_err) ? NO_ERROR : RtlNtStatusToDosError(_err))

#define XNetInitCheck(_fname, _err) \
    if (this == NULL) \
    { \
        TraceSz1(Warning, "%s: You must call XNetStartup or WSAStartup before calling this function.", #_fname); \
        return(_err); \
    } \

#ifdef XNET_FEATURE_ASSERT
    #define XNetParamCheck(_fname, _pcheck, _err) \
        if (!(_pcheck)) \
        { \
            TraceSz2(Warning, "%s: %s", #_fname, #_pcheck); \
            Rip("bad XNet parameters\n"); \
            return(_err); \
        }
    #define XNetEnter(_fname, _pcheck) \
        const char * __pszFName__ = #_fname; \
        XNetInitCheck(_fname, WSANOTINITIALISED); \
        XNetParamCheck(_fname, _pcheck, WSAEFAULT)
    #define XNetLeave(_err) \
        if ((_err) != 0) { TraceSz2(Warning, "%s failed: %d", __pszFName__, (_err)); }
#else
    #define XNetParamCheck(_fname, _pcheck, _err)
    #define XNetEnter(fname, pcheck) XNetInitCheck(fname, WSANOTINITIALISED) 
    #define XNetLeave(_err)
#endif

//
// Stop TCP fast retransmit/recovery mode
//
INLINE VOID TcpStopFastRexmitMode(CTcpSocket* pTcpSocket) {
    pTcpSocket->ClearFlags(SOCKF_FAST_RETRANSMIT);
    pTcpSocket->SetDupAcks(0);
}

// ---------------------------------------------------------------------------------------
// CXnSock
// ---------------------------------------------------------------------------------------

class NOVTABLE CXnSock : public CXnIp
{
    friend void CTcpSocket::TcpInit(CXnBase * pXnBase);
    friend void CXnIp::UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen);
    friend void CXnIp::TcpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbHdrLen, UINT cbLen);
    friend void CXnIp::SockReset(CIpAddr ipa);

    // Definitions -----------------------------------------------------------------------

    //
    // Information about sockets that was passed to the select calls
    //
    typedef struct _SELECTINFO {
        SOCKET s;
        fd_set* fdset;
        INT eventMasks;
        CSocket* pSocket;
        INT pSocketMasks;
    } SELECTINFO;

    // External --------------------------------------------------------------------------

public:

    HAL_DECLARE_NEW_DELETE(CXnSock)

    NTSTATUS            SockInit(XNetInitParams * pxnip);
    void                SockStart()     { IpStart(); }
    void                SockStop()      { IpStop(); }
    void                SockTerm();

    LONG                XNetGetRefs()   { return(_cRefs); }
    LONG                XNetAddRef()    { return(++_cRefs); }
    LONG                XNetRelease()   { return(--_cRefs); }

    LONG                SockGetRefs()   { return(_cRefsSock); }
    LONG                SockAddRef()    { return(++_cRefsSock); }
    LONG                SockRelease()   { return(--_cRefsSock); }
    void                SockShutdown();

    #undef  XNETAPI
    #define XNETAPI(ret, fname, arglist, paramlist) ret fname arglist;
    #undef  XNETAPI_
    #define XNETAPI_(ret, fname, arglist, paramlist)
    #undef  XNETAPIV
    #define XNETAPIV(ret, fname, arglist, paramlist)

    SOCKAPILIST()

    // Internal --------------------------------------------------------------------------

private:

    VIRTUAL void        UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen);
    VIRTUAL void        TcpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbHdrLen, UINT cbLen);
    VIRTUAL void        SockReset(CIpAddr ipa);

    INLINE CSocket *    GetFirstSocket();
    INLINE CSocket *    GetNextSocket(CSocket * pSocketPrev);
    CSocket *           SockAlloc(BOOL fTcp, BOOL fPoolAlloc);
    NTSTATUS            SockClose(CSocket * pSocket, BOOL fForce);
    void                SockCleanup(CSocket * pSocket);
    void                SockFree(CSocket * pSocket);
    CSocket *           SockFindMatch(CIpPort toport, CIpAddr fromaddr, CIpPort fromport, BYTE type);
    NTSTATUS            SockUpdateBufferSize(CSocket* pSocket, INT sendBufsize, INT recvBufsize);
    NTSTATUS            SockBind(CSocket* pSocket, CIpPort ipportBind);
    NTSTATUS            SockWaitForEvent(CSocket* pSocket, INT eventMask, UINT timeout);
    INT                 SockCheckSelectEvents(CSocket * pSocket, INT eventMasks, INT setwait);
    void                SockReqComplete(CSocket * pSocket, CSockReq * pSockReq, NTSTATUS status);
    NTSTATUS            RecvReqEnqueue(CSocket * pSocket, CRecvReq * pRecvReq);
    NTSTATUS            SockQueueOverlappedSend(CSocket * pSocket, CSendReq * sendreq);
    NTSTATUS            SockRead(CSocket * pSocket, CRecvReq * recvreq);
    INT                 SockLockSelectSockets(fd_set* fdset, SELECTINFO* selinfo, INT offset, INT eventMasks);
    NTSTATUS            SockSend(CSocket* pSocket, CSendReq* sendreq);
    void                SockInsertToList(CSocket * pSocket);
    void                SockReleaseSendBuf(CSendBuf * pSendBuf);
    void                SockFlushRecvBuffers(CSocket* pSocket);
    VOID                TcpDisassociateChild(CTcpSocket * childTcp);
    VOID                TcpTrimBacklog(CTcpSocket* pTcpSocket, UINT cBacklogMax);
    BOOL                TcpClose(CTcpSocket* pTcpSocket, BOOL forceful);
    NTSTATUS            TcpShutdown(CTcpSocket* pTcpSocket, DWORD dwFlags, BOOL apicall);
    CTcpSocket *        TcpReset(CTcpSocket* pTcpSocket, NTSTATUS status);
    CTcpSocket *        TcpCloneChild(CTcpSocket * pTcpSocket);
    NTSTATUS            TcpListen(CTcpSocket* pTcpSocket, INT backlog);
    NTSTATUS            TcpConnect(CTcpSocket* pTcpSocket, CIpAddr dstaddr, CIpPort dstport, BOOL synAck);
    void                TcpSetState(CTcpSocket* pTcpSocket, BYTE state, const CHAR* caller);
    void                TcpSlideRecvWindow(CTcpSocket* pTcpSocket, UINT datalen);
    UINT                TcpCopyRecvData(CTcpSocket* pTcpSocket, CRecvReq* recvreq);
    NTSTATUS            TcpRead(CTcpSocket* pTcpSocket, CRecvReq* recvreq);
    void                TcpUpdateRTO(CTcpSocket* pTcpSocket);
    BOOL                TcpUpdatePersistFlag(CTcpSocket* pTcpSocket);
    void                TcpUpdateSndUna(CTcpSocket* pTcpSocket, TCPSEQ ack);
    BOOL                TcpValidateSeqs(CTcpSocket* pTcpSocket, TCPSEQ oldseq0, TCPSEQ oldseq1, TCPSEQ* newseq0, TCPSEQ* newseq1);
    BOOL                TcpVerifyRecvBuf(CTcpSocket* pTcpSocket);
    UINT                TcpCorrectMisorderedSegments(CTcpSocket* pTcpSocket, TCPSEQ seq, CTcpRecvBuf * recvbuf);
    void                TcpBufferMisorderedSegment(CTcpSocket* pTcpSocket, UINT seq, CTcpRecvBuf * recvbuf);
    UINT                TcpCompletePendingRecvReqFast(CTcpSocket* pTcpSocket, BYTE tcpflags, BYTE * pbData, UINT cbData);
    CTcpSocket *        TcpRecvData(CTcpSocket* pTcpSocket, CTcpHdr* tcphdr, BYTE * pbData, UINT cbData);
    void                TcpProcessFIN(CTcpSocket* pTcpSocket, CTcpHdr* tcphdr, TCPSEQ seqfin);
    BOOL                TcpParseOptions(CTcpSocket * pTcpSocket, CTcpHdr * tcphdr, struct _TcpOptions * opts);
    BOOL                TcpAcceptConnReqPassive(CTcpSocket* pTcpSocket, CTcpHdr* tcphdr, CIpAddr ipaSrc);
    void                TcpConnectionEstablished(CTcpSocket* pTcpSocket, CTcpHdr* tcphdr);
    BOOL                TcpAcceptConnReqActive(CTcpSocket* pTcpSocket, CTcpHdr* tcphdr);
    void                TcpSendSegment(CTcpSocket* pTcpSocket, CTcpSendBuf* sendbuf, BOOL fRetransmit);
    BOOL                TcpStartOutput(CTcpSocket* pTcpSocket);
    CTcpSocket *        TcpXmitTimeout(CTcpSocket* pTcpSocket);
    void                TcpDoFastRexmit(CTcpSocket* pTcpSocket);
    void                TcpQueueSegment(CTcpSocket* pTcpSocket, CPacket* pkt, BYTE tcpflags, UINT datalen);
    NTSTATUS            TcpSend(CTcpSocket* pTcpSocket, CSendReq * sendreq, UINT uiFlags);
    TCPSEQ              TcpSndNxt(CTcpSocket* pTcpSocket);
    VOID                TcpResetPeer(CTcpSocket* pTcpSocket);
    void                TcpEmitRST(CTcpSocket * pTcpSocket, CIpAddr ipaDst, CIpPort ipportDst, CIpPort ipportSrc, TCPSEQ seq, TCPSEQ ack, BYTE flags);
    NTSTATUS            TcpEmitSYN(CTcpSocket* pTcpSocket, BOOL synAck);
    void                TcpEmitACK(CTcpSocket* pTcpSocket);
    NTSTATUS            TcpEmitFIN(CTcpSocket * pTcpSocket);
    void                NeedSendACKNow(CTcpSocket * pTcpSocket);
    void                TcpTimer(CTimer * pt);
    CPacket *           TcpPacketAlloc(CTcpSocket * pTcpSocket, CIpAddr ipaDst, UINT uiFlags, UINT cbDat = 0, UINT cbPkt = 0, PFNPKTFREE pfn = NULL);
    void                TcpPacketFree(CPacket * ppkt);
    NTSTATUS            UdpConnect(CSocket* pSocket, CIpAddr dstaddr, CIpPort dstport);
    void                UdpRecvData(CSocket* pSocket, CIpAddr fromaddr, CIpPort fromport, BYTE * pbData, UINT cbData);
    NTSTATUS            UdpRead(CSocket* pSocket, CRecvReq* recvreq);
    NTSTATUS            UdpSend(CSocket* pSocket, CSendReq* sendreq, UINT uiFlags);
    void                UdpPacketFree(CPacket * ppkt);
    NTSTATUS            UdpShutdown(CSocket* pSocket, DWORD dwFlags);

    // Data ------------------------------------------------------------------------------

private:

    LONG                _cRefs;
    LONG                _cRefsSock;
    ULONG               _cSockets;
    LIST_ENTRY          _leSockets;
    LIST_ENTRY          _leDeadSockets;
    UINT                _ipportTempNext;

};

INLINE CSocket * CXnSock::GetNextSocket(CSocket * pSocketPrev)
{
    ICHECK(SOCK, UDPC|SDPC);
    LIST_ENTRY * ple = pSocketPrev ? pSocketPrev->GetFlink() : _leSockets.Flink;
    return(ple == &_leSockets ? NULL : (CSocket *)ple);
}

INLINE CSocket * CXnSock::GetFirstSocket()
{
    ICHECK(SOCK, UDPC|SDPC);
    return(GetNextSocket(NULL));
}

// ---------------------------------------------------------------------------------------
// CTcpSocket Inlines (Requires CSocket Declared)
// ---------------------------------------------------------------------------------------

INLINE void CTcpSocket::TcpInit(CXnBase * pXnBase)
{
    ICHECK_(pXnBase, SOCK, USER|UDPC|SDPC);

    _Linger.l_linger = pXnBase->cfgSockLingerTimeoutInSeconds;
    _Linger.l_onoff  = FALSE;
    _pTcpSendBufPtr  = NULL;
    snd_mss          = TCP_DEFAULT_MSS;
    rcv_mss          = TCP_DEFAULT_MSS;
    snd_cwnd         = MAX_TCP_WNDSIZE;
    snd_ssthresh     = MAX_TCP_WNDSIZE;
    srtt_8           = 0;
    rttvar_4         = (UINT)(pXnBase->cfgSockRexmitTimeoutInSeconds * TICKS_PER_SECOND);
    RTO              = rttvar_4;

    Assert(IsListNull(&_le) || IsListEmpty(&_le));
    InitializeListHead(&_le);

    Assert(!_timer.IsActive());
    _timer.Init((PFNTIMER)CXnSock::TcpTimer);
}

// ---------------------------------------------------------------------------------------
// CXn
// ---------------------------------------------------------------------------------------

class NOVTABLE CXn : public CXnSock
{

public:

    // External --------------------------------------------------------------------------

    #undef  XNETAPI
    #define XNETAPI(ret, fname, arglist, paramlist) ret fname arglist;
    #undef  XNETAPI_
    #define XNETAPI_(ret, fname, arglist, paramlist)
    #undef  XNETAPIV
    #define XNETAPIV(ret, fname, arglist, paramlist)

    XNETAPILIST()

};

#ifdef XNET_FEATURE_XBOX
extern CXn * g_pXn;
#define GetXn()      g_pXn
#define GetXnRef()  &g_pXn
#endif

// ---------------------------------------------------------------------------------------
// XNET_FEATURE_VIRTUAL
// ---------------------------------------------------------------------------------------

#ifndef XNET_FEATURE_VIRTUAL

INLINE void CXnBase::SecRegProbe() { ((CXnIp *)this)->SecRegProbe(); }
INLINE void CXnBase::NicTimer() { ((CXnNic *)this)->NicTimer(); }
INLINE void CXnNic::EnetRecv(CPacket * ppkt, UINT uiType) { ((CXnEnet *)this)->EnetRecv(ppkt, uiType); }
INLINE void CXnNic::EnetPush() { ((CXnEnet *)this)->EnetPush(); }
INLINE void CXnEnet::IpRecv(CPacket * ppkt) { ((CXnIp *)this)->IpRecv(ppkt); }
INLINE void CXnEnet::IpRecvArp(CEnetAddr * pea) { ((CXnIp *)this)->IpRecvArp(pea); }
INLINE void CXnIp::UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen) { ((CXnSock *)this)->UdpRecv(ppkt, pIpHdr, pUdpHdr, cbLen); }
INLINE void CXnIp::TcpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbHdrLen, UINT cbLen) { ((CXnSock *)this)->TcpRecv(ppkt, pIpHdr, pTcpHdr, cbHdrLen, cbLen); }
INLINE void CXnIp::SockReset(CIpAddr ipa) { ((CXnSock *)this)->SockReset(ipa); }

#endif

// ---------------------------------------------------------------------------------------
// XNET_FEATURE_FRAG
// ---------------------------------------------------------------------------------------

#ifndef XNET_FEATURE_FRAG

INLINE void CXnIp::FragTerm() {}

#endif

// ---------------------------------------------------------------------------------------
// XNET_FEATURE_ROUTE
// ---------------------------------------------------------------------------------------

#ifndef XNET_FEATURE_ROUTE

INLINE NTSTATUS CXnIp::RouteInit() { return(NETERR_OK); }
INLINE void     CXnIp::RouteTerm() {}
INLINE void     CXnIp::RouteAdd(CIpAddr ipaDst, CIpAddr ipaMask, CIpAddr ipaNext, WORD wFlags, WORD wMetric) {}
INLINE void     CXnIp::RouteDelete(CIpAddr ipaDst, CIpAddr ipaMask, CIpAddr ipaNext) {}
INLINE void     CXnIp::RouteRedirect(CIpAddr ipaDst, CIpAddr ipaOldGateway, CIpAddr ipNewGateway) {}
INLINE void     CXnIp::RouteRelease(CRouteEntry * prte) {}
INLINE void     CXnIp::RouteListOrphan() {}

#endif

// ---------------------------------------------------------------------------------------
// XNET_FEATURE_DHCP
// ---------------------------------------------------------------------------------------

#ifndef XNET_FEATURE_DHCP

INLINE NTSTATUS CXnIp::DhcpInit() { return(NETERR_OK); }
INLINE void     CXnIp::DhcpTerm() {}
INLINE void     CXnIp::DhcpTimer(CTimer * pt) {}
INLINE void     CXnIp::IpRecvArp(CEnetAddr *) {}

#endif

// ---------------------------------------------------------------------------------------
// XNET_FEATURE_TRACE
// ---------------------------------------------------------------------------------------

#ifndef XNET_FEATURE_TRACE

INLINE void CXnSock::TcpSetState(CTcpSocket* pTcpSocket, BYTE state, const CHAR* caller)
{
    pTcpSocket->SetState(state);
}

#endif

// ---------------------------------------------------------------------------------------
// XNET_FEATURE_ASSERT
// ---------------------------------------------------------------------------------------

#ifndef XNET_FEATURE_ASSERT

INLINE void *   CXnBase::LeakAdd(CLeakInfo * pli, void * pv, UINT cb, ULONG tag) { return(pv); }
INLINE void *   CXnBase::LeakDel(CLeakInfo * pli, void * pv) { return(pv); }

#endif

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\xnver.h ===
// ---------------------------------------------------------------------------------------
// xnver.h
//
// Include file for stamping source files with the appropriate version structure
// ---------------------------------------------------------------------------------------

#ifdef  __XNVER_H__
#error "xnver.h should not be included more than once"
#endif
#define __XNVER_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <xboxverp.h>

#ifdef XNET_FEATURE_XBOX
#pragma data_seg(push)
#pragma data_seg(".XBLD$V")
#endif

#if defined(XNET_BUILD_LIBX) && DBG==0
    #define VERXNET()   VERGEN(XNetBuildNumber,     'X','N','E','T',0,0,0,0)
#elif defined(XNET_BUILD_LIBX) 
    #define VERXNET()   VERGEN(XNetBuildNumberD,    'X','N','E','T','D',0,0,0)
#elif defined(XNET_BUILD_LIBXS) && DBG==0
    #define VERXNET()   VERGEN(XNetBuildNumberS,    'X','N','E','T','S',0,0,0)
#elif defined(XNET_BUILD_LIBXS)
    #define VERXNET()   VERGEN(XNetBuildNumberSD,   'X','N','E','T','S','D',0,0)
#elif defined(XNET_BUILD_LIBXW) && DBG==0
    #define VERXNET()   VERGEN(XNetBuildNumberW,    'X','N','E','T','S',0,0,0)
#elif defined(XNET_BUILD_LIBXW)
    #define VERXNET()   VERGEN(XNetBuildNumberWD,   'X','N','E','T','S','D',0,0)
#elif defined(XNET_BUILD_LIBM) && DBG==0
    #define VERXNET()   VERGEN(XNetBuildNumberM,    'X','N','E','T','M',0,0,0)
#elif defined(XNET_BUILD_LIBM)
    #define VERXNET()   VERGEN(XNetBuildNumberMD,   'X','N','E','T','M','D',0,0)
#elif defined(XNET_BUILD_LIBO) && DBG==0
    #define VERXNET()   VERGEN(XOnlineBuildNumber,  'X','O','N','L','I','N','E',0)
#elif defined(XNET_BUILD_LIBO)
    #define VERXNET()   VERGEN(XOnlineBuildNumberD, 'X','O','N','L','I','N','E','D')
#elif defined(XNET_BUILD_LIBOS) && DBG==0
    #define VERXNET()   VERGEN(XOnlineBuildNumberS, 'X','O','N','L','I','N','E','S')
#elif defined(XNET_BUILD_LIBOS)
    #define VERXNET()   VERGEN(XOnlineBuildNumberSD,'X','O','N','L','I','N','S','D')
#elif defined(XNET_BUILD_LIBOW) && DBG==0
    #define VERXNET()   VERGEN(XOnlineBuildNumberW, 'X','O','N','L','I','N','E','W')
#elif defined(XNET_BUILD_LIBOW)
    #define VERXNET()   VERGEN(XOnlineBuildNumberWD,'X','O','N','L','I','N','W','D')
#else
    #error "Don't know how to make VERXNET"
#endif

#if DBG
#define VERDBG  0x8000
#else
#define VERDBG  0x0000
#endif

//
// XNET_BUILD_LIBOS is not conditionally approved yet - when it is, uncomment the
// line below
//

// #if DBG==0 && (defined(XNET_BUILD_LIBXS) || defined(XNET_BUILD_LIBOS))
#if DBG==0 && (defined(XNET_BUILD_LIBXS))
#define VERSEC  0x2000
#else
#define VERSEC  0x0000
#endif

#define VERGEN(var,a1,a2,a3,a4,a5,a6,a7,a8) comment(linker, "/include:_" # var)
#pragma VERXNET()
#undef  VERGEN
#define VERGEN(var,a1,a2,a3,a4,a5,a6,a7,a8) var[8] = { (a1) | ((a2) << 8), (a3) | ((a4) << 8), (a5) | ((a6) << 8), (a7) | ((a8) << 8), VER_PRODUCTVERSION | VERDBG | VERSEC }
__declspec(selectany) unsigned short VERXNET();
#undef  VERGEN
#undef  VERDBG
#undef  VERSEC
#undef  VERXNET

#ifdef XNET_FEATURE_XBOX
#pragma data_seg(pop)
#endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\sockudp.cpp ===
// ---------------------------------------------------------------------------------------
// sockudp.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(udpWarn, TAG_ENABLE);

// ---------------------------------------------------------------------------------------
// UdpShutdown
// ---------------------------------------------------------------------------------------

NTSTATUS CXnSock::UdpShutdown(CSocket* pSocket, DWORD dwFlags)
{
    RaiseToDpc();

    if (dwFlags & SOCKF_NOMORE_RECV)
    {
        SockReqComplete(pSocket, pSocket->GetRecvReq(), NETERR(WSAESHUTDOWN));
        SockFlushRecvBuffers(pSocket);
    }

    if (dwFlags & SOCKF_NOMORE_XMIT)
    {
        SockReqComplete(pSocket, pSocket->GetSendReq(), NETERR(WSAESHUTDOWN));
    }

    pSocket->SetFlags(dwFlags);

    return(NETERR_OK);
}

NTSTATUS CXnSock::UdpConnect(CSocket* pSocket, CIpAddr dstaddr, CIpPort dstport)
{
    if (    dstaddr == 0 && dstport != 0
        ||  dstaddr != 0 && dstport == 0
        ||  dstaddr.IsMulticast()
        || (dstaddr.IsLoopback() && dstaddr != IPADDR_LOOPBACK))
    {
        return(NETERR(WSAEADDRNOTAVAIL));
    }

    // Destination hasn't changed, no need to do anything
    if (dstaddr == pSocket->_ipaDst && dstport == pSocket->_ipportDst)
    {
        return(NETERR_OK);
    }

    // Is this socket allowed to send broadcast
    // datagrams on this socket?
    if (dstaddr.IsBroadcast() && !pSocket->TestFlags(SOCKF_OPT_BROADCAST))
    {
        return(NETERR(WSAEACCES));
    }

    RaiseToDpc();

    // If the socket is currently connected,
    // we need to disconnect it first.
    if (pSocket->TestFlags(SOCKF_CONNECTED))
    {
        pSocket->_ipaDst = 0;
        pSocket->_ipportDst = 0;

        if (pSocket->_prte)
        {
            RouteRelease(pSocket->_prte);
            pSocket->_prte = NULL;
        }

        pSocket->ClearFlags(SOCKF_CONNECTED);
    }

    // Discard any received packets that have been
    // queued up but not yet processed
    SockFlushRecvBuffers(pSocket);

    if (dstaddr != 0)
    {
        // Bind to a local address if necessary
        if (!pSocket->TestFlags(SOCKF_BOUND))
        {
            NTSTATUS status = SockBind(pSocket, 0);
            if (!NT_SUCCESS(status))
                return(status);
        }

        pSocket->_ipaDst = dstaddr;
        pSocket->_ipportDst = dstport;
        pSocket->SetFlags(SOCKF_CONNECTED);
    }

    return(NETERR_OK);
}

// ---------------------------------------------------------------------------------------
// UdpRead
// ---------------------------------------------------------------------------------------

NTSTATUS CXnSock::UdpRead(CSocket * pSocket, CRecvReq * pRecvReq)
{
    CUdpRecvBuf *   pUdpRecvBuf;
    UINT            cbCopy;
    NTSTATUS        status;

    {
        RaiseToDpc();

        if (pSocket->IsUdpRecvBufEmpty())
        {
            return(RecvReqEnqueue(pSocket, pRecvReq));
        }

        //
        // If there is unprocessed datagram,
        // we must not have any pending recv requests.
        // So we can satisfy the request immediately.
        //
        pUdpRecvBuf = (CUdpRecvBuf *)pSocket->DequeueRecvBuf();
        pSocket->SetCbRecvBuf(pSocket->GetCbRecvBuf() - pUdpRecvBuf->GetCbBuf());
    }

    pRecvReq->SetFromAddrPort(pUdpRecvBuf->fromaddr, pUdpRecvBuf->fromport);
    SecRegSetOwned(pUdpRecvBuf->fromaddr);

    if (pUdpRecvBuf->GetCbBuf() <= pRecvReq->buflen)
    {
        cbCopy = pUdpRecvBuf->GetCbBuf();
        pRecvReq->flags = 0;
        status = NETERR_OK;
    }
    else
    {
        cbCopy = pRecvReq->buflen;
        pRecvReq->flags = MSG_PARTIAL;
        status = NETERR_MSGSIZE;
    }

    *pRecvReq->bytesRecv = cbCopy;
    memcpy(pRecvReq->buf, pUdpRecvBuf+1, cbCopy);
    PoolFree(pUdpRecvBuf);

    return(status);
}

// ---------------------------------------------------------------------------------------
// UdpRecv
// ---------------------------------------------------------------------------------------

void CXnSock::UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbData)
{
    TCHECK(SDPC);

    CIpAddr     ipaDst      = pIpHdr->_ipaDst;
    CIpAddr     ipaSrc      = pIpHdr->_ipaSrc;
    CIpPort     ipportDst   = pUdpHdr->_ipportDst;
    CIpPort     ipportSrc   = pUdpHdr->_ipportSrc;
    BYTE *      pbData      = (BYTE *)pUdpHdr + sizeof(CUdpHdr);
    BOOL        fDelivered  = FALSE;
    CSocket *   pSocket;

    Assert(ipportDst != 0);
    Assert(ipportSrc != 0);

    if (ipaDst.IsBroadcast())
    {
        // Insecure broadcast UDP packets in the secure online stack are discarded. 

    #if defined(XNET_FEATURE_ONLINE) && !defined(XNET_FEATURE_INSECURE)
        if (ppkt->IsEsp())
    #endif
        {
            for (pSocket = GetFirstSocket(); pSocket; pSocket = GetNextSocket(pSocket))
            {
                if (    pSocket->GetFlags(SOCKF_TCP|SOCKF_BOUND|SOCKF_NOMORE_RECV) == SOCKF_BOUND
                    &&  (pSocket->_ipportSrc == ipportDst)
                    &&  (pSocket->_ipaDst == ipaSrc || !pSocket->_ipaDst)
                    &&  (pSocket->_ipportDst == ipportSrc || !pSocket->_ipportDst))
                {
                    TraceUdpHdr(pktRecv, pSocket, pUdpHdr, cbData);
                    UdpRecvData(pSocket, ipaSrc, ipportSrc, pbData, cbData);
                    fDelivered = TRUE;
                }
            }
        }
    }
    else
    {
        pSocket = SockFindMatch(ipportDst, ipaSrc, ipportSrc, SOCK_DGRAM);

        if (pSocket && pSocket->TestFlags(SOCKF_BOUND) && !pSocket->TestFlags(SOCKF_NOMORE_RECV))
        {
            // An insecure, non-loopback UDP packet will only be sent to a socket in the
            // secure online stack if the socket has explicitly allowed insecure packets.

        #if defined(XNET_FEATURE_ONLINE) && !defined(XNET_FEATURE_INSECURE)
            if (ppkt->IsEsp() || ppkt->TestFlags(PKTF_RECV_LOOPBACK) || pSocket->TestFlags(SOCKF_INSECURE))
        #endif
            {
                TraceUdpHdr(pktRecv, pSocket, pUdpHdr, cbData);
                UdpRecvData(pSocket, ipaSrc, ipportSrc, pbData, cbData);
                fDelivered = TRUE;
            }
        }
    }

#ifdef XNET_FEATURE_TRACE
    if (!fDelivered)
    {
        if (!ppkt->IsEsp() || ipaDst.IsBroadcast())
            TraceSz4(pktRecv, "[DISCARD] No UDP socket listening on port %d from %s:%d%s",
                     NTOHS(ipportDst), ipaSrc.Str(), NTOHS(ipportSrc),
                     ipaDst.IsBroadcast() ? " (via broadcast)" : "");
        else
            TraceSz3(pktWarn, "[DISCARD] No UDP socket listening on port %d from %s:%d",
                     NTOHS(ipportDst), ipaSrc.Str(), NTOHS(ipportSrc));
    }
#endif
}

void CXnSock::UdpRecvData(CSocket* pSocket, CIpAddr fromaddr, CIpPort fromport, BYTE * pbData, UINT cbData)
{
    if (pSocket->HasRecvReq())
    {
        CRecvReq *      pRecvReq;
        WSAOVERLAPPED * pWsaOverlapped;
        UINT            cbCopy;
        NTSTATUS        status;

        // If there is a pending receive request, then there must not be any receive buffers
        // enqueued on this socket (because they would have been consumed by the receive
        // request already).

        Assert(pSocket->IsUdpRecvBufEmpty());

        pRecvReq        = pSocket->GetRecvReq();
        pWsaOverlapped  = pRecvReq->_pWsaOverlapped;

        pRecvReq->SetFromAddrPort(fromaddr, fromport);
        SecRegSetOwned(fromaddr);

        cbCopy = min(cbData, pRecvReq->GetCbBuf());

        memcpy(pRecvReq->GetPbBuf(), pbData, cbCopy);

        pWsaOverlapped->_ioxfercnt = cbCopy;

        if (cbCopy < cbData)
        {
            pWsaOverlapped->_ioflags = MSG_PARTIAL;
            status = NETERR_MSGSIZE;
            TraceSz3(udpWarn, "[%X] Copied %ld bytes (%ld lost) into overlapped request",
                     pSocket, cbCopy, cbData - cbCopy);
        }
        else
        {
            pWsaOverlapped->_ioflags = 0;
            status = NETERR_OK;
            TraceSz2(pktRecv, "[%X] Copied %ld bytes directly into overlapped request",
                     pSocket, cbCopy);
        }

        SockReqComplete(pSocket, pRecvReq, status);
        return;
    }

    if (pSocket->IsRecvBufFull())
    {
        TraceSz3(udpWarn, "[%X] Receive buffer is full (%ld bytes).  UDP packet plus %ld data bytes lost.",
                 pSocket, pSocket->GetCbRecvBuf(), cbData);
        return;
    }

    // Copy the data into a receive buffer for later reading.
    
    CUdpRecvBuf * pUdpRecvBuf = (CUdpRecvBuf *)PoolAlloc(sizeof(CUdpRecvBuf) + cbData, PTAG_CUdpRecvBuf);

    if (pUdpRecvBuf == NULL)
    {
        TraceSz2(udpWarn, "[%X] Out of memory allocating receive buffer.  Packet and %ld data bytes lost.",
                 pSocket, cbData);
        return;
    }

    pUdpRecvBuf->Init(this);

    memcpy(pUdpRecvBuf + 1, pbData, cbData);
    pUdpRecvBuf->SetCbBuf(cbData);
    pUdpRecvBuf->fromaddr = fromaddr;
    pUdpRecvBuf->fromport = fromport;

    pSocket->SetCbRecvBuf(pSocket->GetCbRecvBuf() + cbData);
    pSocket->EnqueueRecvBuf(pUdpRecvBuf);
    pSocket->SignalEvent(SOCKF_EVENT_READ);

    TraceSz3(pktRecv, "[%X.u] Buffered %ld bytes (%ld available)",
             pSocket, cbData, pSocket->GetCbRecvBuf());
}

// ---------------------------------------------------------------------------------------
// UdpSend
// ---------------------------------------------------------------------------------------

NTSTATUS CXnSock::UdpSend(CSocket* pSocket, CSendReq * pSendReq, UINT uiFlags)
{
    CSendBuf *      pSendBuf;
    CUdpHdr *       pUdpHdr;
    CIpAddr         ipaDst;
    CRouteEntry **  pprte;

    if (pSendReq->sendtotal > UDP_MAXIMUM_MSS)
    {
        TraceSz3(udpWarn, "[%X] Can't send %ld bytes.  Maximum is %ld bytes.",
                 pSocket, pSendReq->sendtotal, UDP_MAXIMUM_MSS);
        return(NETERR_MSGSIZE);
    }

    Assert((uiFlags & ~(PKTF_POOLALLOC)) == 0);

    uiFlags |= PKTF_TYPE_UDP;

    ipaDst = pSendReq->toaddr ? pSendReq->toaddr->sin_addr.s_addr : pSocket->_ipaDst;

    if (ipaDst.IsSecure())
    {
        uiFlags |= PKTF_TYPE_ESP|PKTF_CRYPT;
    }
    else if (ipaDst.IsBroadcast())
    {
        uiFlags |= PKTF_TYPE_ESP|PKTF_CRYPT;

    #ifdef XNET_FEATURE_INSECURE
        if (cfgFlags & XNET_STARTUP_BYPASS_SECURITY)
        {
            uiFlags &= ~(PKTF_TYPE_ESP|PKTF_CRYPT);
        }
    #endif
    }
    else
    {
    #ifdef XNET_FEATURE_ONLINE
        if (pSocket->TestFlags(SOCKF_INSECURE))
        {
            uiFlags |= PKTF_XMIT_INSECURE;
        }
    #endif
    }

    pSendBuf = (CSendBuf *)PacketAlloc(PTAG_CUdpPacket, uiFlags, pSendReq->sendtotal,
                                       sizeof(CSendBuf), (PFNPKTFREE)UdpPacketFree);

    if (pSendBuf == NULL)
    {
        TraceSz1(udpWarn, "[%X] Out of memory allocating UDP packet", pSocket);
        return(NETERR_MEMORY);
    }

    pSendBuf->Init(pSocket, pSendReq->sendtotal, 2);

    pUdpHdr = pSendBuf->GetUdpHdr();

    // Make a copy of the user data that's passed in

    if (pSendReq->bufcnt == 1)
    {
        memcpy(pUdpHdr + 1, pSendReq->bufs->buf, pSendReq->sendtotal);
    }
    else
    {
        BYTE *      p      = (BYTE *)(pUdpHdr + 1);
        WSABUF *    bufs   = pSendReq->bufs;
        UINT        bufcnt = pSendReq->bufcnt;

        while (bufcnt--)
        {
            memcpy(p, bufs->buf, bufs->len);
            p += bufs->len;
            bufs++;
        }
    }

    if (pSendReq->toaddr)
    {
        pUdpHdr->_ipportSrc = pSocket->_ipportSrc;
        pUdpHdr->_ipportDst = pSendReq->toaddr->sin_port;
        pprte               = NULL;
    }
    else
    {
        pUdpHdr->_ipportSrc = pSocket->_ipportSrc;
        pUdpHdr->_ipportDst = pSocket->_ipportDst;
        pprte               = &pSocket->_prte;
    }

    pUdpHdr->_wLen = HTONS(sizeof(CUdpHdr) + pSendReq->sendtotal);
    pUdpHdr->_wChecksum = 0;

    {
        RaiseToDpc();
        pSocket->IncCbSendBuf(pSendReq->sendtotal);
        pSocket->EnqueueSendBuf(pSendBuf);
        TraceUdpHdr(pktXmit, pSocket, pUdpHdr, pSendReq->sendtotal);
        IpFillAndXmit(pSendBuf, ipaDst, IPPROTOCOL_UDP, pprte);
    }

    return(NETERR_OK);
}

void CXnSock::UdpPacketFree(CPacket * ppkt)
{
    ICHECK(SOCK, UDPC|SDPC);

    CSendBuf * pSendBuf = (CSendBuf *)ppkt;

    if (pSendBuf->Release() > 0)
    {
        CSocket * pSocket = pSendBuf->GetSocket();
        pSocket->DequeueSendBuf(pSendBuf);
        pSocket->DecCbSendBuf(pSendBuf->GetCbBuf());

        if (!pSocket->IsSendBufFull())
        {
            if (pSocket->HasSendReq())
            {
                CSendReq * pSendReq = pSocket->GetSendReq();
                NTSTATUS status = UdpSend(pSocket, pSendReq, PKTF_POOLALLOC);
                pSendReq->_pWsaOverlapped->_ioxfercnt = pSendReq->sendtotal;
                SockReqComplete(pSocket, pSendReq, status);
            }
            else
            {
                pSocket->SignalEvent(SOCKF_EVENT_WRITE);
            }
        }
    }

    PacketFree(ppkt);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\xnetp.cpp ===
// ---------------------------------------------------------------------------------------
// xnetp.cpp
//
// Implementation of private XNet API's
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(NatPort, 0);
DefineTag(NatFlow, 0);

// ---------------------------------------------------------------------------------------
// Reading and Writing Configuration Sectors
// ---------------------------------------------------------------------------------------

HANDLE _WSAAPI_ XNetOpenConfigVolume()
{
    HANDLE              hVolume;
    OBJECT_ATTRIBUTES   oa;
    OBJECT_STRING       os;
    IO_STATUS_BLOCK     statusBlock;
    NTSTATUS            status;

    RtlInitObjectString(&os, OTEXT("\\Device\\Harddisk0\\partition0"));
    InitializeObjectAttributes(&oa, &os, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenFile(&hVolume, SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE, &oa, &statusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_SYNCHRONOUS_IO_ALERT);

    if (!NT_SUCCESS(status))
    {
        TraceSz1(Warning, "XNetOpenConfigVolume: NtOpenFile returned %08lX", status);
        hVolume = INVALID_HANDLE_VALUE;
    }

    return(hVolume);
}

BOOL _WSAAPI_ XNetLoadConfigSector(HANDLE hVolume, UINT iSector, BYTE * pbData, UINT cbData)
{
    BYTE                abSector[XBOX_HD_SECTOR_SIZE];
    PXBOX_CONFIG_SECTOR pxbcs = (PXBOX_CONFIG_SECTOR)abSector;
    LARGE_INTEGER       liOffset;
    IO_STATUS_BLOCK     statusBlock;
    NTSTATUS            status;

    Assert(hVolume != INVALID_HANDLE_VALUE);
    Assert(cbData == sizeof(pxbcs->Data));

    if (iSector >= XBOX_NUM_CONFIG_SECTORS)
    {
        TraceSz2(Warning, "XNetSaveConfigSector (%d): iSector must be between 0 and %d",
                 iSector, XBOX_NUM_CONFIG_SECTORS);
        return(FALSE);
    }

    liOffset.QuadPart = (XBOX_CONFIG_SECTOR_INDEX + iSector) * XBOX_HD_SECTOR_SIZE;

    status = NtReadFile(hVolume, 0, NULL, NULL, &statusBlock, abSector, sizeof(abSector), &liOffset);

    if (!NT_SUCCESS(status))
    {
        TraceSz2(Warning, "XNetLoadConfigSector (%d): NtReadFile returned %08lX", iSector, status);
        return(FALSE);
    }

    if (    pxbcs->SectorBeginSignature != XBOX_CONFIG_SECTOR_BEGIN_SIGNATURE
        ||  pxbcs->SectorEndSignature != XBOX_CONFIG_SECTOR_END_SIGNATURE
        ||  pxbcs->Version < XBOX_CONFIG_VERSION
        ||  pxbcs->SectorCount < XBOX_CONFIG_SECTOR_COUNT)
    {
        return(FALSE);
    }

    memcpy(pbData, pxbcs->Data, sizeof(pxbcs->Data));
    return(TRUE);
}

BOOL _WSAAPI_ XNetSaveConfigSector(HANDLE hVolume, UINT iSector, const BYTE * pbData, UINT cbData)
{
    BYTE                abSector[XBOX_HD_SECTOR_SIZE];
    PXBOX_CONFIG_SECTOR pxbcs = (PXBOX_CONFIG_SECTOR)abSector;
    LARGE_INTEGER       liOffset;
    IO_STATUS_BLOCK     statusBlock;
    NTSTATUS            status;

    Assert(hVolume != INVALID_HANDLE_VALUE);
    Assert(cbData == sizeof(pxbcs->Data));

    if (iSector >= XBOX_NUM_CONFIG_SECTORS)
    {
        TraceSz2(Warning, "XNetSaveConfigSector (%d): iSector must be between 0 and %d",
                 iSector, XBOX_NUM_CONFIG_SECTORS);
        return(FALSE);
    }

    liOffset.QuadPart = (XBOX_CONFIG_SECTOR_INDEX + iSector) * XBOX_HD_SECTOR_SIZE;

    pxbcs->SectorBeginSignature = XBOX_CONFIG_SECTOR_BEGIN_SIGNATURE;
    pxbcs->SectorEndSignature = XBOX_CONFIG_SECTOR_END_SIGNATURE;
    pxbcs->Version = XBOX_CONFIG_VERSION;
    pxbcs->SectorCount = XBOX_CONFIG_SECTOR_COUNT;

    memcpy(pxbcs->Data, pbData, sizeof(pxbcs->Data));
    
    // Recompute the checksum of the configuration sector

    pxbcs->Checksum = 0;
    pxbcs->Checksum = ~XConfigChecksum(pxbcs, sizeof(*pxbcs));

    // Write the config sector back to the disk

    status = NtWriteFile(hVolume, 0, NULL, NULL, &statusBlock, abSector, sizeof(abSector), &liOffset);

    if (!NT_SUCCESS(status))
    {
        TraceSz2(Warning, "XNetSaveConfigSector (%d): NtWriteFile returned %08lX", iSector, status);
        return(FALSE);
    }

    return(TRUE);
}

BOOL _WSAAPI_ XNetCloseConfigVolume(HANDLE hVolume)
{
    if (hVolume != INVALID_HANDLE_VALUE)
    {
        NtClose(hVolume);
    }

    return(TRUE);
}

BOOL _WSAAPI_ XNetLoadConfigParams(XNetConfigParams * pxncp)
{
    HANDLE hVolume = XNetOpenConfigVolume();

    if (hVolume != INVALID_HANDLE_VALUE)
    {
        pxncp->dwSigEnd = 0;

        XNetLoadConfigSector(hVolume, 0, (BYTE *)pxncp, sizeof(XNetConfigParams));

        if (pxncp->dwSigEnd != XNET_CONFIG_PARAMS_SIGEND)
        {
            memset(pxncp, 0, sizeof(pxncp));
            pxncp->dwSigEnd = XNET_CONFIG_PARAMS_SIGEND;
        }

        XNetCloseConfigVolume(hVolume);
    }

    return(TRUE);
}

BOOL _WSAAPI_ XNetSaveConfigParams(const XNetConfigParams * pxncp)
{
    BOOL   fResult = FALSE;
    HANDLE hVolume = XNetOpenConfigVolume();

    if (hVolume != INVALID_HANDLE_VALUE)
    {
        Assert(pxncp->dwSigEnd == XNET_CONFIG_PARAMS_SIGEND);

        fResult = XNetSaveConfigSector(hVolume, 0, (BYTE *)pxncp, sizeof(XNetConfigParams));

        XNetCloseConfigVolume(hVolume);
    }

    return(fResult);
}

// ---------------------------------------------------------------------------------------
// XoBase Support
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ONLINE

void CXoBase::XnSetXoBase(CXoBase * pXoBase)
{
    GetXn()->IpSetXoBase(pXoBase);
}

void CXoBase::XnLogon(IN_ADDR inaLogon, ULONGLONG * pqwUserId, WSAEVENT hEventLogon)
{
    GetXn()->IpLogon(CIpAddr(inaLogon.s_addr), pqwUserId, hEventLogon);
}

DWORD CXoBase::XnLogonGetStatus(SGADDR * psgaddr)
{
    return(GetXn()->IpLogonGetStatus(psgaddr));
}

BOOL CXoBase::XnLogonGetQFlags(UINT iUserId, ULONGLONG * pqwUserId, DWORD * pdwQFlags, DWORD * pdwSeqQFlags)
{
    return(GetXn()->IpLogonGetQFlags(iUserId, pqwUserId, pdwQFlags, pdwSeqQFlags));
}

BOOL CXoBase::XnLogonSetQFlags(UINT iUserId, DWORD dwQFlagsSet, DWORD dwQFlagsClr)
{
    return(GetXn()->IpLogonSetQFlags(iUserId, dwQFlagsSet, dwQFlagsClr));
}

BOOL CXoBase::XnLogonSetPState(UINT iUserId, DWORD dwPState, const XNKID * pxnkid, UINT cbData, BYTE * pbData)
{
    return(GetXn()->IpLogonSetPState(iUserId, dwPState, pxnkid, cbData, pbData));
}

void CXoBase::XnLogoff()
{
    GetXn()->IpLogoff();
}

void CXoBase::XnSetEventTimer(BYTE * pbEventTimer, WSAEVENT hEvent, DWORD dwTimeout)
{
    GetXn()->IpSetEventTimer((CEventTimer *)pbEventTimer, hEvent, dwTimeout);
}

void CXoBase::XnRaiseToDpc(BOOL fRaise)
{
    GetXn()->IpRaiseToDpc(fRaise);
}

#ifdef XNET_FEATURE_ASSERT

void * CXoBase::XnLeakAdd(CLeakInfo * pli, void * pv, UINT cb, ULONG tag)
{
    return(GetXn()->LeakAdd(pli, pv, cb, tag));
}

void * CXoBase::XnLeakDel(CLeakInfo * pli, void * pv)
{
    return(GetXn()->LeakDel(pli, pv));
}

void CXoBase::XnLeakTerm(CLeakInfo * pli)
{
    GetXn()->LeakTerm(pli);
}

#endif

#endif

// ---------------------------------------------------------------------------------------
// Simulated Network Address Translator
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_WINDOWS

#include <pshpack1.h>

struct CDhcpHdr
{
    // Definitions -----------------------------------------------------------------------

    #define DHCP_OP_BOOTREQUEST         1
    #define DHCP_OP_BOOTREPLY           2

    #define DHCP_HWTYPE_ETHERNET        1
    #define DHCP_FLAGS_BROADCAST        0x0008
    #define DHCP_MAGIC_COOKIE           0x63538263

    #define DHCP_TYPE_DISCOVER          1
    #define DHCP_TYPE_OFFER             2
    #define DHCP_TYPE_REQUEST           3
    #define DHCP_TYPE_DECLINE           4
    #define DHCP_TYPE_ACK               5
    #define DHCP_TYPE_NAK               6
    #define DHCP_TYPE_RELEASE           7
    #define DHCP_TYPE_INFORM            8

    #define DHCP_OPT_PAD                0
    #define DHCP_OPT_SUBNET_MASK        1
    #define DHCP_OPT_ROUTERS            3
    #define DHCP_OPT_DNS_SERVERS        6
    #define DHCP_OPT_DOMAIN_NAME        15
    #define DHCP_OPT_REQUESTED_IPADDR   50
    #define DHCP_OPT_IPADDR_LEASE_TIME  51
    #define DHCP_OPT_FIELD_OVERLOAD     52
    #define DHCP_OPT_MESSAGE_TYPE       53
    #define DHCP_OPT_SERVERID           54
    #define DHCP_OPT_PARAM_REQUEST_LIST 55
    #define DHCP_OPT_T1_INTERVAL        58
    #define DHCP_OPT_T2_INTERVAL        59
    #define DHCP_OPT_CLIENTID           61
    #define DHCP_OPT_END                255

    #define DHCP_OVERLOAD_FILE          1
    #define DHCP_OVERLOAD_SERVER        2

    // Functions -------------------------------------------------------------------------

    BOOL        GetOpt(UINT cbLen, BYTE bOpt, UINT cbOpt, BOOL fVariable, BYTE ** ppbOpt, UINT * pcbOpt);
    static BOOL GetOpt(BYTE * pb, UINT cb, BYTE bOpt, UINT cbOpt, BOOL fVar, BYTE ** ppbOpt, UINT * pcbOpt, BYTE * pbOver);

    // Data ------------------------------------------------------------------------------

    BYTE        _bOp;               // DHCP_OP_*
    BYTE        _bHwType;           // DHCP_HWTYPE_*
    BYTE        _bHwLen;            // hardware address length
    BYTE        _bHops;             // relay hops
    DWORD       _dwXid;             // random transaction identifier
    WORD        _wSecs;             // seconds since address acquisition process began
    WORD        _wFlags;            // DHCP_FLAGS_*
    CIpAddr     _ipaC;              // IP address requested by client
    CIpAddr     _ipaY;              // IP address assigned to client
    CIpAddr     _ipaS;              // IP address of DHCP server
    CIpAddr     _ipaG;              // IP address of gateway in trans-router booting
    CEnetAddr   _ea;                // Ethernet Address of client
    BYTE        _abHwPad[10];       // Pad hardware address to full 16 bytes
    char        _achServer[64];     // Null-terminated server hostname
    char        _achFile[128];      // Null-terminated name of bootfile
    DWORD       _dwMagicCookie;     // DHCP_MAGIC_COOKIE

};

#include <poppack.h>

BOOL CDhcpHdr::GetOpt(UINT cbLen, BYTE bOpt, UINT cbOpt, BOOL fVar, BYTE ** ppbOpt, UINT * pcbOpt)
{
    BYTE bOver = 0;

    if (GetOpt((BYTE *)(this + 1), cbLen - sizeof(CDhcpHdr), bOpt, cbOpt, fVar, ppbOpt, pcbOpt, &bOver))
    {
        return(TRUE);
    }

    if (bOver & DHCP_OVERLOAD_FILE)
    {
        if (GetOpt((BYTE *)_achFile, sizeof(_achFile), bOpt, cbOpt, fVar, ppbOpt, pcbOpt, NULL))
        {
            return(TRUE);
        }
    }

    if (bOver & DHCP_OVERLOAD_SERVER)
    {
        if (GetOpt((BYTE *)_achServer, sizeof(_achServer), bOpt, cbOpt, fVar, ppbOpt, pcbOpt, NULL))
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

BOOL CDhcpHdr::GetOpt(BYTE * pb, UINT cb, BYTE bOpt, UINT cbOpt, BOOL fVar, BYTE ** ppbOpt, UINT * pcbOpt, BYTE * pbOver)
{
    BYTE b1, b2;

    while (cb > 0)
    {
        b1  = *pb++;
        cb -= 1;

        if (b1 == DHCP_OPT_END)
            break;

        if (b1 == DHCP_OPT_PAD)
            continue;

        if (cb == 0)
        {
            TraceSz1(Warning, "CDhcpHdr::GetOpt(%d) - Premature end of option list", bOpt);
            break;
        }

        b2  = *pb++;
        cb -= 1;

        if (b2 == 0 || b2 > cb)
        {
            TraceSz3(Warning, "CDhcpHdr::GetOpt(%d) - Option length (%d) is invalid (cb %d)", bOpt, b2, cb);
            break;
        }

        if (b1 == DHCP_OPT_FIELD_OVERLOAD && pbOver && *pbOver == 0 && b2 == 1)
        {
            *pbOver = *pb;
        }

        if (b1 == bOpt)
        {
            if (    (!fVar && b2 != cbOpt)
                ||  ( fVar && (b2 < cbOpt || (b2 % cbOpt) != 0)))
            {
                TraceSz4(Warning, "CDhcpHdr::GetOpt(%d) - Option length (%d) is invalid (%d%s)",
                         bOpt, b2, cbOpt, fVar ? " variable" : "");
                break;
            }

            *ppbOpt = pb;

            if (pcbOpt)
            {
                *pcbOpt = b2;
            }

            return(TRUE);
        }

        pb += b2;
        cb -= b2;
    }

    return(FALSE);
}

class CXnNat
{
    // Definitions -----------------------------------------------------------------------

    struct CDhcpLease
    {
        CEnetAddr       _ea;                // Ethernet address of client
        CIpAddr         _ipa;               // IP address assigned to client
        FILETIME        _ftExpire;          // Expiration time of the lease
    };

    struct CNatFilt
    {
        CIpAddr         _ipaOuter;          // IP address of server on outer lan
        CIpPort         _ipportOuter;       // IP port of server on outer lan
        DWORD           _dwTick;            // Tick of last packet activity through this filter
    };

    struct CNatPort
    {
        LIST_ENTRY      _leHash;            // Link into hash table bucket
        LIST_ENTRY      _leLru;             // Link into LRU list
        CIpAddr         _ipaInner;          // IP address of client on inner lan
        CIpPort         _ipportInner;       // IP port of client on inner lan
        CIpPort         _ipportNat;         // IP port assigned by NAT
        CIpAddr         _ipaOuter;          // IP address of server on outer lan (aggressive) 
        CIpPort         _ipportOuter;       // IP port of server on outer lan (aggressive)
        CNatFilt *      _pNatFilt;          // Vector of sorted CNatFilt structures
        UINT            _cNatFilt;          // Count of CNatFilt structures in _pNatFilt in use
        UINT            _cNatFiltAlloc;     // Count of CNatFilt structures in _pNatFilt
        DWORD           _dwTick;            // Tick of last packet activity through this mapping
    };

    class CXnIpNat : public CXnIp
    {

    public:

        HAL_DECLARE_NEW_DELETE(CXnIpNat)

        BOOL    Init(CXnNat * pXnNat, XNetStartupParams * pxnsp, XNetConfigParams * pxncp, char * pszXbox);
        void    Stop();
        void    Term();
        void    UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen);
        void    TcpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbHdrLen, UINT cbLen);
        void    SockReset(CIpAddr ipa) {}
        BOOL    IsGateway(CIpPort ipport);
        void    IpXmitIp(CPacket * ppkt) { CXnIp::IpXmitIp(ppkt); }

        CIpAddr GetIpa()                { return(_ipa); }
        CIpAddr GetIpaMask()            { return(_ipaMask); }
        CIpAddr GetIpaDns(UINT iDns)    { return(iDns < _options._dnsServerCount ? _options._dnsServers[iDns] : 0); }

    private:

        CXnNat *    _pXnNat;

    };

public:

    HAL_DECLARE_NEW_DELETE(CXnNat)

    BOOL        Init(NATCREATE * pNatCreate);
    void        Term();
    void        Recv(CXnIpNat * pXnIpNat, CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen);
    void        RecvDhcp(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen);
    void        RecvInner(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen);
    void        RecvOuter(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen);
    BOOL        IsGateway(CIpPort ipport, CXnIpNat * pXnIpNat);
    CNatPort *  NatPortLookup(CIpAddr ipaInner, CIpPort ipportInner, CIpAddr ipaOuter, CIpPort ipportOuter);
    CNatPort *  NatPortLookup(CIpPort ipportNat);
    BOOL        NatPortExpire(CNatPort * pNatPort);
    void        NatPortFree(CNatPort * pNatPort);
    CNatFilt *  NatFiltLookup(CNatPort * pNatPort, CIpAddr ipaOuter, CIpPort ipportOuter, BOOL fAlloc);

private:

    CXnIpNat *      _pXnIpNatInner;         // Inner network stack
    CXnIpNat *      _pXnIpNatOuter;         // Outer network stack
    DWORD           _dwIpaBase;             // Base IP address (host order) of DHCP server
    DWORD           _dwIpaLast;             // Last IP address (host order) of DHCP server
    DWORD           _dwIpaNext;             // Next IP address (host order) of DHCP server
    DWORD           _dwLeaseTime;           // Lease time in seconds for DHCP server
    CDhcpLease *    _pDhcpLease;            // Vector of CDhcpLease structures
    UINT            _cDhcpLease;            // Count of CDhcpLease structures in use
    UINT            _cDhcpLeaseAlloc;       // Count of CDhcpLease structures allocated
    UINT            _iAssign;               // See NAT_ASSIGN_*
    UINT            _iFilter;               // See NAT_FILTER_*
    UINT            _iTimeout;              // NAT timeout interval in ticks
    LIST_ENTRY *    _pleHash;               // Vector of hash buckets of CNatPort structures
    UINT            _cBucket;               // Number of buckets in the hash table
    LIST_ENTRY      _leLru;                 // CNatPort structures in LRU order
    CNatPort **     _ppNatPort;             // Mapping from ipportNat to CNatPort
    UINT            _iNatPortBase;          // Base ipportNat to assign
    UINT            _iNatPortLast;          // Last ipportNat to assign
    UINT            _iNatPortNext;          // Next ipportNat to assign
    UINT            _cNatPortFree;          // Count of free ipportNat
    BOOL            _fInitialized;          // TRUE when CXnNat::Init has completed

};

BOOL CXnNat::CXnIpNat::Init(CXnNat * pXnNat, XNetStartupParams * pxnsp, XNetConfigParams * pxncp, char * pszXbox)
{
    _pXnNat = pXnNat;

    XNetInitParams xnip;
    xnip.pxnp = (XNetParams *)pxnsp;
    xnip.pszXbox = pszXbox;
    HalQueryTsc(&xnip.liTime);

    NTSTATUS status = IpInit(&xnip);

    if (!NT_SUCCESS(status))
    {
        TraceSz1(Warning, "CXnNat::CXnIpNat::Init - IpInit failed (%08lX)", status);
        return(FALSE);
    }

    cfgFlags |= XNET_STARTUP_BYPASS_SECURITY;

    INT err = IpConfig(pxncp, XNET_CONFIG_NORMAL);

    if (err != 0)
    {
        TraceSz1(Warning, "CXnNat::CXnIpNat::Init - IpConfig failed (%08lX)", err);
        return(FALSE);
    }

    IpStart();

    return(TRUE);    
}

void CXnNat::CXnIpNat::Stop()
{
    if (TestInitFlag(INITF_HAL))
    {
        RaiseToDpc();
        IpStop();
    }
}

void CXnNat::CXnIpNat::Term()
{
    if (TestInitFlag(INITF_HAL))
    {
        RaiseToDpc();
        IpTerm();
    }

    _pXnNat = NULL;
}

void CXnNat::CXnIpNat::UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    _pXnNat->Recv(this, ppkt, pIpHdr, pUdpHdr, cbLen);
}

void CXnNat::CXnIpNat::TcpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbHdrLen, UINT cbLen)
{
    _pXnNat->Recv(this, ppkt, pIpHdr, (CUdpHdr *)pTcpHdr, cbLen);
}

BOOL CXnNat::CXnIpNat::IsGateway(CIpPort ipport)
{
    return(_pXnNat->IsGateway(ipport, this));
}

BOOL CXnNat::Init(NATCREATE * pNatCreate)
{
    _dwIpaBase     = NTOHL(pNatCreate->_inaBase.s_addr);
    _dwIpaLast     = NTOHL(pNatCreate->_inaLast.s_addr);
    _dwIpaNext     = _dwIpaBase;
    _dwLeaseTime   = pNatCreate->_dwLeaseTime;
    _iAssign       = pNatCreate->_iAssign;
    _iFilter       = pNatCreate->_iFilter;
    _iTimeout      = (pNatCreate->_iTimeout ? pNatCreate->_iTimeout : 60) * TICKS_PER_SECOND;
    _iNatPortBase  = pNatCreate->_iNatPortBase ? pNatCreate->_iNatPortBase : 1000;
    _iNatPortLast  = _iNatPortBase + (pNatCreate->_cNatPort ? pNatCreate->_cNatPort : 1000) - 1;
    _iNatPortNext  = _iNatPortBase;

    if (_iAssign < NAT_ASSIGN_MINIMAL && _iAssign > NAT_ASSIGN_AGGRESSIVE)
        _iAssign = NAT_ASSIGN_MINIMAL;
    if (_iFilter < NAT_FILTER_NONE || _iFilter > NAT_FILTER_ADDRESS_PORT)
        _iFilter = NAT_FILTER_NONE;

    if (_iNatPortLast > 0xFFFF)
        _iNatPortLast = 0xFFFF;

    _cNatPortFree  = _iNatPortLast - _iNatPortBase + 1;
    _cBucket       = _cNatPortFree * 160 / 100;

    static DWORD s_adwPrimes[] = { 37,59,89,139,227,359,577,929,1499,2423,3919,6337,10253,16573,
        26821,43391,70207,113591,183797,297377,481171,778541,1259701,2038217,3297913,5336129,
        8633983,13970093,22604069,36574151,59178199,95752333,154930511,250682837,405613333,
        656296153,1061909479,1718205583,2780115059,0xFFFFFFFF};

    DWORD * pdwPrime = s_adwPrimes;
    for (; _cBucket < *pdwPrime; pdwPrime++) ;
    _cBucket = *pdwPrime;

    _pleHash       = (LIST_ENTRY *)HalAllocZ(_cBucket * sizeof(LIST_ENTRY), PTAG_CNatPort);
    _ppNatPort     = (CNatPort **)HalAllocZ(_cNatPortFree * sizeof(CNatPort *), PTAG_CNatPort);
    _pXnIpNatInner = new CXnIpNat;
    _pXnIpNatOuter = new CXnIpNat;

    if (_pleHash == NULL || _ppNatPort == NULL || _pXnIpNatInner == NULL || _pXnIpNatOuter == NULL)
    {
        TraceSz(Warning, "CXnNat::Init - Out of memory");
        return(FALSE);
    }

    InitializeListHead(&_leLru);

    LIST_ENTRY *    ple     = _pleHash;
    UINT            cBucket = _cBucket;

    for (; cBucket > 0; --cBucket, ++ple)
    {
        InitializeListHead(ple);
    }

    if (!_pXnIpNatInner->Init(this, pNatCreate->_pxnsp, &pNatCreate->_xncpInner, pNatCreate->_achXboxInner))
    {
        return(FALSE);
    }

    if (!_pXnIpNatOuter->Init(this, pNatCreate->_pxnsp, &pNatCreate->_xncpOuter, pNatCreate->_achXboxOuter))
    {
        return(FALSE);
    }

    _fInitialized = TRUE;

    return(TRUE);
}

void CXnNat::Term()
{
    if (_pXnIpNatInner)
    {
        _pXnIpNatInner->Stop();
    }

    if (_pXnIpNatOuter)
    {
        _pXnIpNatOuter->Stop();
    }

    if (_pXnIpNatInner)
    {
        _pXnIpNatInner->Term();
        delete _pXnIpNatInner;
        _pXnIpNatInner = NULL;
    }

    if (_pXnIpNatOuter)
    {
        _pXnIpNatOuter->Term();
        delete _pXnIpNatOuter;
        _pXnIpNatOuter = NULL;
    }

    if (!IsListNull(&_leLru))
    {
        while (!IsListEmpty(&_leLru))
        {
            CNatPort * pNatPort = (CNatPort *)((BYTE *)_leLru.Flink - offsetof(CNatPort, _leLru));
            NatPortFree(pNatPort);
        }
    }

    if (_ppNatPort)
    {
        HalFree(_ppNatPort);
    }

    if (_pDhcpLease)
    {
        HalFree(_pDhcpLease);
    }
}

void CXnNat::Recv(CXnIpNat * pXnIpNat, CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    if (!_fInitialized)
        return;

    if (pXnIpNat == _pXnIpNatOuter)
        RecvOuter(ppkt, pIpHdr, pUdpHdr, cbLen);
    else if (pIpHdr->_bProtocol == IPPROTOCOL_UDP && pUdpHdr->_ipportDst == DHCP_SERVER_PORT)
        RecvDhcp(ppkt, pIpHdr, pUdpHdr, cbLen);
    else
        RecvInner(ppkt, pIpHdr, pUdpHdr, cbLen);
}

void CXnNat::RecvDhcp(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    if (cbLen < sizeof(CDhcpHdr))
    {
        TraceSz(pktWarn, "[DISCARD] CXnNat::RecvDhcp - DHCP payload is too small");
        return;
    }

    CDhcpHdr * pDhcpHdr = (CDhcpHdr *)(pUdpHdr + 1);

    if (    pDhcpHdr->_bOp != DHCP_OP_BOOTREQUEST
        ||  pDhcpHdr->_bHwType != DHCP_HWTYPE_ETHERNET
        ||  pDhcpHdr->_bHwLen != sizeof(CEnetAddr)
        ||  pDhcpHdr->_dwMagicCookie != DHCP_MAGIC_COOKIE)
    {
        TraceSz4(pktWarn, "[DISCARD] CXnNat::RecvDhcp - DHCP request is invalid (%d,%d,%d,%d)",
                 (pDhcpHdr->_bOp != DHCP_OP_BOOTREQUEST),
                 (pDhcpHdr->_bHwType != DHCP_HWTYPE_ETHERNET),
                 (pDhcpHdr->_bHwLen != sizeof(CEnetAddr)),
                 (pDhcpHdr->_dwMagicCookie != DHCP_MAGIC_COOKIE));
        return;
    }

    BYTE * pbOpt;
    UINT   cbOpt;
    BYTE   bType;

    if (!pDhcpHdr->GetOpt(cbLen, DHCP_OPT_MESSAGE_TYPE, 1, FALSE, &pbOpt, NULL))
    {
        TraceSz(pktWarn, "[DISCARD] CXnNat::RecvDhcp - DHCP_OPT_MESSAGE_TYPE not found");
        return;
    }

    bType = *pbOpt;

    if (bType != DHCP_TYPE_DISCOVER && bType != DHCP_TYPE_REQUEST)
    {
        TraceSz1(pktWarn, "[DISCARD] CXnNat::RecvDhcp - DHCP_OPT_MESSAGE_TYPE (%d) not supported", bType);
        return;
    }

    if (_pXnIpNatOuter->GetIpa() == 0)
    {
        TraceSz(pktWarn, "[DISCARD] CXnNat::RecvDhcp - NAT hasn't acquired outer IP address yet");
        return;
    }

    CDhcpLease * pDhcpLease = _pDhcpLease;
    UINT         cDhcpLease = _cDhcpLease;

    for (; cDhcpLease > 0; ++pDhcpLease, --cDhcpLease)
    {
        if (pDhcpLease->_ea.IsEqual(pDhcpHdr->_ea))
            break;
    }

    if (cDhcpLease == 0)
    {
        if (bType != DHCP_TYPE_DISCOVER)
        {
            TraceSz1(pktWarn, "[DISCARD] CXnNat::RecvDhcp - No lease found for %s", pDhcpHdr->_ea.Str());
            return;
        }

        for (; _dwIpaNext <= _dwIpaLast; ++_dwIpaNext)
        {
            if (CIpAddr(HTONL(_dwIpaNext)).IsValidAddr())
                break;
        }

        if (_dwIpaNext > _dwIpaLast)
        {
            TraceSz(pktWarn, "[DISCARD] CXnNat::RecvDhcp - Out of IP addresses");
            return;
        }

        if (_cDhcpLease == _cDhcpLeaseAlloc)
        {
            UINT         cDhcpLeaseAlloc = _cDhcpLeaseAlloc + 64;
            CDhcpLease * pDhcpLease      = (CDhcpLease *)HalAllocZ(cDhcpLeaseAlloc * sizeof(CDhcpLease), PTAG_CDhcpLease);

            if (pDhcpLease == NULL)
            {
                TraceSz(pktWarn, "[DISCARD] CXnNat::RecvDhcp - Out of memory allocating CDhcpLease vector");
                return;
            }

            if (_cDhcpLease > 0)
            {
                memcpy(pDhcpLease, _pDhcpLease, _cDhcpLease * sizeof(CDhcpLease));
                HalFree(_pDhcpLease);
            }

            _pDhcpLease      = pDhcpLease;
            _cDhcpLeaseAlloc = cDhcpLeaseAlloc;
        }

        pDhcpLease       = &_pDhcpLease[_cDhcpLease];
        pDhcpLease->_ea  = pDhcpHdr->_ea;
        pDhcpLease->_ipa = HTONL(_dwIpaNext);
        _dwIpaNext      += 1;
        _cDhcpLease     += 1;
    }

    if (bType == DHCP_TYPE_REQUEST)
    {
        if (!pDhcpHdr->GetOpt(cbLen, DHCP_OPT_REQUESTED_IPADDR, sizeof(CIpAddr), FALSE, &pbOpt, NULL))
        {
            TraceSz(pktWarn, "[DISCARD] CXnNat::RecvDhcp - REQUESTED_IPADDR not supplied");
            return;
        }

        if (*(CIpAddr *)pbOpt != pDhcpLease->_ipa)
        {
            TraceSz2(pktWarn, "[DISCARD] CXnNat::RecvDhcp - REQUESTED_IPADDR is %s, expecting %s",
                     *(CIpAddr *)pbOpt, pDhcpLease->_ipa);
            return;
        }
    }

    CPacket * ppktReply = _pXnIpNatInner->PacketAlloc(PTAG_CDhcpPacket,
        PKTF_TYPE_UDP|PKTF_XMIT_INSECURE|PKTF_POOLALLOC, sizeof(CDhcpHdr) + 128);

    if (ppktReply == NULL)
    {
        TraceSz(pktWarn, "[DISCARD] CXnNat::RecvDhcp - Out of memory allocating CDhcpPacket");
        return;
    }

    CIpHdr *    pIpHdrReply     = ppktReply->GetIpHdr();
    CUdpHdr *   pUdpHdrReply    = (CUdpHdr *)(pIpHdrReply + 1);
    CDhcpHdr *  pDhcpHdrReply   = (CDhcpHdr *)(pUdpHdrReply + 1);
    BYTE *      pbOptReply      = (BYTE *)(pDhcpHdrReply + 1);

    pUdpHdrReply->_ipportSrc = DHCP_SERVER_PORT;
    pUdpHdrReply->_ipportDst = DHCP_CLIENT_PORT;
    
    memset(pDhcpHdrReply, 0, sizeof(CDhcpHdr));
    pDhcpHdrReply->_bOp = DHCP_OP_BOOTREPLY;
    pDhcpHdrReply->_bHwType = DHCP_HWTYPE_ETHERNET;
    pDhcpHdrReply->_bHwLen = sizeof(CEnetAddr);
    pDhcpHdrReply->_dwXid = pDhcpHdr->_dwXid;
    pDhcpHdrReply->_wFlags = pDhcpHdr->_wFlags;
    pDhcpHdrReply->_ipaY = pDhcpLease->_ipa;
    pDhcpHdrReply->_ea = pDhcpLease->_ea;
    pDhcpHdrReply->_dwMagicCookie = DHCP_MAGIC_COOKIE;

    *pbOptReply++ = DHCP_OPT_MESSAGE_TYPE;
    *pbOptReply++ = 1;
    *pbOptReply++ = bType == DHCP_TYPE_DISCOVER ? DHCP_TYPE_OFFER : DHCP_TYPE_ACK;

    *pbOptReply++ = DHCP_OPT_IPADDR_LEASE_TIME;
    *pbOptReply++ = sizeof(DWORD);
    *(DWORD *)pbOptReply = HTONL(_dwLeaseTime);
    pbOptReply += sizeof(DWORD);

    *pbOptReply++ = DHCP_OPT_SERVERID;
    *pbOptReply++ = sizeof(CIpAddr);
    *(CIpAddr *)pbOptReply = _pXnIpNatInner->GetIpa();
    pbOptReply += sizeof(CIpAddr);

    if (pDhcpHdr->GetOpt(cbLen, DHCP_OPT_PARAM_REQUEST_LIST, 1, TRUE, &pbOpt, &cbOpt))
    {
        for (; cbOpt > 0; ++pbOpt, --cbOpt)
        {
            switch (*pbOpt)
            {
                case DHCP_OPT_SUBNET_MASK:
                    *pbOptReply++ = DHCP_OPT_SUBNET_MASK;
                    *pbOptReply++ = sizeof(CIpAddr);
                    *(CIpAddr *)pbOptReply = _pXnIpNatInner->GetIpaMask();
                    pbOptReply += sizeof(CIpAddr);
                    break;

                case DHCP_OPT_ROUTERS:
                    *pbOptReply++ = DHCP_OPT_ROUTERS;
                    *pbOptReply++ = sizeof(CIpAddr);
                    *(CIpAddr *)pbOptReply = _pXnIpNatInner->GetIpa();
                    pbOptReply += sizeof(CIpAddr);
                    break;

                case DHCP_OPT_DNS_SERVERS:
                {
                    CIpAddr *   pipa = (CIpAddr *)(pbOptReply + 2);
                    UINT        iDns;

                    for (iDns = 0; iDns < MAX_DEFAULT_DNSSERVERS; ++iDns)
                    {
                        CIpAddr ipaDns = _pXnIpNatOuter->GetIpaDns(iDns);

                        if (ipaDns == 0)
                            break;

                        *pipa++ = ipaDns;
                    }

                    if (iDns > 0)
                    {
                        *pbOptReply++ = DHCP_OPT_DNS_SERVERS;
                        *pbOptReply++ = iDns * sizeof(CIpAddr);
                        pbOptReply += iDns * sizeof(CIpAddr);
                    }
                    break;
                }
            }
        }
    }

    *pbOptReply++ = DHCP_OPT_END;

    ppktReply->SetCb(pbOptReply - (BYTE *)pIpHdrReply);
    pUdpHdrReply->_wLen = NTOHS(pbOptReply - (BYTE *)pUdpHdrReply);

    _pXnIpNatInner->IpFillAndXmit(ppktReply, pIpHdr->_ipaSrc ? pIpHdr->_ipaSrc : IPADDR_BROADCAST, IPPROTOCOL_UDP);
}

void CXnNat::RecvInner(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    if (    ppkt->TestFlags(PKTF_RECV_BROADCAST|PKTF_RECV_LOOPBACK)
        ||  ppkt->GetHdrOptLen() > 0
        ||  pIpHdr->_ipaDst == _pXnIpNatInner->GetIpa())
        return;

    CIpAddr     ipaInner    = pIpHdr->_ipaSrc;
    CIpPort     ipportInner = pUdpHdr->_ipportSrc;
    CIpAddr     ipaOuter    = pIpHdr->_ipaDst;
    CIpPort     ipportOuter = pUdpHdr->_ipportDst;
    DWORD       dwTick      = _pXnIpNatInner->TimerTick();

    CNatPort * pNatPort = NatPortLookup(ipaInner, ipportInner, ipaOuter, ipportOuter);

    if (pNatPort == NULL)
    {
        TraceSz5(Warning, "[DISCARD] Cannot allocate CNatPort for outbound %s [%s:%d %s:%d]",
                 pIpHdr->_bProtocol == IPPROTOCOL_UDP ? "UDP" : "TCP",
                 ipaInner.Str(), NTOHS(ipportInner), ipaOuter.Str(), NTOHS(ipportOuter));
        return;
    }

    pNatPort->_dwTick = dwTick;

    if (_iFilter)
    {
        CNatFilt * pNatFilt = NatFiltLookup(pNatPort, ipaOuter, ipportOuter, TRUE);

        if (pNatFilt == NULL)
        {
            TraceSz5(Warning, "[DISCARD] Out of memory allocating CNatFilt for outbound %s [%s:%d %s:%d]",
                     pIpHdr->_bProtocol == IPPROTOCOL_UDP ? "UDP" : "TCP",
                     ipaInner.Str(), NTOHS(ipportInner), ipaOuter.Str(), NTOHS(ipportOuter));
            return;
        }

        pNatFilt->_dwTick = dwTick;
    }

    // Copy the packet, change source address and port, and forward to _pXnIpNatOuter

    CPacket * ppktNat = _pXnIpNatOuter->PacketAlloc(PTAG_CNatPacket,
        PKTF_TYPE_IP|PKTF_POOLALLOC|PKTF_XMIT_INSECURE, ppkt->GetCb() - sizeof(CIpHdr));

    if (ppktNat == NULL)
    {
        TraceSz5(pktWarn, "[DISCARD] Out of memory allocating CNatPacket for outbound %s [%s:%d %s:%d]",
                 pIpHdr->_bProtocol == IPPROTOCOL_UDP ? "UDP" : "TCP",
                 ipaInner.Str(), NTOHS(ipportInner), ipaOuter.Str(), NTOHS(ipportOuter));
        return;
    }

    ppktNat->SetType((WORD)(pIpHdr->_bProtocol == IPPROTOCOL_UDP ? PKTF_TYPE_UDP : PKTF_TYPE_TCP));

    CIpHdr *  pIpHdrNat  = ppktNat->GetIpHdr();
    CUdpHdr * pUdpHdrNat = (CUdpHdr *)(pIpHdrNat + 1);

    Assert(ppkt->GetCb() == ppktNat->GetCb());
    memcpy(pIpHdrNat, pIpHdr, ppkt->GetCb());

    pIpHdrNat->_ipaSrc = _pXnIpNatOuter->GetIpa();
    pUdpHdrNat->_ipportSrc = pNatPort->_ipportNat;

    TraceSz10(NatFlow, ">> %s [%s:%d %s:%d] -> [%s:%d %s:%d] (+%d)",
              pIpHdr->_bProtocol == IPPROTOCOL_UDP ? "UDP" : "TCP",
              pIpHdr->_ipaSrc.Str(), NTOHS(pUdpHdr->_ipportSrc),
              pIpHdr->_ipaDst.Str(), NTOHS(pUdpHdr->_ipportDst),
              pIpHdrNat->_ipaSrc.Str(), NTOHS(pUdpHdrNat->_ipportSrc),
              pIpHdrNat->_ipaDst.Str(), NTOHS(pUdpHdrNat->_ipportDst),
              cbLen);

    _pXnIpNatOuter->IpXmit(ppktNat);
}

void CXnNat::RecvOuter(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    if (ppkt->TestFlags(PKTF_RECV_BROADCAST|PKTF_RECV_LOOPBACK) || ppkt->GetHdrOptLen() > 0)
        return;

    CIpAddr     ipaOuter    = pIpHdr->_ipaSrc;
    CIpPort     ipportOuter = pUdpHdr->_ipportSrc;
    CIpAddr     ipaNat      = pIpHdr->_ipaDst;
    CIpPort     ipportNat   = pUdpHdr->_ipportDst;
    DWORD       dwTick      = _pXnIpNatInner->TimerTick();

    CNatPort * pNatPort = NatPortLookup(ipportNat);

    if (pNatPort == NULL)
    {
        TraceSz5(NatPort, "!! No port mapping found for inbound %s [%s:%d %s:%d]",
                 pIpHdr->_bProtocol == IPPROTOCOL_UDP ? "UDP" : "TCP",
                 ipaOuter.Str(), NTOHS(ipportOuter), ipaNat.Str(), NTOHS(ipportNat));
        return;
    }

    pNatPort->_dwTick = dwTick;
    RemoveEntryList(&pNatPort->_leLru);
    InsertTailList(&_leLru, &pNatPort->_leLru);

    if (_iFilter)
    {
        CNatFilt * pNatFilt = NatFiltLookup(pNatPort, ipaOuter, ipportOuter, FALSE);

        if (pNatFilt == NULL)
        {
            TraceSz10(NatPort, "!! %s filter discarding inbound %s [%s:%d %s:%d] -> [%s:%d %s:%d]",
                      _iFilter == NAT_FILTER_ADDRESS ? "Addr" : _iFilter == NAT_FILTER_PORT ? "Port" : "AddrPort",
                      pIpHdr->_bProtocol == IPPROTOCOL_UDP ? "UDP" : "TCP",
                      ipaOuter.Str(), NTOHS(ipportOuter),
                      ipaNat.Str(), NTOHS(ipportNat),
                      ipaOuter.Str(), NTOHS(ipportOuter),
                      pNatPort->_ipaInner.Str(), NTOHS(pNatPort->_ipportInner));
            return;
        }

        pNatFilt->_dwTick = dwTick;
    }

    // Copy the packet, change source address and port, and forward to _pXnIpNatOuter

    CPacket * ppktNat = _pXnIpNatInner->PacketAlloc(PTAG_CNatPacket,
        PKTF_TYPE_IP|PKTF_POOLALLOC|PKTF_XMIT_INSECURE, ppkt->GetCb() - sizeof(CIpHdr));

    if (ppktNat == NULL)
    {
        TraceSz5(pktWarn, "[DISCARD] Out of memory allocating CNatPacket for inbound %s [%s:%d %s:%d]",
                 pIpHdr->_bProtocol == IPPROTOCOL_UDP ? "UDP" : "TCP",
                 ipaOuter.Str(), NTOHS(ipportOuter), ipaNat.Str(), NTOHS(ipportNat));
        return;
    }

    ppktNat->SetType((WORD)(pIpHdr->_bProtocol == IPPROTOCOL_UDP ? PKTF_TYPE_UDP : PKTF_TYPE_TCP));

    CIpHdr *  pIpHdrNat  = ppktNat->GetIpHdr();
    CUdpHdr * pUdpHdrNat = (CUdpHdr *)(pIpHdrNat + 1);

    Assert(ppkt->GetCb() == ppktNat->GetCb());
    memcpy(pIpHdrNat, pIpHdr, ppkt->GetCb());

    pIpHdrNat->_ipaDst = pNatPort->_ipaInner;
    pUdpHdrNat->_ipportDst = pNatPort->_ipportInner;

    TraceSz10(NatFlow, "<< %s [%s:%d %s:%d] -> [%s:%d %s:%d] (+%d)",
              pIpHdr->_bProtocol == IPPROTOCOL_UDP ? "UDP" : "TCP",
              pIpHdr->_ipaSrc.Str(), NTOHS(pUdpHdr->_ipportSrc),
              pIpHdr->_ipaDst.Str(), NTOHS(pUdpHdr->_ipportDst),
              pIpHdrNat->_ipaSrc.Str(), NTOHS(pUdpHdrNat->_ipportSrc),
              pIpHdrNat->_ipaDst.Str(), NTOHS(pUdpHdrNat->_ipportDst),
              cbLen);

    _pXnIpNatInner->IpXmitIp(ppktNat);
}

CXnNat::CNatPort * CXnNat::NatPortLookup(CIpAddr ipaInner, CIpPort ipportInner, CIpAddr ipaOuter, CIpPort ipportOuter)
{
    CNatPort * pNatPort;
    
    while (!IsListEmpty(&_leLru))
    {
        pNatPort = (CNatPort *)((BYTE *)_leLru.Flink - offsetof(CNatPort, _leLru));

        if (!NatPortExpire(pNatPort))
            break;
    }

    DWORD dwHash = ipaInner ^ (ipportInner << 3);

    if (_iAssign == NAT_ASSIGN_AGGRESSIVE)
    {
        dwHash ^= (ipaOuter << 13);
        dwHash ^= (ipaOuter >> 19);
        dwHash ^= (ipportOuter << 7);
    }
    else
    {
        ipaOuter = 0;
        ipportOuter = 0;
    }

    LIST_ENTRY * pleHead = &_pleHash[dwHash % _cBucket];

    for (LIST_ENTRY * ple = pleHead->Flink; ple != pleHead; ple = ple->Flink)
    {
        pNatPort = (CNatPort *)ple;

        if (    pNatPort->_ipaInner == ipaInner
            &&  pNatPort->_ipportInner == ipportInner
            &&  pNatPort->_ipaOuter == ipaOuter
            &&  pNatPort->_ipportOuter == ipportOuter)
        {
            return(pNatPort);
        }
    }

    if (_cNatPortFree == 0)
    {
        return(NULL);
    }

    pNatPort = (CNatPort *)HalAllocZ(sizeof(CNatPort), PTAG_CNatPort);

    if (pNatPort != NULL)
    {
        while (1)
        {
            if (_iNatPortNext > _iNatPortLast)
                _iNatPortNext = _iNatPortBase;

            if (_ppNatPort[_iNatPortNext - _iNatPortBase] == NULL)
                break;

            _iNatPortNext += 1;
        }

        pNatPort->_ipaInner     = ipaInner;
        pNatPort->_ipportInner  = ipportInner;
        pNatPort->_ipportNat    = HTONS((WORD)_iNatPortNext);
        pNatPort->_ipaOuter     = ipaOuter;
        pNatPort->_ipportOuter  = ipportOuter;
        pNatPort->_dwTick       = _pXnIpNatInner->TimerTick();

        InsertTailList(pleHead, &pNatPort->_leHash);
        InsertTailList(&_leLru, &pNatPort->_leLru);

        _ppNatPort[_iNatPortNext - _iNatPortBase] = pNatPort;

        _cNatPortFree -= 1;

        TraceSz5(NatPort, "** Port mapping %d [%s:%d %s:%d] allocated",
                 NTOHS(pNatPort->_ipportNat), pNatPort->_ipaInner.Str(), NTOHS(pNatPort->_ipportInner),
                 pNatPort->_ipaOuter.Str(), NTOHS(pNatPort->_ipportOuter));
    }

    return(pNatPort);
}

CXnNat::CNatPort * CXnNat::NatPortLookup(CIpPort ipportNat)
{
    UINT iNatPort = NTOHS(ipportNat);

    if (iNatPort < _iNatPortBase || iNatPort > _iNatPortLast)
        return(NULL);
    else
        return(_ppNatPort[iNatPort - _iNatPortBase]);
}

BOOL CXnNat::NatPortExpire(CNatPort * pNatPort)
{
    if (pNatPort->_dwTick + _iTimeout > _pXnIpNatInner->TimerTick())
    {
        return(FALSE);
    }
    
    TraceSz5(NatPort, "** Port mapping %d [%s:%d %s:%d] has timed out",
             NTOHS(pNatPort->_ipportNat), pNatPort->_ipaInner.Str(), NTOHS(pNatPort->_ipportInner),
             pNatPort->_ipaOuter.Str(), NTOHS(pNatPort->_ipportOuter));

    NatPortFree(pNatPort);
    return(TRUE);
}

void CXnNat::NatPortFree(CNatPort * pNatPort)
{
    UINT iNatPort = NTOHS(pNatPort->_ipportNat);

    TraceSz5(NatPort, "** Port mapping %d [%s:%d %s:%d] freed",
             iNatPort, pNatPort->_ipaInner.Str(), NTOHS(pNatPort->_ipportInner),
             pNatPort->_ipaOuter.Str(), NTOHS(pNatPort->_ipportOuter));

    Assert(iNatPort >= _iNatPortBase && iNatPort <= _iNatPortLast);
    Assert(_ppNatPort[iNatPort - _iNatPortBase] == pNatPort);
    _ppNatPort[iNatPort - _iNatPortBase] = NULL;

    RemoveEntryList(&pNatPort->_leHash);
    RemoveEntryList(&pNatPort->_leLru);

    if (pNatPort->_pNatFilt)
    {
        HalFree(pNatPort->_pNatFilt);
    }

    HalFree(pNatPort);

    _cNatPortFree += 1;
}

CXnNat::CNatFilt * CXnNat::NatFiltLookup(CNatPort * pNatPort, CIpAddr ipaOuter, CIpPort ipportOuter, BOOL fAlloc)
{
    CNatFilt *  pNatFilt;
    UINT        idx, idxIns;
    DWORD       dwTimeout = _pXnIpNatInner->TimerTick() - _iTimeout;

    if ((_iFilter & NAT_FILTER_ADDRESS) == 0)
    {
        ipaOuter = 0;
    }

    if ((_iFilter & NAT_FILTER_PORT) == 0)
    {
        ipportOuter = 0;
    }

    for (int iLo = 0, iHi = (int)pNatPort->_cNatFilt, iMid; iLo < iHi; )
    {
        iMid     = (iLo + iHi) >> 1;
        pNatFilt = &pNatPort->_pNatFilt[iMid];

        if (pNatFilt->_ipaOuter == ipaOuter && pNatFilt->_ipportOuter == ipportOuter)
        {
            if (!fAlloc && pNatFilt->_dwTick <= dwTimeout)
            {
                return(NULL);
            }

            return(pNatFilt);
        }

        if (pNatFilt->_ipaOuter < ipaOuter || (pNatFilt->_ipaOuter == ipaOuter && pNatFilt->_ipportOuter < ipportOuter))
            iLo = iMid + 1;
        else
            iHi = iMid;
    }

    idxIns = iLo;

    if (!fAlloc)
    {
        return(NULL);
    }

    if (pNatPort->_cNatFilt > 0 && pNatPort->_cNatFilt == pNatPort->_cNatFiltAlloc)
    {
        CNatFilt * pNatFiltDst = pNatPort->_pNatFilt;
        CNatFilt * pNatFiltEnd = pNatFiltDst + pNatPort->_cNatFilt;

        pNatFilt = pNatFiltDst;

        for (idx = 0; pNatFilt < pNatFiltEnd; ++pNatFilt)
        {
            if (pNatFilt->_dwTick > dwTimeout)
            {
                if (pNatFiltDst < pNatFilt)
                {
                    memcpy(pNatFiltDst, pNatFilt, sizeof(CNatFilt));

                    TraceSz7(NatPort, "** Port filter  %d [%s:%d %s:%d] <--> [%s:%d] has timed out",
                             NTOHS(pNatPort->_ipportNat), pNatPort->_ipaInner.Str(), NTOHS(pNatPort->_ipportInner),
                             pNatPort->_ipaOuter.Str(), NTOHS(pNatPort->_ipportOuter),
                             pNatFilt->_ipaOuter.Str(), NTOHS(pNatFilt->_ipportOuter));
                }

                pNatFiltDst += 1;
                idx += 1;
            }
            else
            {
                pNatPort->_cNatFilt -= 1;
                if (idxIns > idx)
                    idxIns -= 1;
            }
        }
    }

    if (pNatPort->_cNatFilt == pNatPort->_cNatFiltAlloc)
    {
        UINT cNatFiltAlloc = pNatPort->_cNatFiltAlloc + 8;

        pNatFilt = (CNatFilt *)HalAlloc(cNatFiltAlloc * sizeof(CNatFilt), PTAG_CNatFilt);

        if (pNatFilt == NULL)
        {
            return(NULL);
        }

        if (pNatPort->_cNatFilt > 0)
        {
            memcpy(pNatFilt, pNatPort->_pNatFilt, pNatPort->_cNatFilt * sizeof(CNatFilt));
            HalFree(pNatPort->_pNatFilt);
        }

        pNatPort->_pNatFilt = pNatFilt;
        pNatPort->_cNatFiltAlloc = cNatFiltAlloc;
    }

    Assert(idxIns <= pNatPort->_cNatFilt);
    Assert(idxIns <  pNatPort->_cNatFiltAlloc);

    pNatFilt = &pNatPort->_pNatFilt[idxIns];

    if (idxIns < pNatPort->_cNatFilt)
    {
        memmove(pNatFilt + 1, pNatFilt, (pNatPort->_cNatFilt - idxIns) * sizeof(CNatFilt));
    }

    pNatFilt->_ipaOuter     = ipaOuter;
    pNatFilt->_ipportOuter  = ipportOuter;
    pNatFilt->_dwTick       = _pXnIpNatInner->TimerTick();

    pNatPort->_cNatFilt    += 1;

    TraceSz7(NatPort, "** Port filter  %d [%s:%d %s:%d] <--> [%s:%d] allocated",
             NTOHS(pNatPort->_ipportNat), pNatPort->_ipaInner.Str(), NTOHS(pNatPort->_ipportInner),
             pNatPort->_ipaOuter.Str(), NTOHS(pNatPort->_ipportOuter),
             pNatFilt->_ipaOuter.Str(), NTOHS(pNatFilt->_ipportOuter));

    return(pNatFilt);
}

BOOL CXnNat::IsGateway(CIpPort ipport, CXnIpNat * pXnIpNat)
{
    return(pXnIpNat == _pXnIpNatInner || ipport == DNS_CLIENT_PORT);
}

// ---------------------------------------------------------------------------------------
// XNetNatCreate / XNetNatDelete
// ---------------------------------------------------------------------------------------

void * WSAAPI XNetNatCreate(NATCREATE * pNatCreate)
{
    CXnNat * pXnNat = new CXnNat;

    if (pXnNat == NULL)
    {
        TraceSz(Warning, "XNetNatCreate - Out of memory allocating CXnNat");
    }
    else if (!pXnNat->Init(pNatCreate))
    {
        XNetNatDelete(pXnNat);
        pXnNat = NULL;
    }

    return(pXnNat);
}

void WSAAPI XNetNatDelete(void * pvNat)
{
    CXnNat * pXnNat = (CXnNat *)pvNat;
    pXnNat->Term();
    delete pXnNat;
}

void WSAAPI XNetNatXmit(void * pvNat, void * pvPkt, BOOL fDiscard)
{
//@@@    ((CXnNat *)pvNat)->NatXmit(pvPkt, fDiscard);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\xnet.cpp ===
// ---------------------------------------------------------------------------------------
// xnet.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(Verbose,      0);                 // Trace verbose messages
DefineTag(Warning,      TAG_ENABLE);        // Trace warnings
DefineTag(pktRecv,      0);                 // Trace packet receives
DefineTag(pktBroadcast, 0);                 // Trace broadcast packet receives
DefineTag(pktXmit,      0);                 // Trace packet transmits
DefineTag(pktWarn,      TAG_ENABLE);        // Trace packet Recv/Xmit uncommon events

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

LONG g_lXnLock = 0;

// ---------------------------------------------------------------------------------------
// XnInit
// ---------------------------------------------------------------------------------------

INT _WSAAPI_ XnInit(void ** ppXn, char * pszXbox, const XNetStartupParams * pxnsp, BOOL fWsa, WORD wVersionRequired, LPWSADATA lpWSAData)
{
    while (InterlockedCompareExchange(&g_lXnLock, 1, 0))
    {
        Sleep(0);
    }

    CXn *   pXn = (CXn *)(*ppXn);
    int     err = 0;

    if (pXn == NULL)
    {
        pXn = new CXn;

        if (pXn == NULL)
        {
            err = RtlNtStatusToDosError(NETERR_MEMORY);
            goto err;
        }

        *ppXn = pXn;

        // Set up XNetInitParams and XNetConfigParams

        XNetInitParams      xnip;
        XNetConfigParams    xncp;

        xnip.pxnp    = (XNetParams *)pxnsp;
        xnip.pszXbox = pszXbox;
        HalQueryTsc(&xnip.liTime);

        memset(&xncp, 0, sizeof(xncp));
        xncp.dwSigEnd = XNET_CONFIG_PARAMS_SIGEND;

        HANDLE hVolume = XNetOpenConfigVolume();

        if (hVolume != INVALID_HANDLE_VALUE)
        {
            if (XNetLoadConfigSector(hVolume, 0, (BYTE *)&xncp, sizeof(xncp)))
            {
                // Extract the rand seed from the config sector and move it into
                // the init params.  If we couldn't read the config sector, just
                // leave the seed with whatever is on the stack.

                Assert(sizeof(xnip.abSeed) == sizeof(xncp.abSeed));
                memcpy(xnip.abSeed, xncp.abSeed, sizeof(xnip.abSeed));
            }
        }

        if (xncp.dwSigEnd != XNET_CONFIG_PARAMS_SIGEND)
        {
            memset(&xncp, 0, sizeof(xncp));
            xncp.dwSigEnd = XNET_CONFIG_PARAMS_SIGEND;
        }

        NTSTATUS status = pXn->SockInit(&xnip);

        if (!NT_SUCCESS(status))
        {
            err = RtlNtStatusToDosError(status);
        }

        if (hVolume != INVALID_HANDLE_VALUE)
        {
            if (err == 0)
            {
                // Write the updated rand seed back to the config sector.

                Assert(sizeof(xnip.abSeed) == sizeof(xncp.abSeed));
                memcpy(xncp.abSeed, xnip.abSeed, sizeof(xncp.abSeed));

                XNetSaveConfigSector(hVolume, 0, (BYTE *)&xncp, sizeof(xncp));
            }

            XNetCloseConfigVolume(hVolume);
        }

        if (err == 0 && (pxnsp == NULL || (pxnsp->cfgFlags & XNET_STARTUP_MANUAL_CONFIG) == 0))
        {
        #if defined(XNET_FEATURE_XBDM_SERVER) && defined(DEVKIT)
            xncp.ina.s_addr = (ULONG)DmTell(DMTELL_GETDBGIP, NULL);
        #endif

            err = pXn->XNetConfig(&xncp, XNET_CONFIG_NORMAL);
        }

        if (err != 0)
        {
            pXn->SockTerm();
            pXn = NULL;
            *ppXn = NULL;
            goto err;
        }

        pXn->SockStart();
    }

    if (fWsa)
    {
        pXn->SockAddRef();

        lpWSAData->wVersion          = wVersionRequired;
        lpWSAData->wHighVersion      = 0x0202;
        lpWSAData->lpVendorInfo      = NULL;
        lpWSAData->iMaxSockets       = 0;
        lpWSAData->iMaxUdpDg         = 0;
        lpWSAData->szDescription[0]  = 0;
        lpWSAData->szSystemStatus[0] = 0;
    }
    else
    {
        pXn->XNetAddRef();
    }

err:

    g_lXnLock = 0;

    if (err != 0)
    {
        TraceSz2(Warning, "%s failed: %d", fWsa ? "WSAStartup" : "XNetStartup", err);

        if (fWsa)
        {
            SetLastError(err);
            err = SOCKET_ERROR;
        }
    }

    return(err);
}

// ---------------------------------------------------------------------------------------
// XnTerm
// ---------------------------------------------------------------------------------------

INT _WSAAPI_ XnTerm(void ** ppXn, BOOL fWsa)
{
    int err = 0;

    while (InterlockedCompareExchange(&g_lXnLock, 1, 0))
    {
        Sleep(0);
    }

    CXn * pXn = (CXn *)*ppXn;

    if (    pXn == NULL
        ||  ( fWsa && pXn->SockGetRefs() == 0)
        ||  (!fWsa && pXn->XNetGetRefs() == 0))
    {
        err = WSANOTINITIALISED;
    }
    else
    {
        if (fWsa)
        {
            if (pXn->SockRelease() == 0)
                pXn->SockShutdown();
        }
        else
        {
            pXn->XNetRelease();
        }

        if (pXn->XNetGetRefs() + pXn->SockGetRefs() == 0)
        {
            pXn->SockTerm();
            delete pXn;
            *ppXn = NULL;
        }
    }

    g_lXnLock = 0;

    if (err != 0)
    {
        TraceSz2(Warning, "%s failed: %d", fWsa ? "WSACleanup" : "XNetCleanup", err);

        if (fWsa)
        {
            SetLastError(err);
            err = SOCKET_ERROR;
        }
    }

    return(err);
}

// ---------------------------------------------------------------------------------------
// Key API's
// ---------------------------------------------------------------------------------------

INT CXn::XNetCreateKey(XNKID * pxnkid, XNKEY * pxnkey)
{
    XNetEnter(XNetCreateKey, pxnkid != NULL && pxnkey != NULL);
    INT err = IpCreateKey(pxnkid, pxnkey);
    XNetLeave(err);
    return(err);
}

INT CXn::XNetRegisterKey(const XNKID * pxnkid, const XNKEY * pxnkey)
{
    XNetEnter(XNetRegisterKey, pxnkid != NULL && pxnkey != NULL);
    INT err = IpRegisterKey(pxnkid, pxnkey);
    XNetLeave(err);
    return(err);
}

INT CXn::XNetUnregisterKey(const XNKID * pxnkid)
{
    XNetEnter(XNetUnregisterKey, pxnkid != NULL);
    INT err = IpUnregisterKey(pxnkid);
    XNetLeave(err);
    return(err);
}

INT CXn::XNetRandom(BYTE * pb, UINT cb)
{
    XNetEnter(XNetRandom, pb != NULL || cb == 0);
    Rand(pb, cb);
    XNetLeave(0);
    return(0);
}

// ---------------------------------------------------------------------------------------
// XnAddr API's
// ---------------------------------------------------------------------------------------

INT CXn::XNetXnAddrToInAddr(const XNADDR * pxna, const XNKID * pxnkid, IN_ADDR * pina)
{
    XNetEnter(XNetXnAddrToInAddr, pxna != NULL && pxnkid != NULL && pina != NULL);
    INT err = IpXnAddrToInAddr(pxna, pxnkid, (CIpAddr *)pina);
    XNetLeave(err);
    return(err);
}

INT CXn::XNetServerToInAddr(const IN_ADDR ina, DWORD dwServiceId, IN_ADDR * pina)
{
    XNetEnter(XNetServerToInAddr, ina.s_addr != 0 && pina != NULL);
#ifdef XNET_FEATURE_SG
    INT err = IpServerToInAddr(CIpAddr(ina.s_addr), dwServiceId, (CIpAddr *)pina);
#else
    INT err = WSAEACCES;
#endif
    XNetLeave(err);
    return(err);
}

INT CXn::XNetInAddrToXnAddr(const IN_ADDR ina, XNADDR * pxna, XNKID * pxnkid)
{
    XNetEnter(XNetInAddrToXnAddr, ina.s_addr != 0);
    INT err = IpInAddrToXnAddr(CIpAddr(ina.s_addr), pxna, pxnkid);
    XNetLeave(err);
    return(err);
}

INT CXn::XNetInAddrToString(const IN_ADDR ina, char * pchBuf, INT cchBuf)
{
    XNetParamCheck(XNetInAddrToString, pchBuf != NULL && cchBuf > 0, WSAEFAULT);
    XnInAddrToString(ina, pchBuf, cchBuf);
    return(0);
}

INT CXn::XNetUnregisterInAddr(const IN_ADDR ina)
{
    XNetEnter(XNetUnregisterInAddr, ina.s_addr != 0);
    INT err = IpUnregisterInAddr(CIpAddr(ina.s_addr));
    XNetLeave(err);
    return(err);
}

DWORD CXn::XNetGetTitleXnAddr(XNADDR * pxna)
{
    XNetInitCheck(XNetGetTitleXnAddr, XNET_GET_XNADDR_NONE);
    XNetParamCheck(XNetGetTitleXnAddr, pxna != NULL, XNET_GET_XNADDR_NONE);

#ifdef XNET_FEATURE_XBDM_SERVER
    return(NicGetOtherXnAddr(pxna));
#else
    return(IpGetXnAddr(pxna));
#endif
}

DWORD CXn::XNetGetDebugXnAddr(XNADDR * pxna)
{
    XNetInitCheck(XNetGetDebugXnAddr, XNET_GET_XNADDR_NONE);
    XNetParamCheck(XNetGetDebugXnAddr, pxna != NULL, XNET_GET_XNADDR_NONE);

#ifdef XNET_FEATURE_XBDM_CLIENT
    return(NicGetOtherXnAddr(pxna));
#elif defined(XNET_FEATURE_XBDM_SERVER)
    return(IpGetXnAddr(pxna));
#else
    return(XNET_GET_XNADDR_NONE);
#endif
}

// ---------------------------------------------------------------------------------------
// Domain Name Service APIs
// ---------------------------------------------------------------------------------------

INT CXn::XNetDnsLookup(const char * pszHost, WSAEVENT hEvent, XNDNS ** ppxndns)
{
    XNetEnter(XNetDnsLookup, pszHost != NULL && ppxndns != NULL);

    #ifdef XNET_FEATURE_DNS
    INT err = IpDnsLookup(pszHost, hEvent, ppxndns);
    #else
    INT err = WSAEACCES;
    #endif

    XNetLeave(err);
    return(err);
}

INT CXn::XNetDnsRelease(XNDNS * pxndns)
{
    XNetEnter(XNetDnsRelease, pxndns != NULL);

    #ifdef XNET_FEATURE_DNS
    INT err = IpDnsRelease(pxndns);
    #else
    INT err = WSAEACCES;
    #endif

    XNetLeave(err);
    return(err);
}

// ---------------------------------------------------------------------------------------
// Quality of Service APIs
// ---------------------------------------------------------------------------------------

INT CXn::XNetQosListen(const XNKID * pxnkid, const BYTE * pb, UINT cb, DWORD dwBitsPerSec, DWORD dwFlags)
{
    XNetEnter(XNetQosListen, pxnkid != NULL && (!!pb == !!cb) && (dwFlags & ~(XNET_QOS_LISTEN_ENABLE|XNET_QOS_LISTEN_DISABLE|XNET_QOS_LISTEN_SET_DATA|XNET_QOS_LISTEN_SET_BITSPERSEC)) == 0);

    #ifdef XNET_FEATURE_QOS
    INT err = IpQosListen(pxnkid, pb, cb, dwBitsPerSec, dwFlags);
    #else
    INT err = WSAEACCES;
    #endif

    XNetLeave(err);
    return(err);
}

INT CXn::XNetQosXnAddr(UINT cxnqos, const XNADDR * apxna[], const XNKID * apxnkid[], const XNKEY * apxnkey[], DWORD dwFlags, WSAEVENT hEvent, XNQOS ** ppxnqos)
{
    XNetEnter(XNetQosXnAddr, cxnqos > 0 && apxna != NULL && apxnkid != NULL && apxnkey != NULL && dwFlags == 0 && ppxnqos != NULL);

    #ifdef XNET_FEATURE_QOS
    INT err = IpQosXnAddr(cxnqos, apxna, apxnkid, apxnkey, dwFlags, hEvent, ppxnqos);
    #else
    INT err = WSAEACCES;
    #endif

    XNetLeave(err);
    return(err);
}

INT CXn::XNetQosServer(UINT cxnqos, const IN_ADDR aina[], const DWORD adwServiceId[], DWORD dwFlags, WSAEVENT hEvent, XNQOS ** ppxnqos)
{
    XNetEnter(XNetQosServer, cxnqos > 0 && aina != NULL && adwServiceId != NULL && dwFlags == 0 && ppxnqos != NULL);

    #if defined(XNET_FEATURE_QOS) && defined(XNET_FEATURE_SG)
    INT err = IpQosServer(cxnqos, aina, adwServiceId, dwFlags, hEvent, ppxnqos);
    #else
    INT err = WSAEACCES;
    #endif

    XNetLeave(err);
    return(err);
}

INT CXn::XNetQosRelease(XNQOS * pxnqos)
{
    XNetEnter(XNetQosRelease, pxnqos != NULL);

    #ifdef XNET_FEATURE_QOS
    INT err = IpQosRelease(pxnqos);
    #else
    INT err = WSAEACCES;
    #endif

    XNetLeave(err);
    return(err);
}

// ---------------------------------------------------------------------------------------
// Config
// ---------------------------------------------------------------------------------------

INT CXn::XNetConfig(const XNetConfigParams * pxncp, DWORD dwFlags)
{
    XNetEnter(XNetConfig, pxncp != NULL);
    INT err = IpConfig(pxncp, dwFlags);
    XNetLeave(err);
    return(err);
}

INT CXn::XNetGetConfigStatus(XNetConfigStatus * pxncs)
{
    XNetEnter(XNetGetConfigStatus, pxncs != NULL);
    INT err = IpGetConfigStatus(pxncs);
    XNetLeave(err);
    return(err);
}

// ---------------------------------------------------------------------------------------
// Main entrypoints for XNet/Winsock APIs
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_XBOX
CXn * g_pXn = NULL;
#endif

#undef  XNETAPI
#define XNETAPI(ret, fname, arglist, paramlist) ret _WSAAPI_ fname arglist { return(GetXn()->fname paramlist); }
#undef  XNETAPI_
#define XNETAPI_(ret, fname, arglist, paramlist)
#undef  XNETAPIV
#define XNETAPIV(ret, fname, arglist, paramlist)

XNETAPILIST()
SOCKAPILIST()

INT _WSAAPI_ XNetStartup(const XNetStartupParams * pxnsp)
{
    XNetParamCheck(XNetStartup, pxnsp == NULL || pxnsp->cfgSizeOfStruct == sizeof(XNetStartupParams), WSAEFAULT);
    return(XnInit((void **)GetXnRef(), GetAchXbox(), pxnsp, FALSE, 0, NULL));
}

int _WSAAPI_ WSAStartup(WORD wVersionRequired, LPWSADATA lpWSAData)
{
    WinsockApiPrologTrivial_(WSAStartup);
    WinsockApiParamCheck_(lpWSAData != NULL);
    return(XnInit((void **)GetXnRef(), GetAchXbox(), NULL, TRUE, wVersionRequired, lpWSAData));
}

INT _WSAAPI_ XNetCleanup()
{
    return(XnTerm((void **)GetXnRef(), FALSE));
}

int _WSAAPI_ WSACleanup()
{
    return(XnTerm((void **)GetXnRef(), TRUE));
}

// ---------------------------------------------------------------------------------------
// XNetGetEthernetLinkStatus
//
// This function is placed in the default .text code section so that is can be called
// before the XNET code section is loaded.
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_XBOX
#pragma code_seg(".text")
#endif

DWORD _WSAAPI_ XNetGetEthernetLinkStatus()
{
#ifdef XNET_FEATURE_XBOX
    while (InterlockedCompareExchange(&g_lXnLock, 1, 0))
    {
        Sleep(0);
    }
    
    if (g_pXn == NULL)
    {
        PhyInitialize(FALSE, NULL);
    }

    g_lXnLock = 0;

    return(PhyGetLinkState(FALSE));
#else
    return(XNET_ETHERNET_LINK_ACTIVE|XNET_ETHERNET_LINK_100MBPS|XNET_ETHERNET_LINK_FULL_DUPLEX);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\test\codesize\codesize.cpp ===
// ---------------------------------------------------------------------------------------
// codesize.cpp
//
// Test program which links with all of the external entry points of
// the XNet library.  Used to track the size of the XNet code.
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"

#ifdef XNET_FEATURE_XBOX
#define CODESIZEINHERIT
#else
#define CODESIZEINHERIT     : public CXNet
#endif

void __cdecl Ref(DWORD dw, ...)
{
    static DWORD s_dwCount;
    s_dwCount += dw;
}

class CCodeSize CODESIZEINHERIT
{
public:
    void DoRef();
};

void CCodeSize::DoRef()
{
#ifndef XNETBASELINE
    #undef  XNETAPI
    #define XNETAPI(ret, fname, arglist, paramlist) Ref(0, fname);
    #undef  XNETAPI_
    #define XNETAPI_(ret, fname, arglist, paramlist) Ref(0, fname);
    #undef  XNETAPIV
    #define XNETAPIV(ret, fname, arglist, paramlist) Ref(0, fname);
    XNETAPILIST()
    SOCKAPILIST()
#endif
}

void __cdecl main(int argc, char * argv[])
{
    CCodeSize CodeSize;
    CodeSize.DoRef();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\i386\tcpipxsum.asm ===
title  "Compute TCP/IP Checksum"

;/*++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;    tcpipxsum.asm
;
; Abstract:
;
;    This module implements a function to compute the checksum of a buffer.
;
; Author:
;
;    David N. Cutler (davec) 27-Jan-1992
;
; Revision History:
;
;     Who         When        What
;     --------    --------    ----------------------------------------------
;     mikeab      01-22-94    Pentium optimization
;
;--*/



LOOP_UNROLLING_BITS equ     4
LOOP_UNROLLING      equ     (1 SHL LOOP_UNROLLING_BITS)

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include ks386.inc
        .list

XNET    SEGMENT DWORD PUBLIC 'CODE'

;++
;
; ULONG
; tcpipxsum(
;   IN ULONG xsum,
;   IN const VOID* buf,
;   IN UINT len
;   )
;
; Routine Description:
;
;    This function computes the checksum of the specified buffer.
;    It uses Processor's prefetch instruction.
;
; Arguments:
;
;    xsum - Suppiles the initial checksum value, in 16-bit form,
;           with the high word set to 0.
;
;    buf - Supplies a pointer to the buffer to the checksum buffer.
;
;    len - Supplies the length of the buffer in bytes.
;
; Return Value:
;
;    The computed checksum in 32-bit two-partial-accumulators form, added to
;    the initial checksum, is returned as the function value.
;
;--

xsum    equ     12                      ; stack offset to initial checksum
buf     equ     16                      ; stack offset to source address
len     equ     20                      ; stack offset to length in words

to_checksum_last_word:
        jmp     checksum_last_word

to_checksum_done:
        jmp     checksum_done

to_checksum_dword_loop_done:
        jmp     checksum_dword_loop_done

cPublicProc tcpipxsum,3

        push    ebx                     ; save nonvolatile register
        push    esi                     ; save nonvolatile register

        mov     ecx,[esp + len]         ; get length in bytes
        sub     eax,eax                 ; clear computed checksum
        test    ecx,ecx                 ; any bytes to checksum at all?
        jz      short to_checksum_done  ; no bytes to checksum

;
; if the checksum buffer is not word aligned, then add the first byte of
; the buffer to the input checksum.
;

        mov     esi,[esp + buf]         ; get source address
        sub     edx,edx                 ; set up to load word into EDX below
        test    esi,1                   ; check if buffer word aligned
        jz      short checksum_word_aligned ; if zf, buffer word aligned
        mov     ah,[esi]                ; get first byte (we know we'll have
                                        ;  to swap at the end)
        inc     esi                     ; increment buffer address
        dec     ecx                     ; decrement number of bytes
        jz      short to_checksum_done  ; if zf set, no more bytes

;
; If the buffer is not an even number of of bytes, then initialize
; the computed checksum with the last byte of the buffer.
;

checksum_word_aligned:                  ;
        shr     ecx,1                   ; convert to word count
        jnc     short checksum_start    ; if nc, even number of bytes
        mov     al,[esi+ecx*2]          ; initialize the computed checksum
        jz      short to_checksum_done  ; if zf set, no more bytes

;
; Compute checksum in large blocks of dwords, with one partial word up front if
; necessary to get dword alignment, and another partial word at the end if
; needed.
;

;
; Compute checksum on the leading word, if that's necessary to get dword
; alignment.
;

checksum_start:                         ;
        test    esi,02h                 ; check if source dword aligned
        jz      short checksum_dword_aligned ; source is already dword aligned
        mov     dx,[esi]                ; get first word to checksum
        add     esi,2                   ; update source address
        add     eax,edx                 ; update partial checksum
                                        ;  (no carry is possible, because EAX
                                        ;  and EDX are both 16-bit values)
        dec     ecx                     ; count off this word (zero case gets
                                        ;  picked up below)

;
; Checksum as many words as possible by processing a dword at a time.
;

checksum_dword_aligned:
        push    ecx                     ; so we can tell if there's a trailing
                                        ;  word later
        shr     ecx,1                   ; # of dwords to checksum
        jz      short to_checksum_last_word ; no dwords to checksum

        mov     edx,[esi]               ; preload the first dword
        add     esi,4                   ; point to the next dword
        dec     ecx                     ; count off the dword we just loaded
        jz      short to_checksum_dword_loop_done
                                        ; skip the loop if that was the only dword
        mov     ebx,ecx                 ; EBX = # of dwords left to checksum
        add     ecx,LOOP_UNROLLING-1    ; round up loop count
        shr     ecx,LOOP_UNROLLING_BITS ; convert from word count to unrolled loop count
        and     ebx,LOOP_UNROLLING-1    ; # of partial dwords to do in first loop
        jz      short checksum_dword_loop ; special-case when no partial loop,
                                          ;  because fixup below doesn't work
                                          ;  in that case (carry flag is
                                          ;  cleared at this point, as required
                                          ;  at loop entry)
        lea     esi,[esi+ebx*4-(LOOP_UNROLLING*4)]
                                        ; adjust buffer pointer back to
                                        ;  compensate for hardwired displacement
                                        ;  at loop entry point
                                        ; ***doesn't change carry flag***
        jmp     loop_entry[ebx*4]       ; enter the loop to do the first,
                                        ; partial iteration, after which we can
                                        ; just do 32-word blocks
                                        ; ***doesn't change carry flag***

checksum_dword_loop:
        ; prefetch the 32-byte cache line from [esi+0]
        db 0fH
        db 18H
        db 46H
        db 00H

        ; prefetch the 32-byte cache line from [esi+20h]
        db 0fH
        db 18H
        db 46H
        db 20H

DEFLAB  macro   pre,suf
pre&suf:
        endm

TEMP=0
        REPT    LOOP_UNROLLING
        deflab  loop_entry_,%TEMP
        adc     eax,edx
        mov     edx,[esi + TEMP]
TEMP=TEMP+4
        ENDM

checksum_dword_loop_end:

        lea     esi,[esi + LOOP_UNROLLING * 4]  ; update source address
                                        ; ***doesn't change carry flag***
        dec     ecx                     ; count off unrolled loop iteration
                                        ; ***doesn't change carry flag***
        jnz     checksum_dword_loop     ; do more blocks

checksum_dword_loop_done label proc
        adc     eax,edx                 ; finish dword checksum
        mov     edx,0                   ; prepare to load trailing word
        adc     eax,edx

;
; Compute checksum on the trailing word, if there is one.
; High word of EDX = 0 at this point
; Carry flag set iff there's a trailing word to do at this point
;

checksum_last_word label proc           ; "proc" so not scoped to function
        pop     ecx                     ; get back word count
        test    ecx,1                   ; is there a trailing word?
        jz      short checksum_done     ; no trailing word
        add     ax,[esi]                ; add in the trailing word
        adc     eax,0                   ;

checksum_done label proc                ; "proc" so not scoped to function
        mov     ecx,eax                 ; fold the checksum to 16 bits
        ror     ecx,16
        add     eax,ecx
        mov     ebx,[esp + buf]
        shr     eax,16
        test    ebx,1                   ; check if buffer word aligned
        jz      short checksum_combine  ; if zf set, buffer word aligned
        ror     ax,8                    ; byte aligned--swap bytes back
checksum_combine label proc             ; "proc" so not scoped to function
        add     ax, word ptr [esp + xsum] ; combine checksums
        pop     esi                     ; restore nonvolatile register
        adc     eax,0                   ;
        pop     ebx                     ; restore nonvolatile register
        stdRET  tcpipxsum


REFLAB  macro   pre,suf
        dd      pre&suf
        endm

        align   4
loop_entry      label   dword
        dd      0
TEMP=LOOP_UNROLLING*4
        REPT    LOOP_UNROLLING-1
TEMP=TEMP-4
        reflab  loop_entry_,%TEMP
        ENDM

stdENDP tcpipxsum

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\test\codesize\sources.inc ===
TARGETPATH=obj
TARGETTYPE=PROGRAM
TARGETNAME=codesize
NO_BINPLACE=1
NTPREFIX=1
INCLUDES=$(INCLUDE);$(SDK_INC_PATH);..\..\..
LINKER_FLAGS=$(LINKER_FLAGS) /map
SOURCES=\
    codesize.c\
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\obx\obcreate.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    obcreate.c

Abstract:

    This module implements routines to create and insert objects into the global
    handle table.

--*/

#include "obp.h"

NTSTATUS
ObCreateObject(
    IN POBJECT_TYPE ObjectType,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG ObjectBodySize,
    OUT PVOID *Object
    )
/*++

Routine Description:

    This routine creates an object with the supplied size and attributes.

Arguments:

    ObjectType - Supplies the type for the object.

    ObjectAttributes - Supplies the attributes for the object.

    ObjectBodySize - Supplies the number of bytes to allocate for the object's
        body.

    Object - Supplies the location to receive the created object.

Return Value:

    Status of operation.

--*/
{
    POBJECT_HEADER ObjectHeader;
    OBJECT_STRING RemainingName;
    OBJECT_STRING ElementName;
    POBJECT_HEADER_NAME_INFO ObjectNameInfo;

    *Object = NULL;

    //
    // Handle the trivial case of creating an unnamed object.
    //

    if (ObjectAttributes == NULL || ObjectAttributes->ObjectName == NULL) {

        ObjectHeader = (POBJECT_HEADER)ObjectType->AllocateProcedure(
            FIELD_OFFSET(OBJECT_HEADER, Body) + ObjectBodySize,
            ObjectType->PoolTag);

        if (ObjectHeader == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        ObjectHeader->PointerCount = 1;
        ObjectHeader->HandleCount = 0;
        ObjectHeader->Type = ObjectType;
        ObjectHeader->Flags = 0;

        *Object = &ObjectHeader->Body;

        return STATUS_SUCCESS;
    }

    //
    // The object is named.  Dissect the path to obtain the last element which
    // is the object's name.
    //

    RemainingName = *ObjectAttributes->ObjectName;
    ElementName.Buffer = NULL;
    ElementName.Length = 0;

    while (RemainingName.Length != 0) {

        ObDissectName(RemainingName, &ElementName, &RemainingName);

        //
        // Verify that there aren't multiple backslashes in the name.
        //

        if ((RemainingName.Length != 0) && (RemainingName.Buffer[0] ==
            OBJ_NAME_PATH_SEPARATOR)) {
            return STATUS_OBJECT_NAME_INVALID;
        }
    }

    //
    // There should be at least one character in the element name.
    //

    if (ElementName.Length == 0) {
        return STATUS_OBJECT_NAME_INVALID;
    }

    //
    // Allocate the object header, body, and name in one chunk.
    //

    ObjectBodySize = ALIGN_UP(ObjectBodySize, ULONG);

    ObjectNameInfo = (POBJECT_HEADER_NAME_INFO)ObjectType->AllocateProcedure(
        sizeof(OBJECT_HEADER_NAME_INFO) + FIELD_OFFSET(OBJECT_HEADER, Body) +
        ObjectBodySize + ElementName.Length, ObjectType->PoolTag);

    if (ObjectNameInfo == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the object.
    //

    ObjectHeader = (POBJECT_HEADER)(ObjectNameInfo + 1);

    ObjectNameInfo->ChainLink = NULL;
    ObjectNameInfo->Directory = NULL;
    ObjectNameInfo->Name.Buffer = (POSTR)((PUCHAR)&ObjectHeader->Body +
        ObjectBodySize);
    ObjectNameInfo->Name.Length = ElementName.Length;
    ObjectNameInfo->Name.MaximumLength = ElementName.Length;

    RtlCopyMemory(ObjectNameInfo->Name.Buffer, ElementName.Buffer,
        ElementName.Length);

    ObjectHeader->PointerCount = 1;
    ObjectHeader->HandleCount = 0;
    ObjectHeader->Type = ObjectType;
    ObjectHeader->Flags = OB_FLAG_NAMED_OBJECT;

    *Object = &ObjectHeader->Body;

    return STATUS_SUCCESS;
}

NTSTATUS
ObInsertObject(
    IN PVOID Object,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG ObjectPointerBias,
    OUT PHANDLE ReturnedHandle
    )
/*++

Routine Description:

    This routine inserts the supplied object into the handle table and
    optionally into an object directory.

Arguments:

    Object - Supplies the object to insert into the handle table.

    ObjectAttributes - Supplies the attributes for the object.

    ObjectPointerBias - Supplies the number of additional pointer references
        that should be applied to the object.

    ReturnedHandle - Supplies the location to receive the object's handle.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    HANDLE Handle;
    PVOID InsertObject;
    HANDLE RootDirectoryHandle;
    POBJECT_HEADER ObjectHeader;
    POBJECT_DIRECTORY Directory;
    KIRQL OldIrql;
    OBJECT_STRING RemainingName;
    OBJECT_STRING ElementName;
    PVOID FoundObject;
    POBJECT_HEADER_NAME_INFO ObjectHeaderNameInfo;
    ULONG HashIndex;
    PVOID DosDevicesObject;
    OCHAR DriveLetter;

    ObpAcquireObjectManagerLock(&OldIrql);

    Handle = NULL;
    InsertObject = Object;

    //
    // Check if the object is named.  If so, then we need to go find the
    // directory to attach the object to.
    //

    if (ObjectAttributes != NULL && ObjectAttributes->ObjectName != NULL) {

        RemainingName = *ObjectAttributes->ObjectName;

        //
        // ObCreateObject has already checked that the name has at least one
        // character in it and that there aren't multiple backslashes in the
        // name.
        //

        ASSERT(RemainingName.Length != 0);

        //
        // Determine whether we parse the object name from an absolute or
        // relative root directory.
        //

        RootDirectoryHandle = ObjectAttributes->RootDirectory;

        if (RootDirectoryHandle != NULL) {

            //
            // Verify that this is not an absolute path.
            //

            if (RemainingName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR) {
                status = STATUS_OBJECT_NAME_INVALID;
                goto CleanupAndExit;
            }

            if (RootDirectoryHandle == ObDosDevicesDirectory()) {

                //
                // Reference the root of the DOS devices space.
                //

                Directory = ObpDosDevicesDirectoryObject;

            } else if (RootDirectoryHandle == ObWin32NamedObjectsDirectory()) {

                //
                // Reference the root of the Win32 named objects space.
                //

                Directory = ObpWin32NamedObjectsDirectoryObject;

            } else {

                //
                // Reference the root directory handle.
                //

                Directory = (POBJECT_DIRECTORY)
                    ObpGetObjectHandleContents(RootDirectoryHandle);

                if (Directory == NULL) {
                    status = STATUS_INVALID_HANDLE;
                    goto CleanupAndExit;
                }

                if (OBJECT_TO_OBJECT_HEADER(Directory)->Type != &ObDirectoryObjectType) {
                    status = STATUS_OBJECT_TYPE_MISMATCH;
                    goto CleanupAndExit;
                }
            }

        } else {

            //
            // Verify that this is an absolute path.
            //

            if (RemainingName.Buffer[0] != OBJ_NAME_PATH_SEPARATOR) {
                status = STATUS_OBJECT_NAME_INVALID;
                goto CleanupAndExit;
            }

            //
            // Reference the global root directory handle.
            //

            Directory = ObpRootDirectoryObject;
        }

        for (;;) {

            ObDissectName(RemainingName, &ElementName, &RemainingName);

            if (ObpLookupElementNameInDirectory(Directory, &ElementName, TRUE,
                &FoundObject)) {

                //
                // If we found the element and there's no more of a path to
                // process, then we can't create the object due to a name
                // collision.
                //

                if (RemainingName.Length == 0) {

                    if (ObpIsFlagSet(ObjectAttributes->Attributes, OBJ_OPENIF)) {

                        if (OBJECT_TO_OBJECT_HEADER(FoundObject)->Type ==
                            OBJECT_TO_OBJECT_HEADER(Object)->Type) {

                            //
                            // We found an object with the same name and type.
                            // The caller wants us to open that object instead
                            // of the one we were given, so change the insertion
                            // object.
                            //
                            // Null out the directory pointer so that we don't
                            // attempt to reinsert this object into the
                            // directory.
                            //

                            InsertObject = FoundObject;
                            Directory = NULL;
                            break;

                        } else {
                            status = STATUS_OBJECT_TYPE_MISMATCH;
                            goto CleanupAndExit;
                        }

                    } else {
                        status = STATUS_OBJECT_NAME_COLLISION;
                        goto CleanupAndExit;
                    }
                }

                //
                // We found the element and there's more of a path to process.
                // The object we found had better be a directory.
                //

                if (OBJECT_TO_OBJECT_HEADER(FoundObject)->Type !=
                    &ObDirectoryObjectType) {
                    status = STATUS_OBJECT_PATH_NOT_FOUND;
                    goto CleanupAndExit;
                }

                Directory = (POBJECT_DIRECTORY)FoundObject;

            } else {

                //
                // If we failed to find the element and there's more of a path
                // name to process, then return path not found.
                //

                if (RemainingName.Length != 0) {
                    status = STATUS_OBJECT_PATH_NOT_FOUND;
                    goto CleanupAndExit;
                }

                //
                // Break out of the loop since we've consumed the entire path
                // and we didn't collide with an existing object's name.
                //

                break;
            }
        }

    } else {
        Directory = NULL;
    }

    //
    // Create the handle for the object.
    //

    Handle = ObpCreateObjectHandle(InsertObject);

    if (Handle == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanupAndExit;
    }

    //
    // Apply the reference bias to the object, including one for the handle
    // itself.
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER(InsertObject);
    ObjectHeader->PointerCount += ObjectPointerBias + 1;

    //
    // If the object is to be attached to an object directory, then do it now.
    //

    if (Directory != NULL) {

        ObjectHeaderNameInfo = OBJECT_TO_OBJECT_HEADER_NAME_INFO(Object);

        HashIndex = ObpComputeHashIndex(&ObjectHeaderNameInfo->Name);

        ObjectHeader->Flags |= OB_FLAG_ATTACHED_OBJECT;

        ObjectHeaderNameInfo->Directory = Directory;
        ObjectHeaderNameInfo->ChainLink = Directory->HashBuckets[HashIndex];
        Directory->HashBuckets[HashIndex] = ObjectHeaderNameInfo;

        //
        // If we're attaching a drive letter relative to the DOS devices
        // directory, then also add the object to the quick array lookup.  If
        // the object that we're attaching is a symbolic link object, then put
        // the resolved link target in the quick array-- the common case is to
        // lookup fully resolve paths.
        //

        if ((Directory == ObpDosDevicesDirectoryObject) &&
            (ObjectHeaderNameInfo->Name.Length == sizeof(OCHAR) * 2) &&
            (ObjectHeaderNameInfo->Name.Buffer[1] == (OCHAR)':')) {

            DosDevicesObject = Object;

            if (OBJECT_TO_OBJECT_HEADER(DosDevicesObject)->Type ==
                &ObSymbolicLinkObjectType) {
                DosDevicesObject =
                    ((POBJECT_SYMBOLIC_LINK)DosDevicesObject)->LinkTargetObject;
            }

            DriveLetter = ObjectHeaderNameInfo->Name.Buffer[0];

            if (DriveLetter >= 'a' && DriveLetter <= 'z') {
                ASSERT(ObpDosDevicesDriveLetterMap[DriveLetter - 'a'] == NULL);
                ObpDosDevicesDriveLetterMap[DriveLetter - 'a'] = DosDevicesObject;
            } else if (DriveLetter >= 'A' && DriveLetter <= 'Z') {
                ASSERT(ObpDosDevicesDriveLetterMap[DriveLetter - 'A'] == NULL);
                ObpDosDevicesDriveLetterMap[DriveLetter - 'A'] = DosDevicesObject;
            }
        }

        //
        // Increment the number of references to the object and the directory.
        // These references are undone in ObpDetachNamedObject.
        //

        OBJECT_TO_OBJECT_HEADER(Directory)->PointerCount++;
        ObjectHeader->PointerCount++;
    }

    //
    // Mark the object as permanent if requested.
    //

    if ((ObjectAttributes != NULL) &&
        ObpIsFlagSet(ObjectAttributes->Attributes, OBJ_PERMANENT)) {
        ObjectHeader->Flags |= OB_FLAG_PERMANENT_OBJECT;
    }

    status = (Object == InsertObject) ? STATUS_SUCCESS : STATUS_OBJECT_NAME_EXISTS;

CleanupAndExit:
    ObpReleaseObjectManagerLock(OldIrql);

    ObDereferenceObject(Object);

    *ReturnedHandle = Handle;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\test\xnet\testxnet.cpp ===
// ----------------------------------------------------------------------------
// testxnet.cpp
//
// Copyright (C) Microsoft Corporation
// ----------------------------------------------------------------------------

#include "xnp.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <vlan.h>

// ---------------------------------------------------------------------------------------
// Utilities
// ---------------------------------------------------------------------------------------

#define Verify(x)       do { if (!(x)) DbgBreak(); } while (0)

struct CDiscReq
{
    BYTE    abNonce[8];         // Nonce of the requester
};

struct CDiscRsp : public CDiscReq
{
    XNKID   xnkid;              // The host's key identifier
    XNKEY   xnkey;              // The host's key
    XNADDR  xnaddr;             // The host's address
};

ULONG WSAAPI inet_addr(const char * pch)
{
    return(((CXNet *)0)->inet_addr(pch));
}

// ---------------------------------------------------------------------------------------
// CTestXnIp
// ---------------------------------------------------------------------------------------

class CTestXnIp : public CXnIp
{

public:
    
    virtual void Startup(char * pszXbox, char * pszIp, char * pszMask, char * pszGateway, DWORD dwFlags)
    {
        XNetParams xnp = { sizeof(XNetStartupParams) };
        xnp.cfgFlags = (BYTE)(XNET_STARTUP_MANUAL_CONFIG|dwFlags);
        XNetInitParams xnip = { &xnp, pszXbox };
        Verify(IpInit(&xnip) == 0);

        XNetConfigParams xncp = { 0 };
        xncp.ina.s_addr = pszIp ? inet_addr(pszIp) : 0;
        xncp.inaMask.s_addr = pszMask ? inet_addr(pszMask) : 0;
        xncp.inaGateway.s_addr = pszGateway ? inet_addr(pszGateway) : 0;
        Verify(IpConfig(&xncp, XNET_CONFIG_NORMAL) == 0);

        IpStart();
    }

    virtual void Init()
    {
        Startup(NULL, NULL, NULL, NULL, 0);
    }

    virtual void Term()
    {
        RaiseToDpc();
        IpTerm();
    }

    void Go(HANDLE hEvent1, HANDLE hEvent2)
    {
        Init();
        if (hEvent1) SetEvent(hEvent1);
        if (hEvent2) Verify(WaitForSingleObject(hEvent2, INFINITE) == WAIT_OBJECT_0);
        Test();
        if (hEvent1) SetEvent(hEvent1);
        if (hEvent2) Verify(WaitForSingleObject(hEvent2, INFINITE) == WAIT_OBJECT_0);
        Term();
    }

    void UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen) {};
    void TcpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbHdrLen, UINT cbLen) {};
    void SockReset(CIpAddr ipa) {};

    virtual void Test() = 0;
};

#define IPTEST_BEG(_name, pszXbox, pszIp, pszMask, pszGateway, dwFlags) \
    class CTest##_name : public CTestXnIp { \
    virtual void Init() { Startup(pszXbox, pszIp, pszMask, pszGateway, dwFlags); } \
    virtual void Test()
#define IPTEST_END(_name) \
    }; void Test_##_name(HANDLE hEvent1 = 0, HANDLE hEvent2 = 0) \
    { CTest##_name * p = new CTest##_name; p->Go(hEvent1, hEvent2); delete p; }

// ---------------------------------------------------------------------------------------
// CTestXNet
// ---------------------------------------------------------------------------------------

HANDLE  g_hEventXb1ToXb2;
HANDLE  g_hEventXb2ToXb1;
XNADDR  g_xnaddrXb1;
XNADDR  g_xnaddrXb2;
XNKID   g_xnkidXb1ToXb2;
XNKEY   g_xnkeyXb1ToXb2;
BOOL    g_fXb1ToXb2Timeout;
UINT    g_cSecsXb1ToXb2Connect;

class CTestXNet : public CXNet
{
public:
    
    CTestXNet(char * pszXbox = NULL) : CXNet(pszXbox) {}

    virtual void Startup(char * pszIp, char * pszMask, char * pszGateway, DWORD dwFlags)
    {
        XNetStartupParams xnp = { sizeof(XNetStartupParams) };
        xnp.cfgFlags = (BYTE)(XNET_STARTUP_MANUAL_CONFIG|dwFlags);
        Verify(XNetStartup(&xnp) == 0);

        XNetConfigParams xncp = { 0 };
        xncp.ina.s_addr = pszIp ? inet_addr(pszIp) : 0;
        xncp.inaMask.s_addr = pszMask ? inet_addr(pszMask) : 0;
        xncp.inaGateway.s_addr = pszGateway ? inet_addr(pszGateway) : 0;
        Verify(XNetConfig(&xncp, XNET_CONFIG_NORMAL) == 0);

        WSADATA WSAData;
        Verify(WSAStartup(0x0200, &WSAData) == 0);
    }

    virtual void Init()
    {
        Startup(NULL, NULL, NULL, 0);
    }

    virtual void Term()
    {
        WSACleanup();
        XNetCleanup();
    }

    void Go(HANDLE hEvent1, HANDLE hEvent2)
    {
        Init();
        if (hEvent1) SetEvent(hEvent1);
        if (hEvent2) Verify(WaitForSingleObject(hEvent2, INFINITE) == WAIT_OBJECT_0);
        Test();
        if (hEvent1) SetEvent(hEvent1);
        if (hEvent2) Verify(WaitForSingleObject(hEvent2, INFINITE) == WAIT_OBJECT_0);
        Term();
    }

    virtual void Test() = 0;

    SOCKET  SockUdpCreate(CIpPort ipport = 0, BOOL fBroadcast = FALSE);
    void    SockUdpTransmit(SOCKET s, CIpAddr ipaDst, CIpPort ipport, UINT cbMax = UDP_MAXIMUM_MSS);
    void    SockUdpReflect(SOCKET s);
    SOCKET  SockTcpCreate(CIpPort ipport = 0);
    void    SockTcpTransmit(SOCKET s, UINT cbMax = TCP_MAXIMUM_MSS);
    void    SockTcpReflect(SOCKET s);
    void    DiscoveryHost(UINT cClient, XNKID * pxnkid);
    void    DiscoveryClient(XNKID * pxnkid, CIpAddr * pipa);
    void    SgTcpXbToXbClient();
    void    SgTcpXbToXbServer();

};

SOCKET CTestXNet::SockUdpCreate(CIpPort ipport, BOOL fBroadcast)
{
    SOCKET s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    Verify(s != SOCKET_ERROR);

    if (ipport)
    {
        sockaddr_in sin;
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = 0;
        sin.sin_port = ipport;
        Verify(bind(s, (struct sockaddr *)&sin, sizeof(sin)) == 0);
    }

    if (fBroadcast)
    {
        char cBroadcast = 1;
        Verify(setsockopt(s, SOL_SOCKET, SO_BROADCAST, &cBroadcast, 1) == 0);
    }

    return(s);
}

void CTestXNet::SockUdpTransmit(SOCKET s, CIpAddr ipaDst, CIpPort ipport, UINT cbMax)
{
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = ipaDst;
    sin.sin_port = ipport;
    
    BYTE abXmit[1500], abRecv[1500];

    if (cbMax > sizeof(abXmit))
        cbMax = sizeof(abXmit);

    int cb;

    for (cb = 1; cb < (int)cbMax; ++cb)
    {
        XNetRandom(abXmit, cb);
        Verify(sendto(s, (char *)abXmit, cb, 0, (struct sockaddr *)&sin, sizeof(sin)) == cb);
        Verify(recv(s, (char *)abRecv, sizeof(abRecv), 0) == cb);
        Verify(memcmp(abXmit, abRecv, cb) == 0);
        if ((cb % 200) == 0) printf(".");
    }

    for (; cb > 0; --cb)
    {
        XNetRandom(abXmit, cb);
        Verify(sendto(s, (char *)abXmit, cb, 0, (struct sockaddr *)&sin, sizeof(sin)) == cb);
        Verify(recv(s, (char *)abRecv, sizeof(abRecv), 0) == cb);
        Verify(memcmp(abXmit, abRecv, cb) == 0);
        if ((cb % 200) == 0) printf(".");
    }

    Verify(sendto(s, (char *)abXmit, 0, 0, (struct sockaddr *)&sin, sizeof(sin)) == 0);
    Verify(recv(s, (char *)abRecv, sizeof(abRecv), 0) == 0);
}

void CTestXNet::SockUdpReflect(SOCKET s)
{
    BYTE abRecv[1500];

    sockaddr_in sin;
    int cb;

    while (1)
    {
        int slen = sizeof(sin);
        cb = recvfrom(s, (char *)abRecv, sizeof(abRecv), 0, (struct sockaddr *)&sin, &slen);
        Verify(cb != SOCKET_ERROR);
        Verify(sendto(s, (char *)abRecv, cb, 0, (struct sockaddr *)&sin, sizeof(sin)) == cb);
        if (cb == 0)
            break;
    }
}

SOCKET CTestXNet::SockTcpCreate(CIpPort ipport)
{
    SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    Verify(s != SOCKET_ERROR);

    if (ipport)
    {
        sockaddr_in sin;
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = 0;
        sin.sin_port = ipport;
        Verify(bind(s, (struct sockaddr *)&sin, sizeof(sin)) == 0);
    }

    return(s);
}

void CTestXNet::SockTcpTransmit(SOCKET s, UINT cbMax)
{
    BYTE abXmit[1500], abRecv[1500];

    if (cbMax > sizeof(abXmit))
        cbMax = sizeof(abXmit);

    int cb;

    for (cb = 1; cb < (int)cbMax; ++cb)
    {
        XNetRandom(abXmit, cb);
        Verify(send(s, (char *)abXmit, cb, 0) == cb);
        Verify(recv(s, (char *)abRecv, sizeof(abRecv), 0) == cb);
        Verify(memcmp(abXmit, abRecv, cb) == 0);
        if ((cb % 200) == 0) printf(".");
    }

    for (; cb > 0; --cb)
    {
        XNetRandom(abXmit, cb);
        Verify(send(s, (char *)abXmit, cb, 0) == cb);
        Verify(recv(s, (char *)abRecv, sizeof(abRecv), 0) == cb);
        Verify(memcmp(abXmit, abRecv, cb) == 0);
        if ((cb % 200) == 0) printf(".");
    }

    Verify(shutdown(s, SD_SEND) != SOCKET_ERROR);
}

void CTestXNet::SockTcpReflect(SOCKET s)
{
    BYTE abRecv[1500];
    int cb;

    while (1)
    {
        cb = recv(s, (char *)abRecv, sizeof(abRecv), 0);
        Verify(cb != SOCKET_ERROR);

        if (cb == 0)
        {
            Verify(shutdown(s, SD_SEND) != SOCKET_ERROR);
            break;
        }

        Verify(send(s, (char *)abRecv, cb, 0) == cb);
    }
}

void CTestXNet::DiscoveryHost(UINT cClient, XNKID * pxnkid)
{
    SOCKET s = SockUdpCreate(NTOHS(1234), TRUE);

    CDiscReq dreq;
    CDiscRsp drsp;
    UINT iClient = 0;
    sockaddr_in sin;
    BYTE * pbNonce = (BYTE *)LocalAlloc(LPTR, sizeof(dreq.abNonce) * cClient);
    Verify(pbNonce != NULL);
    XNADDR xnaddr;
    XNKID xnkid;
    XNKEY xnkey;

    Verify(XNetCreateKey(&drsp.xnkid, &drsp.xnkey) == 0);
    Verify(XNetRegisterKey(&drsp.xnkid, &drsp.xnkey) == 0);
    Verify(XNetGetTitleXnAddr(&drsp.xnaddr) != 0);

    XNetRandom(drsp.abNonce, sizeof(drsp.abNonce));

    while (iClient < cClient)
    {
        Verify(recv(s, (char *)&dreq, sizeof(dreq), 0) == sizeof(dreq));

        for (UINT i = 0; i < iClient; ++i)
        {
            if (memcmp(&pbNonce[i * sizeof(dreq.abNonce)], dreq.abNonce, sizeof(dreq.abNonce)) == 0)
                break;
        }

        if (i == iClient)
        {
            memcpy(&pbNonce[i * sizeof(dreq.abNonce)], dreq.abNonce, sizeof(dreq.abNonce));
            iClient += 1;
        }

        memcpy(drsp.abNonce, dreq.abNonce, sizeof(dreq.abNonce));
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = INADDR_BROADCAST;
        sin.sin_port = NTOHS(1234);
        Verify(sendto(s, (char *)&drsp, sizeof(drsp), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(drsp));
    }

    Verify(closesocket(s) == 0);
    LocalFree(pbNonce);
    *pxnkid = drsp.xnkid;
}

void CTestXNet::DiscoveryClient(XNKID * pxnkid, CIpAddr * pipa)
{
    SOCKET s = SockUdpCreate(NTOHS(1234));

    char cBroadcast = 1;
    sockaddr_in sin;
    CDiscReq dreq;
    CDiscRsp drsp;

    XNetRandom(dreq.abNonce, sizeof(dreq.abNonce));

    Verify(setsockopt(s, SOL_SOCKET, SO_BROADCAST, &cBroadcast, 1) == 0);

    while (1)
    {
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = INADDR_BROADCAST;
        sin.sin_port = NTOHS(1234);
        Verify(sendto(s, (char *)&dreq, sizeof(dreq), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(dreq));

        fd_set  fds;
        TIMEVAL tv;
        FD_ZERO(&fds);
        FD_SET(s, &fds);
        tv.tv_sec  = 0;
        tv.tv_usec = 200000;

        INT iResult = select(0, &fds, NULL, NULL, &tv);
        Verify(iResult != SOCKET_ERROR);

        while (1)
        {
            ULONG ul = 0;
            iResult = ioctlsocket(s, FIONREAD, &ul);
            Verify(iResult != SOCKET_ERROR);

            if (ul == 0)
                break;

            Verify(recv(s, (char *)&drsp, sizeof(drsp), 0) == sizeof(drsp));
            if (memcmp(drsp.abNonce, dreq.abNonce, sizeof(drsp.abNonce)) == 0)
                goto done;
        }
    }

done:

    Verify(XNetRegisterKey(&drsp.xnkid, &drsp.xnkey) == 0);
    Verify(XNetXnAddrToInAddr(&drsp.xnaddr, &drsp.xnkid, (IN_ADDR *)pipa) == 0);
    Verify(closesocket(s) == 0);
    *pxnkid = drsp.xnkid;
}

void CTestXNet::SgTcpXbToXbClient()
{
    while (XNetGetTitleXnAddr(&g_xnaddrXb1) == XNET_GET_XNADDR_PENDING)
        Sleep(100);

    IN_ADDR inaVip, inaSg, inaXb2;
    HANDLE hEventLogon;

    inaVip.s_addr = inet_addr("10.0.0.2");
    Verify(XNetServerToInAddr(inaVip, 0, &inaSg) == 0);
    Verify((hEventLogon = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);
    GetXn()->IpLogon(inaSg.s_addr, NULL, hEventLogon);
    Verify(WaitForSingleObject(hEventLogon, INFINITE) == WAIT_OBJECT_0);
    Verify(GetXn()->IpLogonGetStatus(NULL) == XN_LOGON_STATE_ONLINE);

    Verify(WaitForSingleObject(g_hEventXb1ToXb2, INFINITE) == WAIT_OBJECT_0);

    Verify(XNetRegisterKey(&g_xnkidXb1ToXb2, &g_xnkeyXb1ToXb2) == 0);
    Verify(XNetXnAddrToInAddr(&g_xnaddrXb2, &g_xnkidXb1ToXb2, &inaXb2) == 0);

    SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    Verify(s != SOCKET_ERROR);
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = inaXb2.s_addr;
    sin.sin_port = HTONS(80);
    DWORD dwTick = GetTickCount();
    INT err = connect(s, (struct sockaddr *)&sin, sizeof(sin));
    dwTick = GetTickCount() - dwTick;
    g_cSecsXb1ToXb2Connect = (dwTick + 500) / 1000;

    if (err == SOCKET_ERROR)
    {
        g_fXb1ToXb2Timeout = TRUE;
    }

    SetEvent(g_hEventXb2ToXb1);

    if (!g_fXb1ToXb2Timeout)
    {
        SockTcpTransmit(s, 10);
    }

    Verify(closesocket(s) == 0);

    // don't blow away the SA before the TCP connection has a chance to close gracefully
    Sleep(100);
    
    Verify(XNetUnregisterKey(&g_xnkidXb1ToXb2) == 0);

    GetXn()->IpLogoff();
    Verify(CloseHandle(hEventLogon));
}

void CTestXNet::SgTcpXbToXbServer()
{
    while (XNetGetTitleXnAddr(&g_xnaddrXb2) == XNET_GET_XNADDR_PENDING)
        Sleep(100);

    IN_ADDR inaVip, inaSg, inaXb2;
    HANDLE hEventLogon;

    inaVip.s_addr = inet_addr("10.0.0.2");
    Verify(XNetServerToInAddr(inaVip, 0, &inaSg) == 0);
    Verify((hEventLogon = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);
    GetXn()->IpLogon(inaSg.s_addr, NULL, hEventLogon);
    Verify(WaitForSingleObject(hEventLogon, INFINITE) == WAIT_OBJECT_0);
    Verify(GetXn()->IpLogonGetStatus(NULL) == XN_LOGON_STATE_ONLINE);

    Verify(XNetCreateKey(&g_xnkidXb1ToXb2, &g_xnkeyXb1ToXb2) == 0);
    g_xnkidXb1ToXb2.ab[0] &= ~XNET_XNKID_MASK;
    g_xnkidXb1ToXb2.ab[0] |=  XNET_XNKID_ONLINE_PEER;
    Verify(XNetRegisterKey(&g_xnkidXb1ToXb2, &g_xnkeyXb1ToXb2) == 0);
    DWORD dw = XNetGetTitleXnAddr(&g_xnaddrXb2);
    Verify(dw != XNET_GET_XNADDR_PENDING);
    Verify(dw & XNET_GET_XNADDR_ONLINE);

    SOCKET s1 = SockTcpCreate(HTONS(80));
    Verify(listen(s1, 1) == 0);

    SetEvent(g_hEventXb1ToXb2);
    Verify(WaitForSingleObject(g_hEventXb2ToXb1, INFINITE) == WAIT_OBJECT_0);

    if (!g_fXb1ToXb2Timeout)
    {
        sockaddr_in sin;
        int slen = sizeof(sin);
        SOCKET s2 = accept(s1, (struct sockaddr *)&sin, &slen);
        Verify(s2 != SOCKET_ERROR);
        Verify(slen == sizeof(sin));
        SockTcpReflect(s2);
        Verify(closesocket(s2) == 0);
    }

    Verify(closesocket(s1) == 0);
    Verify(XNetUnregisterKey(&g_xnkidXb1ToXb2) == 0);

    GetXn()->IpLogoff();
    Verify(CloseHandle(hEventLogon));
}

#define XNETTEST_BEG(_name, pszXbox, pszIp, pszMask, pszGateway, dwFlags) \
    class CTest##_name : public CTestXNet { public: \
    CTest##_name() : CTestXNet(pszXbox) {}; \
    virtual void Init() { Startup(pszIp, pszMask, pszGateway, dwFlags); } \
    virtual void Test()
#define XNETTEST_END(_name) \
    }; void Test_##_name(HANDLE hEvent1 = 0, HANDLE hEvent2 = 0) { CTest##_name * p = new CTest##_name; p->Go(hEvent1, hEvent2); delete p; }

// ---------------------------------------------------------------------------------------
// TWOTHREADTEST
// ---------------------------------------------------------------------------------------

typedef void (*PFNTEST)(HANDLE hEvent1, HANDLE hEvent2);

typedef struct {
    HANDLE      hThread;
    HANDLE      hEvent1;
    HANDLE      hEvent2;
    PFNTEST     pfn;
} TWOTHREADPARAM;

DWORD WINAPI TwoThreadProc(void * pv)
{
    TWOTHREADPARAM * p = (TWOTHREADPARAM *)pv;
    p->pfn(p->hEvent1, p->hEvent2);
    return(0);
}

#define TWOTHREADTEST(_name) \
    void Test_##_name##_run() \
    { \
        g_fXb1ToXb2Timeout = FALSE; \
        Verify((g_hEventXb1ToXb2 = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL); \
        Verify((g_hEventXb2ToXb1 = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL); \
        HANDLE  hThread1 = NULL, hEvent1 = NULL, hThread2 = NULL, hEvent2 = NULL; \
        TWOTHREADPARAM p1, p2; \
        Verify((p1.hEvent1 = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL); \
        Verify((p1.hEvent2 = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL); \
        p1.pfn = &Test_##_name##_1; \
        p2.hEvent1 = p1.hEvent2; \
        p2.hEvent2 = p1.hEvent1; \
        p2.pfn = &Test_##_name##_2; \
        Verify((p1.hThread = CreateThread(NULL, 0, TwoThreadProc, &p1, 0, NULL)) != NULL); \
        Verify((p2.hThread = CreateThread(NULL, 0, TwoThreadProc, &p2, 0, NULL)) != NULL); \
        Verify(WaitForSingleObject(p1.hThread, INFINITE) == WAIT_OBJECT_0); \
        Verify(WaitForSingleObject(p2.hThread, INFINITE) == WAIT_OBJECT_0); \
        CloseHandle(p1.hEvent1); CloseHandle(p2.hEvent1); \
        CloseHandle(p1.hThread); CloseHandle(p2.hThread); \
        CloseHandle(g_hEventXb1ToXb2); g_hEventXb1ToXb2 = NULL; \
        CloseHandle(g_hEventXb2ToXb1); g_hEventXb2ToXb1 = NULL; \
    } \
    void Test_##_name() \

#define TWOTHREADRUN(_name) Test_##_name##_run()

// Test_inet_addr ------------------------------------------------------------------------

XNETTEST_BEG(inet_addr, "xb1@Lan", "10.0.0.1", "255.0.0.0", NULL, 0)
{
    printf("Testing inet_addr ");
    Verify(inet_addr("004.003.002.020") == 0x10020304);
    Verify(inet_addr("0377.0377.0377.0377") == 0xffffffff);
    Verify(inet_addr("004.003.002.0400") == 0x00020304);
    Verify(inet_addr("004.003.0400.020") == 0x10000304);
    Verify(inet_addr("004.0400.002.020") == 0x10020004);
    Verify(inet_addr("0400.003.002.020") == 0x10020300);
    Verify(inet_addr("0x4.0x3.0x2.0x10") == 0x10020304);
    Verify(inet_addr("0xFF.0xFF.0xFF.0xFF") == 0xffffffff);
    Verify(inet_addr("0x4.0x3.0x2.0x100") == 0x00020304);
    Verify(inet_addr("0x4.0x3.0x100.0x10") == 0x10000304);
    Verify(inet_addr("0x4.0x100.0x2.0x10") == 0x10020004);
    Verify(inet_addr("0x100.0x3.0x2.0x10") == 0x10020300);
    Verify(inet_addr("4.003.2.0x10") == 0x10020304);
    Verify(inet_addr("004.3.0x2.16") == 0x10020304);
    Verify(inet_addr("4.0x3.2.020") == 0x10020304);
    Verify(inet_addr("0x4.3.002.16") == 0x10020304);
    Verify(inet_addr("255.0377.255.0xFF") == 0xffffffff);
    Verify(inet_addr("0377.255.0xFF.255") == 0xffffffff);
    Verify(inet_addr("255.0xFF.255.0377") == 0xffffffff);
    Verify(inet_addr("0xFF.255.0377.255") == 0xffffffff);
    Verify(inet_addr("4.0400.2.0x10") == 0x10020004);
    Verify(inet_addr("004.3.0x100.16") == 0x10000304);
    Verify(inet_addr("256.0x3.2.020") == 0x10020300);
    Verify(inet_addr("0x4.3.002.256") == 0x00020304);
    Verify(inet_addr("4.3.2") == 0x02000304);
    Verify(inet_addr("255.255.255") == 0xff00ffff);
    Verify(inet_addr("4.3.256") == 0x00010304);
    Verify(inet_addr("4.3.65536") == 0x00000304);
    Verify(inet_addr("4.3") == 0x03000004);
    Verify(inet_addr("255.255") == 0xff0000ff);
    Verify(inet_addr("4.256") == 0x00010004);
    Verify(inet_addr("4.16777216") == 0x00000004);
    Verify(inet_addr("4") == 0x04000000);
    Verify(inet_addr("255") == 0xff000000);
    Verify(inet_addr("4294967296") == 0x00000000);
    Verify(inet_addr("4.3.2.16abcdef") == 0xffffffff);
    Verify(inet_addr("4.3.2abcdef.16") == 0xffffffff);
    Verify(inet_addr("4.3abcdef.2.16") == 0xffffffff);
    Verify(inet_addr("4abcdef.3.2.16") == 0xffffffff);
    Verify(inet_addr("4.3.2.abcdef16") == 0xffffffff);
    Verify(inet_addr("4.3.abcdef2.16") == 0xffffffff);
    Verify(inet_addr("4.abcdef3.2.16") == 0xffffffff);
    Verify(inet_addr("abcdef4.3.2.16") == 0xffffffff);
    Verify(inet_addr("4.3.2 .16") == 0x10020304);
    Verify(inet_addr("4.3 .2.16") == 0x10020304);
    Verify(inet_addr("4 .3.2.16") == 0x10020304);
    Verify(inet_addr("4.3.2. 16") == 0x10020304);
    Verify(inet_addr("4.3. 2.16") == 0x10020304);
    Verify(inet_addr("4. 3.2.16") == 0x10020304);
    Verify(inet_addr(" 4.3.2.16") == 0x10020304);
    printf(" [OK]\n");
}
XNETTEST_END(inet_addr);

// Test_XNetRandom -----------------------------------------------------------------------

XNETTEST_BEG(XNetRandom, "xb1@Lan", "10.0.0.1", "255.0.0.0", NULL, 0)
{
    printf("Testing XNetRandom ");

    DWORD dw1, dw2;
    Verify(XNetRandom((BYTE *)&dw1, sizeof(dw1)) == 0);
    Verify(XNetRandom((BYTE *)&dw2, sizeof(dw2)) == 0);
    Verify(dw1 != dw2);

    BYTE ab[13];
    UINT c = 200;
    for (; c > 0; --c)
    {
        Verify(XNetRandom(ab, sizeof(ab)) == 0);
    }

    printf("[OK]\n");
}
XNETTEST_END(XNetRandom);

// Test_XNetRegisterKey ------------------------------------------------------------------

XNETTEST_BEG(XNetRegisterKey, "xb1@Lan", "10.0.0.1", "255.0.0.0", NULL, 0)
{
    printf("Testing XNetRegisterKey ");

    XNKID xnkid1, xnkid2, xnkid3, xnkid4, xnkid5;
    XNKEY xnkey1, xnkey2, xnkey3, xnkey4, xnkey5;

    Verify(XNetCreateKey(&xnkid1, &xnkey1) == 0);
    Verify(XNetCreateKey(&xnkid2, &xnkey2) == 0);
    Verify(XNetCreateKey(&xnkid3, &xnkey3) == 0);
    Verify(XNetCreateKey(&xnkid4, &xnkey4) == 0);
    Verify(XNetCreateKey(&xnkid5, &xnkey5) == 0);

    Verify(XNetRegisterKey(&xnkid1, &xnkey1) == 0);
    Verify(XNetRegisterKey(&xnkid1, &xnkey1) == WSAEALREADY);
    Verify(XNetRegisterKey(&xnkid1, &xnkey2) == WSAEALREADY);
    Verify(XNetRegisterKey(&xnkid2, &xnkey2) == 0);
    Verify(XNetRegisterKey(&xnkid2, &xnkey1) == WSAEALREADY);
    Verify(XNetRegisterKey(&xnkid2, &xnkey2) == WSAEALREADY);
    Verify(XNetUnregisterKey(&xnkid1) == 0);
    Verify(XNetUnregisterKey(&xnkid1) == WSAEINVAL);
    Verify(XNetRegisterKey(&xnkid1, &xnkey1) == 0);
    Verify(XNetRegisterKey(&xnkid1, &xnkey1) == WSAEALREADY);
    Verify(XNetUnregisterKey(&xnkid2) == 0);
    Verify(XNetUnregisterKey(&xnkid2) == WSAEINVAL);
    Verify(XNetUnregisterKey(&xnkid1) == 0);
    Verify(XNetUnregisterKey(&xnkid1) == WSAEINVAL);
    Verify(XNetRegisterKey(&xnkid1, &xnkey1) == 0);
    Verify(XNetRegisterKey(&xnkid2, &xnkey2) == 0);
    Verify(XNetRegisterKey(&xnkid3, &xnkey3) == 0);
    Verify(XNetRegisterKey(&xnkid4, &xnkey4) == 0);
    Verify(XNetRegisterKey(&xnkid5, &xnkey5) == WSAENOMORE);
    Verify(XNetUnregisterKey(&xnkid3) == 0);
    Verify(XNetRegisterKey(&xnkid5, &xnkey5) == 0);
    Verify(XNetUnregisterKey(&xnkid3) == WSAEINVAL);
    Verify(XNetUnregisterKey(&xnkid2) == 0);
    Verify(XNetUnregisterKey(&xnkid4) == 0);
    Verify(XNetUnregisterKey(&xnkid1) == 0);
    Verify(XNetUnregisterKey(&xnkid5) == 0);

    printf("[OK]\n");
}
XNETTEST_END(XNetRegisterKey);

// Test_XNetXnAddrToInAddr ---------------------------------------------------------------

XNETTEST_BEG(XNetXnAddrToInAddr, "xb1@Lan", "10.0.0.1", "255.0.0.0", NULL, 0)
{
    printf("Testing XNetXnAddrToInAddr ");

    XNKID   xnkid1,     xnkid2,     xnkid3,     xnkidT,     xnkidZ;
    XNKEY   xnkey1,     xnkey2,     xnkey3,     xnkeyT;
    XNADDR  xnaddr1,    xnaddr2,    xnaddr3,    xnaddrT,    xnaddrZ;
    CIpAddr ipa1,       ipa2,       ipa3,       ipaT;

    Verify(XNetCreateKey(&xnkid1, &xnkey1) == 0);
    Verify(XNetCreateKey(&xnkid2, &xnkey2) == 0);
    Verify(XNetCreateKey(&xnkid3, &xnkey3) == 0);

    Verify(XNetRegisterKey(&xnkid1, &xnkey1) == 0);
    Verify(XNetRegisterKey(&xnkid2, &xnkey2) == 0);
    Verify(XNetRegisterKey(&xnkid3, &xnkey3) == 0);
    
    Verify(XNetGetTitleXnAddr(&xnaddr1) != 0);
    Verify(XNetXnAddrToInAddr(&xnaddr1, &xnkid1, (IN_ADDR *)&ipa1) == 0);
    Verify(ipa1 == IPADDR_LOOPBACK);

    memset(&xnkidZ, 0, sizeof(xnkidZ));
    Verify(XNetInAddrToXnAddr(*(IN_ADDR *)&ipa1, &xnaddrT, &xnkidT) == 0);
    Verify(memcmp(&xnaddr1, &xnaddrT, sizeof(XNADDR)) == 0);
    Verify(memcmp(&xnkidT, &xnkidZ, sizeof(xnkidZ)) == 0);

    XNADDR  rgxna[32];
    CIpAddr rgipa[32];
    int     i;

    for (i = 0; i < dimensionof(rgxna); ++i)
    {
        XNADDR * pxnaddr = &rgxna[i];
        memset(pxnaddr, 0, sizeof(XNADDR));
        Verify(XNetRandom(pxnaddr->abEnet, sizeof(pxnaddr->abEnet)) == 0);
        pxnaddr->ina.s_addr = 0;
        XNKID * pxnkid = ((i % 3) == 0 ? &xnkid1 : ((i % 3) == 1) ? &xnkid2 : &xnkid3);
        Verify(XNetXnAddrToInAddr(pxnaddr, pxnkid, (IN_ADDR *)&rgipa[i]) == 0);
    }

    memset(&xnaddrT, 0, sizeof(xnaddrT));
    Verify(XNetRandom(xnaddrT.abEnet, sizeof(xnaddrT.abEnet)) == 0);
    Verify(XNetXnAddrToInAddr(&xnaddrT, &xnkid1, (IN_ADDR *)&ipaT) == WSAENOMORE);

    for (i = 0; i < dimensionof(rgxna); ++i)
    {
        XNADDR * pxnaddr = &rgxna[i];
        XNKID * pxnkid = ((i % 3) == 0 ? &xnkid1 : ((i % 3) == 1) ? &xnkid2 : &xnkid3);
        Verify(XNetInAddrToXnAddr(*(IN_ADDR *)&rgipa[i], &xnaddrT, &xnkidT) == 0);
        Verify(memcmp(&xnaddrT, &rgxna[i], sizeof(XNADDR)) == 0);
        Verify(memcmp(&xnkidT, pxnkid, sizeof(XNKID)) == 0);
    }

    Verify(XNetUnregisterKey(&xnkid2) == 0);

    for (i = 0; i < dimensionof(rgxna); ++i)
    {
        XNKID * pxnkid = ((i % 3) == 0 ? &xnkid1 : ((i % 3) == 1) ? &xnkid2 : &xnkid3);
        if ((i % 3) == 1)
        {
            memset(&xnaddrZ, 0, sizeof(XNADDR));
            memcpy(&xnaddrT, &rgxna[i], sizeof(XNADDR));
            memset(&xnkidZ, 0, sizeof(XNKID));
            memcpy(&xnkidT, pxnkid, sizeof(XNKID));
            Verify(XNetInAddrToXnAddr(*(IN_ADDR *)&rgipa[i], &xnaddrT, &xnkidT) == WSAEINVAL);
            Verify(memcmp(&xnaddrT, &xnaddrZ, sizeof(XNADDR)) == 0);
            Verify(memcmp(&xnkidT, &xnkidZ, sizeof(XNKID)) == 0);
        }
        else
        {
            Verify(XNetInAddrToXnAddr(*(IN_ADDR *)&rgipa[i], &xnaddrT, &xnkidT) == 0);
            Verify(memcmp(&xnaddrT, &rgxna[i], sizeof(XNADDR)) == 0);
            Verify(memcmp(&xnkidT, pxnkid, sizeof(XNKID)) == 0);
        }
    }

    Verify(XNetUnregisterKey(&xnkid1) == 0);
    Verify(XNetUnregisterKey(&xnkid3) == 0);

    printf("[OK]\n");
}
XNETTEST_END(XNetXnAddrToInAddr)

// Test_Broadcast ------------------------------------------------------------------------

IPTEST_BEG(Broadcast_1, "xb1@Lan", "10.0.0.1", "255.0.0.0", NULL, XNET_STARTUP_BYPASS_SECURITY)
{
    Verify((_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);

    _uiFlags = PKTF_TYPE_UDP_ESP|PKTF_CRYPT;

    for (int i = 0; i < 2; ++i)
    {
        Rand(_ab, sizeof(_ab));

        CPacket *   ppkt    = PacketAlloc(0, _uiFlags, sizeof(_ab));
        CUdpHdr *   pUdpHdr = ppkt->GetUdpHdr();
        memcpy(pUdpHdr + 1, _ab, sizeof(_ab));
        pUdpHdr->_ipportDst = HTONS(666);
        pUdpHdr->_ipportSrc = HTONS(666);
        pUdpHdr->_wLen      = HTONS(sizeof(CUdpHdr) + sizeof(_ab));
        IpFillAndXmit(ppkt, IPADDR_BROADCAST, IPPROTOCOL_UDP, NULL);
        Verify(WaitForSingleObject(_hEvent, INFINITE) == WAIT_OBJECT_0);
        _uiFlags = PKTF_TYPE_UDP;
    }
}

virtual void UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    Verify(ppkt->IsUdp());
    Verify(pIpHdr->_ipaDst.IsBroadcast());
    Verify(!!ppkt->TestFlags(PKTF_TYPE_ESP) == !!(_uiFlags & PKTF_TYPE_ESP));
    Verify(!!ppkt->TestFlags(PKTF_CRYPT) == !!(_uiFlags & PKTF_CRYPT));
    Verify(pUdpHdr->_ipportDst == HTONS(666));
    Verify(pUdpHdr->_ipportSrc == HTONS(666));
    Verify(NTOHS(pUdpHdr->_wLen) == sizeof(CUdpHdr) + sizeof(_ab));
    Verify(memcmp(pUdpHdr + 1, _ab, sizeof(_ab)) == 0);
    SetEvent(_hEvent);
}

UINT _uiFlags;
HANDLE _hEvent;
BYTE _ab[211];

IPTEST_END(Broadcast_1);

IPTEST_BEG(Broadcast_2, "xb2@Lan", "10.0.0.2", "255.0.0.0", NULL, XNET_STARTUP_BYPASS_SECURITY)
{
    Verify((_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);

    for (int i = 0; i < 2; ++i)
    {
        Verify(WaitForSingleObject(_hEvent, INFINITE) == WAIT_OBJECT_0);
    }
}

virtual void UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    Verify(pIpHdr->_ipaDst.IsBroadcast());
    UINT uiFlags = (ppkt->GetFlags() & (PKTF_TYPE_UDP|PKTF_TYPE_ESP|PKTF_CRYPT));
    CPacket * ppktNew = PacketAlloc(PTAG_CPacket, PKTF_POOLALLOC|uiFlags, cbLen);
    memcpy(ppktNew->GetUdpHdr(), pUdpHdr, sizeof(CUdpHdr) + cbLen);
    IpFillAndXmit(ppktNew, IPADDR_BROADCAST, IPPROTOCOL_UDP, NULL);
    SetEvent(_hEvent);
}

HANDLE _hEvent;

IPTEST_END(Broadcast_2);

TWOTHREADTEST(Broadcast)
{
    printf("Testing Broadcast ");
    TWOTHREADRUN(Broadcast);
    printf("[OK]\n");
}

// Test_Discovery ------------------------------------------------------------------------

#define DISCOVERY_UNICAST       200

IPTEST_BEG(Discovery_1, "xb1@Lan", "10.0.0.1", "255.0.0.0", NULL, 0)
{
    // This is the host of the "game session".  We create a key and register it.

    Verify((_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);
    Verify(IpCreateKey(&_xnkid, &_xnkey) == 0);
    IpGetXnAddr(&_xnaddr);
    Verify(IpRegisterKey(&_xnkid, &_xnkey) == 0);
    _fListening = TRUE;

    // Now we wait for discovery requests and respond with a discovery response.
    // This event will be signalled as soon as we've responded.

    Verify(WaitForSingleObject(_hEvent, INFINITE) == WAIT_OBJECT_0);
    Verify(_cBroadcast > 0);

    // Now we wait for a stream of unicast UDP packets from the client

    while (_cUnicast < DISCOVERY_UNICAST)
    {
        Verify(WaitForSingleObject(_hEvent, INFINITE) == WAIT_OBJECT_0);
    }

    Verify(IpUnregisterKey(&_xnkid) == 0);
}

virtual void UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    if (pIpHdr->_ipaDst.IsBroadcast())
    {
        if (!_fListening)
        {
            TraceSz(Warning, "Dropping discovery request that arrived too early");
            return;
        }

        Verify(cbLen == sizeof(CDiscReq));
        Verify(pUdpHdr->_ipportDst == HTONS(666));
        Verify(pUdpHdr->_ipportSrc == HTONS(666));
        CDiscReq *  pDiscReq    = (CDiscReq *)(pUdpHdr + 1);
        CPacket *   ppktNew     = PacketAlloc(PTAG_CPacket, PKTF_POOLALLOC|PKTF_TYPE_UDP_ESP|PKTF_CRYPT, sizeof(CDiscRsp));
        CUdpHdr *   pUdpHdrNew  = ppktNew->GetUdpHdr();
        pUdpHdrNew->_ipportDst  = HTONS(666);
        pUdpHdrNew->_ipportSrc  = HTONS(666);
        pUdpHdrNew->_wLen       = HTONS(sizeof(CUdpHdr) + sizeof(CDiscRsp));
        CDiscRsp *  pDiscRsp    = (CDiscRsp *)(pUdpHdrNew + 1);
        memcpy(pDiscRsp->abNonce, pDiscReq->abNonce, sizeof(pDiscReq->abNonce));
        pDiscRsp->xnkid         = _xnkid;
        pDiscRsp->xnkey         = _xnkey;
        pDiscRsp->xnaddr        = _xnaddr;
        IpFillAndXmit(ppktNew, IPADDR_BROADCAST, IPPROTOCOL_UDP, NULL);
        _cBroadcast += 1;
        SetEvent(_hEvent);
        return;
    }

    CIpAddr ipaSrc = pIpHdr->_ipaSrc;
    XNKID   xnkid;
    XNADDR  xnaddr;
    Verify(IpInAddrToXnAddr(ipaSrc, &xnaddr, &xnkid) == 0);
    Verify(memcmp(&xnkid, &_xnkid, sizeof(XNKID)) == 0);
    Verify(ppkt->GetEnetHdr()->_eaSrc.IsEqual(xnaddr.abEnet));
    UINT uiFlags = ppkt->GetFlags() & (PKTF_TYPE_UDP|PKTF_TYPE_ESP|PKTF_CRYPT);
    CPacket * ppktNew = PacketAlloc(PTAG_CPacket, PKTF_POOLALLOC|uiFlags, cbLen);
    memcpy(ppktNew->GetUdpHdr(), pUdpHdr, sizeof(CUdpHdr) + cbLen);
    IpFillAndXmit(ppktNew, ipaSrc, IPPROTOCOL_UDP, NULL);
    _cUnicast += 1;
    SetEvent(_hEvent);
}

HANDLE _hEvent;
XNKID _xnkid;
XNKEY _xnkey;
XNADDR _xnaddr;
BOOL _fListening;
UINT _cBroadcast;
UINT _cUnicast;

IPTEST_END(Discovery_1);

IPTEST_BEG(Discovery_2, "xb2@Lan", "10.0.0.2", "255.0.0.0", NULL, 0)
{
    Verify((_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);

    // Until we get a response, keep broadcasting a CDiscReq packet

    Rand(_abNonce, sizeof(_abNonce));

    while (_cBroadcast == 0)
    {
        CPacket * ppkt = PacketAlloc(0, PKTF_TYPE_UDP_ESP|PKTF_CRYPT, sizeof(CDiscReq));
        CUdpHdr * pUdpHdr = ppkt->GetUdpHdr();
        CDiscReq * pDiscReq = (CDiscReq *)(pUdpHdr + 1);
        pUdpHdr->_ipportDst  = HTONS(666);
        pUdpHdr->_ipportSrc  = HTONS(666);
        pUdpHdr->_wLen       = HTONS(sizeof(CUdpHdr) + sizeof(CDiscReq));
        memcpy(pDiscReq->abNonce, _abNonce, sizeof(_abNonce));
        IpFillAndXmit(ppkt, IPADDR_BROADCAST, IPPROTOCOL_UDP, NULL);
        WaitForSingleObject(_hEvent, 200);
    }

    // Register the host's key

    Verify(IpRegisterKey(&_xnkid, &_xnkey) == 0);

    // Get a secure IP address for the host

    CIpAddr ipaHost;

    Verify(IpXnAddrToInAddr(&_xnaddr, &_xnkid, &ipaHost) == 0);

    // Send Unicast UDP packets

    Rand(_ab, sizeof(_ab));

    UINT i;

    for (i = 0; i < DISCOVERY_UNICAST; ++i)
    {
        UINT uiFlags = PKTF_TYPE_UDP_ESP|PKTF_CRYPT;
        CPacket * ppkt = PacketAlloc(0, uiFlags, sizeof(_ab));
        CUdpHdr * pUdpHdr = ppkt->GetUdpHdr();
        pUdpHdr->_ipportDst  = HTONS(666);
        pUdpHdr->_ipportSrc  = HTONS(666);
        pUdpHdr->_wLen       = HTONS(sizeof(CUdpHdr) + sizeof(_ab));
        memcpy(pUdpHdr + 1, _ab, sizeof(_ab));
        IpFillAndXmit(ppkt, ipaHost, IPPROTOCOL_UDP, NULL);

        // Don't get too far ahead of the other side

        while (_cUnicast + 6 < i)
        {
            Verify(WaitForSingleObject(_hEvent, INFINITE) == WAIT_OBJECT_0);
        }
    }

    // Wait for the remaining packets to be reflected

    while (_cUnicast < i)
    {
        Verify(WaitForSingleObject(_hEvent, INFINITE) == WAIT_OBJECT_0);
    }

    Verify(IpUnregisterKey(&_xnkid) == 0);
}

virtual void UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    if (pIpHdr->_ipaDst.IsBroadcast())
    {
        Verify(cbLen == sizeof(CDiscRsp));
        Verify(pUdpHdr->_ipportDst == HTONS(666));
        Verify(pUdpHdr->_ipportSrc == HTONS(666));
        CDiscRsp * pDiscRsp = (CDiscRsp *)(pUdpHdr + 1);
        Verify(memcmp(pDiscRsp->abNonce, _abNonce, sizeof(_abNonce)) == 0);
        _xnkid = pDiscRsp->xnkid;
        _xnkey = pDiscRsp->xnkey;
        _xnaddr = pDiscRsp->xnaddr;
        _cBroadcast += 1;
        SetEvent(_hEvent);
        return;
    }

    Verify(pUdpHdr->_ipportDst == HTONS(666));
    Verify(pUdpHdr->_ipportSrc == HTONS(666));
    Verify(cbLen == sizeof(_ab));
    Verify(memcmp(pUdpHdr + 1, _ab, sizeof(_ab)) == 0);
    _cUnicast += 1;
    SetEvent(_hEvent);
}

HANDLE _hEvent;
XNKID _xnkid;
XNKEY _xnkey;
XNADDR _xnaddr;
BYTE _abNonce[8];
BYTE _ab[592];
UINT _cBroadcast;
UINT _cUnicast;

IPTEST_END(Discovery_2);

TWOTHREADTEST(Discovery)
{
    printf("Testing Discovery ");
    TWOTHREADRUN(Discovery);
    printf("[OK]\n");
}

// Test_Frag -----------------------------------------------------------------------------

#define FRAGALG_FORWARD     0
#define FRAGALG_REVERSE     1
#define FRAGALG_RANDOM      2
#define FRAGALG_OVERLAP     3
#define FRAGALG_COUNT       4

DefineTag(fragTest, 0);

IPTEST_BEG(Frag, "xb1@Lan", "10.0.0.1", "255.0.0.0", NULL, 0)
{
    Verify((_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);

    for (int iAlg = 0; iAlg < FRAGALG_COUNT; ++iAlg)
    {
        printf("Testing Fragment Reassembler (%s) ",
               iAlg == FRAGALG_FORWARD ? "forward" :
               iAlg == FRAGALG_REVERSE ? "reverse" :
               iAlg == FRAGALG_RANDOM ? "random" : "overlap");

        if (iAlg == FRAGALG_RANDOM)
        {
            printf(" ");
        }

        for (int cbHdrOpt = 0; cbHdrOpt <= (MAXIPHDRLEN-sizeof(CIpHdr)); cbHdrOpt += 4)
        {
            printf(".");

            for (int cbData = 1; cbData < (int)(ENET_DATA_MAXSIZE - sizeof(CIpHdr) - cbHdrOpt - sizeof(CUdpHdr)); )
            {
                int cbChunk = 8;

                while (1)
                {
                    TestFrag(cbHdrOpt, cbData, iAlg, cbChunk);

                    if (cbChunk < 64)
                        cbChunk += 8;
                    else
                        cbChunk += 32;

                    if (cbChunk > (int)((cbData + sizeof(CUdpHdr)) / 2))
                        break;
                }

                if (cbData < 63)
                    cbData += 1;
                else if (cbData < 253)
                    cbData += 51;
                else
                    cbData += 127;
            }
        }

        printf(" [OK]\n");
    }

    CloseHandle(_hEvent);
}

void TestFrag(int cbHdrOpt, int cbData, int iAlg, int cbChunk)
{
    CIpHdr *        pIpHdr;
    CUdpHdr *       pUdpHdr;
    CPseudoHeader   ph;
    UINT            uiChecksum;
    int             iChunk;
    int             cChunk;

    TraceSz4(fragTest, "cbHdrOpt=%d,cbData=%d,iAlg=%d,cbChunk=%d", cbHdrOpt, cbData, iAlg, cbChunk);

    ResetEvent(_hEvent);

    // Create the original packet

    _ppktOrig = PacketAlloc(0, PKTF_TYPE_UDP, cbHdrOpt + cbData);
    Verify(_ppktOrig != NULL);

    pIpHdr              = _ppktOrig->GetIpHdr();
    pIpHdr->SetHdrLen(sizeof(CIpHdr) + cbHdrOpt);
    pIpHdr->_bTos       = 0;
    pIpHdr->_wLen       = HTONS(sizeof(CIpHdr) + cbHdrOpt + sizeof(CUdpHdr) + cbData);
    pIpHdr->_wId        = HTONS(GetNextDgramId());
    pIpHdr->_wFragOff   = 0;
    pIpHdr->_bTtl       = 64;
    pIpHdr->_bProtocol  = IPPROTOCOL_UDP;
    pIpHdr->_ipaSrc     = IPADDR_LOOPBACK;
    pIpHdr->_ipaDst     = IPADDR_LOOPBACK;
    Rand((BYTE *)(pIpHdr + 1), cbHdrOpt);
    pIpHdr->_wChecksum  = 0;
    pIpHdr->_wChecksum  = ~tcpipxsum(0, pIpHdr, sizeof(CIpHdr) + cbHdrOpt);

    _ppktOrig->SetHdrOptLen(cbHdrOpt);

    pUdpHdr             = _ppktOrig->GetUdpHdr();
    pUdpHdr->_ipportSrc = HTONS(666);
    pUdpHdr->_ipportDst = HTONS(666);
    pUdpHdr->_wLen      = HTONS(sizeof(CUdpHdr) + cbData);
    pUdpHdr->_wChecksum = 0;
    Rand((BYTE *)(pUdpHdr + 1), cbData);
    ph._ipaSrc          = pIpHdr->_ipaSrc;
    ph._ipaDst          = pIpHdr->_ipaDst;
    ph._bZero           = 0;
    ph._bProtocol       = IPPROTOCOL_UDP;
    ph._wLen            = HTONS(sizeof(CUdpHdr) + cbData);
    pUdpHdr->_wChecksum = 0;
    uiChecksum          = ~tcpipxsum(tcpipxsum(0, &ph, sizeof(ph)), pUdpHdr, sizeof(CUdpHdr) + cbData);
    pUdpHdr->_wChecksum = uiChecksum - (uiChecksum == 0);

    TraceUdpHdr(fragTest, 0, pUdpHdr, pUdpHdr->GetLen() - sizeof(CUdpHdr));
    TraceSz9(fragTest, "[IP %s %s (%d %d %04X %04X) %d]{%d}[%d]",
             pIpHdr->_ipaDst.Str(), pIpHdr->_ipaSrc.Str(), pIpHdr->_bTos, pIpHdr->_bTtl,
             NTOHS(pIpHdr->_wId), NTOHS(pIpHdr->_wFragOff), pIpHdr->_bProtocol,
             pIpHdr->GetOptLen(), _ppktOrig->GetCb() - pIpHdr->GetHdrLen());

    // Create and send packet fragments

    cbData += sizeof(CUdpHdr);
    cChunk  = (cbData + cbChunk - 1) / cbChunk;

    if (iAlg == FRAGALG_FORWARD)
    {
        for (iChunk = 0; iChunk < cChunk; ++iChunk)
        {
            SendChunk(iChunk, 1, cbChunk, iChunk == (cChunk - 1));
        }
    }
    else if (iAlg == FRAGALG_REVERSE)
    {
        for (iChunk = cChunk - 1; iChunk >= 0; --iChunk)
        {
            SendChunk(iChunk, 1, cbChunk, iChunk == (cChunk - 1));
        }
    }
    else if (iAlg == FRAGALG_RANDOM || iAlg == FRAGALG_OVERLAP)
    {
        BYTE abMap[ENET_DATA_MAXSIZE / 8];
        int cChunkSent = 0;

        memset(abMap, 0, sizeof(abMap));

        while (cChunkSent < cChunk)
        {
            // Randomly select a chunk to send.  If that chunk is already sent,
            // look for the next one that isn't sent yet.

            int iChunkRand = rand() % cChunk;

            while (abMap[iChunkRand])
            {
                iChunkRand += 1;
                if (iChunkRand == cChunk)
                    iChunkRand = 0;
            }

            if (iAlg == FRAGALG_OVERLAP)
            {
                int iChunkBeg = iChunkRand;
                int iChunkEnd = iChunkRand;

                if (iChunkBeg > 0)
                {
                    // Back up a random number of chunks (no more than 4)

                    iChunkBeg -= rand() % (min(4, iChunkBeg));
                    Verify(iChunkBeg >= 0);
                }

                if (iChunkEnd < (cChunk - 1))
                {
                    // Extend the range a random number of chunks (no more than 4)

                    iChunkEnd += rand() % (cChunk - iChunkEnd);
                    Verify(iChunkEnd < cChunk);
                }

                if (iChunkBeg == 0 && iChunkEnd == (cChunk - 1))
                {
                    // Whoops.  Can't send the whole thing in one chunk.

                    if (iChunkBeg != iChunkRand)
                        iChunkBeg += 1;
                    else
                    {
                        Verify(iChunkEnd != iChunkRand);
                        iChunkEnd -= 1;
                    }
                }

                Verify(iChunkBeg >= 0);
                Verify(iChunkEnd < cChunk);

                for (iChunkRand = iChunkBeg; iChunkRand <= iChunkEnd; ++iChunkRand)
                {
                    if (abMap[iChunkRand] == 0)
                    {
                        abMap[iChunkRand] = 1;
                        cChunkSent += 1;
                        Verify(cChunkSent <= cChunk);
                    }
                }

                SendChunk(iChunkBeg, iChunkEnd - iChunkBeg + 1, cbChunk, iChunkEnd == (cChunk - 1));
            }
            else
            {
                abMap[iChunkRand] = 1;
                cChunkSent += 1;
                Verify(cChunkSent <= cChunk);
                SendChunk(iChunkRand, 1, cbChunk, iChunkRand == (cChunk - 1));
            }
        }
    }

    // Wait for the packet to arrive

    Verify(WaitForSingleObject(_hEvent, 1000) == WAIT_OBJECT_0);

    PacketFree(_ppktOrig);
    _ppktOrig = NULL;
}

void SendChunk(int iChunk, int cChunk, int cbChunk, BOOL fLastChunk)
{
    CIpHdr *    pIpHdrOrig   = _ppktOrig->GetIpHdr();
    int         cbHdrOptOrig = pIpHdrOrig->GetOptLen();
    int         cbDataOrig   = _ppktOrig->GetCb() - sizeof(CIpHdr) - cbHdrOptOrig;
    int         cbHdrOpt     = iChunk == 0 ? cbHdrOptOrig : 0;
    int         ibData       = iChunk * cbChunk;
    int         cbData       = cChunk * cbChunk;

    Verify(ibData < cbDataOrig);

    if (ibData + cbData >= cbDataOrig)
    {
        cbData = cbDataOrig - ibData;
        Verify(fLastChunk);
    }

    Verify(cbData > 0);
    Verify(!fLastChunk || iChunk > 0);

    CPacket *   ppkt    = PacketAlloc(0, PKTF_TYPE_IP, cbHdrOpt + cbData);
    Verify(ppkt != NULL);

    CIpHdr *    pIpHdr  = ppkt->GetIpHdr();
    memcpy(pIpHdr, pIpHdrOrig, sizeof(CIpHdr) + cbHdrOpt);
    pIpHdr->SetHdrLen(sizeof(CIpHdr) + cbHdrOpt);
    pIpHdr->_wLen       = NTOHS((WORD)(sizeof(CIpHdr) + cbHdrOpt + cbData));
    pIpHdr->_wFragOff   = NTOHS((WORD)((iChunk * (cbChunk / 8)) | (fLastChunk ? 0 : MORE_FRAGMENTS)));
    pIpHdr->_wChecksum  = 0;
    pIpHdr->_wChecksum  = ~tcpipxsum(0, pIpHdr, pIpHdr->GetHdrLen());
    memcpy((BYTE *)(pIpHdr + 1) + cbHdrOpt, (BYTE *)(pIpHdrOrig + 1) + cbHdrOptOrig + ibData, cbData);

    RaiseToDpc();
    IpXmit(ppkt);
}

void UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    Verify(ppkt->GetCb() == _ppktOrig->GetCb());
    Verify(memcmp(ppkt->GetPv(), _ppktOrig->GetPv(), ppkt->GetCb()) == 0);
    SetEvent(_hEvent);
}

CPacket *   _ppktOrig;
HANDLE      _hEvent;

IPTEST_END(Frag);

// Test_SockUdp --------------------------------------------------------------------------

XNETTEST_BEG(SockUdp_1, "xb1@Lan", "10.0.0.1", "255.0.0.0", NULL, 0)
{
    SOCKET s = SockUdpCreate(NTOHS(1567));
    XNKID xnkid;
    DiscoveryHost(1, &xnkid);
    SockUdpReflect(s);
    Verify(closesocket(s) == 0);
    Verify(XNetUnregisterKey(&xnkid) == 0);
}
XNETTEST_END(SockUdp_1);

XNETTEST_BEG(SockUdp_2, "xb2@Lan", "10.0.0.2", "255.0.0.0", NULL, 0)
{
    SOCKET s = SockUdpCreate(CIpPort(NTOHS(6543)));
    XNKID xnkid;
    CIpAddr ipa;
    DiscoveryClient(&xnkid, &ipa);
    SockUdpTransmit(s, ipa, CIpPort(NTOHS(1567)));
    Verify(closesocket(s) == 0);
    Verify(XNetUnregisterKey(&xnkid) == 0);
}
XNETTEST_END(SockUdp_2);

TWOTHREADTEST(SockUdp)
{
    printf("Testing SockUdp ");
    TWOTHREADRUN(SockUdp);
    printf(" [OK]\n");
}

// Test_SockTcp --------------------------------------------------------------------------

XNETTEST_BEG(SockTcp_1, "xb1@Lan", "10.0.0.1", "255.0.0.0", NULL, 0)
{
    SOCKET s1 = SockTcpCreate(NTOHS(1567));
    Verify(listen(s1, 1) == 0);
    XNKID xnkid;
    DiscoveryHost(1, &_xnkid);
    sockaddr_in sin;
    int slen = sizeof(sin);
    SOCKET s2 = accept(s1, (struct sockaddr *)&sin, &slen);
    Verify(s2 != SOCKET_ERROR);
    Verify(slen == sizeof(sin));
    SockTcpReflect(s2);
    Verify(closesocket(s2) == 0);
    Verify(closesocket(s1) == 0);
}

virtual void Term()
{
    Verify(XNetUnregisterKey(&_xnkid) == 0);
    CTestXNet::Term();
}

XNKID _xnkid;

XNETTEST_END(SockTcp_1);

XNETTEST_BEG(SockTcp_2, "xb2@Lan", "10.0.0.2", "255.0.0.0", NULL, 0)
{
    SOCKET s = SockTcpCreate();
    XNKID xnkid;
    CIpAddr ipa;
    DiscoveryClient(&_xnkid, &ipa);
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = ipa;
    sin.sin_port = NTOHS(1567);
    Verify(connect(s, (struct sockaddr *)&sin, sizeof(sin)) != SOCKET_ERROR);
    SockTcpTransmit(s);
    Verify(closesocket(s) == 0);
}

virtual void Term()
{
    Verify(XNetUnregisterKey(&_xnkid) == 0);
    CTestXNet::Term();
}

XNKID _xnkid;

XNETTEST_END(SockTcp_2);

TWOTHREADTEST(SockTcp)
{
    printf("Testing SockTcp ");
    TWOTHREADRUN(SockTcp);
    printf(" [OK]\n");
}

// Test_Dhcp -----------------------------------------------------------------------------

#include <pshpack1.h>

struct DhcpMessage
{
    CEnetHdr        _enethdr;           // [ENET]
    CIpHdr          _iphdr;             // [IP]
    CUdpHdr         _udphdr;            // [UDP]
    BYTE            _op;                // message type
    BYTE            _htype;             // hareware address type
    BYTE            _hlen;              // hardware address length
    BYTE            _hops;              // relay hops
    DWORD           _xid;               // transaction ID
    WORD            _secs;              // seconds since address acquisition process began
    WORD            _flags;             // flags
    CIpAddr         _ciaddr;            // client IP address
    CIpAddr         _yiaddr;            // "your" (client) IP address
    CIpAddr         _siaddr;            // server IP address
    CIpAddr         _giaddr;            // relay agent IP address
    BYTE            _chaddr[16];        // client hardware address
    BYTE            _sname[64];         // optional server hostname
    BYTE            _file[128];         // boot filename
    BYTE            _options[256];      // optional parameters (variable length)
};

#include <poppack.h>

BYTE abDhcpResp[] =
{
    0x00,0x50,0xF2,0x00,0x17,0xFC,0x00,0x90,0x27,0xCC,0x74,0x7C,0x08,0x00,0x45,0x10,
    0x01,0x4E,0x00,0x00,0x00,0x00,0x10,0x11,0x9F,0x47,0x0A,0x47,0x00,0x02,0xFF,0xFF,
    0xFF,0xFF,0x00,0x43,0x00,0x44,0x01,0x3A,0xB4,0xF7,0x02,0x01,0x06,0x00,0x39,0x73,
    0xDD,0x20,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x0A,0x47,0xFE,0x63,0x0A,0x47,
    0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x50,0xF2,0x00,0x17,0xFC,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x63,0x82,0x53,0x63,0x35,0x01,0x02,0x36,0x04,0x0A,
    0x47,0x00,0x02,0x33,0x04,0x00,0x00,0x46,0x50,0x01,0x04,0xFF,0xFF,0x00,0x00,0x03,
    0x04,0x0A,0x47,0x00,0x01,0x06,0x0C,0x0A,0x47,0x00,0x02,0x0A,0x49,0x00,0x02,0xD1,
    0xF9,0xE0,0x82,0x0F,0x16,0x73,0x61,0x6E,0x6A,0x6F,0x73,0x65,0x2E,0x69,0x6E,0x66,
    0x6F,0x67,0x72,0x61,0x6D,0x65,0x73,0x2E,0x6C,0x6F,0x63,0xFF
};

BYTE abDhcpAck[] =
{
    0x00,0x50,0xF2,0x00,0x17,0xFC,0x00,0x90,0x27,0xCC,0x74,0x7C,0x08,0x00,0x45,0x10,
    0x01,0x4E,0x00,0x00,0x00,0x00,0x10,0x11,0x9F,0x47,0x0A,0x47,0x00,0x02,0xFF,0xFF,
    0xFF,0xFF,0x00,0x43,0x00,0x44,0x01,0x3A,0xB1,0xF6,0x02,0x01,0x06,0x00,0x39,0x73,
    0xDD,0x21,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x0A,0x47,0xFE,0x63,0x0A,0x47,
    0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x50,0xF2,0x00,0x17,0xFC,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x63,0x82,0x53,0x63,0x35,0x01,0x05,0x36,0x04,0x0A,
    0x47,0x00,0x02,0x33,0x04,0x00,0x00,0x46,0x50,0x01,0x04,0xFF,0xFF,0x00,0x00,0x03,
    0x04,0x0A,0x47,0x00,0x01,0x06,0x0C,0x0A,0x47,0x00,0x02,0x0A,0x49,0x00,0x02,0xD1,
    0xF9,0xE0,0x82,0x0F,0x16,0x73,0x61,0x6E,0x6A,0x6F,0x73,0x65,0x2E,0x69,0x6E,0x66,
    0x6F,0x67,0x72,0x61,0x6D,0x65,0x73,0x2E,0x6C,0x6F,0x63,0xFF
};

IPTEST_BEG(Dhcp, "xb1@Lan", NULL, NULL, NULL, 0)
{
    printf("Testing Dhcp ");
    XNADDR xnaddr;
    while (IpGetXnAddr(&xnaddr) == XNET_GET_XNADDR_PENDING)
        Sleep(100);
	Verify(xnaddr.ina.s_addr == inet_addr("10.71.254.99"));
    printf("[OK]\n");
}

virtual void EnetXmit(CPacket * ppkt, CIpAddr ipaNext)
{
    DhcpMessage * pdhcpMsg = (DhcpMessage *)ppkt->GetEnetHdr();
    DhcpMessage   dhcpMsg;

    BYTE * pb = abDhcpResp;
    UINT   cb = sizeof(abDhcpResp);

    if (_fGotDiscover)
    {
        pb = abDhcpAck;
        cb = sizeof(abDhcpAck);
    }

    Assert(sizeof(dhcpMsg) >= cb);
    memcpy(&dhcpMsg, pb, cb);

    memcpy(dhcpMsg._chaddr, _ea._ab, sizeof(_ea._ab));
    dhcpMsg._xid = pdhcpMsg->_xid;
    dhcpMsg._enethdr._eaDst = _ea;

    CPseudoHeader ph;
    ph._ipaSrc      = dhcpMsg._iphdr._ipaSrc;
    ph._ipaDst      = dhcpMsg._iphdr._ipaDst;
    ph._bZero       = 0;
    ph._bProtocol   = IPPROTOCOL_UDP;
    ph._wLen        = dhcpMsg._udphdr._wLen;
    dhcpMsg._udphdr._wChecksum = 0;
    UINT uiChecksum = ~tcpipxsum(tcpipxsum(0, &ph, sizeof(ph)), &dhcpMsg._udphdr, NTOHS(ph._wLen));
    dhcpMsg._udphdr._wChecksum = uiChecksum - (uiChecksum == 0);

    NicRecvFrame(&dhcpMsg, cb);

    CXnEnet::EnetXmit(ppkt, 0);

    _fGotDiscover = TRUE;
}

BOOL _fGotDiscover;

IPTEST_END(Dhcp)

// Test_Dns ------------------------------------------------------------------------------

XNETTEST_BEG(Dns, "xb1@Nic/0:FEFFDEADF00D", NULL, NULL, NULL, 0)
{
    printf("Testing Dns ");

    if (!VLanDriver())
    {
        printf("[No VLan]\n");
        return;
    }

    XNADDR xnaddr;
    while (XNetGetTitleXnAddr(&xnaddr) == XNET_GET_XNADDR_PENDING)
        Sleep(100);
    Verify((_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);
    
    XNDNS * pxndns = NULL;

    Verify(XNetDnsLookup("nosuchhost.foo.bar.com", _hEvent, &pxndns) == 0);
    Verify(WaitForSingleObject(_hEvent, INFINITE) == WAIT_OBJECT_0);
    Verify(pxndns->iStatus == WSAHOST_NOT_FOUND);
    Verify(pxndns->cina == 0);
    Verify(XNetDnsRelease(pxndns) == 0);

    Verify(XNetDnsLookup("products.redmond.corp.microsoft.com", _hEvent, &pxndns) == 0);
    Verify(WaitForSingleObject(_hEvent, INFINITE) == WAIT_OBJECT_0);
    Verify(pxndns->iStatus == 0);
    Verify(pxndns->cina > 0);
    Verify(XNetDnsRelease(pxndns) == 0);

    Verify(XNetDnsLookup("products.redmond.corp.microsoft.com", NULL, &pxndns) == 0);
    while (pxndns->iStatus == WSAEINPROGRESS)
        Sleep(100);
    Verify(pxndns->iStatus == 0);
    Verify(pxndns->cina > 0);
    Verify(XNetDnsRelease(pxndns) == 0);

    CloseHandle(_hEvent);
    printf("[OK]\n");
}

HANDLE _hEvent;

XNETTEST_END(Dns)

// Test_SgUdp ----------------------------------------------------------------------------

XNETTEST_BEG(SgUdp_1, "xb1@Internet", "10.0.0.10", "255.0.0.0", "10.0.0.1", 0)
{
    GetXn()->IpLogon(0, NULL, NULL);
    Sleep(200);
    IN_ADDR inaVip, inaSec;
    inaVip.s_addr = inet_addr("10.0.0.2");
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    SOCKET s = SockUdpCreate(0, FALSE);
    Verify(s != SOCKET_ERROR);
    SockUdpTransmit(s, inaSec.s_addr, CIpPort(NTOHS(1)));
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgUdp_1)

XNETTEST_BEG(SgUdp_2, "xb2@Datacenter", "10.0.0.4", "255.0.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s = SockUdpCreate(HTONS(127));
    SockUdpReflect(s);
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgUdp_2)

TWOTHREADTEST(SgUdp)
{
    printf("Testing SgUdp ");
    TWOTHREADRUN(SgUdp);
    printf(" [OK]\n");
}

// Test_SgTcp ----------------------------------------------------------------------------

XNETTEST_BEG(SgTcp_1, "xb1@Internet", "10.0.0.11", "255.0.0.0", "10.0.0.1", 0)
{
    GetXn()->IpLogon(0, NULL, NULL);
    Sleep(200);
    IN_ADDR inaVip, inaSec;
    inaVip.s_addr = inet_addr("10.0.0.2");
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    Verify(s != SOCKET_ERROR);
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr = inaSec;
    sin.sin_port = HTONS(2);
    Verify(connect(s, (struct sockaddr *)&sin, sizeof(sin)) != SOCKET_ERROR);
    SockTcpTransmit(s);
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgTcp_1)

XNETTEST_BEG(SgTcp_2, "xb2@Datacenter", "10.0.0.5", "255.0.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s1 = SockTcpCreate(HTONS(80));
    Verify(listen(s1, 1) == 0);
    sockaddr_in sin;
    int slen = sizeof(sin);
    SOCKET s2 = accept(s1, (struct sockaddr *)&sin, &slen);
    Verify(s2 != SOCKET_ERROR);
    Verify(slen == sizeof(sin));
    SockTcpReflect(s2);
    Verify(closesocket(s2) == 0);
    Verify(closesocket(s1) == 0);
}
XNETTEST_END(SgTcp_2)

TWOTHREADTEST(SgTcp)
{
    printf("Testing SgTcp ");
    TWOTHREADRUN(SgTcp);
    printf(" [OK]\n");
}

// Test_SgRst ----------------------------------------------------------------------------

XNETTEST_BEG(SgRst_1, "xb1@Internet", "10.0.0.11", "255.0.0.0", "10.0.0.1", 0)
{
    GetXn()->IpLogon(0, NULL, NULL);
    Sleep(200);
    IN_ADDR inaVip, inaSec;
    inaVip.s_addr = inet_addr("10.0.0.2");
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    Verify(s != SOCKET_ERROR);
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr = inaSec;
    sin.sin_port = HTONS(2);
    Verify(connect(s, (struct sockaddr *)&sin, sizeof(sin)) != SOCKET_ERROR);
    Verify(recv(s, (char *)&s, 1, 0) == 1);
    Verify(XNetUnregisterInAddr(inaSec) == 0);
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgRst_1)

XNETTEST_BEG(SgRst_2, "xb2@Datacenter", "10.0.0.5", "255.0.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s1 = SockTcpCreate(HTONS(80));
    Verify(listen(s1, 1) == 0);
    sockaddr_in sin;
    int slen = sizeof(sin);
    SOCKET s2 = accept(s1, (struct sockaddr *)&sin, &slen);
    Verify(s2 != SOCKET_ERROR);
    Verify(slen == sizeof(sin));

    while (1)
    {
        INT err = send(s2, (char *)&s2, 1, 0);

        if (err == SOCKET_ERROR)
        {
            Verify(WSAGetLastError() == WSAECONNRESET);
            break;
        }

        Sleep(100);
    }

    Verify(closesocket(s2) == 0);
    Verify(closesocket(s1) == 0);
}
XNETTEST_END(SgRst_2)

TWOTHREADTEST(SgRst)
{
    printf("Testing SgRst ");
    TWOTHREADRUN(SgRst);
    printf("[OK]\n");
}

// Test_SgAlive --------------------------------------------------------------------------

XNETTEST_BEG(SgAlive_1, "xb1@Internet", "10.0.0.10", "255.0.0.0", "10.0.0.1", 0)
{
    GetXn()->IpLogon(0, NULL, NULL);
    Sleep(200);
    IN_ADDR inaVip, inaSec;
    inaVip.s_addr = inet_addr("10.0.0.2");
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    SOCKET s = SockUdpCreate(0, FALSE);
    Verify(s != SOCKET_ERROR);
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr = inaSec;
    sin.sin_port = NTOHS(3);
    Verify(sendto(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(inaVip));

    // Sleep for a while to allow keepalives to flow
    Sleep(60 * 1000);

    sin.sin_family = AF_INET;
    sin.sin_addr = inaSec;
    sin.sin_port = NTOHS(3);
    Verify(sendto(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(inaVip));
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgAlive_1)

XNETTEST_BEG(SgAlive_2, "xb2@Datacenter", "10.0.0.6", "255.0.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s = SockUdpCreate(HTONS(123));

    IN_ADDR inaVip;
    sockaddr_in sin;
    int slen = sizeof(sin);
    
    Verify(recvfrom(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, &slen) == sizeof(inaVip));
    Verify(inaVip.s_addr == inet_addr("10.0.0.2"));

    CSgMsgAuthReq   sgar;

    sgar._wType   = SGMSG_TYPE_AUTHDATA_REQ;
    sgar._cbEnt   = sizeof(CSgMsgAuthReq);
    XNetRandom((BYTE *)&sgar._dwReqNum, sizeof(sgar._dwReqNum));
    sgar._ipaZ    = sin.sin_addr;
    sgar._ipportZ = sin.sin_port;
    
    sin.sin_port = NTOHS(0xFFFF);
    Verify(sendto(s, (char *)&sgar, sizeof(sgar), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(sgar));

    BYTE            ab[CBSGAUTHREPMSG];
    CSgMsgAuthRep * psgap     = (CSgMsgAuthRep *)ab;
    CSgMsgHdr *     psgmh     = (CSgMsgHdr *)(psgap + 1);
    CAuthData *     pAuthData = (CAuthData *)(psgmh + 1);

    slen = sizeof(sin);
    Verify(recvfrom(s, (char *)ab, sizeof(ab), 0, (struct sockaddr *)&sin, &slen) == sizeof(ab));
    Verify(psgap->_wType == SGMSG_TYPE_AUTHDATA_REP);
    Verify(psgap->_cbEnt == sizeof(CSgMsgAuthRep));
    Verify(psgap->_dwReqNum == sgar._dwReqNum);
    Verify(psgap->_ipaZ.s_addr == sgar._ipaZ.s_addr);
    Verify(psgap->_ipaI.s_addr == inet_addr("10.0.0.10"));
    Verify(psgap->_ipportZ == sgar._ipportZ);
    Verify(psgap->_fNotFound == FALSE);
    Verify(psgmh->_wType == SGMSG_TYPE_AUTHDATA);
    Verify(psgmh->_cbEnt == sizeof(CSgMsgHdr) + sizeof(CAuthData));
    Verify(pAuthData->GetCb() == sizeof(CAuthData));

    slen = sizeof(sin);
    Verify(recvfrom(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, &slen) == sizeof(inaVip));
    Verify(inaVip.s_addr == inet_addr("10.0.0.2"));

    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgAlive_2)

TWOTHREADTEST(SgAlive)
{
    printf("Testing SgAlive ");
    TWOTHREADRUN(SgAlive);
    printf("[OK]\n");
}

// Test_SgMsg ----------------------------------------------------------------------------

XNETTEST_BEG(SgMsg_1, "xb1@Internet", "10.0.0.10", "255.0.0.0", "10.0.0.1", 0)
{
    GetXn()->IpLogon(0, NULL, NULL);
    Sleep(200);
    IN_ADDR inaVip, inaSec;
    inaVip.s_addr = inet_addr("10.0.0.2");
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    SOCKET s = SockUdpCreate(0, FALSE);
    Verify(s != SOCKET_ERROR);
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr = inaSec;
    sin.sin_port = NTOHS(3);
    Verify(sendto(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(inaVip));
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgMsg_1)

XNETTEST_BEG(SgMsg_2, "xb2@Datacenter", "10.0.0.6", "255.0.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s = SockUdpCreate(HTONS(123));

    IN_ADDR inaVip;
    sockaddr_in sin;
    int slen = sizeof(sin);
    
    Verify(recvfrom(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, &slen) == sizeof(inaVip));
    Verify(inaVip.s_addr == inet_addr("10.0.0.2"));

    CSgMsgAuthReq   sgar;

    sgar._wType   = SGMSG_TYPE_AUTHDATA_REQ;
    sgar._cbEnt   = sizeof(CSgMsgAuthReq);
    XNetRandom((BYTE *)&sgar._dwReqNum, sizeof(sgar._dwReqNum));
    sgar._ipaZ    = sin.sin_addr;
    sgar._ipportZ = sin.sin_port;
    
    sin.sin_port = NTOHS(0xFFFF);
    Verify(sendto(s, (char *)&sgar, sizeof(sgar), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(sgar));

    BYTE            ab[CBSGAUTHREPMSG];
    CSgMsgAuthRep * psgap     = (CSgMsgAuthRep *)ab;
    CSgMsgHdr *     psgmh     = (CSgMsgHdr *)(psgap + 1);
    CAuthData *     pAuthData = (CAuthData *)(psgmh + 1);

    slen = sizeof(sin);
    Verify(recvfrom(s, (char *)ab, sizeof(ab), 0, (struct sockaddr *)&sin, &slen) == sizeof(ab));
    Verify(psgap->_wType == SGMSG_TYPE_AUTHDATA_REP);
    Verify(psgap->_cbEnt == sizeof(CSgMsgAuthRep));
    Verify(psgap->_dwReqNum == sgar._dwReqNum);
    Verify(psgap->_ipaZ.s_addr == sgar._ipaZ.s_addr);
    Verify(psgap->_ipaI.s_addr == inet_addr("10.0.0.10"));
    Verify(psgap->_ipportZ == sgar._ipportZ);
    Verify(psgap->_fNotFound == FALSE);
    Verify(psgmh->_wType == SGMSG_TYPE_AUTHDATA);
    Verify(psgmh->_cbEnt == sizeof(CSgMsgHdr) + sizeof(CAuthData));
    Verify(pAuthData->GetCb() == sizeof(CAuthData));
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgMsg_2)

TWOTHREADTEST(SgMsg)
{
    printf("Testing SgMsg ");
    TWOTHREADRUN(SgMsg);
    printf("[OK]\n");
}

// Test_SgLogon --------------------------------------------------------------------------

XNETTEST_BEG(SgLogon_1, "xb1@Internet", "10.0.0.10", "255.0.0.0", "10.0.0.1", 0)
{
    IN_ADDR inaVip, inaSec;
    HANDLE hEventLogon = NULL;
    ULONGLONG aqwUserId[4];
    XNKID axnkid[4];
    BYTE abData[32];
    UINT iUser;

    // Let the other thread start up so it doesn't miss our first UDP packet
    Sleep(500);

    XNetRandom((BYTE *)aqwUserId, sizeof(aqwUserId));
    XNetRandom((BYTE *)axnkid, sizeof(axnkid));
    XNetRandom(abData, sizeof(abData));

    inaVip.s_addr = inet_addr("10.0.0.2");
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    Verify((hEventLogon = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);
    GetXn()->IpLogon(inaSec.s_addr, aqwUserId, hEventLogon);
    Verify(WaitForSingleObject(hEventLogon, INFINITE) == WAIT_OBJECT_0);
    Verify(GetXn()->IpLogonGetStatus(NULL) == XN_LOGON_STATE_ONLINE);

    XNADDR xnaddr;
    Verify(XNetGetTitleXnAddr(&xnaddr) != XNET_GET_XNADDR_PENDING);

    SOCKET s = SockUdpCreate(0, FALSE);
    Verify(s != SOCKET_ERROR);
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr = inaSec;
    sin.sin_port = NTOHS(3);
    Verify(sendto(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(inaVip));

    printf(".");

    for (iUser = 0; iUser < 4; ++iUser)
    {
        Verify(GetXn()->IpLogonSetPState(0, ~iUser, &axnkid[0], iUser ? (iUser + 1) * 2 : 0, &abData[iUser * 8]));
        printf(".");
    }

    // Sleep for a while to allow keepalives to flow
    for (int i = 0; i < 5; i++)
    {
        Sleep(4 * 1000);
        printf(".");
    }

    sin.sin_family = AF_INET;
    sin.sin_addr = inaSec;
    sin.sin_port = NTOHS(3);
    Verify(sendto(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(inaVip));
    Verify(closesocket(s) == 0);
    printf(".");

    GetXn()->IpLogoff();
    printf(".");

    CloseHandle(hEventLogon);
}
XNETTEST_END(SgLogon_1)

XNETTEST_BEG(SgLogon_2, "xb2@Datacenter", "10.0.0.6", "255.0.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s = SockUdpCreate(HTONS(123));

    IN_ADDR inaVip;
    sockaddr_in sin;
    int slen = sizeof(sin);
    
    Verify(recvfrom(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, &slen) == sizeof(inaVip));
    Verify(inaVip.s_addr == inet_addr("10.0.0.2"));
    printf(".");

    CSgMsgAuthReq   sgar;

    sgar._wType   = SGMSG_TYPE_AUTHDATA_REQ;
    sgar._cbEnt   = sizeof(CSgMsgAuthReq);
    XNetRandom((BYTE *)&sgar._dwReqNum, sizeof(sgar._dwReqNum));
    sgar._ipaZ    = sin.sin_addr;
    sgar._ipportZ = sin.sin_port;
    
    sin.sin_port = NTOHS(0xFFFF);
    Verify(sendto(s, (char *)&sgar, sizeof(sgar), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(sgar));

    BYTE            ab[CBSGAUTHREPMSG];
    CSgMsgAuthRep * psgap     = (CSgMsgAuthRep *)ab;
    CSgMsgHdr *     psgmh     = (CSgMsgHdr *)(psgap + 1);
    CAuthData *     pAuthData = (CAuthData *)(psgmh + 1);

    slen = sizeof(sin);
    Verify(recvfrom(s, (char *)ab, sizeof(ab), 0, (struct sockaddr *)&sin, &slen) == sizeof(ab));
    Verify(psgap->_wType == SGMSG_TYPE_AUTHDATA_REP);
    Verify(psgap->_cbEnt == sizeof(CSgMsgAuthRep));
    Verify(psgap->_dwReqNum == sgar._dwReqNum);
    Verify(psgap->_ipaZ.s_addr == sgar._ipaZ.s_addr);
    Verify(psgap->_ipaI.s_addr == inet_addr("10.0.0.10"));
    Verify(psgap->_ipportZ == sgar._ipportZ);
    Verify(psgap->_fNotFound == FALSE);
    Verify(psgmh->_wType == SGMSG_TYPE_AUTHDATA);
    Verify(psgmh->_cbEnt == sizeof(CSgMsgHdr) + sizeof(CAuthData));
    Verify(pAuthData->GetCb() == sizeof(CAuthData));

    slen = sizeof(sin);
    Verify(recvfrom(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, &slen) == sizeof(inaVip));
    Verify(inaVip.s_addr == inet_addr("10.0.0.2"));

    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgLogon_2)

TWOTHREADTEST(SgLogon)
{
    printf("Testing SgLogon ");
    TWOTHREADRUN(SgLogon);
    printf(" [OK]\n");
}

// Test_XnSetEventTimer ------------------------------------------------------------------

IPTEST_BEG(XnSetEventTimer, "xb1@Internet", "10.0.0.1", "255.255.0.0", NULL, 0)
{
    printf("Testing XnSetEventTimer ");
    
    CEventTimer et;
    HANDLE hEvent;

    memset(&et, 0, sizeof(et));
    Verify((hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);
    DWORD dwTickBeg = GetTickCount();
    IpSetEventTimer(&et, hEvent, 1000);
    IpSetEventTimer(&et, hEvent, 0xFFFFFFFF);
    CloseHandle(hEvent);
    hEvent = NULL;

    for (DWORD dwTimeout = 50; dwTimeout < 1000; dwTimeout += 160)
    {
        for (int i = 0; i < 5; ++i)
        {
            memset(&et, 0, sizeof(et));
            Verify((hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);
            DWORD dwTickBeg = GetTickCount();
            IpSetEventTimer(&et, hEvent, dwTimeout);
            Verify(WaitForSingleObject(hEvent, INFINITE) == WAIT_OBJECT_0);
            CloseHandle(hEvent);
            hEvent = NULL;
            DWORD dwTickEnd = GetTickCount();
            Verify(dwTickEnd - dwTickBeg > dwTimeout);
            printf(".");
            Sleep(17 * i);
        }
    }

    printf(" [OK]\n");
}
IPTEST_END(XnSetEventTimer);

// Test_NatDhcp --------------------------------------------------------------------------

XNETTEST_BEG(NatDhcp_1, "xb1@Nat1Inner", NULL, NULL, NULL, 0)
{
    XNADDR xnaddr;
    DWORD dw;

    while (1)
    {
        dw = XNetGetTitleXnAddr(&xnaddr);
        if (dw != XNET_GET_XNADDR_PENDING)
            break;
        Sleep(100);
    }

    Verify(dw & XNET_GET_XNADDR_DHCP);
}
XNETTEST_END(NatDhcp_1)

void Test_NatDhcp()
{
    for (UINT iAssign = NAT_ASSIGN_MINIMAL; iAssign <= NAT_ASSIGN_AGGRESSIVE; ++iAssign)
    {
        for (UINT iFilter = NAT_FILTER_NONE; iFilter <= NAT_FILTER_ADDRESS_PORT; ++iFilter)
        {
            printf("Testing NatDhcp %s/%s ", iAssign == NAT_ASSIGN_MINIMAL ? "min" : "agr",
                   iFilter == NAT_FILTER_NONE ? "none" : iFilter == NAT_FILTER_ADDRESS ? "addr" :
                   iFilter == NAT_FILTER_PORT ? "port" : "both");

            NATCREATE natcreate = { 0 };

            strcpy(natcreate._achXboxInner, "Nat@Nat1Inner");
            strcpy(natcreate._achXboxOuter, "Nat@Nat1Outer");

            natcreate._xncpInner.ina.s_addr         = inet_addr("10.0.0.1");
            natcreate._xncpInner.inaMask.s_addr     = inet_addr("255.255.0.0");
            natcreate._xncpOuter.ina.s_addr         = inet_addr("10.0.0.1");
            natcreate._xncpOuter.inaMask.s_addr     = inet_addr("255.255.0.0");
            natcreate._inaBase.s_addr               = inet_addr("10.0.1.0");
            natcreate._inaLast.s_addr               = inet_addr("10.0.254.254");
            natcreate._dwLeaseTime                  = 60 * 60 * 24;
            natcreate._iAssign                      = iAssign;
            natcreate._iFilter                      = iFilter;

            void * pvNat = XNetNatCreate(&natcreate);
            Verify(pvNat != NULL);

            Test_NatDhcp_1();

            XNetNatDelete(pvNat);

            printf("[OK]\n");
        }
    }
}

// Test_NatDns ---------------------------------------------------------------------------

XNETTEST_BEG(NatDns_1, "xb1@Nat1Inner", NULL, NULL, NULL, 0)
{
    XNADDR xnaddr;
    while (XNetGetTitleXnAddr(&xnaddr) == XNET_GET_XNADDR_PENDING)
        Sleep(100);
    Verify((_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);
    
    XNDNS * pxndns = NULL;

    Verify(XNetDnsLookup("nosuchhost.foo.bar.com", _hEvent, &pxndns) == 0);
    Verify(WaitForSingleObject(_hEvent, INFINITE) == WAIT_OBJECT_0);
    Verify(pxndns->iStatus == WSAHOST_NOT_FOUND);
    Verify(pxndns->cina == 0);
    Verify(XNetDnsRelease(pxndns) == 0);

    Verify(XNetDnsLookup("products.redmond.corp.microsoft.com", _hEvent, &pxndns) == 0);
    Verify(WaitForSingleObject(_hEvent, INFINITE) == WAIT_OBJECT_0);
    Verify(pxndns->iStatus == 0);
    Verify(pxndns->cina > 0);
    Verify(XNetDnsRelease(pxndns) == 0);

    Verify(XNetDnsLookup("products.redmond.corp.microsoft.com", NULL, &pxndns) == 0);
    while (pxndns->iStatus == WSAEINPROGRESS)
        Sleep(100);
    Verify(pxndns->iStatus == 0);
    Verify(pxndns->cina > 0);
    Verify(XNetDnsRelease(pxndns) == 0);

    CloseHandle(_hEvent);
}

HANDLE _hEvent;

XNETTEST_END(NatDns_1)

void Test_NatDns()
{
    for (UINT iAssign = NAT_ASSIGN_MINIMAL; iAssign <= NAT_ASSIGN_AGGRESSIVE; ++iAssign)
    {
        for (UINT iFilter = NAT_FILTER_NONE; iFilter <= NAT_FILTER_ADDRESS_PORT; ++iFilter)
        {
            printf("Testing NatDns %s/%s ", iAssign == NAT_ASSIGN_MINIMAL ? "min" : "agr",
                   iFilter == NAT_FILTER_NONE ? "none" : iFilter == NAT_FILTER_ADDRESS ? "addr" :
                   iFilter == NAT_FILTER_PORT ? "port" : "both");

            if (!VLanDriver())
            {
                printf("[No VLan]\n");
                return;
            }

            NATCREATE natcreate = { 0 };

            strcpy(natcreate._achXboxInner, "Nat1@Nat1Inner");
            strcpy(natcreate._achXboxOuter, "Nat1@Nic/0");

            natcreate._xncpInner.ina.s_addr         = inet_addr("10.0.0.1");
            natcreate._xncpInner.inaMask.s_addr     = inet_addr("255.255.0.0");
            natcreate._inaBase.s_addr               = inet_addr("10.0.1.0");
            natcreate._inaLast.s_addr               = inet_addr("10.0.254.254");
            natcreate._dwLeaseTime                  = 60 * 60 * 24;
            natcreate._iAssign                      = iAssign;
            natcreate._iFilter                      = iFilter;

            void * pvNat = XNetNatCreate(&natcreate);
            Verify(pvNat != NULL);

            Test_NatDns_1();

            XNetNatDelete(pvNat);

            printf("[OK]\n");
        }
    }
}

// Test_NatUdp ---------------------------------------------------------------------------

XNETTEST_BEG(NatUdp_1, "xb1@Nat1Inner", NULL, NULL, NULL, XNET_STARTUP_BYPASS_SECURITY)
{
    XNADDR xnaddr;
    while (XNetGetTitleXnAddr(&xnaddr) == XNET_GET_XNADDR_PENDING)
        Sleep(100);

    SOCKET s = SockUdpCreate(CIpPort(NTOHS(6543)));
    SockUdpTransmit(s, inet_addr("192.168.0.2"), CIpPort(NTOHS(1567)));
    Verify(closesocket(s) == 0);
}
XNETTEST_END(NatUdp_1);

XNETTEST_BEG(NatUdp_2, "xb2@Nat1Outer", "192.168.0.2", "255.255.0.0", NULL, XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s = SockUdpCreate(NTOHS(1567));
    SockUdpReflect(s);
    Verify(closesocket(s) == 0);
}
XNETTEST_END(NatUdp_2);

TWOTHREADTEST(NatUdp)
{
    for (UINT iAssign = NAT_ASSIGN_MINIMAL; iAssign <= NAT_ASSIGN_AGGRESSIVE; ++iAssign)
    {
        for (UINT iFilter = NAT_FILTER_NONE; iFilter <= NAT_FILTER_ADDRESS_PORT; ++iFilter)
        {
            printf("Testing NatUdp %s/%s ", iAssign == NAT_ASSIGN_MINIMAL ? "min" : "agr",
                   iFilter == NAT_FILTER_NONE ? "none" : iFilter == NAT_FILTER_ADDRESS ? "addr" :
                   iFilter == NAT_FILTER_PORT ? "port" : "both");

            NATCREATE natcreate = { 0 };

            strcpy(natcreate._achXboxInner, "Nat1@Nat1Inner");
            strcpy(natcreate._achXboxOuter, "Nat1@Nat1Outer");

            natcreate._xncpInner.ina.s_addr         = inet_addr("10.0.0.1");
            natcreate._xncpInner.inaMask.s_addr     = inet_addr("255.255.0.0");
            natcreate._xncpOuter.ina.s_addr         = inet_addr("192.168.0.1");
            natcreate._xncpOuter.inaMask.s_addr     = inet_addr("255.255.0.0");
            natcreate._inaBase.s_addr               = inet_addr("10.0.1.0");
            natcreate._inaLast.s_addr               = inet_addr("10.0.254.254");
            natcreate._dwLeaseTime                  = 60 * 60 * 24;
            natcreate._iAssign                      = iAssign;
            natcreate._iFilter                      = iFilter;

            void * pvNat = XNetNatCreate(&natcreate);
            Verify(pvNat != NULL);

            TWOTHREADRUN(NatUdp);

            XNetNatDelete(pvNat);

            printf(" [OK]\n");
        }
    }
}

// Test_NatTcp ---------------------------------------------------------------------------

XNETTEST_BEG(NatTcp_1, "xb1@Nat1Inner", NULL, NULL, NULL, XNET_STARTUP_BYPASS_SECURITY)
{
    XNADDR xnaddr;
    while (XNetGetTitleXnAddr(&xnaddr) == XNET_GET_XNADDR_PENDING)
        Sleep(100);

    SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    Verify(s != SOCKET_ERROR);
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = inet_addr("192.168.0.2");
    sin.sin_port = HTONS(80);
    Verify(connect(s, (struct sockaddr *)&sin, sizeof(sin)) != SOCKET_ERROR);
    SockTcpTransmit(s);
    Verify(closesocket(s) == 0);
}
XNETTEST_END(NatTcp_1)

XNETTEST_BEG(NatTcp_2, "xb2@Nat1Outer", "192.168.0.2", "255.255.0.0", NULL, XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s1 = SockTcpCreate(HTONS(80));
    Verify(listen(s1, 1) == 0);
    sockaddr_in sin;
    int slen = sizeof(sin);
    SOCKET s2 = accept(s1, (struct sockaddr *)&sin, &slen);
    Verify(s2 != SOCKET_ERROR);
    Verify(slen == sizeof(sin));
    SockTcpReflect(s2);
    Verify(closesocket(s2) == 0);
    Verify(closesocket(s1) == 0);
}
XNETTEST_END(NatTcp_2)

TWOTHREADTEST(NatTcp)
{
    for (UINT iAssign = NAT_ASSIGN_MINIMAL; iAssign <= NAT_ASSIGN_AGGRESSIVE; ++iAssign)
    {
        for (UINT iFilter = NAT_FILTER_NONE; iFilter <= NAT_FILTER_ADDRESS_PORT; ++iFilter)
        {
            printf("Testing NatTcp %s/%s ", iAssign == NAT_ASSIGN_MINIMAL ? "min" : "agr",
                   iFilter == NAT_FILTER_NONE ? "none" : iFilter == NAT_FILTER_ADDRESS ? "addr" :
                   iFilter == NAT_FILTER_PORT ? "port" : "both");

            NATCREATE natcreate = { 0 };

            strcpy(natcreate._achXboxInner, "Nat1@Nat1Inner");
            strcpy(natcreate._achXboxOuter, "Nat1@Nat1Outer");

            natcreate._xncpInner.ina.s_addr         = inet_addr("10.0.0.1");
            natcreate._xncpInner.inaMask.s_addr     = inet_addr("255.255.0.0");
            natcreate._xncpOuter.ina.s_addr         = inet_addr("192.168.0.1");
            natcreate._xncpOuter.inaMask.s_addr     = inet_addr("255.255.0.0");
            natcreate._inaBase.s_addr               = inet_addr("10.0.1.0");
            natcreate._inaLast.s_addr               = inet_addr("10.0.254.254");
            natcreate._dwLeaseTime                  = 60 * 60 * 24;
            natcreate._iAssign                      = iAssign;
            natcreate._iFilter                      = iFilter;

            void * pvNat = XNetNatCreate(&natcreate);
            Verify(pvNat != NULL);

            TWOTHREADRUN(NatTcp);

            XNetNatDelete(pvNat);

            printf(" [OK]\n");
        }
    }
}

// Test_SgNat1Xb1ToNat2Xb2 ---------------------------------------------------------------

XNETTEST_BEG(SgXb1ToXb2_1, "xb1@Internet", "10.0.0.10", "255.0.0.0", "10.0.0.1", 0)
{
    SgTcpXbToXbClient();
}
XNETTEST_END(SgXb1ToXb2_1)

XNETTEST_BEG(SgXb1ToXb2_2, "xb2@Internet", "10.0.0.11", "255.0.0.0", "10.0.0.1", 0)
{
    SgTcpXbToXbServer();
}
XNETTEST_END(SgXb1ToXb2_2)

TWOTHREADTEST(SgXb1ToXb2)
{
    TWOTHREADRUN(SgXb1ToXb2);
}

XNETTEST_BEG(SgXb1ToNat2Xb2_1, "xb1@Internet", "10.0.0.10", "255.0.0.0", "10.0.0.1", 0)
{
    SgTcpXbToXbClient();
}
XNETTEST_END(SgXb1ToNat2Xb2_1)

XNETTEST_BEG(SgXb1ToNat2Xb2_2, "xb2@Nat2Inner", NULL, NULL, NULL, 0)
{
    SgTcpXbToXbServer();
}
XNETTEST_END(SgXb1ToNat2Xb2_2)

TWOTHREADTEST(SgXb1ToNat2Xb2)
{
    TWOTHREADRUN(SgXb1ToNat2Xb2);
}

XNETTEST_BEG(SgNat1Xb1ToXb2_1, "xb1@Nat1Inner", NULL, NULL, NULL, 0)
{
    SgTcpXbToXbClient();
}
XNETTEST_END(SgNat1Xb1ToXb2_1)

XNETTEST_BEG(SgNat1Xb1ToXb2_2, "xb2@Internet", "10.0.0.10", "255.0.0.0", NULL, 0)
{
    SgTcpXbToXbServer();
}
XNETTEST_END(SgNat1Xb1ToXb2_2)

TWOTHREADTEST(SgNat1Xb1ToXb2)
{
    TWOTHREADRUN(SgNat1Xb1ToXb2);
}

XNETTEST_BEG(SgNat1Xb1ToNat2Xb2_1, "xb1@Nat1Inner", NULL, NULL, NULL, 0)
{
    SgTcpXbToXbClient();
}
XNETTEST_END(SgNat1Xb1ToNat2Xb2_1)

XNETTEST_BEG(SgNat1Xb1ToNat2Xb2_2, "xb2@Nat2Inner", NULL, NULL, NULL, 0)
{
    SgTcpXbToXbServer();
}
XNETTEST_END(SgNat1Xb1ToNat2Xb2_2)

TWOTHREADTEST(SgNat1Xb1ToNat2Xb2)
{
    TWOTHREADRUN(SgNat1Xb1ToNat2Xb2);
}

XNETTEST_BEG(SgNat1Xb1ToNat1Xb2_1, "xb1@Nat1Inner", NULL, NULL, NULL, 0)
{
    SgTcpXbToXbClient();
}
XNETTEST_END(SgNat1Xb1ToNat1Xb2_1)

XNETTEST_BEG(SgNat1Xb1ToNat1Xb2_2, "xb2@Nat1Inner", NULL, NULL, NULL, 0)
{
    SgTcpXbToXbServer();
}
XNETTEST_END(SgNat1Xb1ToNat1Xb2_2)

TWOTHREADTEST(SgNat1Xb1ToNat1Xb2)
{
    TWOTHREADRUN(SgNat1Xb1ToNat1Xb2);
}

void Test_SgNat()
{
    printf("Testing SgNat\n\n");
    printf("         Direct Min/-- Min/A- Min/-P Min/AP Agr/-- Agr/A- Agr/-P Agr/AP\n");

    UINT    aiAssign[] = { NAT_ASSIGN_MINIMAL, NAT_ASSIGN_MINIMAL, NAT_ASSIGN_MINIMAL, NAT_ASSIGN_MINIMAL, NAT_ASSIGN_AGGRESSIVE, NAT_ASSIGN_AGGRESSIVE, NAT_ASSIGN_AGGRESSIVE, NAT_ASSIGN_AGGRESSIVE };
    UINT    aiFilter[] = { NAT_FILTER_NONE, NAT_FILTER_ADDRESS, NAT_FILTER_PORT, NAT_FILTER_ADDRESS_PORT, NAT_FILTER_NONE, NAT_FILTER_ADDRESS, NAT_FILTER_PORT, NAT_FILTER_ADDRESS_PORT };
    UINT    iAssign1, iAssign2, iFilter1, iFilter2;
    void *  pvNat1, * pvNat2;
    UINT    i, j;

    printf("  OneNat ");
    TWOTHREADRUN(SgXb1ToXb2);
    printf(g_fXb1ToXb2Timeout ? "[F:%2d] " : "%6d ", g_cSecsXb1ToXb2Connect);

    for (i = 0; i < dimensionof(aiAssign); ++i)
    {
        iAssign1 = aiAssign[i];
        iFilter1 = aiFilter[i];

        NATCREATE natcreate1 = { 0 };

        strcpy(natcreate1._achXboxOuter, "Nat1@Internet");
        natcreate1._xncpOuter.ina.s_addr         = inet_addr("10.0.0.253");
        natcreate1._xncpOuter.inaMask.s_addr     = inet_addr("255.255.0.0");

        strcpy(natcreate1._achXboxInner, "Nat1@Nat1Inner");
        natcreate1._xncpInner.ina.s_addr         = inet_addr("192.168.0.1");
        natcreate1._xncpInner.inaMask.s_addr     = inet_addr("255.255.0.0");
        natcreate1._inaBase.s_addr               = inet_addr("192.168.0.2");
        natcreate1._inaLast.s_addr               = inet_addr("192.168.254.254");

        natcreate1._dwLeaseTime                  = 60 * 60 * 24;
        natcreate1._iAssign                      = iAssign1;
        natcreate1._iFilter                      = iFilter1;

        pvNat1 = XNetNatCreate(&natcreate1);
        Verify(pvNat1 != NULL);
        TWOTHREADRUN(SgNat1Xb1ToNat1Xb2);
        XNetNatDelete(pvNat1);
        printf(g_fXb1ToXb2Timeout ? "[F:%2d] " : "%6d ", g_cSecsXb1ToXb2Connect);
    }

    printf("\n");
    printf("  Direct ");

    TWOTHREADRUN(SgXb1ToXb2);
    printf(g_fXb1ToXb2Timeout ? "[F:%2d] " : "%6d ", g_cSecsXb1ToXb2Connect);

    for (i = 0; i < dimensionof(aiAssign); ++i)
    {
        iAssign2 = aiAssign[i];
        iFilter2 = aiFilter[i];

        NATCREATE natcreate2 = { 0 };

        strcpy(natcreate2._achXboxOuter, "Nat2@Internet");
        natcreate2._xncpOuter.ina.s_addr         = inet_addr("10.0.0.254");
        natcreate2._xncpOuter.inaMask.s_addr     = inet_addr("255.255.0.0");

        strcpy(natcreate2._achXboxInner, "Nat2@Nat2Inner");
        natcreate2._xncpInner.ina.s_addr         = inet_addr("192.168.0.1");
        natcreate2._xncpInner.inaMask.s_addr     = inet_addr("255.255.0.0");
        natcreate2._inaBase.s_addr               = inet_addr("192.168.0.2");
        natcreate2._inaLast.s_addr               = inet_addr("192.168.254.254");

        natcreate2._dwLeaseTime                  = 60 * 60 * 24;
        natcreate2._iAssign                      = iAssign2;
        natcreate2._iFilter                      = iFilter2;
        natcreate2._iNatPortBase                 = 2000;

        pvNat2 = XNetNatCreate(&natcreate2);
        Verify(pvNat2 != NULL);
        TWOTHREADRUN(SgXb1ToNat2Xb2);
        XNetNatDelete(pvNat2);
        printf(g_fXb1ToXb2Timeout ? "[F:%2d] " : "%6d ", g_cSecsXb1ToXb2Connect);
    }

    printf("\n");

    for (i = 0; i < dimensionof(aiAssign); ++i)
    {
        iAssign1 = aiAssign[i];
        iFilter1 = aiFilter[i];

        printf("  %s/%c%c ", iAssign1 == NAT_ASSIGN_MINIMAL ? "Min" : "Agr",
               (iFilter1 & NAT_FILTER_ADDRESS) ? 'A' : '-', (iFilter1 & NAT_FILTER_PORT) ? 'P' : '-');

        NATCREATE natcreate1 = { 0 };

        strcpy(natcreate1._achXboxOuter, "Nat1@Internet");
        natcreate1._xncpOuter.ina.s_addr         = inet_addr("10.0.0.253");
        natcreate1._xncpOuter.inaMask.s_addr     = inet_addr("255.255.0.0");

        strcpy(natcreate1._achXboxInner, "Nat1@Nat1Inner");
        natcreate1._xncpInner.ina.s_addr         = inet_addr("192.168.0.1");
        natcreate1._xncpInner.inaMask.s_addr     = inet_addr("255.255.0.0");
        natcreate1._inaBase.s_addr               = inet_addr("192.168.0.2");
        natcreate1._inaLast.s_addr               = inet_addr("192.168.254.254");

        natcreate1._dwLeaseTime                  = 60 * 60 * 24;
        natcreate1._iAssign                      = iAssign1;
        natcreate1._iFilter                      = iFilter1;

        pvNat1 = XNetNatCreate(&natcreate1);
        Verify(pvNat1 != NULL);
        TWOTHREADRUN(SgNat1Xb1ToXb2);
        XNetNatDelete(pvNat1);
        printf(g_fXb1ToXb2Timeout ? "[F:%2d] " : "%6d ", g_cSecsXb1ToXb2Connect);

        for (j = 0; j < dimensionof(aiAssign); ++j)
        {
            iAssign2 = aiAssign[j];
            iFilter2 = aiFilter[j];

            NATCREATE natcreate1 = { 0 };

            strcpy(natcreate1._achXboxOuter, "Nat1@Internet");
            natcreate1._xncpOuter.ina.s_addr         = inet_addr("10.0.0.253");
            natcreate1._xncpOuter.inaMask.s_addr     = inet_addr("255.255.0.0");

            strcpy(natcreate1._achXboxInner, "Nat1@Nat1Inner");
            natcreate1._xncpInner.ina.s_addr         = inet_addr("192.168.0.1");
            natcreate1._xncpInner.inaMask.s_addr     = inet_addr("255.255.0.0");
            natcreate1._inaBase.s_addr               = inet_addr("192.168.0.2");
            natcreate1._inaLast.s_addr               = inet_addr("192.168.254.254");

            natcreate1._dwLeaseTime                  = 60 * 60 * 24;
            natcreate1._iAssign                      = iAssign1;
            natcreate1._iFilter                      = iFilter1;

            pvNat1 = XNetNatCreate(&natcreate1);
            Verify(pvNat1 != NULL);

            NATCREATE natcreate2 = { 0 };

            strcpy(natcreate2._achXboxOuter, "Nat2@Internet");
            natcreate2._xncpOuter.ina.s_addr         = inet_addr("10.0.0.254");
            natcreate2._xncpOuter.inaMask.s_addr     = inet_addr("255.255.0.0");

            strcpy(natcreate2._achXboxInner, "Nat2@Nat2Inner");
            natcreate2._xncpInner.ina.s_addr         = inet_addr("192.168.0.1");
            natcreate2._xncpInner.inaMask.s_addr     = inet_addr("255.255.0.0");
            natcreate2._inaBase.s_addr               = inet_addr("192.168.0.2");
            natcreate2._inaLast.s_addr               = inet_addr("192.168.254.254");

            natcreate2._dwLeaseTime                  = 60 * 60 * 24;
            natcreate2._iAssign                      = iAssign2;
            natcreate2._iFilter                      = iFilter2;
            natcreate2._iNatPortBase                 = 2000;

            pvNat2 = XNetNatCreate(&natcreate2);
            Verify(pvNat2 != NULL);
            TWOTHREADRUN(SgNat1Xb1ToNat2Xb2);
            XNetNatDelete(pvNat2);
            XNetNatDelete(pvNat1);

            printf(g_fXb1ToXb2Timeout ? "[F:%2d] " : "%6d ", g_cSecsXb1ToXb2Connect);
        }
            
        printf("\n");
    }

    printf("\n");
}

// ---------------------------------------------------------------------------------------
// main
// ---------------------------------------------------------------------------------------

int     g_argc;
char ** g_argv;

BOOL RunTest(char * pszName, ...)
{
    BOOL fByNameOnly = FALSE;

    va_list va;

    va_start(va, pszName);

    while (pszName)
    {
        if (*pszName == '*')
        {
            fByNameOnly = TRUE;
            pszName += 1;
        }
        else
        {
            fByNameOnly = FALSE;
        }

        if (!fByNameOnly && g_argc == 1)
        {
            return(TRUE);
        }

        for (int i = 1; i < g_argc; ++i)
        {
            if (g_argv[i] && lstrcmpiA(g_argv[i], pszName) == 0)
                return(TRUE);
        }

        pszName = va_arg(va, char *);
    }

    return(FALSE);
}

int __cdecl main(int argc, char * argv[])
{
    g_argc = argc;
    g_argv = argv;

    Verify(VLanInit());

    if (RunTest("inet_addr", NULL))                     Test_inet_addr();
    if (RunTest("XNetRandom", NULL))                    Test_XNetRandom();
    if (RunTest("XNetRegisterKey", NULL))               Test_XNetRegisterKey();
    if (RunTest("XNetXnAddrToInAddr", NULL))            Test_XNetXnAddrToInAddr();
    if (RunTest("Broadcast", NULL))                     Test_Broadcast();
    if (RunTest("Discovery", NULL))                     Test_Discovery();
    if (RunTest("Frag", NULL))                          Test_Frag();
    if (RunTest("XnSetEventTimer", NULL))               Test_XnSetEventTimer();
    if (RunTest("SockUdp", NULL))                       Test_SockUdp();
    if (RunTest("SockTcp", NULL))                       Test_SockTcp();
    if (RunTest("Dhcp", NULL))                          Test_Dhcp();
    if (RunTest("Dns", NULL))                           Test_Dns();
    if (RunTest("NatDhcp", "Nat", NULL))                Test_NatDhcp();
    if (RunTest("NatDns", "Nat", NULL))                 Test_NatDns();
    if (RunTest("NatUdp", "Nat", NULL))                 Test_NatUdp();
    if (RunTest("NatTcp", "Nat", NULL))                 Test_NatTcp();
    if (RunTest("*SgAlive", NULL))                      Test_SgAlive();
    if (RunTest("*SgMsg", "*Sg", NULL))                 Test_SgMsg();
    if (RunTest("*SgUdp", "*Sg", NULL))                 Test_SgUdp();
    if (RunTest("*SgTcp", "*Sg", NULL))                 Test_SgTcp();
    if (RunTest("*SgRst", "*Sg", NULL))                 Test_SgRst();
    if (RunTest("*SgNat", "*Sg", NULL))                 Test_SgNat();
    if (RunTest("*SgLogon", "*Sg", NULL))               Test_SgLogon();

    VLanTerm();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\net\test\sg\testsg.cpp ===
// ----------------------------------------------------------------------------
// test.cpp
//
// Copyright (C) Microsoft Corporation
// ----------------------------------------------------------------------------

#include "xnp.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <vlan.h>
#include <sgadmin.h>

// ---------------------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------------------

#define TESTSG_START_EVENT_NAME     "$TESTSG$1$EVENT$START$"
#define TESTSG_TERM_EVENT_NAME      "$TESTSG$1$EVENT$TERM$"

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

ULONG   g_ipInet = inet_addr("10.0.0.2");

char    g_szServerConfiguration[] =
"Service    { Id 0 Name TestSg }\n"
"Server     { Id 1 Ip 10.0.0.4 Port 127 Service TestSg }\n"
"Server     { Id 2 Ip 10.0.0.5 Port  80 Service TestSg }\n"
"Server     { Id 3 Ip 10.0.0.6 Port 123 Service TestSg }\n";

char    g_szVirtualNicConfiguration[] =
"NetworkInterface {\n"
"    Type                Internet        ; Interface is connected to the Internet\n"
"    Ip                  10.0.0.2        ; Static IP address of this interface\n"
"    IpMask              255.255.0.0     ; Subnet mask of this interface\n"
"    IpGateway           10.0.0.1        ; Gateway of this interface\n"
"    VLan                sg1@Nic/0       ; VLan this interface is connected to }\n"
"NetworkInterface { \n"
"    Type                Datacenter      ; Interface is connected to the Internet\n"
"    Ip                  10.0.0.3        ; Static IP address of this interface\n"
"    IpMask              255.255.0.0     ; Subnet mask of this interface\n"
"    IpGateway           10.0.0.1        ; Gateway of this interface\n"
"    IpAdmin             10.0.0.100      ; Admin IP address of this interface\n"
"    VLan                sg2@Nic/1       ; VLan this interface is connected to }\n";

char    g_szVirtualOtherConfiguration[] =
"ClientLimit                     64      ; Maximum simultanous clients\n"
"ClientScanFrequencyInSeconds    5       ; How often each client is checked for inactivity\n"
"ClientProbeFrequencyInSeconds   5       ; Inactivity time before probe is sent to client\n"
"ClientKeyExTimeoutInSeconds     10      ; KeyEx inactivity before client presumed dead\n"
"ClientActivityTimeoutInSeconds  20      ; Normal inactivity before client presumed dead\n"
"IpHdrTos                        0       ; IP header type-of-service\n"
"IpHdrTtl                        64      ; IP header time-to-live\n"
"EspReplayWindow                 1024    ; Number of packets sender can get ahead of receiver\n"
"KerberosApReqDeltaInMinutes     5       ; Allowable time-skew for AP request\n"
"HashTableOverheadInPercent      60      ; Hash table bucket overhead above expected maximum\n"
"ArpRequestRetries               4       ; Number of times to retry ARP request\n"
"ArpRexmitTimeoutInSeconds       2       ; Timeout for ARP request\n"
"ArpPositiveTimeoutInSeconds     10      ; Timeout before good ARP request is verified\n"
"ArpNegativeTimeoutInSeconds     10      ; Timeout before bad ARP request is retried\n"
"PacketPool                      64      ; Initial packet pool size (will grow if needed)\n";


char    g_szVirtualSgFormat[] = "sgvlan.exe -s \"%s %s %s\" -e " TESTSG_START_EVENT_NAME " " TESTSG_TERM_EVENT_NAME;

HANDLE  g_hTermVirtualSg;

// ---------------------------------------------------------------------------------------
// Utilities
// ---------------------------------------------------------------------------------------

#define Verify(x)       do { if (!(x)) DbgBreak(); } while (0)

struct CDiscReq
{
    BYTE    abNonce[8];         // Nonce of the requester
};

struct CDiscRsp : public CDiscReq
{
    XNKID   xnkid;              // The host's key identifier
    XNKEY   xnkey;              // The host's key
    XNADDR  xnaddr;             // The host's address
};

// ---------------------------------------------------------------------------------------
// CTestXnIp
// ---------------------------------------------------------------------------------------

class CTestXnIp : public CXnIp
{

public:
    
    virtual void Startup(char * pszXbox, char * pszIp, char * pszMask, char * pszGateway, DWORD dwFlags)
    {
        XNetParams xnp = { sizeof(XNetStartupParams) };
        xnp.cfgFlags = (BYTE)(XNET_STARTUP_MANUAL_CONFIG|dwFlags);
        XNetInitParams xnip = { &xnp, pszXbox };
        Verify(IpInit(&xnip) == 0);

        XNetConfigParams xncp = { 0 };
        xncp.ina.s_addr = pszIp ? inet_addr(pszIp) : 0;
        xncp.inaMask.s_addr = pszMask ? inet_addr(pszMask) : 0;
        xncp.inaGateway.s_addr = pszGateway ? inet_addr(pszGateway) : 0;
        Verify(IpConfig(&xncp, XNET_CONFIG_NORMAL) == 0);

        IpStart();
    }

    virtual void Init()
    {
        Startup(NULL, NULL, NULL, NULL, 0);
    }

    virtual void Term()
    {
        RaiseToDpc();
        IpTerm();
    }

    void Go(HANDLE hEvent1, HANDLE hEvent2)
    {
        Init();
        if (hEvent1) SetEvent(hEvent1);
        if (hEvent2) WaitForSingleObject(hEvent2, INFINITE);
        Test();
        if (hEvent1) SetEvent(hEvent1);
        if (hEvent2) WaitForSingleObject(hEvent2, INFINITE);
        Term();
    }

    void UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen) {};
    void TcpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbHdrLen, UINT cbLen) {};

    virtual void Test() = 0;
};


// ---------------------------------------------------------------------------------------
// CTestXNet
// ---------------------------------------------------------------------------------------

class CTestXNet : public CXNet
{
public:

    CTestXNet(char * pszXbox = NULL) : CXNet(pszXbox) {}
    
    virtual void Startup(char * pszIp, char * pszMask, char * pszGateway, DWORD dwFlags)
    {
        XNetStartupParams xnp = { sizeof(XNetStartupParams) };
        xnp.cfgFlags = (BYTE)(XNET_STARTUP_MANUAL_CONFIG|dwFlags);
        Verify(XNetStartup(&xnp) == 0);

        XNetConfigParams xncp = { 0 };
        xncp.ina.s_addr = pszIp ? inet_addr(pszIp) : 0;
        xncp.inaMask.s_addr = pszMask ? inet_addr(pszMask) : 0;
        xncp.inaGateway.s_addr = pszGateway ? inet_addr(pszGateway) : 0;
        Verify(XNetConfig(&xncp, XNET_CONFIG_NORMAL) == 0);

        WSADATA WSAData;
        Verify(WSAStartup(0x0200, &WSAData) == 0);
    }

    virtual void Init()
    {
        Startup(NULL, NULL, NULL, 0);
    }

    virtual void Term()
    {
        WSACleanup();
        XNetCleanup();
    }

    void Go(HANDLE hEvent1, HANDLE hEvent2)
    {
        Init();
        if (hEvent1) SetEvent(hEvent1);
        if (hEvent2) WaitForSingleObject(hEvent2, INFINITE);
        Test();
        if (hEvent1) SetEvent(hEvent1);
        if (hEvent2) WaitForSingleObject(hEvent2, INFINITE);
        Term();
    }

    virtual void Test() = 0;

    SOCKET  SockUdpCreate(CIpPort ipport = 0, BOOL fBroadcast = FALSE);
    void    SockUdpTransmit(SOCKET s, CIpAddr ipaDst, CIpPort ipport);
    void    SockUdpReflect(SOCKET s);
    SOCKET  SockTcpCreate(CIpPort ipport = 0);
    void    SockTcpTransmit(SOCKET s);
    void    SockTcpReflect(SOCKET s);
    void    DiscoveryHost(UINT cClient, XNKID * pxnkid);
    void    DiscoveryClient(XNKID * pxnkid, CIpAddr * pipa);

};

SOCKET CTestXNet::SockUdpCreate(CIpPort ipport, BOOL fBroadcast)
{
    SOCKET s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    Verify(s != SOCKET_ERROR);

    if (ipport)
    {
        sockaddr_in sin;
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = 0;
        sin.sin_port = ipport;
        Verify(bind(s, (struct sockaddr *)&sin, sizeof(sin)) == 0);
    }

    if (fBroadcast)
    {
        char cBroadcast = 1;
        Verify(setsockopt(s, SOL_SOCKET, SO_BROADCAST, &cBroadcast, 1) == 0);
    }

    return(s);
}

void CTestXNet::SockUdpTransmit(SOCKET s, CIpAddr ipaDst, CIpPort ipport)
{
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = ipaDst;
    sin.sin_port = ipport;
    
    BYTE abXmit[1500], abRecv[1500];

    int cb;

    for (cb = 1; cb < UDP_MAXIMUM_MSS; ++cb)
    {
        XNetRandom(abXmit, cb);
        Verify(sendto(s, (char *)abXmit, cb, 0, (struct sockaddr *)&sin, sizeof(sin)) == cb);
        Verify(recv(s, (char *)abRecv, sizeof(abRecv), 0) == cb);
        Verify(memcmp(abXmit, abRecv, cb) == 0);
        if ((cb % 200) == 0) printf(".");
    }

    for (; cb > 0; --cb)
    {
        XNetRandom(abXmit, cb);
        Verify(sendto(s, (char *)abXmit, cb, 0, (struct sockaddr *)&sin, sizeof(sin)) == cb);
        Verify(recv(s, (char *)abRecv, sizeof(abRecv), 0) == cb);
        Verify(memcmp(abXmit, abRecv, cb) == 0);
        if ((cb % 200) == 0) printf(".");
    }

    Verify(sendto(s, (char *)abXmit, 0, 0, (struct sockaddr *)&sin, sizeof(sin)) == 0);
    Verify(recv(s, (char *)abRecv, sizeof(abRecv), 0) == 0);
}

void CTestXNet::SockUdpReflect(SOCKET s)
{
    BYTE abRecv[1500];

    sockaddr_in sin;
    int cb;

    while (1)
    {
        int slen = sizeof(sin);
        cb = recvfrom(s, (char *)abRecv, sizeof(abRecv), 0, (struct sockaddr *)&sin, &slen);
        Verify(cb != SOCKET_ERROR);
        Verify(sendto(s, (char *)abRecv, cb, 0, (struct sockaddr *)&sin, sizeof(sin)) == cb);
        if (cb == 0)
            break;
    }
}

SOCKET CTestXNet::SockTcpCreate(CIpPort ipport)
{
    SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    Verify(s != SOCKET_ERROR);

    if (ipport)
    {
        sockaddr_in sin;
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = 0;
        sin.sin_port = ipport;
        Verify(bind(s, (struct sockaddr *)&sin, sizeof(sin)) == 0);
    }

    return(s);
}

void CTestXNet::SockTcpTransmit(SOCKET s)
{
    BYTE abXmit[1500], abRecv[1500];

    int cb;

    for (cb = 1; cb < TCP_MAXIMUM_MSS; ++cb)
    {
        XNetRandom(abXmit, cb);
        Verify(send(s, (char *)abXmit, cb, 0) == cb);
        Verify(recv(s, (char *)abRecv, sizeof(abRecv), 0) == cb);
        Verify(memcmp(abXmit, abRecv, cb) == 0);
        if ((cb % 200) == 0) printf(".");
    }

    for (; cb > 0; --cb)
    {
        XNetRandom(abXmit, cb);
        Verify(send(s, (char *)abXmit, cb, 0) == cb);
        Verify(recv(s, (char *)abRecv, sizeof(abRecv), 0) == cb);
        Verify(memcmp(abXmit, abRecv, cb) == 0);
        if ((cb % 200) == 0) printf(".");
    }

    Verify(shutdown(s, SD_SEND) != SOCKET_ERROR);
}

void CTestXNet::SockTcpReflect(SOCKET s)
{
    BYTE abRecv[1500];
    int cb;

    while (1)
    {
        cb = recv(s, (char *)abRecv, sizeof(abRecv), 0);
        Verify(cb != SOCKET_ERROR);

        if (cb == 0)
        {
            Verify(shutdown(s, SD_SEND) != SOCKET_ERROR);
            break;
        }

        Verify(send(s, (char *)abRecv, cb, 0) == cb);
    }
}

void CTestXNet::DiscoveryHost(UINT cClient, XNKID * pxnkid)
{
    SOCKET s = SockUdpCreate(NTOHS(1234), TRUE);

    CDiscReq dreq;
    CDiscRsp drsp;
    UINT iClient = 0;
    sockaddr_in sin;
    BYTE * pbNonce = (BYTE *)LocalAlloc(LPTR, sizeof(dreq.abNonce) * cClient);
    Verify(pbNonce != NULL);
    XNADDR xnaddr;
    XNKID xnkid;
    XNKEY xnkey;

    Verify(XNetCreateKey(&drsp.xnkid, &drsp.xnkey) == 0);
    Verify(XNetRegisterKey(&drsp.xnkid, &drsp.xnkey) == 0);
    Verify(XNetGetTitleXnAddr(&drsp.xnaddr) != 0);

    XNetRandom(drsp.abNonce, sizeof(drsp.abNonce));

    while (iClient < cClient)
    {
        Verify(recv(s, (char *)&dreq, sizeof(dreq), 0) == sizeof(dreq));

        for (UINT i = 0; i < iClient; ++i)
        {
            if (memcmp(&pbNonce[i * sizeof(dreq.abNonce)], dreq.abNonce, sizeof(dreq.abNonce)) == 0)
                break;
        }

        if (i == iClient)
        {
            memcpy(&pbNonce[i * sizeof(dreq.abNonce)], dreq.abNonce, sizeof(dreq.abNonce));
            iClient += 1;
        }

        memcpy(drsp.abNonce, dreq.abNonce, sizeof(dreq.abNonce));
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = INADDR_BROADCAST;
        sin.sin_port = NTOHS(1234);
        Verify(sendto(s, (char *)&drsp, sizeof(drsp), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(drsp));
    }

    Verify(closesocket(s) == 0);
    LocalFree(pbNonce);
    *pxnkid = drsp.xnkid;
}

void CTestXNet::DiscoveryClient(XNKID * pxnkid, CIpAddr * pipa)
{
    SOCKET s = SockUdpCreate(NTOHS(1234));

    char cBroadcast = 1;
    sockaddr_in sin;
    CDiscReq dreq;
    CDiscRsp drsp;

    XNetRandom(dreq.abNonce, sizeof(dreq.abNonce));

    Verify(setsockopt(s, SOL_SOCKET, SO_BROADCAST, &cBroadcast, 1) == 0);

    while (1)
    {
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = INADDR_BROADCAST;
        sin.sin_port = NTOHS(1234);
        Verify(sendto(s, (char *)&dreq, sizeof(dreq), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(dreq));

        fd_set  fds;
        TIMEVAL tv;
        FD_ZERO(&fds);
        FD_SET(s, &fds);
        tv.tv_sec  = 0;
        tv.tv_usec = 200000;

        INT iResult = select(0, &fds, NULL, NULL, &tv);
        Verify(iResult != SOCKET_ERROR);

        while (1)
        {
            ULONG ul = 0;
            iResult = ioctlsocket(s, FIONREAD, &ul);
            Verify(iResult != SOCKET_ERROR);

            if (ul == 0)
                break;

            Verify(recv(s, (char *)&drsp, sizeof(drsp), 0) == sizeof(drsp));
            if (memcmp(drsp.abNonce, dreq.abNonce, sizeof(drsp.abNonce)) == 0)
                goto done;
        }
    }

done:

    Verify(XNetRegisterKey(&drsp.xnkid, &drsp.xnkey) == 0);
    Verify(XNetXnAddrToInAddr(&drsp.xnaddr, &drsp.xnkid, (IN_ADDR *)pipa) == 0);
    Verify(closesocket(s) == 0);
    *pxnkid = drsp.xnkid;
}

#define XNETTEST_BEG(_name, pszXbox, pszIp, pszMask, pszGateway, dwFlags) \
    class CTest##_name : public CTestXNet { public: \
    CTest##_name() : CTestXNet(pszXbox) {}; \
    virtual void Init() { Startup(pszIp, pszMask, pszGateway, dwFlags); } \
    virtual void Test()
#define XNETTEST_END(_name) \
    }; void Test_##_name(HANDLE hEvent1 = 0, HANDLE hEvent2 = 0) { CTest##_name * p = new CTest##_name; p->Go(hEvent1, hEvent2); delete p; }

// ---------------------------------------------------------------------------------------
// TWOTHREADTEST
// ---------------------------------------------------------------------------------------

typedef void (*PFNTEST)(HANDLE hEvent1, HANDLE hEvent2);

typedef struct {
    HANDLE      hThread;
    HANDLE      hEvent1;
    HANDLE      hEvent2;
    PFNTEST     pfn;
} TWOTHREADPARAM;

DWORD WINAPI TwoThreadProc(void * pv)
{
    TWOTHREADPARAM * p = (TWOTHREADPARAM *)pv;
    p->pfn(p->hEvent1, p->hEvent2);
    return(0);
}

#define TWOTHREADTEST(_name) \
    void Test_##_name##_run() \
    { \
        HANDLE  hThread1 = NULL, hEvent1 = NULL, hThread2 = NULL, hEvent2 = NULL; \
        TWOTHREADPARAM p1, p2; \
        Verify((p1.hEvent1 = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL); \
        Verify((p1.hEvent2 = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL); \
        p1.pfn = &Test_##_name##_1; \
        p2.hEvent1 = p1.hEvent2; \
        p2.hEvent2 = p1.hEvent1; \
        p2.pfn = &Test_##_name##_2; \
        Verify((p1.hThread = CreateThread(NULL, 0, TwoThreadProc, &p1, 0, NULL)) != NULL); \
        Verify((p2.hThread = CreateThread(NULL, 0, TwoThreadProc, &p2, 0, NULL)) != NULL); \
        WaitForSingleObject(p1.hThread, INFINITE); \
        WaitForSingleObject(p2.hThread, INFINITE); \
        CloseHandle(p1.hEvent1); CloseHandle(p2.hEvent1); \
        CloseHandle(p1.hThread); CloseHandle(p2.hThread); \
    } \
    void Test_##_name() \

#define TWOTHREADRUN(_name) Test_##_name##_run()


// Test_SgUdpCrypt -----------------------------------------------------------------------

//XNETTEST_BEG(SgUdpCrypt_1, NULL, NULL, NULL, "Nic/0:FEFFDEADF00D", 0)
XNETTEST_BEG(SgUdpCrypt_1, "xbsg10@Nic/0", "10.0.0.10", "255.255.0.0", "10.0.0.1", 0)
{
    Sleep(200);
    IN_ADDR inaVip, inaSec;
    inaVip.s_addr = g_ipInet;
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    SOCKET s = SockUdpCreate(0, FALSE);
    Verify(s != SOCKET_ERROR);
    SockUdpTransmit(s, inaSec.s_addr, CIpPort(NTOHS(1)));
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgUdpCrypt_1)

XNETTEST_BEG(SgUdpCrypt_2, "xbsg4@Nic/1", "10.0.0.4", "255.255.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s = SockUdpCreate(HTONS(127));
    SockUdpReflect(s);
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgUdpCrypt_2)

TWOTHREADTEST(SgUdpCrypt)
{
    printf("Testing SgUdpCrypt ");
    TWOTHREADRUN(SgUdpCrypt);
    printf(" [OK]\n");
}

// Test_SgUdpAuth -----------------------------------------------------------------------

//XNETTEST_BEG(SgUdpAuth_1, NULL, NULL, NULL, "Nic/0:FEFFDEADF00D", XNET_STARTUP_BYPASS_ENCRYPTION)
XNETTEST_BEG(SgUdpAuth_1, "xbsg10@Nic/0", "10.0.0.10", "255.255.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_ENCRYPTION)
{
    Sleep(200);
    IN_ADDR inaVip, inaSec;
    inaVip.s_addr = g_ipInet;
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    SOCKET s = SockUdpCreate(0, FALSE);
    Verify(s != SOCKET_ERROR);
    SockUdpTransmit(s, inaSec.s_addr, CIpPort(NTOHS(1)));
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgUdpAuth_1)

XNETTEST_BEG(SgUdpAuth_2, "xbsg4@Nic/1", "10.0.0.4", "255.255.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s = SockUdpCreate(HTONS(127));
    SockUdpReflect(s);
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgUdpAuth_2)

TWOTHREADTEST(SgUdpAuth)
{
    printf("Testing SgUdpAuth  ");
    TWOTHREADRUN(SgUdpAuth);
    printf(" [OK]\n");
}

// Test_SgTcpCrypt -----------------------------------------------------------------------

//XNETTEST_BEG(SgTcpCrypt_1, NULL, NULL, NULL, "Nic/0:FEFFDEADF00D", 0)
XNETTEST_BEG(SgTcpCrypt_1, "xbsg11@Nic/0", "10.0.0.11", "255.255.0.0", "10.0.0.1", 0)
{
    Sleep(200);
    IN_ADDR inaVip, inaSec;
    inaVip.s_addr = g_ipInet;
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    Verify(s != SOCKET_ERROR);
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr = inaSec;
    sin.sin_port = HTONS(2);
    Verify(connect(s, (struct sockaddr *)&sin, sizeof(sin)) != SOCKET_ERROR);
    SockTcpTransmit(s);
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgTcpCrypt_1)

XNETTEST_BEG(SgTcpCrypt_2, "xbsg5@Nic/1", "10.0.0.5", "255.255.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s1 = SockTcpCreate(HTONS(80));
    Verify(listen(s1, 1) == 0);
    sockaddr_in sin;
    int slen = sizeof(sin);
    SOCKET s2 = accept(s1, (struct sockaddr *)&sin, &slen);
    Verify(s2 != SOCKET_ERROR);
    Verify(slen == sizeof(sin));
    SockTcpReflect(s2);
    Verify(closesocket(s2) == 0);
    Verify(closesocket(s1) == 0);
}
XNETTEST_END(SgTcpCrypt_2)

TWOTHREADTEST(SgTcpCrypt)
{
    printf("Testing SgTcpCrypt ");
    TWOTHREADRUN(SgTcpCrypt);
    printf(" [OK]\n");
}

// Test_SgTcpAuth -----------------------------------------------------------------------

//XNETTEST_BEG(SgTcpAuth_1, NULL, NULL, NULL, "Nic/0:FEFFDEADF00D", XNET_STARTUP_BYPASS_ENCRYPTION)
XNETTEST_BEG(SgTcpAuth_1, "xbsg11@Nic/0", "10.0.0.11", "255.255.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_ENCRYPTION)
{
    Sleep(200);
    IN_ADDR inaVip, inaSec;
    inaVip.s_addr = g_ipInet;
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    Verify(s != SOCKET_ERROR);
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr = inaSec;
    sin.sin_port = HTONS(2);
    Verify(connect(s, (struct sockaddr *)&sin, sizeof(sin)) != SOCKET_ERROR);
    SockTcpTransmit(s);
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgTcpAuth_1)

XNETTEST_BEG(SgTcpAuth_2, "xbsg5@Nic/1", "10.0.0.5", "255.255.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s1 = SockTcpCreate(HTONS(80));
    Verify(listen(s1, 1) == 0);
    sockaddr_in sin;
    int slen = sizeof(sin);
    SOCKET s2 = accept(s1, (struct sockaddr *)&sin, &slen);
    Verify(s2 != SOCKET_ERROR);
    Verify(slen == sizeof(sin));
    SockTcpReflect(s2);
    Verify(closesocket(s2) == 0);
    Verify(closesocket(s1) == 0);
}
XNETTEST_END(SgTcpAuth_2)

TWOTHREADTEST(SgTcpAuth)
{
    printf("Testing SgTcpAuth  ");
    TWOTHREADRUN(SgTcpAuth);
    printf(" [OK]\n");
}

// Test_SgMsg ----------------------------------------------------------------------------

//XNETTEST_BEG(SgMsg_1, NULL, NULL, NULL, "Nic/0:FEFFDEADF00D", 0)
XNETTEST_BEG(SgMsg_1, "xbsg10@Nic/0", "10.0.0.10", "255.255.0.0", "10.0.0.1", 0)
{
    Sleep(200);
    IN_ADDR inaVip, inaSec;
    inaVip.s_addr = g_ipInet;
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    printf("1");
    SOCKET s = SockUdpCreate(0, FALSE);
    Verify(s != SOCKET_ERROR);
    printf("1");
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr = inaSec;
    sin.sin_port = NTOHS(3);
    Verify(sendto(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(inaVip));
    printf("1");
    Verify(closesocket(s) == 0);
    printf("1");
}
XNETTEST_END(SgMsg_1)

XNETTEST_BEG(SgMsg_2, "xbsg6@Nic/1", "10.0.0.6", "255.255.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s = SockUdpCreate(HTONS(123));

    IN_ADDR inaVip;
    sockaddr_in sin;
    int slen = sizeof(sin);
    
    Verify(recvfrom(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, &slen) == sizeof(inaVip));
    printf("2");
    inaVip.s_addr = g_ipInet;

    CSgMsgAuthReq   sgar;

    sgar._wType   = SGMSG_TYPE_AUTHDATA_REQ;
    sgar._cbEnt   = sizeof(CSgMsgAuthReq);
    XNetRandom((BYTE *)&sgar._dwReqNum, sizeof(sgar._dwReqNum));
    sgar._ipaZ    = sin.sin_addr;
    sgar._ipportZ = sin.sin_port;
    
    sin.sin_port = NTOHS(0xFFFF);
    Verify(sendto(s, (char *)&sgar, sizeof(sgar), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(sgar));
    printf("2");

    BYTE            ab[CBSGAUTHREPMSG];
    CSgMsgAuthRep * psgap     = (CSgMsgAuthRep *)ab;
    CSgMsgHdr *     psgmh     = (CSgMsgHdr *)(psgap + 1);
    CAuthData *     pAuthData = (CAuthData *)(psgmh + 1);

    slen = sizeof(sin);
    Verify(recvfrom(s, (char *)ab, sizeof(ab), 0, (struct sockaddr *)&sin, &slen) == sizeof(ab));
    printf("2");
    Verify(psgap->_wType == SGMSG_TYPE_AUTHDATA_REP);
    Verify(psgap->_cbEnt == sizeof(CSgMsgAuthRep));
    Verify(psgap->_dwReqNum == sgar._dwReqNum);
    Verify(psgap->_ipaZ.s_addr == sgar._ipaZ.s_addr);
    Verify(psgap->_ipportZ == sgar._ipportZ);
    Verify(psgap->_fNotFound == FALSE);
    Verify(psgap->_bReserved == 0);
//    Verify(psgap->_ipaI.s_addr == inet_addr("10.0.0.10"));
    Verify(psgmh->_wType == SGMSG_TYPE_AUTHDATA);
    Verify(psgmh->_cbEnt == sizeof(CSgMsgHdr) + sizeof(CAuthData));
    Verify(pAuthData->GetCb() == sizeof(CAuthData));

    Verify(closesocket(s) == 0);
    printf("2");
}
XNETTEST_END(SgMsg_2)

TWOTHREADTEST(SgMsg)
{
    printf("Testing SgMsg ");
    TWOTHREADRUN(SgMsg);
    printf("[OK]\n");
}


// ---------------------------------------------------------------------------------------
// main
// ---------------------------------------------------------------------------------------

int     g_argc;
char ** g_argv;

BOOL RunTest(char * pszName, ...)
{
    BOOL fByNameOnly = FALSE;

    va_list va;

    va_start(va, pszName);

    while (pszName)
    {
        if (*pszName == '*')
        {
            fByNameOnly = TRUE;
            pszName += 1;
        }
        else
        {
            fByNameOnly = FALSE;
        }

        if (!fByNameOnly && g_argc == 0)
        {
            return(TRUE);
        }

        for (int i = 0; i < g_argc; ++i)
        {
            if (g_argv[i] && lstrcmpiA(g_argv[i], pszName) == 0)
                return(TRUE);
        }

        pszName = va_arg(va, char *);
    }

    return(FALSE);
}

BOOL RunVirtualSg()
{
    BOOL fReturn;
    STARTUPINFOA StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    char szCmdLine[sizeof(g_szVirtualSgFormat)
                   + sizeof(g_szVirtualNicConfiguration) 
                   + sizeof(g_szServerConfiguration) 
                   + sizeof(g_szVirtualOtherConfiguration)];

    HANDLE hStart       = CreateEventA(NULL, FALSE, FALSE, TESTSG_START_EVENT_NAME);
    g_hTermVirtualSg    = CreateEventA(NULL, FALSE, FALSE, TESTSG_TERM_EVENT_NAME);

    memset(&StartupInfo, 0, sizeof(StartupInfo));
    sprintf(szCmdLine, g_szVirtualSgFormat, g_szVirtualNicConfiguration, g_szServerConfiguration, g_szVirtualOtherConfiguration);

    fReturn = CreateProcessA(NULL,
                             szCmdLine,
                             NULL,                  // lpProcessAttributes
                             NULL,                  // lpThreadAttributes
                             FALSE,                 // bInheritHandles
                             CREATE_NEW_CONSOLE,    // dwCreationFlags
                             NULL,                  // lpEnvironment
                             NULL,                  // lpCurrentDirectory
                             &StartupInfo,
                             &ProcessInfo);
                             

    if (!fReturn)
    {
        printf("Error %d executing sgvlan.exe\n", GetLastError());
    }
    else
    {
        printf("Waiting for sgvlan to start... ");

        HANDLE ah[2];
        DWORD i;

        ah[0] = hStart;
        ah[1] = ProcessInfo.hProcess;

        i = WaitForMultipleObjects(2, ah, FALSE, INFINITE);

        if (i == WAIT_OBJECT_0)
        {
            printf("[OK]\n");
        }
        else
        {
            printf("[FAIL]\n");
        }

        CloseHandle(hStart);
        CloseHandle(ProcessInfo.hProcess);
        CloseHandle(ProcessInfo.hThread);
    }

    return fReturn;                             
}

void Usage()
{
    printf("Usage:\n"
           "    testsg client <sg-ip-inet> [testlist]\n"
           "    testsg server\n"
           "    testsg virtual\n"
           "\n");
}

void Run()
{
    Verify(VLanInit());

    if (RunTest("SgMsg", "Sg", NULL))                   Test_SgMsg();
    if (RunTest("SgUdpCrypt", "SgUdp", "Sg", NULL))     Test_SgUdpCrypt();
    if (RunTest("SgUdpAuth", "SgUdp", "Sg", NULL))      Test_SgUdpAuth();
    if (RunTest("SgTcpCrypt", "SgTcp", "Sg", NULL))     Test_SgTcpCrypt();
    if (RunTest("SgTcpAuth", "SgTcp", "Sg", NULL))      Test_SgTcpAuth();
    
    VLanTerm();
}

int __cdecl main(int argc, char * argv[])
{
    if (argc < 2)
    {
        Usage();
        return(0);
    }

    g_argc = argc - 2;
    g_argv = argv + 2;

    if (lstrcmpiA(argv[1], "client") == 0)
    {
        if (argc < 3 || inet_addr(argv[2]) == INADDR_NONE)
        {
            printf("Error, testsg client requires an IP address\n\n");
            Usage();
            return(0);
        }

        g_argc--;
        g_argv++;

        g_ipInet = inet_addr(argv[2]);
        Run();
    }
    else if (lstrcmpiA(argv[1], "server") == 0)
    {
        Verify(NT_SUCCESS(SgConfigure(g_szServerConfiguration)));
    }
    else if (lstrcmpiA(argv[1], "virtual") == 0)
    {
        if (!RunVirtualSg())
        {
            return(0);
        }

        Run();

        SetEvent(g_hTermVirtualSg);
        CloseHandle(g_hTermVirtualSg);
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\obx\obdir.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    obdir.c

Abstract:

    This module implements routines to manage directory objects.

--*/

#include "obp.h"

//
// Object type information for directories.
//
DECLSPEC_RDATA OBJECT_TYPE ObDirectoryObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    NULL,
    NULL,
    NULL,
    &ObpDefaultObject,
    'eriD'
};

//
// Array lookup of the DOS drive letters for the DOS devices directory object.
//
PVOID ObpDosDevicesDriveLetterMap['Z' - 'A' + 1];

NTSTATUS
NtCreateDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
/*++

Routine Description:

    This routine creates a directory object with the supplied attributes.

Arguments:

    DirectoryHandle - Supplies the location to receive the created handle.

    ObjectAttributes - Supplies the name and parent directory of the new object.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    POBJECT_DIRECTORY Directory;

    //
    // Create the directory object.
    //

    status = ObCreateObject(&ObDirectoryObjectType, ObjectAttributes,
        sizeof(OBJECT_DIRECTORY), (PVOID*)&Directory);

    if (NT_SUCCESS(status)) {

        RtlZeroMemory(Directory, sizeof(OBJECT_DIRECTORY));

        status = ObInsertObject(Directory, ObjectAttributes, 0, DirectoryHandle);
    }

    return status;
}

NTSTATUS
NtOpenDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
/*++

Routine Description:

    This routine opens an existing directory object with the supplied
    attributes.

Arguments:

    DirectoryHandle - Supplies the location to receive the opened handle.

    ObjectAttributes - Supplies the name and parent directory of the desired
        object.

Return Value:

    Status of operation.

--*/
{
    return ObOpenObjectByName(ObjectAttributes, &ObDirectoryObjectType, NULL,
        DirectoryHandle);
}

NTSTATUS
NtQueryDirectoryObject(
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN RestartScan,
    IN OUT PULONG Context,
    OUT PULONG ReturnedLength OPTIONAL
    )
/*++

Routine Description:

    This routine returns the next directory entry from the supplied object
    directory.

Arguments:

    DirectoryHandle - Supplies the handle of the object directory.

    Buffer - Supplies the buffer to receive the information.

    Length - Supplies the length of the above buffer.

    RestartScan - Supplies whether or not the scan should restart.

    Context - Supplies data that controls the current position of the
        enumeration.

    ReturnedLength - Supplies the location to receive the number of bytes copied
        to the buffer or the number of bytes required if the buffer is too
        small.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    POBJECT_DIRECTORY_INFORMATION DirectoryInformation;
    POBJECT_DIRECTORY Directory;
    ULONG BytesRequired;
    ULONG DesiredIndex;
    ULONG CurrentIndex;
    KIRQL OldIrql;
    ULONG HashBucket;
    POBJECT_HEADER_NAME_INFO ObjectHeaderNameInfo;
    ULONG NameBytesToCopy;
    POSTR ReturnedObjectName;

    //
    // Verify that we have enough space to write out at least the header.
    //

    DirectoryInformation = (POBJECT_DIRECTORY_INFORMATION)Buffer;

    if (Length < sizeof(OBJECT_DIRECTORY_INFORMATION)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Reference the directory object.
    //

    status = ObReferenceObjectByHandle(DirectoryHandle, &ObDirectoryObjectType,
        (PVOID*)&Directory);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Assume that we won't find any more entries.
    //

    status = STATUS_NO_MORE_ENTRIES;
    BytesRequired = 0;

    //
    // Figure out which entry we want to find.
    //

    DesiredIndex = RestartScan ? 0 : *Context;
    CurrentIndex = 0;

    //
    // Loop over all of the hash buckets until we find our desired index.
    //

    ObpAcquireObjectManagerLock(&OldIrql);

    for (HashBucket = 0; HashBucket < OB_NUMBER_HASH_BUCKETS; HashBucket++) {

        ObjectHeaderNameInfo = Directory->HashBuckets[HashBucket];

        while (ObjectHeaderNameInfo != NULL) {

            if (CurrentIndex == DesiredIndex) {

                //
                // Compute the number of bytes required to copy the string and
                // the number of bytes that we can actually copy.
                //

                NameBytesToCopy = ObjectHeaderNameInfo->Name.Length;
                BytesRequired = sizeof(OBJECT_DIRECTORY_INFORMATION) +
                    NameBytesToCopy;

                if (BytesRequired <= Length) {
                    status = STATUS_SUCCESS;
                } else {
                    NameBytesToCopy = Length - sizeof(OBJECT_DIRECTORY_INFORMATION);
                    status = STATUS_BUFFER_TOO_SMALL;
                }

                ReturnedObjectName = (POCHAR)(DirectoryInformation + 1);

                DirectoryInformation->Type =
                    OBJECT_HEADER_NAME_INFO_TO_OBJECT_HEADER(ObjectHeaderNameInfo)->Type->PoolTag;
                DirectoryInformation->Name.Buffer = ReturnedObjectName;
                DirectoryInformation->Name.Length =
                    ObjectHeaderNameInfo->Name.Length;
                DirectoryInformation->Name.MaximumLength =
                    ObjectHeaderNameInfo->Name.Length;

                RtlCopyMemory(ReturnedObjectName,
                    ObjectHeaderNameInfo->Name.Buffer, NameBytesToCopy);

                //
                // Bump up the index number for the next iteration.
                //

                *Context = DesiredIndex + 1;

                goto FoundDesiredIndex;
            }

            ObjectHeaderNameInfo = ObjectHeaderNameInfo->ChainLink;
            CurrentIndex++;
        }
    }

FoundDesiredIndex:
    ObpReleaseObjectManagerLock(OldIrql);

    //
    // Dereference the object and return the number of bytes that we copied or
    // that are required.
    //

    ObDereferenceObject(Directory);

    if (ReturnedLength != NULL) {
        *ReturnedLength = BytesRequired;
    }

    return status;
}

ULONG
FASTCALL
ObpComputeHashIndex(
    IN POBJECT_STRING ElementName
    )
/*++

Routine Description:

    This routine computes the hash index for the supplied name.

Arguments:

    ElementName - Supplies the name to compute the hash value for.

Return Value:

    The hash index.

--*/
{
    ULONG HashIndex;
    PUCHAR Buffer;
    PUCHAR BufferEnd;
    UCHAR Char;

    HashIndex = 0;
    Buffer = (PUCHAR)ElementName->Buffer;
    BufferEnd = Buffer + ElementName->Length;

    while (Buffer < BufferEnd) {

        Char = *Buffer++;

        //
        // Don't allow extended characters to change the hash value since we're
        // going to be doing case insensitive comparisions.
        //

        if (Char >= 0x80) {
            continue;
        }

        //
        // Force any upper case characters to be lower case.
        //

        Char |= 0x20;

        HashIndex += (HashIndex << 1) + (HashIndex >> 1) + Char;
    }

    return HashIndex % OB_NUMBER_HASH_BUCKETS;
}

BOOLEAN
ObpLookupElementNameInDirectory(
    IN POBJECT_DIRECTORY Directory,
    IN POBJECT_STRING ElementName,
    IN BOOLEAN ResolveSymbolicLink,
    OUT PVOID *ReturnedObject
    )
/*++

Routine Description:

    This routine searches the object directory for the supplied object name.

Arguments:

    Directory - Supplies the object directory to search.

    ElementName - Supplies the name of the object to find.

    ResolveSymbolicLink - Supplies TRUE if the returned object should be the
        target of a symbolic link

    ReturnedObject - Supplies the location to receive the object if found.

Return Value:

    Returns TRUE if the element name was found, else FALSE.

--*/
{
    OCHAR DriveLetter;
    PVOID Object;
    ULONG HashIndex;
    POBJECT_HEADER_NAME_INFO ObjectHeaderNameInfo;

    ObpAssertObjectManagerLock();

    //
    // If we're looking up a drive letter relative to the DOS devices directory
    // and we're allowed to resolve symbolic links, then do a quick array lookup
    // instead of walking the hash table.
    //

    if ((Directory == ObpDosDevicesDirectoryObject) &&
        ResolveSymbolicLink &&
        (ElementName->Length == sizeof(OCHAR) * 2) &&
        (ElementName->Buffer[1] == (OCHAR)':')) {

        DriveLetter = ElementName->Buffer[0];

        if (DriveLetter >= 'a' && DriveLetter <= 'z') {
            Object = ObpDosDevicesDriveLetterMap[DriveLetter - 'a'];
        } else if (DriveLetter >= 'A' && DriveLetter <= 'Z') {
            Object = ObpDosDevicesDriveLetterMap[DriveLetter - 'A'];
        } else {
            Object = NULL;
        }

        if (Object != NULL) {
            *ReturnedObject = Object;
            return TRUE;
        }
    }

    //
    // Compute the hash index for the element name.
    //

    HashIndex = ObpComputeHashIndex(ElementName);

    //
    // Walk through the object's on this hash chain.
    //

    ObjectHeaderNameInfo = Directory->HashBuckets[HashIndex];

    while (ObjectHeaderNameInfo != NULL) {

        if (RtlEqualObjectString(&ObjectHeaderNameInfo->Name, ElementName, TRUE)) {

            Object = OBJECT_HEADER_NAME_INFO_TO_OBJECT(ObjectHeaderNameInfo);

            //
            // Resolve the symbolic link if requested to.
            //

            if (ResolveSymbolicLink &&
                (OBJECT_TO_OBJECT_HEADER(Object)->Type == &ObSymbolicLinkObjectType)) {
                Object = ((POBJECT_SYMBOLIC_LINK)Object)->LinkTargetObject;
            }

            *ReturnedObject = Object;
            return TRUE;
        }

        ObjectHeaderNameInfo = ObjectHeaderNameInfo->ChainLink;
    }

    *ReturnedObject = NULL;
    return FALSE;
}

NTSTATUS
ObpReferenceObjectByName(
    IN HANDLE RootDirectoryHandle,
    IN POBJECT_STRING ObjectName,
    IN ULONG Attributes,
    IN POBJECT_TYPE ObjectType,
    IN OUT PVOID ParseContext OPTIONAL,
    OUT PVOID *ReturnedObject
    )
/*++

Routine Description:

    This routine references the object with the supplied name and attributes.

Arguments:

    RootDirectoryHandle - Supplies the handle to the root directory to begin
        searching from.

    ObjectName - Supplies the name of the object to reference.

    Attributes - Supplies the attributes of the desired object.

    ObjectType - Optionally supplies the desired type for the returned object.

    ParseContext - Supplies state used while parsing the object's attributes.

    ReturnedObject - Supplies the location to receive the object.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    KIRQL OldIrql;
    OBJECT_STRING RemainingName;
    OBJECT_STRING ElementName;
    BOOLEAN ResolveSymbolicLink;
    PVOID FoundObject;
    POBJECT_HEADER ObjectHeader;
    POBJECT_DIRECTORY Directory;
    PVOID ParsedObject;

    *ReturnedObject = NULL;

    ObpAcquireObjectManagerLock(&OldIrql);

    if (ObjectName != NULL) {
        RemainingName = *ObjectName;
    } else {
        RtlZeroMemory(&RemainingName, sizeof(OBJECT_STRING));
    }

    ResolveSymbolicLink = TRUE;

    //
    // Determine whether we parse the object name from an absolute or
    // relative root directory.
    //

    if (RootDirectoryHandle != NULL) {

        if (RootDirectoryHandle == ObDosDevicesDirectory()) {

            //
            // Reference the root of the DOS devices space.
            //

            FoundObject = ObpDosDevicesDirectoryObject;

        } else if (RootDirectoryHandle == ObWin32NamedObjectsDirectory()) {

            //
            // Reference the root of the Win32 named objects space.
            //

            FoundObject = ObpWin32NamedObjectsDirectoryObject;

        } else {

            //
            // Reference the root directory handle.
            //

            FoundObject = (POBJECT_DIRECTORY)ObpGetObjectHandleContents(RootDirectoryHandle);

            if (FoundObject == NULL) {
                status = STATUS_INVALID_HANDLE;
                goto CleanupAndExit;
            }
        }

        //
        // Verify that this is not an absolute path.
        //

        if ((RemainingName.Length != 0) &&
            (RemainingName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR)) {
            status = STATUS_OBJECT_NAME_INVALID;
            goto CleanupAndExit;
        }

        goto OpenRootDirectory;
    }

    //
    // Verify that this is an absolute path.
    //

    if ((RemainingName.Length == 0) ||
        (RemainingName.Buffer[0] != OBJ_NAME_PATH_SEPARATOR)) {
        status = STATUS_OBJECT_NAME_INVALID;
        goto CleanupAndExit;
    }

    //
    // Reference the global root directory handle.
    //

    FoundObject = ObpRootDirectoryObject;

    //
    // Check if we're supposed to open the root directory.
    //

    if (RemainingName.Length == sizeof(OCHAR)) {

        //
        // Advance past the backslash.
        //

        RemainingName.Buffer++;
        RemainingName.Length = 0;
        RemainingName.MaximumLength = 0;

        goto OpenRootDirectory;
    }

    //
    // Process the object name.
    //

    for (;;) {

        Directory = (POBJECT_DIRECTORY)FoundObject;

        ASSERT(OBJECT_TO_OBJECT_HEADER(Directory)->Type == &ObDirectoryObjectType);

        ObDissectName(RemainingName, &ElementName, &RemainingName);

        if (RemainingName.Length != 0) {

            //
            // Verify that there aren't multiple backslashes in the name.
            //

            if (RemainingName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR) {
                status = STATUS_OBJECT_NAME_INVALID;
                goto CleanupAndExit;
            }

        } else {

            //
            // If the caller is trying to access a symbolic link object, then
            // don't resolve symbolic links for the last element.
            //

            if (ObjectType == &ObSymbolicLinkObjectType) {
                ResolveSymbolicLink = FALSE;
            }
        }

        //
        // Search for the object in the directory and return an error if it
        // doesn't already exist.
        //

        if (!ObpLookupElementNameInDirectory(Directory, &ElementName,
            ResolveSymbolicLink, &FoundObject)) {
            status = (RemainingName.Length != 0) ?
                STATUS_OBJECT_PATH_NOT_FOUND : STATUS_OBJECT_NAME_NOT_FOUND;
            goto CleanupAndExit;
        }

OpenRootDirectory:
        ObjectHeader = OBJECT_TO_OBJECT_HEADER(FoundObject);

        //
        // If we've consumed the entire path, then we found the object, so
        // return success.
        //

        if (RemainingName.Length == 0) {

            //
            // If the object has a parse procedure, then we need to invoke it
            // since it may want to return a different object (such as when we
            // open a device object, we really want to return a file object).
            //

            if (ObjectHeader->Type->ParseProcedure != NULL) {
                goto InvokeParseProcedure;
            }

            //
            // Verify that the found object matches the requested object type.
            //

            if ((ObjectType != NULL) && (ObjectType != ObjectHeader->Type)) {
                status = STATUS_OBJECT_TYPE_MISMATCH;
                goto CleanupAndExit;
            }

            ObjectHeader->PointerCount++;

            *ReturnedObject = FoundObject;

            status = STATUS_SUCCESS;
            goto CleanupAndExit;
        }

        //
        // Only continue parsing in this loop if we found a directory object.
        //

        if (ObjectHeader->Type != &ObDirectoryObjectType) {

            //
            // If the object has a parse procedure, use it to evaluate the
            // remainder of the string.  If not, then we can't go any further.
            //

            if (ObjectHeader->Type->ParseProcedure == NULL) {
                status = STATUS_OBJECT_PATH_NOT_FOUND;
                goto CleanupAndExit;
            }

            //
            // Make sure the object stays alive after we drop the object manager
            // lock.
            //

InvokeParseProcedure:
            ObjectHeader->PointerCount++;

            ObpReleaseObjectManagerLock(OldIrql);

            //
            // If this isn't a file object that we're parsing, then back the
            // remaining name up to the path separator.  If we do have a file
            // object, then it must be from a symbolic link to a directory.  For
            // a directory, we want it to appear that we're doing a relative
            // lookup, so we don't want the leading backslash.
            //

            if (ObjectHeader->Type != &IoFileObjectType &&
                (RemainingName.Buffer > ObjectName->Buffer)) {

                RemainingName.Buffer--;
                RemainingName.Length += sizeof(OCHAR);
                RemainingName.MaximumLength = RemainingName.Length;

                ASSERT(RemainingName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR);
            }

            //
            // Invoke the object's parse procedure.
            //

            ParsedObject = NULL;

            status = ObjectHeader->Type->ParseProcedure(FoundObject, ObjectType,
                Attributes, ObjectName, &RemainingName, ParseContext,
                &ParsedObject);

            ObDereferenceObject(FoundObject);

            //
            // Verify that the parsed object matches the requested object type.
            //

            if (NT_SUCCESS(status)) {

                ASSERT(ParsedObject != NULL);

                if ((ObjectType == NULL) ||
                    (ObjectType == OBJECT_TO_OBJECT_HEADER(ParsedObject)->Type)) {

                    *ReturnedObject = ParsedObject;
                    status = STATUS_SUCCESS;

                } else {

                    ObDereferenceObject(ParsedObject);
                    status = STATUS_OBJECT_TYPE_MISMATCH;
                }
            }

            return status;
        }
    }

CleanupAndExit:
    ObpReleaseObjectManagerLock(OldIrql);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\obx\obp.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    obp.h

Abstract:

    This module contains the private data structures and procedure
    prototypes for the object management system.

--*/

#ifndef _OBP_
#define _OBP_

#include <ntos.h>

//
// Bit flag macros.
//

#define ObpIsFlagSet(flagset, flag)             (((flagset) & (flag)) != 0)
#define ObpIsFlagClear(flagset, flag)           (((flagset) & (flag)) == 0)

//
// Define macros to lock and unlock the object manager.
//

#define ObpAcquireObjectManagerLock(OldIrql) \
    *(OldIrql) = KeRaiseIrqlToDpcLevel()

#define ObpReleaseObjectManagerLock(OldIrql) \
    KeLowerIrql(OldIrql)

#define ObpAssertObjectManagerLock() \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)

//
// Routines which operate on directory objects.
//

ULONG
FASTCALL
ObpComputeHashIndex(
    IN POBJECT_STRING ElementName
    );

BOOLEAN
ObpLookupElementNameInDirectory(
    IN POBJECT_DIRECTORY Directory,
    IN POBJECT_STRING ElementName,
    IN BOOLEAN ResolveSymbolicLink,
    OUT PVOID *ReturnedObject
    );

NTSTATUS
ObpReferenceObjectByName(
    IN HANDLE RootDirectoryHandle,
    IN POBJECT_STRING ObjectName,
    IN ULONG Attributes,
    IN POBJECT_TYPE ObjectType,
    IN OUT PVOID ParseContext OPTIONAL,
    OUT PVOID *ReturnedObject
    );

//
// Routines which operate on the handle table.
//

VOID
ObpInitializeObjectHandleTable(
    VOID
    );

HANDLE
ObpCreateObjectHandle(
    PVOID Object
    );

PVOID
ObpGetObjectHandleReference(
    HANDLE Handle
    );

PVOID
ObpGetObjectHandleContents(
    HANDLE Handle
    );

PVOID
ObpDestroyObjectHandle(
    HANDLE Handle
    );

//
// External symbols.
//

extern POBJECT_DIRECTORY ObpRootDirectoryObject;
extern POBJECT_DIRECTORY ObpDosDevicesDirectoryObject;
extern POBJECT_DIRECTORY ObpIoDevicesDirectoryObject;
extern POBJECT_DIRECTORY ObpWin32NamedObjectsDirectoryObject;
extern PVOID ObpDosDevicesDriveLetterMap['Z' - 'A' + 1];
extern OBJECT_HANDLE_TABLE ObpObjectHandleTable;

#endif  // OBP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\obx\oblink.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    oblink.c

Abstract:

    This module implements routines to manage symbolic link objects.

--*/

#include "obp.h"

//
// Local support.
//

VOID
ObpDeleteSymbolicLink(
    PVOID Object
    );

//
// Object type information for symbolic links.
//
DECLSPEC_RDATA OBJECT_TYPE ObSymbolicLinkObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    NULL,
    ObpDeleteSymbolicLink,
    NULL,
    &ObpDefaultObject,
    'bmyS'
};

NTSTATUS
ObpResolveLinkTarget(
    IN POBJECT_STRING LinkTarget,
    OUT PVOID *ReturnedLinkTargetObject
    )
/*++

Routine Description:

    This routine resolves the object specified by the supplied target name.

Arguments:

    LinkTarget - Supplies the name of the link target.

    ReturnedLinkTargetObject - Supplies the location to receive the object
        reference.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    KIRQL OldIrql;
    POBJECT_DIRECTORY Directory;
    OBJECT_STRING RemainingName;
    OBJECT_STRING ElementName;
    PVOID FoundObject;
    POBJECT_HEADER ObjectHeader;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE FileHandle;
    IO_STATUS_BLOCK IoStatusBlock;

    RemainingName = *LinkTarget;

    //
    // Verify that this is an absolute path.
    //

    if ((RemainingName.Length == 0) ||
        (RemainingName.Buffer[0] != OBJ_NAME_PATH_SEPARATOR)) {
        return STATUS_INVALID_PARAMETER;
    }

    ObpAcquireObjectManagerLock(&OldIrql);

    Directory = ObpRootDirectoryObject;

    for (;;) {

        ObDissectName(RemainingName, &ElementName, &RemainingName);

        //
        // Verify that there aren't multiple backslashes in the name.
        //

        if ((RemainingName.Length != 0) &&
            (RemainingName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR)) {
            break;
        }

        //
        // Search for the object in the directory and return an error if it
        // doesn't already exist.
        //

        if (!ObpLookupElementNameInDirectory(Directory, &ElementName, TRUE,
            &FoundObject)) {
            break;
        }

        ObjectHeader = OBJECT_TO_OBJECT_HEADER(FoundObject);

        //
        // If we've consumed the entire path, then we found the object, so
        // return success.
        //

        if (RemainingName.Length == 0) {

            ObjectHeader->PointerCount++;

            *ReturnedLinkTargetObject = FoundObject;

            ObpReleaseObjectManagerLock(OldIrql);

            return STATUS_SUCCESS;
        }

        //
        // Only continue parsing in this loop if we found a directory object.
        //

        if (ObjectHeader->Type != &ObDirectoryObjectType) {

            //
            // Check if the object has a parse procedure.  If not, we don't know
            // how to continue resolving the link.
            //

            if (ObjectHeader->Type->ParseProcedure == NULL) {
                break;
            }

            //
            // Make sure the object stays alive after we drop the object manager
            // lock.
            //

            ObjectHeader->PointerCount++;

            ObpReleaseObjectManagerLock(OldIrql);

            //
            // Invoke the object's parse procedure.
            //

            status = ObjectHeader->Type->ParseProcedure(FoundObject, NULL,
                OBJ_CASE_INSENSITIVE, LinkTarget, &RemainingName, NULL,
                ReturnedLinkTargetObject);

            if (status == STATUS_OBJECT_TYPE_MISMATCH) {

                //
                // The parse procedure failed due to an object type mismatch.
                // We didn't specify a desired object type, so the most likely
                // reason for the failure is that we needed the I/O manager to
                // build a parse context object in order to resolve a file
                // object.  Attempt to resolve the link using NtOpenFile.
                //

                InitializeObjectAttributes(&ObjectAttributes, LinkTarget,
                    OBJ_CASE_INSENSITIVE, NULL, NULL);

                status = NtOpenFile(&FileHandle, 0, &ObjectAttributes,
                    &IoStatusBlock, FILE_SHARE_READ | FILE_SHARE_WRITE |
                    FILE_SHARE_DELETE, FILE_DIRECTORY_FILE);

                if (NT_SUCCESS(status)) {
                    status = ObReferenceObjectByHandle(FileHandle,
                        &IoFileObjectType, ReturnedLinkTargetObject);
                    NtClose(FileHandle);
                }
            }

            ObDereferenceObject(FoundObject);

            return status;
        }

        Directory = (POBJECT_DIRECTORY)FoundObject;
    }

    ObpReleaseObjectManagerLock(OldIrql);

    return STATUS_INVALID_PARAMETER;
}

NTSTATUS
NtCreateSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN POBJECT_STRING LinkTarget
    )
/*++

Routine Description:

    This routine creates a symbolic link object with the supplied attributes.

Arguments:

    LinkHandle - Supplies the location to receive the created handle.

    ObjectAttributes - Supplies the name and parent directory of the new object.

    LinkTarget - Supplies the name of the link target.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVOID LinkTargetObject;
    ULONG LinkTargetLength;
    POBJECT_SYMBOLIC_LINK SymbolicLink;
    POSTR LinkTargetBuffer;

    //
    // Resolve the link target.  Unlike the NT implementation, we require the
    // target object to exist.
    //

    status = ObpResolveLinkTarget(LinkTarget, &LinkTargetObject);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Create the symbolic link object.
    //

    LinkTargetLength = LinkTarget->Length;

    status = ObCreateObject(&ObSymbolicLinkObjectType, ObjectAttributes,
        sizeof(OBJECT_SYMBOLIC_LINK) + LinkTargetLength, (PVOID*)&SymbolicLink);

    if (NT_SUCCESS(status)) {

        //
        // Copy the link target name to the symbolic link object.
        //

        LinkTargetBuffer = (POSTR)(SymbolicLink + 1);
        RtlCopyMemory(LinkTargetBuffer, LinkTarget->Buffer, LinkTargetLength);

        SymbolicLink->LinkTargetObject = LinkTargetObject;
        SymbolicLink->LinkTarget.Buffer = LinkTargetBuffer;
        SymbolicLink->LinkTarget.Length = (USHORT)LinkTargetLength;
        SymbolicLink->LinkTarget.MaximumLength = (USHORT)LinkTargetLength;

        status = ObInsertObject(SymbolicLink, ObjectAttributes, 0, LinkHandle);

    } else {
        ObDereferenceObject(LinkTargetObject);
    }

    return status;
}

NTSTATUS
NtOpenSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
/*++

Routine Description:

    This routine opens an existing symbolic link object with the supplied
    attributes.

Arguments:

    LinkHandle - Supplies the location to receive the opened handle.

    ObjectAttributes - Supplies the name and parent directory of the desired
        object.

Return Value:

    Status of operation.

--*/
{
    return ObOpenObjectByName(ObjectAttributes, &ObSymbolicLinkObjectType, NULL,
        LinkHandle);
}

NTSTATUS
NtQuerySymbolicLinkObject(
    IN HANDLE LinkHandle,
    IN OUT POBJECT_STRING LinkTarget,
    OUT PULONG ReturnedLength OPTIONAL
    )
/*++

Routine Description:

    This routine returns the link target string from the supplied symbolic link.

Arguments:

    LinkHandle - Supplies the handle of the symbolic link.

    LinkTarget - Supplies the buffer to receive the link target string.

    ReturnedLength - Supplies the location to receive the number of bytes
        required to hold the link target string.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    POBJECT_SYMBOLIC_LINK SymbolicLink;
    ULONG BytesRequired;
    ULONG NameBytesToCopy;

    //
    // Reference the symbolic link object.
    //

    status = ObReferenceObjectByHandle(LinkHandle, &ObSymbolicLinkObjectType,
        (PVOID*)&SymbolicLink);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Compute the number of bytes required to copy the string and the number of
    // bytes that we can actually copy.
    //

    BytesRequired = SymbolicLink->LinkTarget.Length;

    if (BytesRequired <= LinkTarget->MaximumLength) {
        NameBytesToCopy = BytesRequired;
        status = STATUS_SUCCESS;
    } else {
        NameBytesToCopy = LinkTarget->MaximumLength;
        status = STATUS_BUFFER_TOO_SMALL;
    }

    RtlCopyMemory(LinkTarget->Buffer, SymbolicLink->LinkTarget.Buffer,
        NameBytesToCopy);

    LinkTarget->Length = (USHORT)NameBytesToCopy;

    //
    // Dereference the object and return the number of bytes that we copied or
    // that are required.
    //

    ObDereferenceObject(SymbolicLink);

    if (ReturnedLength != NULL) {
        *ReturnedLength = BytesRequired;
    }

    return status;
}

VOID
ObpDeleteSymbolicLink(
    PVOID Object
    )
/*++

Routine Description:

    This routine is called when the last reference to a symbolic link object is
    released.  The link target object is released.

Arguments:

    Object - Supplies the symbolic link to delete.

Return Value:

    None.

--*/
{
    ObDereferenceObject(((POBJECT_SYMBOLIC_LINK)Object)->LinkTargetObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\obx\obtable.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    obtable.c

Abstract:

    This module implements routines to maintain a handle table.

--*/

#include "obp.h"

//
// Global object handle table.
//
OBJECT_HANDLE_TABLE ObpObjectHandleTable;

//
// Define macros to encode and decode the linked list of free handle in the
// object handle table.
//

#define ObpEncodeFreeHandleLink(Link) \
    (((ULONG_PTR)(Link)) | 1)

#define ObpDecodeFreeHandleLink(Link) \
    (((ULONG_PTR)(Link)) & (~1))

#define ObpIsFreeHandleLink(Link) \
    ((LOGICAL)(((ULONG_PTR)(Link)) & 1))

//
// Define a macro to mask off the reserved application bits from a handle.
//

#define ObpMaskOffApplicationBits(Handle) \
    ((HANDLE)(((ULONG_PTR)(Handle)) & ~(sizeof(ULONG) - 1)))

//
// Define macros to index the object handle table.
//

#define ObpGetTableByteOffsetFromHandle(Handle) \
    (HandleToUlong(Handle) & (OB_HANDLES_PER_TABLE * sizeof(PVOID) - 1))

#define ObpGetTableFromHandle(Handle) \
    ObpObjectHandleTable.RootTable[HandleToUlong(Handle) >> (OB_HANDLES_PER_TABLE_SHIFT + 2)]

#define ObpGetHandleContentsPointer(Handle) \
    ((PVOID*)((PUCHAR)ObpGetTableFromHandle(Handle) + ObpGetTableByteOffsetFromHandle(Handle)))

BOOLEAN
ObpExtendObjectHandleTable(
    VOID
    )
/*++

Routine Description:

    This routine extends the tables in the object handle table in order to hold
    more handles.

Arguments:

    None.

Return Value:

    Returns TRUE if the tables were successfully extended, else FALSE.

--*/
{
    PVOID *NewTable;
    SIZE_T OldRootTableSize;
    SIZE_T NewRootTableSize;
    PVOID **NewRootTable;
    HANDLE Handle;
    LONG_PTR FreeHandleLink;
    PVOID *HandleContents;
    ULONG Index;

    ObpAssertObjectManagerLock();

    //
    // Allocate a new table.
    //

    NewTable = (PVOID*)ExAllocatePoolWithTag(sizeof(PVOID) * OB_HANDLES_PER_TABLE,
        'tHbO');

    if (NewTable == NULL) {
        return FALSE;
    }

    //
    // Check if the root table needs to be extended.
    //

    if ((HandleToUlong(ObpObjectHandleTable.NextHandleNeedingPool) &
        (sizeof(PVOID) * OB_HANDLES_PER_SEGMENT - 1)) == 0) {

        if (ObpObjectHandleTable.NextHandleNeedingPool == NULL) {

            //
            // Simple case.  Use the builtin root table.
            //

            NewRootTable = ObpObjectHandleTable.BuiltinRootTable;

        } else {

            OldRootTableSize = HandleToUlong(ObpObjectHandleTable.NextHandleNeedingPool) /
                (sizeof(PVOID*) * OB_HANDLES_PER_TABLE);
            NewRootTableSize = OldRootTableSize + OB_TABLES_PER_SEGMENT;

            //
            // Allocate a new root table.
            //

            NewRootTable = (PVOID**)ExAllocatePoolWithTag(sizeof(PVOID*) *
                NewRootTableSize, 'rHbO');

            if (NewRootTable == NULL) {
                ExFreePool(NewTable);
                return FALSE;
            }

            //
            // Copy the old table to the new table.
            //

            RtlCopyMemory(NewRootTable, ObpObjectHandleTable.RootTable,
                sizeof(PVOID*) * OldRootTableSize);

            //
            // Free the old root table if necessary and switch to the new
            // root table.
            //

            if (ObpObjectHandleTable.RootTable !=
                ObpObjectHandleTable.BuiltinRootTable) {
                ExFreePool(ObpObjectHandleTable.RootTable);
            }
        }

        ObpObjectHandleTable.RootTable = NewRootTable;
    }

    //
    // Attach the new table to the root table.
    //

    ObpGetTableFromHandle(ObpObjectHandleTable.NextHandleNeedingPool) = NewTable;

    //
    // Compute the first handle that will be placed on the free list and it's
    // table position.
    //

    Handle = ObpObjectHandleTable.NextHandleNeedingPool;
    HandleContents = NewTable;
    ASSERT(HandleContents == ObpGetHandleContentsPointer(Handle));

    //
    // Chain the handles from the new table into a free list.
    //

    FreeHandleLink = ObpEncodeFreeHandleLink(Handle);
    ObpObjectHandleTable.FirstFreeTableEntry = FreeHandleLink;

    for (Index = 0; Index < OB_HANDLES_PER_TABLE - 1; Index++) {
        FreeHandleLink += sizeof(PVOID);
        *HandleContents++ = (PVOID)FreeHandleLink;
    }

    //
    // Terminate the free handle list with a negative one.
    //

    *HandleContents = (PVOID)-1;

    //
    // Special case the NULL handle by removing it from the list and setting
    // it's value to NULL.
    //

    if (Handle == NULL) {

        HandleContents = NewTable;
        ASSERT(HandleContents == ObpGetHandleContentsPointer(Handle));

        ObpObjectHandleTable.FirstFreeTableEntry = (LONG_PTR)*HandleContents;
        *HandleContents = NULL;
    }

    ASSERT(ObpIsFreeHandleLink(ObpObjectHandleTable.FirstFreeTableEntry));

    ObpObjectHandleTable.NextHandleNeedingPool = (HANDLE)(HandleToLong(Handle) +
        (sizeof(PVOID) * OB_HANDLES_PER_TABLE));

    return TRUE;
}

HANDLE
ObpCreateObjectHandle(
    PVOID Object
    )
/*++

Routine Description:

    This routine creates an object handle for the supplied object pointer.

Arguments:

    Object - Supplies the object pointer to insert into the handle table.

Return Value:

    Returns the allocated handle or NULL if no resources are available.

--*/
{
    HANDLE Handle;
    PVOID *HandleContents;

    ASSERT((Object != NULL) && !ObpIsFreeHandleLink(Object));

    ObpAssertObjectManagerLock();

    //
    // Check if the object handle table needs to be extended.
    //

    if (ObpObjectHandleTable.FirstFreeTableEntry == -1) {
        if (!ObpExtendObjectHandleTable()) {
            return NULL;
        }
    }

    //
    // Pop the first free handle from the list and initialize the handle to
    // contain the supplied object pointer.
    //

    ASSERT(ObpIsFreeHandleLink(ObpObjectHandleTable.FirstFreeTableEntry));

    Handle = (HANDLE)ObpDecodeFreeHandleLink(ObpObjectHandleTable.FirstFreeTableEntry);
    HandleContents = ObpGetHandleContentsPointer(Handle);

    ObpObjectHandleTable.FirstFreeTableEntry = (LONG_PTR)*HandleContents;

    ASSERT(ObpIsFreeHandleLink(ObpObjectHandleTable.FirstFreeTableEntry));

    ObpObjectHandleTable.HandleCount++;

    OBJECT_TO_OBJECT_HEADER(Object)->HandleCount++;

    *HandleContents = Object;

    return Handle;
}

PVOID
ObpGetObjectHandleReference(
    HANDLE Handle
    )
/*++

Routine Description:

    This routine returns a reference to the supplied handle's contents.

Arguments:

    Handle - Supplies the object handle to reference.

Return Value:

    Returns a referenced object pointer.  ObDereferenceObject should be used to
    release the reference.  Returns NULL if the supplied object handle is
    invalid.

--*/
{
    KIRQL OldIrql;
    PVOID *HandleContents;
    PVOID Object;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    Handle = ObpMaskOffApplicationBits(Handle);

    ObpAcquireObjectManagerLock(&OldIrql);

    //
    // Verify that the handle is not past the end of the allocate handle range.
    //

    if (HandleToUlong(Handle) < HandleToUlong(ObpObjectHandleTable.NextHandleNeedingPool)) {

        HandleContents = ObpGetHandleContentsPointer(Handle);
        Object = *HandleContents;

        //
        // Verify that the handle isn't a free handle link.
        //

        if (Object != NULL && !ObpIsFreeHandleLink(Object)) {

            OBJECT_TO_OBJECT_HEADER(Object)->PointerCount++;

            ObpReleaseObjectManagerLock(OldIrql);

            return Object;
        }
    }

    ObpReleaseObjectManagerLock(OldIrql);

    return NULL;
}

PVOID
ObpGetObjectHandleContents(
    HANDLE Handle
    )
/*++

Routine Description:

    This routine returns the supplied handle's contents.

Arguments:

    Handle - Supplies the object handle to reference.

Return Value:

    Returns a unreferenced object pointer.

--*/
{
    PVOID *HandleContents;
    PVOID Object;

    Handle = ObpMaskOffApplicationBits(Handle);

    ObpAssertObjectManagerLock();

    //
    // Verify that the handle is not past the end of the allocate handle range.
    //

    if (HandleToUlong(Handle) < HandleToUlong(ObpObjectHandleTable.NextHandleNeedingPool)) {

        HandleContents = ObpGetHandleContentsPointer(Handle);
        Object = *HandleContents;

        //
        // Verify that the handle isn't a free handle link.
        //

        if (Object != NULL && !ObpIsFreeHandleLink(Object)) {
            return Object;
        }
    }

    return NULL;
}

PVOID
ObpDestroyObjectHandle(
    HANDLE Handle
    )
/*++

Routine Description:

    This routine destroys an object handle allocated by ObCreateObjectHandle.

Arguments:

    Handle - Supplies the object handle to remove from the handle table.

Return Value:

    Returns the object pointer if the handle is valid, else NULL.

--*/
{
    PVOID *HandleContents;
    PVOID Object;

    Handle = ObpMaskOffApplicationBits(Handle);

    ObpAssertObjectManagerLock();

    //
    // Verify that the handle is not past the end of the allocate handle range.
    //

    if (HandleToUlong(Handle) < HandleToUlong(ObpObjectHandleTable.NextHandleNeedingPool)) {

        HandleContents = ObpGetHandleContentsPointer(Handle);
        Object = *HandleContents;

        //
        // Verify that the handle isn't a free handle link.
        //

        if (Object != NULL && !ObpIsFreeHandleLink(Object)) {

            //
            // Push this handle on the free list.
            //

            *HandleContents = (PVOID)ObpObjectHandleTable.FirstFreeTableEntry;

            ObpObjectHandleTable.FirstFreeTableEntry =
                ObpEncodeFreeHandleLink(Handle);

            ObpObjectHandleTable.HandleCount--;

            return Object;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\obx\obwait.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    obwait.c

Abstract:

    This module implements the generic wait system services.

--*/

#include "obp.h"

NTSTATUS
NtSignalAndWaitForSingleObjectEx (
    IN HANDLE SignalHandle,
    IN HANDLE WaitHandle,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

Routine Description:

    This function atomically signals the specified signal object and then
    waits until the specified wait object attains a state of Signaled.  An
    optional timeout can also be specified.  If a timeout is not specified,
    then the wait will not be satisfied until the wait object attains a
    state of Signaled.  If a timeout is specified, and the wait object has
    not attained a state of Signaled when the timeout expires, then the
    wait is automatically satisfied.  If an explicit timeout value of zero
    is specified, then no wait will occur if the wait cannot be satisfied
    immediately.  The wait can also be specified as alertable.

Arguments:

    SignalHandle - Supplies the handle of the signal object.

    WaitHandle  - Supplies the handle for the wait object.

    WaitMode  - Supplies the processor mode in which the wait is to occur.

    Alertable - Supplies a boolean value that specifies whether the wait
        is alertable.

    Timeout - Supplies an pointer to an absolute or relative time over
        which the wait is to occur.

Return Value:

    The wait completion status.  A value of STATUS_TIMEOUT is returned if a
    timeout occurred.  A value of STATUS_SUCCESS is returned if the specified
    object satisfied the wait.  A value of STATUS_ALERTED is returned if the
    wait was aborted to deliver an alert to the current thread.  A value of
    STATUS_USER_APC is returned if the wait was aborted to deliver a user
    APC to the current thread.

--*/

{
    PVOID RealObject;
    PVOID SignalObject;
    POBJECT_HEADER SignalObjectHeader;
    NTSTATUS Status;
    PVOID WaitObject;
    POBJECT_HEADER WaitObjectHeader;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    //  Reference the signal object by handle.
    //

    Status = ObReferenceObjectByHandle( SignalHandle,
                                        NULL,
                                        &SignalObject );

    //
    //  If the reference was successful, then reference the wait object by
    //  handle.
    //

    if (NT_SUCCESS(Status)) {

        Status = ObReferenceObjectByHandle( WaitHandle,
                                            NULL,
                                            &WaitObject );

        //
        //  If the reference was successful, then determine the real wait
        //  object, check the signal object access, signal the signal object,
        //  and wait for the real wait object.
        //

        if (NT_SUCCESS(Status)) {

            WaitObjectHeader = OBJECT_TO_OBJECT_HEADER(WaitObject);
            RealObject = WaitObjectHeader->Type->DefaultObject;

            if ((LONG_PTR)RealObject >= 0) {

                RealObject = (PVOID)((PCHAR)WaitObject + (ULONG_PTR)RealObject);
            }

            //
            //  If the signal object is an event, then check for modify access
            //  and set the event.  Otherwise, if the signal object is a
            //  mutant, then attempt to release ownership of the mutant.
            //  Otherwise, if the object is a semaphore, then check for modify
            //  access and release the semaphore.  Otherwise, the signal objet
            //  is invalid.
            //

            SignalObjectHeader = OBJECT_TO_OBJECT_HEADER(SignalObject);
            Status = STATUS_ACCESS_DENIED;

            if (SignalObjectHeader->Type == &ExEventObjectType) {

                //
                //  Set the specified event and wait atomically.
                //

                KeSetEvent((PKEVENT)SignalObject, EVENT_INCREMENT, TRUE);

            } else if (SignalObjectHeader->Type == &ExMutantObjectType) {

                //
                //  Release the specified mutant and wait atomically.
                //
                //  N.B. The release will only be successful if the current
                //       thread is the owner of the mutant.
                //

                try {

                    KeReleaseMutant( (PKMUTANT)SignalObject,
                                     MUTANT_INCREMENT,
                                     FALSE,
                                     TRUE );

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    Status = GetExceptionCode();

                    goto WaitExit;
                }

            } else if (SignalObjectHeader->Type == &ExSemaphoreObjectType) {

                //
                //  Release the specified semaphore and wait atomically.
                //

                try {

                    //
                    //  Release the specified semaphore and wait atomically.
                    //

                    KeReleaseSemaphore( (PKSEMAPHORE)SignalObject,
                                        SEMAPHORE_INCREMENT,
                                        1,
                                        TRUE );

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    Status = GetExceptionCode();

                    goto WaitExit;
                }

            } else {

                Status = STATUS_OBJECT_TYPE_MISMATCH;

                goto WaitExit;
            }

            //
            //  Protect the wait call just in case KeWait decides to raise
            //  For example, a mutant level is exceeded
            //

            try {

                Status = KeWaitForSingleObject( RealObject,
                                                UserRequest,
                                                WaitMode,
                                                Alertable,
                                                Timeout );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                Status = GetExceptionCode();
            }

WaitExit:

            ObDereferenceObject(WaitObject);
        }

        ObDereferenceObject(SignalObject);
    }

    return Status;
}

NTSTATUS
NtWaitForSingleObject (
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
{
    return NtWaitForSingleObjectEx (Handle, KernelMode, Alertable, Timeout);
}

NTSTATUS
NtWaitForSingleObjectEx (
    IN HANDLE Handle,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

Routine Description:

    This function waits until the specified object attains a state of
    Signaled.  An optional timeout can also be specified.  If a timeout
    is not specified, then the wait will not be satisfied until the
    object attains a state of Signaled.  If a timeout is specified, and
    the object has not attained a state of Signaled when the timeout
    expires, then the wait is automatically satisfied.  If an explicit
    timeout value of zero is specified, then no wait will occur if the
    wait cannot be satisfied immediately.  The wait can also be specified
    as alertable.

Arguments:

    Handle  - Supplies the handle for the wait object.

    WaitMode  - Supplies the processor mode in which the wait is to occur.

    Alertable - Supplies a boolean value that specifies whether the wait
        is alertable.

    Timeout - Supplies an pointer to an absolute or relative time over
        which the wait is to occur.

Return Value:

    The wait completion status. A value of STATUS_TIMEOUT is returned if a
    timeout occurred.  A value of STATUS_SUCCESS is returned if the specified
    object satisfied the wait.  A value of STATUS_ALERTED is returned if the
    wait was aborted to deliver an alert to the current thread. A value of
    STATUS_USER_APC is returned if the wait was aborted to deliver a user
    APC to the current thread.

--*/

{
    PVOID Object;
    POBJECT_HEADER ObjectHeader;
    NTSTATUS Status;
    PVOID WaitObject;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    //  Get a referenced pointer to the specified object with synchronize
    //  access.
    //

    Status = ObReferenceObjectByHandle( Handle, NULL, &Object );

    //
    //  If access is granted, then check to determine if the specified object
    //  can be waited on.
    //

    if (NT_SUCCESS(Status)) {

        ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
        WaitObject = ObjectHeader->Type->DefaultObject;

        if ((LONG_PTR)WaitObject >= 0) {

            WaitObject = (PVOID)((PCHAR)Object + (ULONG_PTR)WaitObject);
        }

        //
        //  Protect the wait call just in case KeWait decides to raise
        //  For example, a mutant level is exceeded
        //

        try {

            Status = KeWaitForSingleObject( WaitObject,
                                            UserRequest,
                                            WaitMode,
                                            Alertable,
                                            Timeout );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();
        }

        ObDereferenceObject(Object);
    }

    return Status;
}

NTSTATUS
NtWaitForMultipleObjectsEx (
    IN ULONG Count,
    IN HANDLE Handles[],
    IN WAIT_TYPE WaitType,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

Routine Description:

    This function waits until the specified objects attain a state of
    Signaled.  The wait can be specified to wait until all of the objects
    attain a state of Signaled or until one of the objects attains a state
    of Signaled.  An optional timeout can also be specified.  If a timeout
    is not specified, then the wait will not be satisfied until the objects
    attain a state of Signaled.  If a timeout is specified, and the objects
    have not attained a state of Signaled when the timeout expires, then
    the wait is automatically satisfied.  If an explicit timeout value of
    zero is specified, then no wait will occur if the wait cannot be satisfied
    immediately.  The wait can also be specified as alertable.

Arguments:

    Count - Supplies a count of the number of objects that are to be waited
        on.

    Handles[] - Supplies an array of handles to wait objects.

    WaitType - Supplies the type of wait to perform (WaitAll, WaitAny).

    WaitMode  - Supplies the processor mode in which the wait is to occur.

    Alertable - Supplies a boolean value that specifies whether the wait is
        alertable.

    Timeout - Supplies a pointer to an optional absolute of relative time over
        which the wait is to occur.

Return Value:

    The wait completion status.  A value of STATUS_TIMEOUT is returned if a
    timeout occurred.  The index of the object (zero based) in the object
    pointer array is returned if an object satisfied the wait.  A value of
    STATUS_ALERTED is returned if the wait was aborted to deliver an alert
    to the current thread.  A value of STATUS_USER_APC is returned if the
    wait was aborted to deliver a user APC to the current thread.

--*/

{
    ULONG i;
    ULONG j;
    PVOID Object;
    POBJECT_HEADER ObjectHeader;
    PVOID Objects[MAXIMUM_WAIT_OBJECTS];
    ULONG RefCount;
    ULONG Size;
    NTSTATUS Status;
    PKWAIT_BLOCK WaitBlockArray;
    union {
        PVOID WaitObjects[MAXIMUM_WAIT_OBJECTS];
        struct {
            PVOID WaitObjectsSmall[OB_MAXIMUM_STACK_WAIT_BLOCKS];
            KWAIT_BLOCK WaitBlocks[OB_MAXIMUM_STACK_WAIT_BLOCKS];
        };
    } WaitState;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    //  If the number of objects is zero or greater than the largest number
    //  that can be waited on, then return and invalid parameter status.
    //

    if ((Count == 0) || (Count > MAXIMUM_WAIT_OBJECTS)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  If the wait type is not wait any or wait all, then return an invalid
    //  parameter status.
    //

    if ((WaitType != WaitAny) && (WaitType != WaitAll)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  If the number of objects to be waited on is greater than the number
    //  of stack wait blocks, then allocate an array of wait blocks from
    //  nonpaged pool. If the wait block array cannot be allocated, then
    //  return insufficient resources.
    //

    if (Count > OB_MAXIMUM_STACK_WAIT_BLOCKS) {

        Size = Count * sizeof( KWAIT_BLOCK );
        WaitBlockArray = ExAllocatePoolWithTag(Size, 'tiaW');

        if (WaitBlockArray == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        WaitBlockArray = WaitState.WaitBlocks;
    }

    //
    //  Loop through the array of handles and get a referenced pointer to
    //  each object.
    //

    i = 0;
    RefCount = 0;

    Status = STATUS_SUCCESS;

    do {

        //
        //  Get the handle table entry
        //

        Object = ObpGetObjectHandleReference( Handles[i] );

        //
        //  Make sure the handle really did translate to a valid
        //  entry
        //

        if (Object != NULL) {

            RefCount += 1;
            Objects[i] = Object;

            //
            //  We have a object with proper access so get the header
            //  and if the default objects points to a real object
            //  then that is the one we're going to wait on.
            //  Otherwise we'll find the kernel wait object at an
            //  offset into the object body
            //

            ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);

            if ((LONG_PTR)ObjectHeader->Type->DefaultObject < 0) {

                WaitState.WaitObjects[i] = ObjectHeader->Type->DefaultObject;

            } else {

                //
                //  Compute the address of the kernel wait object.
                //

                WaitState.WaitObjects[i] = (PVOID)((PCHAR)&ObjectHeader->Body +
                    (ULONG_PTR)ObjectHeader->Type->DefaultObject);
            }

        } else {

            //
            //  The entry in the handle table isn't in use
            //

            Status = STATUS_INVALID_HANDLE;

            goto ServiceFailed;
        }

        i += 1;

    } while (i < Count);

    //
    //  At this point the WaitObjects[] is set to the kernel wait objects
    //
    //  Now Check to determine if any of the objects are specified more than
    //  once, but we only need to check this for wait all, with a wait any
    //  the user can specify the same object multiple times.
    //

    if (WaitType == WaitAll) {

        i = 0;

        do {

            for (j = i + 1; j < Count; j += 1) {

                if (WaitState.WaitObjects[i] == WaitState.WaitObjects[j]) {

                    Status = STATUS_INVALID_PARAMETER_MIX;

                    goto ServiceFailed;
                }
            }

            i += 1;

        } while (i < Count);
    }

    //
    //  Wait for the specified objects to attain a state of Signaled or a
    //  time out to occur.  Protect the wait call just in case KeWait decides
    //  to raise For example, a mutant level is exceeded
    //

    try {

        Status = KeWaitForMultipleObjects( Count,
                                           WaitState.WaitObjects,
                                           WaitType,
                                           UserRequest,
                                           WaitMode,
                                           Alertable,
                                           Timeout,
                                           WaitBlockArray );

    } except(EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
    }

    //
    //  If any objects were referenced, then deference them.
    //

ServiceFailed:

    while (RefCount > 0) {

        RefCount -= 1;
        ObDereferenceObject(Objects[RefCount]);
    }

    //
    //  If a wait block array was allocated, then deallocate it.
    //

    if (WaitBlockArray != WaitState.WaitBlocks) {

        ExFreePool(WaitBlockArray);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\obx\obhandle.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    obhandle.c

Abstract:

    This module implements routines to manage object handles.

--*/

#include "obp.h"

VOID
ObpDetachNamedObject(
    IN PVOID Object,
    IN KIRQL OldIrql
    )
/*++

Routine Description:

    This routine detaches a named object from its parent directory.

Arguments:

    Object - Supplies the named object to remove.

Return Value:

    None.

--*/
{
    POBJECT_HEADER_NAME_INFO ObjectHeaderNameInfo;
    POBJECT_DIRECTORY Directory;
    OCHAR DriveLetter;
    ULONG HashIndex;
    POBJECT_HEADER_NAME_INFO LastObjectHeaderNameInfo;
    POBJECT_HEADER_NAME_INFO CurrentObjectHeaderNameInfo;

    ObpAssertObjectManagerLock();

    ASSERT(ObpIsFlagSet(OBJECT_TO_OBJECT_HEADER(Object)->Flags, OB_FLAG_NAMED_OBJECT));
    ASSERT(ObpIsFlagSet(OBJECT_TO_OBJECT_HEADER(Object)->Flags, OB_FLAG_ATTACHED_OBJECT));

    ObjectHeaderNameInfo = OBJECT_TO_OBJECT_HEADER_NAME_INFO(Object);

    Directory = ObjectHeaderNameInfo->Directory;

    //
    // If we're removing a drive letter relative to the DOS devices directory,
    // then also remove the object from the quick array lookup.
    //

    if ((Directory == ObpDosDevicesDirectoryObject) &&
        (ObjectHeaderNameInfo->Name.Length == sizeof(OCHAR) * 2) &&
        (ObjectHeaderNameInfo->Name.Buffer[1] == (OCHAR)':')) {

        DriveLetter = ObjectHeaderNameInfo->Name.Buffer[0];

        if (DriveLetter >= 'a' && DriveLetter <= 'z') {
            ASSERT(ObpDosDevicesDriveLetterMap[DriveLetter - 'a'] != NULL);
            ObpDosDevicesDriveLetterMap[DriveLetter - 'a'] = NULL;
        } else if (DriveLetter >= 'A' && DriveLetter <= 'Z') {
            ASSERT(ObpDosDevicesDriveLetterMap[DriveLetter - 'A'] != NULL);
            ObpDosDevicesDriveLetterMap[DriveLetter - 'A'] = NULL;
        }
    }

    //
    // Compute the hash index for the object's name.
    //

    HashIndex = ObpComputeHashIndex(&ObjectHeaderNameInfo->Name);

    //
    // Walk through the directory's hash table to find the object so that we
    // can detach it.
    //

    LastObjectHeaderNameInfo = NULL;
    CurrentObjectHeaderNameInfo = Directory->HashBuckets[HashIndex];

    while (CurrentObjectHeaderNameInfo != ObjectHeaderNameInfo) {

        LastObjectHeaderNameInfo = CurrentObjectHeaderNameInfo;
        CurrentObjectHeaderNameInfo = CurrentObjectHeaderNameInfo->ChainLink;

        ASSERT(CurrentObjectHeaderNameInfo != NULL);
    }

    //
    // Remove the entry.
    //

    if (LastObjectHeaderNameInfo == NULL) {
        Directory->HashBuckets[HashIndex] = CurrentObjectHeaderNameInfo->ChainLink;
    } else {
        LastObjectHeaderNameInfo->ChainLink = CurrentObjectHeaderNameInfo->ChainLink;
    }

    //
    // Null out the link and directory fields so that we don't attempt to do
    // this again.
    //

    ObjectHeaderNameInfo->ChainLink = NULL;
    ObjectHeaderNameInfo->Directory = NULL;

    //
    // Release the reference to the directory and the object which applied in
    // ObInsertObject.
    //

    ObpReleaseObjectManagerLock(OldIrql);

    ObDereferenceObject(Directory);
    ObDereferenceObject(Object);
}

NTSTATUS
NtClose(
    IN HANDLE Handle
    )
/*++

Routine Description:

    This routine closes the supplied handle.

Arguments:

    Handle - Supplies the handle to close.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    KIRQL OldIrql;
    PVOID Object;
    POBJECT_HEADER ObjectHeader;
    ULONG HandleCount;

    ObpAcquireObjectManagerLock(&OldIrql);

    //
    // Attempt to destroy the handle and obtain the object that was stored
    // in the handle.
    //

    Object = ObpDestroyObjectHandle(Handle);

    if (Object != NULL) {

        ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);

        //
        // Grab the current handle count for the object.
        //

        HandleCount = ObjectHeader->HandleCount;
        ASSERT(HandleCount > 0);

        //
        // Decrement the number of handles for this object.
        //

        ObjectHeader->HandleCount--;

        //
        // If the object type has a close procedure, invoke it with the old
        // handle count.
        //

        if (ObjectHeader->Type->CloseProcedure != NULL) {

            ObpReleaseObjectManagerLock(OldIrql);

            ObjectHeader->Type->CloseProcedure(Object, HandleCount);

            ObpAcquireObjectManagerLock(&OldIrql);
        }

        //
        // Check if the object should be removed from its parent directory.
        //

        if ((ObjectHeader->HandleCount == 0) &&
            ObpIsFlagSet(ObjectHeader->Flags, OB_FLAG_ATTACHED_OBJECT) &&
            ObpIsFlagClear(ObjectHeader->Flags, OB_FLAG_PERMANENT_OBJECT)) {
            ObpDetachNamedObject(Object, OldIrql);
        } else {
            ObpReleaseObjectManagerLock(OldIrql);
        }

        //
        // Release the reference that the handle held on the object.
        //

        ObDereferenceObject(Object);

        status = STATUS_SUCCESS;

    } else {

        ObpReleaseObjectManagerLock(OldIrql);

        status = STATUS_INVALID_HANDLE;
    }

    return status;
}

NTSTATUS
NtDuplicateObject(
    IN HANDLE SourceHandle,
    OUT PHANDLE TargetHandle,
    IN ULONG Options
    )
/*++

Routine Description:

    This routine duplicates the supplied handle.

Arguments:

    SourceHandle - Supplies the handle to duplicate.

    TargetHandle - Supplies the location to receive the duplicated handle.

    Options - Supplies options that control the duplication process.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVOID Object;

    //
    // Obtain the object referenced by the handle.
    //

    status = ObReferenceObjectByHandle(SourceHandle, NULL, &Object);

    if (!NT_SUCCESS(status)) {
        *TargetHandle = NULL;
        return status;
    }

    //
    // Close the source handle if requested to.
    //

    if (ObpIsFlagSet(Options, DUPLICATE_CLOSE_SOURCE)) {
        NtClose(SourceHandle);
    }

    //
    // Create a handle for the object and release the reference we acquired
    // above.
    //

    status = ObOpenObjectByPointer(Object, OBJECT_TO_OBJECT_HEADER(Object)->Type,
        TargetHandle);

    ObDereferenceObject(Object);

    return status;
}

NTSTATUS
NtMakeTemporaryObject(
    IN HANDLE Handle
    )
/*++

Routine Description:

    This routine converts a permanent object to a non permanent object.  Non
    permanent objects are removed from the object directory when the last
    handle is closed.

Arguments:

    Handle - Supplies the handle to make temporary.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVOID Object;

    status = ObReferenceObjectByHandle(Handle, NULL, &Object);

    if (NT_SUCCESS(status)) {
        ObMakeTemporaryObject(Object);
        ObDereferenceObject(Object);
    }

    return status;
}

VOID
ObMakeTemporaryObject (
    IN PVOID Object
    )
/*++

Routine Description:

    This routine converts a permanent object to a non permanent object.  Non
    permanent objects are removed from the object directory when the last
    handle is closed.

Arguments:

    Object - Supplies the object to make temporary.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    POBJECT_HEADER ObjectHeader;

    ObpAcquireObjectManagerLock(&OldIrql);

    //
    // Clear the permanent flag.
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);
    ObjectHeader->Flags &= ~OB_FLAG_PERMANENT_OBJECT;

    //
    // Check if the object should be removed from its parent directory.
    //

    if ((ObjectHeader->HandleCount == 0) &&
        ObpIsFlagSet(ObjectHeader->Flags, OB_FLAG_ATTACHED_OBJECT)) {
        ObpDetachNamedObject(Object, OldIrql);
    } else {
        ObpReleaseObjectManagerLock(OldIrql);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\obx\obmanage.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    obmanage.c

Abstract:

    This module implements general routines related to the object manager.

--*/

#include "obp.h"

//
// Pointer to the directory object for the root of the object space.
//
POBJECT_DIRECTORY ObpRootDirectoryObject;

//
// Pointer to the directory object for the DOS devices space.
//
POBJECT_DIRECTORY ObpDosDevicesDirectoryObject;

//
// Pointer to the directory object for the devices space.
//
POBJECT_DIRECTORY ObpIoDevicesDirectoryObject;

//
// Pointer to the directory object for the Win32 named objects space.
//
POBJECT_DIRECTORY ObpWin32NamedObjectsDirectoryObject;

//
// Event used by object types that cannot be signaled.
//
INITIALIZED_KEVENT(ObpDefaultObject, SynchronizationEvent, TRUE);

//
// Name of the DOS devices directory object.
//
INITIALIZED_OBJECT_STRING_RDATA(ObpDosDevicesString, "\\??");
INITIALIZED_OBJECT_STRING_RDATA(ObpIoDevicesString, "\\Device");
INITIALIZED_OBJECT_STRING_RDATA(ObpWin32NamedObjectsString, "\\Win32NamedObjects");

//
// Local support.
//

BOOLEAN                      
ObpCreatePermanentDirectoryObject(
    IN POBJECT_STRING DirectoryName OPTIONAL,
    OUT POBJECT_DIRECTORY *DirectoryObject
    )
/*++

Routine Description:

    This routine creates a permament directory object with the supplied name.

Arguments:

    DirectoryName - Supplies the name of the directory object.

    DirectoryObject - Supplies the buffer to receive the pointer to the
        directory object.

Return Value:

    Returns TRUE if the directory object was created, else FALSE.

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Handle;

    InitializeObjectAttributes(&ObjectAttributes, DirectoryName, OBJ_PERMANENT,
        NULL, NULL);

    status = NtCreateDirectoryObject(&Handle, &ObjectAttributes);

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    status = ObReferenceObjectByHandle(Handle, &ObDirectoryObjectType,
        (PVOID *)DirectoryObject);

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    NtClose(Handle);

    return TRUE;
}

BOOLEAN
ObInitSystem(
    VOID
    )
/*++

Routine Description:

    This routine initializes the object manager.

Arguments:

    None.

Return Value:

    Returns TRUE if the object manager was successfully initialized, else FALSE.

--*/
{
    //
    // Initialize the object handle table.
    //

    ObpObjectHandleTable.HandleCount = 0;
    ObpObjectHandleTable.FirstFreeTableEntry = -1;
    ObpObjectHandleTable.NextHandleNeedingPool = 0;
    ObpObjectHandleTable.RootTable = NULL;

    //
    // Null out the DOS drive letters array.
    //

    RtlZeroMemory(ObpDosDevicesDriveLetterMap, sizeof(ObpDosDevicesDriveLetterMap));

    //
    // Create the root directory object.
    //

    if (!ObpCreatePermanentDirectoryObject(NULL, &ObpRootDirectoryObject)) {
        return FALSE;
    }

    //
    // Create the DOS devices directory object.
    //

    if (!ObpCreatePermanentDirectoryObject(&ObpDosDevicesString,
        &ObpDosDevicesDirectoryObject)) {
        return FALSE;
    }

    //
    // Create the I/O devices directory object.
    //

    if (!ObpCreatePermanentDirectoryObject(&ObpIoDevicesString,
        &ObpIoDevicesDirectoryObject)) {
        return FALSE;
    }

    //
    // Create the Win32 named objects directory object.
    //

    if (!ObpCreatePermanentDirectoryObject(&ObpWin32NamedObjectsString,
        &ObpWin32NamedObjectsDirectoryObject)) {
        return FALSE;
    }

    return TRUE;
}

VOID
ObDissectName(
    IN OBJECT_STRING Path,
    OUT POBJECT_STRING FirstName,
    OUT POBJECT_STRING RemainingName
    )

/*++

Routine Description:

    This routine cracks a path.  It picks off the first element in the
    given path name and provides both it and the remaining part.  A path
    is a set of file names separated by backslashes.  If a name begins
    with a backslash, the FirstName is the string immediately following
    the backslash.  Here are some examples:

        Path           FirstName    RemainingName
        ----           ---------    -------------
        empty          empty        empty

        \              empty        empty

        A              A            empty

        \A             A            empty

        A\B\C\D\E      A            B\C\D\E

        *A?            *A?          empty


    Note that both output strings use the same string buffer memory of the
    input string, and are not necessarily null terminated.

    Also, this routine makes no judgement as to the legality of each
    file name componant.  This must be done separatly when each file name
    is extracted.

Arguments:

    Path - The full path name to crack.

    FirstName - The first name in the path.  Don't allocate a buffer for
        this string.

    RemainingName - The rest of the path.  Don't allocate a buffer for this
        string.

Return Value:

    None.

--*/

{
    ULONG i = 0;
    ULONG PathLength;
    ULONG FirstNameStart;

    //
    //  Make both output strings empty for now
    //

    FirstName->Length = 0;
    FirstName->MaximumLength = 0;
    FirstName->Buffer = NULL;

    RemainingName->Length = 0;
    RemainingName->MaximumLength = 0;
    RemainingName->Buffer = NULL;

    PathLength = Path.Length / sizeof(OCHAR);

    //
    //  Check for an empty input string
    //

    if (PathLength == 0) {

        return;
    }

    //
    //  Skip over a starting backslash, and make sure there is more.
    //

    if ( Path.Buffer[0] == OTEXT('\\') ) {

        i = 1;
    }

    //
    //  Now run down the input string until we hit a backslash or the end
    //  of the string, remembering where we started;
    //

    for ( FirstNameStart = i;
          (i < PathLength) && (Path.Buffer[i] != OTEXT('\\'));
          i += 1 ) {

        NOTHING;
    }

    //
    //  At this point all characters up to (but not including) i are
    //  in the first part.   So setup the first name
    //

    FirstName->Length = (USHORT)((i - FirstNameStart) * sizeof(OCHAR));
    FirstName->MaximumLength = FirstName->Length;
    FirstName->Buffer = &Path.Buffer[FirstNameStart];

    //
    //  Now the remaining part needs a string only if the first part didn't
    //  exhaust the entire input string.  We know that if anything is left
    //  that is must start with a backslash.  Note that if there is only
    //  a trailing backslash, the length will get correctly set to zero.
    //

    if (i < PathLength) {

        RemainingName->Length = (USHORT)((PathLength - (i + 1)) * sizeof(OCHAR));
        RemainingName->MaximumLength = RemainingName->Length;
        RemainingName->Buffer = &Path.Buffer[i + 1];
    }

    //
    //  And return to our caller
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\obx\obref.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    obref.c

Abstract:

    This module implements routines to reference and dereference objects.

--*/

#include "obp.h"

VOID
FASTCALL
ObfReferenceObject(
    IN PVOID Object
    )
/*++

Routine Description:

    This routine increments the reference count for the supplied object.

Arguments:

    Object - Supplies the object to reference.

Return Value:

    None.

--*/
{
    InterlockedIncrement(&OBJECT_TO_OBJECT_HEADER(Object)->PointerCount);
}

NTSTATUS
ObReferenceObjectByPointer(
    IN PVOID Object,
    IN POBJECT_TYPE ObjectType
    )
/*++

Routine Description:

    This routine increments the reference count for the supplied object after
    validating the object type.

Arguments:

    Object - Supplies the object to reference.

    ObjectType - Optionally supplies the desired type for the returned object.

Return Value:

    Status of operation.

--*/
{
    POBJECT_HEADER ObjectHeader;

    ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);

    if (ObjectType == ObjectHeader->Type) {

        InterlockedIncrement(&ObjectHeader->PointerCount);

        return STATUS_SUCCESS;

    } else {
        return STATUS_OBJECT_TYPE_MISMATCH;
    }
}

NTSTATUS
ObOpenObjectByPointer(
    IN PVOID Object,
    IN POBJECT_TYPE ObjectType,
    OUT PHANDLE ReturnedHandle
    )
/*++

Routine Description:

    This routine creates a new handle for the supplied object after validating
    the object type.

Arguments:

    Object - Supplies the object to reference.

    ObjectType - Optionally supplies the desired type for the returned object.

    ReturnedHandle - Supplies the location to receive the object's handle.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    HANDLE Handle;
    KIRQL OldIrql;

    status = ObReferenceObjectByPointer(Object, ObjectType);

    if (NT_SUCCESS(status)) {

        ObpAcquireObjectManagerLock(&OldIrql);

        Handle = ObpCreateObjectHandle(Object);

        ObpReleaseObjectManagerLock(OldIrql);

        if (Handle != NULL) {
            status = STATUS_SUCCESS;
        } else {
            ObDereferenceObject(Object);
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {
        Handle = NULL;
    }

    *ReturnedHandle = Handle;

    return status;
}

NTSTATUS
ObReferenceObjectByHandle(
    IN HANDLE Handle,
    IN POBJECT_TYPE ObjectType OPTIONAL,
    OUT PVOID *ReturnedObject
    )
/*++

Routine Description:

    This routine returns the object referenced by the supplied handle and
    optionally validates the object type.

Arguments:

    Handle - Supplies the handle to reference.

    ObjectType - Optionally supplies the desired type for the returned object.

    ReturnedObject - Supplies the pointer to receive the returned object.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVOID Object;
    POBJECT_HEADER ObjectHeader;

    //
    // Check for the static current process or thread handles.
    //

    if (Handle == NtCurrentThread()) {

        if ((ObjectType == &PsThreadObjectType) || (ObjectType == NULL)) {

            Object = PsGetCurrentThread();
            ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);
            InterlockedIncrement(&ObjectHeader->PointerCount);

            *ReturnedObject = Object;

            return STATUS_SUCCESS;

        } else {
            status = STATUS_OBJECT_TYPE_MISMATCH;
        }

    } else {

        //
        // The handle is not one of the static handles, so reference the object
        // from the handle and validate the type.
        //

        Object = ObpGetObjectHandleReference(Handle);

        if (Object != NULL) {

            ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);

            if ((ObjectType == ObjectHeader->Type) || (ObjectType == NULL)) {

                *ReturnedObject = Object;

                return STATUS_SUCCESS;

            } else {
                ObDereferenceObject(Object);
                status = STATUS_OBJECT_TYPE_MISMATCH;
            }

        } else {
            status = STATUS_INVALID_HANDLE;
        }
    }

    *ReturnedObject = NULL;

    return status;
}

NTSTATUS
ObReferenceObjectByName(
    IN POBJECT_STRING ObjectName,
    IN ULONG Attributes,
    IN POBJECT_TYPE ObjectType,
    IN OUT PVOID ParseContext OPTIONAL,
    OUT PVOID *ReturnedObject
    )
/*++

Routine Description:

    This routine references the object with the supplied name and attributes.

Arguments:

    ObjectName - Supplies the name of the object to reference.

    Attributes - Supplies the attributes of the desired object.

    ObjectType - Optionally supplies the desired type for the returned object.

    ParseContext - Supplies state used while parsing the object's attributes.

    ReturnedObject - Supplies the location to receive the object.

Return Value:

    Status of operation.

--*/
{
    return ObpReferenceObjectByName(NULL, ObjectName, Attributes, ObjectType,
        ParseContext, ReturnedObject);
}

NTSTATUS
ObOpenObjectByName(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN POBJECT_TYPE ObjectType,
    IN OUT PVOID ParseContext OPTIONAL,
    OUT PHANDLE ReturnedHandle
    )
/*++

Routine Description:

    This routine creates a new handle for the object with the supplied
    attributes after validating the object type.

Arguments:

    ObjectAttributes - Supplies the attributes of the desired object.

    ObjectType - Optionally supplies the desired type for the returned object.

    ParseContext - Supplies state used while parsing the object's attributes.

    ReturnedHandle - Supplies the location to receive the object's handle.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVOID Object;
    HANDLE Handle;
    KIRQL OldIrql;

    status = ObpReferenceObjectByName(ObjectAttributes->RootDirectory,
        ObjectAttributes->ObjectName, ObjectAttributes->Attributes, ObjectType,
        ParseContext, &Object);

    if (NT_SUCCESS(status)) {

        ObpAcquireObjectManagerLock(&OldIrql);

        Handle = ObpCreateObjectHandle(Object);

        ObpReleaseObjectManagerLock(OldIrql);

        if (Handle == NULL) {
            ObDereferenceObject(Object);
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {
        Handle = NULL;
    }

    *ReturnedHandle = Handle;

    return status;
}

VOID
FASTCALL
ObfDereferenceObject(
    IN PVOID Object
    )
/*++

Routine Description:

    This routine decrements the reference count for the supplied object and
    destroys the object when the reference count reaches zero.

Arguments:

    Object - Supplies the object to reference.

Return Value:

    None.

--*/
{
    POBJECT_HEADER ObjectHeader;
    PVOID ObjectBase;

    ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);

    if (InterlockedDecrement(&ObjectHeader->PointerCount) == 0) {

        ASSERT(ObjectHeader->HandleCount == 0);

        //
        // If the object has a delete procedure, then invoke it.
        //

        if (ObjectHeader->Type->DeleteProcedure != NULL) {
            ObjectHeader->Type->DeleteProcedure(Object);
        }

        //
        // Determine the allocation base for the object and free the memory.
        //

        if (ObpIsFlagSet(ObjectHeader->Flags, OB_FLAG_NAMED_OBJECT)) {
            ObjectBase = OBJECT_HEADER_TO_OBJECT_HEADER_NAME_INFO(ObjectHeader);
            ASSERT(((POBJECT_HEADER_NAME_INFO)ObjectBase)->Directory == NULL);
        } else {
            ObjectBase = ObjectHeader;
        }

        ObjectHeader->Type->FreeProcedure(ObjectBase);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\phy\phy.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    phy.c

Abstract:

    Ethernet transceiver code inside the ROM

Revision History:

    04/5/2001 davidx
        Created it.
    06/5/2001 dinartem
        Moved to ntos\phy and made it independent of the xnet codebase

--*/

#include <stddef.h>
#include <ntos.h>
#include <nturtl.h>
#include <xtl.h>
#include "phy.h"

//
// Global variables
//  NOTE: The init count persists across quick reboots.
//
DECLSPEC_STICKY DWORD PhyInitFlag;
DWORD PhyLinkState;
LONG PhyLockFlag;

#define PhyLock() InterlockedCompareExchange(&PhyLockFlag, 1, 0)
#define PhyUnlock() (PhyLockFlag = 0)

//
// Macro for spewing debug message
//
#if DBG
BOOL PhyVerboseMode = TRUE;
#define WARNING_ DbgPrint
#define VERBOSE_ !PhyVerboseMode ? (void)0 : (void)DbgPrint
#else !DBG
#define WARNING_ 1 ? (void)0 : (void)
#define VERBOSE_ 1 ? (void)0 : (void)
#endif

#define NETERR(_err)        HRESULT_FROM_WIN32(_err)
#define NETERR_OK           STATUS_SUCCESS
#define NETERR_HARDWARE     0x801f0001  // hardware not responding

BOOL PhyWriteReg(PNICCSR csr, DWORD phyreg, DWORD val);
BOOL PhyReadReg(PNICCSR csr, DWORD phyreg, DWORD* val);

BOOL
PhyUpdateLinkState(
    PNICCSR csr
    )

/*++

Routine Description:

    Update PHY link state information
    (read the information from the PHY registers)

Arguments:

    csr - Points to the NIC registers

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD anar, lpanar, miiStatus, state = 0;

    if (!PhyReadReg(csr, MIIREG_ANAR, &anar) ||
        !PhyReadReg(csr, MIIREG_LPANAR, &lpanar) ||
        !PhyReadReg(csr, MIIREG_STATUS, &miiStatus))
        return FALSE;

    anar &= lpanar;
    if (anar & (MII4_100BASE_T_FULL_DUPLEX | MII4_100BASE_T_HALF_DUPLEX))
        state |= XNET_ETHERNET_LINK_100MBPS;
    else if (anar & (MII4_10BASE_T_FULL_DUPLEX | MII4_10BASE_T_HALF_DUPLEX))
        state |= XNET_ETHERNET_LINK_10MBPS;

    if (anar & (MII4_10BASE_T_FULL_DUPLEX | MII4_100BASE_T_FULL_DUPLEX))
        state |= XNET_ETHERNET_LINK_FULL_DUPLEX;
    else if (anar & (MII4_10BASE_T_HALF_DUPLEX | MII4_100BASE_T_HALF_DUPLEX))
        state |= XNET_ETHERNET_LINK_HALF_DUPLEX;

    if (miiStatus & MIISTATUS_LINK_IS_UP)
        state |= XNET_ETHERNET_LINK_ACTIVE;

    PhyLinkState = state;
    return TRUE;
}


//
// Wait for up to 500ms until the link to be up.
//
DWORD PhyWaitForLinkUp(PNICCSR csr)
{
    DWORD miiStatus = 0;
    INT timeout = 1000;
    while (timeout-- && !(miiStatus & MIISTATUS_LINK_IS_UP)) {
        KeStallExecutionProcessor(500);
        if (!PhyReadReg(csr, MIIREG_STATUS, &miiStatus)) break;
    }
    return miiStatus;
}


// Clear MDIOADR_LOCK bit
VOID PhyClearMDIOLOCK(PNICCSR csr)
{
    INT timeout;

    csr->mdio_adr = MDIOADR_LOCK;
    WARNING_("PHY: MDIOADR_LOCK is set\n");

    timeout = PHYRW_TIMEOUT;
    do {
        KeStallExecutionProcessor(50);
        timeout -= 50;
    } while (timeout > 0 && (csr->mdio_adr & MDIOADR_LOCK));
}


BOOL
PhyReadReg(
    PNICCSR csr,
    DWORD phyreg,
    DWORD* val
    )

/*++

Routine Description:

    Read the value of a PHY register

Arguments:

    csr - Points to the NIC registers
    phyreg - Specifies the PHY register to be read
    val - Return the PHY register value

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD mdioadr;
    INT timeout;

    // The lock bit shouldn't be set.
    // Clear it just in case it's stuck.

    if (csr->mdio_adr & MDIOADR_LOCK) {
        PhyClearMDIOLOCK(csr);
    }

    // Write the PHY register address

    mdioadr = (PHY_ADDR << MDIOADR_PHYSHIFT) | (phyreg << MDIOADR_REGSHIFT);
    csr->mdio_adr = mdioadr;

    mdioadr |= MDIOADR_LOCK;
    for (timeout=PHYRW_TIMEOUT; timeout > 0 && (mdioadr & MDIOADR_LOCK); timeout -= 50) {
        KeStallExecutionProcessor(50);
        mdioadr = csr->mdio_adr;
    }

    // Read the PHY register value
    *val = csr->mdio_data;

    if (mdioadr & MDIOADR_LOCK) {
        WARNING_("PHY read failed: reg %d.\n", phyreg);
        ASSERT(FALSE);
        return FALSE;
    }

    return TRUE;
}


BOOL
PhyWriteReg(
    PNICCSR csr,
    DWORD phyreg,
    DWORD val
    )

/*++

Routine Description:

    Write the specified value to a PHY register

Arguments:

    csr - Points to the NIC registers
    phyreg - Specifies the PHY register to be written
    val - Specifies the value for the PHY register

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD mdioadr;
    INT timeout;

    // The lock bit shouldn't be set.
    // Clear it just in case it's stuck.

    if (csr->mdio_adr & MDIOADR_LOCK) {
        PhyClearMDIOLOCK(csr);
    }

    // Write the data first

    csr->mdio_data = val;

    // Write the PHY register address

    mdioadr = (PHY_ADDR << MDIOADR_PHYSHIFT) | (phyreg << MDIOADR_REGSHIFT) | MDIOADR_WRITE;
    csr->mdio_adr = mdioadr;

    mdioadr |= MDIOADR_LOCK;
    for (timeout=PHYRW_TIMEOUT; timeout > 0 && (mdioadr & MDIOADR_LOCK); timeout -= 50) {
        KeStallExecutionProcessor(50);
        mdioadr = csr->mdio_adr;
    }

    if (mdioadr & MDIOADR_LOCK) {
        WARNING_("PHY write failed: reg %d.\n", phyreg);
        ASSERT(FALSE);
        return FALSE;
    }

    return TRUE;
}


NTSTATUS
PhyInitialize(
    BOOL forceReset,
    VOID* param OPTIONAL
    )

/*++

Routine Description:

    Initialize the Ethernet PHY interface

Arguments:

    forceReset - Whether to force a PHY reset
    param -optional parameters

Return Value:

    Status code

--*/

{
    PNICCSR csr = PNicCsr();
    DWORD miiControl, miiStatus;
    INT timeout;
    NTSTATUS status = NETERR_HARDWARE;

    if (PhyLock() != 0)
        return NETERR(ERROR_BUSY);
    
    if (forceReset) {
        PhyInitFlag = 0;
        PhyLinkState = 0;

        //
        // Force the PHY to reset
        //
        miiControl = MIICONTROL_RESET;
        if (!PhyWriteReg(csr, MIIREG_CONTROL, miiControl)) goto err;

        // Wait for up to 500ms
        timeout = 1000;
        while (timeout-- && (miiControl & MIICONTROL_RESET)) {
            KeStallExecutionProcessor(500);
            if (!PhyReadReg(csr, MIIREG_CONTROL, &miiControl)) goto err;
        }

        // If the reset is still asserted, return error
        if (miiControl & MIICONTROL_RESET) goto err;
    } else if (PhyInitFlag) {
        //
        // If PHY is already initialized, just update the link state
        //
        PhyUpdateLinkState(csr);
        status = NETERR_OK;
        goto exit;
    }

    // The auto-negotiation should be started by now.
    // Wait for a max of 3 seconds for it to complete.
    timeout = 6000;
    miiStatus = 0;
    while (timeout-- && !(miiStatus & MIISTATUS_AUTO_NEGOTIATION_COMPLETE)) {
        KeStallExecutionProcessor(500);
        if (!PhyReadReg(csr, MIIREG_STATUS, &miiStatus)) goto err;
    }

    // NOTE: Workaround for ICS PHY problems with some 10base-t hubs
    //  e.g. Garret Communications Magnum Personal Hub H50
    if (XboxHardwareInfo.McpRevision != 0xa1) {
        DWORD icshack;
        // clear bit 8 of undocumented register 0x18
        if (PhyReadReg(csr, 0x18, &icshack)) {
            icshack &= ~0x0100;
            PhyWriteReg(csr, 0x18, icshack);
        }
    }

    //
    // Use auto-negotiation
    //
    if (!PhyReadReg(csr, MIIREG_CONTROL, &miiControl)) goto err;

    if (miiControl & MIICONTROL_RESTART_AUTO_NEGOTIATION) {
        // If the restart-auto-negotiation bit is set,
        // default to the highest available speed in half-duplex mode.
        WARNING_("Auto-negotiation didn't succeed.\n");

        if (miiStatus & (MIISTATUS_100MBS_T4_CAPABLE |
                         MIISTATUS_100MBS_X_HALF_DUPLEX_CAPABLE |
                         MIISTATUS_100MBS_T2_HALF_DUPLEX_CAPABLE)) {
            // We can do 100Mbps
            miiControl |=  MIICONTROL_SPEED_SELECTION_BIT1;
            miiControl &= ~MIICONTROL_SPEED_SELECTION_BIT0;
            PhyLinkState |= XNET_ETHERNET_LINK_100MBPS;
        } else if (miiStatus & MIISTATUS_10MBS_HALF_DUPLEX_CAPABLE) {
            // We can do 10Mbps
            miiControl &= ~MIICONTROL_SPEED_SELECTION_BIT1;
            miiControl |=  MIICONTROL_SPEED_SELECTION_BIT0;
            PhyLinkState |= XNET_ETHERNET_LINK_10MBPS;
        } else
            goto err;

        PhyLinkState |= XNET_ETHERNET_LINK_HALF_DUPLEX;

        // Set the desired speed if the auto-negotiation never completed
        PhyWriteReg(csr, MIIREG_CONTROL, miiControl);

        miiStatus = PhyWaitForLinkUp(csr);
        if (miiStatus & MIISTATUS_LINK_IS_UP)
            PhyLinkState |= XNET_ETHERNET_LINK_ACTIVE;
    } else {
        // Auto-negotiation worked.
        PhyWaitForLinkUp(csr);
        if (!PhyUpdateLinkState(csr)) goto err;
    }

    PhyInitFlag = 1;
    status = NETERR_OK;

exit:
    PhyUnlock();
    return status;

err:
    WARNING_("Ethernet PHY initialization failed.\n");
    goto exit;
}


//
// Public function for retrieving link state information
//
DWORD PhyGetLinkState(BOOL update)
{
    if ((!PhyLinkState || update) && PhyLock() == 0) {
        PhyUpdateLinkState(PNicCsr());
        PhyUnlock();
    }
    return PhyLinkState;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ps\create.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    create.c

Abstract:

    Process and Thread Creation.

Author:

    Mark Lucovsky (markl) 20-Apr-1989

Revision History:

--*/

#include "psp.h"

ULONG
PspUnhandledExceptionInSystemThread(
    IN PEXCEPTION_POINTERS ExceptionPointers
    )
{
    KdPrint(("PS: Unhandled Kernel Mode Exception Pointers = 0x%p\n", ExceptionPointers));
    KdPrint(("Code %x Addr %p\nInfo0 %p Info1 %p Info2 %p Info3 %p\n",
        ExceptionPointers->ExceptionRecord->ExceptionCode,
        (ULONG_PTR)ExceptionPointers->ExceptionRecord->ExceptionAddress,
        ExceptionPointers->ExceptionRecord->ExceptionInformation[0],
        ExceptionPointers->ExceptionRecord->ExceptionInformation[1],
        ExceptionPointers->ExceptionRecord->ExceptionInformation[2],
        ExceptionPointers->ExceptionRecord->ExceptionInformation[3]
        ));

    //
    // Return EXCEPTION_CONTINUE_SEARCH and let the exception dispatcher notify
    // the debugger of the second chance exception or bugcheck the system.
    //

    return EXCEPTION_CONTINUE_SEARCH;
}

VOID
PspSystemThreadStartup(
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext
    )

/*++

Routine Description:

    This function is called by the kernel to start a system thread.

Arguments:

    StartRoutine - Supplies the address of the system threads entry point.

    StartContext - Supplies a context value for the system thread.

Return Value:

    None.

--*/

{
    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    try {
        (StartRoutine)(StartContext);
    } except (PspUnhandledExceptionInSystemThread(GetExceptionInformation())) {
    }

    PsTerminateSystemThread(STATUS_SUCCESS);
}

NTSTATUS
PsCreateSystemThread(
    OUT PHANDLE ThreadHandle,
    OUT PHANDLE ThreadId OPTIONAL,
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext,
    IN BOOLEAN DebuggerThread
    )

/*++

Routine Description:

    This routine creates and starts a system thread.

Arguments:

    ThreadHandle - Returns the handle for the new thread.

    ThreadId - Returns the thread ID of for the new thread.

    StartRoutine - Supplies the address of the system thread start routine.

    StartContext - Supplies context for a system thread start routine.

    DebuggerThread - Supplies a value that controls whether or not this is a
        thread owned by the debugger.

Return Value:

    Status of operation.

--*/

{
    return PsCreateSystemThreadEx(ThreadHandle,
                                  0,
                                  KERNEL_STACK_SIZE,
                                  0,
                                  ThreadId,
                                  StartRoutine,
                                  StartContext,
                                  FALSE,
                                  DebuggerThread,
                                  PspSystemThreadStartup);
}

NTSTATUS
PsCreateSystemThreadEx(
    OUT PHANDLE ThreadHandle,
    IN SIZE_T ThreadExtensionSize,
    IN SIZE_T KernelStackSize,
    IN SIZE_T TlsDataSize,
    OUT PHANDLE ThreadId OPTIONAL,
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext,
    IN BOOLEAN CreateSuspended,
    IN BOOLEAN DebuggerThread,
    IN PKSYSTEM_ROUTINE SystemRoutine OPTIONAL
    )

/*++

Routine Description:

    This routine creates and initializes a thread object. It implements the
    foundation for NtCreateThread and for PsCreateSystemThread.

Arguments:

    ThreadHandle - Returns the handle for the new thread.

    XapiThreadSize - Supplies the size of the XAPITHREAD to allocate as part of
        the thread's object body.

    ThreadExtensionSize - Supplies the number of bytes to allocate as part of
        the thread's object body.

    KernelStackSize - Supplies the size of the stack for the new thread.

    TlsDataSize - Supplies the number of bytes to reserve from the kernel stack
        for thread local storage.

    ThreadId - Returns the thread ID of for the new thread.

    StartRoutine - Supplies the address of the system thread start routine.

    StartContext - Supplies context for a system thread start routine.

    CreateSuspended - Supplies a value that controls whether or not a thread is
        created in a suspended state.

    DebuggerThread - Supplies a value that controls whether or not this is a
        thread owned by the debugger.

    SystemRoutine - Supplies the address of the routine that wraps the
        StartRoutine.

Return Value:

    Status of operation.

--*/

{
    NTSTATUS st;
    PETHREAD Thread;
    PVOID KernelStack;

    PAGED_CODE();

    Thread = NULL;

    //
    // Allocate thread object.
    //

    st = ObCreateObject(&PsThreadObjectType,
                        NULL,
                        sizeof(ETHREAD) + ThreadExtensionSize,
                        (PVOID *)&Thread);

    if (!NT_SUCCESS(st)) {
        return st;
    }

    //
    // Zero out the thread object.
    //

    RtlZeroMemory(Thread, sizeof(ETHREAD) + ThreadExtensionSize);

    //
    // Initialize Io.
    //

    InitializeListHead(&Thread->IrpList);

    //
    // Initialize Ex.
    //

    InitializeListHead(&Thread->ActiveTimerListHead);

    //
    // Allocate the stack.
    //

    KernelStackSize = ROUND_TO_PAGES(KernelStackSize);
    if (KernelStackSize < KERNEL_STACK_SIZE) {
        KernelStackSize = KERNEL_STACK_SIZE;
    }

    ASSERT(KernelStackSize > TlsDataSize);
    ASSERT((KernelStackSize - TlsDataSize) > KERNEL_USABLE_STACK_SIZE);

    KernelStack = MmCreateKernelStack(KernelStackSize, DebuggerThread);
    if (KernelStack == NULL) {
        ObDereferenceObject(Thread);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize kernel thread object for kernel mode thread.
    //

    Thread->StartAddress = (PVOID)(ULONG_PTR)StartRoutine;

    KeInitializeThread(&Thread->Tcb,
                       KernelStack,
                       KernelStackSize,
                       TlsDataSize,
                       SystemRoutine,
                       StartRoutine,
                       StartContext,
                       &KiSystemProcess);

    KeEnableApcQueuingThread(&Thread->Tcb);

    if (CreateSuspended) {
        KeSuspendThread(&Thread->Tcb);
    }

    //
    // Failures that occur after this point cause the thread to go through
    // PsTerminateSystemThread.
    //

    //
    // Increment the reference count on the thread so that we can safely use the
    // object until the end of this routine.  The thread that we start could
    // terminate before we end up returning to our caller.
    //

    ObReferenceObject(Thread);

    //
    // Increment the reference count on the thread on behalf of the running
    // thread.  The thread reaper will release this reference.
    //

    ObReferenceObject(Thread);

    //
    // Insert the thread object into the handle table and use that handle as the
    // thread identifier.
    //

    st = ObInsertObject(Thread, NULL, 0, &Thread->UniqueThread);

    if (NT_SUCCESS(st)) {

        //
        // Notify registered callout routines of thread creation.
        //

        if (PspCreateThreadNotifyRoutineCount != 0) {
            ULONG i;

            for (i=0; i<PSP_MAX_CREATE_THREAD_NOTIFY; i++) {
                if (PspCreateThreadNotifyRoutine[i] != NULL) {
                    (*PspCreateThreadNotifyRoutine[i])(Thread,
                                                       Thread->UniqueThread,
                                                       TRUE);
                }
            }
        }

        //
        // Create another handle to pass back to the client.
        //

        st = ObOpenObjectByPointer(Thread, &PsThreadObjectType, ThreadHandle);
    }

    if (!NT_SUCCESS(st)) {

        //
        // The insert failed or the handle creation failed.  Terminate the
        // thread.
        //

        Thread->Tcb.HasTerminated = TRUE;

        if (CreateSuspended) {
            KeResumeThread(&Thread->Tcb);
        }

    } else {

        //
        // Return the thread id to the client if requested.
        //

        if (ARGUMENT_PRESENT(ThreadId)) {
            *ThreadId = Thread->UniqueThread;
        }
    }

    //
    // Set the create time for the thread and insert the thread into the ready
    // queue.
    //

    KeQuerySystemTime(&Thread->CreateTime);
    KeReadyThread(&Thread->Tcb);

    //
    // Release the reference to the thread that we made above.
    //

    ObDereferenceObject(Thread);

    return st;
}

NTSTATUS
PsSetCreateThreadNotifyRoutine(
    IN PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
    )

/*++

Routine Description:

    This function allows an installable file system to hook into thread
    creation and deletion to track those events against their own internal
    data structures.

Arguments:

    NotifyRoutine - Supplies the address of the routine which is called at
        thread creation and deletion. The routine is passed the unique Id
        of the created or deleted thread and the unique Id of the containing
        process. The third parameter passed to the notify routine is TRUE if
        the thread is being created and FALSE if it is being deleted.

Return Value:

    STATUS_SUCCESS if successful, and STATUS_INSUFFICIENT_RESOURCES if not.

--*/

{

    ULONG i;
    NTSTATUS Status;

    Status = STATUS_INSUFFICIENT_RESOURCES;
    for (i = 0; i < PSP_MAX_CREATE_THREAD_NOTIFY; i += 1) {
        if (PspCreateThreadNotifyRoutine[i] == NULL) {
            PspCreateThreadNotifyRoutine[i] = NotifyRoutine;
            PspCreateThreadNotifyRoutineCount += 1;
            Status = STATUS_SUCCESS;
            break;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ps\psp.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    psp.h

Abstract:

    Private Interfaces for process structure.

--*/

#ifndef _PSP_
#define _PSP_

#include <ntos.h>
#include <ki.h>

#define PSP_MAX_CREATE_THREAD_NOTIFY 8

ULONG PspCreateThreadNotifyRoutineCount;
PCREATE_THREAD_NOTIFY_ROUTINE PspCreateThreadNotifyRoutine[ PSP_MAX_CREATE_THREAD_NOTIFY ];

VOID
PspReaper(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

#endif // _PSP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ps\psdelete.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    psdelete.c

Abstract:

    This module implements process and thread object termination and
    deletion.

--*/

#include "psp.h"

VOID
PspReaper(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine implements the thread reaper. The reaper is responsible
    for processing terminated threads. This includes:

        - deallocating their kernel stacks

        - releasing their process' CreateDelete lock

        - dereferencing their process

        - dereferencing themselves

Arguments:

    Dpc - Supplies a pointer to the DPC that has fired.

    Context - Unused.

    SystemArgument1 - Supplies a pointer to the thread object to reap.

    SystemArgument2 - Unused.

Return Value:

    None.

--*/

{

    PLIST_ENTRY NextEntry;
    PETHREAD Thread;

    //
    // Lock the dispatcher data and continually remove entries from the
    // reaper list until no more entries exist.
    //
    // N.B. The dispatcher database lock is used to synchronize access to
    //      the reaper list. This is done to avoid a race condition with
    //      the thread termination code.
    //

    KiLockDispatcherDatabaseAtDpcLevel();
    NextEntry = PsReaperListHead.Flink;
    while (NextEntry != &PsReaperListHead) {

        //
        // Remove the next thread from the reaper list, get the address of
        // the executive thread object, and then release the dispatcher
        // database lock.
        //

        RemoveEntryList(NextEntry);
        Thread = CONTAINING_RECORD(NextEntry, ETHREAD, ReaperListEntry);

        KiUnlockDispatcherDatabaseFromDpcLevel();

        //
        // Delete the kernel stack and dereference the thread.
        //

        MmDeleteKernelStack(Thread->Tcb.StackBase, Thread->Tcb.StackLimit);
        Thread->Tcb.StackBase = NULL;
        ObDereferenceObject(Thread);

        //
        // Lock the dispatcher database and get the address of the next
        // entry in the list.
        //

        KiLockDispatcherDatabaseAtDpcLevel();
        NextEntry = PsReaperListHead.Flink;
    }

    //
    // Unlock the dispatcher database.
    //

    KiUnlockDispatcherDatabaseFromDpcLevel();
    return;
}

VOID
PsTerminateSystemThread(
    IN NTSTATUS ExitStatus
    )

/*++

Routine Description:

    This function causes the current thread, which must be a system
    thread, to terminate.

Arguments:

    ExitStatus - Supplies the exit status associated with the thread.

Return Value:

    None.

--*/

{
    PETHREAD Thread;
    PKAPC Apc;
    PLIST_ENTRY FirstEntry;
    PLIST_ENTRY NextEntry;

    PAGED_CODE();

    Thread = PsGetCurrentThread();
    Thread->Tcb.HasTerminated = TRUE;

    KeLowerIrql(PASSIVE_LEVEL);

    //
    // Notify registered callout routines of thread deletion.
    //

    if (Thread->UniqueThread != NULL) {

        if (PspCreateThreadNotifyRoutineCount != 0) {
            ULONG i;

            for (i=0; i<PSP_MAX_CREATE_THREAD_NOTIFY; i++) {
                if (PspCreateThreadNotifyRoutine[i] != NULL) {
                    (*PspCreateThreadNotifyRoutine[i])(Thread,
                                                       Thread->UniqueThread,
                                                       FALSE);
                }
            }
        }
    }

    //
    // Finish terminating the thread at a realtime priority.
    //

    if (Thread->Tcb.Priority < LOW_REALTIME_PRIORITY) {
        KeSetPriorityThread (&Thread->Tcb, LOW_REALTIME_PRIORITY);
    }

    //
    // Rundown The Lists:
    //
    //      - Cancel Io By Thread
    //      - Cancel Timers
    //      - Cancel Registry Notify Requests pending against this thread
    //      - Perform kernel thread rundown
    //

    IoCancelThreadIo(Thread);
    ExTimerRundown();
    KeRundownThread();

    //
    // Set the exit status and exit time for the thread.
    //

    Thread->ExitStatus = ExitStatus;
    KeQuerySystemTime(&Thread->ExitTime);

    //
    // Delete the thread id handle.
    //

    if (Thread->UniqueThread != NULL) {
        NtClose(Thread->UniqueThread);
        Thread->UniqueThread = NULL;
    }

    //
    // Prevent additional APCs from being queued to this thread.
    //

    KeEnterCriticalRegion();
    KeDisableApcQueuingThread(&Thread->Tcb);

    //
    // Guard against another thread suspending us while we were in the process
    // of disabling APCs.
    //

    KeForceResumeThread (&Thread->Tcb);
    KeLeaveCriticalRegion();

    //
    // Flush user-mode APC queue.
    //

    FirstEntry = KeFlushQueueApc(&Thread->Tcb,UserMode);

    if ( FirstEntry ) {

        NextEntry = FirstEntry;
        do {
            Apc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry);
            NextEntry = NextEntry->Flink;

            //
            // If the APC has a rundown routine then call it. Otherwise
            // deallocate the APC
            //

            if ( Apc->RundownRoutine ) {
                (Apc->RundownRoutine)(Apc);
            } else {
                ExFreePool(Apc);
            }

        } while (NextEntry != FirstEntry);
    }

    //
    // At this point, we shouldn't have kernel APCs disabled at all.  If kernel
    // APCs are disabled, then some component forgot to exit a critical region.
    //

    ASSERT(Thread->Tcb.KernelApcDisable == 0);

    //
    // Flush kernel-mode APC queue.
    //
    // There should never be any kernel mode APCs found this far
    // into thread termination. Since we go to PASSIVE_LEVEL upon
    // entering exit.
    //

    FirstEntry = KeFlushQueueApc(&Thread->Tcb,KernelMode);

    if ( FirstEntry ) {
        KeBugCheckEx(
            KERNEL_APC_PENDING_DURING_EXIT,
            (ULONG_PTR)FirstEntry,
            (ULONG_PTR)Thread->Tcb.KernelApcDisable,
            (ULONG_PTR)KeGetCurrentIrql(),
            0
            );
    }

    //
    // Terminate the thread.
    //
    // N.B. There is no return from this call.
    //
    // N.B. The kernel inserts the current thread in the reaper list.
    //

    KeTerminateThread();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ps\psinit.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    psinit.c

Abstract:

    Process Structure Initialization.

--*/

#include "psp.h"

//
// Process Structure Global Data
//

DECLSPEC_RDATA OBJECT_TYPE PsThreadObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    NULL,
    NULL,
    NULL,
    (PVOID)FIELD_OFFSET(KTHREAD, Header),
    'erhT'
};

INITIALIZED_LIST_ENTRY(PsReaperListHead);
KDPC PsReaperDpc;

//
// List head and mutex that links all processes that have been initialized
//

BOOLEAN
PsInitSystem (
    VOID
    )
/*++

Routine Description:

    This function fermorms process structure initialization.
    It is called during phase 0 and phase 1 initialization. Its
    function is to dispatch to the appropriate phase initialization
    routine.

Arguments:

    None.

Return Value:

    TRUE - Initialization succeeded.

    FALSE - Initialization failed.

--*/
{
    HANDLE ThreadHandle;

    //
    // Initialize Reaper Data Structures
    //

    KeInitializeDpc(&PsReaperDpc, PspReaper, NULL);

    //
    // Phase 1 System initialization
    //

    if ( !NT_SUCCESS(PsCreateSystemThread(
                    &ThreadHandle,
                    NULL,
                    Phase1Initialization,
                    NULL,
                    FALSE
                    )) ) {
        return FALSE;
    }

    NtClose( ThreadHandle );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ps\psquery.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    psquery.c

Abstract:

    This module implements the set and query functions for
    process and thread objects.

--*/

#include "psp.h"

extern OBJECT_HANDLE_TABLE ObpObjectHandleTable;

NTSTATUS
PsQueryStatistics(
    IN OUT PPS_STATISTICS ProcessStatistics
    )
/*++

Routine Description:

    This routine returns various statistics about the state of the process
    subsystem.

Arguments:

    ProcessStatistics - Supplies the buffer to fill with the process manager's
        statistics.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PKPROCESS Process;

    if (ProcessStatistics->Length == sizeof(PS_STATISTICS)) {

        Process = PsGetCurrentProcess();

        ProcessStatistics->ThreadCount = Process->StackCount;
        ProcessStatistics->HandleCount = ObpObjectHandleTable.HandleCount;

        status = STATUS_SUCCESS;

    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ps\psctx.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    psctx.c

Abstract:

    This procedure implements Get/Set Context Thread

Author:

    Mark Lucovsky (markl) 25-May-1989

Revision History:

--*/

#include "psp.h"

VOID
PspQueueApcSpecialApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )
{
    PAGED_CODE();

    ExFreePool(Apc);
}

NTSYSAPI
NTSTATUS
NTAPI
NtQueueApcThread(
    IN HANDLE ThreadHandle,
    IN PPS_APC_ROUTINE ApcRoutine,
    IN PVOID ApcArgument1,
    IN PVOID ApcArgument2,
    IN PVOID ApcArgument3
    )

/*++

Routine Description:

    This function is used to queue a user-mode APC to the specified thread. The APC
    will fire when the specified thread does an alertable wait

Arguments:

    ThreadHandle - Supplies a handle to a thread object.  The caller
        must have THREAD_SET_CONTEXT access to the thread.

    ApcRoutine - Supplies the address of the APC routine to execute when the
        APC fires.

    ApcArgument1 - Supplies the first PVOID passed to the APC

    ApcArgument2 - Supplies the second PVOID passed to the APC

    ApcArgument3 - Supplies the third PVOID passed to the APC

Return Value:

    Returns an NT Status code indicating success or failure of the API

--*/

{
    PETHREAD Thread;
    NTSTATUS Status;
    PKAPC Apc;

    PAGED_CODE();

    Status = ObReferenceObjectByHandle(ThreadHandle,
                                       &PsThreadObjectType,
                                       (PVOID *)&Thread);

    if (NT_SUCCESS(Status)) {

        Apc = ExAllocatePoolWithTag(sizeof(*Apc), 'pasP');

        if (Apc != NULL) {

            KeInitializeApc(Apc,
                            &Thread->Tcb,
                            PspQueueApcSpecialApc,
                            NULL,
                            (PKNORMAL_ROUTINE)ApcRoutine,
                            UserMode,
                            ApcArgument1);

            if (!KeInsertQueueApc(Apc, ApcArgument2, ApcArgument3, 0)) {
                ExFreePool(Apc);
                Status = STATUS_UNSUCCESSFUL;
            }

        } else {
            Status = STATUS_NO_MEMORY;
        }

        ObDereferenceObject(Thread);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ps\psspnd.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    psspnd.c

Abstract:

    This module implements NtSuspendThread and NtResumeThread

Author:

    Mark Lucovsky (markl) 25-May-1989

Revision History:

--*/

#include "psp.h"

NTSTATUS
NtSuspendThread(
    IN HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount OPTIONAL
    )

/*++

Routine Description:

    This function suspends the target thread, and optionally
    returns the previous suspend count.

Arguments:

    ThreadHandle - Supplies a handle to the thread object to suspend.

    PreviousSuspendCount - An optional parameter, that if specified
        points to a variable that receives the thread's previous suspend
        count.

Return Value:

    Status of operation.

--*/

{
    PETHREAD Thread;
    NTSTATUS st;
    ULONG LocalPreviousSuspendCount;

    PAGED_CODE();

    st = ObReferenceObjectByHandle(
            ThreadHandle,
            &PsThreadObjectType,
            (PVOID *)&Thread
            );

    if ( !NT_SUCCESS(st) ) {
        return st;
    }

    try {

        if ( Thread != PsGetCurrentThread() ) {
            if ( Thread->Tcb.HasTerminated ) {
                ObDereferenceObject(Thread);
                return STATUS_THREAD_IS_TERMINATING;
            }

            LocalPreviousSuspendCount = (ULONG) KeSuspendThread(&Thread->Tcb);

        } else {
            LocalPreviousSuspendCount = (ULONG) KeSuspendThread(&Thread->Tcb);
        }

        ObDereferenceObject(Thread);

        if (ARGUMENT_PRESENT(PreviousSuspendCount))
            *PreviousSuspendCount = LocalPreviousSuspendCount;

    } except (EXCEPTION_EXECUTE_HANDLER) {

        st = GetExceptionCode();

        //
        // Either the suspend, or the store could cause an
        // exception. The store is a partial success, while the
        // suspend exception is an error
        //

        if ( st == STATUS_SUSPEND_COUNT_EXCEEDED ) {
            ObDereferenceObject(Thread);
        } else {
            st = STATUS_SUCCESS;
        }

        return st;
    }

    return STATUS_SUCCESS;

}

NTSTATUS
NtResumeThread(
    IN HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount OPTIONAL
    )

/*++

Routine Description:

    This function resumes the target thread, and optionally
    returns the previous suspend count.

Arguments:

    ThreadHandle - Supplies a handle to the thread object to resume.

    PreviousSuspendCount - An optional parameter, that if specified
        points to a variable that receives the thread's previous suspend
        count.

Return Value:

    Status of operation.

--*/

{
    PETHREAD Thread;
    NTSTATUS st;
    ULONG LocalPreviousSuspendCount;

    PAGED_CODE();

    st = ObReferenceObjectByHandle(
            ThreadHandle,
            &PsThreadObjectType,
            (PVOID *)&Thread
            );

    if ( !NT_SUCCESS(st) ) {
        return st;
    }

    LocalPreviousSuspendCount = (ULONG) KeResumeThread(&Thread->Tcb);

    ObDereferenceObject(Thread);

    if (ARGUMENT_PRESENT(PreviousSuspendCount)) {
        *PreviousSuspendCount = LocalPreviousSuspendCount;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rawx\create.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    create.c

Abstract:

    This module implements routines related to handling IRP_MJ_CREATE.

--*/

#include "rawx.h"

NTSTATUS
RawxFsdCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CREATE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PRAW_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    ACCESS_MASK DesiredAccess;
    USHORT ShareAccess;
    ULONG CreateOptions;
    PFILE_OBJECT FileObject;
    ULONG CreateDisposition;

    VolumeExtension = (PRAW_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    DesiredAccess = IrpSp->Parameters.Create.DesiredAccess;
    ShareAccess = IrpSp->Parameters.Create.ShareAccess;
    CreateOptions = IrpSp->Parameters.Create.Options;
    FileObject = IrpSp->FileObject;

    RawxAcquireVolumeMutexExclusive(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (VolumeExtension->Dismounted) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Don't allow a relative path to be opened.
    //

    if (IrpSp->FileObject->RelatedFileObject != NULL) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    } else if (IrpSp->Parameters.Create.RemainingName->Length != 0) {
        status = STATUS_OBJECT_PATH_NOT_FOUND;
        goto CleanupAndExit;
    }

    //
    // Verify that the create disposition is for open access only.
    //

    CreateDisposition = (CreateOptions >> 24) & 0xFF;

    if ((CreateDisposition != FILE_OPEN) && (CreateDisposition != FILE_OPEN_IF)) {
        status = STATUS_ACCESS_DENIED;
        goto CleanupAndExit;
    }

    //
    // The caller shouldn't be expecting to see a directory file.
    //

    if (RawxIsFlagSet(CreateOptions, FILE_DIRECTORY_FILE)) {
        status = STATUS_NOT_A_DIRECTORY;
        goto CleanupAndExit;
    }

    //
    // If this is the first open handle to the file, then initialize the sharing
    // mode.  Otherwise, verify that the requested sharing mode is compatible
    // with the current sharing mode.
    //

    if (VolumeExtension->ShareAccess.OpenCount == 0) {
        IoSetShareAccess(DesiredAccess, ShareAccess, FileObject,
            &VolumeExtension->ShareAccess);
        status = STATUS_SUCCESS;
    } else {
        status = IoCheckShareAccess(DesiredAccess, ShareAccess, FileObject,
            &VolumeExtension->ShareAccess, TRUE);
    }

    if (NT_SUCCESS(status)) {

        //
        // Physical volume access is always non-cached.  Mark the file object as
        // non-cached so that the I/O manager enforces alignment requirements.
        //

        FileObject->Flags |= FO_NO_INTERMEDIATE_BUFFERING;

        //
        // Indicate to the caller that we opened the file as opposed to creating
        // or overwriting the file.
        //

        Irp->IoStatus.Information = FILE_OPENED;

        status = STATUS_SUCCESS;
    }

CleanupAndExit:
    RawxReleaseVolumeMutex(VolumeExtension);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rawx\fsctrl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fsctrl.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_FILE_SYSTEM_CONTROL.

--*/

#include "rawx.h"

NTSTATUS
RawxDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine is indirectly called by the I/O manager to handle
    FSCTL_DISMOUNT_VOLUME requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

Return Value:

    Status of operation.

--*/
{
    PRAW_VOLUME_EXTENSION VolumeExtension;
    KIRQL OldIrql;
    ULONG FileObjectCount;

    VolumeExtension = (PRAW_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    RawxAcquireVolumeMutexExclusive(VolumeExtension);

    //
    // Check if the volume is already marked for dismount.  If not, mark it for
    // dismount.
    //

    if (VolumeExtension->Dismounted) {
        RawxReleaseVolumeMutex(VolumeExtension);
        return STATUS_VOLUME_DISMOUNTED;
    }

    VolumeExtension->Dismounted = TRUE;

    //
    // Synchronize access to the MountedOrSelfDevice with the I/O manager by
    // raising to DISPATCH_LEVEL.
    //
    // Clear out the target device object's MountedOrSelfDevice field.  That
    // will cause future accesses to the target device object to mount a new
    // file system device object.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    VolumeExtension->TargetDeviceObject->MountedOrSelfDevice = NULL;

    KeLowerIrql(OldIrql);

    //
    // Release the reference on the target device object.
    //

    ObDereferenceObject(VolumeExtension->TargetDeviceObject);
    VolumeExtension->TargetDeviceObject = NULL;

    //
    // Take a snapshot of the file object count, release the volume mutex, and
    // delete the volume device if the file object count is zero.  This won't
    // normally happen since there's probably an open handle in order to make
    // this dismount call, but it could happen if an IRP was submitted directly
    // to the device object.
    //
    // We'll print out a debug message if the file object count is greater than
    // two.  XUnmountMU dismounts a volume with two file objects outstanding, so
    // anything beyond that represents some user file that hasn't been closed.
    //

    FileObjectCount = VolumeExtension->ShareAccess.OpenCount;

    RawxReleaseVolumeMutex(VolumeExtension);

    if (FileObjectCount == 0) {
        RawxDeleteVolumeDevice(DeviceObject);
    } else if (FileObjectCount > 2) {
        RawxDbgPrint(("RAWX: dismounting volume %p with %d open file handles\n",
            VolumeExtension, FileObjectCount));
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RawxFsdFileSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle
    IRP_MJ_FILE_SYSTEM_CONTROL requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->Parameters.FileSystemControl.FsControlCode) {

        case FSCTL_DISMOUNT_VOLUME:
            //
            // Note that we call indirect through our driver object so that the
            // generated code ends up being identical between GDFX/RAWX/UDFX.
            //

            status = DeviceObject->DriverObject->DriverDismountVolume(DeviceObject);
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rawx\mountvol.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    mountvol.c

Abstract:

    This module implements routines related to the mounting of a RAW volume.

--*/

#include "rawx.h"

VOID
RawxDeleteVolumeDevice(
    IN PDEVICE_OBJECT VolumeDeviceObject
    )
/*++

Routine Description:

    This routine deletes an instance of a volume device object.

Arguments:

    VolumeDeviceObject - Specifies the volume device object to delete.

Return Value:

    Status of operation.

--*/
{
    PRAW_VOLUME_EXTENSION VolumeExtension;

    VolumeExtension = (PRAW_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    //
    // There shouldn't be any open files for this volume.
    //

    ASSERT(VolumeExtension->ShareAccess.OpenCount == 0);

    //
    // Release the reference on the target device object.
    //

    if (VolumeExtension->TargetDeviceObject != NULL) {
        ObDereferenceObject(VolumeExtension->TargetDeviceObject);
    }

    //
    // Delete the device object.
    //

    IoDeleteDevice(VolumeDeviceObject);
}

NTSTATUS
RawxMountVolume(
    IN PDEVICE_OBJECT TargetDeviceObject
    )
/*++

Routine Description:

    This routine is called by the I/O manager to attempt to mount this file
    system.

Arguments:

    TargetDeviceObject - Specifies the device object to attempt to mount.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG IoControlCode;
    DISK_GEOMETRY DiskGeometry;
    PDEVICE_OBJECT VolumeDeviceObject;
    PRAW_VOLUME_EXTENSION VolumeExtension;

    VolumeDeviceObject = NULL;

    RawxAcquireGlobalMutexExclusive();

    //
    // Get the drive geometry from the device.  We don't care about the result,
    // but this gives the device an opportunity to reset any state, such as the
    // number of accessible bytes.
    //

    IoControlCode = (TargetDeviceObject->DeviceType == FILE_DEVICE_CD_ROM) ?
        IOCTL_CDROM_GET_DRIVE_GEOMETRY : IOCTL_DISK_GET_DRIVE_GEOMETRY;

    IoSynchronousDeviceIoControlRequest(IoControlCode, TargetDeviceObject, NULL,
        0, &DiskGeometry, sizeof(DISK_GEOMETRY), NULL, FALSE);

    //
    // Create the volume's device object.
    //

    status = IoCreateDevice(&RawxDriverObject, sizeof(RAW_VOLUME_EXTENSION),
        NULL, FILE_DEVICE_DISK_FILE_SYSTEM, FALSE, &VolumeDeviceObject);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Increase the volume's IRP stack size for requests that we pass down to
    // the target device object.
    //

    VolumeDeviceObject->StackSize = (UCHAR)(VolumeDeviceObject->StackSize +
        TargetDeviceObject->StackSize);

    //
    // Ensure that the alignment for this device matches the requirements of the
    // target device.
    //

    if (VolumeDeviceObject->AlignmentRequirement < TargetDeviceObject->AlignmentRequirement) {
        VolumeDeviceObject->AlignmentRequirement = TargetDeviceObject->AlignmentRequirement;
    }

    //
    // If the target device object supports direct I/O, then indicate that we
    // can as well.
    //

    if (RawxIsFlagSet(TargetDeviceObject->Flags, DO_DIRECT_IO)) {
        VolumeDeviceObject->Flags |= DO_DIRECT_IO;
    }

    //
    // If the target device object supports scatter gather I/O, then indicate
    // that we can as well.
    //

    if (RawxIsFlagSet(TargetDeviceObject->Flags, DO_SCATTER_GATHER_IO)) {
        VolumeDeviceObject->Flags |= DO_SCATTER_GATHER_IO;
    }

    //
    // Set the size of a sector for this device.
    //

    VolumeDeviceObject->SectorSize = TargetDeviceObject->SectorSize;

    //
    // Increment the reference count on the target device object since we'll be
    // holding a pointer to it.
    //

    ObReferenceObject(TargetDeviceObject);

    //
    // Initialize the volume's device extension data.
    //

    VolumeExtension = (PRAW_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    VolumeExtension->TargetDeviceObject = TargetDeviceObject;

    //
    // Initialize the volume's instance lock.
    //

    ExInitializeReadWriteLock(&VolumeExtension->VolumeMutex);

    //
    // The device has finished initializing and is ready to accept requests.
    //

    VolumeDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Connect the volume device object to the target device object and return
    // success.
    //

    TargetDeviceObject->MountedOrSelfDevice = VolumeDeviceObject;

    status = STATUS_SUCCESS;

CleanupAndExit:
    RawxReleaseGlobalMutex();

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rawx\fileinfo.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_QUERY_INFORMATION and IRP_MJ_SET_INFORMATION.

--*/

#include "rawx.h"

NTSTATUS
RawxFsdQueryInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_QUERY_INFORMATION
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_POSITION_INFORMATION PositionInformation;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // The only thing that can be queried is the current file position.
    //

    if (IrpSp->Parameters.QueryFile.FileInformationClass != FilePositionInformation) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    PositionInformation = (PFILE_POSITION_INFORMATION)Irp->UserBuffer;

    //
    // Return the current file position in the user's buffer.
    //

    PositionInformation->CurrentByteOffset = IrpSp->FileObject->CurrentByteOffset;

    //
    // Fill in the number of bytes that we wrote to the user's buffer.
    //

    Irp->IoStatus.Information = sizeof(FILE_POSITION_INFORMATION);
    status = STATUS_SUCCESS;

CleanupAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
RawxFsdSetInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_SET_INFORMATION
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PFILE_POSITION_INFORMATION PositionInformation;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;

    //
    // The only thing that can be set is the current file position.
    //

    if (IrpSp->Parameters.SetFile.FileInformationClass != FilePositionInformation) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    PositionInformation = (PFILE_POSITION_INFORMATION)Irp->UserBuffer;

    //
    // If the file was opened without intermediate buffering, then the byte
    // offset must be sector aligned.
    //
    // Note that we still do the check for FO_NO_INTERMEDIATE_BUFFERING even
    // though this is always set for RAWX file objects; this keeps the code
    // identical to GdfxFsdSetInformation and allows the functions to be
    // collpased by the linker.
    //

    if (RawxIsFlagSet(FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING) &&
        (PositionInformation->CurrentByteOffset.LowPart &
        (DeviceObject->SectorSize - 1)) != 0) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Update the current file position.
    //

    FileObject->CurrentByteOffset = PositionInformation->CurrentByteOffset;
    status = STATUS_SUCCESS;

CleanupAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rawx\close.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    close.c

Abstract:

    This module implements routines related to handling IRP_MJ_CLOSE.

--*/

#include "rawx.h"

NTSTATUS
RawxFsdClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CLOSE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PRAW_VOLUME_EXTENSION VolumeExtension;

    VolumeExtension = (PRAW_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    RawxAcquireVolumeMutexExclusive(VolumeExtension);

    //
    // Check if we're ready to delete this device object.
    //

    if ((VolumeExtension->ShareAccess.OpenCount == 0) &&
        VolumeExtension->Dismounted) {
        RawxReleaseVolumeMutex(VolumeExtension);
        RawxDeleteVolumeDevice(DeviceObject);
    } else {
        RawxReleaseVolumeMutex(VolumeExtension);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rawx\cleanup.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    cleanup.c

Abstract:

    This module implements routines related to handling IRP_MJ_CLEANUP.

--*/

#include "rawx.h"

NTSTATUS
RawxFsdCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CLEANUP requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PRAW_VOLUME_EXTENSION VolumeExtension;
    PFILE_OBJECT FileObject;

    VolumeExtension = (PRAW_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    RawxAcquireVolumeMutexExclusive(VolumeExtension);

    //
    // Cleanup the sharing mode associated with the file object.
    //

    FileObject = IoGetCurrentIrpStackLocation(Irp)->FileObject;
    IoRemoveShareAccess(FileObject, &VolumeExtension->ShareAccess);

    RawxReleaseVolumeMutex(VolumeExtension);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\recovery\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const CHAR* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rawx\driver.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    This module implements routines that apply to the driver object including
    initialization and IRP dispatch routines.

--*/

#include "rawx.h"

//
// Driver object for the RAW file system.
//
DECLSPEC_RDATA DRIVER_OBJECT RawxDriverObject = {
    NULL,                               // DriverStartIo
    NULL,                               // DriverDeleteDevice
    RawxDismountVolume,                 // DriverDismountVolume
    {
        RawxFsdCreate,                  // IRP_MJ_CREATE
        RawxFsdClose,                   // IRP_MJ_CLOSE
        RawxPassIrpDownToTargetDevice,  // IRP_MJ_READ
        RawxPassIrpDownToTargetDevice,  // IRP_MJ_WRITE
        RawxFsdQueryInformation,        // IRP_MJ_QUERY_INFORMATION
        RawxFsdSetInformation,          // IRP_MJ_SET_INFORMATION
        RawxPassIrpDownToTargetDevice,  // IRP_MJ_FLUSH_BUFFERS
        RawxFsdQueryVolumeInformation,  // IRP_MJ_QUERY_VOLUME_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_DIRECTORY_CONTROL
        RawxFsdFileSystemControl,       // IRP_MJ_FILE_SYSTEM_CONTROL
        RawxPassIrpDownToTargetDevice,  // IRP_MJ_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_INTERNAL_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_SHUTDOWN
        RawxFsdCleanup,                 // IRP_MJ_CLEANUP
    }
};

NTSTATUS
RawxVolumeIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called to process the completion of a volume I/O transfer.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Context - Specifies the context that was supplied to IoSetCompletionRoutine.

Return Value:

    Status of operation.

--*/
{
    PRAW_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    VolumeExtension = (PRAW_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Propagate the pending flag up the IRP stack.
    //

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //
    // Check if this is a read or write completion.  This completion routine is
    // shared by other IRP dispatch routines.
    //

    if ((IrpSp->MajorFunction == IRP_MJ_READ) ||
        (IrpSp->MajorFunction == IRP_MJ_WRITE)) {

        if (NT_SUCCESS(Irp->IoStatus.Status)) {

            //
            // If the file is open for synchronous I/O, then we need to update
            // the current file position.
            //

            FileObject = IrpSp->FileObject;

            if (RawxIsFlagSet(FileObject->Flags, FO_SYNCHRONOUS_IO)) {
                FileObject->CurrentByteOffset.QuadPart =
                    IrpSp->Parameters.Read.ByteOffset.QuadPart +
                    Irp->IoStatus.Information;
            }
        }
    }

    RawxDpcReleaseVolumeMutex(VolumeExtension);

    return STATUS_SUCCESS;
}

NTSTATUS
RawxPassIrpDownToTargetDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine passes the current request down to the target device.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PRAW_VOLUME_EXTENSION VolumeExtension;

    VolumeExtension = (PRAW_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    RawxAcquireVolumeMutexShared(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (VolumeExtension->Dismounted) {

        RawxReleaseVolumeMutex(VolumeExtension);

        Irp->IoStatus.Status = STATUS_VOLUME_DISMOUNTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_VOLUME_DISMOUNTED;
    }

    //
    // Initialize the next IRP stack location.
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // Set a completion routine to unlock the volume mutex and update any state
    // in the file control block.
    //

    IoSetCompletionRoutine(Irp, RawxVolumeIoCompletion, NULL, TRUE, TRUE, TRUE);

    //
    // Call down to the target device.
    //

    status = IoCallDriver(VolumeExtension->TargetDeviceObject, Irp);

    //
    // Leave the critical region that we acquired when we took the volume mutex.
    //

    KeLeaveCriticalRegion();

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rawx\rawx.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    rawx.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the RAW file system driver.

--*/

#ifndef _RAWX_
#define _RAWX_

#include <ntos.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>

#include <pshpack4.h>

//
// DBG sensitive DbgPrint wrapper.
//

#if DBG
#define RawxDbgPrint(x)                         DbgPrint x
#else
#define RawxDbgPrint(x)
#endif

//
// Bit flag macros.
//

#define RawxIsFlagSet(flagset, flag)            (((flagset) & (flag)) != 0)
#define RawxIsFlagClear(flagset, flag)          (((flagset) & (flag)) == 0)

//
// Volume device extension data.
//

typedef struct _RAW_VOLUME_EXTENSION {
    PDEVICE_OBJECT TargetDeviceObject;
    SHARE_ACCESS ShareAccess;
    BOOLEAN Dismounted;
    ERWLOCK VolumeMutex;
} RAW_VOLUME_EXTENSION, *PRAW_VOLUME_EXTENSION;

//
// File system dismount routine.
//

NTSTATUS
RawxDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    );

//
// IRP dispatch routines.
//

NTSTATUS
RawxFsdCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RawxFsdClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RawxFsdCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RawxFsdFileSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RawxFsdQueryInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RawxFsdQueryVolumeInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RawxFsdSetInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RawxPassIrpDownToTargetDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// Synchronization routines.
//

VOID
RawxAcquireGlobalMutexExclusive(
    VOID
    );

VOID
RawxReleaseGlobalMutex(
    VOID
    );

VOID
RawxAcquireVolumeMutexExclusive(
    IN PRAW_VOLUME_EXTENSION VolumeExtension
    );

VOID
RawxAcquireVolumeMutexShared(
    IN PRAW_VOLUME_EXTENSION VolumeExtension
    );

VOID
RawxReleaseVolumeMutex(
    IN PRAW_VOLUME_EXTENSION VolumeExtension
    );

#define RawxDpcReleaseVolumeMutex(volume) \
    ExReleaseReadWriteLock(&(volume)->VolumeMutex)

//
// Miscellaneous routines.
//

VOID
RawxDeleteVolumeDevice(
    IN PDEVICE_OBJECT VolumeDeviceObject
    );

//
// External symbols.
//

extern DRIVER_OBJECT RawxDriverObject;

#include <poppack.h>

#endif  // RAWX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rawx\synch.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    synch.c

Abstract:

    This module implements routines which provide synchronization to the file
    system.

--*/

#include "rawx.h"

//
// All file system access is guarded by this single global lock.
//
INITIALIZED_CRITICAL_SECTION(RawxGlobalMutex);

VOID
RawxAcquireGlobalMutexExclusive(
    VOID
    )
/*++

Routine Description:

    This routine acquires the file system's global lock.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KeEnterCriticalRegion();
    RtlEnterCriticalSection(&RawxGlobalMutex);
}

VOID
RawxReleaseGlobalMutex(
    VOID
    )
/*++

Routine Description:

    This routine releases the file system's global lock.

Arguments:

    None.

Return Value:

    None.

--*/
{
    RtlLeaveCriticalSection(&RawxGlobalMutex);
    KeLeaveCriticalRegion();
}

VOID
RawxAcquireVolumeMutexExclusive(
    IN PRAW_VOLUME_EXTENSION VolumeExtension
    )
/*++

Routine Description:

    This routine acquires the volume's lock for exclusive access.

Arguments:

    VolumeExtension - Specifies the volume to lock.

Return Value:

    None.

--*/
{
    KeEnterCriticalRegion();
    ExAcquireReadWriteLockExclusive(&VolumeExtension->VolumeMutex);
}

VOID
RawxAcquireVolumeMutexShared(
    IN PRAW_VOLUME_EXTENSION VolumeExtension
    )
/*++

Routine Description:

    This routine acquires the volume's lock for shared access.

Arguments:

    VolumeExtension - Specifies the volume to lock.

Return Value:

    None.

--*/
{
    KeEnterCriticalRegion();
    ExAcquireReadWriteLockShared(&VolumeExtension->VolumeMutex);
}

VOID
RawxReleaseVolumeMutex(
    IN PRAW_VOLUME_EXTENSION VolumeExtension
    )
/*++

Routine Description:

    This routine releases the volume's lock.

Arguments:

    VolumeExtension - Specifies the volume to unlock.

Return Value:

    None.

--*/
{
    ExReleaseReadWriteLock(&VolumeExtension->VolumeMutex);
    KeLeaveCriticalRegion();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\recovery\bootmbr.h ===
#define X86BOOTCODE_SIZE 512


unsigned char x86BootCode[] = {
51,192,142,208,188,0,124,251,80,7,80,31,252,190,27,124,
191,27,6,80,87,185,229,1,243,164,203,189,190,7,177,4,
56,110,0,124,9,117,19,131,197,16,226,244,205,24,139,245,
131,198,16,73,116,25,56,44,116,246,160,181,7,180,7,139,
240,172,60,0,116,252,187,7,0,180,14,205,16,235,242,136,
78,16,232,70,0,115,42,254,70,16,128,126,4,11,116,11,
128,126,4,12,116,5,160,182,7,117,210,128,70,2,6,131,
70,8,6,131,86,10,0,232,33,0,115,5,160,182,7,235,
188,129,62,254,125,85,170,116,11,128,126,16,0,116,200,160,
183,7,235,169,139,252,30,87,139,245,203,191,5,0,138,86,
0,180,8,205,19,114,35,138,193,36,63,152,138,222,138,252,
67,247,227,139,209,134,214,177,6,210,238,66,247,226,57,86,
10,119,35,114,5,57,70,8,115,28,184,1,2,187,0,124,
139,78,2,139,86,0,205,19,115,81,79,116,78,50,228,138,
86,0,205,19,235,228,138,86,0,96,187,170,85,180,65,205,
19,114,54,129,251,85,170,117,48,246,193,1,116,43,97,96,
106,0,106,0,255,118,10,255,118,8,106,0,104,0,124,106,
1,106,16,180,66,139,244,205,19,97,97,115,14,79,116,11,
50,228,138,86,0,205,19,235,214,97,249,195,73,110,118,97,
108,105,100,32,112,97,114,116,105,116,105,111,110,32,116,97,
98,108,101,0,69,114,114,111,114,32,108,111,97,100,105,110,
103,32,111,112,101,114,97,116,105,110,103,32,115,121,115,116,
101,109,0,77,105,115,115,105,110,103,32,111,112,101,114,97,
116,105,110,103,32,115,121,115,116,101,109,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,44,68,99,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,85,170
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\recovery\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#include <xtl.h>
#include <av.h>

#define APP_TITLE_NAME_A                        "Recovery"

// Screen Dimensions
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2 )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2 )

// Progress Bar Dimensions
#define PROGRESS_WIDTH                           200.0f
#define PROGRESS_HEIGHT                           32.0f
#define PROGRESS_BORDER_OUTER_OFFSET             7.0f
#define PROGRESS_BORDER_GAP                      3.0f
#define PROGRESS_BORDER_WIDTH                    5
#define PROGRESS_X1                               (SCREEN_X_CENTER - (PROGRESS_WIDTH / 2))
#define PROGRESS_X2                               (SCREEN_X_CENTER + (PROGRESS_WIDTH / 2))
#define PROGRESS_Y1                               264.0f
#define PROGRESS_Y2                               (PROGRESS_Y1 + PROGRESS_HEIGHT)

// Launcher Menu Item Information
#define MENU_LAUNCH_MACHINENAME_X1              SCREEN_X_CENTER             // This is not used, it is calculated
#define MENU_LAUNCH_MACHINENAME_Y1              ( SCREEN_HEIGHT - 65.0f )
#define MENU_LAUNCH_NUMXBES_Y1                  MENUBOX_MAINAREA_Y1 - 28.0f
#define MENU_LAUNCH_MACHINENAME_FONTHEIGHT      28
#define MENU_LAUNCH_TOP_BORDER_SIZE             10.0f
#define MENU_LAUNCH_UPARROW_X1                  113     // Bitmaps, use int
#define MENU_LAUNCH_UPARROW_Y1                  106     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_X1                113     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_Y1                380     // Bitmaps, use int

// Menubox constants
#define MENUBOX_MAINAREA_X1                      99.0f
#define MENUBOX_MAINAREA_Y1                     134.0f
#define MENUBOX_MAINAREA_X2                     535.0f
#define MENUBOX_MAINAREA_Y2                     375.0f

#define MENUBOX_SELECTBAR_X1                    MENUBOX_MAINAREA_X1
#define MENUBOX_SELECTBAR_X2                    ( MENUBOX_MAINAREA_X2 + 1 )

#define MENUBOX_TEXT_TOP_BORDER                   16.0f
#define MENUBOX_TEXT_BOTTOM_BORDER                0.0f
#define MENUBOX_TEXT_LSIDE_BORDER                 8.0f
#define MENUBOX_TEXT_RSIDE_BORDER                 8.0f

#define MENUBOX_TEXTAREA_X1                     ( MENUBOX_MAINAREA_X1 + MENUBOX_TEXT_LSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y1                     ( MENUBOX_MAINAREA_Y1 + MENUBOX_TEXT_TOP_BORDER )
#define MENUBOX_TEXTAREA_X2                     ( MENUBOX_MAINAREA_X2 - MENUBOX_TEXT_RSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y2                     ( MENUBOX_MAINAREA_Y2 - MENUBOX_TEXT_BOTTOM_BORDER )

#define MENUBOX_BUILDNUM_Y1                     ( MENUBOX_TEXTAREA_Y2 - 22.0f )

// Behaviour constants
#define KEY_PRESS_INITIAL_DELAY                 400         // milliseconds
#define KEY_PRESS_REPEAT_DELAY                  50
#define EXECUTABLE_DIRECTORY_POLL_INTERVAL      5000        // 5 seconds
#define CLEAR_SCREEN_PAUSE_MS                   250         // milliseconds

// Font info
#define FONT_DEFAULT_HEIGHT                     20
#define FONT_DEFAULT_WIDTH                      8
#define FONT_ALIAS_LEVEL                        0
#define FONT_DEFAULT_STYLE                      XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"

// Screen Item Constants
#define SCREEN_ITEM_TEXT_LENGTH                 40

// Colors
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_LIGHT_YELLOW                      0xFFDFF77F
#define COLOR_YELLOW                            0xFFFFFF00
#define COLOR_LIGHT_GRAY                        0xFFC8C8C8
#define COLOR_DARK_GRAY                         0xFF828282
#define COLOR_LIME_GREEN                        0xFF9BD351
#define COLOR_BRIGHT_GREEN                      0xFF73C034
#define COLOR_MEDIUM_GREEN                      0xFF57932E
#define COLOR_DARK_GREEN2                       0xFF357515
#define COLOR_DARK_GREEN                        0xFF2C531E

#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_TEXT_FG_COLOR            COLOR_LIGHT_YELLOW
#define SCREEN_DEFAULT_TEXT_BG_COLOR            SCREEN_DEFAULT_BACKGROUND_COLOR

// Menu Item constants
#define ITEM_SELECTOR_BORDER_SPACE              2
#define ITEM_VERT_SPACING                       7.0f
#define ITEM_SELECTOR_COLOR                     COLOR_LIME_GREEN
#define ITEM_XBELIST_FONT_HEIGHT                17 // 18

// Keypad and Keyboard location information
#define KEYBOARD_TOPROW_Y1                      225
#define KEYPAD_TOPROW_Y1                        225
#define MENU_DISPSET_BUTTON_Y1                  211

// File path and location constants
#define FILE_DATA_DRIVE                        L"d:"
#define FILE_DATA_DRIVE_A                       "d:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\recmedia"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\recmedia"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\recmedia"

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\recovery\draw.cpp ===
/*--
Copyright (c) 2000 Microsoft Corporation - Xbox SDK

Module Name:

    draw.cpp

Abstract:

    Simple sample for drawing text on the screen.

Revision History:

    Derived from a DX8 sample.
--*/

#include <xtl.h>

#include "d3d8.h"
#include "bitfont.h"

//------------------------------------------------------------------------------
// Draw
//
// Handy little D3D encapsulation for simple 2D drawing.

class Draw
{
private:

    static IDirect3DDevice8* m_pDevice;

    IDirect3DSurface8* m_pBackBuffer;

    BitFont m_font;

public:

    Draw(INT width = 640, INT height = 480);

    ~Draw();

    VOID FillRect(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);

    VOID DrawText(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);

    VOID Present();

    BOOL IsValid() { return m_pDevice != NULL; }
};

//------------------------------------------------------------------------------
// Draw::m_pDevice
//
// Instantiate static class member, initialized to NULL.

IDirect3DDevice8* Draw::m_pDevice;

//------------------------------------------------------------------------------
// Draw constructor

Draw::Draw(INT width, INT height)
{
    m_pBackBuffer = NULL;

    // If we're invoked multiple times, we inherit the old mode (largely
    // because we don't support multiple mode sets on Xbox yet):

    if (m_pDevice == NULL)
    {
        // Create D3D 8.
    
        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (pD3D == NULL)
            return;
    
        // Set the screen mode.
    
        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));
    
        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;
        d3dpp.hDeviceWindow             = NULL;
    
        // Create the device.
    
        if (pD3D->CreateDevice
        (
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            NULL,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &m_pDevice
        ) != S_OK)
        {
            pD3D->Release();

            return;
        }
    
        // Now we no longer need the D3D interface so let's free it.
    
        pD3D->Release();
    }

    m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer);
}

//------------------------------------------------------------------------------
// Draw::~Draw

Draw::~Draw()
{
    if (m_pBackBuffer)
        m_pBackBuffer->Release();
}

//------------------------------------------------------------------------------
// Draw::FillRect

VOID Draw::FillRect(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    D3DRECT rect;

    if (m_pDevice != NULL)
    {
        rect.x1 = x;
        rect.y1 = y;
        rect.x2 = x + width;
        rect.y2 = y + height;

        m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
    }
}

//------------------------------------------------------------------------------
// Draw::DrawText

VOID Draw::DrawText(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    if (m_pBackBuffer != NULL)
    {
        m_font.DrawText(m_pBackBuffer, string, x, y, flags, foregroundColor,
                        backgroundColor);
    }
}

//------------------------------------------------------------------------------
// Draw::Present
//
// Make the current back-buffer visible

VOID Draw::Present()
{
    if (m_pDevice != NULL)
    {
        m_pDevice->Present(NULL, NULL, NULL, NULL);
    }
}

//------------------------------------------------------------------------------
// Test

extern "C" VOID DrawMessage(LPCWSTR pcszText, int iProgPercent)
{
    Draw draw;

    draw.FillRect(0, 0, 640, 480, 0x000080);            // Draw border in dark blue
    draw.FillRect(20, 20, 600, 440, 0);                 // Fill interior with black
    draw.DrawText(pcszText, 100, 100, 0xbbbbff);
    
    if (-1 != iProgPercent)
    {
        //
        // Draw progress bar background
        //

        draw.FillRect(215, 220, 210, 40, 0x000080);
        
        //
        // Draw progress bar
        //

        draw.FillRect(220, 225, 2 * min(iProgPercent, 100), 30, 0xbbbbff);
    }
    draw.Present();                                     // Show the buffer
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\recovery\flash.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    flash.c

Abstract:

    This module implements function used to program kernel image to flash
    ROM on EVT and DVT machine.

--*/

#include "recovpch.h"
#include <pci.h>


//
// Manufacturer and chip identifiers
//

#define SST_ID                  0xBF
#define SST_49LF040             0x53

#define AMD_ID                  0x01
#define FUJITSU_ID              0x04
#define HYUNDAI_ID              0xAD
#define GENERIC_29F080          0xD5

#define ST_ID                   0x20
#define M29F080A                0xF1

typedef enum {
    FlashUnknownDevice = 0,
    FlashSST49LF040,
    FlashGeneric29F080
} FlashDeviceID;

typedef enum {
    FlashStatusReady,
    FlashStatusBusy,
    FlashStatusEraseSuspended,
    FlashStatusTimeout,
    FlashStatusError
} FlashStatus;

//
// Mapped virtual address of ROM region
//

PVOID KernelRomBase;

// SIZE_T
// FlashSize(
//     IN FlashDeviceID ID
//     )
// ++
//
// Routine Description:
//
//     This macro returns size of flash ROM specified by device identifier id
//
// Arguments:
//
//     ID - Device identifier returned by FlashDetectDevice
//
// Return Value:
//
//     Size of flash ROM for specified device
//
// --

#define FlashSize( ID )         FlashSizeMap[(ID)]

SIZE_T FlashSizeMap[] = {
    0,
    512 * 1024,     // SST 49LF040 Firmware Hub
    1024 * 1024     // Generic 29F080
};

// ULONG_PTR
// FlashBaseAddress(
//     IN FlashDeviceID ID
//     )
// ++
//
// Routine Description:
//
//     This macro calculates the base address of flash ROM specified by ID,
//     based on the size of the chip
//
// Arguments:
//
//     ID - Device identifier returned by FlashDetectDevice
//
// Return Value:
//
//     Base address of flash ROM from top 4GB
//
// --

#define FlashBaseAddress( ID )  ((ULONG_PTR)(0xFFFFFFFF-FlashSize(ID)+1))

//
// Lowest possible base address of flash ROM and region size
//

#define FLASH_BASE_ADDRESS      0xFFF00000
#define FLASH_REGION_SIZE       (0xFFFFFFFF-FLASH_BASE_ADDRESS-1)

// BYTE
// FlashReadByte(
//     IN ULONG_PTR Physical
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and reads one byte from mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
// Return Value:
//
//     A read byte from specified address
//
// --

#define FlashReadByte(a) \
    (*(PBYTE)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS))

// VOID
// FlashWriteByte(
//     IN ULONG_PTR Physical,
//     IN BYTE Byte
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and writes one byte to mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
//     Byte - Data to be written to
//
// Return Value:
//
//     None
//
// --

#define FlashWriteByte(a, d) \
    (*(PBYTE)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS) = d)

// WORD
// FlashReadWord(
//     IN ULONG_PTR Physical
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and reads two bytes from mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
// Return Value:
//
//     Two byte from specified address
//
// --

#define FlashReadWord(a) \
    (*(PWORD)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS))

// VOID
// FlashWriteWord(
//     IN ULONG_PTR Physical,
//     IN WORD Word
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and writes two bytes to mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
//     Word - Data to be written to
//
// Return Value:
//
//     None
//
// --

#define FlashWriteWord(a, d) \
    (*(PWORD)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS) = d)

FlashStatus
FlashGetStatus(
    IN FlashDeviceID ID,
    IN ULONG_PTR Address OPTIONAL,
    IN BYTE Data
    )
/*++

Routine Description:

    This routine checks status of flash chip using data# polling method.
    The data# polling bit, DQ7, indicates whether the Embeded Algorithm
    is in progress or completed.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

    Address - Physical address of flash ROM to be checked

    Data - Expected data at specified address

Return Value:

    Status of flash chip, see the definition of FlashStatus above.

--*/
{
    UCHAR retry=1, d, t;

    if ( !ARGUMENT_PRESENT(Address) ) {
        Address = FlashBaseAddress( ID );
    }

    if ( ID == FlashSST49LF040 ) {

        //
        // SST doesn't support Exceeded Timing Limits, DQ5
        //

        d = FlashReadByte(Address) & 0x80;
        t = Data & 0x80;

        if ( t == d ) {
            return FlashStatusReady;
        } else {
            return FlashStatusBusy;
        }

    } else {

again:
        d = FlashReadByte(Address) & 0x80;
        t = Data & 0x80;

        if ( t == d ) {
            return FlashStatusReady;        // data matches
        } else if ( d & 0x20 ) {            // Timeout?
            d = FlashReadByte(Address) & 0x80;
            if ( t == d ) {
                return FlashStatusReady;    // data matches
            }
            if ( retry-- ) {
                goto again;                 // may have been write completion
            }
            return FlashStatusTimeout;
        }

        if ( retry-- ) {
            goto again;                     // may have been write completion
        } else {
            return FlashStatusError;
        }
    }
}

VOID
FlashResetDevice(
    VOID
    )
/*++

Routine Description:

    This routine resets flash ROM back to read mode if device is in ID command
    mode or during a program or erase operation

Arguments:

    None

Return Value:

    None

--*/
{
    FlashWriteByte( 0xFFFF5555, 0xAA );
    FlashWriteByte( 0xFFFF2AAA, 0x55 );
    FlashWriteByte( 0xFFFF5555, 0xF0 );
    KeStallExecutionProcessor( 150000 );
}

FlashDeviceID
FlashDetectDevice(
    VOID
    )
/*++

Routine Description:

    This routine detects the device and manufacturer id of flash device on
    the system.  The device on Xbus will be detected first and if no device
    detected, LPC bus will be next.

Arguments:

    None

Return Value:

    Type of flash id installed in the system or FlashUnknownDevice

--*/
{
    BYTE byte;
    BYTE id1=0, id2=0;
    BOOL FirstTime = TRUE;
    PCI_SLOT_NUMBER PCISlotNumber;
    PCI_COMMON_CONFIG Configuration;

detect:

    FlashWriteByte( 0xFFFF5555, 0xAA );
    FlashWriteByte( 0xFFFF2AAA, 0x55 );
    FlashWriteByte( 0xFFFF5555, 0x90 );

    KeStallExecutionProcessor( 1 );

    id1 = FlashReadByte( 0xFFFF0000 );
    id2 = FlashReadByte( 0xFFFF0001 );

    FlashResetDevice();

    if ( id1 == SST_ID && id2 == SST_49LF040 ) {
        return FlashSST49LF040;
    }

    if ( (id1 == AMD_ID || id1 == HYUNDAI_ID || id1 == FUJITSU_ID) && \
         id2 == GENERIC_29F080 ) {
        return FlashGeneric29F080;
    }

    if ( id1 == ST_ID && id2 == M29F080A ) {
        return FlashGeneric29F080;
    }

    if ( FirstTime == TRUE ) {

        //
        // We are here because we couldn't find any flash ROM on Xbus.
        // Next thing is to see if this is a EVT board and enable ROM
        // write bus cycle to LPC interface.  By default the write cycle
        // to ROM will drop.
        //

        FirstTime = FALSE;

        //
        // Looking for PCI-to-LPC bridge
        //

        for ( byte=0x00; byte<=0xff; byte++ ) {
            PCISlotNumber.u.AsULONG = byte;
            HalReadPCISpace( 0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration) );
            if ( Configuration.BaseClass == 6 && Configuration.SubClass == 1 ) {
                break;
            }
        }

        //
        // If it is Nvidia PCI-to-LPC bridge, enable LPC ROM write
        //

        if ( Configuration.VendorID == 0x10DE && Configuration.DeviceID == 0x01B2 ) {
            byte = 0x01;
            HalWritePCISpace( 0, PCISlotNumber.u.AsULONG, 0x45, &byte, sizeof(byte) );
            goto detect;
        }

    } else {

        //
        // If we still couldn't find any flash ROM on LPC bus, disable LPC
        // ROM write
        //

        byte = 0x00;
        HalWritePCISpace( 0, PCISlotNumber.u.AsULONG, 0x45, &byte, sizeof(byte) );
    }

    return FlashUnknownDevice;
}

BOOL
FlashEraseChip(
    FlashDeviceID ID
    )
/*++

Routine Description:

    This routine erase the content of entire flash ROM to 0xFF.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

Return Value:

    TRUE if operation success, FALSE otherwise

--*/
{
    ULONG_PTR FlashPtr;
    BOOL fBlank = FALSE;
    SIZE_T Count, Retries=5;

    while ( Retries-- ) {

        FlashWriteByte( 0xFFFF5555, 0xAA );
        FlashWriteByte( 0xFFFF2AAA, 0x55 );
        FlashWriteByte( 0xFFFF5555, 0x80 );
        FlashWriteByte( 0xFFFF5555, 0xAA );
        FlashWriteByte( 0xFFFF2AAA, 0x55 );
        FlashWriteByte( 0xFFFF5555, 0x10 );

        FlashPtr = ~0L;

        //
        // Wait until flash chip is ready and completely erased.
        //

        Count = 0x100000;
        while ( FlashGetStatus(ID, FlashPtr, 0xFF) != FlashStatusReady && Count ) {
            Count--;
        }

        //
        // For some reasons in the FIB DVT, even the flash status is
        // ready but the actual data is not written to the chip.
        // We just have to poll the actual data and spin for a while
        // if it didn't get through.
        //

        Count = 0x100000;
        while ( FlashReadByte(FlashPtr) != 0xFF && Count ) {
            KeStallExecutionProcessor( 150000 );
            Count--;
        }

        //
        // Perform a blank check by compare all the content with 0xFF
        //

        Count = FlashSize( ID );
        FlashResetDevice();
        FlashPtr = FlashBaseAddress( ID );

        ASSERTMSG( "Size of flash ROM must be power of two", (Count & (Count-1)) == 0 );

        while ( Count ) {
            if ( FlashReadWord(FlashPtr) != 0xFFFF ) {
                DbgPrint( "FLASH: blank check failed (retries=%d)\n", Retries );
                break;
            }

            Count -= sizeof(WORD);
            FlashPtr += sizeof(WORD);
        }

        if ( Count == 0 ) {
            fBlank = TRUE;
            break;
        }

        FlashResetDevice();
    }

    return fBlank;
}

BOOL
FlashProgramImage(
    IN FlashDeviceID ID,
    IN PVOID ImageBuffer
    )
/*++

Routine Description:

    This routine programs the content of flash ROM with new image.  The flash
    ROM has to be blank first before programming.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

    ImageBuffer - Buffer contains the content to be programmed

Return Value:

    TRUE if operation success, FALSE otherwise

--*/
{
    BYTE b;
    PBYTE pb;
    PWORD pw;
    ULONG TimeOut;
    ULONG_PTR FlashPtr;
    BYTE TrueData, CurrData;
    BOOL Loop, fSuccess = FALSE;
    SIZE_T Count, Retries = 5;
    SIZE_T Again;

    while ( Retries-- ) {

        Count = FlashSize( ID );
        pb = (PBYTE)ImageBuffer;
        FlashPtr = FlashBaseAddress( ID );

        while ( Count-- ) {

            b = *pb++;

            if ( b != 0xFF ) {
                FlashWriteByte( 0xFFFF5555, 0xAA );
                FlashWriteByte( 0xFFFF2AAA, 0x55 );
                FlashWriteByte( 0xFFFF5555, 0xA0 );
                FlashWriteByte( FlashPtr, b );

                //
                // Wait until flash chip is ready for next command
                //

                Again = 0x100000;
                while ( FlashGetStatus(ID, FlashPtr, b) != FlashStatusReady && Again ) {
                    Again--;
                }

                //
                // For some reasons in the FIB DVT, even the flash status is
                // ready but the actual data is not written to the chip.
                // We just have to poll the actual data and spin for a while
                // if it didn't get through.
                //

                Again = 0x100000;
                while ( FlashReadByte(FlashPtr) != b && Again ) {
                    Again--;
                }
            }

            FlashPtr++;
        }

        //
        // Verify the content that just has been programmed
        //

        Count = FlashSize( ID );
        pw = (PWORD)ImageBuffer;
        FlashPtr = FlashBaseAddress( ID );
        FlashResetDevice();

        while ( Count ) {
            if ( FlashReadWord(FlashPtr) != *pw++ ) {
                DbgPrint( "FLASH: verification failed (retries=%d)\n", Retries );
                break;
            }

            Count -= sizeof(WORD);
            FlashPtr += sizeof(WORD);
        }

        if ( Count == 0 ) {
            fSuccess = TRUE;
            break;
        }

        FlashResetDevice();
    }

    return fSuccess;
}

UINT64
FASTCALL
FlashReadMSR(
    IN ULONG Address
    )
/*++

Routine Description:

    This routine reads Pentium III Model-Specific Register (MSR) specified
    by Address

Arguments:

    Address - Register address to read

Return Value:

    64-bit value of specified MSR

--*/
{
    __asm {
        rdmsr
    }
}

VOID
FASTCALL
FlashWriteMSR(
    IN ULONG Address,
    IN UINT64 Value
    )
/*++

Routine Description:

    This routine writes Pentium III Model-Specific Register (MSR) specified
    by Address

Arguments:

    Address - Register address to read

    Value - 64-bit value to be written

Return Value:

    None

--*/
{
    __asm {
        mov     eax, DWORD PTR [Value]
        mov     edx, DWORD PTR [Value+4]
        wrmsr
    }
}

#ifdef FLASH_TIME

UINT64
FlashReadTSC(
    VOID
    )
/*++

Routine Description:

    This routine reads processor's time-stamp counter.  The time-stamp counter
    is contained in a 64-bit MSR.  The high-order of 32 bits MSR are loaded
    into the EDX register, and the low-order 32 bits are loaded into the EAX
    register.  The processor increments the time-stamp counter MSR every
    clock cycle and resets it to 0 whenever the processor reset.

Arguments:

    None

Return Value:

    64-bit MSR of time-stamp counter

--*/
{
    __asm {
        rdtsc
    }
}

#endif // FLASH_TIME

VOID
FlashChangeRomCaching(
    BOOL EnableCache
    )
/*++

Routine Description:

    This routine searches for ROM cache setting in MTRR and disable it.  It is
    necessary to disable and flash cache before changing MTRR.  The following
    steps are recommended by Intel in order to change MTRR settings. Save CR4,
    disable and flush processor cache, flush TLB, disable MTRR, change MTRR
    settings, flush cache and TLB, enable MTRR and restore CR4

Arguments:

    EnableCache - TRUE to enable caching, FALSE to disable

Return Value:

    None

--*/
{
    ULONG MTRR;
    UINT64 v, MTRRdeftype;
    ULONG Base, Type;


    __asm {
        push    ecx
        push    edx

        _emit   0fh                 ; mov  eax, cr4
        _emit   20h
        _emit   0e0h

        push    eax                 ; save content of cr4

        mov     eax, cr0            ; disable and flush cache
        push    eax                 ; save content of cr0
        or      eax, 060000000H
        mov     cr0, eax
        wbinvd

        mov     eax, cr3            ; flush TLB
        mov     cr3, eax
    }

    //
    // Save the content of MTRR deftype and disable MTRR
    //

    MTRRdeftype = FlashReadMSR( 0x2FF );
    FlashWriteMSR( 0x2FF, 0 );

    for ( MTRR=0x200; MTRR<0x20F; MTRR+=2 ) {
        v = FlashReadMSR( MTRR );
        Base = (ULONG)((v >> 12) & 0xFFFFFF);
        Type = (BYTE)v;

        //
        // Set or reset valid bit according to cache enable flag
        //

        if ( Base >= (FLASH_BASE_ADDRESS >> 12) && Type != 0 ) {
            v = FlashReadMSR( MTRR+1 );
            v = EnableCache ? (v | 0x800) : (v & (~0x800));
            FlashWriteMSR( MTRR+1, v );
        }
    }

    __asm {
        wbinvd                      ; flush cache
        mov     eax, cr3            ; flush TLB
        mov     cr3, eax
    }

    //
    // Restore content of MTRR deftype, MTRR should be re-enabled
    //

    FlashWriteMSR( 0x2FF, MTRRdeftype );

    __asm {
        pop     eax                 ; restore cr0
        mov     cr0, eax

        pop     eax                 ; restore cr4

        _emit   0fh                 ; mov  cr4, eax
        _emit   22h
        _emit   0e0h

        pop     edx
        pop     ecx
    }
}

HRESULT
FlashKernelImage(
    IN  PVOID  ImageBuffer,
    IN  SIZE_T ImageSize,
    OUT LPSTR  szResp,
    IN  DWORD  cchResp
    )
{
#ifdef FLASH_TIME
    UINT64 ClockTick;
#endif

    FlashDeviceID ID;
    HRESULT hr = S_OK;

#ifdef FLASH_TIME
    ClockTick = FlashReadTSC();
#endif

    if ( IsBadReadPtr(ImageBuffer, ImageSize) || \
         IsBadWritePtr(szResp, cchResp) ) {
        return HRESULT_FROM_WIN32( ERROR_NOACCESS );
    }

    //
    // Map top 1MB of physical memory of ROM region (FFF00000-FFFFFFFF)
    //

    KernelRomBase = MmMapIoSpace( FLASH_BASE_ADDRESS, FLASH_REGION_SIZE,
                                  PAGE_READWRITE | PAGE_NOCACHE );

    if ( !KernelRomBase ) {
        _snprintf( szResp, cchResp, "unable to map i/o space" );
        return E_FAIL;
    }

    __asm cli

    XDBGWRN("RECOVERY", "FLASH: interrupts are now disabled" );

    //
    // Disable ROM caching
    //

    FlashChangeRomCaching( FALSE );

    ID = FlashDetectDevice();

    if ( ID == FlashUnknownDevice ) {
        _snprintf( szResp, cchResp, "Unknown flash device id" );
        hr = E_FAIL;
        goto cleanup;
    }

    if ( FlashSize(ID) != ImageSize ) {
        _snprintf( szResp, cchResp, "Invalid image size" );
        hr = E_FAIL;
        goto cleanup;
    }

    XDBGWRN("RECOVERY", "FLASH: erasing and blank checking..." );

    if ( !FlashEraseChip(ID) ) {
        _snprintf( szResp, cchResp, "Failed to erase flash chip" );
        hr = E_FAIL;
        goto cleanup;
    }

    XDBGWRN("RECOVERY", "FLASH: programming..." );

    if ( !FlashProgramImage(ID, ImageBuffer) ) {
        _snprintf( szResp, cchResp, "Failed to program kernel image (verify failed)" );
        hr = E_FAIL;
        goto cleanup;
    }

    XDBGWRN("RECOVERY", "FLASH: done" );

    if ( SUCCEEDED(hr) ) {
        _snprintf( szResp, cchResp, "Done, new image flashed" );
    }

    hr = S_OK;

cleanup:

    __asm sti

    XDBGWRN("RECOVERY", "FLASH: interrupts are now enabled" );

    MmUnmapIoSpace( KernelRomBase, FLASH_REGION_SIZE );

    //
    // Re-enable ROM caching as needed
    //

    FlashChangeRomCaching( TRUE );

#ifdef FLASH_TIME
    ClockTick = FlashReadTSC() - ClockTick;
    DbgPrint( "FLASH: elapsed time %I64u seconds\n", ClockTick / 733000000UI64 );
#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\recovery\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const CHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL,
            D3DLOCK_NOSYSLOCK | D3DLOCK_RAWDATA) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    PVOID pBits = Swizzler_GetUnswizzledBits(&lockRect, &desc);
    if (pBits == NULL)
    {
        assert(FALSE);
        pSurface->UnlockRect();
        return;
    }

    PVOID pBitsOld = lockRect.pBits;
    lockRect.pBits = pBits;

    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    lockRect.pBits = pBitsOld;
    Swizzler_SwizzleFromBits(pBits, &lockRect, &desc);

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree   
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rawx\volinfo.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    volinfo.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_QUERY_VOLUME_INFORMATION.

--*/

#include "rawx.h"

NTSTATUS
RawxQueryVolumeSizeInformation(
    IN PRAW_VOLUME_EXTENSION VolumeExtension,
    OUT PFILE_FS_SIZE_INFORMATION SizeInformation
    )
/*++

Routine Description:

    This routine fills the information structure with the volume size
    information for the supplied volume extension.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    SizeInformation - Specifies the buffer to receive the volume size
        information.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    DISK_GEOMETRY DiskGeometry;
    PARTITION_INFORMATION PartitionInformation;

    //
    // Get the drive geometry from the device.  Note that this doesn't work for
    // non-disk devices, but that's the way the old RAW file system worked as
    // well.  If geometry information is required for non-disk devices, then
    // use IOCTLs to talk to the target device.
    //

    status = IoSynchronousDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY,
        VolumeExtension->TargetDeviceObject, NULL, 0, &DiskGeometry,
        sizeof(DISK_GEOMETRY), NULL, FALSE);

    if (NT_SUCCESS(status)) {

        //
        // Get the partition information from the device.
        //

        status = IoSynchronousDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO,
            VolumeExtension->TargetDeviceObject, NULL, 0,
            &PartitionInformation, sizeof(PARTITION_INFORMATION), NULL, FALSE);

        if (NT_SUCCESS(status)) {

            SizeInformation->TotalAllocationUnits.QuadPart =
                PartitionInformation.PartitionLength.QuadPart /
                DiskGeometry.BytesPerSector;
            SizeInformation->AvailableAllocationUnits =
                SizeInformation->TotalAllocationUnits;
            SizeInformation->BytesPerSector = DiskGeometry.BytesPerSector;
            SizeInformation->SectorsPerAllocationUnit = 1;
        }
    }

    return status;
}

NTSTATUS
RawxFsdQueryVolumeInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle
    IRP_MJ_QUERY_VOLUME_INFORMATION requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PRAW_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    ULONG BytesWritten;
    PFILE_FS_DEVICE_INFORMATION DeviceInformation;
    PFILE_FS_ATTRIBUTE_INFORMATION AttributeInformation;

    VolumeExtension = (PRAW_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    RawxAcquireVolumeMutexShared(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (VolumeExtension->Dismounted) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Clear the output buffer.
    //

    RtlZeroMemory(Irp->UserBuffer, IrpSp->Parameters.QueryVolume.Length);

    //
    // Dispatch the information class function.
    //

    status = STATUS_SUCCESS;

    switch (IrpSp->Parameters.QueryVolume.FsInformationClass) {

        case FileFsVolumeInformation:
            NOTHING;
            BytesWritten = FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION, VolumeLabel);
            break;

        case FileFsSizeInformation:
            status = RawxQueryVolumeSizeInformation(VolumeExtension,
                (PFILE_FS_SIZE_INFORMATION)Irp->UserBuffer);
            BytesWritten = sizeof(FILE_FS_SIZE_INFORMATION);
            break;

        case FileFsDeviceInformation:
            DeviceInformation = (PFILE_FS_DEVICE_INFORMATION)Irp->UserBuffer;
            DeviceInformation->DeviceType =
                VolumeExtension->TargetDeviceObject->DeviceType;
            DeviceInformation->Characteristics = 0;
            BytesWritten = sizeof(FILE_FS_DEVICE_INFORMATION);
            break;

        case FileFsAttributeInformation:
            AttributeInformation =
                (PFILE_FS_ATTRIBUTE_INFORMATION)Irp->UserBuffer;
            AttributeInformation->FileSystemNameLength = sizeof(OCHAR) * 4;

            if (IrpSp->Parameters.QueryVolume.Length <
                FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName) +
                sizeof(OCHAR) * 4) {
                BytesWritten = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION,
                    FileSystemName);
                status = STATUS_BUFFER_OVERFLOW;
            } else {
                RtlCopyMemory(AttributeInformation->FileSystemName, OTEXT("RAWX"),
                    sizeof(OCHAR) * 4);
                BytesWritten = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION,
                    FileSystemName) + sizeof(OCHAR) * 4;
            }
            break;

        default:
            BytesWritten = 0;
            status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Fill in the number of bytes that we wrote to the user's buffer.
    //

    Irp->IoStatus.Information = BytesWritten;

    //
    // Check that we didn't overflow the user's buffer.  The I/O manager does
    // the initial check to make sure there's enough space for the static
    // structure for a given information class, but we might overflow the buffer
    // when copying in the variable length file name.
    //

    ASSERT(Irp->IoStatus.Information <= IrpSp->Parameters.QueryVolume.Length);

CleanupAndExit:
    RawxReleaseVolumeMutex(VolumeExtension);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\recovery\imagefile.cpp ===
#include "recovpch.h"
#include "imagefile.h"

//////////////////////////////////////////////////////////////////////
// .BMP File format functions

BitmapFile::BitmapFile() {
	xpos = 0;
	ypos = 0;

	// Initialize Bitmap File Header
	Type	  = 19778;
	FileSize  = 192056;	//check this
	Reserved1 = 0;
	Reserved2 = 0;
	OffBits	  = 54;	//check this

	// Initialize Bitmap Info Header
	InfoSize	  = 40;
	Width		  = 0;
	Height		  = 0;
	Planes		  = 1;
	BitCount	  = 24;
	Compression	  = 0;
	SizeImage	  = 0;
	XPelsPerMeter = 2834;
	YPelsPerMeter = 2834;
	ClrUsed		  = 0;
	ClrImportant  = 0;
}

BitmapFile::~BitmapFile() {
    if( pixels )
    {
	    delete [] pixels;
        pixels = NULL;
    }
}

void BitmapFile::write(char *file, int imageWidth, int imageHeight, DWORD *pixels) {
	FILE *output;

	Width     = imageWidth;
	Height	  = imageHeight;
	ImageSize = imageWidth * imageHeight;

	//open the new bitmap file
	output = fopen(file, "wb");

	// Write the Bitmap File header information
	fwrite(&Type, sizeof(WORD), 1, output);
	fwrite(&FileSize, sizeof(DWORD), 1, output);
	fwrite(&Reserved1, sizeof(WORD), 1, output);
	fwrite(&Reserved2, sizeof(WORD), 1, output);
	fwrite(&OffBits, sizeof(DWORD), 1, output);

	//Write the Bitmap Info header information
	fwrite(&InfoSize, sizeof(DWORD), 1, output);
	fwrite(&Width, sizeof(DWORD), 1, output);
	fwrite(&Height, sizeof(DWORD), 1, output);
	fwrite(&Planes, sizeof(WORD), 1, output);
	fwrite(&BitCount, sizeof(WORD), 1, output);
	fwrite(&Compression, sizeof(DWORD), 1, output);
	fwrite(&SizeImage, sizeof(DWORD), 1, output);
	fwrite(&XPelsPerMeter, sizeof(DWORD), 1, output);
	fwrite(&YPelsPerMeter, sizeof(DWORD), 1, output);
	fwrite(&ClrUsed, sizeof(DWORD), 1, output);
	fwrite(&ClrImportant, sizeof(DWORD), 1, output);

	fclose(output);
}

int BitmapFile::imagesize(char *file) {
	FILE *input;
	input = fopen(file, "rb");

	// Read the Bitmap File header information
	fread(&Type, sizeof(WORD), 1, input);
	fread(&FileSize, sizeof(DWORD), 1, input);
	fread(&Reserved1, sizeof(WORD), 1, input);
	fread(&Reserved2, sizeof(WORD), 1, input);
	fread(&OffBits, sizeof(DWORD), 1, input);

	//Read the Bitmap Info header information
	fread(&InfoSize, sizeof(DWORD), 1, input);
	fread(&Width, sizeof(DWORD), 1, input);
	fread(&Height, sizeof(DWORD), 1, input);

	fclose(input);

	return (Width * Height);
}

void BitmapFile::read(int xloc, int yloc, char *file) {
	FILE *input;
	xpos = xloc;
	ypos = yloc;

	//open the new bitmap file
	input = fopen(file, "rb");
    if( !input )
    {
        XDBGWRN( APP_TITLE_NAME_A, "BitmapFile::read():fopen failed!! - '%s'\n", file );
        return;
    }

	// Read the Bitmap File header information
	fread(&Type, sizeof(WORD), 1, input);
	fread(&FileSize, sizeof(DWORD), 1, input);
	fread(&Reserved1, sizeof(WORD), 1, input);
	fread(&Reserved2, sizeof(WORD), 1, input);
	fread(&OffBits, sizeof(DWORD), 1, input);

	//Read the Bitmap Info header information
	fread(&InfoSize, sizeof(DWORD), 1, input);
	fread(&Width, sizeof(DWORD), 1, input);
	fread(&Height, sizeof(DWORD), 1, input);
	fread(&Planes, sizeof(WORD), 1, input);
	fread(&BitCount, sizeof(WORD), 1, input);
	fread(&Compression, sizeof(DWORD), 1, input);
	fread(&SizeImage, sizeof(DWORD), 1, input);
	fread(&XPelsPerMeter, sizeof(DWORD), 1, input);
	fread(&YPelsPerMeter, sizeof(DWORD), 1, input);
	fread(&ClrUsed, sizeof(DWORD), 1, input);
	fread(&ClrImportant, sizeof(DWORD), 1, input);

	ImageSize = Width * Height;
	pixels = new DWORD[ImageSize];

	float remainer = (float)Width / 4;
	float delta = remainer - (int)remainer;

	BYTE blue, green, red;
	for(int y = (int)Height - 1; y >= 0 ; y--)
	{
		for(int x = 0; x < (int)Width; x++)
		{
			fread(&blue, sizeof(BYTE), 1, input);
			fread(&green, sizeof(BYTE), 1, input);
			fread(&red, sizeof(BYTE), 1, input);
			int position = (y * (int)Width) + x;
			pixels[position] = (0xff << 24) | (red << 16) | (green << 8) | (blue);
		}
		
		//account for the extra bytes in bitmap files
		if(delta == 0.25f) fseek(input, 1, SEEK_CUR);
		else if(delta == 0.50f) fseek(input, 2, SEEK_CUR);
		else if(delta == 0.75f) fseek(input, 3, SEEK_CUR);
	}

	fclose(input);
}

bool BitmapFile::render(IDirect3DDevice8 *d3dDevice) {
	HRESULT hr;
	IDirect3DSurface8 *backBuffer;
	D3DLOCKED_RECT backBufferInfo;
	hr = d3dDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &backBuffer);
	if( FAILED( hr ))
	{
		XDBGWRN( APP_TITLE_NAME_A, "BitmapFile::render():Failed to get the backbuffer\n" );
		return false;
	}

	RECT container;
	container.top = ypos;
	container.left = xpos;
	container.bottom = ypos + Height;
	container.right = xpos + Width;	

	hr = backBuffer->LockRect(&backBufferInfo, &container, D3DLOCK_TILED);
	if( FAILED( hr ))
	{
		XDBGWRN( APP_TITLE_NAME_A, "BitmapFile::render():Failed to lock the backbuffer\n" );
        backBuffer->Release();
		return false;
	}

	int destPitch = backBufferInfo.Pitch;
	int sourcePitch = Width * 4;
	BYTE *s = (BYTE*)pixels;
	BYTE *p = (BYTE*)backBufferInfo.pBits;
	for(int y = 0; y < (int)Height; y++)
	{
		memcpy(p, s, sourcePitch);
		s += sourcePitch;
		p += destPitch;
	}

	backBuffer->UnlockRect();
    backBuffer->Release();
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\recovery\recovstr.h ===
#pragma once

#ifdef HDSETUPAPP

static const PWSTR RStrings[] =
{
    L"[I] Xbox HD Setup version %hs (0x%02x)",
    L"Xbox HD Setup Version %hs",
    L"Xbox HD Setup has failed", L"because of an unexpected error (0x%08x).",
    L"because this Xbox is no longer supported.",
    L"This CD must be in the drive at power up.",
    L"Press any gamepad button to begin HD Setup.", L"(Warning: Hard disk will be erased.)",
    L"Lock the HD?", L"(Y button: lock, Any other button: don't lock)",
    L"Please wait.  Updating the ROM...", L"(Do not reboot or power off!)",
    L"Preparing the hard disk...",
    L"Copying files to the hard disk...",
    L"Please eject and remove the HD Setup CD.",
    L"Please remove the HD Setup CD and",
    L"press any gamepad button to reboot.",
};

#else  // HDSETUPAPP

static const PWSTR RStrings[] =
{
#ifdef ONLINEBETA
    L"Xbox Betakit version %hs (0x%02x)",
    L"Xbox Betakit version %hs (0x%02x)",
#else
    L"[Internal] Xbox version %hs (0x%02x)",
    L"Xbox version %hs",
#endif
    L"Xbox recovery has failed", L"because of an unexpected error (0x%08x).",
    L"because this Xbox is no longer supported.",
    L"This CD must be in the drive at power up.",
    L"Press any gamepad button to begin recovery.", L"(Warning: Hard disk will be erased.)",
    L"ROM is current.  Update anyway?", L"(Y: update, any other button: don't update)",
    L"A newer version of the ROM is available", L"Please run full recovery (any button to continue)",
    L"Recover as a retail Xbox or a dev kit Xbox?", L"(Y button: retail, Any other button: dev kit)",
    L"Please wait.  Updating the ROM...", L"(Do not reboot or power off!)",
    L"Preparing the hard disk...",
    L"Copying files to the hard disk...",
    L"Please eject and remove the recovery CD.",
    L"Please remove the recovery CD and",
    L"press any gamepad button to reboot.",
};

#endif // HDSETUPAPP

enum RECOVSTR_INDEX
{
    RS_BUILD_NUMBER_FORMAT_INTERNAL = 0,
    RS_BUILD_NUMBER_FORMAT,
    RS_FAILURE_LINE1,
    RS_FAILURE_LINE2_FORMAT,
    RS_FAILURE_LINE2_OLD_BOX,
    RS_FAILURE_LINE2_WARM_BOOT,
    RS_GAMEPAD_BEGIN_LINE1,
    RS_GAMEPAD_BEGIN_LINE2,
#ifndef HDSETUPAPP
    RS_OVERWRITEROM_LINE1,
    RS_OVERWRITEROM_LINE2,
    RS_NEWERROM_LINE1,
    RS_NEWERROM_LINE2,
#endif
    RS_RETAIL_LINE1,
    RS_RETAIL_LINE2,
    RS_FLASH_LINE1,
    RS_FLASH_LINE2,
    RS_PREPARING,
    RS_COPYING,
    RS_GAMEPAD_END_RETAIL,
    RS_GAMEPAD_END_LINE1,
    RS_GAMEPAD_END_LINE2,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\recovery\imagefile.h ===
#ifndef __ImageFile_H
#define __ImageFile_H

#include "constants.h"

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;

class BitmapFile {
private:
	int ImageSize;
	DWORD *pixels;
	int xpos, ypos;

	// Bitmap File Header
	WORD Type;
	DWORD FileSize;
	WORD Reserved1;
	WORD Reserved2;
	DWORD OffBits;
	
	// Bitmap Info Header
	DWORD InfoSize;
	DWORD Width;
	DWORD Height;
	WORD Planes;
	WORD BitCount;
	DWORD Compression;
	DWORD SizeImage;
	DWORD XPelsPerMeter;
	DWORD YPelsPerMeter;
	DWORD ClrUsed;
	DWORD ClrImportant;

public:
	BitmapFile(void);
	~BitmapFile(void);
	
	void write(char *file, int imageWidth, int imageHeight, DWORD *pixels);
	int imagesize(char *file);
	void read(int xloc, int yloc, char *file);
	bool render(IDirect3DDevice8 *d3dDevice);

    DWORD GetWidth() { return Width; };         // Get the Width of the bitmap file
    DWORD GetHeight() { return Height; };       // Get the Height of the bitmap file
    int   GetXPos() { return xpos; };           // Get the X Position of the bitmap file
    int   GetYPos() { return ypos; };           // Get the Y Position of the bitmap file
    void  SetXPos( int x ) { xpos = x; };       // Set the X Position of the bitmap file
    void  SetYPos( int y ) { ypos = y; };       // Set the Y Position of the bitmap file
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\assert.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    assert.c

Abstract:

    This module implements the RtlAssert function that is referenced by the
    debugging version of the ASSERT macro defined in NTDEF.H

Author:

    Steve Wood (stevewo) 03-Oct-1989

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <zwapi.h>
#include "stdio.h"

NTSTATUS
PsTerminateSystemThread(
    IN NTSTATUS ExitStatus
    );

NTSTATUS
DebugService(
	ULONG ServiceClass,
	PVOID Arg1,
	PVOID Arg2
	);

//
// RtlAssert is not called unless the caller is compiled with DBG non-zero
// therefore it does no harm to always have this routin in the kernel.  
// This allows checked drivers to be thrown on the system and have their
// asserts be meaningful.
//

#define RTL_ASSERT_ALWAYS_ENABLED 1

VOID
RtlAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{
#if DBG || RTL_ASSERT_ALWAYS_ENABLED
    char Response;
    CONTEXT Context;
	STRING String;
	UCHAR Buffer[512];

#ifndef BLDR_KERNEL_RUNTIME
    RtlCaptureContext( &Context );
#endif

	sprintf(Buffer, "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
                  Message ? Message : "",
                  FailedAssertion,
                  FileName,
                  LineNumber
				  );
    RtlInitAnsiString( &String, Buffer);

    while (TRUE) {
		Response = (CHAR)DebugService(BREAKPOINT_RTLASSERT, &String, 0);
        switch (Response) {
            case 'B':
            case 'b':
                DbgPrint( "Execute '!cxr %p' to dump context\n", &Context);
                DbgBreakPoint();
                break;

            case 'I':
            case 'i':
                return;

            case 'T':
            case 't':
                PsTerminateSystemThread( STATUS_UNSUCCESSFUL );
                break;
            }
        }

    DbgBreakPoint();
#endif
}

VOID
RtlRip(
    IN PVOID ApiName,
    IN PVOID Expression,
    IN PVOID Message
    )
{
#if DBG || RTL_ASSERT_ALWAYS_ENABLED
    UCHAR Buffer[512];
    char Colon;
    char OpenParen;
    char CloseParen;

    if(NULL == Message)
        Message = Expression != NULL ? "failed" : "unexpected failure";
    Colon = ApiName != NULL ? ':' : ' ';
    if(NULL != Expression) {
        OpenParen = '(';
        CloseParen = ')';
    } else
        OpenParen = CloseParen = ' ';

    _snprintf(Buffer, sizeof Buffer, "%s%c %c%s%c %s", ApiName ? ApiName : "",
        Colon, OpenParen, Expression ? Expression : "", CloseParen, Message);
    Buffer[sizeof Buffer - 1] = 0;
    DebugService(BREAKPOINT_RIP, Buffer, 0);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\recovery\recovpch.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <stdio.h>
#include <xtl.h>
#include "ntos.h"
#include <scsi.h>
#include <stdio.h>
#include <xdbg.h>

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
#define CONSTANT_OBJECT_STRING(s)   { sizeof( s ) - sizeof( OCHAR ), sizeof( s ), s }

#ifdef HDSETUPAPP
#define RECOVERYAPP 1
#define RECOVERYNOFLASH 1
#endif // HDSETUPAPP

#ifdef RECOVERYAPP

#define XFONT_TRUETYPE
#include <xfont.h>

HRESULT
FlashKernelImage(
    IN  PVOID  ImageBuffer,
    IN  SIZE_T ImageSize,
    OUT LPSTR  szResp,
    IN  DWORD  cchResp
    );

#endif // RECOVERYAPP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\cnvint.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    cnvint.c

Abstract:

    Text to integer and integer to text converion routines.

Author:

    Steve Wood (stevewo) 23-Aug-1990

Revision History:

--*/

#include <ntrtlp.h>

const CHAR RtlpIntegerChars[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                                 '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

const WCHAR RtlpIntegerWChars[] = { L'0', L'1', L'2', L'3', L'4', L'5',
                                    L'6', L'7', L'8', L'9', L'A', L'B',
                                    L'C', L'D', L'E', L'F' };

NTSTATUS
RtlIntegerToChar (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PSZ String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    CHAR Result[ 33 ], *s;
    ULONG Shift, Mask, Digit, Length;

    Shift = 0;
    switch( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:    Base = 10;
        case 10:    Shift = 0;  break;
        default:    return( STATUS_INVALID_PARAMETER );
        }

    if (Shift != 0) {
        Mask = 0xF >> (4 - Shift);
        }

    s = &Result[ 32 ];
    *s = '\0';
    do {
        if (Shift != 0) {
            Digit = Value & Mask;
            Value >>= Shift;
            }
        else {
            Digit = Value % Base;
            Value = Value / Base;
            }

        *--s = RtlpIntegerChars[ Digit ];
    } while (Value != 0);

    Length = (ULONG) (&Result[ 32 ] - s);
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *--s = '0';
            Length++;
            }
        }

    if ((LONG)Length > OutputLength) {
        return( STATUS_BUFFER_OVERFLOW );
        }
    else {
        try {
            RtlMoveMemory( String, s, Length );

            if ((LONG)Length < OutputLength) {
                String[ Length ] = '\0';
                }
            }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            return( GetExceptionCode() );
            }

        return( STATUS_SUCCESS );
        }
}


NTSTATUS
RtlCharToInteger (
    IN PCSZ String,
    IN ULONG Base OPTIONAL,
    OUT PULONG Value
    )
{
    CHAR c, Sign;
    ULONG Result, Digit, Shift;

    while ((Sign = *String++) <= ' ') {
        if (!*String) {
            String--;
            break;
            }
        }

    c = Sign;
    if (c == '-' || c == '+') {
        c = *String++;
        }

    if (!ARGUMENT_PRESENT( (ULONG_PTR)(Base) )) {
        Base = 10;
        Shift = 0;
        if (c == '0') {
            c = *String++;
            if (c == 'x') {
                Base = 16;
                Shift = 4;
                }
            else
            if (c == 'o') {
                Base = 8;
                Shift = 3;
                }
            else
            if (c == 'b') {
                Base = 2;
                Shift = 1;
                }
            else {
                String--;
                }

            c = *String++;
            }
        }
    else {
        switch( Base ) {
            case 16:    Shift = 4;  break;
            case  8:    Shift = 3;  break;
            case  2:    Shift = 1;  break;
            case 10:    Shift = 0;  break;
            default:    return( STATUS_INVALID_PARAMETER );
            }
        }

    Result = 0;
    while (c) {
        if (c >= '0' && c <= '9') {
            Digit = c - '0';
            }
        else
        if (c >= 'A' && c <= 'F') {
            Digit = c - 'A' + 10;
            }
        else
        if (c >= 'a' && c <= 'f') {
            Digit = c - 'a' + 10;
            }
        else {
            break;
            }

        if (Digit >= Base) {
            break;
            }

        if (Shift == 0) {
            Result = (Base * Result) + Digit;
            }
        else {
            Result = (Result << Shift) | Digit;
            }

        c = *String++;
        }

    if (Sign == '-') {
        Result = (ULONG)(-(LONG)Result);
        }

    try {
        *Value = Result;
        }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        return( GetExceptionCode() );
        }

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlUnicodeStringToInteger (
    IN PUNICODE_STRING String,
    IN ULONG Base OPTIONAL,
    OUT PULONG Value
    )
{
    PCWSTR s;
    WCHAR c, Sign;
    ULONG nChars, Result, Digit, Shift;

    s = String->Buffer;
    nChars = String->Length / sizeof( WCHAR );
    while (nChars-- && (Sign = *s++) <= ' ') {
        if (!nChars) {
            Sign = UNICODE_NULL;
            break;
            }
        }

    c = Sign;
    if (c == L'-' || c == L'+') {
        if (nChars) {
            nChars--;
            c = *s++;
            }
        else {
            c = UNICODE_NULL;
            }
        }

    if (!ARGUMENT_PRESENT( (ULONG_PTR)Base )) {
        Base = 10;
        Shift = 0;
        if (c == L'0') {
            if (nChars) {
                nChars--;
                c = *s++;
                if (c == L'x') {
                    Base = 16;
                    Shift = 4;
                    }
                else
                if (c == L'o') {
                    Base = 8;
                    Shift = 3;
                    }
                else
                if (c == L'b') {
                    Base = 2;
                    Shift = 1;
                    }
                else {
                    nChars++;
                    s--;
                    }
                }

            if (nChars) {
                nChars--;
                c = *s++;
                }
            else {
                c = UNICODE_NULL;
                }
            }
        }
    else {
        switch( Base ) {
            case 16:    Shift = 4;  break;
            case  8:    Shift = 3;  break;
            case  2:    Shift = 1;  break;
            case 10:    Shift = 0;  break;
            default:    return( STATUS_INVALID_PARAMETER );
            }
        }

    Result = 0;
    while (c != UNICODE_NULL) {
        if (c >= L'0' && c <= L'9') {
            Digit = c - L'0';
            }
        else
        if (c >= L'A' && c <= L'F') {
            Digit = c - L'A' + 10;
            }
        else
        if (c >= L'a' && c <= L'f') {
            Digit = c - L'a' + 10;
            }
        else {
            break;
            }

        if (Digit >= Base) {
            break;
            }

        if (Shift == 0) {
            Result = (Base * Result) + Digit;
            }
        else {
            Result = (Result << Shift) | Digit;
            }

        if (!nChars) {
            break;
            }
        nChars--;
        c = *s++;
        }

    if (Sign == L'-') {
        Result = (ULONG)(-(LONG)Result);
        }

    try {
        *Value = Result;
        }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        return( GetExceptionCode() );
        }

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlIntegerToUnicode (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PWSTR String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WCHAR Result[ 33 ], *s;
    ULONG Shift, Mask, Digit, Length;

    Shift = 0;
    switch( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:    Base = 10;
        case 10:    Shift = 0;  break;
        default:    return( STATUS_INVALID_PARAMETER );
        }

    if (Shift != 0) {
        Mask = 0xF >> (4 - Shift);
        }

    s = &Result[ 32 ];
    *s = L'\0';
    do {
        if (Shift != 0) {
            Digit = Value & Mask;
            Value >>= Shift;
            }
        else {
            Digit = Value % Base;
            Value = Value / Base;
            }

        *--s = RtlpIntegerWChars[ Digit ];
    } while (Value != 0);

    Length = (ULONG) (&Result[ 32 ] - s);
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *--s = L'0';
            Length++;
            }
        }

    if ((LONG)Length > OutputLength) {
        return( STATUS_BUFFER_OVERFLOW );
        }
    else {
        try {
            RtlMoveMemory( String, s, Length * sizeof( WCHAR ));

            if ((LONG)Length < OutputLength) {
                String[ Length ] = L'\0';
                }
            }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            return( GetExceptionCode() );
            }

        return( STATUS_SUCCESS );
        }
}


NTSTATUS
RtlIntegerToUnicodeString (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    )
{
    NTSTATUS Status;
    UCHAR ResultBuffer[ 16 ];
    ANSI_STRING AnsiString;

    Status = RtlIntegerToChar( Value, Base, sizeof( ResultBuffer ), ResultBuffer );
    if (NT_SUCCESS( Status )) {
        AnsiString.Buffer = ResultBuffer;
        AnsiString.MaximumLength = sizeof( ResultBuffer );
        AnsiString.Length = (USHORT)strlen( ResultBuffer );
        Status = RtlAnsiStringToUnicodeString( String, &AnsiString, FALSE );
        }

    return( Status );
}


NTSTATUS
RtlLargeIntegerToChar (
    IN PLARGE_INTEGER Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PSZ String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    CHAR Result[ 100 ], *s;
    ULONG Shift, Mask, Digit, Length;

    Shift = 0;
    switch( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:
        case 10:    Shift = 0;  break;
        default:    return( STATUS_INVALID_PARAMETER );
        }

    if (Shift != 0) {
        Mask = 0xF >> (4 - Shift);
        }

    s = &Result[ 99 ];
    *s = '\0';
    if (Shift != 0) {
        ULONG LowValue,HighValue,HighShift,HighMask;

        LowValue = Value->LowPart;
        HighValue = Value->HighPart;
        HighShift = Shift - (sizeof(ULONG) % Shift);
        HighMask = 0xF >> (4 - HighShift);
        do {
            Digit = LowValue & Mask;
            LowValue = (LowValue >> Shift) | ((HighValue & HighMask) << (sizeof(ULONG) - HighShift));
            HighValue = HighValue >> HighShift;
            *--s = RtlpIntegerChars[ Digit ];
        } while ((LowValue | HighValue) != 0);
    } else {
        LARGE_INTEGER TempValue=*Value;
        do {
            TempValue = RtlExtendedLargeIntegerDivide(TempValue,Base,&Digit);
            *--s = RtlpIntegerChars[ Digit ];
        } while (TempValue.HighPart != 0 || TempValue.LowPart != 0);
    }

    Length = (ULONG)(&Result[ 99 ] - s);
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *--s = '0';
            Length++;
            }
        }

    if ((LONG)Length > OutputLength) {
        return( STATUS_BUFFER_OVERFLOW );
        }
    else {
        try {
            RtlMoveMemory( String, s, Length );

            if ((LONG)Length < OutputLength) {
                String[ Length ] = '\0';
                }
            }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            return( GetExceptionCode() );
            }

        return( STATUS_SUCCESS );
        }
}

NTSTATUS
RtlLargeIntegerToUnicode (
    IN PLARGE_INTEGER Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PWSTR String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WCHAR Result[ 100 ], *s;
    ULONG Shift, Mask, Digit, Length;

    Shift = 0;
    switch( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:
        case 10:    Shift = 0;  break;
        default:    return( STATUS_INVALID_PARAMETER );
        }

    if (Shift != 0) {
        Mask = 0xF >> (4 - Shift);
        }

    s = &Result[ 99 ];
    *s = L'\0';
    if (Shift != 0) {
        ULONG LowValue,HighValue,HighShift,HighMask;

        LowValue = Value->LowPart;
        HighValue = Value->HighPart;
        HighShift = Shift - (sizeof(ULONG) % Shift);
        HighMask = 0xF >> (4 - HighShift);
        do {
            Digit = LowValue & Mask;
            LowValue = (LowValue >> Shift) | ((HighValue & HighMask) << (sizeof(ULONG) - HighShift));
            HighValue = HighValue >> HighShift;
            *--s = RtlpIntegerWChars[ Digit ];
        } while ((LowValue | HighValue) != 0);
    } else {
        LARGE_INTEGER TempValue=*Value;
        do {
            TempValue = RtlExtendedLargeIntegerDivide(TempValue,Base,&Digit);
            *--s = RtlpIntegerWChars[ Digit ];
        } while (TempValue.HighPart != 0 || TempValue.LowPart != 0);
    }

    Length = (ULONG)(&Result[ 99 ] - s);
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *--s = L'0';
            Length++;
            }
        }

    if ((LONG)Length > OutputLength) {
        return( STATUS_BUFFER_OVERFLOW );
        }
    else {
        try {
            RtlMoveMemory( String, s, Length * sizeof( WCHAR ));

            if ((LONG)Length < OutputLength) {
                String[ Length ] = L'\0';
                }
            }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            return( GetExceptionCode() );
            }

        return( STATUS_SUCCESS );
        }
}

NTSTATUS
RtlInt64ToUnicodeString (
    IN ULONGLONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    )

{

    NTSTATUS Status;
    UCHAR ResultBuffer[32];
    ANSI_STRING AnsiString;
    LARGE_INTEGER Temp;

    Temp.QuadPart = Value;
    Status = RtlLargeIntegerToChar(&Temp,
                                   Base,
                                   sizeof(ResultBuffer),
                                   ResultBuffer);

    if (NT_SUCCESS(Status)) {
        AnsiString.Buffer = ResultBuffer;
        AnsiString.MaximumLength = sizeof(ResultBuffer);
        AnsiString.Length = (USHORT)strlen(ResultBuffer);
        Status = RtlAnsiStringToUnicodeString(String, &AnsiString, FALSE);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\recovery\recovery.cpp ===
#include "recovpch.h"
#include "recovstr.h"
#include "xboxverp.h"
#include "xconfig.h"
#include "xboxp.h"
#include "xdisk.h"
#include "smcdef.h"
#include <xonlinep.h>


#ifdef HDSETUPAPP
#define HD_KEY "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"

typedef struct
{
    UINT FirstSector;
    UINT LastSector;
} HD_SECTORRANGE, *PHD_SECTORRANGE;

//
// Sector ranges used by the greystone duplicator when hard drives are imaged.
// These should be zero initialized prior to preparing a hard drive image.
//

HD_SECTORRANGE HardDriveSectorRanges[] =
{
    { 0x00000000, 0x000003FF }, // (reserved sectors)
    { 0x00465400, 0x0055F3FF }, // (dash partition)
    { 0x0055F400, 0x00567D97 }, // (data partition + 16 megabytes of files)
    { 0, 0 }
};

#endif // HDSETUPAPP

#ifdef RECOVERYAPP
#include "xboxvideo.h"
#include "imagefile.h"
#include "xcrypt.h"
#endif // RECOVERYAPP

#ifdef DASHLIB
#define RECOVERYNOFLASH 1
#endif // DASHLIB

#ifndef RECOVERYNOFLASH

#define ROM_SIZE                    (1024 * 1024)
#define ROM_VERSION_OFFSET          30 // In DWORDs (0x78 is the absolute offset)
#define ROM_VERSION_BYTE_OFFSET     0x78
#define ROM_VERSION_KDDELAY_FLAG    0x80000000
#define ROM_FLASH_RETRIES           25

//
// Lowest possible base address of flash ROM and region size
//

#define FLASH_BASE_ADDRESS      0xFFF00000
#define FLASH_REGION_SIZE       (0xFFFFFFFF-FLASH_BASE_ADDRESS-1)

#define FlashReadByte(a) \
    (*(PBYTE)((ULONG_PTR)RomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS))
#define FlashReadUlong(a) \
    (*(PULONG)((ULONG_PTR)RomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS))

#endif // ! RECOVERYNOFLASH

#define ZERO_KEY "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"

#ifdef RECOVERYAPP

#define QUICK_FORMAT TRUE

#endif // RECOVERYAPP

#ifdef DASHLIB

#define QUICK_FORMAT FALSE

#endif // DASHLIB

extern "C"
{
UCHAR
FASTCALL
RtlFindFirstSetRightMember(
    IN ULONG Set
    );

BOOL
WINAPI
XapiFormatFATVolume(
    POBJECT_STRING pcVolume
    );

#ifdef RECOVERYAPP

ULONG g_InitTableVer = 0;
BOOL g_fInternalCD;

#ifdef RECOVERY_KERNEL_VER
USHORT RecoveryVersion = RECOVERY_KERNEL_VER;
#else
USHORT RecoveryVersion = VER_PRODUCTBUILD;
#endif

extern DWORD D3D__AvInfo;

#endif // RECOVERYAPP

#ifdef DASHLIB

typedef VOID (CALLBACK *PFNRECPROGRESSCALLBACK)(UINT uPercent, ULONG_PTR Context);

ULONG WINAPI DashRecovery(PFNRECPROGRESSCALLBACK pfnCallback, ULONG_PTR Context);

#endif // DASHLIB

}

#ifdef RECOVERYAPP

ULONG g_FilesCopied = 0;

#if defined(ONLINEBETA) || defined(HDSETUPAPP)
#define APPROX_FILE_COUNT   150
#else
#define APPROX_FILE_COUNT   350
#endif

const POSTR g_RootDirExceptions[] =
{
    OTEXT("default.xbe"),
#if !defined(RECOVERYNOFLASH) || defined(HDSETUPAPP)
    OTEXT("xboxrom.bin"),
#endif // !defined(RECOVERYNOFLASH) || defined(HDSETUPAPP)
    OTEXT("xboxrom_dvt4.bin"),
    OTEXT("xboxrom_qt.bin"),
#ifdef ONLINEBETA
	OTEXT("xboxrom_beta.bin"),
	OTEXT("xbdm.dll"),
	OTEXT("beta.dat"),
#endif
    OTEXT("RETAIL"),
    OTEXT("RECMEDIA"),
    OTEXT("XDASH")
};

const POSTR g_RetailDashExceptions[] =
{
    OTEXT("3dinfo"),
    OTEXT("data"),
    OTEXT("media"),
    OTEXT("menus"),
    OTEXT("sounds"),
    OTEXT("xboxdash.xbe"),
    OTEXT("xshell.xbe"),
    OTEXT("dvdkeyd.bin")
};

CXBoxVideo* g_pVideo;
BitmapFile* g_pBackgroundBitmap;

#endif // RECOVERYAPP

COBJECT_STRING DVDDevice =         CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Cdrom0") );
COBJECT_STRING PrimaryHarddisk =   CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\partition0") );
COBJECT_STRING HdPartition1 =      CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\partition1") );
COBJECT_STRING HdPartition2 =      CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\partition2") );
COBJECT_STRING CDrive =            CONSTANT_OBJECT_STRING( OTEXT("\\??\\C:") );
COBJECT_STRING YDrive =            CONSTANT_OBJECT_STRING( OTEXT("\\??\\Y:") );

#define DASHBOARD_PARTITION_NUMBER 2

static const CHAR HdPartitionX[] = "\\Device\\Harddisk0\\partition%d";

#if defined(RECOVERYAPP) && !defined(HDSETUPAPP)

//
// Functions for dealing with the encrypted section of the EEPROM
//

//
// The EEPROM encrypted section is unencrypted if the confounder field is all 0's
//
inline BOOL IsEEPROMEncryptedSectionUnencrypted(const XBOX_ENCRYPTED_SETTINGS* encryptedSection)
{
    const UCHAR* conf = encryptedSection->Confounder;
    for (INT i=0; i < 8; i++)
        if (conf[i] != 0) return FALSE;
    return TRUE;
}

//
// Decrypted the encrypted section of the EEPROM
//
static DWORD DecryptEEPROMEncryptedSection(XBOX_ENCRYPTED_SETTINGS* encryptedSection)
{
    if (IsEEPROMEncryptedSectionUnencrypted(encryptedSection))
        return ERROR_SUCCESS;

    #define RC4_CONFOUNDER_LEN FIELD_SIZE(XBOX_ENCRYPTED_SETTINGS, Confounder)

    UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
    UCHAR LocalKey[XC_SERVICE_DIGEST_SIZE];
    UCHAR Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];
    UCHAR* Data;
    ULONG DataSize;
    XBOX_ENCRYPTED_SETTINGS EncryptedSettings;
    UCHAR* EepromKey = (UCHAR*) *XboxEEPROMKey;

    EncryptedSettings = *encryptedSection;
    Data = EncryptedSettings.HDKey;
    DataSize = EEPROM_ENCRYPTED_SECTION_SIZE - FIELD_OFFSET(XBOX_ENCRYPTED_SETTINGS, HDKey);
    memcpy(Confounder, EncryptedSettings.Confounder, RC4_CONFOUNDER_LEN);

    //
    // HMAC the checksum into the key
    //
    XcHMAC(
        EepromKey,
        XBOX_KEY_LENGTH,
        EncryptedSettings.Checksum,
        XC_SERVICE_DIGEST_SIZE,
        NULL,
        0,
        LocalKey);

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key(Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey);

    //
    // Decrypt confounder and data
    //
    XcRC4Crypt(Rc4KeyStruct, RC4_CONFOUNDER_LEN, Confounder);
    XcRC4Crypt(Rc4KeyStruct, DataSize, Data);

    //
    // Now verify the checksum.
    //
    XcHMAC(
        EepromKey,
        XBOX_KEY_LENGTH,
        Confounder,
        RC4_CONFOUNDER_LEN,
        Data,
        DataSize,
        Checksum);

    //
    // Decrypt is successful only if checksum matches
    //
    if (memcmp(Checksum, EncryptedSettings.Checksum, XC_SERVICE_DIGEST_SIZE) != 0)
        return ERROR_INVALID_PASSWORD;

    memset(encryptedSection, 0, sizeof(*encryptedSection));
    memcpy(encryptedSection->HDKey, EncryptedSettings.HDKey, XBOX_KEY_LENGTH);
    encryptedSection->GameRegion = EncryptedSettings.GameRegion;
    return ERROR_SUCCESS;
}

#ifdef ONLINEBETA

static UCHAR NewEEPROMKey[16];

typedef struct _XC_ENCFILE_HEADER {
	DWORD Sig;
	UCHAR MAC[XC_SERVICE_DIGEST_SIZE];
	UCHAR Confounder[RC4_CONFOUNDER_LEN];
	DWORD MsgLen;
	UCHAR unused[XC_SERVICE_DIGEST_SIZE];
} XC_ENCFILE_HEADER, *PXC_ENCFILE_HEADER;

static BOOL FLoadNewEEPROMKey(LPSTR szFilename, LPSTR szPasswd)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwBytes;
    BOOL fRet = FALSE;
    DWORD dwEncSize;
    PBYTE pEncBuffer = FALSE;
    PXC_ENCFILE_HEADER pEncHead;
    UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
    UCHAR LocalKey[XC_SERVICE_DIGEST_SIZE];
    UCHAR Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];
	UCHAR rgbEncryptedKey[sizeof(XC_ENCFILE_HEADER) + 76];
	int cbPasswd;

    hFile = CreateFile(szFilename, GENERIC_READ, FILE_SHARE_READ, NULL,
		OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        goto CleanupAndExit;

    dwEncSize = GetFileSize(hFile, NULL);
    if (dwEncSize != sizeof rgbEncryptedKey)
        goto CleanupAndExit;
    
    pEncHead = (PXC_ENCFILE_HEADER)rgbEncryptedKey;

    if (!ReadFile(hFile, rgbEncryptedKey, dwEncSize, &dwBytes, NULL))
        goto CleanupAndExit;

    if (pEncHead->Sig != 'k2ne' || pEncHead->MsgLen != (dwEncSize -
		sizeof(XC_ENCFILE_HEADER))) {
        goto CleanupAndExit;
    }

    //
    // Decrypt it
    //

	cbPasswd = strlen(szPasswd);
	XcHMAC((PUCHAR)szPasswd, cbPasswd, pEncHead->MAC, XC_SERVICE_DIGEST_SIZE,
		NULL, 0, LocalKey);
    XcRC4Key(Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey);
    XcRC4Crypt(Rc4KeyStruct, RC4_CONFOUNDER_LEN, pEncHead->Confounder);
    XcRC4Crypt(Rc4KeyStruct, pEncHead->MsgLen, (PUCHAR)(pEncHead + 1));
    XcHMAC((PUCHAR)szPasswd, cbPasswd, pEncHead->Confounder, RC4_CONFOUNDER_LEN,
		(PUCHAR)(pEncHead + 1),  pEncHead->MsgLen, Checksum);
    if (memcmp(Checksum, pEncHead->MAC, XC_SERVICE_DIGEST_SIZE) != 0)
        goto CleanupAndExit;

	//
	// At this point, assume the key is bytes 52-67 past the encrypted key
	// header -- this matches the xcrypt symmetric key format
	//

	memcpy(NewEEPROMKey, &rgbEncryptedKey[sizeof(XC_ENCFILE_HEADER) + 52],
		16);
	fRet = TRUE;

CleanupAndExit:
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    return fRet;
}

#endif // ONLINEBETA

//
// Encrypt the encrypted section of the EEPROM
//
static DWORD EncryptEEPROMEncryptedSection(XBOX_ENCRYPTED_SETTINGS* encryptedSection)
{
    if (!IsEEPROMEncryptedSectionUnencrypted(encryptedSection))
        return ERROR_SUCCESS;

    UCHAR Confounder[RC4_CONFOUNDER_LEN] = { 0x4c,0x70,0x33,0xcb,0x5b,0xb5,0x97,0xd2 };
    UCHAR LocalKey[XC_SERVICE_DIGEST_SIZE];
    UCHAR Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];
    UCHAR* Data;
    ULONG DataSize;
#ifdef ONLINEBETA
    UCHAR* EepromKey = NewEEPROMKey;
#else
    UCHAR* EepromKey = (UCHAR*) *XboxEEPROMKey;
#endif

    Data = encryptedSection->HDKey;
    DataSize = EEPROM_ENCRYPTED_SECTION_SIZE - FIELD_OFFSET(XBOX_ENCRYPTED_SETTINGS, HDKey);

    //
    // Create the header - the confounder & checksum
    //
    memset(encryptedSection->Checksum, 0, sizeof(encryptedSection->Checksum));
    memcpy(encryptedSection->Confounder, Confounder, sizeof(encryptedSection->Confounder));

    //
    // Checksum everything but the checksum
    //
    XcHMAC(EepromKey,
           XBOX_KEY_LENGTH,
           encryptedSection->Confounder,
           RC4_CONFOUNDER_LEN,
           Data,
           DataSize,
           encryptedSection->Checksum);

    //
    // HMAC the checksum into the key
    //
    XcHMAC(EepromKey,
           XBOX_KEY_LENGTH,
           encryptedSection->Checksum,
           XC_SERVICE_DIGEST_SIZE,
           NULL,
           0,
           LocalKey);

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key(Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey);

    //
    // Encrypt everything but the checksum
    //
    XcRC4Crypt(Rc4KeyStruct, RC4_CONFOUNDER_LEN, encryptedSection->Confounder);
    XcRC4Crypt(Rc4KeyStruct, DataSize, Data);

    return ERROR_SUCCESS;
}

//
// Make sure the encrypted section of the EEPROM is encrypted and that there is
// a region set
//
static DWORD PrepareEEPROM()
{
    EEPROM_LAYOUT eepromData;
    ULONG type, length;
    DWORD err;
    XBOX_ENCRYPTED_SETTINGS* encryptedSection =
        (XBOX_ENCRYPTED_SETTINGS*) eepromData.EncryptedSection;
	XBOX_USER_SETTINGS* userSettings =
		(XBOX_USER_SETTINGS*) eepromData.UserConfigSection;

    //
    // Read the existing content of the encrypted section
    //
    err = XQueryValue(XC_MAX_ALL, &type, &eepromData, sizeof(eepromData), &length);

    if (ERROR_SUCCESS != err)
    {
        return err;
    }

    if (!IsEEPROMEncryptedSectionUnencrypted(encryptedSection))
    {
        if (ERROR_SUCCESS != DecryptEEPROMEncryptedSection(encryptedSection))
        {
            memset(encryptedSection, 0, sizeof(*encryptedSection));
        }
    }

    if (0 == (encryptedSection->GameRegion & ~XC_GAME_REGION_MANUFACTURING))
    {
        encryptedSection->GameRegion = XC_GAME_REGION_NA;
    }
    else
    {
        encryptedSection->GameRegion &= ~XC_GAME_REGION_MANUFACTURING;
    }

    //
    // Always encrypt the EEPROM header (all post-July releases support this)
    //
    err = EncryptEEPROMEncryptedSection(encryptedSection);

    if (ERROR_SUCCESS != err)
    {
        return err;
    }

#ifdef ONLINEBETA
	// We need to zero out the user EEPROM settings as well
    RtlZeroMemory(userSettings, sizeof(*userSettings));
    userSettings->Checksum = ~XConfigChecksum(userSettings, sizeof(*userSettings));
#endif // ONLINEBETA

    return XSetValue(XC_MAX_ALL, REG_BINARY, &eepromData, sizeof(eepromData));
}


#endif // defined(RECOVERYAPP) && !defined(HDSETUPAPP)


#ifdef RECOVERYAPP

VOID
DrawMessage(LPCWSTR pcszTextLine1, LPCWSTR pcszTextLine2, int iProgPercent)
{
    ASSERT(g_pVideo && g_pBackgroundBitmap && pcszTextLine1);

    g_pVideo->ClearScreen(COLOR_BLACK);
    g_pBackgroundBitmap->render(g_pVideo->GetD3DDevicePtr());

    g_pVideo->DrawText(SCREEN_X_CENTER,
                       MENUBOX_TEXTAREA_Y1,
                       SCREEN_DEFAULT_TEXT_FG_COLOR,
                       SCREEN_DEFAULT_TEXT_BG_COLOR,
                       pcszTextLine1);

    if (NULL != pcszTextLine2)
    {
        g_pVideo->DrawText(SCREEN_X_CENTER,
                           MENUBOX_TEXTAREA_Y1 + FONT_DEFAULT_HEIGHT + ITEM_VERT_SPACING,
                           SCREEN_DEFAULT_TEXT_FG_COLOR,
                           SCREEN_DEFAULT_TEXT_BG_COLOR,
                           pcszTextLine2);
    }

    if (-1 != iProgPercent)
    {
        //
        // Draw progress bar background
        //

        g_pVideo->DrawBox(PROGRESS_X1 - PROGRESS_BORDER_OUTER_OFFSET,
                          PROGRESS_Y1 - PROGRESS_BORDER_OUTER_OFFSET,
                          PROGRESS_X2 + PROGRESS_BORDER_OUTER_OFFSET,
                          PROGRESS_Y2 + PROGRESS_BORDER_OUTER_OFFSET,
                          COLOR_BRIGHT_GREEN);

        //
        // Draw progress bar bkgnd
        //

        g_pVideo->DrawBox(PROGRESS_X1 - PROGRESS_BORDER_GAP,
                          PROGRESS_Y1 - PROGRESS_BORDER_GAP,
                          PROGRESS_X2 + PROGRESS_BORDER_GAP,
                          PROGRESS_Y2 + PROGRESS_BORDER_GAP,
                          COLOR_BLACK);

        //
        // Draw progress bar
        //

        g_pVideo->DrawBox(PROGRESS_X1,
                          PROGRESS_Y1,
                          PROGRESS_X1 + ((PROGRESS_WIDTH / 100) * min(iProgPercent, 100)),
                          PROGRESS_Y2,
                          SCREEN_DEFAULT_TEXT_FG_COLOR);
    }

    WCHAR szBuildString[64];

#ifdef ONLINEBETA
    wsprintfW(szBuildString,
              RStrings[RS_BUILD_NUMBER_FORMAT_INTERNAL],
              VER_PRODUCTVERSION_STR,
              g_InitTableVer & 0xFF);
#else
    if (g_fInternalCD)
    {
        wsprintfW(szBuildString,
                  RStrings[RS_BUILD_NUMBER_FORMAT_INTERNAL],
                  VER_PRODUCTVERSION_STR,
                  g_InitTableVer & 0xFF);
    }
    else
    {
        wsprintfW(szBuildString,
                  RStrings[RS_BUILD_NUMBER_FORMAT],
                  VER_PRODUCTVERSION_STR);
    }
#endif

    g_pVideo->DrawText(SCREEN_X_CENTER,
                       MENUBOX_BUILDNUM_Y1,
                       SCREEN_DEFAULT_TEXT_FG_COLOR,
                       SCREEN_DEFAULT_TEXT_BG_COLOR,
                       szBuildString);

    g_pVideo->ShowScreen();
}


VOID
EjectDVD()
{
    //
    // This requires matching SMC firmware and DVD firmware (DVT3 and onward)..
    //

    HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_DVD_TRAY_OPERATION,
        SMC_DVD_TRAY_OPERATION_OPEN);
}


DWORD ReadSMC(unsigned char addr)
{
    DWORD value = 0xCCCCCCCC;
    DWORD status = HalReadSMBusValue(0x21, addr, FALSE, &value);
    return value;
}


VOID GetSMCVersion(PSTR pszSMCVersion, UINT cchSMCVersion)
{
    ASSERT(cchSMCVersion > 3);

    HalWriteSMBusValue(0x21, 0x01, FALSE, 0);

    pszSMCVersion[0] = (char)ReadSMC(0x01);
    pszSMCVersion[1] = (char)ReadSMC(0x01);
    pszSMCVersion[2] = (char)ReadSMC(0x01);
    pszSMCVersion[3] = '\0';
}

//
// Copies files from a source path to a destination path.  The source path
// is a filter that can be passed to FindFirstFile() and is currently required
// to end in "\\*".  The destination path should end with a trailing backslash ('\')
//

BOOL
CopyFiles(
    IN PCOSTR pcszSrcPath,
    IN PCOSTR pcszDestPath,
    IN BOOL fRootDir,
    IN const POSTR * ppszExceptionList,
    IN UINT cExceptionListItems
    )
{
    WIN32_FIND_DATA wfd;
    BOOL bRet = FALSE;
    int nSrcLen = ocslen(pcszSrcPath);
    int nDestLen = ocslen(pcszDestPath);
    HANDLE hFind = FindFirstFile(pcszSrcPath, &wfd);

    if (NULL == ppszExceptionList)
    {
        ppszExceptionList = g_RootDirExceptions;
        cExceptionListItems = ARRAYSIZE(g_RootDirExceptions);
    }

    if (INVALID_HANDLE_VALUE != hFind)
    {
        OCHAR szSrcFile[MAX_PATH], szDestFile[MAX_PATH];
        ocscpy(szSrcFile, pcszSrcPath);
        ocscpy(szDestFile, pcszDestPath);
        ASSERT((szSrcFile[nSrcLen - 1] == OTEXT('*')) &&
               (szSrcFile[nSrcLen - 2] == OTEXT('\\')));
        do
        {
            BOOL fCopyThis = TRUE;

            if (fRootDir)
            {
                int i;
                for (i = 0; i < (int) cExceptionListItems; i++)
                {
                    if (0 == _ocsicmp(wfd.cFileName, ppszExceptionList[i]))
                    {
                        fCopyThis = FALSE;
                        break;
                    }
                }
            }

            if (!fCopyThis)
            {
                continue;
            }

            lstrcpynO(&(szSrcFile[nSrcLen - 1]),
                      wfd.cFileName,
                      ARRAYSIZE(szSrcFile) - (nSrcLen - 1));
            lstrcpynO(&(szDestFile[nDestLen]),
                      wfd.cFileName,
                      ARRAYSIZE(szDestFile) - nDestLen);

            if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                int nFileLen = ocslen(wfd.cFileName);

                bRet = CreateDirectory(szDestFile, NULL);

                if (!bRet)
                {
                    break;
                }

                lstrcpynO(&(szSrcFile[nSrcLen + nFileLen - 1]),
                          OTEXT("\\*"),
                          ARRAYSIZE(szSrcFile) - (nSrcLen + nFileLen - 1));

                lstrcpynO(&(szDestFile[nDestLen + nFileLen]),
                          OTEXT("\\"),
                          ARRAYSIZE(szDestFile) - (nDestLen + nFileLen));

                bRet = CopyFiles(szSrcFile, szDestFile, FALSE, NULL, 0);

                if (!bRet)
                {
                    break;
                }
            }
            else
            {
                bRet = CopyFile(szSrcFile, szDestFile, FALSE);

                //
                // Files coming off of CD/DVD end up read-only, so clear
                // all of the attributes.. (otherwise dosnet won't work)
                //

                SetFileAttributes(szDestFile, FILE_ATTRIBUTE_NORMAL);

                if (!bRet)
                {
                    break;
                }

                DrawMessage(RStrings[RS_COPYING],
                            NULL,
                            5 + min((++g_FilesCopied * 90) / APPROX_FILE_COUNT, 90));
            }

        } while (FindNextFile(hFind, &wfd));

        FindClose(hFind);
    }
    else if (ERROR_FILE_NOT_FOUND == GetLastError())
    {
        bRet = TRUE;
    }

    return bRet;
}




#ifdef SECTORCOPY

#define RECASSERT(cond) do { \
            if (!(cond)) { \
                DbgPrint("ASSERT on line %d: %s\n", __LINE__, #cond); \
                DrawMessage(L"ASSERT", L ## #cond, 0); \
                DebugBreak(); \
            } \
        } while (0)

#define SECTORSIZE 512
#define MAXBUFSIZE (64*1024)
ULONG SectorRanges[] = {
    0x00000000, 0x000003FF,
    0x00465400, 0x0055F3FF,
    0x0055F400, 0x00567D97,
};

VOID ReadDiskSnapshot()
{
    OBJECT_STRING objname;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;
    HANDLE disk;

    RtlInitObjectString(&objname, OTEXT("\\Device\\Harddisk0\\partition0"));
    InitializeObjectAttributes(&oa, &objname, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenFile(
                &disk,
                GENERIC_ALL|SYNCHRONIZE,
                &oa,
                &iosb,
                0,
                FILE_SYNCHRONOUS_IO_ALERT);

    RECASSERT(NT_SUCCESS(status));

    VOID* buf = VirtualAlloc(NULL, MAXBUFSIZE, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
    RECASSERT(buf != NULL);

    HANDLE file = CreateFile(
                    "z:\\snapshot.dat",
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL);

    RECASSERT(file != INVALID_HANDLE_VALUE);

    // Write out the first sector
    memset(buf, 0, MAXBUFSIZE);
    memcpy(buf, SectorRanges, sizeof(SectorRanges));

    DWORD cb;
    BOOL writeok = WriteFile(file, buf, SECTORSIZE, &cb, NULL);
    RECASSERT(writeok);

    ULONG* p = SectorRanges;
    ULONG range_count = sizeof(SectorRanges) / (sizeof(ULONG)*2);
    ULONG total = 0;

    while (range_count--) {
        ULONG sector = p[0];
        ULONG sector_count = p[1] - p[0] + 1;
        p += 2;
        DbgPrint("Copying %d sectors starting from %x\n", sector_count, sector);

        total += sector_count;
        while (sector_count) {
            ULONG n = min(sector_count, MAXBUFSIZE/SECTORSIZE);
            LARGE_INTEGER offset;

            offset.QuadPart = sector;
            offset.QuadPart *= SECTORSIZE;
            status = NtReadFile(disk, 0, NULL, NULL, &iosb, buf, n*SECTORSIZE, &offset);
            RECASSERT(NT_SUCCESS(status));

            writeok = WriteFile(file, buf, n*SECTORSIZE, &cb, NULL);
            RECASSERT(writeok);

            sector += n;
            sector_count -= n;
        }
    }

    VirtualFree(buf, 0, MEM_RELEASE);
    CloseHandle(file);
    NtClose(disk);

    DbgPrint("Total of %d sectors copied\n", total);
}

VOID WriteDiskSnapshot()
{
    OBJECT_STRING objname;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;
    HANDLE disk;

    RtlInitObjectString(&objname, OTEXT("\\Device\\Harddisk0\\partition0"));
    InitializeObjectAttributes(&oa, &objname, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenFile(
                &disk,
                GENERIC_ALL|SYNCHRONIZE,
                &oa,
                &iosb,
                0,
                FILE_SYNCHRONOUS_IO_ALERT);

    RECASSERT(NT_SUCCESS(status));

    VOID* buf = VirtualAlloc(NULL, MAXBUFSIZE, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
    RECASSERT(buf != NULL);

    HANDLE file = CreateFile(
                    "D:\\snapshot.dat",
                    GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL);

    RECASSERT(file != INVALID_HANDLE_VALUE);

    DWORD cb;
    BOOL readok = ReadFile(file, buf, SECTORSIZE, &cb, NULL);
    RECASSERT(readok);
    RECASSERT(memcmp(buf, SectorRanges, sizeof(SectorRanges)) == 0);

    ULONG* p = SectorRanges;
    ULONG range_count = sizeof(SectorRanges) / (sizeof(ULONG)*2);
    ULONG total = 0;

    while (range_count--) {
        ULONG sector = p[0];
        ULONG sector_count = p[1] - p[0] + 1;
        p += 2;
        DbgPrint("Copying %d sectors starting from %x\n", sector_count, sector);

        total += sector_count;
        while (sector_count) {
            ULONG n = min(sector_count, MAXBUFSIZE/SECTORSIZE);
            LARGE_INTEGER offset;
            offset.QuadPart = sector;
            offset.QuadPart *= SECTORSIZE;

            readok = ReadFile(file, buf, n*SECTORSIZE, &cb, NULL);
            RECASSERT(readok);

            status = NtWriteFile(disk, NULL, NULL, NULL, &iosb, buf, n*SECTORSIZE, &offset);
            RECASSERT(NT_SUCCESS(status));

            sector += n;
            sector_count -= n;
        }
    }

    VirtualFree(buf, 0, MEM_RELEASE);
    CloseHandle(file);
    NtClose(disk);

    DbgPrint("Total of %d sectors copied\n", total);
}

#endif // SECTORCOPY


BOOL AreOnlineSectorsOk(PBYTE pbMachineAcctSectorData)
{
    XC_ONLINE_MACHINE_ACCOUNT_STRUCT* pMachineAccount = 
            (XC_ONLINE_MACHINE_ACCOUNT_STRUCT*) pbMachineAcctSectorData;

    ASSERT(pbMachineAcctSectorData);

    if (0 != pMachineAccount->xuid.qwUserID)
    {
        return TRUE;
    }

    return FALSE;
}


#endif // RECOVERYAPP

#define XBOX_MACHINE_ACCT_SECTOR  (XBOX_CONFIG_SECTOR_INDEX + 1)
#define XBOX_USER_SECTOR1         (XBOX_CONFIG_SECTOR_INDEX + 2)
#define XBOX_USER_SECTOR2         (XBOX_CONFIG_SECTOR_INDEX + 3)


NTSTATUS
WriteFirstSectors(
    IN HANDLE hDisk
    )
{
    LARGE_INTEGER WriteOffset;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status = STATUS_SUCCESS;
    BYTE rgbSectorBytes[XBOX_HD_SECTOR_SIZE];
    PXBOX_CONFIG_SECTOR ConfigSector = (PXBOX_CONFIG_SECTOR) rgbSectorBytes;
    int i;

    BOOL fPreserveOnlineSectors = TRUE;

    RtlZeroMemory(rgbSectorBytes, sizeof(rgbSectorBytes));

#ifdef HDSETUPAPP

    //
    // Zero out all sectors used by the greystone duplicator before writing anything
    //

    for (i = 0;
         (HardDriveSectorRanges[i].FirstSector && HardDriveSectorRanges[i].LastSector);
         i++)
    {
        UINT j;

        for (j = HardDriveSectorRanges[i].FirstSector;
             j <= HardDriveSectorRanges[i].LastSector;
             j++)
        {
            WriteOffset.QuadPart = j * XBOX_HD_SECTOR_SIZE;

            NtWriteFile(hDisk,
                        NULL,
                        NULL,
                        NULL,
                        &ioStatus,
                        rgbSectorBytes,
                        XBOX_HD_SECTOR_SIZE,
                        &WriteOffset);
        }
    }

#endif // HDSETUPAPP

    //
    // Zero out sectors 0-2 and 4-7 (including cache db sector):
    //

    //
    // Sector 3 (XBOX_REFURB_INFO_SECTOR_INDEX) contains the refurb
    // information - leave it alone
    //

    //
    // In HDSETUP, we clear out all of the sectors, refurb, config, and all
    //

    for (i = XBOX_BOOT_SECTOR_INDEX;
#if defined(HDSETUPAPP) || defined(ONLINEBETA)
         i < (XBOX_CONFIG_SECTOR_INDEX + XBOX_NUM_CONFIG_SECTORS);
#else  // HDSETUPAPP
         i < XBOX_REFURB_INFO_SECTOR_INDEX;
#endif // HDSETUPAPP
         i++)
    {
        WriteOffset.QuadPart = i * XBOX_HD_SECTOR_SIZE;

        NtWriteFile(hDisk,
                    NULL,
                    NULL,
                    NULL,
                    &ioStatus,
                    rgbSectorBytes,
                    XBOX_HD_SECTOR_SIZE,
                    &WriteOffset);
    }

#if !defined(HDSETUPAPP) && !defined(ONLINEBETA)
    for (i = XBOX_CACHE_DB_SECTOR_INDEX;
         i < XBOX_CONFIG_SECTOR_INDEX;
         i++)
    {
        WriteOffset.QuadPart = i * XBOX_HD_SECTOR_SIZE;

        NtWriteFile(hDisk,
                    NULL,
                    NULL,
                    NULL,
                    &ioStatus,
                    rgbSectorBytes,
                    XBOX_HD_SECTOR_SIZE,
                    &WriteOffset);
    }

    //
    // Preserve config sectors sectors 8-15 (if valid), otherwise zero them:
    //

    for (i = XBOX_CONFIG_SECTOR_INDEX;
         i < (XBOX_CONFIG_SECTOR_INDEX + XBOX_NUM_CONFIG_SECTORS);
         i++)
    {
        WriteOffset.QuadPart = i * XBOX_HD_SECTOR_SIZE;

        status = NtReadFile(hDisk,
                            NULL,
                            NULL,
                            NULL,
                            &ioStatus,
                            ConfigSector,
                            XBOX_HD_SECTOR_SIZE,
                            &WriteOffset);

        if (NT_SUCCESS(status) &&
            (ConfigSector->SectorBeginSignature == XBOX_CONFIG_SECTOR_BEGIN_SIGNATURE) &&
            (ConfigSector->SectorEndSignature == XBOX_CONFIG_SECTOR_END_SIGNATURE) &&
            (XConfigChecksum(ConfigSector, sizeof(*ConfigSector)) == 0xffffffff)
#ifdef RECOVERYAPP
            &&
            ((XBOX_MACHINE_ACCT_SECTOR != i) || (fPreserveOnlineSectors = AreOnlineSectorsOk(ConfigSector->Data))) &&
            (((XBOX_USER_SECTOR1 != i) && (XBOX_USER_SECTOR2 != i)) || fPreserveOnlineSectors))
#else  // RECOVERYAPP
            )
#endif // RECOVERYAPP
        {
            XDBGWRN("RECOVERY", "Preserving config sector %d.", i);
        }
        else
        {
            XDBGWRN("RECOVERY", "Invalid config sector %d - not preserving.", i);

            RtlZeroMemory(ConfigSector, XBOX_HD_SECTOR_SIZE);

            NtWriteFile(hDisk,
                        NULL,
                        NULL,
                        NULL,
                        &ioStatus,
                        ConfigSector,
                        XBOX_HD_SECTOR_SIZE,
                        &WriteOffset);
        }
    }
#endif // !HDSETUPAPP

    return status;
}

#ifdef DASHLIB

//
// Reset user settings in EEPROM to their defaults (all zeros)
//

NTSTATUS ResetEEPROMUserSettings()
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    XBOX_USER_SETTINGS* userSettings;
    NTSTATUS status;
    DWORD type, size;

    eeprom = (EEPROM_LAYOUT*) buf;
    userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);

    if (NT_SUCCESS(status))
    {
        RtlZeroMemory(userSettings, sizeof(*userSettings));
        userSettings->Checksum = ~XConfigChecksum(userSettings, sizeof(*userSettings));
        status = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, buf, sizeof(buf));
    }

    return status;
}

#endif // DASHLIB

#ifdef RECOVERYAPP

#ifdef CHECK_EEPROM_SETTINGS

//
// Generate the default EEPROM image
//  We assume the output buffer has already been
//  zero-initialized by the caller.
//
VOID DefaultNonVolatileSettings(EEPROM_LAYOUT* eeprom)
{
    XBOX_FACTORY_SETTINGS* factorySettings;
    XBOX_USER_SETTINGS* userSettings;
    LARGE_INTEGER systime;
    UCHAR* enetaddr;
    ULONG tick0;

    // Pick a random Ethernet address in the 1M range
    // of the 00-50-f2 address block. Only even addresses
    // are used here.
    __asm {
        rdtsc
        mov tick0, eax
    }
    KeQuerySystemTime(&systime);
    tick0 = (tick0 ^ systime.LowPart) & 0xffffe;

    factorySettings = (XBOX_FACTORY_SETTINGS*) &eeprom->FactorySection;
    userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;

    enetaddr = factorySettings->EthernetAddr;
    enetaddr[0] = 0x00;
    enetaddr[1] = 0x50;
    enetaddr[2] = 0xf2;
    enetaddr[3] = (UCHAR) (tick0 >> 16);
    enetaddr[4] = (UCHAR) (tick0 >>  8);
    enetaddr[5] = (UCHAR) (tick0      );

    // The first 32 addresses are reserved.
    enetaddr[5] |= 0x20;

    factorySettings->AVRegion = AV_STANDARD_NTSC_M | AV_FLAGS_60Hz;
    factorySettings->Checksum = ~XConfigChecksum(factorySettings, sizeof(*factorySettings));

    userSettings->Checksum = ~XConfigChecksum(userSettings, sizeof(*userSettings));
}

//
// Verify the non-volatile settings are valid
// and initialize them to default values if necessary.
//
NTSTATUS CheckNonVolatileSettings()
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    XBOX_FACTORY_SETTINGS* factorySettings;
    XBOX_USER_SETTINGS* userSettings;
    NTSTATUS status;
    DWORD type, size;

    eeprom = (EEPROM_LAYOUT*) buf;
    factorySettings = (XBOX_FACTORY_SETTINGS*) &eeprom->FactorySection;
    userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);

    if (NT_SUCCESS(status) &&
        XConfigChecksum(factorySettings, sizeof(*factorySettings)) == 0xffffffff &&
        XConfigChecksum(userSettings, sizeof(*userSettings)) == 0xffffffff) {
        XDBGWRN("RECOVERY", "Preserving EEPROM settings.");
    } else if (XboxHardwareInfo->GpuRevision == 0xa1) {
        XDBGWRN("RECOVERY", "Initializing EEPROM settings (DVT2) ...");
        memset(buf, 0, sizeof(buf));

        DefaultNonVolatileSettings(eeprom);
        status = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, buf, sizeof(buf));

        if (!NT_SUCCESS(status)) {
            XDBGWRN("RECOVERY", "Failed to initialized EEPROM settings: %x.", status);
        }
    } else {
        XDBGWRN("RECOVERY", "!!!!!!!!!! Corrupted EEPROM on DVT3 box !!!!!!!!!!");
    }

    return status;
}

#endif // CHECK_EEPROM_SETTINGS

// Threshold for analog buttons
#define XINPUT_ANALOGBUTTONTHRESHOLD 32

//
// This function returns with *pdwNewVideoMode set to 0xFFFFFFFF if a regular
// controller button is pressed.
//
// It returns with *pdwNewVideoMode set to a valid video mode if a video mode
// change button sequence has been pressed:
// (both triggers + right thumbstick + some other button)
//

VOID
WaitForAnyButton(PDWORD pdwNewVideoMode, PBOOL pfYButton)
{
    BOOL fButtonPressed = FALSE;
    static DWORD dwPads = 0;
    DWORD dwInsertions, dwRemovals;
    static HANDLE hPads[XGetPortCount()] = { 0 };
    int i;

    ASSERT(pdwNewVideoMode);
    *pdwNewVideoMode = 0xFFFFFFFF;

    while (!fButtonPressed)
    {
        if (XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals))
        {
            dwPads |= dwInsertions;
            dwPads &= ~dwRemovals;

            for (i = 0; i < XGetPortCount(); i++)
            {
                if ((1 << i) & dwRemovals)
                {
                    if (NULL != hPads[i])
                    {
                        XInputClose(hPads[i]);
                        hPads[i] = NULL;
                    }
                }

                if ((1 << i) & dwInsertions)
                {
                    if (NULL == hPads[i])
                    {
                        hPads[i] = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0 + i, XDEVICE_NO_SLOT, NULL);;
                    }
                }
            }
        }

        for (i = 0; i < XGetPortCount(); i++)
        {
            if ((1 << i) & dwPads)
            {
                if (NULL != hPads[i])
                {
                    XINPUT_STATE State;

                    if (ERROR_SUCCESS == XInputGetState(hPads[i], &State))
                    {
                        if ((State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > XINPUT_ANALOGBUTTONTHRESHOLD) &&
                            (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > XINPUT_ANALOGBUTTONTHRESHOLD))
                        {
                            if (State.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP)
                            {
                                *pdwNewVideoMode = AV_STANDARD_PAL_I | AV_FLAGS_50Hz;
                            }
                            else if (State.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT)
                            {
                                *pdwNewVideoMode = AV_STANDARD_NTSC_M | AV_FLAGS_60Hz;
                            }
                            else if (State.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT)
                            {
                                *pdwNewVideoMode = AV_STANDARD_NTSC_J | AV_FLAGS_60Hz;
                            }
                        }
                        else if ((0 != ((XINPUT_GAMEPAD_START | XINPUT_GAMEPAD_BACK) & State.Gamepad.wButtons)) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] > XINPUT_ANALOGBUTTONTHRESHOLD))
                        {
                            fButtonPressed = TRUE;
                            
                            if (pfYButton)
                            {
                                *pfYButton = (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] >
                                                XINPUT_ANALOGBUTTONTHRESHOLD);
                            }
                        }
                    }
                }
            }

            if (fButtonPressed || (*pdwNewVideoMode != 0xFFFFFFFF))
            {
                fButtonPressed = TRUE;
                break;
            }
        }
    }
}

VOID
WaitForButtonPress(
    PBOOL YButton
    )
{
    ULONG VideoMode;

    //
    // Keep processing button presses.  If the video mode changes, then
    // deal with it.
    //

    for(;;) {
        WaitForAnyButton(&VideoMode, YButton);
        if(VideoMode == 0xFFFFFFFF)
            return;

        //
        // Reset video flags and re-init
        //

        ExSaveNonVolatileSetting(XC_FACTORY_AV_REGION, REG_DWORD, &VideoMode,
            sizeof(VideoMode));

        D3D__AvInfo = 0;

        g_pVideo->DeInitialize();

        g_pVideo->Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );

        g_pVideo->ClearScreen(COLOR_BLACK);
        g_pBackgroundBitmap->render(g_pVideo->GetD3DDevicePtr());
        g_pVideo->ShowScreen();
    }
}

#endif // RECOVERYAPP

#ifdef RECOVERYAPP

#define FAIL_RECOVERY(code)                                    \
{                                                              \
    WCHAR szMsg[128];                                          \
    wsprintfW(szMsg, RStrings[RS_FAILURE_LINE2_FORMAT], code); \
    DrawMessage(RStrings[RS_FAILURE_LINE1], szMsg, -1);        \
    XDBGWRN("RECOVERY", "Recovery failed (err 0x%08x)", code); \
    IDirect3DDevice8* pDevice = g_pVideo->GetD3DDevicePtr();   \
    ASSERT(pDevice);                                           \
    pDevice->BlockUntilIdle();                                 \
    Sleep(INFINITE);                                           \
    return;                                                    \
}

#endif // RECOVERYAPP

#ifndef RECOVERYNOFLASH

VOID
DetectInitTableVersion(
    VOID
    )
{
    PVOID RomBase;

    RomBase = MmMapIoSpace( FLASH_BASE_ADDRESS, FLASH_REGION_SIZE,
                                  PAGE_READWRITE | PAGE_NOCACHE );
    if (NULL == RomBase) {
        XDBGERR("RECOVERY", "Could not map ROM");
        FAIL_RECOVERY(4);
    }
    g_InitTableVer = FlashReadUlong(FLASH_BASE_ADDRESS +
        ROM_VERSION_BYTE_OFFSET);
    XDBGWRN("RECOVERY", "Detected init table version 0x%08x", g_InitTableVer);
    MmUnmapIoSpace( RomBase, FLASH_REGION_SIZE );
}

VOID
UpdateROMImage(
    BOOL RetailImage
    )
{
    BOOL ExternalROM;
    BOOL UpdateNeeded;
    BOOL YButton;
    PUCHAR ROMImage;
    PUCHAR ROMData;
    ULONG SizeOfDataReturned;
    PSTR ROMFileName;
    HANDLE ROMFileHandle;

#ifdef ONLINEBETA
	UpdateNeeded = TRUE;
#else

    //
    // Detect the current ROM version and flavor to see whether we need to
    // update it.
    //

    ExternalROM = (g_InitTableVer & ROM_VERSION_KDDELAY_FLAG) != 0;
    if(RetailImage && (XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL))
        UpdateNeeded = TRUE;
    else if(!RetailImage && !(XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL))
        UpdateNeeded = TRUE;
    else if(ExternalROM && g_fInternalCD)
        UpdateNeeded = TRUE;
    else if(!ExternalROM && !g_fInternalCD)
        UpdateNeeded = TRUE;
    else
        UpdateNeeded = ((g_InitTableVer >> 16) & 0x7FFF) < RecoveryVersion;
#endif

    //
    // If the ROM is current and we're doing internal recovery, we offer the
    // option to update anyway.
    //

    if(!UpdateNeeded) {
        if(!g_fInternalCD)
            return;
        DrawMessage(RStrings[RS_OVERWRITEROM_LINE1],
            RStrings[RS_OVERWRITEROM_LINE2], -1);
        Sleep(200);
        WaitForButtonPress(&YButton);
        if(!YButton)
            return;
    }

    //
    // Load the ROM image
    //

    ROMImage = (PUCHAR) LocalAlloc(LMEM_FIXED, ROM_SIZE);
    if (NULL == ROMImage) {
        XDBGERR("RECOVERY", "Could not allocate ROM image memory");
        FAIL_RECOVERY(1);
    }

#ifdef ONLINEBETA
    if ((g_InitTableVer & 0xFF) == 0x46 || (g_InitTableVer & 0xFF) == 0x70) 
        ROMFileName = NULL;
    else
        ROMFileName = "D:\\xboxrom_beta.bin";
#else
    if ((g_InitTableVer & 0xFF) == 0x46)
        ROMFileName = RetailImage ? "D:\\RETAIL\\xboxrom_dvt4.bin" : "D:\\xboxrom_dvt4.bin";
    else if ((g_InitTableVer & 0xFF) == 0x70) 
        ROMFileName = RetailImage ? "D:\\RETAIL\\xboxrom_qt.bin" : "D:\\xboxrom_qt.bin";
    else
        ROMFileName = RetailImage ? "D:\\RETAIL\\xboxrom.bin" : "D:\\xboxrom.bin";
#endif

    ROMFileHandle = CreateFile(ROMFileName, GENERIC_READ, 0, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    //
    // If the ROM image is missing from the drive, we need to advise the user,
    // but not fail recovery.
    //

    if (INVALID_HANDLE_VALUE == ROMFileHandle) {
        DWORD dwErr = GetLastError();
        XDBGWRN("RECOVERY", "Could not open ROM image file (%s), err=0x%08x", ROMFileName, dwErr);
#ifdef ONLINEBETA
		FAIL_RECOVERY(3);
#else
        DrawMessage(RStrings[RS_NEWERROM_LINE1],
            RStrings[RS_NEWERROM_LINE2], -1);
        WaitForButtonPress(&YButton);
        LocalFree(ROMImage);
        return;
#endif
    }

    //
    // Read in the ROM
    //

    ROMData = ROMImage;
    while (ReadFile(ROMFileHandle, ROMData, ROM_SIZE - (ROMData - ROMImage),
        &SizeOfDataReturned, NULL) && (0 != SizeOfDataReturned))
    {
        ROMData += SizeOfDataReturned;
    }
    CloseHandle(ROMFileHandle);

    if (ROM_SIZE != (ROMData - ROMImage)) {
        XDBGERR("RECOVERY", "Could not read ROM image file, read %d out of %d bytes",
            (ROMData - ROMImage), ROM_SIZE);
        FAIL_RECOVERY(3);
    }

    DrawMessage(RStrings[RS_FLASH_LINE1], RStrings[RS_FLASH_LINE2], -1);

    IDirect3DDevice8* pDevice = g_pVideo->GetD3DDevicePtr();
    ASSERT(pDevice);
    pDevice->BlockUntilIdle();

    XDBGWRN("RECOVERY", "Starting ROM Flash...");

    HRESULT hrFlash;

    for (int i = 0; i < ROM_FLASH_RETRIES; i++)
    {
        CHAR szResp[128];
        hrFlash = FlashKernelImage(ROMImage,
                                   ROM_SIZE,
                                   szResp,
                                   ARRAYSIZE(szResp));

        XDBGWRN("RECOVERY", "Flash Status (%d): hr=0x%08x (%s)", i, hrFlash, szResp);

        if (SUCCEEDED(hrFlash))
        {
            break;
        }
    }

    if (ROM_FLASH_RETRIES == i)
    {
        XDBGERR("RECOVERY", "Could not flash ROM, hr=0x%08x", hrFlash);
        FAIL_RECOVERY(hrFlash);
    }

    LocalFree(ROMImage);
}

#endif // RECOVERYNOFLASH

#ifdef DASHLIB

#define FAIL_RECOVERY(code)                                    \
{                                                              \
    XDBGWRN("RECOVERY", "Recovery failed (err 0x%08x)", code); \
    return code;                                               \
}

#endif // DASHLIB

#define MAX_SECS_PER_VERIFY 256

typedef
VOID
(CALLBACK *PFORMAT_PROGRESS_ROUTINE)(
    UINT uPercent
    );

BOOL
WINAPI
RecFormatFATVolume(
    POBJECT_STRING VolumePath,
    BOOL fQuickFormat,
    PFORMAT_PROGRESS_ROUTINE pFPR
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE VolumeHandle;
    DISK_GEOMETRY DiskGeometry;
    ULONG SectorShift;
    ULONG StructureAlignment;
    PARTITION_INFORMATION PartitionInformation;
    LARGE_INTEGER ByteOffset;

    if (pFPR)
    {
        pFPR(0);
    }

    InitializeObjectAttributes(&ObjectAttributes, VolumePath,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    if (!XapiFormatFATVolume(VolumePath))
    {
        return FALSE;
    }

    //
    // Open the volume for read/write access.
    //

    status = NtOpenFile(&VolumeHandle, SYNCHRONIZE | FILE_READ_DATA |
        FILE_WRITE_DATA, &ObjectAttributes, &IoStatusBlock, 0,
        FILE_SYNCHRONOUS_IO_ALERT | FILE_NO_INTERMEDIATE_BUFFERING);

    if (!NT_SUCCESS(status)) {
        // XapiSetLastNTError(status);
        return FALSE;
    }

    //
    // Obtain the drive geometry for the target device.
    //

    status = NtDeviceIoControlFile(VolumeHandle, NULL, NULL, NULL, &IoStatusBlock,
        IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &DiskGeometry,
        sizeof(DiskGeometry));

    if (!NT_SUCCESS(status)) {
        NtClose(VolumeHandle);
        // XapiSetLastNTError(status);
        return FALSE;
    }

    SectorShift = RtlFindFirstSetRightMember(DiskGeometry.BytesPerSector);

    //
    // Obtain the size of the partition for the target device.
    //

    status = NtDeviceIoControlFile(VolumeHandle, NULL, NULL, NULL, &IoStatusBlock,
        IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &PartitionInformation,
        sizeof(PartitionInformation));

    if (!NT_SUCCESS(status)) {
        NtClose(VolumeHandle);
        // XapiSetLastNTError(status);
        return FALSE;
    }

    //
    // Compute the alignment between the various file system structures.
    // Everything should be page aligned in order to maximum file system cache
    // efficiency.
    //

    StructureAlignment = ROUND_TO_PAGES(DiskGeometry.BytesPerSector);

    //
    // Now do the verify...
    //

    {
        DWORD dwAllSectors = (DWORD) PartitionInformation.PartitionLength.QuadPart >> SectorShift;
        DWORD dwSecsPerVerify = min((dwAllSectors / 20) + 1, MAX_SECS_PER_VERIFY);
        DWORD dwPercent = 0;

        // Do a full verify of the disk

        for (DWORD i = 0; i < dwAllSectors; i += dwSecsPerVerify)
        {
            VERIFY_INFORMATION vi;

            if ((i * 100) / dwAllSectors > dwPercent)
            {
                dwPercent = ((i * 100) / dwAllSectors);
                XDBGTRC("RECOVERY", "Format is %ld%% complete", dwPercent);
                if (pFPR)
                {
                    pFPR(dwPercent);
                }
            }

            vi.StartingOffset.QuadPart = i << SectorShift;
            vi.Length = min(dwSecsPerVerify, dwAllSectors - i) << SectorShift;

            ASSERT(dwSecsPerVerify < (0xFFFFFFFF >> SectorShift));

            status = NtDeviceIoControlFile(
                        VolumeHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_DISK_VERIFY,
                        &vi,
                        sizeof(vi),
                        NULL,
                        0
                        );

            if (!NT_SUCCESS(status))
            {
                XDBGERR("RECOVERY",
                        "NtDeviceIoControlFile() IOCTL_DISK_VERIFY failed - st=0x%08X",
                        status);
                break;
            }

            if ((0 == i) && fQuickFormat)
            {
                //
                // NOTE: modifying loop counter, ugly, I know.  But this is a
                // convenient way to make sure that quickformat verifies the
                // beginning and the end of the disk..
                //
                i = max(i + dwSecsPerVerify, dwAllSectors - dwSecsPerVerify);
            }
        }

        NtClose(VolumeHandle);

        if (!NT_SUCCESS(status))
        {
            return FALSE;
        }
    }

    if (pFPR)
    {
        pFPR(100);
    }

    return TRUE;
}

//
// Index of the partition that is currently being formatted (1-based)
//

UINT g_CurrentFormatPartition;

#ifdef RECOVERYAPP

VOID
CALLBACK
RecFormatProgress(
    UINT uPercent
    )
{
    UINT uPartitions = (XDISK_FIRST_CACHE_PARTITION - 1) + *HalDiskCachePartitionCount;
    DrawMessage(RStrings[RS_PREPARING],
                NULL,
                ((100 / uPartitions) * (g_CurrentFormatPartition - 1)) +
                    (uPercent / uPartitions));
}

BOOL HDSetPassword( BYTE* password, DWORD dwLen )
{
    NTSTATUS status;
    HANDLE h;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    OBJECT_STRING name;
    ULONG AtaPassThroughSize;
    ATA_PASS_THROUGH AtaPassThrough;
    IDE_SECURITY_DATA SecurityData;
    BOOL fReturn;
    DWORD cbBytes;

    RtlInitObjectString(&name, "\\Device\\Harddisk0\\Partition0");
    InitializeObjectAttributes(&obja, &name, 0, NULL, 0);

    status = NtOpenFile(&h, GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, &obja, &iosb,
        FILE_SHARE_WRITE | FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(status)) {

        RtlZeroMemory(&AtaPassThrough, sizeof(ATA_PASS_THROUGH));
        RtlZeroMemory(&SecurityData, sizeof(IDE_SECURITY_DATA));

        AtaPassThrough.IdeReg.bHostSendsData = TRUE;
        AtaPassThrough.IdeReg.bCommandReg = IDE_COMMAND_SECURITY_SET_PASSWORD;
        AtaPassThrough.DataBufferSize = sizeof(IDE_SECURITY_DATA);
        AtaPassThrough.DataBuffer = &SecurityData;
        SecurityData.Maximum = TRUE;
        SecurityData.Master = FALSE;

        RtlCopyMemory(SecurityData.Password, password, dwLen);

        fReturn = DeviceIoControl(h, IOCTL_IDE_PASS_THROUGH,
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &cbBytes, NULL);

        if (!fReturn) {
            XDBGTRC("HDSetPassword", "API error!");
            return FALSE;
        } else if (AtaPassThrough.IdeReg.bCommandReg & 1) {
            XDBGTRC("HDSetPassword", "IDE error!");
            return FALSE;
        }

        NtClose(h);
    }

#ifndef INT2RETAIL
#ifndef HDSETUPAPP
    {
    //
    // Now that we've reset the HD password, we need to make sure the EEPROM
    // has the correct key
    //
    EEPROM_LAYOUT eepromData;
    ULONG type, length;
    DWORD err;
    XBOX_ENCRYPTED_SETTINGS* encryptedSection =
        (XBOX_ENCRYPTED_SETTINGS*) eepromData.EncryptedSection;

    //
    // Read the existing content of the encrypted section
    //
    err = XQueryValue(XC_MAX_ALL, &type, &eepromData, sizeof(eepromData), &length);

    if (ERROR_SUCCESS != err)
    {
        return FALSE;
    }

    //
    // By now, the EEPROM should have been encrypted
    //
    if (ERROR_SUCCESS != DecryptEEPROMEncryptedSection(encryptedSection))
    {
        return FALSE;
    }

    //
    // Copy in the HD key we used to lock the HD
    //
    memcpy(encryptedSection->HDKey, *XboxHDKey, XBOX_KEY_LENGTH);

    //
    // Reencrypt the EEPROM header
    //
    err = EncryptEEPROMEncryptedSection(encryptedSection);

    if (ERROR_SUCCESS != err)
    {
        return FALSE;
    }

    err = XSetValue(XC_MAX_ALL, REG_BINARY, &eepromData, sizeof(eepromData));

    if (ERROR_SUCCESS != err)
    {
        return FALSE;
    }
    }
#endif // HDSETUPAPP
#endif // INT2RETAIL

    return TRUE;
}



BOOL HDDisablePassword( BYTE* password, DWORD dwLen )
{
    NTSTATUS status;
    HANDLE h;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    OBJECT_STRING name;
    ULONG AtaPassThroughSize;
    ATA_PASS_THROUGH AtaPassThrough;
    IDE_SECURITY_DATA SecurityData;
    BOOL fReturn;
    DWORD cbBytes;

    RtlInitObjectString(&name, "\\Device\\Harddisk0\\Partition0");
    InitializeObjectAttributes(&obja, &name, 0, NULL, 0);

    status = NtOpenFile(&h, GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, &obja, &iosb,
        FILE_SHARE_WRITE | FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(status)) {

        RtlZeroMemory(&AtaPassThrough, sizeof(ATA_PASS_THROUGH));
        RtlZeroMemory(&SecurityData, sizeof(IDE_SECURITY_DATA));

        AtaPassThrough.IdeReg.bHostSendsData = TRUE;
        AtaPassThrough.IdeReg.bCommandReg = IDE_COMMAND_SECURITY_DISABLE_PASSWORD;
        AtaPassThrough.DataBufferSize = sizeof(IDE_SECURITY_DATA);
        AtaPassThrough.DataBuffer = &SecurityData;
        SecurityData.Maximum = TRUE;
        SecurityData.Master = FALSE;

        RtlCopyMemory(SecurityData.Password, password, dwLen);

        fReturn = DeviceIoControl(h, IOCTL_IDE_PASS_THROUGH,
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &cbBytes, NULL);

        if (!fReturn) {
            XDBGTRC("HDDisablePassword", "API error!");
            return FALSE;
        } else if (AtaPassThrough.IdeReg.bCommandReg & 1) {
            XDBGTRC("HDDisablePassword", "IDE error!");
            return FALSE;
        }

        NtClose(h);
    }

    return TRUE;
}




#ifdef INT2RETAIL
static 
void 
ProgramEEPROM()
{
    EEPROM_LAYOUT ExistingEEPROM;
    EEPROM_LAYOUT NewEEPROM;
    ULONG type;
    ULONG dwBytes;
    DWORD dwRetVal;
    HANDLE hFile;
    XBOX_FACTORY_SETTINGS* pNewFactorySettings;
    XBOX_FACTORY_SETTINGS* pExistingFactorySettings;

    DrawMessage(L"Programming EEPROM", L"Please wait", -1);

    //
    // Read the eeprom image from disk
    //
    hFile = CreateFile("D:\\eeprom.bin", GENERIC_READ, 0, NULL, OPEN_EXISTING, 
        FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        FAIL_RECOVERY(31);
    }

    if (!ReadFile(hFile, &NewEEPROM, sizeof(NewEEPROM), &dwBytes, NULL) || dwBytes != 256) {
        CloseHandle(hFile);
        FAIL_RECOVERY(32);
    }
    CloseHandle(hFile);

    //
    // Read the existing EEPROM
    //
    dwRetVal = XQueryValue(XC_MAX_ALL, &type, &ExistingEEPROM, sizeof(ExistingEEPROM), &dwBytes);
    if (dwRetVal != ERROR_SUCCESS) {
        FAIL_RECOVERY(33);
    }

    //
    // Copy the ehternet address from existing to new
    //

    pNewFactorySettings = (XBOX_FACTORY_SETTINGS*)&NewEEPROM.FactorySection;
    pExistingFactorySettings = (XBOX_FACTORY_SETTINGS*)&ExistingEEPROM.FactorySection;

    memcpy(pNewFactorySettings->EthernetAddr, pExistingFactorySettings->EthernetAddr, 6);

    //
    // Calculate the checksum
    //
    pNewFactorySettings->Checksum = 0;
    pNewFactorySettings->Checksum = ~XConfigChecksum(pNewFactorySettings, sizeof(XBOX_FACTORY_SETTINGS));

    //
    // Write out the new EEPROM
    //
    dwRetVal = XSetValue(XC_MAX_ALL, REG_BINARY, &NewEEPROM, sizeof(NewEEPROM));
    if (dwRetVal != ERROR_SUCCESS) {
        FAIL_RECOVERY(34);
    }

}

#endif  // INT2RETAIL


#endif // RECOVERYAPP

#ifdef DASHLIB

static PFNRECPROGRESSCALLBACK g_spDashCallback = NULL;
static ULONG_PTR g_DashContext = NULL;

VOID
CALLBACK
RecFormatProgress(
    UINT uPercent
    )
{
    //
    // Subtract out the dashboard partition (partition2)
    //

    UINT uPartitions = (XDISK_FIRST_CACHE_PARTITION - 1) + *HalDiskCachePartitionCount - 1;
    UINT uCurPartition = g_CurrentFormatPartition;

    if (uCurPartition >= DASHBOARD_PARTITION_NUMBER)
    {
        uCurPartition--;
    }


    UINT uOverallPercent = ((100 / uPartitions) * (uCurPartition - 1)) + (uPercent / uPartitions);

    XDBGWRN("RECOVERY",
            "Recovery format is %d%% complete",
            uOverallPercent);

    if (g_spDashCallback)
    {
        g_spDashCallback(uOverallPercent, g_DashContext);
    }
}

#endif // DASHLIB

#ifdef RECOVERYAPP

BOOL IsEEPROMKeyAllZeros()
{
    int i;
    UCHAR* EepromKey = (UCHAR*) *XboxEEPROMKey;

    //
    // Check to see if the EEPROM key is zero (which happens after warm reboots).
    //
    // If this is the case, we can't run recovery
    // (which needs to decrypt/encrypt the EEPROM)
    //

    for (i = 0; i < XBOX_KEY_LENGTH; i++)
    {
        if (0 != EepromKey[i])
        {
            return FALSE;
        }
    }

    return TRUE;
}

#endif // RECOVERYAPP

#ifdef RECOVERYAPP
void __cdecl main()
#endif // RECOVERYAPP
#ifdef DASHLIB
extern "C"
{
ULONG DashRecovery(PFNRECPROGRESSCALLBACK pfnCallback, ULONG_PTR Context)
#endif // DASHLIB
{
    IO_STATUS_BLOCK statusBlock;
    DISK_GEOMETRY diskGeometry;
    OBJECT_ATTRIBUTES oa;
    HANDLE hDisk;
    NTSTATUS Status;
    int i;
    
#ifdef DASHLIB
    g_spDashCallback = pfnCallback;
    g_DashContext = Context;
#endif // DASHLIB

#ifdef RECOVERYAPP
    WCHAR szText[128];
    DWORD dwVideoFlags;
    BOOL fRetail = FALSE;
    UINT WaitStep = 0;
    BYTE FinalHardDriveKey[XC_SERVICE_DIGEST_SIZE];
    BOOL fDiskHasRetail = (0xFFFFFFFF != GetFileAttributes("D:\\RETAIL"));
    DWORD dwNV2ARevision = *((DWORD*)0xFD000000);
    CHAR szSMCVersion[4];

    GetSMCVersion(szSMCVersion, ARRAYSIZE(szSMCVersion));
    
#ifdef ONLINEBETA
	g_fInternalCD = fDiskHasRetail = FALSE;
#else
    g_fInternalCD = (0xFFFFFFFF != GetFileAttributes("D:\\DEVKIT\\DXT\\CYDRIVE.DXT"));
#endif

    //
    // Initialize core peripheral port support
    //
    XInitDevices(0,NULL);

#ifdef CHECK_EEPROM_SETTINGS
    CheckNonVolatileSettings();
#endif

    g_pVideo = new CXBoxVideo;
    g_pBackgroundBitmap = new BitmapFile;

    if ((NULL == g_pVideo) || (NULL == g_pBackgroundBitmap))
    {
        XDBGERR("RECOVERY", "Couldn't allocate video objects");
        Sleep(INFINITE);
    }

    g_pBackgroundBitmap->read(0, 0, FILE_DATA_IMAGE_DIRECTORY_A "\\backgrnd.bmp");

    g_pVideo->Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );

#ifndef HDSETUPAPP

    DetectInitTableVersion();

    //
    // Init table version < 0x40: Old DVT 3 Boxes with NV2A A02 old metal 7 (NVCLK 155, CPU 665)
    // Init table version = 0x40: New DVT 3 Boxes with NV2A A02 new metal 7 (Faster)
    // Init table version = 0x46: DVT4, DVT5, XDK2 (FAB F)
    // Init table version = 0x60: DVT6+, XDK2 (FAB G/H)
    // Init table version = 0x70: QT (MCP C03)
    //

    //
    // SMC Versions starting with 'B' are no longer supported (DVT3=B2A, DVT4=B3B, etc.)
    //
    // DVT5/XDK2 and greater start with 'D' or 'P' (i.e. DVT5=DXB)
    //
    
    if (((g_InitTableVer & 0xFF) < 0x46) ||
        ((dwNV2ARevision & 0xFF) == 0xA1) ||
        ((dwNV2ARevision & 0xFF) == 0xA2) ||
        (szSMCVersion[0] == 'B'))
    {
        DrawMessage(RStrings[RS_FAILURE_LINE1], RStrings[RS_FAILURE_LINE2_OLD_BOX], -1);
        XDBGWRN("RECOVERY", "Recovery failed because this Xbox is no longer supported");

        XDBGWRN("RECOVERY", "Versions: 0x%08x, 0x%02x, %s",
                g_InitTableVer, (dwNV2ARevision & 0xFF), szSMCVersion);

        IDirect3DDevice8* pDevice = g_pVideo->GetD3DDevicePtr();
        ASSERT(pDevice);
        pDevice->BlockUntilIdle();

        Sleep(INFINITE);
        return;
    }

    if (IsEEPROMKeyAllZeros())
    {
        DrawMessage(RStrings[RS_FAILURE_LINE1], RStrings[RS_FAILURE_LINE2_WARM_BOOT], -1);
        XDBGWRN("RECOVERY", "Recovery failed because this Xbox needs to have been cold booted");

        IDirect3DDevice8* pDevice = g_pVideo->GetD3DDevicePtr();
        ASSERT(pDevice);
        pDevice->BlockUntilIdle();

        Sleep(INFINITE);
        return;
    }

#endif // ! HDSETUPAPP

#ifdef HDSETUPAPP
    if ((XboxKrnlVersion->Build < 3944) && (XboxKrnlVersion->Major == 1) && (XboxKrnlVersion->Minor == 0))
    {
        DrawMessage(RStrings[RS_FAILURE_LINE1], RStrings[RS_FAILURE_LINE2_OLD_BOX], -1);
        XDBGWRN("RECOVERY", "Recovery failed because this Xbox is no longer supported");

        IDirect3DDevice8* pDevice = g_pVideo->GetD3DDevicePtr();
        ASSERT(pDevice);
        pDevice->BlockUntilIdle();

        Sleep(INFINITE);
        return;
    }
#endif // HDSETUPAPP

    DrawMessage(RStrings[RS_GAMEPAD_BEGIN_LINE1], RStrings[RS_GAMEPAD_BEGIN_LINE2], -1);

    while (WaitStep < 2)
    {
        WaitForAnyButton(&dwVideoFlags, &fRetail);

        if (0xFFFFFFFF != dwVideoFlags)
        {
            //
            // Reset video flags and re-init
            //

            ExSaveNonVolatileSetting(XC_FACTORY_AV_REGION, REG_DWORD, &dwVideoFlags, sizeof(dwVideoFlags));

            D3D__AvInfo = 0;

            g_pVideo->DeInitialize();

            g_pVideo->Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );

            g_pVideo->ClearScreen(COLOR_BLACK);
            g_pBackgroundBitmap->render(g_pVideo->GetD3DDevicePtr());
            g_pVideo->ShowScreen();
        }
        else
        {
            WaitStep++;
#ifndef HDSETUPAPP
            if (!fDiskHasRetail)
            {
                fRetail = FALSE;
                break;
            }
#endif // HDSETUPAPP
        }

        //
        // Wait for the button to go back up before asking for another button press
        //
        
        if ((WaitStep > 0) && (WaitStep < 2))
        {
            Sleep(200);
        }
        
        DrawMessage(RStrings[(0 == WaitStep) ? RS_GAMEPAD_BEGIN_LINE1 : RS_RETAIL_LINE1],
                    RStrings[(0 == WaitStep) ? RS_GAMEPAD_BEGIN_LINE2 : RS_RETAIL_LINE2],
                    -1);

    }

#ifdef ONLINEBETA
	if(!FLoadNewEEPROMKey("D:\\BETA.DAT", "Beta2002_key1set")) {
		XDBGWRN("RECOVERY", "Recovery failed because it could not load the new EEPROM key");
		FAIL_RECOVERY(25);
	}
#endif

#ifndef HDSETUPAPP
    if (ERROR_SUCCESS != PrepareEEPROM())
    {
        XDBGWRN("RECOVERY", "Recovery failed because it could not prepare the EEPROM");
        FAIL_RECOVERY(25);
    }
#endif // HDSETUPAPP

#ifndef RECOVERYNOFLASH
    UpdateROMImage(fRetail);
#endif

    DrawMessage(RStrings[RS_PREPARING], NULL, 0);

#endif // RECOVERYAPP



    //
    // Open a handle to the entire hard disk (aka Partition0)
    //

    InitializeObjectAttributes(&oa,
                               (POBJECT_STRING) &PrimaryHarddisk,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenFile(&hDisk,
                        SYNCHRONIZE | GENERIC_ALL,
                        &oa,
                        &statusBlock,
                        0,
                        FILE_SYNCHRONOUS_IO_ALERT);

    if (!NT_SUCCESS(Status))
    {
        XDBGERR("RECOVERY", "Could not open hard disk %Z (0x%08x).", &PrimaryHarddisk, Status);
        FAIL_RECOVERY(13);
    }

    Status = WriteFirstSectors(hDisk);

    if (!NT_SUCCESS(Status))
    {
        XDBGERR("RECOVERY",
                "WriteFirstSectors() failed (0x%08x) for hard disk %Z.",
                Status,
                &PrimaryHarddisk);
        FAIL_RECOVERY(14);
    }

    NtClose(hDisk);

    XDBGTRC("RECOVERY", "Formatting hard disk partitions...");

    for (g_CurrentFormatPartition = 1;
         g_CurrentFormatPartition < XDISK_FIRST_CACHE_PARTITION + *HalDiskCachePartitionCount;
         g_CurrentFormatPartition++)
    {
        OCHAR szPartition[MAX_PATH];
        OBJECT_STRING PartitionString;

#ifdef DASHLIB
        //
        // If we're running recovery from within the dash, don't reformat the dash partition:
        //

        if (DASHBOARD_PARTITION_NUMBER == g_CurrentFormatPartition)
        {
            continue;
        }
#endif // DASHLIB

        _snoprintf(szPartition,
                   ARRAYSIZE(szPartition),
                   HdPartitionX,
                   g_CurrentFormatPartition);

        RtlInitObjectString(&PartitionString, szPartition);

        if (!RecFormatFATVolume(
                &PartitionString,
                QUICK_FORMAT,
                RecFormatProgress))
        {
            XDBGERR("RECOVERY", "Could not format hard disk partition %d.", g_CurrentFormatPartition);
            FAIL_RECOVERY(100 + g_CurrentFormatPartition);
        }
    }

#ifdef DASHLIB

    //
    // We're assuming that the dash already has the C: drive mapped
    //
    
    if (!CreateDirectory("C:\\TDATA", NULL))
    {
        FAIL_RECOVERY(20);
    }
    
    if (!CreateDirectory("C:\\UDATA", NULL))
    {
        FAIL_RECOVERY(21);
    }

    Status = ResetEEPROMUserSettings();

    if (!NT_SUCCESS(Status))
    {
        XDBGERR("RECOVERY", "Dash recovery failed because ResetEEPROMUserSettings() failed");
        HalReturnToFirmware(HalFatalErrorRebootRoutine);
    }

#endif // DASHLIB

#ifdef RECOVERYAPP

    DrawMessage(RStrings[RS_COPYING], NULL, 5);

    
    //
    // Give the main partition a drive letter
    //

    if (!NT_SUCCESS(IoCreateSymbolicLink((POBJECT_STRING) &CDrive, (POBJECT_STRING) &HdPartition1)))
    {
        XDBGERR("RECOVERY", "Could not assign %Z to %Z", &CDrive, &HdPartition1);
        FAIL_RECOVERY(15);
    }

#ifdef SECTORCOPY

    WriteDiskSnapshot();

#else  // SECTORCOPY

#ifndef HDSETUPAPP
    if (fRetail)
    {
        if (!CreateDirectory("C:\\TDATA", NULL))
        {
            FAIL_RECOVERY(22);
        }
        
        if (!CreateDirectory("C:\\UDATA", NULL))
        {
            FAIL_RECOVERY(23);
        }
    }
    else
#endif // HDSETUPAPP
    {
        if (!CopyFiles(OTEXT("D:\\*"), OTEXT("C:\\"), TRUE, NULL, 0))
        {
            XDBGERR("RECOVERY", "Could not copy files to the hard disk (main partition)");
            FAIL_RECOVERY(16);
        }
    }

    //
    // Give the dash partition a drive letter
    //

    if (!NT_SUCCESS(IoCreateSymbolicLink((POBJECT_STRING) &YDrive, (POBJECT_STRING) &HdPartition2)))
    {
        XDBGERR("RECOVERY", "Could not assign %Z to %Z", &YDrive, &HdPartition2);
        FAIL_RECOVERY(17);
    }

    if (!CopyFiles(OTEXT("D:\\XDASH\\*"),
                   OTEXT("Y:\\"),
#ifdef HDSETUPAPP
                   FALSE, NULL, 0))
#else
                   fRetail,
                   fRetail ? g_RetailDashExceptions : NULL,
                   fRetail ? ARRAYSIZE(g_RetailDashExceptions) : 0))
#endif // HDSETUPAPP
    {
        XDBGERR("RECOVERY", "Could not copy files to the hard disk (dash partition)");
        FAIL_RECOVERY(18);
    }

#ifndef HDSETUPAPP

    if (fRetail)
    {
        //
        // Copy over the retail dash
        //

        if (!CopyFile("D:\\RETAIL\\xboxdash.xbe", "Y:\\xboxdash.xbe", FALSE))
        {
            FAIL_RECOVERY(24);
        }
    }

#endif // HDSETUPAPP

#endif // SECTORCOPY

#ifdef INT2RETAIL
    //
    // Unlock the hard drive
    //
    XcHMAC( (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH,
        (LPBYTE)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
        (LPBYTE)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
        FinalHardDriveKey ) ;
    
    HDDisablePassword(FinalHardDriveKey, XC_SERVICE_DIGEST_SIZE);

    //
    // Program the EEPROM
    //
    ProgramEEPROM();

    //
    // Lock the HDD
    //

    XcHMAC( (LPBYTE)"INT2RETAILHDKEY", XBOX_KEY_LENGTH,
        (LPBYTE)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
        (LPBYTE)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
        FinalHardDriveKey ) ;
 
    if (!HDSetPassword( FinalHardDriveKey, XC_SERVICE_DIGEST_SIZE )) {
        XDBGERR("RECOVERY", "Could not lock HD");
        FAIL_RECOVERY(26);
    }


#else // INT2RETAIL


#ifdef HDSETUPAPP

    //
    // Compute Key to use to lock hard drive
    //
    if(fRetail) {
        /* We're locking, so use the HD_KEY */
        XcHMAC( (LPBYTE) HD_KEY, XBOX_KEY_LENGTH,
            (LPBYTE)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
            (LPBYTE)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
            FinalHardDriveKey );
    } else {
        /* We're unlocking, so use the EEPROM key */
        XcHMAC( (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH,
            (LPBYTE)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
            (LPBYTE)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
            FinalHardDriveKey ) ;
        /* Now perform the unlock */
        HDDisablePassword(FinalHardDriveKey, XC_SERVICE_DIGEST_SIZE);
    }

#else  // HDSETUPAPP

#ifndef ONLINEBETA
    if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) != 0)
    {
        RtlZeroMemory( (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH );
    }
#endif

    //
    // Compute Key to use to lock hard drive
    //
    XcHMAC( (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH,
            (LPBYTE)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
            (LPBYTE)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
            FinalHardDriveKey ) ;

#endif // HDSETUPAPP

    if(
#ifdef HDSETUPAPP
        fRetail &&
#endif
        !HDSetPassword( FinalHardDriveKey, XC_SERVICE_DIGEST_SIZE ))
    {
        XDBGERR("RECOVERY", "Could not lock HD");
        FAIL_RECOVERY(26);
    }

#endif  // !INT2RETAIL

    DrawMessage(RStrings[RS_COPYING], NULL, 100);

    if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) != 0)
    {
        XDBGTRC("RECOVERY", "\n\nPlease remove the recovery CD and then press any gamepad button to reboot...\n");

        DrawMessage(RStrings[RS_GAMEPAD_END_LINE1], RStrings[RS_GAMEPAD_END_LINE2], -1);

        EjectDVD();
    }
    else
    {
        //
        // We can't eject the CD if we're running on the retail kernel, so we have to ask the
        // user to eject instead...
        //
        
        XDBGTRC("RECOVERY", "\n\nPlease eject and remove the recovery CD and then press any gamepad button to reboot...\n");

        DrawMessage(RStrings[RS_GAMEPAD_END_RETAIL], NULL, -1);
    }

    WaitForAnyButton(&dwVideoFlags, NULL);

    if (0xFFFFFFFF != dwVideoFlags)
    {
        //
        // Reset video flags before rebooting
        //

        ExSaveNonVolatileSetting(XC_FACTORY_AV_REGION, REG_DWORD, &dwVideoFlags, sizeof(dwVideoFlags));
    }

    XDBGWRN("RECOVERY", "Recovery completed successfully.");

    HalReturnToFirmware( HalRebootRoutine );
}

#endif // RECOVERYAPP

#ifdef DASHLIB

    //
    // Return zero to indicate success
    //

    return 0;
}

}
#endif // DASHLIB
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\recovery\xboxvideo.h ===
/*****************************************************
*** xboxvideo.h
***
*** Header file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#ifndef _XBOXVIDEO_H_
#define _XBOXVIDEO_H_

#include "constants.h"

// Macros
#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) XDBGWRN( APP_TITLE_NAME_A, #code "File %s Line %d, Failed: %d", __LINE__, __FILE__, _ret__); } while (0);

#define NUM_VB_VERTS            100

// XBox configuration
class CXBoxVideo
{
public:
    // Constructors and Destructors
    CXBoxVideo( void );
    ~CXBoxVideo( void );

    // Public Properties

    // Public Methods
    void Initialize( int width,                         // Initialize D3D for this screen -- height and width default
                     int height );
    
    void DeInitialize( void );                          // Free our objects
    void ClearScreen( DWORD color );                    // Clear the current screen
    
    void DrawBox( float x1,                             // Draw a box on the screen
                  float y1,
                  float x2,
                  float y2,
                  DWORD color );

    void DrawBitBlt( float fx,                          // Draw the inputed bit array to the screen
                     float fy,
                     ULONG ulWidth,
                     ULONG ulHeight,
                     const DWORD* pData );
    
    void DrawClearRect( float x1,                       // Draw a clear rectangle to the screen
                        float y1,
                        float x2,
                        float y2,
                        DWORD color );

    HRESULT DrawLine( float x1,                         // Draw a line on the screen
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    void DrawOutline( float x1,                         // Draw an outline at the current location with a specific border size
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    int DrawText( float x1,                             // Prints formatted text, using the default font size and color
                  float y1,
                  DWORD fgcolor,
                  DWORD bgcolor,
                  const TCHAR* format,
                  ... );

    int GetStringPixelWidth( IN LPCWSTR string,         // Get the pixel width of a string
                             IN int length = -1 );

    int GetStringPixelWidth( IN char* string,           // Get the pixel width of a char*
                             IN int length /*=-1*/ ); 

    void GetFontSize( unsigned int* pheight,            // Get the size of the currently selected font
                      unsigned int* pdecent );

    void LightenImage( int nWidth,                      // Lighten the image specified by "pBits"
                       int nHeight,
                       DWORD* pBits,
                       DWORD dwAddto );
    void DarkenImage( int nWidth,                       // Darken the image specified by "pBits"
                      int nHeight,
                      DWORD* pBits,
                      DWORD dwSubtract );

    HRESULT TruncateStringToFit( char* pString,         // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    HRESULT TruncateStringToFit( WCHAR* pString,        // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    IDirect3DDevice8* GetD3DDevicePtr() { return m_Device; }; // Return the D3DDevice pointer to the caller

    void ShowScreen();                                  // Display the current backbuffer on the screen

    HRESULT GetTransform( D3DTRANSFORMSTATETYPE State,  // Get the D3D Transform
                          D3DMATRIX* pMatrix );         // Set the D3D Transform

    HRESULT SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix );

    HRESULT SetVertexShader( DWORD Handle );            // Set the D3D Vertex Shader
    HRESULT GetVertexShader( DWORD* pHandle );          // Get the D3D Vertex Shader



private:
    // Vertext structure
    struct MYVERTEX
    {
	    D3DXVECTOR3 v;
	    float       fRHW;
	    D3DCOLOR    cDiffuse;
    };

    // Private Properties
    IDirect3DDevice8* m_Device;
    IDirect3DSurface8* m_BackBuffer;
    IDirect3DVertexBuffer8* m_VertexBuffer;
    int m_ScreenWidth; 
    int m_ScreenHeight;
    
    // Font Properties
    XFONT* m_Font;
    float m_FontWidth;
    float m_FontHeight;
    DWORD m_FontColor;
    DWORD m_FontBgColor;

    // Private Methods
};

#endif // _XBOXVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\recovery\xboxvideo.cpp ===
/*****************************************************
*** xboxvideo.cpp
***
*** CPP file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#include "recovpch.h"
#include "xboxvideo.h"

// Constructor
CXBoxVideo::CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::CXBoxVideo()" );

    m_Device = NULL;
    m_BackBuffer = NULL;
    m_VertexBuffer = NULL;

    // Font properties
    m_Font = NULL;
    m_FontWidth = FONT_DEFAULT_WIDTH;
    m_FontHeight = FONT_DEFAULT_HEIGHT;
    m_FontColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
    m_FontBgColor = SCREEN_DEFAULT_TEXT_BG_COLOR;

    m_ScreenWidth = SCREEN_WIDTH;       // Default the screen width to 640
    m_ScreenHeight = SCREEN_HEIGHT;     // Default the screen height to 480
}

// Destructor
CXBoxVideo::~CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::~CXBoxVideo()" );

    if( m_Device )
    {
        m_Device->Release();
        m_Device = NULL;
    }
    
    if( m_BackBuffer )
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_VertexBuffer )
    {
        m_VertexBuffer->Release();
        m_VertexBuffer = NULL;
    }
}

// Clear the screen
void CXBoxVideo::ClearScreen( DWORD color )
{
    if( FAILED( m_Device->Clear( 0, NULL, D3DCLEAR_TARGET, color, 1.0f, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXboxVideo::ClearScreen():Failed to clear the screen!!" );
    }
}


// Draw the inputed bit array to the screen
//
// Parameters:
//      fx - the upper left x coordinate on screen
//      fy - the upper left y coordinate on screen
//      ulWidth - the width of the bitmap
//      ulHeight - the height of the bitmap
//      pData - a pointer to the array of pixel values
void CXBoxVideo::DrawBitBlt( float fx, float fy, ULONG ulWidth, ULONG ulHeight, const DWORD* pData )
{
    // Check to make sure we received a valid pointer
    if( !pData )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawBitBlt():pData not a valid pointer!" );

        return;
    }

    // Draw the bitmap on the screen, pixel by pixel
	for ( ULONG y = 0; y < ulHeight; y++ )
	{
		for ( ULONG x = 0; x < ulWidth; x++ )
		{
			if ( 0 != pData[y * ulWidth + x] )
			{
				DrawLine( fx + x, fy + y, fx + x, fy + y, 1.0f, pData[y * ulWidth + x] );
			}
		}
	}
}

// Draw a box on the screen
void CXBoxVideo::DrawBox( float x1, float y1, float x2, float y2, DWORD color )
{
	MYVERTEX* pb;
	float maxx, minx;
	float maxy, miny;

	CHECK( m_Device->BeginScene() );
	CHECK( m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * 4, (BYTE**)&pb, 0 ) );
	
	if( IsBadWritePtr( pb, 128 ) )
	{
		XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawBox(): Lockreturned '%p', which is BAD!", pb );

		return;
	}

	if( x1 < x2 )
    {
		minx = x1;
		maxx = x2;
	}
    else
    {
		minx = x2;
		maxx = x1;
	}

	if( y1 < y2 )
    {
		miny = y1;
		maxy = y2;
	}
    else
    {
		miny = y2;
		maxy = y1;
	}

	if( x1 == x2 )
    {
		maxx++;
	}

	pb[0].v.x = minx; pb[0].v.y = miny; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
	pb[1].v.x = maxx; pb[1].v.y = miny; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
	pb[2].v.x = maxx; pb[2].v.y = maxy; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
	pb[3].v.x = minx; pb[3].v.y = maxy; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = color;

	m_VertexBuffer->Unlock();

	m_Device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
	m_Device->EndScene();
}


// Draw a clear rectangle to the screen
void CXBoxVideo::DrawClearRect( float x1, float y1, float x2, float y2, DWORD color ) 
{
	D3DRECT rect;

	if ( m_Device )
	{
		if( x1 < x2 )
        {
			rect.x1 = (long)x1; 
			rect.x2 = (long)x2 + 1;
		}
        else
        {
			rect.x1 = (long)x2; 
			rect.x2 = (long)x1 + 1;
		}

		if( y1 < y2 )
        {
			rect.y1 = (long)y1;
			rect.y2 = (long)y2 + 1;
		}
        else
        {
			rect.y1 = (long)y2;
			rect.y2 = (long)y1 + 1;
		}

		m_Device->Clear( 1, &rect, D3DCLEAR_TARGET, color, 0, 0 );
	}
}

// Draw a line to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      color          --- the RGBA color to draw the box with
HRESULT CXBoxVideo::DrawLine( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    HRESULT hr = S_OK;     // Return code for D3D functions that are called, and for the function
	MYVERTEX* pb;   // Vertex information

    // Set the line width
    if( FAILED( hr = m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Failed: m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth )! - '%d'", hr );
    }

    // Before any rendering can be done, this must be called
	if( FAILED( hr = m_Device->BeginScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->BeginScene()! - '%d'", hr );
    }

    // Locks a range of vertex data and obtains a pointer to the vertex buffer memory.
	if( FAILED( hr = m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * NUM_VB_VERTS, (BYTE**)&pb, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Lock()! - '%d'", hr );
    }

    pb[0].v.x = x1;  pb[0].v.y = y1; pb[0].v.z = .1f;  pb[0].fRHW = .9f;  pb[0].cDiffuse = color;
	pb[1].v.x = x2;  pb[1].v.y = y2; pb[1].v.z = .1f;  pb[1].fRHW = .9f;  pb[1].cDiffuse = color;

    // Unlock the vertext data
	if( FAILED( hr = m_VertexBuffer->Unlock() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Unlock()! - '%d'", hr );
        
        return hr;
    }

    // Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams
    if( FAILED( hr = m_Device->DrawPrimitive( D3DPT_LINELIST, 0, 1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->DrawPrimitive()! - '%d'", hr );
    }

    // Once rendering is complete, this must be called
    // We should try this, even on a failure, in case BeginScene() was successful
    // We'll report it to the debugger, but will not return the fail/success code to the
    // caller
	if( FAILED( m_Device->EndScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->EndScene()! - '%d'", hr );
    }

    return hr;
}

// Draw an outline to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      borderSize     --- width in pixels of the border
//      color          --- the RGBA color to draw the box with
void CXBoxVideo::DrawOutline( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    // Draw the box on the screen
    DrawLine( x1, y1, x1, y2, fLineWidth, color );     // Left Line
    DrawLine( x1, y2, x2, y2, fLineWidth, color );     // Bottom Line
    DrawLine( x2, y2, x2, y1, fLineWidth, color );     // Right Line
    DrawLine( x2, y1, x1, y1, fLineWidth, color );     // Top Line
}


// DeInitialize our Screen by freeing our objects
void CXBoxVideo::DeInitialize( void )
{
    if( m_BackBuffer)
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_Device )
    {
	    m_Device->Release();
        m_Device = NULL;
    }
}

// Prints formatted text using the default font to the screen
// Set colors to 0 to use default color
int CXBoxVideo::DrawText( float x1, float y1, DWORD fgcolor, DWORD bgcolor, const TCHAR* format, ... )
{
    if( !m_Font )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():The font is not set!!" );
        return -1;
    }

	int i;                  // Return Value
	HRESULT hr;             // Return Value for XFONT
	va_list v;              // Argument List
	TCHAR wstr[256];        // Honkin Buffer
    DWORD currentFGColor;   // Current FG Color
    DWORD currentBGColor;   // Current FG Color

    // Set our FONT colors if the user wishes to
    if( fgcolor || bgcolor )
    {
        // Set the foreground color if the user wants to
        if( fgcolor )
        {
            XFONT_SetTextColor( m_Font, fgcolor );
        }

        // Set the background color if the user wants to
        if( bgcolor )
        {
            XFONT_SetBkColor( m_Font, bgcolor );
        }
    }

	va_start( v, format );
	i = wvsprintf( wstr, format, v );

    // Print the Text to the backbuffer
    hr = XFONT_TextOut( m_Font, m_BackBuffer, wstr, i, (long)x1, (long)y1 );

    // If we have a valid font object, check the HRESULT
    if( FAILED( hr ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():XFONT_TextOut failed!!  HRESULT: %x", hr );
    }

	va_end( v );
	
    return i;
}

// Get the size of the current font
void CXBoxVideo::GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():The font is not set!!" );

        return;
    }

    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():Invalid arguments passed!!" );

        return;
    }

    XFONT_GetFontMetrics( m_Font, pheight, pdecent );
}

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int CXBoxVideo::GetStringPixelWidth( IN LPCWSTR string, IN int length /*=-1*/ ) 
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):The font is not set!!" );

        return -1;
    }
    
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!" );

        return -1;
    }

	unsigned int outlen = 0;        // Return value

	XFONT_GetTextExtent( m_Font, string, length, &outlen );
	
    return outlen;
}

// Get the width of the char*
int CXBoxVideo::GetStringPixelWidth( IN char* string, IN int length /*=-1*/ ) 
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( char* ):Invalid pointer passed in!" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}

// Get a D3D Transform
HRESULT CXBoxVideo::GetTransform( D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix )
{
    return m_Device->GetTransform( State, pMatrix );
}

// Get the D3D Vertex Shader
HRESULT CXBoxVideo::GetVertexShader( DWORD* pHandle )
{
    return m_Device->GetVertexShader( pHandle );
}

// Lighten the image specified by "pBits"
void CXBoxVideo::LightenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwAddto )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwAddto];
		pshufw mm0, mm0, 01000100b
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		paddusb mm1, mm0 ;//add, saturating to 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Darken the image specified by "pBits"
void CXBoxVideo::DarkenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwSubtract )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwSubtract];
		pshufw mm0, mm0, 01000100b ;;//propegate "subtract" into both dwords of mm0
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		psubusb mm1, mm0 ;//subtract, saturating to 0 or 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Initialize D3D for this screen
void CXBoxVideo::Initialize( int width = SCREEN_WIDTH, int height = SCREEN_HEIGHT )
{
    IDirect3D8* pD3D = NULL;
    m_ScreenWidth = width;
    m_ScreenHeight = height;

	if ( m_Device == NULL )
	{
        // Create D3D 8.
		if( FAILED( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize(): Failed to create pD3D!" );
			return;
        }

        // Set the screen mode.
		D3DPRESENT_PARAMETERS d3dpp;
		ZeroMemory( &d3dpp, sizeof( d3dpp ) );

		d3dpp.BackBufferWidth                 = width;
		d3dpp.BackBufferHeight                = height;
		d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
		d3dpp.BackBufferCount                 = 1;

        d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
		d3dpp.Windowed                        = FALSE;                   // Must be false for Xbox
		d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
        d3dpp.EnableAutoDepthStencil          = FALSE; // TRUE;
        d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;

    // Always do interlaced output on an HDTV.
    if (XGetAVPack() == XC_AV_PACK_HDTV)
    {
        d3dpp.Flags = D3DPRESENTFLAG_INTERLACED;
    }

		// Create the m_Device.
		if ( FAILED ( pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                          D3DDEVTYPE_HAL,
                                          NULL,      // Ignored on Xbox
                                          D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                          &d3dpp,
                                          &m_Device ) ) )
		{
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to CreateDevice!" );
			pD3D->Release();

			return;
		}

		// Now we no longer need the D3D interface so let's free it.
		pD3D->Release();
	}

    if( FAILED( m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) Failed!!" );
    }

    // Create our vertex buffer
	if( FAILED( m_Device->CreateVertexBuffer( sizeof( MYVERTEX ) * NUM_VB_VERTS, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to create the Vertex Buffer!!" );
    }

    // Set the stream source
	m_Device->SetStreamSource( 0, m_VertexBuffer, sizeof( MYVERTEX ) );

    // Set our initial vertex shader that is compatible with our 2D scene
	if( FAILED( m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) Failed!!" );
    }

    // Setup matricies
    // Setup our identity matrix
    D3DMATRIX mat;
    mat._11 = mat._22 = mat._33 = mat._44 = 1.0f;
    mat._12 = mat._13 = mat._14 = mat._41 = 0.0f;
    mat._21 = mat._23 = mat._24 = mat._42 = 0.0f;
    mat._31 = mat._32 = mat._34 = mat._43 = 0.0f;

    // World Matrix
    // The world matrix controls the position and orientation 
    // of the polygons in world space. We'll use it later to 
    // spin the triangle.
    D3DMATRIX WorldMatrix = mat;

    // Set the transforms for our 3D world
    if( FAILED( m_Device->SetTransform( D3DTS_WORLD, &WorldMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the World Matrix!!" );
    }
    
    // View Matrix
    // The view matrix defines the position and orientation of 
    // the camera. Here, we are just moving it back along the z-
    // axis by 10 units.
    D3DMATRIX ViewMatrix = mat;
    ViewMatrix._43 = 10.0f;

    if( FAILED( m_Device->SetTransform( D3DTS_VIEW, &ViewMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the View Matrix!!" );
    }

    // Projection Matrix
    // The projection matrix defines how the 3-D scene is "projected" 
    // onto the 2-D render target surface. 

    // Set up a very simple projection that scales x and y 
    // by 2, and translates z by -1.0.
    D3DXMATRIX ProjectionMatrix; //  = mat;
    D3DXMatrixPerspectiveFovLH( &ProjectionMatrix, 1.57f, 640.0f/480.0f, 0.001f, 30.0f );

    if( FAILED( m_Device->SetTransform( D3DTS_PROJECTION, &ProjectionMatrix ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the Projection Matrix!!" );
    }
    
    // Viewport
    D3DVIEWPORT8 D3DViewport;    // Direct3D Viewport

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = width;  // rect.right - rect.left;
    D3DViewport.Height = height; // rect.bottom - rect.top;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( m_Device->SetViewport( &D3DViewport ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set the viewport!!" );
    }
    
    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &m_Font );

	if( m_Font )
    {
	    if( FAILED( m_Device->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &m_BackBuffer ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->GetBackBuffer() Failed!!" );
        }

        XFONT_SetTextColor( m_Font, SCREEN_DEFAULT_TEXT_FG_COLOR );
        XFONT_SetTextAlignment( m_Font, XFONT_CENTER );
        XFONT_SetBkColor( m_Font, SCREEN_DEFAULT_TEXT_BG_COLOR );
        XFONT_SetTextHeight( m_Font, FONT_DEFAULT_HEIGHT );
        XFONT_SetTextAntialiasLevel( m_Font, FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( m_Font, FONT_DEFAULT_STYLE );
    }
}


// Set a D3D Transform
HRESULT CXBoxVideo::SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix )
{
    return m_Device->SetTransform( State, pMatrix );
};

// Display the current backbuffer on to the screen
void CXBoxVideo::ShowScreen()
{
	if( m_Device )
    {
		m_Device->Present( NULL, NULL, NULL, NULL );
	}
}


// Set the D3D Vertex Shader
HRESULT CXBoxVideo::SetVertexShader( DWORD Handle )
{
    return m_Device->SetVertexShader( Handle );
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\debug.c ===
//      TITLE("Debug Support Functions")
//++
//
// Copyright (c) 1990  Microsoft Corporation
//
// Module Name:
//
//    debug.c
//
// Abstract:
//
//    This module implements functions to support debugging NT.  They call
//    architecture specific routines to do the actual work.
//
// Author:
//
//    Steven R. Wood (stevewo) 8-Nov-1994
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//--

#include "stdarg.h"
#include "stdio.h"
#include "ntrtlp.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include <ntdbg.h>


ULONG
DbgPrint(
    PCHAR Format,
    ...
    )

//++
//
// Routine Description:
//
//    This routine provides a "printf" style capability for the kernel
//    debugger.
//
//    Note:  control-C is consumed by the debugger and returned to
//    this routine as status.  If status indicates control-C was
//    pressed, this routine breakpoints.
//
// Arguments:
//
//    Format     - printf style format string
//    ...        - additional arguments consumed according to the
//                 format string.
//
// Return Value:
//
//    Defined as returning a ULONG, actually returns status.
//
//--

{
    va_list arglist;
    UCHAR Buffer[512];
    int cb;
    STRING Output;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Format the output into a buffer and then print it.
    //

    va_start(arglist, Format);

    cb = _vsnprintf(Buffer, sizeof(Buffer), Format, arglist);

    va_end(arglist);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (cb == -1) {             // detect buffer overflow
        cb = sizeof(Buffer);
        Buffer[sizeof(Buffer) - 1] = '\n';
    }
    Output.Buffer = Buffer;
    Output.Length = (USHORT) cb;

    //
    // If APP is being debugged, raise an exception and the debugger
    // will catch and handle this. Otherwise, kernel debugger service
    // is called.
    //

    Status = DebugPrint( &Output );
    if (Status == STATUS_BREAKPOINT) {
        DbgBreakPointWithStatus(DBG_STATUS_CONTROL_C);
        Status = STATUS_SUCCESS;
    }
    return Status;
}

ULONG
DbgPrompt(
    IN PCHAR Prompt,
    OUT PCHAR Response,
    IN ULONG MaximumResponseLength
    )

//++
//
// Routine Description:
//
//    This function displays the prompt string on the debugging console and
//    then reads a line of text from the debugging console.  The line read
//    is returned in the memory pointed to by the second parameter.  The
//    third parameter specifies the maximum number of characters that can
//    be stored in the response area.
//
// Arguments:
//
//    Prompt - specifies the text to display as the prompt.
//
//    Response - specifies where to store the response read from the
//       debugging console.
//
//    Prompt - specifies the maximum number of characters that can be
//       stored in the Response buffer.
//
// Return Value:
//
//    Number of characters stored in the Response buffer.  Includes the
//    terminating newline character, but not the null character after
//    that.
//
//--

{

    STRING Input;
    STRING Output;

    //
    // Output the prompt string and read input.
    //

    Input.MaximumLength = (USHORT)MaximumResponseLength;
    Input.Buffer = Response;
    Output.Length = (USHORT)strlen( Prompt );
    Output.Buffer = Prompt;
    return DebugPrompt( &Output, &Input );
}

#if defined(NTOS_KERNEL_RUNTIME) || defined(BLDR_KERNEL_RUNTIME)


VOID
DbgLoadImageSymbols(
    IN PSTRING FileName,
    IN PVOID ImageBase,
    IN ULONG_PTR ProcessId
    )

//++
//
// Routine Description:
//
//    Tells the debugger about newly loaded symbols.
//
// Arguments:
//
// Return Value:
//
//--

{

    PIMAGE_NT_HEADERS NtHeaders;
    KD_SYMBOLS_INFO SymbolInfo;

    SymbolInfo.BaseOfDll = ImageBase;
    SymbolInfo.ProcessId = ProcessId;
    NtHeaders = RtlImageNtHeader( ImageBase );
    if (NtHeaders != NULL) {
        SymbolInfo.CheckSum = (ULONG)NtHeaders->OptionalHeader.CheckSum;
        SymbolInfo.SizeOfImage = (ULONG)NtHeaders->OptionalHeader.SizeOfImage;
    } else {
        SymbolInfo.SizeOfImage = 0;
        SymbolInfo.CheckSum    = 0;
    }

    DebugLoadImageSymbols( FileName, &SymbolInfo);

    return;
}


VOID
DbgUnLoadImageSymbols (
    IN PSTRING FileName,
    IN PVOID ImageBase,
    IN ULONG_PTR ProcessId
    )

//++
//
// Routine Description:
//
//    Tells the debugger about newly unloaded symbols.
//
// Arguments:
//
// Return Value:
//
//--

{
    KD_SYMBOLS_INFO SymbolInfo;

    SymbolInfo.BaseOfDll = ImageBase;
    SymbolInfo.ProcessId = ProcessId;
    SymbolInfo.CheckSum    = 0;
    SymbolInfo.SizeOfImage = 0;

    DebugUnLoadImageSymbols( FileName, &SymbolInfo );

    return;
}

#endif // defined(NTOS_KERNEL_RUNTIME)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\error.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains a routine for converting NT status codes
    to DOS/OS|2 error codes.

Author:

    David Treadwell (davidtr)   04-Apr-1991

Revision History:

--*/

#include <ntrtlp.h>
#include "winerror.h"
#include "error.h"

//
// Ensure that the Registry ERROR_SUCCESS error code and the
// NO_ERROR error code remain equal and zero.
//

#if ERROR_SUCCESS != 0 || NO_ERROR != 0
#error Invalid value for ERROR_SUCCESS.
#endif

ULONG
RtlNtStatusToDosError (
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine converts an NT status code to its DOS/OS 2 equivalent
    and returns the translated value.

Arguments:

    Status - Supplies the status value to convert.

Return Value:

    The matching DOS/OS 2 error code.

--*/

{

    ULONG Offset;
    ULONG Entry;
    ULONG Index;

    //
    // Convert any HRESULTs to their original form of a NTSTATUS or a
    // WIN32 error
    //


    if (Status & 0x20000000) {

        //
        // The customer bit is set so lets just pass the
        // error code on thru
        //

        return Status;

    }
    else if ((Status & 0xffff0000) == 0x80070000) {

        //
        // The status code  was a win32 error already.
        //

        return(Status & 0x0000ffff);
    }
    else if ((Status & 0xf0000000) == 0xd0000000) {

        //
        // The status code is a HRESULT from NTSTATUS
        //

        Status &= 0xcfffffff;
    }

    //
    // Scan the run length table and compute the entry in the translation
    // table that maps the specified status code to a DOS error code.
    //

    Entry = 0;
    Index = 0;
    do {
        if ((ULONG)Status >= RtlpRunTable[Entry + 1].BaseCode) {
            Index += (RtlpRunTable[Entry].RunLength * RtlpRunTable[Entry].CodeSize);

        } else {
            Offset = (ULONG)Status - RtlpRunTable[Entry].BaseCode;
            if (Offset >= RtlpRunTable[Entry].RunLength) {
                break;

            } else {
                Index += (Offset * (ULONG)RtlpRunTable[Entry].CodeSize);
                if (RtlpRunTable[Entry].CodeSize == 1) {
                    return (ULONG)RtlpStatusTable[Index];

                } else {
                    return (((ULONG)RtlpStatusTable[Index + 1] << 16) |
                                                (ULONG)RtlpStatusTable[Index]);
                }
            }
        }

        Entry += 1;
    } while (Entry < (sizeof(RtlpRunTable) / sizeof(RUN_ENTRY)));

    //
    // The translation to a DOS error code failed.
    //
    // The redirector maps unknown OS/2 error codes by ORing 0xC001 into
    // the high 16 bits.  Detect this and return the low 16 bits if true.
    //

    if (((ULONG)Status >> 16) == 0xC001) {
        return ((ULONG)Status & 0xFFFF);
    }

#ifndef NTOS_KERNEL_RUNTIME
    DbgPrint("RTL: RtlNtStatusToDosError(0x%lx): No Valid Win32 Error Mapping\n",Status);
    DbgPrint("RTL: Edit ntos\\rtl\\generr.c to correct the problem\n");
    DbgPrint("RTL: ERROR_MR_MID_NOT_FOUND is being returned\n");

#if DBG
    DbgBreakPoint();
#endif // DBG

#endif // NTOS_KERNEL_RUNTIME

    return ERROR_MR_MID_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\error.h ===
//
// Define run length table entry structure type.
//

typedef struct _RUN_ENTRY {
    ULONG BaseCode;
    USHORT RunLength;
    USHORT CodeSize;
} RUN_ENTRY, *PRUN_ENTRY;

//
// Declare translation table array.
//

CONST USHORT RtlpStatusTable[] = {
    0x0000, 0x03e5, 0x00ea, 0x0514, 0x0515, 0x03fe, 0x0516, 
    0x0057, 0x0517, 0x0460, 0x03f6, 0x0461, 0x0518, 0x0720, 
    0x0779, 0x0001, 0x8000, 0x03e6, 0x0000, 0x0003, 0x8000, 
    0x0004, 0x8000, 0x00ea, 0x0000, 0x0012, 0x0000, 0x056f, 
    0x012b, 0x001c, 0x0015, 0x0015, 0x00aa, 0x0103, 0x00fe, 
    0x00ff, 0x00ff, 0x0456, 0x0103, 0x044d, 0x0456, 0x0457, 
    0x044c, 0x044e, 0x044f, 0x0450, 0x0962, 0x048d, 0x048e, 
    0x05aa, 0x0006, 0x0001, 0x0035, 0x054f, 0x0554, 0x0120, 
    0x0554, 0x0057, 0x0057, 0x0032, 0x0558, 0x052e, 0x0057, 
    0x0520, 0x0005, 0x0005, 0x051f, 0x0554, 0x06f8, 0x0057, 
    0x007a, 0x0574, 0x06fe, 0x0057, 0x0057, 0x0532, 0x1770, 
    0x1771, 0x0001, 0x001f, 0x0001, 0x0057, 0x0018, 0x03e6, 
    0x03e7, 0x05ae, 0x0006, 0x03e9, 0x00c1, 0x0057, 0x0057, 0x0000, 
    0x0002, 0x0000, 0x0002, 0x0000, 0x0001, 0x0000, 0x0026, 0x0000, 
    0x0022, 0x0000, 0x0015, 0x0000, 0x06f9, 0x0000, 0x001b, 0x0000, 
    0x00ea, 0x0000, 0x0008, 0x0000, 0x01e7, 0x0000, 0x01e7, 0x0000, 
    0x0057, 0x0000, 0x0057, 0x0000, 0x0001, 0x0000, 0x001d, 0xc000, 
    0x0005, 0x0000, 0x0005, 0x0000, 0x00c1, 0x0000, 0x0005, 0x0000, 
    0x0005, 0x0000, 0x007a, 0x0000, 0x0006, 0x0000, 0x0025, 0xc000, 
    0x0026, 0xc000, 0x009e, 0x0000, 0x002b, 0xc000, 0x01e7, 0x0000, 
    0x01e7, 0x0000, 0x0057, 0x0571, 0x007b, 0x0002, 0x00b7, 
    0x0006, 0x00a1, 0x0000, 0x0003, 0x0000, 0x00a1, 0x0000, 
    0x045d, 0x0000, 0x045d, 0x0000, 0x0017, 0x0000, 0x0017, 0x0000, 
    0x0008, 0x0000, 0x0005, 0x0000, 0x0006, 0x0000, 0x0020, 0x0000, 
    0x0718, 0x0000, 0x0057, 0x0000, 0x0120, 0x0000, 0x012a, 0x0000, 
    0x0057, 0x0000, 0x0057, 0x0000, 0x009c, 0x0000, 0x0005, 0x0000, 
    0x0057, 0x0000, 0x0057, 0x0000, 0x0057, 0x0000, 0x011a, 0x0000, 
    0x00ff, 0x0000, 0x0570, 0x0000, 0x0570, 0x0000, 0x0570, 0x0000, 
    0x0021, 0x0000, 0x0021, 0x0000, 0x0005, 0x0000, 0x0032, 0x0000, 
    0x0519, 0x0000, 0x051a, 0x0000, 0x051b, 0x0000, 0x051c, 0x0000, 
    0x051d, 0x0000, 0x051e, 0x0000, 0x051f, 0x0000, 0x0520, 0x0000, 
    0x0521, 0x0000, 0x0522, 0x0000, 0x0523, 0x0000, 0x0524, 0x0000, 
    0x0525, 0x0000, 0x0526, 0x0000, 0x0527, 0x0000, 0x0528, 0x0000, 
    0x0529, 0x0000, 0x052a, 0x0000, 0x0056, 0x0000, 0x052c, 0x0000, 
    0x052d, 0x0000, 0x052e, 0x0000, 0x052f, 0x0000, 0x0530, 0x0000, 
    0x0531, 0x0000, 0x0532, 0x0000, 0x0533, 0x0000, 0x0534, 0x0000, 
    0x0535, 0x0000, 0x0536, 0x0000, 0x0537, 0x0000, 0x0538, 0x0000, 
    0x0539, 0x0000, 0x053a, 0x0000, 0x007f, 0x0000, 0x00c1, 0x0000, 
    0x03f0, 0x0000, 0x053c, 0x0000, 0x009e, 0x0000, 0x0070, 0x0000, 
    0x053d, 0x0000, 0x053e, 0x0000, 0x0044, 0x0000, 0x0103, 0x0000, 
    0x053f, 0x0000, 0x0103, 0x0000, 0x009a, 0x0000, 0x000e, 0x0000, 
    0x01e7, 0x0000, 0x0714, 0x0000, 0x0715, 0x0000, 0x0716, 0x0000, 
    0x008c, 0xc000, 0x008d, 0xc000, 0x008e, 0xc000, 0x008f, 0xc000, 
    0x0090, 0xc000, 0x0091, 0xc000, 0x0092, 0xc000, 0x0093, 0xc000, 
    0x0094, 0xc000, 0x0216, 0x0000, 0x0096, 0xc000, 0x0008, 0x0000, 
    0x03ee, 0x0000, 0x0540, 0x0000, 0x05aa, 0x0000, 0x0003, 0x0000, 
    0x0017, 0x0000, 0x048f, 0x0000, 0x0015, 0x0000, 0x01e7, 0x0000, 
    0x01e7, 0x0000, 0x05ad, 0x0000, 0x0013, 0x0000, 0x0015, 0x0000, 
    0x0541, 0x0000, 0x0542, 0x0000, 0x0543, 0x0000, 0x0544, 0x0000, 
    0x0545, 0x0000, 0x0057, 0x0000, 0x00e7, 0x00e7, 0x00e6, 
    0x00e7, 0x0001, 0x00e9, 0x00e8, 0x0217, 0x0218, 0x00e6, 
    0x0079, 0x0026, 0x0005, 0x0032, 0x0033, 0x0034, 0x0035, 
    0x0036, 0x0037, 0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 
    0x003d, 0x003e, 0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 
    0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0058, 0x0011, 
    0x0005, 0x00f0, 0x0546, 0x00e8, 0x0547, 0x0548, 0x0549, 
    0x054a, 0x054b, 0x054c, 0x054d, 0x012c, 0x012d, 0x054e, 
    0x054f, 0x0550, 0x0551, 0x06f8, 0x0552, 0x0553, 0x0057, 
    0x0057, 0x0057, 0x0057, 0x0057, 0x0057, 0x0057, 0x0057, 
    0x0057, 0x0057, 0x0057, 0x0057, 0x0003, 0x03e9, 0x0554, 
    0x00cb, 0x0091, 0x0570, 0x010b, 0x0555, 0x0556, 0x00ce, 
    0x0961, 0x0964, 0x013d, 0x0005, 0x0557, 0x0558, 0x0420, 
    0x05a4, 0x03ee, 0x0004, 0x03e3, 0x0005, 0x04ba, 0x0005, 
    0x055b, 0x055c, 0x055d, 0x055e, 0x0006, 0x055f, 0x05af, 
    0x00c1, 0x0576, 0x007e, 0x00b6, 0x007f, 0x0040, 0x0040, 
    0x0033, 0x003b, 0x003b, 0x003b, 0x003b, 0x045a, 0x007c, 
    0x0056, 0x006d, 0x03f1, 0x03f8, 0x03ed, 0x045e, 0x0560, 
    0x0561, 0x0562, 0x0563, 0x0564, 0x0565, 0x0566, 0x0567, 
    0x03ef, 0x0568, 0x0569, 0x03f9, 0x056a, 0x0459, 0x0466, 
    0x0467, 0x0468, 0x045f, 0x0451, 0x0452, 0x0453, 0x0454, 
    0x0455, 0x0469, 0x0458, 0x056b, 0x056c, 0x03fa, 0x03fb, 
    0x056d, 0x056e, 0x03fc, 0x03fd, 0x0057, 0x045d, 0x0016, 
    0x045d, 0x045d, 0x05de, 0x0013, 0x06fa, 0x06fb, 0x06fc, 
    0x06fd, 0x05dc, 0x05dd, 0x06fe, 0x0700, 0x0701, 0x046b, 
    0x04c3, 0x04c4, 0x05df, 0x070f, 0x0710, 0x0711, 0x0712, 
    0x0572, 0x003b, 0x003b, 0x0717, 0x046a, 0x06f8, 0x04be, 
    0x04be, 0x0044, 0x0034, 0x0040, 0x0040, 0x0040, 0x0044, 
    0x003b, 0x003b, 0x003b, 0x003b, 0x003b, 0x003b, 0x003b, 
    0x0032, 0x0032, 0x17e6, 0x046c, 0x00c1, 0x0773, 0x0490, 
    0x022a, 0xc000, 0x022b, 0xc000, 0x04d5, 0x0492, 0x0774, 
    0x0775, 0x0006, 0x04c9, 0x04ca, 0x04cb, 0x04cc, 0x04cd, 
    0x04ce, 0x04cf, 0x04d0, 0x04d1, 0x04d2, 0x04d3, 0x04d4, 
    0x04c8, 0x04d6, 0x04d7, 0x04d8, 0x00c1, 0x054f, 0x04d0, 
    0x0573, 0x0422, 0x00b6, 0x007f, 0x0120, 0x0476, 0x10fe, 
    0x07d1, 0x04b1, 0x0015, 0x0491, 0x1126, 0x1129, 0x112a, 
    0x1128, 0x0780, 0x0781, 0x00a1, 0x0488, 0x0489, 0x048a, 
    0x048b, 0x048c, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 
    0x0005, 0x1777, 0x1778, 0x1772, 0x0001, 0x1127, 0x0651, 
    0x0575, 0x03e6, 0x10e8, 0x04e3, 0x0052, 0x06a4, 0x06a5, 
    0x0006, 0x06a7, 0x06a8, 0x06a9, 0x06aa, 0x06ab, 0x06ac, 
    0x06ad, 0x06ae, 0x06af, 0x06b0, 0x06b1, 0x06b2, 0x06b3, 
    0x06b4, 0x06b5, 0x06b6, 0x06b7, 0x06b8, 0x06b9, 0x06ba, 
    0x06bb, 0x06bc, 0x06bd, 0x06be, 0x06bf, 0x06c0, 0x06c2, 
    0x06c4, 0x06c5, 0x06c6, 0x06c7, 0x06c8, 0x06c9, 0x06cb, 
    0x06cc, 0x06cd, 0x06ce, 0x06cf, 0x06d0, 0x06d1, 0x06d2, 
    0x06d3, 0x06d4, 0x06d5, 0x06d6, 0x06d7, 0x06d8, 0x06d9, 
    0x06da, 0x06db, 0x06dc, 0x06dd, 0x06de, 0x06df, 0x06e0, 
    0x06e1, 0x06e2, 0x06e3, 0x06e4, 0x06e5, 0x06e6, 0x06e7, 
    0x06e8, 0x06e9, 0x06ea, 0x06eb, 0x06ff, 0x070e, 0x076a, 
    0x076b, 0x076c, 0x0719, 0x071a, 0x071b, 0x071c, 0x071d, 
    0x071e, 0x071f, 0x0721, 0x0722, 0x077a, 0x077b, 0x06ec, 
    0x06ed, 0x06ee, 0x0006, 0x0006, 0x06f1, 0x06f2, 0x06f3, 
    0x06f4, 0x06f5, 0x06f6, 0x06f7, 0x0723, 0x0724, 0x0725, 
    0x0726, 0x0728, 0x077c, 0x077d, 0x077e, 0x0037, 0x0037, 
    0x0037, 0x0000, 0x0};

//
// Declare run length table array.
//

CONST RUN_ENTRY RtlpRunTable[] = {
    {0x00000000, 0x0001, 0x0001},
    {0x00000103, 0x0001, 0x0001},
    {0x00000105, 0x0003, 0x0001},
    {0x0000010c, 0x0002, 0x0001},
    {0x40000002, 0x0001, 0x0001},
    {0x40000006, 0x0001, 0x0001},
    {0x40000008, 0x0002, 0x0001},
    {0x4000000c, 0x0002, 0x0001},
    {0x40020056, 0x0001, 0x0001},
    {0x400200af, 0x0001, 0x0001},
    {0x80000001, 0x0006, 0x0002},
    {0x8000000b, 0x0001, 0x0001},
    {0x8000000d, 0x000a, 0x0001},
    {0x8000001a, 0x0006, 0x0001},
    {0x80000021, 0x0002, 0x0001},
    {0x80000025, 0x0001, 0x0001},
    {0x80000288, 0x0002, 0x0001},
    {0x80090300, 0x0012, 0x0001},
    {0x80090316, 0x0001, 0x0001},
    {0x80090318, 0x0001, 0x0001},
    {0x80090320, 0x0003, 0x0001},
    {0x80090325, 0x0005, 0x0001},
    {0x80090330, 0x0002, 0x0001},
    {0xc0000001, 0x000b, 0x0001},
    {0xc000000d, 0x001a, 0x0002},
    {0xc000002a, 0x0004, 0x0002},
    {0xc0000030, 0x0001, 0x0001},
    {0xc0000032, 0x0004, 0x0001},
    {0xc0000037, 0x0001, 0x0001},
    {0xc0000039, 0x0071, 0x0002},
    {0xc00000ab, 0x000c, 0x0001},
    {0xc00000ba, 0x0019, 0x0001},
    {0xc00000d4, 0x0004, 0x0001},
    {0xc00000d9, 0x0002, 0x0001},
    {0xc00000dc, 0x000d, 0x0001},
    {0xc00000ed, 0x000f, 0x0001},
    {0xc00000fd, 0x0002, 0x0001},
    {0xc0000100, 0x000c, 0x0001},
    {0xc000010d, 0x0002, 0x0001},
    {0xc0000117, 0x0001, 0x0001},
    {0xc000011e, 0x000b, 0x0001},
    {0xc000012b, 0x0001, 0x0001},
    {0xc000012d, 0x0001, 0x0001},
    {0xc0000130, 0x0001, 0x0001},
    {0xc0000133, 0x0001, 0x0001},
    {0xc0000135, 0x0001, 0x0001},
    {0xc0000138, 0x0002, 0x0001},
    {0xc000013b, 0x0008, 0x0001},
    {0xc0000148, 0x0002, 0x0001},
    {0xc000014b, 0x0003, 0x0001},
    {0xc000014f, 0x000f, 0x0001},
    {0xc0000162, 0x0001, 0x0001},
    {0xc0000169, 0x0004, 0x0001},
    {0xc0000172, 0x0007, 0x0001},
    {0xc000017a, 0x000d, 0x0001},
    {0xc0000188, 0x0009, 0x0001},
    {0xc0000192, 0x000a, 0x0001},
    {0xc0000202, 0x0002, 0x0001},
    {0xc0000203, 0x0015, 0x0001},
    {0xc000021c, 0x0001, 0x0001},
    {0xc0000220, 0x0002, 0x0001},
    {0xc0000224, 0x0002, 0x0001},
    {0xc000022a, 0x0002, 0x0002},
    {0xc000022d, 0x0001, 0x0001},
    {0xc0000230, 0x0001, 0x0001},
    {0xc0000233, 0x000f, 0x0001},
    {0xc0000243, 0x0001, 0x0001},
    {0xc0000246, 0x0004, 0x0001},
    {0xc0000253, 0x0001, 0x0001},
    {0xc0000257, 0x0001, 0x0001},
    {0xc0000259, 0x0001, 0x0001},
    {0xc000025e, 0x0001, 0x0001},
    {0xc0000262, 0x0004, 0x0001},
    {0xc0000267, 0x0001, 0x0001},
    {0xc000026c, 0x0003, 0x0001},
    {0xc0000272, 0x0001, 0x0001},
    {0xc0000275, 0x0005, 0x0001},
    {0xc0000280, 0x0002, 0x0001},
    {0xc0000283, 0x0005, 0x0001},
    {0xc000028a, 0x0002, 0x0001},
    {0xc000028d, 0x0007, 0x0001},
    {0xc000029c, 0x0001, 0x0001},
    {0xc00002b2, 0x0001, 0x0001},
    {0xc00002b6, 0x0001, 0x0001},
    {0xc00002c3, 0x0001, 0x0001},
    {0xc00002c5, 0x0001, 0x0001},
    {0xc00002ca, 0x0001, 0x0001},
    {0xc00002cc, 0x0001, 0x0001},
    {0xc00002ea, 0x0001, 0x0001},
    {0xc0020001, 0x001d, 0x0001},
    {0xc002001f, 0x0001, 0x0001},
    {0xc0020021, 0x0006, 0x0001},
    {0xc0020028, 0x0026, 0x0001},
    {0xc002004f, 0x0007, 0x0001},
    {0xc0020057, 0x0002, 0x0001},
    {0xc0020062, 0x0002, 0x0001},
    {0xc0030001, 0x000c, 0x0001},
    {0xc0030059, 0x0004, 0x0001},
    {0xc003005e, 0x0004, 0x0001},
    {0xc0980001, 0x0002, 0x0001},
    {0xc0980008, 0x0001, 0x0001},
    {0xffffffff, 0x0001, 0x0001},
    {0x0, 0x0, 0x0}};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\heapdbg.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    heapdbg.c

Abstract:

    This module implements a debugging layer on top of heap allocator.

Author:

    Steve Wood (stevewo) 20-Sep-1994

Revision History:

--*/

#include "ntrtlp.h"
#include "heap.h"
#include "heappriv.h"

BOOLEAN RtlpValidateHeapHdrsEnable = FALSE; // Set to TRUE if headers are being corrupted
BOOLEAN RtlpValidateHeapTagsEnable;         // Set to TRUE if tag counts are off and you want to know why

HEAP_STOP_ON_VALUES RtlpHeapStopOn;


const struct {

    ULONG Offset;
    LPSTR Description;

} RtlpHeapHeaderFieldOffsets[] = {

    FIELD_OFFSET( HEAP, Entry ),                        "Entry",
    FIELD_OFFSET( HEAP, Signature ),                    "Signature",
    FIELD_OFFSET( HEAP, Flags ),                        "Flags",
    FIELD_OFFSET( HEAP, ForceFlags ),                   "ForceFlags",
    FIELD_OFFSET( HEAP, VirtualMemoryThreshold ),       "VirtualMemoryThreshold",
    FIELD_OFFSET( HEAP, SegmentReserve ),               "SegmentReserve",
    FIELD_OFFSET( HEAP, SegmentCommit ),                "SegmentCommit",
    FIELD_OFFSET( HEAP, DeCommitFreeBlockThreshold ),   "DeCommitFreeBlockThreshold",
    FIELD_OFFSET( HEAP, DeCommitTotalFreeThreshold ),   "DeCommitTotalFreeThreshold",
    FIELD_OFFSET( HEAP, TotalFreeSize ),                "TotalFreeSize",
    FIELD_OFFSET( HEAP, MaximumAllocationSize ),        "MaximumAllocationSize",
    FIELD_OFFSET( HEAP, ProcessHeapsListIndex ),        "ProcessHeapsListIndex",
    FIELD_OFFSET( HEAP, HeaderValidateLength ),         "HeaderValidateLength",
    FIELD_OFFSET( HEAP, HeaderValidateCopy ),           "HeaderValidateCopy",
    FIELD_OFFSET( HEAP, NextAvailableTagIndex ),        "NextAvailableTagIndex",
    FIELD_OFFSET( HEAP, MaximumTagIndex ),              "MaximumTagIndex",
    FIELD_OFFSET( HEAP, TagEntries ),                   "TagEntries",
    FIELD_OFFSET( HEAP, UCRSegments ),                  "UCRSegments",
    FIELD_OFFSET( HEAP, UnusedUnCommittedRanges ),      "UnusedUnCommittedRanges",
    FIELD_OFFSET( HEAP, AlignRound ),                   "AlignRound",
    FIELD_OFFSET( HEAP, AlignMask ),                    "AlignMask",
    FIELD_OFFSET( HEAP, VirtualAllocdBlocks ),          "VirtualAllocdBlocks",
    FIELD_OFFSET( HEAP, Segments ),                     "Segments",
    FIELD_OFFSET( HEAP, u ),                            "FreeListsInUse",
    FIELD_OFFSET( HEAP, FreeListsInUseTerminate ),      "FreeListsInUseTerminate",
    FIELD_OFFSET( HEAP, AllocatorBackTraceIndex ),      "AllocatorBackTraceIndex",
    FIELD_OFFSET( HEAP, Reserved1 ),                    "Reserved1",
    FIELD_OFFSET( HEAP, PseudoTagEntries ),             "PseudoTagEntries",
    FIELD_OFFSET( HEAP, FreeLists ),                    "FreeLists",
    FIELD_OFFSET( HEAP, LockVariable ),                 "LockVariable",
    FIELD_OFFSET( HEAP, Lookaside ),                    "Lookaside",
    FIELD_OFFSET( HEAP, LookasideLockCount ),           "LookasideLockCount",
    sizeof( HEAP ),                                     "Uncommitted Ranges",
    0xFFFF, NULL
};


VOID
RtlpUpdateHeapListIndex (
    USHORT OldIndex,
    USHORT NewIndex
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    if (RtlpHeapStopOn.AllocTag.HeapIndex == OldIndex) {

        RtlpHeapStopOn.AllocTag.HeapIndex = NewIndex;
    }

    if (RtlpHeapStopOn.ReAllocTag.HeapIndex == OldIndex) {

        RtlpHeapStopOn.ReAllocTag.HeapIndex = NewIndex;
    }

    if (RtlpHeapStopOn.FreeTag.HeapIndex == OldIndex) {

        RtlpHeapStopOn.FreeTag.HeapIndex = NewIndex;
    }

    return;
}


BOOLEAN
RtlpValidateHeapHeaders (
    IN PHEAP Heap,
    IN BOOLEAN Recompute
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    ULONG i;
    SIZE_T n;
    SIZE_T nEqual;
    NTSTATUS Status;

    if (!RtlpValidateHeapHdrsEnable) {

        return TRUE;
    }

    if (Heap->HeaderValidateCopy == NULL) {

        n = Heap->HeaderValidateLength;

        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &Heap->HeaderValidateCopy,
                                          0,
                                          &n,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return TRUE;
        }

        Recompute = TRUE;
    }

    n = Heap->HeaderValidateLength;

    if (!Recompute) {

        nEqual = RtlCompareMemory( Heap,
                                   Heap->HeaderValidateCopy,
                                   n );

    } else {

        RtlMoveMemory( Heap->HeaderValidateCopy,
                       Heap,
                       n );

        nEqual = n;
    }

    if (n != nEqual) {

        HeapDebugPrint(( "Heap %x - headers modified (%x is %x instead of %x)\n",
                         Heap,
                         (PCHAR)Heap + nEqual,
                         *(PULONG)((PCHAR)Heap + nEqual),
                         *(PULONG)((PCHAR)Heap->HeaderValidateCopy + nEqual)));

        for (i=0; RtlpHeapHeaderFieldOffsets[ i ].Description != NULL; i++) {

            if ((nEqual >= RtlpHeapHeaderFieldOffsets[ i ].Offset) &&
                (nEqual < RtlpHeapHeaderFieldOffsets[ i+1 ].Offset)) {

                DbgPrint( "    This is located in the %s field of the heap header.\n",
                                 RtlpHeapHeaderFieldOffsets[ i ].Description );

                break;
            }
        }

        return FALSE;

    } else {

        return TRUE;
    }
}


PVOID
RtlDebugCreateHeap (
    IN ULONG Flags,
    IN PVOID HeapBase OPTIONAL,
    IN SIZE_T ReserveSize OPTIONAL,
    IN SIZE_T CommitSize OPTIONAL,
    IN PVOID Lock OPTIONAL,
    IN PRTL_HEAP_PARAMETERS Parameters
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap;
    NTSTATUS Status;
    MEMORY_BASIC_INFORMATION MemoryInformation;

    if (ReserveSize <= sizeof( HEAP_ENTRY )) {

        HeapDebugPrint(( "Invalid ReserveSize parameter - %lx\n", ReserveSize ));
        HeapDebugBreak( NULL );

        return NULL;
    }

    if (ReserveSize < CommitSize) {

        HeapDebugPrint(( "Invalid CommitSize parameter - %lx\n", CommitSize ));
        HeapDebugBreak( NULL );

        return NULL;
    }

    if ((Flags & HEAP_NO_SERIALIZE) && ARGUMENT_PRESENT( Lock )) {

        HeapDebugPrint(( "May not specify Lock parameter with HEAP_NO_SERIALIZE\n" ));
        HeapDebugBreak( NULL );

        return NULL;
    }

    if (ARGUMENT_PRESENT( HeapBase )) {

        Status = NtQueryVirtualMemory( NtCurrentProcess(),
                                       HeapBase,
                                       MemoryBasicInformation,
                                       &MemoryInformation,
                                       sizeof( MemoryInformation ),
                                       NULL );

        if (!NT_SUCCESS( Status )) {

            HeapDebugPrint(( "Specified HeapBase (%lx) invalid,  Status = %lx\n",
                             HeapBase,
                             Status ));

            HeapDebugBreak( NULL );

            return NULL;
        }

        if (MemoryInformation.BaseAddress != HeapBase) {

            HeapDebugPrint(( "Specified HeapBase (%lx) != to BaseAddress (%lx)\n",
                             HeapBase,
                             MemoryInformation.BaseAddress ));

            HeapDebugBreak( NULL );

            return NULL;
        }

        if (MemoryInformation.State == MEM_FREE) {

            HeapDebugPrint(( "Specified HeapBase (%lx) is free or not writable\n",
                             MemoryInformation.BaseAddress ));

            HeapDebugBreak( NULL );

            return NULL;
        }
    }

    Heap = RtlCreateHeap( Flags |
                            HEAP_SKIP_VALIDATION_CHECKS |
                            HEAP_TAIL_CHECKING_ENABLED  |
                            HEAP_FREE_CHECKING_ENABLED,
                          HeapBase,
                          ReserveSize,
                          CommitSize,
                          Lock,
                          Parameters );

    if (Heap != NULL) {

#if i386

        if (Heap->Flags & HEAP_CAPTURE_STACK_BACKTRACES) {

            Heap->AllocatorBackTraceIndex = (USHORT)RtlLogStackBackTrace();
        }

#endif // i386

        RtlpValidateHeapHeaders( Heap, TRUE );
    }

    return Heap;
}


BOOLEAN
RtlpSerializeHeap (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_LOCK Lock;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapSerialize( HeapHandle ));

    //
    //  Validate that HeapAddress points to a HEAP structure.
    //

    if (!RtlpCheckHeapSignature( Heap, "RtlpSerializeHeap" )) {

        return FALSE;
    }

    //
    //  Lock the heap.
    //

    if (Heap->Flags & HEAP_NO_SERIALIZE) {

        Lock = RtlAllocateHeap( HeapHandle, HEAP_NO_SERIALIZE, sizeof( *Lock ) );

        if ( Lock == NULL ) {

            return FALSE;
        }
    
        Status = RtlInitializeLockRoutine( Lock );

        if (!NT_SUCCESS( Status )) {

            RtlFreeHeap( HeapHandle, HEAP_NO_SERIALIZE, Lock );

            return FALSE;
        }

        Heap->LockVariable = Lock;
        Heap->Flags &= ~HEAP_NO_SERIALIZE;
        Heap->ForceFlags &= ~HEAP_NO_SERIALIZE;

        RtlpValidateHeapHeaders( Heap, TRUE );
    }

    return TRUE;
}


BOOLEAN
RtlDebugDestroyHeap (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    LIST_ENTRY ListEntry;
    SIZE_T n;

    if (HeapHandle == NtCurrentPeb()->ProcessHeap) {

        HeapDebugPrint(( "May not destroy the process heap at %x\n", HeapHandle ));

        return FALSE;
    }

    if (!RtlpCheckHeapSignature( Heap, "RtlDestroyHeap" )) {

        return FALSE;
    }

    if (!RtlpValidateHeap( Heap, FALSE )) {

        return FALSE;
    }

    //
    //  Now mark the heap as invalid by zeroing the signature field.
    //

    Heap->Signature = 0;

    if (Heap->HeaderValidateCopy != NULL) {

        n = 0;
        NtFreeVirtualMemory( NtCurrentProcess(),
                             &Heap->HeaderValidateCopy,
                             &n,
                             MEM_RELEASE );
    }

    return TRUE;
}


PVOID
RtlDebugAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    PVOID ReturnValue = NULL;
    SIZE_T AllocationSize;
    USHORT TagIndex;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapAllocate( HeapHandle, Flags, Size ));

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlAllocateHeap" )) {

                ReturnValue = NULL;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SETTABLE_USER_VALUE | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Verify that the size did not wrap or exceed the limit for this heap.
            //

            AllocationSize = (((Size ? Size : 1) + Heap->AlignRound) & Heap->AlignMask) +
                             sizeof( HEAP_ENTRY_EXTRA );

            if ((AllocationSize < Size) || (AllocationSize > Heap->MaximumAllocationSize)) {

                HeapDebugPrint(( "Invalid allocation size - %lx (exceeded %x)\n",
                                 Size,
                                 Heap->MaximumAllocationSize ));

                ReturnValue = NULL;
                leave;
            }

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );

            ReturnValue = RtlAllocateHeapSlowly( HeapHandle, Flags, Size );

            RtlpValidateHeapHeaders( Heap, TRUE );

            if (ReturnValue != NULL) {

                BusyBlock = (PHEAP_ENTRY)ReturnValue - 1;

                if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                    ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

    #if i386

                    if (Heap->Flags & HEAP_CAPTURE_STACK_BACKTRACES) {

                        ExtraStuff->AllocatorBackTraceIndex = (USHORT)RtlLogStackBackTrace();

                    } else {

                        ExtraStuff->AllocatorBackTraceIndex = 0;
                    }

    #endif // i386

                    TagIndex = ExtraStuff->TagIndex;

                } else {

                    TagIndex = BusyBlock->SmallTagIndex;
                }

                if (Heap->Flags & HEAP_VALIDATE_ALL_ENABLED) {

                    RtlpValidateHeap( Heap, FALSE );
                }
            }

            if (ReturnValue != NULL) {

                if ((ULONG_PTR)ReturnValue == RtlpHeapStopOn.AllocAddress) {

                    HeapDebugPrint(( "Just allocated block at %lx for 0x%x bytes\n",
                                     RtlpHeapStopOn.AllocAddress,
                                     Size ));

                    HeapDebugBreak( NULL );

                } else if ((IS_HEAP_TAGGING_ENABLED()) &&
                           (TagIndex != 0) &&
                           (TagIndex == RtlpHeapStopOn.AllocTag.TagIndex) &&
                           (Heap->ProcessHeapsListIndex == RtlpHeapStopOn.AllocTag.HeapIndex)) {

                    HeapDebugPrint(( "Just allocated block at %lx for 0x%x bytes with tag %ws\n",
                                     ReturnValue,
                                     Size,
                                     RtlpGetTagName( Heap, TagIndex )));

                    HeapDebugBreak( NULL );
                }
            }

        } except( GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_CONTINUE_SEARCH :
                                                           EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            ReturnValue = NULL;
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return ReturnValue;
}


PVOID
RtlDebugReAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T Size
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    SIZE_T AllocationSize;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    BOOLEAN LockAcquired = FALSE;
    PVOID ReturnValue = NULL;
    USHORT TagIndex;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapReAllocate( HeapHandle, Flags, BaseAddress, Size ));

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlReAllocateHeap" )) {

                ReturnValue = NULL;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SETTABLE_USER_VALUE | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Verify that the size did not wrap or exceed the limit for this heap.
            //

            AllocationSize = (((Size ? Size : 1) + Heap->AlignRound) & Heap->AlignMask) +
                             sizeof( HEAP_ENTRY_EXTRA );

            if (AllocationSize < Size || AllocationSize > Heap->MaximumAllocationSize) {

                HeapDebugPrint(( "Invalid allocation size - %lx (exceeded %x)\n",
                                 Size,
                                 Heap->MaximumAllocationSize ));

                HeapDebugBreak( NULL );

                ReturnValue = NULL;
                leave;
            }

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );
            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            if (RtlpValidateHeapEntry( Heap, BusyBlock, "RtlReAllocateHeap" )) {

                if ((ULONG_PTR)BaseAddress == RtlpHeapStopOn.ReAllocAddress) {

                    HeapDebugPrint(( "About to reallocate block at %lx to 0x%x bytes\n",
                                     RtlpHeapStopOn.ReAllocAddress,
                                     Size ));

                    HeapDebugBreak( NULL );

                } else if (IS_HEAP_TAGGING_ENABLED() && RtlpHeapStopOn.ReAllocTag.HeapAndTagIndex != 0) {

                    if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                        ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );
                        TagIndex = ExtraStuff->TagIndex;

                    } else {

                        TagIndex = BusyBlock->SmallTagIndex;
                    }

                    if ((TagIndex != 0) &&
                        (TagIndex == RtlpHeapStopOn.ReAllocTag.TagIndex) &&
                        (Heap->ProcessHeapsListIndex == RtlpHeapStopOn.ReAllocTag.HeapIndex)) {

                        HeapDebugPrint(( "About to rellocate block at %lx to 0x%x bytes with tag %ws\n",
                                         BaseAddress,
                                         Size,
                                         RtlpGetTagName( Heap, TagIndex )));

                        HeapDebugBreak( NULL );
                    }
                }

                ReturnValue = RtlReAllocateHeap( HeapHandle, Flags, BaseAddress, Size );

                if (ReturnValue != NULL) {

                    BusyBlock = (PHEAP_ENTRY)ReturnValue - 1;

                    if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                        ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

    #if i386

                        if (Heap->Flags & HEAP_CAPTURE_STACK_BACKTRACES) {

                            ExtraStuff->AllocatorBackTraceIndex = (USHORT)RtlLogStackBackTrace();

                        } else {

                            ExtraStuff->AllocatorBackTraceIndex = 0;
                        }

    #endif // i386

                        TagIndex = ExtraStuff->TagIndex;

                    } else {

                        TagIndex = BusyBlock->SmallTagIndex;
                    }
                }

                RtlpValidateHeapHeaders( Heap, TRUE );
                RtlpValidateHeap( Heap, FALSE );
            }

            if (ReturnValue != NULL) {

                if ((ULONG_PTR)ReturnValue == RtlpHeapStopOn.ReAllocAddress) {

                    HeapDebugPrint(( "Just reallocated block at %lx to 0x%x bytes\n",
                                     RtlpHeapStopOn.ReAllocAddress,
                                     Size ));

                    HeapDebugBreak( NULL );

                } else if ((IS_HEAP_TAGGING_ENABLED()) &&
                           (TagIndex == RtlpHeapStopOn.ReAllocTag.TagIndex) &&
                           (Heap->ProcessHeapsListIndex == RtlpHeapStopOn.ReAllocTag.HeapIndex)) {

                    HeapDebugPrint(( "Just reallocated block at %lx to 0x%x bytes with tag %ws\n",
                                     ReturnValue,
                                     Size,
                                     RtlpGetTagName( Heap, TagIndex )));

                    HeapDebugBreak( NULL );
                }
            }

        } except( GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_CONTINUE_SEARCH :
                                                           EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            ReturnValue = NULL;
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return ReturnValue;
}


BOOLEAN
RtlDebugFreeHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    SIZE_T Size;
    BOOLEAN Result = FALSE;
    BOOLEAN LockAcquired = FALSE;
    USHORT TagIndex;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapFree( HeapHandle, Flags, BaseAddress ));

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlFreeHeap" )) {

                Result = FALSE;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;
            Size = BusyBlock->Size << HEAP_GRANULARITY_SHIFT;

            if (RtlpValidateHeapEntry( Heap, BusyBlock, "RtlFreeHeap" )) {

                if ((ULONG_PTR)BaseAddress == RtlpHeapStopOn.FreeAddress) {

                    HeapDebugPrint(( "About to free block at %lx\n",
                                     RtlpHeapStopOn.FreeAddress ));

                    HeapDebugBreak( NULL );

                } else if ((IS_HEAP_TAGGING_ENABLED()) && (RtlpHeapStopOn.FreeTag.HeapAndTagIndex != 0)) {

                    if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                        ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                        TagIndex = ExtraStuff->TagIndex;

                    } else {

                        TagIndex = BusyBlock->SmallTagIndex;
                    }

                    if ((TagIndex != 0) &&
                        (TagIndex == RtlpHeapStopOn.FreeTag.TagIndex) &&
                        (Heap->ProcessHeapsListIndex == RtlpHeapStopOn.FreeTag.HeapIndex)) {

                        HeapDebugPrint(( "About to free block at %lx with tag %ws\n",
                                         BaseAddress,
                                         RtlpGetTagName( Heap, TagIndex )));

                        HeapDebugBreak( NULL );
                    }
                }

                Result = RtlFreeHeapSlowly( HeapHandle, Flags, BaseAddress );

                RtlpValidateHeapHeaders( Heap, TRUE );
                RtlpValidateHeap( Heap, FALSE );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            Result = FALSE;
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Result;
}


BOOLEAN
RtlDebugGetUserInfoHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    OUT PVOID *UserValue OPTIONAL,
    OUT PULONG UserFlags OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    BOOLEAN Result = FALSE;
    BOOLEAN LockAcquired = FALSE;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapGetUserInfo( HeapHandle, Flags, BaseAddress, UserValue, UserFlags ));

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlGetUserInfoHeap" )) {

                Result = FALSE;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            if (RtlpValidateHeapEntry( Heap, BusyBlock, "RtlGetUserInfoHeap" )) {

                Result = RtlGetUserInfoHeap( HeapHandle, Flags, BaseAddress, UserValue, UserFlags );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Result;
}


BOOLEAN
RtlDebugSetUserValueHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN PVOID UserValue
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    BOOLEAN Result = FALSE;
    BOOLEAN LockAcquired = FALSE;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapSetUserValue( HeapHandle, Flags, BaseAddress, UserValue ));

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlSetUserValueHeap" )) {

                Result = FALSE;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            if (RtlpValidateHeapEntry( Heap, BusyBlock, "RtlSetUserValueHeap" )) {

                Result = RtlSetUserValueHeap( HeapHandle, Flags, BaseAddress, UserValue );

                RtlpValidateHeap( Heap, FALSE );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Result;
}


BOOLEAN
RtlDebugSetUserFlagsHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    BOOLEAN Result = FALSE;
    BOOLEAN LockAcquired = FALSE;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapSetUserFlags( HeapHandle, Flags, BaseAddress, UserFlagsReset, UserFlagsSet ));

    if ((UserFlagsReset & ~HEAP_SETTABLE_USER_FLAGS) ||
        (UserFlagsSet & ~HEAP_SETTABLE_USER_FLAGS)) {

        return FALSE;
    }

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlSetUserFlagsHeap" )) {

                Result = FALSE;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            if (RtlpValidateHeapEntry( Heap, BusyBlock, "RtlSetUserFlagsHeap" )) {

                Result = RtlSetUserFlagsHeap( HeapHandle, Flags, BaseAddress, UserFlagsReset, UserFlagsSet );

                RtlpValidateHeap( Heap, FALSE );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Result;
}


SIZE_T
RtlDebugSizeHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    BOOLEAN LockAcquired = FALSE;
    SIZE_T BusySize;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapSize( HeapHandle, Flags, BaseAddress ));

    BusySize = 0xFFFFFFFF;

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlSizeHeap" )) {

                BusySize = FALSE;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                Flags |= HEAP_NO_SERIALIZE;

                LockAcquired = TRUE;
            }

            RtlpValidateHeap( Heap, FALSE );

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            if (RtlpValidateHeapEntry( Heap, BusyBlock, "RtlSizeHeap" )) {

                BusySize = RtlSizeHeap( HeapHandle, Flags, BaseAddress );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return BusySize;
}


SIZE_T
RtlDebugCompactHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    SIZE_T LargestFreeSize;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapCompact( HeapHandle, Flags ));

    LargestFreeSize = 0;

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlCompactHeap" )) {

                LargestFreeSize = 0;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );

            LargestFreeSize = RtlCompactHeap( HeapHandle, Flags );

            RtlpValidateHeapHeaders( Heap, TRUE );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return LargestFreeSize;
}


NTSTATUS
RtlDebugZeroHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    SIZE_T LargestFreeSize;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapZero( HeapHandle, Flags ));

    Status = STATUS_SUCCESS;
    LargestFreeSize = 0;

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlZeroHeap" )) {

                Status = STATUS_INVALID_PARAMETER;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            if (!RtlpValidateHeap( Heap, FALSE )) {

                Status = STATUS_INVALID_PARAMETER;

            } else {

                Status = RtlZeroHeap( HeapHandle, Flags );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Status;
}


NTSTATUS
RtlDebugCreateTagHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PWSTR TagPrefix OPTIONAL,
    IN PWSTR TagNames
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    ULONG TagIndex;

    TagIndex = 0;

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (RtlpCheckHeapSignature( Heap, "RtlCreateTagHeap" )) {

                Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

                //
                //  Lock the heap
                //

                if (!(Flags & HEAP_NO_SERIALIZE)) {

                    RtlAcquireLockRoutine( Heap->LockVariable );

                    LockAcquired = TRUE;

                    Flags |= HEAP_NO_SERIALIZE;
                }

                if (RtlpValidateHeap( Heap, FALSE )) {

                    TagIndex = RtlCreateTagHeap( HeapHandle, Flags, TagPrefix, TagNames );
                }

                RtlpValidateHeapHeaders( Heap, TRUE );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return TagIndex;
}


NTSYSAPI
PWSTR
NTAPI
RtlDebugQueryTagHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN USHORT TagIndex,
    IN BOOLEAN ResetCounters,
    OUT PRTL_HEAP_TAG_INFO TagInfo OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    PWSTR Result;

    Result = NULL;

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (RtlpCheckHeapSignature( Heap, "RtlQueryTagHeap" )) {

                Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

                //
                //  Lock the heap
                //

                if (!(Flags & HEAP_NO_SERIALIZE)) {

                    RtlAcquireLockRoutine( Heap->LockVariable );

                    LockAcquired = TRUE;

                    Flags |= HEAP_NO_SERIALIZE;
                }

                if (RtlpValidateHeap( Heap, FALSE )) {

                    Result = RtlQueryTagHeap( HeapHandle, Flags, TagIndex, ResetCounters, TagInfo );
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Result;
}


NTSTATUS
RtlDebugUsageHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    NTSTATUS Status;
    BOOLEAN LockAcquired = FALSE;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapUsage( HeapHandle, Flags, Usage ));

    Status = STATUS_SUCCESS;

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlUsageHeap" )) {

                Status = STATUS_INVALID_PARAMETER;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            if (!RtlpValidateHeap( Heap, FALSE )) {

                Status = STATUS_INVALID_PARAMETER;

            } else {

                Status = RtlUsageHeap( HeapHandle, Flags, Usage );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Status;
}


BOOLEAN
RtlDebugWalkHeap (
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN Result;

    //
    //  Assumed the caller has serialized via RtlLockHeap or their own locking mechanism.
    //

    Result = FALSE;

    try {

        if (RtlpCheckHeapSignature( Heap, "RtlWalkHeap" )) {

            Result = RtlpValidateHeap( Heap, FALSE );
        }

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        SET_LAST_STATUS( GetExceptionCode() );
    }

    return Result;
}


BOOLEAN
RtlpValidateHeapEntry (
    IN PHEAP Heap,
    IN PHEAP_ENTRY BusyBlock,
    IN PCHAR Reason
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP_SEGMENT Segment;
    UCHAR SegmentIndex;
    BOOLEAN Result;

    if ((BusyBlock == NULL)

            ||

        ((ULONG_PTR)BusyBlock & (HEAP_GRANULARITY-1))

            ||

        ((BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) &&
         ((ULONG_PTR)BusyBlock & (PAGE_SIZE-1)) != FIELD_OFFSET( HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock ))

            ||

        (!(BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) &&
         ((BusyBlock->SegmentIndex >= HEAP_MAXIMUM_SEGMENTS) ||
          !(Segment = Heap->Segments[ BusyBlock->SegmentIndex ]) ||
          (BusyBlock < Segment->FirstEntry) ||
          (BusyBlock >= Segment->LastValidEntry)))

            ||

        !(BusyBlock->Flags & HEAP_ENTRY_BUSY)

            ||

        ((BusyBlock->Flags & HEAP_ENTRY_FILL_PATTERN) && !RtlpCheckBusyBlockTail( BusyBlock ))) {

InvalidBlock:

        HeapDebugPrint(( "Invalid Address specified to %s( %lx, %lx )\n",
                         Reason,
                         Heap,
                         BusyBlock + 1 ));

        HeapDebugBreak( BusyBlock );

        return FALSE;

    } else {

        if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

            Result = TRUE;

        } else {

            for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

                Segment = Heap->Segments[ SegmentIndex ];

                if (Segment) {

                    if ((BusyBlock >= Segment->FirstEntry) &&
                        (BusyBlock < Segment->LastValidEntry)) {

                        Result = TRUE;
                        break;
                    }
                }
            }
        }

        if (!Result) {

            goto InvalidBlock;
        }

        return TRUE;
    }
}


BOOLEAN
RtlpValidateHeapSegment (
    IN PHEAP Heap,
    IN PHEAP_SEGMENT Segment,
    IN UCHAR SegmentIndex,
    IN OUT PULONG CountOfFreeBlocks,
    IN OUT PSIZE_T TotalFreeSize,
    OUT PVOID *BadAddress,
    IN OUT PSIZE_T ComputedTagEntries,
    IN OUT PSIZE_T ComputedPseudoTagEntries
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP_ENTRY CurrentBlock, PreviousBlock;
    SIZE_T Size;
    USHORT PreviousSize, TagIndex;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;

    RTL_PAGED_CODE();

    NumberOfUnCommittedPages = 0;
    NumberOfUnCommittedRanges = 0;

    UnCommittedRange = Segment->UnCommittedRanges;

    if (Segment->BaseAddress == Heap) {

        CurrentBlock = &Heap->Entry;

    } else {

        CurrentBlock = &Segment->Entry;
    }

    while (CurrentBlock < Segment->LastValidEntry) {

        *BadAddress = CurrentBlock;

        if ((UnCommittedRange != NULL) &&
            ((ULONG_PTR)CurrentBlock >= UnCommittedRange->Address)) {

            HeapDebugPrint(( "Heap entry %lx is beyond uncommited range [%x .. %x)\n",
                             CurrentBlock,
                             UnCommittedRange->Address,
                             (PCHAR)UnCommittedRange->Address + UnCommittedRange->Size ));

            return FALSE;
        }

        PreviousSize = 0;

        while (CurrentBlock < Segment->LastValidEntry) {

            *BadAddress = CurrentBlock;

            if (PreviousSize != CurrentBlock->PreviousSize) {

                HeapDebugPrint(( "Heap entry %lx has incorrect PreviousSize field (%04x instead of %04x)\n",
                                 CurrentBlock, CurrentBlock->PreviousSize, PreviousSize ));

                return FALSE;
            }

            PreviousSize = CurrentBlock->Size;
            Size = (ULONG_PTR)CurrentBlock->Size << HEAP_GRANULARITY_SHIFT;

            if (CurrentBlock->Flags & HEAP_ENTRY_BUSY) {

                if (ComputedTagEntries != NULL) {

                    if (CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                        ExtraStuff = RtlpGetExtraStuffPointer( CurrentBlock );
                        TagIndex = ExtraStuff->TagIndex;

                    } else {

                        TagIndex = CurrentBlock->SmallTagIndex;
                    }

                    if (TagIndex != 0) {

                        if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

                            TagIndex &= ~HEAP_PSEUDO_TAG_FLAG;

                            if (TagIndex < HEAP_NUMBER_OF_PSEUDO_TAG) {

                                ComputedPseudoTagEntries[ TagIndex ] += CurrentBlock->Size;
                            }

                        } else if (TagIndex & HEAP_GLOBAL_TAG) {

                            //
                            //  Ignore these since they are global across more than
                            //  one heap.
                            //

                        } else if (TagIndex < Heap->NextAvailableTagIndex) {

                            ComputedTagEntries[ TagIndex ] += CurrentBlock->Size;
                        }
                    }
                }

                if (CurrentBlock->Flags & HEAP_ENTRY_FILL_PATTERN) {

                    if (!RtlpCheckBusyBlockTail( CurrentBlock )) {

                        return FALSE;
                    }
                }

            } else {

                *CountOfFreeBlocks += 1;
                *TotalFreeSize += CurrentBlock->Size;

                if ((Heap->Flags & HEAP_FREE_CHECKING_ENABLED) &&
                    (CurrentBlock->Flags & HEAP_ENTRY_FILL_PATTERN)) {

                    SIZE_T cb, cbEqual;

                    cb = Size - sizeof( HEAP_FREE_ENTRY );

                    if ((CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) &&
                        (cb > sizeof( HEAP_FREE_ENTRY_EXTRA ))) {

                        cb -= sizeof( HEAP_FREE_ENTRY_EXTRA );
                    }

                    cbEqual = RtlCompareMemoryUlong( (PCHAR)((PHEAP_FREE_ENTRY)CurrentBlock + 1),
                                                     cb,
                                                     FREE_HEAP_FILL );

                    if (cbEqual != cb) {

                        HeapDebugPrint(( "Free Heap block %lx modified at %lx after it was freed\n",
                                         CurrentBlock,
                                         (PCHAR)(CurrentBlock + 1) + cbEqual ));

                        return FALSE;
                    }
                }
            }

            if (CurrentBlock->SegmentIndex != SegmentIndex) {

                HeapDebugPrint(( "Heap block at %lx has incorrect segment index (%x)\n",
                                 CurrentBlock,
                                 SegmentIndex ));

                return FALSE;
            }

            if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                CurrentBlock = (PHEAP_ENTRY)((PCHAR)CurrentBlock + Size);

                if (UnCommittedRange == NULL) {

                    if (CurrentBlock != Segment->LastValidEntry) {

                        HeapDebugPrint(( "Heap block at %lx is not last block in segment (%x)\n",
                                         CurrentBlock,
                                         Segment->LastValidEntry ));

                        return FALSE;
                    }

                } else if ((ULONG_PTR)CurrentBlock != UnCommittedRange->Address) {

                    HeapDebugPrint(( "Heap block at %lx does not match address of next uncommitted address (%x)\n",
                                     CurrentBlock,
                                     UnCommittedRange->Address ));

                    return FALSE;

                } else {

                    NumberOfUnCommittedPages += (ULONG) (UnCommittedRange->Size / PAGE_SIZE);
                    NumberOfUnCommittedRanges += 1;

                    CurrentBlock = (PHEAP_ENTRY)
                        ((PCHAR)UnCommittedRange->Address + UnCommittedRange->Size);

                    UnCommittedRange = UnCommittedRange->Next;
                }

                break;
            }

            CurrentBlock = (PHEAP_ENTRY)((PCHAR)CurrentBlock + Size);
        }
    }

    *BadAddress = Segment;

    if (Segment->NumberOfUnCommittedPages != NumberOfUnCommittedPages) {

        HeapDebugPrint(( "Heap Segment at %lx contains invalid NumberOfUnCommittedPages (%x != %x)\n",
                         Segment,
                         Segment->NumberOfUnCommittedPages,
                         NumberOfUnCommittedPages ));

        return FALSE;
    }

    if (Segment->NumberOfUnCommittedRanges != NumberOfUnCommittedRanges) {

        HeapDebugPrint(( "Heap Segment at %lx contains invalid NumberOfUnCommittedRanges (%x != %x)\n",
                         Segment,
                         Segment->NumberOfUnCommittedRanges,
                         NumberOfUnCommittedRanges ));

        return FALSE;
    }

    return TRUE;
}


BOOLEAN
RtlpValidateHeap (
    IN PHEAP Heap,
    IN BOOLEAN AlwaysValidate
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    PHEAP_SEGMENT Segment;
    PLIST_ENTRY Head, Next;
    PHEAP_FREE_ENTRY FreeBlock;
    BOOLEAN EmptyFreeList;
    ULONG NumberOfFreeListEntries;
    ULONG CountOfFreeBlocks;
    SIZE_T TotalFreeSize;
    SIZE_T Size;
    USHORT PreviousSize;
    UCHAR SegmentIndex;
    PVOID BadAddress;
    PSIZE_T ComputedTagEntries = NULL;
    PSIZE_T ComputedPseudoTagEntries = NULL;
    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;
    USHORT TagIndex;

    RTL_PAGED_CODE();

    BadAddress = Heap;

    if (!RtlpValidateHeapHeaders( Heap, FALSE )) {

        goto errorExit;
    }

    if (!AlwaysValidate && !(Heap->Flags & HEAP_VALIDATE_ALL_ENABLED)) {

        goto exit;
    }

    NumberOfFreeListEntries = 0;
    Head = &Heap->FreeLists[ 0 ];

    for (Size = 0; Size < HEAP_MAXIMUM_FREELISTS; Size++) {

        if (Size != 0) {

            EmptyFreeList = (BOOLEAN)(IsListEmpty( Head ));
            BadAddress = &Heap->u.FreeListsInUseBytes[ Size / 8 ];

            if (Heap->u.FreeListsInUseBytes[ Size / 8 ] & (1 << (Size & 7)) ) {

                if (EmptyFreeList) {

                    HeapDebugPrint(( "dedicated (%04x) free list empty but marked as non-empty\n",
                                     Size ));

                    goto errorExit;
                }

            } else {

                if (!EmptyFreeList) {

                    HeapDebugPrint(( "dedicated (%04x) free list non-empty but marked as empty\n",
                                     Size ));

                    goto errorExit;
                }
            }
        }

        Next = Head->Flink;
        PreviousSize = 0;

        while (Head != Next) {

            FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );
            Next = Next->Flink;

            BadAddress = FreeBlock;

            if (FreeBlock->Flags & HEAP_ENTRY_BUSY) {

                HeapDebugPrint(( "dedicated (%04x) free list element %lx is marked busy\n",
                                 Size,
                                 FreeBlock ));

                goto errorExit;
            }

            if ((Size != 0) && (FreeBlock->Size != Size)) {

                HeapDebugPrint(( "Dedicated (%04x) free list element %lx is wrong size (%04x)\n",
                                 Size,
                                 FreeBlock,
                                 FreeBlock->Size ));

                goto errorExit;

            } else if ((Size == 0) && (FreeBlock->Size < HEAP_MAXIMUM_FREELISTS)) {

                HeapDebugPrint(( "Non-Dedicated free list element %lx with too small size (%04x)\n",
                                 FreeBlock,
                                 FreeBlock->Size ));

                goto errorExit;

            } else if ((Size == 0) && (FreeBlock->Size < PreviousSize)) {

                HeapDebugPrint(( "Non-Dedicated free list element %lx is out of order\n",
                                 FreeBlock ));

                goto errorExit;

            } else {

                PreviousSize = FreeBlock->Size;
            }

            NumberOfFreeListEntries++;
        }

        Head++;
    }

    Size = (HEAP_NUMBER_OF_PSEUDO_TAG + Heap->NextAvailableTagIndex + 1) * sizeof( SIZE_T );

    if ((RtlpValidateHeapTagsEnable) && (Heap->PseudoTagEntries != NULL)) {

        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &ComputedPseudoTagEntries,
                                          0,
                                          &Size,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        if (NT_SUCCESS( Status )) {

            ComputedTagEntries = ComputedPseudoTagEntries + HEAP_NUMBER_OF_PSEUDO_TAG;
        }
    }

    Head = &Heap->VirtualAllocdBlocks;
    Next = Head->Flink;

    while (Head != Next) {

        VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

        if (ComputedTagEntries != NULL) {

            TagIndex = VirtualAllocBlock->ExtraStuff.TagIndex;

            if (TagIndex != 0) {

                if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

                    TagIndex &= ~HEAP_PSEUDO_TAG_FLAG;

                    if (TagIndex < HEAP_NUMBER_OF_PSEUDO_TAG) {

                        ComputedPseudoTagEntries[ TagIndex ] +=
                            VirtualAllocBlock->CommitSize >> HEAP_GRANULARITY_SHIFT;
                    }

                } else if (TagIndex & HEAP_GLOBAL_TAG) {

                    //
                    //  Ignore these since they are global across more than
                    //  one heap.
                    //

                } else if (TagIndex < Heap->NextAvailableTagIndex) {

                    ComputedTagEntries[ TagIndex ] +=
                        VirtualAllocBlock->CommitSize >> HEAP_GRANULARITY_SHIFT;
                }
            }
        }

        if (VirtualAllocBlock->BusyBlock.Flags & HEAP_ENTRY_FILL_PATTERN) {

            if (!RtlpCheckBusyBlockTail( &VirtualAllocBlock->BusyBlock )) {

                return FALSE;
            }
        }

        Next = Next->Flink;
    }

    CountOfFreeBlocks = 0;
    TotalFreeSize = 0;

    for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

        Segment = Heap->Segments[ SegmentIndex ];

        if (Segment) {

            if (!RtlpValidateHeapSegment( Heap,
                                          Segment,
                                          SegmentIndex,
                                          &CountOfFreeBlocks,
                                          &TotalFreeSize,
                                          &BadAddress,
                                          ComputedTagEntries,
                                          ComputedPseudoTagEntries )) {

                goto errorExit;
            }
        }
    }

    BadAddress = Heap;

    if (NumberOfFreeListEntries != CountOfFreeBlocks) {

        HeapDebugPrint(( "Number of free blocks in arena (%ld) does not match number in the free lists (%ld)\n",
                         CountOfFreeBlocks,
                         NumberOfFreeListEntries ));

        goto errorExit;
    }

    if (Heap->TotalFreeSize != TotalFreeSize) {

        HeapDebugPrint(( "Total size of free blocks in arena (%ld) does not match number total in heap header (%ld)\n",
                         TotalFreeSize,
                         Heap->TotalFreeSize ));

        goto errorExit;
    }

    if (ComputedPseudoTagEntries != NULL) {

        PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntries;
        PHEAP_TAG_ENTRY TagEntries;
        USHORT TagIndex;

        PseudoTagEntries = Heap->PseudoTagEntries;

        if (PseudoTagEntries != NULL) {

            for (TagIndex=1; TagIndex<HEAP_NUMBER_OF_PSEUDO_TAG; TagIndex++) {

                PseudoTagEntries += 1;

                if (ComputedPseudoTagEntries[ TagIndex ] != PseudoTagEntries->Size) {

                    HeapDebugPrint(( "Pseudo Tag %04x size incorrect (%x != %x) %x\n",
                                     TagIndex,
                                     PseudoTagEntries->Size,
                                     ComputedPseudoTagEntries[ TagIndex ]
                                     &ComputedPseudoTagEntries[ TagIndex ] ));

                    goto errorExit;
                }
            }
        }

        TagEntries = Heap->TagEntries;

        if (TagEntries != NULL) {

            for (TagIndex=1; TagIndex<Heap->NextAvailableTagIndex; TagIndex++) {

                TagEntries += 1;

                if (ComputedTagEntries[ TagIndex ] != TagEntries->Size) {

                    HeapDebugPrint(( "Tag %04x (%ws) size incorrect (%x != %x) %x\n",
                                     TagIndex,
                                     TagEntries->TagName,
                                     TagEntries->Size,
                                     ComputedTagEntries[ TagIndex ],
                                     &ComputedTagEntries[ TagIndex ] ));

                    goto errorExit;
                }
            }
        }

        Size = 0;

        NtFreeVirtualMemory( NtCurrentProcess(),
                             &ComputedPseudoTagEntries,
                             &Size,
                             MEM_RELEASE );
    }

exit:

    return TRUE;

errorExit:

    HeapDebugBreak( BadAddress );

    if (ComputedPseudoTagEntries != NULL) {

        Size = 0;

        NtFreeVirtualMemory( NtCurrentProcess(),
                             &ComputedPseudoTagEntries,
                             &Size,
                             MEM_RELEASE );
    }

    return FALSE;

}


BOOLEAN RtlpHeapInvalidBreakPoint;
PVOID RtlpHeapInvalidBadAddress;

VOID
RtlpBreakPointHeap (
    IN PVOID BadAddress
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    if (NtCurrentPeb()->BeingDebugged) {

        *(BOOLEAN volatile *)&RtlpHeapInvalidBreakPoint = TRUE;

        RtlpHeapInvalidBadAddress = BadAddress;

        DbgBreakPoint();

        *(BOOLEAN volatile *)&RtlpHeapInvalidBreakPoint = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\rtl\heap.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    heap.c

Abstract:

    This module implements a heap allocator.

Author:

    Steve Wood (stevewo) 20-Sep-1989 (Adapted from URTL\alloc.c)

Revision History:

--*/

#include "ntrtlp.h"
#include "heap.h"
#include "heappriv.h"

ULONG NtGlobalFlag;

#ifdef NTHEAP_ENABLED
#include "heapp.h"
#endif // NTHEAP_ENABLED

#ifdef NTOS_KERNEL_RUNTIME

SIZE_T MmHeapSegmentReserve = 1024 * 1024;
SIZE_T MmHeapSegmentCommit = PAGE_SIZE * 2;
SIZE_T MmHeapDeCommitTotalFreeThreshold = 64 * 1024;
SIZE_T MmHeapDeCommitFreeBlockThreshold = PAGE_SIZE;

#else  // NTOS_KERNEL_RUNTIME

ULONG RtlpDisableHeapLookaside = 0;

#endif // NTOS_KERNEL_RUNTIME

//
//  If any of these flags are set, the fast allocator punts
//  to the slow do-everything allocator.
//

#define HEAP_SLOW_FLAGS (HEAP_DEBUG_FLAGS           | \
                         HEAP_SETTABLE_USER_FLAGS   | \
                         HEAP_NEED_EXTRA_FLAGS      | \
                         HEAP_CREATE_ALIGN_16       | \
                         HEAP_FREE_CHECKING_ENABLED | \
                         HEAP_TAIL_CHECKING_ENABLED)

#if DBG

UCHAR CheckHeapFillPattern[ CHECK_HEAP_TAIL_SIZE ] = {
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
#if defined(_WIN64) || defined(_XBOX)
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
#endif
    CHECK_HEAP_TAIL_FILL
};

#endif // DBG

//
//  An extra bitmap manipulation routine
//

#if i386

CCHAR
FASTCALL
RtlFindFirstSetRightMember(
    ULONG Set
    );

#else

#define RtlFindFirstSetRightMember(Set)                     \
    (((Set) & 0xFFFF) ?                                     \
        (((Set) & 0xFF) ?                                   \
            RtlpBitsClearLow[(Set) & 0xFF] :                \
            RtlpBitsClearLow[((Set) >> 8) & 0xFF] + 8) :    \
        ((((Set) >> 16) & 0xFF) ?                           \
            RtlpBitsClearLow[ ((Set) >> 16) & 0xFF] + 16 :  \
            RtlpBitsClearLow[ (Set) >> 24] + 24)            \
    )

#endif


//
//  These are procedure prototypes exported by heapdbg.c
//

#ifndef NTOS_KERNEL_RUNTIME

PVOID
RtlDebugCreateHeap (
    IN ULONG Flags,
    IN PVOID HeapBase OPTIONAL,
    IN SIZE_T ReserveSize OPTIONAL,
    IN SIZE_T CommitSize OPTIONAL,
    IN PVOID Lock OPTIONAL,
    IN PRTL_HEAP_PARAMETERS Parameters OPTIONAL
    );

BOOLEAN
RtlDebugDestroyHeap (
    IN PVOID HeapHandle
    );

PVOID
RtlDebugAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

BOOLEAN
RtlDebugFreeHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    );

ULONG
RtlDebugSizeHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    );

NTSTATUS
RtlDebugZeroHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

#endif // NTOS_KERNEL_RUNTIME


//
//  Local procedure prototypes
//

BOOLEAN
RtlpGrowBlockInPlace (
    IN PHEAP Heap,
    IN ULONG Flags,
    IN PHEAP_ENTRY BusyBlock,
    IN SIZE_T Size,
    IN SIZE_T AllocationIndex
    );

PHEAP_UNCOMMMTTED_RANGE
RtlpCreateUnCommittedRange (
    IN PHEAP_SEGMENT Segment
    );

VOID
RtlpDestroyUnCommittedRange (
    IN PHEAP_SEGMENT Segment,
    IN PHEAP_UNCOMMMTTED_RANGE UnCommittedRange
    );

VOID
RtlpInsertUnCommittedPages (
    IN PHEAP_SEGMENT Segment,
    IN ULONG_PTR Address,
    IN SIZE_T Size
    );

NTSTATUS
RtlpDestroyHeapSegment (
    IN PHEAP_SEGMENT Segment
    );

PHEAP_FREE_ENTRY
RtlpExtendHeap (
    IN PHEAP Heap,
    IN SIZE_T AllocationSize
    );


PVOID
RtlCreateHeap (
    IN ULONG Flags,
    IN PVOID HeapBase OPTIONAL,
    IN SIZE_T ReserveSize OPTIONAL,
    IN SIZE_T CommitSize OPTIONAL,
    IN PVOID Lock OPTIONAL,
    IN PRTL_HEAP_PARAMETERS Parameters OPTIONAL
    )

/*++

Routine Description:

    This routine initializes a heap.

Arguments:

    Flags - Specifies optional attributes of the heap.

        Valid Flags Values:

        HEAP_NO_SERIALIZE - if set, then allocations and deallocations on
                         this heap are NOT synchronized by these routines.

        HEAP_GROWABLE - if set, then the heap is a "sparse" heap where
                        memory is committed only as necessary instead of
                        being preallocated.

    HeapBase - if not NULL, this specifies the base address for memory
        to use as the heap.  If NULL, memory is allocated by these routines.

    ReserveSize - if not zero, this specifies the amount of virtual address
        space to reserve for the heap.

    CommitSize - if not zero, this specifies the amount of virtual address
        space to commit for the heap.  Must be less than ReserveSize.  If
        zero, then defaults to one page.

    Lock - if not NULL, this parameter points to the resource lock to
        use.  Only valid if HEAP_NO_SERIALIZE is NOT set.

    Parameters - optional heap parameters.

Return Value:

    PVOID - a pointer to be used in accessing the created heap.

--*/

{
    NTSTATUS Status;
    PHEAP Heap = NULL;
    PHEAP_SEGMENT Segment = NULL;
    PLIST_ENTRY FreeListHead;
    ULONG SizeOfHeapHeader;
    ULONG SegmentFlags;
    PVOID CommittedBase;
    PVOID UnCommittedBase;
    MEMORY_BASIC_INFORMATION MemoryInformation;
    ULONG n;
    ULONG InitialCountOfUnusedUnCommittedRanges;
    SIZE_T MaximumHeapBlockSize;
    PVOID NextHeapHeaderAddress;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange, *pp;
    RTL_HEAP_PARAMETERS TempParameters;

#ifndef NTOS_KERNEL_RUNTIME

    PPEB Peb;

#endif // NTOS_KERNEL_RUNTIME

    RTL_PAGED_CODE();

#ifndef NTOS_KERNEL_RUNTIME
#ifdef NTHEAP_ENABLED
    {
        if (Flags & NTHEAP_ENABLED_FLAG) {

            Heap = RtlCreateNtHeap( Flags, NULL );

            if (Heap != NULL) {

                return Heap;
            }

            Flags &= ~NTHEAP_ENABLED_FLAG;
        }
    }
#endif // NTHEAP_ENABLED
#endif // NTOS_KERNEL_RUNTIME

    //
    //  Check if we should be using the page heap code.  If not then turn
    //  off any of the page heap flags before going on
    //

#ifdef DEBUG_PAGE_HEAP

    if ( RtlpDebugPageHeap && ( HeapBase == NULL ) && ( Lock == NULL )) {

        PVOID PageHeap;

        PageHeap = RtlpDebugPageHeapCreate(

            Flags,
            HeapBase,
            ReserveSize,
            CommitSize,
            Lock,
            Parameters );

        if (PageHeap != NULL) {
            return PageHeap;
        }

        //
        // A `-1' value signals a recursive call from page heap
        // manager. We set this to null and continue creating
        // a normal heap. This small hack is required so that we
        // minimize the dependencies between the normal and the page
        // heap manager.
        //

        if ((SIZE_T)Parameters == (SIZE_T)-1) {

            Parameters = NULL;
        }
    }

    Flags &= ~( HEAP_PROTECTION_ENABLED |
        HEAP_BREAK_WHEN_OUT_OF_VM |
        HEAP_NO_ALIGNMENT );

#endif // DEBUG_PAGE_HEAP

#if DBG
    //
    //  If the caller does not want to skip heap validiation checks then we
    //  need to validate the rest of the flags but simply masking out only
    //  those flags that want on a create heap call
    //

    if (!(Flags & HEAP_SKIP_VALIDATION_CHECKS)) {

        if (Flags & ~HEAP_CREATE_VALID_MASK) {

            HeapDebugPrint(( "Invalid flags (%08x) specified to RtlCreateHeap\n", Flags ));
            HeapDebugBreak( NULL );

            Flags &= HEAP_CREATE_VALID_MASK;
        }
    }
#endif // DBG

    //
    //  The maximum heap block size is really 0x7f000 which is 0x80000 minus a
    //  page.  Maximum block size is 0xfe00 and granularity shift is 3.
    //

    MaximumHeapBlockSize = HEAP_MAXIMUM_BLOCK_SIZE << HEAP_GRANULARITY_SHIFT;

    //
    //  Assume we're going to be successful until we're shown otherwise
    //

    Status = STATUS_SUCCESS;

    //
    //  This part of the routine builds up local variable containing all the
    //  parameters used to initialize the heap.  First thing we do is zero
    //  it out.
    //

    RtlZeroMemory( &TempParameters, sizeof( TempParameters ) );

    //
    //  If our caller supplied the optional heap parameters then we'll
    //  make sure the size is good and copy over them over to our
    //  local copy
    //

    if (ARGUMENT_PRESENT( Parameters )) {

        try {

            if (Parameters->Length == sizeof( *Parameters )) {

                RtlMoveMemory( &TempParameters, Parameters, sizeof( *Parameters ) );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
        }

        if (!NT_SUCCESS( Status )) {

            return NULL;
        }
    }

    //
    //  Set the parameter block to the local copy
    //

    Parameters = &TempParameters;

    //
    //  If nt global flags tells us to always do tail or free checking
    //  or to disable coalescing then force those bits set in the user
    //  specified flags
    //

#if DBG
    if (NtGlobalFlag & FLG_HEAP_ENABLE_TAIL_CHECK) {

        Flags |= HEAP_TAIL_CHECKING_ENABLED;
    }

    if (NtGlobalFlag & FLG_HEAP_ENABLE_FREE_CHECK) {

        Flags |= HEAP_FREE_CHECKING_ENABLED;
    }
#endif // DBG

    if (NtGlobalFlag & FLG_HEAP_DISABLE_COALESCING) {

        Flags |= HEAP_DISABLE_COALESCE_ON_FREE;
    }

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case we also check if we should
    //  validate parameters, validate all, or do stack backtraces
    //

    Peb = NtCurrentPeb();

#if DBG
    if (NtGlobalFlag & FLG_HEAP_VALIDATE_PARAMETERS) {

        Flags |= HEAP_VALIDATE_PARAMETERS_ENABLED;
    }

    if (NtGlobalFlag & FLG_HEAP_VALIDATE_ALL) {

        Flags |= HEAP_VALIDATE_ALL_ENABLED;
    }

    if (NtGlobalFlag & FLG_USER_STACK_TRACE_DB) {

        Flags |= HEAP_CAPTURE_STACK_BACKTRACES;
    }
#endif // DBG

    //
    //  Also in the non kernel case the PEB will have some state
    //  variables that we need to set if the user hasn't specified
    //  otherwise
    //

    if (Parameters->SegmentReserve == 0) {

        Parameters->SegmentReserve = Peb->HeapSegmentReserve;
    }

    if (Parameters->SegmentCommit == 0) {

        Parameters->SegmentCommit = Peb->HeapSegmentCommit;
    }

    if (Parameters->DeCommitFreeBlockThreshold == 0) {

        Parameters->DeCommitFreeBlockThreshold = Peb->HeapDeCommitFreeBlockThreshold;
    }

    if (Parameters->DeCommitTotalFreeThreshold == 0) {

        Parameters->DeCommitTotalFreeThreshold = Peb->HeapDeCommitTotalFreeThreshold;
    }
#else // NTOS_KERNEL_RUNTIME

    //
    //  In the kernel case Mm has some global variables that we set
    //  into the paramters if the user hasn't specified otherwise
    //

    if (Parameters->SegmentReserve == 0) {

        Parameters->SegmentReserve = MmHeapSegmentReserve;
    }

    if (Parameters->SegmentCommit == 0) {

        Parameters->SegmentCommit = MmHeapSegmentCommit;
    }

    if (Parameters->DeCommitFreeBlockThreshold == 0) {

        Parameters->DeCommitFreeBlockThreshold = MmHeapDeCommitFreeBlockThreshold;
    }

    if (Parameters->DeCommitTotalFreeThreshold == 0) {

        Parameters->DeCommitTotalFreeThreshold = MmHeapDeCommitTotalFreeThreshold;
    }
#endif // NTOS_KERNEL_RUNTIME

    //
    //  If the user hasn't said what the largest allocation size is then
    //  we should compute it as the difference between the highest and lowest
    //  address less one page
    //

    if (Parameters->MaximumAllocationSize == 0) {

        Parameters->MaximumAllocationSize = ((ULONG_PTR)MM_HIGHEST_USER_ADDRESS -
                                             (ULONG_PTR)MM_LOWEST_USER_ADDRESS -
                                             PAGE_SIZE );
    }

    //
    //  Set the virtual memory threshold to be non zero and not more than the
    //  maximum heap block size of 0x7f000.  If the user specified one that is
    //  too large we automatically and silently drop it down.
    //

    if ((Parameters->VirtualMemoryThreshold == 0) ||
        (Parameters->VirtualMemoryThreshold > MaximumHeapBlockSize)) {

        Parameters->VirtualMemoryThreshold = MaximumHeapBlockSize;
    }

    //
    //  The default commit size is one page and the default reserve size is
    //  64 pages.
    //
    //  **** this doesn't check that commit size if specified is less than
    //  **** reserved size if specified
    //

    if (!ARGUMENT_PRESENT( CommitSize )) {

        CommitSize = PAGE_SIZE;

        if (!ARGUMENT_PRESENT( ReserveSize )) {

            ReserveSize = 64 * CommitSize;

        } else {

            ReserveSize = ROUND_UP_TO_POWER2( ReserveSize, PAGE_SIZE );
        }

    } else {

        //
        //  The heap actually uses space that is reserved and commited
        //  to store internal data structures (the LOCK,
        //  the HEAP_PSEUDO_TAG, etc.). These structures can be larger than
        //  4K especially on a 64-bit build. So, make sure the commit
        //  is at least 8K in length which is the minimal page size for
        //  64-bit systems
        //

        CommitSize = ROUND_UP_TO_POWER2(CommitSize, PAGE_SIZE);

        if (!ARGUMENT_PRESENT( ReserveSize )) {

            ReserveSize = ROUND_UP_TO_POWER2( CommitSize, 16 * PAGE_SIZE );

        } else {

            ReserveSize = ROUND_UP_TO_POWER2( ReserveSize, PAGE_SIZE );
        }

    }

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case check if we are creating a debug heap
    //  the test checks that skip validation checks is false.
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugCreateHeap( Flags,
                                   HeapBase,
                                   ReserveSize,
                                   CommitSize,
                                   Lock,
                                   Parameters );
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  Compute the size of the heap which will be the
    //  heap struct itself and if we are to seralize with
    //  out own lock then add room for the lock.  If the
    //  user did not supply the lock then set the lock
    //  variable to -1.
    //

    SizeOfHeapHeader = sizeof( HEAP );

    if (!(Flags & HEAP_NO_SERIALIZE)) {

        if (ARGUMENT_PRESENT( Lock )) {

            Flags |= HEAP_LOCK_USER_ALLOCATED;

        } else {

            SizeOfHeapHeader += sizeof( HEAP_LOCK );
            Lock = (PHEAP_LOCK)-1;
        }

    } else if (ARGUMENT_PRESENT( Lock )) {

        //
        //  In this error case the call said not to seralize but also fed us
        //  a lock
        //

        return NULL;
    }

    //
    //  See if caller allocate the space for the heap.
    //

    if (ARGUMENT_PRESENT( HeapBase )) {

        //
        //  The call specified a heap base now check if there is
        //  a caller supplied commit routine
        //

        if (Parameters->CommitRoutine != NULL) {

            //
            //  The caller specified a commit routine so he caller
            //  also needs to have given us certain parameters and make
            //  sure the heap is not growable.  Otherwise it is an error
            //

            if ((Parameters->InitialCommit == 0) ||
                (Parameters->InitialReserve == 0) ||
                (Parameters->InitialCommit > Parameters->InitialReserve) ||
                (Flags & HEAP_GROWABLE)) {

                return NULL;
            }

            //
            //  Set the commited base and the uncommited base to the
            //  proper pointers within the heap.
            //

            CommittedBase = HeapBase;
            UnCommittedBase = (PCHAR)CommittedBase + Parameters->InitialCommit;
            ReserveSize = Parameters->InitialReserve;

            //
            //  Zero out a page of the heap where our first part goes
            //
            //  **** what if the size is less than a page
            //

            RtlZeroMemory( CommittedBase, PAGE_SIZE );

        } else {

            //
            //  The user gave us space but not commit routine
            //  So query the base to get its size
            //

            Status = ZwQueryVirtualMemory( HeapBase,
                                           &MemoryInformation );

            if (!NT_SUCCESS( Status )) {

                return NULL;
            }

            //
            //  Make sure the user gave us a base address for this block
            //  and that the memory is not free
            //

            if (MemoryInformation.BaseAddress != HeapBase) {

                return NULL;
            }

            if (MemoryInformation.State == MEM_FREE) {

                return NULL;
            }

            //
            //  Set our commit base to the start of the range
            //

            CommittedBase = MemoryInformation.BaseAddress;

            //
            //  If the memory is commmitted then
            //  we can zero out a page worth
            //

            if (MemoryInformation.State == MEM_COMMIT) {

                RtlZeroMemory( CommittedBase, PAGE_SIZE );

                //
                //  Set the commit size and uncommited base according
                //  to the start of the vm
                //

                CommitSize = MemoryInformation.RegionSize;
                UnCommittedBase = (PCHAR)CommittedBase + CommitSize;

                //
                //  Find out the uncommited base is reserved and if so
                //  the update the reserve size accordingly.
                //

                Status = ZwQueryVirtualMemory( UnCommittedBase,
                                               &MemoryInformation );

                ReserveSize = CommitSize;

                if ((NT_SUCCESS( Status )) &&
                    (MemoryInformation.State == MEM_RESERVE)) {

                    ReserveSize += MemoryInformation.RegionSize;
                }

            } else {

                //
                //  The memory the user gave us is not committed so dummy
                //  up these small nummbers
                //

                CommitSize = PAGE_SIZE;
                UnCommittedBase = CommittedBase;
            }
        }

        //
        //  This user gave us a base and we've just taken care of the committed
        //  bookkeeping.  So mark this segment as user supplied and set the
        //  heap
        //

        SegmentFlags = HEAP_SEGMENT_USER_ALLOCATED;
        Heap = (PHEAP)HeapBase;

    } else {

        //
        //  The user did not specify a heap base so we have to allocate the
        //  vm here.  First make sure the user did not give us a commit routine
        //

        if (Parameters->CommitRoutine != NULL) {

            return NULL;
        }

        //
        //  Reserve the amount of virtual address space requested.
        //

        Status = ZwAllocateVirtualMemory( (PVOID *)&Heap,
                                          0,
                                          &ReserveSize,
                                          MEM_RESERVE,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return NULL;
        }

        //
        //  Indicate that this segment is not user supplied
        //

        SegmentFlags = 0;

        //
        //  Set the default commit size to one page
        //

        if (!ARGUMENT_PRESENT( CommitSize )) {

            CommitSize = PAGE_SIZE;
        }

        //
        //  Set the committed and uncommitted base to be the same the following
        //  code will actually commit the page for us
        //

        CommittedBase = Heap;
        UnCommittedBase = Heap;
    }

    //
    //  At this point we have a heap pointer, committed base, uncommitted base,
    //  segment flags, commit size, and reserve size.  If the committed and
    //  uncommited base are the same then we need to commit the amount
    //  specified by the commit size
    //

    if (CommittedBase == UnCommittedBase) {

        Status = ZwAllocateVirtualMemory( (PVOID *)&CommittedBase,
                                          0,
                                          &CommitSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        //
        //  In the non successful case we need to back out any vm reservation
        //  we did earlier
        //

        if (!NT_SUCCESS( Status )) {

            if (!ARGUMENT_PRESENT(HeapBase)) {

                //
                //  Return the reserved virtual address space.
                //

                ZwFreeVirtualMemory( (PVOID *)&Heap,
                                     &ReserveSize,
                                     MEM_RELEASE );

            }

            return NULL;
        }

        //
        //  The new uncommitted base is not adjusted above what we just
        //  committed
        //

        UnCommittedBase = (PVOID)((PCHAR)UnCommittedBase + CommitSize);
    }

    //
    //  At this point we have memory for the start of the heap committed and
    //  ready to be initialized.  So now we need initialize the heap
    //

    //
    //  Calculate the end of the heap header and make room for 8 uncommitted
    //  range structures.  Once we have the room for them then chain them
    //  together and null terminate the chain
    //

    NextHeapHeaderAddress = Heap + 1;

    UnCommittedRange = (PHEAP_UNCOMMMTTED_RANGE)ROUND_UP_TO_POWER2( NextHeapHeaderAddress,
                                                                    sizeof( QUAD ) );

    InitialCountOfUnusedUnCommittedRanges = 8;

    SizeOfHeapHeader += InitialCountOfUnusedUnCommittedRanges * sizeof( *UnCommittedRange );

    //
    //  **** what a hack Pp is really a pointer to the next field of the
    //  **** uncommmtted range structure.  So we set next by setting through Pp
    //

    pp = &Heap->UnusedUnCommittedRanges;

    while (InitialCountOfUnusedUnCommittedRanges--) {

        *pp = UnCommittedRange;
        pp = &UnCommittedRange->Next;
        UnCommittedRange += 1;
    }

    NextHeapHeaderAddress = UnCommittedRange;

    *pp = NULL;

    //
    //  Check if tagging is enabled in global flags.  This check is always true
    //  in a debug build.
    //
    //  If tagging is enabled then make room for 129 pseudo tag heap entry.
    //  Which is one more than the number of free lists.  Also point the heap
    //  header to this array of pseudo tags entries.
    //

    if (IS_HEAP_TAGGING_ENABLED()) {

        Heap->PseudoTagEntries = (PHEAP_PSEUDO_TAG_ENTRY)ROUND_UP_TO_POWER2( NextHeapHeaderAddress,
                                                                             sizeof( QUAD ) );

        SizeOfHeapHeader += HEAP_NUMBER_OF_PSEUDO_TAG * sizeof( HEAP_PSEUDO_TAG_ENTRY );

        //
        //  **** this advancement of the next heap address doesn't seem right
        //  **** given that a pseudo heap entry is 12 ulongs in length and not
        //  **** a single byte

        NextHeapHeaderAddress = Heap->PseudoTagEntries + HEAP_NUMBER_OF_PSEUDO_TAG;
    }

    //
    //  Round the size of the heap header to the next 8 byte boundary
    //

    SizeOfHeapHeader = (ULONG) ROUND_UP_TO_POWER2( SizeOfHeapHeader,
                                                   HEAP_GRANULARITY );

    //
    //  If the sizeof the heap header is larger than the native
    //  page size, you have a problem. Further, if the CommitSize passed
    //  in was smaller than the SizeOfHeapHeader, you may not even make it
    //  this far before death...
    //
    //  HeapDbgPrint() doesn't work for IA64 yet.
    //
    //  HeapDbgPrint(("Size of the heap header is %u bytes, commit was %u bytes\n", SizeOfHeapHeader, (ULONG) CommitSize));
    //

    //
    //  Fill in the heap header fields
    //

    Heap->Entry.Size = (USHORT)(SizeOfHeapHeader >> HEAP_GRANULARITY_SHIFT);
    Heap->Entry.Flags = HEAP_ENTRY_BUSY;

    Heap->Signature = HEAP_SIGNATURE;
    Heap->Flags = Flags;
    Heap->ForceFlags = (Flags & (HEAP_NO_SERIALIZE |
                                 HEAP_GENERATE_EXCEPTIONS |
                                 HEAP_ZERO_MEMORY |
                                 HEAP_REALLOC_IN_PLACE_ONLY |
                                 HEAP_VALIDATE_PARAMETERS_ENABLED |
                                 HEAP_VALIDATE_ALL_ENABLED |
                                 HEAP_TAIL_CHECKING_ENABLED |
                                 HEAP_CREATE_ALIGN_16 |
                                 HEAP_FREE_CHECKING_ENABLED));

    Heap->FreeListsInUseTerminate = 0xFFFF;
    Heap->HeaderValidateLength = (USHORT)((PCHAR)NextHeapHeaderAddress - (PCHAR)Heap);
    Heap->HeaderValidateCopy = NULL;

    //
    //  Initialize the free list to be all empty
    //

    FreeListHead = &Heap->FreeLists[ 0 ];
    n = HEAP_MAXIMUM_FREELISTS;

    while (n--) {

        InitializeListHead( FreeListHead );
        FreeListHead++;
    }

    //
    //  Make it so that there a no big block allocations
    //

    InitializeListHead( &Heap->VirtualAllocdBlocks );

    //
    //  Initialize the cricital section that controls access to
    //  the free list.  If the lock variable is -1 then the caller
    //  did not supply a lock so we need to make room for one
    //  and initialize it.
    //

    if (Lock == (PHEAP_LOCK)-1) {

        Lock = (PHEAP_LOCK)NextHeapHeaderAddress;

        Status = RtlInitializeLockRoutine( Lock );

        if (!NT_SUCCESS( Status )) {

            return NULL;
        }

        NextHeapHeaderAddress = (PHEAP_LOCK)Lock + 1;
    }

    Heap->LockVariable = Lock;


    //
    //  Initialize the first segment for the heap
    //

    if (!RtlpInitializeHeapSegment( Heap,
                                    (PHEAP_SEGMENT)((PCHAR)Heap + SizeOfHeapHeader),
                                    0,
                                    SegmentFlags,
                                    CommittedBase,
                                    UnCommittedBase,
                                    (PCHAR)CommittedBase + ReserveSize )) {

        return NULL;
    }

    //
    //  Fill in additional heap entry fields
    //

    Heap->ProcessHeapsListIndex = 0;
    Heap->SegmentReserve = Parameters->SegmentReserve;
    Heap->SegmentCommit = Parameters->SegmentCommit;
    Heap->DeCommitFreeBlockThreshold = Parameters->DeCommitFreeBlockThreshold >> HEAP_GRANULARITY_SHIFT;
    Heap->DeCommitTotalFreeThreshold = Parameters->DeCommitTotalFreeThreshold >> HEAP_GRANULARITY_SHIFT;
    Heap->MaximumAllocationSize = Parameters->MaximumAllocationSize;

    Heap->VirtualMemoryThreshold = (ULONG) (ROUND_UP_TO_POWER2( Parameters->VirtualMemoryThreshold,
                                                       HEAP_GRANULARITY ) >> HEAP_GRANULARITY_SHIFT);

    Heap->CommitRoutine = Parameters->CommitRoutine;

    //
    //  We either align the heap at 16 or 8 byte boundaries.  The AlignRound
    //  and AlignMask are used to bring allocation sizes up to the next
    //  boundary.  The align round includes the heap header and the optional
    //  check tail size
    //

    if (Flags & HEAP_CREATE_ALIGN_16) {

        Heap->AlignRound = 15 + sizeof( HEAP_ENTRY );
        Heap->AlignMask = (ULONG)~15;

    } else {

        Heap->AlignRound = HEAP_GRANULARITY - 1 + sizeof( HEAP_ENTRY );
        Heap->AlignMask = (ULONG)~(HEAP_GRANULARITY - 1);
    }

#if DBG
    if (Heap->Flags & HEAP_TAIL_CHECKING_ENABLED) {

        Heap->AlignRound += CHECK_HEAP_TAIL_SIZE;
    }
#endif // DBG

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case we need to add this heap to the processes heap
    //  list
    //

    RtlpAddHeapToProcessList( Heap );

    //
    //  Initialize the heap lookaide lists.  This is only for the user mode
    //  heap and the heap contains a pointer to the lookaside list array.
    //  The array is sized the same as the dedicated free list.  First we
    //  allocate space for the lookaside list and then we initialize each
    //  lookaside list.
    //
    //  But the caller asked for no serialize or asked for non growable
    //  heap then we won't enable the lookaside lists.
    //

    Heap->Lookaside = NULL;
    Heap->LookasideLockCount = 0;

    if ((!(Flags & HEAP_NO_SERIALIZE)) &&
        ( (Flags & HEAP_GROWABLE)) &&
        (!(RtlpDisableHeapLookaside))) {

        ULONG i;

        Heap->Lookaside = RtlAllocateHeap( Heap,
                                           Flags,
                                           sizeof(HEAP_LOOKASIDE) * HEAP_MAXIMUM_FREELISTS );

        if (Heap->Lookaside != NULL) {

            for (i = 0; i < HEAP_MAXIMUM_FREELISTS; i += 1) {

                RtlpInitializeHeapLookaside( &(((PHEAP_LOOKASIDE)(Heap->Lookaside))[i]),
                                             32 );
            }
        }
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  And return the fully initialized heap to our caller
    //

    return (PVOID)Heap;
}


PVOID
RtlDestroyHeap (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

    This routine is the opposite of Rtl Create Heap.  It tears down an
    existing heap structure.

Arguments:

    HeapHandle - Supplies a pointer to the heap being destroyed

Return Value:

    PVOID - Returns null if the heap was destroyed completely and a
        pointer back to the heap if for some reason the heap could
        not be destroyed.

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_SEGMENT Segment;
    PHEAP_UCR_SEGMENT UCRSegments;
    PLIST_ENTRY Head, Next;
    PVOID BaseAddress;
    SIZE_T RegionSize;
    UCHAR SegmentIndex;

    //
    //  Validate that HeapAddress points to a HEAP structure.
    //

    RTL_PAGED_CODE();

    if (HeapHandle == NULL) {
        HeapDebugPrint(( "Ignoring RtlDestroyHeap( NULL )\n" ));

        return NULL;
    }

#ifndef NTOS_KERNEL_RUNTIME
#ifdef NTHEAP_ENABLED
    {
        if (Heap->Flags & NTHEAP_ENABLED_FLAG) {

            return RtlDestroyNtHeap( HeapHandle );
        }
    }
#endif // NTHEAP_ENABLED
#endif // NTOS_KERNEL_RUNTIME

    //
    //  Check if this is the debug version of heap using page allocation
    //  with guard pages
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapDestroy( HeapHandle ));

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case check if this is the debug version of heap
    //  and of so then call the debug version to do the teardown
    //

    if (DEBUG_HEAP( Heap->Flags )) {

        if (!RtlDebugDestroyHeap( HeapHandle )) {

            return HeapHandle;
        }
    }

    //
    //  We are not allowed to destroy the process heap
    //

    if (HeapHandle == NtCurrentPeb()->ProcessHeap) {

        return HeapHandle;
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  For every big allocation we remove it from the list and free the
    //  vm
    //

    Head = &Heap->VirtualAllocdBlocks;
    Next = Head->Flink;

    while (Head != Next) {

        BaseAddress = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

        Next = Next->Flink;
        RegionSize = 0;

        ZwFreeVirtualMemory( (PVOID *)&BaseAddress,
                             &RegionSize,
                             MEM_RELEASE );
    }

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case we need to destory any heap tags we have setup
    //  and remove this heap from the process heap list
    //

    RtlpDestroyTags( Heap );
    RtlpRemoveHeapFromProcessList( Heap );

#endif // NTOS_KERNEL_RUNTIME

    //
    //  If the heap is serialized, delete the critical section created
    //  by RtlCreateHeap.
    //

    if (!(Heap->Flags & HEAP_NO_SERIALIZE)) {

        if (!(Heap->Flags & HEAP_LOCK_USER_ALLOCATED)) {

            RtlDeleteLockRoutine( Heap->LockVariable );
        }

        Heap->LockVariable = NULL;
    }

    //
    //  For every uncommitted segment we free its vm
    //

    UCRSegments = Heap->UCRSegments;
    Heap->UCRSegments = NULL;

    while (UCRSegments) {

        BaseAddress = UCRSegments;
        UCRSegments = UCRSegments->Next;
        RegionSize = 0;

        ZwFreeVirtualMemory( &BaseAddress,
                             &RegionSize,
                             MEM_RELEASE );
    }

    //
    //  For every segment in the heap we call a worker routine to
    //  destory the segment
    //

    SegmentIndex = HEAP_MAXIMUM_SEGMENTS;

    while (SegmentIndex--) {

        Segment = Heap->Segments[ SegmentIndex ];

        if (Segment) {

            RtlpDestroyHeapSegment( Segment );
        }
    }

    //
    //  And we return to our caller
    //

    return NULL;
}


PVOID
RtlAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    )

/*++

Routine Description:

    This routine allocates a memory of the specified size from the specified
    heap.

Arguments:

    HeapHandle - Supplies a pointer to an initialized heap structure

    Flags - Specifies the set of flags to use to control the allocation

    Size - Specifies the size, in bytes, of the allocation

Return Value:

    PVOID - returns a pointer to the newly allocated block

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PULONG FreeListsInUse;
    ULONG FreeListsInUseUlong;
    SIZE_T AllocationSize;
    SIZE_T FreeSize, AllocationIndex;
    PLIST_ENTRY FreeListHead, Next;
    PHEAP_ENTRY BusyBlock;
    PHEAP_FREE_ENTRY FreeBlock, SplitBlock, SplitBlock2;
    ULONG InUseIndex;
    UCHAR FreeFlags;
    NTSTATUS Status;
    EXCEPTION_RECORD ExceptionRecord;
    PVOID ReturnValue;
    BOOLEAN LockAcquired = FALSE;

    RTL_PAGED_CODE();


#ifndef NTOS_KERNEL_RUNTIME
#ifdef NTHEAP_ENABLED
    {
        if (Heap->Flags & NTHEAP_ENABLED_FLAG) {

            return RtlAllocateNtHeap( HeapHandle,
                                      Flags,
                                      Size);
        }
    }
#endif // NTHEAP_ENABLED
#endif // NTOS_KERNEL_RUNTIME


    //
    //  Take the callers flags and add in the flags that we must forcibly set
    //  in the heap
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check for special features that force us to call the slow, do-everything
    //  version.  We do everything slow for any of the following flags.
    //
    //    HEAP_SLOW_FLAGS defined as           0x6f030f60
    //
    //      HEAP_DEBUG_FLAGS, defined as       0x69020000 (heappriv.h)
    //
    //        HEAP_VALIDATE_PARAMETERS_ENABLED 0x40000000 (heap.h)
    //
    //        HEAP_VALIDATE_ALL_ENABLED        0x20000000 (heap.h)
    //
    //        HEAP_CAPTURE_STACK_BACKTRACES    0x08000000 (heap.h)
    //
    //        HEAP_CREATE_ENABLE_TRACING       0x00020000 (ntrtl.h winnt obsolete)
    //
    //        HEAP_FLAG_PAGE_ALLOCS            0x01000000 (heappage.h)
    //
    //      HEAP_SETTABLE_USER_FLAGS           0x00000E00 (ntrtl.h)
    //
    //      HEAP_NEED_EXTRA_FLAGS              0x0f000100 (heap.h)
    //
    //      HEAP_CREATE_ALIGN_16               0x00010000 (ntrtl.h winnt obsolete)
    //
    //      HEAP_FREE_CHECKING_ENABLED         0x00000040 (ntrtl.h winnt)
    //
    //      HEAP_TAIL_CHECKING_ENABLED         0x00000020 (ntrtl.h winnt )
    //
    //  We also do everything slow if the size is greater than max long
    //

#if DBG
    if ((Flags & HEAP_SLOW_FLAGS) || (Size >= 0x80000000)) {

        return RtlAllocateHeapSlowly( HeapHandle, Flags, Size );
    }
#endif // DBG

    //
    //  At this point we know we are doing everything in this routine
    //  and not taking the slow route.
    //
    //  Round the requested size up to the allocation granularity.  Note
    //  that if the request is for 0 bytes, we still allocate memory, because
    //  we add in an extra 1 byte to protect ourselves from idiots.
    //
    //      Allocation size will be either 16, 24, 32, ...
    //      Allocation index will be 2, 3, 4, ...
    //
    //  Note that allocation size 8 is skipped and are indices 0 and 1
    //

    AllocationSize = ((Size ? Size : 1) + HEAP_GRANULARITY - 1 + sizeof( HEAP_ENTRY ))
        & ~(HEAP_GRANULARITY -1);
    AllocationIndex = AllocationSize >>  HEAP_GRANULARITY_SHIFT;

    //
    //  If there is a lookaside list and the index is within limits then
    //  try and allocate from the lookaside list.  We'll actually capture
    //  the lookaside pointer from the heap and only use the captured pointer.
    //  This will take care of the condition where a walk or lock heap can
    //  cause us to check for a non null pointer and then have it become null
    //  when we read it again.  If it is non null to start with then even if
    //  the user walks or locks the heap via another thread the pointer to
    //  still valid here so we can still try and do a lookaside list pop.
    //

#ifndef NTOS_KERNEL_RUNTIME

    {
        PHEAP_LOOKASIDE Lookaside = (PHEAP_LOOKASIDE)Heap->Lookaside;

        if ((Lookaside != NULL) &&
            (Heap->LookasideLockCount == 0) &&
            (AllocationIndex < HEAP_MAXIMUM_FREELISTS)) {

            //
            //  If the number of operation elapsed operations is 128 times the
            //  lookaside depth then it is time to adjust the depth
            //

            if ((LONG)(Lookaside[AllocationIndex].TotalAllocates - Lookaside[AllocationIndex].LastTotalAllocates) >=
                      (Lookaside[AllocationIndex].Depth * 128)) {

                RtlpAdjustHeapLookasideDepth(&(Lookaside[AllocationIndex]));
            }

            ReturnValue = RtlpAllocateFromHeapLookaside(&(Lookaside[AllocationIndex]));

            if (ReturnValue != NULL) {

                PHEAP_ENTRY BusyBlock;

                BusyBlock = ((PHEAP_ENTRY)ReturnValue) - 1;
                BusyBlock->UnusedBytes = (UCHAR)(AllocationSize - Size);
                BusyBlock->SmallTagIndex = 0;

                if (Flags & HEAP_ZERO_MEMORY) {

                    RtlZeroMemory( ReturnValue, Size );
                }

                return ReturnValue;
            }
        }
    }

#endif // NTOS_KERNEL_RUNTIME

    try {

        //
        //  Check if we need to serialize our access to the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            //
            //  Lock the free list.
            //

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        //
        //  If the allocation index is less than the maximum free list size
        //  then we can use the index to check the free list otherwise we have
        //  to either pull the entry off of the [0] index list or allocate
        //  memory directly for this request.
        //

        if (AllocationIndex < HEAP_MAXIMUM_FREELISTS) {

            //
            //  With a size that matches a free list size grab the head
            //  of the list and check if there is an available entry
            //

            FreeListHead = &Heap->FreeLists[ AllocationIndex ];

            if ( !IsListEmpty( FreeListHead ))  {

                //
                //  We're in luck the list has an entry so now get the free
                //  entry,  copy its flags, remove it from the free list
                //

                FreeBlock = CONTAINING_RECORD( FreeListHead->Blink,
                                               HEAP_FREE_ENTRY,
                                               FreeList );

                FreeFlags = FreeBlock->Flags;

                RtlpFastRemoveDedicatedFreeBlock( Heap, FreeBlock );

                //
                //  Adjust the total number of bytes free in the heap
                //

                Heap->TotalFreeSize -= AllocationIndex;

                //
                //  Mark the block as busy and and set the number of bytes
                //  unused and tag index.  Also if it is the last entry
                //  then keep that flag.
                //

                BusyBlock = (PHEAP_ENTRY)FreeBlock;
                BusyBlock->Flags = HEAP_ENTRY_BUSY | (FreeFlags & HEAP_ENTRY_LAST_ENTRY);
                BusyBlock->UnusedBytes = (UCHAR)(AllocationSize - Size);
                BusyBlock->SmallTagIndex = 0;

            } else {

                //
                //  The free list that matches our request is empty
                //
                //  Scan the free list in use vector to find the smallest
                //  available free block large enough for our allocations.
                //

                //
                //  Compute the index of the ULONG where the scan should begin
                //

                InUseIndex = (ULONG) (AllocationIndex >> 5);
                FreeListsInUse = &Heap->u.FreeListsInUseUlong[InUseIndex];

                //
                //  Mask off the bits in the first ULONG that represent allocations
                //  smaller than we need.
                //

                FreeListsInUseUlong = *FreeListsInUse++ & ~((1 << ((ULONG) AllocationIndex & 0x1f)) - 1);

                //
                //  Begin unrolled loop to scan bit vector.
                //

                switch (InUseIndex) {

                case 0:

                    if (FreeListsInUseUlong) {

                        FreeListHead = &Heap->FreeLists[0];
                        break;
                    }

                    FreeListsInUseUlong = *FreeListsInUse++;

                    //
                    //  deliberate fallthrough to next ULONG
                    //

                case 1:

                    if (FreeListsInUseUlong) {

                        FreeListHead = &Heap->FreeLists[32];
                        break;
                    }

                    FreeListsInUseUlong = *FreeListsInUse++;

                    //
                    //  deliberate fallthrough to next ULONG
                    //

                case 2:

                    if (FreeListsInUseUlong) {

                        FreeListHead = &Heap->FreeLists[64];
                        break;
                    }

                    FreeListsInUseUlong = *FreeListsInUse++;

                    //
                    //  deliberate fallthrough to next ULONG
                    //

                case 3:

                    if (FreeListsInUseUlong) {

                        FreeListHead = &Heap->FreeLists[96];
                        break;
                    }

                    //
                    //  deliberate fallthrough to non dedicated list
                    //

                default:

                    //
                    //  No suitable entry on the free list was found.
                    //

                    goto LookInNonDedicatedList;
                }

                //
                //  A free list has been found with a large enough allocation.
                //  FreeListHead contains the base of the vector it was found in.
                //  FreeListsInUseUlong contains the vector.
                //

                FreeListHead += RtlFindFirstSetRightMember( FreeListsInUseUlong );

                //
                //  Grab the free block and remove it from the free list
                //

                FreeBlock = CONTAINING_RECORD( FreeListHead->Blink,
                                               HEAP_FREE_ENTRY,
                                               FreeList );

                RtlpFastRemoveDedicatedFreeBlock( Heap, FreeBlock );

    SplitFreeBlock:

                //
                //  Save the blocks flags and decrement the amount of
                //  free space left in the heap
                //

                FreeFlags = FreeBlock->Flags;
                Heap->TotalFreeSize -= FreeBlock->Size;

                //
                //  Mark the block busy
                //

                BusyBlock = (PHEAP_ENTRY)FreeBlock;
                BusyBlock->Flags = HEAP_ENTRY_BUSY;

                //
                //  Compute the size (i.e., index) of the amount from this block
                //  that we don't need and can return to the free list
                //

                FreeSize = BusyBlock->Size - AllocationIndex;

                //
                //  Finish setting up the rest of the new busy block
                //

                BusyBlock->Size = (USHORT)AllocationIndex;
                BusyBlock->UnusedBytes = (UCHAR)(AllocationSize - Size);
                BusyBlock->SmallTagIndex = 0;

                //
                //  Now if the size that we are going to free up is not zero
                //  then lets get to work and to the split.
                //

                if (FreeSize != 0) {

                    //
                    //  But first we won't ever bother doing a split that only
                    //  gives us 8 bytes back.  So if free size is one then just
                    //  bump up the size of the new busy block
                    //

                    if (FreeSize == 1) {

                        BusyBlock->Size += 1;
                        BusyBlock->UnusedBytes += sizeof( HEAP_ENTRY );

                    } else {

                        //
                        //  Get a pointer to where the new free block will be.
                        //  When we split a block the first part goes to the new
                        //  busy block and the second part goes back to the free
                        //  list
                        //

                        SplitBlock = (PHEAP_FREE_ENTRY)(BusyBlock + AllocationIndex);

                        //
                        //  Reset the flags that we copied from the original free list
                        //  header, and set it other size fields.
                        //

                        SplitBlock->Flags = FreeFlags;
                        SplitBlock->PreviousSize = (USHORT)AllocationIndex;
                        SplitBlock->SegmentIndex = BusyBlock->SegmentIndex;
                        SplitBlock->Size = (USHORT)FreeSize;

                        //
                        //  If nothing else follows this entry then we will insert
                        //  this into the corresponding free list (and update
                        //  Segment->LastEntryInSegment)
                        //

                        if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) {

                            RtlpFastInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize);
                            Heap->TotalFreeSize += FreeSize;

                        } else {

                            //
                            //  Otherwise we need to check the following block
                            //  and if it is busy then update its previous size
                            //  before inserting our new free block into the
                            //  free list
                            //

                            SplitBlock2 = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize);

                            if (SplitBlock2->Flags & HEAP_ENTRY_BUSY) {

                                SplitBlock2->PreviousSize = (USHORT)FreeSize;

                                RtlpFastInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );
                                Heap->TotalFreeSize += FreeSize;

                            } else {

                                //
                                //  The following block is free so we'll merge
                                //  these to blocks. by first merging the flags
                                //

                                SplitBlock->Flags = SplitBlock2->Flags;

                                //
                                //  Removing the second block from its free list
                                //

                                RtlpFastRemoveFreeBlock( Heap, SplitBlock2 );

                                //
                                //  Updating the free total number of free bytes
                                //  in the heap and updating the size of the new
                                //  free block
                                //

                                Heap->TotalFreeSize -= SplitBlock2->Size;
                                FreeSize += SplitBlock2->Size;

                                //
                                //  If the new free block is still less than the
                                //  maximum heap block size then we'll simply
                                //  insert it back in the free list
                                //

                                if (FreeSize <= HEAP_MAXIMUM_BLOCK_SIZE) {

                                    SplitBlock->Size = (USHORT)FreeSize;

                                    //
                                    //  Again check if the new following block
                                    //  exists and if so then updsate is previous
                                    //  size
                                    //

                                    if (!(SplitBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                                        ((PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize))->PreviousSize = (USHORT)FreeSize;
                                    }

                                    //
                                    //  Insert the new free block into the free
                                    //  list and update the free heap size
                                    //

                                    RtlpFastInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );
                                    Heap->TotalFreeSize += FreeSize;

                                } else {

                                    //
                                    //  The new free block is pretty large so we
                                    //  need to call a private routine to do the
                                    //  insert
                                    //

                                    RtlpInsertFreeBlock( Heap, SplitBlock, FreeSize );
                                }
                            }
                        }

                        //
                        //  Now that free flags made it back into a free block
                        //  we can zero out what we saved.
                        //

                        FreeFlags = 0;

                        //
                        //  If splitblock now last, update LastEntryInSegment
                        //

                        if (SplitBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                            PHEAP_SEGMENT Segment;

                            Segment = Heap->Segments[SplitBlock->SegmentIndex];
                            Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;
                        }
                    }
                }

                //
                //  If there are no following entries then mark the new block as
                //  such
                //

                if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) {

                    BusyBlock->Flags |= HEAP_ENTRY_LAST_ENTRY;
                }
            }

            //
            //  Return the address of the user portion of the allocated block.
            //  This is the byte following the header.
            //

            ReturnValue = BusyBlock + 1;

            //
            //  **** Release the lock before the zero memory call
            //

            if (LockAcquired) {

                RtlReleaseLockRoutine( Heap->LockVariable );

                LockAcquired = FALSE;
            }
            
            //
            //  If the flags indicate that we should zero memory then do it now
            //

            if (Flags & HEAP_ZERO_MEMORY) {

                RtlZeroMemory( ReturnValue, Size );
            }

            //
            //  And return the allocated block to our caller
            //

            leave;

        //
        //  Otherwise the allocation request is bigger than the last dedicated
        //  free list size.  Now check if the size is within our threshold.
        //  Meaning that it could be in the [0] free list
        //

        } else if (AllocationIndex <= Heap->VirtualMemoryThreshold) {

    LookInNonDedicatedList:

            //
            //  The following code cycles through the [0] free list until
            //  it finds a block that satisfies the request.  The list
            //  is sorted so the search is can be terminated early on success
            //

            FreeListHead = &Heap->FreeLists[0];
            
            //
            //  Check if the largest block in the list is smaller than the request
            //

            Next = FreeListHead->Blink;

            if (FreeListHead != Next) {
                
                FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

                if (FreeBlock->Size >= AllocationIndex) {

                    //
                    //  Here we are sure there is at least a block here larger than
                    //  the requested size. Start searching from the first block
                    //

                    Next = FreeListHead->Flink;
                    
                    while (FreeListHead != Next) {

                        FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

                        if (FreeBlock->Size >= AllocationIndex) {

                            //
                            //  We've found something that we can use so now remove
                            //  it from the free list and go to where we treat spliting
                            //  a free block.  Note that the block we found here might
                            //  actually be the exact size we need and that is why
                            //  in the split free block case we have to consider having
                            //  nothing free after the split
                            //

                            RtlpFastRemoveNonDedicatedFreeBlock( Heap, FreeBlock );

                            goto SplitFreeBlock;
                        }

                        Next = Next->Flink;
                    }
                }
            }

            //
            //  The [0] list is either empty or everything is too small
            //  so now extend the heap which should get us something less
            //  than or equal to the virtual memory threshold
            //

            FreeBlock = RtlpExtendHeap( Heap, AllocationSize );

            //
            //  And provided we got something we'll treat it just like the previous
            //  split free block cases
            //

            if (FreeBlock != NULL) {

                RtlpFastRemoveNonDedicatedFreeBlock( Heap, FreeBlock );

                goto SplitFreeBlock;
            }

            //
            //  We weren't able to extend the heap so we must be out of memory
            //

            Status = STATUS_NO_MEMORY;

        //
        //  At this point the allocation is way too big for any of the free lists
        //  and we can only satisfy this request if the heap is growable
        //

        } else if (Heap->Flags & HEAP_GROWABLE) {

            PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

            VirtualAllocBlock = NULL;

            //
            //  Compute how much memory we will need for this allocation which
            //  will include the allocation size plus a header, and then go
            //  get the committed memory
            //

            AllocationSize += FIELD_OFFSET( HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

            Status = ZwAllocateVirtualMemory( (PVOID *)&VirtualAllocBlock,
                                              0,
                                              &AllocationSize,
                                              MEM_COMMIT | ((Flags & HEAP_ZERO_MEMORY) ? 0 : MEM_NOZERO),
                                              PAGE_READWRITE );

            if (NT_SUCCESS(Status)) {

                //
                //  Just committed, already zero.  Fill in the new block
                //  and insert it in the list of big allocation
                //
                RtlZeroMemory(VirtualAllocBlock, sizeof(*VirtualAllocBlock));

                VirtualAllocBlock->BusyBlock.Size = (USHORT)(AllocationSize - Size);
                VirtualAllocBlock->BusyBlock.Flags = HEAP_ENTRY_VIRTUAL_ALLOC | HEAP_ENTRY_EXTRA_PRESENT | HEAP_ENTRY_BUSY;
                VirtualAllocBlock->CommitSize = AllocationSize;
                VirtualAllocBlock->ReserveSize = AllocationSize;

                InsertTailList( &Heap->VirtualAllocdBlocks, (PLIST_ENTRY)VirtualAllocBlock );

                //
                //  Return the address of the user portion of the allocated block.
                //  This is the byte following the header.
                //

                ReturnValue = (PHEAP_ENTRY)(VirtualAllocBlock + 1);

                leave;
            }

        } else {

            Status = STATUS_BUFFER_TOO_SMALL;
        }

        //
        //  This is the error return.
        //

        if (Flags & HEAP_GENERATE_EXCEPTIONS) {

            //
            //  Construct an exception record.
            //

            ExceptionRecord.ExceptionCode = STATUS_NO_MEMORY;
            ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
            ExceptionRecord.NumberParameters = 1;
            ExceptionRecord.ExceptionFlags = 0;
            ExceptionRecord.ExceptionInformation[ 0 ] = AllocationSize;

            RtlRaiseException( &ExceptionRecord );
        }

        SET_LAST_STATUS(Status);

        ReturnValue = NULL;

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return ReturnValue;
}


PVOID
RtlAllocateHeapSlowly (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    )

/*++

Routine Description:

    This routine does the equivalent of Rtl Allocate Heap but it does it will
    additional heap consistency checking logic and tagging.

Arguments:

    HeapHandle - Supplies a pointer to an initialized heap structure

    Flags - Specifies the set of flags to use to control the allocation

    Size - Specifies the size, in bytes, of the allocation

Return Value:

    PVOID - returns a pointer to the newly allocated block

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    PVOID ReturnValue = NULL;
    PULONG FreeListsInUse;
    ULONG FreeListsInUseUlong;
    SIZE_T AllocationSize;
    SIZE_T FreeSize, AllocationIndex;
    UCHAR EntryFlags, FreeFlags;
    PLIST_ENTRY FreeListHead, Next;
    PHEAP_ENTRY BusyBlock;
    PHEAP_FREE_ENTRY FreeBlock, SplitBlock, SplitBlock2;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    NTSTATUS Status;
    EXCEPTION_RECORD ExceptionRecord;
    SIZE_T ZeroSize = 0;

    RTL_PAGED_CODE();

    //
    //  Note that Flags has already been OR'd with Heap->ForceFlags.
    //

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case check if we should be using the debug version
    //  of heap allocation
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugAllocateHeap( HeapHandle, Flags, Size );
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  If the size is greater than maxlong then say we can't allocate that
    //  much and return the error to our caller
    //

    if (Size > 0x7fffffff) {

        SET_LAST_STATUS( STATUS_NO_MEMORY );

        return NULL;
    }

    //
    //  Round up the requested size to the allocation granularity.  Note
    //  that if the request is for zero bytes we will still allocate memory,
    //
    //      Allocation size will be either 16, 24, 32, ...
    //      Allocation index will be 2, 3, 4, ...
    //

    AllocationSize = ((Size ? Size : 1) + Heap->AlignRound) & Heap->AlignMask;

    //
    //  Generate the flags needed for this heap entry.  Mark it busy and add
    //  any user settable bits.  Also if the input flag indicates any entry
    //  extra fields and we have a tag to use then make room for the extra
    //  fields in the heap entry
    //

    EntryFlags = (UCHAR)(HEAP_ENTRY_BUSY | ((Flags & HEAP_SETTABLE_USER_FLAGS) >> 4));

    if ((Flags & HEAP_NEED_EXTRA_FLAGS) || (Heap->PseudoTagEntries != NULL)) {

        EntryFlags |= HEAP_ENTRY_EXTRA_PRESENT;
        AllocationSize += sizeof( HEAP_ENTRY_EXTRA );
    }

    AllocationIndex = AllocationSize >> HEAP_GRANULARITY_SHIFT;

    try {

        //
        //  Lock the free list.
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        //
        //  Do all the actual heap work under the protection of a try-except clause
        //  to protect us from corruption
        //

        try {

            //
            //  If the allocation index is less than the maximum free list size
            //  then we can use the index to check the free list otherwise we have
            //  to either pull the entry off of the [0] index list or allocate
            //  memory directly for this request.
            //

            if (AllocationIndex < HEAP_MAXIMUM_FREELISTS) {

                //
                //  With a size that matches a free list size grab the head
                //  of the list and check if there is an available entry
                //

                FreeListHead = &Heap->FreeLists[ AllocationIndex ];

                if ( !IsListEmpty( FreeListHead ))  {

                    //
                    //  We're in luck the list has an entry so now get the free
                    //  entry,  copy its flags, remove it from the free list
                    //

                    FreeBlock = CONTAINING_RECORD( FreeListHead->Flink,
                                                   HEAP_FREE_ENTRY,
                                                   FreeList );

                    FreeFlags = FreeBlock->Flags;

                    RtlpRemoveFreeBlock( Heap, FreeBlock );

                    //
                    //  Adjust the total number of bytes free in the heap
                    //

                    Heap->TotalFreeSize -= AllocationIndex;

                    //
                    //  Mark the block as busy and and set the number of bytes
                    //  unused and tag index.  Also if it is the last entry
                    //  then keep that flag.
                    //

                    BusyBlock = (PHEAP_ENTRY)FreeBlock;
                    BusyBlock->Flags = EntryFlags | (FreeFlags & HEAP_ENTRY_LAST_ENTRY);
                    BusyBlock->UnusedBytes = (UCHAR)(AllocationSize - Size);

                } else {

                    //
                    //  The free list that matches our request is empty.  We know
                    //  that there are 128 free lists managed by a 4 ulong bitmap.
                    //  The next big if-else-if statement will decide which ulong
                    //  we tackle
                    //
                    //  Check if the requested allocation index within the first
                    //  quarter of the free lists.
                    //

                    if (AllocationIndex < (HEAP_MAXIMUM_FREELISTS * 1) / 4) {

                        //
                        //  Grab a pointer to the corresponding bitmap ulong, and
                        //  then get the bit we're actually interested in to be the
                        //  first bit of the ulong.
                        //

                        FreeListsInUse = &Heap->u.FreeListsInUseUlong[ 0 ];
                        FreeListsInUseUlong = *FreeListsInUse++ >> ((ULONG) AllocationIndex & 0x1F);

                        //
                        //  If the remaining bitmap has any bits set then we know
                        //  there is a non empty list that is larger than our
                        //  requested index so find that bit and compute the list
                        //  head of the next non empty list
                        //

                        if (FreeListsInUseUlong) {

                            FreeListHead += RtlFindFirstSetRightMember( FreeListsInUseUlong );

                        } else {

                            //
                            //  The rest of the first ulong is all zeros so we need
                            //  to move to the second ulong
                            //

                            FreeListsInUseUlong = *FreeListsInUse++;

                            //
                            //  Check if the second ulong has any bits set and if
                            //  so then compute the list head of the next non empty
                            //  list
                            //

                            if (FreeListsInUseUlong) {

                                FreeListHead += ((HEAP_MAXIMUM_FREELISTS * 1) / 4) -
                                    (AllocationIndex & 0x1F)  +
                                    RtlFindFirstSetRightMember( FreeListsInUseUlong );

                            } else {

                                //
                                //  Do the same test for the third ulong
                                //

                                FreeListsInUseUlong = *FreeListsInUse++;

                                if (FreeListsInUseUlong) {

                                    FreeListHead += ((HEAP_MAXIMUM_FREELISTS * 2) / 4) -
                                        (AllocationIndex & 0x1F) +
                                        RtlFindFirstSetRightMember( FreeListsInUseUlong );

                                } else {

                                    //
                                    //  Repeat the test for the forth ulong, and if
                                    //  that one is also empty then we need to grab
                                    //  the allocation off of the [0] index list
                                    //

                                    FreeListsInUseUlong = *FreeListsInUse++;

                                    if (FreeListsInUseUlong) {

                                        FreeListHead += ((HEAP_MAXIMUM_FREELISTS * 3) / 4) -
                                            (AllocationIndex & 0x1F)  +
                                            RtlFindFirstSetRightMember( FreeListsInUseUlong );

                                    } else {

                                        goto LookInNonDedicatedList;
                                    }
                                }
                            }
                        }

                    //
                    //  Otherwise check if the requested allocation index lies
                    //  within the second quarter of the free lists.  We repeat the
                    //  test just like we did above on the second, third, and forth
                    //  bitmap ulongs.
                    //

                    } else if (AllocationIndex < (HEAP_MAXIMUM_FREELISTS * 2) / 4) {

                        FreeListsInUse = &Heap->u.FreeListsInUseUlong[ 1 ];
                        FreeListsInUseUlong = *FreeListsInUse++ >> ((ULONG) AllocationIndex & 0x1F);

                        if (FreeListsInUseUlong) {

                            FreeListHead += RtlFindFirstSetRightMember( FreeListsInUseUlong );

                        } else {

                            FreeListsInUseUlong = *FreeListsInUse++;

                            if (FreeListsInUseUlong) {

                                FreeListHead += ((HEAP_MAXIMUM_FREELISTS * 1) / 4) -
                                    (AllocationIndex & 0x1F)  +
                                    RtlFindFirstSetRightMember( FreeListsInUseUlong );

                            } else {

                                FreeListsInUseUlong = *FreeListsInUse++;

                                if (FreeListsInUseUlong) {

                                    FreeListHead += ((HEAP_MAXIMUM_FREELISTS * 2) / 4) -
                                        (AllocationIndex & 0x1F)  +
                                        RtlFindFirstSetRightMember( FreeListsInUseUlong );

                                } else {

                                    goto LookInNonDedicatedList;
                                }
                            }
                        }

                    //
                    //  Otherwise check if the requested allocation index lies
                    //  within the third quarter of the free lists. We repeat the
                    //  test just like we did above on the third and forth bitmap
                    //  ulongs
                    //

                    } else if (AllocationIndex < (HEAP_MAXIMUM_FREELISTS * 3) / 4) {

                        FreeListsInUse = &Heap->u.FreeListsInUseUlong[ 2 ];
                        FreeListsInUseUlong = *FreeListsInUse++ >> ((ULONG) AllocationIndex & 0x1F);

                        if (FreeListsInUseUlong) {

                            FreeListHead += RtlFindFirstSetRightMember( FreeListsInUseUlong );

                        } else {

                            FreeListsInUseUlong = *FreeListsInUse++;

                            if (FreeListsInUseUlong) {

                                FreeListHead += ((HEAP_MAXIMUM_FREELISTS * 1) / 4) -
                                    (AllocationIndex & 0x1F)  +
                                    RtlFindFirstSetRightMember( FreeListsInUseUlong );

                            } else {

                                goto LookInNonDedicatedList;
                            }
                        }

                    //
                    //  Lastly the requested allocation index must lie within the
                    //  last quarter of the free lists.  We repeat the test just
                    //  like we did above on the forth ulong
                    //

                    } else {

                        FreeListsInUse = &Heap->u.FreeListsInUseUlong[ 3 ];
                        FreeListsInUseUlong = *FreeListsInUse++ >> ((ULONG) AllocationIndex & 0x1F);

                        if (FreeListsInUseUlong) {

                            FreeListHead += RtlFindFirstSetRightMember( FreeListsInUseUlong );

                        } else {

                            goto LookInNonDedicatedList;
                        }
                    }

                    //
                    //  At this point the free list head points to a non empty free
                    //  list that is of greater size than we need.
                    //

                    FreeBlock = CONTAINING_RECORD( FreeListHead->Flink,
                                                   HEAP_FREE_ENTRY,
                                                   FreeList );

    SplitFreeBlock:

                    //
                    //  Remember the flags that go with this block and remove it
                    //  from its list
                    //

                    FreeFlags = FreeBlock->Flags;

                    RtlpRemoveFreeBlock( Heap, FreeBlock );

                    //
                    //  Adjust the amount free in the heap
                    //

                    Heap->TotalFreeSize -= FreeBlock->Size;

                    //
                    //  Mark the block busy
                    //

                    BusyBlock = (PHEAP_ENTRY)FreeBlock;
                    BusyBlock->Flags = EntryFlags;

                    //
                    //  Compute the size (i.e., index) of the amount from this
                    //  block that we don't need and can return to the free list
                    //

                    FreeSize = BusyBlock->Size - AllocationIndex;

                    //
                    //  Finish setting up the rest of the new busy block
                    //

                    BusyBlock->Size = (USHORT)AllocationIndex;
                    BusyBlock->UnusedBytes = (UCHAR)(AllocationSize - Size);

                    //
                    //  Now if the size that we are going to free up is not zero
                    //  then lets get to work and to the split.
                    //

                    if (FreeSize != 0) {

                        //
                        //  But first we won't ever bother doing a split that only
                        //  gives us 8 bytes back.  So if free size is one then
                        //  just bump up the size of the new busy block
                        //

                        if (FreeSize == 1) {

                            BusyBlock->Size += 1;
                            BusyBlock->UnusedBytes += sizeof( HEAP_ENTRY );

                        } else {

                            //
                            //  Get a pointer to where the new free block will be.
                            //  When we split a block the first part goes to the
                            //  new busy block and the second part goes back to the
                            //  free list
                            //

                            SplitBlock = (PHEAP_FREE_ENTRY)(BusyBlock + AllocationIndex);

                            //
                            //  Reset the flags that we copied from the original
                            //  free list header, and set it other size fields.
                            //

                            SplitBlock->Flags = FreeFlags;
                            SplitBlock->PreviousSize = (USHORT)AllocationIndex;
                            SplitBlock->SegmentIndex = BusyBlock->SegmentIndex;
                            SplitBlock->Size = (USHORT)FreeSize;

                            //
                            //  If nothing else follows this entry then we will
                            //  insert this into the corresponding free list
                            //

                            if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) {

                                RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                                Heap->TotalFreeSize += FreeSize;

                            } else {

                                //
                                //  Otherwise we need to check the following block
                                //  and if it is busy then update its previous size
                                //  before inserting our new free block into the
                                //  free list
                                //

                                SplitBlock2 = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize);

                                if (SplitBlock2->Flags & HEAP_ENTRY_BUSY) {

                                    SplitBlock2->PreviousSize = (USHORT)FreeSize;

                                    RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                                    Heap->TotalFreeSize += FreeSize;

                                } else {

                                    //
                                    //  The following block is free so we'll merge
                                    //  these to blocks. by first merging the flags
                                    //

                                    SplitBlock->Flags = SplitBlock2->Flags;

                                    //
                                    //  Removing the second block from its free
                                    //  list
                                    //

                                    RtlpRemoveFreeBlock( Heap, SplitBlock2 );

                                    //
                                    //  Updating the free total number of free
                                    //  bytes in the heap and updating the size of
                                    //  the new free block
                                    //

                                    Heap->TotalFreeSize -= SplitBlock2->Size;
                                    FreeSize += SplitBlock2->Size;

                                    //
                                    //  If the new free block is still less than
                                    //  the maximum heap block size then we'll
                                    //  simply insert it back in the free list
                                    //

                                    if (FreeSize <= HEAP_MAXIMUM_BLOCK_SIZE) {

                                        SplitBlock->Size = (USHORT)FreeSize;

                                        //
                                        //  Again check if the new following block
                                        //  exists and if so then updsate is
                                        //  previous size
                                        //

                                        if (!(SplitBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                                            ((PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize))->PreviousSize = (USHORT)FreeSize;
                                        }

                                        //
                                        //  Insert the new free block into the free
                                        //  list and update the free heap size
                                        //

                                        RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                                        Heap->TotalFreeSize += FreeSize;

                                    } else {

                                        //
                                        //  The new free block is pretty large so
                                        //  we need to call a private routine to do
                                        //  the insert
                                        //

                                        RtlpInsertFreeBlock( Heap, SplitBlock, FreeSize );
                                    }
                                }
                            }

                            //
                            //  Now that free flags made it back into a free block
                            //  we can zero out what we saved.
                            //

                            FreeFlags = 0;

                            //
                            //  If splitblock now last, update LastEntryInSegment
                            //

                            if (SplitBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                                PHEAP_SEGMENT Segment;

                                Segment = Heap->Segments[SplitBlock->SegmentIndex];
                                Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;
                            }

                        }
                    }

                    //
                    //  If there are no following entries then mark the new block
                    //  as such
                    //

                    if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) {

                        BusyBlock->Flags |= HEAP_ENTRY_LAST_ENTRY;
                    }
                }

                //
                //  Return the address of the user portion of the allocated block.
                //  This is the byte following the header.
                //

                ReturnValue = BusyBlock + 1;

                //
                //  If the flags indicate that we should zero memory then
                //  remember how much to zero.  We'll do the zeroing later
                //

                if (Flags & HEAP_ZERO_MEMORY) {

                    ZeroSize = Size;

                //
                //  Otherwise if the flags indicate that we should fill heap then
                //  it it now.
                //

                }
#if DBG
                else if (Heap->Flags & HEAP_FREE_CHECKING_ENABLED) {

                    RtlFillMemoryUlong( (PCHAR)(BusyBlock + 1), Size & ~0x3, ALLOC_HEAP_FILL );
                }

                //
                //  If the flags indicate that we should do tail checking then copy
                //  the fill pattern right after the heap block.
                //

                if (Heap->Flags & HEAP_TAIL_CHECKING_ENABLED) {

                    RtlFillMemory( (PCHAR)ReturnValue + Size,
                                   CHECK_HEAP_TAIL_SIZE,
                                   CHECK_HEAP_TAIL_FILL );

                    BusyBlock->Flags |= HEAP_ENTRY_FILL_PATTERN;
                }
#endif // DBG

                BusyBlock->SmallTagIndex = 0;

                //
                //  If the flags indicate that there is an extra block persent then
                //  we'll fill it in
                //

                if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                    ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                    RtlZeroMemory( ExtraStuff, sizeof( *ExtraStuff ));

    #ifndef NTOS_KERNEL_RUNTIME

                //
                //  In the non kernel case the tagging goes in either the extra
                //  stuff of the busy block small tag index
                //

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        ExtraStuff->TagIndex = RtlpUpdateTagEntry( Heap,
                                                                   (USHORT)((Flags & HEAP_TAG_MASK) >> HEAP_TAG_SHIFT),
                                                                   0,
                                                                   BusyBlock->Size,
                                                                   AllocationAction );
                    }

                } else if (IS_HEAP_TAGGING_ENABLED()) {

                    BusyBlock->SmallTagIndex = (UCHAR)RtlpUpdateTagEntry( Heap,
                                                                          (USHORT)((Flags & HEAP_SMALL_TAG_MASK) >> HEAP_TAG_SHIFT),
                                                                          0,
                                                                          BusyBlock->Size,
                                                                          AllocationAction );

    #endif // NTOS_KERNEL_RUNTIME

                }

                //
                //  Return the address of the user portion of the allocated block.
                //  This is the byte following the header.
                //

                leave;

            //
            //  Otherwise the allocation request is bigger than the last dedicated
            //  free list size.  Now check if the size is within our threshold.
            //  Meaning that it could be in the [0] free list
            //

            } else if (AllocationIndex <= Heap->VirtualMemoryThreshold) {

    LookInNonDedicatedList:

                //
                //  The following code cycles through the [0] free list until
                //  it finds a block that satisfies the request.  The list
                //  is sorted so the search is can be terminated early on success
                //

                FreeListHead = &Heap->FreeLists[ 0 ];
                Next = FreeListHead->Flink;

                while (FreeListHead != Next) {

                    FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

                    if (FreeBlock->Size >= AllocationIndex) {

                        //
                        //  We've found something that we can use so now go to
                        //  where we treat spliting a free block.  Note that
                        //  the block we found here might actually be the exact
                        //  size we need and that is why in the split free block
                        //  case we have to consider having nothing free after the
                        //  split
                        //

                        goto SplitFreeBlock;

                    } else {

                        Next = Next->Flink;
                    }
                }

                //
                //  The [0] list is either empty or everything is too small
                //  so now extend the heap which should get us something less
                //  than or equal to the virtual memory threshold
                //

                FreeBlock = RtlpExtendHeap( Heap, AllocationSize );

                //
                //  And provided we got something we'll treat it just like the
                //  previous split free block cases
                //

                if (FreeBlock != NULL) {

                    goto SplitFreeBlock;
                }

                //
                //  We weren't able to extend the heap so we must be out of memory
                //

                Status = STATUS_NO_MEMORY;

            //
            //  At this point the allocation is way too big for any of the free
            //  lists and we can only satisfy this request if the heap is growable
            //

            } else if (Heap->Flags & HEAP_GROWABLE) {

                PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

                VirtualAllocBlock = NULL;

                //
                //  Compute how much memory we will need for this allocation which
                //  will include the allocation size plus a header, and then go
                //  get the committed memory
                //

                AllocationSize += FIELD_OFFSET( HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

                Status = ZwAllocateVirtualMemory( (PVOID *)&VirtualAllocBlock,
                                                  0,
                                                  &AllocationSize,
                                                  MEM_COMMIT,
                                                  PAGE_READWRITE );

                if (NT_SUCCESS( Status )) {

                    //
                    //  Just committed, already zero.  Fill in the new block
                    //  and insert it in the list of big allocation
                    //

                    VirtualAllocBlock->BusyBlock.Size = (USHORT)(AllocationSize - Size);
                    VirtualAllocBlock->BusyBlock.Flags = EntryFlags | HEAP_ENTRY_VIRTUAL_ALLOC | HEAP_ENTRY_EXTRA_PRESENT;
                    VirtualAllocBlock->CommitSize = AllocationSize;
                    VirtualAllocBlock->ReserveSize = AllocationSize;

    #ifndef NTOS_KERNEL_RUNTIME

                    //
                    //  In the non kernel case see if we need to add heap tagging
                    //

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        VirtualAllocBlock->ExtraStuff.TagIndex =
                            RtlpUpdateTagEntry( Heap,
                                                (USHORT)((Flags & HEAP_SMALL_TAG_MASK) >> HEAP_TAG_SHIFT),
                                                0,
                                                VirtualAllocBlock->CommitSize >> HEAP_GRANULARITY_SHIFT,
                                                VirtualAllocationAction );
                    }

    #endif // NTOS_KERNEL_RUNTIME

                    InsertTailList( &Heap->VirtualAllocdBlocks, (PLIST_ENTRY)VirtualAllocBlock );

                    //
                    //  Return the address of the user portion of the allocated
                    //  block.  This is the byte following the header.
                    //

                    ReturnValue = (PHEAP_ENTRY)(VirtualAllocBlock + 1);

                    leave;
                }

            //
            //  Otherwise we have an error condition
            //

            } else {

                Status = STATUS_BUFFER_TOO_SMALL;
            }

            SET_LAST_STATUS( Status );

            if (Flags & HEAP_GENERATE_EXCEPTIONS) {

                //
                //  Construct an exception record.
                //

                ExceptionRecord.ExceptionCode = STATUS_NO_MEMORY;
                ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
                ExceptionRecord.NumberParameters = 1;
                ExceptionRecord.ExceptionFlags = 0;
                ExceptionRecord.ExceptionInformation[ 0 ] = AllocationSize;

                RtlRaiseException( &ExceptionRecord );
            }

        } except( GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_CONTINUE_SEARCH :
                                                           EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

        //
        //  Check if there is anything to zero out
        //

        if ( ZeroSize ) {

            RtlZeroMemory( ReturnValue, ZeroSize );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return ReturnValue;
}



PVOID
RtlReAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T Size
    )

/*++

Routine Description:

    This routine will resize a user specified heap block.  The new size
    can either be smaller or larger than the current block size.

Arguments:

    HeapHandle - Supplies a pointer to the heap being modified

    Flags - Supplies a set of heap flags to augment those already
        enforced by the heap

    BaseAddress - Supplies the current address of a block allocated
        from heap.  We will try and resize this block at its current
        address, but it could possibly move if this heap structure
        allows for relocation

    Size - Supplies the size, in bytes, for the newly resized heap
        block

Return Value:

    PVOID - A pointer to the resized block.  If the block had to move
        then this address will not be equal to the input base address

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    SIZE_T AllocationSize;
    PHEAP_ENTRY BusyBlock, NewBusyBlock;
    PHEAP_ENTRY_EXTRA OldExtraStuff, NewExtraStuff;
    SIZE_T FreeSize;
    BOOLEAN LockAcquired = FALSE;
    PVOID NewBaseAddress;
    PHEAP_FREE_ENTRY SplitBlock, SplitBlock2;
    SIZE_T OldSize;
    SIZE_T AllocationIndex;
    SIZE_T OldAllocationIndex;
    UCHAR FreeFlags;
    NTSTATUS Status;
    PVOID DeCommitAddress;
    SIZE_T DeCommitSize;
    EXCEPTION_RECORD ExceptionRecord;

    //
    //  If there isn't an address to relocate the heap at then our work is done
    //

    if (BaseAddress == NULL) {

        SET_LAST_STATUS( STATUS_SUCCESS );

        return NULL;
    }

#ifndef NTOS_KERNEL_RUNTIME
#ifdef NTHEAP_ENABLED
    {
        if (Heap->Flags & NTHEAP_ENABLED_FLAG) {

            return RtlReAllocateNtHeap( HeapHandle, Flags, BaseAddress, Size );
        }
    }
#endif // NTHEAP_ENABLED
#endif

    //
    //  Augment the heap flags
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if we should simply call the debug version of heap to do the work
    //

#ifndef NTOS_KERNEL_RUNTIME
    if (DEBUG_HEAP( Flags)) {

        return RtlDebugReAllocateHeap( HeapHandle, Flags, BaseAddress, Size );
    }
#endif

    //
    //  Make sure we didn't get a negative heap size
    //

    if (Size > 0x7fffffff) {

        SET_LAST_STATUS( STATUS_NO_MEMORY );

        return NULL;
    }

    //
    //  Round the requested size up to the allocation granularity.  Note
    //  that if the request is for 0 bytes, we still allocate memory, because
    //  we add in an extra byte to protect ourselves from idiots.
    //

    AllocationSize = ((Size ? Size : 1) + Heap->AlignRound) & Heap->AlignMask;

    if ((Flags & HEAP_NEED_EXTRA_FLAGS) ||
        (Heap->PseudoTagEntries != NULL) ||
        ((((PHEAP_ENTRY)BaseAddress)-1)->Flags & HEAP_ENTRY_EXTRA_PRESENT)) {

        AllocationSize += sizeof( HEAP_ENTRY_EXTRA );
    }

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;

            //
            //  Because it is now zero the following statement will set the no
            //  serialize bit
            //

            Flags ^= HEAP_NO_SERIALIZE;
        }

        try {

            //
            //  Compute the heap block address for user specified block
            //

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            //
            //  Check if the block is not in use then it is an error
            //

            if (!(BusyBlock->Flags & HEAP_ENTRY_BUSY)) {

                SET_LAST_STATUS( STATUS_INVALID_PARAMETER );

                //
                //  Bail if not a busy block.
                //

                leave;

            //
            //  We need the current (i.e., old) size and allocation of the
            //  block.  Check if the block is a big allocation.  The size
            //  field of a big block is really the unused by count
            //

            } else if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                OldSize = RtlpGetSizeOfBigBlock( BusyBlock );

                OldAllocationIndex = (OldSize + BusyBlock->Size) >> HEAP_GRANULARITY_SHIFT;

                //
                //  We'll need to adjust the new allocation size to account
                //  for the big block header and then round it up to a page
                //

                AllocationSize += FIELD_OFFSET( HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );
                AllocationSize = ROUND_UP_TO_POWER2( AllocationSize, PAGE_SIZE );

            //
            //  Otherwise the block is in use and is a small allocation
            //

            } else {

                OldAllocationIndex = BusyBlock->Size;

                OldSize = (OldAllocationIndex << HEAP_GRANULARITY_SHIFT) -
                          BusyBlock->UnusedBytes;
            }

            //
            //  Compute the new allocation index
            //

            AllocationIndex = AllocationSize >> HEAP_GRANULARITY_SHIFT;

            //
            //  At this point we have the old size and index, and the new size
            //  and index
            //
            //  See if new size less than or equal to the current size.
            //

            if (AllocationIndex <= OldAllocationIndex) {

                //
                //  If the new allocation index is only one less then the current
                //  index then make the sizes equal
                //

                if (AllocationIndex + 1 == OldAllocationIndex) {

                    AllocationIndex += 1;
                    AllocationSize += sizeof( HEAP_ENTRY );
                }

                //
                //  Calculate new residual (unused) amount
                //

                if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                    //
                    //  In a big block the size is really the unused byte count
                    //

                    BusyBlock->Size = (USHORT)(AllocationSize - Size);

                } else if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                    //
                    //  The extra stuff struct goes after the data.  So compute
                    //  the old and new extra stuff location and copy the data
                    //

                    OldExtraStuff = (PHEAP_ENTRY_EXTRA)(BusyBlock + BusyBlock->Size - 1);

                    NewExtraStuff = (PHEAP_ENTRY_EXTRA)(BusyBlock + AllocationIndex - 1);

                    *NewExtraStuff = *OldExtraStuff;

#ifndef NTOS_KERNEL_RUNTIME

                    //
                    //  If we're doing heap tagging then update the tag entry
                    //

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        NewExtraStuff->TagIndex =
                            RtlpUpdateTagEntry( Heap,
                                                NewExtraStuff->TagIndex,
                                                OldAllocationIndex,
                                                AllocationIndex,
                                                ReAllocationAction );
                    }
#endif

                    BusyBlock->UnusedBytes = (UCHAR)(AllocationSize - Size);

                } else {

                    //
                    //  If we're doing heap tagging then update the tag entry
                    //

#ifndef NTOS_KERNEL_RUNTIME

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        BusyBlock->SmallTagIndex = (UCHAR)
                            RtlpUpdateTagEntry( Heap,
                                                BusyBlock->SmallTagIndex,
                                                BusyBlock->Size,
                                                AllocationIndex,
                                                ReAllocationAction );
                    }

#endif

                    BusyBlock->UnusedBytes = (UCHAR)(AllocationSize - Size);
                }

                //
                //  Check if the block is getting bigger, then fill in the extra
                //  space.
                //
                //  **** how can this happen if the allocation index is less than or
                //  **** equal to the old allocation index
                //

                if (Size > OldSize) {

                    //
                    //  See if we should zero the extra space
                    //

                    if (Flags & HEAP_ZERO_MEMORY) {

                        RtlZeroMemory( (PCHAR)BaseAddress + OldSize,
                                       Size - OldSize );

                    //
                    //  Otherwise see if we should fill the extra space
                    //

                    }
#if DBG
                    else if (Heap->Flags & HEAP_FREE_CHECKING_ENABLED) {

                        SIZE_T PartialBytes, ExtraSize;

                        PartialBytes = OldSize & (sizeof( ULONG ) - 1);

                        if (PartialBytes) {

                            PartialBytes = 4 - PartialBytes;
                        }

                        if (Size > (OldSize + PartialBytes)) {

                            ExtraSize = (Size - (OldSize + PartialBytes)) & ~(sizeof( ULONG ) - 1);

                            if (ExtraSize != 0) {

                                RtlFillMemoryUlong( (PCHAR)(BusyBlock + 1) + OldSize + PartialBytes,
                                                    ExtraSize,
                                                    ALLOC_HEAP_FILL );
                            }
                        }
                    }
#endif // DBG
                }

#if DBG
                if (Heap->Flags & HEAP_TAIL_CHECKING_ENABLED) {

                    RtlFillMemory( (PCHAR)(BusyBlock + 1) + Size,
                                   CHECK_HEAP_TAIL_SIZE,
                                   CHECK_HEAP_TAIL_FILL );
                }
#endif // DBG
                //
                //  If amount of change is greater than the size of a free block,
                //  then need to free the extra space.  Otherwise, nothing else to
                //  do.
                //

                if (AllocationIndex != OldAllocationIndex) {

                    FreeFlags = BusyBlock->Flags & ~HEAP_ENTRY_BUSY;

                    if (FreeFlags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                        PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

                        VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

#ifndef NTOS_KERNEL_RUNTIME

                        if (IS_HEAP_TAGGING_ENABLED()) {

                            VirtualAllocBlock->ExtraStuff.TagIndex =
                                RtlpUpdateTagEntry( Heap,
                                                    VirtualAllocBlock->ExtraStuff.TagIndex,
                                                    OldAllocationIndex,
                                                    AllocationIndex,
                                                    VirtualReAllocationAction );
                        }

#endif

                        DeCommitAddress = (PCHAR)VirtualAllocBlock + AllocationSize;

                        DeCommitSize = (OldAllocationIndex << HEAP_GRANULARITY_SHIFT) -
                                       AllocationSize;

                        Status = ZwFreeVirtualMemory( (PVOID *)&DeCommitAddress,
                                                      &DeCommitSize,
                                                      MEM_RELEASE );

                        if (!NT_SUCCESS( Status )) {

                            HeapDebugPrint(( "Unable to release memory at %p for %p bytes - Status == %x\n",
                                             DeCommitAddress, DeCommitSize, Status ));

                            HeapDebugBreak( NULL );

                        } else {

                            VirtualAllocBlock->CommitSize -= DeCommitSize;
                        }

                    } else {

                        //
                        //  Otherwise, shrink size of this block to new size, and make extra
                        //  space at end free.
                        //

                        SplitBlock = (PHEAP_FREE_ENTRY)(BusyBlock + AllocationIndex);

                        SplitBlock->Flags = FreeFlags;

                        SplitBlock->PreviousSize = (USHORT)AllocationIndex;

                        SplitBlock->SegmentIndex = BusyBlock->SegmentIndex;

                        FreeSize = BusyBlock->Size - AllocationIndex;

                        BusyBlock->Size = (USHORT)AllocationIndex;

                        BusyBlock->Flags &= ~HEAP_ENTRY_LAST_ENTRY;

                        //
                        //  If the following block is uncommitted then we only need to
                        //  add this new entry to its free list
                        //

                        if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) {

                            PHEAP_SEGMENT Segment;

                            Segment = Heap->Segments[SplitBlock->SegmentIndex];
                            Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;

                            SplitBlock->Size = (USHORT)FreeSize;

                            RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                            Heap->TotalFreeSize += FreeSize;

                        } else {

                            //
                            //  Otherwise get the next block and check if it is busy.  If it
                            //  is in use then add this new entry to its free list
                            //

                            SplitBlock2 = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize);

                            if (SplitBlock2->Flags & HEAP_ENTRY_BUSY) {

                                SplitBlock->Size = (USHORT)FreeSize;

                                ((PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize))->PreviousSize = (USHORT)FreeSize;

                                RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                                Heap->TotalFreeSize += FreeSize;

                            } else {

                                //
                                //  Otherwise the next block is not in use so we
                                //  should be able to merge with it.  Remove the
                                //  second free block and if the combined size is
                                //  still okay then merge the two blocks and add
                                //  the single block back in.  Otherwise call a
                                //  routine that will actually break it apart
                                //  before insertion.
                                //

                                SplitBlock->Flags = SplitBlock2->Flags;

                                RtlpRemoveFreeBlock( Heap, SplitBlock2 );

                                Heap->TotalFreeSize -= SplitBlock2->Size;

                                FreeSize += SplitBlock2->Size;

                                if (FreeSize <= HEAP_MAXIMUM_BLOCK_SIZE) {

                                    SplitBlock->Size = (USHORT)FreeSize;

                                    if (!(SplitBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                                        ((PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize))->PreviousSize = (USHORT)FreeSize;

                                    } else {

                                        PHEAP_SEGMENT Segment;

                                        Segment = Heap->Segments[SplitBlock->SegmentIndex];
                                        Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;
                                    }

                                    RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                                    Heap->TotalFreeSize += FreeSize;

                                } else {

                                    RtlpInsertFreeBlock( Heap, SplitBlock, FreeSize );
                                }
                            }
                        }
                    }
                }

            } else {

                //
                //  At this point the new size is greater than the current size
                //
                //  If the block is a big allocation or we're not able to grow
                //  the block in place then we have a lot of work to do
                //

                if ((BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) ||
                    !RtlpGrowBlockInPlace( Heap, Flags, BusyBlock, Size, AllocationIndex )) {

                    //
                    //  We're growing the block.  Allocate a new block with the bigger
                    //  size, copy the contents of the old block to the new block and then
                    //  free the old block.  Return the address of the new block.
                    //

                    if (Flags & HEAP_REALLOC_IN_PLACE_ONLY) {

                        // HeapDebugPrint(( "Failing ReAlloc because cant do it inplace.\n" ));

                        BaseAddress = NULL;

                    } else {

                        //
                        //  Clear the tag bits from the flags
                        //

                        Flags &= ~HEAP_TAG_MASK;

                        //
                        //  If there is an extra struct present then get the tag
                        //  index from the extra stuff and augment the flags with
                        //  the tag index.
                        //

                        if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                            Flags &= ~HEAP_SETTABLE_USER_FLAGS;

                            Flags |= HEAP_SETTABLE_USER_VALUE |
                                     ((BusyBlock->Flags & HEAP_ENTRY_SETTABLE_FLAGS) << 4);

                            OldExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                            try {

                                if ((OldExtraStuff->TagIndex != 0) &&
                                    !(OldExtraStuff->TagIndex & HEAP_PSEUDO_TAG_FLAG)) {

                                    Flags |= OldExtraStuff->TagIndex << HEAP_TAG_SHIFT;
                                }

                            } except (EXCEPTION_EXECUTE_HANDLER) {

                                BusyBlock->Flags &= ~HEAP_ENTRY_EXTRA_PRESENT;
                            }

                        } else if (BusyBlock->SmallTagIndex != 0) {

                            //
                            //  There is not an extra stuff struct, but block
                            //  does have a small tag index so now add this small
                            //  tag to the flags
                            //

                            Flags |= BusyBlock->SmallTagIndex << HEAP_TAG_SHIFT;
                        }

                        //
                        //  Allocate from the heap space for the reallocation
                        //

                        NewBaseAddress = RtlAllocateHeap( HeapHandle,
                                                          Flags & ~HEAP_ZERO_MEMORY,
                                                          Size );

                        if (NewBaseAddress != NULL) {

                            //
                            //  We were able to get the allocation so now back up
                            //  to the heap block and if the block has an extra
                            //  stuff struct then copy over the extra stuff
                            //

                            NewBusyBlock = (PHEAP_ENTRY)NewBaseAddress - 1;

                            if (NewBusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                                NewExtraStuff = RtlpGetExtraStuffPointer( NewBusyBlock );

                                if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                                    OldExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                                    NewExtraStuff->Settable = OldExtraStuff->Settable;

                                } else {

                                    RtlZeroMemory( NewExtraStuff, sizeof( *NewExtraStuff ));
                                }
                            }

                            //
                            //  Copy over the user's data area to the new block
                            //

                            RtlMoveMemory( NewBaseAddress, BaseAddress, Size < OldSize ? Size : OldSize );

                            //
                            //  Check if we grew the block and we should zero
                            //  the remaining part.
                            //
                            //  **** is this first test always true because we're
                            //  **** in the part that grows blocks
                            //

                            if (Size > OldSize && (Flags & HEAP_ZERO_MEMORY)) {

                                RtlZeroMemory( (PCHAR)NewBaseAddress + OldSize,
                                               Size - OldSize );
                            }

                            //
                            //  Release the old block
                            //

                            RtlFreeHeap( HeapHandle,
                                         Flags,
                                         BaseAddress );
                        }

                        BaseAddress = NewBaseAddress;
                    }
                }
            }

            if ((BaseAddress == NULL) && (Flags & HEAP_GENERATE_EXCEPTIONS)) {

                //
                //  Construct an exception record.
                //

                ExceptionRecord.ExceptionCode = STATUS_NO_MEMORY;
                ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
                ExceptionRecord.NumberParameters = 1;
                ExceptionRecord.ExceptionFlags = 0;
                ExceptionRecord.ExceptionInformation[ 0 ] = AllocationSize;

                RtlRaiseException( &ExceptionRecord );
            }

        } except( GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_CONTINUE_SEARCH :
                                                           EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
            BaseAddress = NULL;

        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return BaseAddress;
}


//
//  Local Support routine
//

BOOLEAN
RtlpGrowBlockInPlace (
    IN PHEAP Heap,
    IN ULONG Flags,
    IN PHEAP_ENTRY BusyBlock,
    IN SIZE_T Size,
    IN SIZE_T AllocationIndex
    )

/*++

Routine Description:

    This routine will try and grow a heap allocation block at its current
    location

Arguments:

    Heap - Supplies a pointer to the heap being modified

    Flags - Supplies a set of flags to augment those already enforced by
        the heap

    BusyBlock - Supplies a pointer to the block being resized

    Size - Supplies the size, in bytes, needed by the resized block

    AllocationIndex - Supplies the allocation index for the resized block
        Note that the size variable has not been rounded up to the next
        granular block size, but that allocation index has.

Return Value:

    BOOLEAN - TRUE if the block has been resized and FALSE otherwise

--*/

{
    SIZE_T FreeSize;
    SIZE_T OldSize;
    UCHAR EntryFlags, FreeFlags;
    PHEAP_FREE_ENTRY FreeBlock, SplitBlock, SplitBlock2;
    PHEAP_ENTRY_EXTRA OldExtraStuff, NewExtraStuff;

    //
    //  Check if the allocation index is too large for even the nondedicated
    //  free list (i.e., too large for list [0])
    //

    if (AllocationIndex > Heap->VirtualMemoryThreshold) {

        return FALSE;
    }

    //
    //  Get the flags for the current block and a pointer to the next
    //  block following the current block
    //

    EntryFlags = BusyBlock->Flags;

    FreeBlock = (PHEAP_FREE_ENTRY)(BusyBlock + BusyBlock->Size);

    //
    //  If the current block is the last entry before an uncommitted range
    //  we'll try and extend the uncommitted range to fit our new allocation
    //

    if (EntryFlags & HEAP_ENTRY_LAST_ENTRY) {

        //
        //  Calculate how must more we need beyond the current block
        //  size
        //

        FreeSize = (AllocationIndex - BusyBlock->Size) << HEAP_GRANULARITY_SHIFT;
        FreeSize = ROUND_UP_TO_POWER2( FreeSize, PAGE_SIZE );

        //
        //  Try and commit memory at the desired location
        //

        FreeBlock = RtlpFindAndCommitPages( Heap,
                                            Heap->Segments[ BusyBlock->SegmentIndex ],
                                            &FreeSize,
                                            (PHEAP_ENTRY)FreeBlock );

        //
        //  Check if the commit succeeded
        //

        if (FreeBlock == NULL) {

            return FALSE;
        }

        //
        //  New coalesce this newly committed space with whatever is free
        //  around it
        //

        FreeSize = FreeSize >> HEAP_GRANULARITY_SHIFT;

        FreeBlock = RtlpCoalesceFreeBlocks( Heap, FreeBlock, &FreeSize, FALSE );

        FreeFlags = FreeBlock->Flags;

        //
        //  If the newly allocated space plus the current block size is still
        //  not big enough for our resize effort then put this newly
        //  allocated block into the appropriate free list and tell our caller
        //  that a resize wasn't possible
        //

        if ((FreeSize + BusyBlock->Size) < AllocationIndex) {

            RtlpInsertFreeBlock( Heap, FreeBlock, FreeSize );

            Heap->TotalFreeSize += FreeSize;

#ifndef NTOS_KERNEL_RUNTIME
            if (DEBUG_HEAP(Flags)) {

                RtlpValidateHeapHeaders( Heap, TRUE );
            }
#endif

            return FALSE;
        }

        //
        //  We were able to generate enough space for the resize effort, so
        //  now free size will be the index for the current block plus the
        //  new free space
        //

        FreeSize += BusyBlock->Size;

    } else {

        //
        //  The following block is present so grab its flags and see if
        //  it is free or busy.  If busy then we cannot grow the current
        //  block
        //

        FreeFlags = FreeBlock->Flags;

        if (FreeFlags & HEAP_ENTRY_BUSY) {

            return FALSE;
        }

        //
        //  Compute the index if we combine current block with its following
        //  free block and check if it is big enough
        //

        FreeSize = BusyBlock->Size + FreeBlock->Size;

        if (FreeSize < AllocationIndex) {

            return FALSE;
        }

        //
        //  The two blocks together are big enough so now remove the free
        //  block from its free list, and update the heap's total free size
        //

        RtlpRemoveFreeBlock( Heap, FreeBlock );

        Heap->TotalFreeSize -= FreeBlock->Size;
    }

    //
    //  At this point we have a busy block followed by a free block that
    //  together have enough space for the resize.  The free block has been
    //  removed from its list and free size is the index of the two combined
    //  blocks.
    //
    //  Calculate the number of bytes in use in the old block
    //

    OldSize = (BusyBlock->Size << HEAP_GRANULARITY_SHIFT) - BusyBlock->UnusedBytes;

    //
    //  Calculate the index for whatever excess we'll have when we combine
    //  the two blocks
    //

    FreeSize -= AllocationIndex;

    //
    //  If the excess is not too much then put it back in our allocation
    //  (i.e., we don't want small free pieces left over)
    //

    if (FreeSize <= 2) {

        AllocationIndex += FreeSize;

        FreeSize = 0;
    }

    //
    //  If the busy block has an extra stuff struct present then copy over the
    //  extra stuff
    //

    if (EntryFlags & HEAP_ENTRY_EXTRA_PRESENT) {

        OldExtraStuff = (PHEAP_ENTRY_EXTRA)(BusyBlock + BusyBlock->Size - 1);
        NewExtraStuff = (PHEAP_ENTRY_EXTRA)(BusyBlock + AllocationIndex - 1);

        *NewExtraStuff = *OldExtraStuff;

        //
        //  If heap tagging is enabled then update the heap tag from the extra
        //  stuff struct
        //

#ifndef NTOS_KERNEL_RUNTIME
        if (IS_HEAP_TAGGING_ENABLED()) {

            NewExtraStuff->TagIndex =
                RtlpUpdateTagEntry( Heap,
                                    NewExtraStuff->TagIndex,
                                    BusyBlock->Size,
                                    AllocationIndex,
                                    ReAllocationAction );
        }
#endif

    //
    //  Otherwise extra stuff is not in use so see if heap tagging is enabled
    //  and if so then update small tag index
    //

    }
#ifndef NTOS_KERNEL_RUNTIME
         else if (IS_HEAP_TAGGING_ENABLED()) {

        BusyBlock->SmallTagIndex = (UCHAR)
            RtlpUpdateTagEntry( Heap,
                                BusyBlock->SmallTagIndex,
                                BusyBlock->Size,
                                AllocationIndex,
                                ReAllocationAction );
    }
#endif

    //
    //  Check if we will have any free space to give back.
    //

    if (FreeSize == 0) {

        //
        //  No following free space so update the flags, size and byte counts
        //  for the resized block.  If the free block was a last entry
        //  then the busy block must also now be a last entry.
        //

        BusyBlock->Flags |= FreeFlags & HEAP_ENTRY_LAST_ENTRY;

        BusyBlock->Size = (USHORT)AllocationIndex;

        BusyBlock->UnusedBytes = (UCHAR)
            ((AllocationIndex << HEAP_GRANULARITY_SHIFT) - Size);

        //
        //  Update the previous size field of the following block if it exists
        //

        if (!(FreeFlags & HEAP_ENTRY_LAST_ENTRY)) {

            (BusyBlock + BusyBlock->Size)->PreviousSize = BusyBlock->Size;

        } else {

            PHEAP_SEGMENT Segment;

            Segment = Heap->Segments[BusyBlock->SegmentIndex];
            Segment->LastEntryInSegment = BusyBlock;
        }

    //
    //  Otherwise there is some free space to return to the heap
    //

    } else {

        //
        //  Update the size and byte counts for the resized block.
        //

        BusyBlock->Size = (USHORT)AllocationIndex;

        BusyBlock->UnusedBytes = (UCHAR)
            ((AllocationIndex << HEAP_GRANULARITY_SHIFT) - Size);

        //
        //  Determine where the new free block starts and fill in its fields
        //

        SplitBlock = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)BusyBlock + AllocationIndex);

        SplitBlock->PreviousSize = (USHORT)AllocationIndex;

        SplitBlock->SegmentIndex = BusyBlock->SegmentIndex;

        //
        //  If this new free block will be the last entry then update its
        //  flags and size and put it into the appropriate free list
        //

        if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) {

            PHEAP_SEGMENT Segment;

            Segment = Heap->Segments[SplitBlock->SegmentIndex];
            Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;

            SplitBlock->Flags = FreeFlags;
            SplitBlock->Size = (USHORT)FreeSize;

            RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

            Heap->TotalFreeSize += FreeSize;

        //
        //  The free block is followed by another valid block
        //

        } else {

            //
            //  Point to the block following our new free block
            //

            SplitBlock2 = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize);

            //
            //  If the block following the new free block is busy then
            //  update the flags and size for the new free block, update
            //  the following blocks previous size, and put the free block
            //  into the appropriate free list
            //

            if (SplitBlock2->Flags & HEAP_ENTRY_BUSY) {

                SplitBlock->Flags = FreeFlags & (~HEAP_ENTRY_LAST_ENTRY);
                SplitBlock->Size = (USHORT)FreeSize;

                //
                //  **** note that this test must be true because we are
                //  **** already in the else clause of the
                //  **** if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) statement
                //

                if (!(FreeFlags & HEAP_ENTRY_LAST_ENTRY)) {

                    ((PHEAP_ENTRY)SplitBlock + FreeSize)->PreviousSize = (USHORT)FreeSize;

                } else {

                    PHEAP_SEGMENT Segment;

                    Segment = Heap->Segments[SplitBlock->SegmentIndex];
                    Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;
                }

                RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                Heap->TotalFreeSize += FreeSize;

            //
            //  Otherwise the following block is also free so we can combine
            //  these two blocks
            //

            } else {

                //
                //  Remember the new free flags from the following block
                //

                FreeFlags = SplitBlock2->Flags;

                //
                //  Remove the following block from its free list
                //

                RtlpRemoveFreeBlock( Heap, SplitBlock2 );

                Heap->TotalFreeSize -= SplitBlock2->Size;

                //
                //  Calculate the size of the new combined free block
                //

                FreeSize += SplitBlock2->Size;

                //
                //  Give the new the its new flags
                //

                SplitBlock->Flags = FreeFlags;

                //
                //  If the combited block is not too large for the dedicated
                //  free lists then that where we'll put it
                //

                if (FreeSize <= HEAP_MAXIMUM_BLOCK_SIZE) {

                    SplitBlock->Size = (USHORT)FreeSize;

                    //
                    //  If present update the previous size for the following block
                    //

                    if (!(FreeFlags & HEAP_ENTRY_LAST_ENTRY)) {

                        ((PHEAP_ENTRY)SplitBlock + FreeSize)->PreviousSize = (USHORT)FreeSize;

                    } else {

                        PHEAP_SEGMENT Segment;

                        Segment = Heap->Segments[SplitBlock->SegmentIndex];
                        Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;
                    }

                    //
                    //  Insert the new combined free block into the free list
                    //

                    RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                    Heap->TotalFreeSize += FreeSize;

                } else {

                    //
                    //  Otherwise the new free block is too large to go into
                    //  a dedicated free list so put it in the general free list
                    //  which might involve breaking it apart.
                    //

                    RtlpInsertFreeBlock( Heap, SplitBlock, FreeSize );
                }
            }
        }
    }

    //
    //  At this point the block has been resized and any extra space has been
    //  returned to the free list
    //
    //  Check if we should zero out the new space
    //

    if (Flags & HEAP_ZERO_MEMORY) {

        //
        //  **** this test is sort of bogus because we're resizing and the new
        //  **** size by definition must be larger than the old size
        //

        if (Size > OldSize) {

            RtlZeroMemory( (PCHAR)(BusyBlock + 1) + OldSize,
                           Size - OldSize );
        }

    //
    //  Check if we should be filling in heap after it as
    //  been freed, and if so then fill in the newly allocated
    //  space beyond the old bytes.
    //

    }
#if DBG
    else if (Heap->Flags & HEAP_FREE_CHECKING_ENABLED) {

        SIZE_T PartialBytes, ExtraSize;

        PartialBytes = OldSize & (sizeof( ULONG ) - 1);

        if (PartialBytes) {

            PartialBytes = 4 - PartialBytes;
        }

        if (Size > (OldSize + PartialBytes)) {

            ExtraSize = (Size - (OldSize + PartialBytes)) & ~(sizeof( ULONG ) - 1);

            if (ExtraSize != 0) {

                RtlFillMemoryUlong( (PCHAR)(BusyBlock + 1) + OldSize + PartialBytes,
                                    ExtraSize,
                                    ALLOC_HEAP_FILL );
            }
        }
    }

    //
    //  If we are going tailing checking then fill in the space right beyond
    //  the new allocation
    //

    if (Heap->Flags & HEAP_TAIL_CHECKING_ENABLED) {

        RtlFillMemory( (PCHAR)(BusyBlock + 1) + Size,
                       CHECK_HEAP_TAIL_SIZE,
                       CHECK_HEAP_TAIL_FILL );
    }
#endif // DBG

    //
    //  Give the resized block any user settable flags send in by the
    //  caller
    //

    BusyBlock->Flags &= ~HEAP_ENTRY_SETTABLE_FLAGS;
    BusyBlock->Flags |= ((Flags & HEAP_SETTABLE_USER_FLAGS) >> 4);

    //
    //  And return to our caller
    //

    return TRUE;
}



BOOLEAN
RtlFreeHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

    This routine returns a previously allocated block back to its heap

Arguments:

    HeapHandle - Supplies a pointer to the owning heap structure

    Flags - Specifies the set of flags to use in the deallocation

    BaseAddress - Supplies a pointer to the block being freed

Return Value:

    BOOLEAN - TRUE if the block was properly freed and FALSE otherwise

--*/

{
    NTSTATUS Status;
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    SIZE_T FreeSize;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN ReturnValue = TRUE;

    RTL_PAGED_CODE();

    //
    //  First check if the address we're given is null and if so then
    //  there is really nothing to do so just return success
    //

    if (BaseAddress == NULL) {

        return TRUE;
    }

#ifndef NTOS_KERNEL_RUNTIME
#ifdef NTHEAP_ENABLED
    {
        if (Heap->Flags & NTHEAP_ENABLED_FLAG) {

            return RtlFreeNtHeap( HeapHandle,
                                  Flags,
                                  BaseAddress);
        }
    }
#endif // NTHEAP_ENABLED
#endif // NTOS_KERNEL_RUNTIME


    //
    //  Compliment the input flags with those enforced by the heap
    //

    Flags |= Heap->ForceFlags;

    //
    //  Now check if we should go the slow route
    //

#if DBG
    if (Flags & HEAP_SLOW_FLAGS) {

        return RtlFreeHeapSlowly(HeapHandle, Flags, BaseAddress);
    }
#endif // DBG

    //
    //  We can do everything in this routine. So now backup to get
    //  a pointer to the start of the block
    //

    BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

#if DBG
    //
    //  Protect ourselves from idiots by refusing to free blocks
    //  that do not have the busy bit set.
    //
    //  Also refuse to free blocks that are not eight-byte aligned.
    //  The specific idiot in this case is Office95, which likes
    //  to free a random pointer when you start Word95 from a desktop
    //  shortcut.
    //
    //  As further insurance against idiots, check the segment index
    //  to make sure it is less than HEAP_MAXIMUM_SEGMENTS (16). This
    //  should fix all the dorks who have ASCII or Unicode where the
    //  heap header is supposed to be.
    //

    try {
        if ((!(BusyBlock->Flags & HEAP_ENTRY_BUSY)) ||
            (((ULONG_PTR)BaseAddress & 0x7) != 0) ||
            (BusyBlock->SegmentIndex >= HEAP_MAXIMUM_SEGMENTS)) {

            //
            //  Not a busy block, or it's not aligned or the segment is
            //  to big, meaning it's corrupt
            //

            ASSERTMSG("Bad pointer in RtlFreeHeap()\n", 0);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {

        ASSERTMSG("Bad pointer in RtlFreeHeap()\n", 0);
    }
#endif // DBG

    //
    //  If there is a lookaside list and the block is not a big allocation
    //  and the index is for a dedicated list then free the block to the
    //  lookaside list.  We'll actually capture
    //  the lookaside pointer from the heap and only use the captured pointer.
    //  This will take care of the condition where a walk or lock heap can
    //  cause us to check for a non null pointer and then have it become null
    //  when we read it again.  If it is non null to start with then even if
    //  the user walks or locks the heap via another thread the pointer to
    //  still valid here so we can still try and do a lookaside list push
    //

#ifndef NTOS_KERNEL_RUNTIME

    {
        PHEAP_LOOKASIDE Lookaside = (PHEAP_LOOKASIDE)Heap->Lookaside;

        if ((Lookaside != NULL) &&
            (Heap->LookasideLockCount == 0) &&
            (!(BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC)) &&
            ((FreeSize = BusyBlock->Size) < HEAP_MAXIMUM_FREELISTS)) {

            if (RtlpFreeToHeapLookaside( &Lookaside[FreeSize], BaseAddress)) {

                return TRUE;
            }
        }
    }

#endif // NTOS_KERNEL_RUNTIME

    try {

        //
        //  Check if we need to lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        //
        //  Check if this is not a virtual block allocation meaning
        //  that we it is part of the heap free list structure and not
        //  one huge allocation that we got from vm
        //

        if (!(BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC)) {

            //
            //  This block is not a big allocation so we need to
            //  to get its size, and coalesce the blocks note that
            //  the user mode heap does this conditionally on a heap
            //  flag.  The coalesce function returns the newly formed
            //  free block and the new size.
            //

            FreeSize = BusyBlock->Size;

    #ifdef NTOS_KERNEL_RUNTIME

            BusyBlock = (PHEAP_ENTRY)RtlpCoalesceFreeBlocks( Heap,
                                                             (PHEAP_FREE_ENTRY)BusyBlock,
                                                             &FreeSize,
                                                             FALSE );

    #else // NTOS_KERNEL_RUNTIME

            if (!(Heap->Flags & HEAP_DISABLE_COALESCE_ON_FREE)) {

                BusyBlock = (PHEAP_ENTRY)RtlpCoalesceFreeBlocks( Heap,
                                                                 (PHEAP_FREE_ENTRY)BusyBlock,
                                                                 &FreeSize,
                                                                 FALSE );
            }

    #endif // NTOS_KERNEL_RUNTIME

            //
            //  Check for a small allocation that can go on a freelist
            //  first, these should never trigger a decommit.
            //

            HEAPASSERT(HEAP_MAXIMUM_FREELISTS < Heap->DeCommitFreeBlockThreshold);

            //
            //  If the allocation fits on a free list then insert it on
            //  the appropriate free list.  If the block is not the last
            //  entry then make sure that the next block knows our correct
            //  size, and update the heap free space counter.
            //

            if (FreeSize < HEAP_MAXIMUM_FREELISTS) {

                RtlpFastInsertDedicatedFreeBlockDirect( Heap,
                                                        (PHEAP_FREE_ENTRY)BusyBlock,
                                                        (USHORT)FreeSize );

                if (!(BusyBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                    HEAPASSERT((BusyBlock + FreeSize)->PreviousSize == (USHORT)FreeSize);
                }

                Heap->TotalFreeSize += FreeSize;

            //
            //  Otherwise the block is to big for one of the dedicated free list so
            //  see if the free size is under the decommit threshold by itself
            //  or the total free in the heap is under the decomit threshold then
            //  we'll put this into a free list
            //

            } else if ((FreeSize < Heap->DeCommitFreeBlockThreshold) ||
                       ((Heap->TotalFreeSize + FreeSize) < Heap->DeCommitTotalFreeThreshold)) {

                //
                //  Check if the block can go into the [0] index free list, and if
                //  so then do the insert and make sure the following block is
                //  needed knows our correct size, and update the heaps free space
                //  counter
                //

                if (FreeSize <= (ULONG)HEAP_MAXIMUM_BLOCK_SIZE) {

                    RtlpFastInsertNonDedicatedFreeBlockDirect( Heap,
                                                               (PHEAP_FREE_ENTRY)BusyBlock,
                                                               (USHORT)FreeSize );

                    if (!(BusyBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                        HEAPASSERT((BusyBlock + FreeSize)->PreviousSize == (USHORT)FreeSize);
                    }

                    Heap->TotalFreeSize += FreeSize;

                } else {

                    //
                    //  The block is too big to go on a free list in its
                    //  entirety but we don't want to decommit anything so
                    //  simply call a worker routine to hack up the block
                    //  into pieces that will fit on the free lists.
                    //

                    RtlpInsertFreeBlock( Heap, (PHEAP_FREE_ENTRY)BusyBlock, FreeSize );
                }

            //
            //  Otherwise the block is to big for any lists and we should decommit
            //  the block
            //

            } else {

                RtlpDeCommitFreeBlock( Heap, (PHEAP_FREE_ENTRY)BusyBlock, FreeSize );
            }

        } else {

            //
            //  This is a big virtual block allocation.  To free it we only have to
            //  remove it from the heaps list of virtual allocated blocks, unlock
            //  the heap, and return the block to vm
            //

            PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

            VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

            RemoveEntryList( &VirtualAllocBlock->Entry );

            //
            //  Release lock here as there is no reason to hold it across
            //  the system call.
            //

            if (LockAcquired) {

                RtlReleaseLockRoutine( Heap->LockVariable );
                LockAcquired = FALSE;
            }

            FreeSize = 0;

            Status = ZwFreeVirtualMemory( (PVOID *)&VirtualAllocBlock,
                                          &FreeSize,
                                          MEM_RELEASE );


            //
            //  Check if we had trouble freeing the block back to vm
            //  and return an error if necessary
            //

            if (!NT_SUCCESS( Status )) {

                SET_LAST_STATUS( Status );

                ReturnValue = FALSE;
            }
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  The block was freed successfully so return success to our
    //  caller
    //

    return ReturnValue;
}


BOOLEAN
RtlFreeHeapSlowly (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

    This routine returns a previously allocated block back to its heap.
    It is the slower version of Rtl Free Heap and does more checking and
    tagging control.

Arguments:

    HeapHandle - Supplies a pointer to the owning heap structure

    Flags - Specifies the set of flags to use in the deallocation

    BaseAddress - Supplies a pointer to the block being freed

Return Value:

    BOOLEAN - TRUE if the block was properly freed and FALSE otherwise

--*/

{
    NTSTATUS Status;
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    SIZE_T FreeSize;
    BOOLEAN Result;
    BOOLEAN LockAcquired = FALSE;

#ifndef NTOS_KERNEL_RUNTIME

    USHORT TagIndex;

#endif // NTOS_KERNEL_RUNTIME

    RTL_PAGED_CODE();

    //
    //  Note that Flags has already been OR'd with Heap->ForceFlags.
    //

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case see if we should be calling the debug version to
    //  free the heap
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugFreeHeap( HeapHandle, Flags, BaseAddress );
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  Until we figure out otherwise we'll assume that this call will fail
    //

    Result = FALSE;

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        try {

            //
            //  Backup to get a pointer to the start of the block
            //

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            //
            //  Protect ourselves from idiots by refusing to free blocks
            //  that do not have the busy bit set.
            //
            //  Also refuse to free blocks that are not eight-byte aligned.
            //  The specific idiot in this case is Office95, which likes
            //  to free a random pointer when you start Word95 from a desktop
            //  shortcut.
            //
            //  As further insurance against idiots, check the segment index
            //  to make sure it is less than HEAP_MAXIMUM_SEGMENTS (16). This
            //  should fix all the dorks who have ASCII or Unicode where the
            //  heap header is supposed to be.
            //
            //  Note that this test is just opposite from the test used in
            //  Rtl Free Heap
            //

            if ((BusyBlock->Flags & HEAP_ENTRY_BUSY) &&
                (((ULONG_PTR)BaseAddress & 0x7) == 0) &&
                (BusyBlock->SegmentIndex < HEAP_MAXIMUM_SEGMENTS)) {

                //
                //  Check if this is a virtual block allocation
                //

                if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

                    //
                    //  This is a big virtual block allocation.  To free it
                    //  we only have to remove it from the heaps list of
                    //  virtual allocated blocks, unlock the heap, and return
                    //  the block to vm
                    //

                    VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

                    RemoveEntryList( &VirtualAllocBlock->Entry );

    #ifndef NTOS_KERNEL_RUNTIME

                    //
                    //  In the non kernel case see if we need to free the tag
                    //

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        RtlpUpdateTagEntry( Heap,
                                            VirtualAllocBlock->ExtraStuff.TagIndex,
                                            VirtualAllocBlock->CommitSize >> HEAP_GRANULARITY_SHIFT,
                                            0,
                                            VirtualFreeAction );
                    }

    #endif // NTOS_KERNEL_RUNTIME

                    FreeSize = 0;

                    Status = ZwFreeVirtualMemory( (PVOID *)&VirtualAllocBlock,
                                                  &FreeSize,
                                                  MEM_RELEASE );

                    //
                    //  Check if everything worked okay, if we had trouble freeing
                    //  the block back to vm return an error if necessary,
                    //

                    if (NT_SUCCESS( Status )) {

                        Result = TRUE;

                    } else {

                        SET_LAST_STATUS( Status );
                    }

                } else {

                    //
                    //  This block is not a big allocation so we need to
                    //  to get its size, and coalesce the blocks note that
                    //  the user mode heap does this conditionally on a heap
                    //  flag.  The coalesce function returns the newly formed
                    //  free block and the new size.
                    //

    #ifndef NTOS_KERNEL_RUNTIME

                    //
                    //  First in the non kernel case remove any tagging we might
                    //  have been using.  Note that the will either be in
                    //  the heap header, or in the extra block if present
                    //

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                            ExtraStuff = (PHEAP_ENTRY_EXTRA)(BusyBlock + BusyBlock->Size - 1);

                            TagIndex = RtlpUpdateTagEntry( Heap,
                                                           ExtraStuff->TagIndex,
                                                           BusyBlock->Size,
                                                           0,
                                                           FreeAction );

                        } else {

                            TagIndex = RtlpUpdateTagEntry( Heap,
                                                           BusyBlock->SmallTagIndex,
                                                           BusyBlock->Size,
                                                           0,
                                                           FreeAction );
                        }

                    } else {

                        TagIndex = 0;
                    }

    #endif // NTOS_KERNEL_RUNTIME

                    //
                    //  This is the size of the block we are freeing
                    //

                    FreeSize = BusyBlock->Size;

    #ifndef NTOS_KERNEL_RUNTIME

                    //
                    //  In the non kernel case see if we should coalesce on free
                    //

                    if (!(Heap->Flags & HEAP_DISABLE_COALESCE_ON_FREE)) {

    #endif // NTOS_KERNEL_RUNTIME

                        //
                        //  In kernel case and in the tested user mode case we
                        //  now coalesce free blocks
                        //

                        BusyBlock = (PHEAP_ENTRY)RtlpCoalesceFreeBlocks( Heap, (PHEAP_FREE_ENTRY)BusyBlock, &FreeSize, FALSE );

    #ifndef NTOS_KERNEL_RUNTIME

                    }

    #endif // NTOS_KERNEL_RUNTIME

                    //
                    //  If the block should not be decommit then try and put it
                    //  on a free list
                    //

                    if ((FreeSize < Heap->DeCommitFreeBlockThreshold) ||
                        ((Heap->TotalFreeSize + FreeSize) < Heap->DeCommitTotalFreeThreshold)) {

                        //
                        //  Check if the block can fit on one of the dedicated free
                        //  lists
                        //

                        if (FreeSize <= (ULONG)HEAP_MAXIMUM_BLOCK_SIZE) {

                            //
                            //  It can fit on a dedicated free list so insert it on
                            //

                            RtlpInsertFreeBlockDirect( Heap, (PHEAP_FREE_ENTRY)BusyBlock, (USHORT)FreeSize );

                            //
                            //  If there is a following entry then make sure the
                            //  sizes agree
                            //

                            if (!(BusyBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                                HEAPASSERT((BusyBlock + FreeSize)->PreviousSize == (USHORT)FreeSize);
                            }

                            //
                            //  Update the heap with the amount of free space
                            //  available
                            //

                            Heap->TotalFreeSize += FreeSize;

                        } else {

                            //
                            //  The block goes on the non dedicated free list
                            //

                            RtlpInsertFreeBlock( Heap, (PHEAP_FREE_ENTRY)BusyBlock, FreeSize );
                        }

    #ifndef NTOS_KERNEL_RUNTIME

                        //
                        //  In the non kernel case see if the there was tag and if
                        //  so then update the entry to show that it's been freed
                        //

                        if (TagIndex != 0) {

                            PHEAP_FREE_ENTRY_EXTRA FreeExtra;

                            BusyBlock->Flags |= HEAP_ENTRY_EXTRA_PRESENT;

                            FreeExtra = (PHEAP_FREE_ENTRY_EXTRA)(BusyBlock + BusyBlock->Size) - 1;

                            FreeExtra->TagIndex = TagIndex;
                            FreeExtra->FreeBackTraceIndex = 0;

    #if i386 && DBG

                            //
                            //  In the x86 case we can also capture the stack
                            //  backtrace
                            //

                            if (Heap->Flags & HEAP_CAPTURE_STACK_BACKTRACES) {

                                FreeExtra->FreeBackTraceIndex = (USHORT)RtlLogStackBackTrace();
                            }

    #endif // i386 && DBG

                        }

    #endif // NTOS_KERNEL_RUNTIME

                    } else {

                        //
                        //  Otherwise the block is big enough to decommit so have a
                        //  worker routine to do the decommit
                        //

                        RtlpDeCommitFreeBlock( Heap, (PHEAP_FREE_ENTRY)BusyBlock, FreeSize );
                    }

                    //
                    //  And say the free worked fine
                    //

                    Result = TRUE;
                }

            } else {

                //
                //  Not a busy block, or it's not aligned or the segment is
                //  to big, meaning it's corrupt
                //

                SET_LAST_STATUS( STATUS_INVALID_PARAMETER );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            Result = FALSE;
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return Result;
}


SIZE_T
RtlSizeHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

    This routine returns the size, in bytes, of the indicated block
    of heap storage.  The size only includes the number of bytes the
    original caller used to allocate the block and not any unused
    bytes at the end of the block.

Arguments:

    HeapHandle - Supplies a pointer to the heap that owns the block
        being queried

    Flags - Supplies a set of flags used to allocate the block

    BaseAddress - Supplies the address of the block being queried

Return Value:

    SIZE_T - returns the size, in bytes, of the queried block, or -1
        if the block is not in use.

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    SIZE_T BusySize;

    //
    //  Compliment the input flags with those enforced by the heap
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if this is the nonkernel debug version of heap
    //

#ifndef NTOS_KERNEL_RUNTIME

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugSizeHeap( HeapHandle, Flags, BaseAddress );
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  No lock is required since nothing is modified and nothing
    //  outside the busy block is read.  Backup to get a pointer
    //  to the heap entry
    //

    BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

    //
    //  If the block is not in use then the answer is -1 and
    //  we'll set the error status for the user mode thread
    //

    if (!(BusyBlock->Flags & HEAP_ENTRY_BUSY)) {

        BusySize = -1;

        SET_LAST_STATUS( STATUS_INVALID_PARAMETER );

    //
    //  Otherwise if the block is from our large allocation then
    //  we'll get the result from that routine
    //

    } else if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

        BusySize = RtlpGetSizeOfBigBlock( BusyBlock );

    //
    //  Otherwise the block must be one that we can handle so
    //  calculate its block size and then subtract what's not being
    //  used by the caller.
    //
    //  **** this seems to include the heap entry header in its
    //  **** calculation.  Is that what we really want?
    //

    } else {

        BusySize = (BusyBlock->Size << HEAP_GRANULARITY_SHIFT) -
                   BusyBlock->UnusedBytes;
    }

    //
    //  And return to our caller
    //

    return BusySize;
}


NTSTATUS
RtlZeroHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    )

/*++

Routine Description:

    This routine zero's (or fills) in all the free blocks in a heap.
    It does not touch big allocations.

Arguments:

    HeapHandle - Supplies a pointer to the heap being zeroed

    Flags - Supplies a set of heap flags to compliment those already
        set in the heap

Return Value:

    NTSTATUS - An appropriate status code

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    NTSTATUS Status;
    BOOLEAN LockAcquired = FALSE;
    PHEAP_SEGMENT Segment;
    ULONG SegmentIndex;
    PHEAP_ENTRY CurrentBlock;
    PHEAP_FREE_ENTRY FreeBlock;
    SIZE_T Size;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange;

    RTL_PAGED_CODE();

    //
    //  Compliment the input flags with those enforced by the heap
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if this is the nonkernel debug version of heap
    //

#ifndef NTOS_KERNEL_RUNTIME

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugZeroHeap( HeapHandle, Flags );
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  Unless something happens otherwise we'll assume that we'll
    //  be successful
    //

    Status = STATUS_SUCCESS;

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        try {

            //
            //  Zero fill all the free blocks in all the segements
            //

            for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

                Segment = Heap->Segments[ SegmentIndex ];

                if (!Segment) {

                    continue;
                }

                UnCommittedRange = Segment->UnCommittedRanges;
                CurrentBlock = Segment->FirstEntry;

                //
                //  With the current segment we'll zoom through the
                //  blocks until we reach the end
                //

                while (CurrentBlock < Segment->LastValidEntry) {

                    Size = CurrentBlock->Size << HEAP_GRANULARITY_SHIFT;

                    //
                    //  If the block is not in use then we'll either zero
                    //  it or fill it.
                    //

                    if (!(CurrentBlock->Flags & HEAP_ENTRY_BUSY)) {

                        FreeBlock = (PHEAP_FREE_ENTRY)CurrentBlock;

#if DBG
                        if ((Heap->Flags & HEAP_FREE_CHECKING_ENABLED) &&
                            (CurrentBlock->Flags & HEAP_ENTRY_FILL_PATTERN)) {

                            RtlFillMemoryUlong( FreeBlock + 1,
                                                Size - sizeof( *FreeBlock ),
                                                FREE_HEAP_FILL );

                        } else
#endif // DBG
                                {

                            RtlFillMemoryUlong( FreeBlock + 1,
                                                Size - sizeof( *FreeBlock ),
                                                0 );
                        }
                    }

                    //
                    //  If the following entry is uncommited then we need to
                    //  skip over it.  This code strongly implies that the
                    //  uncommitted range list is in perfect sync with the
                    //  blocks in the segement
                    //

                    if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                        CurrentBlock += CurrentBlock->Size;

                        //
                        //  Check if the we've reached the end of the segment
                        //  and should just break out of the while loop
                        //
                        //
                        //  **** "break;" would probably be more clear here
                        //

                        if (UnCommittedRange == NULL) {

                            CurrentBlock = Segment->LastValidEntry;

                        //
                        //  Otherwise skip over the uncommitted range
                        //

                        } else {

                            CurrentBlock = (PHEAP_ENTRY)
                                ((PCHAR)UnCommittedRange->Address + UnCommittedRange->Size);

                            UnCommittedRange = UnCommittedRange->Next;
                        }

                    //
                    //  Otherwise the next block exists so advance to it
                    //

                    } else {

                        CurrentBlock += CurrentBlock->Size;
                    }
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Status;
}


//
//  Local Support Routine
//

PHEAP_UNCOMMMTTED_RANGE
RtlpCreateUnCommittedRange (
    IN PHEAP_SEGMENT Segment
    )

/*++

Routine Description:

    This routine add a new uncommitted range structure to the specified heap
    segment.  This routine works by essentially doing a pop of the stack of
    unused uncommitted range structures located off the heap structure.  If
    the stack is empty then we'll create some more before doing the pop.

Arguments:

    Segment - Supplies the heap segment being modified

Return Value:

    PHEAP_UNCOMMITTED_RANGE - returns a pointer to the newly created
        uncommitted range structure

--*/

{
    NTSTATUS Status;
    PVOID FirstEntry, LastEntry;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange, *pp;
    SIZE_T ReserveSize, CommitSize;
    PHEAP_UCR_SEGMENT UCRSegment;

    RTL_PAGED_CODE();

    //
    //  Get a pointer to the unused uncommitted range structures for
    //  the specified heap
    //

    pp = &Segment->Heap->UnusedUnCommittedRanges;

    //
    //  If the list is null then we need to allocate some more to
    //  put on the list
    //

    if (*pp == NULL) {

        //
        //  Get the next uncommitted range segment from the heap
        //

        UCRSegment = Segment->Heap->UCRSegments;

        //
        //  If there are no more uncommitted range segments or
        //  the segemtns commited and reserved sizes are equal (meaning
        //  it's all used up) then we need to allocate another uncommitted
        //  range segment
        //

        if ((UCRSegment == NULL) ||
            (UCRSegment->CommittedSize == UCRSegment->ReservedSize)) {

            //
            //  We'll reserve 16 pages of memory and commit at this
            //  time one page of it.
            //

            ReserveSize = PAGE_SIZE * 16;
            UCRSegment = NULL;

            Status = ZwAllocateVirtualMemory( &UCRSegment,
                                              0,
                                              &ReserveSize,
                                              MEM_RESERVE,
                                              PAGE_READWRITE );

            if (!NT_SUCCESS( Status )) {

                return NULL;
            }

            CommitSize = PAGE_SIZE;

            Status = ZwAllocateVirtualMemory( &UCRSegment,
                                              0,
                                              &CommitSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE );

            if (!NT_SUCCESS( Status )) {

                ZwFreeVirtualMemory( &UCRSegment,
                                     &ReserveSize,
                                     MEM_RELEASE );

                return NULL;
            }

            //
            //  Add this new segment to the front of the UCR segments
            //

            UCRSegment->Next = Segment->Heap->UCRSegments;
            Segment->Heap->UCRSegments = UCRSegment;

            //
            //  Set the segments commit and reserve size
            //

            UCRSegment->ReservedSize = ReserveSize;
            UCRSegment->CommittedSize = CommitSize;

            //
            //  Point to the first free spot in the segment
            //

            FirstEntry = (PCHAR)(UCRSegment + 1);

        } else {

            //
            //  We have an existing UCR segment with available space
            //  So now try and commit another PAGE_SIZE bytes.  When we are done
            //  FirstEntry will point to the newly committed space
            //

            CommitSize = PAGE_SIZE;
            FirstEntry = (PCHAR)UCRSegment + UCRSegment->CommittedSize;

            Status = ZwAllocateVirtualMemory( &FirstEntry,
                                              0,
                                              &CommitSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE );

            if (!NT_SUCCESS( Status )) {

                return NULL;
            }

            //
            //  And update the amount committed in the segment
            //

            UCRSegment->CommittedSize += CommitSize;
        }

        //
        //  At this point UCR segment exists and First Entry points to the
        //  start of the available committed space.  We'll make Last Entry
        //  point to the end of the committed space
        //

        LastEntry = (PCHAR)UCRSegment + UCRSegment->CommittedSize;

        //
        //  Now the task is to push all of this new space unto the
        //  unused uncommitted range list off the heap, then we can
        //  do a regular pop
        //

        UnCommittedRange = (PHEAP_UNCOMMMTTED_RANGE)FirstEntry;

        pp = &Segment->Heap->UnusedUnCommittedRanges;

        while ((PCHAR)UnCommittedRange < (PCHAR)LastEntry) {

            *pp = UnCommittedRange;
            pp = &UnCommittedRange->Next;
            UnCommittedRange += 1;
        }

        //
        //  Null terminate the list
        //

        *pp = NULL;

        //
        //  And have Pp point the new top of the list
        //

        pp = &Segment->Heap->UnusedUnCommittedRanges;
    }

    //
    //  At this point the Pp points to a non empty list of unused uncommitted
    //  range structures.  So we pop the list and return the top to our caller
    //

    UnCommittedRange = *pp;
    *pp = UnCommittedRange->Next;

    return UnCommittedRange;
}


//
//  Local Support Routine
//

VOID
RtlpDestroyUnCommittedRange (
    IN PHEAP_SEGMENT Segment,
    IN PHEAP_UNCOMMMTTED_RANGE UnCommittedRange
    )

/*++

Routine Description:

    This routine returns an uncommitted range structure back to the unused
    uncommitted range list

Arguments:

    Segment - Supplies any segment in the heap being modified.  Most likely but
        not necessarily the segment containing the uncommitted range structure

    UnCommittedRange - Supplies a pointer to the uncommitted range structure
        being decommissioned.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    //
    //  This routine simply does a "push" of the uncommitted range structure
    //  onto the heap's stack of unused uncommitted ranges
    //

    UnCommittedRange->Next = Segment->Heap->UnusedUnCommittedRanges;
    Segment->Heap->UnusedUnCommittedRanges = UnCommittedRange;

    //
    //  For safety sake we'll also zero out the fields in the decommissioned
    //  structure
    //

    UnCommittedRange->Address = 0;
    UnCommittedRange->Size = 0;

    //
    //  And return to our caller
    //

    return;
}


//
//  Local Support Routine
//

VOID
RtlpInsertUnCommittedPages (
    IN PHEAP_SEGMENT Segment,
    IN ULONG_PTR Address,
    IN SIZE_T Size
    )

/*++

Routine Description:

    This routine adds the specified range to the list of uncommitted pages
    in the segment.  When done the information will hang off the segments
    uncommitted ranges list.

Arguments:

    Segment - Supplies a segment whose uncommitted range is being modified

    Address - Supplies the base (start) address for the uncommitted range

    Size - Supplies the size, in bytes, of the uncommitted range

Return Value:

    None.

--*/

{
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange, *pp;

    RTL_PAGED_CODE();

    //
    //  Get a pointer to the front of the segments uncommitted range list
    //  The list is sorted by ascending address
    //

    pp = &Segment->UnCommittedRanges;

    //
    //  While we haven't reached the end of the list we'll zoom through
    //  trying to find a fit
    //

    while (UnCommittedRange = *pp) {

        //
        //  If address we want is less than what we're pointing at then
        //  we've found where this new entry goes
        //

        if (UnCommittedRange->Address > Address) {

            //
            //  If the new block matches right up to the existing block
            //  then we can simply backup the existing block and add
            //  to its size
            //

            if ((Address + Size) == UnCommittedRange->Address) {

                UnCommittedRange->Address = Address;
                UnCommittedRange->Size += Size;

                //
                //  Check if we need to update our notion of what the
                //  largest uncommitted range is
                //

                if (UnCommittedRange->Size > Segment->LargestUnCommittedRange) {

                    Segment->LargestUnCommittedRange = UnCommittedRange->Size;
                }

                //
                //  And return to our caller
                //

                return;
            }

            //
            //  Pp is the address of the block right before us, and *Pp is the
            //  address of the block right after us.  So now fall out to where
            //  the insertion takes place.
            //

            break;

        //
        //  Otherwise if this existing block stops right where the new block
        //  starts then we get to modify this entry.
        //

        } else if ((UnCommittedRange->Address + UnCommittedRange->Size) == Address) {

            //
            //  Remember the starting address and compute the new larger size
            //

            Address = UnCommittedRange->Address;
            Size += UnCommittedRange->Size;

            //
            //  Remove this entry from the list and then return it to the
            //  unused uncommitted list
            //

            *pp = UnCommittedRange->Next;

            RtlpDestroyUnCommittedRange( Segment, UnCommittedRange );

            //
            //  Modify the segemnt counters and largest size state.  The next
            //  time through the loop should hit the first case above where
            //  we'll either merge with a list following us or add a new
            //  entry
            //

            Segment->NumberOfUnCommittedRanges -= 1;

            if (Size > Segment->LargestUnCommittedRange) {

                Segment->LargestUnCommittedRange = Size;
            }

        //
        //  Otherwise we'll continue search down the list
        //

        } else {

            pp = &UnCommittedRange->Next;
        }
    }

    //
    //  If we reach this point that means we've either fallen off the end of the
    //  list, or the list is empty, or we've located the spot where a new uncommitted
    //  range structure belongs.  So allocate a new uncommitted range structure,
    //  and make sure we got one.
    //
    //  Pp is the address of the block right before us and *Pp is the address of the
    //  block right after us
    //

    UnCommittedRange = RtlpCreateUnCommittedRange( Segment );

    if (UnCommittedRange == NULL) {

        HeapDebugPrint(( "Abandoning uncommitted range (%x for %x)\n", Address, Size ));
        // HeapDebugBreak( NULL );

        return;
    }

    //
    //  Fill in the new uncommitted range structure
    //

    UnCommittedRange->Address = Address;
    UnCommittedRange->Size = Size;

    //
    //  Insert it in the list for the segment
    //

    UnCommittedRange->Next = *pp;
    *pp = UnCommittedRange;

    //
    //  Update the segment counters and notion of the largest uncommitted range
    //

    Segment->NumberOfUnCommittedRanges += 1;

    if (Size >= Segment->LargestUnCommittedRange) {

        Segment->LargestUnCommittedRange = Size;
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Declared in heappriv.h
//

PHEAP_FREE_ENTRY
RtlpFindAndCommitPages (
    IN PHEAP Heap,
    IN PHEAP_SEGMENT Segment,
    IN OUT PSIZE_T Size,
    IN PVOID AddressWanted OPTIONAL
    )

/*++

Routine Description:

    This function searches the supplied segment for an uncommitted range that
    satisfies the specified size.  It commits the range and returns a heap entry
    for the range.

Arguments:

    Heap - Supplies the heap being maniuplated

    Segment - Supplies the segment being searched

    Size - Supplies the size of what we need to look for, on return it contains
        the size of what we're just found and committed.

    AddressWanted - Optionally gives an address where we would like the pages
        based.  If supplied the entry must start at this address

Return Value:

    PHEAP_FREE_ENTRY - Returns a pointer to the newly committed range that
        satisfies the given size requirement, or NULL if we could not find
        something large enough and/or based at the address wanted.

--*/

{
    NTSTATUS Status;
    PHEAP_ENTRY FirstEntry, LastEntry, PreviousLastEntry;
    PHEAP_UNCOMMMTTED_RANGE PreviousUnCommittedRange, UnCommittedRange, *pp;
    ULONG_PTR Address;
    SIZE_T Length;

    RTL_PAGED_CODE();

    //
    //  What the outer loop does is cycle through the uncommited ranges
    //  stored in in the specified segment
    //

    PreviousUnCommittedRange = NULL;
    pp = &Segment->UnCommittedRanges;

    while (UnCommittedRange = *pp) {

        //
        //  Check for the best of worlds, where the size of this current
        //  uncommitted range satisfies our size request and either the user
        //  didn't specify an address or the address match
        //

        if ((UnCommittedRange->Size >= *Size) &&
            (!ARGUMENT_PRESENT( AddressWanted ) || (UnCommittedRange->Address == (ULONG_PTR)AddressWanted ))) {

            //
            //  Calculate an address
            //

            Address = UnCommittedRange->Address;

            //
            //  Commit the memory.  If the heap doesn't have a commit
            //  routine then use the default mm supplied routine.
            //

            if (Heap->CommitRoutine != NULL) {

                Status = (Heap->CommitRoutine)( Heap,
                                                (PVOID *)&Address,
                                                Size );

            } else {

                Status = ZwAllocateVirtualMemory( (PVOID *)&Address,
                                                  0,
                                                  Size,
                                                  MEM_COMMIT,
                                                  PAGE_READWRITE );

            }

            if (!NT_SUCCESS( Status )) {

                return NULL;
            }

            //
            //  At this point we have some committed memory, with Address and Size
            //  giving us the necessary details
            //
            //  Update the number of uncommitted pages in the segment and if necessary
            //  mark down the largest uncommitted range
            //

            Segment->NumberOfUnCommittedPages -= (ULONG) (*Size / PAGE_SIZE);

            if (Segment->LargestUnCommittedRange == UnCommittedRange->Size) {

                Segment->LargestUnCommittedRange = 0;
            }

            //
            //  First entry is the start of the newly committed range
            //

            FirstEntry = (PHEAP_ENTRY)Address;

            //
            //  We want last entry to point to the last real entry before
            //  this newly committed spot.  To do this we start by
            //  setting last entry to either the first entry for the
            //  segment or (if we can do better), to right after the last
            //  uncommitted range we examined.  Either way it points to
            //  some committed range
            //

            if ((Segment->LastEntryInSegment->Flags & HEAP_ENTRY_LAST_ENTRY) &&
                (ULONG_PTR)(Segment->LastEntryInSegment + Segment->LastEntryInSegment->Size) == UnCommittedRange->Address) {

                LastEntry = Segment->LastEntryInSegment;

            } else {

                if (PreviousUnCommittedRange == NULL) {

                    LastEntry = Segment->FirstEntry;

                } else {

                    LastEntry = (PHEAP_ENTRY)(PreviousUnCommittedRange->Address +
                                              PreviousUnCommittedRange->Size);
                }

                //
                //  Now we zoom through the entries until we find the one
                //  marked last
                //

                while (!(LastEntry->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                    PreviousLastEntry = LastEntry;
                    LastEntry += LastEntry->Size;

                    if (((PCHAR)LastEntry >= (PCHAR)Segment->LastValidEntry) || (LastEntry->Size == 0)) {

                        //
                        //  Check for the situation where the last entry in the
                        //  segment isn't marked as a last entry but does put
                        //  us right where the have a new committed range
                        //

                        if (LastEntry == (PHEAP_ENTRY)Address) {

                            LastEntry = PreviousLastEntry;

                            break;
                        }

                        HeapDebugPrint(( "Heap missing last entry in committed range near %x\n", PreviousLastEntry ));
                        HeapDebugBreak( PreviousLastEntry );

                        return NULL;
                    }
                }
            }

            //
            //  Turn off the last bit on this entry because what's following
            //  is no longer uncommitted
            //

            LastEntry->Flags &= ~HEAP_ENTRY_LAST_ENTRY;

            //
            //  Shrink the uncommited range by the size we've committed
            //

            UnCommittedRange->Address += *Size;
            UnCommittedRange->Size -= *Size;

            //
            //  Now if the size is zero then we've committed everything that there
            //  was in the range.  Otherwise make sure the first entry of what
            //  we've just committed knows that an uncommitted range follows.
            //

            if (UnCommittedRange->Size == 0) {

                //
                //  This uncommitted range is about to vanish.  Base on if the
                //  range is the last one in the segemnt then we know how to
                //  mark the committed range as being last or not.
                //

                if (UnCommittedRange->Address == (ULONG_PTR)Segment->LastValidEntry) {

                    FirstEntry->Flags = HEAP_ENTRY_LAST_ENTRY;

                    Segment->LastEntryInSegment = FirstEntry;

                } else {

                    FirstEntry->Flags = 0;

                    Segment->LastEntryInSegment = Segment->FirstEntry;
                }

                //
                //  Remove this zero sized range from the uncommitted range
                //  list, and update the segment counters
                //

                *pp = UnCommittedRange->Next;

                RtlpDestroyUnCommittedRange( Segment, UnCommittedRange );

                Segment->NumberOfUnCommittedRanges -= 1;

            } else {

                //
                //  Otherwise the range is not empty so we know what we committed
                //  is immediately followed by an uncommitted range
                //

                FirstEntry->Flags = HEAP_ENTRY_LAST_ENTRY;

                Segment->LastEntryInSegment = FirstEntry;
            }

            //
            //  Update the fields in the first entry, and optional
            //  following entry.
            //

            FirstEntry->SegmentIndex = LastEntry->SegmentIndex;
            FirstEntry->Size = (USHORT)(*Size >> HEAP_GRANULARITY_SHIFT);
            FirstEntry->PreviousSize = LastEntry->Size;

            if (!(FirstEntry->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                (FirstEntry + FirstEntry->Size)->PreviousSize = FirstEntry->Size;
            }

            //
            //  Now if we adjusted the largest uncommitted range to zero then
            //  we need to go back and find the largest uncommitted range
            //  To do that we simply zoom down the uncommitted range list
            //  remembering the largest one
            //

            if (Segment->LargestUnCommittedRange == 0) {

                UnCommittedRange = Segment->UnCommittedRanges;

                while (UnCommittedRange != NULL) {

                    if (UnCommittedRange->Size >= Segment->LargestUnCommittedRange) {

                        Segment->LargestUnCommittedRange = UnCommittedRange->Size;
                    }

                    UnCommittedRange = UnCommittedRange->Next;
                }
            }

            //
            //  And return the heap entry to our caller
            //

            return (PHEAP_FREE_ENTRY)FirstEntry;

        } else {

            //
            //  Otherwise the current uncommited range is too small or
            //  doesn't have the right address so go to the next uncommitted
            //  range entry
            //

            PreviousUnCommittedRange = UnCommittedRange;
            pp = &UnCommittedRange->Next;
        }
    }

    //
    //  At this point we did not find an uncommitted range entry that satisfied
    //  our requirements either because of size and/or address.  So return null
    //  to tell the user we didn't find anything.
    //

    return NULL;
}


//
//  Declared in heappriv.h
//

BOOLEAN
RtlpInitializeHeapSegment (
    IN PHEAP Heap,
    IN PHEAP_SEGMENT Segment,
    IN UCHAR SegmentIndex,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN PVOID UnCommittedAddress,
    IN PVOID CommitLimitAddress
    )

/*++

Routine Description:

    This routines initializes the internal structures for a heap segment.
    The caller supplies the heap and the memory for the segment being
    initialized

Arguments:

    Heap - Supplies the address of the heap owning this segment

    Segment - Supplies a pointer to the segment being initialized

    SegmentIndex - Supplies the segement index within the heap that this
        new segment is being assigned

    Flags - Supplies flags controlling the initialization of the segment
        Valid flags are:

            HEAP_SEGMENT_USER_ALLOCATED

    BaseAddress - Supplies the base address for the segment

    UnCommittedAddress - Supplies the address where the uncommited range starts

    CommitLimitAddress - Supplies the top address available to the segment

Return Value:

    BOOLEAN - TRUE if the initialization is successful and FALSE otherwise

--*/

{
    NTSTATUS Status;
    PHEAP_ENTRY FirstEntry;
    USHORT PreviousSize, Size;
    ULONG NumberOfPages;
    ULONG NumberOfCommittedPages;
    ULONG NumberOfUnCommittedPages;
    SIZE_T CommitSize;

    RTL_PAGED_CODE();

    //
    //  Compute the total number of pages possible in this segment
    //

    NumberOfPages = (ULONG) (((PCHAR)CommitLimitAddress - (PCHAR)BaseAddress) / PAGE_SIZE);

    //
    //  First entry points to the first possible segment entry after
    //  the segment header
    //

    FirstEntry = (PHEAP_ENTRY)ROUND_UP_TO_POWER2( Segment + 1,
                                                  HEAP_GRANULARITY );

    //
    //  Now if the heap is equal to the base address for the segment which
    //  it the case for the segment zero then the previous size is the
    //  heap header.  Otherwise there isn't a previous entry
    //

    if ((PVOID)Heap == BaseAddress) {

        PreviousSize = Heap->Entry.Size;

    } else {

        PreviousSize = 0;
    }

    //
    //  Compute the index size of the segement header
    //

    Size = (USHORT)(((PCHAR)FirstEntry - (PCHAR)Segment) >> HEAP_GRANULARITY_SHIFT);

    //
    //  If the first available heap entry is not committed and
    //  it is beyond the heap limit then we cannot initialize
    //

    if ((PCHAR)(FirstEntry + 1) >= (PCHAR)UnCommittedAddress) {

        if ((PCHAR)(FirstEntry + 1) >= (PCHAR)CommitLimitAddress) {

            return FALSE;
        }

        //
        //  Enough of the segment has not been committed so we
        //  will commit enough now to handle the first entry
        //

        CommitSize = (PCHAR)(FirstEntry + 1) - (PCHAR)UnCommittedAddress;

        Status = ZwAllocateVirtualMemory( (PVOID *)&UnCommittedAddress,
                                          0,
                                          &CommitSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return FALSE;
        }

        //
        //  Because we had to commit some memory we need to adjust
        //  the uncommited address
        //

        UnCommittedAddress = (PVOID)((PCHAR)UnCommittedAddress + CommitSize);
    }

    //
    //  At this point we know there is enough memory committed to handle the
    //  segment header and one heap entry
    //
    //  Now compute the number of uncommited pages and the number of committed
    //  pages
    //

    NumberOfUnCommittedPages = (ULONG)(((PCHAR)CommitLimitAddress - (PCHAR)UnCommittedAddress) / PAGE_SIZE);
    NumberOfCommittedPages = NumberOfPages - NumberOfUnCommittedPages;

    //
    //  Initialize the heap segment heap entry.  We
    //  calculated earlier if there was a previous entry
    //

    Segment->Entry.PreviousSize = PreviousSize;
    Segment->Entry.Size = Size;
    Segment->Entry.Flags = HEAP_ENTRY_BUSY;
    Segment->Entry.SegmentIndex = SegmentIndex;

#if i386 && !NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel x86 case see if we need to capture the callers stack
    //  backtrace
    //

    if (NtGlobalFlag & FLG_USER_STACK_TRACE_DB) {

        Segment->AllocatorBackTraceIndex = (USHORT)RtlLogStackBackTrace();
    }

#endif // i386 && !NTOS_KERNEL_RUNTIME

    //
    //  Now initializes the heap segment
    //

    Segment->Signature = HEAP_SEGMENT_SIGNATURE;
    Segment->Flags = Flags;
    Segment->Heap = Heap;
    Segment->BaseAddress = BaseAddress;
    Segment->FirstEntry = FirstEntry;
    Segment->LastValidEntry = (PHEAP_ENTRY)((PCHAR)BaseAddress + (NumberOfPages * PAGE_SIZE));
    Segment->NumberOfPages = NumberOfPages;
    Segment->NumberOfUnCommittedPages = NumberOfUnCommittedPages;

    //
    //  If there are uncommitted pages then we need to insert them
    //  into the uncommitted ranges list
    //

    if (NumberOfUnCommittedPages) {

        RtlpInsertUnCommittedPages( Segment,
                                    (ULONG_PTR)UnCommittedAddress,
                                    NumberOfUnCommittedPages * PAGE_SIZE );
    }

    //
    //  Have the containing heap point to this segment via the specified index
    //

    Heap->Segments[ SegmentIndex ] = Segment;

    //
    //  Initialize the first free heap entry after the heap segment header and
    //  put it in the free list.  This first entry will be for whatever is left
    //  of the committed range
    //

    PreviousSize = Segment->Entry.Size;
    FirstEntry->Flags = HEAP_ENTRY_LAST_ENTRY;

    Segment->LastEntryInSegment = FirstEntry;

    FirstEntry->PreviousSize = PreviousSize;
    FirstEntry->SegmentIndex = SegmentIndex;

    RtlpInsertFreeBlock( Heap,
                         (PHEAP_FREE_ENTRY)FirstEntry,
                         (PHEAP_ENTRY)UnCommittedAddress - FirstEntry);

    //
    //  And return to our caller
    //

    return TRUE;
}


//
//  Local Support Routine
//

NTSTATUS
RtlpDestroyHeapSegment (
    IN PHEAP_SEGMENT Segment
    )

/*++

Routine Description:

    This routine removes an existing heap segment.  After the call it
    is as if the segment never existed

Arguments:

    Segment - Supplies a pointer to the heap segment being destroyed

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    PVOID BaseAddress;
    SIZE_T BytesToFree;

    RTL_PAGED_CODE();

    //
    //  We actually only have work to do if the segment is not
    //  user allocated.  If the segement is user allocated then
    //  we'll assume knows how to get rid of the memory
    //

    if (!(Segment->Flags & HEAP_SEGMENT_USER_ALLOCATED)) {

        BaseAddress = Segment->BaseAddress;
        BytesToFree = 0;

        //
        //  Free all the virtual memory for the segment and return
        //  to our caller.
        //

        return ZwFreeVirtualMemory( (PVOID *)&BaseAddress,
                                    &BytesToFree,
                                    MEM_RELEASE );

    } else {

        //
        //  User allocated segments are a noop
        //

        return STATUS_SUCCESS;
    }
}



//
//  Local Support Routine
//

PHEAP_FREE_ENTRY
RtlpExtendHeap (
    IN PHEAP Heap,
    IN SIZE_T AllocationSize
    )

/*++

Routine Description:

    This routine is used to extend the amount of committed memory in a heap

Arguments:

    Heap - Supplies the heap being modified

    AllocationSize - Supplies the size, in bytes, that we need to extend the
        heap

Return Value:

    PHEAP_FREE_ENTRY - Returns a pointer to the newly created heap entry
        of the specified size, or NULL if we weren't able to extend the heap

--*/

{
    NTSTATUS Status;
    PHEAP_SEGMENT Segment;
    PHEAP_FREE_ENTRY FreeBlock;
    UCHAR SegmentIndex, EmptySegmentIndex;
    ULONG NumberOfPages;
    SIZE_T CommitSize;
    SIZE_T ReserveSize;
    SIZE_T FreeSize;

    RTL_PAGED_CODE();

    //
    //  Compute the number of pages need to hold this extension
    //  And then compute the real free, still in bytes, based on
    //  the page count
    //

    NumberOfPages = (ULONG) ((AllocationSize + PAGE_SIZE - 1) / PAGE_SIZE);
    FreeSize = NumberOfPages * PAGE_SIZE;

    //
    //  For every segment we're either going to look for an existing
    //  heap segment that we can get some pages out of or we will
    //  identify a free heap segment index where we'll try and create a new
    //  segment
    //

    EmptySegmentIndex = HEAP_MAXIMUM_SEGMENTS;

    for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

        Segment = Heap->Segments[ SegmentIndex ];

        //
        //  If the segment exists and number of uncommitted pages will
        //  satisfy our reguest and the largest uncommitted range will
        //  also satisfy our request then we'll try and segment
        //
        //  **** note that this second test seems unnecessary given that
        //  **** the largest uncommitted range is also being tested
        //

        if ((Segment) &&
            (NumberOfPages <= Segment->NumberOfUnCommittedPages) &&
            (FreeSize <= Segment->LargestUnCommittedRange)) {

            //
            //  Looks like a good segment so try and commit the
            //  amount we need
            //

            FreeBlock = RtlpFindAndCommitPages( Heap,
                                                Segment,
                                                &FreeSize,
                                                NULL );

            //
            //  If we were successful the we will coalesce it with adjacent
            //  free blocks and put it in the free list then return the
            //  the free block
            //

            if (FreeBlock != NULL) {

                //
                //  **** gdk ****
                //  **** this doesn't seem right given that coalesece should take
                //  **** byte count and not heap entry count
                //

                FreeSize = FreeSize >> HEAP_GRANULARITY_SHIFT;

                FreeBlock = RtlpCoalesceFreeBlocks( Heap, FreeBlock, &FreeSize, FALSE );

                RtlpInsertFreeBlock( Heap, FreeBlock, FreeSize );

                return FreeBlock;
            }

        //
        //  Otherwise if the segment index is not in use and we haven't
        //  yet identified a unused segment index then remembeer this
        //  index
        //

        } else if ((Segment == NULL) &&
                   (EmptySegmentIndex == HEAP_MAXIMUM_SEGMENTS)) {

            EmptySegmentIndex = SegmentIndex;
        }
    }

    //
    //  At this point we weren't able to get the memory from an existing
    //  heap segment so now check if we found an unused segment index
    //  and if we're alowed to grow the heap.
    //

    if ((EmptySegmentIndex != HEAP_MAXIMUM_SEGMENTS) &&
        (Heap->Flags & HEAP_GROWABLE)) {

        Segment = NULL;

        //
        //  Calculate a reserve size for the new segment, we might
        //  need to fudge it up if the allocation size we're going for
        //  right now is already beyond the default reserve size
        //

        if ((AllocationSize + PAGE_SIZE) > Heap->SegmentReserve) {

            ReserveSize = AllocationSize + PAGE_SIZE;

        } else {

            ReserveSize = Heap->SegmentReserve;
        }

        //
        //  Try and reserve some vm
        //

        Status = ZwAllocateVirtualMemory( (PVOID *)&Segment,
                                          0,
                                          &ReserveSize,
                                          MEM_RESERVE,
                                          PAGE_READWRITE );

        //
        //  If we get back status no memory then we should trim back the
        //  request to something reasonable and try again.  We'll half
        //  the amount until we it either succeeds or until we reach
        //  the allocation size.  In the latter case we are really
        //  out of memory.
        //

        while ((!NT_SUCCESS( Status )) && (ReserveSize != (AllocationSize + PAGE_SIZE))) {

            ReserveSize = ReserveSize / 2;

            if( ReserveSize < (AllocationSize + PAGE_SIZE) ) {

                ReserveSize = (AllocationSize + PAGE_SIZE);
            }

            Status = ZwAllocateVirtualMemory( (PVOID *)&Segment,
                                              0,
                                              &ReserveSize,
                                              MEM_RESERVE,
                                              PAGE_READWRITE );
        }

        if (NT_SUCCESS( Status )) {

            //
            //  Adjust the heap state information
            //

            Heap->SegmentReserve += ReserveSize;

            //
            //  Compute the commit size to be either the default, or if
            //  that's not big enough then make it big enough to handle
            //  this current request
            //

            if ((AllocationSize + PAGE_SIZE) > Heap->SegmentCommit) {

                CommitSize = AllocationSize + PAGE_SIZE;

            } else {

                CommitSize = Heap->SegmentCommit;
            }

            //
            //  Try and commit the memory
            //

            Status = ZwAllocateVirtualMemory( (PVOID *)&Segment,
                                              0,
                                              &CommitSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE );

            //
            //  If the commit is successful but we were not able to
            //  initialize the heap segment then still make the status
            //  and error value
            //

            if (NT_SUCCESS( Status ) &&
                !RtlpInitializeHeapSegment( Heap,
                                            Segment,
                                            EmptySegmentIndex,
                                            0,
                                            Segment,
                                            (PCHAR)Segment + CommitSize,
                                            (PCHAR)Segment + ReserveSize)) {

                Status = STATUS_NO_MEMORY;
            }

            //
            //  If we've been successful so far then we're done and we
            //  can return the first entry in the segment to our caller
            //

            if (NT_SUCCESS(Status)) {

                return (PHEAP_FREE_ENTRY)Segment->FirstEntry;
            }

            //
            //  Otherwise either the commit or heap segment initialization failed
            //  so we'll release the memory which will also decommit it if necessary
            //

            ZwFreeVirtualMemory( (PVOID *)&Segment,
                                 &ReserveSize,
                                 MEM_RELEASE );
        }
    }

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case we disabled coaleseing on free then what we'll
    //  do as a last resort is coalesce the heap and see if a block comes out
    //  that we can use
    //

    if (Heap->Flags & HEAP_DISABLE_COALESCE_ON_FREE) {

        FreeBlock = RtlpCoalesceHeap( Heap );

        if ((FreeBlock != NULL) && (FreeBlock->Size >= AllocationSize)) {

            return FreeBlock;
        }
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  Either the heap cannot grow or we out of resources of some type
    //  so we're going to return null
    //

    return NULL;
}


//
//  Declared in heappriv.h
//

PHEAP_FREE_ENTRY
RtlpCoalesceFreeBlocks (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeBlock,
    IN OUT PSIZE_T FreeSize,
    IN BOOLEAN RemoveFromFreeList
    )

/*++

Routine Description:

    This routine coalesces the free block together.

Arguments:

    Heap - Supplies a pointer to the heap being manipulated

    FreeBlock - Supplies a pointer to the free block that we want coalesced

    FreeSize - Supplies the size, in bytes, of the free block.  On return it
        contains the size, in bytes, of the of the newly coalesced free block

    RemoveFromFreeList - Indicates if the input free block is already on a
        free list and needs to be removed to before coalescing

Return Value:

    PHEAP_FREE_ENTRY - returns a pointer to the newly coalesced free block

--*/

{
    PHEAP_FREE_ENTRY FreeBlock1, NextFreeBlock;

    RTL_PAGED_CODE();

    //
    //  Point to the preceding block
    //

    FreeBlock1 = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)FreeBlock - FreeBlock->PreviousSize);

    //
    //  Check if there is a preceding block, and if it is free, and the two sizes
    //  put together will still fit on a free lists.
    //

    if ((FreeBlock1 != FreeBlock) &&
        !(FreeBlock1->Flags & HEAP_ENTRY_BUSY) &&
        ((*FreeSize + FreeBlock1->Size) <= HEAP_MAXIMUM_BLOCK_SIZE)) {

        //
        //  We are going to merge ourselves with the preceding block
        //

        HEAPASSERT(FreeBlock->PreviousSize == FreeBlock1->Size);

        //
        //  Check if we need to remove the input block from the free list
        //

        if (RemoveFromFreeList) {

            RtlpRemoveFreeBlock( Heap, FreeBlock );

            Heap->TotalFreeSize -= FreeBlock->Size;

            //
            //  We're removed so we don't have to do it again
            //

            RemoveFromFreeList = FALSE;
        }

        //
        //  Remove the preceding block from its free list
        //

        RtlpRemoveFreeBlock( Heap, FreeBlock1 );

        //
        //  Copy over the last entry flag if necessary from what we're freeing
        //  to the preceding block
        //

        FreeBlock1->Flags = FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY;

        if( FreeBlock1->Flags & HEAP_ENTRY_LAST_ENTRY ) {

            PHEAP_SEGMENT Segment;

            Segment = Heap->Segments[FreeBlock1->SegmentIndex];
            Segment->LastEntryInSegment = (PHEAP_ENTRY)FreeBlock1;
        }

        //
        //  Point to the preceding block, and adjust the sizes for the
        //  new free block.  It is the total of both blocks.
        //

        FreeBlock = FreeBlock1;

        *FreeSize += FreeBlock1->Size;

        Heap->TotalFreeSize -= FreeBlock1->Size;

        FreeBlock->Size = (USHORT)*FreeSize;

        //
        //  Check if we need to update the previous size of the next
        //  entry
        //

        if (!(FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

            ((PHEAP_ENTRY)FreeBlock + *FreeSize)->PreviousSize = (USHORT)*FreeSize;
        }
    }

    //
    //  Check if there is a following block.
    //

    if (!(FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

        //
        //  There is a following block so now get a pointer to it
        //  and check if it is free and if putting the two blocks together
        //  still fits on a free list
        //

        NextFreeBlock = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)FreeBlock + *FreeSize);

        if (!(NextFreeBlock->Flags & HEAP_ENTRY_BUSY) &&
            ((*FreeSize + NextFreeBlock->Size) <= HEAP_MAXIMUM_BLOCK_SIZE)) {

            //
            //  We are going to merge ourselves with the following block
            //

            HEAPASSERT(*FreeSize == NextFreeBlock->PreviousSize);

            //
            //  Check if we need to remove the input block from the free list
            //

            if (RemoveFromFreeList) {

                RtlpRemoveFreeBlock( Heap, FreeBlock );

                Heap->TotalFreeSize -= FreeBlock->Size;

                //
                //  **** this assignment isn't necessary because there isn't
                //  **** any more merging after this one
                //

                RemoveFromFreeList = FALSE;
            }

            //
            //  Copy up the last entry flag if necessary from the following
            //  block to our input block
            //

            FreeBlock->Flags = NextFreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY;

            if( FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY ) {

                PHEAP_SEGMENT Segment;

                Segment = Heap->Segments[FreeBlock->SegmentIndex];
                Segment->LastEntryInSegment = (PHEAP_ENTRY)FreeBlock;
            }

            //
            //  Remove the following block from its free list
            //

            RtlpRemoveFreeBlock( Heap, NextFreeBlock );

            //
            //  Adjust the size for the newly combined block
            //

            *FreeSize += NextFreeBlock->Size;

            Heap->TotalFreeSize -= NextFreeBlock->Size;

            FreeBlock->Size = (USHORT)*FreeSize;

            //
            //  Check if we need to update the previous size of the next block
            //

            if (!(FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                ((PHEAP_ENTRY)FreeBlock + *FreeSize)->PreviousSize = (USHORT)*FreeSize;
            }
        }
    }

    //
    //  And return the free block to our caller
    //

    return FreeBlock;
}


//
//  Declared in heappriv.h
//

VOID
RtlpDeCommitFreeBlock (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeBlock,
    IN SIZE_T FreeSize
    )

/*++

Routine Description:

    This routine takes a free block and decommits it.  This is usually called
    because the block is beyond the decommit threshold

Arguments:

    Heap - Supplies a pointer to the heap being manipulated

    FreeBlock - Supplies a pointer to the block being decommitted

    FreeSize - Supplies the size, in bytes, of the free block being decommitted

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    ULONG_PTR DeCommitAddress;
    SIZE_T DeCommitSize;
    USHORT LeadingFreeSize, TrailingFreeSize;
    PHEAP_SEGMENT Segment;
    PHEAP_FREE_ENTRY LeadingFreeBlock, TrailingFreeBlock;
    PHEAP_ENTRY LeadingBusyBlock, TrailingBusyBlock;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange;

    RTL_PAGED_CODE();

    //
    //  If the heap has a user specified decommit routine then we won't really
    //  decommit anything instead we'll call a worker routine to chop it up
    //  into pieces that will fit on the free lists
    //

    if (Heap->CommitRoutine != NULL) {

        RtlpInsertFreeBlock( Heap, FreeBlock, FreeSize );

        return;
    }

    //
    //  Get a pointer to the owning segment
    //

    Segment = Heap->Segments[ FreeBlock->SegmentIndex ];

    //
    //  The leading busy block identifies the preceding in use block before
    //  what we are trying to decommit.  It is only used if what we are trying
    //  decommit is right on a page boundary and then it is the block right
    //  before us if it exists.
    //
    //  The leading free block is used to identify whatever space is needed
    //  to round up the callers specified address to a page address.  If the
    //  caller already gave us a page aligned address then the free block
    //  address is identical to what the caller supplied.
    //

    LeadingBusyBlock = NULL;
    LeadingFreeBlock = FreeBlock;

    //
    //  Make sure the block we are trying to decommit start on the next full
    //  page boundary.  The leading free size is the size of whatever it takes
    //  to round up the free block to the next page specified in units of
    //  heap entries.
    //

    DeCommitAddress = ROUND_UP_TO_POWER2( LeadingFreeBlock, PAGE_SIZE );
    LeadingFreeSize = (USHORT)((PHEAP_ENTRY)DeCommitAddress - (PHEAP_ENTRY)LeadingFreeBlock);

    //
    //  If we leading free size only has space for one heap entry then we'll
    //  bump it up to include the next page, because we don't want to leave
    //  anything that small laying around.  Otherwise if we have a preceding
    //  block and the leading free size is zero then identify the preceding
    //  block as the leading busy block
    //

    if (LeadingFreeSize == 1) {

        DeCommitAddress += PAGE_SIZE;
        LeadingFreeSize += PAGE_SIZE >> HEAP_GRANULARITY_SHIFT;

    } else if (LeadingFreeBlock->PreviousSize != 0) {

        if (DeCommitAddress == (ULONG_PTR)LeadingFreeBlock) {

            LeadingBusyBlock = (PHEAP_ENTRY)LeadingFreeBlock - LeadingFreeBlock->PreviousSize;
        }
    }

    //
    //  The trailing busy block identifies the block immediately after the one
    //  we are trying to decommit provided what we are decommitting ends right
    //  on a page boundary otherwise the trailing busy block stays null and
    //  the trailing free block value is used.
    //
    //  **** gdk ****
    //  **** the assignment of tailing free block doesn't seem right because
    //  **** Free size should be in bytes, and not heap entries
    //

    TrailingBusyBlock = NULL;
    TrailingFreeBlock = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)FreeBlock + FreeSize);

    //
    //  Make sure the block we are trying to decommit ends on a page boundary.
    //
    //  And compute how many heap entries we had to backup to make it land on a
    //  page boundary.
    //

    DeCommitSize = ROUND_DOWN_TO_POWER2( (ULONG_PTR)TrailingFreeBlock, PAGE_SIZE );
    TrailingFreeSize = (USHORT)((PHEAP_ENTRY)TrailingFreeBlock - (PHEAP_ENTRY)DeCommitSize);

    //
    //  If the trailing free size is exactly one heap in size then we will
    //  nibble off a bit more from the decommit size because free block of
    //  exactly one heap entry in size are useless.  Otherwise if we actually
    //  ended on a page boundary and there is a block after us then indicate
    //  that we have a trailing busy block
    //

    if (TrailingFreeSize == (sizeof( HEAP_ENTRY ) >> HEAP_GRANULARITY_SHIFT)) {

        DeCommitSize -= PAGE_SIZE;
        TrailingFreeSize += PAGE_SIZE >> HEAP_GRANULARITY_SHIFT;

    } else if ((TrailingFreeSize == 0) && !(FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

        TrailingBusyBlock = (PHEAP_ENTRY)TrailingFreeBlock;
    }

    //
    //  Now adjust the trailing free block to compensate for the trailing free size
    //  we just computed.
    //

    TrailingFreeBlock = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)TrailingFreeBlock - TrailingFreeSize);

    //
    //  Right now DeCommit size is really a pointer.  If it points at is beyond
    //  the decommit address then make the size really be just the byte count
    //  to decommit.  Otherwise the decommit size is zero.
    //

    if (DeCommitSize > DeCommitAddress) {

        DeCommitSize -= DeCommitAddress;

    } else {

        DeCommitSize = 0;
    }

    //
    //  **** this next test is bogus given the if-then-else that just preceded it
    //
    //  Now check if we still have something to decommit
    //

    if (DeCommitSize != 0) {

        //
        //  Before freeing the memory to MM we have to be sure we can create 
        //  a PHEAP_UNCOMMMTTED_RANGE later. So we do it right now
        //

        UnCommittedRange = RtlpCreateUnCommittedRange(Segment);

        if (UnCommittedRange == NULL) {
            
            HeapDebugPrint(( "Failing creating uncommitted range (%x for %x)\n", DeCommitAddress, DeCommitSize ));

            //
            //  We weren't successful in the decommit so now simply
            //  add the leading free block to the free list
            //

            RtlpInsertFreeBlock( Heap, LeadingFreeBlock, FreeSize );

            return;
        }

        //
        //  Decommit the memory
        //

        Status = ZwFreeVirtualMemory( (PVOID *)&DeCommitAddress,
                                      &DeCommitSize,
                                      MEM_DECOMMIT );

        //
        //  Push back the UnCommittedRange structure. Now the insert cannot fail
        //

        RtlpDestroyUnCommittedRange( Segment, UnCommittedRange );

        if (NT_SUCCESS( Status )) {

            //
            //  Insert information regarding the pages we just decommitted
            //  to the lsit of uncommited pages in the segment
            //

            RtlpInsertUnCommittedPages( Segment,
                                        DeCommitAddress,
                                        DeCommitSize );
            //
            //  Adjust the segments count of uncommitted pages
            //

            Segment->NumberOfUnCommittedPages += (ULONG)(DeCommitSize / PAGE_SIZE);

            //
            //  If we have a leading free block then mark its proper state
            //  update the heap, and put it on the free list
            //

            if (LeadingFreeSize != 0) {

                LeadingFreeBlock->Flags = HEAP_ENTRY_LAST_ENTRY;
                LeadingFreeBlock->Size = LeadingFreeSize;
                Heap->TotalFreeSize += LeadingFreeSize;

                Segment->LastEntryInSegment = (PHEAP_ENTRY)LeadingFreeBlock;

                RtlpInsertFreeBlockDirect( Heap, LeadingFreeBlock, LeadingFreeSize );

            //
            //  Otherwise if we actually have a leading busy block then
            //  make sure the busy block knows we're uncommitted
            //

            } else if (LeadingBusyBlock != NULL) {

                LeadingBusyBlock->Flags |= HEAP_ENTRY_LAST_ENTRY;

                Segment->LastEntryInSegment = LeadingBusyBlock;

            } else if ((Segment->LastEntryInSegment >= (PHEAP_ENTRY)DeCommitAddress)
                            &&
                       ((PCHAR)Segment->LastEntryInSegment < ((PCHAR)DeCommitAddress + DeCommitSize))) {

                     Segment->LastEntryInSegment = Segment->FirstEntry;
            }

            //
            //  If there is a trailing free block then sets its state,
            //  update the heap, and insert it on a free list
            //

            if (TrailingFreeSize != 0) {

                TrailingFreeBlock->PreviousSize = 0;
                TrailingFreeBlock->SegmentIndex = Segment->Entry.SegmentIndex;
                TrailingFreeBlock->Flags = 0;
                TrailingFreeBlock->Size = TrailingFreeSize;

                ((PHEAP_FREE_ENTRY)((PHEAP_ENTRY)TrailingFreeBlock + TrailingFreeSize))->PreviousSize = (USHORT)TrailingFreeSize;

                RtlpInsertFreeBlockDirect( Heap, TrailingFreeBlock, TrailingFreeSize );

                Heap->TotalFreeSize += TrailingFreeSize;

            //
            //  Otherwise if we actually have a succeeding block then
            //  make it know we are uncommitted
            //

            } else if (TrailingBusyBlock != NULL) {

                TrailingBusyBlock->PreviousSize = 0;
            }

        } else {

            //
            //  We weren't successful in the decommit so now simply
            //  add the leading free block to the free list
            //

            RtlpInsertFreeBlock( Heap, LeadingFreeBlock, FreeSize );
        }

    } else {

        //
        //  There is nothing left to decommit to take our leading free block
        //  and put it on a free list
        //

        RtlpInsertFreeBlock( Heap, LeadingFreeBlock, FreeSize );
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Declared in heappriv.h
//

VOID
RtlpInsertFreeBlock (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeBlock,
    IN SIZE_T FreeSize
    )

/*++

Routine Description:

    This routines take a piece of committed memory and adds to the
    the appropriate free lists for the heap.  If necessary this
    routine will divide up the free block to sizes that fit
    on the free list


Arguments:

    Heap - Supplies a pointer to the owning heap

    FreeBlock - Supplies a pointer to the block being freed

    FreeSize - Supplies the size, in bytes, of the block being freed

Return Value:

    None.

--*/

{
    USHORT PreviousSize, Size;
    UCHAR Flags;
    UCHAR SegmentIndex;
    PHEAP_SEGMENT Segment;

    RTL_PAGED_CODE();

    //
    //  Get the size of the previous block, the index of the segment
    //  containing this block, and the flags specific to the block
    //

    PreviousSize = FreeBlock->PreviousSize;

    SegmentIndex = FreeBlock->SegmentIndex;
    Segment = Heap->Segments[ SegmentIndex ];

    Flags = FreeBlock->Flags;

    //
    //  Adjust the total amount free in the heap
    //

    Heap->TotalFreeSize += FreeSize;

    //
    //  Now, while there is still something left to add to the free list
    //  we'll process the information
    //

    while (FreeSize != 0) {

        //
        //  If the size is too big for our free lists then we'll
        //  chop it down.
        //

        if (FreeSize > (ULONG)HEAP_MAXIMUM_BLOCK_SIZE) {

            Size = HEAP_MAXIMUM_BLOCK_SIZE;

            //
            //  This little adjustment is so that we don't have a remainder
            //  that is too small to be useful on the next iteration
            //  through the loop
            //

            if (FreeSize == ((ULONG)HEAP_MAXIMUM_BLOCK_SIZE + 1)) {

                Size -= 16;
            }

            //
            //  Guarantee that Last entry does not get set in this
            //  block.
            //

            FreeBlock->Flags = 0;

        } else {

            Size = (USHORT)FreeSize;

            //
            //  This could propagate the last entry flag
            //

            FreeBlock->Flags = Flags;
        }

        //
        //  Update the block sizes and then insert this
        //  block into a free list
        //

        FreeBlock->PreviousSize = PreviousSize;
        FreeBlock->SegmentIndex = SegmentIndex;
        FreeBlock->Size = Size;

        RtlpInsertFreeBlockDirect( Heap, FreeBlock, Size );

        //
        //  Note the size of what we just freed, and then update
        //  our state information for the next time through the
        //  loop
        //

        PreviousSize = Size;

        FreeSize -= Size;
        FreeBlock = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)FreeBlock + Size);

        //
        //  Check if we're done with the free block based on the
        //  segment information, otherwise go back up and check size
        //  Note that is means that we can get called with a very
        //  large size and still work.
        //

        if ((PHEAP_ENTRY)FreeBlock >= Segment->LastValidEntry) {

            return;
        }
    }

    //
    //  If the block we're freeing did not think it was the last entry
    //  then tell the next block our real size.
    //

    if (!(Flags & HEAP_ENTRY_LAST_ENTRY)) {

        FreeBlock->PreviousSize = PreviousSize;
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Declared in heappriv.h
//

PHEAP_ENTRY_EXTRA
RtlpGetExtraStuffPointer (
    PHEAP_ENTRY BusyBlock
    )

/*++

Routine Description:

    This routine calculates where the extra stuff record will be given
    the busy block and returns a pointer to it.  The caller must have
    already checked that the entry extry field is present

Arguments:

    BusyBlock - Supplies the busy block whose extra stuff we are seeking

Return Value:

    PHEAP_ENTRY_EXTRA - returns a pointer to the extra stuff record.

--*/

{
    ULONG AllocationIndex;

    //
    //  On big blocks the extra stuff is automatically part of the
    //  block
    //

    if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

        PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

        VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

        return &VirtualAllocBlock->ExtraStuff;

    } else {

        //
        //  On non big blocks the extra stuff follows immediately after
        //  the allocation itself.
        //
        //  **** What a hack
        //  **** We do some funny math here because the busy block
        //  **** stride is 8 bytes we know we can stride it by its
        //  **** index minus one to get to the end of the allocation
        //

        AllocationIndex = BusyBlock->Size;

        return (PHEAP_ENTRY_EXTRA)(BusyBlock + AllocationIndex - 1);
    }
}


//
//  Declared in heappriv.h
//

SIZE_T
RtlpGetSizeOfBigBlock (
    IN PHEAP_ENTRY BusyBlock
    )

/*++

Routine Description:

    This routine returns the size, in bytes, of the big allocation block

Arguments:

    BusyBlock - Supplies a pointer to the block being queried

Return Value:

    SIZE_T - Returns the size, in bytes, that was allocated to the big
        block

--*/

{
    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

    RTL_PAGED_CODE();

    //
    //  Get a pointer to the block header itself
    //

    VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

    //
    //  The size allocated to the block is actually the difference between the
    //  commit size stored in the virtual alloc block and the size stored in
    //  in the block.
    //

    return VirtualAllocBlock->CommitSize - BusyBlock->Size;
}


//
//  Declared in heappriv.h
//

BOOLEAN
RtlpCheckBusyBlockTail (
    IN PHEAP_ENTRY BusyBlock
    )

/*++

Routine Description:

    This routine checks to see if the bytes beyond the user specified
    allocation have been modified.  It does this by checking for a tail
    fill pattern

Arguments:

    BusyBlock - Supplies the heap block being queried

Return Value:

    BOOLEAN - TRUE if the tail is still okay and FALSE otherwise

--*/

{
    PCHAR Tail;
    SIZE_T Size, cbEqual;

    RTL_PAGED_CODE();

    //
    //  Compute the user allocated size of the input heap block
    //

    if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

        Size = RtlpGetSizeOfBigBlock( BusyBlock );

    } else {

        Size = (BusyBlock->Size << HEAP_GRANULARITY_SHIFT) - BusyBlock->UnusedBytes;
    }

    //
    //  Compute a pointer to the tail of the input block.  This would
    //  be the space right after the user allocated portion
    //

    Tail = (PCHAR)(BusyBlock + 1) + Size;

    //
    //  Check if the tail fill pattern is still there
    //

    cbEqual = RtlCompareMemory( Tail,
                                CheckHeapFillPattern,
                                CHECK_HEAP_TAIL_SIZE );

    //
    //  If the number we get back isn't equal to the tail size then
    //  someone modified the block beyond its user specified allocation
    //  size
    //

    if (cbEqual != CHECK_HEAP_TAIL_SIZE) {

        //
        //  Do some debug printing
        //

        HeapDebugPrint(( "Heap block at %p modified at %p past requested size of %lx\n",
                         BusyBlock,
                         Tail + cbEqual,
                         Size ));

        HeapDebugBreak( BusyBlock );

        //
        //  And tell our caller there was an error
        //

        return FALSE;

    } else {

        //
        //  And return to our caller that the tail is fine
        //

        return TRUE;
    }
}

#if DBG

BOOLEAN RtlpValidateHeapHdrsEnable = FALSE; // Set to TRUE if headers are being corrupted
BOOLEAN RtlpValidateHeapTagsEnable;         // Set to TRUE if tag counts are off and you want to know why

HEAP_STOP_ON_VALUES RtlpHeapStopOn;


const struct {

    ULONG Offset;
    LPSTR Description;

} RtlpHeapHeaderFieldOffsets[] = {

    FIELD_OFFSET( HEAP, Entry ),                        "Entry",
    FIELD_OFFSET( HEAP, Signature ),                    "Signature",
    FIELD_OFFSET( HEAP, Flags ),                        "Flags",
    FIELD_OFFSET( HEAP, ForceFlags ),                   "ForceFlags",
    FIELD_OFFSET( HEAP, VirtualMemoryThreshold ),       "VirtualMemoryThreshold",
    FIELD_OFFSET( HEAP, SegmentReserve ),               "SegmentReserve",
    FIELD_OFFSET( HEAP, SegmentCommit ),                "SegmentCommit",
    FIELD_OFFSET( HEAP, DeCommitFreeBlockThreshold ),   "DeCommitFreeBlockThreshold",
    FIELD_OFFSET( HEAP, DeCommitTotalFreeThreshold ),   "DeCommitTotalFreeThreshold",
    FIELD_OFFSET( HEAP, TotalFreeSize ),                "TotalFreeSize",
    FIELD_OFFSET( HEAP, MaximumAllocationSize ),        "MaximumAllocationSize",
    FIELD_OFFSET( HEAP, ProcessHeapsListIndex ),        "ProcessHeapsListIndex",
    FIELD_OFFSET( HEAP, HeaderValidateLength ),         "HeaderValidateLength",
    FIELD_OFFSET( HEAP, HeaderValidateCopy ),           "HeaderValidateCopy",
    FIELD_OFFSET( HEAP, NextAvailableTagIndex ),        "NextAvailableTagIndex",
    FIELD_OFFSET( HEAP, MaximumTagIndex ),              "MaximumTagIndex",
    FIELD_OFFSET( HEAP, TagEntries ),                   "TagEntries",
    FIELD_OFFSET( HEAP, UCRSegments ),                  "UCRSegments",
    FIELD_OFFSET( HEAP, UnusedUnCommittedRanges ),      "UnusedUnCommittedRanges",
    FIELD_OFFSET( HEAP, AlignRound ),                   "AlignRound",
    FIELD_OFFSET( HEAP, AlignMask ),                    "AlignMask",
    FIELD_OFFSET( HEAP, VirtualAllocdBlocks ),          "VirtualAllocdBlocks",
    FIELD_OFFSET( HEAP, Segments ),                     "Segments",
    FIELD_OFFSET( HEAP, u ),                            "FreeListsInUse",
    FIELD_OFFSET( HEAP, FreeListsInUseTerminate ),      "FreeListsInUseTerminate",
    FIELD_OFFSET( HEAP, AllocatorBackTraceIndex ),      "AllocatorBackTraceIndex",
    FIELD_OFFSET( HEAP, Reserved1 ),                    "Reserved1",
    FIELD_OFFSET( HEAP, PseudoTagEntries ),             "PseudoTagEntries",
    FIELD_OFFSET( HEAP, FreeLists ),                    "FreeLists",
    FIELD_OFFSET( HEAP, LockVariable ),                 "LockVariable",
    FIELD_OFFSET( HEAP, Lookaside ),                    "Lookaside",
    FIELD_OFFSET( HEAP, LookasideLockCount ),           "LookasideLockCount",
    sizeof( HEAP ),                                     "Uncommitted Ranges",
    0xFFFF, NULL
};

//
//  Declared in heappriv.h
//

BOOLEAN
RtlpCheckHeapSignature (
    IN PHEAP Heap,
    IN PCHAR Caller
    )

/*++

Routine Description:

    This routine verifies that it is being called with a properly identified
    heap.

Arguments:

    Heap - Supplies a pointer to the heap being checked

    Caller - Supplies a string that can be used to identify the caller

Return Value:

    BOOLEAN - TRUE if the heap signature is present, and FALSE otherwise

--*/

{
    //
    //  If the heap signature matches then that is the only
    //  checking we do
    //

    if (Heap->Signature == HEAP_SIGNATURE) {

        return TRUE;

    } else {

        //
        //  We have a bad heap signature.  Print out some information, break
        //  into the debugger, and then return false
        //

        HeapDebugPrint(( "Invalid heap signature for heap at %x", Heap ));

        if (Caller != NULL) {

            DbgPrint( ", passed to %s", Caller );
        }

        DbgPrint( "\n" );

        HeapDebugBreak( &Heap->Signature );

        return FALSE;
    }
}



BOOLEAN
RtlpValidateHeapHeaders (
    IN PHEAP Heap,
    IN BOOLEAN Recompute
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    ULONG i;
    SIZE_T n;
    SIZE_T nEqual;
    NTSTATUS Status;

    if (!RtlpValidateHeapHdrsEnable) {

        return TRUE;
    }

    if (Heap->HeaderValidateCopy == NULL) {

        n = Heap->HeaderValidateLength;

        Status = NtAllocateVirtualMemory( &Heap->HeaderValidateCopy,
                                          0,
                                          &n,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return TRUE;
        }

        Recompute = TRUE;
    }

    n = Heap->HeaderValidateLength;

    if (!Recompute) {

        nEqual = RtlCompareMemory( Heap,
                                   Heap->HeaderValidateCopy,
                                   n );

    } else {

        RtlMoveMemory( Heap->HeaderValidateCopy,
                       Heap,
                       n );

        nEqual = n;
    }

    if (n != nEqual) {

        HeapDebugPrint(( "Heap %x - headers modified (%x is %x instead of %x)\n",
                         Heap,
                         (PCHAR)Heap + nEqual,
                         *(PULONG)((PCHAR)Heap + nEqual),
                         *(PULONG)((PCHAR)Heap->HeaderValidateCopy + nEqual)));

        for (i=0; RtlpHeapHeaderFieldOffsets[ i ].Description != NULL; i++) {

            if ((nEqual >= RtlpHeapHeaderFieldOffsets[ i ].Offset) &&
                (nEqual < RtlpHeapHeaderFieldOffsets[ i+1 ].Offset)) {

                DbgPrint( "    This is located in the %s field of the heap header.\n",
                                 RtlpHeapHeaderFieldOffsets[ i ].Description );

                break;
            }
        }

        return FALSE;

    } else {

        return TRUE;
    }
}



BOOLEAN
RtlpValidateHeapSegment (
    IN PHEAP Heap,
    IN PHEAP_SEGMENT Segment,
    IN UCHAR SegmentIndex,
    IN OUT PULONG CountOfFreeBlocks,
    IN OUT PSIZE_T TotalFreeSize,
    OUT PVOID *BadAddress,
    IN OUT PSIZE_T ComputedTagEntries,
    IN OUT PSIZE_T ComputedPseudoTagEntries
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP_ENTRY CurrentBlock, PreviousBlock;
    SIZE_T Size;
    USHORT PreviousSize, TagIndex;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;

    RTL_PAGED_CODE();

    NumberOfUnCommittedPages = 0;
    NumberOfUnCommittedRanges = 0;

    UnCommittedRange = Segment->UnCommittedRanges;

    if (Segment->BaseAddress == Heap) {

        CurrentBlock = &Heap->Entry;

    } else {

        CurrentBlock = &Segment->Entry;
    }

    while (CurrentBlock < Segment->LastValidEntry) {

        *BadAddress = CurrentBlock;

        if ((UnCommittedRange != NULL) &&
            ((ULONG_PTR)CurrentBlock >= UnCommittedRange->Address)) {

            HeapDebugPrint(( "Heap entry %lx is beyond uncommited range [%x .. %x)\n",
                             CurrentBlock,
                             UnCommittedRange->Address,
                             (PCHAR)UnCommittedRange->Address + UnCommittedRange->Size ));

            return FALSE;
        }

        PreviousSize = 0;

        while (CurrentBlock < Segment->LastValidEntry) {

            *BadAddress = CurrentBlock;

            if (PreviousSize != CurrentBlock->PreviousSize) {

                HeapDebugPrint(( "Heap entry %lx has incorrect PreviousSize field (%04x instead of %04x)\n",
                                 CurrentBlock, CurrentBlock->PreviousSize, PreviousSize ));

                return FALSE;
            }

            PreviousSize = CurrentBlock->Size;
            Size = (ULONG_PTR)CurrentBlock->Size << HEAP_GRANULARITY_SHIFT;

            if (CurrentBlock->Flags & HEAP_ENTRY_BUSY) {

                if (ComputedTagEntries != NULL) {

                    if (CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                        ExtraStuff = RtlpGetExtraStuffPointer( CurrentBlock );
                        TagIndex = ExtraStuff->TagIndex;

                    } else {

                        TagIndex = CurrentBlock->SmallTagIndex;
                    }

                    if (TagIndex != 0) {

                        if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

                            TagIndex &= ~HEAP_PSEUDO_TAG_FLAG;

                            if (TagIndex < HEAP_NUMBER_OF_PSEUDO_TAG) {

                                ComputedPseudoTagEntries[ TagIndex ] += CurrentBlock->Size;
                            }

                        } else if (TagIndex & HEAP_GLOBAL_TAG) {

                            //
                            //  Ignore these since they are global across more than
                            //  one heap.
                            //

                        } else if (TagIndex < Heap->NextAvailableTagIndex) {

                            ComputedTagEntries[ TagIndex ] += CurrentBlock->Size;
                        }
                    }
                }

                if (CurrentBlock->Flags & HEAP_ENTRY_FILL_PATTERN) {

                    if (!RtlpCheckBusyBlockTail( CurrentBlock )) {

                        return FALSE;
                    }
                }

            } else {

                *CountOfFreeBlocks += 1;
                *TotalFreeSize += CurrentBlock->Size;

                if ((Heap->Flags & HEAP_FREE_CHECKING_ENABLED) &&
                    (CurrentBlock->Flags & HEAP_ENTRY_FILL_PATTERN)) {

                    SIZE_T cb, cbEqual;

                    cb = Size - sizeof( HEAP_FREE_ENTRY );

                    if ((CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) &&
                        (cb > sizeof( HEAP_FREE_ENTRY_EXTRA ))) {

                        cb -= sizeof( HEAP_FREE_ENTRY_EXTRA );
                    }

                    cbEqual = RtlCompareMemoryUlong( (PCHAR)((PHEAP_FREE_ENTRY)CurrentBlock + 1),
                                                     cb,
                                                     FREE_HEAP_FILL );

                    if (cbEqual != cb) {

                        HeapDebugPrint(( "Free Heap block %lx modified at %lx after it was freed\n",
                                         CurrentBlock,
                                         (PCHAR)(CurrentBlock + 1) + cbEqual ));

                        return FALSE;
                    }
                }
            }

            if (CurrentBlock->SegmentIndex != SegmentIndex) {

                HeapDebugPrint(( "Heap block at %lx has incorrect segment index (%x)\n",
                                 CurrentBlock,
                                 SegmentIndex ));

                return FALSE;
            }

            if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                CurrentBlock = (PHEAP_ENTRY)((PCHAR)CurrentBlock + Size);

                if (UnCommittedRange == NULL) {

                    if (CurrentBlock != Segment->LastValidEntry) {

                        HeapDebugPrint(( "Heap block at %lx is not last block in segment (%x)\n",
                                         CurrentBlock,
                                         Segment->LastValidEntry ));

                        return FALSE;
                    }

                } else if ((ULONG_PTR)CurrentBlock != UnCommittedRange->Address) {

                    HeapDebugPrint(( "Heap block at %lx does not match address of next uncommitted address (%x)\n",
                                     CurrentBlock,
                                     UnCommittedRange->Address ));

                    return FALSE;

                } else {

                    NumberOfUnCommittedPages += (ULONG) (UnCommittedRange->Size / PAGE_SIZE);
                    NumberOfUnCommittedRanges += 1;

                    CurrentBlock = (PHEAP_ENTRY)
                        ((PCHAR)UnCommittedRange->Address + UnCommittedRange->Size);

                    UnCommittedRange = UnCommittedRange->Next;
                }

                break;
            }

            CurrentBlock = (PHEAP_ENTRY)((PCHAR)CurrentBlock + Size);
        }
    }

    *BadAddress = Segment;

    if (Segment->NumberOfUnCommittedPages != NumberOfUnCommittedPages) {

        HeapDebugPrint(( "Heap Segment at %lx contains invalid NumberOfUnCommittedPages (%x != %x)\n",
                         Segment,
                         Segment->NumberOfUnCommittedPages,
                         NumberOfUnCommittedPages ));

        return FALSE;
    }

    if (Segment->NumberOfUnCommittedRanges != NumberOfUnCommittedRanges) {

        HeapDebugPrint(( "Heap Segment at %lx contains invalid NumberOfUnCommittedRanges (%x != %x)\n",
                         Segment,
                         Segment->NumberOfUnCommittedRanges,
                         NumberOfUnCommittedRanges ));

        return FALSE;
    }

    return TRUE;
}



BOOLEAN
RtlpValidateHeapEntry (
    IN PHEAP Heap,
    IN PHEAP_ENTRY BusyBlock,
    IN PCHAR Reason
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP_SEGMENT Segment;
    UCHAR SegmentIndex;
    BOOLEAN Result;

    if ((BusyBlock == NULL)

            ||

        ((ULONG_PTR)BusyBlock & (HEAP_GRANULARITY-1))

            ||

        ((BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) &&
         ((ULONG_PTR)BusyBlock & (PAGE_SIZE-1)) != FIELD_OFFSET( HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock ))

            ||

        (!(BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) &&
         ((BusyBlock->SegmentIndex >= HEAP_MAXIMUM_SEGMENTS) ||
          !(Segment = Heap->Segments[ BusyBlock->SegmentIndex ]) ||
          (BusyBlock < Segment->FirstEntry) ||
          (BusyBlock >= Segment->LastValidEntry)))

            ||

        !(BusyBlock->Flags & HEAP_ENTRY_BUSY)

            ||

        ((BusyBlock->Flags & HEAP_ENTRY_FILL_PATTERN) && !RtlpCheckBusyBlockTail( BusyBlock ))) {

InvalidBlock:

        HeapDebugPrint(( "Invalid Address specified to %s( %lx, %lx )\n",
                         Reason,
                         Heap,
                         BusyBlock + 1 ));

        HeapDebugBreak( BusyBlock );

        return FALSE;

    } else {

        if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

            Result = TRUE;

        } else {

            for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

                Segment = Heap->Segments[ SegmentIndex ];

                if (Segment) {

                    if ((BusyBlock >= Segment->FirstEntry) &&
                        (BusyBlock < Segment->LastValidEntry)) {

                        Result = TRUE;
                        break;
                    }
                }
            }
        }

        if (!Result) {

            goto InvalidBlock;
        }

        return TRUE;
    }
}



BOOLEAN
RtlpValidateHeap (
    IN PHEAP Heap,
    IN BOOLEAN AlwaysValidate
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    PHEAP_SEGMENT Segment;
    PLIST_ENTRY Head, Next;
    PHEAP_FREE_ENTRY FreeBlock;
    BOOLEAN EmptyFreeList;
    ULONG NumberOfFreeListEntries;
    ULONG CountOfFreeBlocks;
    SIZE_T TotalFreeSize;
    SIZE_T Size;
    USHORT PreviousSize;
    UCHAR SegmentIndex;
    PVOID BadAddress;
    PSIZE_T ComputedTagEntries = NULL;
    PSIZE_T ComputedPseudoTagEntries = NULL;
    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;
    USHORT TagIndex;

    RTL_PAGED_CODE();

    BadAddress = Heap;

    if (!RtlpValidateHeapHeaders( Heap, FALSE )) {

        goto errorExit;
    }

    if (!AlwaysValidate && !(Heap->Flags & HEAP_VALIDATE_ALL_ENABLED)) {

        goto exit;
    }

    NumberOfFreeListEntries = 0;
    Head = &Heap->FreeLists[ 0 ];

    for (Size = 0; Size < HEAP_MAXIMUM_FREELISTS; Size++) {

        if (Size != 0) {

            EmptyFreeList = (BOOLEAN)(IsListEmpty( Head ));
            BadAddress = &Heap->u.FreeListsInUseBytes[ Size / 8 ];

            if (Heap->u.FreeListsInUseBytes[ Size / 8 ] & (1 << (Size & 7)) ) {

                if (EmptyFreeList) {

                    HeapDebugPrint(( "dedicated (%04x) free list empty but marked as non-empty\n",
                                     Size ));

                    goto errorExit;
                }

            } else {

                if (!EmptyFreeList) {

                    HeapDebugPrint(( "dedicated (%04x) free list non-empty but marked as empty\n",
                                     Size ));

                    goto errorExit;
                }
            }
        }

        Next = Head->Flink;
        PreviousSize = 0;

        while (Head != Next) {

            FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );
            Next = Next->Flink;

            BadAddress = FreeBlock;

            if (FreeBlock->Flags & HEAP_ENTRY_BUSY) {

                HeapDebugPrint(( "dedicated (%04x) free list element %lx is marked busy\n",
                                 Size,
                                 FreeBlock ));

                goto errorExit;
            }

            if ((Size != 0) && (FreeBlock->Size != Size)) {

                HeapDebugPrint(( "Dedicated (%04x) free list element %lx is wrong size (%04x)\n",
                                 Size,
                                 FreeBlock,
                                 FreeBlock->Size ));

                goto errorExit;

            } else if ((Size == 0) && (FreeBlock->Size < HEAP_MAXIMUM_FREELISTS)) {

                HeapDebugPrint(( "Non-Dedicated free list element %lx with too small size (%04x)\n",
                                 FreeBlock,
                                 FreeBlock->Size ));

                goto errorExit;

            } else if ((Size == 0) && (FreeBlock->Size < PreviousSize)) {

                HeapDebugPrint(( "Non-Dedicated free list element %lx is out of order\n",
                                 FreeBlock ));

                goto errorExit;

            } else {

                PreviousSize = FreeBlock->Size;
            }

            NumberOfFreeListEntries++;
        }

        Head++;
    }

    Size = (HEAP_NUMBER_OF_PSEUDO_TAG + Heap->NextAvailableTagIndex + 1) * sizeof( SIZE_T );

    if ((RtlpValidateHeapTagsEnable) && (Heap->PseudoTagEntries != NULL)) {

        Status = NtAllocateVirtualMemory( &ComputedPseudoTagEntries,
                                          0,
                                          &Size,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        if (NT_SUCCESS( Status )) {

            ComputedTagEntries = ComputedPseudoTagEntries + HEAP_NUMBER_OF_PSEUDO_TAG;
        }
    }

    Head = &Heap->VirtualAllocdBlocks;
    Next = Head->Flink;

    while (Head != Next) {

        VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

        if (ComputedTagEntries != NULL) {

            TagIndex = VirtualAllocBlock->ExtraStuff.TagIndex;

            if (TagIndex != 0) {

                if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

                    TagIndex &= ~HEAP_PSEUDO_TAG_FLAG;

                    if (TagIndex < HEAP_NUMBER_OF_PSEUDO_TAG) {

                        ComputedPseudoTagEntries[ TagIndex ] +=
                            VirtualAllocBlock->CommitSize >> HEAP_GRANULARITY_SHIFT;
                    }

                } else if (TagIndex & HEAP_GLOBAL_TAG) {

                    //
                    //  Ignore these since they are global across more than
                    //  one heap.
                    //

                } else if (TagIndex < Heap->NextAvailableTagIndex) {

                    ComputedTagEntries[ TagIndex ] +=
                        VirtualAllocBlock->CommitSize >> HEAP_GRANULARITY_SHIFT;
                }
            }
        }

        if (VirtualAllocBlock->BusyBlock.Flags & HEAP_ENTRY_FILL_PATTERN) {

            if (!RtlpCheckBusyBlockTail( &VirtualAllocBlock->BusyBlock )) {

                return FALSE;
            }
        }

        Next = Next->Flink;
    }

    CountOfFreeBlocks = 0;
    TotalFreeSize = 0;

    for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

        Segment = Heap->Segments[ SegmentIndex ];

        if (Segment) {

            if (!RtlpValidateHeapSegment( Heap,
                                          Segment,
                                          SegmentIndex,
                                          &CountOfFreeBlocks,
                                          &TotalFreeSize,
                                          &BadAddress,
                                          ComputedTagEntries,
                                          ComputedPseudoTagEntries )) {

                goto errorExit;
            }
        }
    }

    BadAddress = Heap;

    if (NumberOfFreeListEntries != CountOfFreeBlocks) {

        HeapDebugPrint(( "Number of free blocks in arena (%ld) does not match number in the free lists (%ld)\n",
                         CountOfFreeBlocks,
                         NumberOfFreeListEntries ));

        goto errorExit;
    }

    if (Heap->TotalFreeSize != TotalFreeSize) {

        HeapDebugPrint(( "Total size of free blocks in arena (%ld) does not match number total in heap header (%ld)\n",
                         TotalFreeSize,
                         Heap->TotalFreeSize ));

        goto errorExit;
    }

    if (ComputedPseudoTagEntries != NULL) {

        PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntries;
        PHEAP_TAG_ENTRY TagEntries;
        USHORT TagIndex;

        PseudoTagEntries = Heap->PseudoTagEntries;

        if (PseudoTagEntries != NULL) {

            for (TagIndex=1; TagIndex<HEAP_NUMBER_OF_PSEUDO_TAG; TagIndex++) {

                PseudoTagEntries += 1;

                if (ComputedPseudoTagEntries[ TagIndex ] != PseudoTagEntries->Size) {

                    HeapDebugPrint(( "Pseudo Tag %04x size incorrect (%x != %x) %x\n",
                                     TagIndex,
                                     PseudoTagEntries->Size,
                                     ComputedPseudoTagEntries[ TagIndex ]
                                     &ComputedPseudoTagEntries[ TagIndex ] ));

                    goto errorExit;
                }
            }
        }

        TagEntries = Heap->TagEntries;

        if (TagEntries != NULL) {

            for (TagIndex=1; TagIndex<Heap->NextAvailableTagIndex; TagIndex++) {

                TagEntries += 1;

                if (ComputedTagEntries[ TagIndex ] != TagEntries->Size) {

                    HeapDebugPrint(( "Tag %04x (%ws) size incorrect (%x != %x) %x\n",
                                     TagIndex,
                                     TagEntries->TagName,
                                     TagEntries->Size,
                                     ComputedTagEntries[ TagIndex ],
                                     &ComputedTagEntries[ TagIndex ] ));

                    goto errorExit;
                }
            }
        }

        Size = 0;

        NtFreeVirtualMemory( &ComputedPseudoTagEntries,
                             &Size,
                             MEM_RELEASE );
    }

exit:

    return TRUE;

errorExit:

    HeapDebugBreak( BadAddress );

    if (ComputedPseudoTagEntries != NULL) {

        Size = 0;

        NtFreeVirtualMemory( &ComputedPseudoTagEntries,
                             &Size,
                             MEM_RELEASE );
    }

    return FALSE;

}



BOOLEAN
RtlDebugWalkHeap (
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN Result;

    //
    //  Assumed the caller has serialized via RtlLockHeap or their own locking mechanism.
    //

    Result = FALSE;

    try {

        if (RtlpCheckHeapSignature( Heap, "RtlWalkHeap" )) {

            Result = RtlpValidateHeap( Heap, FALSE );
        }

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        SET_LAST_STATUS( GetExceptionCode() );
    }

    return Result;
}



//
//  Declared in nturtl.h
//

NTSTATUS
RtlWalkHeap (
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    )

/*++

Routine Description:

    This routine is used to enumerate all the entries within a heap.  For each
    call it returns a new information in entry.

Arguments:

    HeapHandle - Supplies a pointer to the heap being queried

    Entry - Supplies storage for the entry information.  If the DataAddress field
        is null then the enumeration starts over from the beginning otherwise it
        resumes from where it left off

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    NTSTATUS Status;
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_SEGMENT Segment;
    UCHAR SegmentIndex;
    PHEAP_ENTRY CurrentBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange, *pp;
    PLIST_ENTRY Next, Head;
    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

#if 0
    //
    //  Check if we should be using the guard page verion of heap
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapWalk( HeapHandle, Entry ));
                                    
#endif // 0

    //
    //  If this is the debug version of heap then validate the heap
    //  before we go on
    //

    if (DEBUG_HEAP( Heap->Flags )) {

        if (!RtlDebugWalkHeap( HeapHandle, Entry )) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    Status = STATUS_SUCCESS;

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  If there is an active lookaside list then drain and remove it.
    //  By setting the lookaside field in the heap to null we guarantee
    //  that the call the free heap will not try and use the lookaside
    //  list logic.
    //
    //  We'll actually capture the lookaside pointer from the heap and
    //  only use the captured pointer.  This will take care of the
    //  condition where another walk or lock heap can cause us to check
    //  for a non null pointer and then have it become null when we read
    //  it again.  If it is non null to start with then even if the
    //  user walks or locks the heap via another thread the pointer to
    //  still valid here so we can still try and do a lookaside list pop.
    //

    {
        PHEAP_LOOKASIDE Lookaside = (PHEAP_LOOKASIDE)Heap->Lookaside;

        if (Lookaside != NULL) {

            ULONG i;
            PVOID Block;

            Heap->Lookaside = NULL;

            for (i = 0; i < HEAP_MAXIMUM_FREELISTS; i += 1) {

                while ((Block = RtlpAllocateFromHeapLookaside(&(Lookaside[i]))) != NULL) {

                    RtlFreeHeap( HeapHandle, 0, Block );
                }
            }
        }
    }
    
#endif // NTOS_KERNEL_RUNTIME

    //
    //  Check if this is the first time we've been called to walk the heap
    //

    if (Entry->DataAddress == NULL) {

        //
        //  Start with the first segement in the heap
        //

        SegmentIndex = 0;

nextSegment:

        CurrentBlock = NULL;

        //
        //  Now find the next in use segment for the heap
        //

        Segment = NULL;

        while ((SegmentIndex < HEAP_MAXIMUM_SEGMENTS) &&
               ((Segment = Heap->Segments[ SegmentIndex ]) == NULL)) {

            SegmentIndex += 1;
        }

        //
        //  If there are no more valid segments then we'll try the big
        //  allocation
        //

        if (Segment == NULL) {

            Head = &Heap->VirtualAllocdBlocks;
            Next = Head->Flink;

            if (Next == Head) {

                Status = STATUS_NO_MORE_ENTRIES;

            } else {

                VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

                CurrentBlock = &VirtualAllocBlock->BusyBlock;
            }

        //
        //  Otherwise we'll grab information about the segment.  Note that
        //  the current block is still null so when we fall out of this
        //  block we'll return directly to our caller with this segment
        //  information
        //

        } else {

            Entry->DataAddress = Segment;

            Entry->DataSize = 0;

            Entry->OverheadBytes = sizeof( *Segment );

            Entry->Flags = RTL_HEAP_SEGMENT;

            Entry->SegmentIndex = SegmentIndex;

            Entry->Segment.CommittedSize = (Segment->NumberOfPages -
                                            Segment->NumberOfUnCommittedPages) * PAGE_SIZE;

            Entry->Segment.UnCommittedSize = Segment->NumberOfUnCommittedPages * PAGE_SIZE;

            Entry->Segment.FirstEntry = (Segment->FirstEntry->Flags & HEAP_ENTRY_BUSY) ?
                ((PHEAP_ENTRY)Segment->FirstEntry + 1) :
                (PHEAP_ENTRY)((PHEAP_FREE_ENTRY)Segment->FirstEntry + 1);

            Entry->Segment.LastEntry = Segment->LastValidEntry;
        }

    //
    //  This is not the first time through.  Check if last time we gave back
    //  an heap segement or an uncommitted range
    //

    } else if (Entry->Flags & (RTL_HEAP_SEGMENT | RTL_HEAP_UNCOMMITTED_RANGE)) {

        //
        //  Check that the segment index is still valid
        //

        if ((SegmentIndex = Entry->SegmentIndex) >= HEAP_MAXIMUM_SEGMENTS) {

            Status = STATUS_INVALID_ADDRESS;

            CurrentBlock = NULL;

        } else {

            //
            //  Check that the segment is still in use
            //

            Segment = Heap->Segments[ SegmentIndex ];

            if (Segment == NULL) {

                Status = STATUS_INVALID_ADDRESS;

                CurrentBlock = NULL;

            //
            //  The segment is still in use if what we returned last time
            //  as the segment header then this time we'll return the
            //  segments first entry
            //

            } else if (Entry->Flags & RTL_HEAP_SEGMENT) {

                CurrentBlock = (PHEAP_ENTRY)Segment->FirstEntry;

            //
            //  Otherwise what we returned last time as an uncommitted
            //  range so now we need to get the next block
            //

            } else {

                CurrentBlock = (PHEAP_ENTRY)((PCHAR)Entry->DataAddress + Entry->DataSize);

                //
                //  Check if we are beyond this segment and need to get the
                //  next one
                //

                if (CurrentBlock >= Segment->LastValidEntry) {

                    SegmentIndex += 1;

                    goto nextSegment;
                }
            }
        }

    //
    //  Otherwise this is not the first time through and last time we gave back a
    //  valid heap entry
    //

    } else {

        //
        //  Check if the last entry we gave back was in use
        //

        if (Entry->Flags & HEAP_ENTRY_BUSY) {

            //
            //  Get the last entry we returned
            //

            CurrentBlock = ((PHEAP_ENTRY)Entry->DataAddress - 1);

            //
            //  If the last entry was for a big allocation then
            //  get the next big block if there is one otherwise
            //  say there are no more entries
            //

            if (CurrentBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                Head = &Heap->VirtualAllocdBlocks;

                VirtualAllocBlock = CONTAINING_RECORD( CurrentBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

                Next = VirtualAllocBlock->Entry.Flink;

                if (Next == Head) {

                    Status = STATUS_NO_MORE_ENTRIES;

                } else {

                    VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

                    CurrentBlock = &VirtualAllocBlock->BusyBlock;
                }

            //
            //  Our previous result is a busy normal block
            //

            } else {

                //
                //  Get the segment and make sure it it still valid and in use
                //
                //  **** this should also check that segment index is not
                //  **** greater than HEAP MAXIMUM SEGMENTS
                //

                Segment = Heap->Segments[ SegmentIndex = CurrentBlock->SegmentIndex ];

                if (Segment == NULL) {

                    Status = STATUS_INVALID_ADDRESS;

                    CurrentBlock = NULL;

                //
                //  The segment is still in use, check if what we returned
                //  previously was a last entry
                //

                } else if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

findUncommittedRange:

                    //
                    //  We are at a last entry so now if the segment is done
                    //  then go get another segment
                    //

                    CurrentBlock += CurrentBlock->Size;

                    if (CurrentBlock >= Segment->LastValidEntry) {

                        SegmentIndex += 1;

                        goto nextSegment;
                    }

                    //
                    //  Otherwise we will find the uncommitted range entry that
                    //  immediately follows this last entry
                    //

                    pp = &Segment->UnCommittedRanges;

                    while ((UnCommittedRange = *pp) && UnCommittedRange->Address != (ULONG_PTR)CurrentBlock ) {

                        pp = &UnCommittedRange->Next;
                    }

                    if (UnCommittedRange == NULL) {

                        Status = STATUS_INVALID_PARAMETER;

                    } else {

                        //
                        //  Now fill in the entry to denote that uncommitted
                        //  range information
                        //

                        Entry->DataAddress = (PVOID)UnCommittedRange->Address;

                        Entry->DataSize = UnCommittedRange->Size;

                        Entry->OverheadBytes = 0;

                        Entry->SegmentIndex = SegmentIndex;

                        Entry->Flags = RTL_HEAP_UNCOMMITTED_RANGE;
                    }

                    //
                    //  Null out the current block because we've just filled in
                    //  the entry
                    //

                    CurrentBlock = NULL;

                } else {

                    //
                    //  Otherwise the entry has a following entry so now
                    //  advance to the next entry
                    //

                    CurrentBlock += CurrentBlock->Size;
                }
            }

        //
        //  Otherwise the previous entry we returned is not in use
        //

        } else {

            //
            //  Get the last entry we returned
            //

            CurrentBlock = (PHEAP_ENTRY)((PHEAP_FREE_ENTRY)Entry->DataAddress - 1);

            //
            //  Get the segment and make sure it it still valid and in use
            //
            //  **** this should also check that segment index is not
            //  **** greater than HEAP MAXIMUM SEGMENTS
            //

            Segment = Heap->Segments[ SegmentIndex = CurrentBlock->SegmentIndex ];

            if (Segment == NULL) {

                Status = STATUS_INVALID_ADDRESS;

                CurrentBlock = NULL;

            //
            //  If the block is the last entry then go find the next uncommitted
            //  range or segment
            //

            } else if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                goto findUncommittedRange;

            //
            //  Otherwise we'll just move on to the next entry
            //

            } else {

                CurrentBlock += CurrentBlock->Size;
            }
        }
    }

    //
    //  At this point if current block is not null then we've found another
    //  entry to return.  We could also have found a segment or uncommitted
    //  range but those are handled separately above and keep current block
    //  null
    //

    if (CurrentBlock != NULL) {

        //
        //  Check if the block is in use
        //

        if (CurrentBlock->Flags & HEAP_ENTRY_BUSY) {

            //
            //  Fill in the entry field for this block
            //

            Entry->DataAddress = (CurrentBlock+1);

            if (CurrentBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                Entry->DataSize = RtlpGetSizeOfBigBlock( CurrentBlock );

                Entry->OverheadBytes = (UCHAR)( sizeof( *VirtualAllocBlock ) + CurrentBlock->Size);

                Entry->SegmentIndex = HEAP_MAXIMUM_SEGMENTS;

                Entry->Flags = RTL_HEAP_BUSY |  HEAP_ENTRY_VIRTUAL_ALLOC;

            } else {

                Entry->DataSize = (CurrentBlock->Size << HEAP_GRANULARITY_SHIFT) -
                                  CurrentBlock->UnusedBytes;

                Entry->OverheadBytes = CurrentBlock->UnusedBytes;

                Entry->SegmentIndex = CurrentBlock->SegmentIndex;

                Entry->Flags = RTL_HEAP_BUSY;
            }

            if (CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                ExtraStuff = RtlpGetExtraStuffPointer( CurrentBlock );

                Entry->Block.Settable = ExtraStuff->Settable;
#if i386

                Entry->Block.AllocatorBackTraceIndex = ExtraStuff->AllocatorBackTraceIndex;

#endif // i386

                if (!IS_HEAP_TAGGING_ENABLED()) {

                    Entry->Block.TagIndex = 0;

                } else {

                    Entry->Block.TagIndex = ExtraStuff->TagIndex;
                }

                Entry->Flags |= RTL_HEAP_SETTABLE_VALUE;

            } else {

                if (!IS_HEAP_TAGGING_ENABLED()) {

                    Entry->Block.TagIndex = 0;

                } else {

                    Entry->Block.TagIndex = CurrentBlock->SmallTagIndex;
                }
            }

            Entry->Flags |= CurrentBlock->Flags & HEAP_ENTRY_SETTABLE_FLAGS;

        //
        //  Otherwise the block is not in use
        //

        } else {

            Entry->DataAddress = ((PHEAP_FREE_ENTRY)CurrentBlock+1);

            Entry->DataSize = (CurrentBlock->Size << HEAP_GRANULARITY_SHIFT) -
                              sizeof( HEAP_FREE_ENTRY );

            Entry->OverheadBytes = sizeof( HEAP_FREE_ENTRY );

            Entry->SegmentIndex = CurrentBlock->SegmentIndex;

            Entry->Flags = 0;
        }
    }

    //
    //  And return to our caller
    //

    return Status;
}



//
//  Declared in nturtl.h
//

BOOLEAN
RtlLockHeap (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

    This routine is used by lock access to a specific heap structure

Arguments:

    HeapHandle - Supplies a pointer to the heap being locked

Return Value:

    BOOLEAN - TRUE if the heap is now locked and FALSE otherwise (i.e.,
        the heap is ill-formed).  TRUE is returned even if the heap is
        not lockable.

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;

    RTL_PAGED_CODE();

#if 0

    //
    //  Check for the heap protected by guard pages
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapLock( HeapHandle ));

#endif // 0

    //
    //  Validate that HeapAddress points to a HEAP structure.
    //

    if (!RtlpCheckHeapSignature( Heap, "RtlLockHeap" )) {

        return FALSE;
    }

    //
    //  Lock the heap.  And disable the lookaside list by incrementing
    //  its lock count.
    //

    if (!(Heap->Flags & HEAP_NO_SERIALIZE)) {

        RtlAcquireLockRoutine( Heap->LockVariable );

#ifndef NTOS_KERNEL_RUNTIME
        Heap->LookasideLockCount += 1;
#endif // NTOS_KERNEL_RUNTIME
    }

    return TRUE;
}



//
//  Declared in nturtl.h
//

BOOLEAN
RtlUnlockHeap (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

    This routine is used to unlock access to a specific heap structure

Arguments:

    HeapHandle - Supplies a pointer to the heep being unlocked

Return Value:

    BOOLEAN - TRUE if the heap is now unlocked and FALSE otherwise (i.e.,
        the heap is ill-formed).  TRUE is also returned if the heap was
        never locked to begin with because it is not seralizable.

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;

    RTL_PAGED_CODE();

#if 0

    //
    //  Check for the heap protected by guard pages
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapUnlock( HeapHandle ));

#endif // 0

    //
    //  Validate that HeapAddress points to a HEAP structure.
    //

    if (!RtlpCheckHeapSignature( Heap, "RtlUnlockHeap" )) {

        return FALSE;
    }

    //
    //  Unlock the heap.  And enable the lookaside logic by decrementing
    //  its lock count
    //

    if (!(Heap->Flags & HEAP_NO_SERIALIZE)) {

#ifndef NTOS_KERNEL_RUNTIME
        Heap->LookasideLockCount -= 1;
#endif // NTOS_KERNEL_RUNTIME

        RtlReleaseLockRoutine( Heap->LockVariable );
    }

    return TRUE;
}



//
//  Declared in nturtl.h
//

BOOLEAN
RtlValidateHeap (
    PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

    This routine verifies the structure of a heap and/or heap block

Arguments:

    HeapHandle - Supplies a pointer to the heap being queried

    Flags - Supplies a set of flags used to augment those already
        enforced by the heap

    BaseAddress - Optionally supplies a pointer to the heap block
        that should be individually validated

Return Value:

    BOOLEAN - TRUE if the heap/block is okay and FALSE otherwise

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN Result;

    try {

        try {

#if 0
            //
            //  Check for the guard page version of heap
            //

            if ( IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle )) {

                Result = RtlpDebugPageHeapValidate( HeapHandle, Flags, BaseAddress );

            } else
            
#endif // 0

            {

#ifndef NTOS_KERNEL_RUNTIME

                //
                //  If there is an active lookaside list then drain and remove it.
                //  By setting the lookaside field in the heap to null we guarantee
                //  that the call the free heap will not try and use the lookaside
                //  list logic.
                //
                //  We'll actually capture the lookaside pointer from the heap and
                //  only use the captured pointer.  This will take care of the
                //  condition where another walk or lock heap can cause us to check
                //  for a non null pointer and then have it become null when we read
                //  it again.  If it is non null to start with then even if the
                //  user walks or locks the heap via another thread the pointer to
                //  still valid here so we can still try and do a lookaside list pop.
                //

                PHEAP_LOOKASIDE Lookaside = (PHEAP_LOOKASIDE)Heap->Lookaside;

                if (Lookaside != NULL) {

                    ULONG i;
                    PVOID Block;

                    Heap->Lookaside = NULL;

                    for (i = 0; i < HEAP_MAXIMUM_FREELISTS; i += 1) {

                        while ((Block = RtlpAllocateFromHeapLookaside(&(Lookaside[i]))) != NULL) {

                            RtlFreeHeap( HeapHandle, 0, Block );
                        }
                    }
                }

#endif // NTOS_KERNEL_RUNTIME

                Result = FALSE;

                //
                //  Validate that HeapAddress points to a HEAP structure.
                //

                if (RtlpCheckHeapSignature( Heap, "RtlValidateHeap" )) {

                    Flags |= Heap->ForceFlags;

                    //
                    //  Lock the heap
                    //

                    if (!(Flags & HEAP_NO_SERIALIZE)) {

                        RtlAcquireLockRoutine( Heap->LockVariable );

                        LockAcquired = TRUE;
                    }

                    //
                    //  If the user did not supply a base address then verify
                    //  the complete heap otherwise just do a single heap
                    //  entry
                    //

                    if (BaseAddress == NULL) {

                        Result = RtlpValidateHeap( Heap, TRUE );

                    } else {

                        Result = RtlpValidateHeapEntry( Heap, (PHEAP_ENTRY)BaseAddress - 1, "RtlValidateHeap" );
                    }
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            Result = FALSE;
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return Result;
}



//
//  Declared in heappriv.h
//

PHEAP_FREE_ENTRY
RtlpCoalesceHeap (
    IN PHEAP Heap
    )

/*++

Routine Description:

    This routine scans through heap and coalesces its free blocks

Arguments:

    H