clude    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */

#include    "scglobal.h"            /* structures & constants */
#include    "scgray.h"              /* gray scale param block */
#include    "scbitmap.h"            /* bit blt operations */
#include    "scmemory.h"            /* for allocations */

/*********************************************************************/

/*      Contour reversal list structures                             */

/*********************************************************************/

typedef struct Rev                  /* Reversal list entry */
{
	int16 sScan;                    /* scan line */
	int16 sCross;                   /* direction +1 or -1 */
	struct Rev *prevLink;           /* link to next reversal */
}
Reversal;

struct RevRoots                     /* Reversal list roots */
{
	Reversal *prevYRoot;            /* Y direction contour reversals */
	Reversal *prevXRoot;            /* X direction contour reversals */
	Reversal *prevNext;             /* Next available list item */
	Reversal *prevEnd;              /* End of buffer (for overflow check) */
	struct RevRoots *prrSelf;       /* to check for moved memory */
};

#include    "scanlist.h"            /* for own function prototypes */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE void AddReversal (Reversal**, Reversal*, F26Dot6, int16);
FS_PRIVATE int32 GetIxEstimate(Reversal*);
FS_PRIVATE void FixPointers(PRevRoot);

FS_PRIVATE void AddHorizSimpleScan(PSTATE int32, int32);
FS_PRIVATE void AddVertSimpleScan(PSTATE int32, int32);
FS_PRIVATE void AddHorizSmartScan(PSTATE int32, int32);
FS_PRIVATE void AddVertSmartScan(PSTATE int32, int32);
FS_PRIVATE void AddHorizSimpleBand(PSTATE int32, int32);
FS_PRIVATE void AddHorizSmartBand(PSTATE int32, int32);

FS_PRIVATE int32 LookForDropouts(PSTATE char*, uint16);
FS_PRIVATE int32 DoHorizDropout(PSTATE int16*, int16*, int32, char*, uint16);
FS_PRIVATE int32 DoVertDropout(PSTATE int16*, int16*, int32, char*, uint16);

FS_PRIVATE int32 HorizCrossings(PSTATE int32, int32);
FS_PRIVATE int32 VertCrossings(PSTATE int32, int32);

FS_PRIVATE uint32 GetBitAbs(PSTATE char*, int32, int32);
FS_PRIVATE int32 SetBitAbs(PSTATE char*, int32, int32);


/*********************************************************************/

/*      Initialization Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_InitializeScanlist()
{
	fsc_InitializeBitMasks();
}


/*********************************************************************/

/*      Contour Reversal Functions                                   */

/*********************************************************************/

/* setup the contour reversal list roots structure */

FS_PUBLIC PRevRoot  fsc_SetupRevRoots (
		char* pchRevBuf,
		int32 lRevBufSize )
{
	PRevRoot prrRoots;
	Reversal *prevSentinel;
	
	prrRoots = (PRevRoot) pchRevBuf;                /* workspace begin */
	prevSentinel = (Reversal*) (prrRoots + 1);      /* just past the roots */

	prrRoots->prevYRoot = prevSentinel;             /* point to sentinel */
	prrRoots->prevXRoot = prevSentinel;             /* for both lists */
	prevSentinel->sScan = HUGEINT;                  /* stop value */
	prevSentinel->sCross = 0;
	prevSentinel->prevLink = NULL;
	prrRoots->prevNext = prevSentinel + 1;          /* to next free record */
	
	prrRoots->prevEnd = (Reversal*)(pchRevBuf + lRevBufSize);
	prrRoots->prrSelf = prrRoots;                   /* for address validation */
	
	return prrRoots;
}

/*********************************************************************/

/* insert into y list one countour reversal structure */

FS_PUBLIC void fsc_AddYReversal (
		PRevRoot prrRoots,
		F26Dot6 fxCoord,
		int16 sDir )
{
	AddReversal(&(prrRoots->prevYRoot), prrRoots->prevNext, fxCoord, sDir);

	(prrRoots->prevNext)++;                     /* to next free memory */

	Assert(prrRoots->prevNext <= prrRoots->prevEnd);
}

/*********************************************************************/

/* insert into x list one countour reversal structure */

FS_PUBLIC void fsc_AddXReversal (
		PRevRoot prrRoots,
		F26Dot6 fxCoord,
		int16 sDir )
{
	AddReversal(&(prrRoots->prevXRoot), prrRoots->prevNext, fxCoord, sDir);

	(prrRoots->prevNext)++;                     /* to next free memory */

	Assert(prrRoots->prevNext <= prrRoots->prevEnd);
}

/*********************************************************************/

/* insert into x or y list one countour reversal structure */

FS_PRIVATE void AddReversal (
		Reversal **pprevList,
		Reversal *prevNext,
		F26Dot6 fxCoord,
		int16 sDir )
{
	int16 sScan;

	sScan = (int16)((fxCoord + SUBHALF + (sDir >> 1)) >> SUBSHFT);

	while(sScan > (*pprevList)->sScan)          /* will stop before sentinel */
	{
		pprevList = &((*pprevList)->prevLink);  /* else link to next */
	}
	prevNext->sScan = sScan;                    /* save scanline */
	prevNext->sCross = -sDir;                   /* count up from bottom */
	prevNext->prevLink = *pprevList;            /* link rest of list */

	*pprevList = prevNext;                      /* insert new item */
}

/*********************************************************************/

/* return the total number of reversals in the lists */

FS_PUBLIC int32 fsc_GetReversalCount (PRevRoot prrRoots)
{
	return (int32)(( prrRoots->prevNext - 1 -           /* don't count sentinel */
			 (Reversal*)((char*)prrRoots + sizeof(struct RevRoots))) );
}

/*********************************************************************/

/* calculate anticipated horizontal intersections */

FS_PUBLIC int32 fsc_GetHIxEstimate(PRevRoot prrRoots)
{
	if (prrRoots != prrRoots->prrSelf)          /* if reversals have moved */
	{
		FixPointers(prrRoots);                  /* then patch up the pointers */
	}
	return ( GetIxEstimate( prrRoots->prevYRoot ) );
}

/*********************************************************************/

/* calculate anticipated vertical intersections */

FS_PUBLIC int32 fsc_GetVIxEstimate(PRevRoot prrRoots)
{
	if (prrRoots != prrRoots->prrSelf)          /* if reversals have moved */
	{
		FixPointers(prrRoots);                  /* then patch up the pointers */
	}
	return ( GetIxEstimate( prrRoots->prevXRoot ) );
}

/*********************************************************************/

/* calculate anticipated intersections */

FS_PRIVATE int32 GetIxEstimate(Reversal *prevList)
{
	int32 lTotalIx;
	
	lTotalIx = 0L;
	while (prevList->sScan < HUGEINT)       /* look through list */
	{
		if (prevList->sCross == 1)          /* adding up columns! */
		{
			lTotalIx -= (int32)prevList->sScan;
		}
		else
		{
			lTotalIx += (int32)prevList->sScan;
		}
		prevList = prevList->prevLink;
	}
	return(lTotalIx);
}

/*********************************************************************/

/* calculate horizontal intersections for banding */

FS_PUBLIC int32 fsc_GetHIxBandEst(
		PRevRoot prrRoots,
		Rect* prectBox,
		  int32 lBandWidth
)
{
	Reversal *prevHiList;               /* high band reversal pointer */
	Reversal *prevLoList;               /* low band reversal pointer */
	int16 sHiScan;                      /* current top of band */
	int16 sLoScan;                      /* current bottom of band */
	int16 sHiCross;                     /* top of band's crossings */
	int16 sLoCross;                     /* bottom of band's crossings*/
	int32 lTotalIx;                     /* intersection count for each band */
	int32 lBiggestIx;                   /* largest intersection count */

	if (prrRoots != prrRoots->prrSelf)          /* if reversals have moved */
	{
		FixPointers(prrRoots);                  /* then patch up the pointers */
	}
	lTotalIx = 0;
	prevHiList = prrRoots->prevYRoot;
	sHiScan = prectBox->bottom;
	sHiCross = 0;
	while (lBandWidth > 0)
	{
		while (prevHiList->sScan <= sHiScan)
		{
			sHiCross += prevHiList->sCross;     /* add in this line's crossings */
			prevHiList = prevHiList->prevLink;  /* link to next reversal */
		}
		lTotalIx += (int32)sHiCross;            /* add up first band's crossings */
		sHiScan++;
		lBandWidth--;
	}
	lBiggestIx = lTotalIx;

	prevLoList = prrRoots->prevYRoot;
	sLoScan = prectBox->bottom;
	sLoCross = 0;
	while (sHiScan < prectBox->top)
	{
		while (prevHiList->sScan <= sHiScan)
		{
			sHiCross += prevHiList->sCross;     /* add in high line's crossings */
			prevHiList = prevHiList->prevLink;  /* link to next reversal */
		}
		while (prevLoList->sScan <= sLoScan)
		{
			sLoCross += prevLoList->sCross;     /* add in low line's crossings */
			prevLoList = prevLoList->prevLink;  /* link to next reversal */
		}
		lTotalIx += (int32)(sHiCross - sLoCross);
		if (lTotalIx > lBiggestIx)
		{
			lBiggestIx = lTotalIx;              /* save the largest value */
		}
		sHiScan++;
		sLoScan++;
	}
	return(lBiggestIx);
}

/*********************************************************************/

/*      return number of bytes used by reversal lists                */

FS_PUBLIC int32 fsc_GetRevMemSize(PRevRoot prrRoots)
{
	return (int32)((char*)(prrRoots->prevNext) - (char*)prrRoots);
}

/*********************************************************************/

/*  when reversal list has moved, recalculate the pointers           */

FS_PRIVATE void FixPointers(PRevRoot prrRoots)
{
	char *pchNewBase;
	char *pchOldBase;
	Reversal *prevList;

	pchNewBase = (char*)prrRoots;
	pchOldBase = (char*)prrRoots->prrSelf;          /* pre-move base addr */

	prrRoots->prevYRoot = (Reversal*)(pchNewBase + ((char*)prrRoots->prevYRoot - pchOldBase));
	prrRoots->prevXRoot = (Reversal*)(pchNewBase + ((char*)prrRoots->prevXRoot - pchOldBase));
	prrRoots->prevNext = (Reversal*)(pchNewBase + ((char*)prrRoots->prevNext - pchOldBase));
	prrRoots->prevEnd = (Reversal*)(pchNewBase + ((char*)prrRoots->prevEnd - pchOldBase));
	
	prevList = prrRoots->prevYRoot;
	while(prevList->sScan < HUGEINT)                /* from root to sentinel */
	{
		prevList->prevLink = (Reversal*)(pchNewBase + ((char*)prevList->prevLink - pchOldBase));
		prevList = prevList->prevLink;
	}
	
	prevList = prrRoots->prevXRoot;
	while(prevList->sScan < HUGEINT)                /* from root to sentinel */
	{
		prevList->prevLink = (Reversal*)(pchNewBase + ((char*)prevList->prevLink - pchOldBase));
		prevList = prevList->prevLink;
	}
	
	prrRoots->prrSelf = prrRoots;                   /* for next time */
}

/*********************************************************************/

/*      Workspace Calcluation Functions                              */

/*********************************************************************/

/* calculate horizontal scan workspace memory requirements */

FS_PUBLIC int32 fsc_GetScanHMem(
		uint16 usScanKind,      /* scan type */
		int32 lHScan,           /* number of horiz scanlines */
		int32 lHInter )         /* number of horiz intersections */
{
	ALIGN(voidPtr, lHScan); 
	ALIGN(voidPtr, lHInter ); 
	if (!(usScanKind & SK_SMART))       /* if simple dropout */
	{
		return (lHScan * (4 * sizeof(int16*)) +     /* for on/off begin/end */
				lHInter * (2 * sizeof(int16)));     /* for intersection arrays */
	}
	else                                /* if smart dropout */
	{
		return (lHScan * (4 * sizeof(int16*)) +     /* for on/off begin/end */
				lHInter * (4 * sizeof(int16)));     /* for ix/code arrays */
	}
}


/*********************************************************************/

/* calculate vertical scan workspace memory requirements */

FS_PUBLIC int32 fsc_GetScanVMem(
		uint16 usScanKind,      /* scan type */
		int32 lVScan,           /* number of vert scanlines */
		int32 lVInter,          /* number of vert intersections */
		int32 lElemPts )        /* number of contour element points */
{
	ALIGN(voidPtr, lVScan); 
	ALIGN(voidPtr, lVInter); 
	ALIGN(voidPtr, lElemPts ); 
	if (!(usScanKind & SK_SMART))       /* if simple dropout */
	{
		return (lVScan * (4 * sizeof(int16*)) +     /* for on/off begin/end */
				lVInter * (2 * sizeof(int16)));     /* for intersection arrays */
	}
	else                                /* if smart dropout */
	{
		return (lVScan * (4 * sizeof(int16*)) +     /* for on/off begin/end */
				lVInter * (4 * sizeof(int16)) +     /* for ix/code arrays */
				lElemPts * (2 * sizeof(F26Dot6)));  /* for element (x, y) */
	}
}

/*********************************************************************/

/*      Scan Conversion Preparation Functions                        */

/*********************************************************************/

/*  Line, Spline, and Endpoint register their callbacks here */

FS_PUBLIC void fsc_SetupCallBacks(
		PSTATE                       /* pointer to state variables */
		int16 sCode,                 /* element code (line, spline, endpoint) */
		F26Dot6 (*pfnHoriz)(int32, F26Dot6*, F26Dot6*),   /* horiz callback */
		F26Dot6 (*pfnVert)(int32, F26Dot6*, F26Dot6*)     /* vert callback */
)
{
	STATE.pfnHCallBack[sCode] = pfnHoriz;
	STATE.pfnVCallBack[sCode] = pfnVert;
}


/*********************************************************************/

/*  Allocate scan workspace memory and set up pointer arrays */

FS_PUBLIC int32 fsc_SetupScan(
		PSTATE                      /* pointer to state variables */
		Rect* prectBox,             /* bounding box */
		uint16 usScanKind,          /* dropout control value */
		int32 lHiBand,              /* top scan limit */
		int32 lLoBand,              /* bottom scan limit */
		boolean bSaveRow,           /* save last bitmap row for dropout */
		int32 lRowBytes,            /* for last row alloc */
		int32 lHInterCount,         /* estimate of horiz intersections */
		int32 lVInterCount,         /* estimate of vert intersections */
		int32 lElemCount,           /* estimate of element points */
		PRevRoot prrRoots           /* reversal list roots */
)
{
	int32 lHorizBandCount;          /* number of horizontal scan lines */
	int32 lVertScanCount;           /* number of vertical scan lines */
	int32 lPointerArraySize;        /* bytes per pointer array */

	int16 sScan;                    /* current scan line */
	int16 sCross;                   /* crossings on this line */
	int16 *psScanIx;                /* temp scan intersection array */
	Reversal *prevList;             /* pointer to reversal list */
	
	int16 **ppsHOnBegin;            /* for init speed */
	int16 **ppsHOnEnd;
	int16 **ppsHOffBegin;
	int16 **ppsHOffEnd;
	int16 **ppsVOnBegin;            /* for init speed */
	int16 **ppsVOnEnd;
	int16 **ppsVOffBegin;
	int16 **ppsVOffEnd;


	STATE.lBoxTop = (int32)prectBox->top;   /* copy the bounding box */
	STATE.lBoxBottom = (int32)prectBox->bottom;
	STATE.lBoxLeft = (int32)prectBox->left;
	STATE.lBoxRight = (int32)prectBox->right;
	
	STATE.lHiScanBand = lHiBand;    /* copy scan band limits */
	STATE.lLoScanBand = lLoBand;
	
/*  set STATE according to dropout and banding requirements */

	if ((usScanKind & SK_NODROPOUT) || !(usScanKind & SK_SMART))
	{
		STATE.sIxSize = 1;          /* one int16 per intersection */
		STATE.sIxShift = 0;         /* log2 of size */

		if ((STATE.lHiScanBand == STATE.lBoxTop) && (STATE.lLoScanBand == STATE.lBoxBottom))
		{
			STATE.pfnAddHoriz = AddHorizSimpleScan;
		}
		else    /* if banding */
		{
			STATE.pfnAddHoriz = AddHorizSimpleBand;
		}
		STATE.pfnAddVert = AddVertSimpleScan;
	}
	else        /* if smart dropout */
	{
		STATE.sIxSize = 2;          /* two int16's per intersection */
		STATE.sIxShift = 1;         /* log2 of size */

		if ((STATE.lHiScanBand == STATE.lBoxTop) && (STATE.lLoScanBand == STATE.lBoxBottom))
		{
			STATE.pfnAddHoriz = AddHorizSmartScan;
		}
		else    /* if banding */
		{
			STATE.pfnAddHoriz = AddHorizSmartBand;
		}
		STATE.pfnAddVert = AddVertSmartScan;
	}

/* setup horizontal intersection array for all cases */
	
	lHorizBandCount = STATE.lHiScanBand - STATE.lLoScanBand;
	Assert(lHorizBandCount > 0);
	
	lPointerArraySize = lHorizBandCount * sizeof(int16*);
	STATE.apsHOnBegin = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
	STATE.apsHOffBegin = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
	STATE.apsHOnEnd = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
	STATE.apsHOffEnd = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
	
	STATE.lPoint = 0L;                      /* initial element index */
	STATE.lElementPoints = lElemCount;

	psScanIx = (int16*) fsc_AllocHMem(ASTATE lHInterCount << (STATE.sIxShift + 2));
			
	if (prrRoots != prrRoots->prrSelf)      /* if reversals have moved */
	{
		FixPointers(prrRoots);              /* then patch up the pointers */
	}
	prevList = prrRoots->prevYRoot;         /* root of y list reversals */
	sCross = 0;
	
	ppsHOnBegin = STATE.apsHOnBegin;        /* for init speed */
	ppsHOnEnd = STATE.apsHOnEnd;
	ppsHOffBegin = STATE.apsHOffBegin;
	ppsHOffEnd = STATE.apsHOffEnd;

/* initialize horizontal scan arrays */
	
	for (sScan = (int16)STATE.lLoScanBand; sScan < (int16)STATE.lHiScanBand; sScan++)
	{
		while (prevList->sScan <= sScan)
		{
			sCross += (prevList->sCross << STATE.sIxShift); /* add in this line's crossings */
			prevList = prevList->prevLink;                  /* link to next reversal */
		}
		*ppsHOnBegin = psScanIx;
		ppsHOnBegin++;
		*ppsHOnEnd = psScanIx;
		ppsHOnEnd++;
		psScanIx += sCross;
				
		*ppsHOffBegin = psScanIx;
		ppsHOffBegin++;
		*ppsHOffEnd = psScanIx;
		ppsHOffEnd++;
		psScanIx += sCross;
	}
	
/* if doing dropout control, setup X intersection array */

	if (!(usScanKind & SK_NODROPOUT))           /* if any kind of dropout */
	{
		lVertScanCount = (int32)(prectBox->right - prectBox->left);
		Assert(lVertScanCount > 0);

		lPointerArraySize = lVertScanCount * sizeof(int16*);
		STATE.apsVOnBegin = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
		STATE.apsVOffBegin = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
		STATE.apsVOnEnd = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
		STATE.apsVOffEnd = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);

		if (bSaveRow)                           /* if fast banding & dropout */
		{
			STATE.pulLastRow = (uint32*) fsc_AllocVMem(ASTATE lRowBytes);
			STATE.lLastRowIndex = HUGEFIX;      /* impossible value => uninitialized */
		}
		psScanIx = (int16*) fsc_AllocVMem(ASTATE lVInterCount << (STATE.sIxShift + 2));
				
		prevList = prrRoots->prevXRoot;         /* root of x list reversals */
		sCross = 0;
		sScan = prectBox->left;
	
		ppsVOnBegin = STATE.apsVOnBegin;        /* for init speed */
		ppsVOnEnd = STATE.apsVOnEnd;
		ppsVOffBegin = STATE.apsVOffBegin;
		ppsVOffEnd = STATE.apsVOffEnd;
	
		for (sScan = prectBox->left; sScan < prectBox->right; sScan++)
		{
			while (prevList->sScan <= sScan)
			{
				sCross += (prevList->sCross << STATE.sIxShift); /* add in this line's crossings */
				prevList = prevList->prevLink;                  /* link to next reversal */
			}
			*ppsVOnBegin = psScanIx;
			ppsVOnBegin++;
			*ppsVOnEnd = psScanIx;
			ppsVOnEnd++;
			psScanIx += sCross;
					
			*ppsVOffBegin = psScanIx;
			ppsVOffBegin++;
			*ppsVOffEnd = psScanIx;
			ppsVOffEnd++;
			psScanIx += sCross;
		}
		if (usScanKind & SK_SMART)              /* if smart dropout */
		{
			STATE.afxXPoints = (F26Dot6*) fsc_AllocVMem(ASTATE lElemCount * sizeof(F26Dot6));
			STATE.afxYPoints = (F26Dot6*) fsc_AllocVMem(ASTATE lElemCount * sizeof(F26Dot6));
		}
	}
	return NO_ERR;
}

/*********************************************************************/

/* This function saves the first contour point for smart dropout calcs */

FS_PUBLIC void fsc_BeginContourScan(
		PSTATE                              /* pointer to state variables */
		uint16 usScanKind,                  /* scan type */
		F26Dot6 fxX1,                       /* starting point x coordinate */
		F26Dot6 fxY1                        /* starting point y coordinate */
)
{
	if (!(usScanKind & SK_NODROPOUT) && (usScanKind & SK_SMART)) /* if smart dropout */
	{
		STATE.afxXPoints[STATE.lPoint] = fxX1;
		STATE.afxYPoints[STATE.lPoint] = fxY1;
		STATE.lPoint++;
		Assert (STATE.lPoint <= STATE.lElementPoints);
	}
}

/*********************************************************************/
	
/* This function is called at the beginning of each line, subdivided */
/* spline, or endpoint-on-scanline.  It sets scanline state variables, */
/* save control points (for smart dropout control), and return the */
/* appropriate AddScan function pointers */

FS_PUBLIC void fsc_BeginElement(
	PSTATE                                      /* pointer to state variables */
	uint16 usScanKind,                          /* type of dropout control */
	int32 lQuadrant,                            /* determines scan on/off */
	int32 lElementCode,                         /* element (line, spline, ep) */
	int32 lPts,                                 /* number of points to store */
	F26Dot6 *pfxX,                              /* next x control point(s) */
	F26Dot6 *pfxY,                              /* next y control point(s) */
	void (**ppfnAddHorizScan)(PSTATE int32, int32),  /* horiz add scan return */
	void (**ppfnAddVertScan)(PSTATE int32, int32)    /* vert add scan return */
)
{
	*ppfnAddHorizScan = STATE.pfnAddHoriz;      /* set horiz add scan func */
	*ppfnAddVertScan = STATE.pfnAddVert;        /* set vert add scan func */

	
	if ((lQuadrant == 1) || (lQuadrant == 2))
	{
		STATE.apsHorizBegin = STATE.apsHOnBegin;    /* add 'on' interscections */
		STATE.apsHorizEnd = STATE.apsHOnEnd;
	}
	else
	{
		STATE.apsHorizBegin = STATE.apsHOffBegin;   /* add 'off' interscections */
		STATE.apsHorizEnd = STATE.apsHOffEnd;
	}
	
	if (!(usScanKind & SK_NODROPOUT))               /* if any kind of dropout */
	{
		if ((lQuadrant == 2) || (lQuadrant == 3))
		{
			STATE.apsVertBegin = STATE.apsVOnBegin; /* add 'on' interscections */
			STATE.apsVertEnd = STATE.apsVOnEnd;
		}
		else
		{
			STATE.apsVertBegin = STATE.apsVOffBegin; /* add 'off' interscections */
			STATE.apsVertEnd = STATE.apsVOffEnd;
		}
		
		if (usScanKind & SK_SMART)              /* if smart dropout */
		{
            Assert((STATE.lPoint - 1) <= (0xFFFF >> SC_CODESHFT));
			STATE.usScanTag = (uint16)(((STATE.lPoint - 1) << SC_CODESHFT) | lElementCode);

			while (lPts > 0)                    /* save control points */
			{
				STATE.afxXPoints[STATE.lPoint] = *pfxX;
				pfxX++;
				STATE.afxYPoints[STATE.lPoint] = *pfxY;
				pfxY++;
				STATE.lPoint++;
				lPts--;
				Assert (STATE.lPoint <= STATE.lElementPoints);
			}
		}
	}
}


/*********************************************************************/

/*      Add Scanline Intersection Functions                          */

/*********************************************************************/

/*  Sort a simple intersection into the horizontal scan list array  */

FS_PRIVATE void AddHorizSimpleScan(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	int16 *psBegin;                 /* pts to first array element */
	int16 *psEnd;                   /* pts past last element */
	int16 *psLead;                  /* leads psEnd walking backward */
	int16 sX;

/* printf("H(%li, %li)  ", lX, lY); */

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX <= STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY < STATE.lBoxTop);

	lY -= STATE.lBoxBottom;         /* normalize */
	psBegin = STATE.apsHorizBegin[lY];
	ppsEnd = &STATE.apsHorizEnd[lY];
	psEnd = *ppsEnd;
	(*ppsEnd)++;                    /* bump ptr for next time */
	
	psLead = psEnd - 1;
	sX = (int16)lX;
	
	while((psLead >= psBegin) && (*psLead > sX))
	{
		*psEnd-- = *psLead--;       /* make room */
	}
	*psEnd = sX;                    /* store new value */
}

/*********************************************************************/

/*  Sort a simple intersection into the vertical scan list array  */

FS_PRIVATE void AddVertSimpleScan(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	int16 *psBegin;                 /* pts to first array element */
	int16 *psEnd;                   /* pts past last element */
	int16 *psLead;                  /* leads psEnd walking backward */
	int16 sY;

/* printf("V(%li, %li)  ", lX, lY); */

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX < STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY <= STATE.lBoxTop);

	lX -= STATE.lBoxLeft;           /* normalize */
	psBegin = STATE.apsVertBegin[lX];
	ppsEnd = &STATE.apsVertEnd[lX];
	psEnd = *ppsEnd;
	(*ppsEnd)++;                    /* bump ptr for next time */

	psLead = psEnd - 1;
	sY = (int16)lY;
	
	while((psLead >= psBegin) && (*psLead > sY))
	{
		*psEnd-- = *psLead--;       /* make room */
	}
	*psEnd = sY;                    /* store new value */
}

/*********************************************************************/

/*  Sort a smart intersection into the horizontal scan list array  */

FS_PRIVATE void AddHorizSmartScan(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	uint32 *pulBegin;                /* pts to first array element */
	uint32 *pulEnd;                  /* pts past last element */
	uint32 *pulLead;                 /* leads pulEnd walking backward */
	int16 *psInsert;                /* new data insertion point */
	int16 sX;

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX <= STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY < STATE.lBoxTop);
	
	lY -= STATE.lBoxBottom;         /* normalize */
	pulBegin = (uint32*)STATE.apsHorizBegin[lY];
	ppsEnd = &STATE.apsHorizEnd[lY];
	pulEnd = (uint32*)*ppsEnd;
	(*ppsEnd) += 2;                 /* value & tag */

	pulLead = pulEnd - 1;
	sX = (int16)lX;

	while((pulLead >= pulBegin) && (*((int16*)pulLead) > sX))
	{
		*pulEnd-- = *pulLead--;     /* make room */
	}
	psInsert = (int16*)pulEnd;
	*psInsert = sX;                 /* store new value */
	psInsert++;
	*psInsert = STATE.usScanTag;    /* keep tag too */
}

/*********************************************************************/

/*  Sort a smart intersection into the vertical scan list array  */

FS_PRIVATE void AddVertSmartScan(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	uint32 *pulBegin;                /* pts to first array element */
	uint32 *pulEnd;                  /* pts past last element */
	uint32 *pulLead;                 /* leads pulEnd walking backward */
	int16 *psInsert;                /* new data insertion point */
	int16 sY;

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX < STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY <= STATE.lBoxTop);
	
	lX -= STATE.lBoxLeft;         /* normalize */
	pulBegin = (uint32*)STATE.apsVertBegin[lX];
	ppsEnd = &STATE.apsVertEnd[lX];
	pulEnd = (uint32*)*ppsEnd;
	(*ppsEnd) += 2;                 /* value & tag */

	pulLead = pulEnd - 1;
	sY = (int16)lY;

	while((pulLead >= pulBegin) && (*((int16*)pulLead) > sY))
	{
		*pulEnd-- = *pulLead--;     /* make room */
	}
	psInsert = (int16*)pulEnd;
	*psInsert = sY;                 /* store new value */
	psInsert++;
	*psInsert = STATE.usScanTag;    /* keep tag too */
}

/*********************************************************************/

/*  Add an intersection with banding                                 */

/*********************************************************************/

/*  Sort a simple intersection into the horizontal band list array  */

FS_PRIVATE void AddHorizSimpleBand(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	int16 *psBegin;                 /* pts to first array element */
	int16 *psEnd;                   /* pts past last element */
	int16 *psLead;                  /* leads psEnd walking backward */
	int16 sX;

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX <= STATE.lBoxRight);
	
	if ((lY >= STATE.lLoScanBand) && (lY < STATE.lHiScanBand))
	{
		lY -= STATE.lLoScanBand;    /* normalize */
		psBegin = STATE.apsHorizBegin[lY];
		ppsEnd = &STATE.apsHorizEnd[lY];
		psEnd = *ppsEnd;
		(*ppsEnd)++;                /* bump ptr for next time */
		
		psLead = psEnd - 1;
		sX = (int16)lX;

		while((psLead >= psBegin) && (*psLead > sX))
		{
			*psEnd-- = *psLead--;   /* make room */
		}
		*psEnd = sX;                /* store new value */
	}
}

/*********************************************************************/

/*  Sort a smart intersection into the horizontal band list array  */

FS_PRIVATE void AddHorizSmartBand(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	uint32 *pulBegin;               /* pts to first array element */
	uint32 *pulEnd;                 /* pts past last element */
	uint32 *pulLead;                /* leads pulEnd walking backward */
	int16 *psInsert;                /* new data insertion point */
	int16 sX;

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX <= STATE.lBoxRight);
	
	if ((lY >= STATE.lLoScanBand) && (lY < STATE.lHiScanBand))
	{
		lY -= STATE.lLoScanBand;    /* normalize */
		pulBegin = (uint32*)STATE.apsHorizBegin[lY];
		ppsEnd = &STATE.apsHorizEnd[lY];
		pulEnd = (uint32*)*ppsEnd;
		(*ppsEnd) += 2;             /* value & tag */

		pulLead = pulEnd - 1;
		sX = (int16)lX;

		while((pulLead >= pulBegin) && (*((int16*)pulLead) > sX))
		{
			*pulEnd-- = *pulLead--;  /* make room */
		}
		psInsert = (int16*)pulEnd;
		*psInsert = sX;              /* store new value */
		psInsert++;
		*psInsert = STATE.usScanTag; /* keep tag too */
	}
}


/*********************************************************************/

/*  When all contours have been scanned, fill in the bitmap          */

/*********************************************************************/

FS_PUBLIC int32 fsc_FillBitMap(
		PSTATE                          /* pointer to state variables */
		char *pchBitMap,                /* target memory */
		int32 lHiBand,                  /* top bitmap limit */
		int32 lLoBand,                  /* bottom bitmap limit */
		int32 lRowBytes,                /* bitmap bytes per row */
		int32 lOrgLoBand,               /* original low band row */
		uint16 usScanKind )             /* dropout control value */
{
	int32 lHeight;                      /* of scan band in pixels */
	int32 lIndex;                       /* array index */
	int32 lFirstScan;                   /* first scanline index */

	int16 sXOffset;                     /* bitmap box shift */
	int16 sXStart;                      /* on transition */
	int16 sXStop;                       /* off transition */
	
	uint32 *pulRow;                     /* row beginning pointer */
	uint32 ulBMPLongs;                  /* longs per bitmap */
	int32 lRowLongs;                    /* long words per row */
	int32 lErrCode;
	
	int16 **ppsHOnBegin;                /* for init speed */
	int16 **ppsHOnEnd;
	int16 **ppsHOffBegin;
			
	int16 *psHorizOn;
	int16 *psHorizOff;
	int16 *psHorizOnEnd;
	

/*  printf("%li : %li\n", lHiBand, lLoBand); */
	
	STATE.lHiBitBand = lHiBand;                 /* copy bit band limits */
	STATE.lLoBitBand = lLoBand;
	lHeight = STATE.lHiBitBand - STATE.lLoBitBand;
	
	STATE.lRowBytes = lRowBytes;                /* save bytes per row */
	lRowLongs = lRowBytes >> 2;                 /* long words per row */
	
	ulBMPLongs = (uint32)(lRowLongs * (int32)lHeight);
	pulRow = (uint32*)pchBitMap;                /* start at glyph top */
	lErrCode = fsc_ClearBitMap(ulBMPLongs, pulRow);
	if (lErrCode != NO_ERR) return lErrCode;

	sXOffset = (int16)STATE.lBoxLeft;
	
	lFirstScan = STATE.lHiBitBand - STATE.lLoScanBand - 1;
	ppsHOnBegin = &STATE.apsHOnBegin[lFirstScan];
	ppsHOffBegin = &STATE.apsHOffBegin[lFirstScan];
	ppsHOnEnd = &STATE.apsHOnEnd[lFirstScan];
						
/*  now go through the bitmap from top to bottom */

	for (lIndex = 0; lIndex < lHeight; lIndex++)
	{
		psHorizOn = *ppsHOnBegin;
		ppsHOnBegin--;
		psHorizOff = *ppsHOffBegin;
		ppsHOffBegin--;
		psHorizOnEnd = *ppsHOnEnd;
		ppsHOnEnd--;
				
		Assert(psHorizOnEnd <= psHorizOff);
		Assert(psHorizOnEnd - psHorizOn == STATE.apsHOffEnd[lFirstScan - lIndex] - psHorizOff);

		while (psHorizOn < psHorizOnEnd)
		{
			sXStart = *psHorizOn - sXOffset;
			psHorizOn += STATE.sIxSize;
			sXStop = *psHorizOff - sXOffset;
			psHorizOff += STATE.sIxSize;

			if (sXStart < sXStop)                   /* positive run */
			{
				lErrCode = fsc_BLTHoriz(sXStart, sXStop - 1, pulRow);
			}
			else if (sXStart > sXStop)              /* negative run */
			{
				lErrCode = fsc_BLTHoriz(sXStop, sXStart - 1, pulRow);
			}
			if (lErrCode != NO_ERR) return lErrCode;
		}
		pulRow += lRowLongs;                        /* next row */
	}
	
/* if doing dropout control, do it now */

	if (!(usScanKind & SK_NODROPOUT))               /* if any kind of dropout */
	{
		lErrCode = LookForDropouts(ASTATE pchBitMap, usScanKind);
		if (lErrCode != NO_ERR) return lErrCode;
		
		if (lOrgLoBand != STATE.lLoScanBand)        /* if fast banding & dropout */
		{
			pulRow -= lRowLongs;                    /* back to overscan row */
			pulRow -= lRowLongs;                    /* back to low row */
			lErrCode = fsc_BLTCopy (pulRow, STATE.pulLastRow, lRowLongs);
			if (lErrCode != NO_ERR) return lErrCode;

			STATE.lLastRowIndex = STATE.lLoBitBand + 1; /* save row ID */
		}
	}
	return NO_ERR;
}

/*********************************************************************/

/*      Dropout Control Functions                                    */

/*********************************************************************/
	
FS_PRIVATE int32 LookForDropouts(
		PSTATE                      /* pointer to state variables  */
		char *pchBitMap,
		uint16 usScanKind )         /* dropout control value */
{
	int16 **ppsHOnBegin;            /* for init speed */
	int16 **ppsHOnEnd;
	int16 **ppsHOffBegin;
			
	int16 *psHorizOn;
	int16 *psHorizOff;
	int16 *psHorizOnEnd;
	
	int16 **ppsVOnBegin;            /* for init speed */
	int16 **ppsVOnEnd;
	int16 **ppsVOffEnd;
			
	int16 *psVertOn;
	int16 *psVertOff;
	int16 *psVertOnBegin;

	int32 lHeight;
	int32 lWidth;
	int32 lIndex;                   /* array index */
	int32 lFirstScan;               /* first scanline index */
	
	int32 lErrCode;

/*  Check horizontal scan lines for dropouts  */
	
	lHeight = STATE.lHiBitBand - STATE.lLoBitBand;
	lFirstScan = STATE.lHiBitBand - STATE.lLoScanBand - 1;
	ppsHOnBegin = &STATE.apsHOnBegin[lFirstScan];
	ppsHOffBegin = &STATE.apsHOffBegin[lFirstScan];
	ppsHOnEnd = &STATE.apsHOnEnd[lFirstScan];
		
	for (lIndex = 0; lIndex < lHeight; lIndex++)
	{
		psHorizOn = *ppsHOnBegin;
		ppsHOnBegin--;
		psHorizOff = *ppsHOffBegin;
		ppsHOffBegin--;
		psHorizOnEnd = *ppsHOnEnd;
		ppsHOnEnd--;
		
		while (psHorizOn < psHorizOnEnd)
		{
			if (*psHorizOn == *psHorizOff)  /* zero length run */
			{
				lErrCode = DoHorizDropout(ASTATE psHorizOn, psHorizOff,
										 STATE.lHiBitBand - lIndex - 1,
										 pchBitMap,
										 usScanKind);
				if (lErrCode != NO_ERR) return lErrCode;
			}
			psHorizOn += STATE.sIxSize;
			psHorizOff += STATE.sIxSize;
		}
	}
		
/*  Check vertical scan lines for dropouts  */
	
	lWidth = STATE.lBoxRight - STATE.lBoxLeft;
	ppsVOnBegin = STATE.apsVOnBegin;
	ppsVOnEnd = STATE.apsVOnEnd;
	ppsVOffEnd = STATE.apsVOffEnd;
	
	for (lIndex = 0; lIndex < lWidth; lIndex++)
	{
		psVertOnBegin = *ppsVOnBegin;
		ppsVOnBegin++;
		psVertOn = *ppsVOnEnd - STATE.sIxSize;  /* start at end (glyph top) */
		ppsVOnEnd++;
		psVertOff = *ppsVOffEnd - STATE.sIxSize;
		ppsVOffEnd++;
		
		while (psVertOn >= psVertOnBegin)       /* from top to bottom */
		{
			if (*psVertOn == *psVertOff)        /* zero length run */
			{
				lErrCode = DoVertDropout(ASTATE psVertOn, psVertOff,
										 STATE.lBoxLeft + lIndex,
										 pchBitMap, usScanKind);
				if (lErrCode != NO_ERR) return lErrCode;
			}
			psVertOn -= STATE.sIxSize;
			psVertOff -= STATE.sIxSize;
		}
	}
	return NO_ERR;
}


/*********************************************************************/

FS_PRIVATE int32 DoHorizDropout(
		PSTATE                  /* pointer to state variables */
		int16 *psOn,            /* pointer to on intersection */
		int16 *psOff,           /* pointer to off intersection */
		int32 lYDrop,           /* y coord of dropout */
		char *pchBitMap,        /* target memory */
		uint16 usScanKind )     /* dropout control value */
{
	int32 lXDrop;                                   /* x coord of dropout */
	int32 lCross;                                   /* scanline crossings */
	F26Dot6 fxX1, fxX2;                             /* for smart dropout */
	uint16 usOnTag, usOffTag;                       /* element info */
	int16 sOnPt, sOffPt;                            /* element list index */
	F26Dot6 (*pfnOn)(int32, F26Dot6*, F26Dot6*);    /* on callback */
	F26Dot6 (*pfnOff)(int32, F26Dot6*, F26Dot6*);   /* off callback */

	lXDrop = (int32)*psOn;
	
/*  if stub control on, check for stubs  */

	if (usScanKind & SK_STUBS)
	{
		lCross = HorizCrossings(ASTATE lXDrop, lYDrop + 1);
		lCross += VertCrossings(ASTATE lXDrop - 1, lYDrop + 1);
		lCross += VertCrossings(ASTATE lXDrop, lYDrop + 1);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation above */
		}
		
		lCross = HorizCrossings(ASTATE lXDrop, lYDrop - 1);
		lCross += VertCrossings(ASTATE lXDrop - 1, lYDrop);
		lCross += VertCrossings(ASTATE lXDrop, lYDrop);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation below */
		}
	}

/*  passed stub control, now check pixels left and right  */

	if (lXDrop > STATE.lBoxLeft)                /* if pixel to left */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop - 1, lYDrop) != 0L)
		{
			return NO_ERR;                      /* no dropout needed */
		}
	}
	if (lXDrop < STATE.lBoxRight)               /* if pixel to right */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop) != 0L)
		{
			return NO_ERR;                      /* no dropout needed */
		}
	}

/*  no pixels left or right, now determine bit placement  */

	if (usScanKind & SK_SMART)
	{
		usOnTag = (uint16)*(psOn+1);
		sOnPt = (int16)(usOnTag >> SC_CODESHFT);
		pfnOn = STATE.pfnHCallBack[usOnTag & SC_CODEMASK];
		fxX1 = pfnOn(lYDrop, &STATE.afxXPoints[sOnPt], &STATE.afxYPoints[sOnPt]);
		
		usOffTag = (uint16)*(psOff+1);
		sOffPt = (int16)(usOffTag >> SC_CODESHFT);
		pfnOff = STATE.pfnHCallBack[usOffTag & SC_CODEMASK];
		fxX2 = pfnOff(lYDrop, &STATE.afxXPoints[sOffPt], &STATE.afxYPoints[sOffPt]);
		
		lXDrop = (int32)((fxX1 + fxX2 - 1) >> (SUBSHFT + 1));     /* average */
	}
	else                                        /* simple dropout */
	{
		lXDrop--;                               /* always to the left */
	}
	
	if (lXDrop < STATE.lBoxLeft)                /* confine to bounding box */
	{
		lXDrop = STATE.lBoxLeft;
	}
	if (lXDrop >= STATE.lBoxRight)
	{
		lXDrop = STATE.lBoxRight - 1L;
	}

	return SetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop);  /* turn on dropout pix */
}


/*********************************************************************/

FS_PRIVATE int32 DoVertDropout(
		PSTATE                      /* pointer to state variables */
		int16 *psOn,                /* pointer to on intersection */
		int16 *psOff,               /* pointer to off intersection */
		int32 lXDrop,               /* x coord of dropout */
		char *pchBitMap,            /* target memory descriptor */
		uint16 usScanKind )         /* dropout control value */
{
	int32 lYDrop;                                 /* y coord of dropout */
	int32 lCross;                                 /* scanline crossings */
	F26Dot6 fxY1, fxY2;                           /* for smart dropout */
	uint16 usOnTag, usOffTag;                     /* element info */
	int16 sOnPt, sOffPt;                          /* element list index */
	F26Dot6 (*pfnOn)(int32, F26Dot6*, F26Dot6*);  /* on callback */
	F26Dot6 (*pfnOff)(int32, F26Dot6*, F26Dot6*); /* off callback */
	
	lYDrop = (int32)*psOn;

	if ((lYDrop < STATE.lLoBitBand) || (lYDrop > STATE.lHiBitBand))
	{
		return NO_ERR;                          /* quick return for outside band */
	}

/*  if stub control on, check for stubs  */

	if (usScanKind & SK_STUBS)
	{
		lCross = VertCrossings(ASTATE lXDrop - 1, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop, lYDrop - 1);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation to left */
		}
		
		lCross = VertCrossings(ASTATE lXDrop + 1, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop + 1, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop + 1, lYDrop - 1);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation to right */
		}
	}

/*  passed stub control, now check pixels below and above  */

	if (lYDrop > STATE.lBoxBottom)                  /* if pixel below */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop - 1) != 0L)
		{
			return NO_ERR;                          /* no dropout needed */
		}
	}
	if (lYDrop < STATE.lBoxTop)                     /* if pixel above */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop) != 0L)
		{
			return NO_ERR;                          /* no dropout needed */
		}
	}

/*  no pixels above or below, now determine bit placement  */
	
	if (usScanKind & SK_SMART)
	{
		usOnTag = (uint16)*(psOn+1);
		sOnPt = (int16)(usOnTag >> SC_CODESHFT);
		pfnOn = STATE.pfnVCallBack[usOnTag & SC_CODEMASK];
		fxY1 = pfnOn(lXDrop, &STATE.afxXPoints[sOnPt], &STATE.afxYPoints[sOnPt]);
		
		usOffTag = (uint16)*(psOff+1);
		sOffPt = (int16)(usOffTag >> SC_CODESHFT);
		pfnOff = STATE.pfnVCallBack[usOffTag & SC_CODEMASK];
		fxY2 = pfnOff(lXDrop, &STATE.afxXPoints[sOffPt], &STATE.afxYPoints[sOffPt]);
		
		lYDrop = (int32)((fxY1 + fxY2 - 1) >> (SUBSHFT + 1));     /* average */
	}
	else                                        /* simple dropout */
	{
		lYDrop--;                               /* always below */
	}
	
	if (lYDrop < STATE.lBoxBottom)              /* confine to bounding box */
	{
		lYDrop = STATE.lBoxBottom;
	}
	if (lYDrop >= STATE.lBoxTop)
	{
		lYDrop = STATE.lBoxTop - 1L;
	}
		
	if ((lYDrop >= STATE.lLoBitBand) && (lYDrop < STATE.lHiBitBand))
	{
		return SetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop);  /* turn on dropout pix */
	}
	return NO_ERR;
}


/*********************************************************************/

/*  Count contour crossings of a horizontal scan line segment  */

FS_PRIVATE int32 HorizCrossings(
		PSTATE                          /* pointer to state variables */
		int32 lX,
		int32 lY )
{
	int32 lCrossings;
	int32 lIndex;
	
	int16 *psOn;
	int16 *psOff;
	int16 *psOnEnd;
	int16 sX;
	
	if ((lY < STATE.lLoScanBand) || (lY >= STATE.lHiScanBand))
	{
		return 0;                       /* if outside the scan region */
	}
	
	lCrossings = 0;
	lIndex = lY - STATE.lLoScanBand;
	psOn = STATE.apsHOnBegin[lIndex];
	psOff = STATE.apsHOffBegin[lIndex];
	psOnEnd = STATE.apsHOnEnd[lIndex];
	sX = (int16)lX;
	
	while (psOn < psOnEnd)
	{
		if (*psOn == sX)
		{
			lCrossings++;
		}
		psOn += STATE.sIxSize;
		
		if (*psOff == sX)
		{
			lCrossings++;
		}
		psOff += STATE.sIxSize;
	}
	return lCrossings;
}


/*********************************************************************/

/*  Count contour crossings of a vertical scan line segment  */

FS_PRIVATE int32 VertCrossings(
		PSTATE                          /* pointer to state variables */
		int32 lX,
		int32 lY )
{
	int32 lCrossings;
	int32 lIndex;
	
	int16 *psOn;
	int16 *psOff;
	int16 *psOnEnd;
	int16 sY;
	
	if ((lX < STATE.lBoxLeft) || (lX >= STATE.lBoxRight))
	{
		return 0;                       /* if outside the bitmap */
	}
	
	lCrossings = 0;
	lIndex = lX - STATE.lBoxLeft;
	psOn = STATE.apsVOnBegin[lIndex];
	psOff = STATE.apsVOffBegin[lIndex];
	psOnEnd = STATE.apsVOnEnd[lIndex];
	sY = (int16)lY;
	
	while (psOn < psOnEnd)
	{
		if (*psOn == sY)
		{
			lCrossings++;
		}
		psOn += STATE.sIxSize;
		
		if (*psOff == sY)
		{
			lCrossings++;
		}
		psOff += STATE.sIxSize;
	}
	return lCrossings;
}
		

/****************************************************************************/

/*              Get a pixel using absolute coordinates                      */

/*  When banding with dropout control, this routine uses the last low row   */
/*  of the previous bitmap when possible.                                   */

FS_PRIVATE uint32 GetBitAbs(
		PSTATE                              /* pointer to state variables */
		char *pchBitMap,
		int32 lX,
		int32 lY )
{
	uint32 *pulRow;                         /* bitmap row pointer */

	Assert(lX >= STATE.lBoxLeft);           /* trap unreasonable values */
	Assert(lX < STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY < STATE.lBoxTop);

	if ((lY < STATE.lHiBitBand) && (lY >= STATE.lLoBitBand))  /* if within the bitmap */
	{
		pulRow = (uint32*)(pchBitMap + ((STATE.lHiBitBand - 1 - lY) * STATE.lRowBytes));
		return fsc_GetBit(lX - STATE.lBoxLeft, pulRow);       /* read the bitmap */
	}
	if (lY == STATE.lLastRowIndex)          /* if saved from last band */
	{
		return fsc_GetBit(lX - STATE.lBoxLeft, STATE.pulLastRow);
	}
	return(0L);                             /* outside bitmap doesn't matter */
}


/*********************************************************************/

/*  Set a pixel using absolute coordinates  */

FS_PRIVATE int32 SetBitAbs(
		PSTATE                              /* pointer to state variables */
		char *pchBitMap,
		int32 lX,
		int32 lY )
{
	uint32 *pulRow;                         /* bitmap row pointer */
	
	Assert(lX >= STATE.lBoxLeft);           /* trap unreasonable values */
	Assert(lX < STATE.lBoxRight);
	Assert(lY >= STATE.lLoBitBand);
	Assert(lY < STATE.lHiBitBand);
	
	pulRow = (uint32*)(pchBitMap + ((STATE.lHiBitBand - 1 - lY) * STATE.lRowBytes));
	
	return fsc_SetBit(lX - STATE.lBoxLeft, pulRow);
}


/*********************************************************************/

/*      Gray Scale Pass Through Functions                            */

/*********************************************************************/

FS_PUBLIC int32 fsc_ScanClearBitMap (
		uint32 ulCount,                     /* longs per bmp */
		uint32* pulBitMap                   /* bitmap ptr caste long */
)
{
	return fsc_ClearBitMap(ulCount, pulBitMap);
}


/*********************************************************************/

FS_PUBLIC int32 fsc_ScanCalcGrayRow(
		GrayScaleParam* pGSP                /* pointer to param block */
)
{
	return fsc_CalcGrayRow(pGSP);
}

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\scmemory.c ===
/*********************************************************************

      scmemory.c -- New Scan Converter Memory Managment Module

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       6/10/93  deanb   assert.h and stdio.h removed
      10/28/92  deanb   reentrant params renamed
      10/14/92  deanb   New fsc_SetupMem parameters
      10/09/92  deanb   Reentrant
      10/08/92  deanb   Separate Horiz/Vert memory pools
       9/10/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "scglobal.h"            /* structures & constants */
#include    "scmemory.h"            /* for own function prototypes */


/**********************************************************************

    Workspace memory is divided into two pools, identified here as
    HMem (horizontal memory) and VMem (vertical memory).  HMem is
    always used, and contains horizontal scan array lists.  VMem is 
    used only when dropout control is enabled, and contains the 
    vertical scan array lists and the contour elements used to compute 
    subpixel intersections for smart dropout control.  This division 
    into two pools was done, in part, for backward compatiblity with 
    the Apple rasterizer.  It allows a client to force dropout control
    off by setting the allocated size of VMem to zero.

**********************************************************************/
    
/*********************************************************************/

/*      Export Functions      */

/*********************************************************************/

FS_PUBLIC void fsc_SetupMem( 
        PSTATE                           /* pointer to state variables */
        char* pchHBuffer,                /* pointer to horiz workspace */
        int32 lHMemSize,                 /* size of horiz workspace */
        char* pchVBuffer,                /* pointer to vert workspace */
        int32 lVMemSize )                /* size of vert workspace */
{
    STATE.pchHNextAvailable = pchHBuffer;
    STATE.pchHWorkSpaceEnd = pchHBuffer + lHMemSize;
    
    STATE.pchVNextAvailable = pchVBuffer;
    STATE.pchVWorkSpaceEnd = pchVBuffer + lVMemSize;
}


/********************************************************************/

FS_PUBLIC void *fsc_AllocHMem( 
        PSTATE                         /* pointer to state variables  */
        int32 lSize )                  /* requested size in bytes */
{
    void *pvTemp;
    
/* printf("H: %ui   ", lSize); */

    pvTemp = (void*)STATE.pchHNextAvailable;
    ALIGN(voidPtr, lSize); 
    STATE.pchHNextAvailable += lSize;
    
    Assert(STATE.pchHNextAvailable <= STATE.pchHWorkSpaceEnd);
    return pvTemp;
}

/********************************************************************/

FS_PUBLIC void *fsc_AllocVMem( 
        PSTATE                         /* pointer to state variables */
        int32 lSize )                  /* requested size in bytes */
{
    void *pvTemp;

/* printf("V: %ui   ", lSize); */
    
    pvTemp = (void*)STATE.pchVNextAvailable;
    ALIGN(voidPtr, lSize); 
    STATE.pchVNextAvailable += lSize;
    
    Assert(STATE.pchVNextAvailable <= STATE.pchVWorkSpaceEnd);
    return pvTemp;
}

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\scmemory.h ===
/*********************************************************************

      scmemory.h -- Memory Module Exports

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       3/19/93 deanb    size_t replaced with int32
      10/14/92 deanb    New SetupMem parameters
      10/09/92 deanb    PSTP added
      10/08/92 deanb    Horiz/Vert memory alloc's
       9/09/92 deanb    Alloc param int32  
       9/08/92 deanb    Setup with WorkSpace pointer 
       8/21/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupMem( 
        PSTATE              /* pointer to state variables */
        char*,              /* pointer to horiz workspace */
        int32 ,             /* size of horiz workspace */
        char*,              /* pointer to vert workspace */
        int32               /* size of vert workspace */
);

FS_PUBLIC void *fsc_AllocHMem( 
        PSTATE              /* pointer to state variables */
        int32               /* allocate from horiz memory pool */
);

FS_PUBLIC void *fsc_AllocVMem( 
        PSTATE              /* pointer to state variables */
        int32               /* allocate from vert memory pool */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\scspline.h ===
/*********************************************************************

	  scspline.h -- Spline Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   3/19/93 deanb    size_t replaced with int32
	  10/28/92 deanb    reentrant params renamed, mem req redone
	  10/09/92 deanb    PSTATE added
	   9/25/92 deanb    include scan control type 
	   9/09/92 deanb    GetSplineElemSize returns size_t 
	   9/08/92 deanb    MAXSPLINELENGTH added 
	   8/17/92 deanb    PowerOf2 moved to math 
	   7/23/92 deanb    EvaluateSpline replaced with CalcSpline + PowerOf2 
	   4/09/92 deanb    New types again 
	   3/16/92 deanb    New types 
	   1/14/92 deanb    First cut 

*********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupSpline ( PSTATE0 );

FS_PUBLIC int32 fsc_CalcSpline( 
		PSTATE          /* pointer to state varables */
		F26Dot6,        /* start point x coordinate */
		F26Dot6,        /* start point y coordinate */
		F26Dot6,        /* control point x coordinate */
		F26Dot6,        /* control point y coordinate */
		F26Dot6,        /* ending x coordinate */
		F26Dot6,        /* ending y coordinate */
		uint16          /* scan control type */
);

/********************************************************************/

/*              Export Definitions                                  */

/********************************************************************/

#define MAXSPLINELENGTH     3200        /* calculation overflow limit */

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\scentry.c ===
/*********************************************************************

	  scentry.c -- New Scan Converter NewScan Module

	  (c) Copyright 1992-1997  Microsoft Corp.  All rights reserved.

	  10/14/97  claudebe    accessing unitialized memory
	   1/31/95  deanb       added fsc_GetCoords function
	   8/04/94  deanb       State initialized to more it out of bss
	   8/24/93  deanb       flatcount fix to reversal detection
	   8/10/93  deanb       gray scale support routines added
	   6/22/93  deanb       all black bounding box, (0,0) for null glyph
	   6/11/93  gregh       Removed ONCURVE definition
	   6/11/93  deanb       if HiBand <= LoBand do entire bitmap
	   6/10/93  deanb       fsc_Initialize added, stdio & assert gone
	   4/06/92  deanb       CheckContour removed
	   3/19/92  deanb       ScanArrays rather than lists
	  12/22/92  deanb       MultDivide -> LongMulDiv; Rectangle -> Rect
	  12/21/92  deanb       interface types aligned with rasterizer
	  12/11/92  deanb       fserror.h imported, new error codes
	  11/30/92  deanb       WorkSpace renamed WorkScan
	  11/04/92  deanb       remove duplicate points function added
	  10/28/92  deanb       memory requirement calculation reworked
	  10/19/92  deanb       bad contours ignored rather than error'd
	  10/16/92  deanb       first contour point off curve fix
	  10/13/92  deanb       rect.bounds correction
	  10/12/92  deanb       reentrant State implemented
	  10/08/92  deanb       reworked for split workspace
	  10/05/92  deanb       global ListMemory replace with stListSize 
	   9/25/92  deanb       scankind included in line/spline/endpoint calls 
	   9/10/92  deanb       dropout coding begun 
	   9/08/92  deanb       MAXSPLINELENGTH now imported from scspline.h 
	   8/18/92  deanb       New i/f for dropout control, contour elems 
	   7/28/92  deanb       Recursive calls for up/down & left/right 
	   7/23/92  deanb       EvaluateSpline included 
	   7/17/92  deanb       Included EvaluateLine 
	   7/13/92  deanb       Start/End point made SHORT 
	   6/01/92  deanb       fsc_FillBitMap debug switch added 
	   5/08/92  deanb       reordered includes for precompiled headers 
	   4/27/92  deanb       Splines coded 
	   4/09/92  deanb       New types 
	   4/06/92  deanb       rectBounds calc corrected 
	   3/30/92  deanb       MinMax calc added to MeasureContour 
	   3/24/92  deanb       GetWorkspaceSize coded 
	   3/23/92  deanb       First cut 
 
**********************************************************************/

/*********************************************************************/

/*        Imports                                                    */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types  */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for LongMulDiv */

#include    "scglobal.h"            /* structures & constants */
#include    "scgray.h"              /* gray scale param block */
#include    "scspline.h"            /* spline evaluation */
#include    "scline.h"              /* line evaluation */
#include    "scendpt.h"             /* for init and contour list */
#include    "scanlist.h"            /* for init and bitmap */
#include    "scmemory.h"            /* for setup mem */
#include    "scentry.h"             /* for own function prototypes */

/*********************************************************************/
											 
/*      Global state structure                                       */

/*********************************************************************/

#ifndef FSCFG_REENTRANT
	
FS_PUBLIC StateVars   State = {0};  /* global static:  available to all */

#endif

/*********************************************************************/
											 
/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE int32 FindExtrema(ContourList*, GlyphBitMap*);

FS_PRIVATE int32 EvaluateSpline(PSTATE F26Dot6, F26Dot6, F26Dot6, F26Dot6, F26Dot6, F26Dot6, uint16 );


/*********************************************************************/
											 
/*      Function Exports                                             */

/*********************************************************************/

/*      Initialization Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_Initialize()
{
	fsc_InitializeScanlist();               /* scanlist calls to bitmap */
}


/*********************************************************************/

/*  Remove duplicated points from contour data                       */

/*  This was previously done in sc_FindExtrema of sc.c,              */
/*  but was pulled out to avoid having fsc_MeasureGlyph              */
/*  make changes to the contour list data structure.                 */

/*********************************************************************/

FS_PUBLIC int32 fsc_RemoveDups( 
		ContourList* pclContour )           /* glyph outline */
{
	uint16 usContour;                       /* contour limit */
	int16 sStartPt, sEndPt;                 /* coutour index limits */
	int16 sPt;                              /* point index */
	int16 s;                                /* index for list collapse */
	F26Dot6 *pfxX1, *pfxY1;                 /* leading point */
	F26Dot6 fxX2, fxY2;                     /* trailing point */

	for (usContour = 0; usContour < pclContour->usContourCount; usContour++)
	{
		sStartPt = pclContour->asStartPoint[usContour];
		sEndPt = pclContour->asEndPoint[usContour];
		
		pfxX1 = &(pclContour->afxXCoord[sStartPt]); 
		pfxY1 = &(pclContour->afxYCoord[sStartPt]); 
					
		for (sPt = sStartPt; sPt < sEndPt; ++sPt)
		{
			fxX2 = *pfxX1;                          /* check next pair */
			pfxX1++;
			fxY2 = *pfxY1;
			pfxY1++;
			
			if ((*pfxX1 == fxX2) && (*pfxY1 == fxY2))   /* if duplicate */
			{
				for(s = sPt; s > sStartPt; s--)     /* s = index of point to be removed */
				{
					pclContour->afxXCoord[s] = pclContour->afxXCoord[s - 1];
					pclContour->afxYCoord[s] = pclContour->afxYCoord[s - 1];
					pclContour->abyOnCurve[s] = pclContour->abyOnCurve[s - 1];
				}
				sStartPt++;                         /* advance start past dup */
				pclContour->asStartPoint[usContour] = sStartPt;
				pclContour->abyOnCurve[sPt + 1] |= ONCURVE; /* dup'd pt must be on curve */
			}
		}
		
		/* now pfxX1 and pfxY1 point to end point coordinates */

		if (sStartPt != sEndPt)                     /* finished if single point */
		{
			fxX2 = pclContour->afxXCoord[sStartPt];
			fxY2 = pclContour->afxYCoord[sStartPt];
								
			if ((*pfxX1 == fxX2) && (*pfxY1 == fxY2))   /* if start = end */
			{
				pclContour->asStartPoint[usContour]++;
				pclContour->abyOnCurve[sEndPt] |= ONCURVE;  /* dup'd pt must be on curve */
			}
		}
	}
	return NO_ERR;
}


/*********************************************************************/

/*  Calculate the amount of workspace needed to scan convert         */
/*  a given glyph into a given bitmap.  Get per intersection and     */
/*  per scanline size info from ScanList module.                     */

/*********************************************************************/

FS_PUBLIC int32 fsc_MeasureGlyph( 
		ContourList* pclContour,        /* glyph outline */
		GlyphBitMap* pbmpBitMap,        /* to return bounds */
		WorkScan* pwsWork,              /* to return values */
		uint16 usScanKind,              /* dropout control value */
		uint16 usRoundXMin,              /* for gray scale alignment */
		int16 sBitmapEmboldeningHorExtra,
		int16 sBitmapEmboldeningVertExtra )
{
	uint16 usCont;                      /* contour index */
	int16 sPt;                          /* point index */
	int16 sStart, sEnd;                 /* start and end point of contours */
	int16 sOrgDir;                      /* original contour direction */
	int16 sDir;                         /* current contour direction */
	int16 sFlatCount;                   /* for contours starting flat */
	int32 lVScanCount;                  /* total vertical scan lines */
	int32 lHScanCount;                  /* total horizontal scan lines */
	int32 lTotalHIx;
	int32 lTotalVIx;
	int32 lElementCount;                /* total element point estimate */
	int32 lDivide;                      /* spline element point counter */
	int32 lErrCode;    
	
	F26Dot6 fxX1, fxX2;                 /* x coord endpoints */
	F26Dot6 fxY1, fxY2;                 /* y coord endpoints */
	F26Dot6 *pfxXCoord, *pfxYCoord;     /* for fast point array access */
	F26Dot6 fxAbsDelta;                 /* for element count check */
	uint8 byF1, byF2;                   /* oncurve flag values */
	uint8 *pbyFlags;                    /* for element count check */

	PRevRoot prrRoots;                  /* reversal list roots structure */

	
	lErrCode = FindExtrema(pclContour, pbmpBitMap); /* calc bounding box */
	if (lErrCode != NO_ERR) return lErrCode;

	pbmpBitMap->rectBounds.left &= -((int32)usRoundXMin);   /* mask off low n bits */

	/* bitmap emboldening by 2% + 1 pixel horizontally, 2% vertically */
	if ((pbmpBitMap->rectBounds.top != pbmpBitMap->rectBounds.bottom) && (pbmpBitMap->rectBounds.left != pbmpBitMap->rectBounds.right))
	{
 		// we don't want to increase the size of the bitmap on a empty glyph
		if (sBitmapEmboldeningHorExtra > 0)
		{
			pbmpBitMap->rectBounds.right += sBitmapEmboldeningHorExtra;
		}
		else
		{
			pbmpBitMap->rectBounds.left += sBitmapEmboldeningHorExtra;
		}
		if (sBitmapEmboldeningVertExtra > 0)
		{
			pbmpBitMap->rectBounds.bottom -= (sBitmapEmboldeningVertExtra);
		}
		else
		{
			pbmpBitMap->rectBounds.top -= (sBitmapEmboldeningVertExtra);
		}
	}

	prrRoots = fsc_SetupRevRoots(pwsWork->pchRBuffer, pwsWork->lRMemSize);
	lElementCount = 0;                  /* smart point counter */
	
	for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
	{
		sStart = pclContour->asStartPoint[usCont];
		sEnd = pclContour->asEndPoint[usCont];
		if (sStart == sEnd)
		{
			continue;                               /* for anchor points */
		}

/* check contour Y values for direction reversals */

		fxY1 = pclContour->afxYCoord[sEnd];         /* start by closing */
		pfxYCoord = &pclContour->afxYCoord[sStart];

		sPt = sStart;
		sDir = 0;                                   /* starting dir unknown */
		sFlatCount = 0;
		while ((sDir == 0) && (sPt <= sEnd))
		{
			fxY2 = *pfxYCoord++;
			if (fxY2 > fxY1)                        /* find first up or down */
			{
				sDir = 1;
			}
			else if (fxY2 < fxY1)
			{
				sDir = -1;
			}
			else
			{
				sFlatCount++;                       /* countour starts flat */
			}
			fxY1 = fxY2;
			sPt++;
		}
		sOrgDir = sDir;                             /* save original ep check */

		while (sPt <= sEnd)
		{
			fxY2 = *pfxYCoord++;
			if (sDir == 1)
			{
				if (fxY2 <= fxY1)                   /* = is for endpoint cases */
				{
					fsc_AddYReversal (prrRoots, fxY1, 1);
					sDir = -1;
				}
			}
			else    /* if sDir == -1 */
			{
				if (fxY2 >= fxY1)                   /* = is for endpoint cases */
				{
					fsc_AddYReversal (prrRoots, fxY1, -1);
					sDir = 1;
				}
			}
			fxY1 = fxY2;                            /* next segment */
			sPt++;
		}
								
		while (sFlatCount > 0)                      /* if contour started flat */
		{
			if (sDir == 0)                          /* if completely flat */
			{
				sDir = 1;                           /* then pick a direction */
				sOrgDir = 1;
			}
			fsc_AddYReversal (prrRoots, fxY1, sDir); /* add one per point */
			sDir = -sDir;
			sFlatCount--;
		}
		if (sOrgDir != sDir)                        /* if endpoint reverses */
		{
			fsc_AddYReversal (prrRoots, fxY1, sDir); /* then balance up/down */
		}

/* if doing dropout control, check contour X values for direction reversals */

		if (!(usScanKind & SK_NODROPOUT))           /* if any kind of dropout */
		{
			fxX1 = pclContour->afxXCoord[sEnd];     /* start by closing */
			pfxXCoord = &pclContour->afxXCoord[sStart];

			sPt = sStart;
			sDir = 0;                               /* starting dir unknown */
			sFlatCount = 0;
			while ((sDir == 0) && (sPt <= sEnd))
			{
				fxX2 = *pfxXCoord++;
				if (fxX2 > fxX1)                    /* find first up or down */
				{
					sDir = 1;
				}
				else if (fxX2 < fxX1)
				{
					sDir = -1;
				}
				else
				{
					sFlatCount++;                   /* countour starts flat */
				}
				fxX1 = fxX2;
				sPt++;
			}
			sOrgDir = sDir;                         /* save original ep check */

			while (sPt <= sEnd)
			{
				fxX2 = *pfxXCoord++;
				if (sDir == 1)
				{
					if (fxX2 <= fxX1)               /* = is for endpoint cases */
					{
						fsc_AddXReversal (prrRoots, fxX1, 1);
						sDir = -1;
					}
				}
				else    /* if sDir == -1 */
				{
					if (fxX2 >= fxX1)               /* = is for endpoint cases */
					{
						fsc_AddXReversal (prrRoots, fxX1, -1);
						sDir = 1;
					}
				}
				fxX1 = fxX2;                        /* next segment */
				sPt++;
			}
									
			while (sFlatCount > 0)                  /* if contour started flat */
			{
				if (sDir == 0)                      /* if completely flat */
				{
					sDir = 1;                       /* then pick a direction */
					sOrgDir = 1;
				}
				fsc_AddXReversal (prrRoots, fxX1, sDir); /* add one per point */
				sDir = -sDir;
				sFlatCount--;
			}
			if (sOrgDir != sDir)                    /* if endpoint reverses */
			{
				fsc_AddXReversal (prrRoots, fxX1, sDir); /* then balance up/down */
			}

			if (usScanKind & SK_SMART)              /* if smart dropout control */
			{                                       /* estimate the elem point count */
				fxX1 = pclContour->afxXCoord[sEnd];
				fxY1 = pclContour->afxYCoord[sEnd];
				byF1 = pclContour->abyOnCurve[sEnd];
				pfxXCoord = &pclContour->afxXCoord[sStart];
				pfxYCoord = &pclContour->afxYCoord[sStart];
				pbyFlags = &pclContour->abyOnCurve[sStart];

				lElementCount += (uint32)(sEnd - sStart) + 2L;  /* 1/pt + 1/contour */

				for (sPt = sStart; sPt <= sEnd; sPt++)
				{
					fxX2 = *pfxXCoord++;
					fxY2 = *pfxYCoord++;
					byF2 = *pbyFlags++;

					if (((byF1 & byF2) & ONCURVE) == 0) /* if this is a spline */
					{
						if (((byF1 | byF2) & ONCURVE) == 0)
						{
							lElementCount++;            /* +1 for midpoint */
						}
								
						if (FXABS(fxX2 - fxX1) > FXABS(fxY2 - fxY1))
						{
							fxAbsDelta = FXABS(fxX2 - fxX1);
						}
						else
						{
							fxAbsDelta = FXABS(fxY2 - fxY1);
						}
						lDivide = 0;
						while (fxAbsDelta > (MAXSPLINELENGTH / 2))
						{
							lDivide++;
							lDivide <<= 1;
							fxAbsDelta >>= 1;
						}
						lElementCount += lDivide;   /* for subdivision */
					}
					fxX1 = fxX2;
					fxY1 = fxY2;
					byF1 = byF2;
				}
			}
		}
	}
	if (!(usScanKind & SK_NODROPOUT) && (usScanKind & SK_SMART))  /* if smart dropout */
	{
		lElementCount += fsc_GetReversalCount(prrRoots) << 1;  /* add in 2 * reversals */
		if (lElementCount > (0xFFFF >> SC_CODESHFT))
		{
			return SMART_DROP_OVERFLOW_ERR;
		}
	}

		
/*  set horiz workspace return values */

	lHScanCount = (int32)(pbmpBitMap->rectBounds.top - pbmpBitMap->rectBounds.bottom);
	lVScanCount = (int32)(pbmpBitMap->rectBounds.right - pbmpBitMap->rectBounds.left);
	
	pbmpBitMap->sRowBytes = (int16)ROWBYTESLONG(lVScanCount);
	pbmpBitMap->lMMemSize = (lHScanCount * (int32)pbmpBitMap->sRowBytes);
	
	lTotalHIx = fsc_GetHIxEstimate(prrRoots);   /* intersection count */
	pwsWork->lHMemSize = fsc_GetScanHMem(usScanKind, lHScanCount, lTotalHIx);

/*  set vertical workspace return values */
	
	if (usScanKind & SK_NODROPOUT)                  /* if no dropout */
	{
		pwsWork->lVMemSize = 0L;
		lTotalVIx = 0;
	}
	else
	{
		lTotalVIx = fsc_GetVIxEstimate(prrRoots);   /* estimate intersection count */
		pwsWork->lVMemSize = fsc_GetScanVMem(usScanKind, lVScanCount, lTotalVIx, lElementCount);
	}
	
	pwsWork->lHInterCount = lTotalHIx;              /* save for SetupScan */
	pwsWork->lVInterCount = lTotalVIx;
	pwsWork->lElementCount = lElementCount;
	pwsWork->lRMemSize = fsc_GetRevMemSize(prrRoots);

#ifdef FSCFG_REENTRANT
	
	pwsWork->lHMemSize += sizeof(StateVars);        /* reentrant state space */

#endif

	return NO_ERR;
} 


/*********************************************************************/

/*  Calculate the amount of workspace needed to scan convert         */
/*  a given band into a given bitmap.  Get per intersection and      */
/*  per scanline size info from ScanList module.                     */

/*********************************************************************/

FS_PUBLIC int32 fsc_MeasureBand( 
		GlyphBitMap* pbmpBitMap,        /* computed by MeasureGlyph */
		WorkScan* pwsWork,              /* to return new values */
		uint16 usBandType,              /* small or fast */
		uint16 usBandWidth,             /* scanline count */
		uint16 usScanKind )             /* dropout control value */
{
	int32 lBandWidth;                   /* max scanline count */
	int32 lTotalHIx;                    /* est of horiz intersections in band */
	int32 lVScanCount;                  /* total vertical scan lines */
	int32 lHScanCount;                  /* total horizontal scan lines */

	lBandWidth = (int32)usBandWidth;
	pbmpBitMap->lMMemSize = (lBandWidth * (int32)pbmpBitMap->sRowBytes);
	
	if (usBandType == FS_BANDINGSMALL) 
	{
		lTotalHIx = fsc_GetHIxBandEst((PRevRoot)pwsWork->pchRBuffer, &pbmpBitMap->rectBounds, lBandWidth);
		pwsWork->lHInterCount = lTotalHIx;  /* save for SetupScan */
		pwsWork->lHMemSize = fsc_GetScanHMem(usScanKind, lBandWidth, lTotalHIx);
		pwsWork->lVMemSize = 0L;            /* force dropout control off */
	}
	else if (usBandType == FS_BANDINGFAST) 
	{
		lTotalHIx = fsc_GetHIxEstimate((PRevRoot)pwsWork->pchRBuffer);  /* intersection count */
		pwsWork->lHInterCount = lTotalHIx;  /* save for SetupScan */
		
		lHScanCount = (int32)(pbmpBitMap->rectBounds.top - pbmpBitMap->rectBounds.bottom);
		pwsWork->lHMemSize = fsc_GetScanHMem(usScanKind, lHScanCount, lTotalHIx);

		if (usScanKind & SK_NODROPOUT)      /* if no dropout */
		{
			pwsWork->lVMemSize = 0L;
		}
		else                                /* if any kind of dropout */
		{
			pbmpBitMap->lMMemSize += (int32)pbmpBitMap->sRowBytes;  /* to save below row */
			
			lVScanCount = (int32)(pbmpBitMap->rectBounds.right - pbmpBitMap->rectBounds.left);
			pwsWork->lVMemSize = fsc_GetScanVMem(usScanKind, lVScanCount, pwsWork->lVInterCount, pwsWork->lElementCount);
			pwsWork->lVMemSize += (int32)pbmpBitMap->sRowBytes;     /* to save above row */
			ALIGN(voidPtr, pwsWork->lVMemSize ); 
		}
	}
	
#ifdef FSCFG_REENTRANT
	
	pwsWork->lHMemSize += sizeof(StateVars);        /* reentrant state space */

#endif
	
	return NO_ERR;
}


/*********************************************************************/

/*  Scan Conversion Routine                                          */
/*  Trace the contour, passing out lines and splines,                */
/*  then call ScanList to fill the bitmap                            */

/*********************************************************************/

FS_PUBLIC int32 fsc_FillGlyph( 
		ContourList* pclContour,        /* glyph outline */
		GlyphBitMap* pgbBitMap,         /* target */
		WorkScan* pwsWork,              /* for scan array */
		uint16 usBandType,              /* old, small, fast or faster */
		uint16 usScanKind )             /* dropout control value */
{
	uint16 usCont;                      /* contour index */
	int16 sStart, sEnd;                 /* start and end point of contours */
	int32 lStateSpace;                  /* HMem used by state structure */
	int32 lErrCode;                     /* function return code */
	F26Dot6 *pfxXCoord;                 /* next x coord ptr */
	F26Dot6 *pfxYCoord;                 /* next y coord ptr */
	uint8 *pbyOnCurve;                  /* next flag ptr */
	F26Dot6 *pfxXStop;                  /* contour trace end condition */
	F26Dot6 fxX1, fxX2, fxX3;           /* x coord endpoints */
	F26Dot6 fxY1, fxY2, fxY3;           /* y coord endpoints */
	uint8 byOnCurve;                    /* point 2 flag variable */
	int32 lHiScanBand;                  /* top scan limit */ 
	int32 lLoScanBand;                  /* bottom scan limit */
	int32 lHiBitBand;                   /* top bitmap limit */
	int32 lLoBitBand;                   /* bottom bitmap limit */
	int32 lOrgLoBand;                   /* save for overscan fill check */
	F26Dot6 fxYHiBand, fxYLoBand;       /* limits in f26.6 */
	boolean bSaveRow;                   /* for dropout over scanning */
	boolean bBandCheck;                 /* eliminate out of band elements */

#ifdef FSCFG_REENTRANT
	
	StateVars *pState;                  /* reentrant State is accessed via pointer */

	pState = (StateVars*)pwsWork->pchHBuffer;  /* and lives in HMem (memoryBase[6]) */ 
	lStateSpace = sizeof(StateVars);

#else
	
	lStateSpace = 0L;                   /* no HMem needed if not reentrant */

#endif
	
	if (pgbBitMap->rectBounds.top <= pgbBitMap->rectBounds.bottom)
	{
		return NO_ERR;                              /* quick out for null glyph */
	}

	if (pgbBitMap->bZeroDimension)                  /* if no height or width */
	{
		usScanKind &= (~SK_STUBS);                  /* force no-stub dropout */
	}

	lHiBitBand = (int32)pgbBitMap->sHiBand, 
	lLoBitBand = (int32)pgbBitMap->sLoBand;
	lOrgLoBand = lLoBitBand;                        /* save for fill call */    
	
	Assert (lHiBitBand > lLoBitBand);               /* should be handled above */
	
	if (!(usScanKind & SK_NODROPOUT))               /* if any kind of dropout */
	{
		lLoBitBand--;                               /* leave room below line */
	}
	if (lHiBitBand > pgbBitMap->rectBounds.top)
	{
		lHiBitBand = pgbBitMap->rectBounds.top;     /* clip to top */
	}
	if (lLoBitBand < pgbBitMap->rectBounds.bottom)
	{
		lLoBitBand = pgbBitMap->rectBounds.bottom;  /* clip to bottom */
	}
	if (usBandType == FS_BANDINGFAST)               /* if fast banding */
	{
		lHiScanBand = pgbBitMap->rectBounds.top;    /* render everything */
		lLoScanBand = pgbBitMap->rectBounds.bottom;
		bSaveRow = TRUE;                            /* keep last row for dropout */
	}
	else                                            /* if old or small banding */
	{
		lHiScanBand = lHiBitBand;                   /* just take the band */
		lLoScanBand = lLoBitBand;
		bSaveRow = FALSE;                           /* last row not needed */
	}
	
/*  if fast banding has already renderend elements, skip to FillBitMap */

	if (usBandType != FS_BANDINGFASTER)             /* if rendering required */
	{
		fsc_SetupMem(ASTATE                         /* init workspace */
				pwsWork->pchHBuffer + lStateSpace, 
				pwsWork->lHMemSize - lStateSpace,
				pwsWork->pchVBuffer, 
				pwsWork->lVMemSize);
		
		fsc_SetupLine(ASTATE0);             /* passes line callback to scanlist */
		fsc_SetupSpline(ASTATE0);           /* passes spline callback to scanlist */
		fsc_SetupEndPt(ASTATE0);            /* passes endpoint callback to scanlist */

/*  Eliminate out of band lines and splines, unless fast banding */

		bBandCheck = ((lHiScanBand < pgbBitMap->rectBounds.top) || (lLoScanBand > pgbBitMap->rectBounds.bottom));

		fxYHiBand = (F26Dot6)((lHiScanBand << SUBSHFT) - SUBHALF);  /* may be too wide */
		fxYLoBand = (F26Dot6)((lLoScanBand << SUBSHFT) + SUBHALF);

		lErrCode = fsc_SetupScan(ASTATE &(pgbBitMap->rectBounds), usScanKind, 
							 lHiScanBand, lLoScanBand, bSaveRow, (int32)pgbBitMap->sRowBytes,
							 pwsWork->lHInterCount, pwsWork->lVInterCount,
							 pwsWork->lElementCount, (PRevRoot)pwsWork->pchRBuffer );

		if (lErrCode != NO_ERR) return lErrCode;
		
		for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
		{
			sStart = pclContour->asStartPoint[usCont];
			sEnd = pclContour->asEndPoint[usCont];

			if (sStart == sEnd)
			{
				continue;                               /* for compatibilty */
			}
/*
	For efficiency in tracing the contour, we start by assigning (x1,y1)
	to the last oncurve point.  This is found by starting with the End
	point and backing up if necessary.  The pfxCoord pointers can then
	be used to trace the entire contour without being reset across the
	Start/End gap. 
*/
			pfxXCoord = &pclContour->afxXCoord[sStart];
			pfxYCoord = &pclContour->afxYCoord[sStart];
			pbyOnCurve = &pclContour->abyOnCurve[sStart];
			pfxXStop = &pclContour->afxXCoord[sEnd];

			if (pclContour->abyOnCurve[sEnd] & ONCURVE) /* if endpoint oncurve */
			{
				fxX1 = pclContour->afxXCoord[sEnd];
				fxY1 = pclContour->afxYCoord[sEnd];
				fxX2 = *pfxXCoord;
				fxY2 = *pfxYCoord;
				byOnCurve = *pbyOnCurve;                /* 1st pt might be off */
				pfxXStop++;                             /* stops at endpoint */
			}
			else                                        /* if endpoint offcurve */
			{
				fxX1 = pclContour->afxXCoord[sEnd - 1];
				fxY1 = pclContour->afxYCoord[sEnd - 1];
				fxX2 = pclContour->afxXCoord[sEnd];
				fxY2 = pclContour->afxYCoord[sEnd];
				if ((pclContour->abyOnCurve[sEnd - 1] & ONCURVE) == 0)
				{
					fxX1 = (fxX1 + fxX2 + 1) >> 1;      /* offcurve midpoint */
					fxY1 = (fxY1 + fxY2 + 1) >> 1;
				}
				byOnCurve = 0;
				pfxXCoord--;                            /* pre decrement */
				pfxYCoord--;
				pbyOnCurve--;
			}
			fsc_BeginContourEndpoint(ASTATE fxX1, fxY1);          /* 1st oncurve pt -> ep module */
			fsc_BeginContourScan(ASTATE usScanKind, fxX1, fxY1);  /* to scanlist module too */
/*
	At this point, (x1,y1) is the last oncurve point; (x2,y2) is the next
	point (on or off); and the pointers are ready to be incremented to the
	point following (x2,y2).  
		
	Throughout this loop (x1,y1) is always an oncurve point (it may be the 
	midpoint between two offcurve points).  If (x2,y2) is oncurve, then we 
	have a line; if offcurve, we have a spline, and (x3,y3) will be the 
	next oncurve point.
*/
			if (!bBandCheck)
			{
				while (pfxXCoord < pfxXStop)
				{
					if (byOnCurve & ONCURVE)                /* if next point oncurve */
					{
						lErrCode = fsc_CheckEndPoint(ASTATE fxX2, fxY2, usScanKind);
						if (lErrCode != NO_ERR) return lErrCode;

						lErrCode = fsc_CalcLine(ASTATE fxX1, fxY1, fxX2, fxY2, usScanKind);
						if (lErrCode != NO_ERR) return lErrCode;

						fxX1 = fxX2;                        /* next oncurve point */
						fxY1 = fxY2;
								
						pfxXCoord++;
						pfxYCoord++;
						pbyOnCurve++;
					}
					else
					{
						pfxXCoord++;                        /* check next point */
						fxX3 = *pfxXCoord;
						pfxYCoord++;
						fxY3 = *pfxYCoord;
						pbyOnCurve++;
								
						if (*pbyOnCurve & ONCURVE)          /* if it's on, use it */
						{
							pfxXCoord++;
							pfxYCoord++;
							pbyOnCurve++;
						}
						else                                /* if not, calc next on */
						{
							fxX3 = (fxX2 + fxX3 + 1) >> 1;  /* offcurve midpoint */
							fxY3 = (fxY2 + fxY3 + 1) >> 1;
						}
						lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX2, fxY2, fxX3, fxY3, usScanKind);
						if (lErrCode != NO_ERR) return lErrCode;

						fxX1 = fxX3;                        /* next oncurve point */
						fxY1 = fxY3;
					}

					/* test to avoid reading past the end of memory on the last line */
					if (pfxXCoord != pfxXStop)
					{
						fxX2 = *pfxXCoord;                      /* next contour point */
						fxY2 = *pfxYCoord;
						byOnCurve = *pbyOnCurve;
					}
				}
			}
			else    /* if band checking */
			{
				while (pfxXCoord < pfxXStop)
				{
					if (byOnCurve & ONCURVE)                /* if next point oncurve */
					{
						lErrCode = fsc_CheckEndPoint(ASTATE fxX2, fxY2, usScanKind);
						if (lErrCode != NO_ERR) return lErrCode;

						if (!(((fxY1 > fxYHiBand) && (fxY2 > fxYHiBand)) ||
							  ((fxY1 < fxYLoBand) && (fxY2 < fxYLoBand))))
						{
							lErrCode = fsc_CalcLine(ASTATE fxX1, fxY1, fxX2, fxY2, usScanKind);
							if (lErrCode != NO_ERR) return lErrCode;
						}

						fxX1 = fxX2;                        /* next oncurve point */
						fxY1 = fxY2;
								
						pfxXCoord++;
						pfxYCoord++;
						pbyOnCurve++;
					}
					else
					{
						pfxXCoord++;                        /* check next point */
						fxX3 = *pfxXCoord;
						pfxYCoord++;
						fxY3 = *pfxYCoord;
						pbyOnCurve++;
								
						if (*pbyOnCurve & ONCURVE)          /* if it's on, use it */
						{
							pfxXCoord++;
							pfxYCoord++;
							pbyOnCurve++;
						}
						else                                /* if not, calc next on */
						{
							fxX3 = (fxX2 + fxX3 + 1) >> 1;  /* offcurve midpoint */
							fxY3 = (fxY2 + fxY3 + 1) >> 1;
						}

						if (!(((fxY1 > fxYHiBand) && (fxY2 > fxYHiBand) && (fxY3 > fxYHiBand)) ||
							  ((fxY1 < fxYLoBand) && (fxY2 < fxYLoBand) && (fxY3 < fxYLoBand))))
						{
							lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX2, fxY2, fxX3, fxY3, usScanKind);
							if (lErrCode != NO_ERR) return lErrCode;
						}
						else    /* if entirely outside of the band */
						{
							lErrCode = fsc_CheckEndPoint(ASTATE fxX3, fxY3, usScanKind);
							if (lErrCode != NO_ERR) return lErrCode;
						}

						fxX1 = fxX3;                        /* next oncurve point */
						fxY1 = fxY3;
					}

					/* test to avoid reading past the end of memory on the last line */
					if (pfxXCoord != pfxXStop)
					{
						fxX2 = *pfxXCoord;                      /* next contour point */
						fxY2 = *pfxYCoord;
						byOnCurve = *pbyOnCurve;
					}
				}
			}
			lErrCode = fsc_EndContourEndpoint(ASTATE usScanKind);
			if (lErrCode != NO_ERR) return lErrCode;
		}
	}
	
	lErrCode = fsc_FillBitMap(
			ASTATE 
			pgbBitMap->pchBitMap, 
			lHiBitBand, 
			lLoBitBand,
			(int32)pgbBitMap->sRowBytes, 
			lOrgLoBand,
			usScanKind
	);

	if (lErrCode != NO_ERR) return lErrCode;
	
	return NO_ERR;
}


#ifndef FSCFG_DISABLE_GRAYSCALE

/*********************************************************************/

/*  This routine scales up an outline for gray scale scan conversion */

/*********************************************************************/

FS_PUBLIC int32 fsc_OverScaleOutline( 
		ContourList* pclContour,        /* glyph outline */
		uint16 usOverScale              /* over scale factor */
)
{
	uint16 usCont;                      /* contour index */
	int16 sPt;                          /* point index */
	int16 sStart, sEnd;                 /* start and end point of contours */
	int16 sShift;                       /* for power of two multiply */
	F26Dot6 *pfxXCoord, *pfxYCoord;     /* for fast point array access */
	
	
	switch (usOverScale)                /* look for power of two */
	{
	case 1:
		sShift = 0;
		break;
	case 2:
		sShift = 1;
		break;
	case 4:
		sShift = 2;
		break;
	case 8:
		sShift = 3;
		break;
	default:
		sShift = -1;
		break;
	}

	for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
	{
		sStart = pclContour->asStartPoint[usCont];
		sEnd = pclContour->asEndPoint[usCont];
				
		pfxXCoord = &pclContour->afxXCoord[sStart];
		pfxYCoord = &pclContour->afxYCoord[sStart];
			
		if (sShift >= 0)                    /* if power of two */
		{
			for (sPt = sStart; sPt <= sEnd; sPt++)
			{
				*pfxXCoord <<= sShift;
				pfxXCoord++;
				*pfxYCoord <<= sShift;
				pfxYCoord++;
			}
		}
		else                                /* if not a power of two */
		{
			for (sPt = sStart; sPt <= sEnd; sPt++)
			{
				*pfxXCoord *= (int32)usOverScale;
				pfxXCoord++;
				*pfxYCoord *= (int32)usOverScale;
				pfxYCoord++;
			}
		}
	}
	return NO_ERR;
}


/*********************************************************************/

/*  Gray scale bitmap calculation                                    */
/*  Count over scale pixels into gray scale byte array               */
/*  Be sure that Hi/LoBand are set correctly for both Over & Gray!   */

/*********************************************************************/

FS_PUBLIC int32 fsc_CalcGrayMap( 
		GlyphBitMap* pOverGBMap,        /* over scaled source */
		GlyphBitMap* pGrayGBMap,        /* gray scale target */
		uint16 usOverScale              /* over scale factor */
)
{
	char        *pchOverRow;            /* over scaled bitmap row pointer */
	char        *pchGrayRow;            /* gray scale bitmap row pointer */

	int16       sVOffset;               /* over scaled rows to skip */
	int16       sRightPix;              /* right edge of used over pix's */
		
	int16       sGrayRow;               /* gray scale row loop counter */
	uint16      usOverRowCount;         /* over scaled row loop counter */
	int16       sTotalRowCount;         /* over scaled whole band counter */
	
	uint32      ulBytes;                /* gray scale count for clear */
	int32       lErrCode;               /* function return code */
	
	GrayScaleParam  GSP;                /* param block for CalcGrayRow */


	Assert ((usOverScale == 1) || (usOverScale == 2) || (usOverScale == 4) || (usOverScale == 8));

	ulBytes = (uint32)pGrayGBMap->sRowBytes * (uint32)(pGrayGBMap->sHiBand - pGrayGBMap->sLoBand);
	Assert(((ulBytes >> 2) << 2) == ulBytes);
	fsc_ScanClearBitMap (ulBytes >> 2, (uint32*)pGrayGBMap->pchBitMap);
	
	GSP.usOverScale = usOverScale;
	GSP.pchOverLo = pOverGBMap->pchBitMap;      /* set pointer limits */
	GSP.pchOverHi = pOverGBMap->pchBitMap + pOverGBMap->lMMemSize;
	GSP.pchGrayLo = pGrayGBMap->pchBitMap;      /* set pointer limits */
	GSP.pchGrayHi = pGrayGBMap->pchBitMap + pGrayGBMap->lMMemSize;

	pchOverRow = pOverGBMap->pchBitMap;
	usOverRowCount = usOverScale;
	sTotalRowCount = pOverGBMap->sHiBand - pOverGBMap->sLoBand;
	sVOffset = pOverGBMap->sHiBand - usOverScale * pGrayGBMap->sHiBand;
	if (sVOffset < 0)                                   /* if mapped above over's bitmap */
	{
		usOverRowCount -= (uint16)(-sVOffset);          /* correct first band count */
	}
	else
	{
		pchOverRow += sVOffset * pOverGBMap->sRowBytes; /* point into bitmap */
		sTotalRowCount -= sVOffset;                     /* adjust for skipped rows */
	}
	
	sRightPix = pGrayGBMap->rectBounds.right * (int16)usOverScale - pOverGBMap->rectBounds.left;
	pchOverRow += (sRightPix - 1) >> 3;
	GSP.usFirstShift = (uint16)(7 - ((sRightPix-1) & 0x0007));

	GSP.sGrayCol = pGrayGBMap->rectBounds.right - pGrayGBMap->rectBounds.left;
	pchGrayRow = pGrayGBMap->pchBitMap + (GSP.sGrayCol - 1);

	for (sGrayRow = pGrayGBMap->sHiBand - 1; sGrayRow >= pGrayGBMap->sLoBand; sGrayRow--)
	{
		GSP.pchGray = pchGrayRow;
		while ((usOverRowCount > 0) && (sTotalRowCount > 0))
		{
			GSP.pchOver = pchOverRow;
			lErrCode = fsc_ScanCalcGrayRow( &GSP );
			if (lErrCode != NO_ERR) return lErrCode;
			
			pchOverRow += pOverGBMap->sRowBytes;
			usOverRowCount--;
			sTotalRowCount--;
		}                               
		pchGrayRow += pGrayGBMap->sRowBytes;
		usOverRowCount = usOverScale;
	}
	return NO_ERR;
}

#else                                   /* if grayscale is disabled */

FS_PUBLIC int32 fsc_OverScaleOutline( 
		ContourList* pclContour,        /* glyph outline */
		uint16 usOverScale              /* over scale factor */
)
{
	FS_UNUSED_PARAMETER(pclContour);
	FS_UNUSED_PARAMETER(usOverScale);
	
	return BAD_GRAY_LEVEL_ERR;
}


FS_PUBLIC int32 fsc_CalcGrayMap( 
		GlyphBitMap* pOverGBMap,        /* over scaled source */
		GlyphBitMap* pGrayGBMap,        /* gray scale target */
		uint16 usOverScale              /* over scale factor */
)
{
	FS_UNUSED_PARAMETER(pOverGBMap);
	FS_UNUSED_PARAMETER(pGrayGBMap);
	FS_UNUSED_PARAMETER(usOverScale);
	
	return BAD_GRAY_LEVEL_ERR;
}

#endif

/*********************************************************************/
											 
/*      Local Functions                                              */

/*********************************************************************/

/*********************************************************************/

/*  This routine examines a glyph contour by contour and calculates  */
/*  its bounding box.                                                */

/*********************************************************************/

FS_PRIVATE int32 FindExtrema( 
		ContourList* pclContour,        /* glyph outline */
		GlyphBitMap* pbmpBitMap         /* to return bounds */
)
{
	uint16 usCont;                      /* contour index */
	int16 sPt;                          /* point index */
	int16 sStart, sEnd;                 /* start and end point of contours */
	int32 lMaxX, lMinX;                 /* for bounding box left, right */
	int32 lMaxY, lMinY;                 /* for bounding box top, bottom */
	
	F26Dot6 *pfxXCoord, *pfxYCoord;     /* for fast point array access */
	F26Dot6 fxMaxX, fxMinX;             /* for bounding box left, right */
	F26Dot6 fxMaxY, fxMinY;             /* for bounding box top, bottom */
	boolean bFirstContour;              /* set false after min/max set */


	fxMaxX = 0L;                        /* default bounds limits */
	fxMinX = 0L;
	fxMaxY = 0L;
	fxMinY = 0L;
	bFirstContour = TRUE;               /* first time only */
	
	for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
	{
		sStart = pclContour->asStartPoint[usCont];
		sEnd = pclContour->asEndPoint[usCont];
		if (sStart == sEnd)
		{
			continue;                               /* for anchor points */
		}
		
		pfxXCoord = &pclContour->afxXCoord[sStart];
		pfxYCoord = &pclContour->afxYCoord[sStart];
				
		if (bFirstContour)            
		{
			fxMaxX = *pfxXCoord;                    /* init bounds limits */
			fxMinX = *pfxXCoord;
			fxMaxY = *pfxYCoord;
			fxMinY = *pfxYCoord;
			bFirstContour = FALSE;                  /* just once */
		}

		for (sPt = sStart; sPt <= sEnd; sPt++)      /* find the min & max */
		{
			if (*pfxXCoord > fxMaxX)
				fxMaxX = *pfxXCoord;
			if (*pfxXCoord < fxMinX)
				fxMinX = *pfxXCoord;
					
			if (*pfxYCoord > fxMaxY)
				fxMaxY = *pfxYCoord;
			if (*pfxYCoord < fxMinY)
				fxMinY = *pfxYCoord;

			pfxXCoord++;
			pfxYCoord++;
		}
	}
	
	pbmpBitMap->fxMinX = fxMinX;                    /* save full precision bounds */
	pbmpBitMap->fxMinY = fxMinY;
	pbmpBitMap->fxMaxX = fxMaxX;                    /* save full precision bounds */
	pbmpBitMap->fxMaxY = fxMaxY;

	lMinX = (fxMinX + SUBHALF - 1) >> SUBSHFT;      /* pixel black box */
	lMinY = (fxMinY + SUBHALF - 1) >> SUBSHFT;
	lMaxX = (fxMaxX + SUBHALF) >> SUBSHFT;
	lMaxY = (fxMaxY + SUBHALF) >> SUBSHFT;
			
	if ((F26Dot6)(int16)lMinX != lMinX ||           /* check overflow */
		(F26Dot6)(int16)lMinY != lMinY ||
		(F26Dot6)(int16)lMaxX != lMaxX ||
		(F26Dot6)(int16)lMaxY != lMaxY )
	{
		return POINT_MIGRATION_ERR;
	}

	pbmpBitMap->bZeroDimension = FALSE;             /* assume some size */
	
	if (bFirstContour == FALSE)                     /* if contours present */
	{                                               /* then force a non-zero bitmap */
		if (lMinX == lMaxX)
		{
			lMaxX++;                                /* force 1 pixel wide */
			pbmpBitMap->bZeroDimension = TRUE;      /* flag for filling */
		}
		if (lMinY == lMaxY)
		{
			lMaxY++;                                /* force 1 pixel high */
			pbmpBitMap->bZeroDimension = TRUE;      /* flag for filling */
		}
	}
	
/*  set bitmap structure return values */

	pbmpBitMap->rectBounds.left   = (int16)lMinX;
	pbmpBitMap->rectBounds.right  = (int16)lMaxX;
	pbmpBitMap->rectBounds.bottom = (int16)lMinY;
	pbmpBitMap->rectBounds.top    = (int16)lMaxY;

	return NO_ERR;
}

/*********************************************************************/

/* This recursive routine subdivides splines that are non-monotonic or   */
/* too big into splines that fsc_CalcSpline can handle.  It also         */
/* filters out degenerate (linear) splines, passing off to fsc_CalcLine. */


FS_PRIVATE int32 EvaluateSpline( 
		PSTATE                      /* pointer to state vars */
		F26Dot6 fxX1,               /* start point x coordinate */
		F26Dot6 fxY1,               /* start point y coordinate */
		F26Dot6 fxX2,               /* control point x coordinate */
		F26Dot6 fxY2,               /* control point y coordinate */
		F26Dot6 fxX3,               /* ending x coordinate */
		F26Dot6 fxY3,               /* ending y coordinate */
		uint16 usScanKind           /* scan control type */
)
{
	F26Dot6 fxDX21, fxDX32, fxDX31;     /* delta x's */
	F26Dot6 fxDY21, fxDY32, fxDY31;     /* delta y's */
	
	F26Dot6 fxDenom;                    /* ratio denominator  */
	F26Dot6 fxX4, fxY4;                 /* first mid point */
	F26Dot6 fxX5, fxY5;                 /* mid mid point */
	F26Dot6 fxX6, fxY6;                 /* second mid point */
	F26Dot6 fxX456, fxY456;             /* for monotonic subdivision */
	F26Dot6 fxAbsDX, fxAbsDY;           /* abs of DX31, DY31 */
	
	int32 lErrCode;


	fxDX21 = fxX2 - fxX1;                       /* get all four deltas */
	fxDX32 = fxX3 - fxX2;
	fxDY21 = fxY2 - fxY1;
	fxDY32 = fxY3 - fxY2;
  
/*  If spline goes up and down, then subdivide it  */

	if (((fxDY21 > 0L) && (fxDY32 < 0L)) || ((fxDY21 < 0L) && (fxDY32 > 0L)))
	{
		fxDenom = fxDY21 - fxDY32;              /* total y span */
		fxX4 = fxX1 + LongMulDiv(fxDX21, fxDY21, fxDenom);
		fxX6 = fxX2 + LongMulDiv(fxDX32, fxDY21, fxDenom);
		fxX5 = fxX4 + LongMulDiv(fxX6 - fxX4, fxDY21, fxDenom);
		fxY456 = fxY1 + LongMulDiv(fxDY21, fxDY21, fxDenom);
		
		lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX4, fxY456, fxX5, fxY456, usScanKind);
		if (lErrCode != NO_ERR)  return lErrCode;

		return EvaluateSpline(ASTATE fxX5, fxY456, fxX6, fxY456, fxX3, fxY3, usScanKind);
	}
	
/*  If spline goes left and right, then subdivide it  */
	
	if (((fxDX21 > 0L) && (fxDX32 < 0L)) || ((fxDX21 < 0L) && (fxDX32 > 0L)))
	{
		fxDenom = fxDX21 - fxDX32;              /* total x span */
		fxY4 = fxY1 + LongMulDiv(fxDY21, fxDX21, fxDenom);
		fxY6 = fxY2 + LongMulDiv(fxDY32, fxDX21, fxDenom);
		fxY5 = fxY4 + LongMulDiv(fxY6 - fxY4, fxDX21, fxDenom);
		fxX456 = fxX1 + LongMulDiv(fxDX21, fxDX21, fxDenom);

		lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX456, fxY4, fxX456, fxY5, usScanKind);
		if (lErrCode != NO_ERR)  return lErrCode;

		return EvaluateSpline(ASTATE fxX456, fxY5, fxX456, fxY6, fxX3, fxY3, usScanKind);
	}

/*  By now the spline must be monotonic  */

	fxDX31 = fxX3 - fxX1;                       /* check overall size */
	fxDY31 = fxY3 - fxY1;
	fxAbsDX = FXABS(fxDX31);
	fxAbsDY = FXABS(fxDY31);

/*  If spline is too big to calculate, then subdivide it  */

	if ((fxAbsDX > MAXSPLINELENGTH) || (fxAbsDY > MAXSPLINELENGTH))
	{
		fxX4 = (fxX1 + fxX2) >> 1;              /* first segment mid point */
		fxY4 = (fxY1 + fxY2) >> 1;
		fxX6 = (fxX2 + fxX3) >> 1;              /* second segment mid point */
		fxY6 = (fxY2 + fxY3) >> 1;
		fxX5 = (fxX4 + fxX6) >> 1;              /* mid segment mid point */
		fxY5 = (fxY4 + fxY6) >> 1;

		lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX4, fxY4, fxX5, fxY5, usScanKind);
		if (lErrCode != NO_ERR)  return lErrCode;

		return EvaluateSpline(ASTATE fxX5, fxY5, fxX6, fxY6, fxX3, fxY3, usScanKind);
	}

/*  The spline is now montonic and small enough  */

	lErrCode = fsc_CheckEndPoint(ASTATE fxX3, fxY3, usScanKind);  /* first check endpoint */
	if (lErrCode != NO_ERR)  return lErrCode;

	if (fxDX21 * fxDY32 == fxDY21 * fxDX32)     /* if spline is degenerate (linear) */
	{                                           /* treat as a line */
		return fsc_CalcLine(ASTATE fxX1, fxY1, fxX3, fxY3, usScanKind);
	}
	else        
	{
		return fsc_CalcSpline(ASTATE fxX1, fxY1, fxX2, fxY2, fxX3, fxY3, usScanKind);
	}
}


/*********************************************************************/

/*  Return an array of coordinates for outline points */

FS_PUBLIC int32 fsc_GetCoords(
		ContourList* pclContour,        /* glyph outline */
        uint16 usPointCount,            /* point count */
        uint16* pusPointIndex,          /* point indices */
        PixCoord* ppcCoordinate         /* point coordinates */
)
{
    uint16  usMaxIndex;                 /* last defined point */
    int32  lX;                          /* integer x coord */
    int32  lY;                          /* integer y coord */

    if (pclContour->usContourCount == 0)
    {
        return BAD_POINT_INDEX_ERR;     /* can't have a point without a contour */
    }
     
    usMaxIndex = pclContour->asEndPoint[pclContour->usContourCount - 1] + 2;    /* allow 2 phantoms */

    while (usPointCount > 0)
    {
        if (*pusPointIndex > usMaxIndex)
        {
            return BAD_POINT_INDEX_ERR;     /* beyond the last contour */
        }

        lX = (pclContour->afxXCoord[*pusPointIndex] + SUBHALF) >> SUBSHFT;
        lY = (pclContour->afxYCoord[*pusPointIndex] + SUBHALF) >> SUBSHFT;

        if ( ((int32)(int16)lX != lX) || ((int32)(int16)lY != lY) )
    	{
    		return POINT_MIGRATION_ERR;    /* catch overflow */
    	}

        ppcCoordinate->x = (int16)lX;
        ppcCoordinate->y = (int16)lY;

        pusPointIndex++;
        ppcCoordinate++;
        usPointCount--;                     /* loop through all points */
    }
	return NO_ERR;
}

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\scentry.h ===
/*********************************************************************

      scentry.h -- NewScan Module Exports

      (c) Copyright 1992-95  Microsoft Corp.  All rights reserved.

       1/23/95  deanb       added fsc_GetCoords helper function
       9/07/93  deanb       F26Dot6 min/max added to gbmp structure
       8/10/93  deanb       expand interface for gray scale
       6/10/93  deanb       fsc_Initialize added
       4/21/93  deanb       banding params for MeasureGlyph
       3/29/93  deanb       reversal memory added to WorkScan
       3/19/93  deanb       size_t replaced with int32
      12/22/92  deanb       Rectangle -> Rect
      12/21/92  deanb       Interface types aligned with rasterizer
      11/30/92  deanb       WorkSpace renamed WorkScan
      11/05/92  deanb       ulPointCount removed from ContourList
      11/04/92  deanb       RemoveDups function added
      10/14/92  deanb       Exported data structures added
       8/18/92  deanb       Scan type param added 
       8/17/92  deanb       Functions renamed to ..Glyph 
       7/24/92  deanb       Polyline functions deleted 
       4/09/92  deanb       New types 
       3/30/92  deanb       WorkspaceSize renamed MeasureContour 
       3/24/92  deanb       BitMap back to WorkspaceSize 
       3/20/92  deanb       Structs moved to fscdefs.h, params trimmed 
       3/17/92  deanb       Add ulPointCount, rework fcn params 
       3/05/92  deanb       Add data structures 
       3/04/92  deanb       Size reports added 
       2/21/92  deanb       First cut 

*********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/********************************************************************/

/*      Exported Data Structures                                    */

/********************************************************************/

typedef struct
{
    uint16 usContourCount;          /* number of contours */
    int16 *asStartPoint;            /* contour startpoint index array */
    int16 *asEndPoint;              /* contour endpoint index array */
    F26Dot6 *afxXCoord;             /* contour x coordinate array */
    F26Dot6 *afxYCoord;             /* contour y coordinate array */
    uint8 *abyOnCurve;              /* on curve / off curve array */
    uint8 *abyFc;					/* contour flags, one byte for every contour */
}
ContourList;

typedef struct
{
    int16 sRowBytes;                /* bit map width in bytes */
    int16 sHiBand;                  /* upper banding limit */
    int16 sLoBand;                  /* lower banding limit */
    Rect rectBounds;                /* bit map border */
    boolean bZeroDimension;         /* flags zero width or height */
    F26Dot6 fxMinX;                 /* full precision x minimum */
    F26Dot6 fxMaxX;                 /* full precision x maximum */
    F26Dot6 fxMinY;                 /* full precision y minimum */
    F26Dot6 fxMaxY;                 /* full precision y maximum */
    int32 lMMemSize;                /* size of bitmap in bytes */
    char *pchBitMap;                /* pixel bit map */
}
GlyphBitMap;

typedef struct
{
    int32 lRMemSize;                /* workspace bytes for reversal lists */
    int32 lHMemSize;                /* workspace bytes needed for horiz scan */
    int32 lVMemSize;                /* additional workspace for vert scan */
    int32 lHInterCount;             /* estimate of horiz scan intersections */
    int32 lVInterCount;             /* estimate of vert scan intersections */
    int32 lElementCount;            /* estimate of element control points */
    char *pchRBuffer;               /* reversal workspace byte pointer */
    char *pchHBuffer;               /* horiz workspace byte pointer */
    char *pchVBuffer;               /* vert workspace byte pointer */
}
WorkScan;

typedef struct
{
    int16 x;                        /* x pixel value */
    int16 y;                        /* y pixel value */
}
PixCoord;

/*********************************************************************/

/*      Function Exports                                             */

/*********************************************************************

  fsc_Initialize

    This routine calls down to the bitmap module to initialize the
    bitmap masks.  It should be called once, before and scan conversion
    is done.  No harm will be done if it is called more than once.

*/

FS_PUBLIC void fsc_Initialize (
        void
);


/*********************************************************************

  fsc_RemoveDups

    This routine examines a glyph contour by contour and removes any
    duplicated points.  Two subtlties here:  1) following a call to
    this routine, the relation of End[i] + 1 = Start[i + 1] may no
    longer hold (in other words, the contours may not be tightly
    packed);  and 2) two duplicate off curve points will become a
    single ON curve point (this makes sense when you remember that
    between any two offs there must be an on).

  Input Values:

    ContourList -   All values set (pointers to contour arrays)

  Returned Values:
    
    ContourList -   Start, X, Y, and OnCurve arrays may be modified

*/

FS_PUBLIC int32 fsc_RemoveDups( 
        ContourList*        /* glyph outline */
);

/*********************************************************************

  fsc_OverScaleOutline(&Clist, inputPtr->param.gray.usOverScale);

    This routine scales up an outline for gray scale scan conversion

  Input Values:

    ContourList -   All values set (pointers to contour arrays)
    
    uint16      -   usOverScale     Multiplier

  Returned Values:
    
    ContourList -   X and Y arrays will be multiplied by usOverScale

*/

FS_PUBLIC int32 fsc_OverScaleOutline( 
        ContourList*,       /* glyph outline */
        uint16              /* over scale factor */
);

/*********************************************************************

  fsc_MeasureGlyph

    This routine examines a glyph contour by contour and calculates 
    its size and the amount of workspace needed to scan convert it.

  Input Values:

    ContourList -   All values set (pointers to contour arrays)

    WorkScan    -   pchRBuffer      Points to MeasureGlyph workspace used to
                                    store contour reversals.
                    lRMemSize       Size of RBuffer in bytes.  This should be
                                    2 * sizeof(Reversal) * NumberOfPoints to
                                    handle the worst case.
    
    uint16      -   usScanKind      Dropout control code

    uint16      -   usRoundXMin     Allows alignment of XMin for gray scale
                                    XMin modulo usRoundXMin will be zero

  Returned Values:

    WorkScan    -   pchRBuffer      Unchanged
                    lRMemSize       Amount of RBuffer actually used.  This will
                                    typically be much less than the worst case.
                    lHMemSize       Amount of horizontal workspace memory required.
                                    (Memory base 6, always used)
                    lVMemSize       Amount of vertical workspace memory required.
                                    (Memory base 7, used for dropout only)
                    lHInterCount    Estimate of horiz scan intersections
                    lVInterCount    Estimate of vert scan intersections
                    lElementCount   Estimate of element control points

    GlyphBitMap -   sRowBytes       Bytes per row in bitmap (padded to 0 mod 4).
                    rectBounds      Worst case black bounding box.
                    lMMemSize       Size of bitmap in bytes
*/

FS_PUBLIC int32 fsc_MeasureGlyph( 
		ContourList* pclContour,        /* glyph outline */
		GlyphBitMap* pbmpBitMap,        /* to return bounds */
		WorkScan* pwsWork,              /* to return values */
		uint16 usScanKind,              /* dropout control value */
		uint16 usRoundXMin,              /* for gray scale alignment */
		int16 sBitmapEmboldeningHorExtra,
		int16 sBitmapEmboldeningVertExtra );
    
/*********************************************************************

  fsc_MeasureBand

    This routine calculates the amount of workspace needed to scan 
    convert a glyph using banding.

  Input Values:

    WorkScan    -   pchRBuffer      Same value as passed into fsc_MeasureGlyph
                    lHMemSize       Size of horizontal memory from MeasureGlyph
                    lVMemSize       Size of vertical memory from MeasureGlyph
                    lHInterCount    Same value as returned from fsc_MeasureGlyph
                    lVInterCount    Same value as returned from fsc_MeasureGlyph
                    lElementCount   Same value as returned from fsc_MeasureGlyph
    
    uint16      -   usBandType      FS_BANDINGSMALL or FS_BANDINGFAST
    
    uint16      -   usBandWidth     Number of scan lines of maximum band

    uint16      -   usScanKind      Dropout control code

  Returned Values:

    WorkScan    -   pchRBuffer      Unchanged
                    lRMemSize       Unchanged
                    lHMemSize       Amount of horizontal workspace memory required.
                                    (Memory base 6, always used)
                    lVMemSize       Amount of vertical workspace memory required.
                                    (Memory base 7, used for dropout only)
                    lHInterCount    Estimate of horiz band intersections
                    lVInterCount    Unchanged
                    lElementCount   Unchanged

    GlyphBitMap -   sRowBytes       Unchanged
                    rectBounds      Unchanged
                    lMMemSize       Size of bitmap in bytes

*/

FS_PUBLIC int32 fsc_MeasureBand( 
        GlyphBitMap*,        /* computed by MeasureGlyph */
        WorkScan*,           /* to return new values */
        uint16,              /* usBandType = small or fast */
        uint16,              /* usBandWidth = scanline count */
        uint16               /* usScanKind = dropout control value */
);


/*********************************************************************

  fsc_FillGlyph

    This routine is responsible for the actual creation of a bitmap
    from the outline.
    
  Input Values:

    ContourList -   All values set (pointers to contour arrays)

    WorkScan    -   pchRBuffer      Same value as passed into fsc_MeasureGlyph
                    pchHBuffer      Pointer to horizontal workspace memory
                    pchVBuffer      Pointer to vertical workspace memory
                    lHMemSize       Size of horizontal memory (for assertion checks)
                    lVMemSize       Size of vertical memory (for assertion checks)
                    lHInterCount    Same value as returned from fsc_MeasureGlyph
                    lVInterCount    Same value as returned from fsc_MeasureGlyph
                    lElementCount   Same value as returned from fsc_MeasureGlyph

    GlyphBitMap -   pchBitMap       Pointer to bit map output buffer
                    sRowBytes       Same value as returned from fsc_MeasureGlyph
                    rectBounds      Same value as returned from fsc_MeasureGlyph
  
    uint16      -   usBandType      Old, Small, or Fast banding code
    
    uint16      -   usScanKind      Dropout control code

  Returned Values:

    GlyphBitMap -   Bit map output buffer filled in.

*/

FS_PUBLIC int32 fsc_FillGlyph( 
        ContourList*,       /* glyph outline */
        GlyphBitMap*,       /* target */
        WorkScan*,          /* for scan array */
        uint16,             /* banding type */
        uint16              /* scan type */
);

/*********************************************************************

  fsc_CalcGrayMap

    This routine calculates a gray scale bitmap from an overscaled bitmap
    
  Input Values:

    GlyphBitMap1 -  pchBitMap       Pointer to over scaled bit map
                    sRowBytes       Same value as returned from fsc_MeasureGlyph
                    rectBounds      Same value as returned from fsc_MeasureGlyph
    
    GlyphBitMap2 -  pchBitMap       Pointer to gray scale bit map output buffer
                    sRowBytes       1 byte per pixel
                    rectBounds      Same value as returned from fsc_MeasureExtrema
    
    uint16       -  usOverScale     Gray scale contour multiplier
  
  Returned Values:

    GlyphBitMap2 -  Gray scale bit map output buffer filled in.

*/

FS_PUBLIC int32 fsc_CalcGrayMap( 
        GlyphBitMap*,       /* over scaled source */
        GlyphBitMap*,       /* gray scale target */
        uint16              /* over scale factor */
);


/*********************************************************************

  fsc_GetCoords

    This routine returns an array of coordinates for outline points
    
  Input Values:

    ContourList -   All values set (pointers to contour arrays)
    
    uint16      -   usPointCount    Number of points to look up

    uint16*     -   pusPointIndex   Array of point indices
  
  Returned Values:

    pxyCoords   -   Array of (x,y) integer (pixel) coordinates

*/

FS_PUBLIC int32 fsc_GetCoords(
        ContourList*,       /* glyph outline */
        uint16,             /* point count */
        uint16*,            /* point indices */
        PixCoord*           /* point coordinates */
);

 /*********************************************************************/

#ifdef FSCFG_SUBPIXEL

/*********************************************************************

  fsc_OverscaleToSubPixel

    This routine is the heart of the RGB striping algorithm
    
  Input Values:

    OverscaledBitmap
  
  Returned Values:

    SubPixelBitMap

*/

FS_PUBLIC void fsc_OverscaleToSubPixel (
    GlyphBitMap * OverscaledBitmap, 
	boolean bgrOrder, 
    GlyphBitMap * SubPixelBitMap
);

 /*********************************************************************/

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\scendpt.c ===
/*********************************************************************

	  scendpt.c -- New Scan Converter EndPoint Module

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   6/10/93  deanb   assert.h and stdio.h removed
	   3/19/93  deanb   size_t replaced with int32
	  10/28/92  deanb   reentrant params renamed
	  10/09/92  deanb   reentrant
	   9/25/92  deanb   branch on scan kind 
	   9/14/92  deanb   check vert topology written 
	   9/10/92  deanb   first dropout code 
	   8/18/92  deanb   include struc.h, scconst.h 
	   6/18/92  deanb   int x coord for HorizScanAdd 
	   5/08/92  deanb   reordered includes for precompiled headers 
	   4/21/92  deanb   Single HorizScanAdd 
	   4/09/92  deanb   New types 
	   4/06/92  deanb   Check Topology corrected 
	   4/02/92  deanb   Coded 
	   3/23/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */

#include    "scglobal.h"            /* structures & constants */
#include    "scanlist.h"            /* saves scan line intersections */
#include    "scendpt.h"             /* for own function prototypes */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE void CheckHorizTopology( PSTATE F26Dot6, F26Dot6, uint16 );
FS_PRIVATE void CheckVertTopology( PSTATE F26Dot6, F26Dot6, uint16 );

FS_PRIVATE void AddHorizOn( PSTATE uint16 );
FS_PRIVATE void AddHorizOff( PSTATE uint16 );
FS_PRIVATE void AddVertOn( PSTATE uint16 );
FS_PRIVATE void AddVertOff( PSTATE uint16 );

FS_PRIVATE F26Dot6 CalcHorizEpSubpix( int32, F26Dot6*, F26Dot6* );
FS_PRIVATE F26Dot6 CalcVertEpSubpix( int32, F26Dot6*, F26Dot6* );


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/

/*  pass callback routine pointers to scanlist for smart dropout control */

FS_PUBLIC void fsc_SetupEndPt (PSTATE0) 
{
	fsc_SetupCallBacks(ASTATE SC_ENDPTCODE, CalcHorizEpSubpix, CalcVertEpSubpix);
}

/*********************************************************************/

FS_PUBLIC void fsc_BeginContourEndpoint( 
		PSTATE               /* pointer to state variables */
		F26Dot6 fxX,         /* starting point x coordinate */
		F26Dot6 fxY )        /* starting point y coordinate */
{
	STATE.fxX1 = fxX;                   /* last = contour start point */
	STATE.fxY1 = fxY;
	STATE.fxX0 = HUGEFIX;               /* contour begin alert */
}


/*********************************************************************/

FS_PUBLIC int32 fsc_CheckEndPoint( 
		PSTATE               /* pointer to state variables */
		F26Dot6 fxX2,        /* x coordinate */
		F26Dot6 fxY2,        /* y coordinate */
		uint16 usScanKind )  /* dropout control type */
{
	if (ONSCANLINE(STATE.fxY1))             /* if y1 is on scan line */
	{
		if ((STATE.fxX1 == fxX2) && (STATE.fxY1 == fxY2)) /* catch dup'd points */
		{
			return NO_ERR;                  /*   and just ignore them   */
		}
				
		if (STATE.fxX0 == HUGEFIX)          /* if contour begin */
		{
			STATE.fxX2Save = fxX2;          /*   keep for contour end   */
			STATE.fxY2Save = fxY2;          
		}
		else                                /* if mid contour */
		{
			CheckHorizTopology(ASTATE fxX2, fxY2, usScanKind);
		}               
	}
	
	if (!(usScanKind & SK_NODROPOUT))       /* if dropout control on */
	{
		if (ONSCANLINE(STATE.fxX1))         /* if x1 is on scan line */
		{
			if ((STATE.fxX1 == fxX2) && (STATE.fxY1 == fxY2)) /* catch dup'd points */
			{
				return NO_ERR;              /*   and just ignore them   */
			}
				
			if (STATE.fxX0 == HUGEFIX)      /* if contour begin */
			{
				STATE.fxX2Save = fxX2;      /*   keep for contour end   */
				STATE.fxY2Save = fxY2;
			}
			else                            /* if mid contour */
			{
				CheckVertTopology(ASTATE fxX2, fxY2, usScanKind);
			}               
		}
	}

	STATE.fxX0 = STATE.fxX1;                /* old = last */
	STATE.fxY0 = STATE.fxY1;
	STATE.fxX1 = fxX2;                      /* last = current */
	STATE.fxY1 = fxY2;
	
	return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC int32 fsc_EndContourEndpoint( 
		PSTATE                          /* pointer to state variables */
		uint16 usScanKind )             /* dropout control type */
{
	if (ONSCANLINE(STATE.fxY1))             /* if y1 is on scan line */
	{
		CheckHorizTopology(ASTATE STATE.fxX2Save, STATE.fxY2Save, usScanKind);
	}
	
	if (!(usScanKind & SK_NODROPOUT))       /* if dropout control on */
	{
		if (ONSCANLINE(STATE.fxX1))         /* if x1 is on scan line */
		{
			CheckVertTopology(ASTATE STATE.fxX2Save, STATE.fxY2Save, usScanKind);
		}
	}
	return NO_ERR;
}

/*********************************************************************/

/*      Private Functions      */

/*********************************************************************/

/*      Implement the endpoint-on-horiz-scanline case table    */

FS_PRIVATE void CheckHorizTopology(PSTATE F26Dot6 fxX2, F26Dot6 fxY2, uint16 usScanKind)
{

/* printf("(%li, %li)", fxX2, fxY2); */

	if (fxY2 > STATE.fxY1)
	{
		if (STATE.fxY1 > STATE.fxY0)
		{
			AddHorizOn(ASTATE usScanKind);
		}
		else if (STATE.fxY1 < STATE.fxY0)
		{
			AddHorizOn(ASTATE usScanKind);
			AddHorizOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxY1 == STATE.fxY0) */
		{
			if (STATE.fxX1 < STATE.fxX0)
			{
				AddHorizOn(ASTATE usScanKind);
			}
		}
	}
	else if (fxY2 < STATE.fxY1)
	{
		if (STATE.fxY1 > STATE.fxY0)
		{
			AddHorizOn(ASTATE usScanKind);
			AddHorizOff(ASTATE usScanKind);
		}
		else if (STATE.fxY1 < STATE.fxY0)
		{
			AddHorizOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxY1 == STATE.fxY0) */
		{
			if (STATE.fxX1 > STATE.fxX0)
			{
				AddHorizOff(ASTATE usScanKind);
			}
		}
	}
	else                        /* (fxY2 == STATE.fxY1) */
	{
		if (STATE.fxY1 > STATE.fxY0)
		{
			if (fxX2 > STATE.fxX1)
			{
				AddHorizOn(ASTATE usScanKind);
			}
		}
		else if (STATE.fxY1 < STATE.fxY0)
		{
			if (fxX2 < STATE.fxX1)
			{
				AddHorizOff(ASTATE usScanKind);
			}
		}
		else                    /* (STATE.fxY1 == STATE.fxY0) */
		{
			if ((STATE.fxX1 > STATE.fxX0) && (fxX2 < STATE.fxX1))
			{
				AddHorizOff(ASTATE usScanKind);
			}
			else if ((STATE.fxX1 < STATE.fxX0) && (fxX2 > STATE.fxX1))
			{
				AddHorizOn(ASTATE usScanKind);
			}
		}
	}
}


/*********************************************************************/

/*      Implement the endpoint-on-vert-scanline case table      */

FS_PRIVATE void CheckVertTopology(PSTATE F26Dot6 fxX2, F26Dot6 fxY2, uint16 usScanKind)
{
	if (fxX2 < STATE.fxX1)
	{
		if (STATE.fxX1 < STATE.fxX0)
		{
			AddVertOn(ASTATE usScanKind);
		}
		else if (STATE.fxX1 > STATE.fxX0)
		{
			AddVertOn(ASTATE usScanKind);
			AddVertOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxX1 == STATE.fxX0) */
		{
			if (STATE.fxY1 < STATE.fxY0)
			{
				AddVertOn(ASTATE usScanKind);
			}
		}
	}
	else if (fxX2 > STATE.fxX1)
	{
		if (STATE.fxX1 < STATE.fxX0)
		{
			AddVertOn(ASTATE usScanKind);
			AddVertOff(ASTATE usScanKind);
		}
		else if (STATE.fxX1 > STATE.fxX0)
		{
			AddVertOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxX1 == STATE.fxX0) */
		{
			if (STATE.fxY1 > STATE.fxY0)
			{
				AddVertOff(ASTATE usScanKind);
			}
		}
	}
	else                        /* (fxX2 == STATE.fxX1) */
	{
		if (STATE.fxX1 < STATE.fxX0)
		{
			if (fxY2 > STATE.fxY1)
			{
				AddVertOn(ASTATE usScanKind);
			}
		}
		else if (STATE.fxX1 > STATE.fxX0)
		{
			if (fxY2 < STATE.fxY1)
			{
				AddVertOff(ASTATE usScanKind);
			}
		}
		else                    /* (STATE.fxX1 == STATE.fxX0) */
		{
			if ((STATE.fxY1 > STATE.fxY0) && (fxY2 < STATE.fxY1))
			{
				AddVertOff(ASTATE usScanKind);
			}
			else if ((STATE.fxY1 < STATE.fxY0) && (fxY2 > STATE.fxY1))
			{
				AddVertOn(ASTATE usScanKind);
			}
		}
	}
}


/*********************************************************************/
	
FS_PRIVATE void AddHorizOn( PSTATE uint16 usScanKind )
{
	int32 lXScan, lYScan;
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	fsc_BeginElement( ASTATE usScanKind, 1, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */
	
	lXScan = (int32)((STATE.fxX1 + SUBHALF - 1) >> SUBSHFT);
	lYScan = (int32)(STATE.fxY1 >> SUBSHFT);
	
	pfnAddHorizScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/
	
FS_PRIVATE void AddHorizOff( PSTATE uint16 usScanKind )
{
	int32 lXScan, lYScan;
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	fsc_BeginElement( ASTATE usScanKind, 4, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */

	lXScan = (int32)((STATE.fxX1 + SUBHALF) >> SUBSHFT);
	lYScan = (int32)(STATE.fxY1 >> SUBSHFT);
	
	pfnAddHorizScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/
	
FS_PRIVATE void AddVertOn( PSTATE uint16 usScanKind )
{
	int32 lXScan, lYScan;
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	fsc_BeginElement( ASTATE usScanKind, 2, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */

	lYScan = (int32)((STATE.fxY1 + SUBHALF - 1) >> SUBSHFT);
	lXScan = (int32)(STATE.fxX1 >> SUBSHFT);
	
	pfnAddVertScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/
	
FS_PRIVATE void AddVertOff( PSTATE uint16 usScanKind )
{
	int32 lXScan, lYScan;
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	fsc_BeginElement( ASTATE usScanKind, 1, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */

	lYScan = (int32)((STATE.fxY1 + SUBHALF) >> SUBSHFT);
	lXScan = (int32)(STATE.fxX1 >> SUBSHFT);
	
	pfnAddVertScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/

/*      Private Callback Functions                                   */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizEpSubpix(int32 lYScan, 
									 F26Dot6 *pfxX, 
									 F26Dot6 *pfxY )
{
	FS_UNUSED_PARAMETER(lYScan);
	FS_UNUSED_PARAMETER(pfxY);

/* printf("HorizEndpt(%li %li)\n", *pfxX, *pfxY); */

	return *pfxX;                           /* exact intersection */
}


/*********************************************************************/

FS_PRIVATE F26Dot6 CalcVertEpSubpix(int32 lXScan, 
									F26Dot6 *pfxX, 
									F26Dot6 *pfxY )
{
	FS_UNUSED_PARAMETER(lXScan);
	FS_UNUSED_PARAMETER(pfxX);

/* printf("VertEndpt (%li %li)\n", *pfxX, *pfxY); */

	return *pfxY;                           /* exact intersection */
}


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\scline.c ===
/*********************************************************************

	  scline.c -- New Scan Converter Line Module

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   6/10/93  deanb   assert.h and stdio.h removed
	   3/19/93  deanb   size_t replaced with int32
	  12/22/92  deanb   MultDivide replaced with LongMulDiv
	  10/28/92  deanb   mem requirement reworked
	  10/13/92  deanb   horiz / vert line rework
	  10/09/92  deanb   reentrant
	   9/25/92  deanb   branch on scan kind 
	   9/21/92  deanb   rework horiz & vert lines 
	   9/14/92  deanb   reflection correction with iX/YOffset 
	   9/10/92  deanb   first dropout code 
	   9/08/92  deanb   quickstep deleted 
	   8/18/92  deanb   include struc.h, scconst.h 
	   7/23/92  deanb   Back to x1,y1,x2,y2 input params 
	   7/17/92  deanb   Changed from longline to line 
	   6/18/92  deanb   Cross product line rendering  
	   3/23/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for subpix calc */

#include    "scglobal.h"            /* structures & constants */
#include    "scanlist.h"            /* saves scan line intersections */
#include    "scline.h"              /* for own function prototypes */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizLineSubpix(int32, F26Dot6*, F26Dot6*);
FS_PRIVATE F26Dot6 CalcVertLineSubpix(int32, F26Dot6*, F26Dot6*);


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/
	
/*  pass callback routine pointers to scanlist for smart dropout control */

FS_PUBLIC void fsc_SetupLine (PSTATE0) 
{
	fsc_SetupCallBacks(ASTATE SC_LINECODE, CalcHorizLineSubpix, CalcVertLineSubpix);
}


/*********************************************************************/

FS_PUBLIC int32 fsc_CalcLine( 
		PSTATE                /* pointer to state variables */
		F26Dot6 fxX1,         /* point 1  x coordinate */
		F26Dot6 fxY1,         /* point 1  y coordinate */
		F26Dot6 fxX2,         /* point 2  x coordinate */
		F26Dot6 fxY2,         /* point 2  y coordinate */
		uint16 usScanKind     /* dropout control type */
)
{
	int32 lXScan;                           /* current x pixel index */
	int32 lXSteps;                          /* vert scanline index count */
	int32 lXIncr;                           /* x pixel increment */
	int32 lXOffset;                         /* reflection correction */
	
	int32 lYScan;                           /* current scanline index */
	int32 lYSteps;                          /* horiz scanline index count */
	int32 lYIncr;                           /* y pixel increment */
	int32 lYOffset;                         /* reflection correction */

	F26Dot6 fxXInit, fxYInit;               /* sub steps to first pixel */
	F26Dot6 fxXScan, fxYScan;               /* x,y pixel center coords */
	F26Dot6 fxXX2, fxYY2;                   /* absolute value of DX, DY */
	F26Dot6 fxXTemp, fxYTemp;               /* for horiz/vert line calc */
	
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	int32 lQuadrant;                        /* 1, 2, 3, or 4 */
	int32 lQ;                               /* cross product */
	int32 lDQy, lDQx;                       /* cross product increments */
	int32 i;                                /* loop counter */


/* printf("(%li, %li) - (%li, %li)\n", fxX1, fxY1, fxX2, fxY2); */
	
/*  check y coordinates  */

	if (fxY2 >= fxY1)                           /* if going up or flat */
	{
		lQuadrant = 1;
		lQ = 0L;
		
		fxYScan = SCANABOVE(fxY1);              /* first scanline to cross */
		fxYInit = fxYScan - fxY1;               /* first y step */
		lYScan = (int32)(fxYScan >> SUBSHFT);
		lYSteps = (int32)((SCANBELOW(fxY2)) >> SUBSHFT) - lYScan + 1;
		lYIncr = 1;        
		lYOffset = 0;                           /* no reflection */
		fxYY2 = fxY2 - fxY1;                    /* translate */
	}
	else                                        /* if going down */
	{
		lQuadrant = 4;
		lQ = 1L;                                /* to include pixel centers */
		
		fxYScan = SCANBELOW(fxY1);              /* first scanline to cross */
		fxYInit = fxY1 - fxYScan;               /* first y step */
		lYScan = (int32)(fxYScan >> SUBSHFT);
		lYSteps = lYScan - (int32)((SCANABOVE(fxY2)) >> SUBSHFT) + 1;
		lYIncr = -1;        
		lYOffset = 1;                           /* reflection correction */
		fxYY2 = fxY1 - fxY2;                    /* translate and reflect */
	}
	
	if (fxY2 == fxY1)                           /* if horizontal line */
	{
		if (usScanKind & SK_NODROPOUT)          /* if no dropout control */
		{
			return NO_ERR;                      /* if only horiz scan, done */
		}
		if (fxX2 < fxX1)                        /* if going left  */
		{
			fxYTemp = fxY1 - 1;                 /* to include pix centers */
		}
		else                                    /* if going right */
		{
			fxYTemp = fxY1;          
		}
		lYScan = (int32)(SCANABOVE(fxYTemp) >> SUBSHFT);
		lYSteps = 0;
	}

/*  check x coordinates  */
	
	if (fxX2 >= fxX1)                           /* if going right or vertical */
	{
		fxXScan = SCANABOVE(fxX1);              /* first scanline to cross */
		fxXInit = fxXScan - fxX1;               /* first x step */
		lXScan = (int32)(fxXScan >> SUBSHFT);
		lXSteps = (int32)((SCANBELOW(fxX2)) >> SUBSHFT) - lXScan + 1;
		lXIncr = 1;        
		lXOffset = 0;                           /* no reflection */
		fxXX2 = fxX2 - fxX1;                    /* translate */
	}
	else                                        /* if going left */
	{
		lQ = 1L - lQ;                           /* reverse it */
		lQuadrant = (lQuadrant == 1) ? 2 : 3;   /* negative x choices */

		fxXScan = SCANBELOW(fxX1);              /* first scanline to cross */
		fxXInit = fxX1 - fxXScan;               /* first x step */
		lXScan = (int32)(fxXScan >> SUBSHFT);
		lXSteps = lXScan - (int32)((SCANABOVE(fxX2)) >> SUBSHFT) + 1;
		lXIncr = -1;        
		lXOffset = 1;                           /* reflection correction */
		fxXX2 = fxX1 - fxX2;                    /* translate and reflect */
	}
	
	if (fxX2 == fxX1)                           /* if vertical line       */
	{
		if (fxY2 > fxY1)                        /* if going up  */
		{
			fxXTemp = fxX1 - 1;                 /* to include pix centers */
		}
		else                                    /* if going down */
		{
			fxXTemp = fxX1;          
		}
		lXScan = (int32)(SCANABOVE(fxXTemp) >> SUBSHFT);
		lXSteps = 0;
	}

/*-------------------------------------------------------------------*/
	
	fsc_BeginElement( ASTATE usScanKind, lQuadrant, SC_LINECODE, /* where and what */
					  1, &fxX2, &fxY2,                           /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );       /* what to call */

/*-------------------------------------------------------------------*/

	if (usScanKind & SK_NODROPOUT)              /* if no dropout control */
	{
		if (fxX1 == fxX2)                       /* if vertical line */
		{
			for (i = 0; i < lYSteps; i++)       /*   then blast a column   */
			{
				pfnAddHorizScan(ASTATE lXScan, lYScan);
				lYScan += lYIncr;               /* advance y scan + or - */
			}
			return NO_ERR;
		}
		
/*  handle general case:  line is neither horizontal nor vertical  */

		lQ += (fxXX2 * fxYInit) - (fxYY2 * fxXInit);  /* cross product init */
		lDQy = fxXX2 << SUBSHFT;
		lDQx = -fxYY2 << SUBSHFT;
																	
		lXScan += lXOffset;

		for (i = 0; i < (lXSteps + lYSteps); i++)
		{
			if (lQ > 0L)                        /* if left of line */
			{
				lXScan += lXIncr;               /* advance x scan + or - */
				lQ += lDQx;           
			}
			else                                /* if right of line */
			{
				pfnAddHorizScan(ASTATE lXScan, lYScan);
				lYScan += lYIncr;               /* advance y scan + or - */
				lQ += lDQy;
			}
		}
	}
/*-------------------------------------------------------------------*/
	
	else  /* if dropout control */
	{                                           /* handle special case lines  */
		if (fxY1 == fxY2)                       /* if horizontal line */
		{
			for (i = 0; i < lXSteps; i++)       /*   then blast a row   */
			{
				pfnAddVertScan(ASTATE lXScan, lYScan);
				lXScan += lXIncr;               /* advance x scan + or - */
			}
			return NO_ERR;
		}

		if (fxX1 == fxX2)                       /* if vertical line */
		{
			for (i = 0; i < lYSteps; i++)       /*   then blast a column   */
			{
				pfnAddHorizScan(ASTATE lXScan, lYScan);
				lYScan += lYIncr;               /* advance y scan + or - */
			}
			return NO_ERR;
		}
		
/*  handle general case:  line is neither horizontal nor vertical  */

		lQ += (fxXX2 * fxYInit) - (fxYY2 * fxXInit);  /* cross product init */
		lDQy = fxXX2 << SUBSHFT;
		lDQx = -fxYY2 << SUBSHFT;
																	
		for (i = 0; i < (lXSteps + lYSteps); i++)
		{
			if (lQ > 0L)                        /* if left of line */
			{
				pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);
				lXScan += lXIncr;               /* advance x scan + or - */
				lQ += lDQx;           
			}
			else                                /* if right of line */
			{
				pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);
				lYScan += lYIncr;               /* advance y scan + or - */
				lQ += lDQy;
			}
		}
	}
	return NO_ERR;
}


/*********************************************************************/

/*      Private Callback Functions                                   */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizLineSubpix(int32 lYScan, 
									   F26Dot6 *pfxX, 
									   F26Dot6 *pfxY )
{
	F26Dot6 fxXDrop, fxYDrop;

/* printf("Line (%li, %li) - (%li, %li)", *pfxX, *pfxY, *(pfxX+1), *(pfxY+1)); */

	fxYDrop = ((F26Dot6)lYScan << SUBSHFT) + SUBHALF;
	
	Assert(((fxYDrop > *pfxY) && (fxYDrop < *(pfxY+1))) ||
		   ((fxYDrop < *pfxY) && (fxYDrop > *(pfxY+1))));

	fxXDrop = *pfxX + LongMulDiv(*(pfxX+1) - *pfxX, fxYDrop - *pfxY, *(pfxY+1) - *pfxY);

/* printf("  (%li, %li)\n", fxXDrop, fxYDrop); */

	return fxXDrop;
}


/*********************************************************************/

FS_PRIVATE F26Dot6 CalcVertLineSubpix(int32 lXScan, 
									  F26Dot6 *pfxX, 
									  F26Dot6 *pfxY )
{
	F26Dot6 fxXDrop, fxYDrop;

/* printf("Line (%li, %li) - (%li, %li)", *pfxX, *pfxY, *(pfxX+1), *(pfxY+1)); */

	fxXDrop = ((F26Dot6)lXScan << SUBSHFT) + SUBHALF;
	
	Assert(((fxXDrop > *pfxX) && (fxXDrop < *(pfxX+1))) ||
		   ((fxXDrop < *pfxX) && (fxXDrop > *(pfxX+1))));

	fxYDrop = *pfxY + LongMulDiv(*(pfxY+1) - *pfxY, fxXDrop - *pfxX, *(pfxX+1) - *pfxX);

/* printf("  (%li, %li)\n", fxXDrop, fxYDrop); */

	return fxYDrop;
}


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\scbitmap.c ===
/*********************************************************************

      scbitmap.c -- New Scan Converter BitMap Module

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

      10/03/93  deanb   use (x) in bitmask shift macros
       8/23/93  deanb   gray scale functions
       6/11/93  deanb   use MEMSET macro, string & stddef removed
       6/10/93  deanb   Start/Stop/Bit mask macros
       6/10/93  deanb   InitializeBitMasks added, stdio & assert removed
       4/29/93  deanb   BLTCopy routine added
       3/19/93  deanb   size_t caste checked
      10/14/92  deanb   memset for fsc_ClearBitMap
       9/15/92  deanb   Set bit coded 
       8/18/92  deanb   include scconst.h 
       6/02/92  deanb   Row pointer, integer limits, no descriptor 
       5/08/92  deanb   reordered includes for precompiled headers 
       5/04/92  deanb   Array tags added 
       4/27/92  deanb   Negative runs handled 
       4/16/92  deanb   Coding 
       3/23/92  deanb   First cut 

**********************************************************************/

#define FSCFG_INTERNAL

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/


#include    "fscdefs.h"             /* shared data types */
#include    "scgray.h"              /* gray scale param block */
#include    "fserror.h"             /* error codes */
#include    "scbitmap.h"            /* for own function prototypes */


/*********************************************************************/

/*      Constants                                                    */

/*********************************************************************/

#define     MASKSIZE    32              /* bits per bitmap masks */
#define     MASKSHIFT   5               /* log2 of MASKSIZE */
#define     MASKBITS    0x0000001FL     /* masks pix loc of long word */

#define     ALL_ONES    ((uint32)0xFFFFFFFFL)
#define     HIGH_ONE    ((uint32)0x80000000L)


/*********************************************************************/

/*      Bitmask definitions                                          */

/*********************************************************************/
    
#ifndef FSCFG_USE_MASK_SHIFT    /* if using bitmask tables */

#define START_MASK(x)   aulStartBits[x]
#define STOP_MASK(x)    aulStopBits[x]
#define BIT_MASK(x)     aulBitMask[x]

/*  bitmask tables */

FS_PRIVATE uint32 aulStartBits[MASKSIZE];       /* such as:  0000111 */
FS_PRIVATE uint32 aulStopBits[MASKSIZE];        /* such as:  1110000 */
FS_PRIVATE uint32 aulBitMask[MASKSIZE];         /* such as:  0001000 */


#else                           /* if using bitmask shift */

#define START_MASK(x)   (ALL_ONES >> (x))
#define STOP_MASK(x)    (ALL_ONES << ((MASKSIZE - 1) - (x)))
#define BIT_MASK(x)     (HIGH_ONE >> (x))

#endif


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/

/*      fsc_InitializeBitMasks() loads the arrays of 32-bit masks at 
 *      runtime to create CPU independent bitmap masks.
 *
 *      It is conditionally compiled because the arrays are unused
 *      in a "USE_MASK_SHIFT" (e.g. Apple, HP) configuration. 
 *
 *      We load the arrays by converting the Big-Endian value of
 *      the mask to the "native" representation of that mask.  The
 *      "native" representation can be applied to a "native" byte
 *      array to manipulate more than 8 bits at a time of an output
 *      bitmap.
 */

FS_PUBLIC void fsc_InitializeBitMasks (void)
{
#ifndef FSCFG_USE_MASK_SHIFT

    int32 lIdx;
    uint32 ulStartMask;
    uint32 ulStopMask;
    uint32 ulBitMask;

    ulStartMask = ALL_ONES;
    ulStopMask = ALL_ONES;
    ulBitMask = HIGH_ONE;
    
    for (lIdx = 0; lIdx < MASKSIZE; lIdx++)
    {
        aulStartBits[lIdx] = (uint32) SWAPL(ulStartMask);
        aulStopBits[MASKSIZE - lIdx - 1] = (uint32) SWAPL(ulStopMask);
        aulBitMask[lIdx] = (uint32) SWAPL(ulBitMask);

        ulStartMask >>= 1;
        ulStopMask <<= 1;
        ulBitMask >>= 1;
    }
#endif
}


/*********************************************************************/

FS_PUBLIC int32 fsc_ClearBitMap (
        uint32 ulBMPLongs, 
        uint32 *pulMap )
{
    size_t stBytes;

    stBytes = (size_t)ulBMPLongs << 2;

    Assert((uint32)stBytes == (ulBMPLongs << 2));

    MEMSET((void*)pulMap, 0, stBytes);
    
    return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC int32 fsc_BLTHoriz (
        int32 lXStart, 
        int32 lXStop, 
        uint32 *pulMap )                 
{
    int32 lSkip;

    lSkip = (lXStart >> MASKSHIFT);         /* longwords to first black */
    pulMap += lSkip;
    lXStart -= lSkip << MASKSHIFT;          /* correct start/stop */
    lXStop -= lSkip << MASKSHIFT;
    while (lXStop >= MASKSIZE)
    {
        *pulMap |= START_MASK(lXStart);
        pulMap++;
        lXStart = 0;
        lXStop -= MASKSIZE;
    }
    *pulMap |= START_MASK(lXStart) & STOP_MASK(lXStop);
    return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC int32 fsc_BLTCopy ( 
        uint32 *pulSource,         /* source row pointer */
        uint32 *pulDestination,    /* destination row pointer */
        int32 lCount )             /* long word counter */
{
    while (lCount)
    {
        *pulDestination = *pulSource;
        pulDestination++;
        pulSource++;
        lCount--;
    }
    return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC uint32 fsc_GetBit( 
        int32 lXCoord,              /* x coordinate */
        uint32* pulMap )            /* bit map row pointer */
{
    return(pulMap[lXCoord >> MASKSHIFT] & BIT_MASK(lXCoord & MASKBITS));
}


/*********************************************************************/

FS_PUBLIC int32 fsc_SetBit( 
        int32 lXCoord,              /* x coordinate */
        uint32* pulMap )            /* bit map row pointer */
{
    pulMap[lXCoord >> MASKSHIFT] |= BIT_MASK(lXCoord & MASKBITS);
    
    return NO_ERR;
}


/*********************************************************************/

/*  Gray scale row bitmap calculation                                */
/*  Count one row of over scale pixels into gray scale row           */

/*********************************************************************/
                
FS_PUBLIC int32 fsc_CalcGrayRow(
        GrayScaleParam* pGSP
)
{            
    char        *pchOver;               /* pointer to overscaled bitmap */
    char        *pchGray;               /* pointer to gray scale bitmap */
    uint16      usShiftMask;            /* masks off over scaled bits of interest */
    uint16      usGoodBits;             /* number of valid bits in usOverBits */
    uint16      usOverBits;             /* a byte of overscaled bitmap */
    int16       sGrayColumns;           /* number of gray columns to calc */
    
    static char chCount[256] = {        /* count of one bits */    
        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
    };


    pchGray = pGSP->pchGray;
    pchOver = pGSP->pchOver;
    sGrayColumns = pGSP->sGrayCol;
    usShiftMask = 0x00FF >> (8 - pGSP->usOverScale);  /* over bits per gray pix */
    usGoodBits = 8 - pGSP->usFirstShift;
    usOverBits = ((uint16)*pchOver) >> pGSP->usFirstShift;
                
    Assert (pchGray >= pGSP->pchGrayLo);
    Assert (pchGray < pGSP->pchGrayHi);
    
    *pchGray += chCount[usOverBits & usShiftMask];
    pchGray--;                              /* move backwards through both bitmaps! */
    sGrayColumns--;

    while (sGrayColumns > 0)                /* for each gray column (after 1st) */
    {
        usGoodBits -= pGSP->usOverScale;
        if (usGoodBits > 0)                 /* if bits remain in over byte */
        {
            usOverBits >>= pGSP->usOverScale;
        }
        else                                /* if we've looked at everything */
        {
            pchOver--;

            Assert (pchOver >= pGSP->pchOverLo);
            Assert (pchOver < pGSP->pchOverHi);

            usOverBits = (uint16)*pchOver;
            usGoodBits = 8;
        }

        Assert (pchGray >= pGSP->pchGrayLo);
        Assert (pchGray < pGSP->pchGrayHi);

        *pchGray += chCount[usOverBits & usShiftMask];  /* accumulate count */
        pchGray--;
        sGrayColumns--;
    }
    return NO_ERR;
}

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\sfnt_en.h ===
/*
	File:       sfnt_en.h

	Written by: Mike Reed

	Copyright:  c 1989-1990 by Apple Computer, Inc., all rights reserved.

	Change History (most recent first):

		<8+>     7/16/90    MR      Fixed INTEL version of tag_GlyphData
		 <8>     7/16/90    MR      Conditionalize redefinition of script codes
		 <7>     7/13/90    MR      Conditionalize enums to allow for byte-reversal on INTEL chips
		 <6>     6/30/90    MR      Remove tag reference to 'mvt ' and 'cryp'
		 <4>     6/26/90    MR      Add all script codes, with SM naming conventions
		 <3>     6/20/90    MR      Change tag enums to #defines to be ansi-correct
		 <2>      6/1/90    MR      Add postscript name to sfnt_NameIndex and 'post' to tags.
	To Do:
*/

#ifndef SFNT_ENUMS

#define SFNT_ENUMS

typedef enum {
	plat_Unicode,
	plat_Macintosh,
	plat_ISO,
	plat_MS
} sfnt_PlatformEnum;

#ifndef __SCRIPT__
typedef enum {
	smRoman,
	smJapanese,
	smTradChinese,
	smChinese = smTradChinese,
	smKorean,
	smArabic,
	smHebrew,
	smGreek,
	smCyrillic,
	smRussian = smCyrillic,
	smRSymbol,
	smDevanagari,
	smGurmukhi,
	smGujarati,
	smOriya,
	smBengali,
	smTamil,
	smTelugu,
	smKannada,
	smMalayalam,
	smSinhalese,
	smBurmese,
	smKhmer,
	smThai,
	smLaotian,
	smGeorgian,
	smArmenian,
	smSimpChinese,
	smTibetan,
	smMongolian,
	smGeez,
	smEthiopic = smGeez,
	smAmharic = smGeez,
	smSlavic,
	smEastEurRoman = smSlavic,
	smVietnamese,
	smExtArabic,
	smSindhi = smExtArabic,
	smUninterp
} sfnt_ScriptEnum;
#endif

typedef enum {
	lang_English,
	lang_French,
	lang_German,
	lang_Italian,
	lang_Dutch,
	lang_Swedish,
	lang_Spanish,
	lang_Danish,
	lang_Portuguese,
	lang_Norwegian,
	lang_Hebrew,
	lang_Japanese,
	lang_Arabic,
	lang_Finnish,
	lang_Greek,
	lang_Icelandic,
	lang_Maltese,
	lang_Turkish,
	lang_Yugoslavian,
	lang_Chinese,
	lang_Urdu,
	lang_Hindi,
	lang_Thai
} sfnt_LanguageEnum;

typedef enum {
	name_Copyright,
	name_Family,
	name_Subfamily,
	name_UniqueName,
	name_FullName,
	name_Version,
	name_Postscript
} sfnt_NameIndex;

typedef uint32 sfnt_TableTag;

#define tag_CharToIndexMap      0x636d6170        /* 'cmap' */
#define tag_ControlValue        0x63767420        /* 'cvt ' */
#define tag_BitmapData          0x45424454        /* 'EBDT' */
#define tag_BitmapLocation      0x45424c43        /* 'EBLC' */
#define tag_BitmapScale         0x45425343        /* 'EBSC' */
#define tag_Editor0             0x65647430        /* 'edt0' */
#define tag_Editor1             0x65647431        /* 'edt1' */
#define tag_Encryption          0x63727970        /* 'cryp' */
#define tag_FontHeader          0x68656164        /* 'head' */
#define tag_FontProgram         0x6670676d        /* 'fpgm' */
#define tag_GridfitAndScanProc	0x67617370		  /* 'gasp' */
#define tag_GlyphDirectory      0x67646972        /* 'gdir' */
#define tag_GlyphData           0x676c7966        /* 'glyf' */
#define tag_HoriDeviceMetrics   0x68646d78        /* 'hdmx' */
#define tag_HoriHeader          0x68686561        /* 'hhea' */
#define tag_HorizontalMetrics   0x686d7478        /* 'hmtx' */
#define tag_IndexToLoc          0x6c6f6361        /* 'loca' */
#define tag_Kerning             0x6b65726e        /* 'kern' */
#define tag_LinearThreshold     0x4c545348        /* 'LTSH' */
#define tag_MaxProfile          0x6d617870        /* 'maxp' */
#define tag_NamingTable         0x6e616d65        /* 'name' */
#define tag_OS_2                0x4f532f32        /* 'OS/2' */
#define tag_Postscript          0x706f7374        /* 'post' */
#define tag_PreProgram          0x70726570        /* 'prep' */
#define tag_VertDeviceMetrics	0x56444d58		  /* 'VDMX' */
#define tag_VertHeader	        0x76686561		  /* 'vhea' */
#define tag_VerticalMetrics     0x766d7478		  /* 'vmtx' */

#define tag_TTO_GSUB     		0x47535542		  /* 'GSUB' */
#define tag_TTO_GPOS     		0x47504F53		  /* 'GPOS' */
#define tag_TTO_GDEF     		0x47444546		  /* 'GDEF' */
#define tag_TTO_BASE     		0x42415345		  /* 'BASE' */
#define tag_TTO_JSTF     		0x4A535446		  /* 'JSTF' */

#endif      /* not sfnt_enums */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\stat.h ===
/*********************************************************************/
/*                                                                   */
/*    stat.h -- stat.asm exports                                     */
/*                                                                   */
/*    (c) Copyright 1992  Microsoft Corp.  All rights reserved.      */
/*                                                                   */
/*     4/9/96  claudebe adding profiling with IceCAP                 */
/*     2/26/93 deanb    macros come back                             */
/*     2/22/93 deanb    timing switch moved to fsconfig.h macros     */
/*     2/11/93 deanb    __cdecl's for ms C8                          */
/*    12/22/92 deanb    Apple types                                  */
/*    11/20/92 deanb    Timing switches revised                      */
/*    11/17/92 deanb    First cut                                    */
/*                                                                   */
/*********************************************************************/

/* STAT Card Timing Switches */

#ifdef FSCFG_USESTATCARD         /* compile option for profiling */
  #define STAT_ON               gbTimer = TRUE; StartSample();
  #define STAT_OFF              StopSample(); gbTimer = FALSE;
  #define STAT_ON_CALLBACK      if (gbTimer) StartSample();
  #define STAT_OFF_CALLBACK     if (gbTimer) StopSample();
#elif FSCFG_USEICECAP          /* compile option for profiling with IceCAP */
//#include <ICAPExp.h>
  #define STAT_ON               gbTimer = TRUE; StartCAP();
  #define STAT_OFF              StopCAP(); gbTimer = FALSE;
  #define STAT_ON_CALLBACK      if (gbTimer) ResumeCAP();
  #define STAT_OFF_CALLBACK     if (gbTimer) SuspendCAP();
#else
  #define STAT_ON
  #define STAT_OFF
  #define STAT_ON_CALLBACK
  #define STAT_OFF_CALLBACK
#endif

#if 1

#define STAT_ON_NEWSFNT         STAT_ON
#define STAT_OFF_NEWSFNT        STAT_OFF
#define STAT_ON_NEWTRAN         STAT_ON
#define STAT_OFF_NEWTRAN        STAT_OFF
#define STAT_ON_NEWGLYPH        STAT_ON
#define STAT_OFF_NEWGLYPH       STAT_OFF
#define STAT_ON_GRIDFIT         STAT_ON
#define STAT_OFF_GRIDFIT        STAT_OFF
#define STAT_ON_FINDBMS         STAT_ON
#define STAT_OFF_FINDBMS        STAT_OFF
#define STAT_ON_SCAN            STAT_ON
#define STAT_OFF_SCAN           STAT_OFF
#define STAT_ON_FNTEXEC         
#define STAT_OFF_FNTEXEC        
#define STAT_ON_IUP
#define STAT_OFF_IUP
#define STAT_ON_CALCORIG
#define STAT_OFF_CALCORIG

#else

#define STAT_ON_NEWSFNT
#define STAT_OFF_NEWSFNT
#define STAT_ON_NEWTRAN
#define STAT_OFF_NEWTRAN
#define STAT_ON_NEWGLYPH
#define STAT_OFF_NEWGLYPH
#define STAT_ON_GRIDFIT         STAT_ON         
#define STAT_OFF_GRIDFIT        STAT_OFF         
#define STAT_ON_FINDBMS   
#define STAT_OFF_FINDBMS  
#define STAT_ON_SCAN            
#define STAT_OFF_SCAN           
#define STAT_ON_FNTEXEC
#define STAT_OFF_FNTEXEC
#define STAT_ON_IUP
#define STAT_OFF_IUP
#define STAT_ON_CALCORIG
#define STAT_OFF_CALCORIG

#endif

/*********************************************************************/

/*              Global timing variable                               */

/*********************************************************************/

extern boolean gbTimer;                /* set true when timer running */

/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/


#ifdef FSCFG_USESTATCARD         /* compile option for profiling */

uint16 __cdecl  InitStat( void );

uint16 __cdecl  ConfigElapsed( void );

uint16 __cdecl  ConfigSample( void );

uint16 __cdecl  StartElapsed( void );

uint16 __cdecl  StartSample( void );

uint32 __cdecl  ReadElapsed( void );

uint32 __cdecl  ReadSample( void );

uint16 __cdecl  ReadSample_Count( void );

uint16 __cdecl  StopElapsed( void );

uint16 __cdecl  StopSample( void );

uint16 __cdecl  ResetElapsed( void );

uint16 __cdecl  ResetSample( void );

#endif  /* FSCFG_USESTATCARD */

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\scspline.c ===
/*********************************************************************

      scspline.c -- New Scan Converter Spline Module

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       6/10/93  deanb   assert.h and stdio.h removed
       3/19/93  deanb   size_t replaced with int32
      10/28/92  deanb   memory requirements reworked
      10/09/92  deanb   reentrant
       9/28/92  deanb   quick out for nearly vert/horiz splines 
       9/25/92  deanb   branch on scan kind 
       9/22/92  deanb   subpix calculation using subdivision 
       9/14/92  deanb   reflection correction with iX/YOffset 
       9/10/92  deanb   first dropout code 
       9/02/92  deanb   Precision reduction by shifting control points 
       7/24/92  deanb   Initial Q set for perfect symmetry 
       7/23/92  deanb   EvaluateSpline split out and moved to NewScan 
       7/20/92  deanb   removed unreachable case 
       7/16/92  deanb   faster power of 2 
       7/06/92  deanb   Cleanups 
       7/01/92  deanb   Reinstate a single spline routine 
       6/30/92  deanb   Implicit spline rendering 
       3/23/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for power of 2 calc */

#include    "scglobal.h"            /* structures & constants */
#include    "scanlist.h"            /* for direct horizscan add call */
#include    "scspline.h"            /* for own function prototypes */
                
/*********************************************************************/

/*      Constants                                                    */

/*********************************************************************/

#define     QMAXSHIFT      7            /* shift limit q precision */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/
 
FS_PRIVATE F26Dot6 CalcHorizSpSubpix(int32, F26Dot6*, F26Dot6*);
FS_PRIVATE F26Dot6 CalcVertSpSubpix(int32, F26Dot6*, F26Dot6*);


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/
    
/*  pass callback routine pointers to scanlist for smart dropout control */

FS_PUBLIC void fsc_SetupSpline (PSTATE0) 
{
    fsc_SetupCallBacks(ASTATE SC_SPLINECODE, CalcHorizSpSubpix, CalcVertSpSubpix);
}


/*********************************************************************/

FS_PUBLIC int32 fsc_CalcSpline( 
        PSTATE                  /* pointer to state variables */
        F26Dot6 fxX1,           /* start point x coordinate */
        F26Dot6 fxY1,           /* start point y coordinate */
        F26Dot6 fxX2,           /* control point x coordinate */
        F26Dot6 fxY2,           /* control point y coordinate */
        F26Dot6 fxX3,           /* ending x coordinate */
        F26Dot6 fxY3,           /* ending y coordinate */
        uint16 usScanKind )     /* dropout control type */
{
    F26Dot6 fxXInit, fxYInit;           /* initial step values */
    F26Dot6 fxXScan, fxYScan;           /* set to first crossings */
    F26Dot6 fxXX2, fxYY2;               /* translated reflected control point */
    F26Dot6 fxXX3, fxYY3;               /* translated reflected end point */
    
    F26Dot6 afxXControl[2];             /* params for BeginElement call */
    F26Dot6 afxYControl[2];

    void (*pfnAddHorizScan)(PSTATE int32, int32);
    void (*pfnAddVertScan)(PSTATE int32, int32);
    
    int32 lABits;                       /* 1+int(log2(alpha)) */
    int32 lXYBits;                      /* 1+int(log2(max(x3,y3))) */
    int32 lZBits;                       /* 6, 5, 4 log2(subpixels per pix) */
    int32 lZShift;                      /* 0, 1, 2 shift to minipixel */
    F26Dot6 fxZRound;                   /* rounding factor for minipix shift */
    F26Dot6 fxZSubpix;                  /* 64, 32, 16 subpixels per pix */
    int32 lQuadrant;                    /* 1, 2, 3, or 4 */

    F26Dot6 fxAx, fxAy;                 /* parametric 2nd order terms */
    F26Dot6 lAlpha;                     /* cross product measures curvature */

    int32 lR, lT;                       /* quadratic coefficients for xx, yy */
    int32 lS2, lU2, lV2;                /* half coefficients for xy, x, y */
    int32 lRz, lSz, lTz;                /* coeff's times subpix size */
        
    int32 lQ;                           /* cross product value */
    int32 lDQx, lDQy;                   /* first order derivative */
    int32 lDDQx, lDDQy;                 /* second order derivative */

    int32 lYScan;                       /* scan line counter */
    int32 lYStop;                       /* scan line end */
    int32 lYIncr;                       /* scan line direction */
    int32 lYOffset;                     /* reflection correction */
    int32 lXScan;                       /* horiz pix position */
    int32 lXStop;                       /* pix end */
    int32 lXIncr;                       /* pix increment direction */
    int32 lXOffset;                     /* reflection correction */

    static const int32 lZShiftTable[] = { /* for precision adjustment */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /*  0 -  9  */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /* 10 - 19 */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /* 20 - 29 */
        1, 1, 1, 2, 2, 2, 3, 3          /* 30 - 34 */
    };


/* printf("(%li, %li) - (%li, %li) -(%li, %li)\n", fxX1, fxY1, fxX2, fxY2, fxX3, fxY3 ); */


/*  Translate spline point 1 to (0,0) and reflect into the first quadrant  */
    
    if (fxY3 > fxY1)                            /* if going up */
    {
        lQ = 0L;
        lQuadrant = 1;

        fxYScan = SCANABOVE(fxY1);              /* first scanline to cross */
        fxYInit = fxYScan - fxY1;               /* first y step */
        lYScan = (int32)(fxYScan >> SUBSHFT);
        lYStop = (int32)((SCANBELOW(fxY3)) >> SUBSHFT) + 1;
        lYIncr = 1;        
        lYOffset = 0;                           /* no reflection */
        fxYY2 = fxY2 - fxY1;                    /* translate */
        fxYY3 = fxY3 - fxY1;
    }
    else                                        /* if going down */
    {
        lQ = 1L;                                /* to include pixel centers */
        lQuadrant = 4;
        
        fxYScan = SCANBELOW(fxY1);              /* first scanline to cross */
        fxYInit = fxY1 - fxYScan;               /* first y step */
        lYScan = (int32)(fxYScan >> SUBSHFT);
        lYStop = (int32)((SCANABOVE(fxY3)) >> SUBSHFT) - 1;
        lYIncr = -1;        
        lYOffset = 1;                           /* reflection correction */
        fxYY2 = fxY1 - fxY2;                    /* translate and reflect */
        fxYY3 = fxY1 - fxY3;
    }
    
    if (fxX3 > fxX1)                            /* if going right */
    {
        fxXScan = SCANABOVE(fxX1);              /* first scanline to cross */
        fxXInit = fxXScan - fxX1;               /* first x step */
        lXScan = (int32)(fxXScan >> SUBSHFT);
        lXStop = (int32)((SCANBELOW(fxX3)) >> SUBSHFT) + 1;
        lXIncr = 1;        
        lXOffset = 0;                           /* no reflection */
        fxXX2 = fxX2 - fxX1;                    /* translate */
        fxXX3 = fxX3 - fxX1;
    }
    else                                        /* if going left or straight */
    {
        lQ = 1L - lQ;                           /* to include pixel centers */
        lQuadrant = (lQuadrant == 1) ? 2 : 3;   /* negative x choices */

        fxXScan = SCANBELOW(fxX1);              /* first scanline to cross */
        fxXInit = fxX1 - fxXScan;               /* first x step */
        lXScan = (int32)(fxXScan >> SUBSHFT);
        lXStop = (int32)((SCANABOVE(fxX3)) >> SUBSHFT) - 1;
        lXIncr = -1;        
        lXOffset = 1;                           /* reflection correction */
        fxXX2 = fxX1 - fxX2;                    /* translate and reflect */
        fxXX3 = fxX1 - fxX3;
    }

/*-------------------------------------------------------------------*/
    
    afxXControl[0] = fxX2;
    afxYControl[0] = fxY2;
    afxXControl[1] = fxX3;
    afxYControl[1] = fxY3;

    fsc_BeginElement( ASTATE usScanKind, lQuadrant, SC_SPLINECODE,  /* where and what */
                      2, afxXControl, afxYControl,                  /* number of pts */
                      &pfnAddHorizScan, &pfnAddVertScan );          /* what to call */

/*-------------------------------------------------------------------*/

    if (usScanKind & SK_NODROPOUT)              /* if no dropout control */
    {
        if (lYScan == lYStop)                   /* and if no scan crossings */
        {
            return NO_ERR;                      /* then quick exit */
        }
        
        if (lXScan == lXStop)                   /* if nearly vertical */
        {    
            lXScan += lXOffset;
            while (lYScan != lYStop)
            {
                pfnAddHorizScan(ASTATE lXScan, lYScan);
                lYScan += lYIncr;               /* advance y scan + or - */
            }
            return NO_ERR;                      /* quick out */
        }
    }
        
/*-------------------------------------------------------------------*/

    else                                        /* if smart dropout control on */
    {
        if (lXScan == lXStop)                   /* if nearly vertical */
        {    
            lXScan += lXOffset;
            while (lYScan != lYStop)
            {
                pfnAddHorizScan(ASTATE lXScan, lYScan);
                lYScan += lYIncr;               /* advance y scan + or - */
            }
            return NO_ERR;                      /* quick out */
        }

        if (lYScan == lYStop)                   /* if nearly horizontal */
        {
            lYScan += lYOffset;
            while (lXScan != lXStop)
            {
                pfnAddVertScan(ASTATE lXScan, lYScan);
                lXScan += lXIncr;               /* advance x scan + or - */
            }        
            return NO_ERR;                      /* quick out */
        }
    }

/*-------------------------------------------------------------------*/

/*  Now calculate parametric term precision      */

    Assert(fxXX3 <= MAXSPLINELENGTH);
    Assert(fxYY3 <= MAXSPLINELENGTH);

    lAlpha = (fxXX2 * fxYY3 - fxYY2 * fxXX3) << 1;      /* curvature term */
    
    lABits = PowerOf2(lAlpha);
    lXYBits = fxXX3 > fxYY3 ? PowerOf2((int32)fxXX3) : PowerOf2((int32)fxYY3);
    
    Assert(lXYBits <= 12);                      /* max allowed spline bits */
    Assert(lABits <= 25);

    lZShift = lZShiftTable[lABits + lXYBits];   /* look up precision fix */
    lZBits = SUBSHFT - lZShift;

    if (lZShift > 0)                            /* if precision fix is needed */
    {
        fxZRound = 1L << (lZShift - 1);
        
        fxXX2 = (fxXX2 + fxZRound) >> lZShift;  /* shift to 32 or 16 subpix grid */
        fxXX3 = (fxXX3 + fxZRound) >> lZShift;
        fxYY2 = (fxYY2 + fxZRound) >> lZShift;
        fxYY3 = (fxYY3 + fxZRound) >> lZShift;
        
        fxXInit = (fxXInit + fxZRound) >> lZShift;
        fxYInit = (fxYInit + fxZRound) >> lZShift;

        lAlpha = (fxXX2 * fxYY3 - fxYY2 * fxXX3) << 1;  /* recompute curvature */
    }

    Assert (FXABS(lAlpha * fxXX3) < (1L << 29) + (3L << 24));
    Assert (FXABS(lAlpha * fxYY3) < (1L << 29) + (3L << 24));

/*  Calculate terms for Q = Rxx + Sxy + Tyy + Ux + Vy  */

    fxAx = fxXX3 - (fxXX2 << 1);
    fxAy = fxYY3 - (fxYY2 << 1);

    lR = fxAy * fxAy;
    lS2 = -fxAx * fxAy;
    lT = fxAx * fxAx;
    lU2 = fxYY2 * lAlpha;
    lV2 = -fxXX2 * lAlpha;

/*  
    Calculate starting forward difference terms:

    lQ = Q(x,y) = Rxx + Sxy + Tyy + Ux + Vy
    lDQx = Q(x+z, y) - Q(x, y) = R(2xz + zz) + Syz + Uz
    lDQy = Q(x, y+z) - Q(x, y) = T(2yz + zz) + Sxz + Vz 

*/
    fxZSubpix = 1L << lZBits;                   /* adjusted subpix per pix */

    if (lXYBits <= QMAXSHIFT)                   /* if small enough use full Q */
    {
        lQ += (lR * fxXInit + (lS2 << 1) * fxYInit + (lU2 << 1)) * fxXInit + 
              (lT * fxYInit + (lV2 << 1)) * fxYInit;
        lDQx = (lR * ((fxXInit << 1) + fxZSubpix) + (lS2 << 1) * fxYInit + (lU2 << 1)) << lZBits;
        lDQy = (lT * ((fxYInit << 1) + fxZSubpix) + (lS2 << 1) * fxXInit + (lV2 << 1)) << lZBits;
        
        lRz = lR << (lZBits << 1);              /* needed in the loop */
        lSz = (lS2 << 1) << (lZBits << 1);
        lTz = lT << (lZBits << 1);
    }
    else                                        /* if too big take out a 2 * Z */
    {
        lQ += (((lR >> 1) * fxXInit + lS2 * fxYInit + lU2) >> lZBits) * fxXInit + 
              (((lT >> 1) * fxYInit + lV2) >> lZBits) * fxYInit;
        
        lDQx = lR * (fxXInit + (fxZSubpix >> 1)) + lS2 * fxYInit + lU2;
        lDQy = lT * (fxYInit + (fxZSubpix >> 1)) + lS2 * fxXInit + lV2;
        
        lRz = lR << (lZBits - 1);               /* needed in the loop */
        lSz = lS2 << lZBits;
        lTz = lT << (lZBits - 1);
    }
    lDDQx = lRz << 1;                           /* 2nd derivative terms */
    lDDQy = lTz << 1;
                
/*-------------------------------------------------------------------*/

    if (usScanKind & SK_NODROPOUT)              /* if no dropout control */
    {
        lXScan += lXOffset;                     /* pre increment */
        lXStop += lXOffset;                     /* limit too */

/*  Branch to appropriate inner loop  */

        if (lAlpha > 0L)                        /* if curvature up */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQy > lTz))  /* check against dy */
                {
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }                               
                else
                {
                    pfnAddHorizScan(ASTATE lXScan, lYScan);
                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
            }
        }
        else                                    /* if curvature down */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQx > lRz))  /* check against dx */
                {
                    pfnAddHorizScan(ASTATE lXScan, lYScan);
                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
                else
                {
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }
            }
        }

/* if past bounding box, finish up */

        while (lYScan != lYStop)
        {
            pfnAddHorizScan(ASTATE lXScan, lYScan);
            lYScan += lYIncr;                   /* advance y scan + or - */
        }
    }        

/*-------------------------------------------------------------------*/

    else                                        /* if dropout control on */
    {
        if (lAlpha > 0L)                        /* if curvature up */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQy > lTz))  /* check against dy */
                {
                    pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }                               
                else
                {
                    pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);
                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
            }
        }
        else                                    /* if curvature down */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQx > lRz))  /* check against dx */
                {
                    pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);
                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
                else
                {
                    pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }
            }
        }

/* if outside the bounding box, finish up */

        while (lXScan != lXStop)
        {
            pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);
            lXScan += lXIncr;                   /* advance x scan + or - */
        }        
        
        while (lYScan != lYStop)
        {
            pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);
            lYScan += lYIncr;                   /* advance y scan + or - */
        }
    }

/*-------------------------------------------------------------------*/

    return NO_ERR;
}


/*********************************************************************/

/*      Private Callback Functions      */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizSpSubpix(
    int32 lYScan, 
    F26Dot6 *pfxX, 
    F26Dot6 *pfxY )
{
    F26Dot6 fxYDrop;                            /* dropout scan line */
    F26Dot6 fxX1, fxY1;                         /* local control points */
    F26Dot6 fxX2, fxY2;
    F26Dot6 fxX3, fxY3;
    F26Dot6 fxXMid, fxYMid;                     /* spline center point */

/* printf("Spline (%li, %li) - (%li, %li) - (%li, %li)", *pfxX, *pfxY,
        *(pfxX+1), *(pfxY+1), *(pfxX+2), *(pfxY+2));
*/

    fxYDrop = ((F26Dot6)lYScan << SUBSHFT) + SUBHALF;
    
    Assert(((fxYDrop > *pfxY) && (fxYDrop < *(pfxY+2))) ||
           ((fxYDrop < *pfxY) && (fxYDrop > *(pfxY+2))));

    fxX2 = *(pfxX+1);
    fxY2 = *(pfxY+1);
    
    if (*pfxY < *(pfxY+2))                      /* if spline goes up */
    {
        fxX1 = *pfxX;                           /* just copy it */
        fxY1 = *pfxY;
        fxX3 = *(pfxX+2);
        fxY3 = *(pfxY+2);
    }
    else                                        /* if spline goes down */
    {
        fxX1 = *(pfxX+2);                       /* flip it upside down */
        fxY1 = *(pfxY+2);
        fxX3 = *pfxX;
        fxY3 = *pfxY;
    }

    do                                          /* midpoint subdivision */
    {
        fxXMid = (fxX1 + fxX2 + fxX2 + fxX3 + 1) >> 2;
        fxYMid = (fxY1 + fxY2 + fxY2 + fxY3 + 1) >> 2;
        
        if (fxYMid > fxYDrop)
        {
            fxX2 = (fxX1 + fxX2) >> 1;          /* subdivide down */
            fxY2 = (fxY1 + fxY2) >> 1;
            fxX3 = fxXMid;
            fxY3 = fxYMid;
        }
        else if (fxYMid < fxYDrop)
        {
            fxX2 = (fxX2 + fxX3) >> 1;          /* subdivide up */
            fxY2 = (fxY2 + fxY3) >> 1;
            fxX1 = fxXMid;
            fxY1 = fxYMid;
        }
    } 
    while (fxYMid != fxYDrop);

/* printf("  (%li, %li)\n", fxXMid, fxYMid); */

    return fxXMid;
}


/*********************************************************************/

FS_PRIVATE F26Dot6 CalcVertSpSubpix(
    int32 lXScan, 
    F26Dot6 *pfxX, 
    F26Dot6 *pfxY )
{
    F26Dot6 fxXDrop;                            /* dropout scan line */
    F26Dot6 fxX1, fxY1;                         /* local control points */
    F26Dot6 fxX2, fxY2;
    F26Dot6 fxX3, fxY3;
    F26Dot6 fxXMid, fxYMid;                     /* spline center point */

/* printf("Spline (%li, %li) - (%li, %li) - (%li, %li)", *pfxX, *pfxY,
        *(pfxX+1), *(pfxY+1), *(pfxX+2), *(pfxY+2));
*/
    
    fxXDrop = ((F26Dot6)lXScan << SUBSHFT) + SUBHALF;
    
    Assert(((fxXDrop > *pfxX) && (fxXDrop < *(pfxX+2))) ||
           ((fxXDrop < *pfxX) && (fxXDrop > *(pfxX+2))));
    
    fxX2 = *(pfxX+1);
    fxY2 = *(pfxY+1);

    if (*pfxX < *(pfxX+2))                      /* if spline goes right */
    {                                                                  
        fxX1 = *pfxX;                           /* just copy it */
        fxY1 = *pfxY;
        fxX3 = *(pfxX+2);
        fxY3 = *(pfxY+2);
    }
    else                                        /* if spline goes left */
    {                                                                  
        fxX1 = *(pfxX+2);                       /* flip it around */
        fxY1 = *(pfxY+2);
        fxX3 = *pfxX;
        fxY3 = *pfxY;
    }

    do
    {
        fxXMid = (fxX1 + fxX2 + fxX2 + fxX3 + 1) >> 2;
        fxYMid = (fxY1 + fxY2 + fxY2 + fxY3 + 1) >> 2;
        
        if (fxXMid > fxXDrop)
        {
            fxX2 = (fxX1 + fxX2) >> 1;          /* subdivide left */
            fxY2 = (fxY1 + fxY2) >> 1;
            fxX3 = fxXMid;
            fxY3 = fxYMid;
        }
        else if (fxXMid < fxXDrop)
        {
            fxX2 = (fxX2 + fxX3) >> 1;          /* subdivide right */
            fxY2 = (fxY2 + fxY3) >> 1;
            fxX1 = fxXMid;
            fxY1 = fxYMid;
        }
    } 
    while (fxXMid != fxXDrop);

/* printf("  (%li, %li)\n", fxXMid, fxYMid); */
    
    return fxYMid;
}


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\sfnt.h ===
/*
	File:       sfnt.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  c 1988-1990 by Apple Computer, Inc., all rights reserved.
	            (c) 1989-1999 by Microsoft Corporation.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		 <3>    02/21/97    CB      ClaudeBe, add flags for scaled composite offset compatibility
		 <3>    10/31/90    MR      Add bit-field option for integer or fractional scaling [rb]
		 <2>    10/20/90    MR      Remove unneeded tables from sfnt_tableIndex. [rb]
		<12>     7/18/90    MR      platform and specific should always be unsigned
		<11>     7/14/90    MR      removed duplicate definitions of int[8,16,32] etc.
		<10>     7/13/90    MR      Minor type changes, for Ansi-C
		 <9>     6/29/90    RB      revise postscriptinfo struct
		 <7>      6/4/90    MR      Remove MVT
		 <6>      6/1/90    MR      pad postscriptinfo to long word aligned
		 <5>     5/15/90    MR      Add definition of PostScript table
		 <4>      5/3/90    RB      mrr     Added tag for font program 'fpgm'
		 <3>     3/20/90    CL      chucked old change comments from EASE
		 <2>     2/27/90    CL      getting bbs headers
	   <3.1>    11/14/89    CEL     Instructions are legal in components.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.7>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.6>     6/13/89    SJK     Comment
	   <1.5>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.4>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.3>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts

	To Do:
		<3+>     3/20/90    mrr     Added tag for font program 'fpgm'
*/

#pragma pack(1)

#ifndef SFNT_DEFINED
#define SFNT_DEFINED

#include "fscdefs.h" // DO NOT REMOVE
#include "sfnt_en.h"

typedef struct {
	uint32 bc;
	uint32 ad;
} BigDate;

typedef struct {
	sfnt_TableTag   tag;
	uint32          checkSum;
	uint32          offset;
	uint32          length;
} sfnt_DirectoryEntry;

/*
 *  The search fields limits numOffsets to 4096.
 */
typedef struct {
	int32 version;                  /* 0x10000 (1.0) */
	uint16 numOffsets;              /* number of tables */
	uint16 searchRange;             /* (max2 <= numOffsets)*16 */
	uint16 entrySelector;           /* log2 (max2 <= numOffsets) */
	uint16 rangeShift;              /* numOffsets*16-searchRange*/
	sfnt_DirectoryEntry table[1];   /* table[numOffsets] */
} sfnt_OffsetTable;
#define OFFSETTABLESIZE     12  /* not including any entries */

/*
 *  for the flags field
 */
#define Y_POS_SPECS_BASELINE            0x0001
#define X_POS_SPECS_LSB                 0x0002
#define HINTS_USE_POINTSIZE             0x0004
#define USE_INTEGER_SCALING             0x0008
#define INSTRUCTED_ADVANCE_WIDTH        0x0010

/* flags 5-10 defined by Apple */
#define APPLE_VERTICAL_LAYOUT           0x0020
#define APPLE_RESERVED                  0x0040
#define APPLE_LINGUISTIC_LAYOUT         0x0080
#define APPLE_GX_METAMORPHOSIS          0x0100
#define APPLE_STRONG_RIGHT_TO_LEFT      0x0200
#define APPLE_INDIC_EFFECT              0x0400

#define FONT_COMPRESSED                 0x0800
#define FONT_CONVERTED                  0x1000

#define OUTLINE_CORRECT_ORIENTATION     0x4000
#define SFNT_MAGIC 0x5F0F3CF5

#define SHORT_INDEX_TO_LOC_FORMAT       0
#define LONG_INDEX_TO_LOC_FORMAT        1
#define GLYPH_DATA_FORMAT               0

typedef struct {
	Fixed       version;            /* for this table, set to 1.0 */
	Fixed       fontRevision;       /* For Font Manufacturer */
	uint32      checkSumAdjustment;
	uint32      magicNumber;        /* signature, should always be 0x5F0F3CF5  == MAGIC */
	uint16      flags;
	uint16      unitsPerEm;         /* Specifies how many in Font Units we have per EM */

	BigDate     created;
	BigDate     modified;

	/** This is the font wide bounding box in ideal space
 (baselines and metrics are NOT worked into these numbers) **/
	FUnit       xMin;
	FUnit       yMin;
	FUnit       xMax;
	FUnit       yMax;

	uint16      macStyle;               /* macintosh style word */
	uint16      lowestRecPPEM;          /* lowest recommended pixels per Em */

	/* 0: fully mixed directional glyphs, 1: only strongly L->R or T->B glyphs, 
	   -1: only strongly R->L or B->T glyphs, 2: like 1 but also contains neutrals,
	   -2: like -1 but also contains neutrals */
	int16       fontDirectionHint;

	int16       indexToLocFormat;
	int16       glyphDataFormat;
} sfnt_FontHeader;

typedef struct {
	Fixed       version;                /* for this table, set to 1.0 */

	FUnit       yAscender;
	FUnit       yDescender;
	FUnit       yLineGap;       /* Recommended linespacing = ascender - descender + linegap */
	uFUnit      advanceWidthMax;
	FUnit       minLeftSideBearing;
	FUnit       minRightSideBearing;
	FUnit       xMaxExtent; /* Max of (LSBi + (XMAXi - XMINi)), i loops through all glyphs */

	int16       horizontalCaretSlopeNumerator;
	int16       horizontalCaretSlopeDenominator;

	uint16      reserved0;
	uint16      reserved1;
	uint16      reserved2;
	uint16      reserved3;
	uint16      reserved4;

	int16       metricDataFormat;           /* set to 0 for current format */
	uint16      numberOf_LongHorMetrics;    /* if format == 0 */
} sfnt_HorizontalHeader;

typedef struct {
	uint16      advanceWidth;
	int16       leftSideBearing;
} sfnt_HorizontalMetrics;

typedef struct {
	uint16      advanceHeight;
	int16       topSideBearing;
} sfnt_VerticalMetrics;

/*
 *  CVT is just a bunch of int16s
 */
typedef int16 sfnt_ControlValue;

/*
 *  Char2Index structures, including platform IDs
 */
typedef struct {
	uint16  format;
	uint16  length;
	uint16  version;
} sfnt_mappingTable;

typedef struct {
	uint16  platformID;
	uint16  specificID;
	uint32  offset;
} sfnt_platformEntry;

typedef struct {
	uint16  version;
	uint16  numTables;
	sfnt_platformEntry platform[1]; /* platform[numTables] */
} sfnt_char2IndexDirectory;
#define SIZEOFCHAR2INDEXDIR     4

typedef struct {
  uint16  firstCode;
  uint16  entryCount;
  int16   idDelta;
  uint16  idRangeOffset;
} sfnt_subHeader2;

typedef struct {
  uint16            subHeadersKeys [256];
  sfnt_subHeader2   subHeaders [1];
} sfnt_mappingTable2;

typedef struct {
  uint16  segCountX2;
  uint16  searchRange;
  uint16  entrySelector;
  uint16  rangeShift;
  uint16  endCount[1];
} sfnt_mappingTable4;

typedef struct {
  uint16  firstCode;
  uint16  entryCount;
  uint16  glyphIdArray [1];
} sfnt_mappingTable6;

typedef struct {
	uint16 platformID;
	uint16 specificID;
	uint16 languageID;
	uint16 nameID;
	uint16 length;
	uint16 offset;
} sfnt_NameRecord;

typedef struct {
	uint16 format;
	uint16 count;
	uint16 stringOffset;
/*  sfnt_NameRecord[count]  */
} sfnt_NamingTable;

typedef struct {
	Fixed       version;                /* for this table, set to 1.0 */
	uint16      numGlyphs;
	uint16      maxPoints;              /* in an individual glyph */
	uint16      maxContours;            /* in an individual glyph */
	uint16      maxCompositePoints;     /* in an composite glyph */
	uint16      maxCompositeContours;   /* in an composite glyph */
	uint16      maxElements;            /* set to 2, or 1 if no twilightzone points */
	uint16      maxTwilightPoints;      /* max points in element zero */
	uint16      maxStorage;             /* max number of storage locations */
	uint16      maxFunctionDefs;        /* max number of FDEFs in any preprogram */
	uint16      maxInstructionDefs;     /* max number of IDEFs in any preprogram */
	uint16      maxStackElements;       /* max number of stack elements for any individual glyph */
	uint16      maxSizeOfInstructions;  /* max size in bytes for any individual glyph */
	uint16      maxComponentElements;   /* number of glyphs referenced at top level */
	uint16      maxComponentDepth;      /* levels of recursion, 1 for simple components */
} sfnt_maxProfileTable;

typedef struct {
  int16       numberOfContours;
  BBOX        bbox;
  int16       endPoints[1];
} sfnt_PackedSplineFormat;

#define DEVEXTRA    2   /* size + max */
/*
 *  Each record is n+2 bytes, padded to long word alignment.
 *  First byte is ppem, second is maxWidth, rest are widths for each glyph
 */
typedef struct {
	int16               version;
	int16               numRecords;
	int32               recordSize;
	/* Byte widths[numGlyphs+2] * numRecords */
} sfnt_DeviceMetrics;

#ifdef UNNAMED_UNION        /* Anonymous unions are supported */
#define postScriptNameIndices   /* by some C implementations,  */
#endif              /* but they are not portable. */

typedef struct {
	Fixed   version;                /* 1.0 */
	Fixed   italicAngle;
	FUnit   underlinePosition;
	FUnit   underlineThickness;
	uint32  isFixedPitch;
	uint32  minMemType42;
	uint32  maxMemType42;
	uint32  minMemType1;
	uint32  maxMemType1;

	uint16  numberGlyphs;
	union
	{
	  uint16  glyphNameIndex[1];   /* version == 2.0 */
	  int8    glyphNameIndex25[1]; /* version == 2.5 */
	} postScriptNameIndices;
} sfnt_PostScriptInfo;

#ifdef postScriptNameIndices
#undef postScriptNameIndices
#endif 

typedef struct {
	uint16  Version;
	int16   xAvgCharWidth;
	uint16  usWeightClass;
	uint16  usWidthClass;
	int16   fsType;
	int16   ySubscriptXSize;
	int16   ySubscriptYSize;
	int16   ySubscriptXOffset;
	int16   ySubscriptYOffset;
	int16   ySuperScriptXSize;
	int16   ySuperScriptYSize;
	int16   ySuperScriptXOffset;
	int16   ySuperScriptYOffset;
	int16   yStrikeOutSize;
	int16   yStrikeOutPosition;
	int16   sFamilyClass;
	uint8   Panose [10];
	uint32  ulCharRange [4];
	char    achVendID [4];
	uint16  usSelection;
	uint16  usFirstChar;
	uint16  usLastChar;
	int16   sTypoAscender;
	 int16  sTypoDescender;
	int16   sTypoLineGap;
	int16   sWinAscent;
	int16   sWinDescent;
	uint32  ulCodePageRange[2];
} sfnt_OS2;

typedef struct
{
	uint8   bEmY;
	uint8   bEmX;
	uint8   abInc[1];
} sfnt_hdmxRecord;

typedef struct
{
	uint16          Version;
	int16           sNumRecords;
	int32           lSizeRecord;
	sfnt_hdmxRecord HdmxTable;
} sfnt_hdmx;

typedef struct
{
	uint16    Version;
	uint16    usNumGlyphs;
	uint8     ubyPelsHeight;
} sfnt_LTSH;

typedef struct
{
	uint16          rangeMaxPPEM;
	uint16          rangeGaspBehavior;
} sfnt_gaspRange;

typedef struct
{
	uint16          version;
	uint16          numRanges;
	sfnt_gaspRange  gaspRange[1];
} sfnt_gasp;

/* various typedef to access to the sfnt data */

typedef sfnt_OffsetTable          *sfnt_OffsetTablePtr;
typedef sfnt_FontHeader           *sfnt_FontHeaderPtr;
typedef sfnt_HorizontalHeader     *sfnt_HorizontalHeaderPtr;
typedef sfnt_maxProfileTable      *sfnt_maxProfileTablePtr;
typedef sfnt_ControlValue         *sfnt_ControlValuePtr;
typedef sfnt_char2IndexDirectory  *sfnt_char2IndexDirectoryPtr;
typedef sfnt_HorizontalMetrics    *sfnt_HorizontalMetricsPtr;
typedef sfnt_VerticalMetrics      *sfnt_VerticalMetricsPtr;
typedef sfnt_platformEntry        *sfnt_platformEntryPtr;
typedef sfnt_NamingTable          *sfnt_NamingTablePtr;
typedef sfnt_OS2                  *sfnt_OS2Ptr;
typedef sfnt_DirectoryEntry       *sfnt_DirectoryEntryPtr;
typedef sfnt_PostScriptInfo       *sfnt_PostScriptInfoPtr;
typedef sfnt_gasp                 *sfnt_gaspPtr;

/*
 * 'gasp' Table Constants
*/

#define GASP_GRIDFIT    0x0001
#define GASP_DOGRAY     0x0002


/*
 * UNPACKING Constants
*/
/*define ONCURVE                 0x01   defined in FSCDEFS.H    */
#define XSHORT              0x02
#define YSHORT              0x04
#define REPEAT_FLAGS        0x08 /* repeat flag n times */
/* IF XSHORT */
#define SHORT_X_IS_POS      0x10 /* the short vector is positive */
/* ELSE */
#define NEXT_X_IS_ZERO      0x10 /* the relative x coordinate is zero */
/* ENDIF */
/* IF YSHORT */
#define SHORT_Y_IS_POS      0x20 /* the short vector is positive */
/* ELSE */
#define NEXT_Y_IS_ZERO      0x20 /* the relative y coordinate is zero */
/* ENDIF */
/* 0x40 & 0x80              RESERVED
** Set to Zero
**
*/

/*
 * Composite glyph constants
 */
#define COMPONENTCTRCOUNT           -1      /* ctrCount == -1 for composite */
#define ARG_1_AND_2_ARE_WORDS       0x0001  /* if set args are words otherwise they are bytes */
#define ARGS_ARE_XY_VALUES          0x0002  /* if set args are xy values, otherwise they are points */
#define ROUND_XY_TO_GRID            0x0004  /* for the xy values if above is true */
#define WE_HAVE_A_SCALE             0x0008  /* Sx = Sy, otherwise scale == 1.0 */
#define NON_OVERLAPPING             0x0010  /* set to same value for all components */
#define MORE_COMPONENTS             0x0020  /* indicates at least one more glyph after this one */
#define WE_HAVE_AN_X_AND_Y_SCALE    0x0040  /* Sx, Sy */
#define WE_HAVE_A_TWO_BY_TWO        0x0080  /* t00, t01, t10, t11 */
#define WE_HAVE_INSTRUCTIONS        0x0100  /* instructions follow */
#define USE_MY_METRICS              0x0200  /* apply these metrics to parent glyph */
#define OVERLAP_COMPOUND			0x0400  /* used by Apple in GX fonts */
#define SCALED_COMPONENT_OFFSET     0x0800  /* composite designed to have the component offset scaled (designed for Apple) */
#define UNSCALED_COMPONENT_OFFSET   0x1000  /* composite designed not to have the component offset scaled (designed for MS) */

/*
 *  Private enums for tables used by the scaler.  See sfnt_Classify
 */
typedef enum {
	sfnt_fontHeader,
	sfnt_horiHeader,
	sfnt_indexToLoc,
	sfnt_maxProfile,
	sfnt_controlValue,
	sfnt_preProgram,
	sfnt_glyphData,
	sfnt_horizontalMetrics,
	sfnt_charToIndexMap,
	sfnt_fontProgram,
	sfnt_Postscript,
	sfnt_HoriDeviceMetrics,
	sfnt_LinearThreshold,
	sfnt_Names,
	sfnt_OS_2,
	sfnt_GlyphDirectory,
	sfnt_BitmapData,
	sfnt_BitmapLocation,
	sfnt_BitmapScale,
	sfnt_vertHeader,
	sfnt_verticalMetrics,
	sfnt_BeginningOfFont,       /* References the beginning of memory   */
	sfnt_NUMTABLEINDEX
} sfnt_tableIndex;

#endif
#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\sfntaccs.h ===
/*
	File:       private sfnt.h

	Contains:   xxx put contents here xxx

	Written by: xxx put writers here xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1997. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

		<>       02/21/97   CB      ClaudeBe, scaled component in composite glyphs
		<>       12/14/95   CB      add advance height to sfac_ReadGlyphMetrics
		<3+>     7/17/90    MR      Change return types to in for computemapping and readsfnt
		 <3>     7/14/90    MR      changed SQRT to conditional FIXEDSQRT2
		 <2>     7/13/90    MR      Change parameters to ReadSFNT and ComputeMapping
		<1+>     4/18/90    CL      
		 <1>     3/21/90    EMT     First checked in with Mike Reed's blessing.

	To Do:
*/

#include    "sfnt.h"

/* EXPORTED DATA TYPES */

typedef struct {
  uint32    ulOffset;
  uint32    ulLength;
} sfac_OffsetLength;

typedef struct sfac_ClientRec *sfac_ClientRecPtr;

typedef uint16 (*MappingFunc) (const uint8 *, uint16 , sfac_ClientRecPtr);

typedef struct sfac_ClientRec {
	ClientIDType        lClientID;          /* User ID Number                           */
	GetSFNTFunc         GetSfntFragmentPtr; /* User function to eat sfnt                */
	ReleaseSFNTFunc     ReleaseSfntFrag;    /* User function to relase sfnt             */
	int16               sIndexToLocFormat;  /* Format of loca table                     */
	uint32              ulMapOffset;        /* Offset to platform mapping data          */
	sfac_OffsetLength   TableDirectory[sfnt_NUMTABLEINDEX]; /* Table offsets/lengths    */
	uint16              usNumberOf_LongHorMetrics; /* Number of entries in hmtx table   */
	uint16              usNumLongVertMetrics;      /* number of entries with AH         */
	boolean				bValidNumLongVertMetrics; /* true if 'vhea' table exist         */
    uint16              usMappingFormat;    /* format code (0,2,4,6) for mapping func   */
	MappingFunc			GlyphMappingF;		/* mapping function char to glyph			*/
	uint16              usGlyphIndex;       /* Current glyph index                      */
	uint16				usFormat4SearchRange; /* Format 4 cached SearchRange			*/
	uint16				usFormat4EntrySelector; /* Format 4 cached EntrySelector		*/
	uint16				usFormat4RangeShift;/* Format 4 cached Range Shift				*/
	/* value for sDefaultAscender and sDefaultDescender comes from TypoAscender and     */
	/* TypoDescender from 'OS/2', if the 'OS/2' is missing, alternate values comes from */
	/* the horizontal header Ascender and Descender                                     */
	int16				sDefaultAscender;
	int16				sDefaultDescender;
	int16				sWinDescender;
} sfac_ClientRec;


/* It would be great if we could make this an opaque data type
// But in this case, the ownership of the memory for the data is the
// responsibility of the owner module. (i.e. sfntaccs.c) This adds
// complications to our model (read: it is much easier to allocate the
// data off the stack of the caller) so we won't implement this for now.
*/

/*  Glyph Handle -- Used for access to glyph data in 'glyf' table   */

typedef struct {
	 const void *     pvGlyphBaseAddress; /* Base address of glyph, needed for Release */
	 const void *     pvGlyphNextAddress; /* Current position in glyph                    */
	 const void *     pvGlyphEndAddress; /* End address of glyph, used to catch glyph corruption */
} sfac_GHandle;

/*  ComponentTypes -- Method used for positioning component in composite    */

typedef enum {
	AnchorPoints,
	OffsetPoints,
	Undefined
} sfac_ComponentTypes;

/* MACROS */

#define SFAC_LENGTH(ClientInfo,Table)  ClientInfo->TableDirectory[(int)Table].ulLength

/* PUBLIC PROTOTYPE CALLS */

/*
 * Creates mapping for finding offset table
 */

FS_PUBLIC ErrorCode sfac_DoOffsetTableMap (
	sfac_ClientRec *    ClientInfo);    /* Sfnt Client information  */

FS_PUBLIC ErrorCode sfac_ComputeMapping (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information      */
	uint16              usPlatformID,   /* Platform Id used for mapping */
	uint16              usSpecificID);  /* Specific Id used for mapping */

FS_PUBLIC ErrorCode sfac_GetGlyphIndex(
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16              usCharacterCode);   /* Character code to be mapped  */

FS_PUBLIC ErrorCode sfac_GetMultiGlyphIDs (
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID);        /* Output glyph ID array        */

FS_PUBLIC ErrorCode sfac_GetWin95GlyphIDs (
	uint8 *             pbyCmapSubTable,    /* Pointer to cmap sub table    */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID);        /* Output glyph ID array        */

FS_PUBLIC ErrorCode sfac_GetWinNTGlyphIDs (
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint32	            ulCharCodeOffset,   /* Offset to be added to *pulCharCode
											   before converting            */
	uint32 *	        pulCharCode,        /* Pointer to char code list    */
	uint32 *	        pulGlyphID);        /* Output glyph ID array        */

FS_PUBLIC ErrorCode sfac_LoadCriticalSfntMetrics(
	 sfac_ClientRec *   ClientInfo,      /* Sfnt Client information     */
	 uint16 *               pusEmResolution,/* Sfnt Em Resolution               */
	 boolean *              pbIntegerScaling,/* Sfnt flag for int scaling   */
	 LocalMaxProfile *  pMaxProfile);    /* Sfnt Max Profile table      */

FS_PUBLIC ErrorCode sfac_ReadGlyphMetrics (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information          */
	register uint16     glyphIndex,     /* Glyph number for metrics         */
	uint16 *            pusNonScaledAW, /* Return: Non Scaled Advance Width */
	uint16 *            pusNonScaledAH, /* Return: Non Scaled Advance Height */
	int16 *             psNonScaledLSB,
	int16 *             psNonScaledTSB);

FS_PUBLIC ErrorCode sfac_ReadGlyphHorMetrics (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information          */
	register uint16     glyphIndex,     /* Glyph number for metrics         */
	uint16 *            pusNonScaledAW, /* Return: Non Scaled Advance Width */
	int16 *             psNonScaledLSB);

FS_PUBLIC ErrorCode sfac_ReadGlyphVertMetrics (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information          */
	register uint16     glyphIndex,     /* Glyph number for metrics         */
	uint16 *            pusNonScaledAH, /* Return: Non Scaled Advance Height */
	int16 *             psNonScaledTSB);

FS_PUBLIC ErrorCode sfac_ReadNumLongVertMetrics (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information           */
	uint16 *            pusNumLongVertMetrics, /* Entries for which AH exists */
	boolean *           pbValidNumLongVertMetrics ); /* true if 'vhea' table exist  */

FS_PUBLIC ErrorCode sfac_CopyFontAndPrePrograms(
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client Information  */
	char *              pFontProgram,   /* pointer to Font Program  */
	char *              pPreProgram);   /* pointer to Pre Program   */

FS_PUBLIC ErrorCode sfac_CopyCVT(
	sfac_ClientRec *    ClientInfo,     /* Client Information       */
	F26Dot6 *           pCVT);          /* pointer to CVT           */

FS_PUBLIC ErrorCode sfac_CopyHdmxEntry(
	sfac_ClientRec *    ClientInfo,     /* Client Information   */
	uint16              usPixelsPerEm,  /* Current Pixels per Em    */
	boolean *           bFound,         /* Flag indicating if entry found */
	uint16              usFirstGlyph,   /* First Glyph to copy */
	uint16              usLastGlyph,    /* Last Glyph to copy */
	int16 *             psBuffer);      /* Buffer to save glyph sizes */

FS_PUBLIC ErrorCode sfac_GetLTSHEntries(
	sfac_ClientRec *    ClientInfo,     /* Client Information   */
	uint16              usPixelsPerEm,  /* Current Pixels per Em    */
	uint16              usFirstGlyph,   /* First Glyph to copy */
	uint16              usLastGlyph,    /* Last Glyph to copy */
	int16 *             psBuffer);      /* Buffer to save glyph sizes */

FS_PUBLIC ErrorCode sfac_ReadGlyphHeader(
	sfac_ClientRec *    ClientInfo,         /* Client Information           */
	uint16              usGlyphIndex,       /* Glyph index to read          */
	sfac_GHandle *      hGlyph,             /* Return glyph handle          */
	boolean *           pbCompositeGlyph,   /* Is glyph a composite?        */
	boolean *           pbHasOutline,       /* Does glyph have outlines?    */
	int16 *             psNumberOfContours, /* Number of contours in glyph  */
	BBOX *              pbbox);             /* Glyph Bounding box           */

FS_PUBLIC ErrorCode sfac_ReadOutlineData(
	 uint8 *                abyOnCurve,           /* Array of on curve indicators per point  */
	 F26Dot6 *              afxOoy,               /* Array of ooy points for every point         */
	 F26Dot6 *              afxOox,               /* Array of oox points for every point         */
	 sfac_GHandle *     hGlyph,
	 LocalMaxProfile *  maxProfile,       /* MaxProfile Table                                */
	 boolean                bHasOutline,          /* Does glyph have outlines?                   */
	 int16                  sNumberOfContours,  /* Number of contours in glyph               */
	 int16 *                asStartPoints,    /* Array of start points for every contour  */
	 int16 *                asEndPoints,          /* Array of end points for every contour   */
	 uint16 *               pusSizeOfInstructions, /* Size of instructions in bytes          */
	 uint8 **               pbyInstructions,   /* Pointer to start of glyph instructions    */
     uint32*                pCompositePoints,   /* total number of point for composites, to check for overflow */
     uint32*                pCompositeContours);    /* total number of contours for composites, to check for overflow */

FS_PUBLIC ErrorCode sfac_ReadComponentData(
	sfac_GHandle *          hGlyph,
	sfac_ComponentTypes *   pMultiplexingIndicator, /* Indicator for Anchor vs offsets    */
	boolean *               pbRoundXYToGrid,    /* Round composite offsets to grid              */
	boolean *               pbUseMyMetrics,     /* Use component metrics                        */
	boolean *               pbScaleCompositeOffset,   /* Do we scale the composite offset, Apple/MS   */
	boolean *               pbWeHaveInstructions, /* Composite has instructions                 */
	uint16 *                pusComponentGlyphIndex, /* Glyph index of component                 */
	int16 *                 psXOffset,          /* X Offset of component (if app)               */
	int16 *                 psYOffset,          /* Y Offset of component (if app)               */
	uint16 *                pusAnchorPoint1,    /* Anchor point 1 of component (if app)         */
	uint16 *                pusAnchorPoint2,    /* Anchor point 2 of component (if app)         */
	transMatrix             *pMulT,             /* Transformation matrix for component          */
	boolean *				pbWeHaveAScale,     /* We have a scaling in pMulT					*/
	boolean *               pbLastComponent);   /* Is this the last component?                  */

/*  sfac_ReadCompositeInstructions

	Returns pointer to TrueType instructions for composites.

 */

FS_PUBLIC ErrorCode sfac_ReadCompositeInstructions(
	sfac_GHandle *  hGlyph,
	uint8 **        pbyInstructions,    /* Pointer to start of glyph instructions   */
	uint16 *        pusSizeOfInstructions); /* Size of instructions in bytes        */


/*  sfac_ReleaseGlyph

	Called when access to glyph in 'glyf' table is finished.

 */

FS_PUBLIC ErrorCode sfac_ReleaseGlyph(
	sfac_ClientRec *    ClientInfo, /* Sfnt Client Information  */
	sfac_GHandle *      hGlyph);    /* Glyph Handle Information */


/**********************************************************************/

/*      Embedded Bitmap (sbit) Access Routines      */

/**********************************************************************/

#ifndef FSCFG_DISABLE_GRAYSCALE
#define SBIT_BITDEPTH_MASK	0x0116	 /* support sbit with bitDepth of 1, 2, 4 and 8 */
/* SBIT_BITDEPTH_MASK must have the same value as FS_SBIT_BITDEPTH_MASK in fscaler.h */ 
#else

#define SBIT_BITDEPTH_MASK	0x0002	 /* support only sbit with bitDepth of 1 */
/* SBIT_BITDEPTH_MASK must have the same value as FS_SBIT_BITDEPTH_MASK in fscaler.h */ 
#endif


/*      SFNTACCS Export Prototypes for SBIT      */

FS_PUBLIC ErrorCode sfac_SearchForStrike (
	sfac_ClientRec *pClientInfo,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint16 usOverScale,            /* outline magnification requested */
	uint16 *pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint16 *pusTableState,
	uint16 *pusSubPpemX,
	uint16 *pusSubPpemY,
	uint32 *pulStrikeOffset 
);

FS_PUBLIC ErrorCode sfac_SearchForBitmap (
	sfac_ClientRec *pClientInfo,
	uint16 usGlyphCode,
	uint32 ulStrikeOffset,
	boolean *pbGlyphFound,
	uint16 *pusMetricsType,
	uint16 *pusMetricsTable,
	uint32 *pulMetricsOffset,
	uint16 *pusBitmapFormat,
	uint32 *pulBitmapOffset,
	uint32 *pulBitmapLength
);

FS_PUBLIC ErrorCode sfac_GetSbitMetrics (
	sfac_ClientRec *pClientInfo,
	uint16 usMetricsType,
	uint16 usMetricsTable,
	uint32 ulMetricsOffset,
	uint16 *pusHeight,
	uint16 *pusWidth,
	int16 *psLSBearingX,
	int16 *psLSBearingY,
	int16 *psTopSBearingX, /* NEW */
	int16 *psTopSBearingY, /* NEW */
	uint16 *pusAdvanceWidth,
	uint16 *pusAdvanceHeight,  /* NEW */
   	boolean *pbHorMetricsFound, /* NEW */
   	boolean *pbVertMetricsFound /* NEW */
);

FS_PUBLIC ErrorCode sfac_ShaveSbitMetrics (
	sfac_ClientRec *pClientInfo,
	uint16 usBitmapFormat,
	uint32 ulBitmapOffset,
    uint32 ulBitmapLength,
	uint16 usBitDepth,
	uint16 *pusHeight,
	uint16 *pusWidth,
    uint16 *pusShaveLeft,
    uint16 *pusShaveRight,
    uint16 *pusShaveTop,  /* NEW */
    uint16 *pusShaveBottom,  /* NEW */
	int16 *psLSBearingX,
	int16 *psLSBearingY, /* NEW */
	int16 *psTopSBearingX, /* NEW */
	int16 *psTopSBearingY /* NEW */
);

FS_PUBLIC ErrorCode sfac_GetSbitBitmap (
	sfac_ClientRec *pClientInfo,
	uint16 usBitmapFormat,
	uint32 ulBitmapOffset,
	uint32 ulBitmapLength,
	uint16 usHeight,
	uint16 usWidth,
    uint16 usShaveLeft,
    uint16 usShaveRight,
    uint16 usShaveTop, /* NEW */
    uint16 usShaveBottom,  /* NEW */
	uint16 usXOffset,
	uint16 usYOffset,
	uint16 usRowBytes,
	uint16 usBitDepth,
	uint8 *pbyBitMap, 
	uint16 *pusCompCount
);

FS_PUBLIC ErrorCode sfac_GetSbitComponentInfo (
	sfac_ClientRec *pClientInfo,
	uint16 usComponent,
	uint32 ulBitmapOffset,
	uint32 ulBitmapLength,
	uint16 *pusCompGlyphCode,
	uint16 *pusCompXOffset,
	uint16 *pusCompYOffset
);


/**********************************************************************/

/*  Results of search for strike's bitmapSizeSubtable   */

#define     SBIT_UN_SEARCHED    0
#define     SBIT_NOT_FOUND      1
#define     SBIT_BLOC_FOUND     2
#define     SBIT_BSCA_FOUND     3

/**********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\sfntaccs.c ===
/*
	File:       sfnt.c

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

   Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
			   (c) 1989-1997. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

		<>       02/21/97   CB      ClaudeBe, scaled component in composite glyphs
		<>       12/14/95   CB      add advance height to sfac_ReadGlyphMetrics
	   <17+>     10/9/90    MR,rb   Remove classification of unused tables in sfnt_Classify
		<17>     8/10/90    MR      Pass nil for textLength parameter to MapString2, checked in
									other files to their precious little system will BUILD.  Talk
									about touchy!
		<16>     8/10/90    gbm     rolling out Mike's textLength change, because he hasn't checked
									in all the relevant files, and the build is BROKEN!
		<15>     8/10/90    MR      Add textLength arg to MapString2
		<14>     7/26/90    MR      don't include toolutil.h
		<13>     7/23/90    MR      Change computeindex routines to call functins in MapString.c
		<12>     7/18/90    MR      Add SWAPW macro for INTEL
		<11>     7/13/90    MR      Lots of Ansi-C stuff, change behavior of ComputeMapping to take
									platform and script
		 <9>     6/27/90    MR      Changes for modified format 4: range is now times two, loose pad
									word between first two arrays.  Eric Mader
		 <8>     6/21/90    MR      Add calls to ReleaseSfntFrag
		 <7>      6/5/90    MR      remove vector mapping functions
		 <6>      6/4/90    MR      Remove MVT
		 <5>      5/3/90    RB      simplified decryption.
		 <4>     4/10/90    CL      Fixed mapping table routines for double byte codes.
		 <3>     3/20/90    CL      Joe found bug in mappingtable format 6 Added vector mapping
									functions use pointer-loops in sfnt_UnfoldCurve, changed z from
									int32 to int16
		 <2>     2/27/90    CL      New error code for missing but needed table. (0x1409)  New
									CharToIndexMap Table format.
									Assume subtablenumber zero for old sfnt format.  Fixed
									transformed component bug.
	   <3.2>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Instructions are legal in components. Glyph-length 0
									bug in sfnt.c is fixed. Now it is legal to pass in zero as the
									address of memory when a piece of the sfnt is requested by the
									scaler. If this happens the scaler will simply exit with an
									error code ! Fixed bug with instructions in components.
	   <3.1>     9/27/89    CEL     Removed phantom points.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <y1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
		<3+>     3/20/90    mrr     Fixed mapping table routines for double byte codes.
									Added support for font program.
									Changed count from uint16 to int16 in vector char2index routines.
*/

#define FSCFG_INTERNAL

/** FontScaler's Includes **/

#include "fserror.h"
#include "fscdefs.h"
#include "sfntaccs.h"
#include "sfntoff.h"
/*#include "MapString.h" */

#include "stat.h"                   /* STAT timing card prototypes */

/*  CONSTANTS   */

#define MISSING_GLYPH_INDEX     0
#define MAX_FORMAT0_CHAR_INDEX  256
#define MAX_LINEAR_X2           16
static  const   transMatrix   IdentTransform =
   {{{ONEFIX,      0,      0},
	 {     0, ONEFIX,      0},
	 {     0,      0, ONEFIX}}};

/*  MACROS  */
#define MAX(a, b)   (((a) > (b)) ? (a) : (b))

#define GETSFNTFRAG(ClientInfo,lOffset,lLength) (ClientInfo)->GetSfntFragmentPtr(ClientInfo->lClientID, lOffset, lLength)
#define RELEASESFNTFRAG(ClientInfo,data)        (ClientInfo)->ReleaseSfntFrag((voidPtr)data)

#define SFAC_BINARYITERATION \
	  newP = (uint16 *) ((char *)tableP + (usSearchRange >>= 1)); \
		if (charCode > (uint16) SWAPW (*newP)) tableP = newP;

#define SFAC_GETUNSIGNEDBYTEINC( p ) ((uint8)(*p++))

/* PRIVATE PROTOTYES */

FS_PRIVATE void sfac_Classify (
	 sfac_OffsetLength * TableDirectory,
	 uint8 *                    dir);

FS_PRIVATE uint16 sfac_ComputeUnkownIndex (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex0 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex2 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex4 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex6 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);

FS_PRIVATE ErrorCode sfac_GetGlyphLocation (
	sfac_ClientRec *    ClientInfo,
	uint16              gIndex,
	uint32 *            ulOffset,
	uint32 *            ulLength,
	sfnt_tableIndex*  pGlyphTableIndex);

FS_PRIVATE ErrorCode    sfac_GetDataPtr (
	sfac_ClientRec *    ClientInfo,
	uint32              ulOffset,
	uint32              ulLength,
	sfnt_tableIndex     TableRef,
	boolean             bMustHaveTable,
    const void * *     ppvTablePtr);

FS_PRIVATE ErrorCode sfac_GetGlyphIDs (
   	MappingFunc			pfnGlyphMapping,		/* mapping func char to glyph	*/
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usCharCode,         /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID);        /* Output glyph ID array        */

FS_PRIVATE ErrorCode sfac_GetLongGlyphIDs (
   	MappingFunc			pfnGlyphMapping,	/* mapping func char to glyph	*/
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
	sfac_ClientRec *    ClientInfo,         /* May be NULL!                 */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usCharCode,         /* First char code              */
	uint32	            ulCharCodeOffset,   /* Offset to be added to *pulCharCode
											   before converting            */
	uint32 *	        pulCharCode,        /* Pointer to char code list    */
	uint32 *	        pulGlyphID);         /* Output glyph ID array        */

FS_PRIVATE void	sfac_ComputeBinarySearchParams(
	uint16		usSegCount, 		/* INPUT */
	uint16 *	pusSearchRange,		/* OUTPUT */
	uint16 *	pusEntrySelector,	/* OUTPUT */
	uint16 *	pusRangeShift);		/* OUTPUT */

FS_PRIVATE ErrorCode sfac_ReadGlyphBbox(
	sfac_ClientRec *    ClientInfo,         /* Client Information           */
	uint16              usGlyphIndex,       /* Glyph index to read          */
	BBOX *              pbbox);             /* Glyph Bounding box           */

/*
 * Internal routine (make this an array and do a look up?)
 */
FS_PRIVATE void sfac_Classify (
	 sfac_OffsetLength * TableDirectory,
	 uint8 *                    dir)
{
	int32 Index;

	switch ((uint32)SWAPL(*((sfnt_TableTag *)&dir[SFNT_DIRECTORYENTRY_TAG])))
	{
		case tag_FontHeader:
			Index = (int32)sfnt_fontHeader;
			break;
		case tag_HoriHeader:
			Index = (int32)sfnt_horiHeader;
			break;
		case tag_IndexToLoc:
			Index = (int32)sfnt_indexToLoc;
			break;
		case tag_MaxProfile:
			Index = (int32)sfnt_maxProfile;
			break;
		case tag_ControlValue:
			Index = (int32)sfnt_controlValue;
			break;
		case tag_PreProgram:
			Index = (int32)sfnt_preProgram;
			break;
		case tag_GlyphData:
			Index = (int32)sfnt_glyphData;
			break;
		case tag_HorizontalMetrics:
			Index = (int32)sfnt_horizontalMetrics;
			break;
		case tag_CharToIndexMap:
			Index = (int32)sfnt_charToIndexMap;
			break;
		case tag_FontProgram:
			Index = (int32)sfnt_fontProgram;   /* <4> */
			break;
		case tag_GlyphDirectory:         /* Used for GlyphDirectory Download */
			Index = (int32)sfnt_GlyphDirectory;
			break;
		case tag_HoriDeviceMetrics:
			Index = (int32)sfnt_HoriDeviceMetrics;
			break;
		case tag_LinearThreshold:
			Index = (int32)sfnt_LinearThreshold;
			break;
		case tag_BitmapData:
			Index = (int32)sfnt_BitmapData;
			break;
		case tag_BitmapLocation:
			Index = (int32)sfnt_BitmapLocation;
			break;
		case tag_BitmapScale:
			Index = (int32)sfnt_BitmapScale;
			break;
		case tag_VertHeader:
			Index = (int32)sfnt_vertHeader;
			break;
		case tag_VerticalMetrics:
			Index = (int32)sfnt_verticalMetrics;
			break;
		case tag_OS_2:
			Index = (int32)sfnt_OS_2;
			break;
		default:
			Index = -1;
			break;
	}
	if (Index >= 0)
	{
		  TableDirectory[Index].ulOffset = (uint32) SWAPL (*((uint32 *)&dir[SFNT_DIRECTORYENTRY_TABLEOFFSET]));
		  TableDirectory[Index].ulLength = (uint32) SWAPL (*((uint32 *)&dir[SFNT_DIRECTORYENTRY_TABLELENGTH]));
	}
}


/*
 * Creates mapping for finding offset table     <4>
 */

FS_PUBLIC ErrorCode sfac_DoOffsetTableMap (
	sfac_ClientRec *  ClientInfo)    /* Sfnt Client information */

{
	int32        i;
	uint8 *      sfntDirectory;
	int32        cTables;
	uint8 *      dir;

	STAT_OFF_CALLBACK;                  /* pause STAT timer */

	sfntDirectory = (uint8 *) GETSFNTFRAG (ClientInfo, 0L, (int32)SIZEOF_SFNT_OFFSETTABLE);

	STAT_ON_CALLBACK;                /* restart STAT timer */

	if (sfntDirectory != NULL)
	{
		cTables = (int32) SWAPW (*((uint16 *)&sfntDirectory[SFNT_OFFSETTABLE_NUMOFFSETS]));
		RELEASESFNTFRAG(ClientInfo, sfntDirectory);

		STAT_OFF_CALLBACK;               /* pause STAT timer */

		sfntDirectory = (uint8 *) GETSFNTFRAG (
			ClientInfo,
			0L,
			((int32)SIZEOF_SFNT_OFFSETTABLE + (int32)SIZEOF_SFNT_DIRECTORYENTRY * (int32)(cTables)));

		STAT_ON_CALLBACK;             /* restart STAT timer */


		if (sfntDirectory == NULL)
		{
			return(CLIENT_RETURNED_NULL);
		}
	}
	else
	{
		return(NULL_SFNT_DIR_ERR);
	}

	/* Initialize */

	MEMSET (ClientInfo->TableDirectory, 0, sizeof (ClientInfo->TableDirectory));

	dir = &sfntDirectory[SFNT_OFFSETTABLE_TABLE];

	for (i = 0; i < cTables; i++)
	{
		sfac_Classify (ClientInfo->TableDirectory, dir);
		dir += SIZEOF_SFNT_DIRECTORYENTRY;
	}

	/* Used when glyphs are accessed from the base of memory */

	ClientInfo->TableDirectory[(int32)sfnt_BeginningOfFont].ulOffset = 0U;
	ClientInfo->TableDirectory[(int32)sfnt_BeginningOfFont].ulLength = ~0U;

	RELEASESFNTFRAG(ClientInfo, sfntDirectory);

	return NO_ERR;
}

/*
 * Use this function when only part of the table is needed.
 *
 * n is the table number.
 * offset is within table.
 * length is length of data needed.
 * To get an entire table, pass length = ULONG_MAX     <4>
 */

FS_PRIVATE ErrorCode sfac_GetDataPtr (
	sfac_ClientRec *    ClientInfo,
	uint32              ulOffset,
	uint32              ulLength,
	sfnt_tableIndex     TableRef,
	boolean             bMustHaveTable,
	const void **       ppvTablePtr)
{
	uint32      ulTableLength;

	ulTableLength = SFAC_LENGTH(ClientInfo, TableRef);

	if (ulTableLength > 0)
	{
		if(ulLength == ULONG_MAX)
		{
			ulLength = ulTableLength;
		}

		STAT_OFF_CALLBACK;               /* pause STAT timer */

		*ppvTablePtr = (void *)GETSFNTFRAG (
			ClientInfo,
			(int32)(ulOffset + ClientInfo->TableDirectory[(int32)TableRef].ulOffset),
			(int32)ulLength);

		STAT_ON_CALLBACK;             /* restart STAT timer */

		if (*ppvTablePtr == NULL)
		{
			return CLIENT_RETURNED_NULL; /* Do a gracefull recovery   */
		}
	}
	else
	{
		*ppvTablePtr = (void *)NULL;

		if (bMustHaveTable)
		{
			return MISSING_SFNT_TABLE; /* Do a gracefull recovery  */
		}
	}

	return NO_ERR;
}


/*
 * This, is when we don't know what is going on
 */

FS_PRIVATE uint16 sfac_ComputeUnkownIndex (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	FS_UNUSED_PARAMETER(mapping);
	FS_UNUSED_PARAMETER(charCode);
	FS_UNUSED_PARAMETER(ClientInfo);
	return MISSING_GLYPH_INDEX;
}


/*
 * Byte Table Mapping 256->256          <4>
 */
FS_PRIVATE uint16 sfac_ComputeIndex0 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	FS_UNUSED_PARAMETER(ClientInfo);
	if (charCode < MAX_FORMAT0_CHAR_INDEX)
	{
		return (uint16)mapping[charCode];
	}
	else
	{
		return MISSING_GLYPH_INDEX;
	}
}

/*
 * High byte mapping through table
 *
 * Useful for the national standards for Japanese, Chinese, and Korean characters.
 *
 * Dedicated in spirit and logic to Mark Davis and the International group.
 *
 *  Algorithm: (I think)
 *      First byte indexes into KeyOffset table.  If the offset is 0, keep going, else use second byte.
 *      That offset is from beginning of data into subHeader, which has 4 words per entry.
 *          entry, extent, delta, range
 *
 */

FS_PRIVATE uint16 sfac_ComputeIndex2 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	uint16          usIndex;
	uint16          usMapMe;
	uint16          usHighByte;
	uint16          usGlyph;
	const uint8 *   Table2;
	const uint8 *   subHeader;

	FS_UNUSED_PARAMETER(ClientInfo);
	Table2 = (const uint8 *) mapping;

	usHighByte = (uint16)(charCode >> 8);

	if (((uint16 *)&Table2[SFNT_MAPPINGTABLE2_SUBHEADERSKEYS]) [usHighByte])
	{
		usMapMe = (uint16)(charCode & 0xFF); /* We also need the low byte. */
	}
	else
	{
#ifdef  FSCFG_MICROSOFT_KK
		if(usHighByte != 0)
		{
			usMapMe = usHighByte;
		}
		else
		{
				usMapMe = (uint16)(charCode & 0xFF);
		}
#else
		usMapMe = usHighByte;
#endif
	}

	subHeader = (const uint8 *) ((char *)&Table2[SFNT_MAPPINGTABLE2_SUBHEADERS] +
		(uint16)SWAPW (((uint16 *)&Table2[SFNT_MAPPINGTABLE2_SUBHEADERSKEYS]) [usHighByte]));

	usMapMe -= (uint16)SWAPW (*((uint16 *)&subHeader[SFNT_SUBHEADER2_FIRSTCODE]));    /* Subtract first code. */

	if (usMapMe < (uint16)SWAPW (*((uint16 *)&subHeader[SFNT_SUBHEADER2_ENTRYCOUNT])))
	{  /* See if within range. */

		usGlyph = (uint16)(* ((uint16 *) ((char *) &subHeader[SFNT_SUBHEADER2_IDRANGEOFFSET] +
			(uint16)SWAPW (*((uint16 *)&subHeader[SFNT_SUBHEADER2_IDRANGEOFFSET]))) + usMapMe));

		if (usGlyph != 0) /* Note: usGlyph has not been swapped yet */
		{
			usIndex = (uint16)((int32)(uint32)(uint16)SWAPW(usGlyph) + (int32)SWAPW (*((int16 *)&subHeader[SFNT_SUBHEADER2_IDDELTA])));
		}
		else
		{
			usIndex = MISSING_GLYPH_INDEX;
		}
	}
	else
	{
		usIndex = MISSING_GLYPH_INDEX;
	}

	return usIndex;
}

/*
 * Segment mapping to delta values, Yack.. !
 *
 * In memory of Peter Edberg. Initial code taken from code example supplied by Peter.
 */
FS_PRIVATE uint16 sfac_ComputeIndex4 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	const uint16 *  tableP;
	const uint8 *   Table4;
	uint16          usIdDelta;
	uint16          usOffset;
	uint16          usIndex;
	uint16          usSegCountX2;
	uint16			usSearchRange;
	uint16			usEntrySelector;
	uint16			usRangeShift;
	const uint16 *  newP;    /* temporary pointer for binary iteration   */
	uint16          usStartCount;

	Table4 = (const uint8 *)mapping;

	usSegCountX2 = (uint16) SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_SEGCOUNTX2]));
	tableP = (const uint16 *)&Table4[SFNT_MAPPINGTABLE4_ENDCOUNT];

	/* If there are just a few segments, skip straight to the linear search */

	if (usSegCountX2 >= MAX_LINEAR_X2 && charCode > 0xFF)
	{
		/* start with unrolled binary search */

		/* tableP points at endCount[] */
		if( ClientInfo == NULL )
		{
			sfac_ComputeBinarySearchParams(
				(uint16)(usSegCountX2 / 2),
				&usSearchRange,
				&usEntrySelector,
				&usRangeShift);
		}
		else
		{
			usSearchRange = ClientInfo->usFormat4SearchRange;

			/* Assert(SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_RANGESHIFT])) == ClientInfo->usFormat4RangeShift); */
			usRangeShift = ClientInfo->usFormat4RangeShift;

			/* Assert((uint16)SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_ENTRYSELECTOR])) == ClientInfo->usFormat4EntrySelector); */
			usEntrySelector = ClientInfo->usFormat4EntrySelector;
		}

		if (charCode >= (uint16) SWAPW (* ((uint16 *) ((char *)tableP + usSearchRange))))
		{
			tableP = (uint16 *) ((char *)tableP + usRangeShift); /* range to low shift it up */
		}


		switch( usEntrySelector )
		{
		case 15:
			SFAC_BINARYITERATION;
			/* fall through */
		case 14:
			SFAC_BINARYITERATION;
			/* fall through */
		case 13:
			SFAC_BINARYITERATION;
			/* fall through */
		case 12:
			SFAC_BINARYITERATION;
			/* fall through */
		case 11:
			SFAC_BINARYITERATION;
			/* fall through */
		case 10:
			SFAC_BINARYITERATION;
			/* fall through */
		case 9:
			SFAC_BINARYITERATION;
			/* fall through */
		case 8:
			SFAC_BINARYITERATION;
			/* fall through */
		case 7:
			SFAC_BINARYITERATION;
			/* fall through */
		case 6:
			SFAC_BINARYITERATION;
			/* fall through */
		case 5:
			SFAC_BINARYITERATION;
			/* fall through */
		case 4:
			SFAC_BINARYITERATION;
			/* fall through */
		case 3:
		case 2:   /* drop through */
		case 1:
		case 0:
			break;
		default:
			Assert(FALSE);
			break;
		}
	}

	/*  Now do linear search */

	while(charCode > (uint16) SWAPW(*tableP))
	{
		tableP++;
	}

	tableP++;                  /*  Skip Past reservedPad word    */

	/* End of search, now do mapping */

	tableP = (uint16 *) ((char *)tableP + usSegCountX2); /* point at startCount[] */
	usStartCount = (uint16) SWAPW (*tableP);

	if (charCode >= usStartCount)
	{
		  usOffset = (uint16)(charCode - (uint16) SWAPW (*tableP));
		tableP = (uint16 *) ((char *)tableP + usSegCountX2); /* point to idDelta[] */
		usIdDelta = (uint16) SWAPW (*tableP);
		tableP = (uint16 *) ((char *)tableP + usSegCountX2); /* point to idRangeOffset[] */

		if ((uint16) SWAPW (*tableP) == 0)
		{
				usIndex   = (uint16)(charCode + usIdDelta);
		}
		else
		{
			/* Use glyphIdArray to access index */

			usOffset += usOffset; /* make word offset */
			tableP   = (uint16 *) ((char *)tableP + (uint16) SWAPW (*tableP) + usOffset); /* point to glyphIndexArray[] */

			if((uint16)SWAPW (*tableP) != MISSING_GLYPH_INDEX)
			{
					 usIndex    = (uint16)((uint16) SWAPW (*tableP) + usIdDelta);
			}
			else
			{
				usIndex = MISSING_GLYPH_INDEX;
			}
		}
	}
	else
	{
		usIndex = MISSING_GLYPH_INDEX;
	}

	return usIndex;
}


/*
 * Trimmed Table Mapping
 */

FS_PRIVATE uint16 sfac_ComputeIndex6 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	const uint8 *Table6;

	FS_UNUSED_PARAMETER(ClientInfo);

	Table6 = (const uint8 *) mapping;

	charCode  -= (uint16)SWAPW (*((uint16 *)&Table6[SFNT_MAPPINGTABLE6_FIRSTCODE]));

	if (charCode < (uint16) SWAPW (*((uint16 *)&Table6[SFNT_MAPPINGTABLE6_ENTRYCOUNT])))
	{
		return ((uint16) SWAPW (((uint16 *)&Table6[SFNT_MAPPINGTABLE6_GLYPHIDARRAY]) [charCode]));
	}
	else
	{
		return   MISSING_GLYPH_INDEX;
	}
}


/*
 * Sets up our mapping function pointer.
 */

FS_PUBLIC ErrorCode sfac_ComputeMapping (
	sfac_ClientRec *  ClientInfo,
	uint16            usPlatformID,
	uint16            usSpecificID)

{
	const uint8 *   table;
	const uint8 *   MappingTable;
	const uint8 *   Table4;
	boolean         bFound;
	ErrorCode       Ret;
	const uint8 *	plat;
	uint16			usSegCountX2;

	bFound = FALSE;

	/* the following code allow a client that is only interested by glyph indices to
               call fs_NewSfnt with -1 for PlatformID and SpecificID */
	if(usPlatformID == 0xFFFF)
	{
		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		return NO_ERR;
	}


	Ret = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, FALSE, (const void **)&table);

	if(Ret != NO_ERR)
	{
		return Ret;
	}


	if (table == NULL)
	{
		/* If no "cmap" is present, permits access to characters by glyph index */

		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		return NO_ERR;
	}

	/* APPLE Code
	if(*((uint16 *)&table[SFNT_CHAR2INDEXDIRECTORY_VERSION]) != 0)
	{
		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		RELEASESFNTFRAG(ClientInfo, table);
		return OUT_OF_RANGE_SUBTABLE;
	}
	*/

	/* mapping */

	plat = (uint8 *) &table[SFNT_CHAR2INDEXDIRECTORY_PLATFORM]; /* <4> */

	while(plat < (uint8 *)&table[SFNT_CHAR2INDEXDIRECTORY_PLATFORM + ((uint16)SWAPW(*((uint16 *)&table[SFNT_CHAR2INDEXDIRECTORY_NUMTABLES])) *
		  SIZEOF_SFNT_PLATFORMENTRY)] && !bFound)
	{
		if (((uint16)SWAPW(*((uint16 *)&plat[SFNT_PLATFORMENTRY_PLATFORMID])) == usPlatformID) &&
			((uint16)SWAPW(*((uint16 *)&plat[SFNT_PLATFORMENTRY_SPECIFICID])) == usSpecificID))
		{
			bFound = TRUE;
			ClientInfo->ulMapOffset = (uint32) SWAPL (*((uint32 *)&plat[SFNT_PLATFORMENTRY_PLATFORMOFFSET]));   /* skip header */
		}
		plat += SIZEOF_SFNT_PLATFORMENTRY;
	}


	if (!bFound)
	{
		ClientInfo->ulMapOffset = 0;
		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		RELEASESFNTFRAG(ClientInfo, table);
		return OUT_OF_RANGE_SUBTABLE;
	}
	else
	{
		Assert(Ret == NO_ERR);
		MappingTable = (uint8 *)((uint8 *)table + ClientInfo->ulMapOffset);  /* back up for header */
		ClientInfo->ulMapOffset += (uint32)SIZEOF_SFNT_MAPPINGTABLE;
	}

    ClientInfo->usMappingFormat = (uint16)SWAPW (*((uint16 *)&MappingTable[SFNT_MAPPINGTABLE_FORMAT]));

	switch (ClientInfo->usMappingFormat)
	{
	case 0:
		ClientInfo->GlyphMappingF = sfac_ComputeIndex0;
		break;
	case 2:
		ClientInfo->GlyphMappingF = sfac_ComputeIndex2;
		break;
	case 4:
		ClientInfo->GlyphMappingF = sfac_ComputeIndex4;

		/* Pre-compute several values used for Index 4 lookups */
		/* This becomes necessary because of several font vendors who */
		/* have placed incorrect values in the TrueType font file. */

		Table4 = (uint8 *)((uint8 *)table + ClientInfo->ulMapOffset);
		usSegCountX2 = (uint16) SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_SEGCOUNTX2]));

		sfac_ComputeBinarySearchParams(
			(uint16)(usSegCountX2 / 2),
			&ClientInfo->usFormat4SearchRange,
			&ClientInfo->usFormat4EntrySelector,
			&ClientInfo->usFormat4RangeShift);

		break;
	case 6:
		ClientInfo->GlyphMappingF = sfac_ComputeIndex6;
		break;
	default:
		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		Ret = UNKNOWN_CMAP_FORMAT;
		break;
	}
	RELEASESFNTFRAG(ClientInfo, table);

	return Ret;
}

FS_PRIVATE void	sfac_ComputeBinarySearchParams(
	uint16		usSegCount, 		/* INPUT */
	uint16 *	pusSearchRange,		/* OUTPUT */
	uint16 *	pusEntrySelector,	/* OUTPUT */
	uint16 *	pusRangeShift)		/* OUTPUT */
{
	uint16			usLog;
	uint16			usPowerOf2;

	usLog = 0;
	usPowerOf2 = 1;

	while((2 * usPowerOf2) <= usSegCount )
	{
		usPowerOf2 *= 2;
		usLog++;
	}

	*pusSearchRange = 2 * usPowerOf2;
	*pusEntrySelector = usLog;
	*pusRangeShift = (2 * usSegCount) - (2 * usPowerOf2);
}

FS_PUBLIC ErrorCode sfac_GetGlyphIndex(
	sfac_ClientRec *  ClientInfo,
	uint16            usCharacterCode)
{
	 const uint8 *   mappingPtr;
	ErrorCode   error;

	 error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, TRUE, (const void **)&mappingPtr);

	if(error != NO_ERR)
	{
		return error;
	}

	ClientInfo->usGlyphIndex = ClientInfo->GlyphMappingF (mappingPtr + ClientInfo->ulMapOffset, usCharacterCode, ClientInfo);

	RELEASESFNTFRAG(ClientInfo, mappingPtr);

	return NO_ERR;
}

/*  return glyph ID's for a range or for an array of character codes */

FS_PUBLIC ErrorCode sfac_GetMultiGlyphIDs (
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID)         /* Output glyph ID array        */
{
	const uint8 *       mappingPtr;
    const uint8 *       mapOffsetPtr;
	ErrorCode           errCode;

    if ((ClientInfo->usMappingFormat != 0) &&
        (ClientInfo->usMappingFormat != 2) &&
        (ClientInfo->usMappingFormat != 4) &&
        (ClientInfo->usMappingFormat != 6))
    {
        return UNKNOWN_CMAP_FORMAT;
    }

	errCode = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, TRUE, (const void **)&mappingPtr);
    if(errCode != NO_ERR)
	{
		return errCode;
	}
    mapOffsetPtr = mappingPtr + ClientInfo->ulMapOffset;

    errCode = sfac_GetGlyphIDs (
   	    ClientInfo->GlyphMappingF,
        mapOffsetPtr,
        ClientInfo,
        usCharCount,
	    usFirstChar,
	    pusCharCode,
	    pusGlyphID);

	RELEASESFNTFRAG(ClientInfo, mappingPtr);

	return errCode;
}

/*  special version for Win95 doesn't require a font context */

FS_PUBLIC ErrorCode sfac_GetWin95GlyphIDs (
	uint8 *             pbyCmapSubTable,       /* Pointer to cmap sub table    */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID)         /* Output glyph ID array        */
{
   	uint16              usMappingFormat;    /* cmap subtable format code    */
   	MappingFunc			pfnGlyphMapping;	/* mapping func char to glyph   */
    const uint8 *       pbyCmapData;        /* past subtable header         */
 	ErrorCode           errCode;

    usMappingFormat = (uint16)SWAPW (*((uint16 *)&pbyCmapSubTable[SFNT_MAPPINGTABLE_FORMAT]));
	switch (usMappingFormat)
	{
	case 0:
		pfnGlyphMapping = sfac_ComputeIndex0;
		break;
	case 2:
		pfnGlyphMapping = sfac_ComputeIndex2;
        break;
	case 4:
		pfnGlyphMapping = sfac_ComputeIndex4;
        break;
	case 6:
		pfnGlyphMapping = sfac_ComputeIndex6;
		break;
    default:
        return UNKNOWN_CMAP_FORMAT;
    }
    pbyCmapData = pbyCmapSubTable + SIZEOF_SFNT_MAPPINGTABLE;


    errCode = sfac_GetGlyphIDs (
   	    pfnGlyphMapping,
        pbyCmapData,
        NULL,                               /* ClientInfo */
        usCharCount,
	    usFirstChar,
	    pusCharCode,
	    pusGlyphID );

	return errCode;
}

/* special helper function for NT
   - an offset usCharCodeOffset is added to the character codes from pulCharCode 
     before converting the value to glyph index
   - pulCharCode and pulGlyphID are both uint32 *
   - pulCharCode and pulGlyphID can point to the same address        
*/

FS_PUBLIC ErrorCode sfac_GetWinNTGlyphIDs (
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint32	            ulCharCodeOffset,   /* Offset to be added to *pulCharCode
											   before converting            */
	uint32 *	        pulCharCode,        /* Pointer to char code list    */
	uint32 *	        pulGlyphID)        /* Output glyph ID array        */
{
	const uint8 *       mappingPtr;
    const uint8 *       mapOffsetPtr;
	ErrorCode           errCode;

    if ((ClientInfo->usMappingFormat != 0) &&
        (ClientInfo->usMappingFormat != 2) &&
        (ClientInfo->usMappingFormat != 4) &&
        (ClientInfo->usMappingFormat != 6))
    {
        return UNKNOWN_CMAP_FORMAT;
    }

	errCode = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, TRUE, (const void **)&mappingPtr);
    if(errCode != NO_ERR)
	{
		return errCode;
	}
    mapOffsetPtr = mappingPtr + ClientInfo->ulMapOffset;

    errCode = sfac_GetLongGlyphIDs (
   	    ClientInfo->GlyphMappingF,
        mapOffsetPtr,
        ClientInfo,
        usCharCount,
	    usFirstChar,
		ulCharCodeOffset,
	    pulCharCode,
	    pulGlyphID);

	RELEASESFNTFRAG(ClientInfo, mappingPtr);

	return errCode;
}

/*      common code for the two get glyph ID helper routines */

FS_PRIVATE ErrorCode sfac_GetGlyphIDs (
   	MappingFunc			pfnGlyphMapping,	/* mapping func char to glyph	*/
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
	sfac_ClientRec *    ClientInfo,         /* May be NULL!                 */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usCharCode,         /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID)         /* Output glyph ID array        */
{
	if (pusCharCode == NULL)                /* Null pointer implies character code range */
    {
        if (((uint32)usCharCode + (uint32)usCharCount) > 0x0000FFFFL)
        {
            return INVALID_CHARCODE_ERR;    /* trap an illegal range */
        }

        while (usCharCount > 0)
        {
        	*pusGlyphID = pfnGlyphMapping (mapOffsetPtr, usCharCode, ClientInfo);
            pusGlyphID++;
            usCharCode++;                   /* next character in range */
            usCharCount--;
        }
    }
    else                                    /* Valid pointer implies character code array */
    {
        while (usCharCount > 0)
        {
            if (*pusCharCode == 0xFFFF)     /* trap illegal char code */
            {
                return INVALID_CHARCODE_ERR;
            }
        	*pusGlyphID = pfnGlyphMapping (mapOffsetPtr, *pusCharCode, ClientInfo);
            pusGlyphID++;
            pusCharCode++;                  /* next character in array */
            usCharCount--;
        }
    }
	return NO_ERR;
}

/*      special for NT */

FS_PRIVATE ErrorCode sfac_GetLongGlyphIDs (
   	MappingFunc			pfnGlyphMapping,	/* mapping func char to glyph	*/
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
	sfac_ClientRec *    ClientInfo,         /* May be NULL!                 */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usCharCode,         /* First char code              */
	uint32	            ulCharCodeOffset,   /* Offset to be added to *pulCharCode
											   before converting            */
	uint32 *	        pulCharCode,        /* Pointer to char code list    */
	uint32 *	        pulGlyphID)         /* Output glyph ID array        */
{
	if (pulCharCode == NULL)                /* Null pointer implies character code range */
    {
        if (((uint32)usCharCode + (uint32)usCharCount) > 0x0000FFFFL)
        {
            return INVALID_CHARCODE_ERR;    /* trap an illegal range */
        }

        while (usCharCount > 0)
        {
        	*pulGlyphID = (uint32)pfnGlyphMapping (mapOffsetPtr, usCharCode, ClientInfo);
            pulGlyphID++;
            usCharCode++;                   /* next character in range */
            usCharCount--;
        }
    }
    else                                    /* Valid pointer implies character code array */
    {
        while (usCharCount > 0)
        {
			if ((*pulCharCode + ulCharCodeOffset) > 0x0000FFFFL)
            {
                return INVALID_CHARCODE_ERR;   /* trap an illegal range */
            }
			usCharCode = (uint16) (*pulCharCode + ulCharCodeOffset);
        	*pulGlyphID = (uint32)pfnGlyphMapping (mapOffsetPtr, usCharCode, ClientInfo);
            pulGlyphID++;
            pulCharCode++;                  /* next character in array */
            usCharCount--;
        }
    }
	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC ErrorCode sfac_LoadCriticalSfntMetrics(
	sfac_ClientRec *        ClientInfo,
	uint16 *                pusEmResolution,
	boolean *               pbIntegerScaling,
	LocalMaxProfile *       pMaxProfile)
{
	ErrorCode       error;
	const uint8 *   fontHead;
	const uint8 *   horiHead;
	const uint8 *   pTempMaxProfile;
	const uint8 *   pTempOS_2;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_fontHeader, TRUE, (const void **)&fontHead);

	if(error != NO_ERR)
	{
		return error;
	}

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_horiHeader, TRUE, (const void **)&horiHead);

	if(error != NO_ERR)
	{
		return error;
	}

	if ((uint32)SWAPL (*((uint32 *)&fontHead[SFNT_FONTHEADER_MAGICNUMBER])) != SFNT_MAGIC)
	{
		return BAD_MAGIC_ERR;
	}

	*pusEmResolution     = (uint16)SWAPW (*((uint16 *)&fontHead[SFNT_FONTHEADER_UNITSPEREM]));
	if(*pusEmResolution < 16 || *pusEmResolution > 16384)
		return BAD_UNITSPEREM_ERR;
		
	*pbIntegerScaling    = (((uint16)SWAPW (*((uint16 *)&fontHead[SFNT_FONTHEADER_FLAGS]))& USE_INTEGER_SCALING) ==
									 USE_INTEGER_SCALING);

	ClientInfo->usNumberOf_LongHorMetrics = (uint16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_NUMBEROF_LONGHORMETRICS]));
	if(ClientInfo->usNumberOf_LongHorMetrics == 0)
		return BAD_NUMLONGHORMETRICS_ERR;

	ClientInfo->sIndexToLocFormat       = SWAPW (*((int16 *)&fontHead[SFNT_FONTHEADER_INDEXTOLOCFORMAT]));

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_OS_2, FALSE, (const void **)&pTempOS_2); /* not a mandatory table */

	if(error != NO_ERR)
	{
		return error;
	}

	if(pTempOS_2 != NULL)
	{
		/* get TypoAscender and TypoDescender from the OS/2 table */
		ClientInfo->sDefaultAscender = (int16)SWAPW (*((uint16 *)&pTempOS_2[SFNT_OS2_STYPOASCENDER]));
		ClientInfo->sDefaultDescender = (int16)SWAPW (*((uint16 *)&pTempOS_2[SFNT_OS2_STYPODESCENDER]));
		RELEASESFNTFRAG(ClientInfo, pTempOS_2);
	} else {
		/* if OS/2 is not there get the values from horizontal header */
		ClientInfo->sDefaultAscender = (int16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_YASCENDER]));
		ClientInfo->sDefaultDescender = (int16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_YDESCENDER]));
	}
	ClientInfo->sWinDescender = (int16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_YDESCENDER]));

	RELEASESFNTFRAG(ClientInfo, horiHead);
	RELEASESFNTFRAG(ClientInfo, fontHead);

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_maxProfile, TRUE, (const void **)&pTempMaxProfile);

	if(error != NO_ERR)
	{
		return error;
	}

	pMaxProfile->version =              (Fixed)SWAPL(*((Fixed *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_VERSION]));
	pMaxProfile->numGlyphs =            (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_NUMGLYPHS]));
	pMaxProfile->maxPoints =            (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXPOINTS]));
	pMaxProfile->maxContours =          (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCONTOURS]));
	pMaxProfile->maxCompositePoints =   (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPOSITEPOINTS]));
	pMaxProfile->maxCompositeContours = (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPOSITECONTOURS]));
	pMaxProfile->maxElements =          (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXELEMENTS]));
	pMaxProfile->maxTwilightPoints =    (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXTWILIGHTPOINTS]));
	pMaxProfile->maxStorage =           (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXSTORAGE]));
	pMaxProfile->maxFunctionDefs =      (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXFUNCTIONDEFS]));
	pMaxProfile->maxInstructionDefs =   (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXINSTRUCTIONDEFS]));
	pMaxProfile->maxStackElements =     (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXSTACKELEMENTS]));
	pMaxProfile->maxSizeOfInstructions =(uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXSIZEOFINSTRUCTIONS]));
	pMaxProfile->maxComponentElements = (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPONENTELEMENTS]));
	pMaxProfile->maxComponentDepth =    (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPONENTDEPTH]));

	RELEASESFNTFRAG(ClientInfo, pTempMaxProfile);

	error = sfac_ReadNumLongVertMetrics(ClientInfo, &ClientInfo->usNumLongVertMetrics,&ClientInfo->bValidNumLongVertMetrics);

	return error;
}



/*
 *
 */

FS_PUBLIC ErrorCode sfac_ReadGlyphHorMetrics (
	sfac_ClientRec *    ClientInfo,
	uint16              glyphIndex,
	uint16 *            pusNonScaledAW,
	int16 *             psNonScaledLSB)
{
	const uint8 *   horizMetricPtr;
	uint16          numberOf_LongHorMetrics;
	ErrorCode       error;
	int16 *         lsb;

	numberOf_LongHorMetrics = ClientInfo->usNumberOf_LongHorMetrics;
	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_horizontalMetrics, TRUE, (const void **)&horizMetricPtr);

	if(error != NO_ERR)
	{
		return error;
	}

	if (glyphIndex < numberOf_LongHorMetrics)
	{
		*pusNonScaledAW     = (uint16)SWAPW (*((uint16 *)&horizMetricPtr[(glyphIndex * SIZEOF_SFNT_HORIZONTALMETRICS) + SFNT_HORIZONTALMETRICS_ADVANCEWIDTH]));
		*psNonScaledLSB     = SWAPW (*((int16 *)&horizMetricPtr[(glyphIndex * SIZEOF_SFNT_HORIZONTALMETRICS) + SFNT_HORIZONTALMETRICS_LEFTSIDEBEARING]));
	}
	else
	{
		lsb = (int16 *) (char *)& horizMetricPtr[numberOf_LongHorMetrics * SIZEOF_SFNT_HORIZONTALMETRICS]; /* first entry after[AW,LSB] array */

		*pusNonScaledAW       = (uint16)SWAPW (*((uint16 *)&horizMetricPtr[((numberOf_LongHorMetrics-1) * SIZEOF_SFNT_HORIZONTALMETRICS) + SFNT_HORIZONTALMETRICS_ADVANCEWIDTH]));
		*psNonScaledLSB      = SWAPW (lsb[glyphIndex - numberOf_LongHorMetrics]);
	}

	RELEASESFNTFRAG(ClientInfo, horizMetricPtr);

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_ReadGlyphVertMetrics (
	sfac_ClientRec *    ClientInfo,
	uint16              glyphIndex,
	uint16 *            pusNonScaledAH,
	int16 *             psNonScaledTSB)
{
	const uint8 *   vertMetricPtr;
	uint16          usNumLongVertMetrics;       /* number of entries with AH */
	ErrorCode       error;
	int16 *         psTSB;
	BBOX            bbox;           


	usNumLongVertMetrics = ClientInfo->usNumLongVertMetrics;
	if(ClientInfo->bValidNumLongVertMetrics)
	{

		error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_verticalMetrics, FALSE, (const void **)&vertMetricPtr);  /* not a mandatory table */

		if(error != NO_ERR)
		{
			return error;
		}
	}

	if (ClientInfo->bValidNumLongVertMetrics && (vertMetricPtr != NULL) )
	{
		if (glyphIndex < usNumLongVertMetrics)
		{
			*pusNonScaledAH     = (uint16)SWAPW (*((uint16 *)&vertMetricPtr[(glyphIndex * SIZEOF_SFNT_VERTICALMETRICS) + SFNT_VERTICALMETRICS_ADVANCEHEIGHT]));
			*psNonScaledTSB     = SWAPW (*((int16 *)&vertMetricPtr[(glyphIndex * SIZEOF_SFNT_VERTICALMETRICS) + SFNT_VERTICALMETRICS_TOPSIDEBEARING]));
		}
		else
		{
			psTSB = (int16 *) (char *)& vertMetricPtr[usNumLongVertMetrics * SIZEOF_SFNT_VERTICALMETRICS]; /* first entry after[AW,TSB] array */

			*pusNonScaledAH       = (uint16)SWAPW (*((uint16 *)&vertMetricPtr[((usNumLongVertMetrics-1) * SIZEOF_SFNT_VERTICALMETRICS) + SFNT_VERTICALMETRICS_ADVANCEHEIGHT]));
			*psNonScaledTSB      = SWAPW (psTSB[glyphIndex - usNumLongVertMetrics]);
		}

		RELEASESFNTFRAG(ClientInfo, vertMetricPtr);
	} else {

		/* We don't have vertical metrics, let's set to default values */

		/* to get the glyph bbox for the defalut value of the vertical metrics */
		error = sfac_ReadGlyphBbox(ClientInfo,ClientInfo->usGlyphIndex, &bbox);

		if(error != NO_ERR)
		{
			return error;
		}		

		/* default if no vertical metrics found */
		*pusNonScaledAH = ClientInfo->sDefaultAscender - ClientInfo->sDefaultDescender;   
		*psNonScaledTSB = ClientInfo->sDefaultAscender - bbox.yMax;
	}

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_ReadGlyphMetrics (
	sfac_ClientRec *    ClientInfo,
	uint16              glyphIndex,
	uint16 *            pusNonScaledAW,
	uint16 *            pusNonScaledAH,
	int16 *             psNonScaledLSB,
	int16 *             psNonScaledTSB)
{
	ErrorCode       error;

	error = sfac_ReadGlyphHorMetrics (ClientInfo, glyphIndex, pusNonScaledAW, psNonScaledLSB);

	if(error != NO_ERR)
	{
		return error;
	}

	error = sfac_ReadGlyphVertMetrics (ClientInfo, glyphIndex, pusNonScaledAH, psNonScaledTSB);
	return error;
}

/*
 *  Read Number of Long Vertical Metrics from vhea table
 */

FS_PUBLIC ErrorCode sfac_ReadNumLongVertMetrics(
	sfac_ClientRec *        ClientInfo,
	uint16 *                pusNumLongVertMetrics,
	boolean *               pbValidNumLongVertMetrics )
{
	ErrorCode       error;
	const uint8 *   vertHead;

	*pbValidNumLongVertMetrics = FALSE;
	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_vertHeader, FALSE, (const void **)&vertHead);

	if(error != NO_ERR)
	{
		return error;
	}		
	
	if(vertHead != NULL)
	{
		*pusNumLongVertMetrics = (uint16)SWAPW (*((uint16 *)&vertHead[SFNT_VERTICALHEADER_NUMBEROF_LONGVERTMETRICS]));
		*pbValidNumLongVertMetrics = TRUE;

		RELEASESFNTFRAG(ClientInfo, vertHead);
	}

	return NO_ERR;
}


FS_PRIVATE ErrorCode sfac_GetGlyphLocation (
	sfac_ClientRec *    ClientInfo,
	uint16              gIndex,
	uint32 *            ulOffset,
	uint32 *            ulLength,
	sfnt_tableIndex*    pGlyphTableIndex)

{
	const void *    indexPtr;
	ErrorCode       error;
	uint16 *        shortIndexToLoc;
	uint32 *        longIndexToLoc;
	uint32 *        offsetPtr;
	uint16 *        lengthPtr;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_GlyphDirectory, FALSE, (const void **)&indexPtr);

	if(error != NO_ERR)
	{
		return error;
	}

	/* If there is a glyph directory, first check for the glyph there.  */

	if (indexPtr != NULL)
	{
		offsetPtr = (uint32 *)((char *)indexPtr+((int32)gIndex*(int32)(sizeof(int32)+sizeof(uint16))));
		lengthPtr = (uint16 *)(char *)(offsetPtr+1);

		*ulOffset = (uint32)SWAPL(*offsetPtr);

		if(*ulOffset == 0L)
		{
			*ulLength =  0L;
		}
		else
		{
			*ulLength =  (uint32) (uint16)SWAPW(*lengthPtr);
		}

		/* sfnt_BeginningOfFont references the beginning of memory  */

		*pGlyphTableIndex = sfnt_BeginningOfFont;

		RELEASESFNTFRAG(ClientInfo, indexPtr);
		return NO_ERR;
	}

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_indexToLoc, TRUE, (const void **)&indexPtr);
	if(error != NO_ERR)
	{
		return error;
	}

	if (ClientInfo->sIndexToLocFormat == SHORT_INDEX_TO_LOC_FORMAT)
	{
		shortIndexToLoc = (uint16 *)indexPtr + gIndex;
		*ulOffset = (uint32) (uint16) (SWAPW (*shortIndexToLoc)) << 1;
		shortIndexToLoc++;
		*ulLength =  (((uint32) (uint16) (SWAPW (*shortIndexToLoc)) << 1) - *ulOffset);
	}
	else
	{
		longIndexToLoc = (uint32 *)indexPtr + gIndex;
		*ulOffset = (uint32) SWAPL (*longIndexToLoc);
		longIndexToLoc++;
		*ulLength = ((uint32)SWAPL (*longIndexToLoc) - *ulOffset);
	}

	*pGlyphTableIndex = sfnt_glyphData;

	RELEASESFNTFRAG(ClientInfo, indexPtr);

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_CopyFontAndPrePrograms(
	sfac_ClientRec *    ClientInfo,    /* Client Information         */
	char *              pFontProgram,  /* pointer to Font Program    */
	char *              pPreProgram)   /* pointer to Pre Program     */
{
	uint32              ulLength;
	const char *        pFragment;
	ErrorCode           error;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_fontProgram, FALSE, (const void **)&pFragment);
	if(error)
	{
		return error;
	}
	ulLength = SFAC_LENGTH (ClientInfo, sfnt_fontProgram);
	if (ulLength)
	{
		MEMCPY (pFontProgram, pFragment, ulLength);
		RELEASESFNTFRAG(ClientInfo, pFragment);
	}

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_preProgram, FALSE, (const void **)&pFragment);
	if(error)
	{
		return error;
	}
	ulLength = SFAC_LENGTH (ClientInfo, sfnt_preProgram);
	if (ulLength)
	{
		MEMCPY (pPreProgram, pFragment, ulLength);
		RELEASESFNTFRAG(ClientInfo, pFragment);
	}

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_CopyCVT(
	sfac_ClientRec *    ClientInfo,    /* Client Information   */
	F26Dot6 *           pCVT)       /* pointer to CVT    */
{
	uint32              ulLength;
	const int16 *       pFragment;
	int32               lNumCVT;
	int32               lCVTCount;
	const int16 *       psSrcCVT;
	F26Dot6 *           pfxDstCVT;
	ErrorCode           error;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_controlValue, FALSE, (const void **)&pFragment);

	if(error)
	{
		return error;
	}

	ulLength = SFAC_LENGTH (ClientInfo, sfnt_controlValue);

	if (ulLength)
	{
		psSrcCVT = pFragment;
		pfxDstCVT = pCVT;

		lNumCVT = ((int32)ulLength / (int32)sizeof( sfnt_ControlValue));

		for(lCVTCount = 0L; lCVTCount < lNumCVT; lCVTCount++)
		{
			pfxDstCVT[lCVTCount] = (F26Dot6)SWAPW(psSrcCVT[lCVTCount]);
		}

		RELEASESFNTFRAG(ClientInfo, pFragment);
	}

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_CopyHdmxEntry(
	sfac_ClientRec *    ClientInfo,     /* Client Information   */
	uint16              usPixelsPerEm,  /* Current Pixels per Em    */
	boolean *           pbFound,        /* Flag indicating if entry found */
	uint16              usFirstGlyph,   /* First Glyph to copy */
	uint16              usLastGlyph,    /* Last Glyph to copy */
	int16 *             psBuffer)       /* Buffer to save glyph sizes */
{
	const uint8 *       pHdmx;
	const uint8 *       pCurrentHdmxRecord;
	uint32              ulHdmxRecordSize;
	uint16              usRecordIndex;
	uint16              usGlyphIndex;
	ErrorCode           error;

	Assert( usFirstGlyph <= usLastGlyph );
	Assert( psBuffer != NULL );

	*pbFound = FALSE;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_HoriDeviceMetrics, FALSE, (const void **)&pHdmx);

	if(error)
	{
		return error;
	}

	/* If no 'hdmx' return success and not found    */

	if( pHdmx == NULL )
	{
		return NO_ERR;
	}

	if((uint16)pHdmx[SFNT_HDMX_VERSION] == 0)   /*  NOTE: No SWAP for zero check    */
	{
		ulHdmxRecordSize = (uint32)SWAPL(*((uint32 *)&pHdmx[SFNT_HDMX_LSIZERECORD]));

		usRecordIndex = 0;
		pCurrentHdmxRecord = &pHdmx[SFNT_HDMX_HDMXTABLE];
		while (  (usRecordIndex < (uint16)SWAPW(*((uint16 *)&pHdmx[SFNT_HDMX_SNUMRECORDS]))) && !*pbFound )
		{
			if( usPixelsPerEm == (uint16)pCurrentHdmxRecord[SFNT_HDMXRECORD_BEMY] )
			{
				*pbFound = TRUE;
			}
			else
			{
				pCurrentHdmxRecord += ulHdmxRecordSize;
			}
			usRecordIndex++;
		}

		if ( *pbFound )
		{
			for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++)
			{
				*psBuffer = (int16)pCurrentHdmxRecord[SFNT_HDMXRECORD_BWIDTHS + usGlyphIndex];
				psBuffer++;
			}
		}
	}

	RELEASESFNTFRAG(ClientInfo, pHdmx);

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_GetLTSHEntries(
	sfac_ClientRec *    ClientInfo,     /* Client Information   */
	uint16              usPixelsPerEm,  /* Current Pixels per Em    */
	uint16              usFirstGlyph,   /* First Glyph to copy */
	uint16              usLastGlyph,    /* Last Glyph to copy */
	int16 *             psBuffer)       /* Buffer to save glyph sizes */
{
	const uint8 *       pLTSH;
	uint16              usGlyphIndex;
	ErrorCode           error;

	MEMSET(psBuffer, FALSE, ((usLastGlyph - usFirstGlyph) + 1) * sizeof(int16));

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_LinearThreshold, FALSE, (const void **)&pLTSH);

	if(error)
	{
		return error;
	}
	
	if( pLTSH == NULL )
	{
		return NO_ERR;
	}

	if((uint16)pLTSH[SFNT_LTSH_VERSION] == 0)   /*  NOTE: No SWAP for zero check    */
	{
		for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++ )
		{
			if( usPixelsPerEm >= (uint16)pLTSH[SFNT_LTSH_UBYPELSHEIGHT + usGlyphIndex] )
			{
				*psBuffer = TRUE;
			}
			else
			{
				*psBuffer = FALSE;
			}
			psBuffer++;
		}
	}

	RELEASESFNTFRAG(ClientInfo, pLTSH);

	return NO_ERR;
}



/***************************** Public  Function ****************************\
* sfac_ReadGlyphHeader
*
* This routine sets up the glyph handle to a glyph, and returns the header
* information in the glyph.
*
* Effects:
*
* Error Returns:
*
* UNKNOWN_COMPOSITE_VERSION
*
* History:
* Wed 26-Aug-1992 09:55:19 -by-  Greg Hitchcock [gregh]
*      Added CodeReview fixes
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadGlyphHeader(
	sfac_ClientRec *    ClientInfo,       /* Client Information         */
	uint16              usGlyphIndex,     /* Glyph index to read        */
	sfac_GHandle *      hGlyph,           /* Return glyph handle        */
	boolean *           pbCompositeGlyph, /* Is glyph a composite?      */
	boolean *           pbHasOutline,     /* Does glyph have outlines?  */
	int16 *             psNumberOfContours, /* Number of contours in glyph */
	BBOX *              pbbox)            /* Glyph Bounding box         */
{
	uint32              ulLength;
	uint32              ulOffset;
	sfnt_tableIndex     glyphTableIndex;
	ErrorCode           error;
	const uint8 *       GlyphHeader;

	hGlyph->pvGlyphBaseAddress = NULL;
	hGlyph->pvGlyphNextAddress = NULL;

	/* Locate the glyph in the font file   */

	error = sfac_GetGlyphLocation(
		ClientInfo,
		usGlyphIndex,
		&ulOffset,
		&ulLength,
		&glyphTableIndex);

	if(error)
	{
		return error;
	}

	if( ulLength == 0 )
	{
		*psNumberOfContours = 1;
		MEMSET(pbbox, 0, sizeof(BBOX));
		*pbHasOutline = FALSE;
		*pbCompositeGlyph = FALSE;
	}
	else
	{
		if (ulLength < SFNT_PACKEDSPLINEFORMAT_ENDPOINTS)
		{
			return GLYF_TABLE_CORRUPTION_ERR;
		}

		error = sfac_GetDataPtr(ClientInfo, ulOffset, ulLength,
				glyphTableIndex, TRUE, (const void **)&hGlyph->pvGlyphBaseAddress);

		if(error)
		{
			return error;
		}

		hGlyph->pvGlyphEndAddress = (uint8 *)hGlyph->pvGlyphBaseAddress + ulLength;

		GlyphHeader = (uint8 *)hGlyph->pvGlyphBaseAddress;
		*psNumberOfContours = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_NUMBEROFCONTOURS]));

		if( *psNumberOfContours < COMPONENTCTRCOUNT )
		{
			return UNKNOWN_COMPOSITE_VERSION;
		}

		if( *psNumberOfContours == COMPONENTCTRCOUNT )
		{
			*pbCompositeGlyph = TRUE;
			*psNumberOfContours = 0;
			*pbHasOutline = FALSE;
		}
		else
		{
			*pbCompositeGlyph = FALSE;
			*pbHasOutline = TRUE;
		}

		pbbox->xMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMIN]));
		pbbox->yMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMIN]));
		pbbox->xMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMAX]));
		pbbox->yMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMAX]));

		if((pbbox->xMin > pbbox->xMax) || (pbbox->yMin > pbbox->yMax))
		{
			return SFNT_DATA_ERR;
		}

		if(pbHasOutline)
		{
			hGlyph->pvGlyphNextAddress = (voidPtr)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_ENDPOINTS];
		}
	}

	return NO_ERR;
}

/***************************** Public  Function ****************************\
* sfac_ReadGlyphBbox
*
*
* Effects:
*         This function release the glyph memory immediately
*
* Error Returns:
*
* SFNT_DATA_ERR
*
* History:
* Wed 20-Dec-1996 18:42:51 -by-  Claude Betrisey [claudebe]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadGlyphBbox(
	sfac_ClientRec *    ClientInfo,       /* Client Information         */
	uint16              usGlyphIndex,     /* Glyph index to read        */
	BBOX *              pbbox)            /* Glyph Bounding box         */
{
	uint32              ulLength;
	uint32              ulOffset;
	sfnt_tableIndex     glyphTableIndex;
	ErrorCode           error;
	const uint8 *       GlyphHeader;


	/* Locate the glyph in the font file   */

	error = sfac_GetGlyphLocation(
		ClientInfo,
		usGlyphIndex,
		&ulOffset,
		&ulLength,
		&glyphTableIndex);

	if(error)
	{
		return error;
	}

	if( ulLength == 0 )
	{
		MEMSET(pbbox, 0, sizeof(BBOX));
	}
	else
	{
		error = sfac_GetDataPtr(ClientInfo, ulOffset, ulLength,
				glyphTableIndex, TRUE, (const void **)&GlyphHeader);

		if(error)
		{
			return error;
		}

		pbbox->xMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMIN]));
		pbbox->yMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMIN]));
		pbbox->xMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMAX]));
		pbbox->yMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMAX]));

		RELEASESFNTFRAG(ClientInfo, GlyphHeader );

		if((pbbox->xMin > pbbox->xMax) || (pbbox->yMin > pbbox->yMax))
		{
			return SFNT_DATA_ERR;
		}


	}

	return NO_ERR;
}

/***************************** Public  Function ****************************\
* sfac_ReadOutlineData
*
*   This routine reads the outline data from the font file. This information
*   includes x and y coordinates, and on-curve indicators as well as start/end
*   points, flags, and instruction data.
*
* Effects:
*   hGlyph
*
* Error Returns:
*   CONTOUR_DATA_ERR
*
* History:
* Wed 26-Aug-1992 09:55:49 -by-  Greg Hitchcock [gregh]
*      Added Code Review fixes
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/


FS_PUBLIC ErrorCode sfac_ReadOutlineData(
	uint8 *             abyOnCurve,             /* Array of on curve indicators per point */
	F26Dot6 *           afxOoy,                 /* Array of ooy points for every point    */
	F26Dot6 *           afxOox,                 /* Array of oox points for every point    */
	sfac_GHandle *      hGlyph,
	LocalMaxProfile *   pMaxProfile,            /* copy of profile                        */
	boolean             bHasOutline,            /* Does glyph have outlines?              */
	int16               sNumberOfContours,      /* Number of contours in glyph            */
	int16 *             asStartPoints,          /* Array of start points for every contour   */
	int16 *             asEndPoints,            /* Array of end points for every contour    */
	uint16 *            pusSizeOfInstructions,  /* Size of instructions in bytes        */
	 uint8 **               pbyInstructions,    /* Pointer to start of glyph instructions    */
     uint32*                pCompositePoints,   /* total number of point for composites, to check for overflow */
     uint32*                pCompositeContours) /* total number of contours for composites, to check for overflow */

{

	uint8 *     pbyCurrentSfntLocation;
	int16 *     psCurrentLocation;
	int16 *     asSfntEndPoints;
	uint8 *     pbySfntFlags;
	uint8       byRepeatFlag;

	int32       lNumPoints;
	int32       lContourIndex;
	int32       lPointCount;
	int32       lPointIndex;
	uint16      usRepeatCount;
	int16       sXValue;
	int16       sYValue;
	uint8 *     pbyFlags;
	F26Dot6 *   pf26OrigX;
	F26Dot6 *   pf26OrigY;

	/* Initialize Fields */

	asStartPoints[0] = 0;
	asEndPoints[0] = 0;

	abyOnCurve[0] = ONCURVE;
	afxOox[0] = 0;
	afxOoy[0] = 0;

	*pbyInstructions = NULL;
	*pusSizeOfInstructions = 0;

	/* If we don't have an outline, exit here   */

	if (!bHasOutline)
	{
		return NO_ERR;
	}

	if (sNumberOfContours <= 0 || sNumberOfContours > (int16)pMaxProfile->maxContours)
	{
		return CONTOUR_DATA_ERR;
	}

    /* Handle the case of outlines   */

	psCurrentLocation = (int16 *)hGlyph->pvGlyphNextAddress;

	asSfntEndPoints = psCurrentLocation;
	psCurrentLocation += sNumberOfContours;

	if ((voidPtr)psCurrentLocation > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}

	*pusSizeOfInstructions = (uint16)SWAPWINC (psCurrentLocation);
	*pbyInstructions = (uint8 *)psCurrentLocation;
	pbySfntFlags = (uint8 *)((char *)psCurrentLocation + *pusSizeOfInstructions);

	if ((voidPtr)pbySfntFlags > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}


    *pCompositeContours += sNumberOfContours;
	if (*pCompositeContours > (uint32)MAX (pMaxProfile->maxContours, pMaxProfile->maxCompositeContours))
	{
		return CONTOUR_DATA_ERR;
	}

	lContourIndex = 0;

	asStartPoints[lContourIndex] = 0;
	asEndPoints[lContourIndex] = SWAPW (asSfntEndPoints[lContourIndex]);
	lNumPoints = (int32)asEndPoints[lContourIndex] + 1;

	for(lContourIndex = 1; lContourIndex < (int32)sNumberOfContours; lContourIndex++)
	{
		asStartPoints[lContourIndex] = (int16)(asEndPoints[lContourIndex - 1] + 1);
		asEndPoints[lContourIndex] = SWAPW (asSfntEndPoints[lContourIndex]);
		if ((lNumPoints > asEndPoints[lContourIndex]) || (lNumPoints > (int32)pMaxProfile->maxPoints) || (lNumPoints <= 0))
		{
			/* array of end points is not in ascending order, or too many points */
			/* or negative, that mean overflow since it's signed int16 instead of unsigned int16, for example 0xcdab */
			return POINTS_DATA_ERR;
		}
		lNumPoints = (int32)asEndPoints[lContourIndex] + 1;
	}

	if (lNumPoints <= 0)
	{
		return POINTS_DATA_ERR;
	}

    *pCompositePoints += lNumPoints;
	if (*pCompositePoints > (uint32)MAX (pMaxProfile->maxPoints, pMaxProfile->maxCompositePoints) )
	{
		return POINTS_DATA_ERR;
	}

	/* Do flags */

	usRepeatCount = 0;

	lPointCount = lNumPoints;
	pbyFlags = abyOnCurve;

	while(lPointCount > 0)
	{
		if(usRepeatCount == 0)
		{
			*pbyFlags = *pbySfntFlags;

			if(*pbyFlags & REPEAT_FLAGS)
			{
				pbySfntFlags++;
				usRepeatCount = (uint16)*pbySfntFlags;
			}
			pbySfntFlags++;
			pbyFlags++;
			lPointCount--;
		}
		else
		{
			byRepeatFlag = pbyFlags[-1];
			lPointCount -= (int32)usRepeatCount;

			if (lPointCount < 0)
			{
				return GLYF_TABLE_CORRUPTION_ERR;
			}

			while(usRepeatCount > 0)
			{
				*pbyFlags = byRepeatFlag;
				pbyFlags++;
				usRepeatCount--;
			}
		}
	}

	pbyCurrentSfntLocation = pbySfntFlags;

	if(usRepeatCount > 0)
	{
		return POINTS_DATA_ERR;
	}

	if ((voidPtr)pbyCurrentSfntLocation > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}
	/* Do X first */

	sXValue = 0;
	pf26OrigX = afxOox;
	pbyFlags = abyOnCurve;

	for(lPointIndex = 0; lPointIndex < lNumPoints; lPointIndex++)
	{
		if(*pbyFlags & XSHORT)
		{
			if(*pbyFlags & SHORT_X_IS_POS)
			{
				sXValue += (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
			}
			else
			{
				sXValue -= (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
			}
		}
		else if (! (*pbyFlags & NEXT_X_IS_ZERO))
		{
			/* This means we have a two byte quantity */

			sXValue += SWAPW(*((int16 *)pbyCurrentSfntLocation));
			pbyCurrentSfntLocation += sizeof(int16);
		}
		*pf26OrigX = (F26Dot6)sXValue;
		pf26OrigX++;
		pbyFlags++;
	}

	if ((voidPtr)pbyCurrentSfntLocation > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}
	/* Now Do Y */

	sYValue = 0;
	pf26OrigY = afxOoy;
	pbyFlags = abyOnCurve;

	for(lPointIndex = 0; lPointIndex < lNumPoints; lPointIndex++)
	{
		if(*pbyFlags & YSHORT)
		{
			if(*pbyFlags & SHORT_Y_IS_POS)
			{
				sYValue += (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
			}
			else
			{
				sYValue -= (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
			}
		}
		else if (! (*pbyFlags & NEXT_Y_IS_ZERO))
		{
			/* This means we have a two byte quantity */

			sYValue += SWAPW(*((int16 *)pbyCurrentSfntLocation));
			pbyCurrentSfntLocation += sizeof(int16);
		}
		*pf26OrigY = (F26Dot6)sYValue;
		pf26OrigY++;

		/* Clear out extraneous bits in OnCurve */

		*pbyFlags &= ONCURVE;
		pbyFlags++;
	}

	if ((voidPtr)pbyCurrentSfntLocation > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}

	hGlyph->pvGlyphNextAddress = (voidPtr)pbyCurrentSfntLocation;

	return NO_ERR;
}

/***************************** Public  Function ****************************\
*
* sfac_ReadComponentData
*
*   This routine reads information from the font file for positioning and
*   scaling a glyph component.
*
* Effects:
*
* Error Returns:
*   none
*
* History:
* Wed 26-Aug-1992 09:56:29 -by-  Greg Hitchcock [gregh]
*      Added Code Review Fixes
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadComponentData(
	sfac_GHandle *          hGlyph,
	sfac_ComponentTypes *   pMultiplexingIndicator, /* Indicator for Anchor vs offsets  */
	boolean *               pbRoundXYToGrid,  /* Round composite offsets to grid     */
	boolean *               pbUseMyMetrics,   /* Use component metrics            */
	boolean *               pbScaleCompositeOffset,   /* Do we scale the composite offset, Apple/MS   */
	boolean *               pbWeHaveInstructions, /* Composite has instructions         */
	uint16 *                pusComponentGlyphIndex, /* Glyph index of component         */
	int16 *                 psXOffset,        /* X Offset of component (if app)      */
	int16 *                 psYOffset,        /* Y Offset of component (if app)      */
	uint16 *                pusAnchorPoint1,  /* Anchor point 1 of component (if app) */
	uint16 *                pusAnchorPoint2,  /* Anchor point 2 of component (if app) */
	transMatrix             *pMulT,           /* Transformation matrix for component */
	boolean *				pbWeHaveAScale,     /* We have a scaling in pMulT					*/
	boolean *               pbLastComponent)   /* Is this the last component?                  */

{
	int16 *     psCurrentLocation;
	uint16      usComponentFlags;
	char *      byteP;

	Fixed       fMultiplier;


	psCurrentLocation = (int16 *)hGlyph->pvGlyphNextAddress;

	/* Initialize values */

	/* Initialize transformation matrix to identity */

	*pMulT = IdentTransform;

	*psXOffset = 0;
	*psYOffset = 0;
	*pusAnchorPoint1 = 0;
	*pusAnchorPoint2 = 0;
	*pbWeHaveAScale = FALSE;

	usComponentFlags = (uint16)SWAPWINC(psCurrentLocation);

	*pbWeHaveInstructions = ((usComponentFlags & WE_HAVE_INSTRUCTIONS) == WE_HAVE_INSTRUCTIONS);
	*pbUseMyMetrics =    ((usComponentFlags & USE_MY_METRICS) == USE_MY_METRICS);
	*pbRoundXYToGrid =      ((usComponentFlags & ROUND_XY_TO_GRID) == ROUND_XY_TO_GRID);

	/* new flags that indicate if the glyph was designed to have the component offset scaled or not
	   Apple does scale the component offset, MS doesn't, those flags are supposed to be clear on old fonts
	   on new fonts, only one of these flags must be set,
	   default is set to false, MS behavior */
	if ((usComponentFlags & SCALED_COMPONENT_OFFSET) == SCALED_COMPONENT_OFFSET)
	{
		*pbScaleCompositeOffset = TRUE;
	}
	if ((usComponentFlags & UNSCALED_COMPONENT_OFFSET) == UNSCALED_COMPONENT_OFFSET)
	{
		*pbScaleCompositeOffset = FALSE;
	}

	*pusComponentGlyphIndex = (uint16)SWAPWINC(psCurrentLocation);

	if (usComponentFlags & ARGS_ARE_XY_VALUES)
	{
		*pMultiplexingIndicator = OffsetPoints;
	}
	else
	{
		*pMultiplexingIndicator = AnchorPoints;
	}


	/*
		!!!APPLEBUG The rasterizer did not handle Word Anchor Points. This
		!!!APPLEBUG has been corrected in our version of the rasterizer, but
		!!!APPLEBUG we need to verify with the Apple source code.  --GregH
	 */

	if (usComponentFlags & ARG_1_AND_2_ARE_WORDS)
	{
		if (usComponentFlags & ARGS_ARE_XY_VALUES)
		{
			*psXOffset    = SWAPWINC (psCurrentLocation);
			*psYOffset    = SWAPWINC (psCurrentLocation);
		}
		else
		{
			*pusAnchorPoint1 = (uint16) SWAPWINC (psCurrentLocation);
			*pusAnchorPoint2 = (uint16) SWAPWINC (psCurrentLocation);
		}
	}
	else
	{
		byteP = (char *)psCurrentLocation;
		if (usComponentFlags & ARGS_ARE_XY_VALUES)
		{
		/* offsets are signed */
			*psXOffset = (int16)(int8)*byteP++;
			*psYOffset = (int16)(int8)*byteP;
		}
		else
		{
		/* anchor points are unsigned */
			*pusAnchorPoint1 = (uint16)(uint8) * byteP++;
			*pusAnchorPoint2 = (uint16)(uint8) * byteP;
		}
		++psCurrentLocation;
	}


	if (usComponentFlags & (WE_HAVE_A_SCALE | WE_HAVE_AN_X_AND_Y_SCALE | WE_HAVE_A_TWO_BY_TWO))
	{

		*pbWeHaveAScale = TRUE;

		if (usComponentFlags & WE_HAVE_A_TWO_BY_TWO)
		{
			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[0][0] = (fMultiplier << 2); /* turn into 16.16 */

			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[0][1] = (fMultiplier << 2); /* turn into 16.16 */

			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[1][0] = (fMultiplier << 2); /* turn into 16.16 */

			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[1][1] = (fMultiplier << 2); /* turn into 16.16 */

		}
		else
		{
			/* If we have a scale factor, build it into the transformation matrix   */

			pMulT->transform[0][1] = 0;
			pMulT->transform[1][0] = 0;

			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[0][0] = (fMultiplier <<= 2); /* turn into 16.16 */

			if (usComponentFlags & WE_HAVE_AN_X_AND_Y_SCALE)
			{
				fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
				pMulT->transform[1][1] = (fMultiplier <<= 2); /* turn into 16.16 */
			}
			else
			{
				pMulT->transform[1][1] = pMulT->transform[0][0];
			}
		}
	}
	*pbLastComponent = !((usComponentFlags & MORE_COMPONENTS) == MORE_COMPONENTS);

	hGlyph->pvGlyphNextAddress = (voidPtr)psCurrentLocation;

	if (hGlyph->pvGlyphNextAddress > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}
	return NO_ERR;
}

/***************************** Public  Function ****************************\
*
* sfac_ReadCompositeInstructions
*
*   This routine returns the instructions for the composite
*
* Effects:
*   none
*
* Error Returns:
*   none
*
* History:
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadCompositeInstructions(
	sfac_GHandle * hGlyph,
	uint8 **    pbyInstructions,     /* Pointer to start of glyph instructions */
	uint16 *    pusSizeOfInstructions) /* Size of instructions in bytes           */
{
	int16 *    psCurrentLocation;

	psCurrentLocation = (int16 *)hGlyph->pvGlyphNextAddress;

	*pusSizeOfInstructions = (uint16)SWAPWINC (psCurrentLocation);
	*pbyInstructions = (uint8 *)psCurrentLocation;
	hGlyph->pvGlyphNextAddress = (voidPtr)(*pbyInstructions + *pusSizeOfInstructions);

	if (hGlyph->pvGlyphNextAddress > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}

	return NO_ERR;
}

/***************************** Public  Function ****************************\
*
* sfac_ReleaseGlyph
*
*   This routine releases the glyph handle for the font file
*
* Effects:
*   none
*
* Error Returns:
*   none
*
* History:
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReleaseGlyph(
	sfac_ClientRec *  ClientInfo,
	sfac_GHandle *    hGlyph)
{
	if(hGlyph->pvGlyphNextAddress)
	{
		RELEASESFNTFRAG(ClientInfo,(voidPtr)hGlyph->pvGlyphBaseAddress);

		hGlyph->pvGlyphNextAddress = NULL;
		hGlyph->pvGlyphBaseAddress = NULL;

	}

	return NO_ERR;
}

/***************************************************************************/

/*      Embedded Bitmap (sbit) Access Routines      */

/**********************************************************************/

/*  Local constants  */

#define     SBIT_BLOC_TABLE         1       /* which table are metrics in */
#define     SBIT_BDAT_TABLE         2

#define     SBIT_HORIZ_METRICS      1       /* which kind of metrics */
#define     SBIT_VERT_METRICS       2
#define     SBIT_BIG_METRICS        3

typedef enum {                              /* metrics type */
	flgHorizontal = 0x01,
	flgVertical = 0x02
} bitmapFlags;

FS_PRIVATE boolean FindBlocStrike (         /* helper function prototype */
	const uint8 *pbyBloc,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint16 usOverScale,            /* outline magnification requested */
	uint16 *pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint32 *pulStrikeOffset );

FS_PRIVATE boolean FindBscaStrike (         /* helper function prototype */
	const uint8 *pbyBsca,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint32 *pulStrikeOffset );

/*  byte size bitmap range masks */

static uint8    achStartMask[] = { 0xFF, 0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01 };
static uint8    achStopMask[] =  { 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF };
					
/**********************************************************************/

FS_PUBLIC ErrorCode sfac_SearchForStrike (
	sfac_ClientRec *pClientInfo,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint16 usOverScale,            /* outline magnification requested */
	uint16 *pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint16 *pusTableState,
	uint16 *pusSubPpemX,
	uint16 *pusSubPpemY,
	uint32 *pulStrikeOffset )
{
	const uint8 *   pbyBloc;
	const uint8 *   pbyBsca;
	ErrorCode       ReturnCode;
	
	*pusTableState = SBIT_NOT_FOUND;                /* defaults */
	*pulStrikeOffset = 0L;
	*pusSubPpemX = 0;
	*pusSubPpemY = 0;

	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                /* callback etc. */
		0L,                                         /* table start */
		ULONG_MAX,                                  /* read whole table */
		sfnt_BitmapLocation,                        /* registered tag */
		FALSE,                                      /* doesn't have to be there */
		(const void**)&pbyBloc );                   /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;
	
	if (pbyBloc != NULL)                            /* if bloc exists */
	{
		if (FindBlocStrike (pbyBloc, usPpemX, usPpemY, usOverScale, pusBitDepth, pulStrikeOffset))
		{
			*pusTableState = SBIT_BLOC_FOUND;       /* exact match */
		}
		else                                        /* if bloc and NO match */
		{
			ReturnCode = sfac_GetDataPtr (
				pClientInfo,                        /* callback etc. */
				0L,                                 /* table start */
				ULONG_MAX,                          /* read whole table */
				sfnt_BitmapScale,                   /* registered tag */
				FALSE,                              /* doesn't have to be there */
				(const void**)&pbyBsca );           /* data pointer */
			
			if (ReturnCode != NO_ERR) return ReturnCode;
			
			if (pbyBsca != NULL)                    /* if bsca exists */
			{
				if (FindBscaStrike (pbyBsca, usPpemX, usPpemY, pulStrikeOffset))
				{
					*pusSubPpemX = (uint16)pbyBsca[*pulStrikeOffset + SFNT_BSCA_SUBPPEMX];
					*pusSubPpemY = (uint16)pbyBsca[*pulStrikeOffset + SFNT_BSCA_SUBPPEMY];
					
					if (FindBlocStrike (pbyBloc, *pusSubPpemX, *pusSubPpemY, usOverScale, pusBitDepth, pulStrikeOffset))
					{
						*pusTableState = SBIT_BSCA_FOUND;
					}
				}
				RELEASESFNTFRAG(pClientInfo, pbyBsca );
			}
		}
		RELEASESFNTFRAG(pClientInfo, pbyBloc);
	}
	return NO_ERR;
}

/**********************************************************************/

/*  Find a strike that matches ppemX & Y in the bloc table */

FS_PRIVATE boolean FindBlocStrike (
	const uint8 *pbyBloc,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint16 usOverScale,            /* outline magnification requested */
	uint16 *pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint32 *pulStrikeOffset )
{
	uint32          ulNumStrikes;
	uint32          ulStrikeOffset;
	uint32          ulColorRefOffset;
	uint16			usPreferedBitDepth, usBestBitDepth, usCurrentBitDepth;
	uint16			usSbitBitDepthMask;
	
	ulNumStrikes = (uint32)SWAPL(*((uint32*)&pbyBloc[SFNT_BLOC_NUMSIZES]));
	ulStrikeOffset = SFNT_BLOC_FIRSTSTRIKE;

	usBestBitDepth = 0;
	
	if (usOverScale == 0)
	{
		usPreferedBitDepth = 1;
		usSbitBitDepthMask = SBIT_BITDEPTH_MASK & 0x0002; /* accept only black/white bitmap */
	} else 
	{
		if (usOverScale == 2)
		{
			usPreferedBitDepth = 2;
		} else if (usOverScale == 4) 
		{
			usPreferedBitDepth = 4;
		} else
		{
			usPreferedBitDepth = 8;
		}
		usSbitBitDepthMask = SBIT_BITDEPTH_MASK & ~0x0002; /* accept only grayscale bitmap */
	} 

	while (ulNumStrikes > 0)
	{
		if ((usPpemX == (uint16)pbyBloc[ulStrikeOffset + SFNT_BLOC_PPEMX]) &&
			(usPpemY == (uint16)pbyBloc[ulStrikeOffset + SFNT_BLOC_PPEMY]))
		{
			ulColorRefOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_COLORREF]));
			usCurrentBitDepth = pbyBloc[ulStrikeOffset + SFNT_BLOC_BITDEPTH];

			if (((0x01 << usCurrentBitDepth) & usSbitBitDepthMask) && (ulColorRefOffset == 0L))
			{
				if (usCurrentBitDepth == usPreferedBitDepth)
				{
					/* perfect match */
					*pulStrikeOffset = ulStrikeOffset;
					*pusBitDepth = usPreferedBitDepth;
					return TRUE;      
				} else if (usCurrentBitDepth > usPreferedBitDepth)
				{
					/* above is better than below */
					if ((usCurrentBitDepth < usBestBitDepth) || (usBestBitDepth < usPreferedBitDepth))
					{
						/* above and closer */
						*pulStrikeOffset = ulStrikeOffset;
						usBestBitDepth = usCurrentBitDepth;
					}
				} else /* if (usCurrentBitDepth < usPreferedBitDepth) */
				{
					/* we look below the prefered only if we don't have found anything above */
					if ((usBestBitDepth < usPreferedBitDepth) && (usCurrentBitDepth > usBestBitDepth))
					{
						/* below and closer */
						*pulStrikeOffset = ulStrikeOffset;
						usBestBitDepth = usCurrentBitDepth;
					}
				}
			}
		}
		ulNumStrikes--;
		ulStrikeOffset += SIZEOF_BLOC_SIZESUBTABLE;
	}

	if (usBestBitDepth != 0)
	{
		*pusBitDepth = usBestBitDepth;
		return TRUE;                                   /* best match found */
	} 

	return FALSE;                                   /* match not found */
}

/**********************************************************************/

/*  Find a strike that matches ppemX & Y in the bsca table */

FS_PRIVATE boolean FindBscaStrike (
	const uint8 *pbyBsca,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint32 *pulStrikeOffset )
{
	uint32          ulNumStrikes;
	uint32          ulStrikeOffset;
	
	ulNumStrikes = (uint32)SWAPL(*((uint32*)&pbyBsca[SFNT_BSCA_NUMSIZES]));
	ulStrikeOffset = SFNT_BSCA_FIRSTSTRIKE;
								
	while (ulNumStrikes > 0)
	{
		if ((usPpemX == (uint16)pbyBsca[ulStrikeOffset + SFNT_BSCA_PPEMX]) &&
			(usPpemY == (uint16)pbyBsca[ulStrikeOffset + SFNT_BSCA_PPEMY]))
		{
			*pulStrikeOffset = ulStrikeOffset;
			return TRUE;                            /* match found */
		}
		ulNumStrikes--;
		ulStrikeOffset += SIZEOF_BSCA_SIZESUBTABLE;
	}
	return FALSE;                                   /* match not found */
}

/**********************************************************************/

/*  Look for a glyph in a given strike */        

FS_PUBLIC ErrorCode sfac_SearchForBitmap (
	sfac_ClientRec *pClientInfo,
	uint16 usGlyphCode,
	uint32 ulStrikeOffset,
	boolean *pbGlyphFound,                   /* return values */
	uint16 *pusMetricsType,
	uint16 *pusMetricsTable,
	uint32 *pulMetricsOffset,
	uint16 *pusBitmapFormat,
	uint32 *pulBitmapOffset,
	uint32 *pulBitmapLength )
{
	const uint8 *   pbyBloc;
	ErrorCode       ReturnCode;

	uint32      ulNumIndexTables;
	uint32      ulIndexArrayTop;
	uint32      ulIndexArrayOffset;
	uint32      ulSubTableOffset;
	uint32      ulGlyphOffset;
	uint32      ulNextGlyphOffset;
	uint32      ulBitmapLength;
	uint32      ulImageDataOffset;
	uint32      ulNumGlyphs;
	uint32      ulTop;                      /* binary search ranges */
	uint32      ulBottom;
	uint32      ulHit;
	uint32      ulHitOffset;

	uint16      usStartGlyph;               /* for whole strike */
	uint16      usEndGlyph;
	uint16      usFirstGlyph;               /* for one sub table */
	uint16      usLastGlyph;
	uint16      usIndexFormat;
	uint16      usImageFormat;
	uint16      usHitCode;
	
	bitmapFlags bmfDirection;               /* horiz or vert */

	
	*pbGlyphFound = FALSE;                              /* default */

	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                    /* callback etc. */
		0L,                                             /* table start */
		ULONG_MAX,                                      /* read whole table */
		sfnt_BitmapLocation,                            /* registered tag */
		TRUE,                                           /* better be there now */
		(const void**)&pbyBloc );                       /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;
		
	usStartGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_STARTGLYPH]));
	usEndGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_ENDGLYPH]));

	if ((usStartGlyph > usGlyphCode) || (usEndGlyph < usGlyphCode))
	{
		RELEASESFNTFRAG(pClientInfo, pbyBloc);
		return NO_ERR;                                  /* glyph out of range */
	}

	ulNumIndexTables = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_NUMINDEXTABLES]));
	ulIndexArrayTop = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_INDEXARRAYOFFSET]));
	ulIndexArrayOffset = ulIndexArrayTop;

	while ((ulNumIndexTables > 0) && (*pbGlyphFound == FALSE))
	{
		usFirstGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_FIRSTGLYPH]));
		usLastGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_LASTGLYPH]));
	
		if ((usFirstGlyph <= usGlyphCode) && (usLastGlyph >= usGlyphCode))
		{
			ulSubTableOffset = ulIndexArrayTop +
				(uint32)SWAPL(*((uint32*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_ADDITIONALOFFSET]));
			
			usIndexFormat = (uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_INDEXFORMAT]));
			usImageFormat = (uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IMAGEFORMAT]));
			ulImageDataOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IMAGEOFFSET]));

/* decode the individual index subtable formats */            

			switch(usIndexFormat)                       /* different search req's */
			{
			case 1:
				ulSubTableOffset += SFNT_BLOC_OFFSETARRAY + sizeof(uint32) * (uint32)(usGlyphCode - usFirstGlyph);
				ulGlyphOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset]));
				
				ulSubTableOffset += sizeof(uint32);
				ulNextGlyphOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset]));
				ulBitmapLength = ulNextGlyphOffset - ulGlyphOffset;

				if (ulBitmapLength == 0)
				{
					RELEASESFNTFRAG(pClientInfo, pbyBloc);
					return NO_ERR;                      /* no bitmap data stored */
				}
				ulImageDataOffset += ulGlyphOffset;
				*pulMetricsOffset = ulImageDataOffset;
				*pusMetricsTable = SBIT_BDAT_TABLE;
				break;
			
			case 2:
				ulBitmapLength = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX2IMAGESIZE]));
				ulImageDataOffset += ulBitmapLength * (usGlyphCode - usFirstGlyph);
				*pulBitmapOffset = ulImageDataOffset;
				
				*pulMetricsOffset = ulSubTableOffset + SFNT_BLOC_IDX2METRICS;
				*pusMetricsTable = SBIT_BLOC_TABLE;
				*pusMetricsType = SBIT_BIG_METRICS;
				break;
			
			case 3:
				ulSubTableOffset += SFNT_BLOC_OFFSETARRAY + sizeof(uint16) * (uint32)(usGlyphCode - usFirstGlyph);
				ulGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset]));
				
				ulSubTableOffset += sizeof(uint16);
				ulNextGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset]));
				ulBitmapLength = ulNextGlyphOffset - ulGlyphOffset;

				if (ulBitmapLength == 0)
				{
					RELEASESFNTFRAG(pClientInfo, pbyBloc);
					return NO_ERR;                      /* no bitmap data stored */
				}
				ulImageDataOffset += ulGlyphOffset;
				*pulMetricsOffset = ulImageDataOffset;
				*pusMetricsTable = SBIT_BDAT_TABLE;
				break;
			
			case 4:
				ulNumGlyphs = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX4NUMGLYPHS]));
				ulTop = 0L;
				ulBottom = ulNumGlyphs - 1L;
				ulSubTableOffset += SFNT_BLOC_IDX4OFFSETARRAY;  /* array base */

				ulHit = ulTop;
				ulHitOffset = ulSubTableOffset;
				usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
				if (usHitCode != usGlyphCode)
				{
					ulHit = ulBottom;
					ulHitOffset = ulSubTableOffset + (ulHit * SIZEOF_CODEOFFSETPAIR);
					usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
					while (usHitCode != usGlyphCode)
					{
						if (usHitCode < usGlyphCode)    /* binary search for glyph code */
						{
							ulTop = ulHit;
						}
						else
						{
							ulBottom = ulHit;
						}
						
						if ((ulBottom - ulTop) < 2L)
						{
							RELEASESFNTFRAG(pClientInfo, pbyBloc);
							return NO_ERR;              /* glyph not found */
						}
						
						ulHit = (ulTop + ulBottom) >> 1L;
						ulHitOffset = ulSubTableOffset + (ulHit * SIZEOF_CODEOFFSETPAIR);
						usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
					}
				}
				ulGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4OFFSET]));
				ulNextGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SIZEOF_CODEOFFSETPAIR + SFNT_BLOC_IDX4OFFSET]));
				ulBitmapLength = ulNextGlyphOffset - ulGlyphOffset;
				
				ulImageDataOffset += ulGlyphOffset;
				*pulMetricsOffset = ulImageDataOffset;
				*pusMetricsTable = SBIT_BDAT_TABLE;
				break;
			
			case 5:
				ulBitmapLength = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX5IMAGESIZE]));
				
				*pulMetricsOffset = ulSubTableOffset + SFNT_BLOC_IDX5METRICS;
				*pusMetricsTable = SBIT_BLOC_TABLE;
				*pusMetricsType = SBIT_BIG_METRICS;
				
				ulNumGlyphs = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX5NUMGLYPHS]));
				ulTop = 0L;
				ulBottom = ulNumGlyphs - 1L;
				ulSubTableOffset += SFNT_BLOC_IDX5CODEARRAY;  /* array base */

				ulHit = ulTop;
				ulHitOffset = ulSubTableOffset;
				usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset]));
				if (usHitCode != usGlyphCode)
				{
					ulHit = ulBottom;
					ulHitOffset = ulSubTableOffset + (ulHit * sizeof(uint16));
					usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
					while (usHitCode != usGlyphCode)
					{
						if (usHitCode < usGlyphCode)    /* binary search for glyph code */
						{
							ulTop = ulHit;
						}
						else
						{
							ulBottom = ulHit;
						}
						
						if ((ulBottom - ulTop) < 2L)
						{
							RELEASESFNTFRAG(pClientInfo, pbyBloc);
							return NO_ERR;              /* glyph not found */
						}
						
						ulHit = (ulTop + ulBottom) >> 1L;
						ulHitOffset = ulSubTableOffset + (ulHit * sizeof(uint16));
						usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset]));
					}
				}
				ulImageDataOffset += ulBitmapLength * ulHit;
				*pulBitmapOffset = ulImageDataOffset;
				break;
			
			
			default:
				
				RELEASESFNTFRAG(pClientInfo, pbyBloc);
				return NO_ERR;                          /* unknown format */
			}

/* use the glyph formats to calculate metrics type & data offsets */
				
			*pulBitmapLength = ulBitmapLength;
			*pusBitmapFormat = usImageFormat;           /* save for bitmap decoding */
			bmfDirection = (bitmapFlags)pbyBloc[ulStrikeOffset + SFNT_BLOC_FLAGS];

			switch(usImageFormat)                       /* different metrics sizes */
			{
			case 1:                                     /* small glyph metrics */
			case 2:
				if (bmfDirection == flgHorizontal)
				{
					*pusMetricsType = SBIT_HORIZ_METRICS;
				}
				else
				{
					Assert(bmfDirection == flgVertical);

					*pusMetricsType = SBIT_VERT_METRICS;
				}
				*pulBitmapOffset = ulImageDataOffset + SIZEOF_SBIT_SMALLMETRICS;
				*pbGlyphFound = TRUE;
				break;
			
			case 3:
				break;
			
			case 4:
				break;
			
			case 5:             /* bitmap offset and metrics type set above */
				*pbGlyphFound = TRUE;
				break;
			
			case 6:
			case 7:
			case 9:
				*pusMetricsType = SBIT_BIG_METRICS;
				*pulBitmapOffset = ulImageDataOffset + SIZEOF_SBIT_BIGMETRICS;
				*pbGlyphFound = TRUE;
				break;
			
			case 8:
				if (bmfDirection == flgHorizontal)
				{
					*pusMetricsType = SBIT_HORIZ_METRICS;
				}
				else
				{
					Assert(bmfDirection == flgVertical);

					*pusMetricsType = SBIT_VERT_METRICS;
				}
				*pulBitmapOffset = ulImageDataOffset + SIZEOF_SBIT_SMALLMETRICS + SIZEOF_SBIT_GLYPH8PAD;
				*pbGlyphFound = TRUE;
				break;

			default:
				break;
			}
		}
		ulNumIndexTables--;    
		ulIndexArrayOffset += SIZEOF_BLOC_INDEXARRAY;
	}
	
	RELEASESFNTFRAG(pClientInfo, pbyBloc);
	return NO_ERR;
}


/**********************************************************************/

/* fetch the horizontal metrics */

FS_PUBLIC ErrorCode sfac_GetSbitMetrics (
	sfac_ClientRec *pClientInfo,
	uint16 usMetricsType,
	uint16 usMetricsTable,
	uint32 ulMetricsOffset,
	uint16 *pusHeight,
	uint16 *pusWidth,
	int16 *psLSBearingX,
	int16 *psLSBearingY,
	int16 *psTopSBearingX, /* NEW */
	int16 *psTopSBearingY, /* NEW */
	uint16 *pusAdvanceWidth,
	uint16 *pusAdvanceHeight,  /* NEW */
   	boolean *pbHorMetricsFound, /* NEW */
   	boolean *pbVertMetricsFound ) /* NEW */
{
	const uint8     *pbyTable;
	uint32          ulTableLength;
	sfnt_tableIndex TableIndex;
	ErrorCode       ReturnCode;

	*pbHorMetricsFound = FALSE;                        /* default */
	*pbVertMetricsFound = FALSE;                        /* default */

	if (usMetricsTable == SBIT_BDAT_TABLE)          /* if metrics in bdat */
	{
		TableIndex = sfnt_BitmapData;
	}
	else                                            /* if metrics in bloc */
	{
		TableIndex = sfnt_BitmapLocation;
	}
	if (usMetricsType == SBIT_BIG_METRICS)          /* if both h & v metrics */
	{
		ulTableLength = SIZEOF_SBIT_BIGMETRICS;
	}
	else                                            /* if only h or v metrics */
	{
		ulTableLength = SIZEOF_SBIT_SMALLMETRICS;
	}

	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                /* callback etc. */
		ulMetricsOffset,                            /* metrics start */
		ulTableLength,                              /* read just metrics */
		TableIndex,                                 /* registered tag */
		TRUE,                                       /* should be there */
		(const void**)&pbyTable );                  /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;

/*  for horizontal metrics, offsets could be different for big & small */

	*pusHeight = (uint16)pbyTable[SFNT_SBIT_HEIGHT];
	*pusWidth = (uint16)pbyTable[SFNT_SBIT_WIDTH];

	if (usMetricsType == SBIT_BIG_METRICS)          /* if both h & v metrics */
	{
    	*psLSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGX]));
    	*psLSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGY]));
    	*pusAdvanceWidth = (uint16)pbyTable[SFNT_SBIT_ADVANCE];
    	*psTopSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_VERTBEARINGX]));
    	*psTopSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_VERTBEARINGY]));
    	*pusAdvanceHeight = (uint16)pbyTable[SFNT_SBIT_VERTADVANCE];
		*pbHorMetricsFound = TRUE;                        
		*pbVertMetricsFound = TRUE;                     
	}
	else if (usMetricsType == SBIT_HORIZ_METRICS)   
	{
    	*psLSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGX]));
    	*psLSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGY]));
    	*pusAdvanceWidth = (uint16)pbyTable[SFNT_SBIT_ADVANCE];
		*pbHorMetricsFound = TRUE;                        
	}
	else /* if (usMetricsType == SBIT_VERT_METRICS) */  
	{
    	*psTopSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGX]));
    	*psTopSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGY]));
    	*pusAdvanceHeight = (uint16)pbyTable[SFNT_SBIT_ADVANCE];
		*pbVertMetricsFound = TRUE;                     
	}

	RELEASESFNTFRAG(pClientInfo, pbyTable);

	return NO_ERR;
}

/**********************************************************************/

/* shave the white space from horizontal metrics for bitmap format 5 */

#define     ROWSIZE     16                      /* 16 bytes = 128 bits max */

FS_PUBLIC ErrorCode sfac_ShaveSbitMetrics (
	sfac_ClientRec *pClientInfo,
	uint16 usBitmapFormat,
	uint32 ulBitmapOffset,
    uint32 ulBitmapLength,
	uint16 usBitDepth,
	uint16 *pusHeight,
	uint16 *pusWidth,
    uint16 *pusShaveLeft,
    uint16 *pusShaveRight,
    uint16 *pusShaveTop,  /* NEW */
    uint16 *pusShaveBottom,  /* NEW */
	int16 *psLSBearingX,
	int16 *psLSBearingY, /* NEW */
	int16 *psTopSBearingX, /* NEW */
	int16 *psTopSBearingY) /* NEW */
{
    uint8           abyBitRow[ROWSIZE];         /* or bitmap into one row */
	const uint8     *pbyTable;
	const uint8     *pbyBdat;
    uint8           *pbyBitMap;
    uint8           byMask;
    uint8           byUpMask;
    uint8           byLowMask;
	uint16          usBitData;
	uint16          usFreshBits;
	uint16       	usOutBits;
	uint16       	usRow;
	uint16       	usStopBit;
    uint16          usShaveLeft;
    uint16          usShaveRight;
    uint16          usShaveTop;
    uint16          usShaveBottom;
	uint16          usStart;
	ErrorCode       ReturnCode;
	boolean			bWeGotBlackPixels;				/* used in vertical shaving */
	uint8			byBlackPixelsInCurrentRaw;		/* used in vertical shaving */
	uint8			byTempBuffer;		/* temporary buffer used to detect the first/last row containing black pixels */

    *pusShaveLeft = 0;                          /* defaults */
    *pusShaveRight = 0;
    *pusShaveTop = 0;                          /* defaults */
    *pusShaveBottom = 0;

    if (usBitmapFormat != 5)                    /* if not constant metrics data */
    {
        return NO_ERR;
    }

    if ((*pusWidth * usBitDepth) > (ROWSIZE << 3))
    {
    	return NO_ERR;                          /* punt huge bitmaps */
    }
    
    MEMSET(abyBitRow, 0, ROWSIZE);              /* clear to zeros */

/*      read the bitmap data    */
    if  ((ulBitmapLength == 0) || (*pusWidth == 0) || (*pusHeight == 0))
    {
        return NO_ERR; 
    }

	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                            /* callback etc. */
		ulBitmapOffset,                         /* metrics start */
		ulBitmapLength,                         /* read bitmap data */
		sfnt_BitmapData,                        /* registered tag */
		TRUE,                                   /* should be there */
		(const void**)&pbyTable );              /* data pointer */

	if (ReturnCode != NO_ERR) return ReturnCode;

	pbyBdat = pbyTable;
	usBitData = 0;                              /* up to 16 bits of bdat */
	usFreshBits = 0;                            /* read & unwritten */

	bWeGotBlackPixels = FALSE;					/* used for vertical shaving */
	usShaveTop = 0;
	usShaveBottom = 0;


/*      'or' the bitmap data into a single row    */    
	usRow = *pusHeight;

    while (usRow > 0)
	{
		pbyBitMap = abyBitRow;
		usOutBits = *pusWidth * usBitDepth;
		usStopBit = 8;
		byBlackPixelsInCurrentRaw = 0;

		while (usOutBits > 0)                   /* if more to do */
		{
			if (usFreshBits < 8)                /* if room for fresh data */
			{
				usBitData <<= 8;
                if (ulBitmapLength > 0)         /* prevent read past data end */
                {
                    usBitData |= (uint16)*pbyBdat++;
                    ulBitmapLength--;
                }
				usFreshBits += 8;
			}
			
			if (usStopBit > usOutBits)
			{
				usStopBit = usOutBits;
			}
			byMask = achStopMask[usStopBit];
			
			byTempBuffer = (uint8)((usBitData >> (usFreshBits - 8)) & byMask);

			byBlackPixelsInCurrentRaw |= byTempBuffer;

			*pbyBitMap++ |= byTempBuffer;

			usFreshBits -= usStopBit;
			usOutBits -= usStopBit;
		}
		if (byBlackPixelsInCurrentRaw != 0)
		{
			bWeGotBlackPixels = TRUE;
			usShaveBottom = usRow-1;
		}
		if (!bWeGotBlackPixels) usShaveTop ++;
        usRow--;
	}

	if (usShaveTop == *pusHeight)
	{
		/* the bitmap is completely white */
		usShaveTop = 0;
		usShaveBottom = 0;
	}

	RELEASESFNTFRAG(pClientInfo, pbyTable);

/*      calculate white space on the left    */
    
    pbyBitMap = abyBitRow;
	if (usBitDepth == 1)
	{
		byUpMask = 0x80;
		byLowMask = 0x01;
	} else if (usBitDepth == 2)
	{
		byUpMask = 0xC0;
		byLowMask = 0x03;
	} else if (usBitDepth == 4)
	{
		byUpMask = 0xF0;
		byLowMask = 0x0F;
	} else /* usBitDepth == 8 */
	{
		byUpMask = 0xFF;
		byLowMask = 0xFF;
	}
	byMask = byUpMask;
    usShaveLeft = 0;

    while ((*pbyBitMap & byMask) == 0)
    {
        usShaveLeft++;
        if (usShaveLeft == *pusWidth)
        {
            return NO_ERR;          /* no black found, don't shave */
        }
        byMask >>= usBitDepth;
        if (byMask == 0)
        {
            byMask = byUpMask;
            pbyBitMap++;
        }
    }

/*      calculate white space on the right    */
    
    usStart = (*pusWidth - 1) * usBitDepth;
    pbyBitMap = &abyBitRow[usStart >> 3];
    byMask = byUpMask >> (usStart & 0x0007);
    usShaveRight = 0;
    
    while ((*pbyBitMap & byMask) == 0)
    {
        usShaveRight++;
        if (byMask == byUpMask)
        {
            byMask = byLowMask;
            pbyBitMap--;
        }
        else
        {
            byMask <<= usBitDepth;
        }
    }

/*      correct the width and sidebearing    */

    *pusShaveLeft = usShaveLeft;
    *pusShaveRight = usShaveRight;
    *pusWidth -= usShaveLeft + usShaveRight;
    *psLSBearingX += (int16)usShaveLeft;
    *psTopSBearingX += (int16)usShaveLeft;

	*pusShaveTop = usShaveTop;
    *pusShaveBottom = usShaveBottom;
    *pusHeight -= usShaveTop + usShaveBottom;
    *psLSBearingY -= (int16)usShaveTop;
    *psTopSBearingY -= (int16)usShaveTop;

	return NO_ERR;
}


/**********************************************************************/


/* fetch the bitmap */

/*  Currently supporting the following bdat formats:
	
	1 - Small metrics;  Byte aligned data
	2 - Small metrics;  Bit aligned data
	5 - Const metrics;  Bit aligned data
	6 - Big metrics;    Byte aligned data
	7 - Big metrics;    Bit aligned data
	8 - Small metrics;  Composite data
	9 - Big metrics;    Composite data
*/

FS_PUBLIC ErrorCode sfac_GetSbitBitmap (
	sfac_ClientRec *pClientInfo,
	uint16 usBitmapFormat,
	uint32 ulBitmapOffset,
	uint32 ulBitmapLength,
	uint16 usHeight,
	uint16 usWidth,
    uint16 usShaveLeft,                             /* for white space in fmt 5 */
    uint16 usShaveRight,
    uint16 usShaveTop, /* NEW */
    uint16 usShaveBottom,  /* NEW */
	uint16 usXOffset,
	uint16 usYOffset,
	uint16 usDstRowBytes,
	uint16 usBitDepth,
	uint8 *pbyBitMap, 
	uint16 *pusCompCount )
{
	const uint8     *pbyTable;
	const uint8     *pbyBdat;
	uint8           *pbyBitRow;                     /* start of bitmap row */

	uint16          usSrcRowBytes;                  /* bytes per row in bdat */
	ErrorCode       ReturnCode;

	uint16          usBitData;                      /* bdat data read into 16 bits */
	uint16          usOutBits;                      /* num of bits to put to bitmap */
	uint16          usCount;
	uint16          usXOffBytes;
	uint16          usXOffBits;
	uint16          usStartBit;
	uint16          usStopBit;
	int16           sFreshBits;                     /* num of bits read not written */
	uint8           byMask;                         /* for partial bytes */
	
	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                /* callback etc. */
		ulBitmapOffset,                             /* metrics start */
		ulBitmapLength,                             /* read bitmap data */
		sfnt_BitmapData,                            /* registered tag */
		TRUE,                                       /* should be there */
		(const void**)&pbyTable );                  /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;

	pbyBdat = pbyTable;
	*pusCompCount = 0;                              /* usual case */
	
	pbyBitRow = pbyBitMap + (usDstRowBytes * usYOffset);
	usXOffBytes = (usXOffset * usBitDepth) >> 3;
	usXOffBits = (usXOffset * usBitDepth) & 0x07;

	switch(usBitmapFormat)
	{
	case 1:                                         /* byte aligned */
	case 6:
		
		usSrcRowBytes = ((usWidth * usBitDepth) + 7) / 8;

		if (usXOffBits == 0)                         /* if byte aligned */
		{
			while (usHeight > 0)
			{
				pbyBitMap = pbyBitRow + usXOffBytes;    /* adjust left */

				for (usCount = 0; usCount < usSrcRowBytes; usCount++)
				{
					*pbyBitMap++ |= *pbyBdat++;
				}
				pbyBitRow += usDstRowBytes;
				usHeight--;
			}
		}
		else                                        /* if offset in x */
		{
			while (usHeight > 0)
			{
				pbyBitMap = pbyBitRow + usXOffBytes;    /* adjust left */
				usBitData = 0;

				for (usCount = 0; usCount < usSrcRowBytes; usCount++)
				{
					usBitData |= (uint16)*pbyBdat++;
					*pbyBitMap++ |= (usBitData >> usXOffBits) & 0x00FF;
					usBitData <<= 8;
				}
				*pbyBitMap |= (usBitData >> usXOffBits) & 0x00FF;
							 
				pbyBitRow += usDstRowBytes;
				usHeight--;
			}
		}
		break;
	
	case 2:                                         /* bit aligned data */
	case 5:
	case 7:
		
		usBitData = 0;                              /* up to 16 bits of bdat */
		sFreshBits = 0;                             /* read & unwritten */
	
		usHeight += usShaveTop;

		while (usHeight > 0)                        /* for each row */
		{
			pbyBitMap = pbyBitRow + usXOffBytes;    /* adjust left */
			usOutBits = usWidth * usBitDepth;
			usStartBit = usXOffBits;
			usStopBit = 8;
			sFreshBits -= (int16)usShaveLeft * usBitDepth;       /* skip the left white bits */

			while (usOutBits > 0)                   /* if more to do */
			{
				while (sFreshBits < 8)              /* if room for fresh data */
				{
					usBitData <<= 8;
					if (ulBitmapLength > 0)         /* prevent read past data end */
					{
						usBitData |= (uint16)*pbyBdat++;
						ulBitmapLength--;
					}
					sFreshBits += 8;
				}
				
				if (usStopBit > usOutBits + usStartBit)
				{
					usStopBit = usStartBit + usOutBits;
				}
				byMask = achStartMask[usStartBit] & achStopMask[usStopBit];
				
				*pbyBitMap++ |= (uint8)((usBitData >> (sFreshBits + (int16)usStartBit - 8)) & byMask);

				sFreshBits -= (int16)(usStopBit - usStartBit);
				usOutBits -= usStopBit - usStartBit;
				usStartBit = 0;
			}
			sFreshBits -= (int16)usShaveRight*usBitDepth;      /* skip the right white bits */

			if (usShaveTop == 0)
			{
				pbyBitRow += usDstRowBytes;             /* next row */
			} else {
				usShaveTop --;
			}
			usHeight--;
		}
		break;
	
	case 3:                                         /* various */
	case 4:
		break;
	
	case 8:                                         /* composites */
	case 9:                                         /* just return count */
		
		*pusCompCount = (uint16)SWAPW(*((uint16*)&pbyBdat[SFNT_BDAT_COMPCOUNT]));
		break;
	
	default:
		Assert(FALSE);
		break;
	}

	RELEASESFNTFRAG(pClientInfo, pbyTable);
	return NO_ERR;
}

/**********************************************************************/

FS_PUBLIC ErrorCode sfac_GetSbitComponentInfo (
	sfac_ClientRec *pClientInfo,
	uint16 usComponent,
	uint32 ulBitmapOffset,
	uint32 ulBitmapLength,
	uint16 *pusCompGlyphCode,
	uint16 *pusCompXOffset,
	uint16 *pusCompYOffset
)
{
	const uint8 *   pbyBdat;
	ErrorCode       ReturnCode;

	
	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                /* callback etc. */
		ulBitmapOffset,                             /* metrics start */
		ulBitmapLength,                             /* read bitmap data */
		sfnt_BitmapData,                            /* registered tag */
		TRUE,                                       /* should be there */
		(const void**)&pbyBdat );                   /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;

	pbyBdat += SFNT_BDAT_FIRSTCOMP + (SIZEOF_SBIT_BDATCOMPONENT * usComponent);
		
	*pusCompGlyphCode = (uint16)SWAPW(*((uint16*)&pbyBdat[SFNT_BDAT_COMPGLYPH]));
	*pusCompXOffset = (uint16)pbyBdat[SFNT_BDAT_COMPXOFF];
	*pusCompYOffset = (uint16)pbyBdat[SFNT_BDAT_COMPYOFF];

	RELEASESFNTFRAG(pClientInfo, pbyBdat);

	return NO_ERR;
}

/**********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\sfntoff.h ===
#define BIGDATE_BC      0
#define BIGDATE_AD      4
#define SIZEOF_BIGDATE  8

#define BBOX_XMIN   0
#define BBOX_YMIN   2
#define BBOX_XMAX   4
#define BBOX_YMAX   6
#define SIZEOF_BBOX 8

#define SFNT_DIRECTORYENTRY_TAG         0
#define SFNT_DIRECTORYENTRY_CHECKSUM    4
#define SFNT_DIRECTORYENTRY_TABLEOFFSET 8
#define SFNT_DIRECTORYENTRY_TABLELENGTH 12
#define SIZEOF_SFNT_DIRECTORYENTRY      16

#define SFNT_OFFSETTABLE_VERSION        0
#define SFNT_OFFSETTABLE_NUMOFFSETS     4
#define SFNT_OFFSETTABLE_SEARCHRANGE    6
#define SFNT_OFFSETTABLE_ENTRYSELECTOR  8
#define SFNT_OFFSETTABLE_RANGESHIFT     10
#define SFNT_OFFSETTABLE_TABLE          12
#define SIZEOF_SFNT_OFFSETTABLE         12

#define SFNT_FONTHEADER_VERSION             0
#define SFNT_FONTHEADER_FONTREVISION        4
#define SFNT_FONTHEADER_CHECKSUMADJUSTMENT  8
#define SFNT_FONTHEADER_MAGICNUMBER         12
#define SFNT_FONTHEADER_FLAGS               16
#define SFNT_FONTHEADER_UNITSPEREM          18
#define SFNT_FONTHEADER_CREATED             20
#define SFNT_FONTHEADER_MODIFIED            28
#define SFNT_FONTHEADER_XMIN                36
#define SFNT_FONTHEADER_YMIN                38
#define SFNT_FONTHEADER_XMAX                40
#define SFNT_FONTHEADER_YMAX                42
#define SFNT_FONTHEADER_MACSTYLE            44
#define SFNT_FONTHEADER_LOWESTRECPPEM       46
#define SFNT_FONTHEADER_FONTDIRECTIONHINT   48
#define SFNT_FONTHEADER_INDEXTOLOCFORMAT    50
#define SFNT_FONTHEADER_GLYPHDATAFORMAT     52
#define SIZEOF_SFNT_FONTHEADER              54

#define SFNT_HORIZONTALHEADER_VERSION                           0
#define SFNT_HORIZONTALHEADER_YASCENDER                         4
#define SFNT_HORIZONTALHEADER_YDESCENDER                        6
#define SFNT_HORIZONTALHEADER_YLINEGAP                          8
#define SFNT_HORIZONTALHEADER_ADVANCEWIDTHMAX                   10
#define SFNT_HORIZONTALHEADER_MINLEFTSIDEBEARING                12
#define SFNT_HORIZONTALHEADER_MINRIGHTSIDEBEARING               14
#define SFNT_HORIZONTALHEADER_XMAXEXTENT                        16
#define SFNT_HORIZONTALHEADER_HORIZONTALCARETSLOPENUMERATOR     18
#define SFNT_HORIZONTALHEADER_HORIZONTALCARETSLOPEDENOMINATOR   20
#define SFNT_HORIZONTALHEADER_RESERVED0                         22
#define SFNT_HORIZONTALHEADER_RESERVED1                         24
#define SFNT_HORIZONTALHEADER_RESERVED2                         26
#define SFNT_HORIZONTALHEADER_RESERVED3                         28
#define SFNT_HORIZONTALHEADER_RESERVED4                         30
#define SFNT_HORIZONTALHEADER_METRICDATAFORMAT                  32
#define SFNT_HORIZONTALHEADER_NUMBEROF_LONGHORMETRICS           34
#define SIZEOF_SFNT_HORIZONTALHEADER                            36

#define SFNT_HORIZONTALMETRICS_ADVANCEWIDTH     0
#define SFNT_HORIZONTALMETRICS_LEFTSIDEBEARING  2
#define SIZEOF_SFNT_HORIZONTALMETRICS           4

#define SFNT_VERTICALHEADER_NUMBEROF_LONGVERTMETRICS            34

#define SFNT_VERTICALMETRICS_ADVANCEHEIGHT      0
#define SFNT_VERTICALMETRICS_TOPSIDEBEARING     2
#define SIZEOF_SFNT_VERTICALMETRICS             4



#define SFNT_CONTROLVALUE 2

#define SFNT_MAPPINGTABLE_FORMAT            0
#define SFNT_MAPPINGTABLE_MAPTABLELENGTH    2
#define SFNT_MAPPINGTABLE_VERSION           4
#define SIZEOF_SFNT_MAPPINGTABLE            6

#define SFNT_PLATFORMENTRY_PLATFORMID       0
#define SFNT_PLATFORMENTRY_SPECIFICID       2
#define SFNT_PLATFORMENTRY_PLATFORMOFFSET   4
#define SIZEOF_SFNT_PLATFORMENTRY           8

#define SFNT_CHAR2INDEXDIRECTORY_VERSION    0
#define SFNT_CHAR2INDEXDIRECTORY_NUMTABLES  2
#define SFNT_CHAR2INDEXDIRECTORY_PLATFORM   4
#define SIZEOF_SFNT_CHAR2INDEXDIRECTORY     4

#define SFNT_SUBHEADER2_FIRSTCODE       0
#define SFNT_SUBHEADER2_ENTRYCOUNT      2
#define SFNT_SUBHEADER2_IDDELTA         4
#define SFNT_SUBHEADER2_IDRANGEOFFSET   6
#define SIZEOF_SFNT_SUBHEADER2          8

#define SFNT_MAPPINGTABLE2_SUBHEADERSKEYS   0
#define SFNT_MAPPINGTABLE2_SUBHEADERS       512
#define SIZEOF_SFNT_MAPPINGTABLE2           512

#define SFNT_MAPPINGTABLE4_SEGCOUNTX2       0
#define SFNT_MAPPINGTABLE4_SEARCHRANGE      2
#define SFNT_MAPPINGTABLE4_ENTRYSELECTOR    4
#define SFNT_MAPPINGTABLE4_RANGESHIFT       6
#define SFNT_MAPPINGTABLE4_ENDCOUNT         8
#define SIZEOF_SFNT_MAPPINGTABLE4           8

#define SFNT_MAPPINGTABLE6_FIRSTCODE    0
#define SFNT_MAPPINGTABLE6_ENTRYCOUNT   2
#define SFNT_MAPPINGTABLE6_GLYPHIDARRAY 4
#define SIZEOF_SFNT_MAPPINGTABLE6       4

#define SFNT_NAMERECORD_PLATFORMID  0
#define SFNT_NAMERECORD_SPECIFICID  2
#define SFNT_NAMERECORD_LANGUAGEID  4
#define SFNT_NAMERECORD_NAMEID      6
#define SFNT_NAMERECORD_NAMELENGTH  8
#define SFNT_NAMERECORD_NAMEOFFSET  10
#define SIZEOF_SFNT_NAMERECORD      12

#define SFNT_NAMINGTABLE_FORMAT         0
#define SFNT_NAMINGTABLE_COUNT          2
#define SFNT_NAMINGTABLE_STRINGOFFSET   4
/*  SFNT_NAMERECORD[COUNT]  */
#define SIZEOF_SFNT_NAMINGTABLE         6

#define SFNT_PACKEDSPLINEFORMAT_NUMBEROFCONTOURS    0
#define SFNT_PACKEDSPLINEFORMAT_BBOX                2
#define SFNT_PACKEDSPLINEFORMAT_ENDPOINTS           10
#define SIZEOF_SFNT_PACKEDSPLINEFORMAT              10

#define SFNT_DEVICEMETRICS_VERSION      0
#define SFNT_DEVICEMETRICS_NUMRECORDS   2
#define SFNT_DEVICEMETRICS_RECORDSIZE   4
/* BYTE WIDTHS[NUMGLYPHS+2] * NUMRECORDS */
#define SIZEOF_SFNT_DEVICEMETRICS       8

#define POSTSCRIPTNAMEINDICES_VERSION               0
#define POSTSCRIPTNAMEINDICES_ITALICANGLE           4
#define POSTSCRIPTNAMEINDICES_UNDERLINEPOSITION     8
#define POSTSCRIPTNAMEINDICES_UNDERLINETHICKNESS    10
#define POSTSCRIPTNAMEINDICES_ISFIXEDPITCH          12
#define POSTSCRIPTNAMEINDICES_PAD                   14
#define POSTSCRIPTNAMEINDICES_MINMEMTYPE42          16
#define POSTSCRIPTNAMEINDICES_MAXMEMTYPE42          20
#define POSTSCRIPTNAMEINDICES_MINMEMTYPE1           24
#define POSTSCRIPTNAMEINDICES_MAXMEMTYPE1           28
#define POSTSCRIPTNAMEINDICES_NUMBERGLYPHS          32
#define GLYPHNAMEINDEX                              34
#define GLYPHNAMEINDEX25                            34
#define SIZEOF_SFNT_POSTSCRIPTINFO                  36

#define SFNT_OS2_VERSION                0
#define SFNT_OS2_XAVGCHARWIDTH          2
#define SFNT_OS2_USWEIGHTCLASS          4
#define SFNT_OS2_USWIDTHCLASS           6
#define SFNT_OS2_FSTYPE                 8
#define SFNT_OS2_YSUBSCRIPTXSIZE        10
#define SFNT_OS2_YSUBSCRIPTYSIZE        12
#define SFNT_OS2_YSUBSCRIPTXOFFSET      14
#define SFNT_OS2_YSUBSCRIPTYOFFSET      16
#define SFNT_OS2_YSUPERSCRIPTXSIZE      18
#define SFNT_OS2_YSUPERSCRIPTYSIZE      20
#define SFNT_OS2_YSUPERSCRIPTXOFFSET    22
#define SFNT_OS2_YSUPERSCRIPTYOFFSET    24
#define SFNT_OS2_YSTRIKEOUTSIZE         26
#define SFNT_OS2_YSTRIKEOUTPOSITION     28
#define SFNT_OS2_SFAMILYCLASS           30
#define SFNT_OS2_PANOSE                 32
#define SFNT_OS2_ULCHARRANGE            42
#define SFNT_OS2_ACHVENDID              58
#define SFNT_OS2_USSELECTION            62
#define SFNT_OS2_USFIRSTCHAR            64
#define SFNT_OS2_USLASTCHAR             66
#define SFNT_OS2_STYPOASCENDER          68
#define SFNT_OS2_STYPODESCENDER         70
#define SFNT_OS2_STYPOLINEGAP           72
#define SFNT_OS2_SWINASCENT             74
#define SFNT_OS2_SWINDESCENT            76
#define SIZEOF_SFNT_OS2                 78

#define SFNT_HDMX_VERSION               0
#define SFNT_HDMX_SNUMRECORDS           2
#define SFNT_HDMX_LSIZERECORD           4
#define SFNT_HDMX_HDMXTABLE             8
#define SIZEOF_SFNT_HDMX                8

#define SFNT_HDMXRECORD_BEMY            0
#define SFNT_HDMXRECORD_BEMX            1
#define SFNT_HDMXRECORD_BWIDTHS         2
#define SIZEOF_SFNT_HDMXRECORD          2

#define SFNT_LTSH_VERSION               0
#define SFNT_LTSH_NUMGLYPHS             2
#define SFNT_LTSH_UBYPELSHEIGHT         4
#define SIZEOF_SFNT_LTSH                4

#define SFNT_MAXPROFILETABLE_VERSION                0
#define SFNT_MAXPROFILETABLE_NUMGLYPHS              4
#define SFNT_MAXPROFILETABLE_MAXPOINTS              6
#define SFNT_MAXPROFILETABLE_MAXCONTOURS            8
#define SFNT_MAXPROFILETABLE_MAXCOMPOSITEPOINTS     10
#define SFNT_MAXPROFILETABLE_MAXCOMPOSITECONTOURS   12
#define SFNT_MAXPROFILETABLE_MAXELEMENTS            14
#define SFNT_MAXPROFILETABLE_MAXTWILIGHTPOINTS      16
#define SFNT_MAXPROFILETABLE_MAXSTORAGE             18
#define SFNT_MAXPROFILETABLE_MAXFUNCTIONDEFS        20
#define SFNT_MAXPROFILETABLE_MAXINSTRUCTIONDEFS     22
#define SFNT_MAXPROFILETABLE_MAXSTACKELEMENTS       24
#define SFNT_MAXPROFILETABLE_MAXSIZEOFINSTRUCTIONS  26
#define SFNT_MAXPROFILETABLE_MAXCOMPONENTELEMENTS   28
#define SFNT_MAXPROFILETABLE_MAXCOMPONENTDEPTH      30
#define SIZEOF_SFNT_MAXPROFILETABLE 				32

#define SFNT_GASPRANGE_RANGEMAXPPEM 		0
#define SFNT_GASPRANGE_RANGEGASPBEHAVIOR	2
#define SIZEOF_SFNT_GASPRANGE				4

#define SFNT_GASP_VERSION					0
#define SFNT_GASP_NUMRANGES 				2
#define SFNT_GASP_GASPRANGE 				4
#define SIZEOF_SFNT_GASP					4

/**********************************************************************/

/*      Embedded Bitmap (sbit) Table Offsets      */

/**********************************************************************/

/*  Bloc, Bdat and Bsca file constants    */

/*  This first bloc is common to both bloc and bsca tables */

#define     SFNT_BLOC_NUMSIZES               4
#define     SFNT_BLOC_FIRSTSTRIKE            8

#define     SFNT_BLOC_INDEXARRAYOFFSET       0
#define     SFNT_BLOC_NUMINDEXTABLES         8
#define     SFNT_BLOC_COLORREF              12
#define     SFNT_BLOC_STARTGLYPH            40
#define     SFNT_BLOC_ENDGLYPH              42
#define     SFNT_BLOC_PPEMX                 44
#define     SFNT_BLOC_PPEMY                 45
#define     SFNT_BLOC_BITDEPTH              46
#define     SFNT_BLOC_FLAGS                 47
#define     SIZEOF_BLOC_SIZESUBTABLE        48

#define     SFNT_BLOC_FIRSTGLYPH             0
#define     SFNT_BLOC_LASTGLYPH              2
#define     SFNT_BLOC_ADDITIONALOFFSET       4
#define     SIZEOF_BLOC_INDEXARRAY           8

#define     SFNT_BLOC_INDEXFORMAT            0
#define     SFNT_BLOC_IMAGEFORMAT            2
#define     SFNT_BLOC_IMAGEOFFSET            4
#define     SFNT_BLOC_OFFSETARRAY            8

#define     SFNT_BLOC_IDX2IMAGESIZE          8
#define     SFNT_BLOC_IDX2METRICS           12

#define     SFNT_BLOC_IDX4NUMGLYPHS          8
#define     SFNT_BLOC_IDX4OFFSETARRAY       12

#define     SFNT_BLOC_IDX4CODE               0
#define     SFNT_BLOC_IDX4OFFSET             2
#define     SIZEOF_CODEOFFSETPAIR            4
                
#define     SFNT_BLOC_IDX5IMAGESIZE          8
#define     SFNT_BLOC_IDX5METRICS           12
#define     SFNT_BLOC_IDX5NUMGLYPHS         20
#define     SFNT_BLOC_IDX5CODEARRAY         24

#define     SFNT_SBIT_HEIGHT                 0
#define     SFNT_SBIT_WIDTH                  1
#define     SFNT_SBIT_BEARINGX               2
#define     SFNT_SBIT_BEARINGY               3
#define     SFNT_SBIT_ADVANCE                4
#define     SFNT_SBIT_VERTBEARINGX           5
#define     SFNT_SBIT_VERTBEARINGY           6
#define     SFNT_SBIT_VERTADVANCE            7
#define     SIZEOF_SBIT_SMALLMETRICS         5
#define     SIZEOF_SBIT_BIGMETRICS           8

#define     SFNT_BDAT_COMPCOUNT              0
#define     SIZEOF_SBIT_GLYPH8PAD            1
#define     SFNT_BDAT_FIRSTCOMP              2

#define     SFNT_BDAT_COMPGLYPH              0
#define     SFNT_BDAT_COMPXOFF               2
#define     SFNT_BDAT_COMPYOFF               3
#define     SIZEOF_SBIT_BDATCOMPONENT        4

#define     SFNT_BSCA_NUMSIZES               4
#define     SFNT_BSCA_FIRSTSTRIKE            8

#define     SFNT_BSCA_PPEMX                 24
#define     SFNT_BSCA_PPEMY                 25
#define     SFNT_BSCA_SUBPPEMX              26
#define     SFNT_BSCA_SUBPPEMY              27
#define     SIZEOF_BSCA_SIZESUBTABLE        28

/**********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\i386\math386.asm ===
;*********************************************************************
;    
;   FONTMATH.ASM -- TT Rasterizer Assembly Optimization Math Functions
;
;   3/02/93     deanb   David Cutler's FracSqrt (slightly modified)
;   2/25/93     deanb   CompMul and CompDiv implementation
;
;*********************************************************************

;.386P
;.model FLAT
        .386
        .model  small

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        extrn   _function:dword

_TEXT   SEGMENT USE32 PUBLIC 'CODE'


;********************************************************************


PUBLIC  @FracSqrt@4

;   at entry:   ecx =  2.30 radicand
;   at exit:    eax =  2.30 square root
;
; Routine Description:
;
;    This function computes the square root of a 2.30 fractional (2.30)
;    number.
;
;    N.B. This algorithm produces results that are 100% compatible with
;         the portable True Type version. If this constraint were relaxed,
;         i.e., as under Win 3.1, then a faster algorithm could be used.
;

@FracSqrt@4 PROC NEAR
		push    esi
		push    edi
		push    ebx

		mov     eax,ecx                 ; get the input argument value
		or      eax,eax                 ; check is argument is zero or negative
		jle     short FsxfZeroNeg       ; jump if zero or negative

;
; Test for the two special cases that would result in a one bit error in
; least significant digit of the result.
;
		
		cmp     eax,3fffffffh           ; check for first special case
		je      short FsxfExit          ; if zf set, first special case
		cmp     eax,40000001h           ; check for second special case
		je      short FsxfSpecial       ; if zf set, second special case

		xor     ecx,ecx                 ; exponent counter

FsxfNormalize:                          ; this loop should be very fast
		inc     ecx                     ; since most arguments are
		add     eax,eax                 ; nearly normalized at input
		jns     FsxfNormalize

		dec     ecx
		shr     eax,1
;
; If the exponent is odd, then use the odd square root table to estimate
; the first approximation. Otherwise, use the even square root table to
; estimate the first approximation. The exponent of the result is the
; normalize shift divided by two.
;

		mov     esi,eax                 ; copy the operand for extraction
		mov     edi,eax                 ;
		shr     eax,23                  ; isolate table index value
		and     eax,7fh                 ;
		shr     ecx,1                   ; compute result exponent
		jnc     short FsxfEven          ; if cf clear, use even table

;
; The exponent is odd.
;

FsxfOdd:
		shr     esi,3                   ; shift high part into place
		shl     edi,29                  ; shift low part into place
		mov     ebx,FsEstimateTableOdd[eax*4] ; get first estimate value
		jmp     short FsxfFinish        ; finish in common code

;
; The exponent is even.
;

FsxfEven:
		shr     esi,2                   ; shift high part into place
		shl     edi,30                  ; shift low part into place
		mov     ebx,FsEstimateTableEven[eax*4] ; get first estimate value

;
; Perform three iterations of Newton's formula:
;
; X' = (X + N / X) / 2
;
; extract the result and round.
;

FsxfFinish:
		mov     edx,esi                 ; set high part of dividend
		mov     eax,edi                 ; set low part of dividend
		div     ebx                     ; compute first quotient
		add     ebx,eax                 ; add first estimate and average
		shr     ebx,1                   ;
		mov     edx,esi                 ; set high part of dividend
		mov     eax,edi                 ; set low part of dividend
		div     ebx                     ; compute second quotient
		add     ebx,eax                 ; add second estimate and average
		shr     ebx,1                   ;
		mov     edx,esi                 ; set high part of dividend
		mov     eax,edi                 ; set low part of dividend
		div     ebx                     ; compute third quotient
		add     ebx,eax                 ; add third estimate and average
		mov     eax,ebx                 ; copy estimate value scaled by two
		shr     eax,1                   ; average last estimate and extract
		shl     ebx,31                  ; possible rounding bit
		shrd    ebx,eax,cl              ; extract insignificant bits
		shr     eax,cl                  ; shift final result into position
		shr     ebx,31                  ; shift round bit into low bit position
		add     eax,ebx                 ; round result

FsxfExit:        
		pop     ebx
		pop     edi
		pop     esi
		ret

;
; The input value is zero or negative.
;

FsxfZeroNeg:
		jz      short FsxfExit          ; if zero, return zero
		mov     eax,80000001h           ; if negative, return negative infinity

;
; The input value is the special case 40000001h.
;

FsxfSpecial:
		dec     eax                     ; convert to compatible value
		jmp     short FsxfExit          ; finish in common code

@FracSqrt@4 ENDP

_TEXT   ENDS

	.data








;
; First Estimate Tables
;

FsEstimateTableOdd equ  this dword
		dd      2d413ccdh, 2d6e6780h, 2d9b6577h, 2dc83738h
		dd      2df4dd43h, 2e215817h, 2e4da830h, 2e79ce0ah
		dd      2ea5ca1bh, 2ed19cdah, 2efd46bbh, 2f28c82eh
		dd      2f5421a3h, 2f7f5388h, 2faa5e49h, 2fd5424eh
		dd      30000000h, 302a97c5h, 30550a01h, 307f5717h
		dd      30a97f67h, 30d38351h, 30fd6332h, 31271f67h
		dd      3150b84ah, 317a2e34h, 31a3817dh, 31ccb27bh
		dd      31f5c183h, 321eaee8h, 32477afch, 32702611h
		dd      3298b076h, 32c11a79h, 32e96467h, 33118e8ch
		dd      33399933h, 336184a6h, 3389512dh, 33b0ff10h
		dd      33d88e94h, 34000000h, 34275397h, 344e899dh
		dd      3475a254h, 349c9dfeh, 34c37cdah, 34ea3f29h
		dd      3510e528h, 35376f16h, 355ddd2fh, 35842fb0h
		dd      35aa66d3h, 35d082d2h, 35f683e8h, 361c6a4dh
		dd      36423639h, 3667e7e3h, 368d7f81h, 36b2fd49h
		dd      36d86170h, 36fdac2bh, 3722ddadh, 3747f629h
		dd      376cf5d1h, 3791dcd6h, 37b6ab6bh, 37db61beh
		dd      38000000h, 38248660h, 3848f50ch, 386d4c32h
		dd      38918c00h, 38b5b4a2h, 38d9c645h, 38fdc114h
		dd      3921a53ah, 394572e3h, 39692a37h, 398ccb60h
		dd      39b05689h, 39d3cbd8h, 39f72b77h, 3a1a758dh
		dd      3a3daa41h, 3a60c9bah, 3a83d41dh, 3aa6c992h
		dd      3ac9aa3ch, 3aec7642h, 3b0f2dc7h, 3b31d0efh
		dd      3b545fdfh, 3b76dabah, 3b9941a2h, 3bbb94b9h
		dd      3bddd423h, 3c000000h, 3c221872h, 3c441d9ah
		dd      3c660f99h, 3c87ee8eh, 3ca9ba9ah, 3ccb73dch
		dd      3ced1a73h, 3d0eae7fh, 3d30301dh, 3d519f6dh
		dd      3d72fc8bh, 3d944795h, 3db580aah, 3dd6a7e4h
		dd      3df7bd63h, 3e18c140h, 3e39b39ah, 3e5a948bh
		dd      3e7b642fh, 3e9c22a1h, 3ebccffch, 3edd6c5ah
		dd      3efdf7d7h, 3f1e728ch, 3f3edc93h, 3f5f3606h
		dd      3f7f7efdh, 3f9fb793h, 3fbfdfe0h, 3fdff7fch

FsEstimateTableEven equ this dword
		dd      40000000h, 403fe020h, 407f80feh, 40bee354h
		dd      40fe07d9h, 413cef41h, 417b9a3ch, 41ba0977h
		dd      41f83d9bh, 4236374fh, 4273f736h, 42b17df2h
		dd      42eecc1fh, 432be258h, 4368c136h, 43a5694eh
		dd      43e1db33h, 441e1776h, 445a1ea3h, 4495f146h
		dd      44d18fe9h, 450cfb12h, 45483345h, 45833905h
		dd      45be0cd2h, 45f8af29h, 46332087h, 466d6166h
		dd      46a7723eh, 46e15384h, 471b05adh, 4754892bh
		dd      478dde6eh, 47c705e6h, 48000000h, 4838cd26h
		dd      48716dc3h, 48a9e23fh, 48e22b00h, 491a486bh
		dd      49523ae4h, 498a02cdh, 49c1a086h, 49f9146fh
		dd      4a305ee5h, 4a678044h, 4a9e78e9h, 4ad5492ch
		dd      4b0bf165h, 4b4271edh, 4b78cb1ah, 4baefd3fh
		dd      4be508b1h, 4c1aedc1h, 4c50acc3h, 4c864604h
		dd      4cbbb9d6h, 4cf10885h, 4d26325fh, 4d5b37afh
		dd      4d9018c1h, 4dc4d5deh, 4df96f50h, 4e2de55eh
		dd      4e623850h, 4e96686bh, 4eca75f6h, 4efe6133h
		dd      4f322a67h, 4f65d1d4h, 4f9957bch, 4fccbc60h
		dd      50000000h, 503322dbh, 50662531h, 5099073dh
		dd      50cbc93fh, 50fe6b71h, 5130ee10h, 51635155h
		dd      5195957ch, 51c7babeh, 51f9c153h, 522ba973h
		dd      525d7356h, 528f1f32h, 52c0ad3eh, 52f21dafh
		dd      532370b9h, 5354a691h, 5385bf6bh, 53b6bb7ah
		dd      53e79aefh, 54185dfdh, 544904d6h, 54798fa9h
		dd      54a9fea7h, 54da5200h, 550a89e3h, 553aa67fh
		dd      556aa801h, 559a8e97h, 55ca5a6eh, 55fa0bb3h
		dd      5629a293h, 56591f37h, 568881cdh, 56b7ca7eh
		dd      56e6f975h, 57160edch, 57450adbh, 5773ed9dh
		dd      57a2b749h, 57d16807h, 58000000h, 582e7f5ah
		dd      585ce63dh, 588b34ceh, 58b96b34h, 58e78995h
		dd      59159016h, 59437edbh, 5971560ah, 599f15c6h
		dd      59ccbe34h, 59fa4f77h, 5a27c9b2h, 5a552d07h

;********************************************************************


END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\ttfd\dbg.c ===
/******************************Module*Header*******************************\
* Module Name: dbg.c
*
* several debug routines
*
* Created: 20-Feb-1992 16:00:36
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
*
\**************************************************************************/

#include "fd.h"
#include "fdsem.h"


#if DBG


int ttfdDebugLevel = 1;

VOID
TtfdDbgPrint(
    PCHAR DebugMessage,
    ...
    )
{

    va_list ap;

    va_start(ap, DebugMessage);

    EngDebugPrint("",DebugMessage, ap);

    va_end(ap);

}


/******************************Public*Routine******************************\
*
*     vDbgCurve
*
* Effects: prints curve contensts
*
*
* History:
*  20-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID  vDbgCurve(TTPOLYCURVE *pcrv)
{
    PSZ               psz;
    POINTFIX        * pptfix, * pptfixEnd;

    if (pcrv->wType == TT_PRIM_QSPLINE)
    {
        psz = "TT_PRIM_QSPLINE";
    }
    else if (pcrv->wType == TT_PRIM_LINE)
    {
        psz = "TT_PRIM_LINE";
    }
    else
    {
        psz = "BOGUS CURVE TYPE";
    }
    TtfdDbgPrint("\n\nCurve: %s, cpfx = %ld\n", psz, pcrv->cpfx);


    pptfixEnd = (POINTFIX *)pcrv->apfx + pcrv->cpfx;
    for (pptfix = (POINTFIX *)pcrv->apfx; pptfix < pptfixEnd; pptfix++)
        TtfdDbgPrint("x = 0x%lx, y = 0x%lx \n", pptfix->x, pptfix->y);


}


/******************************Public*Routine******************************\
*
* vDbgGridFit(fs_GlyphInfoType *pout)
*
*
* Effects:
*
* Warnings:
*
* History:
*  17-Dec-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID vDbgGridFit(fs_GlyphInfoType *pout)
{
// this is spline data returned that we want to print

    uint32       cpt, cptTotal;     // total number of points:
    uint32       cptContour;        // total number of points in a contour:

    F26Dot6     *xPtr, *yPtr;
    int16       *startPtr;
    int16       *endPtr;
    uint8       *onCurve;

    uint32      c, cContours;
    int32       ipt;

    xPtr      = pout->xPtr;
    yPtr      = pout->yPtr;
    startPtr  = pout->startPtr;
    endPtr    = pout->endPtr;
    onCurve   = pout->onCurve;
    cContours = pout->numberOfContours;

    cptTotal = (uint32)(pout->endPtr[cContours - 1] + 1);

    TtfdDbgPrint("\n outlinesExist = %ld, numberOfCountours = %ld, cptTotal = %ld\n",
        (uint32)pout->outlinesExist,
        (uint32)pout->numberOfContours,
        cptTotal
        );

    if (!pout->outlinesExist)
        return;

// both statPtr and endPtr are inclusive: so that the folowing rule applies:
//  startPtr[i + 1] = endPtr[i] + 1;

    cpt = 0;   // initialize total number of points

    for (c = 0; c < cContours; c++, startPtr++, endPtr++)
    {
        cptContour = (uint32)(*endPtr - *startPtr + 1);
        TtfdDbgPrint ("start = %ld, end = %ld \n", (int32)*startPtr, (int32)*endPtr);

        for (ipt = (int32)*startPtr; ipt <= (int32)*endPtr; ipt++)
        {
            TtfdDbgPrint("x = 0x%lx, y = 0x%lx, onCurve = 0x%lx\n",
                    xPtr[ipt], yPtr[ipt], (uint32)onCurve[ipt]);
        }
        cpt += cptContour;
    }

    ASSERTDD(cpt == cptTotal, "cptTotal\n");
}

/******************************Public*Routine******************************\
*
* vDbgGlyphset
*
* Effects:
*
* Warnings:
*
* History:
*  20-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID vDbgGlyphset(PFD_GLYPHSET pgset)
{
    ULONG i;

    TtfdDbgPrint("\n\n cRuns = %ld, cGlyphsSupported = %ld \n\n",
                   pgset->cRuns, pgset->cGlyphsSupported);
    for (i = 0; i < pgset->cRuns; i++)
        TtfdDbgPrint("wcLow = 0x%lx, wcHi = 0x%lx\n",
                  (ULONG)pgset->awcrun[i].wcLow,
                  (ULONG)pgset->awcrun[i].wcLow + (ULONG)pgset->awcrun[i].cGlyphs - 1);
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\subpixel.c ===
/*********************************************************************

	  subpixel.c -- sub pixel rendering

	  (c) Copyright 1999-2000  Microsoft Corp.  All rights reserved.

 
**********************************************************************/

/*********************************************************************/

/*        Imports                                                    */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types  */
#include    "scentry.h"             /* for own function prototypes */

#ifdef FSCFG_SUBPIXEL

#ifdef FSCFG_SUBPIXEL_STANDALONE

// this should be considered a temporary solution. currently, the rasterizer is plumbed for 8 bpp output in SubPixel,
// and appears to have John Platt's filter hard-wired in. In the future, we would rather have the overscaled b/w bitmap
// as output, such that we can do any color filtering and gamma correction outside and independent of the rasterizer

// Index values for wRGBColors and awColorIndexTable

#define RED_INDEX	0
#define GREEN_INDEX	1
#define	BLUE_INDEX	2

// The abColorIndexTable datastructure contains one entry for each virtual subpixel.
// We index into this table to determine which color is assigned to that subpixel.
// To create the table, we set the first number of subpixels assigned to red to the red index,
// and likewise for green and blue.

static const uint8 abColorIndexTable[2][RGB_OVERSCALE] = // 2 Tables to indicate color for each subpixel, 0 = RGB striping order, 1 = BGR striping order
	{{RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX,														// R_Subpixels, hard-wired
	  GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,	// G_Subpixels, hard-wired
	  BLUE_INDEX, BLUE_INDEX},																						// B_Subpixels, hard-wired
	 {BLUE_INDEX, BLUE_INDEX,
	  GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,
	  RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX}};

#define PIXEL_ON	1
#define PIXEL_OFF	0
#define CHAR_BIT	8         /* number of bits in a char */

char GetInputPixel( char *pbyInputRowData, uint32 ulWidthIndex )
{
	uint32	ulRowIndex;
	char	byPixelMask;
	
	ulRowIndex = ulWidthIndex / CHAR_BIT;			// Determines which byte to check out
	byPixelMask = 0x80 >> ulWidthIndex % CHAR_BIT; // Determine offset within byte
	return ( (pbyInputRowData[ ulRowIndex ] & byPixelMask)?PIXEL_ON:PIXEL_OFF );
}


FS_PUBLIC void fsc_OverscaleToSubPixel (GlyphBitMap * OverscaledBitmap, boolean bgrOrder, GlyphBitMap * SubPixelBitMap)
{
	char * pbyInputRowData, *pbyOutputRowData;			// Pointer to one scanline of data
	uint32 ulOverscaledBitmapWidth; // Fscaled bitmap widths
	uint32 ulHeightIndex, ulWidthIndex, ulMaxWidthIndex;	// Scanline index and byte pixel index
	char byPixel;						// Contents of one pixel from the rasterizer
	uint16 usRGBColors[ 3 ];				// Contains sum of each color based on number of subpixels
    int16 sBitmapSubPixelStart;     
    uint16 usColorIndex;
    uint32 ulBytes;
	
	// Start processing the bitmap
	// This is the heart of the RGB striping algorithm
	sBitmapSubPixelStart = OverscaledBitmap->rectBounds.left % RGB_OVERSCALE;
    if (sBitmapSubPixelStart < 0)
    {
        sBitmapSubPixelStart += RGB_OVERSCALE;
    }

    ulOverscaledBitmapWidth = OverscaledBitmap->rectBounds.right - OverscaledBitmap->rectBounds.left;
    ulMaxWidthIndex = ulOverscaledBitmapWidth + sBitmapSubPixelStart;

    /* clear the resulting bitmap */
	ulBytes = (uint32)SubPixelBitMap->sRowBytes * (uint32)(SubPixelBitMap->sHiBand - SubPixelBitMap->sLoBand);
	Assert(((ulBytes >> 2) << 2) == ulBytes);

	for ( ulHeightIndex = 0; ulHeightIndex < (uint32)(SubPixelBitMap->sHiBand - SubPixelBitMap->sLoBand); ulHeightIndex++ )
	{
		// Initialize Input to start of current row

		pbyInputRowData = OverscaledBitmap->pchBitMap + (OverscaledBitmap->sRowBytes * ulHeightIndex);
		pbyOutputRowData = SubPixelBitMap->pchBitMap + (SubPixelBitMap->sRowBytes * ulHeightIndex);
				
		// Initialize RGBColors

		usRGBColors[RED_INDEX] = 0;
		usRGBColors[GREEN_INDEX] = 0;
		usRGBColors[BLUE_INDEX] = 0;

		// Walk the scanline from the first subpixel, calculating R,G, & B values

		for( ulWidthIndex = sBitmapSubPixelStart; ulWidthIndex < ulMaxWidthIndex; ulWidthIndex++)
		{
            byPixel = GetInputPixel( pbyInputRowData, ulWidthIndex - sBitmapSubPixelStart );
			FS_ASSERT((byPixel <= 1),"Input Pixel greater than one");
			usRGBColors[abColorIndexTable[bgrOrder][ulWidthIndex % RGB_OVERSCALE]] += byPixel;

			// If we've finished one pixel or the scanline, write out pixel 

			if((( ulWidthIndex % RGB_OVERSCALE ) == (uint32)(RGB_OVERSCALE - 1)) || // Finish one pixel
				ulWidthIndex == ( ulOverscaledBitmapWidth + sBitmapSubPixelStart - 1) ) // Finish row
			{
                /* write out current pixel, 8 bits in range 0 through 179 = (R_Subpixels + 1) * (G_Subpixels + 1) * (B_Subpixels + 1) */

                usColorIndex = usRGBColors[RED_INDEX]   * (G_Subpixels + 1) * (B_Subpixels + 1) +
                               usRGBColors[GREEN_INDEX] * (B_Subpixels + 1) +
                               usRGBColors[BLUE_INDEX];

                        FS_ASSERT((usColorIndex < 256),"Resulting pixel doesn't fit in a byte");

                *pbyOutputRowData = (char) usColorIndex;
                pbyOutputRowData++;
				usRGBColors[RED_INDEX] = 0;
				usRGBColors[GREEN_INDEX] = 0;
				usRGBColors[BLUE_INDEX] = 0;
            }
		}
	}
}

#else // !FSCFG_SUBPIXEL_STANDALONE


#define CHAR_BIT      8         /* number of bits in a char */

unsigned char ajRGBToWeight222[64] = {
    0,1,1,2,4,5,5,6,4,5,5,6,8,9,9,10,
    16,17,17,18,20,21,21,22,20,21,21,22,24,25,25,26,
    16,17,17,18,20,21,21,22,20,21,21,22,24,25,25,26,
    32,33,33,34,36,37,37,38,36,37,37,38,40,41,41,42};

    unsigned char ajRGBToWeightMask[CHAR_BIT] = { 
        0xFC, 0x7E, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01};

FS_PUBLIC void fsc_OverscaleToSubPixel (GlyphBitMap * OverscaledBitmap, boolean bgrOrder, GlyphBitMap * SubPixelBitMap)
{
	char * pbyInputRowData, *pbyOutputRowData;			// Pointer to one scanline of data
	uint32 ulOverscaledBitmapWidth; // Fscaled bitmap widths
	uint32 ulHeightIndex, ulWidthIndex, ulMaxWidthIndex;	// Scanline index and byte pixel index
    int16 sBitmapSubPixelStart;     
    uint16 usColorIndex;

    uint16 usSubPixelIndex;
    int16 uSubPixelRightShift, uSubPixelLeftShift;
    char * pbyInputEndRowData;


	// Start processing the bitmap
	// This is the heart of the RGB striping algorithm
	sBitmapSubPixelStart = OverscaledBitmap->rectBounds.left % RGB_OVERSCALE;
    if (sBitmapSubPixelStart < 0)
    {
        sBitmapSubPixelStart += RGB_OVERSCALE;
    }

    ulOverscaledBitmapWidth = OverscaledBitmap->rectBounds.right - OverscaledBitmap->rectBounds.left;
    ulMaxWidthIndex = (uint32)(SubPixelBitMap->rectBounds.right - SubPixelBitMap->rectBounds.left);

	for ( ulHeightIndex = 0; ulHeightIndex < (uint32)(SubPixelBitMap->sHiBand - SubPixelBitMap->sLoBand); ulHeightIndex++ )
	{
		// Initialize Input to start of current row

		pbyInputRowData = OverscaledBitmap->pchBitMap + (OverscaledBitmap->sRowBytes * ulHeightIndex);
        pbyInputEndRowData = pbyInputRowData + OverscaledBitmap->sRowBytes;
		pbyOutputRowData = SubPixelBitMap->pchBitMap + (SubPixelBitMap->sRowBytes * ulHeightIndex);
				

        /* do the first partial byte : */

        usColorIndex = (unsigned char)(*pbyInputRowData) >> (sBitmapSubPixelStart + (8 - RGB_OVERSCALE));
        usColorIndex = ajRGBToWeight222[usColorIndex];

        *pbyOutputRowData = (char) usColorIndex;

        pbyOutputRowData++;

        usSubPixelIndex = (CHAR_BIT + RGB_OVERSCALE - sBitmapSubPixelStart) % CHAR_BIT;

		// Walk the scanline from the first subpixel, calculating R,G, & B values

		for( ulWidthIndex = 1; ulWidthIndex < ulMaxWidthIndex; ulWidthIndex++)
		{
            uSubPixelLeftShift = 0;
            uSubPixelRightShift = CHAR_BIT - RGB_OVERSCALE - usSubPixelIndex;
            if (uSubPixelRightShift < 0) 
            {
                uSubPixelLeftShift = - uSubPixelRightShift;
                uSubPixelRightShift = 0;
            }

            usColorIndex = ((unsigned char)(*pbyInputRowData) & ajRGBToWeightMask[usSubPixelIndex]) >> uSubPixelRightShift << uSubPixelLeftShift;

            if (pbyInputRowData+1 < pbyInputEndRowData)
            {
                /* avoid reading too far for the partial pixel at the end */
                uSubPixelRightShift = CHAR_BIT + CHAR_BIT - RGB_OVERSCALE - usSubPixelIndex;

                usColorIndex += (unsigned char)(*(pbyInputRowData+1)) >> uSubPixelRightShift;
            }
            usColorIndex = ajRGBToWeight222[usColorIndex];

            *pbyOutputRowData = (char) usColorIndex;

            pbyOutputRowData++;

            usSubPixelIndex = (usSubPixelIndex + RGB_OVERSCALE);
            if (usSubPixelIndex >= CHAR_BIT)
            {
                usSubPixelIndex = usSubPixelIndex % CHAR_BIT;
                pbyInputRowData ++;
            }
		}
	}
}

#endif // FSCFG_SUBPIXEL_STANDALONE

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\ttfd\dbg.h ===
/******************************Module*Header*******************************\
* Module Name: dbg.h
*
* several debug routines
*
* Created: 20-Feb-1992 16:00:36
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
*
\**************************************************************************/




// all the routines in this file MUST BE under DBG

#define DEBUG_GRAY  1

#if DBG

extern int ttfdDebugLevel;

VOID TtfdDbgPrint(PCHAR DebugMessage,...);

#define KPRINT(x)

VOID  vDbgCurve(TTPOLYCURVE *pcrv);
VOID  vDbgGridFit(fs_GlyphInfoType *pout);
VOID  vDbgGlyphset(PFD_GLYPHSET pgset);


#define RIP(x)        { TtfdDbgPrint(x); EngDebugBreak();}
#define ASSERTDD(x,y) { if (!(x)) { TtfdDbgPrint(y); EngDebugBreak();} }
#define WARNING(x)    TtfdDbgPrint(x)

#define TTFD_PRINT(x,_y_) if (ttfdDebugLevel >= (x)) TtfdDbgPrint _y_


#else

#define KPRINT(x)

#define RIP(x)
#define ASSERTDD(x,y)
#define WARNING(x)
#define TTFD_PRINT(x,y)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\ttfd\cvt.h ===
/******************************Module*Header*******************************\
* Module Name: cvt.h
*
* function declarations that are private to cvt.c
*
* Created: 26-Nov-1990 17:39:35
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
\**************************************************************************/


BOOL bGetTagIndex
(
ULONG  ulTag,      // tag
INT   *piTable,    // index into a table
BOOL  *pbRequired  // requred or optional table
);

BOOL bGrabXform
(
PFONTCONTEXT pfc,
USHORT usOverScale,
BOOL  bBitmapEmboldening
,BOOL   bClearType
);


typedef struct _GMC  // Glyph Metrics Corrections
{
// corrections to top, bottom and cx:

    ULONG dyTop;        // (yTop < pfc->yMin) ? (pfc->yMin - yTop) : 0;
    ULONG dyBottom;     // (yBottom > pfc->Max) ? (yBottom - pfc->Max):0;

    ULONG dxLeft;
    ULONG dxRight;

// corrected values (using the corrections above)

    ULONG cxCor;
    ULONG cyCor;


} GMC, *PGMC;

#define FL_SKIP_IF_BITMAP  1
#define FL_FORCE_UNHINTED  2

// iMode is used in the case the user select a specific overScale (QFD_TT_GRAY1_BITMAP to QFD_TT_GRAY8_BITMAP)
// to be able to set the overScale in the font context correctely

FONTCONTEXT *ttfdOpenFontContext (
    FONTOBJ *pfo
    );

#if DBG
#define IS_GRAY(p) ((((p)->flFontType & FO_CHOSE_DEPTH) ? \
    0 : TtfdDbgPrint("Level Not chosen yet\n")) ,(p)->flFontType & FO_GRAY16)
#else
#define IS_GRAY(p) ((p)->flFontType & FO_GRAY16)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\ttfd\fdfc.c ===
/******************************Module*Header*******************************\
* Module Name: fdfc.c                                                      *
*                                                                          *
* Open,Close,Reset Font Context                                            *
*                                                                          *
* Created: 18-Nov-1991 11:55:38                                            *
* Author: Bodin Dresevic [BodinD]                                          *
*                                                                          *
* Copyright (c) 1993 Microsoft Corporation                                 *
\**************************************************************************/

#include "fd.h"
#include "winfont.h"

#if DBG
// #define DBG_XFORM
extern ULONG gflTtfdDebug;
ULONG gflTtfdDebug = 0;
#endif

STATIC BOOL bNewXform
(
FONTOBJ      *pfo,            // IN
PFONTCONTEXT  pfc             // OUT
);


STATIC BOOL bComputeMaxGlyph(PFONTCONTEXT pfc);

#define CVT_TRUNCATE  0x00000001
#define CVT_TO_FIX    0X00000002

STATIC BOOL bFloatToL(FLOATL e, PLONG pl);
STATIC Fixed fxPtSize(PFONTCONTEXT pfc);
STATIC BOOL ttfdCloseFontContext(FONTCONTEXT *pfc);
STATIC VOID vFindHdmxTable(PFONTCONTEXT pfc);
STATIC ULONG iHipot(LONG x, LONG y);
LONG lFFF(LONG l);


#define FFF(e,l) *(LONG*)(&(e)) = lFFF(l)

#define MAX_BOLD 56

/******************************Public*Routine******************************\
*
* PVOID Pv_Realloc
*
*
* History:
*  10-14-1997 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/
PVOID   Pv_Realloc(PVOID pv, LONG newSize, LONG oldSize)
{
// This function will only used by
// fst_CallBackFSTraceFunction() for robust rasterizer
// There is an assumption, the input parameter will be
// alwys correct and there is no need to do value checking.
// If other function need to use it, please be aware of that.
    PVOID   pvNew;

    ASSERTDD(newSize > oldSize, "Pv_Realloc wrong input parameters \n");

    pvNew = PV_ALLOC(newSize);

    if (pvNew == NULL)
    {
        V_FREE(pv);
        return NULL;
    }

    RtlCopyMemory(pvNew, pv, oldSize);
    V_FREE(pv);

    return pvNew;
}

/******************************Public*Routine******************************\
*
* BOOL bInitInAndOut
*
*
* History:
*  18-Nov-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL bInitInAndOut(FONTFILE *pff)
{
    FS_ENTRY           iRet;
    fs_GlyphInputType *pgin;
    fs_GlyphInfoType  *pgout;

    ASSERTDD(pff->pj034 != NULL, "pff->pj3 IS null\n");

    pgin  = (fs_GlyphInputType *)pff->pj034;
    pgout = (fs_GlyphInfoType  *)(pff->pj034 + CJ_IN);

    if ((iRet = fs_OpenFonts(pgin, pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);
        return (FALSE);
    }

    pgin->memoryBases[0] = (char *)(pff->pj034 + CJ_IN + CJ_OUT);
    pgin->memoryBases[1] = NULL;
    pgin->memoryBases[2] = NULL;

// initialize the font scaler, notice no fields of pfc->gin are initialized [BodinD]

    if ((iRet = fs_Initialize(pgin, pgout)) != NO_ERR)
    {
    // clean up and return:

        V_FSERROR(iRet);
        RET_FALSE("TTFD!_ttfdLoadFontFile(): fs_Initialize \n");
    }

// initialize info needed by NewSfnt function

    pgin->sfntDirectory  = (int32 *)pff->pvView; // pointer to the top of the view of the ttf file

    pgin->clientID = (ULONG_PTR)pff; // pointer to FONTFILE.

    pgin->GetSfntFragmentPtr = pvGetPointerCallback;
    pgin->ReleaseSfntFrag  = vReleasePointerCallback;

    pgin->param.newsfnt.platformID = BE_UINT16(&pff->ffca.ui16PlatformID);
    pgin->param.newsfnt.specificID = BE_UINT16(&pff->ffca.ui16SpecificID);

    if ((iRet = fs_NewSfnt(pgin, pgout)) != NO_ERR)
    {
    // clean up and exit

        V_FSERROR(iRet);
        RET_FALSE("TTFD!_ttfdLoadFontFile(): fs_NewSfnt \n");
    }

// sizes 3 and 4 returned

    ASSERTDD(pff->ffca.cj3 == (ULONG)NATURAL_ALIGN(pgout->memorySizes[3]), "cj3\n");
    ASSERTDD(pff->ffca.cj4 == (ULONG)NATURAL_ALIGN(pgout->memorySizes[4]), "cj4\n");

// pj3 should  be shareable, but unfortunately there are fonts that
// use it to store some info there which they expect to find there at
// later times, so we have to make pj3 private as well

    pgin->memoryBases[3] = pff->pj034 + (CJ_IN + CJ_OUT + CJ_0);

// not shared, private

    pgin->memoryBases[4] = pgin->memoryBases[3] + pff->ffca.cj3;

    return TRUE;
}


#define LGINT_TO_LL(X)                                       \
((LONGLONG)(((LONGLONG)((X).HighPart) << 32) | (LONGLONG)((X).LowPart)))


VOID vLONG_X_POINTQF(LONG lIn, POINTQF *ptqIn, POINTQF *ptqOut)
{
    LONGLONG dx, dy;

    dx = LGINT_TO_LL(ptqIn->x);
    dy = LGINT_TO_LL(ptqIn->y);

    dx *= lIn;
    dy *= lIn;

    ptqOut->x = *((LARGE_INTEGER*)(&dx));
    ptqOut->y = *((LARGE_INTEGER*)(&dy));
}




/******************************Public*Routine******************************\
*
* void vCalcEmboldSize
*
* We only support embold enhancemet in FE font.
* The basic rule is 2% extended from normal font.
*
* History:
*  14-May-1997 -by- Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/


void vCalcEmboldSize(FONTCONTEXT * pfc)
{
    USHORT dDesc;

// we always shift glyphs in the direction of baseline and then in
// the direction opposite from ascender direction.
// That is the full shift vector is
//
// dv = dBase * pteUnitBase - dDesc * pteUnitSide;
//
// where dBase and dDesc are positive.
// We decompose this vector along x and y axes to get it in the form
//
// dv = dxBold * Ex + dyBold * Ey; // Ex, Ey unit vectors in x,y directions
//
// we shall use the win95-J compatible algorithm where
// we will shift bitmpas (((2%+1) right X 2% down)) algorithm
//
// The following computation was adapted to get the same cutoff than Win'98 between 50 and 51 ppem
// for an emboldening factor of 2%

    dDesc = (USHORT)((pfc->lEmHtDev * 2 - 1) / 100);

// dBase is always at least 1, we do not compute it based on width

    pfc->dBase = dDesc + 1;

}


/******************************Public*Routine******************************\
*
* Find minimal non-zero advance width
*
* Called by:       ttfdOpenFontContext
*
* Routines called: bGetTablePointers
*
* History:
*  02-May-1996 [kirko]
* Added checking for table corruption.
*  22-Feb-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID  vGetMinD(FONTFILE *pff)
{
    extern PBYTE pjTable(ULONG, PFONTFILE, ULONG*);
    extern BOOL bGetTablePointers(PVOID, ULONG, BYTE*, TABLE_POINTERS*);

    sfnt_HorizontalHeader  *phhea;
    sfnt_HorizontalMetrics *phmtx;
    ULONG  cHMTX;

    BYTE  *pjView;

    ULONG  ig;
    ULONG  igMin = 0;
    USHORT usMinWidth = 0xffff;
    USHORT usWidth;


    pjView = (BYTE *)pff->pvView;
    ASSERTDD(pjView, "pjView is NULL 1\n");
    ASSERTDD(pff->ffca.igMinD == USHRT_MAX, "igMinD is bogus \n");

    phhea = (sfnt_HorizontalHeader *)(pjView + pff->ffca.tp.ateReq[IT_REQ_HHEAD].dp);
    phmtx = (sfnt_HorizontalMetrics *)(pjView + pff->ffca.tp.ateReq[IT_REQ_HMTX].dp);

    cHMTX = (ULONG) BE_UINT16(&phhea->numberOf_LongHorMetrics);

    for (ig = 0; ig < cHMTX; ig++)
    {
        usWidth = BE_UINT16(&phmtx[ig].advanceWidth);
        if ((usWidth < usMinWidth) && (usWidth != 0))
        {
            usMinWidth = usWidth;
            igMin = ig;
        }
    }

// store the results

    pff->ffca.usMinD = usMinWidth;
    pff->ffca.igMinD = (USHORT)igMin;
}

/******************************Public*Routine******************************\
* ttfdOpenFontContext                                                      *
*                                                                          *
* History:                                                                 *
*  11-Nov-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/


FONTCONTEXT *ttfdOpenFontContextInternal(FONTOBJ *pfo)
{
    PFONTCONTEXT  pfc   = PFC(NULL);
    PTTC_FONTFILE pttc  = (PTTC_FONTFILE)pfo->iFile;
    ULONG         iFace = pfo->iFace;
    ULONG_PTR     iFile;
    PFONTFILE     pff;

    if (!pttc)
        return((FONTCONTEXT *) NULL);

    ASSERTDD(
        iFace <= pttc->ulNumEntry,
        "gdisrv!ttfdOpenFontContextTTC(): ulFont out of range\n"
        );

    iFile = PFF(pttc->ahffEntry[0].hff)->iFile;

    if (pttc->cRef == 0)
    {
    // have to remap the file

        if
        (
            !EngMapFontFileFD(
                iFile,
                (PULONG*)&pttc->pvView,
                &pttc->cjView
                )
        )
        {
            RETURN("TTFD!_bMapTTF, somebody removed a ttf file\n",NULL);
        }
    }

    // Get FONTFILE structure.

    pff = PFF(pttc->ahffEntry[iFace-1].hff);

    if (pff->cRef == 0)
    {
    // Update FILEVIEW structure in FONTFILE

        pff->pvView = pttc->pvView;
        pff->cjView = pttc->cjView;

    // We have precomputed all sizes and we are allocating all memory at once:

        ASSERTDD(pff->pj034 == NULL, "TTFD, pff->pj034 should be null\n");

        if
        (
            !(pff->pj034 = (PBYTE)PV_ALLOC(
                                    CJ_IN    +
                                    CJ_OUT   +
                                    CJ_0     +
                                    pff->ffca.cj3 +
                                    pff->ffca.cj4
                                    ))
        )
        {
            if(pttc->cRef == 0)
                EngUnmapFontFileFD(iFile);
            RETURN("ttfd, MEM Alloc  failed for pj034\n", NULL);
        }

        if (!bInitInAndOut(pff)) // could cause the exception
        {
            if(pttc->cRef == 0)
                EngUnmapFontFileFD(iFile);
            V_FREE(pff->pj034);
            pff->pj034 = (BYTE *)NULL;
            RETURN("ttfd, bInitInAndOut failed for \n", NULL);
        }

    // check if ffca.usMinD has been initialized, if not do it

        if (!pff->ffca.usMinD)
            vGetMinD(pff);
    }

// allocate memory for the font context and get the pointer to font context

    ASSERTDD(!pff->pfcToBeFreed, "TTFD!ttfdOpenFontContext, pfcToBeFreed NOT null\n");

    if ((pff->pfcToBeFreed = pfc = pfcAlloc(sizeof(FONTCONTEXT))) ==
        (FONTCONTEXT *) NULL )
    {
        WARNING("TTFD!_ttfdOpenFontContext, hfcAlloc failed\n");
        if (pttc->cRef == 0)
            EngUnmapFontFileFD(iFile);
        if (pff->cRef == 0)
        {
            V_FREE(pff->pj034);
            pff->pj034 = (BYTE *)NULL;
        }
        return((FONTCONTEXT *) NULL);
    }

// state that the hff passed to this function is the FF selected in
// this font context

    pfc->pfo = pfo;
    pfc->pff = pff;
    pfc->ptp = &pff->ffca.tp;

// parts of FONTOBJ that are important

    pfc->flFontType   = pfo->flFontType  ;
    pfc->sizLogResPpi = pfo->sizLogResPpi;
    pfc->ulStyleSize  = pfo->ulStyleSize ;

// tt strucs

    pfc->pgin  = (fs_GlyphInputType *) pfc->pff->pj034;
    pfc->pgout = (fs_GlyphInfoType  *) (pfc->pff->pj034 + CJ_IN);

// 2,4,6... (n*2) is Vertical face.

    pfc->bVertical = (pttc->ahffEntry[iFace-1].iFace & 0x1) ? FALSE : TRUE;

// given the values in the context info store the transform matrix:



    if (!bNewXform(pfo,pfc))
    {
    // clean up and exit

        WARNING("TTFD!_ttfdOpenFontContext, bNewXform\n");

        vFreeFC(pfc);
        pff->pfcToBeFreed = NULL;

        if (pttc->cRef == 0)
            EngUnmapFontFileFD(iFile);
        if (pff->cRef == 0)
        {
            V_FREE(pff->pj034);
            pff->pj034 = (BYTE *)NULL;
        }
        return((FONTCONTEXT *) NULL);
    }

    pfc->ulControl = 0;

// setting up of the overScale to a default value

    pfc->overScale = FF_UNDEFINED_OVERSCALE;

// increase the reference count of the font file, WE DO THIS ONLY WHEN
// WE ARE SURE that can not fail any more
// we have pfc, no exceptions any more

// now that we have pfc, we do not want to delete it

    pff->pfcToBeFreed = NULL;

    (pff->cRef)++;
    (pttc->cRef)++;

    return(pfc);
}

/**************************Public*Routine****************************\
* ttfdOpenFontContext                                                *
*                                                                    *
* History:                                                           *
*  07-Jan-1999 -by- Xudong Wu [tessiew]                              *
* Wrote it.                                                          *
\********************************************************************/
FONTCONTEXT *ttfdOpenFontContext(FONTOBJ *pfo)
{
    FONTCONTEXT *pfc;

    VOID vMarkFontGone(TTC_FONTFILE*, DWORD);
    DWORD iExcCode;
    TTC_FONTFILE *pttc = (TTC_FONTFILE *)pfo->iFile;

    try 
    {
        pfc = ttfdOpenFontContextInternal(pfo);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("TTFD!_ exception in ttfdOpenFontContext\n");

        vMarkFontGone(pttc, iExcCode = GetExceptionCode());
        if (pttc && (pttc->cRef == 0) && (iExcCode == STATUS_IN_PAGE_ERROR))
        {
            EngUnmapFontFileFD(PFF(pttc->ahffEntry[0].hff)->iFile);
        }
        pfc = NULL;
    }

    return pfc;
}

/******************************Public*Routine******************************\
*
* ttfdCloseFontContext
*
*
* Effects:
*
*
* History:
*  11-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
ttfdCloseFontContext (
    FONTCONTEXT *pfc
    )
{
    PTTC_FONTFILE pttc;
    PFONTFILE     pff;

    if (pfc == (FONTCONTEXT *) NULL)
        return(FALSE);

    pff  = pfc->pff;
    pttc = pfc->pff->pttc;

// decrement the reference count for the corresponding FONTFILE

    ASSERTDD(pff->cRef > 0L, "TTFD!_CloseFontContext: cRef <= 0 \n");

    pff->cRef--;
    pttc->cRef--;

// if this was the last fc that last used the buffer at pj3, invalidate
// the associated pfcLast

    if (pff->pfcLast == pfc)
        pff->pfcLast = PFC(NULL);

// in case that this is happening after the exception, make sure to release
// any memory that may have possibly been allocated to perform queries
// on per character basis:

    if (pttc->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
    // if exception this memory has already been freed

        ASSERTDD(!pff->pj034, "\n TTFD! pff->pj3 is NOT null\n");

        if (pfc->gstat.pv) // this may or may have not been allocated
        {
            V_FREE(pfc->gstat.pv);
            pfc->gstat.pv = NULL;
        }
    }
    else
    {
        ASSERTDD(pff->pj034, "\n TTFD! pff->pj3 is null\n");
    }

    if (pff->cRef == 0)
    {
    // there are no fc's  around to use memory at pff->pj3, release it.

        if (!(pttc->fl & FF_EXCEPTION_IN_PAGE_ERROR))
        {
            V_FREE(pff->pj034);
            pff->pj034 = (BYTE *)NULL;
        }
    }

    if (pttc->cRef == 0)
    {
    // file will not be used for a while,

        EngUnmapFontFileFD(PFF(pttc->ahffEntry[0].hff)->iFile);
    }

// free the memory associated with hfc

    vFreeFC(pfc);
    return(TRUE);
}

/******************************Public*Routine******************************\
* ttfdDestroyFont
*
* Driver can release all resources associated with this font realization
* (embodied in the FONTOBJ).
*
* History:
*  27-Oct-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
ttfdDestroyFont (
    FONTOBJ *pfo
    )
{
// For the ttfd, this is simply closing the font context.
// We cleverly store the font context handle in the FONTOBJ pvProducer
// field.

// pfo->pvProducer COULD BE null if exception occured while trying to create fc

    if (pfo->pvProducer)
    {
        ttfdCloseFontContext((FONTCONTEXT *) pfo->pvProducer);
        pfo->pvProducer = NULL;
    }
}


/******************************Public*Routine******************************\
* ttfdFree
*
*
* Effects:
*
* Warnings:
*
* History:
*  27-Oct-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
ttfdFree (
    PVOID pv,
    ULONG_PTR id
    )
{
    DYNAMICDATA *pdd;

//
// If id is NULL, then we can ignore.
//
    if ( (pdd = (DYNAMICDATA *) id) == (DYNAMICDATA *) NULL )
        return;

// What kind of data?
//
    switch (pdd->ulDataType)
    {
    case ID_KERNPAIR:

    // Invalidate the cached pointer to the data.

         pdd->pff->pkp = NULL; // important to check at vUnloadFontFile time

    // Free the kerning pair buffer and DYNAMICDATA structure.

        pv;    // we ignore pv because it is part of the mem allocated with DYNAMICDATA structure.
        V_FREE(pdd);    // this frees both the DYNAMICDATA struct and the FD_KERNINGPAIR buffer.

        break;

    default:
    //
    // Don't do anything.
    //
        break;
    }
}


/******************************Public*Routine******************************\
*
* bSetXform
*
* the only reason this funcion can fail is if fs_NewTransformation has failed
* Needs to be called when the transform has changed relative to the
* transform stored in this fc
*
* History:
*  28-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL bSetXform (
    PFONTCONTEXT  pfc,
    BOOL bBitmapEmboldening
    ,BOOL bClearType
    )
{
    FS_ENTRY    iRet;
    transMatrix mx = pfc->mx;
    Fixed       fxScale;
    LONG        ptSize;

// no previous glyph metric computation can be used

    vInitGlyphState(&pfc->gstat);

// if an illegal junk is passed for style size replace by reasonable default

    if (pfc->ulStyleSize > SHRT_MAX)
        pfc->ulStyleSize = 0;

    pfc->pgin->param.newtrans.xResolution = (int16)pfc->sizLogResPpi.cx;
    pfc->pgin->param.newtrans.yResolution = (int16)pfc->sizLogResPpi.cy;

    if (pfc->flXform & XFORM_SINGULAR)
    {
    // just put in some junk so that the preprogram does not explode

        pfc->pgin->param.newtrans.pointSize = LTOF16_16(12);

        mx.transform[0][0] = LTOF16_16(1);
        mx.transform[1][0] = 0;
        mx.transform[1][1] = LTOF16_16(1);
        mx.transform[0][1] = 0;
    }
    else
    {
        if (pfc->flXform & XFORM_HORIZ)
        {
            if (pfc->ulStyleSize == 0)
            {
            // hinting is determined by ptSize that corresponds to the
            // actual height in points of the font

                pfc->pgin->param.newtrans.pointSize = pfc->fxPtSize;

            // factor out pointSize from the xform:

                if (pfc->mx.transform[1][1] > 0)
                    mx.transform[1][1] = LTOF16_16(1);
                else
                    mx.transform[1][1] = LTOF16_16(-1);

                if
                (
                    (pfc->mx.transform[1][1] == pfc->mx.transform[0][0])
                    &&
                    (pfc->sizLogResPpi.cy == pfc->sizLogResPpi.cx)
                )
                {
                // important special case, simplify computation

                    mx.transform[0][0] = mx.transform[1][1];
                }
                else // general case
                {
                    fxScale = LongMulDiv(
                                 LTOF16_16(pfc->pff->ffca.ui16EmHt),pfc->sizLogResPpi.cy,
                                 pfc->lEmHtDev * pfc->sizLogResPpi.cx
                                 );

                    mx.transform[0][0] = FixMul(mx.transform[0][0], fxScale);
                }
            }
            else
            {
            // This is the support for new optical scaling feature.
            // Hint the font as determined by the style point size from
            // ExtLogFont,  but possibly zoom the font to a different
            // physical size

                pfc->pgin->param.newtrans.pointSize =
                    (Fixed)LTOF16_16(pfc->ulStyleSize);

            // factor out pointSize from the xform:

                fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),72,
                             pfc->ulStyleSize * pfc->sizLogResPpi.cx
                             );

                mx.transform[0][0] = FixMul(mx.transform[0][0], fxScale);

                if (pfc->sizLogResPpi.cy != pfc->sizLogResPpi.cx)
                {
                    fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),72,
                                  pfc->ulStyleSize * pfc->sizLogResPpi.cy
                                  );
                }

                mx.transform[1][1] = FixMul(mx.transform[1][1], fxScale);
            }
        }
        else
        {
            if (pfc->ulStyleSize == 0)
            {
            // compute the physical point size

                ptSize = F16_16TOLROUND(pfc->fxPtSize);
                pfc->pgin->param.newtrans.pointSize = pfc->fxPtSize;
            }
            else // use style size from logfont, the support for optical scaling
            {
                ptSize = pfc->ulStyleSize;
                pfc->pgin->param.newtrans.pointSize = LTOF16_16(pfc->ulStyleSize);
            }

        // factor out pointSize from the xform:

            if
            (
                (pfc->flXform & XFORM_VERT) &&
                (pfc->mx.transform[1][0] == -pfc->mx.transform[0][1])
                &&
                (pfc->sizLogResPpi.cy == pfc->sizLogResPpi.cx)
            )
            {
            // important special case, simplify computation
            // and avoid rounding error

                if (pfc->mx.transform[0][1] > 0)
                    mx.transform[0][1] = LTOF16_16(1);
                else
                    mx.transform[0][1] = LTOF16_16(-1);

                mx.transform[1][0] = -mx.transform[0][1];
                mx.transform[0][0] = 0;
                mx.transform[1][1] = 0;
            }
            else
            {
                if (((ptSize + 1) * pfc->sizLogResPpi.cx) > 0x8000)
                {
                    /* keep the old computation to avoid overflow */
                    fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),72,
                                 ptSize * pfc->sizLogResPpi.cx
                                 );
                } else {
                    fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),0x480000 /* 72 */,
                                 pfc->pgin->param.newtrans.pointSize * pfc->sizLogResPpi.cx
                                 );
                }

                mx.transform[0][0] = FixMul(mx.transform[0][0], fxScale);
                mx.transform[1][0] = FixMul(mx.transform[1][0], fxScale);

                if (pfc->sizLogResPpi.cy != pfc->sizLogResPpi.cx)
                {
                    if (((ptSize + 1) * pfc->sizLogResPpi.cy) > 0x8000)
                    {
                    /* keep the old computation to avoid overflow */
                        fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),72,
                                      ptSize * pfc->sizLogResPpi.cy
                                      );
                    } else {
                        fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),0x480000 /* 72 */,
                                      pfc->pgin->param.newtrans.pointSize * pfc->sizLogResPpi.cy
                                      );
                    }
                }

                mx.transform[1][1] = FixMul(mx.transform[1][1], fxScale);
                mx.transform[0][1] = FixMul(mx.transform[0][1], fxScale);
            }
        }

    }

// last minute modification to the matrix if italicization is present:

    if (pfc->flFontType & FO_SIM_ITALIC)
    {
    // the result of multiplying arbitrary matrix with italicization matrix
    // We are multiplying from the left because the italicization matrix
    // acts first on the notional space vectors on the left
    //
    // |1      0|   |m00    m01|   |m00                 m10              |
    // |        | * |          | = |                                     |
    // |sin20  1|   |m10    m11|   |m10 + m00 * sin20   m11 + m01 * sin20|
    //

        mx.transform[1][0] += FixMul(mx.transform[0][0], FX_SIN20);
        mx.transform[1][1] += FixMul(mx.transform[0][1], FX_SIN20);
    }

    pfc->pgin->param.newtrans.transformMatrix = &mx;

// FIXEDSQRT2 is good as pixel diameter for all practical purposes
// according to EliK, LenoxB and JeanP [bodind]

    if ( pfc->bVertical )
    {
    //
    // keep these values for later
    //
        pfc->mxn = mx;
        pfc->pointSize = pfc->pgin->param.newtrans.pointSize;

    // new comment:
    // When we rotate dbcs characters we do not want to deform them,
    // we want to leave the natural aspect ratio of these glyphs.
    // For vertical writing the base line for dbcs glyphs that need to be rotated
    // goes through the middle of the glyphs, for sbcs characters stays the same.
    // Shift vector computed below does this job. Also, for older fixed pitch fe
    // fonts, where dbcs glyphs have the w == h and sbcs glyphs have width = w/2 for
    // dbcs and height the same for as for dbcs, these formulas become the old
    // formulas we used to have.

        vCalcXformVertical(pfc);
    }

    pfc->pgin->param.newtrans.pixelDiameter = FIXEDSQRT2;

    pfc->pgin->param.newtrans.usOverScale = pfc->overScale;
    ASSERTDD( pfc->overScale != FF_UNDEFINED_OVERSCALE , "Undefined Overscale\n" );

    if (bClearType == -1) {
        pfc->pgin->param.newtrans.flSubPixel = SP_SUB_PIXEL;
    } else if (bClearType == TRUE)
    {
        pfc->pgin->param.newtrans.flSubPixel = SP_SUB_PIXEL | SP_COMPATIBLE_WIDTH;
    } else {
        pfc->pgin->param.newtrans.flSubPixel = 0;
    }

    pfc->pgin->param.newtrans.traceFunc = (FntTraceFunc)NULL;

    if (pfc->flFontType & FO_SIM_BOLD)
    {
	/* 2% + 1 pixel along baseline, 2% along descender line */
	    pfc->pgin->param.newtrans.usEmboldWeightx = 20;
	    pfc->pgin->param.newtrans.usEmboldWeighty = 20;
	    pfc->pgin->param.newtrans.lDescDev = pfc->lDescDev;
	    pfc->pgin->param.newtrans.bBitmapEmboldening = bBitmapEmboldening;
    }
    else
    {
	    pfc->pgin->param.newtrans.usEmboldWeightx = 0;
	    pfc->pgin->param.newtrans.usEmboldWeighty = 0;
	    pfc->pgin->param.newtrans.lDescDev = 0;
	    pfc->pgin->param.newtrans.bBitmapEmboldening = FALSE;
    }

    pfc->pgin->param.newtrans.bHintAtEmSquare = FALSE;
// now call the rasterizer to acknowledge the new transform

    if ((iRet = fs_NewTransformation(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);

    // try to recover, most likey bad hints, just return unhinted glyph

        if ((iRet = fs_NewTransformNoGridFit(pfc->pgin, pfc->pgout)) != NO_ERR)
        {
           V_FSERROR(iRet);
            return(FALSE);
        }
    }

    if (bBitmapEmboldening && (pfc->flFontType & FO_SIM_BOLD))
    {
        pfc->flXform |= XFORM_BITMAP_SIM_BOLD;
    } else {
        pfc->flXform &= ~XFORM_BITMAP_SIM_BOLD;
    }
    return(TRUE);
}



VOID vQuantizeXform
(
PFONTCONTEXT pfc
);


/******************************Public*Routine******************************\
*
* STATIC bComputeMaxGlyph
*
*
* Effects:
*
* Warnings:
*
* History:
*  04-Dec-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC BOOL
bComputeMaxGlyph (
    PFONTCONTEXT   pfc
    )
{
    VOID vSetGrayState__FONTCONTEXT(FONTCONTEXT *);
    VOID vSetClearTypeState__FONTCONTEXT(FONTCONTEXT *);

    LONG              cxMax,cyMax;

    LONG              yMinN, yMaxN;
    LONG              xMinN, xMaxN;

    LONG              lTmp;
    Fixed             fxMxx,fxMyy;
    BYTE             *pjView = (BYTE *)pfc->pff->pvView;

    sfnt_FontHeader * phead = (sfnt_FontHeader *) (
                      pjView + pfc->ptp->ateReq[IT_REQ_HEAD].dp
                      );

    BYTE * pjOS2 = (pfc->ptp->ateOpt[IT_OPT_OS2].dp)          ?
                   (pjView + pfc->ptp->ateOpt[IT_OPT_OS2].dp) :
                   NULL                                       ;

    ASSERTDD(pjView, "bComputeMaxGlyph, pjView\n");

// get the notional space values

    if (pjOS2 && (pfc->flXform & (XFORM_HORIZ | XFORM_VERT)))
    {
    // win 31 compatibility: we only take the max over win 31 char set.
    // All the glyphs outside this set, if they stand out will get shaved
    // off to match the height of the win31 char subset. Also notice that
    // for nonhorizontal cases we do not use os2 values because shaving
    // only applies to horizontal case, otherwise our bounding box values
    // will not be computed properly for nonhorizontal cases.

        yMinN =  - BE_INT16(pjOS2 + OFF_OS2_usWinAscent);
        yMaxN =    BE_INT16(pjOS2 + OFF_OS2_usWinDescent);
    }
    else
    {
        yMinN = - BE_INT16(&phead->yMax);
        yMaxN = - BE_INT16(&phead->yMin);
    }

    ASSERTDD(yMinN < yMaxN, "yMinN >= yMaxN\n");

    xMinN = BE_INT16(&phead->xMin);
    xMaxN = BE_INT16(&phead->xMax);

    if (pfc->flFontType & FO_SIM_ITALIC)
    {
    // IF there is italic simulation
    //     xMin -> xMin - yMaxN * sin20
    //     xMax -> yMax - yMinN * sin20

        xMinN -= FixMul(yMaxN, FX_SIN20);
        xMaxN -= FixMul(yMinN, FX_SIN20);
    }

    ASSERTDD(xMinN < xMaxN, "xMinN >= xMaxN\n");

    pfc->lEmHtDev = 0; // flag that it has not been computed
    pfc->fxPtSize = 0; // flag that it has not been computed
    pfc->SBCSWidth = 0; // flag that it has not been computed
    pfc->phdmx = NULL; // NULL unless computed otherwise

    if ((pfc->flXform & XFORM_HORIZ) &&
        !(pfc->flXform & XFORM_SINGULAR))  // XX AND YY Only
    {
        sfnt_HorizontalHeader  *phhea;
        ULONG  cHMTX;

        fxMxx = pfc->mx.transform[0][0];
        fxMyy = pfc->mx.transform[1][1];

    // ascender, round up

        yMinN = FixMul(fxMyy, yMinN);
        yMaxN = FixMul(fxMyy, yMaxN);

        if (fxMyy > 0)
        {
        // vdmx table should be consulted if present and used to compute
        // ascender and descender. If this computation can not be done
        // based on vdmx table or if vdmx table is not present simple
        // linear scaling will suffice [bodind].

            vQuantizeXform(pfc);

            if (!(pfc->flXform & XFORM_VDMXEXTENTS)) // COMPUTED FROM VDMX
            {
                pfc->yMin = yMinN;
                pfc->yMax = yMaxN;
            }

            pfc->lAscDev  = - pfc->yMin;
            pfc->lDescDev =   pfc->yMax;
        }
        else // fxMyy < 0
        {
            pfc->lAscDev =    yMinN;
            pfc->lDescDev = - yMaxN;

        // swap yMin and yMax for when the xform flips y coord

            lTmp  = yMinN;
            yMinN = yMaxN;
            yMaxN = lTmp;

            pfc->yMin = yMinN;
            pfc->yMax = yMaxN;

        }

        if (pfc->lEmHtDev == 0)
        {
        // if this value has not been computed in vQuantizeXform routine

            pfc->lEmHtDev = FixMul(fxMyy, pfc->pff->ifi.fwdUnitsPerEm);
            if (pfc->lEmHtDev < 0)
                pfc->lEmHtDev = - pfc->lEmHtDev;
        }

        ASSERTDD(pfc->lEmHtDev >= 0, "lEmHt negative\n");

    // now that em height has been computed, we can compute the
    // pt size on the rendering device. This value will be fed to
    // fs_NewTransformation

        pfc->fxPtSize = LongMulDiv(
                            LTOF16_16(pfc->lEmHtDev), 72,
                            pfc->sizLogResPpi.cy);

        cyMax = pfc->yMax - pfc->yMin;

        if
        (
            (pfc->mx.transform[0][0] == pfc->mx.transform[1][1])  &&
            (pfc->mx.transform[1][1] > 0)
        )
        {
        // caution, do not move this line of code elsewhere for
        // this check has to be made after vQuantizeXform since
        // this function may change the transform, but it has to be
        // made before bGetFastAdvanceWidth or bQueryAdvanceWidths
        // are ever called for these functions check flXform agains
        // XFORM_POSITIVE_SCALE

            pfc->flXform |= XFORM_POSITIVE_SCALE;

        // find the hdmx table, in case of the console fixed pitch font this
        // table may be useful in determining if cxMax needs to be cut off
        // to the advance width of this font

            vFindHdmxTable(pfc); // this could cause an exception:
        }

        phhea = (sfnt_HorizontalHeader *)(
                (BYTE *)pfc->pff->pvView + pfc->ptp->ateReq[IT_REQ_HHEAD].dp
                );
        cHMTX = (ULONG) BE_UINT16(&phhea->numberOf_LongHorMetrics);


    // scale xMin,xMax to device, 28.4 format

        xMinN = FixMul(LTOFX(xMinN), fxMxx);
        xMaxN = FixMul(LTOFX(xMaxN), fxMxx);

        if (fxMxx < 0)
        {
            lTmp  = xMinN;
            xMinN = xMaxN;
            xMaxN = lTmp;
        }

    // I run the experiment on 400 fonts at several sizes. I found
    // that subtracting 2 from xMin and adding 1 to xMax suffices
    // in all situations to prevent any columns from being shaved off.
    // [bodind]

        xMinN = FXTOLFLOOR(xMinN) - 2;
        xMaxN = FXTOLCEILING(xMaxN) + 1;

        pfc->xMin = xMinN;
        pfc->xMax = xMaxN;

        cxMax = xMaxN - xMinN;

    // the direction unit vectors for scaling transforms  are simple
    // if the font is intended for horizontal left to right writing

    //!!! here the check is due to verify that the font is not designed
    //!!! for vertical writing in the notional space [bodind]

        vLToE(&pfc->pteUnitBase.x, (fxMxx > 0) ? 1L : - 1L);
        vLToE(&pfc->pteUnitBase.y, 0L);
        vLToE(&pfc->pteUnitSide.x, 0L);
        vLToE(&pfc->pteUnitSide.y, (fxMyy > 0) ? -1L : 1L); // y axis points down

    // We need to adjust the the glyph origin of singular bitmaps for glyphs
    // when MaxAscent or MaxDescent is negative or zero. The trick is to choose
    // these values so that the "blank" glyph is always included in the
    // rectangle of the text. What this means is that
    //     for m11 > 0 we must have: yT >= -lAsc  && yB <= lDesc
    //     for m11 < 0 we must have: yT >= -lDesc && yB <= lAsc
    // here yB == yT + 1, because blank glyphs has a cy == 1, and
    //     yT == ptlSingularOrigin.y
    // This leads to
    //     for m11 > 0 we must have: - (lAsc + 1)  < yT < lDesc
    //     for m11 < 0 we must have: - (lDesc + 1) < yT < lAsc
    // One point that would satisfy both of these conditions is
    // the midpoint between the endpoints. Thus, before any rouding:
    //     for m11 > 0 we have: yT =  (lDesc- lAsc - 1)/2
    //     for m11 < 0 we have: yT = -(lDesc- lAsc - 1)/2
    // where divide by 2 is not integer divide but ordinary real number divide.
    // The proper rounding is done ala KirkO, that is, add 1/2 and take a
    // flor:
    //     for m11 > 0 we have: yT = FLOOR((lDesc - lAsc - 1)/2 + 1/2)
    //     for m11 < 0 we have: yT = FLOOR((lAsc - lDesc - 1)/2 + 1/2)
    // That is:
    //     for m11 > 0 we have: yT = FLOOR(lDesc - lAsc)/2)
    //     for m11 < 0 we have: yT = FLOOR(lAsc - lDesc)/2)
    // Now floor is computed correctly (on signed nubmers) by implementing
    // divide by 2 as >> 1 operation:

        pfc->ptlSingularOrigin.x = 0;

        if ((pfc->lAscDev <= 0) || (pfc->lDescDev <= 0))
        {
            if (pfc->mx.transform[1][1] > 0)
            {
                pfc->ptlSingularOrigin.y =
                    (pfc->lDescDev - pfc->lAscDev) >> 1;
            }
            else
            {
                pfc->ptlSingularOrigin.y =
                    (pfc->lAscDev - pfc->lDescDev) >> 1;
            }
        }
        else
        {
            pfc->ptlSingularOrigin.y = 0;
        }

    }
    else // nontrivial transformation
    {
        POINTL   aptl[4];
        POINTFIX aptfx[4];
        BOOL     bOk;
        INT      i;
        FIX      xMinD, xMaxD, yMinD, yMaxD; // device space values;

    // add little extra space to be safe

        i = (INT)(pfc->pff->ffca.ui16EmHt / 64);
        yMaxN +=  i; // adds about 1.7% to ht
        yMinN -=  i; // adds about 1.7% to ht

    // set up the input array, the four corners of the maximal bounding
    // box in the notional coords

        aptl[0].x = xMinN;       //  tl.x
        aptl[0].y = yMinN;       //  tl.y

        aptl[1].x = xMaxN;       //  tr.x
        aptl[1].y = yMinN;       //  tr.y

        aptl[2].x = xMinN;       //  bl.x
        aptl[2].y = yMaxN;       //  bl.y

        aptl[3].x = xMaxN;       //  br.x
        aptl[3].y = yMaxN;       //  br.y

    // xform to device coords with 28.4 precision:

        // !!! [GilmanW] 27-Oct-1992
        // !!! Should change over to engine user object helper functions
        // !!! instead of the fontmath.cxx functions.

        bOk = bFDXform(&pfc->xfm, aptfx, aptl, 4);

        if (!bOk) { RETURN("TTFD!_:bFDXform\n", FALSE); }

        xMaxD = xMinD = aptfx[0].x;
        yMaxD = yMinD = aptfx[0].y;

        for (i = 1; i < 4; i++)
        {
            if (aptfx[i].x < xMinD)
                xMinD = aptfx[i].x;
            if (aptfx[i].x > xMaxD)
                xMaxD = aptfx[i].x;
            if (aptfx[i].y < yMinD)
                yMinD = aptfx[i].y;
            if (aptfx[i].y > yMaxD)
                yMaxD = aptfx[i].y;
        }

        yMinD = FXTOLFLOOR(yMinD)   ;
        yMaxD = FXTOLCEILING(yMaxD) ;
        xMinD = FXTOLFLOOR(xMinD)   ;
        xMaxD = FXTOLCEILING(xMaxD) ;

        cxMax = xMaxD - xMinD;
        cyMax = yMaxD - yMinD;

    // now re-use aptl to store e1 and -e2, base and side unit
    // vectors in the notional space.
    //!!! This may be wrong if have font for
    //!!! right to left or vert writing [bodind]

        aptl[0].x = 1;    // base.x
        aptl[0].y = 0;    // base.y

        aptl[1].x =  0;   // side.x
        aptl[1].y = -1;   // side.y

        // !!! [GilmanW] 27-Oct-1992
        // !!! Should change over to engine user object helper functions
        // !!! instead of the fontmath.cxx functions.

        bOk = bXformUnitVector (
                  &aptl[0],          // IN,  incoming unit vector
                  &pfc->xfm,         // IN,  xform to use
                  &pfc->vtflBase,    // OUT, xform of the incoming unit vector
                  &pfc->pteUnitBase, // OUT, *pptqXormed/|*pptqXormed|, POINTE
                  (pfc->flFontType & FO_SIM_BOLD) ? &pfc->ptqUnitBase : NULL, // OUT, *pptqXormed/|*pptqXormed|, POINTQF
                  &pfc->efBase       // OUT, |*pptqXormed|
                  );

        bOk &= bXformUnitVector (
                  &aptl[1],          // IN,  incoming unit vector
                  &pfc->xfm,         // IN,  xform to use
                  &pfc->vtflSide,    // OUT, xform of the incoming unit vector
                  &pfc->pteUnitSide, // OUT, *pptqXormed/|*pptqXormed|, POINTE
                  (pfc->flFontType & FO_SIM_BOLD) ? &pfc->ptqUnitSide : NULL, // OUT, *pptqXormed/|*pptqXormed|, POINTQF
                  &pfc->efSide       // OUT, |*pptqXormed|
                  );

        if (!bOk) { RETURN("TTFD!_:bXformUnitVector\n", FALSE); }

        pfc->lAscDev  = -fxLTimesEf(&pfc->efSide,yMinN);
        pfc->lDescDev =  fxLTimesEf(&pfc->efSide,yMaxN);

        pfc->lAscDev  = FXTOLCEILING(pfc->lAscDev) ;
        pfc->lDescDev = FXTOLCEILING(pfc->lDescDev);

        pfc->ptfxTop.x    = lExL(pfc->pteUnitSide.x, LTOFX(pfc->lAscDev));
        pfc->ptfxTop.y    = lExL(pfc->pteUnitSide.y, LTOFX(pfc->lAscDev));
        pfc->ptfxBottom.x = lExL(pfc->pteUnitSide.x, -LTOFX(pfc->lDescDev));
        pfc->ptfxBottom.y = lExL(pfc->pteUnitSide.y, -LTOFX(pfc->lDescDev));

        if ((yMinN >= 0) || (yMaxN <= 0) || ((pfc->lAscDev + pfc->lDescDev) < 3))
        {
        // Either all the glyphs are above the base line or all the glyphs
        // are below the baseline.  In either case adjust the origin for
        // the singular glyph bitmap.
        // Compute the midpoint between asc and desc in notional space:
        // lAverage = ROUND(-(yMaxN+yMinN)/2)

            LONG lAverage =  (-yMaxN -yMinN + 1) >> 1;

            pfc->ptlSingularOrigin.x = fxLTimesEf(&pfc->vtflSide.x,lAverage);
            pfc->ptlSingularOrigin.x = FXTOLROUND(pfc->ptlSingularOrigin.x);

            pfc->ptlSingularOrigin.y = fxLTimesEf(&pfc->vtflSide.y,lAverage);
            pfc->ptlSingularOrigin.y = FXTOLROUND(pfc->ptlSingularOrigin.y);

        }
        else
        {
            pfc->ptlSingularOrigin.x = 0;
            pfc->ptlSingularOrigin.y = 0;
        }


    // finally store the results:

        pfc->xMin        = xMinD;
        pfc->xMax        = xMaxD;
        pfc->yMin        = yMinD;
        pfc->yMax        = yMaxD;

    // compute em ht in pixels and points


        pfc->fxPtSize = fxPtSize(pfc);

        /* compute pfc->lEmHtDev from pfc->fxPtSize to make sure values are coherent */

        {
            Fixed fxScale;

            fxScale = LongMulDiv(pfc->fxPtSize, pfc->sizLogResPpi.cy, 72);
            pfc->lEmHtDev = (uint16)ROUNDFIXTOINT(fxScale);
        }
    }

// compute corrections

    if (pfc->flFontType & FO_SIM_BOLD)
    {
        vCalcEmboldSize(pfc);
    }
    else
    {
        pfc->dBase = 0;
    }

// if this is one of the almost singular transforms, reject this

    if ((cxMax == 0) || (cyMax == 0))
    {
        RETURN("TTFD! almost singular xform, must fail\n", FALSE);
    }


    if (pfc->flFontType & FO_SIM_BOLD)
    {
        /* we are on the safe side by adding dBase to both cxMax and cyMax */
        cxMax += pfc->dBase;
        cyMax += pfc->dBase;
    }

// we can liberally extend cxMax to the byte boundary, this is not
// going to change memory requirements of the system.

    cxMax = ((cxMax + 7) & ~7);
    pfc->cxMax = cxMax;

// now we have to determine how big in memory is the biggest glyph.
// let us remember that the rasterizer needs little more storage than the
// the engine does, because rasterizer will want dword aligned rows rather
// than byte aligned rows

    {
        DWORDLONG lrg;

    // why am I dword instead byte extending cxMax? because that is
    // how much rasterizer will want for this bitmap

        ULONG          cjMaxScan = ((cxMax + 31) & ~31) / 8;
        lrg =  UInt32x32To64(cjMaxScan, cyMax);
        if (lrg > ULONG_MAX)
        {
        // the result does not fit in 32 bits, alloc memory will fail
        // this is too big to digest, we fail to open fc

            RETURN("TTFD! huge pt size, must fail\n", FALSE);
        }
    }

// We now have all the informaiton to set the gray bit
// appropriately.

    if (pfc->flFontType & FO_CLEARTYPE_X)
    {
        vSetClearTypeState__FONTCONTEXT(pfc);
    }
    else
    {
        vSetGrayState__FONTCONTEXT(pfc);
    }

    ASSERTDD(pfc->flFontType & FO_CHOSE_DEPTH,
        "We haven't decided about pixel depth\n"
    );

    pfc->cjGlyphMax = CJGD(cxMax,cyMax,pfc);

// See if this is shell font and we want to hack max neg a and c spaces

    if (
        (pfc->pff->ffca.fl & FF_NEW_SHELL_FONT) &&
        ((pfc->flXform & (XFORM_HORIZ | XFORM_POSITIVE_SCALE)) == (XFORM_HORIZ | XFORM_POSITIVE_SCALE))
    )
    {
        pfc->flXform |= XFORM_MAX_NEG_AC_HACK;
    }

    return TRUE;
}

//--------------------------------------------------------------------
// LONG iHipot(x, y)
//
// This routine returns the hypoteneous of a right triangle.
//
// FORMULA:
//          use sq(x) + sq(y) = sq(hypo);
//          start with MAX(x, y),
//          use sq(x + 1) = sq(x) + 2x + 1 to incrementally get to the
//          target hypotenouse.
//
// History:
//  Mon 07-Feb-1994 -by- Bodin Dresevic [BodinD]
//  update:   update to use Fixed 16.16
//   10-Feb-1993    -by-    Kent Settle     (kentse)
//  Stole from RASDD.
//   21-Aug-1991    -by-    Lindsay Harris  (lindsayh)
//  Cleaned up UniDrive version, added comments etc.
//--------------------------------------------------------------------


/*

      Algorithm analysis by DChinn :

      After a bit of incorrect attempts, I figured it all out.  It turns out that
    the if h is the correct hypotenuse, then the routine returns the
    ceiling of h.  Here's the analysis:


    Let h = the correct hypotenuse
        h = sqrt{x^2 + y^2}

        x and y are integers.

    Let h' = the value returned by the algorithm

                      { d-1                        }
        h' = y +  min { sum [ 2(y+i) + 1 ]  >= x^2 }
                  d>0 { i=0                        }

                 { d-1                        }
    Let d' = min { sum [ 2(y+i) + 1 ]  >= x^2 }
             d>0 { i=0                        }

    Consider the smallest d for which

            d-1
            sum [ 2(y+i) + 1 ]  >= x^2  .
            i=0

            d-1                d-1
            sum (2y + 1)  +  2 sum i   >= x^2
            i=0                i=0

               2yd + d    + (d-1)d   - x^2 >= 0

            d^2 + 2yd - x^2 >= 0        (solve this equation as if it were an equality)

                  -2y +/- sqrt{ (2y)^2 - 4 * 1 * (-x^2) }
            d  =  ---------------------------------------
                                    2
            d' =  ceiling (d)

            d' =  ceiling (  -y +/- sqrt{ y^2 + x^2 }  )

               =  -y + ceiling ( sqrt{ y^2 + x^2 } )     (the minus in +/- is impossible)

    So, h' = y +  (-y) + ceiling ( sqrt{ y^2 + x^2 } )
           = ceiling ( sqrt{ y^2 + x^2 } )

    The loop invariant: Since delta is incremented by 2*hypo+1 in each iteration and
    (hypo+1)^2 = hypo^2 + (2*hypo + 1), then at the end of each iteration, a
    triangle with sides y, sqrt{delta}, and hypo is always a right triangle.

    Note that there is no assumption in the above that y >= x, so
    that assumption is for performance reasons only.

  */

STATIC ULONG iHipot(LONG x, LONG y)
{
    ULONG  hypo;         /* Value to calculate */
    ULONG  delta;        /* Used in the calculation loop */
    ULONG  target;       /* Loop limit factor */
	USHORT  shift = 0;

// quick exit for frequent trivial cases [bodind]

    if (x < 0)
        x = -x;

    if (y < 0)
        y = -y;

    if (x == 0)
        return y;

    if (y == 0)
        return x;

    /* avoid overflow */
    while ((x > 0x8000L) || (y > 0x8000L))
    {
        x >>= 1;
        y >>= 1;
        shift ++;
    }

    if (x > y)
    {
        hypo = x;
        target = y * y;
    }
    else
    {
        hypo = y;
        target = x * x;
    }

    for (delta = 0; delta < target; hypo++)
        delta += ((hypo << 1) + 1);

    return (hypo << shift);
}


/******************************Public*Routine******************************\
*
* bSingularXform
*
* Checks whether this is one of the xforms that the rasterizer is known
* to choke on. Those are the transforms that generate very
* narrow fonts (less than 0.5 pixels/em wide or tall). For fonts that
* allow only integer widths/em and heights/em this number will get rounded
* down to zero and generate divide by zero exception in the preprogram.
* We will flag such transforms as XFORM_SINGULAR and return empty bitmaps
* and outlines for them shortcircuiting the rasterizer which would die on
* us.
*
* Actually, for compatibility reasons we will have to change
* this plan a little bit. It turns out that
* win 31 does not allow for the rasterization of a font that is less
* than 2 pixels tall (ie. the Em Ht of the font in device space must be
* >= 2 pixels). If a request comes down to realize a font that is tall less
* than 2 pixels we will simply have to substitute the transform by a scaled
* transform that will produce a font of height two pixels. We will still keep
* our singular transform code in case a font is requested that is singular in
* X direction, that is, too narrow.
*
* History:
*  22-Sep-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

// smallest ppem allowed under  win31:

#define WIN31_PPEM_CUTOFF 2

STATIC VOID vCheckForSingularXform (PFONTCONTEXT  pfc) // OUT
{

    register LONG  lEmHtDev;

    Fixed fxEmHtDev;
    Fixed fxEmHtNot = LTOF16_16(pfc->pff->ffca.ui16EmHt);
    Fixed fxScale;
    Fixed fxEmWidthDev;

// xforms are conforming left multiplication rule v' = v * M i.e.:
//
// (x,0) -> x(m00,m01)
// (0,y) -> y(m10,m11)
//
// compute length of (0,Em) after it gets transformed to device space:
// We need to have fxEmHtDev computed with high precission, for we
// shall be using it to divide the original transform by.
// We want to avoid division by zero when that is not neccessary.

    fxEmHtDev = FixMul(
                   iHipot(pfc->mx.transform[1][1],pfc->mx.transform[1][0]),
                   fxEmHtNot
                   );

    lEmHtDev = F16_16TOLROUND(fxEmHtDev);
    if (lEmHtDev < WIN31_PPEM_CUTOFF) // too small a transform:
    {
        pfc->flXform |= XFORM_2PPEM;

    // according to win31 algorithm, we must scale this xform so that the
    // resulting xform will produce font that is 2 pels tall.
    // That is, the new transform M' is going to be
    //
    // M' = (WIN31_PPEM_CUTOFF / lEmHtDev) * M
    //
    // so that the following equation is satisfied:
    //
    // |(0,EmNotional) * M'| == WIN31_PPEM_CUTOFF == 2;

        if (pfc->flXform & XFORM_HORIZ)
        {
        // in this special case the above formula for M' becomes:
        //
        //                                         | m00/|m11|     0     |
        // M' = (WIN31_PPEM_CUTOFF / EmNotional) * |                     |
        //                                         |   0        sgn(m11) |

#define LABS(x) ((x)<0)?(-x):(x)

            Fixed fxAbsM11 = LABS(pfc->mx.transform[1][1]);
            Fixed fxAbsM00 = LABS(pfc->mx.transform[0][0]);

            LONG lSgn11 = (pfc->mx.transform[1][1] >= 0) ? 1 : -1;
            LONG lSgn00 = (pfc->mx.transform[0][0] >= 0) ? 1 : -1;

            fxScale = FixDiv(WIN31_PPEM_CUTOFF,pfc->pff->ffca.ui16EmHt);

            pfc->mx.transform[1][1] = fxScale;
            if (fxAbsM00 != fxAbsM11)
            {
                pfc->mx.transform[0][0] = LongMulDiv(fxScale,fxAbsM00,fxAbsM11);
            }
            else
            {
                pfc->mx.transform[0][0] = fxScale;
            }

        // fix the signs if needed:

            if (lSgn11 < 0)
                pfc->mx.transform[1][1] = - pfc->mx.transform[1][1];

            if (lSgn00 < 0)
                pfc->mx.transform[0][0] = - pfc->mx.transform[0][0];
        }
        else
        {
        // general case, compute scale (which involves division) once,
        // and use it for all four members of the matrix:

            fxScale = FixDiv(LTOF16_16(WIN31_PPEM_CUTOFF),fxEmHtDev);

            pfc->mx.transform[0][0] = FixMul(pfc->mx.transform[0][0],fxScale);
            pfc->mx.transform[0][1] = FixMul(pfc->mx.transform[0][1],fxScale);
            pfc->mx.transform[1][0] = FixMul(pfc->mx.transform[1][0],fxScale);
            pfc->mx.transform[1][1] = FixMul(pfc->mx.transform[1][1],fxScale);

        // In general case must also fix the original EFLOAT xform because
        // it is going to be used for computation of extents, max glyphs etc.

            FFF(pfc->xfm.eM11, +pfc->mx.transform[0][0]);
            FFF(pfc->xfm.eM22, +pfc->mx.transform[1][1]);
            FFF(pfc->xfm.eM12, -pfc->mx.transform[0][1]);
            FFF(pfc->xfm.eM21, -pfc->mx.transform[1][0]);
        }
    }

// Now check if the transform is singular in x. To do this
// compute length of (Em,0) after it gets transformed to device space:

    fxEmWidthDev = FixMul(
                   iHipot(pfc->mx.transform[0][0],pfc->mx.transform[0][1]),
                   fxEmHtNot
                   );

    if (fxEmWidthDev <= ONEHALFFIX)
    {
    // We are in trouble, we shall have to lie to the engine:

        pfc->flXform |= XFORM_SINGULAR;
    }
}




/******************************Public*Routine******************************\
*
* bNewXform:
*
* converts the transform matrix to the form the rasterizer likes
* and computes the global (per font) sizes that are relevant for this
* transform.
*
* History:
*  28-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


STATIC BOOL
bNewXform (
    FONTOBJ      *pfo,
    PFONTCONTEXT pfc             // OUT
    )
{
// do not write immediately to pfc->mx until sure that all bFloatToL
// have succeeded. You do not want to leave this function and leave
// fc in a dirty state

    Fixed fx00, fx01, fx10, fx11;

// Get the transform elements.

    XFORMOBJ_iGetXform(FONTOBJ_pxoGetXform(pfo),&pfc->xfm);

    if (
        !bFloatToL(pfc->xfm.eM11, &fx00) ||
        !bFloatToL(pfc->xfm.eM22, &fx11) ||
        !bFloatToL(pfc->xfm.eM12, &fx01) ||
        !bFloatToL(pfc->xfm.eM21, &fx10)
       )
        RET_FALSE("TTFD!_bFloatToL failed\n");

// we are fine now, can not fail after this:

    pfc->mx.transform[0][0]  = fx00;
    pfc->mx.transform[1][1]  = fx11;
    pfc->mx.transform[0][1]  = -fx01;
    pfc->mx.transform[1][0]  = -fx10;

// check if this is one of the sing xform where one row or column is zero:
// It is important to do this after bFloatToL, some floating numbers can be
// so small that can only be represented as zeros in 16.16 format

    if
    (
        !(fx00 | fx01) ||
        !(fx00 | fx10) ||
        !(fx11 | fx10) ||
        !(fx11 | fx01)
    )
    {
        ASSERTDD(1, "We are screwed by this xform\n");
        return FALSE;
    }

// components in the projective space are zero

// ClaudeBe, from the client interface Doc :
// Please note that although the third column of the matrix is defined as Fixed numbers
// you will actually need to use  Fract numbers in that column. The higher resolution provided
// by Fracts is required to change the perspective of a glyph. Fracts are 2.30 fixed point numbers.

    pfc->mx.transform[2][2] = ONEFRAC;
    pfc->mx.transform[0][2] = (Fixed)0;
    pfc->mx.transform[1][2] = (Fixed)0;
    pfc->mx.transform[2][0] = (Fixed)0;
    pfc->mx.transform[2][1] = (Fixed)0;

// set the flags for the transform:

    pfc->flXform = 0;

    if ((fx01 == 0) && (fx10 == 0))
        pfc->flXform |= XFORM_HORIZ;

    if ((fx00 == 0) && (fx11 == 0))
        pfc->flXform |= XFORM_VERT;

// important to check for "singular transform"
// (ie. request for too small a font realization) after flags have been set

    vCheckForSingularXform(pfc);

// no glyph metrics computation is valid yet

    vInitGlyphState(&pfc->gstat);

// no memory to rasterize a glyph or produce glyph outline has been allocated

    pfc->gstat.pv = NULL;

// now get the sizes for this transform

    return bComputeMaxGlyph(pfc);
}


/******************************Public*Function*****************************\
* bFToL                                                                    *
*                                                                          *
* Convert an IEEE floating point number to a long integer.                 *
*                                                                          *
* History:                                                                 *
*
*  Thu 29-Mar-2001 -by- Mikhail Leonov [MLeonov]
* update:
*   changed <= 23 to < 23, otherwise numbers like 142.5 get converted to 0
*
*  Sun 17-Nov-1991 -by- Bodin Dresevic [BodinD]
* update:
*
* changed the line
*    if (flType & CVT_TO_FIX) lExp += 4;
* to
*    if (flType & CVT_TO_FIX) lExp += 16;
* to reflect that we are converting to 16.16 format rather than to 28.4
*
*
*  03-Jan-1991 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

STATIC BOOL bFloatToL(FLOATL e, PLONG pl)
{

    LONG lEf, lExp;

    lEf = (*((LONG *) &e));        // convert type EFLOAT to LONG

// if exponent < 0 then convert to 0 and return true

    lExp = ((lEf >> 23) & 0xff) -127;

    lExp += 16; // this is the only line I changed [bodind]

    if (lExp < 0)
    {
        *pl = 0;
        return(TRUE);
    }

// if exponent < 23 then
//     lMantissa = (lEf & 0x7fffff) | 0x800000;
//         l = ((lMantissa >> (23 - lExponent -1)) + 1) >> 1;

    if (lExp < 23)
    {
        *pl = (lEf & 0x80000000) ?
             -(((((lEf & 0x7fffff) | 0x800000) >> (23 - lExp -1)) + 1) >> 1) :
             ((((lEf & 0x7fffff) | 0x800000) >> (23 - lExp -1)) + 1) >> 1;
        return(TRUE);
    }

// if exponent <= 30 then
// lMantissa = (lEf & 0x7fffff) | 0x800000;
// l = lMantissa << (lExponent - 23);

    if (lExp <= 30)
    {
        *pl = (lEf & 0x80000000) ?
            -(((lEf & 0x7fffff) | 0x800000) << (lExp - 23)) :
            ((lEf & 0x7fffff) | 0x800000) << (lExp - 23);
        return(TRUE);
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* lFFF = long-float-from-fixed
*
* input: 16.16 representation
* output: LONG that is bit equivalent of the 32-bit ieee float
*         equal to the fix point number. To recover the float
*   the FLOAT representation you simply cast the bits as a float
*   that is
*
*   FLOAT e;
*
*       *(LONG*)&e = lFFF(n16Dot16)
*
* History:
*  Tue 03-Jan-1995 14:33:35 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

LONG lFFF(LONG l)
{
#if defined(_AMD64_) || defined(_IA64_)
    FLOAT e = ((FLOATL) l)/((FLOATL) 65536);
    return(*(LONG*)&e);
#elif defined(_X86_)
    int i;                              // shift count
    unsigned k;                         // significand

    if (k = (unsigned) l)
    {
        if (l < 0)
            k = (unsigned) -l;          // significand is positive, sign
                                        // bit accounted for later
        i = 0;
        if (k < (1 << 16)) {            // put the number in the
            k <<= 16;                   // range 2^31 <= k < 2^32
            i += 16;                    // by shifting to left, put
        }                               // shift count in i
        if (k < (1 << 24)) {
            k <<= 8;
            i += 8;
        }
        if (k < (1 << 28)) {
            k <<= 4;
            i += 4;
        }
        if (k < (1 << 30)) {
            k <<= 2;
            i += 2;
        }
        if (k < (1 << 31)) {
            k <<= 1;
            i += 1;
        }
                                        // at this point
                                        // i = 31-floor(log2(abs(l)))

        k += (1 << 7);                  // about to shift out
                                        // the lowest 8-bits
                                        // account for their effect by
                                        // rounding. This has the effect
                                        // that numbers are rounded away
                                        // from zero as opposed to rounding
                                        // stricktly up
        k >>= 8;                        // shift out the lowest 8 bits

        k &= ((1<<23) - 1);             // 2^23 bit is implicit so mask it out
        k |= (0xff & (142 - i)) << 23;  // set exponent at correct place
        if (l < 0)                      // if original number was negative
            k |= (1<<31);               // then set the sign bit
    }
    return((LONG) k);
#endif
}


#if DBG

/******************************Public*Routine******************************\
*
* VOID vFSError(FS_ENTRY iRet);
*
*
* Effects:
*
* Warnings:
*
* History:
*  25-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID vFSError(FS_ENTRY iRet)
{
    PCHAR psz;

    switch (iRet)
    {
        case BAD_CALL_ERR:
            psz =  "BAD_CALL_ERR";
            break;
        case BAD_CLIENT_ID_ERR:
            psz =  "BAD_CLIENT_ID_ERR";
            break;
        case BAD_MAGIC_ERR:
            psz =  "BAD_MAGIC_ERR";
            break;
        case BAD_START_POINT_ERR:
            psz =  "BAD_START_POINT_ERR";
            break;
        case CLIENT_RETURNED_NULL:
            psz =  "CLIENT_RETURNED_NULL";
            break;
        case CONTOUR_DATA_ERR:
            psz =  "CONTOUR_DATA_ERR";
            break;
        case GLYPH_INDEX_ERR:
            psz =  "GLYPH_INDEX_ERR";
            break;
        case INSTRUCTION_SIZE_ERR:
            psz =  "INSTRUCTION_SIZE_ERR";
            break;
        case INVALID_GLYPH_INDEX:
            psz =  "INVALID_GLYPH_INDEX";
            break;
        case MISSING_SFNT_TABLE:
            psz =  "MISSING_SFNT_TABLE";
            break;
        case NULL_INPUT_PTR_ERR:
            psz =  "NULL_INPUT_PTR_ERR";
            break;
        case NULL_KEY_ERR:
            psz =  "NULL_KEY_ERR";
            break;
        case NULL_MEMORY_BASES_ERR:
            psz =  "NULL_MEMORY_BASES_ERR";
            break;
        case NULL_OUTPUT_PTR_ERR:
            psz =  "NULL_OUTPUT_PTR_ERR";
            break;
        case NULL_SFNT_DIR_ERR:
            psz =  "NULL_SFNT_DIR_ERR";
            break;
        case NULL_SFNT_FRAG_PTR_ERR:
            psz =  "NULL_SFNT_FRAG_PTR_ERR";
            break;
        case OUT_OFF_SEQUENCE_CALL_ERR:
            psz =  "OUT_OFF_SEQUENCE_CALL_ERR";
            break;
        case OUT_OF_RANGE_SUBTABLE:
            psz =  "OUT_OF_RANGE_SUBTABLE";
            break;
        case POINTS_DATA_ERR:
            psz =  "POINTS_DATA_ERR";
            break;
        case POINT_MIGRATION_ERR:
            psz =  "POINT_MIGRATION_ERR";
            break;
        case SCAN_ERR:
            psz =  "SCAN_ERR";
            break;
        case SFNT_DATA_ERR:
            psz =  "SFNT_DATA_ERR";
            break;
        case TRASHED_MEM_ERR:
            psz =  "TRASHED_MEM_ERR";
            break;
        case TRASHED_OUTLINE_CACHE:
            psz =  "TRASHED_OUTLINE_CACHE";
            break;
        case UNDEFINED_INSTRUCTION_ERR:
            psz =  "UNDEFINED_INSTRUCTION_ERR";
            break;
        case UNKNOWN_CMAP_FORMAT:
            psz =  "UNKNOWN_CMAP_FORMAT";
            break;
        case UNKNOWN_COMPOSITE_VERSION:
            psz =  "UNKNOWN_COMPOSITE_VERSION";
            break;
        case VOID_FUNC_PTR_BASE_ERR:
            psz =  "VOID_FUNC_PTR_BASE_ERR";
            break;
        case SBIT_COMPONENT_MISSING_ERR:
            psz =  "SBIT_COMPONENT_MISSING_ERR";
            break;
        case TRACE_FAILURE_ERR:
            psz = "Trace_Failure_Error";
            break;
        case DIV_BY_0_IN_HINTING_ERR:
            psz = "DIV_BY_0_IN_HINTING_ERR";
            break;
        case MISSING_ENDF_ERR:
            psz = "MISSING_ENDF_ERR";
            break;
        case MISSING_EIF_ERR:
            psz = "MISSING_EIF_ERR";
            break;
        case INFINITE_RECURSION_ERR:
            psz = "INFINITE_RECURSION_ERR";
            break;
        case INFINITE_LOOP_ERR:
            psz = "INFINITE_LOOP_ERR";
            break;
        case FDEF_IN_GLYPHPGM_ERR:
            psz = "FDEF_IN_GLYPHPGM_ERR";
            break;
        case IDEF_IN_GLYPHPGM_ERR:
            psz = "IDEF_IN_GLYPHPGM_ERR";
            break;
        case JUMP_BEFORE_START_ERR:
            psz = "JUMP_BEFORE_START_ERR";
            break;
        case RAW_NOT_IN_GLYPHPGM_ERR:
            psz = "RAW_NOT_IN_GLYPHPGM_ERR";
            break;	
        case INSTRUCTION_ERR:
            psz = "INSTRUCTION_ERR";
            break;
        case SECURE_STACK_UNDERFLOW:
            psz = "SECURE_STACK_UNDERFLOW";
            break;
        case SECURE_STACK_OVERFLOW:
            psz = "SECURE_STACK_OVERFLOW";
            break;
        case SECURE_POINT_OUT_OF_RANGE:
            psz = "SECURE_POINT_OUT_OF_RANGE";
            break;
        case SECURE_INVALID_STACK_ACCESS:
            psz = "SECURE_INVALID_STACK_ACCESS";
            break;
        case SECURE_FDEF_OUT_OF_RANGE:
            psz = "SECURE_FDEF_OUT_OF_RANGE";
            break;
        case SECURE_ERR_FUNCTION_NOT_DEFINED:
            psz = "SECURE_ERR_FUNCTION_NOT_DEFINED";
            break;
        case SECURE_INVALID_ZONE:
            psz = "SECURE_INVALID_ZONE";
            break;
        case SECURE_INST_OPCODE_TO_LARGE:
            psz = "SECURE_INST_OPCODE_TO_LARGE";
            break;
        case SECURE_EXCEEDS_INSTR_DEFS_IN_MAXP:
            psz = "SECURE_EXCEEDS_INSTR_DEFS_IN_MAXP";
            break;
        case SECURE_STORAGE_OUT_OF_RANGE:
            psz = "SECURE_STORAGE_OUT_OF_RANGE";
            break;
        case SECURE_CONTOUR_OUT_OF_RANGE:
            psz = "SECURE_CONTOUR_OUT_OF_RANGE";
            break;
        case SECURE_CVT_OUT_OF_RANGE:
            psz = "SECURE_CVT_OUT_OF_RANGE";
            break;
        case SECURE_UNITIALIZED_ZONE:
            psz = "SECURE_UNITIALIZED_ZONE";
            break;	
        default:
            psz = "UNKNOWN FONT SCALER ERROR";
                break;
    }
    TtfdDbgPrint ("\n Rasterizer Error: 0x%lx, %s \n", iRet, psz);

}


#endif


/******************************Public*Routine******************************\
*
* fxPtSize
*
* Effects: computes the size in points for this font realization
*
* History:
*  06-Aug-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC LONG fxPtSize(PFONTCONTEXT pfc)
{
// This is done as follows:
//
// Transform
// (0, ui16EmHt) to device (pixel) space.
// Let us say that the vector obtained is (xEm, yEm).
// Then, ptSize should be computed as
// ptSize =  72 * sqrt((xEm/xRes)^2 + (yEm/yRes)^2);

// expanding here a bit we get:
// ptSize =  72 * ui16EmHt * sqrt((mx10/xRes)^2 + (mx11/yRes)^2);

	Fixed x,y;
    LONG  lEmHtX72 = (LONG)(72 * pfc->pff->ffca.ui16EmHt);

    x = LongMulDiv(lEmHtX72,pfc->mx.transform[1][0],pfc->sizLogResPpi.cx);
    y = LongMulDiv(lEmHtX72,pfc->mx.transform[1][1],pfc->sizLogResPpi.cy);
    return iHipot(x,y);
}


//
// this is win31 code intended as a comment for our code:
//

#ifdef THIS_IS_WIN31_CODE_INTENDED_AS_COMMENT

      // Find out if a width Table is available
    if (pfnt->ulHdmxPos && !(pfc->fStatus & FD_MORE_THAN_STRETCH) && pfc->Mx11 == pfc->Mx00)
    {
      unsigned    i;
      HDMXHEADER  FAR *pHdmx;
      HDMXTABLE   FAR *pHdmxTable;

      if (pHdmx = (HDMXHEADER  FAR *) SfntReadFragment (pfc->fgi.clientID, pfnt->ulHdmxPos, pfnt->uHdmxSize))
      {
        if (pHdmx->Version == 0)
        {
          pHdmxTable = pHdmx->HdmxTable;

            // Init the the glyph count
          pfc->cHdmxRecord = (unsigned) SWAPL (pHdmx->cbSizeRecord);

           // look through the table if the size is available
          for (i = 0; i < (unsigned) SWAPW (pHdmx->cbRecord); i++, pHdmxTable = (HDMXTABLE FAR *)((char FAR *) pHdmxTable + pfc->cHdmxRecord))
            if (pfc->Mx11 == (int) pHdmxTable->ucEmY)
            {
              pfc->ulHdmxPosTable = pfnt->ulHdmxPos + (i * pfc->cHdmxRecord + sizeof (HDMXHEADER));
              break;
            }
        }
        ReleaseSFNT (pHdmx);
      }
    }

#endif // THIS_IS_WIN31_CODE_INTENDED_AS_COMMENT

STATIC VOID vFindHdmxTable(PFONTCONTEXT pfc)
{
    HDMXHEADER  *phdr = (HDMXHEADER  *)(
        (pfc->ptp->ateOpt[IT_OPT_HDMX].dp)                                   ?
        ((BYTE *)pfc->pff->pvView + pfc->ptp->ateOpt[IT_OPT_HDMX].dp) :
        NULL
        );

    UINT         cRecords;
    ULONG        cjRecord;

    HDMXTABLE    *phdmx, *phdmxEnd;
    LONG         yEmHt = pfc->lEmHtDev;

// assume failure, no hdmx table can be used:

    pfc->phdmx = NULL;

// first see if hdmx table is there at all:

    if (!phdr || !pfc->ptp->ateOpt[IT_OPT_HDMX].cj)
        return;

// if table is there but not necessary since the whole font scales
// linearly at all sizes, we will ignore it:

    //(phead->flags & SWAP(2))
    //    return;

// if transform is not such as to allow the use of hdmx table, return;

    ASSERTDD(pfc->flXform & XFORM_POSITIVE_SCALE,
        "vFindHdmxTable, bogus xform\n");

// if this is the version that we do not understand, return

    if (phdr->Version != 0)
        return;

    cRecords = BE_UINT16(&phdr->cRecords);
    cjRecord = (ULONG)SWAPL(phdr->cjRecord);

    ASSERTDD((cjRecord & 3) == 0, "cjRecord\n");

// if yEmHt > 255, can not fit in the byte, so there is no need to
// to search for the hdmx entry:

    if (yEmHt > 255)
        return;

// Finally, find out if there is something useful there.  Note that the
// table is sorted by size, so we can take an early out.

    phdmx = (HDMXTABLE *)(phdr + 1);
    phdmxEnd = (HDMXTABLE *)((PBYTE)phdmx + cRecords * cjRecord);

    for
    (
        ;
        phdmx < phdmxEnd;
        phdmx = (HDMXTABLE *)((PBYTE)phdmx + cjRecord)
    )
    {
        if (((BYTE) yEmHt) <= phdmx->ucEmY)
        {
            if (((BYTE) yEmHt) == phdmx->ucEmY)
                pfc->phdmx = phdmx; // We found it.
            break;
        }
    }
}

/******************************Public*Routine******************************\
*
* bGrabXform
*
*  updates buffers 0 and 4, those that save the state of the transform.
*  also for "buggy" fonts (URW FONTS) some of the transform dependent
*  info (twightlight points) may be stored in the buffer 3, which otherwise would be shareable
*  this is unfortunate, more memory is required
*
*
* History:
*  24-Mar-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL
bGrabXform (
    PFONTCONTEXT pfc,
    USHORT usOverScale,
    BOOL bBitmapEmboldening,
    BOOL bRequestedClearType
)
{
    BOOL bLastClearType;
    BOOL bOk = TRUE;

     if((pfc->pgin->param.newtrans.flSubPixel & (SP_SUB_PIXEL | SP_COMPATIBLE_WIDTH)) == SP_SUB_PIXEL)
        bLastClearType = -1;
    else if((pfc->pgin->param.newtrans.flSubPixel & (SP_SUB_PIXEL | SP_COMPATIBLE_WIDTH)) == (SP_SUB_PIXEL | SP_COMPATIBLE_WIDTH))
        bLastClearType = 1;
    else 
        bLastClearType = 0;

   if ((pfc->pff->pfcLast != pfc) || (pfc->overScale != usOverScale) ||
        ( bLastClearType != bRequestedClearType)||
        (bBitmapEmboldening != (BOOL)(!!(pfc->flXform & XFORM_BITMAP_SIM_BOLD)) ) )
    {
    // set the overscale to the current one

        pfc->overScale = usOverScale;

    // have to refresh the transform, somebody has changed it on us

        if (bOk = bSetXform(pfc, bBitmapEmboldening, bRequestedClearType))
        {
            if ((pfc->pff->pfcLast != pfc) && (pfc->pff->ifi.flInfo & FM_INFO_DBCS_FIXED_PITCH))
            {
                /* we need to set pfc->SBCDWidth */

	            if (pfc->mx.transform[0][0] > 0)
	            {
	                pfc->SBCSWidth = F16_16TOLROUND(pfc->mx.transform[0][0] * pfc->pff->ifi.fwdAveCharWidth);
	            }
	            else
	            {
	                pfc->SBCSWidth = -F16_16TOLROUND(-pfc->mx.transform[0][0] * pfc->pff->ifi.fwdAveCharWidth);
	            }

            }
        // affirm that we are the ones who have set the transform last

            pfc->pff->pfcLast = pfc;
        }
        else // make sure to restore the old current transform
        {
            if (pfc->pff->pfcLast)
            {
            #if DBG
                BOOL bOkXform;
            #endif
                        
            #if DBG
                bOkXform =
            #endif
                bSetXform (
                    pfc->pff->pfcLast,
                    (BOOL)(!!(pfc->pff->pfcLast->flXform & XFORM_BITMAP_SIM_BOLD)),
                    bLastClearType
                );
                ASSERTDD(bOkXform, "bOkXform\n");
            }
        }

    }
    return (bOk);
}

/******************************Public*Routine******************************\
* vSetGrayState__FONTCONTEXT                                               *
*                                                                          *
* This routine set the FO_GRAY16 bit in pfc->flFontType and                *
* pfc->pfo->flFontType as is appropriate. If the bit is set                *
* then, later on, we shall make calls to the fs_FindGraySize and           *
* fs_ContourGrayScan pair instead of the usual monochrome pair of          *
* calls, fs_FindBitmapSize and fs_ContourScan.                             *
*                                                                          *
* The only effect that this routine could have is to clear                 *
* the FO_GRAY16 flags in pfc->flFontType and pfc->pfo->flFontType.         *
*                                                                          *
* The only way in which this clearing could occur is if all of the         *
* following conditions are met: 1) the caller has not set the              *
* FO_NO_CHOICE bit; 2) the font has a 'gasp' table; 3) the 'gasp'          *
* table indicates that for the requested number of pixels per em           *
* the 'gasp' table indicates that the font should not be grayed; 4)        *
* the glyphs of the font are not acted upon by a simple scaling            *
* transformation.                                                          *
*                                                                          *
* On Entry                                                                 *
*                                                                          *
*   pfc->flFontType & FO_GRAY16      != 0                                  *
*   pfc->pfo->flFontType & FO_GRAY16 != 0                                  *
*                                                                          *
* Procedure                                                                *
*                                                                          *
*   1. if the force bit is on then go to 6.                                *
*   2. if the transformation is not axial then go to 6.                    *
*   3. if the font does not gave a 'gasp' table then go to 6.              *
*   4. if the gasp table says that this size is ok for graying then        *
*      go to 6.                                                            *
*   5. clear the FO_GRAY16 flags in both places                            *
*   6. return                                                              *
*                                                                          *
* History:                                                                 *
*  Fri 10-Feb-1995 14:02:51 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID vSetGrayState__FONTCONTEXT(FONTCONTEXT *this)
{
    #if DBG
        void vPrintGASPTABLE(GASPTABLE*);
    #endif

    ptrdiff_t dp;               // offset from the beginning of the font to the
                                // 'gasp' table
    GASPTABLE *pgasp;           // pointer to the 'gasp' table
    GASPRANGE *pgr, *pgrOut;

    ASSERTDD(
        this->flFontType == this->pfo->flFontType
      ,"flFontType value should be identical here\n"
    );
    ASSERTDD(
        !(this->flFontType & FO_CHOSE_DEPTH)
       ,"We should not have chosen a level at this time\n"
    );

    this->flFontType |= FO_CHOSE_DEPTH;
    if (this->flFontType & FO_GRAY16)
    {
        this->flFontType &= ~(FO_GRAY16);
        if (this->flFontType & FO_NO_CHOICE)
        {
            this->flFontType |= FO_GRAY16;
        }
        else
        {
            if (!(dp = (ptrdiff_t) (this->ptp->ateOpt[IT_OPT_GASP].dp)))
            {
                USHORT fs;

                // Win95 lifts the default GASP tables from the registry
                // We should have the same behavior. Bug #11755

                #define US2BE(x)     ((((x) >> 8) | ((x) << 8)) & 0xFFFF)
                static CONST USHORT gaspDefaultRegular[] = {
                    US2BE(0)    // version
                  , US2BE(3)    // numRanges
                  , US2BE(8)         , US2BE(GASP_DOGRAY)
                  , US2BE(17)        , US2BE(GASP_GRIDFIT)
                  , US2BE(USHRT_MAX) , US2BE(GASP_GRIDFIT + GASP_DOGRAY)
                };
                static CONST USHORT gaspDefaultBold[] = {
                    US2BE(0)     // version
                  , US2BE(2)     // numRanges
                  , US2BE(8)         , US2BE(GASP_DOGRAY)
                  , US2BE(USHRT_MAX) , US2BE(GASP_GRIDFIT + GASP_DOGRAY)
                };
                static CONST USHORT *gaspDefaultItalic = gaspDefaultRegular;

                #if DBG
                if (gflTtfdDebug & DEBUG_GRAY)
                {
                    TtfdDbgPrint("Supplying default GASPTABLE\n");
                }
                #endif // DBG

                fs = this->pff->ifi.fsSelection;
                if (fs & FM_SEL_ITALIC)
                {
                    pgasp = (GASPTABLE*) gaspDefaultItalic;
                }
                else if (fs & FM_SEL_BOLD)
                {
                    pgasp = (GASPTABLE*) gaspDefaultBold;
                }
                else
                {
                    pgasp = (GASPTABLE*) gaspDefaultRegular;
                }
            }
            else
            {
                pgasp = (GASPTABLE*) (((BYTE *)(this->pff->pvView)) + dp);
            }
            #if DBG
            if (gflTtfdDebug & DEBUG_GRAY)
            {
                vPrintGASPTABLE(pgasp);
                EngDebugBreak();
            }
            #endif
            if (this->lEmHtDev > USHRT_MAX)
            {
                WARNING("vSetGrayScale: lEmHtDev > USHRT_MAX\n");
            }
            else
            {
                size_t cRanges;
                int iLow, iHt, iHigh;

                // Search the gasp table for the instructions
                // for this particular em height. I have assumed that there
                // are not too many GASP tables (typically 3 or less) so
                // I use a linear search.

                pgr     = pgasp->gaspRange;
                cRanges = BE_UINT16(&(pgasp->numRanges));
                if (cRanges > 8)
                {
                    WARNING("Unusual GASPTABLE : cRanges > 8\n");
                    cRanges = 8;
                }
                pgrOut = pgr + cRanges;
                iLow = -1;
                iHt  = this->lEmHtDev;
                for ( ; pgr < pgrOut; pgr++)
                {
                    iHigh = (int) BE_UINT16(&(pgr->rangeMaxPPEM));
                    if (iLow < iHt && iHt <= iHigh)
                    {
                        if (GASP_DOGRAY & BE_UINT16(&(pgr->rangeGaspBehavior)))
                        {
                            this->flFontType |= FO_GRAY16;
                        }
                        break;
                    }
                    iLow = iHigh;
                }
            }
        }

        if (this->flFontType & FO_GRAY16)
        {
#if DBG
            if (gflTtfdDebug & DEBUG_GRAY)
            {
                TtfdDbgPrint("Choosing 16-Level Glyphs\n");
            }
#endif
        }
        else
        {
#if DBG
            if (gflTtfdDebug & DEBUG_GRAY)
            {
                TtfdDbgPrint(
                    "\n"
                    "We came into the routine with the FO_GRAY16 bit set.\n"
                    "However, for some reason it is not possible to has\n"
                    "anti-aliased the text. Therefore we must adjust the\n"
                    "font context and inform it that that antialiasing \n"
                    "is out of the picture. We will continue and create\n"
                    "a monochrome font.\n"
                );
            }
#endif
            this->flFontType |= FO_NOGRAY16;
            this->pfo->flFontType = this->flFontType;
        }
    }
}

/******************************Public*Routine******************************\
* vSetClearTypeState__FONTCONTEXT                                          *
*                                                                          *
* This routine set the FO_GRAY16 bit in pfc->flFontType and                *
* pfc->pfo->flFontType as is appropriate. If the bit is set                *
*                                                                          *
* History:                                                                 *
*  15-Nov-1999 by Claude Betrisey [claudebe]                               *
* Wrote it.                                                                *
\**************************************************************************/
/**********************************************************************/

/*  Find a strike that matches ppem in the bloc table, simplified from scaler\sfntaccs.c */

BOOL fd_FindBlocStrike (
	const uint8 *pbyBloc,
	uint16 usPpem)
{
	uint32          ulNumStrikes;
	uint32          ulStrikeOffset;
	uint32          ulColorRefOffset;
	uint16			usSbitBitDepthMask;
	
	ulNumStrikes = (uint32)SWAPL(*((uint32*)&pbyBloc[SFNT_BLOC_NUMSIZES]));
	ulStrikeOffset = SFNT_BLOC_FIRSTSTRIKE;


	while (ulNumStrikes > 0)
	{
		if ((usPpem == (uint16)pbyBloc[ulStrikeOffset + SFNT_BLOC_PPEMX]) &&
			(usPpem == (uint16)pbyBloc[ulStrikeOffset + SFNT_BLOC_PPEMY]))
		{
					return TRUE;
		}
		ulNumStrikes--;
		ulStrikeOffset += SIZEOF_BLOC_SIZESUBTABLE;
	}

	return FALSE;                                   /* match not found */
}

VOID vSetClearTypeState__FONTCONTEXT(FONTCONTEXT *this)
{

    /* we want to disable ClearType at any size that has an embedded bitmap */

    ptrdiff_t dp;               // offset from the beginning of the font to the
                                // 'EBLC' table
    uint8 *pEBLC;           // pointer to the 'EBLC' table

    ASSERTDD(
        this->flFontType == this->pfo->flFontType
      ,"flFontType value should be identical here\n"
    );
    ASSERTDD(
        !(this->flFontType & FO_CHOSE_DEPTH)
       ,"We should not have chosen a level at this time\n"
    );

    this->flFontType |= FO_CHOSE_DEPTH;


    if (this->pff->ffca.fl & FF_DBCS_CHARSET)
    {
    /* we test for embedded bitmaps only for fonts that support FE charsets */
        if ((this->flXform & (XFORM_HORIZ | XFORM_VERT)) && 
            ((this->mx.transform[0][0] == this->mx.transform[1][1]) || (this->mx.transform[0][0] == -this->mx.transform[1][1]) ) &&
            ((this->mx.transform[0][1] == this->mx.transform[1][0]) || (this->mx.transform[0][1] == -this->mx.transform[1][0])) )
        {
            /* we only want to look for embedded bitmap if we are in a square transformation that is a multiple of 90 degree rotation */
            if ((dp = (ptrdiff_t)(this->ptp->ateOpt[IT_OPT_EBLC].dp)))
            {

                pEBLC = (uint8*) (((BYTE *)(this->pff->pvView)) + dp);

		        if (fd_FindBlocStrike (pEBLC, (uint16)this->lEmHtDev))
		        {
	                this->flFontType &= ~(FO_GRAY16 | FO_CLEARTYPE_X);
	                this->flFontType |= FO_NOCLEARTYPE;
	                this->pfo->flFontType = this->flFontType;
	            }
            }
        }
    }

    if (this->pff->ffca.fl & FF_TYPE_1_CONVERSION)
    {
        this->flFontType &= ~(FO_GRAY16 | FO_CLEARTYPE_X);
	    this->flFontType |= FO_NOCLEARTYPE;
	    this->pfo->flFontType = this->flFontType;
    }
    else if (!_wcsicmp((PWSTR)((BYTE*)&this->pff->ifi + this->pff->ifi.dpwszFamilyName),L"Marlett"))
    {
        /* we want to disable ClearType for the Marlett font */
	    this->flFontType &= ~(FO_GRAY16 | FO_CLEARTYPE_X);
	    this->flFontType |= FO_NOCLEARTYPE;
	    this->pfo->flFontType = this->flFontType;
    }

}

#if DBG
/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   vPrintGASPTABLE                                                        *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Dumps a GASPTABLE to the debug screen                                  *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pgasp   --  pointer to a big endian GASPTABLE                          *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   none                                                                   *
*                                                                          *
\**************************************************************************/

void vPrintGASPTABLE(GASPTABLE *pgasp)
{
    GASPRANGE *pgr, *pgrOut;

    TtfdDbgPrint(
        "\n"
        "-------------------------------------\n"
        "GASPTABLE HEADER\n"
        "-------------------------------------\n"
        "pgasp     = %-#x\n"
        "version   = %d\n"
        "numRanges = %d\n"
        "-------------------------------------\n"
        "    rangeMaxPPEM    rangeGaspBehavior\n"
        "-------------------------------------\n"
       , pgasp
       , BE_UINT16(&(pgasp->version))
       , BE_UINT16(&(pgasp->numRanges))
    );
    pgr     = pgasp->gaspRange;
    pgrOut  = pgr + BE_UINT16(&(pgasp->numRanges));
    for (pgr = pgasp->gaspRange; pgr < pgrOut; pgr++)
    {
        char *psz;
        USHORT us = BE_UINT16(&(pgr->rangeGaspBehavior));
        us &= (GASP_GRIDFIT | GASP_DOGRAY);
        switch (us)
        {
        case 0:
            psz = "";
            break;
        case GASP_GRIDFIT:
            psz = "GASP_GRIDFIT";
            break;
        case GASP_DOGRAY:
            psz = "GASP_DOGRAY";
            break;
        case GASP_GRIDFIT | GASP_DOGRAY:
            psz = "GASP_GRIDFIT | GASP_DOGRAY";
            break;
        }
        TtfdDbgPrint(
            "    %12d    %s\n"
          , BE_UINT16(&(pgr->rangeMaxPPEM))
          , psz
        );
    }
    TtfdDbgPrint(
        "-------------------------------------\n\n\n"
    );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\ttfd\fdfon.c ===
/******************************Module*Header*******************************\
* Module Name: fdfon.c
*
* basic file claim/load/unload font file functions
*
* Created: 08-Nov-1991 10:09:24
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/
#include "fd.h"
#include <stdlib.h>
#include <winerror.h>

#define SZ_GLYPHSET_CACHE(r, g) ( offsetof(FD_GLYPHSET,awcrun) + (r)*sizeof(WCRUN) + (g)*sizeof(USHORT))

#define SZ_GLYPHSET_WRUN(r) ( offsetof(FD_GLYPHSET,awcrun) + (r)*sizeof(WCRUN))

BOOL
bLoadTTF (
    ULONG_PTR iFile,
    PVOID     pvView,
    ULONG     cjView,
    ULONG     ulTableOffset,
    ULONG     ulLangId,
    HFF       *phff,
    PTTF_CACHE  pCache,
    ULONG     ulFastCheckSum
    );

VOID vStoreGSetV(PFD_GLYPHSET pgsetCache, PFONTFILE pff);
VOID vStoreGSetH(PFD_GLYPHSET pgsetCache, PFD_GLYPHSET pgset);

#define NOEMCHARSETS 16
void vFillIFICharsets(FONTFILE *pff, IFIMETRICS *pifi, BYTE *aCharSets, BYTE *pjView, BYTE * pjOS2, fs_GlyphInputType *pgin);
VOID vGetVerticalGSet(PFD_GLYPHSET pgsetv, PFONTFILE pff);

// CMI_2219_PRESENT set if 2219 is     supported in a font
// CMI_B7_ABSENT    set if b7   is NOT supported in a font
// CMI_5C_SPLIT     set for TT shell font and current system locale is Japanese or Korean

#define CMI_2219_PRESENT 1
#define CMI_B7_ABSENT    2
#define CMI_5C_SPLIT	 4

// Those 2 value is for NT shell font, if we change the font name \
// Then we need to update these 2 values.

#define PSZ_MICROSS_SHELLFONT       "Microsoft Sans Serif Regular"
#define MICROSS_SHELLFONT_SIZE      sizeof(PSZ_MICROSS_SHELLFONT)
#define PSZ_TAHOMA_SHELLFONT        "Microsoft Tahoma Regular"
#define TAHOMA_SHELLFONT_SIZE       sizeof(PSZ_TAHOMA_SHELLFONT)
#define PSZ_TAHOMA_BOLD_SHELLFONT   "Microsoft Tahoma Bold"
#define TAHOMA_BOLD_SHELLFONT_SIZE  sizeof(PSZ_TAHOMA_BOLD_SHELLFONT)
#define MICROSS_SHELLFONT           0x1
#define TAHOMA_SHELLFONT            0x2
#define TAHOMA_BOLD_SHELLFONT       0x3

#define PSZ_MS_MINCHO               L"Microsoft:MS Mincho:1995"
#define PSZ_MS_PMINCHO              L"Microsoft:MS PMincho:1995"
#define PSZ_MS_GOTHIC               L"Microsoft:MS Gothic:1995"
#define PSZ_MS_PGOTHIC              L"Microsoft:MS PGothic:1995"

extern DWORD fs[];  // charset/fs table
extern UINT  nCharsets;
extern UINT  charsets[];
extern UINT  codepages[];

// this routine checks if any dbcs charsets are supported in a font
// gre\pfeobj.cxx

extern BOOL IsAnyCharsetDbcs(IFIMETRICS *pifi);



BOOL IsCurrentCodePageDBCS()
{
    USHORT AnsiCodePage, OemCodePage;

    EngGetCurrentCodePage(&OemCodePage,&AnsiCodePage);

    return(AnsiCodePage == 932  || AnsiCodePage == 949  ||
           AnsiCodePage == 1361 || AnsiCodePage == 936  || AnsiCodePage == 950 );
}

STATIC BOOL  bContainGlyphSet
(
WCHAR                 wc,
PFD_GLYPHSET          pgset
);

// Windows 95-J and Windows NT 3.51J shipped some fonts with buggy signatures.
// These fonts are shift-jis fonts but have just one entry in the signature
// saying the are Chinese fonts.  NT 4.0 also shipped one of these fonts in
// a lang pack and NEC based some fonts on these fonts and shipped them with
// their systems.  This routine detects these bogus signatures so that we
// will ignore them when computing charset and so that we can put the right
// signature value in the ifimetrics.


BOOL IsBogusSignature(ULONG ulCodePageRange, PFONTFILE pff)
{
    if((!(ulCodePageRange & FS_JISJAPAN))                             &&
       (pff->ffca.ui16SpecificID == BE_SPEC_ID_SHIFTJIS)                   &&
       bContainGlyphSet( U_HALFWIDTH_KATAKANA_LETTER_A , pff->pgset ) &&
       bContainGlyphSet( U_HALFWIDTH_KATAKANA_LETTER_I , pff->pgset ) &&
       bContainGlyphSet( U_HALFWIDTH_KATAKANA_LETTER_U , pff->pgset ) &&
       bContainGlyphSet( U_HALFWIDTH_KATAKANA_LETTER_E , pff->pgset ) &&
       bContainGlyphSet( U_HALFWIDTH_KATAKANA_LETTER_O , pff->pgset ))
    {
        return(TRUE);
    }
    else
    {
        if (ulCodePageRange & FS_CHINESESIMP)
        {
            PWCHAR pszUnique; 
            pszUnique = (PWCHAR) (pff->ifi.dpwszUniqueName + (PBYTE) &pff->ifi);
            if (!_wcsicmp(pszUnique, PSZ_MS_MINCHO) || !_wcsicmp(pszUnique, PSZ_MS_PMINCHO)
                || !_wcsicmp(pszUnique, PSZ_MS_GOTHIC) || !_wcsicmp(pszUnique, PSZ_MS_PGOTHIC))                
                return (TRUE);                
            else
                return (FALSE);
        }
        else
        {
            return(FALSE);
        }
    }
}


#ifdef WIN31_ORIGINAL_CODE
;******************************************************************************
;************************  C O P Y   I F I   N A M E  *************************
;******************************************************************************

cProc   CopyIfiName, <FAR, PUBLIC>, <es, si, di>
    parmD   lpszUnicode
    parmD   lpszAnsi
    parmW   cwUnicode
cBegin
    lfs si, lpszUnicode         ; fs:si --> ptr to Unicode str
    les di, lpszAnsi            ; es:di --> ptr to DBCS str
CINCopyLoop:
    lodsw   fs:[si]             ; load a Unicode
    or  ah, ah
    jz  @f
    mov es:[di], ah         ; store higher byte
    inc di
@@: stosb                   ; store lower byte
    or  ax, ax              ; end of string?
    jnz CINCopyLoop         ; no. keep copying

    mov ax, di              ; return number of bytes copyed
    sub ax, lpszAnsi.off
cEnd
#endif // WIN31_ORIGINAL_CODE

STATIC
ULONG CopyDBCSIFIName(
    CHAR *AnsiName,
    ULONG BufferLength,
    LPCSTR OriginalName,
    ULONG OriginalLength)
{
    ULONG AnsiLength = 0;

    for( ;OriginalLength; OriginalLength-=2 )
    {
        if (OriginalName[0])
        {
            if( BufferLength >= (AnsiLength+2) )
            {
                *AnsiName++ = OriginalName[0];
                *AnsiName++ = OriginalName[1];
                AnsiLength += 2;
            }
            else
            {
                break;
            }
        }
        else
        {
            if( BufferLength >= (AnsiLength+1) )
            {
                *AnsiName++ = OriginalName[1];
                AnsiLength++;
            }
            else
            {
                break;
            }
        }
        OriginalName += 2;
    }

    return (AnsiLength);
}

STATIC UINT GetCodePageFromSpecId( uint16 ui16SpecId )
{
    USHORT AnsiCodePage, OemCodePage;
    UINT iCodePage;

    EngGetCurrentCodePage(&OemCodePage,&AnsiCodePage);

    iCodePage = AnsiCodePage;

    switch( ui16SpecId )
    {
        case BE_SPEC_ID_SHIFTJIS :
            iCodePage = 932;
            break;

        case BE_SPEC_ID_GB :
            iCodePage = 936;
            break;

        case BE_SPEC_ID_BIG5 :
            iCodePage = 950;
            break;

        case BE_SPEC_ID_WANSUNG :
            iCodePage = 949;
            break;

        default :
            WARNING("TTFD!:Unknown SPECIFIC ID\n");
            break;
    }

    return( iCodePage );
}

STATIC BOOL bVerifyMsftHighByteTable
(
sfnt_mappingTable * pmap,
ULONG             * pgset,
CMAPINFO          * pcmi,
uint16              ui16SpecID
);

STATIC ULONG cjComputeGLYPHSET_HIGH_BYTE
(
sfnt_mappingTable     *pmap,
ULONG                **ppgset,
CMAPINFO              *pcmi
);

STATIC BOOL bVerifyMsftTableGeneral
(
sfnt_mappingTable * pmap,
ULONG             * pgset,
CMAPINFO          * pcmi,
uint16              ui16SpecID
);

STATIC ULONG cjComputeGLYPHSET_MSFT_GENERAL
(
sfnt_mappingTable     *pmap,
ULONG                **ppgset,
CMAPINFO              *pcmi
);



STATIC ULONG cjComputeGLYPHSET_TEMPLATE
(
sfnt_mappingTable     *pmap,
fs_GlyphInputType     *pgin,
fs_GlyphInfoType      *pgout,
FD_GLYPHSET          **pgset,
ULONG                  ul_wcBias,
ULONG                  iGsetType
);

STATIC ULONG cjComputeGLYPHSET_OLDBIDI     // Old BiDi (win 31) TTF font pages
(
 fs_GlyphInputType  *pgin,
 fs_GlyphInfoType   *pgout,
 FD_GLYPHSET        **ppgset,
 ULONG              ul_wcBias
 ) ;


STATIC uint16 ui16BeLangId(ULONG ulPlatId, ULONG ulLangId)
{
    ulLangId = CV_LANG_ID(ulPlatId,ulLangId);
    return BE_UINT16(&ulLangId);
}


STATIC FSHORT  fsSelectionTTFD(BYTE *pjView, TABLE_POINTERS *ptp)
{
    PBYTE pjOS2 = (ptp->ateOpt[IT_OPT_OS2].dp)        ?
                  pjView + ptp->ateOpt[IT_OPT_OS2].dp :
                  NULL                                ;

    sfnt_FontHeader * phead = (sfnt_FontHeader *)(pjView + ptp->ateReq[IT_REQ_HEAD].dp);

//
// fsSelection
//
    ASSERTDD(TT_SEL_ITALIC     == FM_SEL_ITALIC     , "ITALIC     \n");
    ASSERTDD(TT_SEL_UNDERSCORE == FM_SEL_UNDERSCORE , "UNDERSCORE \n");
    ASSERTDD(TT_SEL_NEGATIVE   == FM_SEL_NEGATIVE   , "NEGATIVE   \n");
    ASSERTDD(TT_SEL_OUTLINED   == FM_SEL_OUTLINED   , "OUTLINED   \n");
    ASSERTDD(TT_SEL_STRIKEOUT  == FM_SEL_STRIKEOUT  , "STRIKEOUT  \n");
    ASSERTDD(TT_SEL_BOLD       == FM_SEL_BOLD       , "BOLD       \n");

    if (pjOS2)
    {
        return((FSHORT)BE_UINT16(pjOS2 + OFF_OS2_usSelection));
    }
    else
    {
    #define  BE_MSTYLE_BOLD       0x0100
    #define  BE_MSTYLE_ITALIC     0x0200

        FSHORT fsSelection = 0;

        if (phead->macStyle & BE_MSTYLE_BOLD)
            fsSelection |= FM_SEL_BOLD;
        if (phead->macStyle & BE_MSTYLE_ITALIC)
            fsSelection |= FM_SEL_ITALIC;

        return fsSelection;
    }
}



STATIC BOOL  bComputeIFISIZE
(
BYTE             *pjView,
TABLE_POINTERS   *ptp,
uint16            ui16PlatID,
uint16            ui16SpecID,
uint16            ui16LangID,
PIFISIZE          pifisz,
BOOL             *pbType1,
ULONG            *pulShellFont
);

STATIC BOOL  bCheckLocaTable
(
int16	indexToLocFormat,
BYTE    *pjView,
TABLE_POINTERS   *ptp,
uint16 	numGlyphs
);

STATIC BOOL  bCheckHdmxTable
(
sfnt_hdmx      *phdmx,
ULONG 			size
);

STATIC BOOL bCvtUnToMac(BYTE *pjView, TABLE_POINTERS *ptp, uint16 ui16PlatformID);

STATIC BOOL  bVerifyTTF
(
ULONG_PTR           iFile,
PVOID               pvView,
ULONG               cjView,
PBYTE               pjOffsetTable,
ULONG               ulLangId,
PTABLE_POINTERS     ptp,
PIFISIZE            pifisz,
uint16             *pui16PlatID,
uint16             *pui16SpecID,
sfnt_mappingTable **ppmap,
ULONG              *pulGsetType,
ULONG              *pul_wcBias,
CMAPINFO           *pcmi,
BOOL               *pbType1,
ULONG              *pulShellFont
);

STATIC BOOL  bGetTablePointers
(
PVOID               pvView,
ULONG               cjView,
PBYTE               pjOffsetTable,
PTABLE_POINTERS  ptp
);

STATIC BOOL bVerifyMsftTable
(
sfnt_mappingTable * pmap,
ULONG             * pgset,
ULONG             * pul_wcBias,
CMAPINFO          * pcmi,
uint16              ui16SpecID,
ULONG             * pul_startCount
);


STATIC BOOL  bVerifyMacTable(sfnt_mappingTable * pmap);


STATIC BOOL bComputeIDs
(
BYTE                     * pjView,
TABLE_POINTERS           * ptp,
uint16                   * pui16PlatID,
uint16                   * pui16SpecID,
sfnt_mappingTable       ** ppmap,
ULONG                    * pulGsetType,
ULONG                    * pul_wcBias,
CMAPINFO                 * pcmi
);


STATIC VOID vFill_IFIMETRICS
(
PFONTFILE       pff,
PIFIMETRICS     pifi,
PIFISIZE        pifisz,
fs_GlyphInputType     *pgin
);

BYTE jIFIMetricsToGdiFamily (PIFIMETRICS pifi);


BOOL
ttfdUnloadFontFileTTC (
    HFF hff
    )
{
    ULONG i;
    BOOL  bRet = TRUE;
    #if DBG
    ULONG ulTrueTypeResource = PTTC(hff)->ulTrueTypeResource;
    #endif

    // free hff for this ttc file.

    for( i = 0; i < PTTC(hff)->ulNumEntry; i++ )
    {
        if(PTTC(hff)->ahffEntry[i].iFace == 1)
        {
            if( !ttfdUnloadFontFile(PTTC(hff)->ahffEntry[i].hff) )
            {
                WARNING("TTFD!ttfdUnloadFontFileTTC(): ttfdUnloadFontFile fail\n");
                bRet = FALSE;
            }

            #if DBG
            ulTrueTypeResource--;
            #endif
        }
    }

    if (PTTC(hff)->pga)
        V_FREE(PTTC(hff)->pga);

    // finally free the memory for the ttc itself

    vFreeTTC(PTTC(hff));

    ASSERTDD(ulTrueTypeResource == 0L,
              "TTFD!ttfdUnloadFontFileTTC(): ulTrueTypeResource != 0\n");

    return(bRet);
}

/******************************Public*Routine******************************\
*
* ttfdUnloadFontFile
*
*
* Effects: done with using this tt font file. Release all system resources
* associated with this font file
*
*
* History:
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
ttfdUnloadFontFile (
    HFF hff
    )
{
    if (hff == HFF_INVALID)
        return(FALSE);

// check the reference count, if not 0 (font file is still
// selected into a font context) we have a problem

    ASSERTDD(PFF(hff)->cRef == 0L, "ttfdUnloadFontFile: cRef\n");

// no need to unmap the file at this point
// it has been unmapped when cRef went down to zero

// assert that pff->pkp does not point to the allocated mem

    ASSERTDD(!PFF(hff)->pkp, "UnloadFontFile, pkp not null\n");

    if(PFF(hff)->cRefGSet  != 0)
    	WARNING("cRefGSet is not 0\n");
    if(PFF(hff)->cRefGSetV != 0)
    	WARNING("cRefGSetV is not 0\n");
    if(PFF(hff)->pgset  != NULL)
    	WARNING("pgset is not NULL\n");
    if(PFF(hff)->pgsetv != NULL)
    	WARNING("pgsetv is not NULL\n");

// just in case we goofed up, we force free this memory

    if (PFF(hff)->pgset)
    {
        V_FREE(PFF(hff)->pgset);
        PFF(hff)->pgset = NULL;
    }

    if (PFF(hff)->pgsetv)
    {
        V_FREE(PFF(hff)->pgsetv);
        PFF(hff)->pgsetv = NULL;
    }

// free vertical ifimetrics and the vertical glyphset that are allocated of the same chunk

    if (PFF(hff)->pifi_vertical)
        V_FREE(PFF(hff)->pifi_vertical);

// free memory associated with this FONTFILE object

    vFreeFF(hff);
    return(TRUE);
}

/******************************Public*Routine******************************\
*
* BOOL bVerifyTTF
*
*
* Effects: verifies that a ttf file contains consistent tt information
*
* History:
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC BOOL
bVerifyTTF (
    ULONG_PTR           iFile,
    PVOID               pvView,
    ULONG               cjView,
    PBYTE               pjOffsetTable,
    ULONG               ulLangId,
    PTABLE_POINTERS     ptp,
    PIFISIZE            pifisz,
    uint16             *pui16PlatID,
    uint16             *pui16SpecID,
    sfnt_mappingTable **ppmap,
    ULONG              *pulGsetType,
    ULONG              *pul_wcBias,
    CMAPINFO           *pcmi,
    BOOL               *pbType1,
    ULONG              *pulShellFont
    )
{
    // extern BOOL bCheckSumOK( void *pvView, ULONG cjView, sfnt_FontHeader *phead );
    sfnt_FontHeader      *phead;

    sfnt_HorizontalHeader  *phhea;
    sfnt_HorizontalMetrics *phmtx;
    sfnt_maxProfileTable   *pmaxp;
    sfnt_hdmx			   *phdmx;	
    ULONG  cHMTX;

// if attempted a bm *.fon file this will fail, so do not print
// warning, but if passes this, and then fails, something is wrong

    if (!bGetTablePointers(pvView,cjView,pjOffsetTable,ptp))
    {
        return( FALSE );
    }

    phead = (sfnt_FontHeader *)((BYTE *)pvView + ptp->ateReq[IT_REQ_HEAD].dp);
    phhea = (sfnt_HorizontalHeader *)((BYTE *)pvView + ptp->ateReq[IT_REQ_HHEAD].dp);
    phmtx = (sfnt_HorizontalMetrics *)((BYTE *)pvView + ptp->ateReq[IT_REQ_HMTX].dp);
    pmaxp = (sfnt_maxProfileTable *)((BYTE *)pvView + ptp->ateReq[IT_REQ_MAXP].dp);
    phdmx = ptp->ateOpt[IT_OPT_HDMX].dp ? 
    	(sfnt_hdmx *)((BYTE *)pvView + ptp->ateOpt[IT_OPT_HDMX].dp) : NULL;

    cHMTX = (ULONG) BE_UINT16(&phhea->numberOf_LongHorMetrics);

    if (sizeof(sfnt_HorizontalMetrics) * cHMTX > ptp->ateReq[IT_REQ_HMTX].cj)
    {
        return FALSE;
    }

    /*
    if ( !bCheckSumOK( pvView, cjView, phead ))
    {
        RET_FALSE("TTFD!_bVerifyTTF, possible file corruption, checksums did not match\n");
    }
    */

#define SFNT_MAGIC   0x5F0F3CF5
    if (BE_UINT32((BYTE*)phead + SFNT_FONTHEADER_MAGICNUMBER) != SFNT_MAGIC)
        RET_FALSE("TTFD: bVerifyTTF: SFNT_MAGIC \n");

    if (!bComputeIDs(pvView,
                     ptp,
                     pui16PlatID,
                     pui16SpecID,
                     ppmap,
                     pulGsetType,
                     pul_wcBias,
                     pcmi)
        )
        RET_FALSE("TTFD!_bVerifyTTF, bComputeIDs failed\n");


    if (!bComputeIFISIZE (
                    pvView,
                    ptp,
                    *pui16PlatID,
                    *pui16SpecID,
                    ui16BeLangId(*pui16PlatID,ulLangId),
                    pifisz,             // return results here
                    pbType1,
                    pulShellFont)
        )
        {
            RET_FALSE("TTFD!_bVerifyTTF, bComputeIFISIZE failed\n");
        }

    if (!bCheckLocaTable (
    				SWAPW(phead->indexToLocFormat),
    				pvView,
    				ptp,
    				(uint16) SWAPW(pmaxp->numGlyphs) )
    	)
        {
            RET_FALSE("TTFD!_bVerifyTTF, bCheckLocaTable failed\n");
        }

    if (phdmx && !bCheckHdmxTable (
    				phdmx,
    				ptp->ateOpt[IT_OPT_HDMX].cj )
    	)
        {
            RET_FALSE("TTFD!_bVerifyTTF, bCheckHdmxTable failed\n");
        }

// all checks passed

    return(TRUE);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   bCheckSumOK
*
* Routine Description:
*
*   Check file for corruption by calculationg check sum
*   and comparing it against value in file.
*
*   Ref: TrueType 1.0 Font Files: Technical Specification,
*        Revision 1.64 beta, December 1994, p. 65,
*        'head' - Font Header".
*
* Arguments:
*
*   pvView              pointer to view of TrueType file
*
*   cjView              size of view in byte's
*
*   phead               pointer to sfnt_FontHeader table in view of
*                       TrueType file
*
* Return Value:
*
*   TRUE if check sum's match, FALSE if they don't
*
\**************************************************************************/
/*
BOOL bCheckSumOK( void *pvView, ULONG cjView, sfnt_FontHeader *phead )
{
    extern ULONG ttfdCheckSum( ULONG*, ULONG );
    ULONG ul, *pul, ulView;

    pul  = (ULONG*) ( (BYTE*) phead + SFNT_FONTHEADER_CHECKSUMADJUSTMENT );
                                    // pul now points to the
                                    // checkSumAdjustment field in the
                                    // 'head' table of the font file.
    if ( (ULONG) pul & 3 )          // Check that pul is DWORD aligned
    {
        RET_FALSE("bCheckSumOK: checkSumAdjustment is not DWORD aligned\n");
    }
    ul   = *pul;                    // Big endian representation
    *pul = 0;                       // required to calculate checksum
    ulView = ttfdCheckSum( (ULONG*) pvView, cjView );   // little endian value
    *pul = ul;                      // restore view
    ulView = 0xb1b0afba - ulView;   // magic subtraction as per spec
    ulView = BE_UINT32( &ulView );  // convert to big endian representation
    return( ul == ulView );         // compare with big endian number in file
}
*/
/******************************Public*Routine******************************\
*
* Routine Name:
*
*   ttfdCheckSum
*
* Routine Description:
*
*   Calculates check sum's of memory blocks according to TrueType
*   conventions.
*
*   Ref: TrueType 1.0 Font Files: Technical Specification,
*        Revision 1.64 beta, December 1994, p. 34, The Table
*        Directory
*
* Arguments:
*
*   pul                 pointer to DWORD aligned start of memory block
*
*   cj                  size of memory block in bytes. It is assumed
*                       that access of the last DWORD is allowed
*                       even if cj is not a multiple of 4.
*
* Return Value:
*
*   Little Endian representation of CheckSum.
*
\**************************************************************************/
/*
ULONG ttfdCheckSum( ULONG *pul, ULONG cj )
{
    ULONG *pulEnd, ul, Sum;
    pulEnd = (ULONG*) ((BYTE*) pul + ((cj + 3) & ~3) );
    for ( Sum = 0; pul < pulEnd; pul++)
    {
        ul = *pul;                  // ul is big endian
        Sum += BE_UINT32( &ul );    // do little endian sum
    }
    return( Sum );  // return little endian result
}
*/
/******************************Public*Routine******************************\
*
* PBYTE pjGetPointer(LONG clientID, LONG dp, LONG cjData)
*
* this function is required by scaler. It is very simple
* Returns a pointer to the position in a ttf file which is at
* offset dp from the top of the file:
*
* Effects:
*
* Warnings:
*
* History:
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

//!!! clientID should be uint32, just a set of bits
//!!! I hate to have this function defined like this [bodind]

voidPtr   FS_CALLBACK_PROTO
pvGetPointerCallback(
    ULONG_PTR clientID,
    long     dp,
    long     cjData
    )
{
    cjData;

// clientID is FONTFILE structure...

    if(dp)
        if ((dp > 0) && (cjData >= 0) && (dp + cjData <= (long)PFF(clientID)->cjView))
        {
            return(voidPtr)((PBYTE)(PFF(clientID)->pvView) + dp);
        }
        else
        {
            return NULL;
        }
     else
        return(voidPtr)((PBYTE)(PFF(clientID)->pvView) +
                               (PFF(clientID)->ffca.ulTableOffset));
}


/******************************Public*Routine******************************\
*
* void vReleasePointer(voidPtr pv)
*
*
* required by scaler, the type of this function is ReleaseSFNTFunc
*
*
*
* History:
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

void FS_CALLBACK_PROTO
vReleasePointerCallback(
    voidPtr pv
    )
{
    pv;
}


/******************************Public*Routine******************************\
*
* PBYTE pjTable
*
* Given a table tag, get a pointer and a size for the table
*
* History:
*  11-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


PBYTE pjTable(ULONG ulTag, PFONTFILE pff, ULONG *pcjTable)
{
    INT                 cTables;
    sfnt_OffsetTable    *pofft;
    register sfnt_DirectoryEntry *pdire, *pdireEnd;

// offset table is at the very top of the file,

    pofft = (sfnt_OffsetTable *) ((PBYTE) (pff->pvView) + pff->ffca.ulTableOffset);

    cTables = (INT) SWAPW(pofft->numOffsets);

// do linear search, this is usually small list and it is NOT always
// ordered by the tag as ttf spec says it should be.

    pdireEnd = &pofft->table[cTables];

    for
    (
        pdire = &pofft->table[0];
        pdire < pdireEnd;
        ((PBYTE)pdire) += SIZE_DIR_ENTRY
    )
    {

        if (ulTag == pdire->tag)
        {
            ULONG ulOffset = (ULONG)SWAPL(pdire->offset);
            ULONG ulLength = (ULONG)SWAPL(pdire->length);

        // check if the ends of all tables are within the scope of the
        // tt file. If this is is not the case trying to access the field in the
        // table may result in an access violation, as is the case with the
        // spurious FONT.TTF that had the beginning of the cmap table below the
        // end of file, which was resulting in the system crash reported by beta
        // testers. [bodind]

            if
            (
             !ulLength ||
             ((ulOffset + ulLength) > pff->cjView)
            )
            {
                RETURN("TTFD: pjTable: table offset/length \n", NULL);
            }
            else // we found it
            {
                *pcjTable = ulLength;
                return ((PBYTE)(pff->pvView) + ulOffset);
            }
        }
    }

// if we are here, we did not find it.

    return NULL;
}

/******************************Public*Routine******************************\
*
* bGetTablePointers - cache the pointers to all the tt tables in a tt file
*
* IF a table is not present in the file, the corresponding pointer is
* set to NULL
*
*
* //   tag_CharToIndexMap              // 'cmap'    0
* //   tag_GlyphData                   // 'glyf'    1
* //   tag_FontHeader                  // 'head'    2
* //   tag_HoriHeader                  // 'hhea'    3
* //   tag_HorizontalMetrics           // 'hmtx'    4
* //   tag_IndexToLoc                  // 'loca'    5
* //   tag_MaxProfile                  // 'maxp'    6
* //   tag_NamingTable                 // 'name'    7
* //   tag_Postscript                  // 'post'    9
* //   tag_OS_2                        // 'OS/2'    10
*
* // optional
*
* //   tag_ControlValue                // 'cvt '    11
* //   tag_FontProgram                 // 'fpgm'    12
* //   tag_HoriDeviceMetrics           // 'hdmx'    13
* //   tag_Kerning                     // 'kern'    14
* //   tag_LSTH                        // 'LTSH'    15
* //   tag_PreProgram                  // 'prep'    16
* //   tag_GlyphDirectory              // 'gdir'    17
* //   tag_Editor0                     // 'edt0'    18
* //   tag_Editor1                     // 'edt1'    19
* //   tag_Encryption                  // 'cryp'    20
*
*
* returns false if all of required pointers are not present
*
* History:
*  05-Dec-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL bGetTablePointers (
    PVOID            pvView,
    ULONG            cjView,
    PBYTE            pjOffsetTable,
    PTABLE_POINTERS  ptp
    )
{
    INT                 iTable;
    INT                 cTables;
    sfnt_OffsetTable    *pofft;
    register sfnt_DirectoryEntry *pdire, *pdireEnd;
    ULONG                ulTag;
    BOOL                 bRequiredTable;

// offset table is at the very top of the file,

    pofft = (sfnt_OffsetTable *)pjOffsetTable;

// check version number, if wrong exit before doing
// anything else. This line rejects bm FON files
// if they are attempted to be loaed as TTF files
// Version #'s are in big endian.

#define BE_VER1     0x00000100
#define BE_VER2     0x00000200

    if ((pofft->version != BE_VER1) && (pofft->version !=  BE_VER2))
        return (FALSE); // *.fon files fail this check, make this an early out

// clean up the pointers

    RtlZeroMemory((VOID *)ptp, sizeof(TABLE_POINTERS));

    cTables = (INT) SWAPW(pofft->numOffsets);
    ASSERTDD(cTables <= MAX_TABLES, "cTables\n");

    pdireEnd = &pofft->table[cTables];

    for
    (
        pdire = &pofft->table[0];
        pdire < pdireEnd;
        ((PBYTE)pdire) += SIZE_DIR_ENTRY
    )
    {
        ULONG ulOffset = (ULONG)SWAPL(pdire->offset);
        ULONG ulLength = (ULONG)SWAPL(pdire->length);

        ulTag = (ULONG)SWAPL(pdire->tag);

    // check if the ends of all tables are within the scope of the
    // tt file. If this is is not the case trying to access the field in the
    // table may result in an access violation, as is the case with the
    // spurious FONT.TTF that had the beginning of the cmap table below the
    // end of file, which was resulting in the system crash reported by beta
    // testers. [bodind]

        if ((ulOffset + ulLength) > cjView)
            RET_FALSE("TTFD: bGetTablePointers : table offset/length \n");

        if (bGetTagIndex(ulTag, &iTable, &bRequiredTable))
        {
            if (bRequiredTable)
            {
                ptp->ateReq[iTable].dp = ulOffset;
                ptp->ateReq[iTable].cj = ulLength;
            }
            else // optional table
            {
                ptp->ateOpt[iTable].dp = ulOffset;
                ptp->ateOpt[iTable].cj = ulLength;

            // here we are fixing a possible bug in in the tt file.
            // In lucida sans font they claim that pj != 0 with cj == 0 for
            // vdmx table. Attempting to use this vdmx table was
            // resulting in an access violation in bSearchVdmxTable

                if (ptp->ateOpt[iTable].cj == 0)
                    ptp->ateOpt[iTable].dp = 0;
            }
        }

    }

// now check that all required tables are present

    for (iTable = 0; iTable < C_REQ_TABLES; iTable++)
    {
        if ((ptp->ateReq[iTable].dp == 0) || (ptp->ateReq[iTable].cj == 0))
            RET_FALSE("TTFD!_required table absent\n");
    }

    return(TRUE);
}


/******************************Public*Routine******************************\
*
* BOOL bGetTagIndex
*
* Determines whether the table is required or optional, assiciates the index
* into TABLE_POINTERS  with the tag
*
* returns FALSE if ulTag is not one of the recognized tags
*
* History:
*  09-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bGetTagIndex (
    ULONG  ulTag,      // tag
    INT   *piTable,    // index into a table
    BOOL  *pbRequired  // requred or optional table
    )
{
    *pbRequired = FALSE;  // default set for optional tables, change the
                          // value if required table

    switch (ulTag)
    {
    // reqired tables:

    case tag_CharToIndexMap:
        *piTable = IT_REQ_CMAP;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_GlyphData:
        *piTable = IT_REQ_GLYPH;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_FontHeader:
        *piTable = IT_REQ_HEAD;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_HoriHeader:
        *piTable = IT_REQ_HHEAD;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_HorizontalMetrics:
        *piTable = IT_REQ_HMTX;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_IndexToLoc:
        *piTable = IT_REQ_LOCA;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_MaxProfile:
        *piTable = IT_REQ_MAXP;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_NamingTable:
        *piTable = IT_REQ_NAME;
        *pbRequired = TRUE;
        return (TRUE);

// optional tables

    case tag_OS_2:
        *piTable = IT_OPT_OS2;
        return (TRUE);
    case tag_HoriDeviceMetrics:
        *piTable = IT_OPT_HDMX;
        return (TRUE);
    case tag_Vdmx:
        *piTable = IT_OPT_VDMX;
        return (TRUE);
    case tag_Kerning:
        *piTable = IT_OPT_KERN;
        return (TRUE);
    case tag_LinearThreshold:
        *piTable = IT_OPT_LSTH;
        return (TRUE);
    case tag_Postscript:
        *piTable = IT_OPT_POST;
        return (TRUE);
    case tag_GridfitAndScanProc:
        *piTable = IT_OPT_GASP;
        return (TRUE);
    case tag_mort:
        *piTable = IT_OPT_MORT;
        return (TRUE);
    case tag_GSUB:
        *piTable = IT_OPT_GSUB;
        return (TRUE);
    case tag_VerticalMetrics:
        *piTable = IT_OPT_VMTX;
        return(TRUE);
    case tag_VertHeader:
        *piTable = IT_OPT_VHEA;
        return(TRUE);
    case tag_BitmapLocation:
        *piTable = IT_OPT_EBLC;
        return (TRUE);
    default:
        return (FALSE);
    }
}


/******************************Public*Routine******************************\
*
* STATIC BOOL  bComputeIFISIZE
*
* Effects:
*
* Warnings:
*
* History:
*  10-Dec-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

// this function is particularly likely to break on MIPS, since
// NamingTable structure is three SHORTS so that

#define BE_NAME_ID_COPYRIGHT   0x0000
#define BE_NAME_ID_FAMILY      0x0100
#define BE_NAME_ID_SUBFAMILY   0x0200
#define BE_NAME_ID_UNIQNAME    0x0300
#define BE_NAME_ID_FULLNAME    0x0400
#define BE_NAME_ID_VERSION     0x0500
#define BE_NAME_ID_PSCRIPT     0x0600
#define BE_NAME_ID_TRADEMARK   0x0700

STATIC CHAR  pszType1[] = "Converter: Windows Type 1 Installer";

// big endian unicode version of the above string

STATIC CHAR  awszType1[] = {
0,'C',
0,'o',
0,'n',
0,'v',
0,'e',
0,'r',
0,'t',
0,'e',
0,'r',
0,':',
0,' ',
0,'W',
0,'i',
0,'n',
0,'d',
0,'o',
0,'w',
0,'s',
0,' ',
0,'T',
0,'y',
0,'p',
0,'e',
0,' ',
0,'1',
0,' ',
0,'I',
0,'n',
0,'s',
0,'t',
0,'a',
0,'l',
0,'l',
0,'e',
0,'r',
0, 0
};

BOOL    bShellFontFace(PBYTE pszShellFontFace, PBYTE pszFamilyName, ULONG ulShellFont)
{
    UINT    i;
    BOOL    bShellFont;

// Now it is Microsoft Sans Serif, we will change it later.

    bShellFont = TRUE;

    for(i = 0; i < ulShellFont - 1; i++)
    {
        pszFamilyName++;
        if(*pszFamilyName != *pszShellFontFace++)
        {
            bShellFont = FALSE;
            break;
        }
        pszFamilyName++;
    }
    
    return bShellFont;
}

ULONG ConvertLangIDtoCodePage(uint16 uiLangID)
{
    uint16  uiCodePage;

    uiCodePage = 0;

    switch(uiLangID)
    {
        case 0x0404:   // Taiwan
        case 0x040c:   // Hongkong
        case 0x0414:   // mckou
            uiCodePage = 950; // CHINESEBIG5_CHARSET
            break;
        case 0x0408:    // PRC
        case 0x0410:    // Singapore
            uiCodePage = 936; // GB2312_CHARSET
            break;
        default:
            break;
    }

    return uiCodePage;
}

STATIC BOOL  bComputeIFISIZE
(
BYTE             *pjView,
TABLE_POINTERS   *ptp,
uint16            ui16PlatID,
uint16            ui16SpecID,
uint16            ui16LangID,
PIFISIZE          pifisz,
BOOL             *pbType1,
ULONG            *pulShellFont
)
{

    sfnt_OS2 * pOS2;
    sfnt_NamingTable *pname = (sfnt_NamingTable *)(pjView + ptp->ateReq[IT_REQ_NAME].dp);
    BYTE  *pjStorage;

    sfnt_NameRecord * pnrecInit, *pnrec, *pnrecEnd;

    BOOL    bMatchLangId, bFoundAllNames;
    INT     iNameLoop;

    USHORT  AnsiCodePage, OemCodePage;


// pointers to name records for the four strings we are interested in:

    sfnt_NameRecord * pnrecFamily    = (sfnt_NameRecord *)NULL;
    sfnt_NameRecord * pnrecSubFamily = (sfnt_NameRecord *)NULL;
    sfnt_NameRecord * pnrecUnique    = (sfnt_NameRecord *)NULL;
    sfnt_NameRecord * pnrecFull      = (sfnt_NameRecord *)NULL;
    sfnt_NameRecord * pnrecVersion   = (sfnt_NameRecord *)NULL;
    sfnt_NameRecord * pnrecFamilyAlias = (sfnt_NameRecord *)NULL;

// get out if this is not one of the platID's we know what to do with

    if ((ui16PlatID != BE_PLAT_ID_MS) && (ui16PlatID != BE_PLAT_ID_MAC))
        RET_FALSE("ttfd!_ do not know how to handle this plat id\n");

// first clean the output structure:

    RtlZeroMemory((PVOID)pifisz, sizeof(IFISIZE));

// first name record is layed just below the naming table

    pnrecInit = (sfnt_NameRecord *)((PBYTE)pname + SIZE_NAMING_TABLE);
    pnrecEnd = &pnrecInit[BE_UINT16(&pname->count)];

// in the first iteration of the loop we want to match lang id to our
// favorite lang id. If we find all 4 strings in that language we are
// done. If we do not find all 4 string with matching lang id we will try to
// language only, but not sublanguage. For instance if Canadian French
// is requested, but the file only contains "French" French names, we will
// return the names in French French. If that does not work either
// we shall go over name records again and try to find
// the strings in English. If that does not work either we
// shall resort to total desperation and just pick any language.
// therefore we may go up to 4 times through the NAME_LOOP

    bFoundAllNames = FALSE;

    EngGetCurrentCodePage(&OemCodePage,&AnsiCodePage);

// find the name record with the desired ID's
// NAME_LOOP:

    for (iNameLoop = 0; (iNameLoop < 4) && !bFoundAllNames; iNameLoop++)
    {
        for
        (
          pnrec = pnrecInit;
          (pnrec < pnrecEnd) && !(bFoundAllNames && (pnrecVersion != NULL));
          pnrec++
        )
        {
            switch (iNameLoop)
            {
            case 0:
            // match BOTH language and sublanguage

                bMatchLangId = (pnrec->languageID == ui16LangID);
                break;

            case 1:
            // match language but not sublanguage
            // except if we are dealing with LANG_CHINESE then we need to see 
            // the font code page is same as system defaul or not

                if ((ui16LangID & 0xff00) == 0x0400) // LANG_CHINESE == 0x0400
                {
                    if ((ConvertLangIDtoCodePage(pnrec->languageID) != AnsiCodePage))
                    {
                        bMatchLangId = ((pnrec->languageID & 0xff00) == 0x0900);
                    }
                    else
                    {
                        bMatchLangId = ((pnrec->languageID & 0xff00) == (ui16LangID & 0xff00));
                    }
                }
                else
                {
                    bMatchLangId = ((pnrec->languageID & 0xff00) == (ui16LangID & 0xff00));
                }
                break;

            case 2:
            // try to find english names if desired language is not available

                if ((ui16LangID & 0xff00) == 0x0400) // LANG_CHINESE == 0x0400
                {
                    if ((ConvertLangIDtoCodePage(pnrec->languageID) != AnsiCodePage))
                    {
                        bMatchLangId = ((pnrec->languageID & 0xff00) == (ui16LangID & 0xff00));
                    }
                    else
                    {
                        bMatchLangId = ((pnrec->languageID & 0xff00) == 0x0900);
                    }
                }
                else
                {
                    bMatchLangId = ((pnrec->languageID & 0xff00) == 0x0900);
                }
                break;

            case 3:
            // do not care to match language at all, just give us something

                bMatchLangId = TRUE;
                break;

            default:
                RIP("ttfd! must not have more than 3 loop iterations\n");
                break;
            }

            if
            (
                (pnrec->platformID == ui16PlatID) &&
                (pnrec->specificID == ui16SpecID) &&
                bMatchLangId
            )
            {
                switch (pnrec->nameID)
                {
                case BE_NAME_ID_FAMILY:

                    if (!pnrecFamily) // if we did not find it before
                        pnrecFamily = pnrec;
                    break;

                case BE_NAME_ID_SUBFAMILY:

                    if (!pnrecSubFamily) // if we did not find it before
                        pnrecSubFamily = pnrec;
                    break;

                case BE_NAME_ID_UNIQNAME:

                    if (!pnrecUnique) // if we did not find it before
                        pnrecUnique = pnrec;
                    break;

                case BE_NAME_ID_FULLNAME:

                    if (!pnrecFull)    // if we did not find it before
                        pnrecFull = pnrec;
                    break;

                case BE_NAME_ID_VERSION  :

                    if (!pnrecVersion)    // if we did not find it before
                        pnrecVersion = pnrec;
                    break;

                case BE_NAME_ID_COPYRIGHT:
                case BE_NAME_ID_PSCRIPT  :
                case BE_NAME_ID_TRADEMARK:
                    break;

                default:
                    RIP("ttfd!bogus name ID\n");
                    break;
                }

            }

            bFoundAllNames = (
                (pnrecFamily    != NULL)    &&
                (pnrecSubFamily != NULL)    &&
                (pnrecUnique    != NULL)    &&
                (pnrecFull      != NULL)
                );
        }


    } // end of iNameLoop

    if (!bFoundAllNames)
    {
    // we have gone through the all 3 iterations of the NAME loop
    // and still have not found all the names. We have singled out
    // pnrecVersion because it is not required for the font to be
    // loaded, we only need it to check if this a ttf converted from t1

        RETURN("ttfd!can not find all name strings in a file\n", FALSE);
    }

// let us check if there  is a family alias, usually only exists in
// FE tt fonts, where there might be a western and fe family name.

    for (pnrec = pnrecInit; pnrec < pnrecEnd; pnrec++)
    {
      if ((pnrec->platformID == ui16PlatID)   &&
           (pnrec->specificID == ui16SpecID)  &&
           (pnrec->nameID == BE_NAME_ID_FAMILY) &&
          (pnrecFamily != pnrec)
       )
            {
              pnrecFamilyAlias = pnrec;
              break;
            }
    }

// get the pointer to the beginning of the storage area for strings

    pjStorage = (PBYTE)pname + BE_UINT16(&pname->stringOffset);

    if (ui16PlatID == BE_PLAT_ID_MS)
    {
    // offsets in the records are relative to the beginning of the storage

        pifisz->cjFamilyName = BE_UINT16(&pnrecFamily->length) +
                               sizeof(WCHAR); // for terminating zero
        pifisz->pjFamilyName = pjStorage +
                               BE_UINT16(&pnrecFamily->offset);

        if(pnrecFamilyAlias)
        {
            pifisz->cjFamilyNameAlias = BE_UINT16(&pnrecFamilyAlias->length) +
                     sizeof(WCHAR);
            pifisz->pjFamilyNameAlias = pjStorage + BE_UINT16(&pnrecFamilyAlias->offset);
        }
        else
        {
            pifisz->cjFamilyNameAlias = 0;
            pifisz->pjFamilyNameAlias = NULL;
        }

        pifisz->cjSubfamilyName = BE_UINT16(&pnrecSubFamily->length) +
                                  sizeof(WCHAR); // for terminating zero
        pifisz->pjSubfamilyName = pjStorage +
                                  BE_UINT16(&pnrecSubFamily->offset);

        pifisz->cjUniqueName = BE_UINT16(&pnrecUnique->length) +
                               sizeof(WCHAR); // for terminating zero
        pifisz->pjUniqueName = pjStorage +
                               BE_UINT16(&pnrecUnique->offset);

        pifisz->cjFullName = BE_UINT16(&pnrecFull->length) +
                             sizeof(WCHAR); // for terminating zero
        pifisz->pjFullName = pjStorage +
                             BE_UINT16(&pnrecFull->offset);
    }
    else  // mac id
    {
    // offsets in the records are relative to the beginning of the storage

        pifisz->cjFamilyName = sizeof(WCHAR) * BE_UINT16(&pnrecFamily->length) +
                               sizeof(WCHAR); // for terminating zero
        pifisz->pjFamilyName = pjStorage +
                               BE_UINT16(&pnrecFamily->offset);

    // In MAC case, we do not need to handle the FamilyNameAlias

        pifisz->cjFamilyNameAlias = 0;
        pifisz->pjFamilyNameAlias = NULL;

        pifisz->cjSubfamilyName = sizeof(WCHAR) * BE_UINT16(&pnrecSubFamily->length) +
                                  sizeof(WCHAR); // for terminating zero
        pifisz->pjSubfamilyName = pjStorage +
                                  BE_UINT16(&pnrecSubFamily->offset);

        pifisz->cjUniqueName = sizeof(WCHAR) * BE_UINT16(&pnrecUnique->length) +
                               sizeof(WCHAR); // for terminating zero
        pifisz->pjUniqueName = pjStorage +
                               BE_UINT16(&pnrecUnique->offset);

        pifisz->cjFullName = sizeof(WCHAR) * BE_UINT16(&pnrecFull->length) +
                             sizeof(WCHAR); // for terminating zero
        pifisz->pjFullName = pjStorage +
                             BE_UINT16(&pnrecFull->offset);
    }

// check out if this is a converted Type 1 font:

    *pbType1 = FALSE; // default

    if (pnrecVersion)
    {
        ULONG ulLen;
        BYTE  *pjVersion = pjStorage + BE_UINT16(&pnrecVersion->offset);

        if (ui16PlatID == BE_PLAT_ID_MS)
        {
            ulLen = BE_UINT16(&pnrecVersion->length);
            if (ulLen > sizeof(awszType1))
                ulLen = sizeof(awszType1);
            ulLen -= sizeof(WCHAR); // minus terminating zero

            *pbType1 = !memcmp(pjVersion, awszType1, ulLen);
        }
        else // mac id
        {
            ulLen = BE_UINT16(&pnrecVersion->length); // minus term. zero
            if (ulLen > sizeof(pszType1))
                ulLen = sizeof(pszType1);
            ulLen -= 1; // minus terminating zero

            *pbType1 = !strncmp(pjVersion, pszType1, ulLen);
        }
    }

// lay the strings below the ifimetrics
// but insert IFIEXTRA below ifimetrics itself and before strings

    pifisz->cjIFI = sizeof(IFIMETRICS)      +
                    offsetof(IFIEXTRA, dpDesignVector) +
                    pifisz->cjFamilyName        +
                    pifisz->cjFamilyNameAlias   +
                    pifisz->cjSubfamilyName     +
                    pifisz->cjUniqueName        +
                    pifisz->cjFullName          ;

    pifisz->cjIFI = DWORD_ALIGN(pifisz->cjIFI);

// we may need to add a '@' to facename and family name in case this
// font has a vertical face name

    pifisz->cjIFI += sizeof(WCHAR) * 2;
    if (pifisz->cjFamilyNameAlias)
    {
    // one WCHAR for @, the other one for double terminating zero L\'0'

   pifisz->cjIFI += 2 * sizeof(WCHAR);
    }

    {
        ULONG cSims = 0;

        switch (fsSelectionTTFD(pjView,ptp) & (FM_SEL_BOLD | FM_SEL_ITALIC))
        {
        case 0:
            cSims = 3;
            break;

        case FM_SEL_BOLD:
        case FM_SEL_ITALIC:
            cSims = 1;
            break;

        case (FM_SEL_ITALIC | FM_SEL_BOLD):
            cSims = 0;
            break;

        default:
            RIP("TTFD!tampering with flags\n");
            break;
        }

        if (cSims)
        {
            pifisz->dpSims = pifisz->cjIFI;
            pifisz->cjIFI += (DWORD_ALIGN(sizeof(FONTSIM)) + cSims * DWORD_ALIGN(sizeof(FONTDIFF)));
        }
        else
        {
            pifisz->dpSims = 0;
        }
    }

// add charset info:

    pifisz->dpCharSets = pifisz->cjIFI;
    pifisz->cjIFI += DWORD_ALIGN(NOEMCHARSETS);

// finally check if FONTSIGNATURE info is needed

    pOS2 = (sfnt_OS2 *)((ptp->ateOpt[IT_OPT_OS2].dp)         ?
                         pjView + ptp->ateOpt[IT_OPT_OS2].dp :
                         NULL)                               ;

    if (pOS2)
    {
    // used to 1.0 or higher is TT open
	// but version 0 already contain some of those flags, changed to fix problem with Tamil fonts

        pifisz->dpFontSig = pifisz->cjIFI;
        pifisz->cjIFI += sizeof(FONTSIGNATURE); // 6 dwords, no need to add dword align
    }

// Here is the code to know it is a shell font or not

// Most of case, we do not need to check it.

    *pulShellFont = 0;

    if (pifisz->cjUniqueName == (MICROSS_SHELLFONT_SIZE * 2))
    {
        if (bShellFontFace(PSZ_MICROSS_SHELLFONT, pifisz->pjUniqueName, MICROSS_SHELLFONT_SIZE))
        {
            *pulShellFont = MICROSS_SHELLFONT;
        }
    }
    else if (pifisz->cjUniqueName == (TAHOMA_SHELLFONT_SIZE * 2))
    {
        if (bShellFontFace(PSZ_TAHOMA_SHELLFONT, pifisz->pjUniqueName, TAHOMA_SHELLFONT_SIZE))
        {
            *pulShellFont = TAHOMA_SHELLFONT;
        }
    }
    else if (pifisz->cjUniqueName == (TAHOMA_BOLD_SHELLFONT_SIZE * 2))
    {
        if (bShellFontFace(PSZ_TAHOMA_BOLD_SHELLFONT, pifisz->pjUniqueName, TAHOMA_BOLD_SHELLFONT_SIZE))
        {
            *pulShellFont = TAHOMA_BOLD_SHELLFONT;
        }
    }

    pifisz->cjIFI = NATURAL_ALIGN( pifisz->cjIFI );
    return (TRUE);
}

/******************************Public*Routine******************************\
*
* STATIC BOOL  bCheckLocaTable
*
* Effects:
*
* Warnings:
*
* History:
*  20-June-2000 -by- Sung-Tae Yoo [styoo]
* Wrote it.
\**************************************************************************/

STATIC BOOL  bCheckLocaTable
(
int16	indexToLocFormat,
BYTE    *pjView,
TABLE_POINTERS   *ptp,
uint16 	numGlyphs
)
{
	uint16	i;
	
	if(indexToLocFormat){	//For Long Offsets
		uint32* pLongOffSet;

		pLongOffSet = (uint32 *)(pjView + ptp->ateReq[IT_REQ_LOCA].dp);

		for(i=0; i<numGlyphs-1; i++)
			if( (uint32)SWAPL(pLongOffSet[i]) > (uint32)SWAPL(pLongOffSet[i+1]) )
				return (FALSE);
	}
	else{	//For Short Offsets
		uint16* pShortOffSet;

		pShortOffSet = (uint16 *)(pjView + ptp->ateReq[IT_REQ_LOCA].dp);

		for(i=0; i<numGlyphs-1; i++)
			if( (uint16)SWAPW(pShortOffSet[i]) > (uint16)SWAPW(pShortOffSet[i+1]) )
				return (FALSE);
	}

	return (TRUE);
}

/******************************Public*Routine******************************\
*
* STATIC BOOL  bCheckHdmxTable
*
* Effects:
*
* Warnings:
*
* History:
*  20-Sep-2000 -by- Sung-Tae Yoo [styoo]
* Wrote it.
\**************************************************************************/

STATIC BOOL  bCheckHdmxTable
(
	sfnt_hdmx	   *phdmx,
	ULONG 			size
)
{
	return( size >= (ULONG) (SWAPW(phdmx->sNumRecords) * SWAPL(phdmx->lSizeRecord) + 8));
}

/******************************Public*Routine******************************\
*
* STATIC void vDetectOldBiDiFonts
*
* Effects:
*
* Warnings:
*
* History:
*  10-May-1999 -by- Samer Arafeh [SamerA]
* Wrote it.
\**************************************************************************/

STATIC void
vDetectOldBiDiFonts(
    sfnt_OS2 *pOS2,
    ULONG     ul_startCount,
    ULONG    *pulGsetType,
    ULONG    *pul_wcBias
    )
{

    if (EngLpkInstalled())
    {
    // Treat old BiDi fonts correctly, if langpack is installed
    
        if (pOS2 &&
            ((ul_startCount & 0xff00) >= 0xf000) &&
            ((ul_startCount & 0xff00) <= 0xf2ff) )
        {
            switch (pOS2->usSelection & 0x00ff)     // win 31 foreign charsets
            {
                case 0xb1:
                case 0xb2:
                case 0xb3:
                case 0xb4:
                case 0xb5:

                    *pulGsetType = GSET_TYPE_OLDBIDI ;
                    *pul_wcBias  = ul_startCount & 0xff00;
                break ;
            }
        }
    }
}


/******************************Public*Routine******************************\
*
* STATIC BOOL bComputeIDs
*
* Effects:
*
* Warnings:
*
* History:
*  13-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC BOOL
bComputeIDs (
    BYTE              * pjView,
    TABLE_POINTERS     *ptp,
    uint16             *pui16PlatID,
    uint16             *pui16SpecID,
    sfnt_mappingTable **ppmap,
    ULONG              *pulGsetType,
    ULONG              *pul_wcBias,
    CMAPINFO           *pcmi
    )
{
    ULONG ul_startCount=0L;

    sfnt_char2IndexDirectory * pcmap =
            (sfnt_char2IndexDirectory *)(pjView + ptp->ateReq[IT_REQ_CMAP].dp);

    sfnt_platformEntry * pplat = &pcmap->platform[0];
    sfnt_platformEntry * pplatEnd = pplat + BE_UINT16(&pcmap->numTables);
    sfnt_platformEntry * pplatMac = (sfnt_platformEntry *)NULL;

	uint32 sizeOfCmap = ptp->ateReq[IT_REQ_CMAP].cj;

    *ppmap = (sfnt_mappingTable  *)NULL;
    *pul_wcBias  = 0;

    if (pcmap->version != 0) // no need to swap bytes, 0 == be 0
        RET_FALSE("TTFD!_bComputeIDs: version number\n");
    if (BE_UINT16(&(pcmap->numTables)) > 30)
    {
        RET_FALSE("Number of cmap tables greater than 30 -- probably a bad font\n");
    }

// find the first sfnt_platformEntry with platformID == PLAT_ID_MS,
// if there was no MS mapping table, go for the mac one
    for (; pplat < pplatEnd; pplat++)
    {
        if (pplat->platformID == BE_PLAT_ID_MS)
        {
            BOOL bRet;
            uint32 offset = (uint32) SWAPL(pplat->offset);

            *pui16PlatID = BE_PLAT_ID_MS;
            *pui16SpecID = pplat->specificID;

            if( offset > sizeOfCmap )
            	RET_FALSE("Start position of cmap subtable is out of cmap size -- mustbe bad font\n");

            *ppmap = (sfnt_mappingTable  *) ((PBYTE)pcmap + offset);

// We rolled back this because of Corel's font bug. And we will improve this checking at Blackcomb
//            if( offset + (uint16) SWAPW((*ppmap)->length) > sizeOfCmap )
//            	RET_FALSE("End position of cmap subtable is out of cmap size -- mustbe bad font\n");

            switch((*ppmap)->format)
            {
              case BE_FORMAT_MSFT_UNICODE :

                switch(pplat->specificID)
                {
                  case BE_SPEC_ID_SHIFTJIS :
                  case BE_SPEC_ID_GB :
                  case BE_SPEC_ID_BIG5 :
                  case BE_SPEC_ID_WANSUNG :

                    bRet = bVerifyMsftTableGeneral(*ppmap,pulGsetType,pcmi,
                                                   pplat->specificID);
                    break;

                  case BE_SPEC_ID_UGL :
                  default :

                // this will set *pulGsetType to GSET_TYPE_GENERAL

                    bRet = bVerifyMsftTable(*ppmap,pulGsetType,pul_wcBias,pcmi,
                                             pplat->specificID
                                            ,&ul_startCount
                                           );
                    break;
                }
                break;

              case BE_FORMAT_HIGH_BYTE :

                bRet = bVerifyMsftHighByteTable(*ppmap,
                                                pulGsetType,pcmi,pplat->specificID);
                break;

                default :

                bRet = FALSE;
                break;
            }

            if(!bRet)
            {
                *ppmap = (sfnt_mappingTable  *)NULL;
                RET_FALSE("TTFD!_bComputeIDs: bVerifyMsftTable failed \n");
            }

            // keep specific ID in CMAPINFO

            pcmi->ui16SpecID = pplat->specificID;

            if (pplat->specificID == BE_SPEC_ID_UNDEFINED)
            {
            // correct the value of the glyph set, we cheat here

                sfnt_OS2 * pOS2 = (sfnt_OS2 *)(
                               (ptp->ateOpt[IT_OPT_OS2].dp)    ?
                               pjView + ptp->ateOpt[IT_OPT_OS2].dp :
                               NULL
                               );

                BOOL bSymbol = FALSE;
                if (pOS2)
                {
                    if (((pOS2->usSelection & 0x00ff) == ANSI_CHARSET) &&
                        (pOS2->Panose[0]==PAN_FAMILY_PICTORIAL)) // means symbol
                        bSymbol = TRUE;
                }

            // this code is put here because of the need to differentiate
            // between msicons2.ttf and bahamn1.ttf.
            // Both of them have Bias = 0, but msicons2 is a symbol font.

                if (*pul_wcBias || bSymbol)
                    *pulGsetType = GSET_TYPE_SYMBOL;

                vDetectOldBiDiFonts( pOS2,
                                     ul_startCount,
                                     pulGsetType,
                                     pul_wcBias );
            }
            else if (pplat->specificID == BE_SPEC_ID_UGL)
            {

                if (*pul_wcBias)  // we are really using f0?? range to put in a symbol font
                {
                    sfnt_OS2 * pOS2 = (sfnt_OS2 *)(
                                   (ptp->ateOpt[IT_OPT_OS2].dp)    ?
                                   pjView + ptp->ateOpt[IT_OPT_OS2].dp :
                                   NULL
                               );

                    *pulGsetType = GSET_TYPE_SYMBOL;

                //
                // some bidi fonts claims they're Unicode (plat=3, specid = 1), however
                // they've a fixed fp like ghaim.ttf
                //
                    vDetectOldBiDiFonts( pOS2,
                                         ul_startCount,
                                         pulGsetType,
                                         pul_wcBias );
                }
            }

            return (TRUE);
        }

        if ((pplat->platformID == BE_PLAT_ID_MAC)  &&
            (pplat->specificID == BE_SPEC_ID_UNDEFINED))
        {
            pplatMac = pplat;
        }
    }

    if (pplatMac != (sfnt_platformEntry *)NULL)
    {
        uint32 offset = (uint32) SWAPL(pplat->offset);
        *pui16PlatID = BE_PLAT_ID_MAC;
        *pui16SpecID = BE_SPEC_ID_UNDEFINED;

        if( offset > sizeOfCmap )
           	RET_FALSE("Offset of cmap subtable is out of cmap size -- mustbe bad font\n");

		*ppmap = (sfnt_mappingTable  *) ((PBYTE)pcmap + offset);

        if( offset + (uint16) SWAPW((*ppmap)->length) > sizeOfCmap )
          	RET_FALSE("End position of cmap subtable is out of cmap size -- mustbe bad font\n");

        if (!bVerifyMacTable(*ppmap))
        {
            *ppmap = (sfnt_mappingTable  *)NULL;
            RET_FALSE("TTFD!_bComputeIDs: bVerifyMacTable failed \n");
        }

    //!!! lang issues, what if not roman but thai mac char set ??? [bodind]

    // see if it is necessary to convert unicode to mac code points, or we
    // shall cheat in case of symbol char set for win31 compatiblity

        if (bCvtUnToMac(pjView, ptp, *pui16PlatID))
        {
            *pulGsetType = GSET_TYPE_MAC_ROMAN;
        }
        else
        {
            *pulGsetType = GSET_TYPE_PSEUDO_WIN;
        }
        return(TRUE);
    }
    else
    {
        RET_FALSE("TTFD!_bComputeIDs: unknown platID\n");
    }

}


/******************************Public*Routine******************************\
*
* STATIC VOID vComputeGLYPHSET_MSFT_UNICODE
*
* computes the glyphset structure for the cmap table that has
* format 4 = MSFT_UNICODE
*
* History:
*  22-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC ULONG
cjComputeGLYPHSET_MSFT_UNICODE (
    sfnt_mappingTable     *pmap,
    fs_GlyphInputType     *pgin,
    fs_GlyphInfoType      *pgout,
    FD_GLYPHSET           *pgset,
    CMAPINFO              *pcmi
    )
{
    uint16 * pstartCount;
    uint16 * pendCount;
    uint16   cRuns, cRuns5cSplit;
    PWCRUN   pwcrun, pwcrunEnd, pwcrunInit, pwcrun_b7, pwcrun5cFirst;
    HGLYPH  *phg;
    ULONG    cjRet;
    FS_ENTRY iRet;
    BOOL     bInsert_b7;

    #if DBG
    ULONG    cGlyphsSupported = 0;
    #endif

    cRuns5cSplit = 0;

    if(pcmi->fl & CMI_5C_SPLIT)
    {
        cRuns5cSplit = 1;
    }

    cjRet = SZ_GLYPHSET((pcmi->cRuns + cRuns5cSplit), pcmi->cGlyphs);


    if (!pgset)
    {
        return cjRet;
    }

// check if need to insert an extra run for b7 only

    bInsert_b7 = ((pcmi->fl & (CMI_2219_PRESENT | CMI_B7_ABSENT)) == (CMI_2219_PRESENT | CMI_B7_ABSENT));

    cRuns = BE_UINT16((PBYTE)pmap + OFF_segCountX2) >> 1;

// get the pointer to the beginning of the array of endCount code points

    pendCount = (uint16 *)((PBYTE)pmap + OFF_endCount);

// the final endCode has to be 0xffff;
// if this is not the case, there is a bug in the tt file or in our code:

    ASSERTDD(pendCount[cRuns - 1] == 0xFFFF,
              "pendCount[cRuns - 1] != 0xFFFF\n");

// Get the pointer to the beginning of the array of startCount code points
// For resons known only to tt designers, startCount array does not
// begin immediately after the end of endCount array, i.e. at
// &pendCount[cRuns]. Instead, they insert an uint16 padding which has to
// set to zero and the startCount array begins after the padding. This
// padding in no way helps alignment of the structure

//    ASSERTDD(pendCount[cRuns] == 0, "TTFD!_padding != 0\n");

    pstartCount = &pendCount[cRuns + 1];

// here we shall check if the last run is just a terminator for the
// array of runs or a real nontrivial run. If just a terminator, there is no
// need to report it. This will save some memory in the cache plus
// pifi->wcLast will represent the last glyph that is truly supported in
// font:

    if ((pstartCount[cRuns-1] == 0xffff) && (cRuns > 1))
        cRuns -= 1; // do not report trivial run

// real no of runs, including the range for b7: If b7 is already supportred
// then the same as number of runs reported in a font. If b7 is not supported
// we will have to add a range [b7,b7] to the glyphset structure for win31
// compatibility reasons. win31 maps b7 to 2219 and we will have b7 point to 2219

    if (bInsert_b7)  // if b7 not supported in a font but 2219 is
    {
        pcmi->i_b7 += cRuns5cSplit;
        cRuns++;              // add a run with b7 only
    }

// by default we will not have to simulate the presence of b7 by adding
// an extra run containing single glyph

    pwcrun_b7 = NULL;

    pwcrunInit = &pgset->awcrun[0];

// Add one more run for 5c split

    pwcrun5cFirst = NULL;

    if(cRuns5cSplit)
    {
        cRuns++;
        pwcrun5cFirst = pwcrunInit;
    }

    phg = (HGLYPH *)((PBYTE)pgset + offsetof(FD_GLYPHSET,awcrun) + cRuns*sizeof(WCRUN));

    if (bInsert_b7)  // if b7 not supported in a font, will have to add it
    {
        pwcrun_b7 = pwcrunInit + pcmi->i_b7;
    }

    ASSERTDD((pcmi->cRuns+cRuns5cSplit) == cRuns, "cRuns\n");

    for
    (
         pwcrun = pwcrunInit, pwcrunEnd = pwcrunInit + cRuns;
         pwcrun < pwcrunEnd;
         pwcrun++, pstartCount++, pendCount++
    )
    {
        WCHAR   wcFirst, wcLast;

    // check if we need to skip a run and a handle space for b7:

        if (bInsert_b7 && (pwcrun == pwcrun_b7))
        {
        #if DBG
            cGlyphsSupported += 1;   // list b7 as a supported glyph
        #endif

            pwcrun->wcLow = 0xb7;
            pwcrun->cGlyphs = 1;
            pwcrun->phg = phg;         // will be initialized later
            phg++;                     // skip to the next handle
            pwcrun++;                  // go to the next run
            if (pwcrun == pwcrunEnd)   // check if done
            {
                break; // done
            }
        }

        wcFirst = (WCHAR)BE_UINT16(pstartCount);
        wcLast  = (WCHAR)BE_UINT16(pendCount);

        pwcrun->cGlyphs = (USHORT)(wcLast - wcFirst + 1);

    // is this a run which contains b7 ?

        if ((0xb7 >= wcFirst) && (0xb7 <= wcLast))
            pwcrun_b7 = pwcrun;

    // add the default glyph at the end of the first run, if possible, i.e.
    // if wcLast < 0xffff for the first run, and if we are not in the collision
    // with the run we have possibly added for b7
    // Above adding default glyph has been removed since nobody use that default
    // glyph and adding default glyph broke font link.        katsumiy 8/15/2000


    #if DBG
        cGlyphsSupported += pwcrun->cGlyphs;
    #endif

        pwcrun->wcLow   = wcFirst;
        pwcrun->phg     = phg;

        if(pwcrun == pwcrun5cFirst)
        {
            USHORT  cGlyphs;

            cGlyphs = pwcrun->cGlyphs;
            pwcrun->cGlyphs = 0x5c - pwcrun->wcLow;

            if ((iRet = fs_WinNTGetGlyphIDs (pgin, pwcrun->cGlyphs, wcFirst, 0, NULL, phg)) != NO_ERR)
            {
                V_FSERROR(iRet);
                RET_FALSE("TTFD!_cjComputeGLYPHSET_MSFT_UNICODE, fs_WinNTGetGlyphIDs\n");
            }
            phg += pwcrun->cGlyphs;

            // For the split run
    		cGlyphs = cGlyphs - pwcrun->cGlyphs - 1;
    		pwcrun++;
            pwcrun->wcLow   = 0x5d;
            pwcrun->phg     = phg;
            pwcrun->cGlyphs = cGlyphs;

            if ((iRet = fs_WinNTGetGlyphIDs (pgin, pwcrun->cGlyphs, 0x5d, 0, NULL, phg)) != NO_ERR)
            {
                V_FSERROR(iRet);
                RET_FALSE("TTFD!_cjComputeGLYPHSET_MSFT_UNICODE, fs_WinNTGetGlyphIDs\n");
            }

            phg += pwcrun->cGlyphs;
            
#if DBG
            cGlyphsSupported--;
#endif
            pcmi->cGlyphs--;
        }
        else
        {
            if (wcFirst < 0xffff)
            {
              // this test allow bogous font that have duplicate stopper run in the cmap to get installed
              // nt bug #277787, font Isocp2.ttf form Autocad
                if ((iRet = fs_WinNTGetGlyphIDs (pgin, pwcrun->cGlyphs, wcFirst, 0, NULL, phg)) != NO_ERR)
                {
                     V_FSERROR(iRet);
                     RET_FALSE("TTFD!_cjComputeGLYPHSET_MSFT_UNICODE, fs_WinNTGetGlyphIDs\n");
                }
            }

    		phg += pwcrun->cGlyphs;
        }
    }

// fix a handle for b7:

    if (bInsert_b7)
    {
        PWCRUN   pwcrun_2219;

        pcmi->i_2219 += cRuns5cSplit;

        pwcrun_2219 = pwcrunInit + pcmi->i_2219;

        ASSERTDD(pwcrun_b7,"these ptrs must not be 0\n");
        ASSERTDD(0x2219 >= pwcrun_2219->wcLow, "pwcrun_2219->wcLow\n");
        ASSERTDD(0x2219 < (pwcrun_2219->wcLow + pwcrun_2219->cGlyphs),
            "pwcrun_2219->wcHi\n"
            );

        pwcrun_b7->phg[0xb7 - pwcrun_b7->wcLow] =
            pwcrun_2219->phg[0x2219 - pwcrun_2219->wcLow];
    }

    ASSERTDD(pcmi->cGlyphs == cGlyphsSupported, "cGlyphsSupported\n");

    pgset->cjThis  = cjRet;
    pgset->flAccel = GS_16BIT_HANDLES;
    pgset->cGlyphsSupported = pcmi->cGlyphs;
    pgset->cRuns = cRuns;

    return cjRet;
}



/******************************Public*Routine******************************\
*
* STATIC ULONG  cjGsetGeneral
*
* computes the size of FD_GLYPHSET structure for the font represented
* by this mapping Table
*
* History:
*  21-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

//!!! this needs some review [bodind]

STATIC ULONG
cjGsetGeneral(
    sfnt_mappingTable      *pmap,
    CMAPINFO               *pcmi
    )
{
    switch(pmap->format)
    {
    case BE_FORMAT_MAC_STANDARD:

        return 20; // return(ggsetMac->cjThis);

    case BE_FORMAT_MSFT_UNICODE:

        switch(pcmi->ui16SpecID)
        {
          case BE_SPEC_ID_SHIFTJIS :
          case BE_SPEC_ID_GB :
          case BE_SPEC_ID_BIG5 :
          case BE_SPEC_ID_WANSUNG :
            return cjComputeGLYPHSET_MSFT_GENERAL (pmap,NULL,pcmi);

          case BE_SPEC_ID_UGL :
            default :

            return cjComputeGLYPHSET_MSFT_UNICODE (pmap,NULL,NULL,NULL,pcmi);
        }

    case BE_FORMAT_TRIMMED:

        WARNING("TTFD!_cjGsetGeneral: TRIMMED format\n");
        return 0;

    case BE_FORMAT_HIGH_BYTE:

        WARNING("TTFD!_cjGsetGeneral: HIGH_BYTE format\n");
        return 0;

    default:

        WARNING("TTFD!_cjGsetGeneral: illegal format\n");
        return 0;

    }
}





/******************************Public*Routine******************************\
*
* STATIC BOOL bVerifyMsftTable
*
*
* Effects: checks whether the table is consistent with what tt
*          spec claims it should be
*
*
* History:
*  22-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC BOOL
bVerifyMsftTable (
    sfnt_mappingTable *pmap,
    ULONG             *pulGsetType,
    ULONG             *pul_wcBias,
    CMAPINFO          *pcmi,
    uint16             ui16SpecID,
    ULONG             * pul_startCount
    )
{
    uint16 * pstartCount, * pstartCountBegin;
    uint16 * pendCount, * pendCountEnd, * pendCountBegin;
    uint16   cRuns;
    uint16   usLo, usHi, usHiPrev;
    BOOL     bInsert_b7;

    if (pmap->format != BE_FORMAT_MSFT_UNICODE)
        RET_FALSE("TTFD!_bVerifyMsftTable, format\n");

    cRuns = BE_UINT16((PBYTE)pmap + OFF_segCountX2);

    if (cRuns & 1)
        RET_FALSE("TTFD!_bVerifyMsftTable, segCountX2 is odd\n");

    cRuns >>= 1;

//!!! here one could check whether all other quantities in the
//!!! preceding endCount when derived from cRuns are the
//!!! same as in the file [bodind]

// get the pointer to the beginning of the array of endCount code points

    pendCountBegin = pendCount = (uint16 *)((PBYTE)pmap + OFF_endCount);

// the final endCode has to be 0xffff;
// if this is not the case, there is a bug in the tt file or in our code:

    if (pendCount[cRuns - 1] != 0xFFFF)
        RET_FALSE("TTFD!_bVerifyMsftTable, pendCount[cRuns - 1] != 0xFFFF\n");

// Get the pointer to the beginning of the array of startCount code points
// For resons known only to tt designers, startCount array does not
// begin immediately after the end of endCount array, i.e. at
// &pendCount[cRuns]. Instead, they insert an uint16 padding which has to
// set to zero and the startCount array begins after the padding. This
// padding in no way helps alignment of the structure nor it is useful
// for anything else. Moreover, there are fonts which forget to set the
// padding to zero and are otherwise ok (bodoni), which load under win31
// so that I have to remove this check:

#if 0

// used to return false here [bodind]

    if (pendCount[cRuns] != 0)
        TtfdDbgPrint(
            "TTFD!_bVerifyMsftTable, padding = 0x%x\n",
            pendCount[cRuns]
            );

#endif

// set the default, change only as needed

    *pulGsetType = GSET_TYPE_GENERAL;

// check whether the runs are well ordered, find out if b7
// is supported in one of the ranges in a font by checking complimetary ranges
// of glyphs that are NOT SUPPORTED

    usHiPrev = 0;
    pendCountEnd = &pendCount[cRuns];
    pstartCountBegin = pstartCount = &pendCount[cRuns + 1];
// check if this is a candidate for a symbol font
// stored in the unicode range 0xf000 - 0xf0ff that has to be
// mapped to 0x0000-0x00ff range, or maybe if this is a crazy arabic font
// which has glyphs in the range f200-f2ff.
// We have seen several fonts broken in the past as a result od touching the
// next few lines of code that compute wcBias.
// Here are all of these cases:

#if 0

originally, in 3.51 the code was as follows:

   if ((*pul_wcBias & 0xFF00) == 0xF000)
       *pul_wcBias =  0xF000;
   else
       *pul_wcBias = 0;
This did not work for arabic trad.ttf font:

trad.ttf. (arabic) format (3,0), range [f200,f2ff],
wcBias needs to be f200-20 for compat. It can be computed as follows:

<     if ((*pul_wcBias & 0xFF00) == 0xF000)
<         *pul_wcBias =  0xF000;
<     else
<         *pul_wcBias = 0;
---
>     *pul_wcBias = (BE_UINT16(pstartCount)) & 0xFF00;

for some reason this did not work, perhaps because of msicons2.ttf,
had to do fix to a fix

<     *pul_wcBias = (BE_UINT16(pstartCount)) & 0xFF00;
---
>     *pul_wcBias = BE_UINT16(pstartCount) - 0x20; // = f200 - 20 = f1e0.

This is a pathological case, had to be put in so that this font
can work the same way as it does under win95

msicons2.ttf, format (3,0), ranges are [0001,0004], [0007,0007], etc.
wcBias needs to be ?


garam4.ttf. This is a regular (3,1) font with one anomaly which is that the
first range is anomalous [00, 00], the second range is [20,ff] etc.
wcBias needs to be 0 in this case. so the fix is as follows:

<     *pul_wcBias = BE_UINT16(pstartCount) - 0x20;
---
>     *pul_wcBias = BE_UINT16(pstartCount);
>     if (*pul_wcBias & 0xff00) // one of these
>         *pul_wcBias = *pul_wcBias - 0x20;  // covers arabic case
>     else
>         *pul_wcBias = 0; // garam4 case

this is how we arrive at our present code which seems to be breaking
fonts obtained by conversion from Type 1 fonts with custom encoding,
examples being cmr10.ttf (yy font)

cmr10.ttf, format (3,0), ranges [f000, f080], etc,
wcBias needs to be f000 in this case.

also

gotbx__2.ttf, format (3,0), ranges [f005, f006], [f008,f008], etc,
wcBias needs to be f000 in this case.

bahamn1.ttf: format (3,0), ranges [0020, 007E], etc.

#endif

    *pul_wcBias = BE_UINT16(pstartCount);

    *pul_startCount = *pul_wcBias;     // save it to identify BiDi fonts later

    if (ui16SpecID == BE_SPEC_ID_UGL)  // ie. specific id = 1, regular case
    {
        if ((*pul_wcBias & 0xff00) == 0xf000)
        {
            *pul_wcBias = 0xf000; // chess figurine fonts hack, they have spec id == 1, force them to symbol font case.
        }
        else // all other normal fonts:
        {
            *pul_wcBias = 0; // garam4.ttf is in this class
        }
    }
    else // specific id = 0; // symbol font case
    {
    // trad.ttf, msicons2.ttf, cmr10.ttf, gotbx__2.ttf
    // Another interesting font is corel's font Bahamn1.ttf.
    // This font is really not symbol font, it has specific id errorneously
    // set to zero. This font contains some Eastern European characters.
    // For this font we do NOT want to use
    // GSET_TYPE_SYMBOL. This font has the opposite problem from chess figurine
    // font which is a symbol font with specific id set to 1 instead of zero.
        switch (*pul_wcBias & 0xff00)
        {
        case 0xf000:

        // custom encoding t1 fonts converted to tt (cmr10.ttf, gotbx__2.ttf)
        // and and all other "reasonable" tt symbol fonts.
        // Examples of other "reasonable" symbol fonts are
        // marlett.ttf, symbol.ttf and wingding.ttf where for all these fonts
        // the first range is [f020, ???], so that, either formula would work

            *pul_wcBias = 0xf000;
            break;

        case 0: // msicons2.ttf,bahamn1.ttf. How to differentiate between them?

           *pul_wcBias = 0;
           break;

         case 0xe000: // eudc fonts
           *pul_wcBias = 0;
           break;

        case 0xf200:          // trad.ttf FP
        default:
            *pul_wcBias = *pul_wcBias - 0x20;
            break;
        }
    }

// here we shall check if the last run is just a terminator for the
// array of runs or a real nontrivial run. If just a terminator, there is no
// need to report it. This will save some memory in the cache plus
// pifi->wcLast will represent the last glyph that is truly supported in
// font:

    if ((pstartCountBegin[cRuns-1] == 0xffff) && (cRuns > 1))
    {
        cRuns -= 1; // do not report trivial run
        pendCountEnd--;
    }

// init the cmap info:

    pcmi->fl         = 0;
    pcmi->i_b7       = 0;       // index for [b7,b7] wcrun in FD_GLYPHSET if b7 is NOT supported
    pcmi->i_2219     = 0;       // cmap index for 2219 if 2219 IS supported
    pcmi->cRuns      = cRuns;   // number of runs in a font, excluding the last run if equal to [ffff,ffff]
    pcmi->cGlyphs    = 0;       // total number of glyphs in a font

    for (
         ;
         pendCount < pendCountEnd;
         pstartCount++, pendCount++, usHiPrev = usHi
        )
    {
        usLo = BE_UINT16(pstartCount);
        usHi = BE_UINT16(pendCount);

        if (usHi < usLo)
            RET_FALSE("TTFD!_bVerifyMsftTable: usHi < usLo\n");
        if (usHiPrev > usLo)
            RET_FALSE("TTFD!_bVerifyMsftTable: usHiPrev > usLo\n");

        pcmi->cGlyphs += (ULONG)(usHi + 1 - usLo);

    // check if b7 is in one of the ranges of glyphs that are NOT SUPPORTED

        if ((0xb7 > usHiPrev) && (0xb7 < usLo))
        {
        // store the index of the run that b7 is going to occupy in FD_GLYPHSET
        // Just in case this index is zero we will store it in the upper word
        // of b7Absent and store 1 in the lower word

            pcmi->fl |= CMI_B7_ABSENT;
            pcmi->i_b7 = (ULONG)(pstartCount - pstartCountBegin);
        }

    // check if 2219 is supported in a font, if not then there is
    // no need to make a handle for b7 equal to the handle for 2219.
    // In other words if 0x2219 is not supported in a font, there will be no
    // need to hack FD_GLYPHSET to make hg(b7) == hg(2219) and possibly add a
    // [b7,b7] range if b7 is not already supported in a font:

        if ((0x2219 >= usLo) && (0x2219 <= usHi))
        {
            pcmi->fl |= CMI_2219_PRESENT;
            pcmi->i_2219 = (ULONG)(pstartCount - pstartCountBegin);
        }
    }

// this is what we will do

// b7 supported       2219 supported  => hg(b7) = hg(2219)
// b7 not supported   2219 supported  => add [b7,b7] range and hg(b7) = hg(2219)
// b7 supported       2219 not supported  => do nothing
// b7 not supported   2219 not supported  => do nothing

    bInsert_b7 = (pcmi->fl & (CMI_2219_PRESENT | CMI_B7_ABSENT)) == (CMI_2219_PRESENT | CMI_B7_ABSENT);

    if (bInsert_b7)
    {
    // will have to insert [b7,b7] run, one more run, one more glyph, i_2219
    // has to be incremented because the run for b7 will be inserted before the
    // run which contains 2219

        pcmi->cRuns++;
        pcmi->cGlyphs++;
        pcmi->i_2219++;
    }

// add a default glyph at the end of the first run if not in collision with
// the run for b7 that we may have possibly inserted and if the first run is
// not the last run at the same time;
// Above adding default glyph has been removed since nobody use that default
// glyph and adding default glyph broke font link.        katsumiy 8/15/2000

    return (TRUE);
}


/******************************Public*Routine******************************\
*
* STATIC BOOL bVerifyMacTable(sfnt_mappingTable * pmap)
*
* just checking consistency of the format
*
* History:
*  23-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC BOOL
bVerifyMacTable(
    sfnt_mappingTable * pmap
    )
{
    if (pmap->format != BE_FORMAT_MAC_STANDARD)
        RET_FALSE("TTFD!_bVerifyMacTable, format \n");

// sfnt_mappingTable is followed by <= 256 byte glyphIdArray

    if (BE_UINT16(&pmap->length) > DWORD_ALIGN(SIZEOF_SFNT_MAPPINGTABLE + 256))
        RET_FALSE("TTFD!_bVerifyMacTable, length \n");

    return (TRUE);
}


/******************************Public*Routine******************************\
*
* BOOL bLoadTTF
*
* Effects:
*
* Warnings:
*
* History:
*  29-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

//!!! SHOUD BE RETURNING hff


#define OFF_TTC_Sign           0x0000
#define OFF_TTC_Version        0x0004
#define OFF_TTC_DirectoryCount 0x0008
#define OFF_TTC_DirectoryEntry 0x000C

#define DSIG_LONG_TAG          0x44534947

#define TTC_VERSION_1_0     0x00010000



ULONG GetUlong( PVOID pvView, ULONG ulOffset)
{
    ULONG ulReturn;

    ulReturn = (  (ULONG)*((PBYTE) pvView + ulOffset +3)              |
                (((ULONG)*((PBYTE) pvView + ulOffset +2)) << 8)  |
                (((ULONG)*((PBYTE) pvView + ulOffset +1)) << 16) |
                (((ULONG)*((PBYTE) pvView + ulOffset +0)) << 24)
               );
    return ( ulReturn );
}


BOOL bVerifyTTC (
    PVOID pvView
    )
{
    ULONG ulVersion;
// Check TTC ID.

    #define TTC_ID      0x66637474

    if(*((PULONG)((BYTE*) pvView + OFF_TTC_Sign)) != TTC_ID)
        return(FALSE);

// Check TTC verson.

    ulVersion = SWAPL(*((PULONG)((BYTE*) pvView + OFF_TTC_Version)));

    if (ulVersion < TTC_VERSION_1_0)
        RETURN("TTFD!ttfdLoadFontFileTTC(): wrong TTC version\n", FALSE);

    return(TRUE);
}

void vFontFileCache(PTTC_FONTFILE pttc, ULONG ulFastCheckSum, ULONG flTTCFormat)
{
    PTTC_CACHE  pCache_TTC;
    PTTF_CACHE  pCache_TTF;
    PBYTE       pbCache;
    HFF         hff;
    ULONG       i;
    ULONG       ulSize;
    DWORD       dpTTF;
    DWORD       dpGlyphAttr = 0;

    if (!ulFastCheckSum)
        return;

    ulSize = 0;

// compute how much space we need in cache to store ifimetrics

    for ( i = 0; i < pttc->ulNumEntry; i++ )
    {
        if (pttc->ahffEntry[i].iFace == 1)
        {
            hff = pttc->ahffEntry[i].hff;

            ulSize += offsetof(TTF_CACHE, acIfi) + QWORD_ALIGN(PFF(hff)->ifi.cjThis);
        }
    }

    dpTTF = QWORD_ALIGN(offsetof(TTC_CACHE, dpTTF) + (pttc->ulTrueTypeResource * sizeof (DWORD)));

    ulSize += dpTTF;

    if (PFF(pttc->ahffEntry[0].hff)->ffca.fl & FF_DBCS_CHARSET)
    {
        ASSERTDD(pttc->pga, "vFontFileCache: pga is NULL\n");
        dpGlyphAttr = ulSize;
        ulSize += QWORD_ALIGN(pttc->pga->cjThis);
    }

    if (pCache_TTC = (PTTC_CACHE) EngFntCacheAlloc(ulFastCheckSum, ulSize))
    {
        BOOL bException = FALSE;

        try
        {
            DWORD iTTF = 0;

            pCache_TTC->flTTCFormat = flTTCFormat;
            pCache_TTC->cTTFsInTTC = pttc->ulTrueTypeResource ;
            pCache_TTC->dpGlyphAttr = dpGlyphAttr;
            
        // Now IFI metrices will be cached into TTCACHE file
            pbCache = (PBYTE) pCache_TTC + dpTTF;

            for( i = 0; i < pttc->ulNumEntry; i++ )
            {
                hff = pttc->ahffEntry[i].hff;

                if (pttc->ahffEntry[i].iFace == 1)
                {
                    // start of TTF_CACHE

                    pCache_TTF = (PTTF_CACHE) pbCache;
    
                    // Get the disp for TTF

                    pCache_TTC->dpTTF[iTTF] = (DWORD)((PBYTE) pCache_TTF - (PBYTE)pCache_TTC);

                // IFI Cache will do for normal font face
                // @font face will be copied after normal face finish

                    pCache_TTF->ffca = PFF(hff)->ffca;

                // Copy the IFI into cache

                    RtlCopyMemory((PBYTE) &pCache_TTF->acIfi, (PBYTE) &PFF(hff)->ifi, PFF(hff)->ifi.cjThis);

                // offset of GSET, the offset is calculated from TTF_CACHE

                    pbCache = (PBYTE) &pCache_TTF->acIfi + QWORD_ALIGN (PFF(hff)->ifi.cjThis);

                    if (PFF(hff)->ffca.ulNumFaces == 2)
                    {
                    // Cache the info computed by bCheckVerticalTable:
                        if (PFF(hff)->hgSearchVerticalGlyph == SearchMortTable)
                            pCache_TTF->iSearchVerticalGlyph = SUB_FUNCTION_MORT;
                        else if (PFF(hff)->hgSearchVerticalGlyph == SearchGsubTable)
                            pCache_TTF->iSearchVerticalGlyph = SUB_FUNCTION_GSUB;
                        else
                            pCache_TTF->iSearchVerticalGlyph = SUB_FUNCTION_DUMMY;
                    }
                    else
                    {
                        pCache_TTF->iSearchVerticalGlyph  = SUB_FUNCTION_DUMMY;
                    }

                    iTTF++; // go to the next ttf file
                }
            }

            if (pCache_TTC->dpGlyphAttr)
            {
                ASSERTDD(pttc->pga, "vFontFileCache: pttc->pga is NULL\n");
                RtlCopyMemory((PBYTE)((PBYTE)pCache_TTC + pCache_TTC->dpGlyphAttr), (PBYTE) pttc->pga, pttc->pga->cjThis);
            }
                
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
        // There is something that FAULTed during IFI cache write.

            bException = TRUE;
        }

        if (bException)
        {
            EngFntCacheFault(ulFastCheckSum, ENG_FNT_CACHE_WRITE_FAULT);
        }
    }
}

VOID vCopy_IFIV ( PIFIMETRICS pifi, PIFIMETRICS pifiv)
{
    PWCHAR pwchSrc, pwchDst;

    RtlCopyMemory(pifiv, pifi, pifi->cjThis);

//
// modify facename so that it has '@' at the beginning of facename.
//
    pwchSrc = (PWCHAR)((PBYTE)pifiv + pifiv->dpwszFaceName);
    pwchDst = (PWCHAR)((PBYTE)pifi + pifi->dpwszFaceName);

    *pwchSrc++ = L'@';
    while ( *pwchDst )
    {
        *pwchSrc++ = *pwchDst++;
    }

    *pwchSrc = L'\0';

    // modify familyname so that it has '@' at the beginning of familyname

    pwchSrc = (PWCHAR)((PBYTE)pifiv + pifiv->dpwszFamilyName);
    pwchDst = (PWCHAR)((PBYTE)pifi + pifi->dpwszFamilyName);

    *pwchSrc++ = L'@';

    while ( *pwchDst )
    {
        *pwchSrc++ = *pwchDst++;
    }

    *pwchSrc = L'\0';

    if(pifiv->flInfo & FM_INFO_FAMILY_EQUIV)
    {
        pwchSrc++;
        pwchDst++;

        *pwchSrc++ = L'@';

        while ( *pwchDst )
        {
            *pwchSrc++ = *pwchDst++;
        }

        *pwchSrc++ = L'\0';
        *pwchSrc = L'\0';
    }

}

BOOL bLoadTTF_Cache(
    ULONG_PTR   iFile,
    PVOID       pvView,
    ULONG       cjView,
    ULONG       ulTableOffset,
    ULONG       ulLangId,
    HFF         *phff,
    PTTF_CACHE  pCache,
    ULONG       ulFastCheckSum
    )
{
    PIFIMETRICS         pifiCache;
    PFD_GLYPHSET        pgsetCache;
    PFONTFILE           pff;
    ULONG               cjff;
    PIFIMETRICS         pifiv = NULL; // ifimetrics for the vertical face
    BOOL                bRet;

    ASSERTDD(pCache, "pCache is not allocate \n");

    *phff = HFF_INVALID;

    pifiCache = (PIFIMETRICS) pCache->acIfi;

    cjff = offsetof(FONTFILE,ifi) + pifiCache->cjThis;

    if ((pff = pffAlloc(cjff)) == PFF(NULL))
    {
        RET_FALSE("TTFD!bLoadTTF_Cache(): memory allocation error\n");
    }

    bRet = TRUE;
    *phff = (HFF)pff;

    /* we need to clean the beginning of pff to ensure correct cleanup in case of error/exception */

    RtlZeroMemory((PVOID)pff, offsetof(FONTFILE,ifi));

// init fields of pff structure
// store the ttf file name at the bottom of the strucutre

    pff->pfcToBeFreed = NULL;

// initialize count of HFC's associated with this HFF

    pff->cRef    = 0L;

// remember which file this is

    pff->iFile = iFile;
    pff->pvView = pvView;
    pff->cjView = cjView;

// The kerning pair array is allocated and filled lazily.  So set to NULL
// for now.

    pff->pkp = (FD_KERNINGPAIR *) NULL;

    pff->pj034   = (PBYTE)NULL;
    pff->pfcLast = (FONTCONTEXT *)NULL;

// By default the number of faces is 1L.  The vert facename code may change this.

    pff->pifi_vertical = NULL;
    pff->pgsetv = NULL;
    pff->pgset  = NULL;

    if (pCache->ffca.ulNumFaces == 2)
    {
        ASSERTDD(pCache->ffca.fl & FF_DBCS_CHARSET, "IFI cache: pff->ffca.fl & FF_DBCS_CHARSET == 0\n");

        pifiv = (PIFIMETRICS)PV_ALLOC( NATURAL_ALIGN(pifiCache->cjThis));

        if (pifiv == NULL)
        {
            bRet = FALSE;
            WARNING(" TTF Cache can not allocate enough memory for @face \n");
            goto retError;

        }

    }

    try
    {
    // Copy the pff cache
        pff->ffca = pCache->ffca;

        RtlCopyMemory((PBYTE) &pff->ifi, (PBYTE)pifiCache, pifiCache->cjThis);

        if (pifiv)
        {

            ASSERTDD(pff->ffca.fl & FF_DBCS_CHARSET, "Font file cache something wrong in DBCS charset \n");

            vCopy_IFIV(&pff->ifi, pifiv);

        // save a pointer to the vertical ifimetrics.
        // now we have two faces( normal, @face ) for the fontfile.

            pff->pifi_vertical = pifiv;

        // now we init the fields that are initialized by bCheckVerticalTable in the usual case

            switch (pCache->iSearchVerticalGlyph)
            {
            case SUB_FUNCTION_MORT:
                pff->hgSearchVerticalGlyph = SearchMortTable;
                break;

            case SUB_FUNCTION_GSUB:
                pff->hgSearchVerticalGlyph = SearchGsubTable;
                break;

            case SUB_FUNCTION_DUMMY:
            default:
                pff->hgSearchVerticalGlyph = SearchDummyTable;
                break;
            }
        }

        pff->cRefGSet = 0;
        pff->cRefGSetV = 0;
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        bRet = FALSE;
    }

    if (!bRet)
    {
        EngFntCacheFault(ulFastCheckSum, ENG_FNT_CACHE_READ_FAULT);
    }

retError:
    if (!bRet)
    {

    // Free FONTFILE * pff
        if (*phff)
        {
            vFreeFF(*phff);
            *phff = (HFF)NULL;
        }

    //  Free IFI for  @face
        if (pifiv)
        {
            V_FREE(pifiv);
            pifiv = NULL;
        }

    }

    return bRet;
}

BOOL bLoadFontFile (
    ULONG_PTR iFile,
    PVOID pvView,
    ULONG cjView,
    ULONG ulLangId,
    ULONG ulFastCheckSum,
    HFF   *phttc
    )
{
    BOOL            bRet = FALSE;

    BOOL           bTTCFormat;
    PTTC_FONTFILE  pttc;
    ULONG          cjttc,i;

    HFF hff;

    PTTC_CACHE      pCache_TTC;
    PTTF_CACHE      pCache_TTF;
    BOOL            bCached;
    ULONG           ulSize;

    *phttc = (HFF)NULL; // Important for clean up in case of exception


// How mamy TrueType resources in this file if TTC file.

// Look up the fontcache for IFI metrices

    pCache_TTC = NULL;
    pCache_TTF = NULL;
    bCached = FALSE;   // flag that info is not in the cache

// ulCheckSum means, Font file Cache now is active and we need to read or write from TTCACHE

    if (ulFastCheckSum)
    {
        pCache_TTC = (PTTC_CACHE) EngFntCacheLookUp(ulFastCheckSum, &ulSize);

        if (pCache_TTC)
        {

        // Check this is a TrueType collection format or not.
        
            bTTCFormat = pCache_TTC->flTTCFormat;
            
            bCached = TRUE;
        }
    }
    
    if (!bCached)
    {
    // Check this is a TrueType collection format or not.

        bTTCFormat = bVerifyTTC(pvView);
    }

    if(bTTCFormat)
    {
        ULONG     ulTrueTypeResource;
        ULONG     ulEntry;
        BOOL      bCanBeLoaded = TRUE;

    // Get Directory count.

        if (bCached)
            ulTrueTypeResource = pCache_TTC->cTTFsInTTC;
        else
            ulTrueTypeResource = GetUlong(pvView,OFF_TTC_DirectoryCount);


   // Allocate TTC_FONTFILE structure

        cjttc =  offsetof(TTC_FONTFILE,ahffEntry);
        cjttc += sizeof(TTC_HFF_ENTRY) * ulTrueTypeResource * 2; // *2 for Vertical face

        *phttc = (HFF)pttcAlloc(cjttc);

        pttc = (PTTC_FONTFILE)*phttc;

        if(pttc == (HFF)NULL)
            RETURN("TTFD!ttfdLoadFontFileTTC(): pttcAlloc failed\n", FALSE);

        
    // fill hff array in TTC_FONTFILE struture

        ulEntry = 0;

        for( i = 0; i < ulTrueTypeResource; i++ )
        {
            ULONG    ulOffset;


        // get the starting offset of a TrueType font resource.
            if (bCached)
            {
                pCache_TTF = (PTTF_CACHE) ((PBYTE) pCache_TTC + pCache_TTC->dpTTF[i]);
                ulOffset = pCache_TTF->ffca.ulTableOffset;
            }
            else
            {
                pCache_TTF = NULL;
                ulOffset = GetUlong(pvView,(OFF_TTC_DirectoryEntry + (4 * i)));
            }

        // load font..

            pttc->ahffEntry[ulEntry].iFace = 1; // start from 1.
            pttc->ahffEntry[ulEntry].ulOffsetTable = ulOffset;

            if (bLoadTTF(iFile,pvView,cjView,ulOffset,ulLangId,&pttc->ahffEntry[ulEntry].hff,pCache_TTF, ulFastCheckSum))
            {
                hff = pttc->ahffEntry[ulEntry].hff;

            // set pointer to TTC_FONTFILE in FONTFILE structure

                PFF(hff)->pttc = pttc;

                ASSERTDD(
                    PFF(hff)->ffca.ulNumFaces <= 2,
                    "TTFD!ulNumFaces > 2\n"
                    );

                if (PFF(hff)->ffca.ulNumFaces == 2)
                {
                    pttc->ahffEntry[ulEntry + 1].hff	= hff;
                    pttc->ahffEntry[ulEntry + 1].iFace = 2; // start from 1.
                    pttc->ahffEntry[ulEntry + 1].ulOffsetTable = ulOffset;
                }

                ulEntry += PFF(hff)->ffca.ulNumFaces;
            }
            else
            {
                bCanBeLoaded = FALSE;
                break;
            }
        }

    // Is there a font that could be loaded ?

        if(bCanBeLoaded)
        {
            ASSERTDD(
                (ulTrueTypeResource * 2) >= ulEntry,
                "TTFD!ulTrueTypeResource * 2 < ulEntry\n"
                );

            pttc->ulTrueTypeResource = ulTrueTypeResource;
            pttc->ulNumEntry         = ulEntry;
            pttc->cRef               = 0;
            pttc->fl                 = 0;
            pttc->pga                = NULL;

            bRet = TRUE;
        }
        else
        {
            for (i = 0; i < ulEntry; i++)
            {
                if(pttc->ahffEntry[i].iFace == 1)
                    ttfdUnloadFontFile(pttc->ahffEntry[i].hff);
            }
            
            WARNING("TTFD!No TrueType resource in this TTC file\n");
            vFreeTTC(*phttc);
            *phttc = (HFF)NULL;
        }
    }
    else
    {
    // This is the case of the single TTF being loaded (NOT TTC)
    // Allocate TTC_FONTFILE structure

        cjttc =  offsetof(TTC_FONTFILE,ahffEntry) + sizeof(TTC_HFF_ENTRY) * 2; // *2 for Vertical face

        *phttc = (HFF)pttcAlloc(cjttc);

        pttc = (PTTC_FONTFILE)*phttc;

        if(pttc != (HFF)NULL)
        {
            pttc->ahffEntry[0].iFace = 1;
            pttc->ahffEntry[0].ulOffsetTable = 0;

            if (bCached)
            {
                pCache_TTF = (PTTF_CACHE) ((PBYTE) pCache_TTC + pCache_TTC->dpTTF[0]);
            }

            if(bLoadTTF(iFile,pvView,cjView,0,ulLangId,&pttc->ahffEntry[0].hff, pCache_TTF, ulFastCheckSum))
            {
                hff = pttc->ahffEntry[0].hff;

            // set pointer to TTC_FONTFILE in FONTFILE structure

                PFF(hff)->pttc = pttc;

            // fill hff array in TTC_FONTFILE struture

                pttc->ulTrueTypeResource = 1;
                pttc->ulNumEntry         = PFF(hff)->ffca.ulNumFaces;
                pttc->cRef               = 0;
                pttc->fl                 = 0;
                pttc->pga                = NULL;

            // fill up TTC_FONTFILE structure for each faces.

                ASSERTDD(
                    PFF(hff)->ffca.ulNumFaces <= 2,
                    "TTFD!ulNumFaces > 2\n"
                    );

                if (PFF(hff)->ffca.ulNumFaces == 2)
                {
                    pttc->ahffEntry[1].hff   = hff;
                    pttc->ahffEntry[1].iFace = 2;
                    pttc->ahffEntry[1].ulOffsetTable = 0;
                }

            // now, everything is o.k.

                bRet = TRUE;
            }
            else
            {
                vFreeTTC(*phttc);
                *phttc = (HFF)NULL;
            }
        }
        else
        {
            WARNING("TTFD!ttfdLoadFontFileTTC(): pttcAlloc failed\n");
        }
    }

    if(bRet)
    {
    // now that everything is ok we need to cache the IFIMETRICS info for this file.
    // we only do this if this is happening during boot and if the IFI's are not in the cache
    // already.

        if (!bCached)
        {
            if (PFF(pttc->ahffEntry[0].hff)->ffca.fl & FF_DBCS_CHARSET)
            {
                if (!bComputeGlyphAttrBits(pttc, PFF(pttc->ahffEntry[0].hff)))
                {
                    ttfdUnloadFontFileTTC (*phttc);
                    *phttc = (HFF) NULL;

                    return FALSE;
                }
            }
            
            if (ulFastCheckSum)
            {
                vFontFileCache(pttc, ulFastCheckSum, (ULONG) bTTCFormat);
            }
        }
        else
        {
            if (pCache_TTC->dpGlyphAttr)
            {
                PFD_GLYPHATTR   pga;
                BOOL            bOk = TRUE;

                pga = (PFD_GLYPHATTR)((PBYTE) pCache_TTC + pCache_TTC->dpGlyphAttr);

                try
                {
                    pttc->pga = PV_ALLOC(pga->cjThis);

                    if (pttc->pga)
                    {
                        RtlCopyMemory(pttc->pga, pga, pga->cjThis);
                    }
                    else
                    {
                        bOk = FALSE;
                    }
                }
                except (EXCEPTION_EXECUTE_HANDLER)
                {
                    bOk = FALSE;
                }

                if (!bOk)
                {
                    ttfdUnloadFontFileTTC (*phttc);
                    *phttc = (HFF) NULL;
                    return FALSE;
                }
            }
        }

    // Free FD_GLYPHSET

        for (i = 0; i < pttc->ulNumEntry ; i++)
        {
            PFONTFILE pff = PFF(pttc->ahffEntry[i].hff);

            if (pttc->ahffEntry[i].iFace == 1)
            {
                if (pff->pgset)
                {
                    V_FREE(pff->pgset);
                    pff->pgset = NULL;
                }

                if (pff->pgsetv)
                {
                    V_FREE(pff->pgsetv);
                    pff->pgsetv = NULL;
                }
            }
        }   
    }

    return bRet;
}

/******************************Public*Routine******************************\
*
* VOID vGetVerticalGset(PFD_GLYPHSET pgsetv) 
*
* Make every vertical glyph index to right glyph in font
* 
* History:
*  9-2-1998 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

VOID vGetVerticalGSet(PFD_GLYPHSET pgsetRef, PFONTFILE pff)
{
    PWCRUN          pwcruns, pwcrunsEnd;
    PHGLYPH         phg;
    WCHAR           wcLow, wcHigh;

    ASSERTDD(pff->hgSearchVerticalGlyph, "vert font with zero hgSearchVerticalGlyph routine\n");

    pwcruns = &pff->pgsetv->awcrun[0];
    pwcrunsEnd = pwcruns + pff->pgsetv->cRuns;

    while (pwcruns < pwcrunsEnd)
    {
        wcLow = pwcruns->wcLow;
        wcHigh = pwcruns->wcLow + pwcruns->cGlyphs - 1;

        phg = (PHGLYPH) (((PBYTE) pwcruns->phg - (PBYTE) pgsetRef) + (PBYTE) pff->pgsetv);
        pwcruns->phg = phg;

        while (wcLow <= wcHigh)
        {
            *phg = (*pff->hgSearchVerticalGlyph)( pff, *phg, FALSE );

            phg++;
            wcLow++;
        }

        pwcruns++;
    }
}

STATIC BOOL bLoadGlyphSet(
    PFONTFILE               pff,
    sfnt_mappingTable       *pmap,
    fs_GlyphInputType       *pgin,
    fs_GlyphInfoType        *pgout,
    CMAPINFO                *pcmi,
    FD_GLYPHSET            **ppgset
)
{
    *ppgset = NULL;

    switch (pff->ffca.iGlyphSet)
    {
    case GSET_TYPE_GENERAL:
        #ifdef  DBG_GLYPHSET
            WARNING("GSET_TYPE_GENERAL\n");
        #endif

        *ppgset = (FD_GLYPHSET *) PV_ALLOC(cjGsetGeneral(pmap,pcmi));

        if (*ppgset)
        {
            if (!cjComputeGLYPHSET_MSFT_UNICODE( pmap, pgin, pgout, *ppgset, pcmi))
            {
                V_FREE(*ppgset );
                *ppgset = NULL;
            }
        }

        break;

    case GSET_TYPE_GENERAL_NOT_UNICODE:

        cjComputeGLYPHSET_MSFT_GENERAL(
            pmap,
            (ULONG **)ppgset, // == (FD_GLYPHSET **)
            pcmi
            );

        break;

    case GSET_TYPE_HIGH_BYTE:
        #ifdef  DBG_GLYPHSET
            WARNING("GSET_TYPE_HIGH_BYTE\n");
        #endif

    // Create GlyphSet

        cjComputeGLYPHSET_HIGH_BYTE(
            pmap,
            (ULONG **)ppgset, // == (FD_GLYPHSET **)
            pcmi
            );
        break;


    case GSET_TYPE_MAC_ROMAN:

        #ifdef  DBG_GLYPHSET
            WARNING("GSET_TYPE_MAC_ROMAN\n");
        #endif

        cjComputeGLYPHSET_TEMPLATE(pmap, pgin, pgout, ppgset, 0, GSET_TYPE_MAC_ROMAN);
        break;

    case GSET_TYPE_PSEUDO_WIN:

    // we are cheating, report windows code page even though it is
    // a mac font

        cjComputeGLYPHSET_TEMPLATE(pmap, pgin, pgout, ppgset, 0, GSET_TYPE_PSEUDO_WIN);

        break;

    case GSET_TYPE_SYMBOL:

    // we are cheating, report windows code page even though it is
    // a symbol font where symbols live somewhere high in unicode

        cjComputeGLYPHSET_TEMPLATE(pmap, pgin, pgout, ppgset, pff->ffca.wcBiasFirst, GSET_TYPE_SYMBOL);

        break;

    // case we have an old BiDi font

    case GSET_TYPE_OLDBIDI:
        cjComputeGLYPHSET_OLDBIDI(pgin, pgout, ppgset, pff->ffca.wcBiasFirst);
        break;

    default:
        RIP("TTFD!_ulGsetType\n");
        *ppgset = NULL;
        break;
    }

    return (*ppgset != NULL);
}

VOID vReleaseGlyphSet(PFONTFILE pff, ULONG iFace)
{
    if (iFace == 1)
    {
        ASSERTDD(pff->cRefGSet != 0, " vReleaseGlyphSet incorrect cRefGSet \n");

        pff->cRefGSet--;

        if (pff->cRefGSet == 0)
        {
            ASSERTDD(pff->pgset, " vReleaseGlyphSet incorrect pGset \n");
            V_FREE(pff->pgset);
            pff->pgset = NULL;
        }

    }
    else
    {
        ASSERTDD(pff->cRefGSetV, " vReleaseGlyphSet incorrect cRefGSetV \n");

        pff->cRefGSetV--;

        if (pff->cRefGSetV == 0)
        {
            ASSERTDD(pff->pgsetv, " vReleaseGlyphSet incorrect pGsetv \n");
            V_FREE(pff->pgsetv);
            pff->pgsetv = NULL;
        }

    }
}

BOOL bReloadGlyphSet(PFONTFILE pff, ULONG iFace)
{
    fs_GlyphInputType   *pgin;
    fs_GlyphInputType   gin;
    fs_GlyphInfoType    gout;
    sfnt_mappingTable   *pmap;
    CMAPINFO            cmi;

    FD_GLYPHSET         *pgset;
    FS_ENTRY            iRet;


    BOOL bRet;

    ASSERTDD(iFace == 1 || iFace == 2, "bReloadGlyphSet: iFace \n");

    if (iFace == 1)
    {
        if (pff->cRefGSet)
        {
            ASSERTDD(pff->pgset, "pff->pgset\n")
            pff->cRefGSet++;
            return TRUE;
        }
    }
    else
    {
        if (pff->cRefGSetV)
        {
            ASSERTDD(pff->pgsetv, "pff->pgset\n")
            pff->cRefGSetV++;
            return TRUE;
        }
    }

// at this point we know we will have to allocate either gset or gsetv
// let us see if the app is asking for gsetv and gset is already allocated.
// The next if statement is just a performance optimization, if we deleted this
// the code would work just fine.

    if ((iFace != 1) && pff->pgset)
    {
        if (pff->cRef == 0)
        {
        // have to remap the file.

            pff->pvView = pff->pttc->pvView;
            pff->cjView = pff->pttc->cjView;
        }

   // pff->pgsetv == NULL, otherwise we would have hit the early exit

        pff->pgsetv = PV_ALLOC(pff->pgset->cjThis);

        if (pff->pgsetv)
        {
            BOOL bTmp = FALSE;
            RtlCopyMemory((PVOID) pff->pgsetv, (PVOID) pff->pgset, pff->pgset->cjThis);
            try
            {
                vGetVerticalGSet(pff->pgset, pff);
                bTmp = TRUE;
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                WARNING("bReloadGlyphSet exception for vGetVerticalGSet\n");
            }

            if (bTmp)
            {
                pff->cRefGSetV = 1;
            }
            else
            {
                V_FREE(pff->pgsetv);
                pff->pgsetv = NULL;
            }
        }

        return (pff->pgsetv != NULL);
    }

    if (pff->cRef == 0)
    {
        BOOL bTmp = FALSE;

    // the size of this structure is sizeof(fs_SplineKey) + STAMPEXTRA.
    // It is because of STAMPEXTRA that we are not just putting the strucuture
    // on the stack such as fs_SplineKey sk; we do not want to overwrite the
    // stack at the bottom when putting a stamp in the STAMPEXTRA field.
    // [bodind]. The other way to obtain the correct alignment would be to use
    // union of fs_SplineKey and the array of bytes of length CJ_0.

        NATURAL             anat0[CJ_0 / sizeof(NATURAL)];

    // have to remap the file.

        pff->pvView = pff->pttc->pvView;
        pff->cjView = pff->pttc->cjView;

   /* we need to initialize a gin for the TrueType rasterizer */

        if ((iRet = fs_OpenFonts(&gin, &gout)) != NO_ERR)
        {
            V_FSERROR(iRet);
            return FALSE;
        }

        ASSERTDD(NATURAL_ALIGN(gout.memorySizes[0]) == CJ_0, "mem size 0\n");
        ASSERTDD(gout.memorySizes[1] == 0,  "mem size 1\n");

        gin.memoryBases[0] = (char *)anat0;
        gin.memoryBases[1] = NULL;
        gin.memoryBases[2] = NULL;

    // initialize the font scaler, notice no fields of gin are initialized [BodinD]

        if ((iRet = fs_Initialize(&gin, &gout)) != NO_ERR)
        {
            V_FSERROR(iRet);
            return FALSE;
        }

    // initialize info needed by NewSfnt function

        gin.sfntDirectory  = (int32 *)pff->pvView; // pointer to the top of the view of
                                                   // the ttf file
        gin.clientID = (ULONG_PTR)pff;  // pointer to the top of the view of the ttf file

        gin.GetSfntFragmentPtr = pvGetPointerCallback;
        gin.ReleaseSfntFrag  = vReleasePointerCallback;

        gin.param.newsfnt.platformID = BE_UINT16(&pff->ffca.ui16PlatformID);
        gin.param.newsfnt.specificID = BE_UINT16(&pff->ffca.ui16SpecificID);

        try
        {
            if ((iRet = fs_NewSfnt(&gin, &gout)) != NO_ERR)
            {
                V_FSERROR(iRet);
            }
            else
            {
                bTmp = TRUE;
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("bReloadGlyphSet exception in fs_NewSfnt \n");
        }

        if (!bTmp)
            return FALSE;

        pgin = &gin;
    }
    else
    {
        pgin = (fs_GlyphInputType *)pff->pj034;
    }

    pmap = (sfnt_mappingTable  *) ((PBYTE) pff->pvView + pff->ffca.dpMappingTable);
    cmi = pff->ffca.cmi;

    bRet = FALSE;
    try
    {
        if (bLoadGlyphSet(pff, pmap, pgin, &gout, &cmi, (iFace == 1) ? &pff->pgset : &pff->pgsetv))
        {
            if (iFace != 1)
            {
                vGetVerticalGSet(pff->pgsetv, pff);
            }
            bRet = TRUE;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("bReloadGlyphSet: exception in bLoadGlyphSet or in vGetVerticalGset \n");
    }


    if (bRet)
    {
        if (iFace != 1)
        {
            pff->cRefGSetV = 1;
        }
        else
        {
            pff->cRefGSet = 1;
        }
    }
    else // do clean up in case we allocated memory
    {
        if (iFace != 1)
        {
            if (pff->pgsetv)
            {
                V_FREE(pff->pgsetv);
                pff->pgsetv = NULL;
            }

        }
        else
        {
            if (pff->pgset)
            {
                V_FREE(pff->pgset);
                pff->pgset = NULL;
            }
        }
    }

    return bRet;
}


STATIC BOOL
bLoadTTF (
    ULONG_PTR iFile,
    PVOID     pvView,
    ULONG     cjView,
    ULONG     ulTableOffset,
    ULONG     ulLangId,
    HFF       *phff,
    PTTF_CACHE pCache,
    ULONG     ulFastCheckSum
    )
{
    PFONTFILE      pff;
    FS_ENTRY       iRet;
    TABLE_POINTERS tp;
    IFISIZE        ifisz;
    fs_GlyphInputType   gin;
    fs_GlyphInfoType    gout;

    sfnt_FontHeader * phead;
    sfnt_HorizontalHeader *phhea;

    uint16 ui16PlatID, ui16SpecID;
    sfnt_mappingTable *pmap;
    ULONG              ulGsetType;
    ULONG              cjff, dpwszTTF;
    ULONG              ul_wcBias;

// the size of this structure is sizeof(fs_SplineKey) + STAMPEXTRA.
// It is because of STAMPEXTRA that we are not just putting the strucuture
// on the stack such as fs_SplineKey sk; we do not want to overwrite the
// stack at the bottom when putting a stamp in the STAMPEXTRA field.
// [bodind]. The other way to obtain the correct alignment would be to use
// union of fs_SplineKey and the array of bytes of length CJ_0.

    NATURAL             anat0[CJ_0 / sizeof(NATURAL)];

    CMAPINFO           cmi;
    BOOL               bType1 = FALSE; // if Type1 conversion
    BOOL               ulShellFont = 0; // If it is not a shell font
    PBYTE pjOffsetTable = (BYTE*) pvView + ulTableOffset;
    PIFIMETRICS        pifiv = NULL; // ifimetrics for the vertical face
    PFD_GLYPHSET       pgsetv = NULL;
    

    *phff = HFF_INVALID;

    if (pCache)
    {
        return bLoadTTF_Cache(iFile,
                             pvView,
                             cjView,
                             ulTableOffset,
                             ulLangId,
                             phff,
                             pCache,
                             ulFastCheckSum);
    }


    if
    (
        !bVerifyTTF(
            iFile,
            pvView,
            cjView,
            pjOffsetTable,
            ulLangId,
            &tp,
            &ifisz,
            &ui16PlatID,
            &ui16SpecID,
            &pmap,
            &ulGsetType,
            &ul_wcBias,
            &cmi,
            &bType1,
            &ulShellFont
            )
    )
    {
        return(FALSE);
    }

    cjff = offsetof(FONTFILE,ifi) + ifisz.cjIFI;

    if(ulShellFont)
    {
        USHORT AnsiCodePage, OemCodePage;

    // Microsoft Sans Serif is a new shell font for NT 5.0,
    // Here, we need to hack for 2 problems

    // This issue is language dependcy
    // Within Japanese and Korean code page, we need to replace 0x5c glyph

        EngGetCurrentCodePage(&OemCodePage, &AnsiCodePage);
        if (AnsiCodePage == 932 || AnsiCodePage == 949)
        {
    	    cmi.fl |= CMI_5C_SPLIT;
        }
    }

   

// at this point cjff is equal to the offset to the full path
// name of the ttf file

    dpwszTTF = cjff;


    if ((pff = pffAlloc(cjff)) == PFF(NULL))
    {
        RET_FALSE("TTFD!ttfdLoadFontFile(): memory allocation error\n");
    }

    *phff = (HFF)pff;

    /* we need to clean the beginning of pff to ensure correct cleanup in case of error/exception */

    RtlZeroMemory((PVOID)pff, offsetof(FONTFILE,ifi));

// init fields of pff structure
// store the ttf file name at the bottom of the strucutre

    phead = (sfnt_FontHeader *)((BYTE *)pvView + tp.ateReq[IT_REQ_HEAD].dp);

// remember which file this is

    pff->iFile = iFile;
    pff->pvView = pvView;
    pff->cjView = cjView;

    pff->ffca.ui16EmHt = BE_UINT16(&phead->unitsPerEm);
    if (pff->ffca.ui16EmHt < 16 || pff->ffca.ui16EmHt > 16384)
    {
        vFreeFF(*phff);
        *phff = (HFF)NULL;
        RET_FALSE("TTFD!bLoadTTF(): invalid unitsPerEm value\n");
    }
    pff->ffca.ui16PlatformID = ui16PlatID;
    pff->ffca.ui16SpecificID = ui16SpecID;

// few new fields for user's private api:

    phhea = (sfnt_HorizontalHeader *)((BYTE *)pvView + tp.ateReq[IT_REQ_HHEAD].dp);

    pff->ffca.usMinD = 0;          // flag that it has not been initialized
    pff->ffca.igMinD = USHRT_MAX; // flag that it has not been initialized
    pff->ffca.sMinA  = BE_INT16(&phhea->minLeftSideBearing);
    pff->ffca.sMinC  = BE_INT16(&phhea->minRightSideBearing);

// so far no exception

    pff->ffca.fl = bType1 ? FF_TYPE_1_CONVERSION : 0;

    if(ulShellFont & MICROSS_SHELLFONT)
    {
    // Microsoft Sans Serif is a new shell font for NT 5.0,
    // Here, we need to hack for 2 problems

    // It is a backward compatibility issue to make
    // Max Neg A, C will be 0 at 11 & 13 ppem

        pff->ffca.fl |= FF_NEW_SHELL_FONT;
    }

    pff->pfcToBeFreed = NULL;

// convert Language id to macintosh style if this is mac style file
// else leave it alone, store it in be format, ready to be compared
// with the values in the font files

    pff->ffca.ui16LanguageID = ui16BeLangId(ui16PlatID,ulLangId);
    pff->ffca.dpMappingTable = (ULONG)((BYTE*)pmap - (BYTE*)pvView);

// initialize count of HFC's associated with this HFF

    pff->cRef    = 0L;

// cache pointers to ttf tables and ifi metrics size info

    pff->ffca.tp    = tp;

// The kerning pair array is allocated and filled lazily.  So set to NULL
// for now.

    pff->pkp = (FD_KERNINGPAIR *) NULL;

// used for TTC fonts

    pff->ffca.ulTableOffset = ulTableOffset;

// Used for reload glyphset
    pff->ffca.cmi = cmi;

    pff->ffca.wcBiasFirst = ul_wcBias;

// Notice that this information is totaly independent
// of the font file in question, seems to be right according to fsglue.h
// and compfont code

    if ((iRet = fs_OpenFonts(&gin, &gout)) != NO_ERR)
    {
        V_FSERROR(iRet);
        vFreeFF(*phff);
        *phff = (HFF)NULL;
        return (FALSE);
    }

    ASSERTDD(NATURAL_ALIGN(gout.memorySizes[0]) == CJ_0, "mem size 0\n");
    ASSERTDD(gout.memorySizes[1] == 0,  "mem size 1\n");


    #if DBG
    if (gout.memorySizes[2] != 0)
        TtfdDbgPrint("TTFD!_mem size 2 = 0x%lx \n", gout.memorySizes[2]);
    #endif

    gin.memoryBases[0] = (char *)anat0;
    gin.memoryBases[1] = NULL;
    gin.memoryBases[2] = NULL;

// initialize the font scaler, notice no fields of gin are initialized [BodinD]

    if ((iRet = fs_Initialize(&gin, &gout)) != NO_ERR)
    {
    // clean up and return:

        V_FSERROR(iRet);
        vFreeFF(*phff);
        *phff = (HFF)NULL;
        RET_FALSE("TTFD!_ttfdLoadFontFile(): fs_Initialize \n");
    }

// initialize info needed by NewSfnt function

    gin.sfntDirectory  = (int32 *)pff->pvView; // pointer to the top of the view of
                                               // the ttf file

    gin.clientID = (ULONG_PTR)pff;  // pointer to the top of the view of the ttf file

    gin.GetSfntFragmentPtr = pvGetPointerCallback;
    gin.ReleaseSfntFrag  = vReleasePointerCallback;

    gin.param.newsfnt.platformID = BE_UINT16(&pff->ffca.ui16PlatformID);
    gin.param.newsfnt.specificID = BE_UINT16(&pff->ffca.ui16SpecificID);

    if ((iRet = fs_NewSfnt(&gin, &gout)) != NO_ERR)
    {
    // clean up and exit

        V_FSERROR(iRet);
        vFreeFF(*phff);
        *phff = (HFF)NULL;
        RET_FALSE("TTFD!_ttfdLoadFontFile(): fs_NewSfnt \n");
    }

    pff->pj034   = (PBYTE)NULL;
    pff->pfcLast = (FONTCONTEXT *)NULL;

    pff->ffca.cj3 = NATURAL_ALIGN(gout.memorySizes[3]);
    pff->ffca.cj4 = NATURAL_ALIGN(gout.memorySizes[4]);

// By default the number of faces is 1L.  The vert facename code may change this.

    pff->ffca.ulNumFaces = 1L;
    pff->pifi_vertical = NULL;
    pff->pgsetv = NULL;

// compute the gset or set a pointer to one of the precomputed gsets

    pff->ffca.iGlyphSet = ulGsetType;

// if we failed to create the glyphset bail out now

    if (!bLoadGlyphSet(pff, pmap, &gin, &gout, &cmi, &pff->pgset))
    {
        // clean up and exit

        vFreeFF(*phff);
        *phff = (HFF)NULL;
        RET_FALSE("ttfdLoadFontFile(): failed to create glyphset or invalid glyphset\n");
    }

// finally compute the ifimetrics for this font, this assumes that gset has
// also been computed

// if ifimetrics are stored in the boot cache, copy them out, else compute ifimetrics

    vFill_IFIMETRICS(pff,&pff->ifi,&ifisz, &gin);

    if ((pff->ffca.fl & FF_DBCS_CHARSET) && bCheckVerticalTable(pff))
    {

        ASSERTDD( pff->hgSearchVerticalGlyph != NULL ,
                  "pff->hgSearchVerticalGlyph == NULL for vertical font\n");

        pifiv = (PIFIMETRICS)PV_ALLOC( NATURAL_ALIGN(ifisz.cjIFI));
        pgsetv = (PFD_GLYPHSET)PV_ALLOC(pff->pgset->cjThis);

        if ( pifiv != NULL && pgsetv != NULL)
        {

            vCopy_IFIV(&pff->ifi, pifiv);

        // save a pointer to the vertical ifimetrics.
        // now we have two faces( normal, @face ) for the fontfile.

            pff->pifi_vertical = pifiv;
            pff->ffca.ulNumFaces = 2L;

        }
        else
        {
        // Something wrong in read cache file

            if (pifiv)
            {
                V_FREE(pifiv);
            }

        // Free pgset

            if (pff->pgset)
            {
                V_FREE(pff->pgset);
            }

            if (pgsetv)
            {
                V_FREE(pgsetv);
            }

        // Free FONTFILE * pff

            if (*phff)
            {
                vFreeFF(*phff);
                *phff = (HFF)NULL;
            }

            RET_FALSE("ttfdLoadFontFile(): failed to create pifiv\n");

        }
    }

    if (pifiv)
    {
    // now compute the vertical glyphset
        RtlCopyMemory((PVOID) pgsetv, (PVOID) pff->pgset, pff->pgset->cjThis);
        pff->pgsetv = pgsetv;
        vGetVerticalGSet(pff->pgset, pff);
    }

    pff->cRefGSet = 0;
    pff->cRefGSetV = 0;
    return (TRUE);
}

/******************************Public*Routine******************************\
*
* STATIC BOOL bCvtUnToMac
*
* the following piece of code is stolen from JeanP and
* he claims that this piece of code is lousy and checks whether
* we the font is a SYMBOL font in which case unicode to mac conversion
* should be disabled, according to JeanP (??? who understands this???)
* This piece of code actually applies to symbol.ttf [bodind]
*
*
* History:
*  24-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC BOOL
bCvtUnToMac(
    BYTE           *pjView,
    TABLE_POINTERS *ptp,
    uint16 ui16PlatformID
    )
{
// Find out if we have a Mac font and if the Mac charset translation is needed

    BOOL bUnToMac = (ui16PlatformID == BE_PLAT_ID_MAC);

    if (bUnToMac) // change your mind if needed
    {
        sfnt_PostScriptInfo *ppost;

        ppost = (ptp->ateOpt[IT_OPT_POST].dp)                                ?
                (sfnt_PostScriptInfo *)(pjView + ptp->ateOpt[IT_OPT_POST].dp):
                NULL;

        if
        (
            ppost &&
            (BE_UINT32((BYTE*)ppost + POSTSCRIPTNAMEINDICES_VERSION) == 0x00020000)
        )
        {
            INT i, cGlyphs;

            cGlyphs = (INT)BE_UINT16(&ppost->numberGlyphs);

            for (i = 0; i < cGlyphs; i++)
            {
                uint16 iNameIndex = ppost->postScriptNameIndices.glyphNameIndex[i];
                if ((int8)(iNameIndex & 0xff) && ((int8)(iNameIndex >> 8) > 1))
                    break;
            }

            if (i < cGlyphs)
                bUnToMac = FALSE;
        }
    }
    return bUnToMac;
}


// Weight (must convert from IFIMETRICS weight to Windows LOGFONT.lfWeight).

// !!! [Windows 3.1 compatibility]
//     Because of some fonts shipped with WinWord, if usWeightClass is 10
//     or above, then usWeightClass == lfWeight.  All other cases, use
//     the conversion table.

// pan wt -> Win weight converter:

STATIC USHORT ausIFIMetrics2WinWeight[10] = {
            0, 100, 200, 300, 350, 400, 600, 700, 800, 900
            };

STATIC BYTE
ajPanoseFamily[16] = {
     FF_DONTCARE       //    0 (Any)
    ,FF_DONTCARE       //    1 (No Fit)
    ,FF_ROMAN          //    2 (Cove)
    ,FF_ROMAN          //    3 (Obtuse Cove)
    ,FF_ROMAN          //    4 (Square Cove)
    ,FF_ROMAN          //    5 (Obtuse Square Cove)
    ,FF_ROMAN          //    6 (Square)
    ,FF_ROMAN          //    7 (Thin)
    ,FF_ROMAN          //    8 (Bone)
    ,FF_ROMAN          //    9 (Exaggerated)
    ,FF_ROMAN          //   10 (Triangle)
    ,FF_SWISS          //   11 (Normal Sans)
    ,FF_SWISS          //   12 (Obtuse Sans)
    ,FF_SWISS          //   13 (Perp Sans)
    ,FF_SWISS          //   14 (Flared)
    ,FF_SWISS          //   15 (Rounded)
    };


static BYTE
ajPanoseFamilyForJapanese[16] = {
     FF_DONTCARE       //    0 (Any)
    ,FF_DONTCARE       //    1 (No Fit)
    ,FF_ROMAN          //    2 (Cove)
    ,FF_ROMAN          //    3 (Obtuse Cove)
    ,FF_ROMAN          //    4 (Square Cove)
    ,FF_ROMAN          //    5 (Obtuse Square Cove)
    ,FF_ROMAN          //    6 (Square)
    ,FF_ROMAN          //    7 (Thin)
    ,FF_ROMAN          //    8 (Bone)
    ,FF_ROMAN          //    9 (Exaggerated)
    ,FF_ROMAN          //   10 (Triangle)
    ,FF_MODERN         //   11 (Normal Sans)
    ,FF_MODERN         //   12 (Obtuse Sans)
    ,FF_MODERN         //   13 (Perp Sans)
    ,FF_MODERN         //   14 (Flared)
    ,FF_MODERN         //   15 (Rounded)
    };


/******************************Public*Routine******************************\
*
* vFill_IFIMETRICS
*
* Effects: Looks into the font file and fills IFIMETRICS
*
* History:
*  Mon 09-Mar-1992 10:51:56 by Kirk Olynyk [kirko]
* Added Kerning Pair support.
*  18-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


STATIC VOID
vFill_IFIMETRICS(
    PFONTFILE       pff,
    PIFIMETRICS     pifi,
    PIFISIZE        pifisz,
    fs_GlyphInputType     *pgin
    )
{
    BYTE           *pjView = (BYTE*)pff->pvView;
    PTABLE_POINTERS ptp = &pff->ffca.tp;
    BYTE            jWinCharset;
    IFIEXTRA       *pifiex;

// ptrs to various tables of tt files

    PBYTE pjNameTable = pjView + ptp->ateReq[IT_REQ_NAME].dp;
    sfnt_FontHeader *phead =
        (sfnt_FontHeader *)(pjView + ptp->ateReq[IT_REQ_HEAD].dp);

    sfnt_maxProfileTable * pmaxp =
        (sfnt_maxProfileTable *)(pjView + ptp->ateReq[IT_REQ_MAXP].dp);

    sfnt_HorizontalHeader *phhea =
        (sfnt_HorizontalHeader *)(pjView + ptp->ateReq[IT_REQ_HHEAD].dp);

    sfnt_PostScriptInfo   *ppost = (sfnt_PostScriptInfo *) (
                           (ptp->ateOpt[IT_OPT_POST].dp)        ?
                           pjView + ptp->ateOpt[IT_OPT_POST].dp :
                           NULL
                           );

    PBYTE  pjOS2 = (ptp->ateOpt[IT_OPT_OS2].dp)        ?
                   pjView + ptp->ateOpt[IT_OPT_OS2].dp :
                   NULL                                ;

    pifi->cjThis    = pifisz->cjIFI;
    pifi->cjIfiExtra =
                    offsetof(IFIEXTRA, dpDesignVector);

// lay pifiextra below ifimetrics
    pifiex = (IFIEXTRA *)(pifi + 1);
    pifiex->ulIdentifier = 0;

// enter the number of distinct font indicies

    pifiex->cig = BE_UINT16(&pmaxp->numGlyphs);

// get name strings info

// For the 3.1 compatibility, GRE returns FamilyName rather than
// Facename for GetTextFace. We make a room for '@' in both
// familyname and facename.

    pifi->dpwszFamilyName = sizeof(IFIMETRICS)    + pifi->cjIfiExtra;

    if(pifisz->pjFamilyNameAlias)
    {
        pifi->dpwszUniqueName = pifi->dpwszFamilyName     +
                                pifisz->cjFamilyName      + sizeof(WCHAR) + // for @
                                pifisz->cjFamilyNameAlias + sizeof(WCHAR) + // for @
                                sizeof(WCHAR);                              // for L'\0';
    }
    else
    {
      pifi->dpwszUniqueName = pifi->dpwszFamilyName + pifisz->cjFamilyName + sizeof(WCHAR);
    }

    pifi->dpwszFaceName   = pifi->dpwszUniqueName + pifisz->cjUniqueName;
    pifi->dpwszStyleName  = pifi->dpwszFaceName   + pifisz->cjFullName + sizeof(WCHAR);

// copy the strings to their new location. Here we assume that the
// sufficient memory has been allocated

    if (pff->ffca.ui16PlatformID == BE_PLAT_ID_MS)
    {

        if (pff->ffca.ui16SpecificID == BE_SPEC_ID_BIG5     ||
            pff->ffca.ui16SpecificID == BE_SPEC_ID_WANSUNG  ||
            pff->ffca.ui16SpecificID == BE_SPEC_ID_GB)
        {
            CHAR chConvertArea[128];
            UINT iCodePage = GetCodePageFromSpecId(pff->ffca.ui16SpecificID);

            //
            // Convert MBCS string to Unicode..
            //
            // Do for FamilyName....
            //
            RtlZeroMemory(chConvertArea,sizeof(chConvertArea));

            CopyDBCSIFIName(chConvertArea,
                            sizeof(chConvertArea),
                            (LPCSTR)pifisz->pjFamilyName,
                            pifisz->cjFamilyName-sizeof(WCHAR)); // -sizeof(WCHAR) for
                                                                 // real length
            if(EngMultiByteToWideChar(iCodePage,
                                      (LPWSTR)((PBYTE)pifi + pifi->dpwszFamilyName),
                                      pifisz->cjFamilyName,
                                      chConvertArea,
                  strlen(chConvertArea)+1) == -1)
            {

                WARNING("TTFD!vFill_IFIMETRICS() MBCS to Unicode conversion failed\n");
                goto CopyUnicodeString;
            }

   // Do for FamilyNameAlias....

       if (pifisz->pjFamilyNameAlias)
            {
                WCHAR   *pwszFamilyNameAlias;

                pwszFamilyNameAlias = (LPWSTR)((PBYTE)pifi + pifi->dpwszFamilyName + pifisz->cjFamilyName);

                RtlZeroMemory(chConvertArea,sizeof(chConvertArea));

                CopyDBCSIFIName(chConvertArea,
                                sizeof(chConvertArea),
                                (LPCSTR)pifisz->pjFamilyNameAlias,
             pifisz->cjFamilyNameAlias-sizeof(WCHAR)); //double NULL in this case

       // this routine puts the first terminating zero

      if (EngMultiByteToWideChar(iCodePage,
                                pwszFamilyNameAlias,
            pifisz->cjFamilyNameAlias,
                                chConvertArea,
                                strlen(chConvertArea)+1) == -1)
                {

                    WARNING("TTFD!vFill_IFIMETRICS() MBCS to Unicode conversion failed\n");
                    goto CopyUnicodeString;
                }

       // add the second terminating zero

      pwszFamilyNameAlias[pifisz->cjFamilyNameAlias/sizeof(WCHAR)] = L'\0';
            }

   // Do for FullName....

            RtlZeroMemory(chConvertArea,sizeof(chConvertArea));
            CopyDBCSIFIName(chConvertArea,
                            sizeof(chConvertArea),
                            (LPCSTR)pifisz->pjFullName,
                            pifisz->cjFullName-sizeof(WCHAR)); // -sizeof(WCHAR) for
                                                               // real length

            if(EngMultiByteToWideChar(iCodePage,
                                      (LPWSTR)((PBYTE)pifi + pifi->dpwszFaceName),
                                      pifisz->cjFullName,
                                      chConvertArea,
                                      strlen(chConvertArea)+1) == -1)
            {
                WARNING("TTFD!vFill_IFIMETRICS() MBCS to Unicode conversion failed\n");
                goto CopyUnicodeString;
            }

            //
            // Do for UniqueName....
            //

            RtlZeroMemory(chConvertArea,sizeof(chConvertArea));
            CopyDBCSIFIName(chConvertArea,sizeof(chConvertArea),
                            (LPCSTR)pifisz->pjUniqueName,
                            pifisz->cjUniqueName-sizeof(WCHAR)); // -sizeof(WCHAR) for
                                                                 // real length

            if(EngMultiByteToWideChar(iCodePage,
                                      (LPWSTR)((PBYTE)pifi + pifi->dpwszUniqueName),
                                      pifisz->cjUniqueName,
                                      chConvertArea,
                                      strlen(chConvertArea)+1) == -1)
            {
                WARNING("TTFD!vFill_IFIMETRICS() MBCS to Unicode conversion failed\n");
                goto CopyUnicodeString;
            }

            if(pff->ffca.ui16SpecificID == BE_SPEC_ID_WANSUNG  ||
               pff->ffca.ui16SpecificID == BE_SPEC_ID_BIG5 )
            {
                // MingLi.TTF's bug, Style use Unicode encoding, not BIG5 encodingi, GB??

                vCpyBeToLeUnicodeString
                  (
                   (LPWSTR)((PBYTE)pifi + pifi->dpwszStyleName),
                   (LPWSTR)pifisz->pjSubfamilyName,
                   pifisz->cjSubfamilyName / 2
                   );
            }
            else
            {
                UINT iRet;
                RtlZeroMemory(chConvertArea,sizeof(chConvertArea));
                CopyDBCSIFIName(chConvertArea,sizeof(chConvertArea),
                                (LPCSTR)pifisz->pjSubfamilyName,
                                pifisz->cjSubfamilyName-sizeof(WCHAR)); // -sizeof(WCHAR) for
                                                                 // real length

                iRet = EngMultiByteToWideChar(iCodePage,
                                              (LPWSTR)((PBYTE)pifi+pifi->dpwszStyleName),
                                              pifisz->cjSubfamilyName,
                                              chConvertArea,
                                              strlen(chConvertArea)+1);

                if( iRet == -1 )
                {
                    WARNING("TTFD!vFill_IFIMETRICS() MBCS to Unicode failed\n");
                    goto CopyUnicodeString;
                }
            }

        }
        else
        {
          CopyUnicodeString:

           vCpyBeToLeUnicodeString
              (
               (LPWSTR)((PBYTE)pifi + pifi->dpwszFamilyName),
               (LPWSTR)pifisz->pjFamilyName,
               pifisz->cjFamilyName / 2);

        // Do for FamilyNameAlias....

            if(pifisz->pjFamilyNameAlias)
            {
                WCHAR   *pwszFamilyNameAlias;
                pwszFamilyNameAlias = (LPWSTR)((PBYTE)pifi + pifi->dpwszFamilyName + pifisz->cjFamilyName);

      vCpyBeToLeUnicodeString (
                    pwszFamilyNameAlias,
                    (LPWSTR)pifisz->pjFamilyNameAlias,
          pifisz->cjFamilyNameAlias / sizeof(WCHAR));

       // add second terminating zero

      pwszFamilyNameAlias[pifisz->cjFamilyNameAlias/sizeof(WCHAR)] = L'\0';
            }

        vCpyBeToLeUnicodeString
          (
           (LPWSTR)((PBYTE)pifi + pifi->dpwszFaceName),
           (LPWSTR)pifisz->pjFullName,
           pifisz->cjFullName / 2
           );

        vCpyBeToLeUnicodeString
          (
           (LPWSTR)((PBYTE)pifi + pifi->dpwszUniqueName),
           (LPWSTR)pifisz->pjUniqueName,
           pifisz->cjUniqueName / 2
           );

        vCpyBeToLeUnicodeString
          (
           (LPWSTR)((PBYTE)pifi + pifi->dpwszStyleName),
           (LPWSTR)pifisz->pjSubfamilyName,
           pifisz->cjSubfamilyName / 2
           );
        }
    }
    else
    {
        ASSERTDD(pff->ffca.ui16PlatformID == BE_PLAT_ID_MAC,
                  "bFillIFIMETRICS: not mac id \n");

        vCpyMacToLeUnicodeString
        (
            pff->ffca.ui16LanguageID,
            (LPWSTR)((PBYTE)pifi + pifi->dpwszFamilyName),
            pifisz->pjFamilyName,
            pifisz->cjFamilyName / 2
        );

        vCpyMacToLeUnicodeString
        (
            pff->ffca.ui16LanguageID,
            (LPWSTR)((PBYTE)pifi + pifi->dpwszFaceName),
            pifisz->pjFullName,
            pifisz->cjFullName / 2
        );

        vCpyMacToLeUnicodeString
        (
            pff->ffca.ui16LanguageID,
            (LPWSTR)((PBYTE)pifi + pifi->dpwszUniqueName),
            pifisz->pjUniqueName,
            pifisz->cjUniqueName / 2
        );

        vCpyMacToLeUnicodeString
        (
            pff->ffca.ui16LanguageID,
            (LPWSTR)((PBYTE)pifi + pifi->dpwszStyleName),
            pifisz->pjSubfamilyName,
            pifisz->cjSubfamilyName / 2
        );
    }

//
// flInfo
//
    pifi->flInfo = (
                     FM_INFO_TECH_TRUETYPE    |
                     FM_INFO_ARB_XFORMS       |
                     FM_INFO_RETURNS_OUTLINES |
                     FM_INFO_RETURNS_BITMAPS  |
                     FM_INFO_1BPP             | // monochrome
                     FM_INFO_4BPP             | // anti-aliased too
                     FM_INFO_RIGHT_HANDED
                   );
    {
        ULONG cjDSIG;

        if (pff->ffca.ulTableOffset == 0)
        {
            if (pjTable('GISD', pff, &cjDSIG) && cjDSIG)
            {
                pifi->flInfo |= FM_INFO_DSIG;
            }
        }
        else
        {
            ULONG     ulValue;
            ULONG     ulOffset;

            // Get Directory count.

            ulValue = GetUlong(pff->pvView,OFF_TTC_DirectoryCount);

            ulOffset = OFF_TTC_DirectoryEntry + (sizeof(ULONG) * ulValue);

            // Read the DSIG_LONG_TAG

            ulValue = GetUlong(pff->pvView,ulOffset);

            if (ulValue == DSIG_LONG_TAG)
            {
                pifi->flInfo |= FM_INFO_DSIG;
            }
        }
    }

    if (pifisz->pjFamilyNameAlias )
    {
        pifi->flInfo |= FM_INFO_FAMILY_EQUIV;
    }

    if (ppost && BE_UINT32((BYTE*)ppost + POSTSCRIPTNAMEINDICES_ISFIXEDPITCH))
    {
        ULONG  cHMTX;
        int16  aw,xMin,xMax;
        sfnt_HorizontalMetrics *phmtx;

        pifi->flInfo |= FM_INFO_OPTICALLY_FIXED_PITCH;

    // CHECK IF THE FONT HAS NONNEGATIVE A AND C SPACES

        xMin = (int16) BE_UINT16(&phead->xMin);
        xMax = (int16) BE_UINT16(&phead->xMax);

        phmtx = (sfnt_HorizontalMetrics *)(pjView + ptp->ateReq[IT_REQ_HMTX ].dp);
        cHMTX = (ULONG) BE_UINT16(&phhea->numberOf_LongHorMetrics);
        aw = (int16)BE_UINT16(&phmtx[cHMTX-1].advanceWidth);

        if ((xMin >= 0) && (xMax <= aw))
        {

        //    TtfdDbgPrint("%ws\n:",(PBYTE)pifi + pifi->dpwszUniqueName);
        //    TtfdDbgPrint("xMin = %d, xMax = %d, aw = %d\n", xMin, xMax, aw);

            pifi->flInfo |= FM_INFO_NONNEGATIVE_AC;
        }
    }

    pifi->dpCharSets = 0; // for now

    pifi->lEmbedId = 0; // not used, stored in pff.

// fsSelection

    pifi->fsSelection = fsSelectionTTFD(pjView, ptp);

// some of the old windows fonts contain the char set in the upper byte of
// the fsSelection field of the os2 table.

    jWinCharset = (BYTE)(pifi->fsSelection >> 8);

// fsType

    pifi->fsType = (pjOS2) ? (BE_UINT16(pjOS2 + OFF_OS2_fsType)) & TT_FSDEF_MASK : 0;

// em height

    pifi->fwdUnitsPerEm = (FWORD) BE_INT16(&phead->unitsPerEm);
    pifi->fwdLowestPPEm = BE_UINT16(&phead->lowestRecPPEM);

// ascender, descender, linegap

    pifi->fwdMacAscender    = (FWORD) BE_INT16(&phhea->yAscender);
    pifi->fwdMacDescender   = (FWORD) BE_INT16(&phhea->yDescender);
    pifi->fwdMacLineGap     = (FWORD) BE_INT16(&phhea->yLineGap);

    if (pjOS2)
    {
        pifi->fwdWinAscender    = (FWORD) BE_INT16(pjOS2 + OFF_OS2_usWinAscent);
        pifi->fwdWinDescender   = (FWORD) BE_INT16(pjOS2 + OFF_OS2_usWinDescent);
        pifi->fwdTypoAscender   = (FWORD) BE_INT16(pjOS2 + OFF_OS2_sTypoAscender);
        pifi->fwdTypoDescender  = (FWORD) BE_INT16(pjOS2 + OFF_OS2_sTypoDescender);
        pifi->fwdTypoLineGap    = (FWORD) BE_INT16(pjOS2 + OFF_OS2_sTypoLineGap);
    }
    else
    {
        pifi->fwdWinAscender    = pifi->fwdMacAscender;
        pifi->fwdWinDescender   = -(pifi->fwdMacDescender);
        pifi->fwdTypoAscender   = pifi->fwdMacAscender;
        pifi->fwdTypoDescender  = pifi->fwdMacDescender;
        pifi->fwdTypoLineGap    = pifi->fwdMacLineGap;
    }

// font box

    pifi->rclFontBox.left   = (LONG)((FWORD)BE_INT16(&phead->xMin));
    pifi->rclFontBox.top    = (LONG)((FWORD)BE_INT16(&phead->yMax));
    pifi->rclFontBox.right  = (LONG)((FWORD)BE_INT16(&phead->xMax));
    pifi->rclFontBox.bottom = (LONG)((FWORD)BE_INT16(&phead->yMin));

// fwdMaxCharInc -- really the maximum character width
//
// [Windows 3.1 compatibility]
// Note: Win3.1 calculates max char width to be equal to the width of the
// bounding box (Font Box).  This is actually wrong since the bounding box
// may pick up its left and right max extents from different glyphs,
// resulting in a bounding box that is wider than any single glyph.  But
// this is the way Windows 3.1 does it, so that's the way we'll do it.

    // pifi->fwdMaxCharInc = (FWORD) BE_INT16(&phhea->advanceWidthMax);

    pifi->fwdMaxCharInc = (FWORD) (pifi->rclFontBox.right - pifi->rclFontBox.left);

// fwdAveCharWidth

    if (pjOS2)
    {
        pifi->fwdAveCharWidth = (FWORD)BE_INT16(pjOS2 + OFF_OS2_xAvgCharWidth);

    // This is here for Win 3.1 compatibility since some apps expect non-
    // zero widths and Win 3.1 does the same in this case.

        if( pifi->fwdAveCharWidth == 0 )
            pifi->fwdAveCharWidth = (FWORD)(pifi->fwdMaxCharInc / 2);
    }
    else
    {
        pifi->fwdAveCharWidth = (FWORD)((pifi->fwdMaxCharInc * 2) / 3);
    }

// !!! New code needed [kirko]
// The following is done for Win 3.1 compatibility
// reasons. The correct thing to do would be to look for the
// existence of the 'PCLT'Z table and retieve the XHeight and CapHeight
// fields, otherwise use the default Win 3.1 behavior.

    pifi->fwdCapHeight   = pifi->fwdUnitsPerEm/2;
    pifi->fwdXHeight     = pifi->fwdUnitsPerEm/4;

// Underscore, Subscript, Superscript, Strikeout

    if (ppost)
    {
        pifi->fwdUnderscoreSize     = (FWORD)BE_INT16(&ppost->underlineThickness);
        pifi->fwdUnderscorePosition = (FWORD)BE_INT16(&ppost->underlinePosition);
    }
    else
    {
    // must provide reasonable defaults, when there is no ppost table,
    // win 31 sets these quantities to zero. This does not sound reasonable.
    // I will supply the (relative) values the same as for arial font. [bodind]

        pifi->fwdUnderscoreSize     = (pifi->fwdUnitsPerEm + 7)/14;
        pifi->fwdUnderscorePosition = -((pifi->fwdUnitsPerEm + 5)/10);
    }

    if (pjOS2)
    {
        pifi->fwdSubscriptXSize     = BE_INT16(pjOS2 + OFF_OS2_ySubscriptXSize    );
        pifi->fwdSubscriptYSize     = BE_INT16(pjOS2 + OFF_OS2_ySubscriptYSize    );
        pifi->fwdSubscriptXOffset   = BE_INT16(pjOS2 + OFF_OS2_ySubscriptXOffset  );
        pifi->fwdSubscriptYOffset   = BE_INT16(pjOS2 + OFF_OS2_ySubscriptYOffset  );
        pifi->fwdSuperscriptXSize   = BE_INT16(pjOS2 + OFF_OS2_ySuperScriptXSize  );
        pifi->fwdSuperscriptYSize   = BE_INT16(pjOS2 + OFF_OS2_ySuperScriptYSize  );
        pifi->fwdSuperscriptXOffset = BE_INT16(pjOS2 + OFF_OS2_ySuperScriptXOffset);
        pifi->fwdSuperscriptYOffset = BE_INT16(pjOS2 + OFF_OS2_ySuperScriptYOffset);
        pifi->fwdStrikeoutSize      = BE_INT16(pjOS2 + OFF_OS2_yStrikeOutSize    );
        pifi->fwdStrikeoutPosition  = BE_INT16(pjOS2 + OFF_OS2_yStrikeOutPosition);
    }
    else
    {
        pifi->fwdSubscriptXSize     = 0;
        pifi->fwdSubscriptYSize     = 0;
        pifi->fwdSubscriptXOffset   = 0;
        pifi->fwdSubscriptYOffset   = 0;
        pifi->fwdSuperscriptXSize   = 0;
        pifi->fwdSuperscriptYSize   = 0;
        pifi->fwdSuperscriptXOffset = 0;
        pifi->fwdSuperscriptYOffset = 0;
        pifi->fwdStrikeoutSize      = pifi->fwdUnderscoreSize;
        pifi->fwdStrikeoutPosition  = (FWORD)(pifi->fwdMacAscender / 3) ;
    }


//
// panose
//
    pifi->ulPanoseCulture = FM_PANOSE_CULTURE_LATIN;
    if (pjOS2)
    {
        pifi->usWinWeight = BE_INT16(pjOS2 + OFF_OS2_usWeightClass);

    // now comes a hack from win31. Here is the comment from fonteng2.asm:

    // MAXPMWEIGHT equ ($ - pPM2WinWeight)/2 - 1

    //; Because winword shipped early TT fonts, - only index usWeightClass
    //; if between 0 and 9.  If above 9 then treat as a normal Windows lfWeight.
    //
    //        cmp     bx,MAXPMWEIGHT
    //        ja      @f                      ;jmp if weight is ok as is
    //        shl     bx, 1                   ;make it an offset into table of WORDs
    //        mov     bx, cs:[bx].pPM2WinWeight
    //@@:     xchg    ax, bx
    //        stosw                           ;store font weight

    // we emulate this in NT:

#define MAXPMWEIGHT ( sizeof(ausIFIMetrics2WinWeight) / sizeof(ausIFIMetrics2WinWeight[0]) )

        if (pifi->usWinWeight < MAXPMWEIGHT)
            pifi->usWinWeight = ausIFIMetrics2WinWeight[pifi->usWinWeight];

        RtlCopyMemory((PVOID)&pifi->panose,
                      (PVOID)(pjOS2 + OFF_OS2_Panose), sizeof(PANOSE));
    }
    else  // os2 table is not present
    {
        pifi->panose.bFamilyType       = PAN_FAMILY_TEXT_DISPLAY;
        pifi->panose.bSerifStyle       = PAN_ANY;
        pifi->panose.bWeight           = (BYTE)
           ((phead->macStyle & BE_MSTYLE_BOLD) ?
            PAN_WEIGHT_BOLD                    :
            PAN_WEIGHT_BOOK
           );
        pifi->panose.bProportion       = (BYTE)
            ((pifi->flInfo & FM_INFO_OPTICALLY_FIXED_PITCH) ?
             PAN_PROP_MONOSPACED                     :
             PAN_ANY
            );
        pifi->panose.bContrast         = PAN_ANY;
        pifi->panose.bStrokeVariation  = PAN_ANY;
        pifi->panose.bArmStyle         = PAN_ANY;
        pifi->panose.bLetterform       = PAN_ANY;
        pifi->panose.bMidline          = PAN_ANY;
        pifi->panose.bXHeight          = PAN_ANY;

    // have to fake it up, cause we can not read it from the os2 table
    // really important to go through this table for compatibility reasons [bodind]

        pifi->usWinWeight =
            ausIFIMetrics2WinWeight[pifi->panose.bWeight];
    }


// first, last, break, defalut

#define LAST_CHAR  255
#define SPACE_CHAR  32

    // Assume character bias is zero.

    pifi->lCharBias = 0;

    if (!(pff->ffca.fl & FF_TYPE_1_CONVERSION))
    {
        if (pjOS2 && *((uint16*)(pjOS2+SFNT_OS2_VERSION)) &&
            (DWORD)BE_UINT32(pjOS2+OFF_OS2_ulCodePageRange1) &&
            !IsBogusSignature((DWORD)BE_UINT32(pjOS2+OFF_OS2_ulCodePageRange1),pff))
        {
            DWORD  fontSig;

            fontSig = (DWORD)BE_UINT32(pjOS2+OFF_OS2_ulCodePageRange1);

            // We only supports ANSI/SHIFTJIS/BIG5/WANSANG/GB2312 charset for
            // FarEast version.
            //
            // [NOTE:]
            //
            // We will have TRUE world wide support in NT 4.0 with TranslateCharsetInfo()

            if( fontSig & ( FS_JISJAPAN | FS_CHINESETRAD | FS_CHINESESIMP |  FS_WANSUNG))
            {
                if(fontSig & gfsCurSignature)
                {
                    USHORT AnsiCodePage, OemCodePage;
                    EngGetCurrentCodePage(&OemCodePage,&AnsiCodePage);

                    pifi->jWinCharSet = gjCurCharset;
                    pff->ffca.uiFontCodePage = AnsiCodePage;
                }
                else
                {
                // Here we try to make the code compatible with NT 4.0

                    if(fontSig & FS_LATIN1)
                    {
                        pifi->jWinCharSet = ANSI_CHARSET;
                        pff->ffca.uiFontCodePage = 1252;
                    }
                    else if (fontSig & FS_JISJAPAN)
                    {
                        pifi->jWinCharSet   = SHIFTJIS_CHARSET;
                        pff->ffca.uiFontCodePage = 932;
                    }
                    else if (fontSig & FS_CHINESETRAD)
                    {
                        pifi->jWinCharSet   = CHINESEBIG5_CHARSET;
                        pff->ffca.uiFontCodePage = 950;
                    }
                    else if (fontSig & FS_CHINESESIMP)
                    {
                       pifi->jWinCharSet   = GB2312_CHARSET;
                        pff->ffca.uiFontCodePage = 936;
                    }
                    else if (fontSig & FS_WANSUNG)
                    {
                        pifi->jWinCharSet   = HANGEUL_CHARSET;
                        pff->ffca.uiFontCodePage = 949;
                    }
                }
            }
            else
            {
                pifi->jWinCharSet = jWinCharset;

            // Added this next line of garbage for Win 3.1 compatability sake.
            // The WatchTower Library depends on for the charset to be set properly
            // on a set of fonts that comes with it.  [gerritv] 3-6-95

                if (!jWinCharset && (pifi->panose.bFamilyType==PAN_FAMILY_PICTORIAL) && (pff->ffca.iGlyphSet == GSET_TYPE_SYMBOL))
                   pifi->jWinCharSet = SYMBOL_CHARSET;

                pff->ffca.uiFontCodePage = 1252;
            }
        }
        else
        {
        // Determine character set.
            if (pff->ffca.iGlyphSet == GSET_TYPE_HIGH_BYTE)
            {
                switch (pff->ffca.ui16SpecificID)
                {
                case BE_SPEC_ID_SHIFTJIS:
                    pifi->jWinCharSet   = SHIFTJIS_CHARSET;
                    pff->ffca.uiFontCodePage = 932;
                   break;

                case BE_SPEC_ID_GB:
                    pifi->jWinCharSet   = GB2312_CHARSET;
                    pff->ffca.uiFontCodePage = 936;
                    break;

                case BE_SPEC_ID_BIG5:
                    pifi->jWinCharSet   = CHINESEBIG5_CHARSET;
                    pff->ffca.uiFontCodePage = 950;
                    break;

                case BE_SPEC_ID_WANSUNG:
                    pifi->jWinCharSet   = HANGEUL_CHARSET;
                    pff->ffca.uiFontCodePage = 949;
                    break;

                default: // default to the old code
                    ASSERTDD(FALSE, "illegal high byte charset");
                    pifi->jWinCharSet   = ANSI_CHARSET;
                    pff->ffca.uiFontCodePage = 1252;
                    break;
                }
            }
            else if(bContainGlyphSet( U_HALFWIDTH_KATAKANA_LETTER_A , pff->pgset ) &&
               bContainGlyphSet( U_HALFWIDTH_KATAKANA_LETTER_I , pff->pgset ) &&
               bContainGlyphSet( U_HALFWIDTH_KATAKANA_LETTER_U , pff->pgset ) &&
               bContainGlyphSet( U_HALFWIDTH_KATAKANA_LETTER_E , pff->pgset ) &&
               bContainGlyphSet( U_HALFWIDTH_KATAKANA_LETTER_O , pff->pgset )
               )
            {
                pifi->jWinCharSet   = SHIFTJIS_CHARSET;
                pff->ffca.uiFontCodePage = 932;

            }
            else if( bContainGlyphSet( U_FULLWIDTH_HAN_IDEOGRAPHIC_61D4 , pff->pgset ) &&
                    bContainGlyphSet( U_FULLWIDTH_HAN_IDEOGRAPHIC_9EE2 , pff->pgset )
                    )
            {
                pifi->jWinCharSet   = GB2312_CHARSET;
                pff->ffca.uiFontCodePage = 936;
            }
            else if( bContainGlyphSet( U_FULLWIDTH_HAN_IDEOGRAPHIC_9F98 , pff->pgset ) &&
                    bContainGlyphSet( U_FULLWIDTH_HAN_IDEOGRAPHIC_9F79 , pff->pgset )
                    )
            {
                pifi->jWinCharSet   = CHINESEBIG5_CHARSET;
                pff->ffca.uiFontCodePage = 950;
            }
            else if( bContainGlyphSet( U_FULLWIDTH_HANGUL_LETTER_GA  , pff->pgset ) &&
                    bContainGlyphSet( U_FULLWIDTH_HANGUL_LETTER_HA , pff->pgset )
                    )
            {
                pifi->jWinCharSet   = HANGEUL_CHARSET;
                pff->ffca.uiFontCodePage = 949;
            }
            else if(bContainGlyphSet( U_PRIVATE_USER_AREA_E000 , pff->pgset ) &&
                    IsCurrentCodePageDBCS())
            {
                USHORT AnsiCodePage, OemCodePage;
                EngGetCurrentCodePage(&OemCodePage,&AnsiCodePage);

                // !!! I claim that what we really want to do is
                // return the proper DBCS charset (based on the current code page)
                // if there are characters in the EUDC range.  If the current
                // code page is not a DBCS code page then we shouldn't be here
                // and should fall through to the old behavior.  Hence I've added
                // a check above making sure the current code page is a DBCS
                // code page  in order to get here.  The old code didn't have
                // this check and had the following functionality instead of
                // my switch statement.
                // GreTranslateCharSetInfo from the engine I will implement that
                // functionality here [gerritv]
                //
                //if( GreTranslateCharsetInfo((DWORD *)GetACP(),&csi,TCI_SRCCODEPAGE) )
                //    pifi->jWinCharSet = csi.ciCharset;
                //else
                //    pifi->jWinCharSet = ANSI_CHARSET;

                switch(AnsiCodePage)
                {
                  case 932:
                    pifi->jWinCharSet = SHIFTJIS_CHARSET;
                    break;
                  case 949:
                    pifi->jWinCharSet = HANGEUL_CHARSET;
                    break;
                  case 1361:
                    pifi->jWinCharSet = JOHAB_CHARSET;
                    break;
                  case 936:
                    pifi->jWinCharSet = GB2312_CHARSET;
                    break;
                  case 950:
                    pifi->jWinCharSet = CHINESEBIG5_CHARSET;
                    break;
                  default:
                    ASSERTDD(FALSE, "shouldn't be here if non DBCS code page\n");
                }

                pff->ffca.uiFontCodePage = AnsiCodePage;
            }
            else
            {
                pifi->jWinCharSet = jWinCharset;

            // Added this next line of garbage for Win 3.1 compatability sake.
            // The WatchTower Library depends on for the charset to be set properly
            // on a set of fonts that comes with it.  [gerritv] 3-6-95

                if (!jWinCharset && (pifi->panose.bFamilyType==PAN_FAMILY_PICTORIAL) &&  (pff->ffca.iGlyphSet == GSET_TYPE_SYMBOL))
                    pifi->jWinCharSet = SYMBOL_CHARSET;
                pff->ffca.uiFontCodePage = 1252;
            }
        }

        if (pff->ffca.ui16PlatformID == BE_PLAT_ID_MS && (pjOS2))
        {
        // win 31 compatibility behavior, ask kirko about the origin

            USHORT usF, usL;

            usF = BE_UINT16(pjOS2 + OFF_OS2_usFirstChar);
            usL = BE_UINT16(pjOS2 + OFF_OS2_usLastChar);

            if (usL > LAST_CHAR)
            {
                if (usF > LAST_CHAR)
                {
                    pifi->lCharBias = (LONG) (usF - (USHORT) SPACE_CHAR);

                    pifi->jWinCharSet = SYMBOL_CHARSET;
                    pifi->chFirstChar = SPACE_CHAR;
                    pifi->chLastChar  = (BYTE)min(LAST_CHAR, usL - usF + SPACE_CHAR);
                }
                else
                {
                    pifi->chFirstChar = (BYTE) usF;
                    pifi->chLastChar = LAST_CHAR;
                }
            }
            else
            {
                pifi->chFirstChar = (BYTE) usF;
                pifi->chLastChar  = (BYTE) usL;
            }
        //
        // if chFirstChar is less-than 2.. we do not substract...
        //
            if( pifi->chFirstChar >= 2 )
                pifi->chFirstChar   -= 2;


            //
            //  In SHIFTJIS TrueType font, We use 0xa5 ( U+ff65 ) character
            // as a SBCS default character accoring to Microsoft Standard
            // character set specification ( SHIFTJIS version )
            //  font file's default char ( 0x1f ) is a DBCS(Full Width)
            // defalt character.
            // in NT, we won't use DBCS default character
            //

            if( pifi->jWinCharSet == SHIFTJIS_CHARSET )
            {
                pifi->chDefaultChar = 0xa5;
                pifi->chBreakChar   = pifi->chFirstChar + 2;
            }
            else if ( pifi->jWinCharSet == CHINESEBIG5_CHARSET ||
                     pifi->jWinCharSet == GB2312_CHARSET         )
            {

                pifi->chDefaultChar = 0x20; // Space
                pifi->chBreakChar   = pifi->chFirstChar + 2;
            }
            else if ( pifi->jWinCharSet == HANGEUL_CHARSET )
            {
                    pifi->chDefaultChar = 0x7f;
                    pifi->chBreakChar   = 0x1f;
            }
            else
            {
                pifi->chDefaultChar = pifi->chFirstChar + 1;
                pifi->chBreakChar   = pifi->chDefaultChar + 1;
            }

            //!!! little bit dangerous, what if 32 and 31 do not exhist in the font?
            //!!! we must not lie to the engine, these two have to exhist in
            //!!! some of the runs reported to the engine [bodind]

            // Pls refer above comment

            if( pifi->jWinCharSet == SHIFTJIS_CHARSET )
            {
                pifi->wcDefaultChar = (WCHAR) 0xff65;
                pifi->wcBreakChar   = (WCHAR) pifi->chBreakChar;
            }
            else if( IS_ANY_DBCS_CHARSET(pifi->jWinCharSet) )
            {
                pifi->wcDefaultChar = (WCHAR) 0x25a1;
                pifi->wcBreakChar   = (WCHAR) pifi->chBreakChar;
            }
            else
            {
                pifi->wcDefaultChar = (WCHAR) pifi->chDefaultChar;
                pifi->wcBreakChar   = (WCHAR) pifi->chBreakChar  ;
            }
        }
        else
        {
        // win 31 compatibility behavior

            pifi->chFirstChar   = SPACE_CHAR - 2;
            pifi->chLastChar    = LAST_CHAR;

            //
            //  In SHIFTJIS TrueType font, We use 0xa5 ( U+ff65 ) character
            // as a SBCS default character according to Microsoft Standard
            // character set specification ( SHIFTJIS version )
            //  font file's default char ( 0x1f ) is a DBCS defalt character.
            // in NT, we won't use DBCS default character.
            //

            if( pifi->jWinCharSet == SHIFTJIS_CHARSET )
            {
                pifi->chDefaultChar = 0xa5;
                pifi->chBreakChar   = SPACE_CHAR;
            }
            else if (pifi->jWinCharSet == CHINESEBIG5_CHARSET ||
                     pifi->jWinCharSet == GB2312_CHARSET         )
            {
                pifi->chDefaultChar = 0x20; // Space
                pifi->chBreakChar   = SPACE_CHAR;
            }
            else
            {
                pifi->chBreakChar   = SPACE_CHAR;
                pifi->chDefaultChar = SPACE_CHAR - 1;
            }

            //!!! little bit dangerous, what if 32 and 31 do not exhist in the font?
            //!!! we must not lie to the engine, these two have to exhist in
            //!!! some of the runs reported to the engine [bodind]

            if( pifi->jWinCharSet == SHIFTJIS_CHARSET )
            {
                pifi->wcBreakChar   = SPACE_CHAR;
                pifi->wcDefaultChar = (WCHAR) 0xff65;
            }
            else if( pifi->jWinCharSet == CHINESEBIG5_CHARSET ||
                     pifi->jWinCharSet == GB2312_CHARSET         )
            {
                pifi->wcBreakChar   = SPACE_CHAR;
                pifi->wcDefaultChar = (WCHAR) 0x25a1;
            }
            else
            {
                pifi->wcBreakChar   = SPACE_CHAR;
                pifi->wcDefaultChar = SPACE_CHAR - 1;
            }
        }
    }
    else // t1 conversion, have to be compatible with ps driver:
    {
        pifi->chFirstChar   = ((BYTE *)phhea)[SFNT_HORIZONTALHEADER_RESERVED0];
        pifi->chLastChar    = ((BYTE *)phhea)[SFNT_HORIZONTALHEADER_RESERVED1];
        pifi->chDefaultChar = 149;
        pifi->chBreakChar   = ((BYTE *)phhea)[SFNT_HORIZONTALHEADER_RESERVED3] + pifi->chFirstChar;

    // charset has the highest weight. This will ensure that the charset of the
    // tt font is the same as charset of the original type 1 font, ensuring the
    // correct mapping. That is we will always get the tt conversion for the
    // screen and the corresponding t1 original on the printer.
    // The CharSet value got stored to hhead straight from .pfm file

        pifi->jWinCharSet = ((BYTE *)phhea)[SFNT_HORIZONTALHEADER_RESERVED4];

    // this is win31 hack. to understand look at pslib\pfmtontm.c

        #define NO_TRANSLATE_CHARSET 200 /* djm 12/20/87 */ // WIN31 HACK

        if (pifi->jWinCharSet == NO_TRANSLATE_CHARSET)
             pifi->jWinCharSet = ANSI_CHARSET;

    // adobe has handed out zapfdingbats with ansi charset in the pfm file.
    // ps resident version of zapfdingbats has charset = symbol.
    // For this reason only we override the value we have just written with
    // symbol charset. (In wow16 they force charset for zapfdingbats to SYMBOL)

        if
        (
         (!_wcsicmp((PWSTR)((BYTE*)pifi + pifi->dpwszFamilyName),L"ZapfDingbats") ||
          !_wcsicmp((PWSTR)((BYTE*)pifi + pifi->dpwszFamilyName),L"Symbol"))
         && (pifi->jWinCharSet == ANSI_CHARSET)
        )
        {
            pifi->jWinCharSet = SYMBOL_CHARSET;
        }
    }

// this is always done in the same fashion, regardless of the glyph set type

    {
        WCRUN *pwcRunLast = &pff->pgset->awcrun[pff->pgset->cRuns - 1];
        pifi->wcFirstChar = pff->pgset->awcrun[0].wcLow;
        pifi->wcLastChar  = pwcRunLast->wcLow + pwcRunLast->cGlyphs - 1;
    }


//!!! one should look into directional hints here, this is good for now

    pifi->ptlBaseline.x   = 1;
    pifi->ptlBaseline.y   = 0;
    pifi->ptlAspect.x     = 1;
    pifi->ptlAspect.y     = 1;

// this is what win 31 is doing, so we will do the same thing [bodind]

    pifi->ptlCaret.x = (LONG)BE_INT16(&phhea->horizontalCaretSlopeDenominator);
    pifi->ptlCaret.y = (LONG)BE_INT16(&phhea->horizontalCaretSlopeNumerator);

// We have to use one of the reserved fields to return the italic angle.

    if (ppost)
    {
    // The italic angle is stored in the POST table as a 16.16 fixed point
    // number.  We want the angle expressed in tenths of a degree.  What we
    // can do here is multiply the entire 16.16 number by 10.  The most
    // significant 16-bits of the result is the angle in tenths of a degree.
    //
    // In the conversion below, we don't care whether the right shift is
    // arithmetic or logical because we are only interested in the lower
    // 16-bits of the result.  When the 16-bit result is cast back to LONG,
    // the sign is restored.

        int16 iTmp;

        iTmp = (int16) ((BE_INT32((BYTE*)ppost + POSTSCRIPTNAMEINDICES_ITALICANGLE) * 10) >> 16);
        pifi->lItalicAngle = (LONG) iTmp;
    }
    else
        pifi->lItalicAngle = 0;

//
// vendor id
//
    if (pjOS2)
    {
        char *pchSrc = (char*)(pjOS2 + OFF_OS2_achVendID);

        pifi->achVendId[0] = *(pchSrc    );
        pifi->achVendId[1] = *(pchSrc + 1);
        pifi->achVendId[2] = *(pchSrc + 2);
        pifi->achVendId[3] = *(pchSrc + 3);
    }
    else
    {
        pifi->achVendId[0] = 'U';
        pifi->achVendId[1] = 'n';
        pifi->achVendId[2] = 'k';
        pifi->achVendId[3] = 'n';
    }

//
// kerning pairs
//
    {
        PBYTE pj =  (ptp->ateOpt[IT_OPT_KERN].dp)         ?
                    (pjView + ptp->ateOpt[IT_OPT_KERN].dp):
                    NULL;

        if (!pj)
        {
            pifi->cKerningPairs = 0;
        }
        else
        {
            PBYTE pjEndOfView = pjView + pff->cjView;

            ULONG cTables  = BE_UINT16(pj+KERN_OFFSETOF_TABLE_NTABLES);
            pj += KERN_SIZEOF_TABLE_HEADER;

            while (cTables)
            {
            //
            // Windows will only recognize KERN_WINDOWS_FORMAT
            //

            // make sure this doesn't put us past the file view
            // KERN_OFFSETOF_SUBTABLE_FORMAT > KERN_OFFSETOF_SUBTABLE_LENGTH so
            // one check here will cover both cases below where we derefence pj

                if(pj+KERN_OFFSETOF_SUBTABLE_FORMAT >= pjEndOfView ||
                   pj+KERN_OFFSETOF_SUBTABLE_FORMAT < pjView )
                {
                    WARNING("vFill_IFIMETRICS font has bad kerning table\n");
                    cTables = 0;
                    break;
                }

                if ((*(pj+KERN_OFFSETOF_SUBTABLE_FORMAT)) == KERN_WINDOWS_FORMAT)
                {
                    break;
                }
                pj += BE_UINT16(pj+KERN_OFFSETOF_SUBTABLE_LENGTH);
                cTables -= 1;
            }
            pifi->cKerningPairs = (SHORT) (cTables ? BE_UINT16(pj+KERN_OFFSETOF_SUBTABLE_NPAIRS) : 0);
        }
    }


// jWinPitchAndFamily

#ifdef THIS_IS_WIN31_SOURCE_CODE

; record family type

    mov ah, pIfiMetrics.ifmPanose.bFamilyKind
    or  ah,ah
    jz  @F
    .errnz  0 - PANOSE_FK_ANY
    dec ah
    jz  @F
    .errnz  1 - PANOSE_FK_NOFIT
    dec ah
    jz  @F
    .errnz  2 - PANOSE_FK_TEXT
    mov al, FF_SCRIPT
    dec ah
    jz  MFDSetFamily
    .errnz  3 - PANOSE_FK_SCRIPT
    mov al, FF_DECORATIVE
    dec ah
    jz  MFDSetFamily
    .errnz  4 - PANOSE_FK_DECORATIVE
    .errnz  5 - PANOSE_FK_PICTORIAL
@@:
    mov al, FF_MODERN
    cmp pIfiMetrics.ifmPanose.bProportion, PANOSE_FIXED_PITCH
    jz  MFDSetFamily
    mov al, pIfiMetrics.ifmPanose.bSerifStyle
    sub ah, ah
    mov si, ax
    add si, MiscSegOFFSET pPansoseSerifXlate
    mov al, cs:[si]     ;get serif style
MFDSetFamily:
    cmp pIfiMetrics.ifmPanose.bProportion, PANOSE_FIXED_PITCH
    je  @f
;    test    pIfiMetrics.fsType, IFIMETRICS_FIXED
;    jnz     @F
    inc al          ;hack: var pitch: 1, fixed pitch: 0
    .errnz  VARIABLE_PITCH-FIXED_PITCH-1
@@:
    or  al, PF_ENGINE_TYPE SHL PANDFTYPESHIFT ;mark font as engine
    stosb               ;copy pitch and font family info
    .errnz  efbPitchAndFamily-efbPixHeight-2

#endif  // end of win31 source code,

    if((pifi->jWinCharSet == SHIFTJIS_CHARSET) ||
        (pifi->jWinCharSet == HANGEUL_CHARSET))
    {   
          //
          // Following Code is Win3.1J compatibility
          //
          // ajPanoseFamilyForJapanese is defined as following
          //
          // static BYTE
          // ajPanoseFamilyForJapanese[16] = {
          //     FF_DONTCARE       //    0 (Any)
          //    ,FF_DONTCARE       //    1 (No Fit)
          //    ,FF_ROMAN          //    2 (Cove)
          //    ,FF_ROMAN          //    3 (Obtuse Cove)
          //    ,FF_ROMAN          //    4 (Square Cove)
          //    ,FF_ROMAN          //    5 (Obtuse Square Cove)
          //    ,FF_ROMAN          //    6 (Square)
          //    ,FF_ROMAN          //    7 (Thin)
          //    ,FF_ROMAN          //    8 (Bone)
          //    ,FF_ROMAN          //    9 (Exaggerated)
          //    ,FF_ROMAN          //   10 (Triangle)
          //    ,FF_MODERN         //   11 (Normal Sans)
          //    ,FF_MODERN         //   12 (Obtuse Sans)
          //    ,FF_MODERN         //   13 (Perp Sans)
          //    ,FF_MODERN         //   14 (Flared)
          //    ,FF_MODERN         //   15 (Rounded)
          //      };
          //
          //  Win3.1J determine the font is fixed pitch or not by
          // Proportion in PANOSE. if Proportion is PAN_PROP_MONOSPACED (9)
          // Win3.1J treat the font as fixed pitch font
          //
          // In detail, Please refer to following document
          //
          //  GDI TrueType Extension for Far East version Rev 1.02
          //     Author : Shusuke Uehara [ ShusukeU ]
          //
          //  30.Aug.1993 -By- Hideyuki Nagase [ hideyukn ]
          //

        if(pifi->panose.bFamilyType == PAN_FAMILY_SCRIPT)
        {
            pifi->jWinPitchAndFamily = FF_SCRIPT;
        }
        else
        {
            if (pifi->panose.bSerifStyle >= sizeof(ajPanoseFamilyForJapanese))
            {
                pifi->jWinPitchAndFamily = ajPanoseFamily[0];
            }
            else
            {
                pifi->jWinPitchAndFamily =
                    ajPanoseFamilyForJapanese[pifi->panose.bSerifStyle];
            }
        }

        if(pifi->panose.bProportion == PAN_PROP_MONOSPACED)
        {
            pifi->flInfo |= (FM_INFO_OPTICALLY_FIXED_PITCH | FM_INFO_DBCS_FIXED_PITCH);
        }

    }
    else
    {

        // verified that the translation to c is correct [bodind]
        // Set the family type in the upper nibble

        switch (pifi->panose.bFamilyType)
        {
        case PAN_FAMILY_DECORATIVE:

            pifi->jWinPitchAndFamily = FF_DECORATIVE;
            break;

        case PAN_FAMILY_SCRIPT:

            pifi->jWinPitchAndFamily = FF_SCRIPT;
            break;

        default:

            if (pifi->panose.bProportion == PAN_PROP_MONOSPACED)
            {
                pifi->jWinPitchAndFamily = FF_MODERN;
            }
            else
            {
                if (pifi->panose.bSerifStyle >= sizeof(ajPanoseFamily))
                {
                    pifi->jWinPitchAndFamily = ajPanoseFamily[0];
                }
                else
                {
                    pifi->jWinPitchAndFamily = ajPanoseFamily[pifi->panose.bSerifStyle];
                }
            }
            break;
        }
    
    }

// simulation information:

    if (pifi->dpFontSim = pifisz->dpSims)
    {
        FONTDIFF FontDiff;
        FONTSIM * pfsim = (FONTSIM *)((BYTE *)pifi + pifi->dpFontSim);
        FONTDIFF *pfdiffBold       = NULL;
        FONTDIFF *pfdiffItalic     = NULL;
        FONTDIFF *pfdiffBoldItalic = NULL;

        switch (pifi->fsSelection & (FM_SEL_ITALIC | FM_SEL_BOLD))
        {
        case 0:
        // all 3 simulations are present

            pfsim->dpBold       = DWORD_ALIGN(sizeof(FONTSIM));
            pfsim->dpItalic     = pfsim->dpBold + DWORD_ALIGN(sizeof(FONTDIFF));
            pfsim->dpBoldItalic = pfsim->dpItalic + DWORD_ALIGN(sizeof(FONTDIFF));

            pfdiffBold       = (FONTDIFF *)((BYTE*)pfsim + pfsim->dpBold);
            pfdiffItalic     = (FONTDIFF *)((BYTE*)pfsim + pfsim->dpItalic);
            pfdiffBoldItalic = (FONTDIFF *)((BYTE*)pfsim + pfsim->dpBoldItalic);

            break;

        case FM_SEL_ITALIC:
        case FM_SEL_BOLD:

        // only bold italic variation is present:

            pfsim->dpBold       = 0;
            pfsim->dpItalic     = 0;

            pfsim->dpBoldItalic = DWORD_ALIGN(sizeof(FONTSIM));
            pfdiffBoldItalic = (FONTDIFF *)((BYTE*)pfsim + pfsim->dpBoldItalic);

            break;

        case (FM_SEL_ITALIC | FM_SEL_BOLD):
            RIP("ttfd!another case when flags have been messed up\n");
            break;
        }

    // template reflecting a base font:
    // (note that the FM_SEL_REGULAR bit is masked off because none of
    // the simulations generated will want this flag turned on).

        FontDiff.jReserved1      = 0;
        FontDiff.jReserved2      = 0;
        FontDiff.jReserved3      = 0;
        FontDiff.bWeight         = pifi->panose.bWeight;
        FontDiff.usWinWeight     = pifi->usWinWeight;
        FontDiff.fsSelection     = pifi->fsSelection & ~FM_SEL_REGULAR;
        FontDiff.fwdAveCharWidth = pifi->fwdAveCharWidth;
        FontDiff.fwdMaxCharInc   = pifi->fwdMaxCharInc;
        FontDiff.ptlCaret        = pifi->ptlCaret;

    //
    // Create FONTDIFFs from the base font template
    //
        if (pfdiffBold)
        {
            *pfdiffBold = FontDiff;
            pfdiffBoldItalic->bWeight    = PAN_WEIGHT_BOLD;
            pfdiffBold->fsSelection     |= FM_SEL_BOLD;
            pfdiffBold->usWinWeight      = FW_BOLD;

        // really only true if ntod transform is unity

        // for backwards compatibility we increase the width only by one pixel in emboldening

            pfdiffBold->fwdAveCharWidth += 1;
            pfdiffBold->fwdMaxCharInc   += 1;
        }

        if (pfdiffItalic)
        {
            *pfdiffItalic = FontDiff;
            pfdiffItalic->fsSelection     |= FM_SEL_ITALIC;

            pfdiffItalic->ptlCaret.x = CARET_X;
            pfdiffItalic->ptlCaret.y = CARET_Y;
        }

        if (pfdiffBoldItalic)
        {
            *pfdiffBoldItalic = FontDiff;
            pfdiffBoldItalic->bWeight          = PAN_WEIGHT_BOLD;
            pfdiffBoldItalic->fsSelection     |= (FM_SEL_BOLD | FM_SEL_ITALIC);
            pfdiffBoldItalic->usWinWeight      = FW_BOLD;

            pfdiffBoldItalic->ptlCaret.x       = CARET_X;
            pfdiffBoldItalic->ptlCaret.y       = CARET_Y;

            // for backwards compatibility we increase the width only by one pixel in emboldening

            pfdiffBoldItalic->fwdAveCharWidth += 1;
            pfdiffBoldItalic->fwdMaxCharInc   += 1;
        }

    }

// offset to charesets

    pifi->dpCharSets = pifisz->dpCharSets;
    vFillIFICharsets(pff,
                     pifi,
                     (BYTE *)pifi + pifi->dpCharSets,
                     pjView,
                     pjOS2,
                     pgin);

// check if there is font signiture info

    pifiex->dpFontSig = pifisz->dpFontSig;

// fill in the font signature, for now, non-trivial only for tt fonts
// The following if is equivalent to
// if (pjOS2 && ((sfnt_OS2 *)pjOS2)->Version)

    if (pifiex->dpFontSig)
    {

        FONTSIGNATURE *pfsig = (FONTSIGNATURE *)((BYTE *)pifi + pifiex->dpFontSig);

        pfsig->fsUsb[0] = SWAPL(((sfnt_OS2 *)pjOS2)->ulCharRange[0]);
        pfsig->fsUsb[1] = SWAPL(((sfnt_OS2 *)pjOS2)->ulCharRange[1]);
        pfsig->fsUsb[2] = SWAPL(((sfnt_OS2 *)pjOS2)->ulCharRange[2]);
        pfsig->fsUsb[3] = SWAPL(((sfnt_OS2 *)pjOS2)->ulCharRange[3]);

		if ( ((sfnt_OS2 *)pjOS2)->Version != 0)
		{
			// 1.0 or higher contain those additional flags :
			if(IsBogusSignature((DWORD)BE_UINT32(pjOS2+OFF_OS2_ulCodePageRange1),pff))
			{
				pfsig->fsCsb[0] = FS_JISJAPAN;
			}
			else
			{
				pfsig->fsCsb[0] = SWAPL(((sfnt_OS2 *)pjOS2)->ulCodePageRange[0]);
			}

			pfsig->fsCsb[1] = SWAPL(((sfnt_OS2 *)pjOS2)->ulCodePageRange[1]);
		}
		else
		{
			pfsig->fsCsb[0] = 0;
			pfsig->fsCsb[1] = 0;
		}
    }

// if this is a far east vertical font we may create a vertical face

    if (IsAnyCharsetDbcs(&pff->ifi))
    {
        pff->ffca.fl |= FF_DBCS_CHARSET;

        if(pifi->panose.bProportion == PAN_PROP_MONOSPACED)
        {
            pifi->flInfo |= (FM_INFO_OPTICALLY_FIXED_PITCH | FM_INFO_DBCS_FIXED_PITCH);

        }
    }

    // Defining the pitch
    // set the lower 4 bits according to the LOGFONT convention
    pifi->jWinPitchAndFamily |= (pifi->flInfo & FM_INFO_OPTICALLY_FIXED_PITCH) ?
                                     FIXED_PITCH : VARIABLE_PITCH;

}


/*************************************************************************\
*
* BOOL bVerifyMsftHighByteTable
*
* History:
*  11-Oct-1993 -By- Hideyuki Nagase [HideyukN]
* Wrote it.
*
**************************************************************************/

STATIC BOOL bVerifyMsftHighByteTable
(
sfnt_mappingTable * pmap,
ULONG             * pgset,
CMAPINFO          * pcmi,
uint16              ui16SpecID
)
{
    UNREFERENCED_PARAMETER( pmap );

// Now, we only support SHIFTJIS encoding

    if( ui16SpecID != BE_SPEC_ID_SHIFTJIS &&
        ui16SpecID != BE_SPEC_ID_GB       &&
        ui16SpecID != BE_SPEC_ID_BIG5     &&
        ui16SpecID != BE_SPEC_ID_WANSUNG
      ) return( FALSE );

    // Init stuff

    *pgset = GSET_TYPE_HIGH_BYTE;

    pcmi->fl         = 0;
    pcmi->i_b7       = 0;
    pcmi->i_2219     = 0;
    pcmi->cRuns      = 0;
    pcmi->cGlyphs    = 0;

    return( TRUE );
}

/*************************************************************************\
*
* BOOL bVerifyMsftTableGeneral
*
* History:
*  11-Oct-1993 -By- Hideyuki Nagase [HideyukN]
* Wrote it.
*
**************************************************************************/

STATIC BOOL bVerifyMsftTableGeneral
(
sfnt_mappingTable * pmap,
ULONG             * pgset,
CMAPINFO          * pcmi,
uint16              ui16SpecID
)
{
    UNREFERENCED_PARAMETER( pmap );

// Now, we only support SHIFTJIS encoding

    if( ui16SpecID != BE_SPEC_ID_SHIFTJIS &&
        ui16SpecID != BE_SPEC_ID_GB       &&
        ui16SpecID != BE_SPEC_ID_BIG5     &&
        ui16SpecID != BE_SPEC_ID_WANSUNG
      ) return( FALSE );

// Init stuff

    *pgset = GSET_TYPE_GENERAL_NOT_UNICODE;

    pcmi->fl         = 0;
    pcmi->i_b7       = 0;
    pcmi->i_2219     = 0;
    pcmi->cRuns      = 0;
    pcmi->cGlyphs    = 0;

    return( TRUE );
}

/*************************************************************************\
*
* ULONG CreateGlyphSetFromMITable
*
* History:
*  11-Oct-1993 -By- Hideyuki Nagase [HideyukN]
* Wrote it.
*
**************************************************************************/

STATIC ULONG CreateGlyphSetFromMITable
(
CMAPINFO        *pcmi,
MbcsToIndex     *MITable,
USHORT           MICount,
ULONG          **ppgset
)
{
    USHORT     ii;
    INT        iCodePage;
    WcharToIndex *WITable;
    ULONG       cRuns;
    ULONG       cGlyphsSupported;
    ULONG       cjThis;
    BOOL bInRun = FALSE;
    FD_GLYPHSET *pgset;
    WcharToIndex *WINow;
    PWCRUN  pwcrun;
    HGLYPH *phg;


// Alloc WcharToIndex table

    WITable = PV_ALLOC( sizeof(WcharToIndex) * 0xFFFF );

    if( WITable == NULL )
    {
        WARNING("TTFD!CreateGlyphSetFromMITable() PV_ALLOC() fail\n");
        if (ppgset)
            *ppgset = NULL;

        return( 0 );
    }

    RtlZeroMemory( WITable , sizeof(WcharToIndex) * 0xFFFF );

// Set CodePage

    iCodePage = GetCodePageFromSpecId( pcmi->ui16SpecID );

// Fill up WcharToIndex table

    for( ii = 0 ; ii < MICount ; ii++ )
    {
        WCHAR wChar[2];
        int   iRet;

    // Convert Mbcs to Wide char

        iRet = EngMultiByteToWideChar(iCodePage ,
                                      wChar,
                                      2 * sizeof(WCHAR),
                                      MITable[ii].MbcsChar,
                                      2);

        if( iRet == -1 )
        {
            WARNING("TTFD!MultiByteToWideChar fail\n");
            V_FREE(WITable);
            if (ppgset)
                *ppgset = NULL;
            return( 0 );
        }

        if( !WITable[wChar[0]].bValid )
        {
            WITable[wChar[0]].bValid = TRUE;
            WITable[wChar[0]].wChar  = wChar[0];
            WITable[wChar[0]].hGlyph = MITable[ii].hGlyph;
        }
    }

// Dump WITable

#ifdef DBG_GLYPHSET
    for( ii = 0 ; ii < 0xFFFF ; ii++ )
    {
        if(WITable[ii].bValid)
        {
            TtfdDbgPrint("WideChar - %x : hGlyph - %x \n",
                         WITable[ii].wChar , WITable[ii].hGlyph );
        }
    }
#endif // DBG_GLYPHSET

// Compute cRuns and cGlyphsSupported

    cRuns = 0;
    cGlyphsSupported = 0;

    for( ii = 0 ; ii < 0xFFFF ; ii++ )
    {
        if( !WITable[ii].bValid )
        {
            if( bInRun )
            {
                bInRun = FALSE;
                cRuns++;
            }
        }
        else
        {
            bInRun = TRUE;
            cGlyphsSupported++;
        }
    }
    if( bInRun )
      cRuns++;


#ifdef DBG_GLYPHSET
    TtfdDbgPrint("cRuns - %x , cGlyphsSupported - %x\n",cRuns,cGlyphsSupported);
#endif // DBG_GLYPHSET

// Compute needed size for FD_GLYPHSET

    cjThis =   sizeof ( FD_GLYPHSET )  + (cRuns - 1) * sizeof ( WCRUN )
      + cGlyphsSupported * sizeof( HGLYPH );

    if( ppgset == NULL ) return( cjThis );

// Alloc FD_GLYPHSET table

    pgset = PV_ALLOC( cjThis );

    if( pgset == NULL )
    {
        WARNING("TTFD!cjComputeGLYPHSET_HIGH_BYTE() PV_ALLOC() fail\n");
        V_FREE(WITable);
        *ppgset = NULL;
        return( 0 );
    }

    RtlZeroMemory( pgset , cjThis );
    pgset->cjThis   = cjThis;
    pgset->flAccel  = 0;
    pgset->cRuns    = cRuns;
    pgset->cGlyphsSupported = cGlyphsSupported;

// Fill UP FD_GLYPHSET


    pwcrun = &(pgset->awcrun[0]);
    phg = (HGLYPH *)((PBYTE)pgset + sizeof( FD_GLYPHSET ) + (cRuns - 1) *
                      sizeof(WCRUN));

    WINow  = &WITable[0];

    for( ii = 0 ; ii < cRuns ; ii++ )
    {
        while( !WINow->bValid ) WINow++;

        pwcrun->wcLow   = WINow->wChar;
        pwcrun->cGlyphs = 0;
        pwcrun->phg     = phg;
        while( WINow->bValid )
        {
            pwcrun->cGlyphs++;
            *phg++ = WINow->hGlyph;
            WINow++;
        }
        pwcrun++;
    }

    V_FREE(WITable);

    *ppgset = (ULONG *)pgset;

    return( cjThis );
}

/*************************************************************************\
*
* ULONG cjComputeGLYPHSET_HIGH_BYTE
*
* History:
*  11-Oct-1993 -By- Hideyuki Nagase [HideyukN]
* Wrote it.
*
**************************************************************************/

typedef struct _subHeader
{
    uint16  firstCode;
    uint16  entryCount;
    int16   idDelta;
    uint16  idRangeOffset;
} subHeader;

STATIC ULONG cjComputeGLYPHSET_HIGH_BYTE
(
sfnt_mappingTable     *pmap,
ULONG                **ppgset,
CMAPINFO              *pcmi
)
{
    uint16    *pui16SubHeaderKeys = (uint16 *)((PBYTE)pmap + 6);
    subHeader *pSubHeaderArray    = (subHeader *)(pui16SubHeaderKeys + 256);

    UINT       cjChar = 0;
    USHORT     ii , jj;

    MbcsToIndex *MITable;
    USHORT       MICount;

    ULONG        cjGlyphSet;

#ifdef DBG_GLYPHSET
    TtfdDbgPrint("pui16SubHeaderKeys - %x\n",pui16SubHeaderKeys);
    TtfdDbgPrint("pSubHeaderArray    - %x\n",pSubHeaderArray);
#endif // DBG_GLYPHSET

// Compute how many chars in this cmap ?

// for single-byte char

    cjChar = (BE_UINT16(&(((subHeader *)((PBYTE)pSubHeaderArray))->entryCount)));

// for double-byte char

    for( ii = 0 ; ii < 256 ; ii ++ )
    {
        jj = BE_UINT16( &pui16SubHeaderKeys[ii] );
        if( jj != 0 )
          cjChar +=
            (BE_UINT16(&(((subHeader *)((PBYTE)pSubHeaderArray + jj))->entryCount)));
    }

#ifdef DBG_GLYPHSET
    TtfdDbgPrint("cjChar - %x\n",cjChar);
#endif // DBG_GLYPHSET

// Alloc memory for MbcsToIndex table

    MITable = PV_ALLOC( sizeof(MbcsToIndex) * cjChar );

    if( MITable == NULL )
    {
        WARNING("TTFD!cjComputeGLYPHSET_HIGH_BYTE() PV_ALLOC() fail\n");
        *ppgset = NULL;
        return( 0 );
    }

// Fill up MbcsToIndex table

    MICount = 0;

// Process single-byte char

    for( ii = 0 ; ii < 256 ; ii ++ )
    {
        USHORT entryCount, firstCode, idDelta, idRangeOffset;
        subHeader *CurrentSubHeader;
        uint16 *pui16GlyphArray;
        HGLYPH hGlyph;

        jj = BE_UINT16( &pui16SubHeaderKeys[ii] );

        if( jj != 0 ) continue;

        CurrentSubHeader = pSubHeaderArray;

        firstCode     = BE_UINT16(&(CurrentSubHeader->firstCode));
        entryCount    = BE_UINT16(&(CurrentSubHeader->entryCount));
        idDelta       = BE_UINT16(&(CurrentSubHeader->idDelta));
        idRangeOffset = BE_UINT16(&(CurrentSubHeader->idRangeOffset));

        pui16GlyphArray = (uint16 *)((PBYTE)&(CurrentSubHeader->idRangeOffset) +
                                     idRangeOffset);

#ifdef DBG_GLYPHSET
        TtfdDbgPrint("\n");
        TtfdDbgPrint("firstCode - %x , entryCount - %x\n",firstCode,entryCount);
        TtfdDbgPrint("idDelta   - %x , idROffset  - %x\n",idDelta,idRangeOffset);
        TtfdDbgPrint("GlyphArray - %x\n",pui16GlyphArray);
        TtfdDbgPrint("\n");
#endif // DBG_GLYPHSET

        // ASSERTDD( idDelta == 0 , "TTFD!cjComputeGLYPHSET_HIGH_BYTE:entryCount != 0\n" );

        hGlyph = (HGLYPH)BE_UINT16(&pui16GlyphArray[ii-firstCode]);

        if( hGlyph == 0 ) continue;

        MITable[MICount].MbcsChar[0] =  (UCHAR) ii;
        MITable[MICount].MbcsChar[1] =  (UCHAR) 0;
        MITable[MICount].hGlyph      =  hGlyph;
        MICount++;
    }

// Process double-byte char

    for( ii = 0 ; ii < 256 ; ii ++ )
    {
        USHORT entryCount, firstCode, idDelta, idRangeOffset;
        subHeader *CurrentSubHeader;
        uint16 *pui16GlyphArray;

        jj = BE_UINT16( &pui16SubHeaderKeys[ii] );

        if( jj == 0 ) continue;

        CurrentSubHeader = (subHeader *)((PBYTE)pSubHeaderArray + jj);

        firstCode     = BE_UINT16(&(CurrentSubHeader->firstCode));
        entryCount    = BE_UINT16(&(CurrentSubHeader->entryCount));
        idDelta       = BE_UINT16(&(CurrentSubHeader->idDelta));
        idRangeOffset = BE_UINT16(&(CurrentSubHeader->idRangeOffset));

        pui16GlyphArray = (uint16 *)((PBYTE)&(CurrentSubHeader->idRangeOffset) +
                                     idRangeOffset);

#ifdef DBG_GLYPHSET
        TtfdDbgPrint("\n");
        TtfdDbgPrint("firstCode - %x , entryCount - %x\n",firstCode,entryCount);
        TtfdDbgPrint("idDelta   - %x , idROffset  - %x\n",idDelta,idRangeOffset);
        TtfdDbgPrint("GlyphArray - %x\n",pui16GlyphArray);
        TtfdDbgPrint("\n");
#endif // DBG_GLYPHSET

        for( jj = firstCode ; jj < firstCode + entryCount ; jj++ )
        {
            HGLYPH hGlyph;

            hGlyph = (HGLYPH)(BE_UINT16(&pui16GlyphArray[jj-firstCode]));

            if( hGlyph == 0 ) continue;

            MITable[MICount].MbcsChar[0] = (UCHAR) ii;
            MITable[MICount].MbcsChar[1] = (UCHAR) jj;
            MITable[MICount].MbcsChar[2] = (UCHAR) 0;
            MITable[MICount].hGlyph      = hGlyph + idDelta;
            MICount++;
        }
    }

#ifdef DBG_GLYPHSET
// Dump MITable
//    for( ii = 0 ; ii < MICount ; ii++ )
    for( ii = 0 ; ii < 10 ; ii++ )
    {
        TtfdDbgPrint("MbcsChar - %2x%2x : hGlyph - %x \n"
                     ,MITable[ii].MbcsChar[0],
                     MITable[ii].MbcsChar[1] , MITable[ii].hGlyph );
    }
#endif // DBG_GLYPHSET

    cjGlyphSet = CreateGlyphSetFromMITable( pcmi, MITable, MICount, ppgset );

    V_FREE( MITable );

    return( cjGlyphSet );
}

/*************************************************************************\
*
* ULONG cjComputeGLYPHSET_MSFT_GENERAL
*
* History:
*  11-Oct-1993 -By- Hideyuki Nagase [HideyukN]
* Wrote it.
*
**************************************************************************/

STATIC ULONG cjComputeGLYPHSET_MSFT_GENERAL
(
sfnt_mappingTable     *pmap,
ULONG                **ppgset,
CMAPINFO              *pcmi
)
{
    USHORT  cSegments, cValidSegments;
    uint16 *pendCountKeep , *pstartCountKeep , *pendCount , *pstartCount;
    uint16 *pidDelta, *pRangeOffset, *pGlyphArray;

    USHORT  cChars;

    USHORT  ii;

    MbcsToIndex *MITable;
    USHORT       MICount;

    ULONG   cjGlyphSet;

    cSegments       = BE_UINT16((PBYTE)pmap + OFF_segCountX2) / 2;
    pendCountKeep   = pendCount   = (uint16 *)((PBYTE)pmap + OFF_endCount);
    pstartCountKeep = pstartCount = (uint16 *)(pendCount + (cSegments + 1));
    pidDelta                      = (uint16 *) pstartCount + (cSegments * 1);
    pRangeOffset                  = (uint16 *) pstartCount + (cSegments * 2);
    pGlyphArray                   = (uint16 *) pstartCount + (cSegments * 3);

#ifdef DBG_GLYPHSET
    TtfdDbgPrint("cSegments   - %x\n",cSegments   );
    TtfdDbgPrint("pstart      - %x\n",pstartCount );
    TtfdDbgPrint("pGlyphArray - %x\n",pGlyphArray );
    TtfdDbgBreakPoint();
#endif // DBG_GLYPHSET

// Compute valid segments : This is fix for love.ttf which has bogus cmap table
    cValidSegments = cSegments;
    if(pendCount[cSegments-1] != 0xFFFF){
    	WARNING("TTFD!cjComputeGLYPHSET_MSFT_GENERAL() : Last endCount is not 0xFFFF in cmap table\n");

    	for( ii = cSegments-2 ; ii >= 0 ; ii--){
    		if(pendCount[ii] == 0xFFFF){
    			cValidSegments = ii+1;
    			break;
    		}
    	}
    	
        ASSERTDD(cSegments != cValidSegments, "TTFD!cjComputeGLYPHSET_MSFT_GENERAL() : no 0xFFFF in endCount\n");
    }

// Compute how many chars in this table

    cChars = 0;
	
    for( ii = 0 ; ii < cValidSegments - 1 ; ii ++ , pendCount ++ , pstartCount ++ )
        cChars += (BE_UINT16(pendCount) - BE_UINT16(pstartCount) + 1);

#ifdef DBG_GLYPHSET
    TtfdDbgPrint("cChars - %x\n",cChars);
#endif // DBG_GLYPHSET

// Alloc memory for MbcsToIndex table

    MITable = PV_ALLOC( sizeof(MbcsToIndex) * cChars );

    if( MITable == NULL )
    {
        WARNING("TTFD!cjComputeGLYPHSET_MSFT_GENERAL() PV_ALLOC() fail\n");
        *ppgset = NULL;
        return( 0 );
    }

// Fill up MbcsToIndex table

    pendCount   = pendCountKeep;
    pstartCount = pstartCountKeep;

    MICount = 0;

    for( ii = 0 ; ii < cValidSegments - 1 ; ii ++ , pendCount ++ , pstartCount ++ )
    {
        USHORT usStart , usEnd;
        USHORT jj;

        usStart = BE_UINT16(pstartCount);
        usEnd   = BE_UINT16(pendCount);

#ifdef DBG_GLYPHSET
        TtfdDbgPrint("usStart - %x\n",usStart);
        TtfdDbgPrint("usEnd   - %x\n",usEnd);
#endif // DBG_GLYPHSET

    // Check order

        if( usStart > usEnd ) WARNING("TTFD!usStart > usEnd\n");

        for( jj = usStart ; jj <= usEnd ; jj ++ )
        {
            *(ULONG  *)(MITable[MICount].MbcsChar) = (LONG)0;

            if( usStart > 0xFF )
                *(USHORT *)(MITable[MICount].MbcsChar) = ((jj >> 8) | (jj << 8));
             else
                *(USHORT *)(MITable[MICount].MbcsChar) = jj;

            if( pRangeOffset[ii] == 0 )
                MITable[MICount].hGlyph = (USHORT)(jj + BE_UINT16(pidDelta + ii));
             else
               MITable[MICount].hGlyph =
                 (USHORT)(BE_UINT16((USHORT *)&pRangeOffset[ii] +
                          BE_UINT16(&pRangeOffset[ii])/2+(jj-usStart)) +
                          BE_UINT16( pidDelta + ii ));
            MICount++;
        }
    }

#ifdef DBG_GLYPHSET
    TtfdDbgPrint("MICount - %x\n",MICount);
#endif

    ASSERTDD( cChars == MICount , "cChars != MICount - 1\n" );

#ifdef DBG_GLYPHSET
// Dump MITable
    for( ii = 0 ; ii < MICount ; ii++ )
    {
        TtfdDbgPrint("MbcsChar - %2x%2x : hGlyph - %x \n"
                     ,MITable[ii].MbcsChar[0] ,
                     MITable[ii].MbcsChar[1] ,
                     MITable[ii].hGlyph );
    }
#endif // DBG_GLYPHSET

    cjGlyphSet = CreateGlyphSetFromMITable( pcmi, MITable, MICount, ppgset );

    V_FREE( MITable );

    return( cjGlyphSet );
}

/******************************Public*Routine******************************\
*
* STATIC ULONG cjComputeGLYPHSET_TEMPLATE
*
* History:
*  07-Mar-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


STATIC ULONG cjComputeGLYPHSET_TEMPLATE
(
sfnt_mappingTable     *pmap,
fs_GlyphInputType     *pgin,
fs_GlyphInfoType      *pgout,
FD_GLYPHSET          **ppgset,
ULONG                  ul_wcBias,
ULONG                  iGsetType
)
{
    ULONG iRun;
    HGLYPH *phg;
    FS_ENTRY iRet;
    FD_GLYPHSET  *pgset = NULL;

// zero out just the result in case somebody tries to use it when we fail:

    *ppgset = NULL;

// go on to produce template set:

    switch (iGsetType)
    {
    case GSET_TYPE_SYMBOL:
        pgset = pgsetComputeSymbolCP();
        break;

    case GSET_TYPE_PSEUDO_WIN:
        pgset = EngComputeGlyphSet(0, 0, 256);
        break;

    case GSET_TYPE_MAC_ROMAN:
        pgset = EngComputeGlyphSet(10000, 0, 256); // mac code page
        break;

    default:
        RIP("wrong iGsetType passed to cjComputeGLYPHSET_TEMPLATE\n");
        return 0;
    }


    if (!pgset)
    {
        return 0;
    }

// override whatever was there before:

    pgset->flAccel = GS_16BIT_HANDLES;

// now fix the handles to be glyph indices:

    for (iRun = 0; iRun < pgset->cRuns; iRun++)
    {
		phg = pgset->awcrun[iRun].phg;

        if ((iRet = fs_WinNTGetGlyphIDs (pgin, pgset->awcrun[iRun].cGlyphs, 0, ul_wcBias, phg, phg)) != NO_ERR)
        {
             V_FSERROR(iRet);
             WARNING("TTFD!_cjComputeGLYPHSET_TEMPLATE, fs_WinNTGetGlyphIDs\n");
			 V_FREE(pgset);
			 return 0;
        }


    }

    *ppgset = pgset;
    return pgset->cjThis;
}


/******************************Module*Header*******************************\
* Defines the Unicode to GlyphIndex map of the old BiDi font pages.
* These fonts have a fixed page layout and are identified by
* pOS2->ufSelection&0xff00 == (0xb1 or 0xb2 or 0xb3 or 0xb4 or 0xb5)
* &&
* pCmap->puStartCount&0xff00 is true
\**************************************************************************/

#define C_MAX_OLDBIDI_CHARS   256        // Max char/FP

// Creating the FD_GLYPHSET for the Old Arabic/Hebrew TTF fonts
// structure used to walk through the hard-coded font tables
// Any change here should accompany a change in the hard-coded tables below
typedef struct _UNICODE_TO_HGLYPH
{
  WCHAR  wcLow ;
  USHORT cGlyphs ;
  USHORT gi[1] ;
} WC_GI, *PWC_GI ;



// The structure of the following FontPages is based on the above structure
WCHAR wc_giArabicSimplifiedFP[]=
{
  // wcLow   cGlyphs   gi[..]
  0x0020 ,   0x03   ,  0x20,0x21,0x22,
  0x0025 ,   0x01   ,  0x25,
  0x0028 ,   0x04   ,  0x28,0x29,0x2a,0x2b,
  0x002d ,   0x0d   ,  0x2d,0x2e,0x2f,0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,
  0x003d ,   0x01   ,  0x3d,
  0x005b ,   0x03   ,  0x5b,0x5c,0x5d,
  0x00ab ,   0x01   ,  0x23,
  0x00bb ,   0x01   ,  0x24,
  0x00d7 ,   0x01   ,  0x26,
  0x060c ,   0x01   ,  0x2c,
  0x061b ,   0x01   ,  0x3b,
  0x061f ,   0x01   ,  0x3f,
  0x0621 ,   0x1a   ,  0xad,0x45,0x43,0xbb,0x47,0xba,0x41,0x4a,0xa9,0x4c,0x4e,0x51,0x54,
                       0x57,0x58,0x59,0x5a,0x60,0x62,0x64,0x66,0x68,0x69,0x6a,0x6e,0x72,
  0x0640 ,   0x13   ,  0x40,0x75,0x78,0x7a,0x7c,0x7e,0xe1,0xa4,0xa5,0xac,0xa8,0xd5,0xd6,
                       0xd9,0xd2,0xd3,0xd8,0xd7,0xd4,
  0x0660 ,   0x0a   ,  0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,
  0x066b ,   0x02   ,  0x5e,0x5e,
  0x200c ,   0x04   ,  0x0c,0x0d,0x0e,0x0f,
  0x2018 ,   0x02   ,  0x3c,0x3e,

  0xffff ,   0x00   ,  0x00,    // terminator
} ;


WCHAR wc_giArabicTraditionalFP[]=
{
  // wcLow   cGlyphs   gi[..]
  0x0020 ,   0x03   ,  0x20,0x21,0x22,
  0x0025 ,   0x01   ,  0x25,
  0x0028 ,   0x04   ,  0x28,0x29,0x2a,0x2b,
  0x002c ,   0x04   ,  0x5e,0x2d,0x2e,0x2f,
  0x003a ,   0x01   ,  0x3a,
  0x003d ,   0x01   ,  0x3d,
  0x005b ,   0x01   ,  0x5b,
  0x005d ,   0x01   ,  0x5d,
  0x00ab ,   0x01   ,  0x23,
  0x00bb ,   0x01   ,  0x24,
  0x00d7 ,   0x01   ,  0x26,
  0x00f7 ,   0x01   ,  0x27,
  0x060c ,   0x01   ,  0x2c,
  0x061b ,   0x01   ,  0x3b,
  0x061f ,   0x01   ,  0x3f,
  0x0621 ,   0x1a   ,  0xd5,0x45,0x43,0xda,0x47,0xd9,0x41,0x4c,0xd1,0x50,0x54,0x58,0x60,
                       0x64,0x65,0x67,0x69,0x6b,0x70,0x74,0x78,0x7e,0x7f,0xa3,0xaa,0xae,
  0x0640 ,   0x13   ,  0x40,0xb2,0xb6,0xba,0xbe,0xc3,0xc6,0xca,0xcb,0xd4,0xd0,0xe7,0xe8,
                       0xeb,0xe4,0xe5,0xea,0xe9,0xe6,
  0x0660 ,   0x0a   ,  0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,
  0x066b ,   0x02   ,  0x5e,0x5e,
  0x200c ,   0x04   ,  0x0c,0x0d,0x0e,0x0f,
  0x201c ,   0x02   ,  0x3c,0x3e,

  0xffff ,   0x00   ,  0x00,    // terminator
} ;

WCHAR wc_giHebrewFP[]=
{
  // wcLow   cGlyphs   gi[..]
  0x0020 ,   0x21   ,  0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,
                       0x2d,0x2e,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,
                       0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x40,
  0x005b ,   0x05   ,  0x5b,0x5c,0x5d,0x5e,0x5f,
  0x007b ,   0x04   ,  0x7b,0x7c,0x7d,0x7e,
  0x00a3 ,   0x01   ,  0xa3,
  0x00a7 ,   0x01   ,  0xa7,
  0x00b0 ,   0x01   ,  0xb0,
  0x00b2 ,   0x02   ,  0x82,0x83,
  0x00b7 ,   0x01   ,  0xb7,
  0x00b9 ,   0x01   ,  0x81,
  0x00bc ,   0x03   ,  0xbc,0xbd,0xbe,
  0x00d7 ,   0x01   ,  0xaa,
  0x00f7 ,   0x01   ,  0xba,
  0x05b0 ,   0x14   ,  0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,
                       0xcd,0xce,0xcf,0xd0,0xd1,0xd2,0xd3,
  0x05d0 ,   0x1b   ,  0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,
                       0xed,0xee,0xef,0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,
                       0xfa,
  0x200e ,   0x02   ,  0xfd,0xfe,
  0x2070 ,   0x01   ,  0x80,
  0x2074 ,   0x06   ,  0x84,0x85,0x86,0x87,0x88,0x89,
  0x20aa ,   0x01   ,  0xa4,

  0xffff ,   0x00   ,  0x00,    // terminator
} ;



















/******************************Public*Routine******************************\
* cjComputeGLYPHSET_OLDBIDI
*
*
* Compute the FD_GLYPHSET for old Arabic/Hebrew TTFs which have fsSelection
* equal 0xb1, 0xb2, 0xb3 0xb4 or 0xb5 and puStartCount&0xFF00 is true
*
*
* History:
*  14-Aug-1997 -by- Samer Arafeh [SamerA]
* Wrote it.
\**************************************************************************/
STATIC ULONG cjComputeGLYPHSET_OLDBIDI(
    fs_GlyphInputType *pgin,
    fs_GlyphInfoType  *pgout,
    FD_GLYPHSET      **ppgset,
    ULONG              ul_wcBias
)
{
  ULONG         cjOldBiDiCP ;
  PWC_GI        pwc_gi=NULL,pwc_giTEMP ;
  INT           cGlyphsSupported=0, cRuns=0 ;
  PFD_GLYPHSET  pgsetOldBiDiCP=NULL ;
  uint16        characterCode;
  uint16        glyphIndex;
  ULONG         cjThis = 0;

  *ppgset = NULL ;    // to start with

  // Parse the proper table

  switch (ul_wcBias & 0xff00)
  {
    case 0xf000:       // Old Hebrew FP
    {
      pwc_giTEMP = pwc_gi= (PWC_GI)wc_giHebrewFP;
    }
    break;

    case 0xf100:       // Old Arabic Simplified FP
    {
      pwc_giTEMP = pwc_gi= (PWC_GI)wc_giArabicSimplifiedFP;
    }
    break;

    case 0xf200:       // Old Arabic Traditional FP
    {
      pwc_giTEMP = pwc_gi= (PWC_GI)wc_giArabicTraditionalFP;
    }
    break;

    default:
    {
      WARNING("TTFD!_ciComputeGLYPHSET_OLDBIDI, Invalid ul_wcBias\n");
      return 0;
    }
    break;
  }

  // Count number of runs

  while( pwc_gi->cGlyphs )
  {
    cRuns++ ;
    cGlyphsSupported += pwc_gi->cGlyphs ;
    pwc_gi = (PWC_GI)&pwc_gi->gi[pwc_gi->cGlyphs] ;
  }

  // add the U+FX00 page

  cGlyphsSupported += C_MAX_OLDBIDI_CHARS ;

  pwc_gi = pwc_giTEMP ;

  // Generate the FD_GLYPHSET for the claimed and non-claimed

  cjOldBiDiCP  = SZ_GLYPHSET(cRuns+1 ,  cGlyphsSupported );
  pgsetOldBiDiCP = (FD_GLYPHSET *)PV_ALLOC(cjOldBiDiCP);

  if( pgsetOldBiDiCP )
  {
    INT iRun ;
    INT iGlyph;
    HGLYPH *phgD,*phgDLastRun;
    FS_ENTRY iRet;

    pgsetOldBiDiCP->cjThis = cjOldBiDiCP;
    pgsetOldBiDiCP->flAccel = GS_16BIT_HANDLES;
    pgsetOldBiDiCP->cGlyphsSupported = cGlyphsSupported ;
    pgsetOldBiDiCP->cRuns = cRuns+1 ;

    // Let's fill in the Unicode content of the font

    phgD = (HGLYPH *)&pgsetOldBiDiCP->awcrun[cRuns+1] ;

    phgDLastRun = phgD+(cGlyphsSupported-C_MAX_OLDBIDI_CHARS);
    RtlZeroMemory( phgDLastRun , sizeof(HGLYPH)*(C_MAX_OLDBIDI_CHARS) );

    for( iRun = 0; iRun < cRuns; iRun++ )
    {
      uint16 usCh = pwc_gi->wcLow ;

      pgsetOldBiDiCP->awcrun[iRun].wcLow = usCh ;
      pgsetOldBiDiCP->awcrun[iRun].cGlyphs = pwc_gi->cGlyphs ;
      pgsetOldBiDiCP->awcrun[iRun].phg = phgD ;

      // Now let's fill phg area with true GIs

      for( iGlyph=0 ; iGlyph<pwc_gi->cGlyphs ; iGlyph++ )
      {
        characterCode = (uint16)(pwc_gi->gi[iGlyph]+ul_wcBias) ;

        if ((iRet = fs_GetGlyphIDs(pgin, 1, characterCode, NULL, &glyphIndex)) != NO_ERR)   // get the true GI
        {
          V_FSERROR(iRet);
          WARNING("TTFD!_pgsetComputeOldBiDiCP, fs_GetGlyphIDs\n");
          V_FREE(pgsetOldBiDiCP);
          return 0 ;
        }

        *phgD = (HGLYPH)glyphIndex ;
        phgDLastRun[pwc_gi->gi[iGlyph]] = *phgD;
        phgD++ ;
      }

      pwc_gi = (PWC_GI)&pwc_gi->gi[pwc_gi->cGlyphs] ;
    }

    // Now, let's reflect the U+FX00 range as the last one
    pgsetOldBiDiCP->awcrun[cRuns].wcLow = (WCHAR)ul_wcBias ;
    pgsetOldBiDiCP->awcrun[cRuns].cGlyphs = C_MAX_OLDBIDI_CHARS ;
    pgsetOldBiDiCP->awcrun[cRuns].phg = phgD ;

    // Now let's phg area with true GIs

    for( iGlyph=0 ; iGlyph<C_MAX_OLDBIDI_CHARS ; iGlyph++ )
    {
      characterCode = (uint16)(iGlyph+ul_wcBias) ;

      // make sure no redundant calls to the rasterizer

      if ( !(*phgD) )
      {
        if ((iRet = fs_GetGlyphIDs(pgin, 1, characterCode, NULL, &glyphIndex)) != NO_ERR)   // get the true GI
        {
          V_FSERROR(iRet);
          WARNING("TTFD!_pgsetComputeOldBiDiCP, fs_GetGlyphIDs\n");
          V_FREE(pgsetOldBiDiCP);
          return 0 ;
        }

        *phgD = glyphIndex ;
      }
      phgD++ ;
    }

    cjThis = pgsetOldBiDiCP->cjThis; 
    *ppgset = pgsetOldBiDiCP ;
  }

  return cjThis ;
}


/*************************************************************************\
*
* BOOL bContainGlyphSet()
*
* History:
*  11-Oct-1993 -By- Hideyuki Nagase [HideyukN]
* Wrote it.
*
**************************************************************************/

STATIC BOOL  bContainGlyphSet
(
WCHAR                 wc,
PFD_GLYPHSET          pgs
)
{
    WCRUN *pwcRun = pgs->awcrun;

// binary search over awcrun, looking for correct run, if any

    WCRUN *pwcRunLow = pgs->awcrun;
    WCRUN *pwcRunHi = pgs->awcrun + (pgs->cRuns - 1);

    while ( 1 )
    {
        int nwc;

    // if run exists, it is in [pwcRunLow, pwcRunHi]

        pwcRun = pwcRunLow + (pwcRunHi-pwcRunLow)/2;
        nwc = wc - pwcRun->wcLow;

        if ( nwc < 0)
        {
        // if correct run exists, it is in [pwcRunLow, pwcRun)
            pwcRunHi = pwcRun - 1;

        }
        else if ( nwc >= (int)pwcRun->cGlyphs)
        {
        // if correct run exists, it is in (pwcRun, pwcHi]
            pwcRunLow = pwcRun + 1;
        }
        else
        {
        // pwcRun is correct run
        if ( pwcRun->phg != NULL )
            return TRUE;
        else
            return FALSE;
        }

        if ( pwcRunLow > pwcRunHi )
        {
        // wc is not in any run
            return FALSE;
        }
    } // while
}

//*****************************************************************************
//*****************   F I L L   I F I   C H A R S E T S   *********************
//*****************************************************************************
//
//   Now determine how many charsets are supported in the TTF file. If
//    the family isn't pictorial, then I assume it is at least an WANSI
//    font. Then I see if a Unicode 0x2206 (Mac Increment char) is present
//   in the font, if it is then I assume the MAC_CHARSET is supported.
//    Finally, I check if Unicode 0x2592 (IBM medium shade char) is in
//   the font, if so then I assume the OEM_CHARSET is supported.
//
//   If the family is pictorial, then assume only the SYMBOL_CHARSET is
//    supported.
//
//  Wed 25-Jan-1995 -by- Bodin Dresevic [BodinD]
//  update: stolen from win95 code
//*****************************************************************************

// these are in descending order in the font signature.  there are no holes
// as defined in the spec. we go backwards so that 437 will be found first
// (usa/english)

UINT oemPages[] = {437, 850, 708, 737, 775, 852, 855, 857,
                   860, 861, 862, 863, 864, 865, 866, 869};

#define FEOEM_CHARSET 254

void vFillIFICharsets(
    FONTFILE *pff,
    IFIMETRICS *pifi,
    BYTE *aCharSets,
    BYTE *pjView,
    BYTE * pjOS2,
    fs_GlyphInputType *pgin)
{
    UINT   iCS = 0;
    DWORD  fsig;
    UINT   i;
    DWORD  fsigOEM;
    BYTE   cs;
    uint8 *pCmap = pjView + pff->ffca.dpMappingTable + sizeof(sfnt_mappingTable);
    uint16 giFirstChar = pjOS2 ? BE_UINT16(pjOS2+OFF_OS2_usFirstChar) : 0;

    // This routine is to be replaced by a routine that searches the registry
    // for the names of fonts that have bogus os2 table signatures:


    BOOL   bDBCSFont = IS_ANY_DBCS_CHARSET(pifi->jWinCharSet);
    DWORD CSfs = FS_HEBREW | FS_ARABIC | FS_THAI;

    // Far East versions of Windows 95 ignore the charset array for far east
    // fonts.  Instead they jam the charset of the font, the value 254
    // (which the call FEOEM_CHARSET), and DEFAULT_CHARSET into the array.
    // The following code comes from t2api.asm
    //
    // ifdef    DBCS                            ;DBCS T2 output
    //;-----------------  Set charset and family for DBCS font  -------------------
    //
    //  test    bptr fEmbed, FEM_WIN31  ; Want new format?
    //  .errnz  (FEM_WIN31 and 0FF00h)  ;
    //  jnz     @f                      ; No,
    //  sub     di, MAXCHARSETS
    //@@:
        //  Save        <es, bx>
        //  cCall       GetCharSetFromLanguage, <lhFontFile>
        //  or      ax, ax         <-- this will be zero if non-far east font
        //  jz      @f
    //
    //  test    bptr fEmbed, FEM_WIN31  ; Want new format?
    //  .errnz  (FEM_WIN31 and 0FF00h)  ;
    //  jnz     MFDOldCharSetOnly       ; No, skip charset array
    //
        //  and     eax, 0ffh
        //  or      eax, (FEOEM_CHARSET shl 8) + (DEFAULT_CHARSET shl 16)
    //  mov     dwptr es:[di], eax
    //MFDOldCharSetOnly:
    //  mov     es:[di-efbaCharSets-1].efbCharSet, al
    //
    // For WIN 95-J compatibility sake I will do the same here [gerritv]
    // If you remove this code in the future be sure to put a check in here
    // to handle the buggy msmincho and msgothic fonts that have FS_CHINESESIMP
    // instead of FS_JAPANESE in the signature. [gerritv]
    //


    if (bDBCSFont &&  pjOS2 &&
        (!(*((uint16*)(pjOS2+SFNT_OS2_VERSION))) ||
        IsBogusSignature((DWORD)BE_UINT32(pjOS2+OFF_OS2_ulCodePageRange1),pff))
    )
    {
        aCharSets[iCS++] = pifi->jWinCharSet;
    }
    else if (pjOS2 && *((uint16*)(pjOS2+SFNT_OS2_VERSION)))
    {
        // font signature

        fsig = (DWORD)BE_UINT32(pjOS2+OFF_OS2_ulCodePageRange1);

    // Jam in the current one first if it is supported:

        if ( (fsig & gfsCurSignature) && !(CSfs & gfsCurSignature) )
          aCharSets[iCS++] = gjCurCharset;

    // now jam in the rest of them:

        for (i=0; i<nCharsets; i++)
        {
          if ( (fs[i] != gfsCurSignature) || (CSfs & gfsCurSignature) )
          {
            if (fsig & fs[i])
              aCharSets[iCS++] = (BYTE)charsets[i];
          }
        }

        // get the codepage value if any.

        fsig = (DWORD)BE_UINT32(pjOS2+OFF_OS2_ulCodePageRange2);
        if (fsig)
        {
            USHORT OemCodePage, AnsiCodePage;

            EngGetCurrentCodePage(&OemCodePage,&AnsiCodePage);

            fsigOEM = 0x80000000L;
            for (i=0; i<NOEMCHARSETS; i++)
            {
                if ((UINT) OemCodePage == oemPages[i])
                {
                    if (fsigOEM & fsig)
                        aCharSets[iCS++] = OEM_CHARSET;
                    break;
                }
                fsigOEM >>= 1;          // move to next OEM page
            }
        }

    // make sure that ifi.jWinCharSet is consistent with whatever we have put in
    // the dpCharSet array. If ifi.jWinCharSet is not one of the charsets in the
    // array fix it so that it is.

    // Example of the font which was not fully consistent and was having enum problems
    // because we were setting jWinCharSet to zero while dpCharSets array was
    // not claiming zero was trado.ttf, arabic font with os/2 table of version 1.0.
    // Signature only claimed arabic charset, but we put zero (rather than arabic)

        for (i = 0; i < iCS; i++)
        {
            if (aCharSets[i] == pifi->jWinCharSet)
                break;
        }

        if (i == iCS) // did not fid it, have to fix it up:
        {
        	if( iCS > 0 )
            	pifi->jWinCharSet = aCharSets[0];
	// Indic fonts such as Mangal doesn't have charset so aCharSets have garbage values.
	// For this problem, we use DEFAULT_CHARSET instead. This also let Fonts that do not 
	// support any charset be enumerated with DEFAULT_CHARSET
            else
            	pifi->jWinCharSet = DEFAULT_CHARSET;        
        }
    }
    else if ((pifi->panose.bFamilyType != PAN_FAMILY_PICTORIAL ) && (giFirstChar < 256))
    {
        if (pCmap)
        {
            if( pifi->fsSelection & 0xff00 )
            {
            // backward compatability. If a value exists here then this is a
            // Win 3.1 foreign font.

                cs = (BYTE)((pifi->fsSelection >> 8) & 0xff) ;
                switch (cs)
                {
                case 0xB2:
                case 0xB3:
                case 0xB4:
                    aCharSets[iCS++] = pifi->jWinCharSet =
                      (EngLpkInstalled() ? 0xb2 : SYMBOL_CHARSET);
                    break;
                default:
                    aCharSets[iCS++] = cs;
                    break;
                }

            }
            else
            {
                FS_ENTRY iRet;
                uint16 glyphIndex, glyphIndex2;
#if 0
    // ANSI_FIX
    // ANSI_FIX
    //
    // for now, we always assume an ANSI charset if we are not sure.
    //
    // This will have to change later.  The non-ANSI markets have fonts
    // which have no ANSI so this would be wrong.
    //
                iRet = fs_GetGlyphIDs(pgin, 1, 0xd0, NULL, &glyphIndex);
                if (iRet == NO_ERR && glyphIndex != 0)
    // ANSI_FIX
    // ANSI_FIX
#endif
                aCharSets[iCS++] = ANSI_CHARSET;    // 0

                iRet = fs_GetGlyphIDs(pgin, 1, 0x2206, NULL, &glyphIndex);
                if (iRet == NO_ERR && glyphIndex != 0)
                    aCharSets[iCS++] = MAC_CHARSET;

                iRet = fs_GetGlyphIDs(pgin, 1, 0x03cb, NULL, &glyphIndex);
                iRet = fs_GetGlyphIDs(pgin, 1, 0x03a9, NULL, &glyphIndex2); // upper case omega
                if (iRet == NO_ERR && (glyphIndex != 0 || glyphIndex2 != 0))
                    aCharSets[iCS++] = GREEK_CHARSET;

                iRet = fs_GetGlyphIDs(pgin, 1, 0x0130, NULL, &glyphIndex);
                if (iRet == NO_ERR && glyphIndex != 0)
                    aCharSets[iCS++] = TURKISH_CHARSET;

                iRet = fs_GetGlyphIDs(pgin, 1, 0x05d0, NULL, &glyphIndex);
                if (iRet == NO_ERR && glyphIndex != 0)
                    aCharSets[iCS++] = HEBREW_CHARSET;

            // 451 is obscure glyph, should not require it,
            // we shall keep this for for compat. sake.
            // We shall request 42f which is inverted R as in Toy'R'Us

                iRet = fs_GetGlyphIDs(pgin, 1, 0x0451, NULL, &glyphIndex);
                iRet = fs_GetGlyphIDs(pgin, 1, 0x042F, NULL, &glyphIndex2);
                if (iRet == NO_ERR && (glyphIndex != 0 || glyphIndex2 != 0))
                    aCharSets[iCS++] = RUSSIAN_CHARSET;

                iRet = fs_GetGlyphIDs(pgin, 1, 0x0148, NULL, &glyphIndex);
                iRet = fs_GetGlyphIDs(pgin, 1, 0x010c, NULL, &glyphIndex2); // C^ ie. Ch
                if (iRet == NO_ERR && (glyphIndex != 0 || glyphIndex2 != 0))
                    aCharSets[iCS++] = EASTEUROPE_CHARSET;

            // lower case u with accent sign underneath, not present in EE charset

                iRet = fs_GetGlyphIDs(pgin, 1, 0x0173, NULL, &glyphIndex);
                if (iRet == NO_ERR && glyphIndex != 0)
                    aCharSets[iCS++] = BALTIC_CHARSET;

                iRet = fs_GetGlyphIDs(pgin, 1, 0x2592, NULL, &glyphIndex);
                if (iRet == NO_ERR && glyphIndex != 0)
                    aCharSets[iCS++] = OEM_CHARSET;     // ff
            }
        }
    }
    else if( (giFirstChar >= 0xf000) && (pifi->fsSelection & 0xff00))
    {
    // its a 3.1 oldstyle font. For some reason best known to
    // themselves they decided to put all the fonts in the symbol area and
    // to ignore unicode.
    //
    // HACK! As we know that GDI16 never looks beyond the DEFAULT_CHARSET
    // flag we shove at the end, and we know that there are 14 spare locations
    // in the array, we will use these to store the symbol location where
    // the font is loaded from.  This is a hardcoded value taken from
    // win3.1/Heb/ara/far
    //
    // this isn't the cleanest way to do this, but this affects nothing else
    // in the system so there is no core affected code and it's fast for the
    // LPK. (This is good cause then Chico apps aren't dragged down by bogus
    // 3.1 stuff).

            switch ((BYTE)((pifi->fsSelection >> 8) & 0xff))
            {
            case 0xB1 :               // hebrew case
            case 0xB5 :
                aCharSets[iCS++] = pifi->jWinCharSet =
                  EngLpkInstalled() ? 0xB1 : SYMBOL_CHARSET;
            break;

            case 0xB2 :               // arabic
            case 0xB3 :
            case 0xB4 :
                aCharSets[iCS++] = pifi->jWinCharSet =
                  EngLpkInstalled() ? 0xB2 : SYMBOL_CHARSET;
            }
    }
    else
    {
        aCharSets[iCS++] = pifi->jWinCharSet;
    }


    if (bDBCSFont && (iCS < 16))
    {
        aCharSets[iCS++] = FEOEM_CHARSET;
    }

// Terminate with all DEFAULT_...

    while ( iCS < 16 )
        aCharSets[iCS++] = DEFAULT_CHARSET;

// Mangal.ttf doesn't have support for Latin alphabet
//    ASSERTDD(aCharSets[0] != DEFAULT_CHARSET, "IFI charset array bogus\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\ttfd\fd.h ===
/******************************Module*Header*******************************\
* Module Name: fd.h
*
* file which is going to be included by the most *.c files in this directory.
* Supplies basic types, debugging stuff, error logging and checking stuff,
* error codes, usefull macros etc.
*
* Created: 22-Oct-1990 15:23:44
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/


#define  IFI_PRIVATE

#include <stddef.h>
#include <stdarg.h>
#include <excpt.h>
#include <windef.h>
#include <wingdi.h>
#include <winddi.h>

typedef ULONG W32PID;

#include "mapfile.h"

#include "fot16.h"
#include "service.h"     // string service routines
#include "tt.h"          // interface to the font scaler
//#include "common.h"

#include "fontfile.h"
#include "cvt.h"
#include "dbg.h"

#define RETURN(x,y)   {WARNING((x)); return(y);}
#define RET_FALSE(x)  {WARNING((x)); return(FALSE);}


#if defined(_AMD64_) || defined(_IA64_)

#define  vLToE(pe,l)           (*(pe) = (FLOATL)(l))

#else   // i386

ULONG  ulLToE (LONG l);
VOID   vLToE(FLOATL * pe, LONG l);

#endif

#define STATIC
#define DWORD_ALIGN(x) (((x) + 3L) & ~3L)
#define QWORD_ALIGN(x) (((x) + 7L) & ~7L)

#if defined(i386)
// natural alignment for x86 is on 32 bit boundary

#define NATURAL           DWORD
#define NATURAL_ALIGN(x)  DWORD_ALIGN(x)

#else
// for mips and alpha we want 64 bit alignment

#define NATURAL           DWORDLONG
#define NATURAL_ALIGN(x)  QWORD_ALIGN(x)

#endif



#define ULONG_SIZE(x)  (((x) + sizeof(ULONG) - 1) / sizeof(ULONG))


// MACROS FOR converting 16.16 BIT fixed numbers to LONG's


#define F16_16TOL(fx)            ((fx) >> 16)
#define F16_16TOLFLOOR(fx)       F16_16TOL(fx)
#define F16_16TOLCEILING(fx)     F16_16TOL((fx) + (Fixed)0x0000FFFF)
#define F16_16TOLROUND(fx)       ((((fx) >> 15) + 1) >> 1)


// MACROS FOR GOING THE OTHER WAY ARROUND

#define LTOF16_16(l)   (((LONG)(l)) << 16)
#define BLTOF16_16OK(l)  (((l) < 0x00007fff) && ((l) > -0x00007fff))

// 16.16 --> 28.4

#define F16_16TO28_4(X)   ((X) >> 12)

// going back is not always legal

#define F28_4TO16_16(X)   ((X) << 12)
#define B28_4TO16_16OK(X) (((X) < 0x0007ffff) && ((X) > -0x0007ffff))

// 26.6 --> 16.16, never go the other way

#define F26_6TO16_16(X)   ((X) << 10)
#define B26_6TO16_16OK(X) (((X) < 0x003fffff) && ((X) > -0x003fffff))

// sin of 20 degrees in 16.16 notation, however computed only with
// 8.8 presission to be fully win31 compatible, SEE gdifeng.inc, SIM_ITALIC
// SIM_ITALIC equ 57h

#define FX_SIN20 0x5700
#define FX_COS20 0xF08F

// CARET_Y/CARET_X = tan 12
// these are the values for arial italic from hhead table

#define CARET_X  0X07
#define CARET_Y  0X21


#if DBG
VOID vFSError(FS_ENTRY iRet);
#define V_FSERROR(iRet) vFSError((iRet))
#else
#define V_FSERROR(iRet)
#endif



FD_GLYPHSET *pgsetComputeSymbolCP();

DHPDEV
ttfdEnablePDEV(
    DEVMODEW*   pdm,
    PWSTR       pwszLogAddr,
    ULONG       cPat,
    HSURF*      phsurfPatterns,
    ULONG       cjCaps,
    ULONG*      pdevcaps,
    ULONG       cjDevInfo,
    DEVINFO*    pdi,
    HDEV        hdev,
    PWSTR       pwszDeviceName,
    HANDLE      hDriver
    );

VOID
ttfdDisablePDEV(
    DHPDEV  dhpdev
    );

VOID
ttfdCompletePDEV(
    DHPDEV dhpdev,
    HDEV   hdev
    );

LONG
ttfdQueryFontCaps (
    ULONG culCaps,
    PULONG pulCaps
    );

BOOL
ttfdUnloadFontFile (
    HFF hff
    );

BOOL
ttfdUnloadFontFileTTC (
    HFF hff
    );

PFD_GLYPHATTR
ttfdQueryGlyphAttrs (
    FONTOBJ *pfo,
    ULONG   iMode
    );

LONG
ttfdQueryFontFile (
    HFF     hff,
    ULONG   ulMode,
    ULONG   cjBuf,
    PULONG  pulBuf
    );

PIFIMETRICS
ttfdQueryFont (
    DHPDEV dhpdev,
    HFF    hff,
    ULONG  iFace,
    ULONG_PTR *pid
    );

PVOID
ttfdQueryFontTree (
    DHPDEV  dhpdev,
    HFF     hff,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR *pid
    );

LONG
ttfdQueryFontData (
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    );

VOID
ttfdFree (
    PVOID pv,
    ULONG_PTR id
    );

VOID
ttfdDestroyFont (
    FONTOBJ *pfo
    );

LONG
ttfdQueryTrueTypeTable (
    HFF     hff,
    ULONG   ulFont,  // always 1 for version 1.0 of tt
    ULONG   ulTag,   // tag identifyint the tt table
    PTRDIFF dpStart, // offset into the table
    ULONG   cjBuf,   // size of the buffer to retrieve the table into
    PBYTE   pjBuf,   // ptr to buffer into which to return the data
    PBYTE  *ppjTable,// ptr to table in otf file
    ULONG  *cjTable  // size of table
    );


LONG
ttfdQueryTrueTypeOutline (
    FONTOBJ   *pfo,
    HGLYPH     hglyph,         // glyph for which info is wanted
    BOOL       bMetricsOnly,   // only metrics is wanted, not the outline
    GLYPHDATA *pgldt,          // this is where the metrics should be returned
    ULONG      cjBuf,          // size in bytes of the ppoly buffer
    TTPOLYGONHEADER *ppoly
    );

PVOID ttfdGetTrueTypeFile(HFF hff,ULONG *pcj);

LONG ttfdQueryFontFile
(
    HFF     hff,
    ULONG   ulMode,
    ULONG   cjBuf,
    ULONG  *pulBuf
);

BOOL
bQueryAdvanceWidths (
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    LONG    *plWidths,
    ULONG    cGlyphs
    );

BOOL bLoadFontFile (
    ULONG_PTR iFile,
    PVOID pvView,
    ULONG cjView,
    ULONG ulLangId,
    ULONG ulFastCheckSum,
    HFF   *phttc
    );

FD_GLYPHSET *
pgsetRunSplitFor5C(
    FD_GLYPHSET * pOldgset
    );

typedef struct _NOT_GM  // ngm, notional glyph metrics
{
    SHORT xMin;
    SHORT xMax;
    SHORT yMin;   // char box in notional
    SHORT yMax;
    SHORT sA;     // a space in notional
    SHORT sD;     // char inc in notional

} NOT_GM, *PNOT_GM;

extern BYTE  gjCurCharset;
extern DWORD gfsCurSignature;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\ttfd\service.c ===
/******************************Module*Header*******************************\
* Module Name: service.c
*
* set of service routines for converting between ascii and  unicode strings
*
* Created: 15-Nov-1990 11:38:31
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/


#include "fd.h"

/******************************Public*Routine******************************\
*
* vCpyBeToLeUnicodeString,
*
* convert (c - 1) WCHAR's in big endian format to little endian and
* put a terminating zero at the end of the dest string
*
* History:
*  11-Dec-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID vCpyBeToLeUnicodeString(LPWSTR pwcLeDst, LPWSTR pwcBeSrc, ULONG c)
{
    LPWSTR pwcBeSrcEnd;

    ASSERTDD(c > 0, "vCpyBeToLeUnicodeString: c == 0\n");

    for
    (
        pwcBeSrcEnd = pwcBeSrc + (c - 1);
        pwcBeSrc < pwcBeSrcEnd;
        pwcBeSrc++, pwcLeDst++
    )
    {
        *pwcLeDst = BE_UINT16(pwcBeSrc);
    }
    *pwcLeDst = (WCHAR)(UCHAR)'\0';

}



/******************************Public*Routine******************************\
*
* VOID  vCvtMacToUnicode
*
* Effects:
*
* Warnings:
*
* History:
*  07-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




VOID  vCvtMacToUnicode
(
ULONG  ulLangId,
LPWSTR pwcLeDst,
PBYTE  pjSrcMac,
ULONG  c
)
{
    PBYTE pjSrcEnd;

//!!! I believe that LangId should be used to select the proper conversion
//!!! routine, this is a stub [bodind]

    ulLangId;

    for
    (
        pjSrcEnd = pjSrcMac + c;
        pjSrcMac < pjSrcEnd;
        pjSrcMac++, pwcLeDst++
    )
    {
        *pwcLeDst = (WCHAR)(*pjSrcMac);
    }
}

/******************************Public*Routine******************************\
*
* VOID  vCpyMacToLeUnicodeString
*
*
* Ensures that string is zero terminated so that other cool things can be
* done to it such as wcscpy, wcslen e.t.c.
*
* History:
*  13-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID  vCpyMacToLeUnicodeString
(
ULONG  ulLangId,
LPWSTR pwcLeDst,
PBYTE  pjSrcMac,
ULONG  c
)
{
    ASSERTDD(c > 0, "vCpyMacToLeUnicodeString: c == 0\n");

    c -= 1;
    vCvtMacToUnicode (ulLangId, pwcLeDst, pjSrcMac, c);
    pwcLeDst[c] = (WCHAR)(UCHAR)'\0';
}


/**************************************************************************\
* The rest of the file is stolen from JeanP's win31 code in fd_mac.c
*
* Conversion routines from Mac character code and Mac langageID to
* Unicode character code and OS2 langage ID
*
* Public routines:
*   Unicode2Mac
*   Mac2Lang
*
\**************************************************************************/



/*
** Converts the OS2 langageID to the to the Mac langage ID
*/

#ifdef JEANP_IS_WRONG

// JEANp messed up danish and german, else my conversion table is the
// same as mine [bodind]

uint16  aCvLang [32] =
{
   0, 12,  0,  0,  0,  0,  0,  7,
  14,  0,  6, 13,  1, 10,  0, 15,
   3, 11, 21,  4,  9,  0,  8,  0,
   0,  0, 18,  0,  0,  5, 22, 17
};

#endif // JEANP_IS_WRONG

uint16  aCvLang [32] =
{
   0,     //  0 -> 0  (0           -> english == default)
  12,     //  1 -> 12 (arabic      -> arabic)
   0,     //  2 -> 0  (bulgarian   -> english == default)
   0,     //  3 -> 0  (catalon     -> english == default)
   0,     //  4 -> 0  (Chinese     -> english == default)
   0,     //  5 -> 0  (Czeh        -> english == default)
   7,     //  6 -> 7  (Danish      -> Danish)
   2,     //  7 -> 2  (German      -> German)
  14,     //  8 -> 14 (Greek       -> Greek)
   0,     //  9 -> 0  (English     -> english)
   6,     //  a -> 6  (spanish     -> spanish)
  13,     //  b -> 13 (finnish     -> finnish)
   1,     //  c -> 1  (french      -> french)
  10,     //  d -> 10 (hebrew      -> hebrew)
   0,     //  e -> 0  (hungarian   -> english == default)
  15,     //  f -> 15 (icelandic   -> icelandic)
   3,     // 10 -> 3  (Italian     -> italian)
  11,     // 11 -> 11 (japanese    -> japanese)
  21,     // 12 -> 21 (korean      -> hindi, this seems to be a bug?????????)
   4,     // 13 -> 4  (dutch       -> dutch)
   9,     // 14 -> 9  (norweign    -> norweign)
   0,     // 15 -> 0  (Polish      -> english == default)
   8,     // 16 -> 8  (portugese   -> portugese)
   0,     // 17 -> 0  (rhaeto-romanic -> english == default)
   0,     // 18 -> 0  (romanian    -> english == default)
   0,     // 19 -> 0  (russian     -> english == default)
  18,     // 1a -> 18 (Yugoslavian -> Yugoslavian), lat or cyr ????
   0,     // 1b -> 0  (slovakian   -> english == default)
   0,     // 1c -> 0  (albanian    -> english == default)
   5,     // 1d -> 5  (swedish     -> swedish)
  22,     // 1e -> 22 (thai        -> thai)
  17      // 1f -> 17 (turkish     -> turkish)
};



/************************** Public Routine *****************************\
*  Mac2Lang
*
* Converts the OS2 langageID to the to the Mac langage ID
*
* History:
*  Fri Dec 08 11:28:35 1990    -by-    Jean-Francois Peyroux [jeanp]
* Wrote it.
\***********************************************************************/

uint16 ui16Mac2Lang (uint16 Id)
{
// this is just a way to bail out if an incorrect lang id is passed to
// this routine [bodind]
// Note that Id & 1f < 32 == sizeof(aCvLang)/sizeof(aCvLang[0]), no gp-fault

    return aCvLang[Id & 0x1f];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\ttfd\service.h ===
/******************************Module*Header*******************************\
* Module Name: service.h
*
* routines in service.c
*
* Created: 15-Nov-1990 13:00:56
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
*
\**************************************************************************/



VOID vCpyBeToLeUnicodeString(LPWSTR pwcLeDst, LPWSTR pwcBeSrc, ULONG c);


VOID  vCpyMacToLeUnicodeString
(
ULONG  ulLangId,
LPWSTR pwcLeDst,
PBYTE  pjSrcMac,
ULONG  c
);

VOID  vCvtMacToUnicode
(
ULONG  ulLangId,
LPWSTR pwcLeDst,
PBYTE  pjSrcMac,
ULONG  c
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\ttfd\fd_poly.c ===
/******************************Module*Header*******************************\
* Module Name: fd_poly.c
*
* stolen from win31 tt code
*
* Created: 10-Feb-1992 17:10:39
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
*
\**************************************************************************/

#include "fd.h"
#include "winerror.h"

STATIC VOID vQsplineToPolyBezier (
    ULONG      cBez,          // IN  count of curves to convert to beziers format
    POINTFIX * pptfixStart,   // IN  starting point on the first curve
    POINTFIX * pptfixSpline,  // IN  array of (cBez+1) points that, together with the starting point *pptfixStart define the spline
    POINTFIX * pptfixBez      // OUT buffer to be filled with 3 * cBez poly bezier control points
    );


BOOL bGeneratePath (
    PATHOBJ         * ppo,        // IN OUT pointer to the path object to be generated
    TTPOLYGONHEADER * ppolyStart, // IN     pointer to the buffer with outline data
    ULONG             cj,         // IN     size of the buffer
    ULONG           * pcjOut,      // OUT   size of needed bezier buffer
    TTPOLYGONHEADER * ppolyBeziers // OUT   buffer with Bezier outline data
    );

#if DBG

// #define DBG_POLYGON

#endif

VOID vFillSingularGLYPHDATA(HGLYPH,ULONG,FONTCONTEXT*,GLYPHDATA*);
VOID vFillGLYPHDATA(HGLYPH,ULONG,FONTCONTEXT*,fs_GlyphInfoType*,GLYPHDATA*,GMC*,POINTL*);
BOOL bGetGlyphMetrics(FONTCONTEXT*,HGLYPH,FLONG,FS_ENTRY*);

/******************************Public*Routine******************************\
*
* void Scale_16DOT16
*
*
* Effects: 26.6 -> 16.16
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* stole it from jeanp and modified for nt
\**************************************************************************/

//!!! some checks should be put in so as to verify that 26.6 -> 16.16
//!!! conversion can be done without loosing information [bodind]

void Scale_16DOT16 (POINTFX  *ppfx, F26Dot6 x, F26Dot6 y, int xLsb2Org, int yLsb2Org)
{
    LONG lTmp;

#ifdef  DBG_POLYGON

    xLsb2Org;
    yLsb2Org;

    lTmp = (LONG)x;
    ppfx->x = * (FIXED *) &lTmp;

    lTmp = (LONG)y;
    ppfx->y = * (FIXED *) &lTmp;

#else // true version

// for this to work the following assert must be true:

    ASSERTDD(sizeof(LONG) == sizeof(FIXED), "_Scale 16.16 \n");

    lTmp = (LONG) ((x - xLsb2Org) << 10);
    ppfx->x = * (FIXED *) &lTmp;

    lTmp = (LONG) ((y - yLsb2Org) << 10);
    ppfx->y = * (FIXED *) &lTmp;

#endif //  DBG_POLYGON
}


/******************************Public*Routine******************************\
*
* void Scale_28Dot4
*
*
* Effects: 26.6 -> 28.4
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* wrote it
\**************************************************************************/

void Scale_28DOT4 (POINTFX  *ppfx, F26Dot6 x, F26Dot6 y, int xLsb2Org, int yLsb2Org)
{
    LONG lTmp;

// for this to work the following assert must be true:

    ASSERTDD(sizeof(LONG) == sizeof(FIXED), "Scale, 28.4\n");

    lTmp = (LONG) ((x - xLsb2Org) >> 2);
    ppfx->x = * (FIXED *) &lTmp;

// note that the sign of y coordinate differs from the 16.16 case

    lTmp = - (LONG) ((y - yLsb2Org) >> 2);
    ppfx->y = * (FIXED *) &lTmp;
}


/******************************Public*Routine******************************\
*
* Scale_None
*
* Called when only the size of the ppoly buffer is wanted
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

void Scale_None (POINTFX *ppfx, F26Dot6 x, F26Dot6 y, int xLsb2Org, int yLsb2Org)
{
  ppfx;
  x;
  y;
  xLsb2Org;
  yLsb2Org;

  return;
}


/******************************Public*Routine******************************\
*
* cjFillPolygon
*
* Effects: fills in the array of structures that describe glyph's
*          outline. There is one polygonheader stuct for every closed contour
*          that composes the glyph. A polygon headed structure is followed
*          by an array of polycurve structure that describe composite curves
*          of a closed contour.
*
* Note: if pBuffer is NULL or cb is 0, then it is assumed that the caller
*       only wants the size of the buffer required.
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it. (stole it from JeanP's win31 code and addapted for NT)
\**************************************************************************/

UINT cjFillPolygon(
    PFONTCONTEXT pfc,
    BOOL         b16Dot16,  // FORMAT of the points, 16.16 or 28.4
    PBYTE        pBuffer,
    UINT         cb
    )
{
  BOOL            bGetLength = ( (pBuffer == (PBYTE)NULL) || (cb == 0) );
  uint16          nc = pfc->pgout->numberOfContours;
  uint8           *pbOnCurve = pfc->pgout->onCurve;
  int16           *sp = pfc->pgout->startPtr;
  int16           *ep = pfc->pgout->endPtr;
  F26Dot6         *x = pfc->pgout->xPtr;
  F26Dot6         *y = pfc->pgout->yPtr;
  BYTE            *pBuf = pBuffer;
  BYTE            *pStart = pBuf;
  BYTE            *pEnd = pStart + (bGetLength ? -1 : cb);
  TTPOLYGONHEADER *pPoly;
  TTPOLYCURVE     *pCurve;
  POINTFX         *ppfxStart;
  POINTFX         *pptfx;

  uint16      iContour;   //  index into a contour
  int16       iptEnd, cpt;
  int16       ipt = 0; // follows the points on the contour

  uint8        ucMask;
  void        (*Scale)(POINTFX *ppfx, F26Dot6 x, F26Dot6 y, int xlsb, int ylsb);

  int       xLsb2Org;
  int       yLsb2Org;

  if (!pfc->pgout->outlinesExist)
    return 0;

  if (!bGetLength) // we are actually filling in the information
  {

  #ifdef  DBG_POLYGON
    TtfdDbgPrint(" BEGIN NEW GLYPH \n\n");
    vDbgGridFit(pfc->pgout);
  #endif //  DBG_POLYGON

    if (b16Dot16)
    {
      Scale = Scale_16DOT16;
    }
    else  // scale to 28.4 format
    {
      Scale = Scale_28DOT4;
    }
  }
  else // just computing the size of the buffer needed to store the information
  {
    Scale = Scale_None;
  }

// Compute the delta between the referencial origin and dev left bearing

  cpt = (int16)(ep[nc - 1] + 1);  // total number of points in a contour

  xLsb2Org = x [cpt];  // LEFTSIDEBEARING == 0
  yLsb2Org = y [cpt];  // LEFTSIDEBEARING == 0

  for (iContour = 0; iContour < nc; iContour++)
  {
     // make sure that ipt points to the firts point on a contour upon entry
     // to the loop

    ipt    = sp [iContour];
    iptEnd = ep [iContour];

      // skip contour made of one point
    if (ipt == iptEnd)
    {
      continue; // go to the starting point of the next contour,
    }

    x = &pfc->pgout->xPtr[ipt];
    y = &pfc->pgout->yPtr[ipt];

    if (!bGetLength)
    {
      pPoly = (TTPOLYGONHEADER *) pBuf; //!!! dangerous, alignment [bodind]
      pPoly->dwType = TT_POLYGON_TYPE;
      ppfxStart = &pPoly->pfxStart;

    #ifdef  DBG_POLYGON
      TtfdDbgPrint("Begin Polygon\n\n");
    #endif //  DBG_POLYGON
    }

    pBuf += sizeof (TTPOLYGONHEADER);

      // The first point on the curve
    if (pbOnCurve[ipt] & 1)
    {
        //Easy case
      (*Scale) (ppfxStart, *x++, *y++, xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
      ++ipt;
    }
    else
    {
        // Is last contour point on the curve
      if (pbOnCurve[iptEnd] & 1)
      {
          //Make the last point the first point and decrement the last point
        (*Scale) (ppfxStart, x[iptEnd - ipt], y[iptEnd - ipt], xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
      }
      else
      {
          //First and last point are off the countour, fake a mid point
        (*Scale) (ppfxStart, (x[iptEnd - ipt] + *x) >> 1, (y[iptEnd - ipt] + *y) >> 1, xLsb2Org, yLsb2Org);
      }
    }

    while (ipt <= iptEnd)
    {
      pCurve = (TTPOLYCURVE *) pBuf;
      pptfx = pCurve->apfx;
      ucMask = (int8) (1 & (~pbOnCurve[ipt]));
      if (!bGetLength)
      {
          // if mid point not on the curve this is qspline, this is midpoint
          // because the starting point is in the previous record [bodind]
        pCurve->wType = (WORD)((ucMask == 0) ? TT_PRIM_LINE : TT_PRIM_QSPLINE);
      }
        // Set up the POLYCURVE
      while ((ipt <= iptEnd) && ((pbOnCurve[ipt] & 1) ^ ucMask))
      {
          // Check overflow
        if (pEnd < (BYTE *)(pptfx + 1))
          return FD_ERROR;

        (*Scale) (pptfx++, *x++, *y++, xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
        ipt++;
      }

      if (ucMask == 1) // if this curve is a qspline
      {
          // Check overflow
        if (pEnd < (BYTE *)(pptfx + 1))
          return FD_ERROR;

         // Set up the end point
        if (ipt <= iptEnd)
        {
          ASSERTDD(pbOnCurve[ipt] & 1, " end point not on the curve\n");
          (*Scale) (pptfx, *x++, *y++, xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
          ipt++;
        }
        else
        {
           // close the contour
          if (!bGetLength)
             *pptfx = *ppfxStart;
        }
        pptfx++;
      }
      if (!bGetLength)
      {
        pCurve->cpfx = (WORD)(pptfx - pCurve->apfx);
      #ifdef DBG_POLYGON
        vDbgCurve(pCurve);
      #endif // DBG_POLYGON
      }

      pBuf = (BYTE *) pptfx;
    }

    if (!bGetLength)
    {
      pPoly->cb = (DWORD) (pBuf - (BYTE *) pPoly);
      #ifdef DBG_POLYGON
        TtfdDbgPrint("\n end polygon, pPoly->cb = %ld\n\n", pPoly->cb);
      #endif // DBG_POLYGON
    }
  }
  #ifdef  DBG_POLYGON
    if (!bGetLength)
        TtfdDbgPrint("\n END NEW GLYPH \n\n");
  #endif //  DBG_POLYGON

  return (UINT) (pBuf - pStart);
}


/******************************Public*Routine******************************\
*
* lQuerySingularTrueTypeOutline
*
* Effects:
*
* Warnings:
*
* History:
*  22-Sep-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




LONG lQuerySingularTrueTypeOutline(
    PFONTCONTEXT pfc,            // IN
    BOOL         b16Dot16,       // IN  format of the points, 16.16 or 28.4
    HGLYPH       hglyph,         // IN  glyph for which info is wanted
    BOOL         bMetricsOnly,   // IN  only metrics is wanted, not the outline
    GLYPHDATA *   pgldt,         // OUT this is where the metrics should be returned
    ULONG        cjBuf,          // IN  size in bytes of the ppoly buffer
    TTPOLYGONHEADER * ppoly      // OUT output buffer
    )
{
    FS_ENTRY     iRet;
    ULONG        ig; // <--> hglyph

// hglyph is valid, either asking about the size for that particular
// glyph bitmap, or want the bitmap itself

    vCharacterCode(pfc->pff,hglyph,pfc->pgin);

// compute the glyph index from the character code:

    if ((iRet = fs_NewGlyph(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);
        RET_FALSE("TTFD!_lQuerySingularTrueTypeOutline, fs_NewGlyph\n");
    }

// return the glyph index corresponding to this hglyph:

    ig = pfc->pgout->glyphIndex;

// must call cjFillPolygon now since fsFindBitmapSize messes up outline
// data in pgout

// fill all of GLYPHDATA structure

    if (pgldt != (GLYPHDATA *)NULL)
    {
        vFillSingularGLYPHDATA(hglyph,ig,pfc,pgldt);
    }

// now check whether the caller is asking about the size of the buffer
// needed to store the array of POLYGONHEADER structures:

    return 0; // nothing written to the ppoly buffer
}


/******************************Public*Routine******************************\
*
* LONG lQueryTrueTypeOutline
*
*
* Effects:
*
* Warnings:
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG lQueryTTOutline(
    PFONTCONTEXT pfc,            // IN
    BOOL         b16Dot16,       // IN  format of the points, 16.16 or 28.4
    HGLYPH       hglyph,         // IN  glyph for which info is wanted
    BOOL         bMetricsOnly,   // IN  only metrics is wanted, not the outline
    BOOL         bUnhinted,      //     unhinted
    GLYPHDATA *   pgldt,          // OUT this is where the metrics should be returned
    ULONG        cjBuf,          // IN  size in bytes of the ppoly buffer
    TTPOLYGONHEADER * ppoly      // OUT output buffer
    )
{
    FS_ENTRY     iRet;
    LONG         cjRet;
    ULONG        ig = pfc->gstat.igLast;

// check if the rasterizer would behave unpolitely for this xform:

    if (pfc->flXform & XFORM_SINGULAR)
        return lQuerySingularTrueTypeOutline(
                    pfc,
                    b16Dot16,
                    hglyph,
                    bMetricsOnly,
                    pgldt,
                    cjBuf,
                    ppoly);

// check the last glyph processed to determine
// whether we have to register the glyph as new and compute its size

    if ((pfc->gstat.hgLast != hglyph) || bUnhinted || pfc->gstat.bOutlineIsMessed)
    {
        extern BOOL bGetGlyphOutline(FONTCONTEXT*,HGLYPH,ULONG*,FLONG,FS_ENTRY*);

        FLONG flOutline = bUnhinted ? FL_FORCE_UNHINTED : 0;

        // DO NOT skip grid fitting even if embedded bitmpas are found,
        // for we will be interested in outlines -+
        //                                        |
        //                                        |
        if ( !bGetGlyphOutline(pfc, hglyph , &ig, flOutline, &iRet) )
        {
            V_FSERROR(iRet);
            RETURN("lQueryTTOutline: bGetGlyphOutline failed\n", FD_ERROR);
        }
        pfc->gstat.bOutlineIsMessed = FALSE;
    }

// we know that at this point pfc->gstat.bOutlineIsMessed == FALSE

// must call cjFillPolygon now since fsFindBitmapSize messes up outline
// data in pgout

    if (!(bMetricsOnly & TTO_METRICS_ONLY))
    {
        if ((cjRet = cjFillPolygon(pfc, b16Dot16, (PBYTE)ppoly, cjBuf)) == FD_ERROR)
            RETURN("TTFD!_cjFillPolygon failed\n", FD_ERROR);

        if (cjRet && ppoly && pfc->bVertical && (pfc->ulControl & VERTICAL_MODE))
        {
            ULONG        igTemp = pfc->gstat.igLast;

            pfc->gstat.igLast = ig; 

            // vShiftOutlineInfo is using metrics that are computed in fs_FindBitMapSize

            pfc->gstat.bOutlineIsMessed = TRUE; // fs_FindBitMapSize might mess the outline by calling fsc_RemoveDups

            if ((iRet = fs_FindBitMapSize(pfc->pgin, pfc->pgout)) != NO_ERR)
            {
                EngSetLastError(ERROR_CAN_NOT_COMPLETE);
                V_FSERROR(iRet);
                RETURN("lQueryTTOutline: fs_FindBitMapSize failed\n", FD_ERROR);
            }

            vShiftOutlineInfo(pfc, b16Dot16, (PBYTE)ppoly, cjRet);
            pfc->gstat.igLast = igTemp;
        }
    }
    else // nothing will be written to ppoly buffer
    {
        cjRet = 0;
    }

// fill all of GLYPHDATA structure

    if (pgldt != (GLYPHDATA *)NULL)
    {
        // we only need to call fs_FindBitMapSize if GLYPHDATA is requested

        if (!pfc->gstat.bOutlineIsMessed)
        {
        // we haven't meesed the outline yet (ie called fs_FindBitMapSize for vertical writing vShiftOutlineInfo)
        // now is the time to do it
            pfc->gstat.bOutlineIsMessed = TRUE; // fs_FindBitMapSize might mess the outline by calling fsc_RemoveDups

            if ((iRet = fs_FindBitMapSize(pfc->pgin, pfc->pgout)) != NO_ERR)
            {
                EngSetLastError(ERROR_CAN_NOT_COMPLETE);
                V_FSERROR(iRet);
                RETURN("lQueryTTOutline: fs_FindBitMapSize failed\n", FD_ERROR);
            }
        }

        if ( pfc->bVertical && pfc->ulControl & VERTICAL_MODE )
        {
        // Vertical case
            fs_GlyphInfoType  my_gout;

            vShiftBitmapInfo( pfc, &my_gout, pfc->pgout );
            vFillGLYPHDATA(
                pfc->hgSave,         // this is a little bit tricky. we wouldn't like to
                ig,                  // tell GDI about vertical glyph index.
                pfc,
                &my_gout,
                pgldt,
                (PGMC)NULL, NULL);
        }
        else
        {
        // Normal case
            vFillGLYPHDATA(
                hglyph,
                ig,
                pfc,
                pfc->pgout,
                pgldt,
                (PGMC)NULL, NULL);
        }
    }

    // now that everything is computed sucessfully, we can update
    // glyphstate (hg data stored in pj3) and return

    if (!bUnhinted)
    {
        pfc->gstat.hgLast = hglyph;
        pfc->gstat.igLast = ig;
    }
    else
    {
        vInitGlyphState(&pfc->gstat);
    }

    return cjRet;
}


LONG lQueryTrueTypeOutlineVertical(
    PFONTCONTEXT pfc,            // IN
    BOOL         b16Dot16,       // IN  format of the points, 16.16 or 28.4
    HGLYPH       hglyph,         // IN  glyph for which info is wanted
    BOOL         bMetricsOnly,   // IN  only metrics is wanted, not the outline
    BOOL         bUnhinted,      // IN  hinted or unhinted outlines
    GLYPHDATA   *pgd,            // OUT this is where the metrics should be returned
    ULONG        cjBuf,          // IN  size in bytes of the ppoly buffer
    TTPOLYGONHEADER * ppoly      // OUT output buffer
    )
{
    LONG     cjGlyphData;

    if (!IsFullWidthCharacter (pfc->pff, hglyph))
    {
        return (lQueryTTOutline(pfc,
                                      b16Dot16,
                                      hglyph,
                                      bMetricsOnly,bUnhinted,
                                      pgd, cjBuf, ppoly ));
    }

    // change the transformation

    if (!bChangeXform( pfc, TRUE ) )
    {
        WARNING("TTFD!bChangeXform(TRUE) failed\n");
        return FD_ERROR;
    }

    // set vertical mode

    pfc->ulControl |= VERTICAL_MODE;

    pfc->hgSave = hglyph;

    // call ordinary function

    cjGlyphData = lQueryTTOutline(pfc,
                                        b16Dot16,
                                        hglyph,
                                        bMetricsOnly, bUnhinted,
                                        pgd, cjBuf, ppoly );


    // restore the transformation and return

    if ( ! bChangeXform( pfc, FALSE ) )
    {
        WARNING("TTFD!bChangeXform(FALSE) failed\n");
    }
    pfc->ulControl &= ~VERTICAL_MODE;
    return(cjGlyphData);
}




/******************************Public*Routine******************************\
*
* LONG ttfdQueryTrueTypeOutline
*
*
* Effects:
*
* Warnings:
*
* History:
*  12-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG ttfdQueryQuadTrueTypeOutline (
    FONTOBJ   *pfo,
    HGLYPH     hglyph,         // IN  glyph for which info is wanted
    BOOL       bMetricsOnly,   // IN  only metrics is wanted, not the outline
    GLYPHDATA *pgldt,          // OUT this is where the metrics should be returned
    ULONG      cjBuf,          // IN  size in bytes of the ppoly buffer
    TTPOLYGONHEADER * ppoly    // IN OUT  output buffer
    )
{
    FONTCONTEXT *pfc;
	USHORT usOverScale;
    BOOL     bUnhinted = (bMetricsOnly & TTO_UNHINTED) ? TRUE : FALSE;

    bMetricsOnly = (bMetricsOnly & ~TTO_UNHINTED);

    ASSERTDD(pfo->iFile, "ttfdQueryTrueTypeOutline, pfo->iFile\n");

    if (((TTC_FONTFILE *)pfo->iFile)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
        WARNING("ttfd, ttfdQueryTrueTypeOutline: file is gone\n");
        return FD_ERROR;
    }
//
// If pfo->pvProducer is NULL, then we need to open a font context.
//
    if ( pfo->pvProducer == (PVOID) NULL )
    {
        pfo->pvProducer = pfc = ttfdOpenFontContext(pfo);
    }
    else
    {
        pfc = (FONTCONTEXT*) pfo->pvProducer;
        pfc->flFontType = (pfc->flFontType & FO_CHOSE_DEPTH) | pfo->flFontType;
    }

    if ( pfc == (FONTCONTEXT *) NULL )
    {
        WARNING("gdisrv!ttfdQueryTrueTypeOutline(): cannot create font context\n");
        return FD_ERROR;
    }
    pfc->pfo = pfo;

// call fs_NewTransformation if needed:

// ClaudeBe 1/22/98 :
//
// for backwards compatibility, we always return the BW version of the outline
// (TrueType rasterizer 1.7 allow specific grayscale hinting)
//
// the code could be :
//
//	if (IS_GRAY(pfc))
//	{
//		usOverScale = 4;
//	}
//	else
//	{
//		usOverScale = 0;
//	}
//
// but then we would need to copy the outline from gout, before calling fs_FindBitmapSize
// to avoid getting an overscaled outline
// For the same reason we force bClearType to FALSE

    usOverScale = 0;

    if (!bGrabXform(
           pfc,
           usOverScale, // zero usOverScale, do not want overscaled outline
           FALSE,  // outline code path, no bitmap emboldening simulation
           FALSE   // outline code path, bClearType set to FALSE
           ))
        RETURN("gdisrv!ttfd  bGrabXform failed\n", FD_ERROR);

    if( pfc->bVertical )
    {
        return  lQueryTrueTypeOutlineVertical(pfc,
                                              TRUE, // b16Dot16 is true, this is the
                                                    //  desired format
                                              hglyph,
                                              bMetricsOnly, bUnhinted,
                                              pgldt,
                                              cjBuf,
                                              ppoly);
    }
    else
    {
        return  lQueryTTOutline(pfc,
                                      TRUE, // b16Dot16 is true, this is the desired
                                            // format
                                      hglyph,
                                      bMetricsOnly, bUnhinted,
                                      pgldt,
                                      cjBuf,
                                      ppoly);
    }
}



/******************************Public*Routine******************************\
*
*  now supports returning data in bezier format as well
*
* ttfdQueryTrueTypeOutline
*
* History:
*  24-Oct-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



LONG ttfdQueryTrueTypeOutline (
    FONTOBJ   *pfo,
    HGLYPH     hglyph,         // IN  glyph for which info is wanted
    BOOL       bMetricsOnly,   // IN  only metrics is wanted, not the outline
    GLYPHDATA *pgldt,          // OUT this is where the metrics should be returned
    ULONG      cjBuf,          // IN  size in bytes of the ppoly buffer
    TTPOLYGONHEADER * ppoly    // IN OUT  output buffer
    )
{

    LONG lRet = FD_ERROR;

    if (bMetricsOnly & TTO_QUBICS)
    {
    // in this case we have to get the quadratic data first:

        LONG cjBufQuad, cjBufQuad2;
        TTPOLYGONHEADER * ppolyQuad;

        cjBufQuad = ttfdQueryQuadTrueTypeOutline (pfo,
                                          hglyph,
                                          (bMetricsOnly & TTO_UNHINTED),
                                          pgldt,
                                          0,     // cjBufQuad
                                          NULL); // ppolyQuad

        if (cjBufQuad && (cjBufQuad != FD_ERROR))
        {
            if (ppolyQuad = (TTPOLYGONHEADER *)PV_ALLOC(cjBufQuad))
            {

                cjBufQuad2 = ttfdQueryQuadTrueTypeOutline (pfo,
                                          hglyph,
                                          (bMetricsOnly & TTO_UNHINTED),
                                          pgldt,
                                          cjBufQuad,  // cjBufQuad
                                          ppolyQuad); // ppolyQuad


                if (cjBufQuad2 && (cjBufQuad2 != FD_ERROR))
                {
                    ULONG cjBufBez;

                    ASSERTDD(cjBufQuad == cjBufQuad2, "ttfd, cjBufQuad != cjBufQuad2\n");
                    if (bGeneratePath(NULL, // ppo
                                      ppolyQuad,
                                      (ULONG)cjBufQuad,
                                      &cjBufBez,
                                      ppoly))
                    {
                        lRet = (LONG)cjBufBez;
                    }
                }

                V_FREE(ppolyQuad);
            }
        }
    }
    else
    {
        lRet = ttfdQueryQuadTrueTypeOutline (pfo,
                                             hglyph,
                                             bMetricsOnly,
                                             pgldt,
                                             cjBuf,
                                             ppoly);
    }

    return lRet;
}



/******************************Public*Routine******************************\
*
* ttfdQueryGlyphOutline
*
*
*
* History:
*  12-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL ttfdQueryGlyphOutline (
    FONTCONTEXT *pfc,
    HGLYPH       hglyph,
    GLYPHDATA   *pgldt,
    PATHOBJ     *ppo        // pointer to path to be built
    )
{
    LONG             cjAllPolygons, cjAllPolygons2;
    BOOL             bOk;

    if (ppo == NULL)
    {
    // if ppo == NULL, the caller wants metrics only:

        ASSERTDD(pgldt, "ttfdQueryGlyphOutline, pgldt NULL\n");

        if(pfc->bVertical)
        {
            cjAllPolygons =
              lQueryTrueTypeOutlineVertical
                (
                 pfc,              // lpMat2 is incorporated into this fc
                 FALSE,            // NOT 16.16 i.e. 28.4
                 hglyph,           // glyph for which info is wanted
                 TTO_METRICS_ONLY,             // DO just metrics, do NOT do outline
                 FALSE,            // hinted
                 pgldt,            // STORE the result here
                 0,                // size in bytes of the ppoly buffer
                 (TTPOLYGONHEADER *)NULL // do not need it
                );
        }
        else
        {
            cjAllPolygons =
              lQueryTTOutline
                (
                 pfc,              // lpMat2 is incorporated into this fc
                 FALSE,            // NOT 16.16 i.e. 28.4
                 hglyph,           // glyph for which info is wanted
                 TTO_METRICS_ONLY, // DO just metrics, do NOT do outline
                 FALSE,            // hinted
                 pgldt,            // STORE the result here
                 0,                // size in bytes of the ppoly buffer
                 (TTPOLYGONHEADER *)NULL // do not need it
                 );
        }

    // interpret the result, if zero for polygons, we succeded
    // glyph data was filled in and no polygon computation has been
    // performed.
    // if FD_ERROR we did not, no other result should be possible

        if (cjAllPolygons == 0)
            return TRUE;
        else
        {
            ASSERTDD(cjAllPolygons == FD_ERROR,
                     "ttfdQueryGlyphOutline, pgldt == NULL\n");
            return FALSE;
        }

    }

// first learn how big a buffer we need for all polygons:

    if( pfc->bVertical )
    {
        cjAllPolygons =
          lQueryTrueTypeOutlineVertical
            (
             pfc,              // lpMat2 is incorporated into this fc
             FALSE,            // NOT 16.16 i.e. 28.4
             hglyph,           // glyph for which info is wanted
             FALSE,            //  DO more than just metrics
             FALSE,            // hinted
             (GLYPHDATA *)NULL,// do not need glyphdata
             0,                // size in bytes of the ppoly buffer
             (TTPOLYGONHEADER *)NULL
             );
    }
    else
    {
        cjAllPolygons = lQueryTTOutline
          (
           pfc,              // lpMat2 is incorporated into this fc
           FALSE,            // NOT 16.16 i.e. 28.4
           hglyph,           // glyph for which info is wanted
           FALSE,            //  DO more than just metrics
           FALSE,            // hinted
           (GLYPHDATA *)NULL,// do not need glyphdata
           0,                // size in bytes of the ppoly buffer
           (TTPOLYGONHEADER *)NULL
           );
    }

    if (cjAllPolygons == FD_ERROR)
        RET_FALSE("TTFD! cjAllPolygons\n");

    if (cjAllPolygons != 0)
    {
        if ((pfc->gstat.pv = PV_ALLOC(cjAllPolygons)) == NULL)
        {
            RET_FALSE("TTFD_cjAllPolygons or ppoly\n");
        }
    }
    else
    {
        pfc->gstat.pv = NULL;
    }

// get all the polygons in the buffer we just allocated:

    if( pfc->bVertical )
    {
        cjAllPolygons2 = lQueryTrueTypeOutlineVertical
          (
           pfc,            // lpMat2 is incorporated into this fc
           FALSE,          // NOT 16.16 i.e. 28.4
           hglyph,         // glyph for which info is wanted
           FALSE,          //  DO more than just metrics
           FALSE,            // hinted
           pgldt,          // this is where the metrics should be returned
           cjAllPolygons,  // size in bytes of the ppoly buffer
           (TTPOLYGONHEADER *)pfc->gstat.pv
           );
    }
    else
    {
        cjAllPolygons2 = lQueryTTOutline
          (
           pfc,            // lpMat2 is incorporated into this fc
           FALSE,          // NOT 16.16 i.e. 28.4
           hglyph,         // glyph for which info is wanted
           FALSE,          //  DO more than just metrics
           FALSE,            // hinted
           pgldt,          // this is where the metrics should be returned
           cjAllPolygons,  // size in bytes of the ppoly buffer
           (TTPOLYGONHEADER *)pfc->gstat.pv
           );
    }

    if (cjAllPolygons2 == FD_ERROR)
    {
        if (pfc->gstat.pv)
        {
            V_FREE(pfc->gstat.pv);
            pfc->gstat.pv = NULL;
        }
        RET_FALSE("TTFD_ QueryTrueTypeOutline failed\n");
    }

    ASSERTDD(cjAllPolygons == cjAllPolygons2,
              "cjAllPolygons PROBLEM\n");

// now that we have all the info in ppoly buffer we can generate the path

    bOk = bGeneratePath(
            (PATHOBJ *)ppo,
            (TTPOLYGONHEADER *)pfc->gstat.pv,
            cjAllPolygons, NULL, NULL
            );

    if (pfc->gstat.pv)
    {
        V_FREE(pfc->gstat.pv);
        pfc->gstat.pv = NULL;
    }

    return (bOk);
}


/******************************Public*Routine******************************\
*
* bGeneratePath
*
* Effects: Adds control points of the glyph to the gluph path
*
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

// macro that computes the size of the polycurve record:

#define CJ_CRV(pcrv)                                            \
(                                                               \
    offsetof(TTPOLYCURVE,apfx) + (pcrv)->cpfx * sizeof(POINTFX) \
)

#define CJ_BEZCRV(cBezPts)                                       \
(                                                                \
    offsetof(TTPOLYCURVE,apfx) + (cBezPts) * sizeof(POINTFX)     \
)


// reasonable guess that in most cases a contour will not consist of more
// than this many beziers

#define C_BEZIER 6


BOOL bGeneratePath(
    PATHOBJ         * ppo,        // IN OUT pointer to the path object to be generated
    TTPOLYGONHEADER * ppolyStart, // IN OUT pointer to the buffer with outline data
    ULONG             cjTotal,    // IN     size of the buffer
    ULONG           * pcjOut,      // OUT   size of needed bezier buffer
    TTPOLYGONHEADER * ppolyBeziers // OUT   buffer with Bezier outline data
    )
{
    TTPOLYGONHEADER * ppoly, * ppolyEnd, *ppolyBez;
    TTPOLYCURVE     * pcrv, * pcrvEnd, *pcrvBez;
    POINTFIX          aptfixBez[3 * C_BEZIER];  // 3 points per bezier
    POINTFIX        * pptfixBez;
    ULONG             cBez;
    POINTFIX        * pptfixStart;
    ULONG             cjPolyBez = 0;
    ULONG             cjCrv, cjCrvBez;

    if (pcjOut)
        *pcjOut = 0; // to begin with

    // The code is no problem with NULL.
    ppolyBez = NULL;
    
    if (ppolyBeziers)
        ppolyBez = ppolyBeziers;

    for (
         ppoly = ppolyStart, ppolyEnd = (TTPOLYGONHEADER *)((PBYTE)ppolyStart + cjTotal);
         ppoly < ppolyEnd;
         ppoly = (TTPOLYGONHEADER *)((PBYTE)ppoly + ppoly->cb),
         ppolyBez = (TTPOLYGONHEADER *)((PBYTE)ppolyBez + cjPolyBez)
        )
    {
        ASSERTDD(ppoly->dwType == TT_POLYGON_TYPE, "TT_POLYGON_TYPE\n");

    // begin new closed contour

        if (ppo && !PATHOBJ_bMoveTo(ppo, *(POINTFIX *)&ppoly->pfxStart))
            RET_FALSE("TTFD!_PATHOBJ_bMoveTo failed\n");

    // init a loop over curves


        pptfixStart = (POINTFIX *)&ppoly->pfxStart;
        pcrvEnd = (TTPOLYCURVE *)((PBYTE)ppoly + ppoly->cb);

        for (
             pcrv = (TTPOLYCURVE *)(ppoly + 1),
             pcrvBez = (TTPOLYCURVE *)(ppolyBez + 1),
             cjPolyBez = sizeof(TTPOLYGONHEADER);
             pcrv < pcrvEnd;
             pcrv = (TTPOLYCURVE *)((PBYTE)pcrv + cjCrv),
             pcrvBez = (TTPOLYCURVE *)((PBYTE)pcrvBez + cjCrvBez),
             cjPolyBez += cjCrvBez
            )
        {
        // must compute the size of this curve first

            cjCrv = CJ_CRV(pcrv);

            if (pcrv->wType == TT_PRIM_LINE)
            {
                if (ppo && !PATHOBJ_bPolyLineTo(ppo,(POINTFIX *)pcrv->apfx, pcrv->cpfx))
                    RET_FALSE("TTFD!_bPolyLineTo()\n");

                cjCrvBez = cjCrv;

            // in the case of poly lines, we just copy the data out

                if (ppolyBeziers)
                    RtlCopyMemory(pcrvBez, pcrv, cjCrv);
            }
            else // qspline
            {
                BOOL bOk;
                ULONG cBezPts;

                ASSERTDD(pcrv->wType == TT_PRIM_QSPLINE, "TT_PRIM_QSPLINE\n");
                ASSERTDD(pcrv->cpfx > 1, "_TT_PRIM_QSPLINE, cpfx <= 1\n");
                cBez = pcrv->cpfx - 1;
                cBezPts = 3 * cBez;

                if (cBez > C_BEZIER) // must allocate buffer for the bezier points
                {
                    if ((pptfixBez = (POINTFIX *)PV_ALLOC(cBezPts * sizeof(POINTFIX))) == (POINTFIX *)NULL)
                    {
                        return (FALSE);
                    }
                }
                else // enough memory on the stack
                {
                    pptfixBez = aptfixBez;
                }

                vQsplineToPolyBezier (
                    cBez,                     // count of curves to convert to beziers format
                    pptfixStart,              // starting point on the first curve
                    (POINTFIX *)pcrv->apfx,   // array of (cBez+1) points that, together with the starting point *pptfixStart define the spline
                    pptfixBez);               // buffer to be filled with 3 * cBez poly bezier control points

                bOk = !ppo || PATHOBJ_bPolyBezierTo(ppo, pptfixBez, cBezPts);

            // compute the size of the corresponding bezier curve

                cjCrvBez = CJ_BEZCRV(cBezPts);

            // may need to fill bezier data out

                if (ppolyBeziers)
                {
                    pcrvBez->wType = TT_PRIM_CSPLINE;
                    pcrvBez->cpfx  = (WORD) cBezPts;
                    RtlCopyMemory(pcrvBez->apfx, pptfixBez,
                                  cBezPts * sizeof(POINTFIX));
                }

            // free mem if needed

                if (cBez > C_BEZIER)
                    V_FREE(pptfixBez);

                if (!bOk)
                    RET_FALSE("TTFD!_bPolyBezierTo() failed\n");
            }

        // get to the next curve in this polygon

            pptfixStart = (POINTFIX *) &pcrv->apfx[pcrv->cpfx - 1];
        }
        ASSERTDD(pcrv == pcrvEnd, "pcrv problem\n");

    // close the path

        if (ppo && (!PATHOBJ_bPolyLineTo(ppo, (POINTFIX *)&ppoly->pfxStart, 1) ||
            !PATHOBJ_bCloseFigure(ppo)))
            RET_FALSE("TTFD!_bPolyLineTo()\n");

    // add the size of the bezier polygon to the total bezier buffer size

        if (pcjOut)
            *pcjOut += cjPolyBez;

    // write polygon header to the out buffer

        if (ppolyBeziers)
        {
            ppolyBez->dwType = TT_POLYGON_TYPE;
            ppolyBez->cb = cjPolyBez;
            ppolyBez->pfxStart = ppoly->pfxStart;
        }
    }                                             // loop over polygons

    ASSERTDD(ppoly == ppolyEnd, "poly problem\n");
    return (TRUE);
}


/******************************Public*Routine******************************\
*
*    vQsplineToPolyBezier
*
* Effects:
*
* Warnings:
*
* History:
*  20-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#define DIV_BY_2(x) (((x) + 0x00000001) / 2)
#define DIV_BY_3(x) (((x) + 0x00000002) / 3)

STATIC VOID vQsplineToPolyBezier(
    ULONG      cBez,          //IN  count of curves to convert to beziers format
    POINTFIX * pptfixStart,   //IN  starting point on the first curve
    POINTFIX * pptfixSpline,  //IN  array of (cBez+1) points that, together with the starting point *pptfixStart define the spline
    POINTFIX * pptfixBez      //OUT buffer to be filled with 3 * cBez poly bezier control points
    )
{
    ULONG    iBez,cMidBez;
    POINTFIX ptfixA;

// cMidBez == # of beziers for whom the last point on the bezier is computed
// as a mid point of the two consecutive points in the input array. Only the
// last bezier is not a mid bezier, the last point for that bezier is equal
// to the last point in the input array

    ASSERTDD(cBez > 0, "cBez == 0\n");

    cMidBez = cBez - 1;
    ptfixA = *pptfixStart;

    for (iBez = 0; iBez < cMidBez; iBez++, pptfixSpline++)
    {
    // let us call the three spline points
    // A,B,C;
    // B = *pptfix;
    // C = (pptfix[0] + pptfix[1]) / 2; // mid point, unless at the end
    //
    // if we decide to call the two intermediate control points for the
    // bezier M,N (i.e. full set of control points for the bezier is
    // A,M,N,C), the points M,N are determined by following formulas:
    //
    // M = (2*B + A) / 3  ; two thirds along the segment AB
    // N = (2*B + C) / 3  ; two thirds along the segment CB
    //
    // this is the computation we are doing in this loop:

    // M point for this bezier

        pptfixBez->x = DIV_BY_3((pptfixSpline->x * 2) + ptfixA.x);
        pptfixBez->y = DIV_BY_3((pptfixSpline->y * 2) + ptfixA.y);
        pptfixBez++;

    // compute C point for this bezier, which is also the A point for the next
    // bezier

        ptfixA.x = DIV_BY_2(pptfixSpline[0].x + pptfixSpline[1].x);
        ptfixA.y = DIV_BY_2(pptfixSpline[0].y + pptfixSpline[1].y);

    // now compute N point for this bezier:

        pptfixBez->x = DIV_BY_3((pptfixSpline->x * 2) + ptfixA.x);
        pptfixBez->y = DIV_BY_3((pptfixSpline->y * 2) + ptfixA.y);
        pptfixBez++;

    // finally record the C point for this curve

        *pptfixBez++ = ptfixA;
    }

// finally do the last bezier. If the last bezier is the only one, the loop
// above has been skipped

// M point for this bezier

    pptfixBez->x = DIV_BY_3((pptfixSpline->x * 2) + ptfixA.x);
    pptfixBez->y = DIV_BY_3((pptfixSpline->y * 2) + ptfixA.y);
    pptfixBez++;

// compute C point for this bezier, its end point is the last point
// in the input array

    ptfixA = pptfixSpline[1];

// now compute N point for this bezier:

    pptfixBez->x = DIV_BY_3((pptfixSpline->x * 2) + ptfixA.x);
    pptfixBez->y = DIV_BY_3((pptfixSpline->y * 2) + ptfixA.y);
    pptfixBez++;

// finally record the C point for this curve, no need to increment pptfixBez

    *pptfixBez = ptfixA;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\ttfd\fdsem.h ===
/******************************Module*Header*******************************\
* Module Name: fdsem.h
*
* declarations for the wrappers that serialize access to the rasterizer
*
* Created: 11-Apr-1992 19:37:49
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/


// EXPORTED FUNCTIONS OF THE IFI INTERFACE


HFF
ttfdSemLoadFontFile (
    ULONG cFiles,
    ULONG_PTR *piFile,
    PVOID *ppvView,
    ULONG *pcjView,
    DESIGNVECTOR *pdv,
    ULONG ulLangId,
    ULONG ulFastCheckSum
    );

BOOL
ttfdSemUnloadFontFile (
    HFF hff
    );

LONG
ttfdSemQueryFontData (
    DHPDEV  dhpdev,
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH   hg,
    GLYPHDATA *pgd,
    PVOID   pv,
    ULONG   cjSize
    );

VOID
ttfdSemFree (
    PVOID pv,
    ULONG_PTR id
    );

VOID
ttfdSemDestroyFont (
    FONTOBJ *pfo
    );

LONG
ttfdSemQueryTrueTypeOutline (
    DHPDEV     dhpdev,
    FONTOBJ   *pfo,
    HGLYPH     hglyph,
    BOOL       bMetricsOnly,
    GLYPHDATA *pgldt,
    ULONG      cjBuf,
    TTPOLYGONHEADER *ppoly
    );



BOOL
ttfdSemQueryAdvanceWidths (
    DHPDEV   dhpdev,
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    LONG    *plWidths,
    ULONG    cGlyphs
    );


LONG
ttfdSemQueryTrueTypeTable (
    HFF     hff,
    ULONG   ulFont,  // always 1 for version 1.0 of tt
    ULONG   ulTag,   // tag identifying the tt table
    PTRDIFF dpStart, // offset into the table
    ULONG   cjBuf,   // size of the buffer to retrieve the table into
    PBYTE   pjBuf,   // ptr to buffer into which to return the data
    PBYTE  *ppjTable,
    ULONG  *pcjTable
    );

PFD_GLYPHATTR  ttfdSemQueryGlyphAttrs (FONTOBJ *pfo, ULONG iMode);

PVOID ttfdSemQueryFontTree (
    DHPDEV  dhpdev,
    HFF     hff,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR *pid
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\ttfd\fontfile.c ===
/******************************Module*Header*******************************\
* Module Name: fontfile.c                                                  *
*                                                                          *
* "Methods" for operating on FONTCONTEXT and FONTFILE objects              *
*                                                                          *
* Created: 18-Nov-1990 15:23:10                                            *
* Author: Bodin Dresevic [BodinD]                                          *
*                                                                          *
* Copyright (c) 1993 Microsoft Corporation                                 *
\**************************************************************************/

#include "fd.h"
#include "fdsem.h"


#define C_ANSI_CHAR_MAX 256

HSEMAPHORE ghsemTTFD;

// The driver function table with all function index/address pairs


DRVFN gadrvfnTTFD[] =
{
    {   INDEX_DrvEnablePDEV,            (PFN) ttfdEnablePDEV             },
    {   INDEX_DrvDisablePDEV,           (PFN) ttfdDisablePDEV            },
    {   INDEX_DrvCompletePDEV,          (PFN) ttfdCompletePDEV           },
    {   INDEX_DrvQueryFont,             (PFN) ttfdQueryFont              },
    {   INDEX_DrvQueryFontTree,         (PFN) ttfdSemQueryFontTree       },
    {   INDEX_DrvQueryFontData,         (PFN) ttfdSemQueryFontData       },
    {   INDEX_DrvDestroyFont,           (PFN) ttfdSemDestroyFont         },
    {   INDEX_DrvQueryFontCaps,         (PFN) ttfdQueryFontCaps          },
    {   INDEX_DrvLoadFontFile,          (PFN) ttfdSemLoadFontFile        },
    {   INDEX_DrvUnloadFontFile,        (PFN) ttfdSemUnloadFontFile      },
    {   INDEX_DrvQueryFontFile,         (PFN) ttfdQueryFontFile          },
    {   INDEX_DrvQueryGlyphAttrs,       (PFN) ttfdSemQueryGlyphAttrs     },
    {   INDEX_DrvQueryAdvanceWidths,    (PFN) ttfdSemQueryAdvanceWidths  },
    {   INDEX_DrvFree,                  (PFN) ttfdSemFree                },
    {   INDEX_DrvQueryTrueTypeTable,    (PFN) ttfdSemQueryTrueTypeTable  },
    {   INDEX_DrvQueryTrueTypeOutline,  (PFN) ttfdSemQueryTrueTypeOutline},
    {   INDEX_DrvGetTrueTypeFile,       (PFN) ttfdGetTrueTypeFile        }
};





/******************************Public*Routine******************************\
* ttfdEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
*  Sun 25-Apr-1993 -by- Patrick Ha1luptzok [patrickh]
* Change to be same as DDI Enable.
*
* History:
*  12-Dec-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL ttfdEnableDriver(
ULONG iEngineVersion,
ULONG cj,
PDRVENABLEDATA pded)
{
// Engine Version is passed down so future drivers can support previous
// engine versions.  A next generation driver can support both the old
// and new engine conventions if told what version of engine it is
// working with.  For the first version the driver does nothing with it.

    iEngineVersion;

    if ((ghsemTTFD = EngCreateSemaphore()) == (HSEMAPHORE) 0)
    {
        return(FALSE);
    }

    pded->pdrvfn = gadrvfnTTFD;
    pded->c = sizeof(gadrvfnTTFD) / sizeof(DRVFN);
    pded->iDriverVersion = DDI_DRIVER_VERSION_NT5;

// init global data:

    return(TRUE);
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI
*
\**************************************************************************/

DHPDEV
ttfdEnablePDEV(
    DEVMODEW*   pdm,
    PWSTR       pwszLogAddr,
    ULONG       cPat,
    HSURF*      phsurfPatterns,
    ULONG       cjCaps,
    ULONG*      pdevcaps,
    ULONG       cjDevInfo,
    DEVINFO*    pdi,
    HDEV        hdev,
    PWSTR       pwszDeviceName,
    HANDLE      hDriver)
{

    PVOID*   ppdev;

    //
    // Allocate a four byte PDEV for now
    // We can grow it if we ever need to put information in it.
    //

    ppdev = (PVOID*) EngAllocMem(0, sizeof(PVOID), 'dftT');

    return ((DHPDEV) ppdev);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
\**************************************************************************/

VOID
ttfdDisablePDEV(
    DHPDEV  dhpdev)
{
    EngFreeMem(dhpdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID
ttfdCompletePDEV(
    DHPDEV dhpdev,
    HDEV   hdev)
{
    return;
}



/******************************Public*Routine******************************\
*
* VOID vInitGlyphState(PGLYPHSTAT pgstat)
*
* Effects: resets the state of the new glyph
*
* History:
*  22-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vInitGlyphState(PGLYPHSTATUS pgstat)
{
    pgstat->hgLast  = HGLYPH_INVALID;
    pgstat->igLast  = 0xffffffff;
    pgstat->bOutlineIsMessed = TRUE;
}



VOID vMarkFontGone(TTC_FONTFILE *pff, DWORD iExceptionCode)
{
    ULONG i;

    ASSERTDD(pff, "ttfd!vMarkFontGone, pff\n");

// this font has disappeared, probably net failure or somebody pulled the
// floppy with ttf file out of the floppy drive

    if (iExceptionCode == STATUS_IN_PAGE_ERROR) // file disappeared
    {
    // prevent any further queries about this font:

        pff->fl |= FF_EXCEPTION_IN_PAGE_ERROR;

        for( i = 0; i < pff->ulNumEntry ; i++ )
        {
            PFONTFILE pffReal;

        // get real pff.

            pffReal = PFF(pff->ahffEntry[i].hff);

        // if memoryBases 0,3,4 were allocated free the memory,
        // for they are not going to be used any more

            if (pffReal->pj034)
            {
                V_FREE(pffReal->pj034);
                pffReal->pj034 = NULL;
            }

        // if memory for font context was allocated and exception occured
        // after allocation but before completion of ttfdOpenFontContext,
        // we have to free it:

            if (pffReal->pfcToBeFreed)
            {
                V_FREE(pffReal->pfcToBeFreed);
                pffReal->pfcToBeFreed = NULL;
            }
        }
    }

    if (iExceptionCode == STATUS_ACCESS_VIOLATION)
    {
        RIP("TTFD!this is probably a buggy ttf file\n");
    }
}

/**************************************************************************\
*
* These are semaphore grabbing wrapper functions for TT driver entry
* points that need protection.
*
*  Mon 29-Mar-1993 -by- Bodin Dresevic [BodinD]
* update: added try/except wrappers
*
*   !!! should we also do some unmap file clean up in case of exception?
*   !!! what are the resources to be freed in this case?
*   !!! I would think,if av files should be unmapped, if in_page exception
*   !!! nothing should be done
*
 *
\**************************************************************************/

HFF
ttfdSemLoadFontFile (
    ULONG cFiles,
    ULONG_PTR *piFile,
    PVOID *ppvView,
    ULONG *pcjView,
    DESIGNVECTOR *pdv,
    ULONG ulLangId,
    ULONG ulFastCheckSum
    )
{
    HFF   hff = (HFF)NULL;
    ULONG_PTR iFile;
    PVOID pvView;
    ULONG cjView;

    if ((cFiles != 1) || pdv)
        return hff;

    iFile  = *piFile;
    pvView = *ppvView;
    cjView = *pcjView;

    EngAcquireSemaphore(ghsemTTFD);

    try
    {
        BOOL     bRet = FALSE;

        bRet = bLoadFontFile(iFile,
                             pvView,
                             cjView,
                             ulLangId,
                             ulFastCheckSum,
                             &hff
                             );

        if (!bRet)
        {
            ASSERTDD(hff == (HFF)NULL, "LoadFontFile, hff not null\n");
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("TTFD!_ exception in ttfdLoadFontFile\n");

        ASSERTDD(GetExceptionCode() == STATUS_IN_PAGE_ERROR,
                  "ttfdSemLoadFontFile, strange exception code\n");

        if (hff)
        {
            ttfdUnloadFontFileTTC(hff);
            hff = (HFF)NULL;
        }
    }

    EngReleaseSemaphore(ghsemTTFD);
    return hff;
}

BOOL
ttfdSemUnloadFontFile (
    HFF hff
    )
{
    BOOL bRet;
    EngAcquireSemaphore(ghsemTTFD);

    try
    {
        bRet = ttfdUnloadFontFileTTC(hff);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("TTFD!_ exception in ttfdUnloadFontFile\n");
        bRet = FALSE;
    }

    EngReleaseSemaphore(ghsemTTFD);
    return bRet;
}

BOOL bttfdMapFontFileFD(PTTC_FONTFILE pttc)
{
    return (pttc ? (EngMapFontFileFD(PFF(pttc->ahffEntry[0].hff)->iFile,
                                     (PULONG*)&pttc->pvView,
                                     &pttc->cjView))
                 : FALSE);
}


PFD_GLYPHATTR  ttfdSemQueryGlyphAttrs (FONTOBJ *pfo, ULONG iMode)
{

    PFD_GLYPHATTR pRet = NULL;

    if (iMode == FO_ATTR_MODE_ROTATE)
    {
        if (!(pRet = PTTC(pfo->iFile)->pga) &&
            bttfdMapFontFileFD((PTTC_FONTFILE)pfo->iFile))
        {
            EngAcquireSemaphore(ghsemTTFD);
        
            try
            {
                pRet = ttfdQueryGlyphAttrs(pfo, iMode);
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                WARNING("TTFD!_ exception in ttfdQueryGlyphAttrs\n");
            
                vMarkFontGone((TTC_FONTFILE *)pfo->iFile, GetExceptionCode());
            }
        
            EngReleaseSemaphore(ghsemTTFD);
    
            EngUnmapFontFileFD(PFF(PTTC(pfo->iFile)->ahffEntry[0].hff)->iFile);
        }
    }

    return pRet;
}



LONG
ttfdSemQueryFontData (
    DHPDEV  dhpdev,
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH  hg,
    GLYPHDATA *pgd,
    PVOID   pv,
    ULONG   cjSize
    )
{
    LONG lRet = FD_ERROR;

    dhpdev;

    if (bttfdMapFontFileFD((TTC_FONTFILE *)pfo->iFile))
    {
        EngAcquireSemaphore(ghsemTTFD);
    
        try
        {
            lRet = ttfdQueryFontData (
                       pfo,
                       iMode,
                       hg,
                       pgd,
                       pv,
                       cjSize
                       );
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("TTFD!_ exception in ttfdQueryFontData\n");
    
            vMarkFontGone((TTC_FONTFILE *)pfo->iFile, GetExceptionCode());
        }
        
        EngReleaseSemaphore(ghsemTTFD);

        EngUnmapFontFileFD(PFF(PTTC(pfo->iFile)->ahffEntry[0].hff)->iFile);
    }
    return lRet;
}


VOID
ttfdSemFree (
    PVOID pv,
    ULONG_PTR id
    )
{
    EngAcquireSemaphore(ghsemTTFD);

    ttfdFree (
        pv,
        id
        );

    EngReleaseSemaphore(ghsemTTFD);
}


VOID
ttfdSemDestroyFont (
    FONTOBJ *pfo
    )
{
    EngAcquireSemaphore(ghsemTTFD);

    ttfdDestroyFont (
        pfo
        );

    EngReleaseSemaphore(ghsemTTFD);
}


LONG
ttfdSemQueryTrueTypeOutline (
    DHPDEV     dhpdev,
    FONTOBJ   *pfo,
    HGLYPH     hglyph,
    BOOL       bMetricsOnly,
    GLYPHDATA *pgldt,
    ULONG      cjBuf,
    TTPOLYGONHEADER *ppoly
    )
{
    LONG lRet = FD_ERROR;

    dhpdev;

    if (bttfdMapFontFileFD((TTC_FONTFILE *)pfo->iFile))
    {
        EngAcquireSemaphore(ghsemTTFD);
    
        try
        {
             lRet = ttfdQueryTrueTypeOutline (
                        pfo,
                        hglyph,
                        bMetricsOnly,
                        pgldt,
                        cjBuf,
                        ppoly
                        );
    
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("TTFD!_ exception in ttfdQueryTrueTypeOutline\n");
    
            vMarkFontGone((TTC_FONTFILE *)pfo->iFile, GetExceptionCode());
        }
    
        EngReleaseSemaphore(ghsemTTFD);

        EngUnmapFontFileFD(PFF(PTTC(pfo->iFile)->ahffEntry[0].hff)->iFile);
    }
    return lRet;
}




/******************************Public*Routine******************************\
* BOOL ttfdQueryAdvanceWidths
*
* History:
*  29-Jan-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL ttfdSemQueryAdvanceWidths
(
    DHPDEV   dhpdev,
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    LONG    *plWidths,
    ULONG    cGlyphs
)
{
    BOOL               bRet = FD_ERROR;

    dhpdev;

    if (bttfdMapFontFileFD((TTC_FONTFILE *)pfo->iFile))
    {
        EngAcquireSemaphore(ghsemTTFD);
    
        try
        {
            bRet = bQueryAdvanceWidths (
                       pfo,
                       iMode,
                       phg,
                       plWidths,
                       cGlyphs
                       );
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("TTFD!_ exception in bQueryAdvanceWidths\n");
    
            vMarkFontGone((TTC_FONTFILE *)pfo->iFile, GetExceptionCode());
        }
    
        EngReleaseSemaphore(ghsemTTFD);

        EngUnmapFontFileFD(PFF(PTTC(pfo->iFile)->ahffEntry[0].hff)->iFile);
    }
    return bRet;
}



LONG
ttfdSemQueryTrueTypeTable (
    HFF     hff,
    ULONG   ulFont,  // always 1 for version 1.0 of tt
    ULONG   ulTag,   // tag identifying the tt table
    PTRDIFF dpStart, // offset into the table
    ULONG   cjBuf,   // size of the buffer to retrieve the table into
    PBYTE   pjBuf,   // ptr to buffer into which to return the data
    PBYTE  *ppjTable,// ptr to table in mapped font file
    ULONG  *pcjTable // size of the whole table in the file
    )
{
    LONG lRet;
    lRet = FD_ERROR;

    if (bttfdMapFontFileFD((TTC_FONTFILE *)hff))
    {
        EngAcquireSemaphore(ghsemTTFD);
    
        try
        {
            lRet = ttfdQueryTrueTypeTable (
                        hff,
                        ulFont,  // always 1 for version 1.0 of tt
                        ulTag,   // tag identifying the tt table
                        dpStart, // offset into the table
                        cjBuf,   // size of the buffer to retrieve the table into
                        pjBuf,   // ptr to buffer into which to return the data
                        ppjTable,
                        pcjTable
                        );
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("TTFD!_ exception in ttfdQueryTrueTypeTable\n");
            vMarkFontGone((TTC_FONTFILE *)hff, GetExceptionCode());
        }
    
        EngReleaseSemaphore(ghsemTTFD);

        EngUnmapFontFileFD(PFF(PTTC(hff)->ahffEntry[0].hff)->iFile);
    }

    return lRet;
}



FD_GLYPHSET *pgsetComputeSymbolCP()
{
    WCHAR awc[C_ANSI_CHAR_MAX];
    BYTE  aj[C_ANSI_CHAR_MAX];
    ULONG cjSymbolCP;

    PFD_GLYPHSET pgsetCurrentCP;
    PFD_GLYPHSET pgsetSymbolCP  = NULL; // current code page + symbol area


// pgsetCurrentCP contains the unicode runs for the current ansi code page
// It is going to be used for fonts with PlatformID for Mac, but for which
// we have determined that we are going to cheat and pretend that the code
// page is NOT mac but windows code page. Those are the fonts identified
// by bCvtUnToMac = FALSE

    pgsetCurrentCP = EngComputeGlyphSet(0,0,256);

    if (pgsetCurrentCP)
    {
    // for symbol fonts we report both the current code page plus
    // the range 0xf000-0xf0ff.

        INT cRuns = (INT)pgsetCurrentCP->cRuns;

        cjSymbolCP  = SZ_GLYPHSET(cRuns + 1, 2 * C_ANSI_CHAR_MAX - 32);


        pgsetSymbolCP = (FD_GLYPHSET *)PV_ALLOC(cjSymbolCP);

        if (pgsetSymbolCP)
        {
        // now use pgsetCurrentCP to manufacture symbol character set:

            pgsetSymbolCP->cjThis = cjSymbolCP;
            pgsetSymbolCP->flAccel = GS_16BIT_HANDLES;

            pgsetSymbolCP->cGlyphsSupported = 2 * C_ANSI_CHAR_MAX - 32;
            pgsetSymbolCP->cRuns = cRuns + 1;

            {
                INT iRun, ihg;
                HGLYPH *phgS, *phgD;

                phgD = (HGLYPH *)&pgsetSymbolCP->awcrun[cRuns+1];
                for
                (
                    iRun = 0;
                    (iRun < cRuns) && (pgsetCurrentCP->awcrun[iRun].wcLow < 0xf000);
                    iRun++
                )
                {
                    pgsetSymbolCP->awcrun[iRun].wcLow =
                        pgsetCurrentCP->awcrun[iRun].wcLow;
                    pgsetSymbolCP->awcrun[iRun].cGlyphs =
                        pgsetCurrentCP->awcrun[iRun].cGlyphs;
                    pgsetSymbolCP->awcrun[iRun].phg = phgD;
                    RtlCopyMemory(
                        phgD,
                        pgsetCurrentCP->awcrun[iRun].phg,
                        sizeof(HGLYPH) * pgsetCurrentCP->awcrun[iRun].cGlyphs
                        );
                    phgD += pgsetCurrentCP->awcrun[iRun].cGlyphs;
                }

            // now insert the user defined area:

                pgsetSymbolCP->awcrun[iRun].wcLow   = 0xf020;
                pgsetSymbolCP->awcrun[iRun].cGlyphs = C_ANSI_CHAR_MAX - 32;
                pgsetSymbolCP->awcrun[iRun].phg = phgD;
                for (ihg = 32; ihg < C_ANSI_CHAR_MAX; ihg++)
                    *phgD++ = ihg;

            // and now add the remaining ranges if any from the current code page:

                for ( ; iRun < cRuns; iRun++)
                {
                    pgsetSymbolCP->awcrun[iRun+1].wcLow =
                        pgsetCurrentCP->awcrun[iRun].wcLow;
                    pgsetSymbolCP->awcrun[iRun+1].cGlyphs =
                        pgsetCurrentCP->awcrun[iRun].cGlyphs;
                    pgsetSymbolCP->awcrun[iRun+1].phg = phgD;

                    RtlCopyMemory(
                        phgD,
                        pgsetCurrentCP->awcrun[iRun].phg,
                        sizeof(HGLYPH) * pgsetCurrentCP->awcrun[iRun].cGlyphs
                        );
                    phgD += pgsetCurrentCP->awcrun[iRun].cGlyphs;
                }
            }

        }

        V_FREE(pgsetCurrentCP);
    }

    return pgsetSymbolCP;

}


PVOID ttfdSemQueryFontTree (
    DHPDEV  dhpdev,
    HFF     hff,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR *pid
)
{
    PVOID   pRet = NULL;

    if (bttfdMapFontFileFD(PTTC(hff)))
    {
        EngAcquireSemaphore(ghsemTTFD);

        pRet = ttfdQueryFontTree (
                    dhpdev,
                    hff,
                    iFace,
                    iMode,
                    pid
                    );

        EngReleaseSemaphore(ghsemTTFD);

        EngUnmapFontFileFD(PFF(PTTC(hff)->ahffEntry[0].hff)->iFile);
    }

    return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\ttfd\fontfile.h ===
/******************************Module*Header*******************************\
* Module Name: fontfile.h
*
* FONTFILE and FONTCONTEXT objects
*
* Created: 25-Oct-1990 09:20:11
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
*
\**************************************************************************/


#include "xform.h"

// for high-byte mapping support

typedef struct _MbcsToIndex
{
    BYTE    MbcsChar[4];
    HGLYPH  hGlyph;
} MbcsToIndex;

typedef struct _WcharToIndex
{
    BOOL    bValid;
    WCHAR   wChar;
    HGLYPH  hGlyph;
} WcharToIndex;


// cjIFI - size of the whole ifimetrics struct, with all strings appended
// cjFamilyName
// cjFaceName
// cjUniqueName
// cjSubfamilyName

#if DBG
#define DEBUG_GRAY 1
#endif

typedef struct _IFISIZE  // ifisz
{
    ULONG cjIFI;
    ULONG dpSims;          // offset of the FONTSIM struct
    PBYTE pjFamilyName;    // pointer to the location in the ttf file
    ULONG cjFamilyName;
    PBYTE pjFamilyNameAlias;    // pointer to the location in the ttf file
    ULONG cjFamilyNameAlias;
    PBYTE pjSubfamilyName; // pointer to the location in the ttf file
    ULONG cjSubfamilyName;
    PBYTE pjUniqueName;    // pointer to the location in the ttf file
    ULONG cjUniqueName;
    PBYTE pjFullName;      // pointer to the location in the ttf file
    ULONG cjFullName;
    ULONG dpCharSets;      // offset to array of charsets
    ULONG dpFontSig;       // offset to FONTSIGNATURE
} IFISIZE, *PIFISIZE;


typedef struct _FONTFILE       *PFONTFILE;     // pff
typedef struct _FONTCONTEXT    *PFONTCONTEXT;  // pfc
typedef struct _TTC_FONTFILE   *PTTC_FONTFILE; // pttc


// in the debug version of the rasterizer STAMPEXTRA shoud be added to the
// sizes. strictly speaking this is illegal, but nevertheless very useful.
// it assumes the knowlege of rasterizer internalls [bodind],
// see fscaler.c

#define STAMPEXTRA 4


#define CJ_0  NATURAL_ALIGN(sizeof(fs_SplineKey) + STAMPEXTRA)

#define FF_EXCEPTION_IN_PAGE_ERROR 1
#define FF_TYPE_1_CONVERSION       2


// BEGIN hack for kerning pairs, if these two map to same glyph index
// than space and hyphen should be returned.

#define FF_SPACE_EQUAL_NBSPACE     16
#define FF_HYPHEN_EQUAL_SFTHYPHEN  32

// Hack for new shell font for NT 5.0.
// Max Neg A will be forced to 0, it is same as MS Sans Serif
// 0x50 will not support in Korean and Japanese language

#define FF_NEW_SHELL_FONT           64

// If the font is signed

#define FF_SIGNATURE_VALID     128

// set if any DBCS charset is supported

#define FF_DBCS_CHARSET        256


#define SPACE        0X20
#define NBSPACE      0xA0
#define HYPHEN       0X2D
#define SFTHYPHEN    0XAD

typedef struct _CMAPINFO // cmi
{
    FLONG  fl;       // flags, see above
    ULONG  i_b7;     // index for [b7,b7] wcrun in FD_GLYPHSET if b7 is NOT supported
    ULONG  i_2219;   // cmap index for 2219 if 2219 IS supported
    ULONG  cRuns;    // number of runs in a font, excluding the last run
                     // if equal to [ffff,ffff]
    uint16 ui16SpecID; // for keep encoding ID
    ULONG  cGlyphs;  // total number of glyphs in a font
} CMAPINFO;


typedef struct _FFCACHE
{
//
// Move it from FONTFILE. We will cache it into TTCACHE.
//

    TABLE_POINTERS  tp;

    ULONG           ulTableOffset;

// FE vertical facename support

    ULONG           ulVerticalTableOffset; 
    uint16          uLongVerticalMetrics;

    ULONG           ulNumFaces;       // 1 or at most 2 if this is a FE font, (foo and @foo)

    UINT            uiFontCodePage; // 

    ULONG           cj3;     // request memorySizes[3],   
    ULONG           cj4;     // request memorySizes[4],     

// some general flags, for now only exception info, such as in_page_err

    FLONG           fl;

    ULONG           dpMappingTable;

// make it simple to access the ttf file

    uint16          ui16EmHt;
    uint16          ui16PlatformID;
    uint16          ui16SpecificID;
    uint16          ui16LanguageID;

// pointer to a glyphset for this file. It may be pointing to one of the
// shared glyphset structures, if this is appropriate, or to a
// glyphset structure that is very specific to this file and is stored
// at the bottom of GLYPH_IN_OUT

    ULONG           iGlyphSet;         // type of the glyphset  
    ULONG           wcBiasFirst;       // only used if ffca.iGlyphSet == SYMBOL 

// support for GeCharWidthInfo, private user api:

    USHORT          usMinD; // needs to be computed on the first font realization
    USHORT          igMinD; // index in hmtx table that points to usMinD
    SHORT           sMinA;  // from hhea
    SHORT           sMinC;  // from hhea

    CMAPINFO        cmi;    

} FFCACHE;

typedef struct _FONTFILE    // ff
{
    PTTC_FONTFILE pttc;

// these are set by bCheckVerticalTable

    ULONG       (*hgSearchVerticalGlyph)(PFONTFILE,ULONG, BOOL);

    PIFIMETRICS pifi_vertical;

    PBYTE        pj034;   // 0,3,4 buffers
    PFONTCONTEXT pfcLast; // last fc that set 034 buffers

// mem to be freed if file disappeared while trying to open font context
// only used in exception scenarios

    PFONTCONTEXT pfcToBeFreed;

    ULONG cRef;    // # no of times this font file is selected into fnt context

    ULONG_PTR iFile; // contains a pointer
    PVOID  pvView;   // contains the pointer to the top of ttf
    ULONG  cjView;  // contains size of the font file

// Pointer to an array of FD_KERNINGPAIR structures (notional units).
// The array is terminated by a zeroed FD_KERNINGPAIR structure.
// NULL until computed.  If there are no kerning pairs, then this will
// point to a zeroed (terminating) FD_KERNINGPAIR structure.

    FD_KERNINGPAIR *pkp;      // pointer to array of kerning pairs

    PFD_GLYPHSET    pgset;

//  for vertical gset


    PFD_GLYPHSET    pgsetv;

    ULONG           cRefGSet;
    ULONG           cRefGSetV;

    FFCACHE ffca;

// Note:
// The way memory is allocated for the FONTFILE structure, the IFIMETRICS
// MUST BE THE LAST ELEMENT of the structure!

    IFIMETRICS   ifi;         //!!! should it not this be put on the disk??? [bodind]

} FONTFILE;


typedef struct _TTC_CACHE
{
    FLONG       flTTCFormat;
    ULONG       cTTFsInTTC;       // number of TTF's in this TTC (or one if this is a TTF file)
    DWORD       dpGlyphAttr; // Cache for Glyphset;
    DWORD       dpTTF[1];         // there will be cTTFsInTTC of these offsets in the array
} TTC_CACHE,    *PTTC_CACHE;

// we will have one of these for every TTF in a TTC. Therefore ulNumFaces can be at most 2,
// for foo and @foo faces. cjIFI is the size of either IFIMETRICS corresponding
// to foo or @foo faces (we allocate the same size for foo and @foo IFIMETRICS structures).
// cjIFI is is NOT the sum of the sizes of the two IFIMETRICS.

typedef struct _TTF_CACHE
{
    ULONG        iSearchVerticalGlyph;  // (*hgSearchVerticalGlyph)(PFONTFILE,ULONG, BOOL);
    FFCACHE      ffca;       // shared data between foo and @foo faces

// we store the ifimetrics for foo face starting here, followed by the the ifimetrics for
// @foo face if there is one, followed by gset for foo face. For now we do not store gsetv,
// but compute it dynamically

    double      acIfi[1];    // really a byte array but now compiler guarantees QUAD alignment

} TTF_CACHE, *PTTF_CACHE;

// the values for iSearchVerticalGlyph

#define SUB_FUNCTION_DUMMY 0
#define SUB_FUNCTION_GSUB  1
#define SUB_FUNCTION_MORT  2

//
// TrueType collection 'ttc' font file support
//

typedef struct _TTC_HFF_ENTRY
{
    ULONG     ulOffsetTable;
    ULONG     iFace;
    HFF       hff;
} TTC_HFF_ENTRY, *PTTC_HFF_ENTRY;

typedef struct _TTC_FONTFILE    // ttcff
{
    ULONG         cRef;
    FLONG         fl;
    ULONG         ulTrueTypeResource;
    ULONG         ulNumEntry;
    PVOID         pvView;
    ULONG         cjView;
    PFD_GLYPHATTR pga;
    TTC_HFF_ENTRY ahffEntry[1];
} TTC_FONTFILE, *PTTC_FONTFILE;


#define CJ_IN      NATURAL_ALIGN(sizeof(fs_GlyphInputType))
#define CJ_OUT     NATURAL_ALIGN(sizeof(fs_GlyphInfoType))


// types of FD_GLYPHSET's, one of the predefined ones, or some
// general type

// mac

#define GSET_TYPE_MAC_ROMAN  1

// mac, but we pretend it is windows ansi

#define GSET_TYPE_PSEUDO_WIN 2

// honest to God msft unicode font

#define GSET_TYPE_GENERAL    3

// this is windows 31 hack. This is intened for fonts that have
// platid = 3 (msft), spec id (0), cmap format 4. In this case
// char codes are converted as
// charCode = iAnsi + (wcFirst - 0x20)

#define GSET_TYPE_SYMBOL     4

#define GSET_TYPE_HIGH_BYTE  5

#define GSET_TYPE_GENERAL_NOT_UNICODE  6


// win 31 BiDi fonts (Arabic Simplified, Arabic Traditional and Hebrew)
// These fonts have the HIBYTE(pOS2->usSelection) = 0xB1, 0xB2, 0xB3 or 0xB4
// and the puStartCount&0xFF00 is TRUE

#define GSET_TYPE_OLDBIDI    7


/**************************************************************************\

         GLYPHSTATUS structure

// handle of the last glyph that has been processed and a boolean
// which indicates whether metric info for a bitmap corresponding
// to that glyph has been computed

\**************************************************************************/

typedef struct _GLYPHSTATUS
{
    HGLYPH hgLast;
    ULONG  igLast;       // corresponding glyph index, rasterizer likes it better
    PVOID  pv;           // pointer to mem allocated just for the purpose of
                         // or producing bitmap or the outline for this glyph
    BOOL   bOutlineIsMessed;  // outline generated by bGetGlyphOutline might get messed by fs_FindBitMapSize
} GLYPHSTATUS, *PGLYPHSTATUS;

// "method" acting on this "object"

VOID vInitGlyphState(PGLYPHSTATUS pgstat);

// HDMX stuff, from fd_royal.h in win31 sources:

typedef struct
{
  BYTE     ucEmY;
  BYTE     ucEmX;          // MAX advance width for this EmHt;
  BYTE     aucInc [1];     // maxp->numGlyphs of entries
} HDMXTABLE;        // hdmx

typedef struct
{
  uint16            Version;    // table version number, starts at zero
  uint16            cRecords;
  uint32            cjRecord;   // dword aligned size of individual record,
                                // all of them have the same size

// after this records follow:

  // HDMXTABLE         HdmxTable [cRecords]
} HDMXHEADER;  // hdhdr

// to get to the next record one does the following:
// phdmx = (HDMXTABLE *)((BYTE *)phdmx + phdhdr->cjRecord);

// 'gasp' structures

typedef struct
{
    uint16  rangeMaxPPEM;
    uint16  rangeGaspBehavior;
} GASPRANGE;

typedef struct
{
    uint16  version;
    uint16  numRanges;
    GASPRANGE   gaspRange[1];
} GASPTABLE;

#define GASP_GRIDFIT    0x0001
#define GASP_DOGRAY     0x0002


/**************************************************************************\
 *  FONTCONTEXT structure
\**************************************************************************/

typedef struct _FONTCONTEXT     // fc
{
    FONTOBJ*  pfo;          // points back to calling FONTOBJ
    PFONTFILE pff;          // handle of the font file selected into this context

// handle of the last glyph that has been processed and a boolean
// which indicates whether metric info for a bitmap corresponding
// to that glyph has been computed

    GLYPHSTATUS gstat;

// parts of FONTOBJ that are important

    FLONG   flFontType;
    SIZE    sizLogResPpi;
    ULONG   ulStyleSize;

// transform matrix in the format as requested by the font scaler
// the FONTOBJ and XFORMOBJ (in the form of the XFORM) fully specify
// the font context for the realization

    XFORML      xfm;          // cached xform
    transMatrix mx;           // the same as above, just a different format
    FLONG       flXform;

// if it were not for win31 vdmx hacks this field would not be necessary,

    LONG   lEmHtDev;          // em height in pixels in device space
    Fixed  fxPtSize;          // em height in points on the rendering device

// pointer to the hdmx table that applies if any, else NULL

    HDMXTABLE *phdmx;

// asc and desc measured along unit ascender vector in device coords.
// Unit ascender vector in device coords == xForm(0,-1)/|xForm(0,-1)|

    LONG  lAscDev;
    LONG  lDescDev;

// xMin and xMax in device coords for grid fitted glyphs, cxMax = xMax - xMin

    LONG  xMin;
    LONG  xMax;

// asender and descender in device coords for grid fitted glyphs
// cyMax = yMax - yMin;

    LONG  yMin;
    LONG  yMax;

// max width in pixels of all rasterized bitmaps

    ULONG cxMax;

// the size of the GLYPHDATA structure necessary to store the largest
// glyph bitmap with the header info. This is value is cashed at the
// time the font context is opened and used later in FdQueryGlyphBitmap

    ULONG cjGlyphMax;  // in BYTE's

// tt structures, they live in pff->cj034

    fs_GlyphInputType *pgin;
    fs_GlyphInfoType  *pgout;

    PTABLE_POINTERS     ptp;

// This is used for the glyph origin of singular bitmaps to make sure they don't
// get placed outside of the text bounding box for fonts with positive max
// descent or negative max ascent.

    POINTL ptlSingularOrigin;

// a few fields that are realy only necessary if the xform is
// non trivial, cached here to speed up metric computations for glyphs:

    VECTORFL vtflBase;      // ptqBase = Xform(e1)
    POINTE   pteUnitBase;   // ptqBase/|ptqBase|
    EFLOAT   efBase;        // |ptqBase|, enough precission

    POINTQF  ptqUnitBase;   // pteUnitBase in POINTQF format,
                            // has to be added to all ptqD's if emboldening

    VECTORFL vtflSide;      // ptqSide = Xform(-e2)
    POINTE   pteUnitSide;   // ptqSide/|ptqSide|
    EFLOAT   efSide;        // |ptqSide|, enough precission

    POINTQF  ptqUnitSide;   // pteUnitSide in POINTQF format,

// data added to speed up bBigEnough computation

    POINTFIX ptfxTop;
    POINTFIX ptfxBottom;

// for FE vertical support

    ULONG    ulControl;     // to signal if we need a rotated glyph or use bitmap
    BOOL     bVertical;     // TRUE if it's @face
    ULONG    hgSave;
    Fixed    pointSize;     // for fs_NewTransformation
    transMatrix mxv;        // mx for vertical glyphs
    transMatrix mxn;        // mx for normal glyphs
    Fixed    fxdevShiftX;   // x shift value in device space
    Fixed    fxdevShiftY;   // y shift value in device space

// for font emboldening, most glyphs will use global emboldening info,
// only those glyphs which extend to descender will have to
// use different emb.

    USHORT dBase;

// TrueType Rasterizer 1.7 require the overScale (for antialiazed text) to be passed to fs_NewTransformation
// we need to keep track of this value to pass it at fs_NewTransform

	USHORT overScale;

// for FE DBCS fixed pitch, we store the SBCS width so that we can enforce DBCS width = 2 * SBCS width
// value set for fonts that have  (pifi->flInfo & FM_INFO_DBCS_FIXED_PITCH)

    LONG SBCSWidth;


} FONTCONTEXT;

/* fc->overscale get first set to FF_UNDEFINED_OVERSCALE and at fs_NewTransform get set to the current one */
#define FF_UNDEFINED_OVERSCALE 0x0FFFF

// flags describing the transform, may change a bit,
// quantized bit means that the original xform has been
// changed a bit to take into account vdmx quantization

#define XFORM_HORIZ           1
#define XFORM_VERT            2
#define XFORM_VDMXEXTENTS     4
#define XFORM_SINGULAR        8
#define XFORM_POSITIVE_SCALE 16
#define XFORM_2PPEM	     32
#define XFORM_MAX_NEG_AC_HACK  64
#define XFORM_BITMAP_SIM_BOLD  128

// unicode code points used to detect charset of FE fonts

#define U_HALFWIDTH_KATAKANA_LETTER_A      0xFF71 // SJIS B1
#define U_HALFWIDTH_KATAKANA_LETTER_I      0xFF72 // SJIS B2
#define U_HALFWIDTH_KATAKANA_LETTER_U      0xFF73 // SJIS B3
#define U_HALFWIDTH_KATAKANA_LETTER_E      0xFF74 // SJIS B4
#define U_HALFWIDTH_KATAKANA_LETTER_O      0xFF75 // SJIS B5

#define U_FULLWIDTH_HAN_IDEOGRAPHIC_9F98   0x9F98 // BIG5 F9D5
#define U_FULLWIDTH_HAN_IDEOGRAPHIC_9F79   0x9F79 // BIG6 F96A

#define U_FULLWIDTH_HAN_IDEOGRAPHIC_61D4   0x61D4 // GB   6733
#define U_FULLWIDTH_HAN_IDEOGRAPHIC_9EE2   0x9EE2 // GB   8781

#define U_FULLWIDTH_HANGUL_LETTER_GA       0xAC00 // WS   B0A1
#define U_FULLWIDTH_HANGUL_LETTER_HA       0xD558 // WS   C7CF

#define U_PRIVATE_USER_AREA_E000           0xE000 // SJIS F040

// basic "methods" that act on the FONTFILE object  (in fontfile.c)

#define   PFF(hff)      ((PFONTFILE)hff)
#define   pffAlloc(cj)  ((PFONTFILE)EngAllocMem(0, cj, 'dftT'))
#define   vFreeFF(hff)  EngFreeMem((PVOID)hff)

// basic "methods" that act on the TTC_FONTFILE object

#define   PTTC(httc)     ((PTTC_FONTFILE)httc)
#define   pttcAlloc(cj)  ((PTTC_FONTFILE)EngAllocMem(FL_ZERO_MEMORY, cj, 'dftT'))
#define   vFreeTTC(httc) V_FREE(httc)

// basic "methods" that act on the FONTCONTEXT object  (in fontfile.c)

#define   PFC(hfc)      ((PFONTCONTEXT)hfc)
#define   pfcAlloc(cj)  ((PFONTCONTEXT)EngAllocMem(0, cj, 'dftT'))
#define   vFreeFC(hfc)  EngFreeMem((PVOID)hfc)

#define   V_FREE(pv)    EngFreeMem((PVOID)pv)
#define   PV_ALLOC(cj)  EngAllocMem(0, cj, 'dftT')

// New added Pv_Realloc used in robust rasterizer

PVOID   Pv_Realloc(PVOID pv, LONG newSzie, LONG oldSize);

// Robust rasterizer need malloc, free & realloc
// NT kernel can not support realloc, we got to implement by ourselves
#define FST_MALLOC PV_ALLOC
#define FST_FREE V_FREE
#define FST_REALLOC Pv_Realloc

// Robust rasterizer assertion
#if DBG
#define FSTAssert(exp, str) ASSERTDD(exp, str)
#else
#define FSTAssert(exp,str)
#endif

// tt required functions, callbacks

// I hate to have this function defined like this [bodind],

voidPtr FS_CALLBACK_PROTO pvGetPointerCallback    (ULONG_PTR  clientID, long dp, long cjData);
void    FS_CALLBACK_PROTO vReleasePointerCallback (voidPtr pv);

BOOL bGetFastAdvanceWidth(FONTCONTEXT *, ULONG, FIX *);


//
// Used to identify data dynamically allocated that will be
// freed via the ttfdFree function.  The ulDataType specifies
// the type of dynamic data.
//

typedef struct _DYNAMICDATA
{
    ULONG     ulDataType;   // data type
    FONTFILE *pff;          // identifies font file this data corresponds to
} DYNAMICDATA;


//
// Data types allocated dynamically:
//
//  ID_KERNPAIR dynamically allocated array of FD_KERNINGPAIR structures
//

#define ID_KERNPAIR 0
#define FO_CHOSE_DEPTH   0x80000000

#define CJGD(w,h,p)                                                      \
  ALIGN4(offsetof(GLYPHBITS,aj)) +                                       \
  ALIGN4((h)*(((p)->flFontType & FO_GRAY16)?(((p)->flFontType & FO_CLEARTYPE_X)?(w):(((w)+1)/2)):(((w)+7)/8)))

LONG lExL(FLOATL e, LONG l);


// for FE vertical support

// pfc->ulControl

#define VERTICAL_MODE       0x02

VOID  vCalcXformVertical( FONTCONTEXT *pfc);
BOOL  bChangeXform( FONTCONTEXT *pfc, BOOL bRotation );
BOOL  IsFullWidthCharacter(FONTFILE *pff, HGLYPH hg);
VOID  vShiftBitmapInfo(FONTCONTEXT *pfc, fs_GlyphInfoType *pgoutDst, fs_GlyphInfoType *pgoutSrc);
VOID  vShiftOutlineInfo(FONTCONTEXT *pfc, BOOL b16Dot16, BYTE* ppoly, ULONG cjBuf );
ULONG SearchMortTable( FONTFILE *pff, ULONG  ig, BOOL bDump);
ULONG SearchGsubTable( FONTFILE *pff, ULONG  ig, BOOL bDump);
ULONG SearchDummyTable( FONTFILE *pff, ULONG ig, BOOL bDump);
BOOL  bCheckVerticalTable( PFONTFILE pff );

#if DBG
// #define DBCS_VERT_DEBUG
#define DEBUG_VERTICAL_XFORM              0x1
#define DEBUG_VERTICAL_CALL               0x2
#define DEBUG_VERTICAL_GLYPHDATA          0x4
#define DEBUG_VERTICAL_NOTIONALGLYPH      0x8
#define DEBUG_VERTICAL_BITMAPINFO        0x10
#define DEBUG_VERTICAL_DEVICERECT        0x20
#define DEBUG_VERTICAL_MAXGLYPH          0x40

extern ULONG DebugVertical;

VOID vDumpGlyphData( GLYPHDATA *pgldg );
#endif // DBG

VOID vCharacterCode (PFONTFILE pff, HGLYPH hg, fs_GlyphInputType *pgin);
BOOL bGetGlyphOutline(FONTCONTEXT*,HGLYPH, ULONG*, FLONG, FS_ENTRY*);
BOOL bIndexToWchar (PFONTFILE pff, PWCHAR pwc, uint16 usIndex, BOOL bVertical);

VOID vLONG_X_POINTQF(LONG lIn, POINTQF *ptqIn, POINTQF *ptqOut);

BOOL bComputeGlyphAttrBits(PTTC_FONTFILE pttc, PFONTFILE pff);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\ttfd\fot16.c ===
/******************************Module*Header*******************************\
* Module Name: fon16.c
*
* routines for accessing font resources within *.fon files
* (win 3.0 16 bit dlls)
*
* Created: 08-May-1991 12:55:14
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/

#include "fd.h"
#include "exehdr.h"
#include "winfont.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\ttfd\fd_query.c ===
/******************************Module*Header*******************************\
* Module Name: fd_query.c                                                  *
*                                                                          *
* QUERY functions.                                                         *
*                                                                          *
* Created: 18-Nov-1991 14:37:56                                            *
* Author: Bodin Dresevic [BodinD]                                          *
*                                                                          *
* Copyright (c) 1993 Microsoft Corporation                                 *
\**************************************************************************/

#include "fd.h"
#include "winfont.h"
#include "fdsem.h"
#include "winerror.h"

extern HSEMAPHORE ghsemTTFD;

#if DBG
extern ULONG gflTtfdDebug;
#endif

#ifdef _X86_
//
// For x86, FLOATL is actually DWORD, but the value is IEEE format floating
// point, then check sign bit.
//
#define IS_FLOATL_MINUS(x)   ((DWORD)(x) & 0x80000000)
#else
//
// For RISC, FLOATL is FLOAT.
//
#define IS_FLOATL_MINUS(x)   (((FLOATL)(x)) < 0.0f)
#endif // _X86_

//
// Monochrome: 1  bit per pixel
// Gray:       8 bits per pixel
// ClearType   8 bits per pixel also, no modification needed for CLEARTYPE
///            because FO_GRAY16 will be set along with FO_CLEARTYPE_X
//
// CJ_TT_SCAN rounds up to a 32-bit boundary
//
#define CJ_TT_SCAN(cx,p) \
    (4*((((((p)->flFontType & FO_GRAY16)?(8):(1))*(cx))+31)/32))

// Each scan of a glyph bitmap is BYTE aligned (except for the
// top (first) scan which is DWORD aligned. The last scan is
// padded out with zeros to the nearest DWORD boundary. These
// statements apply to monochrome and 4-bpp gray glyphs images.
// The number of bytes per scan will depend upon the number of
// pixels in a scan and the depth of the image. For monochrome
// glyphs the number of bytes per scan is ceil(cx/8) = floor((cx+7)/8)
// For the case of 4-bpp bitmaps the count of bytes in a scan
// is ceil( 4*cx/8 ) = ceil(cx/2)

#define CJ_MONOCHROME_SCAN(cx)  (((cx)+7)/8)
#define CJ_GRAY_SCAN(cx)        (((cx)+1)/2)
#define CJ_CLEARTYPE_SCAN(cx)   (cx)

BOOL bReloadGlyphSet(PFONTFILE pff, ULONG iFace);
VOID vReleaseGlyphSet(PFONTFILE pff, ULONG iFace);

#if DBG
// #define  DEBUG_OUTLINE
// #define  DBG_CHARINC
#endif

BOOL gbJpn98FixPitch = FALSE;

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewContourGridFit(fs_GlyphInputType *gin, fs_GlyphInfoType *gout)
{
// this routine needs to be improved to only attempt to use
// nonhinted outline when hints are at fault for not being able to produce the
// hinted outline

    FS_ENTRY iRet = fs_ContourGridFit(gin, gout);

    if (iRet != NO_ERR)
    {
        V_FSERROR(iRet);

    // try to recover, most likey bad hints, just return unhinted glyph

        iRet = fs_ContourNoGridFit(gin, gout);
    }
    return iRet;
}

// notional space metric data for an individual glyph

/******************************Public*Routine******************************\
* vAddPOINTQF
*
*
\**************************************************************************/

VOID vAddPOINTQF( POINTQF *pptq1, POINTQF *pptq2)
{
    pptq1->x.LowPart  += pptq2->x.LowPart;
    pptq1->x.HighPart += pptq2->x.HighPart + (pptq1->x.LowPart < pptq2->x.LowPart);

    pptq1->y.LowPart  += pptq2->y.LowPart;
    pptq1->y.HighPart += pptq2->y.HighPart + (pptq1->y.LowPart < pptq2->y.LowPart);
}


/******************************Public*Routine******************************\
* VOID vCharacterCode
*
* History:
*  07-Dec-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vCharacterCode (
    FONTFILE          *pff,
    HGLYPH             hg,
    fs_GlyphInputType *pgin
    )
{
    ASSERTDD((hg & 0xffff0000) == 0, "hg not unicode\n");

    pgin->param.newglyph.characterCode = NONVALID;
    pgin->param.newglyph.glyphIndex = (uint16)hg;
    pgin->param.newglyph.bMatchBBox  = FALSE;
    pgin->param.newglyph.bNoEmbeddedBitmap = FALSE;
    return;
}


/******************************Public*Routine******************************\
*
* LONG ttfdQueryCaps
*
*
* Effects: returns the capabilities of this driver.
*          Only mono bitmaps are supported.
*
*
* History:
*  27-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG ttfdQueryFontCaps (
    ULONG  culCaps,
    ULONG *pulCaps
    )
{
    ULONG culCopied = min(culCaps,2);
    ULONG aulCaps[2];

    aulCaps[0] = 2L; // number of ULONG's in a complete array

//!!! make sure that outlines are really supported in the end, when this driver
//!!! is completed, if not, get rid of FD_OUTLINES flag [bodind]

    aulCaps[1] = (QC_1BIT | QC_OUTLINES);   // 1 bit per pel bitmaps only are supported

    RtlCopyMemory((PVOID)pulCaps,(PVOID)aulCaps, culCopied * 4);
    return( culCopied );
}


/******************************Public*Routine******************************\
* PIFIMETRICS ttfdQueryFont
*
* Return a pointer to the IFIMETRICS for the specified face of the font
* file.  Also returns an id (via the pid parameter) that is later used
* by ttfdFree.
*
* History:
*  21-Oct-1992 Gilman Wong [gilmanw]
* IFI/DDI merge
*
*  18-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

IFIMETRICS *ttfdQueryFont (
    DHPDEV dhpdev,
    HFF    hff,
    ULONG  iFace,
    ULONG_PTR *pid
    )
{
    HFF    httc = hff;

// Validate handle.

    ASSERTDD(hff, "ttfdQueryFaces(): invalid iFile (hff)\n");
    ASSERTDD(iFace <= PTTC(hff)->ulNumEntry,
             "gdisrv!ttfdQueryFaces(): iFace out of range\n");

// get real hff from ttc array.

    hff   = PTTC(httc)->ahffEntry[iFace-1].hff;
    iFace = PTTC(httc)->ahffEntry[iFace-1].iFace;

    dhpdev;

//
// Validate handle.
//
    ASSERTDD(hff, "ttfdQueryFaces(): invalid iFile (hff)\n");
    ASSERTDD(iFace <= PFF(hff)->ffca.ulNumFaces,
             "ttfdQueryFaces(): iFace out of range\n");

//
// ttfdFree can ignore this.  IFIMETRICS will be deleted with the FONTFILE
// structure.
//
    *pid = (ULONG_PTR) NULL;

//
// Return the pointer to the precomputed IFIMETRICS in the PFF.
//

    if ( iFace == 1L )
        return ( &(PFF(hff)->ifi) ); // Normal face
    else
      return ( PFF(hff)->pifi_vertical ); // Vertical face
}


/******************************Public*Routine******************************\
* vFillSingularGLYPHDATA
*
* History:
*  22-Sep-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vFillSingularGLYPHDATA (
    HGLYPH       hg,
    ULONG        ig,
    FONTCONTEXT *pfc,
    GLYPHDATA   *pgldt   // OUT
    )
{
    extern VOID vGetNotionalGlyphMetrics(FONTCONTEXT*, ULONG, NOT_GM*);
    NOT_GM ngm;  // notional glyph data

    // may get changed by the calling routine if bits requested too
    pgldt->gdf.pgb = NULL;
    pgldt->hg = hg;

// this is a fake 1x1 bitmap

    pgldt->rclInk.left   = 0;
    pgldt->rclInk.top    = 0;
    pgldt->rclInk.right  = 0;
    pgldt->rclInk.bottom = 0;

// go on to compute the positioning info:

// here we will just xform the notional space data:

    vGetNotionalGlyphMetrics(pfc,ig,&ngm);

// xforms are computed by simple multiplication

    pgldt->fxD         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sD);
    pgldt->fxA         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sA);
    pgldt->fxAB        = fxLTimesEf(&pfc->efBase, (LONG)ngm.xMax);

    pgldt->fxInkTop    = - fxLTimesEf(&pfc->efSide, (LONG)ngm.yMin);
    pgldt->fxInkBottom = - fxLTimesEf(&pfc->efSide, (LONG)ngm.yMax);

    vLTimesVtfl((LONG)ngm.sD, &pfc->vtflBase, &pgldt->ptqD);
}


/******************************Public*Routine******************************\
* lGetSingularGlyphBitmap
*
* History:
*  22-Sep-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG lGetSingularGlyphBitmap (
    FONTCONTEXT *pfc,
    HGLYPH       hglyph,
    GLYPHDATA   *pgd,
    VOID        *pv
    )
{
    LONG         cjGlyphData;
    ULONG        ig;
    FS_ENTRY     iRet;


    vCharacterCode(pfc->pff,hglyph,pfc->pgin);

// Compute the glyph index from the character code:

    if ((iRet = fs_NewGlyph(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);

        WARNING("gdisrv!lGetSingularGlyphBitmap(): fs_NewGlyph failed\n");
        return FD_ERROR;
    }

// Return the glyph index corresponding to this hglyph.

    ig = pfc->pgout->glyphIndex;

    ASSERTDD(pfc->flFontType & FO_CHOSE_DEPTH,"Depth Not Chosen Yet!\n");
    cjGlyphData = CJGD(1,1,pfc);

// If prg is NULL, caller is requesting just the size.

// At this time we know that the caller wants the whole GLYPHDATA with
// bitmap bits, or maybe just the glypdata without the bits.
// In either case we shall reject the caller if he did not
// provide sufficiently big buffer

// fill all of GLYPHDATA structure except for bitmap bits

    if ( pgd != (GLYPHDATA *)NULL )
    {
        vFillSingularGLYPHDATA( hglyph, ig, pfc, pgd );
    }

    if ( pv != NULL )
    {
        GLYPHBITS *pgb = (GLYPHBITS *)pv;

    // By returning a small 1x1 bitmap, we save device drivers from having
    // to special case this.

        // The corresponding GLYPHDATA structure has been modified
        // by vFillGlyphData. See the statement "pgldt->fxA = 0"
        // in vFillGlyphData.

        pgb->ptlOrigin.x = pfc->ptlSingularOrigin.x;
        pgb->ptlOrigin.y = pfc->ptlSingularOrigin.y;

        pgb->sizlBitmap.cx = 1;    // cheating
        pgb->sizlBitmap.cy = 1;    // cheating

        // This is where we fill in the blank 1x1 dib
        // it turns out that a single zero'ed byte
        // covers both the 1-bpp and 4-bpp cases

        *((ULONG *)pgb->aj) = 0;  // fill in a blank 1x1 dib
    }

    if ( pgd != (GLYPHDATA *)NULL )
    {
        pgd->gdf.pgb = (GLYPHBITS *)pv;
    }


// Return the size.

    return(cjGlyphData);
}


/******************************Public*Routine******************************\
* lGetGlyphBitmap
*
* History:
*  20-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG lGetGlyphBitmap (
    FONTCONTEXT *pfc,
    HGLYPH       hglyph,
    GLYPHDATA   *pgd,
    VOID        *pv,
    FS_ENTRY    *piRet
    )
{
    PVOID pvSetMemoryBases(fs_GlyphInfoType*, fs_GlyphInputType*, int);
    VOID vCopyAndZeroOutPaddingBits(FONTCONTEXT*, GLYPHBITS*, BYTE*, GMC*);
    VOID vCopyGrayBits(FONTCONTEXT*, GLYPHBITS*, BYTE*, GMC*);
    VOID vCopyClearTypeBits(FONTCONTEXT *, GLYPHBITS *, BYTE *, GMC *);
    VOID vFillGLYPHDATA(HGLYPH, ULONG, FONTCONTEXT*, fs_GlyphInfoType*, GLYPHDATA*, GMC*, POINTL*);
    BOOL bGetGlyphMetrics(FONTCONTEXT*, HGLYPH, FLONG, FS_ENTRY*);
    LONG  lGetGlyphBitmapVertical(FONTCONTEXT*,HGLYPH,GLYPHDATA*,PVOID,FS_ENTRY*);

    LONG         cjGlyphData;
    ULONG        cx,cy;
    GMC          gmc;
    GLYPHDATA    gd;
    POINTL       ptlOrg;
    BOOL         bBlankGlyph = FALSE; // initialization essential;

    ASSERTDD(hglyph != HGLYPH_INVALID, "lGetGlyphBitmap, hglyph == -1\n");
    ASSERTDD(pfc == pfc->pff->pfcLast, "pfc! = pfcLast\n");

    *piRet = NO_ERR;

// check the last glyph processed to determine
// whether we have to register the glyph as new and compute its size

    if (pfc->gstat.hgLast != hglyph)
    {
    // DO skip grid fitting if embedded bitmpas are found,
    // for we will NOT be interested in outlines

        if (!bGetGlyphMetrics(pfc,hglyph,FL_SKIP_IF_BITMAP,piRet))
        {
            return(FD_ERROR);
        }
    }


    cx = pfc->pgout->bitMapInfo.bounds.right
       - pfc->pgout->bitMapInfo.bounds.left;
    cy = pfc->pgout->bitMapInfo.bounds.bottom
       - pfc->pgout->bitMapInfo.bounds.top;

// here we shall endulge in cheating. If cx or cy is zero
// (ususally space character - no bits to set, but there is a nontrivial
// positioning information) we shall cheat and instead of retrning no bits
// for bimtap we shall
// return a small 1x1 bitmap, which will be blank, i.e. all bits will be off
// this prevents having to insert an if(cx && cy) check to a time critical
// loop in all device drivers before calling DrawGlyph routine.

    if ((cx == 0) || (cy == 0)) // cheat here
    {
        bBlankGlyph = TRUE;
    }

    if (bBlankGlyph)
    {
        ASSERTDD(
            pfc->flFontType & FO_CHOSE_DEPTH,"Depth Not Chosen Yet!\n");
        cjGlyphData = CJGD(1,1,pfc);
    }
    else
    {
    // this is quick and dirty computation, the acutal culGlyphData
    // written to the buffer may be little smaller if we had to shave
    // off a few scans off the glyph bitmap that extended over
    // the pfc->yMin or pfc->yMax bounds. Notice that culGlyphData
    // computed this way may be somewhat bigger than pfc->culGlyphMax,
    // but the actual glyph written to the buffer will be smaller than
    // pfc->culGlyphMax

        // really win31 hack, shold not always be shifting right [bodind]
        // Win95 FE hack

        ASSERTDD(
            pfc->flFontType & FO_CHOSE_DEPTH,
            "Depth Not Chosen Yet!\n"
        );
        cjGlyphData = CJGD(cx,cy,pfc);

    // since we will shave off any extra rows if there are any,
    // we can fix culGlyphData so as not extend over the max value

        if ((ULONG)cjGlyphData > pfc->cjGlyphMax)
            cjGlyphData = (LONG)pfc->cjGlyphMax;
    }

    if ( (pgd == NULL) && (pv == NULL))
        return cjGlyphData;

// at this time we know that the caller wants the whole GLYPHDATA with
// bitmap bits, or maybe just the glypdata without the bits.

// fill all of GLYPHDATA structure except for bitmap bits
// !!! Scummy hack - there appears to be no way to get just the
// !!! bitmap, without getting the metrics, since the origin for the
// !!! bitmap is computed from the rclink field in the glyphdata.
// !!! this is surely fixable but I have neither the time nor the
// !!! inclination to pursue it.
// !!!
// !!! We should fix this when we have time.

    if ( pgd == NULL )
    {
        pgd = &gd;
    }


    if ( pfc->bVertical && ( pfc->ulControl & VERTICAL_MODE ) )
    {
        // Vertical case
        fs_GlyphInfoType  my_gout;

        vShiftBitmapInfo( pfc, &my_gout, pfc->pgout );
        vFillGLYPHDATA(
            pfc->hgSave,         // this is a little bit tricky. we wouldn't like to
            pfc->gstat.igLast,   // tell GDI about vertical glyph index.
            pfc,
            &my_gout,
            pgd,
            &gmc,
            &ptlOrg);
    }
    else
    {

        // Normal case
        vFillGLYPHDATA(
            hglyph,
            pfc->gstat.igLast,
            pfc,
            pfc->pgout,
            pgd,
            &gmc,
            &ptlOrg);
    }

    // the caller wants the bits too


    if ( pv != NULL )
    {
        GLYPHBITS *pgb = (GLYPHBITS *)pv;

    // allocate mem for the glyph, 5-7 are magic #s required by the spec
    // remember the pointer so that the memory can be freed later in case
    // of exception

        pfc->gstat.pv = pvSetMemoryBases(pfc->pgout, pfc->pgin, IS_GRAY(pfc));
        if (!pfc->gstat.pv)
           RETURN("TTFD!_ttfdQGB, mem allocation failed\n",FD_ERROR);

    // initialize the fields needed by fs_ContourScan,
    // the routine that fills the outline, do the whole
    // bitmap at once, do not want banding

        pfc->pgin->param.scan.bottomClip = pfc->pgout->bitMapInfo.bounds.top;
        pfc->pgin->param.scan.topClip = pfc->pgout->bitMapInfo.bounds.bottom;
        pfc->pgin->param.scan.outlineCache = (int32 *)NULL;


    // make sure that our state is ok: the ouline data in the shared buffer 3
    // must correspond to the glyph we are processing, and the last
    // font context that used the shared buffer pj3 to store glyph outlines
    // has to be the pfc passed to this function:

        ASSERTDD(hglyph == pfc->gstat.hgLast, "hgLast trashed \n");

        *piRet = fs_ContourScan(pfc->pgin,pfc->pgout);

        pfc->gstat.hgLast = HGLYPH_INVALID;


        if (*piRet != NO_ERR)
        {
        // just to be safe for the next time around, reset pfcLast to NULL

            V_FSERROR(*piRet);
            V_FREE(pfc->gstat.pv);
            pfc->gstat.pv = NULL;

            return(FD_ERROR);
        }

        if (!bBlankGlyph && gmc.cxCor && gmc.cyCor)
        {
        // copy to the engine's buffer and zero out the bits
        // outside of the black box

#if DBG
if ((pfc->flXform & XFORM_POSITIVE_SCALE) )
{
ASSERTDD(gmc.cxCor == (ULONG)((pgd->fxAB - pgd->fxA) >> 4),
    "TTFD!vCopyAndZeroOutPaddingBits, SUM RULE\n");
}
#endif

        // Call either the monochrome or the gray level function
        // depending upon the gray bit in the font context

            (*(IS_GRAY(pfc) ? ((pfc->flFontType & FO_CLEARTYPE_X) ? vCopyClearTypeBits : vCopyGrayBits) : vCopyAndZeroOutPaddingBits))(
                pfc
              , pgb
              , (BYTE*) pfc->pgout->bitMapInfo.baseAddr
              , &gmc
            );

        // bitmap origin, i.e. the upper left corner of the bitmap, bitmap
        // is as big as its black box

            if (!(pfc->flXform & (XFORM_HORIZ | XFORM_VERT)))
            {
                pgb->ptlOrigin = ptlOrg;

            }
            else
            {
            // In HORIZ or VERT case there is no need to shift origin
            // when emboldening. The point is that we have already fixed
            // rclInk, and therefore this is all we need to do

                pgb->ptlOrigin.x = pgd->rclInk.left;
                pgb->ptlOrigin.y = pgd->rclInk.top;
            }
        }
        else // blank glyph, cheat and return a blank 1x1 bitmap
        {
            if (bBlankGlyph)
            {
                ASSERTDD(
                    pfc->flFontType & FO_CHOSE_DEPTH
                   ,"Depth Not Chosen Yet!\n");
                ASSERTDD(
                    cjGlyphData == (LONG) CJGD(1,1,pfc),
                    "TTFD!_bBlankGlyph, cjGlyphData\n");
            }
            else
            {
                ASSERTDD(
                    cjGlyphData >= (LONG) CJGD(1,1,pfc),
                    "TTFD!_corrected blank glyph, cjGlyphData\n"
                    );
            }


            pgb->ptlOrigin.x = pfc->ptlSingularOrigin.x;
            pgb->ptlOrigin.y = pfc->ptlSingularOrigin.y;

            pgb->sizlBitmap.cx = 1;    // cheating
            pgb->sizlBitmap.cy = 1;    // cheating

            pgb->aj[0] = (BYTE)0;  // fill in a blank 1x1 bmp

        }

        pgd->gdf.pgb = pgb;


    // free memory and return

        V_FREE(pfc->gstat.pv);
        pfc->gstat.pv = NULL;
    }

    return(cjGlyphData);
}


/******************************Public*Routine******************************\
*
* bIndexToWchar
*
* Effects:
*
*   Converts glyph index to the wchar that corresponds to that glyph
*   index. returns true if succeeds, the function will fail only if
*   there happens to be a bug in the font file, otherwise it should
*   always succeed.
*
* Comments:
*
*   The Win 3.1 algorithm generates a table for glyph index to Unicode
*   translation.  The table consists of an array of Unicode codepoints
*   indexed by the corresponding glyph index.  The table is built by
*   scanning the ENTIRE cmap table.  As each glyph index is encountered,
*   its corresponding Unicode codepoint is put into the table EVEN IF
*   THIS MEANS OVERWRITING A PREVIOUS VALUE.  The effect of this is that
*   Win 3.1, in the situation where there is a one-to-many mapping of
*   glyph index to Unicode codepoint, always picks the last Unicode
*   character encountered in the cmap table.  We emulate this behavior
*   by scanning the cmap table BACKWARDS and terminating the search at
*   the first match encountered.    [GilmanW]
*
* Returns:
*   TRUE if conversion succeeded, FALSE otherwise.
*
* History:
*  16-May-1993 Gilman Wong [gilmanw]
* Re-wrote.  Changed translation to be Win 3.1 compatible.  Win 3.1 does
* not terminate the search as soon as the first Unicode character is found
* with the proper glyph index.  Instead, its algorithm finds the LAST
* Unicode character with the proper glyph index.
*
*  06-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bIndexToWchar(FONTFILE *pff, WCHAR *pwc, uint16 usIndex, BOOL bVertical)
{
    uint16 *pstartCount, *pendCount,            // Arrays that define the
           *pidDelta, *pidRangeOffset;          // Unicode runs supported
                                                // by the CMAP table.
    uint16 *pendCountStart;                     // Beginning of arrays.
    uint16  cRuns;                              // Number of Unicode runs.
    uint16  usLo, usHi, idDelta, idRangeOffset; // Current Unicode run.
    uint16 *pidStart, *pid;                     // To parse glyph index array.
    uint16  usIndexBE;                          // Big endian ver of usIndex.
    sfnt_mappingTable *pmap = (sfnt_mappingTable *)(
        (BYTE *)pff->pvView + pff->ffca.dpMappingTable
        );

    uint16 *pusEnd = (uint16 *)((BYTE *)pmap + (uint16)SWAPW(pmap->length));

// First must check if this is an MSFT style tt file or a Mac style file.
// Each case is handled separately.

    if (pff->ffca.ui16PlatformID == BE_PLAT_ID_MAC)
    {
        PBYTE pjGlyphIdArray;
        PBYTE pjGlyph;
        BYTE  jIndex;

    // This is an easy case, GlyphIdArray is indexed into by mac code point,
    // all we have to do is to convert it to UNICODE:
    //
    // Scan backwards for Win 3.1 compatibility.

        ASSERTDD(pmap->format == BE_FORMAT_MAC_STANDARD,
                  "bIndexToWchar cmap format for mac\n");
        ASSERTDD(usIndex < 256, "bIndexToWchar mac usIndex > 255\n");

        jIndex = (BYTE) usIndex;

        pjGlyphIdArray = (PBYTE)pmap + SIZEOF_CMAPTABLE;
        pjGlyph = &pjGlyphIdArray[255];

        for ( ; pjGlyph >= pjGlyphIdArray; pjGlyph--)
        {
            if (*pjGlyph == jIndex)
            {
            // Must convert the Mac code point to Unicode.  The Mac code
            // point is a BYTE; indeed, it is the index of the glyph id in
            // the table and may be computed as the current offset from
            // the beginning of the table.

                jIndex = (BYTE) (pjGlyph - pjGlyphIdArray);
                vCvtMacToUnicode((ULONG)pff->ffca.ui16LanguageID,pwc,&jIndex,1);

                return TRUE;
            }
        }

    // If we are here, this is an indication of a bug in the font file
    // (well, or possibly in my code [bodind])

        WARNING("TTFD!_bIndexToWchar invalid kerning index\n");
        return FALSE;
    }

// !!!
// !!! This code is NOT good, We have to get more performance
// !!!

    if( pff->ffca.ui16PlatformID == BE_PLAT_ID_MS &&
       (pff->ffca.iGlyphSet == GSET_TYPE_GENERAL_NOT_UNICODE ||
        pff->ffca.iGlyphSet == GSET_TYPE_HIGH_BYTE )
       )
    {
        UINT            ii,jj;
        PFD_GLYPHSET    pgset;

        if (bVertical)
            pgset = pff->pgsetv;
        else
            pgset = pff->pgset;

        for( ii = 0; ii < pgset->cRuns; ii++)
        {
            HGLYPH *phg = pgset->awcrun[ii].phg;
            USHORT cGlyphs = pgset->awcrun[ii].cGlyphs;

            for( jj = 0; jj < cGlyphs; jj++ )
            {
                if( phg[jj] == usIndex )
                {
                    *pwc = pgset->awcrun[ii].wcLow + jj;
                    return(TRUE);
                }
            }
        }
        return( FALSE );
    }

// !!! 17-May-1993 [GilmanW]
// !!! Why doesn't this code handle Format 6 (Trimmed table mapping)?  The
// !!! code below only handles Format 4.  Format 0 would be the Mac TT file
// !!! specific code above.

// If we get to this point, we know that this is an MSFT style TT file.

    ASSERTDD(pff->ffca.ui16PlatformID == BE_PLAT_ID_MS,
              "bIndexToWchar plat ID messed up\n");
    ASSERTDD(pmap->format == BE_FORMAT_MSFT_UNICODE,
              "bIndexToWchar cmap format for unicode table\n");

    cRuns = BE_UINT16((PBYTE)pmap + OFF_segCountX2) >> 1;

// Get the pointer to the beginning of the array of endCount code points

    pendCountStart = (uint16 *)((PBYTE)pmap + OFF_endCount);

// The final endCode has to be 0xffff; if this is not the case, there
// is a bug in the TT file or in our code:

    ASSERTDD(pendCountStart[cRuns - 1] == 0xFFFF,
              "bIndexToWchar pendCount[cRuns - 1] != 0xFFFF\n");

// Loop through the four paralel arrays (startCount, endCount, idDelta, and
// idRangeOffset) and find wc that usIndex corresponds to.  Each iteration
// scans a continuous range of Unicode characters supported by the TT font.
//
// To be Win3.1 compatible, we are looking for the LAST Unicode character
// that corresponds to usIndex.  So we scan all the arrays backwards,
// starting at the end of each of the arrays.
//
// Please note the following:
// For resons known only to the TT designers, startCount array does not
// begin immediately after the end of endCount array, i.e. at
// &pendCount[cRuns]. Instead, they insert an uint16 padding which has to
// set to zero and the startCount array begins after the padding. This
// padding in no way helps alignment of the structure.
//
// Here is the format of the arrays:
// ________________________________________________________________________________________
// | endCount[cRuns] | skip 1 | startCount[cRuns] | idDelta[cRuns] | idRangeOffset[cRuns] |
// |_________________|________|___________________|________________|______________________|

    // ASSERTDD(pendCountStart[cRuns] == 0, "TTFD!_bIndexToWchar, padding != 0\n");

    pendCount      = &pendCountStart[cRuns - 1];
    pstartCount    = &pendCount[cRuns + 1];   // add 1 because of padding
    pidDelta       = &pstartCount[cRuns];
    pidRangeOffset = &pidDelta[cRuns];

    for ( ;
         pendCount >= pendCountStart;
         pstartCount--, pendCount--,pidDelta--,pidRangeOffset--
        )
    {
        usLo          = BE_UINT16(pstartCount);     // current Unicode run
        usHi          = BE_UINT16(pendCount);       // [usLo, usHi], inclusive
        idDelta       = BE_UINT16(pidDelta);
        idRangeOffset = BE_UINT16(pidRangeOffset);

        ASSERTDD(usLo <= usHi, "bIndexToWChar: usLo > usHi\n");

    // Depending on idRangeOffset for the run, indexes are computed
    // differently.
    //
    // If idRangeOffset is zero, then index is the Unicode codepoint
    // plus the delta value.
    //
    // Otherwise, idRangeOffset specifies the BYTE offset of an array of
    // glyph indices (elements of which correspond to the Unicode range
    // [usLo, usHi], inclusive).  Actually, each element of the array is
    // the glyph index minus idDelta, so idDelta must be added in order
    // to derive the actual glyph indices from the array values.
    //
    // Notice that the delta arithmetic is always mod 65536.

        if (idRangeOffset == 0)
        {
        // Glyph index == Unicode codepoint + delta.
        //
        // If (usIndex-idDelta) is within the range [usLo, usHi], inclusive,
        // we have found the glyph index.  We'll overload usIndexBE
        // to be usIndex-idDelta == Unicode codepoint.

            usIndexBE = usIndex - idDelta;

            if ( (usIndexBE >= usLo) && (usIndexBE <= usHi) )
            {
                *pwc = (WCHAR) usIndexBE;

                return TRUE;
            }
        }
        else
        {
        // We are looking for usIndex in an array in which each element
        // is stored in big endian format.  Rather than convert each
        // element in the array to little endian, lets turn usIndex into
        // a big endian number.
        //
        // The idDelta is subtracted from usIndex before the conversion
        // because the values in the table we are searching are actually
        // the glyph indices minus idDelta.

            usIndexBE = usIndex - idDelta;
            usIndexBE = (uint16) ( (usIndexBE << 8) | (usIndexBE >> 8) );

        // Find the address of the glyph index array.  Since we're doing
        // pointer arithmetic with a uint16 ptr and idRangeOffset is a
        // BYTE offset, we need to divide idRangeOffset by sizeof(uint16).

            pidStart = pidRangeOffset + (idRangeOffset/sizeof(uint16));

            if (pidStart <= pusEnd) // this will always be the case except for buggy files
            {
            // Search the glyph index array backwards.  The range of the search
            // is [usLo, usHi], inclusive, which corresponds to pidStart[0]
            // through pidStart[usHi-usLo].

                for (pid = &pidStart[usHi - usLo]; pid >= pidStart; pid--)
                {
                    if ( usIndexBE == *pid )
                    {
                    // (pid-pidStart) == current offset into the glyph index
                    // array.  Glyph index array[0] corresponds to Unicode
                    // codepoint usLo.
                    // Therefore, (pid-pidStart)+usLo == current
                    // Unicode codepoint.

                        *pwc = (WCHAR) ((pid - pidStart) + usLo);

                        return TRUE;
                    }
                }
            }
        }
    }

    WARNING("TTFD!_bIndexToWchar: wonky TT file, index not found\n");
    return FALSE;
}

BOOL bIndexToWcharKern(FONTFILE *pff, WCHAR *pwc, uint16 usIndex, BOOL bVertical)
{
    BOOL bRet = bIndexToWchar(pff, pwc, usIndex, bVertical);

    if (bRet && (pff->ffca.fl & (FF_SPACE_EQUAL_NBSPACE|FF_HYPHEN_EQUAL_SFTHYPHEN)))
    {
        if ((*pwc == NBSPACE) && (pff->ffca.fl & FF_SPACE_EQUAL_NBSPACE))
        {
            *pwc = SPACE;
        }

        if ((*pwc == SFTHYPHEN) && (pff->ffca.fl & FF_HYPHEN_EQUAL_SFTHYPHEN))
        {
            *pwc = HYPHEN;
        }
    }

    return bRet;
}






/******************************Public*Routine******************************\
* cQueryKerningPairs                                                       *
*                                                                          *
*   Low level routine that pokes around inside the truetype font file      *
*   an gets the kerning pair data.                                         *
*                                                                          *
* Returns:                                                                 *
*                                                                          *
*   If pkp is NULL then return the number of kerning pairs in              *
*   the table If pkp is not NULL then return the number of                 *
*   kerning pairs copied to the buffer. In case of error,                  *
*   the return value is FD_ERROR.                                          *
*                                                                          *
* Called by:                                                               *
*                                                                          *
*   ttfdQueryFaceAttr                                                      *
*                                                                          *
* History:                                                                 *
*  Mon 17-Feb-1992 15:39:21 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

ULONG cQueryKerningPairs(FONTFILE *pff, ULONG cPairsInBuffer, FD_KERNINGPAIR *pkp, BOOL bVertical)
{
    FD_KERNINGPAIR *pkpTooFar;
    ULONG     cTables, cPairsInTable, cPairsRet;
    BYTE     *pj  =
            pff->ffca.tp.ateOpt[IT_OPT_KERN].dp                                ?
            ((BYTE *)pff->pvView +  pff->ffca.tp.ateOpt[IT_OPT_KERN].dp):
            NULL                                                          ;

    if (pj == (BYTE*) NULL)
    {
        return(0);
    }
    cTables  = BE_UINT16(pj+KERN_OFFSETOF_TABLE_NTABLES);
    pj      += KERN_SIZEOF_TABLE_HEADER;
    while (cTables)
    {
    //
    // if the subtable is of format KERN_WINDOWS_FORMAT then we can use it
    //
        if ((*(pj+KERN_OFFSETOF_SUBTABLE_FORMAT)) == KERN_WINDOWS_FORMAT)
        {
            break;
        }
        pj += BE_UINT16(pj+KERN_OFFSETOF_SUBTABLE_LENGTH);
        cTables -= 1;
    }

//
// If you have gone through all the tables and haven't
// found one of the format we like ... KERN_WINDOWS_FORMAT,
// then return no kerning info.
//
    if (cTables == 0)
    {
        return(0);
    }

    cPairsInTable = BE_UINT16(pj+KERN_OFFSETOF_SUBTABLE_NPAIRS);

    if (pkp == (FD_KERNINGPAIR*) NULL)
    {
    //
    // If the pointer to the buffer was null, then the caller
    // is asking for the number of pairs in the table. In this
    // case the size of the buffer must be zero. This assures
    // consistency
    //
        return (cPairsInBuffer ? FD_ERROR : cPairsInTable);
    }

    cPairsRet = min(cPairsInTable,cPairsInBuffer);

    pj       += KERN_SIZEOF_SUBTABLE_HEADER;
    pkpTooFar = pkp + cPairsRet;

    while (pkp < pkpTooFar)
    {
    // the routines that convert tt glyph index into a WCHAR only can fail
    // if there is a bug in the tt font file. but we check for this anyway

        if (!bIndexToWcharKern(
                 pff,
                 &pkp->wcFirst ,
                 (uint16)BE_UINT16(pj+KERN_OFFSETOF_ENTRY_LEFT),
                 bVertical
                )
            ||
            !bIndexToWcharKern(
                 pff,
                 &pkp->wcSecond,
                 (uint16)BE_UINT16(pj+KERN_OFFSETOF_ENTRY_RIGHT),
                 bVertical
                 )
           )
        {
            WARNING("TTFD!_bIndexToWchar failed\n");
            return (FD_ERROR);
        }

        pkp->fwdKern =  (FWORD)BE_UINT16(pj+KERN_OFFSETOF_ENTRY_VALUE);

    // update pointers

        pkp    += 1;
        pj     += KERN_SIZEOF_ENTRY;
    }

    return (cPairsRet);
}




/******************************Public*Routine******************************\
* pvHandleKerningPairs                                                     *
*                                                                          *
*   This routine sets up a DYNAMIC data structure to hold the kerning pair *
*   data and then calls cQueryKerning pairs to fill it up.  It also points *
*   *pid to the dynamic data structure.                                    *
*                                                                          *
* Returns:                                                                 *
*                                                                          *
*   If succesful this returns a pointer to the kerning pair data.  If not  *
*   it returns NULL.                                                       *
*                                                                          *
* Called by:                                                               *
*                                                                          *
*   ttfdQueryFontTree                                                      *
*                                                                          *
* History:                                                                 *
*  Tue 1-Mar-1994 10:39:21 by Gerrit van Wingerden [gerritv]               *
* Wrote it.                                                                *
\**************************************************************************/

VOID *pvHandleKerningPairs(HFF hff, ULONG_PTR *pid, BOOL bVertical)
{
    DYNAMICDATA *pdd;
    FS_ENTRY iRet;

// set *pid to NULL right now that way if we except the exception handler
// in the calling routine will know not to deallocate any memory

    *pid = (ULONG_PTR) NULL;


// ttfdFree must deal with the memory allocated for kerning pairs.
// We will pass a pointer to the DYNAMICDATA structure as the id.

    ASSERTDD (
        sizeof(ULONG_PTR) == sizeof(DYNAMICDATA *),
        "gdisrv!ttfdQueryFontTree(): "
        "BIG TROUBLE--pointers are not ULONG size\n"
        );

//
// Does the kerning pair array already exist?
//
    if ( PFF(hff)->pkp == (FD_KERNINGPAIR *) NULL )
    {
        ULONG   cKernPairs;     // number of kerning pairs in font
        FD_KERNINGPAIR *pkpEnd;

    // see if the file is mapped already, if not we will have to
    // map it in temporarily:

        if (PFF(hff)->cRef == 0)
        {
            //
            // have to remap the file.
            //

            PFF(hff)->pvView = PFF(hff)->pttc->pvView;
            PFF(hff)->cjView = PFF(hff)->pttc->cjView;
        }
    // Construct the kerning pairs array.
    // Determine number of kerning pairs in the font.

        if ( (cKernPairs = cQueryKerningPairs(PFF(hff), 0, (FD_KERNINGPAIR *) NULL, bVertical))
              == FD_ERROR )
        {
            return ((PVOID) NULL);
        }

    // make sure to mark the situation where SPACE and NBSPACE map to the same
    // glyph and also when HYPHEN and SFTHYPHEN map to the same glyph.

        if (cKernPairs &&
            (PFF(hff)->ffca.ui16PlatformID == BE_PLAT_ID_MS) &&
            (PFF(hff)->ffca.ui16SpecificID == BE_SPEC_ID_UGL) )
        {
            uint16 glyphIndex, glyphIndex2;
            fs_GlyphInputType *pgin = (fs_GlyphInputType *)PFF(hff)->pj034;
            fs_GlyphInputType gin;
            fs_GlyphInfoType  gout;
            // the size of this structure is sizeof(fs_SplineKey) + STAMPEXTRA.
            // It is because of STAMPEXTRA that we are not just putting the strucuture
            // on the stack such as fs_SplineKey sk; we do not want to overwrite the
            // stack at the bottom when putting a stamp in the STAMPEXTRA field.
            // [bodind]. The other way to obtain the correct alignment would be to use
            // union of fs_SplineKey and the array of bytes of length CJ_0.

            NATURAL            anat0[CJ_0 / sizeof(NATURAL)];

            uint8 *pCmap = (BYTE *)PFF(hff)->pvView +
                           PFF(hff)->ffca.dpMappingTable +
                           sizeof(sfnt_mappingTable);

            if (PFF(hff)->cRef == 0)
            {
                /* we need to initialize a gin for the TrueType rasterizer */
                if ((iRet = fs_OpenFonts(&gin, &gout)) != NO_ERR)
                {
                    return ((PVOID) NULL);
                }

                ASSERTDD(NATURAL_ALIGN(gout.memorySizes[0]) == CJ_0, "mem size 0\n");
                ASSERTDD(gout.memorySizes[1] == 0,  "mem size 1\n");

                gin.memoryBases[0] = (char *)anat0;
                gin.memoryBases[1] = NULL;
                gin.memoryBases[2] = NULL;

                // initialize the font scaler, notice no fields of gin are initialized [BodinD]

                if ((iRet = fs_Initialize(&gin, &gout)) != NO_ERR)
                {
                    return ((PVOID) NULL);
                }

                // initialize info needed by NewSfnt function

                gin.sfntDirectory  = (int32 *)PFF(hff)->pvView; // pointer to the top of the view of
                                               // the ttf file

                gin.clientID = (ULONG_PTR)PFF(hff);  // pointer to the top of the view of the ttf file

                gin.GetSfntFragmentPtr = pvGetPointerCallback;
                gin.ReleaseSfntFrag  = vReleasePointerCallback;

                gin.param.newsfnt.platformID = BE_UINT16(&PFF(hff)->ffca.ui16PlatformID);
                gin.param.newsfnt.specificID = BE_UINT16(&PFF(hff)->ffca.ui16SpecificID);

                if ((iRet = fs_NewSfnt(&gin, &gout)) != NO_ERR)
                {
                    return ((PVOID) NULL);
                }

                pgin = &gin;
            }
            ASSERTDD(pgin,"pvHandleKerningPairs(): pgin is NULL\n");

            iRet = fs_GetGlyphIDs(pgin, 1, SPACE, NULL, &glyphIndex);
            iRet = fs_GetGlyphIDs(pgin, 1, NBSPACE, NULL, &glyphIndex2);
            if (iRet == NO_ERR && (glyphIndex != 0 || glyphIndex2 != 0))
            {
                PFF(hff)->ffca.fl |= FF_SPACE_EQUAL_NBSPACE;
            }

            iRet = fs_GetGlyphIDs(pgin, 1, HYPHEN, NULL, &glyphIndex);
            iRet = fs_GetGlyphIDs(pgin, 1, SFTHYPHEN, NULL, &glyphIndex2);
            if (iRet == NO_ERR && (glyphIndex != 0 || glyphIndex2 != 0))
            {
                PFF(hff)->ffca.fl |= FF_HYPHEN_EQUAL_SFTHYPHEN;
            }
        }

    // Allocate memory for the kerning pair array.  Leave room to terminate
    // array with a zeroed FD_KERNINGPAIR structure.  Also, make room at
    // the beginning of the buffer for the DYNAMICDATA structure.
    //
    // Buffer:
    //
    //     __________________________________________________________
    //     |                 |                         |            |
    //     | DYNAMICDATA     | FD_KERNINPAIR array ... | Terminator |
    //     |_________________|_________________________|____________|
    //

        pdd =
            (DYNAMICDATA *)
            PV_ALLOC((cKernPairs + 1) * sizeof(FD_KERNINGPAIR) + sizeof(DYNAMICDATA));
        if (pdd == (DYNAMICDATA *) NULL)
        {
            return ((PVOID) NULL);
        }

    // Adjust kerning pair array pointer to point at the actual array.

        PFF(hff)->pkp = (FD_KERNINGPAIR *) (pdd + 1);

    // record to which font this data refers to:

        pdd->pff = PFF(hff); // important for consistency checking

    // set the data type

        pdd->ulDataType = ID_KERNPAIR;

    // set this here so that if we except the exception handler will know to
    // deallocate the data just allocated.

        *pid = (ULONG_PTR) pdd;

    // Fill in the array.

        if ( (cKernPairs = cQueryKerningPairs(PFF(hff), cKernPairs, PFF(hff)->pkp, bVertical))
             == FD_ERROR )
        {
        // Free kerning pair array.

            V_FREE(pdd);
            PFF(hff)->pkp = (FD_KERNINGPAIR *) NULL;
            return ((PVOID) NULL);
        }

    // Terminate the array.  (Terminating entry defined as an
    // FD_KERNINGPAIR with all fields set to zero).

        pkpEnd = PFF(hff)->pkp + cKernPairs;    // point to end of array
        pkpEnd->wcFirst  = 0;
        pkpEnd->wcSecond = 0;
        pkpEnd->fwdKern  = 0;
    }
    else
    {
        *pid = (ULONG_PTR) (((DYNAMICDATA*) PFF(hff)->pkp) - 1);
    }
//
// Return pointer to the kerning pair array.
//
    return ((PVOID) PFF(hff)->pkp);
}




/******************************Public*Routine******************************\
* ttfdQueryFontTree
*
* This function returns pointers to per-face information.
*
* Parameters:
*
*   dhpdev      Not used.
*
*   hff         Handle to a font file.
*
*   iFace       Index of a face in the font file.
*
*   iMode       This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFT_LIGATURES -- returns a pointer to the ligature map.
*
*       QFT_KERNPAIRS -- return a pointer to the kerning pair table.
*
*       QFT_GLYPHSET  -- return a pointer to the WC->HGLYPH mapping table.
*
*   pid         Used to identify data that ttfdFree will know how to deal
*               with it.
*
* Returns:
*   Returns a pointer to the requested data.  This data will not change
*   until BmfdFree is called on the pointer.  Caller must not attempt to
*   modify the data.  NULL is returned if an error occurs.
*
* History:
*  21-Oct-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PVOID ttfdQueryFontTree (
    DHPDEV  dhpdev,
    HFF     hff,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR *pid
    )
{
    PVOID pvRet;

    VOID vMarkFontGone(TTC_FONTFILE*, DWORD);

    HFF     hffTTC = hff;

    ASSERTDD(hff,"ttfdQueryFontTree(): invalid iFile (hff)\n");

    ASSERTDD(iFace <= PTTC(hff)->ulNumEntry,
             "gdisrv!ttfdQueryFontTree(): iFace out of range\n");

// get real hff from ttc array.

    hff   = PTTC(hffTTC)->ahffEntry[iFace-1].hff;
    iFace = PTTC(hffTTC)->ahffEntry[iFace-1].iFace;


    dhpdev;

    ASSERTDD(hff,"ttfdQueryFontTree(): invalid iFile (hff)\n");
    ASSERTDD(iFace <= PFF(hff)->ffca.ulNumFaces ,
             "ttfdQueryFaces(): iFace out of range\n");

//
// Which mode?
//
    switch (iMode)
    {
    case QFT_LIGATURES:
    //
    // !!! Ligatures not currently supported.
    //
    // There are no ligatures currently not supported,
    // therefore we return NULL.
    //
        *pid = (ULONG_PTR) NULL;

        return ((PVOID) NULL);

    case QFT_GLYPHSET:
    //
    // ttfdFree can ignore this because the glyph set will be deleted with
    // the FONTFILE structure.
    //
        *pid = (ULONG_PTR) NULL;

        if (!bReloadGlyphSet(PFF(hff), iFace))
        {
            return ((PVOID) NULL);
        }

        if (iFace == 1)
        {
            return( (PVOID) PFF(hff)->pgset );
        }
        else
        {
            ASSERTDD(PFF(hff)->pgsetv, " PFF(hff)->pgsetv should not be NULL \n");
            return( (PVOID) PFF(hff)->pgsetv );
        }

    case QFT_KERNPAIRS:

        pvRet = NULL;

        if (!bReloadGlyphSet(PFF(hff), iFace)) // inc ref counts if succeeded
        {
            return ((PVOID) NULL);
        }

        try
        {
        // make sure the file is still around

            if ((PTTC(hffTTC))->fl & FF_EXCEPTION_IN_PAGE_ERROR)
            {

                WARNING("ttfd, pvHandleKerningPairs(): file is gone\n");
            }
            else
            {
                pvRet = pvHandleKerningPairs (hff, pid, (iFace != 1));
            }

        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("TTFD!_ exception in ttfdQueryFontTree\n");

            vMarkFontGone((TTC_FONTFILE *)PTTC(hffTTC), GetExceptionCode());

        // possibly free memory that was allocated and reset the pkp pointer
        // to NULL

            ttfdFree( NULL, *pid );
        }

    // decrement ref counts

        vReleaseGlyphSet(PFF(hff), iFace);

        return pvRet;

    default:

    //
    // Should never get here.
    //
        RIP("gdisrv!ttfdQueryFontTree(): unknown iMode\n");
        return ((PVOID) NULL);
    }
}

VOID ttfdFreeGlyphset(
    HFF     hff,
    ULONG   iFace
    )
{
    HFF     hffTTC = hff;
    EngAcquireSemaphore(ghsemTTFD);

    ASSERTDD(hff,"ttfdQueryFontTree(): invalid iFile (hff)\n");

    ASSERTDD(iFace <= PTTC(hff)->ulNumEntry,
             "gdisrv!ttfdQueryFontTree(): iFace out of range\n");

// get real hff from ttc array.

    hff   = PTTC(hffTTC)->ahffEntry[iFace-1].hff;
    iFace = PTTC(hffTTC)->ahffEntry[iFace-1].iFace;

    vReleaseGlyphSet((PFONTFILE) hff, iFace);
    
    EngReleaseSemaphore(ghsemTTFD);

}

/******************************Public*Routine******************************\
*
* BOOL bGetGlyphOutline
*
* valid outline points are in pfc->gout after this call
*
* History:
*  19-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bGetGlyphOutline (
    FONTCONTEXT *pfc,
    HGLYPH       hg,
    ULONG       *pig,
    FLONG        fl,
    FS_ENTRY    *piRet
    )
{
// new glyph coming in or the metric has to be recomputed
// because the contents of the gin,gout strucs have been destroyed

    vInitGlyphState(&pfc->gstat);

    ASSERTDD((hg != HGLYPH_INVALID) && ((hg & (HGLYPH)0xFFFF0000) == 0),
              "ttfdQueryGlyphBitmap: hg\n");

    vCharacterCode(pfc->pff,hg,pfc->pgin);

// compute the glyph index from the character code:

    if ((*piRet = fs_NewGlyph(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(*piRet);
        RET_FALSE("TTFD!_bGetGlyphOutline, fs_NewGlyph\n");
    }

// return the glyph index corresponding to this hglyph:

    *pig = pfc->pgout->glyphIndex;

// these two field must be initialized before calling fs_ContourGridFit

    pfc->pgin->param.gridfit.styleFunc = 0; //!!! do some casts here

    pfc->pgin->param.gridfit.traceFunc = (FntTraceFunc)NULL;

// if bitmap is found for this glyph and if we are ultimately interested
// in bitmaps only and do not care about intermedieate outline, then set the
// bit in the "in" structure to hint the rasterizer that grid fitting
// will not be necessary:

    if (!IS_GRAY(pfc) && pfc->pgout->usBitmapFound && (fl & FL_SKIP_IF_BITMAP))
        pfc->pgin->param.gridfit.bSkipIfBitmap = 1;
    else
        pfc->pgin->param.gridfit.bSkipIfBitmap = 0; // must do hinting

// fs_ContourGridFit hints the glyph (executes the instructions for the glyph)
// and converts the glyph data from the tt file into an outline for this glyph

    if (!(fl & FL_FORCE_UNHINTED))
    {
        if ((*piRet = fs_NewContourGridFit(pfc->pgin, pfc->pgout)) != NO_ERR)
        {
            V_FSERROR(*piRet);
            RET_FALSE("TTFD!_bGetGlyphOutline, fs_NewContourGridFit\n");
        }
    }
    else // unhinted glyphs are desired
    {
        if ((*piRet = fs_ContourNoGridFit(pfc->pgin, pfc->pgout)) != NO_ERR)
        {
            V_FSERROR(*piRet);
            RET_FALSE("TTFD!_bGetGlyphOutline, fs_ContourNoGridFit\n");
        }
    }


#ifdef  DEBUG_OUTLINE
    vDbgGridFit(pfc->pgout);
#endif // DEBUG_OUTLINE

    return(TRUE);
}

/******************************Public*Routine******************************\
*
* b_fxA_and_fxAB_are_Ok:
* This function checks if the fxA and fxAB
* that are computed by linear scaling are big enough in the following sense:
*
* The bounding box of the background parallelogram for the glyph which
* is spanned by ptfxLeft, Right, Top, Bottom (as defined by the code below)
* must fully contain the glyph bitmap.
*
* Warnings: slow function, not executed often
*
* History:
*  13-Mar-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#if defined(_X86_)

VOID    ftoef_c(FLOATL, EFLOAT *);
#define vEToEF(e, pef)      ftoef_c((e), (pef))

#else // not X86

#define vEToEF(e, pef)      ( *(pef) = (e) )

#endif

// lExL is same as (LONG)(e*l), but do not want to use floating point
// math on pentium machines

LONG lExL(FLOATL e, LONG l)
{
    EFLOAT  ef;
    vEToEF(e, &ef);
    return lCvt(ef, l);
}

BOOL b_fxA_and_fxAB_are_Ok(
    FONTCONTEXT *pfc,
    GLYPHDATA   *pgldt,
    POINTL      *pptlOrigin,
    LONG         cx,
    LONG         cy
    )
{
    BOOL bRet = TRUE;
    POINTFIX ptfxLeft,ptfxRight, aptfx[4];
    LONG     xLeft, yTop, xRight, yBottom;
    INT      i;

    ptfxLeft.x   = lExL(pfc->pteUnitBase.x, pgldt->fxA);
    ptfxLeft.y   = lExL(pfc->pteUnitBase.y, pgldt->fxA);
    ptfxRight.x  = lExL(pfc->pteUnitBase.x, pgldt->fxAB);
    ptfxRight.y  = lExL(pfc->pteUnitBase.y, pgldt->fxAB);

// note that here we do not use fxInkTop and fxInkBottom
// for the individual glyph, instead we use global asc and desc,
// in parallel with G2 and G3 layout routines in the engine.
// We are adjusting fxA and fxAB so that the code for G2 and G3
// cases together with bOpaqueArea computes the bounding box of the text

    aptfx[0].x = ptfxLeft.x  + pfc->ptfxTop.x;
    aptfx[0].y = ptfxLeft.y  + pfc->ptfxTop.y;
    aptfx[1].x = ptfxRight.x + pfc->ptfxTop.x;
    aptfx[1].y = ptfxRight.y + pfc->ptfxTop.y;
    aptfx[2].x = ptfxRight.x + pfc->ptfxBottom.x;
    aptfx[2].y = ptfxRight.y + pfc->ptfxBottom.y;
    aptfx[3].x = ptfxLeft.x  + pfc->ptfxBottom.x;
    aptfx[3].y = ptfxLeft.y  + pfc->ptfxBottom.y;

// bound the paralelogram

    xLeft = xRight  = aptfx[0].x;
    yTop  = yBottom = aptfx[0].y;

    for (i = 1; i < 4; i++)
    {
        if (aptfx[i].x < xLeft)
            xLeft = aptfx[i].x;
        if (aptfx[i].x > xRight)
            xRight = aptfx[i].x;
        if (aptfx[i].y < yTop)
            yTop = aptfx[i].y;
        if (aptfx[i].y > yBottom)
            yBottom = aptfx[i].y;
    }

// Here we are following the prescription of the bOpaqueArea in textobj.cxx.
// We add a fudge factor of 1, 1/2 of the fuge factor in bOpaqueArea,
// and than check if glyph fits in the bounding rectangle.
// We add fudge factor in order to execute this function
// as few times as possible, but for glyph to still fit in the background
// rectangle computed by bOpaqueArea

    #define FUDGE 1

    xLeft   = FXTOLFLOOR(xLeft) - FUDGE;
    yTop    = FXTOLFLOOR(yTop)  - FUDGE;
    xRight  = FXTOLCEILING(xRight)  + FUDGE;
    yBottom = FXTOLCEILING(yBottom) + FUDGE;

// now check if glyph bitmap fits in the bounding rectangle, if not
// we need to augment fxA and fxAB and try again.

    if (xLeft > pptlOrigin->x)
        pptlOrigin->x = xLeft;

    if (yTop > pptlOrigin->y)
        pptlOrigin->y = yTop;

    if
    (
        (xRight  < (pptlOrigin->x + cx)) ||
        (yBottom < (pptlOrigin->y + cy))
    )
    {
    // this code path is executed very rarely, that is only
    // in case of really wierd transforms. Yet, because such
    // transforms exist and used to crash machines, we needed to add
    // this routine. That is, in most cases this routine will be called
    // only once in the loop to confirm that fxA and fxAB as computed
    // by linear scaling are fine. When they are not fine the routine
    // will be called again with new augmented values of fxA and fxAB.

    #ifdef DEBUG_FXA_FXAB
        TtfdDbgPrint("need to fix rcfxInkBox: %ld, %ld, %ld, %ld\n",
            xLeft,
            yTop,
            xRight,
            yBottom);
        TtfdDbgPrint("glyph cell            : %ld, %ld, %ld, %ld\n\n",
            pptlOrigin->x,
            pptlOrigin->y,
            pptlOrigin->x + cx,
            pptlOrigin->y + cy);
    #endif

        bRet = FALSE; // not big enough.
    }

    return bRet;
}



/******************************Public*Routine******************************\
*
* BOOL bGetGlyphMetrics
*
* History:
*  22-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bGetGlyphMetrics (
    PFONTCONTEXT pfc,
    HGLYPH       hg,
    FLONG        fl,
    FS_ENTRY    *piRet
    )
{
    ULONG  ig;
    FS_ENTRY i;

    if (!bGetGlyphOutline(pfc,hg,&ig,fl,piRet))
    {
        V_FSERROR(*piRet);
        RET_FALSE("TTFD!_bGetGlyphMetrics, bGetGlyphOutline failed \n");
    }

// get the metric info for this glyph,

    i = fs_FindBitMapSize(pfc->pgin, pfc->pgout);

    if (i != NO_ERR)
    {
        *piRet = i;
        V_FSERROR(*piRet);
        RET_FALSE("TTFD!_bGetGlyphMetrics, fs_FindBitMapSize \n");
    }


// now that everything is computed sucessfully, we can update
// glyphstate (hg data stored in pj3) and return

    pfc->gstat.hgLast = hg;
    pfc->gstat.igLast = ig;

    return(TRUE);
}


VOID vGetVertNotionalMetrics
(
FONTCONTEXT *pfc,       // in
ULONG        ig,        // in
SHORT        yMin,      // in, ngm.yMin
LONG         *plAH,     // out, advance height
LONG         *plTSB     // out, tsb
)
{
    ULONG cVMTX = pfc->pff->ffca.uLongVerticalMetrics;
    int16 sAH, sTSB;

    ASSERTDD(pfc->bVertical, "vGetVertNotionalMetrics, bVertical = 0\n");
    ASSERTDD(pfc->pgout->glyphIndex == ig, "vGetVertNotionalMetrics, ig wrong\n");

    if (cVMTX)  // the font has vmtx table
    {
        uint8 *pvmtx = (uint8*) pfc->pff->pvView +
                       pfc->pff->ffca.tp.ateOpt[IT_OPT_VMTX].dp;

        if (ig < cVMTX)
        {
            sAH  = SWAPW(*((int16 *)&pvmtx[ig*4]));
            sTSB = SWAPW(*((int16 *)&pvmtx[ig*4+2]));
        }
        else
        {
            int16 * psTSB = (int16 *) (&pvmtx[cVMTX * 4]); /* first entry after[AW,TSB] array */

            sAH  = SWAPW(*((int16 *)&pvmtx[(cVMTX-1)*4]));
            sTSB = SWAPW(psTSB[ig - cVMTX]);
        }
    }
    else // few buggy fonts do not have vmtx table
    {
    // default AdvanceHeight and TopSideBearing from Ascender and Descender

        sAH  = pfc->pff->ifi.fwdWinAscender + pfc->pff->ifi.fwdWinDescender;
        sTSB = pfc->pff->ifi.fwdWinAscender + yMin; // y points down!!!

    // at this point sTSB should be bigger than 0. But because of the bugs in
    // our fonts, mingliu.ttc etc, it turns out that there are glyphs that
    // have their tops significanly above the descender so sTSB becomes
    // negative, even though it should not be. So we hack it now:

        if (sTSB < 0)
            sTSB = 0;
    }

    *plAH  = sAH;
    *plTSB = sTSB;
}




/******************************Public*Routine******************************\
* VOID vFillGLYPHDATA
*
* History:
*  22-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vFillGLYPHDATA(
    HGLYPH            hg,
    ULONG             ig,
    FONTCONTEXT      *pfc,
    fs_GlyphInfoType *pgout,   // outputed from fsFind bitmap size
    GLYPHDATA        *pgldt,   // OUT
    GMC              *pgmc,    // optional, not used if doing outline only
    POINTL           *pptlOrigin
    )
{
    extern VOID vGetNotionalGlyphMetrics(FONTCONTEXT*, ULONG, NOT_GM*);

    BOOL bOutOfBounds = FALSE;

    vectorType     * pvtD;  // 16.16 point
    LONG lA,lAB;      // *pvtA rounded to the closest integer value

    BOOL bVert = pfc->bVertical && (pfc->ulControl & VERTICAL_MODE);

    ULONG  cx = (ULONG)(pgout->bitMapInfo.bounds.right - pgout->bitMapInfo.bounds.left);
    ULONG  cy = (ULONG)(pgout->bitMapInfo.bounds.bottom - pgout->bitMapInfo.bounds.top);

    LONG lAdvanceHeight;
    LONG lTopSideBearing;

    pgldt->gdf.pgb = NULL; // may get changed by the calling routine if bits requested too
    pgldt->hg = hg;

// fs_FindBitMapSize returned  the the following information in gout:
//
//  1) gout.metricInfo // left side bearing and advance width
//
//  2) gout.bitMapInfo // black box info
//
//  3) memory requirement for the bitmap,
//     returned in gout.memorySizes[5] and gout.memorySizes[6]
//
// Notice that fs_FindBitMapSize is exceptional scaler interface routine
// in that it returns info in several rather than in a single
// substructures of gout

// Check if hinting produced totally unreasonable result:

    bOutOfBounds = ( (pgout->bitMapInfo.bounds.left > pfc->xMax)    ||
                     (pgout->bitMapInfo.bounds.right < pfc->xMin)   ||
                     (-pgout->bitMapInfo.bounds.bottom > pfc->yMax) ||
                     (-pgout->bitMapInfo.bounds.top < pfc->yMin)    );

    #if DBG
        if (bOutOfBounds)
            TtfdDbgPrint("TTFD! Glyph out of bounds: ppem = %ld, gi = %ld\n",
                pfc->lEmHtDev, hg);
    #endif

out_of_bounds:

    if ((cx == 0) || (cy == 0) || bOutOfBounds)
    {
    // will be replaced by a a fake 1x1 bitmap

        pgldt->rclInk.left   = pfc->ptlSingularOrigin.x;
        pgldt->rclInk.top    = pfc->ptlSingularOrigin.y;
        pgldt->rclInk.right  = pgldt->rclInk.left + 1; // ink white for this glyph!
        pgldt->rclInk.bottom = pgldt->rclInk.top + 1;  // ink white for this glyph!

    // more of hackorama forced upon me by DaveC so that suppossedly
    // video drivers do not have to do a check on cx and cy.
    // By setting right = bottom = 1 for blank glyph we are slightly
    // incompatible with win31 in that they would return zero cx and cy
    // when calling GGO, as well as B space equal to 0 in GetCharABCWidths.
    // NT will return 1 for all of these quantities. I think we want to fix
    // our drivers for Cairo to be able to accept cx = cy = 0.

        if (pgmc != (PGMC)NULL)
        {
            pgmc->cxCor = 0;  // forces blank glyph case when filling the bits
            pgmc->cyCor = 0;  // forces blank glyph case when filling the bits
        }
    }
    else // non empty bitmap
    {
        lA = (LONG)pgout->bitMapInfo.bounds.left;
        lAB = lA + (LONG)cx;

    // black box info, we have to transform y coords to ifi specifications

        pgldt->rclInk.bottom = - pgout->bitMapInfo.bounds.top;
        pgldt->rclInk.top    = - pgout->bitMapInfo.bounds.bottom;

        if (pgmc != (PGMC)NULL)
        {
            LONG dyTop, dyBottom, dxLeft, dxRight;
            LONG dxError, dyError;

        #define MAXERROR 10

            dyTop    = (pgldt->rclInk.top < pfc->yMin) ?
                       (pfc->yMin - pgldt->rclInk.top) :
                       0;

            dyBottom = (pgldt->rclInk.bottom > pfc->yMax) ?
                       (pgldt->rclInk.bottom - pfc->yMax) :
                       0;

            if (dyTop || dyBottom)
            {
            // will have to chop off a few scans, infrequent

            #if DBG
                if ((LONG)cy < (dyTop + dyBottom))
                {
                    TtfdDbgPrint("TTFD!_dcy: ppem = %ld, gi = %ld, cy: %ld, dyTop: %ld, dyBottom: %ld\n",
                        pfc->lEmHtDev, hg, cy, dyTop,dyBottom);
                    EngDebugBreak();
                }
            #endif

                cy -= (dyTop + dyBottom);
                pgldt->rclInk.top += dyTop;
                pgldt->rclInk.bottom -= dyBottom;

                dyError = max(pfc->lEmHtDev, MAXERROR);
                if ((dyTop > dyError) || (dyBottom > dyError))
                {
                // something is really bogus, let us bail out:

                    bOutOfBounds = TRUE;
                    goto out_of_bounds;
                }
            }

        // let us see how good is scaling with appropriate rounding
        // to determine xMin and xMax:

            dxLeft = dxRight = 0;
            if (lA < pfc->xMin)
                dxLeft = pfc->xMin - lA;
            if (lAB > pfc->xMax)
                dxRight = lAB - pfc->xMax;

            if (dxLeft || dxRight)
            {
            #if DBG
                TtfdDbgPrint("TTFD! ppem = %ld"
                  ", gi = %ld,  dxLeft: %ld, dxRight: %ld\n"
                  , pfc->lEmHtDev, hg, dxLeft,dxRight
                );
                if ((LONG)cx  < (dxLeft + dxRight))
                {
                    TtfdDbgPrint(
                        "TTFD!_dcx: ppem = %ld, gi = %ld, cx: %ld"
                        ", dxLeft: %ld, dxRight: %ld\n",
                        pfc->lEmHtDev, hg, cx, dxLeft, dxRight);
                    EngDebugBreak();
                }
            #endif // DBG

                cx  -= (dxLeft + dxRight);
                lA  += dxLeft;
                lAB -= dxRight;

                dxError = (LONG)max((pfc->cxMax/4),MAXERROR);
                if ((dxLeft > dxError) || (dxRight > dxError))
                {
                // something is really bogus, let us bail out:

                    bOutOfBounds = TRUE;
                    goto out_of_bounds;
                }
            }
            ASSERTDD(cx <= pfc->cxMax, "cx > cxMax\n");

            pgmc->dyTop    = (ULONG)dyTop   ;
            pgmc->dyBottom = (ULONG)dyBottom;
            pgmc->dxLeft   = (ULONG)dxLeft  ;
            pgmc->dxRight  = (ULONG)dxRight ;
            pgmc->cxCor    = cx;
            pgmc->cyCor    = cy;

        // only corrected values have to obey this condition:

            ASSERTDD(
                pfc->flFontType & FO_CHOSE_DEPTH,"Depth Not Chosen Yet!\n");
            ASSERTDD(
                CJGD(pgmc->cxCor,pgmc->cyCor,pfc) <= pfc->cjGlyphMax,
                "ttfdQueryGlyphBitmap, cjGlyphMax \n"
                );
        }

    // x coords do not transform, just shift them

        pgldt->rclInk.left = lA;
        pgldt->rclInk.right = lAB;

    } // end of the non empty bitmap clause

// go on to compute the positioning info:
    pvtD = & pgout->metricInfo.devAdvanceWidth;

    if (pfc->flXform & XFORM_HORIZ)  // scaling only
    {
        FIX fxTmp;

    // We shall lie to the engine and store integer
    // pre and post bearings and char inc vectors because
    // win31 also rounds, but we should not round for nondiag xforms


    // bGetFastAdvanceWidth returns the same aw that would get
    // computed by bQueryAdvanceWidths and propagated to an api
    // level through GetTextExtent and GetCharWidths. We have to
    // fill in the same aw for consistency reasons.
    // This also has to be done for win31 compatibility.

        if (bVert)
        {
            lAdvanceHeight = F16_16TOLROUND(pgout->verticalMetricInfo.devAdvanceHeight.y);

            pgldt->fxD = LTOFX(lAdvanceHeight);

            /* metrics from the rasterizer are already adjusted for embolding simulation */
        }
        else
        {
            if (!bGetFastAdvanceWidth(pfc,ig, &pgldt->fxD))
            {
            // not possible to get the fast value, use the "slow" value
            // supplied by the rasterizer.

                pgldt->fxD = F16_16TOLROUND(pvtD->x);
                pgldt->fxD = LTOFX(pgldt->fxD);
            } else {
                USHORT cxExtra = (pfc->flFontType & FO_SIM_BOLD) ? (1 << 4) : 0; /* for backwards compatibility reason, we inclease the width only by one pixel */
                if (pgldt->fxD != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
                {
                    if (pfc->mx.transform[0][0] < 0)
                    {
                        pgldt->fxD -= cxExtra;
                    } 
                    else 
                    {
                        pgldt->fxD += cxExtra;
                    }
                }
            }
        #ifdef DEBUG_AW

        // this should alsmost never happen, one example when it does
        // is Lucida Sans Unicode at 14 pt, glyph 'a', try from winword
        // the possible source of discrepancy is a bug in hdmx or ltsh
        // tables or a loss of precission in some of mult. math routines

            else
            {
                fxTmp = F16_16TOLROUND(pvtD->x);
                fxTmp = LTOFX(fxTmp);
                if (fxTmp != pgldt->fxD)
                {
                // print out a warning

                    fxTmp -= pgldt->fxD;
                    if (fxTmp < 0)
                        fxTmp = - fxTmp;

                    if (fxTmp > 16)
                    {
                        TtfdDbgPrint("ttfd! fxDSlow = 0x%lx\n", pgldt->fxD);
                    }
                }
            }

        #endif // DEBUG_AW

        }
        pgldt->ptqD.x.HighPart = (LONG)pgldt->fxD;
        pgldt->ptqD.x.LowPart  = 0;

        if (pfc->mx.transform[0][0] < 0)
            pgldt->fxD = - pgldt->fxD;  // this is an absolute value

    // make CharInc.y zero even if the rasterizer messed up

        pgldt->ptqD.y.HighPart = 0;
        pgldt->ptqD.y.LowPart  = 0;

#if DBG
        // if (pvtD->y) {TtfdDbgPrint("TTFD!_ pvtD->y = 0x%lx\n", pvtD->y);}
#endif

        if (bVert)
        {
            LONG lWidthOfBitmap = pgldt->rclInk.right-pgldt->rclInk.left;

            lTopSideBearing = F16_16TOLROUND(pgout->verticalMetricInfo.devTopSideBearing.x);

            if(pfc->mx.transform[0][0] < 0)
            {
                lTopSideBearing = - lTopSideBearing - lWidthOfBitmap;
                pgldt->rclInk.right = -lTopSideBearing;
                pgldt->rclInk.left = pgldt->rclInk.right - lWidthOfBitmap;
            }
            else
            {
                pgldt->rclInk.left = lTopSideBearing;
                pgldt->rclInk.right = pgldt->rclInk.left + lWidthOfBitmap;
            }

            pgldt->fxA = LTOFX(lTopSideBearing);
            pgldt->fxAB = LTOFX(lWidthOfBitmap) + pgldt->fxA;

        }
        else
        {
            pgldt->fxA = LTOFX(pgldt->rclInk.left);
            pgldt->fxAB = LTOFX(pgldt->rclInk.right);

            if (pfc->mx.transform[0][0] < 0)
            {
                fxTmp = pgldt->fxA;
                pgldt->fxA = -pgldt->fxAB;
                pgldt->fxAB = -fxTmp;
            }
        }


    // - is used here since ascender points in the negative y direction

        pgldt->fxInkTop    = -LTOFX(pgldt->rclInk.top);
        pgldt->fxInkBottom = -LTOFX(pgldt->rclInk.bottom);

        if (pfc->mx.transform[1][1] < 0)
        {
            fxTmp = pgldt->fxInkTop;
            pgldt->fxInkTop = -pgldt->fxInkBottom;
            pgldt->fxInkBottom = -fxTmp;
        }
    }
    else // non trivial information
    {
    // here we will just xform the notional space data:

        NOT_GM ngm;  // notional glyph data
        USHORT cxExtra = (pfc->flFontType & FO_SIM_BOLD) ? (1 << 4) : 0; /* for backwards compatibility reason, we increase the width only by one pixel */

        vGetNotionalGlyphMetrics(pfc,ig,&ngm);

    // xforms are computed by simple multiplication

        pgldt->fxD         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sD);

        if (pfc->flXform & XFORM_VERT)
        {
            if (bVert)
            {
                LONG lHeightOfBox;

                lAdvanceHeight = F16_16TOLROUND(pgout->verticalMetricInfo.devAdvanceHeight.x);
                lTopSideBearing = F16_16TOLROUND(pgout->verticalMetricInfo.devTopSideBearing.y);
                lHeightOfBox = pgldt->rclInk.bottom - pgldt->rclInk.top;

                if( pfc->mx.transform[0][1] < 0 )
                {
                    lTopSideBearing = -lTopSideBearing;
                    pgldt->rclInk.top = lTopSideBearing;
                    pgldt->rclInk.bottom = pgldt->rclInk.top + lHeightOfBox;
                }
                else
                {
                    lTopSideBearing = lTopSideBearing - lHeightOfBox;
                    pgldt->rclInk.bottom = -lTopSideBearing;
                    pgldt->rclInk.top = pgldt->rclInk.bottom - lHeightOfBox;

                    lAdvanceHeight = - lAdvanceHeight; // this is an absolute value
                }

                pgldt->fxD = LTOFX(lAdvanceHeight);
                pgldt->ptqD.x.LowPart  = 0;
                pgldt->ptqD.x.HighPart = 0;
                pgldt->ptqD.y.LowPart  = 0;

                /* metrics from the rasterizer are already adjusted for embolding simulation */
            }
            else
            {

                pgldt->fxD = FXTOLROUND(pgldt->fxD);
                pgldt->fxD = LTOFX(pgldt->fxD);

                pgldt->ptqD.x.LowPart  = 0;
                pgldt->ptqD.x.HighPart = 0;
                pgldt->ptqD.y.LowPart  = 0;

                /* adjust for embolding simulation */
                if (pgldt->fxD != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
                    pgldt->fxD += cxExtra;
            }

            if (IS_FLOATL_MINUS(pfc->pteUnitBase.y)) // base.y < 0
            {
                pgldt->fxA  = -LTOFX(pgldt->rclInk.bottom);
                pgldt->fxAB = -LTOFX(pgldt->rclInk.top);
                pgldt->ptqD.y.HighPart = -(LONG)pgldt->fxD;
            }
            else
            {
                pgldt->fxA  = LTOFX(pgldt->rclInk.top);
                pgldt->fxAB = LTOFX(pgldt->rclInk.bottom);
                pgldt->ptqD.y.HighPart = (LONG)pgldt->fxD;
            }

            if (IS_FLOATL_MINUS(pfc->pteUnitSide.x)) // asc.x < 0
            {
                pgldt->fxInkTop    = -LTOFX(pgldt->rclInk.left);
                pgldt->fxInkBottom = -LTOFX(pgldt->rclInk.right);
            }
            else
            {
                pgldt->fxInkTop    = LTOFX(pgldt->rclInk.right);
                pgldt->fxInkBottom = LTOFX(pgldt->rclInk.left);
            }
        }
        else // most general case, totally arb. xform.
        {
            POINTL         ptlOrigin;

            if (bVert)
            {
                vGetVertNotionalMetrics(pfc, ig, ngm.yMin, &lAdvanceHeight, &lTopSideBearing);

                vLTimesVtfl(lAdvanceHeight, &pfc->vtflBase, &pgldt->ptqD);

                pgldt->fxD = fxLTimesEf(&pfc->efBase, lAdvanceHeight);

                ptlOrigin.x =  F16_16TOLROUND(pgout->metricInfo.devLeftSideBearing.x);
                ptlOrigin.y = -F16_16TOLROUND(pgout->metricInfo.devLeftSideBearing.y);

                pgldt->fxA         = fxLTimesEf(&pfc->efBase, lTopSideBearing);
                pgldt->fxAB        = fxLTimesEf(&pfc->efBase, (LONG)ngm.yMax - (LONG)ngm.yMin + lTopSideBearing);

                pgldt->fxInkTop    = - fxLTimesEf(&pfc->efSide, (LONG)ngm.xMax);
                pgldt->fxInkBottom = - fxLTimesEf(&pfc->efSide, (LONG)ngm.xMin);

            }
            else
            {
                vLTimesVtfl((LONG)ngm.sD, &pfc->vtflBase, &pgldt->ptqD);


                ptlOrigin.x =  F16_16TOLROUND(pgout->metricInfo.devLeftSideBearing.x);
                ptlOrigin.y = -F16_16TOLROUND(pgout->metricInfo.devLeftSideBearing.y);

                pgldt->fxA         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sA);
                pgldt->fxAB        = fxLTimesEf(&pfc->efBase, (LONG)ngm.xMax);

                pgldt->fxInkTop    = - fxLTimesEf(&pfc->efSide, (LONG)ngm.yMin);
                pgldt->fxInkBottom = - fxLTimesEf(&pfc->efSide, (LONG)ngm.yMax);

            }

            if (pfc->flFontType & FO_SIM_BOLD) 
            {

                if ((pgldt->ptqD.x.HighPart != 0) || (pgldt->ptqD.y.HighPart != 0)) /* we don't increase the width of a zero width glyph, problem with indic script */
                {
                        vAddPOINTQF(&pgldt->ptqD,&pfc->ptqUnitBase);
                    pgldt->fxD += LTOFX(1);
                }
	// the emboldening is done by dBase but the advance width is increased only by one pixel
                pgldt->fxAB += LTOFX(pfc->dBase);
            }

            // just to be safe let us round these up and down appropriately

            #define ROUND_DOWN(X) ((X) & ~0xf)
            #define ROUND_UP(X)   (((X) + 15) & ~0xf)

            pgldt->fxA         = ROUND_DOWN(pgldt->fxA);
            pgldt->fxAB        = ROUND_UP(pgldt->fxAB);

            pgldt->fxInkTop    = ROUND_UP(pgldt->fxInkTop);
            pgldt->fxInkBottom = ROUND_DOWN(pgldt->fxInkBottom);

            if (pgmc && pgmc->cxCor && pgmc->cyCor)
            {
                int iCutoff = 0;
                while (!b_fxA_and_fxAB_are_Ok(
                                   pfc,
                                   pgldt,
                                   &ptlOrigin,
                                   (LONG)pgmc->cxCor,
                                   (LONG)pgmc->cyCor) && (iCutoff++ < 2000))
                {
                    pgldt->fxA  -= 16;
                    pgldt->fxAB += 16;

                    if ((pgldt->fxInkTop + 16) < LTOFX(pfc->lAscDev))
                        pgldt->fxInkTop += 16;
                    if ((pgldt->fxInkBottom - 16) > -LTOFX(pfc->lDescDev))
                        pgldt->fxInkTop -= 16;
                }
            }

            if (pptlOrigin)
                *pptlOrigin = ptlOrigin;

        }

    }

    // If the caller requests a minimal bitmap and the bitmap or the
    // corrected bimap has a zero extent in any dimension then
    // the font driver will replace the original bitmap by a
    // phony 1 x 1 blank bitmap. See lGetGlyphBitmap near
    // the code  "pgb->sizlBitmap.cx = 1".

    if ((cx == 0 || cy == 0) ||
        (pgmc && (pgmc->cxCor == 0 || pgmc->cyCor == 0)))
    {
        pgldt->fxA           = 0;
        pgldt->fxAB          = 16;
        pgldt->fxInkTop      = 0;
        pgldt->fxInkBottom   = 16;
        pgldt->rclInk.left   = 0;
        pgldt->rclInk.top    = 0;
        pgldt->rclInk.right  = 1;
        pgldt->rclInk.bottom = 1;
    }

}


/******************************Public*Routine******************************\
*
* ttfdQueryTrueTypeTable
*
* copies cjBytes starting at dpStart from the beginning of the table
* into the buffer
*
* if pjBuf == NULL or cjBuf == 0, the caller is asking how big a buffer
* is needed to store the info from the offset dpStart to the table
* specified by ulTag to the end of the table
*
* if pjBuf != 0  the caller wants no more than cjBuf bytes from
* the offset dpStart into the table copied into the
* buffer.
*
* if table is not present or if dpScart >= cjTable 0 is returned
*
* tag 0 means that the data has to be retrieved from the offset dpStart
* from the beginning of the file. The lenght of the whole file
* is returned if pBuf == nULL
*
* History:
*  09-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


PBYTE pjTable(ULONG ulTag, PFONTFILE pff, ULONG *pcjTable);

LONG ttfdQueryTrueTypeTable2 (
    HFF     hff,
    ULONG   ulFont,  // always 1 for version 1.0 of tt
    ULONG   ulTag,   // tag identifying the tt table
    PTRDIFF dpStart, // offset into the table
    ULONG   cjBuf,   // size of the buffer to retrieve the table into
    BYTE   *pjBuf,   // ptr to buffer into which to return the data
    PBYTE  *ppjTable,// ptr to table in the mapped file
    ULONG  *pcjTable // size of the whole table
    )
{
    PBYTE     pjBegin;  // ptr to the beginning of the table
    LONG      cjTable;
    HFF       hffTTC = hff;

    ASSERTDD(hff, "ttfdQueryTrueTypeTable\n");

    if (dpStart < 0)
        return (FD_ERROR);

// if this font file is gone we are not gonna be able to answer any questions
// about it

    if (PTTC(hffTTC)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
        WARNING("ttfd, ttfdQueryTrueTypeTable: file is gone\n");
        return FD_ERROR;
    }

    ASSERTDD(ulFont <= PTTC(hffTTC)->ulNumEntry,
             "gdisrv!ttfdQueryFaces(): iFace out of range\n"
             );

// get real hff from ttc array.

    hff    = PTTC(hffTTC)->ahffEntry[ulFont-1].hff;
    ulFont = PTTC(hffTTC)->ahffEntry[ulFont-1].iFace;

    ASSERTDD(ulFont <= PFF(hff)->ffca.ulNumFaces,
             "TTFD!_ttfdQueryTrueTypeTable: ulFont != 1\n");

// verify the tag, determine whether this is a required or an optional
// table:

#define tag_TTCF  0x66637474    // 'ttcf'

    if(ulTag == tag_TTCF)
    {
    // if the table offset is 0 it can't be a TTC and we should fail.

        if(PFF(hff)->ffca.ulTableOffset)
        {
            pjBegin = (PBYTE)PFF(hff)->pvView;
            cjTable = PFF(hff)->cjView;
        }
        else
        {
            return(FD_ERROR);
        }
    }
    else
    if (ulTag == 0)  // requesting the whole file
    {
        pjBegin = (PBYTE)PFF(hff)->pvView + PFF(hff)->ffca.ulTableOffset;
        cjTable = PFF(hff)->cjView - PFF(hff)->ffca.ulTableOffset; // cjView == cjFile
    }
    else // some specific table is requested
    {
        pjBegin = pjTable(ulTag, PFF(hff), &cjTable);

        if (pjBegin == (PBYTE)NULL)  // table not present
            return (FD_ERROR);
    }

// if we are succesfull now is the time to return
// the pointer to the whole table in the file and its size:

    if (ppjTable)
    {
        *ppjTable = pjBegin;
    }
    if (pcjTable)
    {
        *pcjTable = cjTable;
    }

// adjust pjBegin to point to location from where the data is to be copied

    pjBegin += dpStart;
    cjTable -= (LONG)dpStart;

    if (cjTable <= 0) // dpStart offsets into mem after the end of table
        return (FD_ERROR);

    if ( (pjBuf == (PBYTE)NULL) || (cjBuf == 0) )
    {
    // the caller is asking how big a buffer it needs to allocate to
    // store the bytes from the offset dpStart into the table to
    // the end of the table (or file if tag is zero)

        return (cjTable);
    }

// at this point we know that pjBuf != 0, the caller wants cjBuf bytes copied
// into his buffer:

    if ((ULONG)cjTable > cjBuf)
        cjTable = (LONG)cjBuf;

    RtlCopyMemory((PVOID)pjBuf, (PVOID)pjBegin, cjTable);

    return (cjTable);
}



LONG
ttfdQueryTrueTypeTable (
    HFF     hff,
    ULONG   ulFont,  // always 1 for version 1.0 of tt
    ULONG   ulTag,   // tag identifying the tt table
    PTRDIFF dpStart, // offset into the table
    ULONG   cjBuf,   // size of the buffer to retrieve the table into
    BYTE   *pjBuf,   // ptr to buffer into which to return the data
    PBYTE  *ppjTable,// pointer in the file
    ULONG  *pcjTable // size of the whole table
    )
{
    LONG lRet;
    HFF hffTTF;

    // update the HFF with the remapped view

    hffTTF   = PTTC(hff)->ahffEntry[ulFont-1].hff;

    if (PFF(hffTTF)->cRef == 0)
    {

        PFF(hffTTF)->pvView = PTTC(hff)->pvView;
        PFF(hffTTF)->cjView = PTTC(hff)->cjView;
    }

    lRet = ttfdQueryTrueTypeTable2(
               hff, ulFont, ulTag, dpStart,
               cjBuf, pjBuf, ppjTable, pcjTable);

    return lRet;
}




/******************************Public*Routine******************************\
*
* ttfdGetTrueTypeFile
*
*  private entry point for the engine, supported only off of ttfd to expose
*  the pointer to the memory mapped file to the device drivers
*
* History:
*  04-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID *ttfdGetTrueTypeFile( HFF hff, ULONG *pcj )
{
    PVOID pvView = NULL; // essential to initialize
    *pcj  = 0;

    ASSERTDD(hff, "ttfdGetTrueTypeFile, hff\n");

    if (PTTC(hff)->cRef)
    {
        pvView = PTTC(hff)->pvView;
        *pcj   = PTTC(hff)->cjView;
    }
    return (pvView);
}


/******************************Public*Routine******************************\
* ttfdQueryGlyphAttrs
*
* Get glyph attributes
*
\**************************************************************************/

PFD_GLYPHATTR  ttfdQueryGlyphAttrs (
    FONTOBJ *pfo,
    ULONG   iMode
    )
{

    FONTCONTEXT *pfc;

    ASSERTDD(pfo->iFile, "ttfdQueryGlyphAttrs, pfo->iFile\n");

    if (((TTC_FONTFILE *)pfo->iFile)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
        WARNING("ttfd, ttfdQueryGlyphAttrs: file is gone\n");
        return NULL;
    }

// If pfo->pvProducer is NULL, then we need to open a font context.

    if ( pfo->pvProducer == (PVOID) NULL )
    {
        pfo->pvProducer = pfc = ttfdOpenFontContext(pfo);
    }
    else
    {
        pfc = (FONTCONTEXT*) pfo->pvProducer;
    }

    if (pfc == (FONTCONTEXT *) NULL)
    {
        WARNING("gdisrv!ttfdQueryGlyphAttrs(): cannot create font context\n");
        return NULL;
    }

    return pfc->pff->pttc->pga;
}


/******************************Public*Routine******************************\
* ttfdQueryFontFile
*
* A function to query per font file information.
*
* Parameters:
*
*   hff         Handle to a font file.
*
*   ulMode      This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFF_DESCRIPTION -- copies a UNICODE string in the buffer
*                          that describes the contents of the font file.
*
*       QFF_NUMFACES   -- returns number of faces in the font file.
*
*   cjBuf       Maximum number of BYTEs to copy into the buffer.  The
*               driver will not copy more than this many BYTEs.
*
*               This should be zero if pulBuf is NULL.
*
*               This parameter is not used in QFF_NUMFACES mode.
*
*   pulBuf      Pointer to the buffer to receive the data
*               If this is NULL, then the required buffer size
*               is returned as a count of BYTEs.  Notice that this
*               is a PULONG, to enforce 32-bit data alignment.
*
*               This parameter is not used in QFF_NUMFACES mode.
*
* Returns:
*
*   If mode is QFF_DESCRIPTION, then the number of BYTEs copied into
*   the buffer is returned by the function.  If pulBuf is NULL,
*   then the required buffer size (as a count of BYTEs) is returned.
*
*   If mode is QFF_NUMFACES, then number of faces in font file is returned.
*
*   FD_ERROR is returned if an error occurs.
*
* History:
*  22-Oct-1992 -by- Gilman Wong [gilmanw]
* Added QFF_NUMFACES mode (IFI/DDI merge).
*
*  09-Mar-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LONG ttfdQueryFontFile (
    HFF     hff,        // handle to font file
    ULONG   ulMode,     // type of query
    ULONG   cjBuf,      // size of buffer (in BYTEs)
    ULONG  *pulBuf      // return buffer (NULL if requesting size of data)
    )
{
    PIFIMETRICS pifi;

    ASSERTDD(hff != HFF_INVALID, "ttfdQueryFontFile(): invalid HFF\n");

    switch (ulMode)
    {
      case QFF_DESCRIPTION:
      {
          ULONG ulIndex;
          LPWSTR  pwszDesc = (LPWSTR)pulBuf;
          LONG  lBuffer = 0;

          for( ulIndex = 0;
              ulIndex < PTTC(hff)->ulNumEntry;
              ulIndex++
              )
          {
              LONG wchlen;

          // if this is a entry for vertical face font, just skip it...

              if( !((PTTC(hff)->ahffEntry[ulIndex].iFace) & 0x1) )
                continue;

              pifi = &((PFF(PTTC(hff)->ahffEntry[ulIndex].hff))->ifi);

              wchlen = (LONG)(pifi->dpwszStyleName - pifi->dpwszFaceName) / sizeof(WCHAR);

              if (ulIndex != 0)
              {
                  if (pwszDesc != (LPWSTR) NULL)
                  {
                      wcscpy((LPWSTR)pwszDesc, (LPWSTR) L" & ");
                      pwszDesc += 3;
                  }
                  lBuffer += (3 * sizeof(WCHAR));
              }

              if (pwszDesc != (LPWSTR) NULL)
              {
                  wcscpy((LPWSTR)pwszDesc, (LPWSTR)((PBYTE)pifi + pifi->dpwszFaceName));
                  pwszDesc += (wchlen-2); // -2 for overwrite NULL at next time.
              }
              lBuffer += (wchlen * sizeof(WCHAR));
          }

          return( lBuffer );
      }

    case QFF_NUMFACES:
    //
    // Currently, only one face per TrueType file.  This may one day change!
    //

      return (PTTC(hff))->ulNumEntry;

    default:
        WARNING("ttfd!ttfdQueryFontFile(): invalid mode\n");
        return FD_ERROR;
    }
}


/******************************Public*Routine******************************\
*
* vCopyAndZeroOutPaddingBits
*
* copies the bits of the bitmap and zeroes out padding bits
*
* History:
*  18-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

// array of masks for the last byte in a row

static BYTE gjMask[8] = {0XFF, 0X80, 0XC0, 0XE0, 0XF0, 0XF8, 0XFC, 0XFE };
static BYTE gjMaskHighBit[8] = {0XFF, 0X01, 0X03, 0X07, 0X0F, 0X1F, 0X3F, 0X7F};

VOID vCopyAndZeroOutPaddingBits(
    FONTCONTEXT *pfc,
    GLYPHBITS   *pgb,
    BYTE        *pjSrc,
    GMC         *pgmc
    )
{
    BYTE   jMask = gjMask[pgmc->cxCor & 7];
    ULONG  cjScanSrc = CJ_TT_SCAN(pgmc->cxCor+pgmc->dxLeft+pgmc->dxRight,pfc);
    ULONG  cxDst = pgmc->cxCor;
    ULONG  cjScanDst = CJ_MONOCHROME_SCAN(cxDst);      // includes emboldening if any
    ULONG  cjDst = CJ_MONOCHROME_SCAN(pgmc->cxCor);    // does not include emboldening
    BYTE   *pjScan, *pjScanEnd;
    ULONG  iByteLast = cjDst - 1;

// sanity checks

    ASSERTDD(!IS_GRAY(pfc),"Monochrome Images Only Please!\n");
    ASSERTDD(pfc->flFontType & FO_CHOSE_DEPTH,
        "We haven't decided about pixel depth\n"
    );
    ASSERTDD(pgmc->cxCor < LONG_MAX, "TTFD!vCopyAndZeroOutPaddingBits, cxCor\n");
    ASSERTDD(pgmc->cyCor < LONG_MAX, "TTFD!vCopyAndZeroOutPaddingBits, cyCor\n");
    ASSERTDD(pgmc->cxCor > 0, "vCopyAndZeroOutPaddingBits, cxCor == 0\n");
    ASSERTDD(pgmc->cyCor > 0, "vCopyAndZeroOutPaddingBits, cyCor == 0\n");

    pgb->sizlBitmap.cx = cxDst;

    pgb->sizlBitmap.cy = pgmc->cyCor;

// skip the rows at the top that we want to chop off

    if (pgmc->dyTop)
    {
        pjSrc += (pgmc->dyTop * cjScanSrc);
    }

// if must chop off a few columns (on the right, this should almost
// never happen), put the warning for now to detect these
// situations and look at them, it does not matter if this is slow

    pjScan = pgb->aj;


    if ((pgmc->dxLeft & 7) == 0) // common fast case
    {
        pjSrc += (pgmc->dxLeft >> 3); // adjust the source
        for (
             pjScanEnd = pjScan + (pgmc->cyCor * cjScanDst);
             pjScan < pjScanEnd;
             pjScan += cjScanDst, pjSrc += cjScanSrc
            )
        {
            RtlCopyMemory((PVOID)pjScan,(PVOID)pjSrc,cjDst);
            pjScan[iByteLast] &= jMask; // mask off the last byte
        }
    }
    else // must shave off from the left:
    {
        BYTE   *pjD, *pjS, *pjDEnd, *pjSrcEnd;
        ULONG   iShiftL, iShiftR;

        iShiftL = pgmc->dxLeft & 7;
        iShiftR = 8 - iShiftL;

        pjSrcEnd = pjSrc + (pgmc->cyCor * cjScanSrc);
        pjSrc += (pgmc->dxLeft >> 3); // adjust the source
        for (
             pjScanEnd = pjScan + (pgmc->cyCor * cjScanDst);
             pjScan < pjScanEnd;
             pjScan += cjScanDst, pjSrc += cjScanSrc
            )
        {
            pjS = pjSrc;
            pjD = pjScan;
            pjDEnd = pjD + iByteLast;

        // the last byte has to be done outside the loop

            for (;pjD < pjDEnd; pjD++)  // loop for the bytes in the middle
            {
                *pjD  = (*pjS << iShiftL);
                pjS++;
                *pjD |= (*pjS >> iShiftR);
            }

        // do the last byte outside of the loop

            *pjD  = (*pjS << iShiftL);
            if (++pjS < pjSrcEnd)
                *pjD |= (*pjS >> iShiftR);

            *pjD &= jMask; // mask off the last byte
        }
    }

}


/******************************Public*Routine******************************\
* vGetNotionalGlyphMetrics
*
*
\**************************************************************************/

// be values for the format of the indexToLocation table

#define BE_ITOLOCF_SHORT   0X0000
#define BE_ITOLOCF_LONG    0X0100

// offsets to the non scaled glyphdata

#define OFF_nc    0
#define OFF_xMin  2
#define OFF_yMin  4
#define OFF_xMax  6
#define OFF_yMax  8


VOID vGetNotionalGlyphMetrics(
    FONTCONTEXT *pfc,  // IN
    ULONG        ig,   // IN , glyph index
    NOT_GM      *pngm  // OUT, notional glyph metrics
    )
{
    sfnt_FontHeader        * phead;
    sfnt_HorizontalHeader  * phhea;
    sfnt_HorizontalMetrics * phmtx;
    PBYTE                    pjGlyph;
    PBYTE                    pjLoca;
    ULONG                    numberOf_LongHorMetrics;
    BYTE                   * pjView = pfc->pff->pvView;

#if DBG
    sfnt_maxProfileTable   * pmaxp;
    ULONG                    cig;

    pmaxp = (sfnt_maxProfileTable *)(pjView + pfc->ptp->ateReq[IT_REQ_MAXP].dp);
    cig = BE_UINT16(&pmaxp->numGlyphs) + 1;
    ASSERTDD(ig < cig, "ig >= numGlyphs\n");
#endif

// compute the relevant pointers:

    phead = (sfnt_FontHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HEAD].dp);
    phhea = (sfnt_HorizontalHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HHEAD].dp);
    phmtx = (sfnt_HorizontalMetrics *)(pjView + pfc->ptp->ateReq[IT_REQ_HMTX].dp);
    pjGlyph = pjView + pfc->ptp->ateReq[IT_REQ_GLYPH].dp;
    pjLoca  = pjView + pfc->ptp->ateReq[IT_REQ_LOCA].dp;
    numberOf_LongHorMetrics = BE_UINT16(&phhea->numberOf_LongHorMetrics);

// get the pointer to the beginning of the glyphdata for this glyph
// if short format, offset divided by 2 is stored in the table, if long format,
// the actual offset is stored. Offsets are measured from the beginning
// of the glyph data table, i.e. from pjGlyph

    switch (phead->indexToLocFormat)
    {
    case BE_ITOLOCF_SHORT:
        pjGlyph += 2 * BE_UINT16(pjLoca + (sizeof(uint16) * ig));
        break;

    case BE_ITOLOCF_LONG :
        pjGlyph += BE_UINT32(pjLoca + (sizeof(uint32) * ig));
        break;

    default:
        RIP("TTFD!_illegal phead->indexToLocFormat\n");
        break;
    }

// get the bounds, flip y

    pngm->xMin = BE_INT16(pjGlyph + OFF_xMin);
    pngm->xMax = BE_INT16(pjGlyph + OFF_xMax);
    pngm->yMin = - BE_INT16(pjGlyph + OFF_yMax);
    pngm->yMax = - BE_INT16(pjGlyph + OFF_yMin);

// get the adwance width and the lsb
// the piece of code stolen from the rasterizer [bodind]

    if (ig < numberOf_LongHorMetrics)
    {
        pngm->sD = BE_INT16(&phmtx[ig].advanceWidth);
        pngm->sA = BE_INT16(&phmtx[ig].leftSideBearing);
    }
    else
    {
    // first entry after[AW,LSB] array

        int16 * psA = (int16 *) &phmtx[numberOf_LongHorMetrics];

        pngm->sD = BE_INT16(&phmtx[numberOf_LongHorMetrics-1].advanceWidth);
        pngm->sA = BE_INT16(&psA[ig - numberOf_LongHorMetrics]);
    }

// redefine x coords so that they correspond to being measured relative to
// the real character origin

    pngm->xMax = pngm->xMax - pngm->xMin + pngm->sA;
    pngm->xMin = pngm->sA;

    if (pfc->flFontType & FO_SIM_ITALIC)
    {
    // IF there is italic simulation A,B,C spaces change

        pngm->sA   -= (SHORT)FixMul(pngm->yMax, FX_SIN20);
        pngm->xMax -= (SHORT)FixMul(pngm->yMin, FX_SIN20);
    }
}

LONG lFFF(LONG l);
#define FFF(e,l) *(LONG*)(&(e)) = lFFF(l)

/******************************Public*Routine******************************\
* lQueryDEVICEMETRICS
*
* History:
*  08-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG lQueryDEVICEMETRICS (
         FONTCONTEXT *pfc,
               ULONG  cjBuffer,
    FD_DEVICEMETRICS *pdevm
    )
{
    sfnt_FontHeader *phead;

    LONG  lULThickness,
          lSOThickness,
          lStrikeoutPosition,
          lUnderscorePosition,
          lTotalLeading;

    BYTE *pjView =  (BYTE *)pfc->pff->pvView;

    PBYTE pjOS2 = (pfc->pff->ffca.tp.ateOpt[IT_OPT_OS2].dp)         ?
                  (pjView + pfc->pff->ffca.tp.ateOpt[IT_OPT_OS2].dp):
                  NULL                                         ;

   Fixed fxXScale = pfc->mx.transform[0][0];
   if (fxXScale < 0)
       fxXScale = - fxXScale;

// actually requesting the data

    ASSERTDD (
        sizeof(FD_DEVICEMETRICS) <= cjBuffer,
        "FD_QUERY_DEVICEMETRICS: buffer too small\n");

// get the pointers to needed tables in the tt file

    phead = (sfnt_FontHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HEAD].dp);

// first store precomputed quantities

    pdevm->pteBase = pfc->pteUnitBase;
    pdevm->pteSide = pfc->pteUnitSide;
    pdevm->cxMax = pfc->cxMax;

    pdevm->fxMaxAscender  = LTOFX(pfc->lAscDev);
    pdevm->fxMaxDescender = LTOFX(pfc->lDescDev);

// get the notional space values for the strike out and underline quantities:

    lSOThickness        = (LONG)pfc->pff->ifi.fwdStrikeoutSize;
    lStrikeoutPosition  = (LONG)pfc->pff->ifi.fwdStrikeoutPosition;

    lULThickness        = (LONG)pfc->pff->ifi.fwdUnderscoreSize;
    lUnderscorePosition = (LONG)pfc->pff->ifi.fwdUnderscorePosition;

// compute the accelerator flags for this font

    pdevm->flRealizedType = 0;

    pdevm->lD = 0;

// things interesting for private user apis:

    if (pfc->flXform & XFORM_MAX_NEG_AC_HACK)
    {
        pdevm->lMinA = 0;
        pdevm->lMinC = 0;
    }
    else
    {
        pdevm->lMinA = (LONG)pfc->pff->ffca.sMinA;
        pdevm->lMinC = (LONG)pfc->pff->ffca.sMinC;
    }

    if (pfc->flFontType & FO_SIM_ITALIC)
    {
    // need to fix lMinA and lMinC

        LONG              yMinN, yMaxN;

        if (pjOS2 && (pfc->flXform & (XFORM_HORIZ | XFORM_VERT)))
        {
        // win 31 compatibility: we only take the max over win 31 char set.
        // All the glyphs outside this set, if they stand out will get shaved
        // off to match the height of the win31 char subset. Also notice that
        // for nonhorizontal cases we do not use os2 values because shaving
        // only applies to horizontal case, otherwise our bounding box values
        // will not be computed properly for nonhorizontal cases.

            yMinN =  - BE_INT16(pjOS2 + OFF_OS2_usWinAscent);
            yMaxN =    BE_INT16(pjOS2 + OFF_OS2_usWinDescent);
        }
        else
        {
            yMinN = - BE_INT16(&phead->yMax);
            yMaxN = - BE_INT16(&phead->yMin);
        }

        ASSERTDD(yMinN < yMaxN, "yMinN >= yMaxN\n");

        // IF there is italic simulation
        //     xMin -> xMin - yMaxN * sin20
        //     xMax -> yMax - yMinN * sin20

        pdevm->lMinA -= FixMul(yMaxN, FX_SIN20);
        pdevm->lMinC += FixMul(yMinN, FX_SIN20);
    }

    pdevm->lMinD = (LONG)pfc->pff->ffca.usMinD;

    if (pfc->flXform & XFORM_HORIZ)
    {
        Fixed fxYScale = pfc->mx.transform[1][1];

    // strike out and underline size:

        lULThickness *= fxYScale;
        lULThickness = F16_16TOLROUND(lULThickness);
        if (lULThickness == 0)
            lULThickness = (fxYScale > 0) ? 1 : -1;

        pdevm->ptlULThickness.x = 0;
        pdevm->ptlULThickness.y = lULThickness;

        lSOThickness *= fxYScale;
        lSOThickness = F16_16TOLROUND(lSOThickness);
        if (lSOThickness == 0)
            lSOThickness = (fxYScale > 0) ? 1 : -1;

        pdevm->ptlSOThickness.x = 0;
        pdevm->ptlSOThickness.y = lSOThickness;

    // strike out and underline position

        lStrikeoutPosition *= fxYScale;
        pdevm->ptlStrikeOut.y = -F16_16TOLROUND(lStrikeoutPosition);

        lUnderscorePosition *= fxYScale;
        pdevm->ptlUnderline1.y = -F16_16TOLROUND(lUnderscorePosition);

        pdevm->ptlUnderline1.x = 0L;
        pdevm->ptlStrikeOut.x  = 0L;

    // things needed for private a user api:

        pdevm->lMinA = F16_16TOLROUND(fxXScale * pdevm->lMinA);
        pdevm->lMinC = F16_16TOLROUND(fxXScale * pdevm->lMinC);
        pdevm->lMinD = F16_16TOLROUND(fxXScale * pdevm->lMinD);
    }
    else // nontrivial transform
    {
        POINTL   aptl[4];
        POINTFIX aptfx[4];
        BOOL     b;

        pdevm->lD = 0;

    // xform so and ul vectors

        aptl[0].x = 0;
        aptl[0].y = lSOThickness;

        aptl[1].x = 0;
        aptl[1].y = -lStrikeoutPosition;

        aptl[2].x = 0;
        aptl[2].y = lULThickness;

        aptl[3].x = 0;
        aptl[3].y = -lUnderscorePosition;

        // !!! [GilmanW] 27-Oct-1992
        // !!! Should change over to engine user object helper functions
        // !!! instead of the fontmath.cxx functions.

        b = bFDXform(&pfc->xfm, aptfx, aptl, 4);
        if (!b) {RIP("TTFD!_bFDXform, fd_query.c\n");}

        pdevm->ptlSOThickness.x = FXTOLROUND(aptfx[0].x);
        pdevm->ptlSOThickness.y = FXTOLROUND(aptfx[0].y);

        pdevm->ptlStrikeOut.x = FXTOLROUND(aptfx[1].x);
        pdevm->ptlStrikeOut.y = FXTOLROUND(aptfx[1].y);

        pdevm->ptlULThickness.x = FXTOLROUND(aptfx[2].x);
        pdevm->ptlULThickness.y = FXTOLROUND(aptfx[2].y);

        pdevm->ptlUnderline1.x = FXTOLROUND(aptfx[3].x);
        pdevm->ptlUnderline1.y = FXTOLROUND(aptfx[3].y);

        if ((pfc->flXform & XFORM_VERT) &&
            ((pdevm->ptlSOThickness.x == 0) || (pdevm->ptlULThickness.x == 0)))
        {
            Fixed fxXScale = pfc->mx.transform[1][0];

            if (pdevm->ptlSOThickness.x == 0)
            {
                pdevm->ptlSOThickness.x = (fxXScale > 0) ? -1 : 1;
            }
            
            if (pdevm->ptlULThickness.x == 0)
            {
                pdevm->ptlULThickness.x = (fxXScale > 0) ? -1 : 1;
            }
        }

    // things needed for private a user api:

        pdevm->lMinA = FXTOLROUND(fxLTimesEf(&pfc->efBase, pdevm->lMinA));
        pdevm->lMinC = FXTOLROUND(fxLTimesEf(&pfc->efBase, pdevm->lMinC));
        pdevm->lMinD = FXTOLROUND(fxLTimesEf(&pfc->efBase, pdevm->lMinD));
    }

// Compute the device metrics.
// HACK ALLERT, overwrite the result if the transformation
// to be really used has changed as a result of "vdmx" quantization.
// Not a hack any more, this is even documented now in DDI spec:

    if (pfc->flXform & (XFORM_HORIZ | XFORM_2PPEM))
    {
        FFF(pdevm->fdxQuantized.eXX, pfc->mx.transform[0][0]);
        FFF(pdevm->fdxQuantized.eYY, pfc->mx.transform[1][1]);

        if (!(pfc->flXform & XFORM_HORIZ))
        {
            FFF(pdevm->fdxQuantized.eXY,-pfc->mx.transform[0][1]);
            FFF(pdevm->fdxQuantized.eYX,-pfc->mx.transform[1][0]);
        }
    }

// finally we have to do nonlinear external leading for type 1 conversions

    if (pfc->pff->ffca.fl & FF_TYPE_1_CONVERSION)
    {
        LONG lPtSize = F16_16TOLROUND(pfc->fxPtSize);

        LONG lIntLeading = pfc->lAscDev + pfc->lDescDev - pfc->lEmHtDev;

    // I need this, PS driver does it and so does makepfm utility.

        if (lIntLeading < 0)
            lIntLeading = 0;

        switch (pfc->pff->ifi.jWinPitchAndFamily & 0xf0)
        {
        case FF_ROMAN:

            lTotalLeading = (pfc->sizLogResPpi.cy + 18) / 32;  // 2 pt leading;
            break;

        case FF_SWISS:

            if (lPtSize <= 12)
                lTotalLeading = (pfc->sizLogResPpi.cy + 18) / 32;  // 2 pt
            if (lPtSize < 14)
                lTotalLeading = (pfc->sizLogResPpi.cy + 12) / 24;  // 3 pt
            else
                lTotalLeading = (pfc->sizLogResPpi.cy + 9) / 18;   // 4 pt
            break;

        default:

        // use 19.6% of the Em height for leading, do not do any rounding.

            lTotalLeading = (pfc->lEmHtDev * 196) / 1000;
            break;
        }

        pdevm->lNonLinearExtLeading = (lTotalLeading - lIntLeading) << 4; // TO 28.4
        if (pdevm->lNonLinearExtLeading < 0)
            pdevm->lNonLinearExtLeading = 0;
    }

// for emboldened fonts MaxCharWidth and AveCharWidth can not be computed
// by linear scaling. These nonlinarly transformed values we will store in
// pdevm->lNonLinearMaxCharWidth // max and pdevm->lNonLinearAvgCharWidth // avg.

    if (pfc->flFontType & FO_SIM_BOLD)
    {

         if (pfc->flXform & XFORM_HORIZ)
        {
        // notice +1 we are adding: this is the nonlinearity we are talking about

            pdevm->lNonLinearMaxCharWidth = fxXScale * (LONG)pfc->pff->ifi.fwdMaxCharInc;
            pdevm->lNonLinearMaxCharWidth = F16_16TO28_4(pdevm->lNonLinearMaxCharWidth) + (1 << 4);

            pdevm->lNonLinearAvgCharWidth = fxXScale * ((LONG)pfc->pff->ifi.fwdAveCharWidth);
            pdevm->lNonLinearAvgCharWidth = F16_16TO28_4(pdevm->lNonLinearAvgCharWidth) + (1 << 4);
        }
        else // nontrivial transform
        {
            pdevm->lNonLinearMaxCharWidth =
                fxLTimesEf(&pfc->efBase, (LONG)pfc->pff->ifi.fwdMaxCharInc) + (1 << 4);

            pdevm->lNonLinearAvgCharWidth =
                fxLTimesEf(&pfc->efBase, (LONG)pfc->pff->ifi.fwdAveCharWidth) + (1 << 4);
        }
    }

// add new fields:


// If singular transform, the TrueType driver will provide a blank
// 1x1 bitmap.  This is so device drivers will not have to implement
// special case code to handle singular transforms.

    if ( pfc->flXform & XFORM_SINGULAR )
    {
        ASSERTDD(pfc->flFontType & FO_CHOSE_DEPTH,"Depth Not Chosen Yet!\n");
        pdevm->cyMax      = 1;
        pdevm->cjGlyphMax = (CJGD(1,1,pfc));
    }
    else // Otherwise, the max glyph size is cached in the FONTCONTEXT.
    {
        pdevm->cyMax      = pfc->yMax - pfc->yMin;
        pdevm->cjGlyphMax = pfc->cjGlyphMax;
    }

// we are outa here

    return sizeof(FD_DEVICEMETRICS);
}



/******************************Public*Routine******************************\
* ttfdQueryFontData
*
*   dhpdev      Not used.
*
*   pfo         Pointer to a FONTOBJ.
*
*   iMode       This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFD_GLYPH           -- return glyph metrics only
*
*       QFD_GLYPHANDBITMAP  -- return glyph metrics and bitmap
*
*       QFD_GLYPHANDOUTLINE -- return glyph metrics and outline
*
*       QFD_MAXEXTENTS      -- return FD_DEVICEMETRICS structure
*
*   pgd        Buffer to hold glyphdata structure, if any
*
*   pv         Output buffer to hold glyphbits or pathobj, if any.
*
* Returns:
*
*   Otherwise, returns the size of the glyphbits
*
*   FD_ERROR is returned if an error occurs.
*
* History:
*  31-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LONG ttfdQueryFontData (
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    )
{
extern LONG lGetSingularGlyphBitmap(FONTCONTEXT*, HGLYPH, GLYPHDATA*, PVOID);
extern STATIC LONG lQueryDEVICEMETRICS(FONTCONTEXT*, ULONG, FD_DEVICEMETRICS*);
extern LONG ttfdGlyphBitmap(FONTCONTEXT*, HGLYPH, GLYPHDATA*, VOID*, ULONG);
extern LONG lGetGlyphBitmapErrRecover(FONTCONTEXT*, HGLYPH, GLYPHDATA*, PVOID);
extern LONG lGetGlyphBitmap(FONTCONTEXT*, HGLYPH, GLYPHDATA*, PVOID, FS_ENTRY*);
extern BOOL ttfdQueryGlyphOutline(FONTCONTEXT*, HGLYPH, GLYPHDATA*, PATHOBJ*);

// declare the locals

    PFONTCONTEXT pfc;
    USHORT usOverScale;
    LONG cj = 0, cjDataRet = 0;

    cjSize; // bizzare, why is this passed in ? [bodind]

// if this font file is gone we are not gonna be able to answer any questions
// about it

    ASSERTDD(pfo->iFile, "ttfdQueryFontData, pfo->iFile\n");

    if (((TTC_FONTFILE *)pfo->iFile)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
        WARNING("ttfd, ttfdQueryFontData(): file is gone\n");
        return FD_ERROR;
    }

// If pfo->pvProducer is NULL, then we need to open a font context.

    if ( pfo->pvProducer == (PVOID) NULL )
    {
        pfo->pvProducer = pfc = ttfdOpenFontContext(pfo);
    }
    else
    {
        pfc = (FONTCONTEXT*) pfo->pvProducer;
        pfc->flFontType = (pfc->flFontType & FO_CHOSE_DEPTH) | pfo->flFontType;
    }

    if ( pfc == (FONTCONTEXT *) NULL )
    {
        WARNING("gdisrv!ttfdQueryFontData(): cannot create font context\n");
        return FD_ERROR;
    }

    pfc->pfo = pfo;

    switch ( iMode )
    {
        case QFD_TT_GRAY1_BITMAP: // monochrome

            usOverScale = 0;  /// !!! 0 for monochrome
            break;

        case QFD_TT_GRAY2_BITMAP: // one byte per pixel: 0..4

            usOverScale = 2;
            break;

        case QFD_TT_GRAY4_BITMAP: // one byte per pixel: 0..16

            usOverScale = 4;
            break;

        case QFD_TT_GRAY8_BITMAP: // one byte per pixel: 0..64

            usOverScale = 8;
            break;

        default:
            if (IS_GRAY(pfc) && !(pfc->flFontType & FO_CLEARTYPE_X))
            {
                usOverScale = 4;
            }
            else
            {
                usOverScale = 0;
            }
            break;
    }

// call fs_NewTransformation if needed:
    {
        BOOL bClearType = FALSE;
        BOOL bBitmapEmboldening = FALSE;

        if ( (pfc->flFontType & FO_SIM_BOLD) &&
            (pfc->flXform & (XFORM_HORIZ | XFORM_VERT)) &&
            (iMode != QFD_GLYPHANDOUTLINE))
        {
            /* for backwards compatibility and to get better bitmaps at screen resolution, we are doing
               bitmap emboldening simulation (as opposed to outline emboldening simulation) if we are
               emboldening only by one pixel and we are under no rotation or 90 degree rotation and not asking for path */
            bBitmapEmboldening = TRUE;
        }

        switch ( iMode )
        {
        case QFD_TT_GRAY1_BITMAP: // monochrome
        case QFD_TT_GRAY2_BITMAP: // one byte per pixel: 0..4
        case QFD_TT_GRAY4_BITMAP: // one byte per pixel: 0..16
        case QFD_TT_GRAY8_BITMAP: // one byte per pixel: 0..64
            bClearType = FALSE;
            break;
        default:	// We use tri-mode bClearType
        	if((pfc->flFontType & FO_CLEARTYPE_X) == FO_CLEARTYPE_X){
	        	if((pfc->flFontType & FO_CLEARTYPENATURAL_X) == FO_CLEARTYPENATURAL_X)
	        		bClearType = -1;	
	        	else
	        		bClearType = TRUE;
        	}
            break;
        }

        if (!bGrabXform(
                pfc,
                usOverScale,
                bBitmapEmboldening,
                bClearType
                ))
        {
            RETURN("gdisrv!ttfd  bGrabXform failed\n", FD_ERROR);
        }
    }

    switch ( iMode )
    {
    case QFD_TT_GRAY1_BITMAP: // monochrome
    case QFD_TT_GRAY2_BITMAP: // one byte per pixel: 0..4
    case QFD_TT_GRAY4_BITMAP: // one byte per pixel: 0..16
    case QFD_TT_GRAY8_BITMAP: // one byte per pixel: 0..64

         return( ttfdGlyphBitmap( pfc, hg, pgd, pv, cjSize) );
         break;

    case QFD_GLYPHANDBITMAP:
    case QFD_TT_GLYPHANDBITMAP:
        {
        // Engine should not be querying on the HGLYPH_INVALID.

            ASSERTDD (
                hg != HGLYPH_INVALID,
                "ttfdQueryFontData(QFD_GLYPHANDBITMAP): HGLYPH_INVALID \n"
                );

        // If singular transform, the TrueType driver will provide a blank
        // 1x1 bitmap.  This is so device drivers will not have to implement
        // special case code to handle singular transforms.
        //
        // So depending on the transform type, choose a function to retrieve
        // bitmaps.

            if (pfc->flXform & XFORM_SINGULAR)
            {
                cj = lGetSingularGlyphBitmap(pfc, hg, pgd, pv);
            }
            else
            {
                FS_ENTRY iRet;

                if ( pfc->bVertical )
                {
                    cj = lGetGlyphBitmapVertical( pfc, hg, pgd, pv, &iRet);
                }
                else
                {
                    cj = lGetGlyphBitmap(pfc,
                                         hg,
                                         pgd,
                                         pv,
                                         &iRet);
                }

                if ((cj == FD_ERROR) && (iRet == POINT_MIGRATION_ERR))
                {
                // this is buggy glyph where hinting has so severly distorted
                // the glyph that one of the points went out of range.
                // We will just return a blank glyph but with correct
                // abcd info. That way only that buggy glyph will not be printed
                // correctly, the rest will of glyphs will.
                // More importantly, if psciprt driver tries to
                // download this font, the download operation will not fail just because
                // one glyph in a font is buggy. [BodinD]

                    cj = lGetGlyphBitmapErrRecover(pfc, hg, pgd, pv);
                }
            }

        #if DBG
            if (cj == FD_ERROR)
            {
                WARNING("ttfdQueryFontData(QFD_GLYPHANDBITMAP): get bitmap failed\n");
            }
        #endif
        }
        return cj;

    case QFD_GLYPHANDOUTLINE:

        ASSERTDD (
            hg != HGLYPH_INVALID,
            "ttfdQueryFontData(QFD_GLYPHANDOUTLINE): HGLYPH_INVALID \n"
            );

        if (!ttfdQueryGlyphOutline(pfc, hg, pgd, (PATHOBJ *) pv))
        {
            WARNING("ttfdQueryFontData(QFD_GLYPHANDOUTLINE): failed to get outline\n");
            return FD_ERROR;
        }
        return sizeof(GLYPHDATA);

    case QFD_MAXEXTENTS:

        return lQueryDEVICEMETRICS(
                   pfc,
                   sizeof(FD_DEVICEMETRICS),
                   (FD_DEVICEMETRICS *) pv
                   );


    default:

        WARNING("gdisrv!ttfdQueryFontData(): unsupported mode\n");
        return FD_ERROR;
    }
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   ttfdGlyphBitmap
*
* Routine Description:
*
* Arguments:
*
* Routines called:
*
*   EngSetLastError
*   lGGOBitmap
*
* Called by:
*
*   ttfdQueryFontData
*
* Return Value:
*
*   If pv is zero then then return the size of the required buffer
*   in bytes. If pv is not zero, then return the number of bytes
*   copied to the buffer. An error is indicated by a return value
*   of FD_ERROR.
*
\**************************************************************************/

LONG ttfdGlyphBitmap(
    FONTCONTEXT *pfc,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    VOID       *pv,
    ULONG       cjSize
    )
{
    extern LONG lGGOBitmap(FONTCONTEXT*,HGLYPH,GLYPHDATA*,VOID*,unsigned);

    LONG lRet;

    // RIP("ttfdGlypBitmap\n");

    lRet = 0;
    if ( hg == HGLYPH_INVALID )
    {
        WARNING( "ttfdGlyphBitamp -- invalid hg\n" );
        EngSetLastError( ERROR_INVALID_PARAMETER );
        lRet = FD_ERROR;
    }
    else
    {
        if (lRet != FD_ERROR)
        {
            if (pfc->bVertical)
            {
                if (IsFullWidthCharacter(pfc->pff, hg))
                {

                    lRet = FD_ERROR;
                    if (bChangeXform(pfc, TRUE))
                    {
                        pfc->ulControl |= VERTICAL_MODE;
                        pfc->hgSave = hg;
                        lRet = ~FD_ERROR;
                    }
                }
            }
            if (lRet != FD_ERROR)
            {
                lRet = lGGOBitmap(pfc, hg, pgd, pv, cjSize);
                if (pfc->ulControl & VERTICAL_MODE)
                {
                    pfc->ulControl &= ~VERTICAL_MODE;
                    if (!bChangeXform(pfc, FALSE))
                    {
                        lRet = FD_ERROR;
                    }
                }
            }
        }
    }
    return( lRet );
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   lGGOBitmap
*
* Routine Description:
*
*   For returning bitmaps in the format as required by GetGlyphOutline
*
* Routines called:
*
*   EngSetLastError
*   vCharacterCode
*   fs_NewGlyph
*   fs_FindBitmapSize
*   fs_FindGraySize
*   pvSetMemoryBases
*   V_FREE
*
* Arguments:
*
* Return Value:
*
*   if (pv == 0)
*       <return the size of buffer needed to receive the bitmap>;
*   else
*       <return the number of bytes written to the recieving buffer>;
*
\**************************************************************************/

LONG lGGOBitmap(
    FONTCONTEXT *pfc,
    HGLYPH       hg,
    GLYPHDATA   *pgd,
    VOID        *pv,
    unsigned     cjSize
    )
{

  LONG lRet;                                    // returned to caller
  ULONG iError;                                 // for EngSetLastError
  ULONG ig;                                     // index of glyph (fs_NewGlyph)
  BitMap *pbm;                                  // pointer into fs_ structure
  Rect   *pRect;                                // pointer into fs_ structure
  fs_GlyphInputType *pin  = pfc->pgin;          // used a lot
  fs_GlyphInfoType  *pout = pfc->pgout;         // used a lot
  int isMonochrome = ( pfc->overScale == 0 );       // TRUE iff monochrome glyph
  FS_ENTRY     iRet;

  // RIP("lGGOBitmap\n");

  iError = NO_ERROR;                            // keep going until this changes
  vInitGlyphState( &pfc->gstat );               // invalidate cache
  vCharacterCode( pfc->pff, hg, pin );          // translate the glyph handle
  if ((iRet = fs_NewGlyph(pin, pout)) != NO_ERR )       // inform the rasterizer of new glyph
  {                                             // rasterizer not happy, get out
    V_FSERROR(iRet);
    WARNING("lGGOBitmap -- fs_NewGlyph failed\n");
    iError = ERROR_CAN_NOT_COMPLETE;
  }
  else
  {
    ig = pfc->pgout->glyphIndex;
    pin->param.gridfit.styleFunc = 0;
    pin->param.gridfit.traceFunc = 0;

    pin->param.gridfit.bSkipIfBitmap = FALSE; // if embedded bitmap then no hints

    if ((iRet = fs_NewContourGridFit(pin, pout)) != NO_ERR ) // have rasterizer generate outlines
    {                                             // something went wrong, get out
      V_FSERROR(iRet);
      WARNING("lGGOBitmap -- fs_ContourGridFit failed\n");
      iError = ERROR_CAN_NOT_COMPLETE;
    }
    else
    { // if you get here, the rasterizer has accepted the new glyph now we must
      // get glyph metrics and initialize pgin for later rasterization calls
      // of the required bitmaps

        if ((iRet = fs_FindBitMapSize(pin, pout)) != NO_ERR )
        {                                         // no, get out
          V_FSERROR(iRet);
          WARNING("lGGOBitmap -- fs_FindBitMapSize failed\n");
          iError = ERROR_CAN_NOT_COMPLETE;
        }
     }

    if ( iError == NO_ERROR )                     // everything OK so far?
    {                                             // yes
      if ( pgd )                                  // caller provided GLYPHDATA?
      {                                           // yes, fill it in
        GMC gmc;                                  // necessary scratch space
        POINTL ptlOrg;                            // necessary scratch space
        fs_GlyphInfoType gout, *pgout;
        HGLYPH hgTemp;

        if ( pfc->bVertical && ( pfc->ulControl & VERTICAL_MODE ) ) // vertical?
        {                                                           // yes
            hgTemp = pfc->hgSave;
            pgout = &gout;
            vShiftBitmapInfo( pfc, pgout, pfc->pgout );
        }
        else
        {                                         // not vertical
            hgTemp = hg;
            pgout  = pfc->pgout;
        }

        // fill the GLYPHDATA structure
 
        vFillGLYPHDATA(hgTemp,ig,pfc,pgout,pgd,&gmc,&ptlOrg);
      }

      if ( pv == 0 )                              // buffer provided for bits?
      {                                           // no, return necessary size
        if ( cjSize )                             // is the input size zero?
        {                                         // no, caller is a fool, get out
          WARNING("lGGOBitmap -- pv == 0 && cjRet != 0\n");
          iError = ERROR_INVALID_PARAMETER;
        }
        else                                      // input size zero
        {                                         // so caller is not a fool
          pbm   = &pfc->pgout->bitMapInfo;        // calculate necessary size
          pRect = &pbm->bounds;                   // and return
          lRet = (LONG) (pRect->bottom - pRect->top) * (LONG) pbm->rowBytes;
        }
      }
      else
      {                                           // buffer for bits is provided
        if ( cjSize == 0 )                        // is the size reasonable?
        {                                         // no
          WARNING("lGGOBitmap -- pv != 0 && cjRet == 0\n");
          iError = ERROR_INVALID_PARAMETER;
        }
        else                                      // caller provided a buffer for
        {                                         // the bits representing the glyph
          if (pfc->flXform & XFORM_SINGULAR)      // is the transform bad?
          {                                       // yes! Make a blank 1 x 1 bitmap
            *(BYTE*)pv = 0;                       // legal for both monochrome
          }                                       //                 and gray glyphs
          else                                    // notional to device transform ok
          {                                       // prepare to rasterize glyph
            pfc->gstat.pv =                       // allocate scratch space
              pvSetMemoryBases(pfc->pgout, pin, !isMonochrome );
                                                  // be sure you free this!
            if ( pfc->gstat.pv == 0 )             // successful allocation?
            {                                     // no, get out
              WARNING("lGGOBitmap -- pfc->gstat.pv == 0\n");
              iError = ERROR_NOT_ENOUGH_MEMORY;
            }
            else                                  // memory has been allocated!
            {                                     // free it when leaving this scope
              if ((iRet = fs_ContourScan(pin, pout)) != NO_ERR )
              {                                 // no, get out
                V_FSERROR(iRet);
                WARNING("lGGOBitmap -- fs_ContourScan failed\n");
                iError = ERROR_CAN_NOT_COMPLETE;
              }

              if ( iError == NO_ERROR )           // everthing ok so far?
              {                                   // yes
                pbm   = &pfc->pgout->bitMapInfo;  // calculate size of bitmap
                pRect = &pbm->bounds;             // just in case it changed
                lRet = (LONG) (pRect->bottom - pRect->top) * (LONG) pbm->rowBytes;
                lRet = min((LONG) cjSize, lRet);  // don't overwrite buffer
                if ( pfc->pgout->bitMapInfo.baseAddr )  // bitmap there?
                {                                 // yes, copy to caller's buffer
                  RtlCopyMemory(pv, pfc->pgout->bitMapInfo.baseAddr, lRet);
                }
                else
                {                                 // bitmap not there, get out
                  WARNING("lGGOBitmap -- invalid pointer to bitmap\n");
                  iError = ERROR_CAN_NOT_COMPLETE;
                }
              }
              V_FREE(pfc->gstat.pv);              // free memory before leaving scope
              pfc->gstat.pv = NULL;
            }
          }
        }
      }
    }
  }
  if ( iError != NO_ERROR )                       // has an error occurred?
  {                                               // yes
    EngSetLastError( iError );                    // regitster the error
    lRet = FD_ERROR;                              // return value indicates error
  }
  vInitGlyphState( &pfc->gstat );                 // invalidate cache
  return( lRet );
}

/******************************Public*Routine******************************\
*
* pvSetMemoryBases
*
* To release this memory simply do vFreeMemoryBases(&pv); where pv is
* returned from bSetMemoryBases in ppv
*
* Looks into memory request in fs_GlyphInfoType and allocates this memory
* , than it fills memoryBases in fs_GlyphInputType with pointers to the
* requested memory
*
* History:
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


void *pvSetMemoryBases(fs_GlyphInfoType *pgout,fs_GlyphInputType *pgin,int isGray)
{
    FS_MEMORY_SIZE adp[MEMORYFRAGMENTS];
    FS_MEMORY_SIZE cjTotal;
    INT i;
    PBYTE pjMem;

#define I_LO 5
#define I_HI 7

    cjTotal = 0;    // total memory to allocate for all fragments


// unroll the loop:

//     for (i = I_LO; i <= I_HI; i++)
//     {
//         adp[i] = cjTotal;
//         cjTotal += NATURAL_ALIGN(pgin->memorySizes[i]);
//     }

    adp[5] = cjTotal;
    cjTotal += NATURAL_ALIGN(pgout->memorySizes[5]);
    adp[6] = cjTotal;
    cjTotal += NATURAL_ALIGN(pgout->memorySizes[6]);
    adp[7] = cjTotal;
    cjTotal += NATURAL_ALIGN(pgout->memorySizes[7]);
    if (isGray)
    {
        adp[8] = cjTotal;
        cjTotal += NATURAL_ALIGN(pgout->memorySizes[8]);
    }

    if (cjTotal == 0)
    {
        cjTotal = 4;
    }

    if ((pjMem = (PBYTE)PV_ALLOC((ULONG)cjTotal)) == (PBYTE)NULL)
    {
        for (i = I_LO; i <= I_HI; i++)
            pgin->memoryBases[i] = (PBYTE)NULL;

        RETURN("TTFD!_bSetMemoryBases mem alloc failed\n",NULL);
    }

// unroll the loop:
// set the pointers

//    for (i = I_LO; i <= I_HI; i++)
//    {
//        if (pgin->memorySizes[i] != (FS_MEMORY_SIZE)0)
//        {
//            pgout->memoryBases[i] = pjMem + adp[i];
//        }
//        else
//        {
//        // if no mem was required set to NULL to prevent accidental use
//
//            pgout->memoryBases[i] = (PBYTE)NULL;
//        }
//    }

    if (pgout->memorySizes[5] != (FS_MEMORY_SIZE)0)
    {
        pgin->memoryBases[5] = pjMem + adp[5];
    }
    else
    {
        pgin->memoryBases[5] = (PBYTE)NULL;
    }

    if (pgout->memorySizes[6] != (FS_MEMORY_SIZE)0)
    {
        pgin->memoryBases[6] = pjMem + adp[6];
    }
    else
    {
        pgin->memoryBases[6] = (PBYTE)NULL;
    }

    if (pgout->memorySizes[7] != (FS_MEMORY_SIZE)0)
    {
        pgin->memoryBases[7] = pjMem + adp[7];
    }
    else
    {
        pgin->memoryBases[7] = (PBYTE)NULL;
    }

    if (isGray && (pgout->memorySizes[8] != (FS_MEMORY_SIZE)0))
    {
        pgin->memoryBases[8] = pjMem + adp[8];
    }
    else
    {
        pgin->memoryBases[8] = (PBYTE)NULL;
    }

    return pjMem;
}

/******************************Public*Routine******************************\
* VOID vFreeMemoryBases()                                                  *
*                                                                          *
* Releases the memory allocated by bSetMemoryBases.                        *
*                                                                          *
* History:                                                                 *
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/

VOID vFreeMemoryBases(PVOID * ppv)
{
    if (*ppv != (PVOID) NULL)
    {
        V_FREE(*ppv);
        *ppv = (PVOID) NULL; // clean up the state and prevent accidental use
    }
}




/******************************Public*Routine******************************\
* bQueryAdvanceWidths                                                      *
*                                                                          *
* A routine to compute advance widths, as long as they're simple enough.   *
                                                                           *
* Warnings: !!! if a bug is found in bGetFastAdvanceWidth this routine has *
*           !!! to be changed as well                                      *
*                                                                          *
*  Sun 17-Jan-1993 21:23:30 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

typedef struct
{
  unsigned short  Version;
  unsigned short  cGlyphs;
  unsigned char   PelsHeight[1];
} LSTHHEADER;




BOOL bQueryAdvanceWidths(
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    LONG    *plWidths,
    ULONG    cGlyphs
    )
{

    FONTCONTEXT *pfc;
    USHORT      *psWidths = (USHORT *) plWidths;   // True for the cases we handle.
    HDMXTABLE   *phdmx;
    sfnt_FontHeader        *phead;
    sfnt_HorizontalHeader  *phhea;
    sfnt_HorizontalMetrics *phmtx;
    LSTHHEADER             *plsth;
    ULONG  cHMTX;
    USHORT dxLastWidth;
    LONG   dx;
    ULONG  ii;
    BOOL   bRet;
    BYTE   *pjView;

// if this font file is gone we are not gonna be able to answer any questions
// about it

    ASSERTDD(pfo->iFile, "bQueryAdvanceWidths, pfo->iFile\n");

    if (((TTC_FONTFILE *)pfo->iFile)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
        WARNING("ttfd, : bQueryAdvanceWidths, file is gone\n");
        return FALSE;
    }

// make sure that there is the font context is initialized

    if ( pfo->pvProducer == (PVOID) NULL )
    {
        pfo->pvProducer = pfc = ttfdOpenFontContext(pfo);
    }
    else
    {
        pfc = (FONTCONTEXT*) pfo->pvProducer;
        pfc->flFontType = (pfc->flFontType & FO_CHOSE_DEPTH) | pfo->flFontType;
    }

    if ( pfc == (FONTCONTEXT *) NULL )
    {
        WARNING("winsrv!bQueryAdvanceWidths(): cannot create font context\n");
        return FD_ERROR;
    }
    pfc->pfo = pfo;

    if( ((pfc->flFontType & (FO_CLEARTYPENATURAL_X | FO_NOCLEARTYPE)) == FO_CLEARTYPENATURAL_X) && !(pfc->pff->ifi.flInfo & FM_INFO_DBCS_FIXED_PITCH) )
    {
        for (ii=0; ii<cGlyphs; ii++,psWidths++)
	        *psWidths  = 0xFFFF;
        return(FALSE);
    }


    phdmx = pfc->phdmx;

// Make sure we understand the call.

    if (iMode > QAW_GETEASYWIDTHS)
        return FALSE;

// Try to use the HDMX table.

    if (phdmx != (HDMXTABLE *) NULL)
    {
        USHORT cxExtra = (pfc->flFontType & FO_SIM_BOLD) ? (1 << 4) : 0; /* for backwards conpatibility reason, we inclease the widht only by one pixel */

    //    while (cGlyphs)
    //        *psWidths++ = ((USHORT) phdmx->aucInc[*phg++]) << 4;

    unroll_here:
        switch (cGlyphs)
        {
        default:
              if (phdmx->aucInc[phg[7]] != 0)
              {
                  psWidths[7] = (((USHORT) phdmx->aucInc[phg[7]]) << 4) + cxExtra;
              }
              else
              {
                  psWidths[7] = (((USHORT) phdmx->aucInc[phg[7]]) << 4);
              }
        case 7:
               if (phdmx->aucInc[phg[6]] != 0)
              {
                  psWidths[6] = (((USHORT) phdmx->aucInc[phg[6]]) << 4) + cxExtra;
              }
              else
              {
                  psWidths[6] = (((USHORT) phdmx->aucInc[phg[6]]) << 4);
              }
        case 6:
              if (phdmx->aucInc[phg[5]] != 0)
              {
                  psWidths[5] = (((USHORT) phdmx->aucInc[phg[5]]) << 4) + cxExtra;
              }
              else
              {
                  psWidths[5] = (((USHORT) phdmx->aucInc[phg[5]]) << 4);
              }
        case 5:
              if (phdmx->aucInc[phg[4]] != 0)
              {
                  psWidths[4] = (((USHORT) phdmx->aucInc[phg[4]]) << 4) + cxExtra;
              }
              else
              {
                  psWidths[4] = (((USHORT) phdmx->aucInc[phg[4]]) << 4);
              }
        case 4:
              if (phdmx->aucInc[phg[3]] != 0)
              {
                  psWidths[3] = (((USHORT) phdmx->aucInc[phg[3]]) << 4) + cxExtra;
              }
              else
              {
                  psWidths[3] = (((USHORT) phdmx->aucInc[phg[3]]) << 4);
              }
        case 3:
              if (phdmx->aucInc[phg[2]] != 0)
              {
                  psWidths[2] = (((USHORT) phdmx->aucInc[phg[2]]) << 4) + cxExtra;
              }
              else
              {
                  psWidths[2] = (((USHORT) phdmx->aucInc[phg[2]]) << 4);
              }
        case 2:
              if (phdmx->aucInc[phg[1]] != 0)
              {
                  psWidths[1] = (((USHORT) phdmx->aucInc[phg[1]]) << 4) + cxExtra;
              }
              else
              {
                  psWidths[1] = (((USHORT) phdmx->aucInc[phg[1]]) << 4);
              }
        case 1:
              if (phdmx->aucInc[phg[0]] != 0)
              {
                  psWidths[0] = (((USHORT) phdmx->aucInc[phg[0]]) << 4) + cxExtra;
              }
              else
              {
                  psWidths[0] = (((USHORT) phdmx->aucInc[phg[0]]) << 4);
              }
        case 0:
              break;
        }
        if (cGlyphs > 8)
        {
            psWidths += 8;
            phg      += 8;
            cGlyphs  -= 8;
            goto unroll_here;
        }
        return(TRUE);
    }

// Otherwise, try to scale.  Pick up the tables.

    pjView = (BYTE *)pfc->pff->pvView;
    ASSERTDD(pjView, "pjView is NULL 1\n");

    phead = (sfnt_FontHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HEAD ].dp);
    phhea = (sfnt_HorizontalHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HHEAD].dp);
    phmtx = (sfnt_HorizontalMetrics *)(pjView + pfc->ptp->ateReq[IT_REQ_HMTX].dp);
    plsth = (LSTHHEADER *)(
              (pfc->ptp->ateOpt[IT_OPT_LSTH].dp && pfc->ptp->ateOpt[IT_OPT_LSTH].cj != 0) ?
              (pjView + pfc->ptp->ateOpt[IT_OPT_LSTH ].dp):
              NULL
              );

    cHMTX = (ULONG) BE_UINT16(&phhea->numberOf_LongHorMetrics);
    dxLastWidth = BE_UINT16(&phmtx[cHMTX-1].advanceWidth);

// Try a simple horizontal scaling.

    if (pfc->flXform & XFORM_HORIZ)
    {
        USHORT cxExtra;
        LONG xScale;
        LONG lEmHt = pfc->lEmHtDev;
	    BOOL bNonLinear = TRUE;

        cxExtra = (pfc->flFontType & FO_SIM_BOLD) ? (1 << 4) : 0; /* for backwards compatibility reason, we increase the width only by one pixel */

    // See if there is cause for worry.

        if
        (
          !(pfc->flXform & XFORM_POSITIVE_SCALE)
          || ((((BYTE *) &phead->flags)[1] & 0x14)==0) // Bits indicating nonlinearity.
          || (pfc->pff->ifi.flInfo & FM_INFO_DBCS_FIXED_PITCH) // DBCS fixed pitch font
        )
        {
	        bNonLinear = FALSE;  // we are linear regardless of the size
        }

    // OK, let's scale using the FIXED transform.

        xScale = pfc->mx.transform[0][0];
        if (xScale < 0)
            xScale = -xScale;

        bRet = TRUE;
        for (ii=0; ii<cGlyphs; ii++,phg++,psWidths++)
        {
            if
            ( ( ((pfc->flFontType & (FO_CLEARTYPENATURAL_X | FO_NOCLEARTYPE )) == FO_CLEARTYPENATURAL_X) && 
                  !IsFullWidthCharacter(pfc->pff, *phg) ) ||
              (bNonLinear &&
                  ( (plsth == (LSTHHEADER *) NULL)
                  || (lEmHt < plsth->PelsHeight[*phg]) ))
            )
            {
                *psWidths = 0xFFFF;
                bRet = FALSE;
            }
            else
            {
                if (*phg < cHMTX)
                    dx = (LONG) BE_UINT16(&phmtx[*phg].advanceWidth);
                else
                    dx = (LONG) dxLastWidth;

                *psWidths = (USHORT) (((xScale * dx + 0x8000L) >> 12) & 0xFFF0);

                if (!gbJpn98FixPitch && (pfc->pff->ifi.flInfo & FM_INFO_DBCS_FIXED_PITCH) && IsFullWidthCharacter(pfc->pff, *phg))
                {
                    /* DBCS FixedPitch Full Width glyph */
                    /* we need to use the width 2*pfc->SBCDWidth */
                    /* some glyphs are flagged as FullWidth for the rotation of FE vertical writing but designed as single width */
                    if (pfc->mx.transform[0][0] > 0)
                    {
                        if (*psWidths != pfc->SBCSWidth << 4) 
                            *psWidths = (USHORT) ((2* pfc->SBCSWidth) << 4);
                    } else {
                        if (*psWidths != -pfc->SBCSWidth << 4) 
                            *psWidths = (USHORT) ((2* -pfc->SBCSWidth) << 4);
                    }
                }
                
                if (*psWidths != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
                    *psWidths += cxExtra;
            }
        }
        return(bRet);
    }

// Must be some random transform.  In this case, vComputeMaxGlyph computes
// pfc->efBase, which we will use here.

    else
    {
        USHORT cxExtra = (pfc->flFontType & FO_SIM_BOLD) ? (1 << 4) : 0; /* for backwards compatibility reason, we increase the width only by one pixel */

        for (ii=0; ii<cGlyphs; ii++,phg++,psWidths++)
        {
            if (*phg < cHMTX)
                dx = BE_UINT16(&phmtx[*phg].advanceWidth);
            else
                dx = dxLastWidth;

            if (dx != 0)
            {
                *psWidths = (USHORT)(lCvt(*(EFLOAT *) &pfc->efBase,(LONG) dx) + cxExtra);
            }
            else
            { /* we don't increase the width of a zero width glyph, problem with indic script */
                *psWidths = (USHORT)(lCvt(*(EFLOAT *) &pfc->efBase,(LONG) dx));
            }

        }
        return(TRUE);
    }
}


/******************************Public*Routine******************************\
*
* BOOL bGetFastAdvanceWidth
*
*
* Effects: retrieves the same result as bQueryAdvanceWidth, except it
*          ignores adding 1 for EMBOLDENING and it does not do anything
*          for non horiz. xforms
*
* Warnings: !!! if a bug is found in bQueryAdvanceWidth this routine has to
*           !!! changed as well
*
* History:
*  25-Mar-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




BOOL bGetFastAdvanceWidth(
    FONTCONTEXT *pfc,
    ULONG        ig,    // glyph index
    FIX         *pfxD   // result in 28.4
    )
{
    HDMXTABLE   *phdmx = pfc->phdmx;
    sfnt_FontHeader        *phead;
    sfnt_HorizontalHeader  *phhea;
    sfnt_HorizontalMetrics *phmtx;
    LSTHHEADER             *plsth;
    ULONG  cHMTX;
    USHORT dxLastWidth;
    LONG   dx;
    BOOL   bRet;
    BOOL   bNonLinear = TRUE;
    BYTE  *pjView;

    ASSERTDD(pfc->flXform & XFORM_HORIZ, "bGetFastAdvanceWidth xform\n");

    if((pfc->flFontType & (FO_CLEARTYPENATURAL_X | FO_NOCLEARTYPE)) == FO_CLEARTYPENATURAL_X){
        if ( !((pfc->pff->ifi.flInfo & FM_INFO_DBCS_FIXED_PITCH) && IsFullWidthCharacter(pfc->pff, ig)) )
        {
            *pfxD  = 0xFFFFFFFF;
            return( FALSE);
        }
    }

    if (phdmx != (HDMXTABLE *) NULL)
    {
        *pfxD = (((FIX) phdmx->aucInc[ig]) << 4);
        return(TRUE);
    }

// Otherwise, try to scale.  Pick up the tables.


    pjView = (BYTE *)pfc->pff->pvView;
    ASSERTDD(pjView, "pjView is NULL 1\n");

    phead = (sfnt_FontHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HEAD ].dp);
    phhea = (sfnt_HorizontalHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HHEAD].dp);
    phmtx = (sfnt_HorizontalMetrics *)(pjView + pfc->ptp->ateReq[IT_REQ_HMTX].dp);
    plsth = (LSTHHEADER *)(
              (pfc->ptp->ateOpt[IT_OPT_LSTH].dp && pfc->ptp->ateOpt[IT_OPT_LSTH].cj != 0) ?
              (pjView + pfc->ptp->ateOpt[IT_OPT_LSTH ].dp):
              NULL
              );

    cHMTX = (ULONG) BE_UINT16(&phhea->numberOf_LongHorMetrics);
    dxLastWidth = BE_UINT16(&phmtx[cHMTX-1].advanceWidth);

// See if there is cause for worry.

    if
    (
      !(pfc->flXform & XFORM_POSITIVE_SCALE)
      || ((((BYTE *) &phead->flags)[1] & 0x14)==0) // Bits indicating nonlinearity.
      || ((pfc->pff->ifi.flInfo & FM_INFO_DBCS_FIXED_PITCH) && IsFullWidthCharacter(pfc->pff, ig)) // glyph may need to be forced to 2*singleWidth
    )
    {
        bNonLinear = FALSE; // we are linear regardless of the size
    }

    bRet = TRUE;

    if 
    (
        bNonLinear &&
        ( (plsth == (LSTHHEADER *) NULL)
        || (pfc->lEmHtDev < plsth->PelsHeight[ig]) )
        )
    {
        *pfxD  = 0xFFFFFFFF;
        bRet = FALSE;
    }
    else
    {
    // OK, let's scale using the FIXED transform.

        if (ig < cHMTX)
            dx = (LONG) BE_UINT16(&phmtx[ig].advanceWidth);
        else
            dx = (LONG) dxLastWidth;

	    if (pfc->mx.transform[0][0] > 0)
	    {
	        *pfxD = (FIX) (((pfc->mx.transform[0][0] * dx + 0x8000L) >> 12) & 0xFFFFFFF0);
	    }
	    else
	    {
	        *pfxD = -(FIX) (((-pfc->mx.transform[0][0] * dx + 0x8000L) >> 12) & 0xFFFFFFF0);
	    }

        if ((pfc->pff->ifi.flInfo & FM_INFO_DBCS_FIXED_PITCH) && IsFullWidthCharacter(pfc->pff, ig))
        {
            /* DBCS FixedPitch Full Width glyph */
            /* we need to use the width 2*pfc->SBCDWidth */
            /* some glyphs are flagged as FullWidth for the rotation of FE vertical writing but designed as single width */
            if ( !gbJpn98FixPitch && *pfxD && *pfxD != pfc->SBCSWidth << 4) 
                *pfxD = (2* pfc->SBCSWidth) << 4;
        }

    }
    return(bRet);
}


/******************************Public*Routine******************************\
*
*  vFillGLYPHDATA_ErrRecover
*
* Effects: error recovery routine, if rasterizer messed up just
*          provide linearly scaled values with blank bitmap.
*
* History:
*  24-Jun-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID vFillGLYPHDATA_ErrRecover(
    HGLYPH        hg,
    ULONG         ig,
    FONTCONTEXT  *pfc,
    GLYPHDATA    *pgldt    // OUT
    )
{

    extern VOID vGetNotionalGlyphMetrics(FONTCONTEXT*, ULONG, NOT_GM*);
    NOT_GM ngm;  // notional glyph data

    pgldt->gdf.pgb = NULL; // may get changed by the calling routine if bits requested too
    pgldt->hg = hg;

// this is a fake blank 1x1 bitmap, no ink

    pgldt->rclInk.left   = 0;
    pgldt->rclInk.top    = 0;
    pgldt->rclInk.right  = 0;
    pgldt->rclInk.bottom = 0;

    pgldt->fxInkTop    = 0;
    pgldt->fxInkBottom = 0;

// go on to compute the positioning info:

    vGetNotionalGlyphMetrics(pfc,ig,&ngm);

    if (pfc->flXform & XFORM_HORIZ)  // scaling only
    {
        Fixed fxMxx =  pfc->mx.transform[0][0];
        if (fxMxx < 0)
            fxMxx = -fxMxx;

    // bGetFastAdvanceWidth returns the same aw that would get
    // computed by bQueryAdvanceWidths and propagated to an api
    // level through GetTextExtent and GetCharWidths. We have to
    // fill in the same aw for consistency reasons.
    // This also has to be done for win31 compatibility.

        if (!bGetFastAdvanceWidth(pfc,ig, &pgldt->fxD))
        {
        // just provide something reasonable, force linear scaling
        // even if we would not normally do it.

            pgldt->fxD = FixMul(ngm.sD,pfc->mx.transform[0][0]) << 4;
        }

        pgldt->ptqD.x.HighPart = (LONG)pgldt->fxD;
        pgldt->ptqD.x.LowPart  = 0;

        if (pfc->mx.transform[0][0] < 0)
            pgldt->fxD = - pgldt->fxD;  // this is an absolute value

        pgldt->ptqD.y.HighPart = 0;
        pgldt->ptqD.y.LowPart  = 0;

        pgldt->fxA   = FixMul(fxMxx, (LONG)ngm.sA) << 4;
        pgldt->fxAB  = FixMul(fxMxx, (LONG)ngm.xMax) << 4;

    }
    else // non trivial information
    {
    // here we will just xform the notional space data:

    // xforms are computed by simple multiplication

        pgldt->fxD         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sD);
        pgldt->fxA         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sA);
        pgldt->fxAB        = fxLTimesEf(&pfc->efBase, (LONG)ngm.xMax);

        vLTimesVtfl((LONG)ngm.sD, &pfc->vtflBase, &pgldt->ptqD);
    }

// finally check if the glyphdata will need to get modified because of the
// emboldening simulation:

    if (pfc->flFontType & FO_SIM_BOLD)
    {
        if (pgldt->fxD != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
                pgldt->fxD += (1 << 4);  // for backwards compatibility reason, the width inclease only by one pixel

    // go on to compute the positioning info:

        if (pfc->flXform & XFORM_HORIZ)  // scaling only
        {
            pgldt->ptqD.x.HighPart = (LONG)pgldt->fxD;

            if (pfc->mx.transform[0][0] < 0)
                pgldt->ptqD.x.HighPart = - pgldt->ptqD.x.HighPart;

        }
        else // non trivial information
        {
        // add a correction vector in baseline direction to each char inc vector.
        // This is consistent with fxD += LTOFX(1) and compatible with win31.

            if ((pgldt->ptqD.x.HighPart != 0) || (pgldt->ptqD.y.HighPart != 0)) /* we don't increase the width of a zero width glyph, problem with indic script */
            {
                    vAddPOINTQF(&pgldt->ptqD,&pfc->ptqUnitBase);
            }

        }
    }
}



/******************************Public*Routine******************************\
*
* LONG lGetGlyphBitmapErrRecover
*
* Effects: error recovery routine, if rasterizer messed up just
*          provide linearly scaled values with blank bitmap.
*
* History:
*  Thu 24-Jun-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG lGetGlyphBitmapErrRecover (
    FONTCONTEXT *pfc,
    HGLYPH       hglyph,
    GLYPHDATA   *pgd,
    PVOID        pv
    )
{
    LONG         cjGlyphData;
    GLYPHDATA    gd;      // Scummy hack
    FS_ENTRY     iRet;
    ULONG        ig; // <--> hglyph


    ASSERTDD(hglyph != HGLYPH_INVALID, "lGetGlyphBitmap, hglyph == -1\n");
    ASSERTDD(pfc == pfc->pff->pfcLast, "pfc! = pfcLast\n");

// return a small 1x1 bitmap, which will be blank, i.e. all bits will be off
// this prevents having to insert an if(cx && cy) check to a time critical
// loop in all device drivers before calling DrawGlyph routine.

    ASSERTDD(pfc->flFontType & FO_CHOSE_DEPTH,"Depth Not Chosen Yet!\n");
    cjGlyphData = CJGD(1,1,pfc);

    if ( (pgd == NULL) && (pv == NULL))
        return cjGlyphData;

// at this time we know that the caller wants the whole GLYPHDATA with
// bitmap bits, or maybe just the glypdata without the bits.

    if ( pgd == NULL )
    {
        pgd = &gd;
    }

// compute the glyph index from the character code:

    vCharacterCode(pfc->pff,hglyph,pfc->pgin);

    if ((iRet = fs_NewGlyph(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);
        return FD_ERROR; // even backup funcion can fail
    }

// return the glyph index corresponding to this hglyph:

    ig = pfc->pgout->glyphIndex;

    vFillGLYPHDATA_ErrRecover(
        hglyph,
        ig,
        pfc,
        pgd
        );

// the caller wants the bits too

    if ( pv != NULL )
    {
        GLYPHBITS *pgb = (GLYPHBITS *)pv;

        // return blank 1x1 bitmap

        pgb->ptlOrigin.x = pfc->ptlSingularOrigin.x;
        pgb->ptlOrigin.y = pfc->ptlSingularOrigin.y;

        pgb->sizlBitmap.cx = 1;    // cheating
        pgb->sizlBitmap.cy = 1;    // cheating

        pgb->aj[0] = (BYTE)0;  // fill in a blank 1x1 bmp

        pgd->gdf.pgb = pgb;
    }

    return(cjGlyphData);
}


#if(WINVER < 0x0400)

typedef struct tagFONTSIGNATURE
{
    DWORD fsUsb[4];
    DWORD fsCsb[2];
} FONTSIGNATURE, *PFONTSIGNATURE,FAR *LPFONTSIGNATURE;
#endif
/******************************Public*Routine******************************\
*
* VOID vGetFontSignature(HFF hff, FONTSIGNATURE *pfs);
*
*
* Effects: If font file contains the font signature,
*          it copies the data out, else computes it using win95 mechanism.
*
* History:
*  10-Jan-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vGetFontSignature(FONTFILE *pff, FONTSIGNATURE *pfs)
{
    pff;
    pfs;
}

/******************************Public*Routine******************************\
*
* DWORD ttfdQueryLpkInfo
*
*
* Effects: returns per font information needed to support various new
*          multilingual api's invented by DavidMS from Chicago team
*
* History:
*  10-Jan-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

// called by GetFontLanguageInfo

#define LPK_GCP_FLAGS       1
#define LPK_FONTSIGNATURE   2

DWORD ttfdQueryLpkInfo(
    FONTFILE  *pff,
    ULONG      ulFont,
    ULONG      ulMode,
    ULONG      cj,
    BYTE      *pj
    )
{
    FONTSIGNATURE *pfs = (FONTSIGNATURE *)pj;

    switch (ulMode)
    {
    default:
    case LPK_GCP_FLAGS:
        return 0;
    case LPK_FONTSIGNATURE:
        if (pj)
        {
            vGetFontSignature(pff, pfs);
            return sizeof(FONTSIGNATURE);
        }
        else
        {
            return 0;
        }

    }
}

#if DBG
/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpGrayGLYPHBITS
*
* Routine Description:
*
*   Dumps a 4bpp gray glyph bitmap to the debugging screen
*
* Arguments:
*
*   pgb -- pointer to a gray GLYPHBITS structure
*
* Return Value:
*
*   None.
*
\**************************************************************************/

void vDumpGrayGLYPHBITS(GLYPHBITS *pgb)
{
    #define CH_TOP_LEFT_CORNER '\xDA'
    #define CH_HORIZONTAL_BAR  '\xC4'
    #define CH_VERTICAL_BAR    '\xB3'
    #define CH_PIXEL_ON        '\x02'
    #define CH_PIXEL_OFF       '\xFA'

    BYTE *pj8, *pj, *pjNext, *pjEnd;
    int cjScan, i, k, c8, c4, cj;
    static char achGray[16] = {
        CH_PIXEL_OFF,
        '1','2','3','4','5','6','7','8','9','a','b','c','d','e',
        CH_PIXEL_ON
    };

    TtfdDbgPrint(
        "\n\n"
        "ptlOrigin  = (%d,%d)\n"
        "sizlBitmap = (%d,%d)\n"
        "\n\n"
        , pgb->ptlOrigin.x
        , pgb->ptlOrigin.y
        , pgb->sizlBitmap.cx
        , pgb->sizlBitmap.cy
    );
    cjScan = (pgb->sizlBitmap.cx + 1)/2;
    cj = cjScan * pgb->sizlBitmap.cy;
    TtfdDbgPrint("\n\n  ");
    for (i = 0, k = 0; i < pgb->sizlBitmap.cx; i++, k++)
    {
        k = (k > 9) ? 0 : k;
        TtfdDbgPrint("%1d", k);
    }
    TtfdDbgPrint("\n %c",CH_TOP_LEFT_CORNER);
    for (i = 0; i < pgb->sizlBitmap.cx; i++)
    {
        TtfdDbgPrint("%c",CH_HORIZONTAL_BAR);
    }
    TtfdDbgPrint("\n");
    c8 = pgb->sizlBitmap.cx / 2;
    c4 = pgb->sizlBitmap.cx % 2;
    for (
        pj = pgb->aj, pjNext=pj+cjScan , pjEnd=pjNext+cj, k=0
        ; pjNext < pjEnd
        ; pj=pjNext , pjNext+=cjScan, k++
    )
    {
        k = (k > 9) ? 0 : k;
        TtfdDbgPrint("%1d%c",k,CH_VERTICAL_BAR);
        for (pj8 = pj+c8 ; pj < pj8; pj++)
        {
            TtfdDbgPrint("%c%c", achGray[*pj>>4], achGray[*pj & 0xf]);
        }
        if (c4)
        {
            TtfdDbgPrint("%c%c", achGray[*pj>>4], achGray[*pj & 0xf]);
        }
        TtfdDbgPrint("\n");
    }
}
#endif


/******************************Public*Routine******************************\
* vGCGB
*
* Called by: vCopyGrayBits
*
* void General Copy Gray Bits
*
* History:
*  Wed 22-Feb-1995 13:14:36 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

VOID vGCGB(
    FONTCONTEXT *pfc,   // pointer to the FONTCONTEXT this is used
                        // to determine if the font is bold simulated
    GLYPHBITS   *pgb,   // pointer to destination GRAY GLYPHBITS structure
                        // In the case where dY is zero, all the fields
                        // of the GLYPHBITS structure must be filled
                        // this includes sizlBitmap and the bits; in
                        // the case where dY is non-zero, the
                        // sizlBitmap components are precomputed and
                        // must not be touched.
    BYTE        *pjSrc, // pointer to TT gray scale bitmap
                        // This is 8-bit per pixel bitmap whose scans
                        // are aligned on 4-byte multiples. The values
                        // stored in the bitmaps are in the range
                        // 0-16. In order to fit 17 levels in the 4 bit
                        // per pixel destination we reduce the level
                        // value by 1, except for zero which is left alone.
    GMC         *pgmc,  // pointer to the glyph-metric-correction structure
                        // which has information on how to "shave" the
                        // bitmap so that it does not get above a guaranteed
                        // value
    LONG dY             // vertical offset into destination bitmap used
                        // for "special fixed pitch fonts" like Lucida
                        // Console.
    )
{
    unsigned cxDst;     // width of destination bitmap
    unsigned cjSrcScan; // count of bytes in a source scan including
                        // padding out to nearest 4-byte multiple boundary
    unsigned cjDstScan; // count of bytes in a desintation scan including
                        // padding out to nearest byte boundary

    BYTE   *pjDst, *pjSrcScan, *pjDstScan, *pjDstScanEnd;

    static const BYTE ajGray[17] = {0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};

    #if DBG
    if (gflTtfdDebug & DEBUG_GRAY)
    {
        typedef struct _FLAGDEF {
            char *psz;      // description
            FLONG fl;       // flag
        } FLAGDEF;
        FLAGDEF *pfd;
        FLONG fl;

        static FLAGDEF afdFO[] = {
            {"FO_TYPE_RASTER  ", FO_TYPE_RASTER  },
            {"FO_TYPE_DEVICE  ", FO_TYPE_DEVICE  },
            {"FO_TYPE_TRUETYPE", FO_TYPE_TRUETYPE},
            {"FO_SIM_BOLD     ", FO_SIM_BOLD     },
            {"FO_SIM_ITALIC   ", FO_SIM_ITALIC   },
            {"FO_EM_HEIGHT    ", FO_EM_HEIGHT    },
            {"FO_GRAY16       ", FO_GRAY16       },
            {"FO_NOGRAY16     ", FO_NOGRAY16     },
            {"FO_NOHINTS      ", FO_NOHINTS      },
            {"FO_NO_CHOICE    ", FO_NO_CHOICE    },
            {                 0, 0               }
        };

        TtfdDbgPrint(
            "vGCGB(\n"
            "   FONTCONTEXT *pfc = %-#x\n"
            "   GLYPHBITS   *pgb = %-#x\n"
            "   BYTE      *pjSrc = %-#x\n"
            "   GMC        *pgmc = %-#x\n"
            "   LONG          dY = %d\n"
            ")\n"
          , pfc, pgb, pjSrc, pgmc, dY
        );
        TtfdDbgPrint(
            "---"
            " GMC\n"
            "\n"
            "   dyTop    = %u\n"
            "   dyBottom = %u\n"
            "   dxLeft   = %u\n"
            "   dxRight  = %u\n"
            "   cxCor    = %u\n"
            "   cyCor    = %u\n"
            "---\n\n"
          , pgmc->dyTop
          , pgmc->dyBottom
          , pgmc->dxLeft
          , pgmc->dxRight
          , pgmc->cxCor
          , pgmc->cyCor
        );
        fl = pfc->flFontType;
        TtfdDbgPrint("pfc->flFontType = %-#x\n",pfc->flFontType);
        for ( pfd=afdFO; pfd->psz; pfd++ )
        {
            if (fl & pfd->fl)
            {
                TtfdDbgPrint("    %s\n", pfd->psz);
                fl &= ~pfd->fl;
            }
        }
        if ( fl )
        {
            TtfdDbgPrint("    UNKNOWN FLAGS\n");
        }
    }
    #endif

    ASSERTDD(
        pfc->flFontType & FO_CHOSE_DEPTH
       ,"We haven't decided about pixel depth\n"
    );
    ASSERTDD(pgmc->cxCor < LONG_MAX && pgmc->cyCor < LONG_MAX
     , "vCopyGrayBits -- bad gmc\n"
    );

    cjSrcScan = CJ_TT_SCAN(pgmc->cxCor+pgmc->dxLeft+pgmc->dxRight,pfc);

    cxDst = pgmc->cxCor;

    cjDstScan = CJ_GRAY_SCAN(cxDst);

    // correct source pointer for shaving

    if (pgmc->dyTop)
    {
        pjSrc += pgmc->dyTop * cjSrcScan;
    }
    pjSrc += pgmc->dxLeft;
    pjSrcScan = pjSrc;
    pjDstScan = pgb->aj;

    // destination correction for special fixed pitch fonts

    if (dY)
    {
        // Console font
        // the size of the bitmap has been established already
        pjDstScan += dY * cjDstScan;
    }
    else
    {
        // Extended with Embold
        pgb->sizlBitmap.cx = cxDst;
        pgb->sizlBitmap.cy = pgmc->cyCor;
    }
    pjDstScanEnd = pjDstScan + pgmc->cyCor * cjDstScan;

    #if DBG
    if (gflTtfdDebug & DEBUG_GRAY)
    {
        int bBad;
        BYTE *pjScan, *pjScanEnd;

        TtfdDbgPrint(
            "cjSrcScan          = %u\n"
            "cjDstScan          = %u\n"
            "cxDst              = %u\n"
            "pgb->sizlBitmap.cx = %u\n"
            "pgb->sizlBitmap.cy = %u\n"
            "pjSrc              = %-#x\n"
            "pjSrcScan          = %-#x\n"
            "pjDstScan          = %-#x\n"
            "pjDstScanEnd       = %-#x\n"
          ,  cjSrcScan
          ,  cjDstScan
          ,  cxDst
          ,  pgb->sizlBitmap.cx
          ,  pgb->sizlBitmap.cy
          ,  pjSrc
          ,  pjSrcScan
          ,  pjDstScan
          ,  pjDstScanEnd
        );

        // scan the source for gray values greater than 16

        pjScan    = pjSrcScan;
        pjScanEnd = pjSrcScan + cjSrcScan * pgmc->cyCor;
        for (; pjScan < pjScanEnd; pjScan+=cjSrcScan) {
            BYTE *pj;
            BYTE *pjEnd = pjScan + cjSrcScan;
            for (pj = pjScan; pj < pjEnd; pj++) {
                if (*pj > 16)
                    break;
            }
            if (pj != pjEnd)
                break;
        }
        if (pjScan != pjScanEnd) {
            TtfdDbgPrint("\n\nBad Source Gray Bitmap\n\n");
            pjScan    = pjSrcScan;
            pjScanEnd = pjSrcScan + cjSrcScan * pgmc->cyCor;
            for (; pjScan < pjScanEnd; pjScan+=cjSrcScan) {
                BYTE *pj;
                BYTE *pjEnd = pjScan + cjSrcScan;
                for (pj = pjScan; pj < pjEnd; pj++) {
                    TtfdDbgPrint("%02x ", *pj);
                }
                TtfdDbgPrint("\n");
            }
            EngDebugBreak();
        }

        TtfdDbgPrint(
            "\n"
            "Source 8-bit-per-pixel-bitmap\n"
            "\n"
        );
        pjScan    = pjSrcScan;
        pjScanEnd = pjSrcScan + cjSrcScan * pgmc->cyCor;
        for (; pjScan < pjScanEnd; pjScan+=cjSrcScan) {
            BYTE *pj;
            BYTE *pjEnd = pjScan + cjSrcScan;
            for (pj = pjScan; pj < pjEnd; pj++) {
                TtfdDbgPrint("%1x", ajGray[*pj]);
            }
            TtfdDbgPrint("\n");
        }
        TtfdDbgPrint("\n");

        EngDebugBreak();
    }
    #endif
    for (
        ; pjDstScan < pjDstScanEnd                  // whole byte loop
        ; pjDstScan += cjDstScan, pjSrcScan += cjSrcScan)
    {
        for (
            pjSrc = pjSrcScan, pjDst = pjDstScan
          ; pjDst < pjDstScan + (pgmc->cxCor  / 2)
          ; pjDst += 1
        )
        {
            *pjDst  = 16*ajGray[*pjSrc++];  // set high nyble
            *pjDst += ajGray[*pjSrc++];     // set low nyble
        }

        // The dxAbsBold has been enhanced >= 1

        if (pgmc->cxCor & 1)                // one more pixel in source?
        {                                   // yes
            *pjDst++  = 16*ajGray[*pjSrc];    // set high nyble
        }                                   // low nyble is cleared

        while ( pjDst < (pjDstScan + cjDstScan) )    // embodening is taken care of
            *pjDst++ = 0;                           // emboldened?
                                                    // yes; clear last byte
                                                    //
   }


    #if DBG
    if (gflTtfdDebug & DEBUG_GRAY)
    {
        vDumpGrayGLYPHBITS(pgb);
    }
    #endif

}

VOID
vCopyGrayBits(
    FONTCONTEXT *pfc
  , GLYPHBITS *pgb
  , BYTE *pjSrc
  , GMC *pgmc
)
{
    vGCGB(pfc, pgb, pjSrc, pgmc, 0);
}



VOID vCopyClearTypeBits(
    FONTCONTEXT *pfc,   // pointer to the FONTCONTEXT this is used
                        // to determine if the font is bold simulated
    GLYPHBITS   *pgb,   // pointer to destination CLEARTYPE GLYPHBITS structure
                        // All the fields
                        // of the GLYPHBITS structure must be filled
                        // this includes sizlBitmap and the bits;
                        // The sizlBitmap components are precomputed and
                        // must not be touched.
    BYTE        *pjSrc, // pointer to TT ClearType bitmap
                        // This is 8-bit per pixel bitmap whose scans
                        // are aligned on 4-byte multiples. The values
                        // stored in the bitmaps are in the range
                        // 0-252.
    GMC         *pgmc   // pointer to the glyph-metric-correction structure
                        // which has information on how to "shave" the
                        // bitmap so that it does not get above a guaranteed
                        // value
    )
{
    unsigned cjSrcScan; // count of bytes in a source scan including
                        // padding out to nearest 4-byte multiple boundary
    unsigned cjDstScan; // count of bytes in a desintation scan including
                        // padding out to nearest byte boundary

    BYTE   *pjDst, *pjSrcScan, *pjDstScan, *pjDstScanEnd;

    cjSrcScan = CJ_TT_SCAN(pgmc->cxCor+pgmc->dxLeft+pgmc->dxRight,pfc);
    cjDstScan = CJ_CLEARTYPE_SCAN(pgmc->cxCor);  // should be the same as cxCor

    // correct source pointer for shaving

    if (pgmc->dyTop)
    {
        pjSrc += pgmc->dyTop * cjSrcScan;
    }
    pjSrc += pgmc->dxLeft;
    pjSrcScan = pjSrc;
    pjDstScan = pgb->aj;

    pgb->sizlBitmap.cx = pgmc->cxCor;
    pgb->sizlBitmap.cy = pgmc->cyCor;

    pjDstScanEnd = pjDstScan + pgmc->cyCor * cjDstScan;

    for ( ; pjDstScan < pjDstScanEnd ; pjDstScan += cjDstScan, pjSrcScan += cjSrcScan)
    {
        for
        (
          pjSrc = pjSrcScan, pjDst = pjDstScan;
          pjDst < (pjDstScan + pgmc->cxCor);
          pjDst++, pjSrc++
        )
        {
            *pjDst  = *pjSrc;
        }
    }
}

/******************************Public*Routine******************************\
*
* LONG lGetBitmapVertical
*
* History:
*  20-Mar-1993 -by- Takao Kitano [TakaoK]
* grabbed lGetBitmap() and modified
*
\**************************************************************************/

LONG lGetGlyphBitmapVertical (
    FONTCONTEXT *pfc,
    HGLYPH       hglyph,
    GLYPHDATA   *pgd,
    PVOID        pv,
    FS_ENTRY    *piRet
    )
{
    LONG cjGlyphData;

    if ( !IsFullWidthCharacter( pfc->pff, hglyph) )
    {
        return (lGetGlyphBitmap(pfc, hglyph, pgd, pv, piRet));
    }

    //
    // change the transformation
    //

    if ( !bChangeXform( pfc, TRUE ) )
    {
        WARNING("TTFD!bChangeXform(TRUE) failed\n");
        return FD_ERROR;
    }


    //
    // set vertical mode
    //
    pfc->ulControl |= VERTICAL_MODE;
    pfc->hgSave = hglyph;

    // call ordinary function

    cjGlyphData = lGetGlyphBitmap( pfc, hglyph, pgd, pv, piRet);

    //
    // restore the transformation and return
    //
    if ( ! bChangeXform( pfc, FALSE ) )
    {
        WARNING("TTFD!bChangeXform(FALSE) failed\n");
    }

    pfc->ulControl &= ~VERTICAL_MODE;
    return(cjGlyphData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\ttfd\sources.inc ===
MAJORCOMP=windows
MINORCOMP=ttfd

TARGETNAME=ttfd
TARGETTYPE=LIBRARY

TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

C_DEFINES=$(C_DEFINES) -DFE_SB

INCLUDES=..;..\..\..\..\inc;..\..\scaler


NTPROFILEINPUT=yes

SOURCES=..\fdfon.c     \
        ..\fdfc.c      \
        ..\fd_query.c  \
        ..\fontfile.c  \
        ..\service.c   \
        ..\fd_poly.c   \
        ..\vdmx.c      \
        ..\vertical.c  \
        ..\dbg.c

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\ttfd\tt.h ===
/******************************Module*Header*******************************\
* Module Name: tt.h
*
*  interface to the font scaler. Also defines some macros that should
* have been defined in the scaler *.h files
*
* Created: 17-Nov-1991 15:56:21
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
*
\**************************************************************************/



// turns out that some of the macros that follow are already defined
// in some of the top include files that precede tt.h. Worse, these
// macros are defined DIFFERENTLY than in tt.h.
// We want to enforce that these macros when used in ttfd have the meaning
// defined in tt include files so that we have to kill the definitions
// inherited from anywhere else.


//!!! maybe this should go to scaler\config.h !!!!!!!!

#ifdef SWAPL
#undef SWAPL
#endif

#ifdef SWAPW
#undef SWAPW
#endif

// defined earlier, turns on the garbage in fserror.h

#ifdef XXX
#undef XXX
#endif

// defined earlier, use tt definition

#ifdef HIWORD
#undef HIWORD
#endif

// defined earlier, use tt definition

#ifdef LOWORD
#undef LOWORD
#endif

#include "FSERROR.H"
#include "FSCDEFS.H"    // inlcudes fsconfig.h
#include "FONTMATH.H"
#include "SFNT.H"       // includes sfnt_en.h
#include "FNT.H"
#include "INTERP.H"
#include "FNTERR.H"
#include "SFNTACCS.H"
#include "FSGLUE.H"
#include "SCENTRY.H"
#include "SBIT.H"
#include "FSCALER.H"
#include "SCGLOBAL.H"
#include "SFNTOFF.H"

// allowed specific ID's

#define SPEC_ID_UNDEFINED    0   // undefined char set or indexing scheme
#define SPEC_ID_UGL          1   // UGL char set with UNICODE indexing
#define SPEC_ID_SHIFTJIS     2   // SHIFTJIS mapping
#define SPEC_ID_GB           3   // GB mapping
#define SPEC_ID_BIG5         4   // BIG5 mapping
#define SPEC_ID_WANSUNG      5   // Hangeul WANSUNG mapping

// the same but in big endian format

#define BE_SPEC_ID_UNDEFINED    0x0000   // undefined char set or indexing scheme
#define BE_SPEC_ID_UGL          0x0100   // UGL char set with UNICODE indexing
#define BE_SPEC_ID_SHIFTJIS     0x0200   // SHIFTJIS mapping
#define BE_SPEC_ID_GB           0x0300   // GB mapping
#define BE_SPEC_ID_BIG5         0x0400   // BIG5 mapping
#define BE_SPEC_ID_WANSUNG      0x0500   // Hangeul WANSUMG mapping

// platform id's, this is copied from sfnt_en.h

/*
*
* typedef enum {
*     plat_Unicode,
*     plat_Macintosh,
*     plat_ISO,
*     plat_MS
* } sfnt_PlatformEnum;
*
*/

#define  PLAT_ID_UNICODE   0
#define  PLAT_ID_MAC       1
#define  PLAT_ID_ISO       2
#define  PLAT_ID_MS        3

// the same but in big endian format

#define  BE_PLAT_ID_UNICODE   0x0000
#define  BE_PLAT_ID_MAC       0x0100
#define  BE_PLAT_ID_ISO       0x0200
#define  BE_PLAT_ID_MS        0x0300


// language id's that are required to exhist in a ttf file:

#define LANG_ID_USENGLISH   0X0409  // for microsoft records
#define LANG_ID_MAC         0       // ENGLISH FOR MAC RECORDS

// the same but in big endian format

#define BE_LANG_ID_USENGLISH   0X0904  // for microsoft records
#define BE_LANG_ID_MAC         0X0000  // ENGLISH FOR MAC RECORDS


// allowed format values of the cmap tables:

#define BE_FORMAT_MAC_STANDARD      0X0000
#define BE_FORMAT_HIGH_BYTE         0X0200
#define BE_FORMAT_MSFT_UNICODE      0X0400
#define BE_FORMAT_TRIMMED           0X0600


/*
*
* typedef enum {
*     name_Copyright,
*     name_Family,
*     name_Subfamily,
*     name_UniqueName,
*     name_FullName,
*     name_Version,
*     name_Postscript
* } sfnt_NameIndex;
*
*/

#if  0

#define NAME_ID_COPYRIGHT   0
#define NAME_ID_FAMILY      1
#define NAME_ID_SUBFAMILY   2
#define NAME_ID_UNIQNAME    3
#define NAME_ID_FULLNAME    4
#define NAME_ID_VERSION     5
#define NAME_ID_PSCRIPT     6
#define NAME_ID_TRADEMARK   7

#endif

// there are 19 tables (10 required + 9 optianal) defined in 1.0 revision
// of tt spec. We define this cut off arbitrarily (but bigger than 19)
// to get out of the loops rather than sit there and die;


#define MAX_TABLES 128

// size of some sfnt_xxx Structures as they are layed out on the disk:

#define SIZE_DIR_ENTRY        16
#define SIZE_NAMING_TABLE     6
#define SIZE_NAME_RECORD      12

// offsets into OS2 metrics table. Significant enough to be done by hand
// to ensure portability:

// original structure (from sfnt.h), version 0

/*
*
*
*   typedef struct {
*       uint16  Version;
*       int16   xAvgCharWidth;
*       uint16  usWeightClass;
*       uint16  usWidthClass;
*       int16   fsType;
*       int16   ySubscriptXSize;
*       int16   ySubscriptYSize;
*       int16   ySubscriptXOffset;
*       int16   ySubscriptYOffset;
*       int16   ySuperScriptXSize;
*       int16   ySuperScriptYSize;
*       int16   ySuperScriptXOffset;
*       int16   ySuperScriptYOffset;
*       int16   yStrikeOutSize;
*       int16   yStrikeOutPosition;
*       int16   sFamilyClass;
*       uint8   Panose [10];
*       uint32  ulCharRange [4];
*       char    achVendID [4];
*       uint16  usSelection;
*       uint16  usFirstChar;
*       uint16  usLastChar;
*   } sfnt_OS2;
*
*/



#define     OFF_OS2_Version               0
#define     OFF_OS2_xAvgCharWidth         2
#define     OFF_OS2_usWeightClass         4
#define     OFF_OS2_usWidthClass          6
#define     OFF_OS2_fsType                8
#define     OFF_OS2_ySubscriptXSize       10
#define     OFF_OS2_ySubscriptYSize       12
#define     OFF_OS2_ySubscriptXOffset     14
#define     OFF_OS2_ySubscriptYOffset     16
#define     OFF_OS2_ySuperScriptXSize     18
#define     OFF_OS2_ySuperScriptYSize     20
#define     OFF_OS2_ySuperScriptXOffset   22
#define     OFF_OS2_ySuperScriptYOffset   24
#define     OFF_OS2_yStrikeOutSize        26
#define     OFF_OS2_yStrikeOutPosition    28
#define     OFF_OS2_sFamilyClass          30
#define     OFF_OS2_Panose                32
#define     OFF_OS2_ulCharRange           42
#define     OFF_OS2_achVendID             58
#define     OFF_OS2_usSelection           62
#define     OFF_OS2_usFirstChar           64
#define     OFF_OS2_usLastChar            66


// these fields are defined in the spec but not in the sfnt.h structure above.
// I shall have to check whether these really exhist in tt files or not

#define     OFF_OS2_sTypoAscender         68
#define     OFF_OS2_sTypoDescender        70
#define     OFF_OS2_sTypoLineGap          72
#define     OFF_OS2_usWinAscent           74
#define     OFF_OS2_usWinDescent          76

// these two are added for version 200

#define     OFF_OS2_ulCodePageRange1      78
#define     OFF_OS2_ulCodePageRange2      82




// #define SIZE_OS2                        86

// values of some flags of the flag fields of the OS2 structure
//            taken from the tt spec


// fsType flags, notice bit 0x0001 is not used

#define TT_FSDEF_LICENSED        0x0002
#define TT_FSDEF_READONLY_ENCAPS 0x0004
#define TT_FSDEF_EDITABLE_ENCAPS 0x0008

#define TT_FSDEF_MASK  (TT_FSDEF_LICENSED|TT_FSDEF_READONLY_ENCAPS|TT_FSDEF_EDITABLE_ENCAPS)

// usSelection

#define TT_SEL_ITALIC            0x0001
#define TT_SEL_UNDERSCORE        0x0002
#define TT_SEL_NEGATIVE          0x0004
#define TT_SEL_OUTLINED          0x0008
#define TT_SEL_STRIKEOUT         0x0010
#define TT_SEL_BOLD              0x0020
#define TT_SEL_REGULAR           0x0040

//
// Macro to extract the big endian word at pj, really
// the correct equivalent of SWAPW macro, which does not assume
// that pj is word aligned.
//

#define BE_UINT16(pj)                                \
    (                                                \
        ((USHORT)(((PBYTE)(pj))[0]) << 8) |          \
        (USHORT)(((PBYTE)(pj))[1])                   \
    )


#define BE_INT16(pj)  ((SHORT)BE_UINT16(pj))


//
// macro to extract the big endian dword at pj, really
// a the correct equivalent of SWAPL macro, which does not assume
// that pj is DWORD aligned
//


#define BE_UINT32(pj)                                              \
    (                                                              \
        ((ULONG)BE_UINT16(pj) << 16) |                             \
        (ULONG)BE_UINT16((PBYTE)(pj) + 2)                          \
    )


#define BE_INT32(pj) ((LONG)BE_UINT32(pj))

// number of tt tables may change as we decide to add more tables to
// tt files, this list is extracted from sfnt_en.h

// required tables

//   tag_CharToIndexMap              // 'cmap'    0
//   tag_GlyphData                   // 'glyf'    1
//   tag_FontHeader                  // 'head'    2
//   tag_HoriHeader                  // 'hhea'    3
//   tag_HorizontalMetrics           // 'hmtx'    4
//   tag_IndexToLoc                  // 'loca'    5
//   tag_MaxProfile                  // 'maxp'    6
//   tag_NamingTable                 // 'name'    7
//   tag_Postscript                  // 'post'    8
//   tag_OS_2                        // 'OS/2'    9

// optional

//   tag_ControlValue                // 'cvt '    11
//   tag_FontProgram                 // 'fpgm'    12
//   tag_HoriDeviceMetrics           // 'hdmx'    13
//   tag_Kerning                     // 'kern'    14
//   tag_LSTH                        // 'LTSH'    15
//   tag_PreProgram                  // 'prep'    16
//   tag_GridfitAndScanProc          // 'gasp'    21
//   tag_BitmapLocation              // 'EBLC'    

//!!! not in the tt spec, but in defined in sfnt_en.h

//   tag_GlyphDirectory              // 'gdir'    17
//   tag_Editor0                     // 'edt0'    18
//   tag_Editor1                     // 'edt1'    19
//   tag_Encryption                  // 'cryp'    20

// REQUIRED TABLES

#define IT_REQ_CMAP    0
#define IT_REQ_GLYPH   1
#define IT_REQ_HEAD    2
#define IT_REQ_HHEAD   3
#define IT_REQ_HMTX    4
#define IT_REQ_LOCA    5
#define IT_REQ_MAXP    6
#define IT_REQ_NAME    7

#define C_REQ_TABLES   8

// optional tables

#define IT_OPT_OS2     0
#define IT_OPT_HDMX    1
#define IT_OPT_VDMX    2
#define IT_OPT_KERN    3
#define IT_OPT_LSTH    4
#define IT_OPT_POST    5
#define IT_OPT_GASP    6
#define IT_OPT_MORT    7 
#define IT_OPT_GSUB    8
#define IT_OPT_VMTX    9
#define IT_OPT_VHEA    10
#define IT_OPT_EBLC    11
#define C_OPT_TABLES   12

/*

// there are more optional tables, but ttfd is not
// using them so we are eliminating these from the code

#define IT_OPT_CVT
#define IT_OPT_FPGM
#define IT_OPT_PREP

// these are not mentioned in the spec (unless
// they are mentioned under a different name) but tags
// for them exhist in sfnt_en.h

#define IT_OPT_GDIR
#define IT_OPT_EDT0
#define IT_OPT_EDT1
#define IT_OPT_ENCR
#define IT_OPT_FOCA
#define IT_OPT_WIN

//!!! these ARE mentioned in the spec, but I found no tags for them
//!!! in the sfnt_en.h include file [bodind], I am putting the tags
//!!! here for now, until they are added to sfnt_en.h

*/



#define tag_Vdmx      0x56444d58
#define tag_Foca      0x666f6361
#define tag_Win       0x0077696e
// for far east support
#define tag_mort      0x6d6f7274 
#define tag_GSUB      0x47535542
#define tag_DSIG      'DSIG'

typedef struct _TABLE_ENTRY // te
{
    ULONG dp;  // offset to the beginning of the table
    ULONG cj;  // size of the table
} TABLE_ENTRY, *PTABLE_ENTRY;


typedef struct _TABLE_POINTERS // tptr
{
    TABLE_ENTRY ateReq[C_REQ_TABLES];
    TABLE_ENTRY ateOpt[C_OPT_TABLES];
} TABLE_POINTERS, *PTABLE_POINTERS;


// jeanp's functions

uint16 ui16UnicodeToMac (uint16 wc);
uint16 ui16Mac2Lang (uint16 Id);

#define CHAR_CODE(bToMac,wc)                                \
(                                                           \
(bToMac) ? ui16UnicodeToMac((uint16)(wc)) : (uint16)(wc)    \
)

// convert "os2" language id to the mac style lang id if this is a mac file

#define  CV_LANG_ID(ui16PlatformID, Id)                               \
(                                                                     \
(ui16PlatformID == BE_PLAT_ID_MS) ? (Id) : ui16Mac2Lang((uint16)(Id)) \
)

// magic number in big endian

#define BE_SFNT_MAGIC   0xF53C0F5F

// in order to understand this structure one needs to know
// the format of the table pmap  which is as follows
//
// typedef struct {
//     uint16 format;
//     uint16 length;
//     uint16 version;

// the three fields above are common for all formats

//     uint16 segCountX2;
//     uint16 searchRange;
//     uint16 entrySelector;
//     uint16 rangeShift;
//     uint16 endCount[segCount];
//     uint16 reservedPad;         // only God knows why
//     uint16 startCount[segCount];
//     uint16 idDelta[segCount];
//     uint16 idRangeOffset[segCount];
//     uint16 glyphIdArray[1];     // arbitrary length
// } CMAP_TABLE_IN_MSFT_FORMAT;
//
// Not all of these fields are relevant for us,
// we shall only need few of them. Their offsets
// from the beginning of the structure are as follows:
//

// cmap table  size and offsets

#define SIZEOF_CMAPTABLE  (3 * sizeof(uint16))

#define OFF_segCountX2  6
#define OFF_endCount    14


//
// offsets within kerning table
//

#define KERN_OFFSETOF_TABLE_VERSION             0
#define KERN_OFFSETOF_TABLE_NTABLES             1 * sizeof(USHORT)
#define KERN_SIZEOF_TABLE_HEADER                2 * sizeof(USHORT)

//
// offsets within a kerning sub table
//

#define KERN_OFFSETOF_SUBTABLE_VERSION          0
#define KERN_OFFSETOF_SUBTABLE_LENGTH           1 * sizeof(USHORT)
#define KERN_OFFSETOF_SUBTABLE_COVERAGE         2 * sizeof(USHORT)
#define KERN_OFFSETOF_SUBTABLE_NPAIRS           3 * sizeof(USHORT)
#define KERN_OFFSETOF_SUBTABLE_SEARCHRANGE      4 * sizeof(USHORT)
#define KERN_OFFSETOF_SUBTABLE_ENTRYSELECTOR    5 * sizeof(USHORT)
#define KERN_OFFSETOF_SUBTABLE_RANGESHIFT       6 * sizeof(USHORT)
#define KERN_SIZEOF_SUBTABLE_HEADER             7 * sizeof(USHORT)

#define KERN_OFFSETOF_ENTRY_LEFT                0
#define KERN_OFFSETOF_ENTRY_RIGHT               1 * sizeof(USHORT)
#define KERN_OFFSETOF_ENTRY_VALUE               2 * sizeof(USHORT)
#define KERN_SIZEOF_ENTRY                       2 * sizeof(USHORT) + sizeof(FWORD)

#define KERN_OFFSETOF_SUBTABLE_FORMAT           KERN_OFFSETOF_SUBTABLE_COVERAGE
#define KERN_WINDOWS_FORMAT                     0


// these functions are candidates to be bracketed the try/except


// FS_ENTRY fs_NewSfnt           (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_NewTransformation (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_NewGlyph          (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_GetAdvanceWidth   (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_ContourGridFit    (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_ContourNoGridFit  (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_FindBitMapSize    (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_ContourScan       (fs_GlyphInputType *, fs_GlyphInfoType *);




#define MAX_UINT8    0xff
#define MAX_INT8     0x7f
#define MIN_INT8     (-0x7f)
#define B_INT8(x)    (((x) <= MAX_INT8) && ((x) >= MIN_INT8))

#define MAX_UINT16   0xffff
#define MAX_INT16    0x7fff
#define MIN_INT16    (-0x7fff)
#define B_INT16(x)   (((x) <= MAX_INT16) && ((x) >= MIN_INT16))

#define MAX_UINT32  0xffffffff
#define MAX_INT32   0x7fffffff
#define MIN_INT32   (-0x7fffffff)
#define B_INT32(x)   (((x) <= MAX_INT32) && ((x) >= MIN_INT32))

typedef struct 
{
    int32   version;
    int16   ascent;
    int16   descent;
    int16   lineGap;
    int16   advanceHeightMax;
    int16   minTopSideBearing;
    int16   minBottomSideBearing;
    int16   yMaxExtent;
    int16   caretSlopeRise;
    int16   caretSlopeRun;
    int16   caretOffset;
    int16   reserved1;
    int16   reserved2;
    int16   reserved3;
    int16   reserved4;
    int16   metricDataFormat;
    uint16  numOfLongVerMetrics;
} sfnt_vheaTable;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\ttfd\vdmx.c ===
/******************************Module*Header*******************************\
* Module Name: vdmx.c
*
* Created: 03-Oct-1991 10:58:34
* Author: Jean-francois Peyroux [jeanp]
*
*     Microsoft Confidential
*
*         Copyright (c) Microsoft Corporation 1989, 1991
*
*         All Rights Reserved
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/


#include "fd.h"
#include "winfont.h"

#define LINEAR_TRESHOLD 255

#pragma pack(1)

typedef struct
{
  BYTE    bCharSet;       // Character set (0=all glyphs, 1=Windows ANSI subset
  BYTE    xRatio;         // Value to use for x-Ratio
  BYTE    yStartRatio;    // Starting y-Ratio value
  BYTE    yEndRatio;      // Ending y-Ratio value
}  RATIOS;

typedef struct
{
  USHORT  version;        // Version number for table (starts at 0)
  USHORT  numRecs;        // Number of VDMX groups present
  USHORT  numRatios;      // Number of aspect ratio groupings
} VDMX_HDR;

typedef struct
{
  USHORT  yPelHeight;     // yPelHeight (PPEM in Y) to which values apply
  SHORT   yMax;           // yMax (in pels) for this yPelHeight
  SHORT   yMin;           // yMin (in pels) for this yPelHeight
} VTABLE;

typedef struct
{
  USHORT  recs;           // Number of height records in this group.
  BYTE    startsz;        // Starting yPelHeight
  BYTE    endsz;          // Ending yPelHeight
} VDMX;

#pragma pack()

/******************************Public Routine*******************************
*
* BOOL   bSearchVdmxTable
*
* Description:
*
*   if em > 0
*       searches vdmx table for vA+vD == em. returns vA,vD (== em - vA), vEm
*   else // em < 0
*       searches vdmx table for vEm == em. returns vA,vD, vEm
*
* History:
*
*  Tue 21-Jul-1992 -by- Bodin Dresevic [BodinD]
* update: ported to NT
*   15 Nov 1991 -by-    Raymond E. Endres   [rayen]
* Added aspect ratio option and optimized the function.
*   3  Oct 1991 -by-    Jean-francois Peyroux   [jeanp]
* Wrote it.
**************************************************************************/

BOOL
bSearchVdmxTable (
    PBYTE     pjVdmx,
    ULONG     ResX,
    ULONG     ResY,
    INT       EM,     // NOT really EM, could be asc + desc wish in pixel units
    VTABLE    *pVTAB  // out put structure
    )
{
    USHORT    numRatios;        // VDMX_HDR.numRatios
    USHORT    numVtable;        // VDMX.recs, not VDMX_HDR.numRecs

    RATIOS   *pRatios;
    VDMX     *pVdmx;
    VTABLE   *pVtable;
    LONG      lRet, lRet2;
    UINT      i;
    BYTE      Abs_EM;

// do not call us if pjVdmx is null

    ASSERTDD (pjVdmx != (PBYTE)NULL, "pjVdmx == NULL\n");

// The following line is odd, but we keep it here for win31 compatibility.
// It is possible to have EM = +256, which corresponds to |ppem| < 256
// such that there is an entry for this -|ppem| in the table but
// yMax-yMin for this entry may be equal to 256. This in fact is the case
// with symbol.ttf font [bodind]

    if ((EM >= LINEAR_TRESHOLD) || (EM <= -LINEAR_TRESHOLD)) // assume EM > LINEAR_TRESHOLD scales linearly
        return FALSE;

// need to proceed to search vdmx table

    numRatios = SWAPW(((VDMX_HDR  *) pjVdmx)->numRatios);
    pRatios = (RATIOS  *) &((VDMX_HDR  *) pjVdmx)[1];

    for(i = 0; i < numRatios; i++)
    {
        if (pRatios[i].bCharSet == 1)
        {
        // must be Windows ANSI subset

            if (pRatios[i].xRatio == 0)
            {
                break;
            }           // auto match if 0
            else
            {                   // is it within aspect ratios
                lRet = ResY * pRatios[i].xRatio;
                lRet2= ResX * pRatios[i].yStartRatio;
                if (lRet >= lRet2)
                {
                    lRet2 = ResX * pRatios[i].yEndRatio;
                    if (lRet <= lRet2)
                        break;
                }
            }
        }
    }

    if (i == numRatios)  // did not find an aspect ratio match
        return FALSE;

// found an aspect ratio match

    pVdmx = (VDMX  *) (pjVdmx + SWAPW(((USHORT  *) &pRatios[numRatios])[i]));
    Abs_EM = (BYTE) (EM >=0 ? EM : - EM);

    if (EM > 0 || Abs_EM >= pVdmx->startsz && Abs_EM <= pVdmx->endsz)
    {
    // is there a Vtable for this EM

        pVtable = (VTABLE  *) &pVdmx[1];
        numVtable = SWAPW(pVdmx->recs);

        if (EM > 0)
        {
        // return the original yPelHeight

            for (i = 0; i < numVtable; i++)
            {
                pVTAB->yPelHeight = SWAPW(pVtable[i].yPelHeight);
                pVTAB->yMax       = SWAPW(pVtable[i].yMax);
                pVTAB->yMin       = SWAPW(pVtable[i].yMin);

            if ((pVTAB->yMax - pVTAB->yMin) == EM)
                {
                    return TRUE;
            }
            else if ((pVTAB->yMax - pVTAB->yMin) > EM)
                {
                    return FALSE;
            }
            }
        }
        else // return the actual em height in pixels
        {
            for (i = 0; i < numVtable; i++)
            {
                pVTAB->yPelHeight = SWAPW(pVtable[i].yPelHeight);
                pVTAB->yMax       = SWAPW(pVtable[i].yMax);
                pVTAB->yMin       = SWAPW(pVtable[i].yMin);

            if ((INT)pVTAB->yPelHeight == -EM)
                {
                    return TRUE;
            }
            else if ((INT)pVTAB->yPelHeight > -EM)
                {
                    return FALSE;
            }
            }
        }
    }
    return FALSE;
}

#ifdef THIS_IS_COMMENTED_PSEUDOCODE

// BASED ON THE DISCUSSION OF KIRKO, BODIND AND GILMANW WITH GUNTERZ

|INPUT:  hWish = wish height in pixel units
|
|OUTPUT: ascender, descender, ppem (all in pixel units) (dA,dD,dEm)
|
|
|    NOTATION:
|
|        dA = ascender in device/pixel space
|        nA = ascender in notional space
|        vA = ascender in vdmx table
|
|        dD = descender in device/pixel space
|        nD = descender in notional space
|        vD = descender in vdmx table
|
|        dEm = pixels per em in device space
|        nEm = em height in notional space
|        vEm = pixels per em in vdmx table
|
|
|LOCALS
|
|    LONG hTrial
|    LONG hEqualOrBelow
|    BOOL wasAbove
|    BOOL wasBelow
|
|PROCEDURE
|{
|    if (hWish < 0) then
|    {
|        <look in the vdmx and look for a vEm that matches -hWish>;
|        if (a match is found) then
|        {
|            dA = vA;
|            dD = vD;
|        }
|        else
|        {
|        //
|        // No Match is found in vdmx table, assume linear scaling
|        //
|            dA = round(nA * (-hWish) / nEm);
|            dD = round(nD * (-hWish) / nEm);
|        }
|        ppEm = -hWish;
|        return;
|    }
|
|//
|// hWish > 0
|//
|    <search the vdmx table for (vA + vD) that matches hWish>;
|    if (a match is found)
|    {
|        dA  = vA;
|        dCs = vD;
|        dEm = vEm;
|        return;
|    }
|
|//
|// Note, that from this point forward vA + vD never equals hWish
|// otherwise we would have found it in the step above
|//
|    ppemTrial = round(nEm * hWish / (nA + nD));
|
|    wasAbove = FALSE;
|    wasBelow = FALSE;
|
|    while (TRUE)
|    {
|        <search the vdmx table for vEm that matches ppemTrial>;
|        if (a match is found)
|        {
|            hTrial = vA + vD;
|        //
|        // This can't equal hWish (see above) so don't bother
|        // checking
|        }
|        else
|        {
|            hTrial = round(ppemTrial * (nA + nD) / nEm);
|            if (hTrial == hWish)
|            {
|                hEqualOrBelow = hTrial;
|                break;
|            }
|        }
|
|        if (hTrial < hWish)
|        {
|            hEqualOrBelow = hTrial;
|            if (wasAbove)
|                break;
|            ppemTrial = ppemTrial + 1;
|            wasBelow  = TRUE;
|        }
|        else
|        {
|            ppemTrial = ppemTrial - 1;   // <==== NEW POSITION
|            if (wasBelow)
|                break;
|                                         // <==== OLD POSITION
|            wasAbove = TRUE
|        }
|    }
|    dA  = round(ppemTrial * nA / nEm);
|    dD  = hEqualOrBelow - dA;
|    dEm = ppemTrial;
|    return;
|}.
|

#endif // THIS_IS_COMMENTED_PSEUDOCODE


/******************************Public*Routine******************************\
*
* VOID vQuantizeXform
*
* Effects: quantize the xform according to win31 recipe. as side effects
*          this routine may compute ascender and descener in device space
*          from vdmx table as well as number of pixels per M in device space.
*
* History:
*  25-Jul-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID
vQuantizeXform (
    PFONTCONTEXT pfc
    )
{
    BYTE  *pjView =  (BYTE *)pfc->pff->pvView;
    Fixed  fxMyy = pfc->mx.transform[1][1];
    PBYTE  pjVdmx  = (pfc->ptp->ateOpt[IT_OPT_VDMX].dp)          ?
                     (pjView + pfc->ptp->ateOpt[IT_OPT_VDMX].dp) :
                     NULL                                        ;

    LONG   hWish;
    VTABLE vtb, vtbPrev;

    LONG   ppemTrial, hTrial, yEmN, yHeightN;

    BOOL   bWasAbove, bWasBelow, bFound, bFoundPrev;

    sfnt_FontHeader * phead =
                      (sfnt_FontHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HEAD].dp);
    BYTE * pjOS2 = (pfc->ptp->ateOpt[IT_OPT_OS2].dp)         ?
                   (pjView + pfc->ptp->ateOpt[IT_OPT_OS2].dp):
                   NULL                                      ;

    yEmN = pfc->pff->ifi.fwdUnitsPerEm;

    if (!((pfc->flXform & XFORM_HORIZ) && (fxMyy > 0) && (pjVdmx != (PBYTE)NULL)))
    {
    // nothing to do, just return.

        return;
    }

// compute hWish in pixel coords. This is lfHeight from the logfont, except
// that it has been transformed to device pixel units and the sign is preserved

    if (pfc->flFontType & FO_EM_HEIGHT)
    {
        hWish = FixMul(fxMyy, -yEmN);
    }
    else // use tmp variable
    {
        yHeightN = pfc->pff->ifi.fwdWinAscender + pfc->pff->ifi.fwdWinDescender;
        hWish = FixMul(fxMyy, yHeightN);
    }

// quick out, all bSearchVdmxTable routines will fail if hWish is too big:



    if (bSearchVdmxTable(pjVdmx,
                         pfc->sizLogResPpi.cx,
                         pfc->sizLogResPpi.cy,
                         hWish,
                         &vtb)
    )
    {
        pfc->yMax = - vtb.yMin;
        pfc->yMin = - vtb.yMax;
        pfc->lEmHtDev = vtb.yPelHeight;

    // flag that dA and dD have been computed, do not scale linerly:

        pfc->flXform |= XFORM_VDMXEXTENTS;
    }
    else
    {
    // dA and dD will have to be computed using linear scaling
    // after the xform is quantized using win31 hacked recipe
    // get the notional space values which are needed for scaling

    // get the notional space values

        if (pjOS2)
        {
        // win 31 compatibility: we only take the max over win 31 char set:
        // all the glyphs outside this set, if they stand out will get chopped
        // off to match the height of the win31 char subset:

            yHeightN = BE_INT16(pjOS2 + OFF_OS2_usWinDescent) +
                       BE_INT16(pjOS2 + OFF_OS2_usWinAscent);
        }
        else
        {
            yHeightN = BE_INT16(&phead->yMax) - BE_INT16(&phead->yMin);
        }

        if (hWish < 0)
        {
            pfc->lEmHtDev = -hWish;
        }
        else // hWish > 0
        {
        // Note, that from this point forward vA + vD never equals hWish
        // otherwise we would have found it in the step above. This claim
        // is WRONG for only one reason. suppose hWish is 256. bSearchVdmxTable
        // will return FALSE because of the early exit test |EM| <= LINEAR_TRESHOLD
        // at the begininig of the routine. We have to keep this test in the
        // code for compatibility reasons. Now it is possible to have
        // ppemTrial <= LINEAR_TRESHOLD, so that bSearchVdmxTable will not hit the
        // early exit, and such that there exists an entry in the vdmx table
        // for this -ppemTrial, but with yMax-yMin == 256 == hWish.

            // ppemTrial = F16_16TOLROUND(yEmN * fxMyy);
            ppemTrial = FixMul(fxMyy, yEmN);

            bWasAbove  = FALSE;
            bWasBelow  = FALSE;
            bFound     = FALSE;
            bFoundPrev = FALSE; // save the value from the prev. loop

        // init the strucs

            vtb.yMin       = 0;
            vtb.yMax       = 0;
            vtb.yPelHeight = 0;
            vtbPrev        = vtb;

            for (;TRUE; bFoundPrev = bFound, vtbPrev = vtb)
            {
            // search the vdmx table for vEm that matches ppemTrial

                if
                (
                    bFound = bSearchVdmxTable(
                                     pjVdmx,
                                     pfc->sizLogResPpi.cx,
                                     pfc->sizLogResPpi.cy,
                                     -ppemTrial,
                                     &vtb)
                )
                {
                    hTrial = vtb.yMax - vtb.yMin;
                //
                // This can't equal hWish (see above) so don't bother
                // checking? WRONG!!! see teh comment above.

                    if (hTrial == hWish)
                    {
                    // This assert would be correct if it were not
                    // for occasional bugs in vdmx tables.
                    // In the case of Bell MT Regular, vA+vD = 0x13 for
                    // lEmHt = 0x0f which is STRICTLY bigger than
                    // vA+vD = 0x12 for lEmHt = 0x10 which is absurd.
                    // For this reason the first
                    // bSearchVdmxTable(EM = 0X12) fails to find an entry
                    // while the second bSearchVdmxTable(EM =- 0X10)
                    // DOES FIND an entry
                    // in vdmx table such that vA+vD=0x12, generating
                    // the commented assertion to bark. That is why we converted
                    // assertion to just print out a warning message.


                    #if DBG

                        // ASSERTGDI(hWish > LINEAR_TRESHOLD, "TTFD! hWish <= LINEAR_TRESHOLD\n");

                        if (hWish <= LINEAR_TRESHOLD)
                            TtfdDbgPrint("TTFD! hWish <= LINEAR_TRESHOLD\n");

                    #endif

                    /*   Bell MT Table:

    pVtable  -->    f800 ff08       //  F8 entries = numVtable,
                                    //  startsz = 8, endsz = ff
                    0800 0800 feff
                    0900 0900 feff
                    0a00 0900 fdff
                    0b00 0a00 fdff
                    0c00 0c00 fdff
                    0d00 0c00 fdff
                    0e00 0d00 fcff
                    0f00 0e00 fbff  <- yMax-yMin = 14-(-5) = 19 == 0X13
                    1000 0e00 fcff  <- yMax-yMin = 14-(-4) = 18 // problem
                    1100 0f00 fbff
                    1200 1100 fbff
                    1300 1100 fbff
                    ..............

                    */

                        pfc->yMax = - vtb.yMin;
                        pfc->yMin = - vtb.yMax;
                        pfc->lEmHtDev = vtb.yPelHeight;

                    // flag that dA and dD have been computed, do not scale linerly:

                        pfc->flXform |= XFORM_VDMXEXTENTS;
                        break;
                    }
                }
                else
                {
                    hTrial = LongMulDiv(ppemTrial, yHeightN, yEmN);

                    if (hTrial == hWish)
                    {
                        // hEqualOrBelow = hTrial;
                        break;
                    }
                }

                if (hTrial < hWish)
                {
                    // hEqualOrBelow = hTrial;
                    if (bWasAbove)
                    {
                        if (bFound) // just found this hTrial in the search above
                        {
                            pfc->yMax = - vtb.yMin;
                            pfc->yMin = - vtb.yMax;

                        // flag that dA and dD have been computed, do not scale linerly:

                            pfc->flXform |= XFORM_VDMXEXTENTS;
                        }
                        break;
                    }
                    ppemTrial = ppemTrial + 1;
                    bWasBelow  = TRUE;
                }
                else
                {
                    ppemTrial = ppemTrial - 1;   // <==== NEW POSITION
                    if (bWasBelow)
                    {
                        if (bFoundPrev) // just found this hTrial in the search above
                        {
                            ASSERTDD (ppemTrial == vtbPrev.yPelHeight,
                                      "vdmx logic screwed up");

                            pfc->yMax = - vtbPrev.yMin;
                            pfc->yMin = - vtbPrev.yMax;

                        // flag that dA and dD have been computed, do not scale linerly:

                            pfc->flXform |= XFORM_VDMXEXTENTS;
                        }
                        break;
                    }
                                             // <==== OLD POSITION
                    bWasAbove = TRUE;
                }
            }
            pfc->lEmHtDev = ppemTrial;
        }
    }

// the following line means quantizing:

    pfc->mx.transform[1][1] = FixDiv(pfc->lEmHtDev, yEmN);

// now fix xx component accordingly: xxNew = xxOld * (yyNew/yyOld)

// we do one final tweak with the transform here:
// If the difference between
// horizontal and vertical scaling is so small that the resulting
// avg font width is the same if we replace x scaling by y scaling
// than we will do it, which will result in diag transform and we will
// be able to use hdmx tables for this realization. By doing so
// we ensure that we get the same realization when we enumerate font
// and then use the logfont returned from enumeration to realize this font
// again.

    if
    (
        (pfc->mx.transform[0][0] == fxMyy) ||
        (FixMul(pfc->mx.transform[0][0] - pfc->mx.transform[1][1],
                (Fixed)pfc->pff->ifi.fwdAveCharWidth) == 0)
    )
    {
        pfc->mx.transform[0][0] = pfc->mx.transform[1][1];
    }
    else
    {
        pfc->mx.transform[0][0] = LongMulDiv(
                                      pfc->mx.transform[0][0],
                                      pfc->mx.transform[1][1],
                                      fxMyy
                                      );
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\ttfd\vertical.c ===
/******************************Module*Header*******************************\
* Module Name: vertical.c                                                  *
*                                                                          *
* vertical writing (@face) support functions                               *
* whole file should be #ifdef-ed with DBCS_VERT                            *
*                                                                          *
* Created: 18-Mar-1993 11:55:38                                            *
* Author: Takao Kitano [TakaoK]                                            *
*                                                                          *
* Copyright (c) 1993 Microsoft Corporation                                 *
\**************************************************************************/

#include "fd.h"
//#include "fontfile.h"
//#include "cvt.h"
//#include "limits.h"
//#include "winnls.h"


#ifdef DBCS_VERT_DEBUG
     ULONG DebugVertical = 0x0;

#endif

#if DBG
VOID CheckGlyphAttr(PTTC_FONTFILE pttc, PFD_GLYPHATTR pga, PFONTFILE pff);
#endif

//
// Glyph Metamorphosis table (mort) structures
//
typedef struct {
    uint16  entrySize;      // size in bytes of a lookup entry ( should be 4 )
    uint16  nEntries;       // number of lookup entries to be searched
    uint16  searchRange;
    uint16  entrySelector;
    uint16  rangeShift;
} BinSrchHeader;

typedef struct {
    uint16  glyphid1;       // the glyph index for the horizontal shape
    uint16  glyphid2;       // the glyph index for the vertical shape
} LookupSingle;

typedef struct {
    BYTE           constants1[12];
    uint32         length1;
    BYTE           onstants2[16];
    BYTE           constants3[16];
    BYTE           constants4[8];
    uint16         length2;
    BYTE           constants5[8];
    BinSrchHeader  SearchHeader;
    LookupSingle   entries[1];
} MortTable;

//
// Glyph Substitution table (GSUB) structures
//

#pragma pack(1)

typedef uint16  Offset;
typedef uint16  GlyphID;
typedef ULONG   Tag;

typedef struct {
    GlyphID         Start;
    GlyphID         End;
    uint16          StartCoverageIndex;
} RangeRecord;

typedef struct {
    uint16          CoverageFormat;
    union {
        struct {
            uint16  GlyphCount;
            GlyphID GlyphArray[1];
        } Type1;
        struct {
            uint16  RangeCount;
            RangeRecord RangeRecord[1];
        } Type2;
    } Format;
} Coverage;

typedef struct {
    uint16          SubstFormat;
    union {
        struct {
            Offset  Coverage;
            uint16  DeltaGlyphID;
        } Type1;
        struct {
            Offset  Coverage;
            uint16  GlyphCount;
            GlyphID Substitute[1];
        } Type2;
    } Format;
} SingleSubst;

typedef struct {
    uint32         Version;
    Offset         ScriptListOffset;
    Offset         FeatureListOffset;
    Offset         LookupListOffset[];
} GsubTable;

typedef struct {
    uint16         LookupType;
    uint16         LookupFlag;
    uint16         SubtableCount;
    Offset         Subtable[1];
} Lookup;

typedef struct {
    uint16         LookupCount;
    Offset         Lookup[1];
} LookupList;

typedef struct {
    Offset         FeatureParams;
    uint16         LookupCount;
    uint16         LookupListIndex[1];
} Feature;

typedef struct {
    Tag            FeatureTag;
    Offset         FeatureOffset;
} FeatureRecord;

typedef struct {
    uint16         FeatureCount;
    FeatureRecord  FeatureRecord[1];
} FeatureList;

typedef struct {
    Offset         LookupOrderOffset;
    uint16         ReqFeatureIndex;
    uint16         FeatureCount;
    uint16         FeatureIndex[1];
} LangSys;

typedef struct {
    Tag            LangSysTag;
    Offset         LangSysOffset;
} LangSysRecord;

typedef struct {
    Offset         DefaultLangSysOffset;
    uint16         LangSysCount;
    LangSysRecord  LangSysRecord[1];
} Script;

typedef struct {
    Tag            ScriptTag;
    Offset         ScriptOffset;
} ScriptRecord;

typedef struct {
    uint16         ScriptCount;
    ScriptRecord   ScriptRecord[1];
} ScriptList;


#pragma pack()

/******************************Public*Routine******************************\
*
* bCheckVerticalTable()
*
* History:
*  12-Apr-1995 -by- Hideyuki Nagase [HideyukN]
* Wrote it.
\**************************************************************************/

BOOL bCheckVerticalTable(
 PFONTFILE pff
 )
{

// Get vertical metrics information if this font has it.  Don't use the
// the vertical metrics table for a fixed pitch DBCS font because
// a) we don't need it and
// b) embeded bitmaps for these fonts can't be layed
//    out using the vertical metrics table.

// !!! for NT 5.0 we need to elminate the hacks for embeded bitmaps
// (such as gulim fix) and do something to detect when we are using
// embeded bitmaps and use the appropriate tables, etc to compute metrics
// and the like. [gerritv]

    if(pff->ffca.tp.ateOpt[IT_OPT_VHEA].dp != 0 &&
       pff->ffca.tp.ateOpt[IT_OPT_VMTX].dp != 0 )
    {
        sfnt_vheaTable *pvheaTable;

        pvheaTable = (sfnt_vheaTable *)((BYTE *)(pff->pvView) +
                                       pff->ffca.tp.ateOpt[IT_OPT_VHEA].dp);
        pff->ffca.uLongVerticalMetrics = (uint16) SWAPW(pvheaTable->numOfLongVerMetrics);
    }
    else
    {
        pff->ffca.uLongVerticalMetrics = 0;
    }


    //
    // Is GSUB table present ?
    //
    if( pff->ffca.tp.ateOpt[ IT_OPT_GSUB ].cj != 0 &&
               pff->ffca.tp.ateOpt[ IT_OPT_GSUB ].dp != 0    )
    {
        //
        // Check this GSUB table is for Vertical Glyphs ?
        //

        GsubTable   *pGsubTable;
        ScriptList  *pScriptList;
        FeatureList *pFeatureList;
        LookupList  *pLookupList;

        ULONG dpGsubTable;
        ULONG dpScriptList;
        ULONG dpFeatureList;
        ULONG dpLookupList;

        INT    ii;
        USHORT LookupIndex;
        ULONG  VerticalLookupOffset = 0;
        ULONG  VerticalFeatureOffset = 0;
        ULONG  VerticalSubtableOffset = 0;

        Feature *pFeature;
        Lookup  *pLookup;

        dpGsubTable   = pff->ffca.tp.ateOpt[ IT_OPT_GSUB ].dp;
        pGsubTable    = (GsubTable *)((BYTE *)(pff->pvView) + dpGsubTable);

        dpScriptList  = BE_UINT16(&pGsubTable->ScriptListOffset);
        dpFeatureList = BE_UINT16(&pGsubTable->FeatureListOffset);
        dpLookupList  = BE_UINT16(&pGsubTable->LookupListOffset);

        pScriptList  = (ScriptList *)((BYTE *)pGsubTable + dpScriptList);
        pFeatureList = (FeatureList *)((BYTE *)pGsubTable + dpFeatureList);
        pLookupList  = (LookupList *)((BYTE *)pGsubTable + dpLookupList);

        #if DBG_MORE
        TtfdDbgPrint("TTFD!GsubTable   - %x\n",pGsubTable);
        TtfdDbgPrint("TTFD!ScriptList  - %x\n",pScriptList);
        TtfdDbgPrint("TTFD!FeatureList - %x\n",pFeatureList);
        TtfdDbgPrint("TTFD!LookupList  - %x\n",pLookupList);
        #endif

        //
        // Search 'vert' Tag from FeatureList....
        //
        #define tag_vert 0x74726576

        for( ii = 0;
             ii < BE_INT16(&pFeatureList->FeatureCount) ;
             ii++ )
        {
            if( pFeatureList->FeatureRecord[ii].FeatureTag == tag_vert )
            {
                VerticalFeatureOffset = BE_UINT16(
                                          &(pFeatureList->FeatureRecord[ii].FeatureOffset)
                                        );
                #if DBG_MORE
                TtfdDbgPrint("TTFD:VerticalFeature - %x\n",VerticalFeatureOffset);
                #endif
                break;
            }
        }

        //
        // if we could not find out 'vert' tag, this is a not vertical font.
        //

        if( VerticalFeatureOffset == 0 )
        {
            WARNING("TTFD!Could not find 'vert' tag in FeatureList\n");
            return(FALSE);
        }

        //
        // Vertical feature offset contains offset from FeatureList...
        // adjust it to offset from GsubTable..
        //

        VerticalFeatureOffset += dpFeatureList;

        //
        // Compute pointer to Feature offset.
        //

        pFeature = (Feature *)((BYTE *)pGsubTable + VerticalFeatureOffset);

        //
        // for Vertical glyph substitution, the lookup count should be 1.
        //

        if( BE_UINT16(&pFeature->LookupCount) != 1 )
        {
            WARNING("pFeature->LookupCount != 1\n");
            return(FALSE);
        }

        //
        // make sure the Lookup list has a entry for this feature....
        //

        LookupIndex = BE_UINT16(&(pFeature->LookupListIndex[0]));

        if( BE_UINT16(&pLookupList->LookupCount) < LookupIndex )
        {
            WARNING("LookupIndex < LookupCount\n");
            return(FALSE);
        }

        //
        // Compute pointer to Lookup..
        //

        VerticalLookupOffset = BE_UINT16(&(pLookupList->Lookup[LookupIndex]));
        pLookup = (Lookup *)((BYTE *)pLookupList + VerticalLookupOffset);

        #if DBG_MORE
        TtfdDbgPrint("pLookup - %x\n",pLookup);
        #endif

        //
        // Check Lookup Type, it should be 1 (='Single') for vertical font.
        //

        if( BE_UINT16(&pLookup->LookupType) != 1 )
        {
            WARNING("LookupType != 1\n");
            return(FALSE);
        }

        //
        // Check subtable count.. it should be 1 for vertical font.
        //

        if( BE_UINT16(&pLookup->SubtableCount) != 1 )
        {
            WARNING("SubTableCount != 1\n");
            return(FALSE);
        }

        //
        // Compute offset to subtable from FileTop...
        //

        VerticalSubtableOffset = BE_UINT16(&(pLookup->Subtable[0]));
        VerticalSubtableOffset += VerticalLookupOffset;
        VerticalSubtableOffset += dpLookupList;
        VerticalSubtableOffset += dpGsubTable;

        #if DBG_MORE
        TtfdDbgPrint("Subtable Offset - %x\n",VerticalSubtableOffset);
        #endif

        pff->ffca.ulVerticalTableOffset = VerticalSubtableOffset;
        pff->hgSearchVerticalGlyph = SearchGsubTable;
        return(TRUE);
    }

    //
    // Is mort table present ?
    //
    else if( pff->ffca.tp.ateOpt[ IT_OPT_MORT ].cj != 0 &&
        pff->ffca.tp.ateOpt[ IT_OPT_MORT ].dp != 0    )
    {
        pff->ffca.ulVerticalTableOffset = pff->ffca.tp.ateOpt[ IT_OPT_MORT ].dp;
        pff->hgSearchVerticalGlyph = SearchMortTable;
        return(TRUE);
    }
     else
    {
        //
        // Set dummy..
        //
        pff->ffca.ulVerticalTableOffset = 0;
        pff->hgSearchVerticalGlyph = SearchDummyTable;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
*
* SearchDummyTable()
*
* History:
*  14-Jan-1996 -by- Hideyuki Nagase [HideyukN]
* Wrote it.
\**************************************************************************/

ULONG SearchDummyTable(
 FONTFILE   *pff,
 ULONG      ig,              // glyph index
 BOOL       bDump
 )
{
    return ig;
}

/******************************Public*Routine******************************\
*
* SearhVerticalGlyphIndex( FONTCONTEXT *pfc, ULONG ig )
*
* If there is glyph index for the vertical shape, returns
* the glyph index of vertical shape, else returns same
* glyph index as specified.
*
* History:
*  04-Apr-1993 -by- Takao Kitano [TakaoK]
* Wrote it.
\**************************************************************************/

ULONG SearchMortTable(
 FONTFILE   *pff,
 ULONG      ig,              // glyph index
 BOOL       bDump
 )
{
    MortTable      *pMortTable;
    BinSrchHeader  *pHeader;
    LookupSingle   *pLookup;
    USHORT         n;

    pMortTable = (MortTable *)((BYTE *)(pff->pvView) +
                                       (pff->ffca.ulVerticalTableOffset));

    #if DBG
    if ( pMortTable == NULL )
    {
        WARNING("pMortTable == NULL\n");
        return ig;
    }
    #endif

    pHeader = &pMortTable->SearchHeader;

//
// If you have time, you may want to change the loop from the straight search
// to the binary search. Currently kanji truetype font has about 110 entries
// for alternative glyphs. [takaok]
//
    if (bDump)
    {
        if ((USHORT) ig < BE_UINT16(&pHeader->nEntries))
        {
            pLookup = &pMortTable->entries[(USHORT)ig];
            return ( BE_UINT16( &pLookup->glyphid2 ) );
        } 
    }
    else
    {
        for ( pLookup = &pMortTable->entries[0], n = BE_UINT16(&pHeader->nEntries);
              n > 0;
              n--, pLookup++
            )
        {
            if ( ig == (ULONG)BE_UINT16( &pLookup->glyphid1 ) )
                return ( BE_UINT16( &pLookup->glyphid2 ) );
        }
    }
    return ( ig );
}

/******************************Public*Routine******************************\
*
* SearchGsubTable()
*
* History:
*  12-Apr-1995 -by- Hideyuki Nagase [HideyukN]
* Wrote it.
\**************************************************************************/

ULONG SearchGsubTable(
 FONTFILE    *pff,
 ULONG       ig,              // glyph index
 BOOL        bDump
 )
{
    SingleSubst *pSingleSubst;

    pSingleSubst = (SingleSubst *)((BYTE *)(pff->pvView) +
                                           (pff->ffca.ulVerticalTableOffset));

    //
    // Check subtable format...
    //

    if( BE_UINT16(&pSingleSubst->SubstFormat) == 2 )
    {
        Coverage *pCoverage;

        pCoverage = (Coverage *)
                     ((BYTE *)pSingleSubst +
                      BE_UINT16(&(pSingleSubst->Format.Type2.Coverage)));

        //
        // Check Coverage format...
        //

        if( BE_UINT16(&pCoverage->CoverageFormat) == 1 )
        {
            USHORT  ii;
            GlyphID *pGlyphArray;
            GlyphID *pGlyphSubstArray;

            pGlyphArray = pCoverage->Format.Type1.GlyphArray;
            pGlyphSubstArray = pSingleSubst->Format.Type2.Substitute;

            if (bDump)
            {
                if ((USHORT) ig < BE_UINT16(&(pCoverage->Format.Type1.GlyphCount)))
                    return((ULONG)BE_UINT16(&(pGlyphSubstArray[ig])));
            }
            else
            {
                for( ii = 0;
                     ii < BE_UINT16(&(pCoverage->Format.Type1.GlyphCount)) ;
                     ii ++ )
                {
                    if( ig == (ULONG)BE_UINT16(&(pGlyphArray[ii])) )
                        return( (ULONG)BE_UINT16(&(pGlyphSubstArray[ii])) );
                }
            }
        }
         else
        {
            WARNING("TTFD:Unsupported CoverageFormat\n");
        }
    }
     else
    {
        WARNING("TTFD:Unsupported SubstFormat\n");
    }

    return(ig);
}

/******************************Public*Routine******************************\
*
* vCalcXformVertical
*
* Right now, we assume all the width of glyphs that need to be rotated
* for @face are same. ( I mean all kanji character has same width. )
* So a single transformation is applied to all rotated glyphs.
*
* Before the final release, we need to change this scheme. We will
* check the advanceWidth in notional space ( please refer to
* vGetNotionalGlyphMetrics ). If the advanceWidth of specified
* glyph is different than the maxCharInc, we will compute the
* transformation matrix dynamically. [takaok]
*
* History:
*  19-Mar-1993 -by- Takao Kitano [TakaoK]
* Wrote it.
\**************************************************************************/

VOID vCalcXformVertical(FONTCONTEXT  *pfc)
{
    LONG lHeight, lAscender, lDescender;

    lAscender  = (LONG)pfc->pff->ifi.fwdTypoAscender;
    lDescender = (LONG)pfc->pff->ifi.fwdTypoDescender;


#ifdef DBCS_VERT_DEBUG
    if ( DebugVertical & DEBUG_VERTICAL_CALL )
    {
        TtfdDbgPrint("TTFD!bGetNotionalHeightAndWidth(Ascent=%ld, Descent=%ld )\n",
                 lAscender, lDescender);
    }
#endif

// old comment, here just for historic reasons [bodind]
//
// [ 90 degree rotation ]
//
// In the truetype rasterizer, 90 degree rotation matrix looks like this:
//
//   A
//  Y|             [  cos90  sin90 ]   [ 0   1 ]
//   |             [               ] = [       ]
//   |      X      [ -sin90  cos90 ]   [ -1  0 ]
//   +------->
//
// [ X-Y scaling ]
//
// We don't want to change the character box shape after the rotation.
//
//   [ h/w   0  ]   where  w: notional space width = IFIMETRICS.aveCharWidth
//   [          ]
//   [  0   w/h ]          h: notional space height = IFIMETRICS.Ascender +
//                                                    IFIMETRICS.Descender
//
// We are multiplying the scaling matrix from the left because the
// scaling matrix acts first on the notinal space vectors on the left
//
//  ((x,y)*A)*B = (x,y)*(A*B)
//
//  [ h/w   0  ]   [  0   1 ]   [  0    h/w ]
//  [          ] * [        ] = [           ]
//  [  0   w/h ]   [ -1   0 ]   [ -w/h   0  ] ... this is it! [rotation] * [scaling] matrix
//
// We are multiplying from the left because the [ scaling * rotation ] matrix
// acts first on the notional space vectors on the left
//
//  [ 0      h/w ]   [ m00  m01 ]   [   m10 * h / w        m11 * h / w  ]
//  [            ] * [          ] = [                                   ]
//  [-w/h     0  ]   [ m10  m11 ]   [  -m00 * w / h       -m01 * w / h  ]
//
// old comment, end

// old comment, here just for historic reasons [bodind]
//
// compute shift parameters in device space
// coordinate system is truetype coordinate.
//
// At early stage of development, I put the following shift
// information into the matrix passed to the scaler.
// However I don't know why but the scaler just ignores
// the X and Y shift values. In windows 3.1J, they
// changes the scaler interface ( fs_xxx ) and give the scaler
// X and Y shift information. For NT-J, I don't want to change
// the scaler interface. Following shift values are applied
// after we got bitmap information from scaler. [takaok]
//
// old comment, end


// new comment:
// When we rotate dbcs characters we do not want to deform them,
// we want to leave the natural aspect ratio of these glyphs.
// For vertical writing the base line for dbcs glyphs that need to be rotated
// goes through the middle of the glyphs, for sbcs characters stays the same.
// Shift vector computed below does this job. Also, for older fixed pitch fe
// fonts, where dbcs glyphs have the w == h and sbcs glyphs have width = w/2 for
// dbcs and height the same for as for dbcs, these formulas become the old
// formulas we used to have.

    pfc->mxv.transform[0][0] =  pfc->mxn.transform[1][0];
    pfc->mxv.transform[0][1] =  pfc->mxn.transform[1][1];
    pfc->mxv.transform[1][0] =  -pfc->mxn.transform[0][0];
    pfc->mxv.transform[1][1] =  -pfc->mxn.transform[0][1];

// ClaudeBe, from the client interface Doc :
// Please note that although the third column of the matrix is defined as Fixed numbers 
// you will actually need to use  Fract numbers in that column. The higher resolution provided 
// by Fracts is required to change the perspective of a glyph. Fracts are 2.30 fixed point numbers.

    pfc->mxv.transform[2][2] = ONEFRAC;
    pfc->mxv.transform[0][2] = (Fixed)0;
    pfc->mxv.transform[1][2] = (Fixed)0;
    pfc->mxv.transform[2][0] = (Fixed)0;
    pfc->mxv.transform[2][1] = (Fixed)0;

    {
        Fixed lX;
        Fixed lY;

    // shift value in notional space
    // We will position dbcs glyphs so that the centers of dbcs glyphs
    // are aligned with the mid line going through Height of sbcs glyphs.
    // fxdevShift computation below does exactly that. [bodind]

        lX = LTOF16_16(lAscender);
        lY = LTOF16_16(lDescender);
    // shift value in device space

        pfc->fxdevShiftX = FixMul(pfc->mx.transform[0][0], lX) +
                           FixMul(pfc->mx.transform[1][0], lY);
        pfc->fxdevShiftY = FixMul(pfc->mx.transform[0][1], lX) +
                           FixMul(pfc->mx.transform[1][1], lY);
    }

#ifdef DBCS_VERT_DEBUG
    if ( DebugVertical & DEBUG_VERTICAL_XFORM )
    {
        TtfdDbgPrint("vCalcXformVertical pfc->mx00 =0x%lx, 11=0x%lx, 01=0x%lx, 10=0x%lx \n",
                  pfc->mx.transform[0][0],
                  pfc->mx.transform[1][1],
                  pfc->mx.transform[0][1],
                  pfc->mx.transform[1][0] );
        TtfdDbgPrint("vCalcXformVertical mxn:00=0x%lx, 11=0x%lx, 01=0x%lx, 10=0x%lx \n",
                  pfc->mxn.transform[0][0],
                  pfc->mxn.transform[1][1],
                  pfc->mxn.transform[0][1],
                  pfc->mxn.transform[1][0] );
        TtfdDbgPrint("                  mxv:00=0x%lx, 11=0x%lx, 01=0x%lx, 10=0x%lx \n",
                  pfc->mxv.transform[0][0],
                  pfc->mxv.transform[1][1],
                  pfc->mxv.transform[0][1],
                  pfc->mxv.transform[1][0] );
        TtfdDbgPrint("                   devShiftX=%ld, devShiftY=%ld \n",
                  F16_16TOLROUND(pfc->fxdevShiftX),F16_16TOLROUND(pfc->fxdevShiftY));
    }
#endif
}

/******************************Public*Routine******************************\
*
* BOOL IsFullWidth( WCHAR wc)
*
* Returns TRUE if specified unicode codepoint is corresponding to
* double byte character in multibyte codepage.
*
* History:
*  10-Nov-1995 Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

typedef struct _VERTICAL_UNICODE {
    WCHAR Start;
    WCHAR End;
} VERTICAL_UNICODE, *PVERTICAL_UNICODE;

#define NUM_VERTICAL_UNICODES  (sizeof(VerticalUnicodes)/sizeof(VerticalUnicodes[0]))

// A sorted range from the specification
// But this range will not be the optimized
// So just for the reference
/*
VERTICAL_UNICODE VerticalUnicodes[] = {
    { 0x1100, 0x11f9 },     // Hangul Jamo
    { 0x2010, 0x206f },     // General Punctuation, 
    { 0x2100, 0x2138 },     // Letterlike Symbols 
    { 0x2460, 0x24EA },     // Enclosed Alphanumerics
    { 0x25A0, 0x25EF },     // Geometric Shapes
    { 0x2600, 0x266F },     // Miscellaneious Symbols 
    { 0x2700, 0x27BE },     // Dingbats 
    { 0x3001, 0x303f },     // CJK Symbols and Punctuation 
    { 0x3040, 0x309F },     // HIRAGANA
    { 0x30A0, 0x30FF },     // KATAKANA
    { 0x3105, 0x312c },     // Bopomofo
    { 0x3131, 0x318e },     // Hangul Compatibility Jamo         
    { 0x3190, 0x319f },     // Kanbun (CJK Miscellaneous) 
    { 0x3200, 0x32ff },     // Enclosed CJK Letters & Months 
    { 0x3300, 0x33ff },     // CJK Compatibility, 
    { 0x3400, 0x4Dff },     // ExtA range
    { 0x4E00, 0x9FFF },     // CJK_UNIFIED_IDOGRAPHS
    { 0xAC00, 0xD7A3 },     // HANGUL
    { 0xe000, 0xf8ff },     // Private Use Area (PUA)
    { 0xf900, 0xfaff },     // CJK Compatibility Ideographs
    { 0xfe30, 0xfe4f },     // CJK Compatibility forms 
    { 0xff01, 0xff5e },     // Halfwidth  
                            // Note: halfwidth Katakana and hangul are not included. 
    { 0xffe0, 0xffee }      // Fullwidth forms 

};
*/


// Most frequent used rang
VERTICAL_UNICODE VerticalUnicodes[] = {
    { 0x1100, 0x11ff },     // Hangul Jamo
    { 0x2000, 0x206f },     // General Punctuation, 
    { 0x2100, 0x214f },     // Letterlike Symbols 
    { 0x2460, 0x24ff },     // Enclosed Alphanumerics
//    { 0x25A0, 0x25FF },     // Geometric Shapes
//    { 0x2600, 0x26FF },     // Miscellaneious Symbols 
    { 0x25A0, 0x27FF },      // Dingbats 
//    { 0x3001, 0x303f },     // CJK Symbols and Punctuation 
//    { 0x3040, 0x309F },     // HIRAGANA
//    { 0x30A0, 0x30FF },     // KATAKANA
//    { 0x3100, 0x312f },     // Bopomofo
//    { 0x3130, 0x318f },     // Hangul Compatibility Jamo         
//    { 0x3190, 0x319f },     // Kanbun (CJK Miscellaneous) 
    { 0x3001, 0x319F },     // KATA merged with the above 3 items
//    { 0x3200, 0x32ff },     // Enclosed CJK Letters & Months 
//    { 0x3300, 0x33ff },     // CJK Compatibility, 
//    { 0x3400, 0x4Dff },     // ExtA range
    { 0x3200, 0x4Dff },     // Merge above 3 sub-range
    { 0x4E00, 0x9FFF },     // CJK_UNIFIED_IDOGRAPHS
    { 0xAC00, 0xD7A3 },     // HANGUL
//    { 0xe000, 0xf8ff },     // Private Use Area (PUA)
//    { 0xf900, 0xfaff },     // CJK Compatibility Ideographs
    { 0xe000, 0xfaff },     // Merged with the above 2 items
    { 0xfe30, 0xfe4f },     // CJK Compatibility forms 
    { 0xff01, 0xff5e },     // Halfwidth  
                            // Note: halfwidth Katakana and hangul are not included. 
    { 0xffe0, 0xffee }      // Fullwidth forms 
};


BYTE glyphBits[8] = {0x80, 0x40, 0x20, 0x10, 0x8, 0x4, 0x2, 0x1};

BOOL IsLocalDbcsCharacter(ULONG uiFontCodePage, WCHAR wc)
{
    INT             index;
    int             cwc;
    char            ach[2];

    // Error handling in case, we do not have enough memory to allocate.
    // Then we will process through the old code.

    if ((wc >= VerticalUnicodes[0].Start) && (wc <= VerticalUnicodes[NUM_VERTICAL_UNICODES - 1].End))
    {
        for (index = 0; index < NUM_VERTICAL_UNICODES; index++)
        {
            if ((wc >= VerticalUnicodes[index].Start) &&
                 (wc <= VerticalUnicodes[index].End)      )
            {
                return (TRUE);
            }
        }
    }

    // if this Unicode character is mapped to Double-Byte character,
    // this is also full-width character..

    cwc = EngWideCharToMultiByte(uiFontCodePage,&wc,sizeof(WCHAR),ach,2);

    return( cwc > 1 ? TRUE : FALSE );

}

BOOL IsFullWidthCharacter(FONTFILE *pff, HGLYPH hg)
{
    ASSERTDD(pff->pttc->pga, "pga must not be NULL\n");

    // The glyph index could be invalid in some fonts
    if (hg < pff->pttc->pga->cGlyphs)
    {
        return(pff->pttc->pga->aGlyphAttr[hg / 8] & (glyphBits[hg % 8]));
    }
    else
    {
        return FALSE;
    }
}


#if 0

/******************************Public*Routine******************************\
*
* VOID vMapGlyphIndexToAttrBit(PFD_GLYPHATTR pga, PHGLYPH phg, ULONG cGlyphs)
*
* Make a bit array, when each bit is on, it indicate the glyph no need to rotate
*                                    off, the glyph is DBCS and need to ratate       
* 
* History:
*  5-28-1998 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

VOID MapGsubToGlyphAttr(FONTFILE *pff, PFD_GLYPHATTR pga)
{
    HGLYPH  hg, hgTmp;

    if (pff->hgSearchVerticalGlyph)
    {
        hg = 0;
        while (1)
        {
            hgTmp = (*pff->hgSearchVerticalGlyph)(pff, hg, TRUE);

            if ( hgTmp == hg)
                break;
            else
            {
            // The glyph index could be invalid in some fonts
                if (hgTmp < pga->cGlyphs)
                {
                    pga->aGlyphAttr[hgTmp / 8] |= glyphBits[hgTmp % 8];
                }
            }

            hg++;
        }
    }

}

#endif

/******************************Public*Routine******************************\
*
* BOOL bComputeGlyphAttrBits(PTTC_FONTFILE pttc, PFONTFILE pff)
*
* Make a bit array, when each bit is on, it indicate the glyph no need to rotate
*                                    off, the glyph is DBCS and need to ratate       
* 
* History:
*  5-28-1998 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

BOOL bComputeGlyphAttrBits(PTTC_FONTFILE pttc, PFONTFILE pff)
{
    PIFIMETRICS     pifi;
    IFIEXTRA        *pifiex;
    PFONTFILE       pffTmp;
    PFD_GLYPHATTR   pga;
    PWCRUN          pwcruns, pwcrunsEnd;
    PHGLYPH         phg;
    HGLYPH          hGlyph;
    WCHAR           wcLow, wcHigh;
    WCHAR           wcStart, wcEnd;
    BOOL            bBug;
    PFD_GLYPHSET    pgset;
    ULONG           cj;
    ULONG           i;

    ASSERTDD(!pttc->pga, "error calling bComputeGlyphAttrBits\n");

    pffTmp = PFF(pttc->ahffEntry[0].hff);

    pifi = (PIFIMETRICS) &pffTmp->ifi;
    pifiex = (IFIEXTRA *)(pifi + 1);

    cj = offsetof(FD_GLYPHATTR,aGlyphAttr) + ((pifiex->cig + 7) / 8);

    pga = PV_ALLOC(cj);

// Alloc memory failed, need to return faliure

    if (!pga)
        return FALSE;

// first set all the bits to 0

    RtlZeroMemory((PVOID)pga, cj);

// Alloc the total glyph bits

    pga->cjThis = cj;
    pga->cGlyphs = pifiex->cig;
    pga->iMode = FO_ATTR_MODE_ROTATE;

    for( i = 0; i < pttc->ulNumEntry; i++ )
    {

    // go only through horizontal faces, the bits for the glyphs in the @faces will be set
    // by looking into substitution tables.

        if (pttc->ahffEntry[i].iFace == 1)
        {
            BOOL        bVertical = FALSE;
            PWCRUN      pwcrunsv = NULL;
            PHGLYPH     phgv = NULL;

            pffTmp = PFF(pttc->ahffEntry[i].hff);
            pgset = pffTmp->pgset;
            pwcruns = &pffTmp->pgset->awcrun[0];
            pwcrunsEnd = pwcruns + pgset->cRuns;

            if (pffTmp->pgsetv)
            {
                pwcrunsv = &pffTmp->pgsetv->awcrun[0];
                bVertical = TRUE;
            }

            while ((pwcruns < pwcrunsEnd))
            {
                wcLow = pwcruns->wcLow;
                wcHigh = pwcruns->wcLow + pwcruns->cGlyphs - 1;
                phg = pwcruns->phg;

                if (bVertical)
                    phgv = pwcrunsv->phg;

                if (wcLow < 0xffff)
                {
                    while (wcLow <= wcHigh)
                    {
                        if (IsLocalDbcsCharacter(pff->ffca.uiFontCodePage, wcLow))
                        {
                            // Buggy font might break it, so we need to guard it.
                            if( *phg < pga->cGlyphs)
                            {
                                pga->aGlyphAttr[*phg / 8] |= glyphBits[*phg % 8];

                                // we can optimize this part of code
                                if ( bVertical && (*phg != *phgv) && (*phgv < pga->cGlyphs))
                                {
                                    pga->aGlyphAttr[*phgv / 8] |= glyphBits[*phgv % 8];
                                }
                            }
                        }
                        phg++;
                        wcLow++;
                        // A tricky step, we do not care about it if bVertical != TRUE
                        phgv++;
                    }
                }

                pwcruns++;
                pwcrunsv++; // same trick as phgv
            }
       }
    }

// Map glyphs in GSUB / MORT to Attribute bits, presently we do not do this because
// we found that in some FE fonts there are indices there that have no dbcs equivalents

//    MapGsubToGlyphAttr(pff, pga);

    pttc->pga = pga;

#if DBG
    CheckGlyphAttr(pttc, pga, pff);
#endif

    return TRUE;
}

/******************************Public*Routine******************************\
*
* BOOL bChangeXform( PFONTCONTEXT pfc, BOOL bRotation )
*
*
* if bRotation is TRUE: call the scaler with rotated transform.
*                FALSE: call the scaler with normal transform.
*
* History:
*  19-Mar-1993 -by- Takao Kitano [TakaoK]
* Wrote it.
\**************************************************************************/

BOOL bChangeXform( PFONTCONTEXT pfc, BOOL bRotation)
{
    FS_ENTRY    iRet;

#ifdef DBCS_VERT_DEBUG
    if ( DebugVertical & DEBUG_VERTICAL_CALL )
    {
        TtfdDbgPrint("TTFD!bChangeXform:bRotation=%s\n", bRotation ? "TRUE":"FALSE");
    }
#endif

    vInitGlyphState(&pfc->gstat);

    if ( bRotation )
    {
        pfc->pgin->param.newtrans.transformMatrix = &(pfc->mxv);
    }
    else
    {
        pfc->pgin->param.newtrans.transformMatrix = &(pfc->mxn);
    }

    pfc->pgin->param.newtrans.pointSize = pfc->pointSize;
    pfc->pgin->param.newtrans.xResolution = (int16)pfc->sizLogResPpi.cx;
    pfc->pgin->param.newtrans.yResolution = (int16)pfc->sizLogResPpi.cy;
    pfc->pgin->param.newtrans.pixelDiameter = FIXEDSQRT2;
    pfc->pgin->param.newtrans.usOverScale = pfc->overScale;
    ASSERTDD( pfc->overScale != FF_UNDEFINED_OVERSCALE , "Undefined Overscale\n" );


    pfc->pgin->param.newtrans.traceFunc = (FntTraceFunc)NULL;

    if (pfc->flFontType & FO_SIM_BOLD)
    {
        /* 2% + 1 pixel along baseline, 2% along descender line */

        pfc->pgin->param.newtrans.usEmboldWeightx = 20;
        pfc->pgin->param.newtrans.usEmboldWeighty = 20;
        pfc->pgin->param.newtrans.lDescDev = pfc->lDescDev;

        if (pfc->flXform & XFORM_BITMAP_SIM_BOLD)
        {
            pfc->pgin->param.newtrans.bBitmapEmboldening = TRUE;
        } else
        {
            pfc->pgin->param.newtrans.bBitmapEmboldening = FALSE;
        }
    }
    else
    {
        pfc->pgin->param.newtrans.usEmboldWeightx = 0;
        pfc->pgin->param.newtrans.usEmboldWeighty = 0;
        pfc->pgin->param.newtrans.lDescDev = 0;
        pfc->pgin->param.newtrans.bBitmapEmboldening = FALSE;
    }

    pfc->pgin->param.newtrans.bHintAtEmSquare = FALSE;

    if ((iRet = fs_NewTransformation(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);

    // try to recover, most likey bad hints, just return unhinted glyph

        if ((iRet = fs_NewTransformNoGridFit(pfc->pgin, pfc->pgout)) != NO_ERR)
        {
           V_FSERROR(iRet);
           #if DBG
           TtfdDbgPrint("bChangeXform(%-#x,%d) failed\n", pfc, bRotation);
           #endif
            return(FALSE);
        }
    }

    return TRUE;
}

/******************************Public*Routine******************************\
*
* VOID vShiftBitmapInfo( FONTCONTEXT *pfc, fs_GlyphInfoType *pgout )
*
*
* Modifies following values.
*
* Using pfc->devShiftX and pfc->devShiftY:
*
*  gout.bitMapInfo.bounds.right
*  gout.bitMapInfo.bounds.left
*  gout.bitMapInfo.bounds.top
*  gout.bitMapInfo.bounds.bottom
*  gout.metricInfo.devLeftSideBearing.x
*  gout.metricInfo.devLeftSideBearing.y
*
* Using -90 degree rotation
*
*  gout.metricInfo.devAdvanceWidth.x
*  gout.metricInfo.devAdvanceWidth.y
*
* History:
*  04-Apr-1993 -by- Takao Kitano [TakaoK]
* Wrote it.
\**************************************************************************/

VOID vShiftBitmapInfo(
    FONTCONTEXT *pfc,
    fs_GlyphInfoType *pgoutDst,
    fs_GlyphInfoType *pgoutSrc)
{
    SHORT sdevShiftX = (SHORT) F16_16TOLROUND(pfc->fxdevShiftX);
    SHORT sdevShiftY = (SHORT) F16_16TOLROUND(pfc->fxdevShiftY);

    pgoutDst->bitMapInfo.bounds.right =  pgoutSrc->bitMapInfo.bounds.right + sdevShiftX;
    pgoutDst->bitMapInfo.bounds.left = pgoutSrc->bitMapInfo.bounds.left + sdevShiftX;
    pgoutDst->bitMapInfo.bounds.top = pgoutSrc->bitMapInfo.bounds.top + sdevShiftY;
    pgoutDst->bitMapInfo.bounds.bottom = pgoutSrc->bitMapInfo.bounds.bottom + sdevShiftY;

    pgoutDst->metricInfo.devLeftSideBearing.x = pgoutSrc->metricInfo.devLeftSideBearing.x + pfc->fxdevShiftX;
    pgoutDst->metricInfo.devLeftSideBearing.y = pgoutSrc->metricInfo.devLeftSideBearing.y + pfc->fxdevShiftY;

    //
    // -90degree rotation in truetype coordinate system
    //
    //                            [ 0  -1 ]
    //  (newX, newY) = ( x, y ) * [       ]  = (y, -x )
    //                            [ 1   0 ]
    //       A
    //      Y|
    //       |
    //       |
    //       +----->
    //            X
    //

    pgoutDst->metricInfo.devAdvanceWidth.x = pgoutSrc->metricInfo.devAdvanceWidth.y;
    pgoutDst->metricInfo.devAdvanceWidth.y = - pgoutSrc->metricInfo.devAdvanceWidth.x;

    pgoutDst->verticalMetricInfo.devAdvanceHeight.x = pgoutSrc->verticalMetricInfo.devAdvanceHeight.y;
    pgoutDst->verticalMetricInfo.devAdvanceHeight.y = - pgoutSrc->verticalMetricInfo.devAdvanceHeight.x;

    pgoutDst->verticalMetricInfo.devTopSideBearing.x = pgoutSrc->verticalMetricInfo.devTopSideBearing.x;
    pgoutDst->verticalMetricInfo.devTopSideBearing.y = pgoutSrc->verticalMetricInfo.devTopSideBearing.y;
    
#ifdef DBCS_VERT_DEBUG
    if ( DebugVertical & DEBUG_VERTICAL_BITMAPINFO )
    {
        TtfdDbgPrint("=====TTFD:vShiftBitmapInfo() before \n");
        TtfdDbgPrint("bitMapInfo.bounds:right=%ld, left=%ld, top=%ld, bottom=%ld\n",
                   pgoutSrc->bitMapInfo.bounds.right,
                   pgoutSrc->bitMapInfo.bounds.left,
                   pgoutSrc->bitMapInfo.bounds.top,
                   pgoutSrc->bitMapInfo.bounds.bottom);
        TtfdDbgPrint("metricInfo.devLeftSideBearing x = %ld, y=%ld \n",
                  F16_16TOLROUND(pgoutSrc->metricInfo.devLeftSideBearing.x),
                  F16_16TOLROUND(pgoutSrc->metricInfo.devLeftSideBearing.y));
        TtfdDbgPrint("metricInfo.devAdvanceWidth x = %ld, y=%ld \n",
                  F16_16TOLROUND(pgoutSrc->metricInfo.devAdvanceWidth.x),
                  F16_16TOLROUND(pgoutSrc->metricInfo.devAdvanceWidth.y));

        TtfdDbgPrint("=====TTFD:vShiftBitmapInfo() after \n");
        TtfdDbgPrint("bitMapInfo.bounds:right=%ld, left=%ld, top=%ld, bottom=%ld\n",
                   pgoutDst->bitMapInfo.bounds.right,
                   pgoutDst->bitMapInfo.bounds.left,
                   pgoutDst->bitMapInfo.bounds.top,
                   pgoutDst->bitMapInfo.bounds.bottom);
        TtfdDbgPrint("metricInfo.devLeftSideBearing x = %ld, y=%ld \n",
                  F16_16TOLROUND(pgoutDst->metricInfo.devLeftSideBearing.x),
                  F16_16TOLROUND(pgoutDst->metricInfo.devLeftSideBearing.y));
        TtfdDbgPrint("metricInfo.devAdvanceWidth x = %ld, y=%ld \n",
                  F16_16TOLROUND(pgoutDst->metricInfo.devAdvanceWidth.x),
                  F16_16TOLROUND(pgoutDst->metricInfo.devAdvanceWidth.y));
    }
#endif
}

/******************************Public*Routine******************************\
*
* vShiftOutlineInfo()
*
* History:
*  04-Apr-1993 -by- Hideyuki Nagase [HideyukN]
* Wrote it.
\**************************************************************************/

#define CJ_CRV(pcrv)                                              \
(                                                                 \
    offsetof(TTPOLYCURVE,apfx) + ((pcrv)->cpfx * sizeof(POINTFX)) \
)

VOID vAdd16FixTo16Fix(
    FIXED *A ,
    FIXED *B ,
    BOOL  bForceMinus
)
{
    A->fract += B->fract;
    A->value += B->value;
}

VOID vAdd16FixTo28Fix(
    FIXED *A ,
    FIXED *B ,
    BOOL  bForceMinus
)
{
    Fixed longA , longB;

    ASSERTDD( sizeof(FIXED) == sizeof(Fixed) , "TTFD:FIXED != ULONG\n" );

    longA = *(Fixed *)A;
    longB = *(Fixed *)B;

// WINBUG 82937 claudebe 2-11-2000 , if we rewrite or modify the vertical writing code, we need to be careful about :
//
// if outline request from PostScript printer driver, the driver
// can not get correct outline without following super hack.
// we most need feather investigation.
//
// propably, we should compute shift value accoring
// to device coordinate ???. Y axis is different
// between device and truetype coordinate.
// how about GetGlyphOutline() ???
// I just tested using gdi\test\fonttest.nt\fonttest.exe
// It seems work fine.
//
// start super-hack.

    if(bForceMinus) longB = -longB;

// end super-hack.

    longB = longB >> 12;

    longA += longB;

    *A = *(FIXED *)&longA;
}

VOID vShiftOutlineInfo(
    FONTCONTEXT     *pfc,        // IN  font context
    BOOL             b16Dot16,   // IN  Fixed format 16.16 or 28.4
    BYTE            *pBuffer,    // OUT output buffer
    ULONG            cjTotal     // IN  buffer size
)
{
    VOID vFillGLYPHDATA(
                     HGLYPH,
                     ULONG,
                     FONTCONTEXT*,
                     fs_GlyphInfoType*,
                     GLYPHDATA*,
                     GMC*,
                     POINTL*
                     );

    TTPOLYGONHEADER *ppoly, *ppolyStart, *ppolyEnd;
    TTPOLYCURVE     *pcrv, * pcrvEnd;
    LONG             fxShiftX, fxShiftY;
    ULONG            cSpli , cSpliMax;
    POINTFX         *pptfix;
    VOID             (*vAddFunc)(FIXED *A,FIXED *B,BOOL bForceMinus);
    BOOL             bForceMinus;
    fs_GlyphInfoType Info, *pInfo = pfc->pgout;
    GLYPHDATA        Data;

    //
    // In order to calculate the shift I will call the routine
    // that calculates the shift for the equivalent bitmap. This
    // will cost some unnecessary cycles since we will be calculating
    // some information that will be ignored. However, this approach
    // has the advantage of using working code without a lot of
    // re-writing. Since this routine is called relatively infrequently
    // I am willing to paying this relatively small price.
    //

    //
    // First
    //
    // Call the routine that calculates the shift for the bitmap. Note
    // Info is a dummy fs_GlyphInfoType that must be supplied
    // but is not used here.
    //

    vShiftBitmapInfo(pfc, &Info, pInfo);
    vFillGLYPHDATA(pfc->hgSave, pfc->gstat.igLast, pfc, &Info, &Data, 0, 0);

    //
    // Then
    //
    // Use that information to calculate the shift for the font space outline
    // Note that the shift in the x-direction and the shift in the y-direction
    // are calculated with a different sign. This arises because the shift
    // is calculated in a coordinate system where y increases downward while
    // the shift is applied to a curve whose y-coordinates are assumed to
    // increase in the upward direction.
    //

    fxShiftX  = Data.rclInk.left << 16;
    fxShiftX -= ((pInfo->metricInfo.devLeftSideBearing.x + 0x8000) & 0xFFFF0000);
    fxShiftY = -((Data.rclInk.top + pInfo->bitMapInfo.bounds.bottom) << 16);


    if( b16Dot16 ) {
        vAddFunc = vAdd16FixTo16Fix;
        bForceMinus = FALSE;
    } else {
        vAddFunc = vAdd16FixTo28Fix;
        bForceMinus = TRUE;
    }

    #ifdef DBCS_VERT_DEBUG
    TtfdDbgPrint("====== START DUMP VERTICAL POLYGON ======\n");
    TtfdDbgPrint("devShiftX=%ld, devShiftY=%ld \n"
                  ,F16_16TOLROUND(fxShiftX),
                   F16_16TOLROUND(fxShiftY));
    #endif // DBCS_VERT_DEBUG

    ppolyStart = (TTPOLYGONHEADER *)pBuffer;
    ppolyEnd   = (TTPOLYGONHEADER *)(pBuffer + cjTotal);

    for (
         ppoly = ppolyStart;
         ppoly < ppolyEnd;
         ppoly = (TTPOLYGONHEADER *)((PBYTE)ppoly + ppoly->cb)
        )
    {
        ASSERTDD(ppoly->dwType == TT_POLYGON_TYPE,"ppoly->dwType != TT_POLYGON_TYPE\n");

        #ifdef DBCS_VERT_DEBUG
        TtfdDbgPrint("ppoly->cb  - %d\n",ppoly->cb);
        #endif // DBCS_VERT_DEBUG

        (*vAddFunc)( &ppoly->pfxStart.x , (FIXED*)&fxShiftX , FALSE );
        (*vAddFunc)( &ppoly->pfxStart.y , (FIXED*)&fxShiftY , bForceMinus );

        #ifdef DBCS_VERT_DEBUG
        TtfdDbgPrint("StartPoint - ( %x , %x )\n",ppoly->pfxStart.x,ppoly->pfxStart.y);
        #endif // DBCS_VERT_DEBUG

        for (
             pcrv = (TTPOLYCURVE *)(ppoly + 1),pcrvEnd = (TTPOLYCURVE *)((PBYTE)ppoly + ppoly->cb);
             pcrv < pcrvEnd;
             pcrv = (TTPOLYCURVE *)((PBYTE)pcrv + CJ_CRV(pcrv))
            )
        {
            #ifdef DBCS_VERT_DEBUG
            TtfdDbgPrint("Contents of TTPOLYCURVE (%d)\n",pcrv->cpfx);
            #endif // DBCS_VERT_DEBUG

            for (
                 cSpli = 0,cSpliMax = pcrv->cpfx,pptfix = &(pcrv->apfx[0]);
                 cSpli < cSpliMax;
                 cSpli ++,pptfix ++
                )
            {
                (*vAddFunc)( &pptfix->x , (FIXED*) &fxShiftX , FALSE );
                (*vAddFunc)( &pptfix->y , (FIXED*) &fxShiftY , bForceMinus );

                #ifdef DBCS_VERT_DEBUG
                TtfdDbgPrint("           - ( %x , %x )\n",pptfix->x,pptfix->y);
                #endif // DBCS_VERT_DEBUG
            }
        }

        #ifdef DBCS_VERT_DEBUG
        TtfdDbgPrint("\n");
        #endif // DBCS_VERT_DEBUG
    }

    #ifdef DBCS_VERT_DEBUG
    TtfdDbgPrint("====== END DUMP VERTICAL POLYGON ======\n");
    #endif // DBCS_VERT_DEBUG
}

#if DBG

VOID CheckGlyphAttr(PTTC_FONTFILE pttc, PFD_GLYPHATTR pga, PFONTFILE pff)
{
    FONTFILE            *pffTmp;
    PWCRUN              pwcruns, pwcrunsEnd;
    PHGLYPH             phg;
    HGLYPH              hGlyph;
    WCHAR               wcLow, wcHigh;
    WCHAR               wcStart, wcEnd;
    ULONG               cGlyphs;
    PFD_GLYPHATTR       pgaTmp;
    ULONG               i;
    ULONG               cj;
    BOOL                bBug;
    PFD_GLYPHSET        pgset;

    cj = pga->cjThis;

    pgaTmp = PV_ALLOC(cj);

// Alloc memory failed, need to return faliure

    if (!pgaTmp)
        return;

// first set all the bits to 1

    RtlCopyMemory((PVOID)pgaTmp, (PVOID)pga, cj);

    for( i = 0; i < pttc->ulNumEntry; i++ )
    {
        if ((pttc->ahffEntry[i].iFace == 1))
        {
            pffTmp = PFF(pttc->ahffEntry[i].hff);
            pgset = pffTmp->pgset;
            pwcruns = &pffTmp->pgset->awcrun[0];
            pwcrunsEnd = pwcruns + pgset->cRuns;

            while ((pwcruns < pwcrunsEnd))
            {
                wcLow = pwcruns->wcLow;
                wcHigh = pwcruns->wcLow + pwcruns->cGlyphs - 1;
                phg = pwcruns->phg;

                while (wcLow <= wcHigh)
                {
                    if (IsLocalDbcsCharacter(pffTmp->ffca.uiFontCodePage, wcLow))
                    {
                        if( *phg < pgaTmp->cGlyphs)
                        {
                            if ( (pgaTmp->aGlyphAttr[*phg / 8] & glyphBits[*phg % 8]))
                            {
                                pgaTmp->aGlyphAttr[*phg / 8] &= (~glyphBits[*phg % 8]);
                                if ( pff->hgSearchVerticalGlyph )
                                {
                                    hGlyph = (*pff->hgSearchVerticalGlyph)( pff, *phg, FALSE );
                                    if ( pgaTmp->aGlyphAttr[hGlyph / 8] & glyphBits[hGlyph % 8])
                                        pgaTmp->aGlyphAttr[hGlyph / 8] &= ~glyphBits[hGlyph % 8];
                                }
                            }
                        }
                    }
                    phg++;
                    wcLow++;
                }
                pwcruns++;
            }
        }
    }

    bBug = FALSE;

    for ( i = 0; i < (cj - offsetof(FD_GLYPHATTR,aGlyphAttr)); i++)
        if (pgaTmp->aGlyphAttr[i])
        {
            bBug = TRUE;    
            TtfdDbgPrint(" i = %x, pgaTmp->aGlyphAttr[i] %x \n",i, pgaTmp->aGlyphAttr[i]);
//            EngDebugBreak();
        }

    if (bBug)
    {
        TtfdDbgPrint(" Error in @Font glyph attribute bits\n");
        TtfdDbgPrint(" Error in @Font glyph attribute bits\n");
        TtfdDbgPrint(" Error in @Font glyph attribute bits\n");
    }

    V_FREE(pgaTmp);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\vtfd\fd.h ===
/******************************Module*Header*******************************\
* Module Name: fd.h
*
* file which is going to be included by the most *.c files in this directory.
* Supplies basic types, debugging stuff, error logging and checking stuff,
* error codes, usefull macros etc.
*
* Copyright (c) 1990-1995 Microsoft Corporation
\**************************************************************************/
#define  SUPPORT_OEM
#define  IFI_PRIVATE

#include <stddef.h>
#include <stdarg.h>
#include <excpt.h>
#include <windef.h>
#include <wingdi.h>
#include <winddi.h>

typedef ULONG W32PID;

#include "mapfile.h"

#include "winres.h"
#include "service.h"     // string service routines
#include "fontfile.h"
#include "winfont.h"

#define abs(x) max((x),-(x))


#if DBG

VOID
VtfdDebugPrint(
    PCHAR DebugMessage,
    ...
    );

#define RIP(x)        { VtfdDebugPrint(x); EngDebugBreak();}
#define ASSERTDD(x,y) { if (!(x)) { VtfdDebugPrint(y); EngDebugBreak();} }
#define WARNING(x)    VtfdDebugPrint(x)

#else

#define RIP(x)
#define ASSERTDD(x,y)
#define WARNING(x)

#endif

BOOL vtfdLoadFontFile (
        ULONG_PTR iFile, PVOID pvView, ULONG cjView, HFF *phff
    );

BOOL
vtfdUnloadFontFile (
    HFF hff
    );

LONG
vtfdQueryFontCaps (
    ULONG culCaps,
    PULONG pulCaps
    );

LONG
vtfdQueryFontFile (
        HFF     hff,
        ULONG   ulMode,
        ULONG   cjBuf,
        PULONG  pulBuf
        );

PIFIMETRICS
vtfdQueryFont (
        DHPDEV dhpdev,
        HFF    hff,
        ULONG  iFace,
        ULONG_PTR  *pid
        );

PVOID
vtfdQueryFontTree (
    DHPDEV  dhpdev,
    HFF     hff,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR   *pid
    );

LONG vtfdQueryFontData
(
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH  hg,
    GLYPHDATA *pgd,
    PVOID   pv,
    ULONG   cjSize
);

VOID vtfdDestroyFont(FONTOBJ *pfo);

HFC  vtfdOpenFontContext(FONTOBJ *pfo);

BOOL vtfdCloseFontContext(HFC hfc);

BOOL vtfdQueryAdvanceWidths
(
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    LONG    *plWidths,
    ULONG    cGlyphs
);




extern HSEMAPHORE ghsemVTFD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\ttfd\xform.h ===
/******************************Module*Header*******************************\
* Module Name: xform.h
*
* (Brief description)
*
* Created: 05-Apr-1992 11:06:23
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/


#if defined(_AMD64_) || defined(_IA64_)

typedef FLOAT EFLOAT;
#ifndef TT_DEBUG_EXTENSIONS
#define lCvt(ef, l) ((LONG) (ef * l))
#endif

#else // i386

typedef struct  _EFLOAT
{
    LONG    lMant;
    LONG    lExp;
} EFLOAT;

#ifndef TT_DEBUG_EXTENSIONS
LONG lCvt(EFLOAT ef,LONG l);
#endif

#endif // i386

typedef EFLOAT *PEFLOAT;

typedef struct _VECTORFL
{
    EFLOAT x;
    EFLOAT y;
} VECTORFL, *PVECTORFL;


BOOL bFDXform
(
XFORML   *pxf,
POINTFIX *pptfxDst,
POINTL   *pptlSrc,
ULONG     c
);

BOOL bXformUnitVector
(
POINTL       *pptl,           // IN,  incoming unit vector
XFORML       *pxf,            // IN,  xform to use
PVECTORFL     pvtflXformed,   // OUT, xform of the incoming unit vector
POINTE       *ppteUnit,       // OUT, *pptqXormed/|*pptqXormed|, POINTE
POINTQF      *pptqUnit,       // OUT, optional
EFLOAT       *pefNorm         // OUT, |*pptqXormed|
);

VOID vLTimesVtfl     // *pptq = l * pvtfl, *pptq is in 28.36 format
(
LONG       l,
VECTORFL  *pvtfl,
POINTQF   *pptq
);


FIX  fxLTimesEf  //!!! SHOULD BE MOVED TO TTFD and VTFD
(
EFLOAT *pef,
LONG    l
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\vtfd\fdcvt.c ===
/******************************Module*Header*******************************\
* Module Name: fdcvt.c
*
* Font file loading and unloadking.  Adapted from BodinD's bitmap font driver.
*
* Created: 26-Feb-1992 20:23:54
* Author: Wendy Wu [wendywu]
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "fd.h"

// points to the linked list of glyphset strucs

CP_GLYPHSET *gpcpVTFD = NULL;



ULONG cjVTFDIFIMETRICS(PBYTE ajHdr);

// !!! put prototype in common area for all font drivers so change
// !!! in 1 is reflected in all.


FSHORT fsSelectionFlags(PBYTE ajHdr); // in bmfd

extern BOOL bDbgPrintAndFail(PSZ psz);

#if DBG

extern BOOL bDbgPrintAndFail(PSZ psz);

#else

#define bDbgPrintAndFail(psz) FALSE

#endif

ULONG iDefaultFace(PBYTE ajHdr) // similar to vDefFace, should not be duplicated
{
    ULONG iDefFace;

    if (READ_WORD(&ajHdr[OFF_Weight]) <= FW_NORMAL)
    {
        if (ajHdr[OFF_Italic])
        {
            iDefFace = FF_FACE_ITALIC;
        }
        else
        {
            iDefFace = FF_FACE_NORMAL;
        }
    }
    else
    {
        if (ajHdr[OFF_Italic])
        {
            iDefFace = FF_FACE_BOLDITALIC;
        }
        else
        {
            iDefFace = FF_FACE_BOLD;
        }
    }
    return iDefFace;
}


/******************************Private*Routine*****************************\
* BOOL bVerifyVTFD
*
* CHECK whether header contains file info which corresponds to
* the raster font requirements, go into the file and check
* the consistency of the header data
*
* History:
*  26-Feb-1992 -by- Wendy Wu [wendywu]
* Adapted from bmfd.
\**************************************************************************/

BOOL bVerifyVTFD(PRES_ELEM pre)
{
    PBYTE ajHdr  = (PBYTE)pre->pvResData;

    if (!(READ_WORD(&ajHdr[OFF_Type]) & TYPE_VECTOR))   // Vector bit has to
        return(bDbgPrintAndFail("fsType \n"));          // be on.

    if ((READ_WORD(&ajHdr[OFF_Version]) != 0x0100) &&     // The only version
        (READ_WORD(&ajHdr[OFF_Version]) != 0x0200) )      // The only version
        return(bDbgPrintAndFail("iVersion\n"));         // supported.

    if ((ajHdr[OFF_BitsOffset] & 1) != 0)               // Must be an even
        return(bDbgPrintAndFail("dpBits odd \n"));      // offset.

// file size must be <= than the size of the view

    if (READ_DWORD(&ajHdr[OFF_Size]) > pre->cjResData)
        return(bDbgPrintAndFail("cjSize \n"));

// make sure that the reserved bits are all zero

    if ((READ_WORD(&ajHdr[OFF_Type]) & BITS_RESERVED) != 0)
        return(bDbgPrintAndFail("fsType, reserved bits \n"));

    if (abs(READ_WORD(&ajHdr[OFF_Ascent])) > READ_WORD(&ajHdr[OFF_PixHeight]))
        return(bDbgPrintAndFail("sAscent \n")); // Ascent Too Big

    if (READ_WORD(&ajHdr[OFF_IntLeading]) > READ_WORD(&ajHdr[OFF_Ascent]))
        return(bDbgPrintAndFail(" IntLeading too big\n")); // Int Lead Too Big;

// check consistency of character ranges

    if (ajHdr[OFF_FirstChar] > ajHdr[OFF_LastChar])
        return(bDbgPrintAndFail(" FirstChar\n")); // this can't be

// default and break character are given relative to the FirstChar,
// so that the actual default (break) character is given as
// chFirst + chDefault(Break)

    if ((BYTE)(ajHdr[OFF_DefaultChar] + ajHdr[OFF_FirstChar]) > ajHdr[OFF_LastChar])
        return(bDbgPrintAndFail(" DefaultChar\n"));

    if ((BYTE)(ajHdr[OFF_BreakChar] + ajHdr[OFF_FirstChar]) > ajHdr[OFF_LastChar])
        return(bDbgPrintAndFail(" BreakChar\n"));

// finally verify that all the offsets to glyph data point to locations
// within the file and that what they point to is valid glyph data: [BodinD]

    {

        INT iIndex, dIndex, iIndexEnd;
        PBYTE pjCharTable, pjGlyphData,pjFirstChar, pjEndFile;

        iIndexEnd =  (INT)ajHdr[OFF_LastChar] - (INT)ajHdr[OFF_FirstChar] + 1;

    // init out of the loop:

        if (READ_WORD(&ajHdr[OFF_PixWidth]) != 0) // fixed pitch
        {
            iIndexEnd <<= 1;           // each entry is 2-byte long
            dIndex = 2;
        }
        else
        {
            iIndexEnd <<= 2;           // each entry is 4-byte long
            dIndex = 4;
        }

        pjFirstChar = ajHdr + READ_DWORD(ajHdr + OFF_BitsOffset);

    // Vector font file doesn't have the byte filler.  Win31 bug?

        pjCharTable = ajHdr + OFF_jUnused20;
        pjEndFile   = ajHdr + READ_DWORD(ajHdr + OFF_Size);

        for (iIndex = 0; iIndex < iIndexEnd; iIndex += dIndex)
        {
             pjGlyphData = pjFirstChar + READ_WORD(&pjCharTable[iIndex]);

             if ((pjGlyphData >= pjEndFile) || (*pjGlyphData != (BYTE)PEN_UP))
                 return(bDbgPrintAndFail("bogus vector font \n"));
        }
    }

    return(TRUE);
}


/******************************Private*Routine*****************************\
* ULONG cVtfdResFaces
*
* Compute the number of faces that the given .FNT file can support.
*
* History:
*  04-Mar-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

ULONG cVtfdResFaces(PBYTE ajHdr)
{
// We set the FM_SEL_BOLD flag iff weight is > FW_NORMAL (400).
// We will not allow emboldening simulation on the font that has this
// flag set.

    if (READ_WORD(&ajHdr[OFF_Weight]) <= FW_NORMAL)
    {
        if (ajHdr[OFF_Italic])
            return(2);
        else
            return(4);
    }
    else
    {
        if (ajHdr[OFF_Italic])
            return(1);
        else
            return(2);
    }
}

/******************************Private*Routine*****************************\
* VOID vVtfdFill_IFIMetrics
*
* Looks into the .FNT file and fills the IFIMETRICS structure accordingly.
*
* History:
*  Wed 04-Nov-1992 -by- Bodin Dresevic [BodinD]
* update: new ifimetrics
*  26-Feb-1992 -by- Wendy Wu [wendywu]
* Adapted from bmfd.
\**************************************************************************/


VOID vVtfdFill_IFIMetrics(PBYTE ajHdr, FD_GLYPHSET * pgset, PIFIMETRICS pifi)
{
    FWORD     fwdHeight;
    FONTSIM  *pFontSim;
    FONTDIFF *pfdiffBold = 0, *pfdiffItalic = 0, *pfdiffBoldItalic = 0;
    PANOSE   *ppanose;
    ULONG    iDefFace;
    ULONG    cjIFI = ALIGN4(sizeof(IFIMETRICS));
    ULONG    cch;
    FWORD     cy;

// compute pointers to the various sections of the converted file

// face name lives in the original file, this is the only place pvView is used

    PSZ   pszFaceName = (PSZ)(ajHdr + READ_DWORD(&ajHdr[OFF_Face]));

    pifi->cjIfiExtra = 0;
    pifi->cjThis    = cjVTFDIFIMETRICS(ajHdr);

// the string begins on a DWORD aligned address.

    pifi->dpwszFaceName = cjIFI;

// face name == family name for vector fonts [Win3.0 compatibility]

    pifi->dpwszFamilyName    = pifi->dpwszFaceName;

// these names don't exist, so point to the NULL char  [Win3.1 compatibility]
// Note: lstrlen() does not count the terminating NULL.

    cch = (ULONG)strlen(pszFaceName);

    pifi->dpwszStyleName = pifi->dpwszFaceName + sizeof(WCHAR) * cch;
    pifi->dpwszUniqueName = pifi->dpwszStyleName;

    cjIFI += ALIGN4((cch + 1) * sizeof(WCHAR));

// copy the strings to their new location. Here we assume that the sufficient
// memory has been allocated

    vToUNICODEN((LPWSTR)((PBYTE)pifi + pifi->dpwszFaceName), cch+1, pszFaceName, cch+1);

// Check to see if simulations are necessary and if they are, fill
// in the offsets to the various simulation fields and update cjThis
// field of the IFIMETRICS structure

    iDefFace = iDefaultFace(ajHdr);

    if (iDefFace == FF_FACE_BOLDITALIC)
    {
        pifi->dpFontSim = 0;
    }
    else
    {
        pifi->dpFontSim = cjIFI;
        pFontSim = (FONTSIM*) ((BYTE*)pifi + pifi->dpFontSim);
        cjIFI += ALIGN4(sizeof(FONTSIM));

        switch (iDefFace)
        {
        case FF_FACE_NORMAL:
        //
        // simulations are needed for bold, italic, and bold-italic
        //
            pFontSim->dpBold  = ALIGN4(sizeof(FONTSIM));
            pFontSim->dpItalic = pFontSim->dpBold + ALIGN4(sizeof(FONTDIFF));
            pFontSim->dpBoldItalic = pFontSim->dpItalic + ALIGN4(sizeof(FONTDIFF));

            pfdiffBold      =
                (FONTDIFF*) ((BYTE*) pFontSim + pFontSim->dpBold);

            pfdiffItalic    =
                (FONTDIFF*) ((BYTE*) pFontSim + pFontSim->dpItalic);

            pfdiffBoldItalic =
                (FONTDIFF*) ((BYTE*) pFontSim + pFontSim->dpBoldItalic);

            cjIFI += (3 * ALIGN4(sizeof(FONTDIFF)));
            break;

        case FF_FACE_BOLD:
        case FF_FACE_ITALIC:
        //
        // a simulation is needed for bold-italic only
        //
            pFontSim->dpBold       = 0;
            pFontSim->dpItalic     = 0;

            pFontSim->dpBoldItalic = ALIGN4(sizeof(FONTSIM));
            pfdiffBoldItalic       =
                (FONTDIFF*) ((BYTE*) pFontSim + pFontSim->dpBoldItalic);

            cjIFI += ALIGN4(sizeof(FONTDIFF));
            break;

        default:

            RIP("VTFD -- bad iDefFace\n");
            break;
        }
    }

    ASSERTDD(cjIFI == pifi->cjThis, "cjIFI is wrong\n");

    pifi->jWinCharSet        = ajHdr[OFF_CharSet];
    pifi->jWinPitchAndFamily = ajHdr[OFF_Family];

//
// !!![kirko] The next line of code is very scary but it seems to work.
// This will call a font with FIXED_PITCH set, a varible pitch font.
// Or should this be decided upon whether cx == 0 or not? [bodind]
//

// this is the excert from wendy's code:

//    if ((ajHdr[OFF_Family] & 1) == 0)
//        pifi->flInfo |= FM_INFO_CONSTANT_WIDTH;


    if (pifi->jWinPitchAndFamily & 0x0f)
    {
        pifi->jWinPitchAndFamily = ((pifi->jWinPitchAndFamily & 0xf0) | VARIABLE_PITCH);
    }
    else
    {
        pifi->jWinPitchAndFamily = ((pifi->jWinPitchAndFamily & 0xf0) | FIXED_PITCH);
    }

    pifi->usWinWeight = READ_WORD(&ajHdr[OFF_Weight]);

// weight, may have to fix it up if the font contains a garbage value [bodind]

    if ((pifi->usWinWeight > MAX_WEIGHT) || (pifi->usWinWeight < MIN_WEIGHT))
        pifi->usWinWeight = 400;

    pifi->flInfo = (  FM_INFO_TECH_STROKE
                    | FM_INFO_ARB_XFORMS
                    | FM_INFO_RETURNS_STROKES
                    | FM_INFO_RIGHT_HANDED
                   );

    if ((pifi->jWinPitchAndFamily & 0xf) == FIXED_PITCH)
    {
        pifi->flInfo |= (FM_INFO_CONSTANT_WIDTH | FM_INFO_OPTICALLY_FIXED_PITCH);
    }

    pifi->lEmbedId = 0;
    pifi->fsSelection = fsSelectionFlags(ajHdr);

//
// The choices for fsType are FM_TYPE_LICENSED and FM_READONLY_EMBED
// These are TrueType things and do not apply to old fashioned bitmap and vector
// fonts.
//
    pifi->fsType = 0;

    cy = (FWORD)READ_WORD(&ajHdr[OFF_PixHeight]);

    pifi->fwdUnitsPerEm = ((FWORD)READ_WORD(&ajHdr[OFF_IntLeading]) > 0) ?
        cy - (FWORD)READ_WORD(&ajHdr[OFF_IntLeading]) : cy;

    pifi->fwdLowestPPEm    = 0;

    pifi->fwdWinAscender   = (FWORD)READ_WORD(&ajHdr[OFF_Ascent]);
    pifi->fwdWinDescender  = cy - pifi->fwdWinAscender;

    pifi->fwdMacAscender   =  pifi->fwdWinAscender ;
    pifi->fwdMacDescender  = -pifi->fwdWinDescender;
    pifi->fwdMacLineGap    =  (FWORD)READ_WORD(&ajHdr[OFF_ExtLeading]);

    pifi->fwdTypoAscender  = pifi->fwdMacAscender;
    pifi->fwdTypoDescender = pifi->fwdMacDescender;
    pifi->fwdTypoLineGap   = pifi->fwdMacLineGap;

    pifi->fwdAveCharWidth  = (FWORD)READ_WORD(&ajHdr[OFF_AvgWidth]);
    pifi->fwdMaxCharInc    = (FWORD)READ_WORD(&ajHdr[OFF_MaxWidth]);
//
// don't know much about SuperScripts
//
    pifi->fwdSubscriptXSize     = 0;
    pifi->fwdSubscriptYSize     = 0;
    pifi->fwdSubscriptXOffset   = 0;
    pifi->fwdSubscriptYOffset   = 0;

//
// don't know much about SubScripts
//
    pifi->fwdSuperscriptXSize   = 0;
    pifi->fwdSuperscriptYSize   = 0;
    pifi->fwdSuperscriptXOffset = 0;
    pifi->fwdSuperscriptYOffset = 0;

//
// win 30 magic. see the code in textsims.c in the Win 3.1 sources
//
    fwdHeight = pifi->fwdWinAscender + pifi->fwdWinDescender;

    pifi->fwdUnderscoreSize     = (fwdHeight > 12) ? (fwdHeight / 12) : 1;
    pifi->fwdUnderscorePosition = -(FWORD)(pifi->fwdUnderscoreSize / 2 + 1);

    pifi->fwdStrikeoutSize = pifi->fwdUnderscoreSize;

    {
    // We are further adjusting underscore position if underline
    // hangs below char stems.
    // The only font where this effect is noticed to
    // be important is an ex pm font sys08cga.fnt, presently used in console

        FWORD yUnderlineBottom = -pifi->fwdUnderscorePosition
                               + ((pifi->fwdUnderscoreSize + (FWORD)1) >> 1);

        FWORD dy = yUnderlineBottom - pifi->fwdWinDescender;

        if (dy > 0)
        {
        #ifdef CHECK_CRAZY_DESC
            DbgPrint("bmfd: Crazy descender: old = %ld, adjusted = %ld\n\n",
            (ULONG)pifi->fwdMaxDescender,
            (ULONG)yUnderlineBottom);
        #endif // CHECK_CRAZY_DESC

            pifi->fwdUnderscorePosition += dy;
        }
    }

//
// Win 3.1 method
//
//    LineOffset = ((((Ascent-IntLeading)*2)/3) + IntLeading)
//
// [remember that they measure the offset from the top of the cell,
//  where as NT measures offsets from the baseline]
//
    pifi->fwdStrikeoutPosition =
        (FWORD) (((FWORD)READ_WORD(&ajHdr[OFF_Ascent]) - (FWORD)READ_WORD(&ajHdr[OFF_IntLeading]) + 2)/3);

    pifi->chFirstChar   = ajHdr[OFF_FirstChar];
    pifi->chLastChar    = ajHdr[OFF_LastChar];;

// wcDefaultChar
// wcBreakChar

    {
        UCHAR chDefault = ajHdr[OFF_FirstChar] + ajHdr[OFF_DefaultChar];
        UCHAR chBreak   = ajHdr[OFF_FirstChar] + ajHdr[OFF_BreakChar];

    // Default and Break chars are given relative to the first char

        pifi->chDefaultChar = chDefault;
        pifi->chBreakChar   = chBreak;

        EngMultiByteToUnicodeN(&pifi->wcDefaultChar, sizeof(WCHAR), NULL, &chDefault, 1);
        EngMultiByteToUnicodeN(&pifi->wcBreakChar  , sizeof(WCHAR), NULL, &chBreak, 1);
    }

// These have to be taken from the glyph set [bodind]

    {
        WCRUN *pwcrunLast =  &(pgset->awcrun[pgset->cRuns - 1]);
        pifi->wcFirstChar =  pgset->awcrun[0].wcLow;
        pifi->wcLastChar  =  pwcrunLast->wcLow + pwcrunLast->cGlyphs - 1;
    }

    pifi->fwdCapHeight   = 0;
    pifi->fwdXHeight     = 0;

    pifi->dpCharSets = 0; // no multiple charsets in vector fonts

// All the fonts that this font driver will see are to be rendered left
// to right

    pifi->ptlBaseline.x = 1;
    pifi->ptlBaseline.y = 0;

    pifi->ptlAspect.y = (LONG) READ_WORD(&ajHdr[OFF_VertRes ]);
    pifi->ptlAspect.x = (LONG) READ_WORD(&ajHdr[OFF_HorizRes]);

    if (!(pifi->fsSelection & FM_SEL_ITALIC))
    {
    // The base class of font is not italicized,

        pifi->ptlCaret.x = 0;
        pifi->ptlCaret.y = 1;
    }
    else
    {
    // somewhat arbitrary

        pifi->ptlCaret.x = 1;
        pifi->ptlCaret.y = 2;
    }

//
// The font box reflects the  fact that a-spacing and c-spacing are zero
//
    pifi->rclFontBox.left   = 0;
    pifi->rclFontBox.top    = (LONG) pifi->fwdTypoAscender;
    pifi->rclFontBox.right  = (LONG) pifi->fwdMaxCharInc;
    pifi->rclFontBox.bottom = (LONG) pifi->fwdTypoDescender;

//
// achVendorId, do not bother figuring it out
//

    pifi->achVendId[0] = 'U';
    pifi->achVendId[1] = 'n';
    pifi->achVendId[2] = 'k';
    pifi->achVendId[3] = 'n';

    pifi->cKerningPairs   = 0;

//
// Panose
//
    pifi->ulPanoseCulture = FM_PANOSE_CULTURE_LATIN;
    ppanose = &(pifi->panose);
    ppanose->bFamilyType = PAN_NO_FIT;
    ppanose->bSerifStyle =
        ((pifi->jWinPitchAndFamily & 0xf0) == FF_SWISS) ?
            PAN_SERIF_NORMAL_SANS : PAN_ANY;
    ppanose->bWeight = (BYTE) WINWT_TO_PANWT(READ_WORD(&ajHdr[OFF_Weight]));
    ppanose->bProportion = (READ_WORD(&ajHdr[OFF_PixWidth]) == 0) ? PAN_ANY : PAN_PROP_MONOSPACED;
    ppanose->bContrast        = PAN_ANY;
    ppanose->bStrokeVariation = PAN_ANY;
    ppanose->bArmStyle        = PAN_ANY;
    ppanose->bLetterform      = PAN_ANY;
    ppanose->bMidline         = PAN_ANY;
    ppanose->bXHeight         = PAN_ANY;

//
// Now fill in the fields for the simulated fonts
//

    if (pifi->dpFontSim)
    {
    //
    // Create a FONTDIFF template reflecting the base font
    //
        FONTDIFF FontDiff;

        FontDiff.jReserved1      = 0;
        FontDiff.jReserved2      = 0;
        FontDiff.jReserved3      = 0;
        FontDiff.bWeight         = pifi->panose.bWeight;
        FontDiff.usWinWeight     = pifi->usWinWeight;
        FontDiff.fsSelection     = pifi->fsSelection;
        FontDiff.fwdAveCharWidth = pifi->fwdAveCharWidth;
        FontDiff.fwdMaxCharInc   = pifi->fwdMaxCharInc;
        FontDiff.ptlCaret        = pifi->ptlCaret;

        if (pfdiffBold)
        {
            *pfdiffBold = FontDiff;
            pfdiffBoldItalic->bWeight    = PAN_WEIGHT_BOLD;
            pfdiffBold->fsSelection     |= FM_SEL_BOLD;
            pfdiffBold->usWinWeight      = FW_BOLD;

        // in vtfd case this is only true in the notional space

            pfdiffBold->fwdAveCharWidth += 1;
             pfdiffBold->fwdMaxCharInc   += 1;
        }

        if (pfdiffItalic)
        {
            *pfdiffItalic = FontDiff;
            pfdiffItalic->fsSelection     |= FM_SEL_ITALIC;
            pfdiffItalic->ptlCaret.x = 1;
            pfdiffItalic->ptlCaret.y = 2;
        }

        if (pfdiffBoldItalic)
        {
            *pfdiffBoldItalic = FontDiff;
            pfdiffBoldItalic->bWeight          = PAN_WEIGHT_BOLD;
            pfdiffBoldItalic->fsSelection     |= (FM_SEL_BOLD | FM_SEL_ITALIC);
            pfdiffBoldItalic->usWinWeight      = FW_BOLD;
            pfdiffBoldItalic->ptlCaret.x       = 1;
            pfdiffBoldItalic->ptlCaret.y       = 2;

        // in vtfd case this is only true in the notional space

            pfdiffBoldItalic->fwdAveCharWidth += 1;
            pfdiffBoldItalic->fwdMaxCharInc   += 1;
        }
    }

}





ULONG cjVTFDIFIMETRICS(PBYTE ajHdr)
{
    ULONG cjIFI = ALIGN4(sizeof(IFIMETRICS));
    PSZ   pszFaceName = ajHdr + READ_DWORD(&ajHdr[OFF_Face]);
    ULONG cSims;

    cjIFI += ALIGN4((strlen(pszFaceName) + 1) * sizeof(WCHAR));

// add simulations:

    if (cSims = (cVtfdResFaces(ajHdr) - 1))
        cjIFI += (ALIGN4(sizeof(FONTSIM)) + cSims * ALIGN4(sizeof(FONTDIFF)));

    return cjIFI;
}




/******************************Private*Routine*****************************\
* HFF hffVtfdLoadFont
*
* Loads an *.fon or an *.fnt file, returns handle to a fonfile object
* if successfull.
*
* History:
*  Wed 04-Nov-1992 -by- Bodin Dresevic [BodinD]
* update: rewrote it to reflect the new ifimetrics organization;
*  26-Feb-1992 -by- Wendy Wu [wendywu]
* Adapted from bmfd.
\**************************************************************************/

BOOL bVtfdLoadFont(PVOID pvView, ULONG cjView, ULONG_PTR iFile, ULONG iType, HFF *phff)
{
    WINRESDATA  wrd;
    RES_ELEM    re;
    ULONG       dpIFI, cjFF;
    ULONG       ifnt;
    PIFIMETRICS pifi;

    *phff = (HFF)NULL;

    if (iType == TYPE_DLL16)
    {
        if (!bInitWinResData(pvView,cjView, &wrd))
            return FALSE;
    }
    else // TYPE_FNT or TYPE_EXE
    {
        ASSERTDD((iType == TYPE_FNT) || (iType == TYPE_EXE),
                  "hffVtfdLoadFont: wrong iType\n");

        re.pvResData = pvView;
        re.dpResData = 0;
        re.cjResData = cjView;
        re.pjFaceName = NULL;
        wrd.cFntRes = 1;
    }

    cjFF = dpIFI = offsetof(FONTFILE,afd) + wrd.cFntRes * sizeof(FACEDATA);

    for (ifnt = 0; ifnt < wrd.cFntRes; ifnt++)
    {
        if (iType == TYPE_DLL16)
            vGetFntResource(&wrd, ifnt, &re);

    // verify that this is a no nonsense resource:

        if (!bVerifyVTFD(&re))
            return FALSE;

        cjFF += cjVTFDIFIMETRICS(re.pvResData);
    }

// now at the bottom of the structure we will store File name

// Let's allocate the FONTFILE struct.

    if ((*phff = (HFF)pffAlloc(cjFF)) == (HFF)NULL)
    {
        WARNING("hffVtfdLoadFont: memory allocation error\n");
        return FALSE;
    }

// Initialize fields of FONTFILE struct.

    PFF(*phff)->iType      = iType;
    PFF(*phff)->fl         = 0;
    PFF(*phff)->cRef       = 0L;
    PFF(*phff)->iFile      = iFile;
    PFF(*phff)->pvView     = pvView;
    PFF(*phff)->cjView       = cjView;
    PFF(*phff)->cFace      = wrd.cFntRes;

    pifi = (PIFIMETRICS)((PBYTE)PFF(*phff) + dpIFI);

    for (ifnt = 0; ifnt < wrd.cFntRes; ifnt++)
    {
        if (iType == TYPE_DLL16)
            vGetFntResource(&wrd, ifnt, &re);

        PFF(*phff)->afd[ifnt].re = re;
        PFF(*phff)->afd[ifnt].iDefFace = iDefaultFace(re.pvResData);
        PFF(*phff)->afd[ifnt].pifi = pifi;

        PFF(*phff)->afd[ifnt].pcp = pcpComputeGlyphset(
                                 &gpcpVTFD,
                                 (UINT)((BYTE *)re.pvResData)[OFF_FirstChar],
                                 (UINT)((BYTE *)re.pvResData)[OFF_LastChar],
                                 ((BYTE*)(re.pvResData))[OFF_CharSet]
                                 );

        if (PFF(*phff)->afd[ifnt].pcp == NULL)
        {
            vFree(*phff);    // clean up
            *phff = (HFF)NULL; // do not clean up again in exception code path

            WARNING("pgsetCompute failed\n");
            return (FALSE);
        }

        vVtfdFill_IFIMetrics(re.pvResData, &(PFF(*phff)->afd[ifnt].pcp->gset),pifi);
        pifi = (PIFIMETRICS)((PBYTE)pifi + pifi->cjThis);
    }

    return TRUE;
}

/******************************Public*Routine******************************\
* vtfdLoadFontFile
*
* Load the given font file into memory and prepare the file for use.
*
* History:
*  26-Feb-1992 -by- Wendy Wu [wendywu]
* Adapted from bmfd.
\**************************************************************************/

BOOL vtfdLoadFontFile(ULONG_PTR iFile, PVOID pvView, ULONG cjView, HFF *phff)
{
    BOOL     bRet = FALSE;

    *phff = (HFF)NULL;

// Try loading it as a fon file, if it does not work, try as an fnt file.

    if (!(bRet = bVtfdLoadFont(pvView, cjView, iFile, TYPE_DLL16,phff)))
        bRet = bVtfdLoadFont(pvView, cjView, iFile, TYPE_FNT, phff);  // try as an *.fnt file

    return bRet;
}

/******************************Public*Routine******************************\
* BOOL vtfdUnloadFontFile
*
* Unload a font file and free all the structures created.
*
* History:
*  26-Feb-1992 -by- Wendy Wu [wendywu]
* Adapted from bmfd.
\**************************************************************************/

BOOL vtfdUnloadFontFile(HFF hff)
{
    ULONG iFace;

    if (hff == HFF_INVALID)
        return(FALSE);

// check the reference count, if not 0 (font file is still
// selected into a font context) we have a problem

    ASSERTDD(PFF(hff)->cRef == 0L, "cRef: links are broken\n");

// unload all glyphsets:

    for (iFace = 0; iFace < PFF(hff)->cFace; iFace++)
    {
        vUnloadGlyphset(&gpcpVTFD,
                        PFF(hff)->afd[iFace].pcp);
    }

// the file has been umapped as cRef went back to zero

    vFree(PFF(hff));

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\vtfd\fdfc.c ===
/******************************Module*Header*******************************\
* Module Name: fdfc.c
*
* Various font context functions.  Adapted from BodinD's bitmap font driver.
*
* Copyright (c) 1990-1995 Microsoft Corporation
\**************************************************************************/

#include "fd.h"

#define MIN(A,B)    ((A) < (B) ?  (A) : (B))
#define MAX(A,B)    ((A) > (B) ?  (A) : (B))

#if defined(_AMD64_) || defined(_IA64_)
#define MUL16(ef)   {ef *= 16; }
#define lCvt(ef, l) ((LONG) (ef * l))
#else
#define MUL16(ef)   {if (ef.lMant != 0) ef.lExp += 4; }
LONG lCvt(EFLOAT ef,LONG l);
#endif

/******************************Private*Routine*****************************\
* BOOL bInitXform
*
* Initialize the coefficients of the transforms for the given font context.
* It also transforms and saves various measurements of the font in the
* context.
*
* History:
*  25-Feb-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL bInitXform(PFONTCONTEXT pfc, XFORMOBJ *pxo)
{
// !!! bFloatToFix should be replaced with a compare and a type cast.
// Dont update the coefficeints in the font context yet since overflows
// might occur.

    VECTORFL  vtflTmp;
    POINTL    ptl;
    XFORML    xfm;

// Get the transform elements.

    XFORMOBJ_iGetXform(pxo,&xfm);

// Convert elements of the matrix from IEEE float to our EFLOAT.

    vEToEF(xfm.eM11, &pfc->efM11);
    vEToEF(xfm.eM12, &pfc->efM12);
    vEToEF(xfm.eM21, &pfc->efM21);
    vEToEF(xfm.eM22, &pfc->efM22);

// The path we are to construct takes 1/16 pixel per unit.  So lets
// multiply this factor in the transform.

    MUL16(pfc->efM11)
    MUL16(pfc->efM12)
    MUL16(pfc->efM21)
    MUL16(pfc->efM22)

//
// These are the special cases for which we need to clip bottom and right
// edges.  Below is the lower case letter e all posible 90 rotations and
// flips.
//
//
//  ***     ***      **       *****    ***     ***     *****       **
// *   *   *        *  *  *  *  *  *      *   *   *   *  *  *  *  *  *
// *****   *****    *  *  *  *  *  *  *****   *****   *  *  *  *  *  *
// *       *   *    *  *  *  *  *  *  *   *       *   *  *  *  *  *  *
//  ***     ***      *****    **       ***     ***        **    *****
//
// case 1  case 2   case 6   case 5   case 3  case 4   case 7   case 8
//
//


    if (bIsZero(pfc->efM12) && bIsZero(pfc->efM21))
    {
        pfc->flags |= FC_SCALE_ONLY;
        if (!bPositive(pfc->efM11))
            pfc->flags |= FC_X_INVERT;

        if( bPositive(pfc->efM11 ) )
        {
            pfc->flags |= (bPositive(pfc->efM22)) ?  FC_ORIENT_1 : FC_ORIENT_2;
        }
        else
        {
            pfc->flags |= (bPositive(pfc->efM22)) ?  FC_ORIENT_4 : FC_ORIENT_3;
        }

    }


    if( bIsZero(pfc->efM22) && bIsZero(pfc->efM11) )
    {

        if( bPositive(pfc->efM21 ) )
        {
            pfc->flags |= (bPositive(pfc->efM12)) ?  FC_ORIENT_5 : FC_ORIENT_6;
        }
        else
        {
            pfc->flags |= (bPositive(pfc->efM12)) ?  FC_ORIENT_7 : FC_ORIENT_8;
        }
    }



// Transform the base and the side vectors.  Should never overflow.

    ptl.x = 1;
    ptl.y = 0;

    bXformUnitVector(&ptl,
                     &xfm,
                     &pfc->vtflBase,
                     &pfc->pteUnitBase,
                     (pfc->flags & FC_SIM_EMBOLDEN) ? &pfc->ptqUnitBase : NULL,
                     &pfc->efBase);

    pfc->fxEmbolden = 0;

    if (pfc->flags & FC_SIM_EMBOLDEN)
    {
    // emboldening shift for vector fonts in not always one with vector fonts
    // It is computed as 1 * efBase. This is win31 compatible way of doing this

        pfc->fxEmbolden = ((lCvt(pfc->efBase, 1) + 8) & 0xfffffff0);
        if (pfc->fxEmbolden < 24)
        {
        // primitive "hinting", do not let it become zero

            pfc->fxEmbolden      = 16;
            pfc->pfxBaseOffset.x = FXTOL(pfc->ptqUnitBase.x.HighPart + 8);
            pfc->pfxBaseOffset.y = FXTOL(pfc->ptqUnitBase.y.HighPart + 8);

        // resolve mult of 45 degrees situations:

            if ((pfc->pfxBaseOffset.x == pfc->pfxBaseOffset.y) ||
                (pfc->pfxBaseOffset.x == -pfc->pfxBaseOffset.y) )
            {
                pfc->pfxBaseOffset.y = 0;
            }

            pfc->pfxBaseOffset.x = LTOFX(pfc->pfxBaseOffset.x);
            pfc->pfxBaseOffset.y = LTOFX(pfc->pfxBaseOffset.y);

            ASSERTDD(pfc->pfxBaseOffset.x || pfc->pfxBaseOffset.y, "x zero and y zero\n");
            ASSERTDD((pfc->pfxBaseOffset.x && pfc->pfxBaseOffset.y) == 0, "x * y not zero\n");
        }
        else
        {
            pfc->pfxBaseOffset.x = lCvt(pfc->vtflBase.x, 1);
            pfc->pfxBaseOffset.y = lCvt(pfc->vtflBase.y, 1);
        }
    }

// Transform the side vector.

    ptl.x = 0;
    ptl.y = -1;

    bXformUnitVector(&ptl, &xfm, &vtflTmp,
                     &pfc->pteUnitSide, NULL, &pfc->efSide);

    pfc->fxInkTop = fxLTimesEf(&pfc->efSide, pfc->pifi->fwdWinAscender);
    pfc->fxInkBottom = -fxLTimesEf(&pfc->efSide, pfc->pifi->fwdWinDescender);

    pfc->fxItalic = 0;
    if (pfc->flags & FC_SIM_ITALICIZE)
    {
        pfc->fxItalic
            = (fxLTimesEf(
                 &pfc->efBase,
                 (pfc->pifi->fwdWinAscender + pfc->pifi->fwdWinDescender + 1)/2
                 ) + 8) & 0xfffffff0 ;
    }


    return(TRUE);
}

/******************************Public*Routine******************************\
* HFC vtfdOpenFontContext
*
* Open a font context.  Store font transform and other requests for
* the realization of this font.
*
* History:
*  27-Feb-1992 -by- Wendy Wu [wendywu]
* Adapted from bmfd.
\**************************************************************************/

HFC vtfdOpenFontContext(FONTOBJ *pfo)
{
    PFONTFILE    pff = (PFONTFILE)pfo->iFile;
    PFONTCONTEXT pfc;
    BYTE         *pjView;
    DWORD        dwFirstCharOffset;

#ifdef DEBUGSIM
    DbgPrint("vtfdOpenFontContext, ulFont = %ld\n", ulFont);
#endif // DEBUGSIM

    if (pff == (PFONTFILE) NULL)
        return(HFC_INVALID);

// iFace is 1 based:

    if ((pfo->iFace < 1L) || (pfo->iFace > pff->cFace)) // pfo->iFace values are 1 based
        return(HFC_INVALID);

// increase the reference count of the font file, WE DO THIS ONLY WHEN
// WE ARE SURE that can not fail any more

// need to grab a sem for we will be looking into cRef now.

    if (pff->cRef == 0)
    {
    // need to remap the file into the memory again and update pointers:

        UINT  i;

        if (!EngMapFontFileFD(pff->iFile,(PULONG*)&pff->pvView, &pff->cjView))
        {
            WARNING("somebody removed the file\n");
            return (HFC_INVALID);
        }

        for (i = 0; i < pff->cFace; i++)
        {
            pff->afd[i].re.pvResData = (PVOID) (
                (BYTE*)pff->pvView + pff->afd[i].re.dpResData
                );
        }
    }

// remember this so that we do not have to read from the file
// after we allocate the memory for the font context. This simplifies
// clean up code in case of exception, i.e. disappearing font files.

    pjView = pff->afd[pfo->iFace-1].re.pvResData;
    dwFirstCharOffset = READ_DWORD(pjView + OFF_BitsOffset);

// Allocate memory for the font context.

    if ((pfc = pfcAlloc()) == (PFONTCONTEXT)NULL)
    {
        if (pff->cRef == 0)
        {
            EngUnmapFontFileFD(pff->iFile);
        }
        return(HFC_INVALID);
    }

// we MUST NOT not touch the memory mapped file past this point
// until the end of the routine. This is important for the
// proper clean up code in case of exception. [bodind]

    pfc->pre = &pff->afd[pfo->iFace-1].re;
    pfc->pifi = pff->afd[pfo->iFace-1].pifi;

// SET wendywu style flags

    pfc->flags = 0;

    if (pfo->flFontType & FO_SIM_BOLD)
        pfc->flags |= FC_SIM_EMBOLDEN;

    if (pfo->flFontType & FO_SIM_ITALIC)
        pfc->flags |= FC_SIM_ITALICIZE;

    pfc->dpFirstChar = dwFirstCharOffset;

// !!! Vector font file doesn't have the byte filler.  Win31 bug?

    //pfc->ajCharTable = pjView + OFF_jUnused20;

// Store the transform matrix.

    if ( !bInitXform(pfc, FONTOBJ_pxoGetXform(pfo)) )
    {
        WARNING("vtfdOpenFontContext transform out of range\n");

        if (pff->cRef == 0)
        {
            EngUnmapFontFileFD(pff->iFile);
        }
        vFree(pfc);
        return(HFC_INVALID);
    }

// State that the hff passed to this function is the FF selected in
// this font context.

    pfc->pff = pff;

    (pff->cRef)++;

    return((HFC)pfc);
}

/******************************Public*Routine******************************\
* vtfdDestroyFont
*
* Driver can release all resources associated with this font realization
* (embodied in the FONTOBJ).
*
* History:
*  02-Sep-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
vtfdDestroyFont (
    FONTOBJ *pfo
    )
{
//
// For the vector font driver, this is simply closing the font context.
// We cleverly store the font context handle in the FONTOBJ pvProducer
// field.
//
    EngAcquireSemaphore(ghsemVTFD);
    vtfdCloseFontContext((HFC) pfo->pvProducer);
    EngReleaseSemaphore(ghsemVTFD);
}


/******************************Public*Routine******************************\
* BOOL  vtfdCloseFontContext
*
* Close the font context and update the context link for the associated
* font file.
*
* History:
*  27-Feb-1992 -by- Wendy Wu [wendywu]
* Adapted from bmfd.
\**************************************************************************/

BOOL vtfdCloseFontContext(HFC hfc)
{
    BOOL bRet;

    if (hfc != HFC_INVALID)
    {
        //
        // decrement the reference count for the corresponding FONTFILE
        //

        if (PFC(hfc)->pff->cRef > 0L)
        {
            (PFC(hfc)->pff->cRef)--;

            //
            // if this file is going out of use we can close it to save memory
            //

            if (PFC(hfc)->pff->cRef == 0L)
            {
                // if FF_EXCEPTION_IN_PAGE_ERROR is set
                // and the font type is TYPE_FNT or TYPE_DLL16
                // the font file must have been unmapped in vVtfdMarkFontGone

                if (!(PFC(hfc)->pff->fl & FF_EXCEPTION_IN_PAGE_ERROR) ||
                    !((PFC(hfc)->pff->iType == TYPE_FNT) || (PFC(hfc)->pff->iType == TYPE_DLL16)))
                {
                    EngUnmapFontFileFD(PFC(hfc)->pff->iFile);
                }
                PFC(hfc)->pff->fl &= ~FF_EXCEPTION_IN_PAGE_ERROR;
            }

            //
            // free the memory associated with hfc
            //

            vFree(PFC(hfc));

            bRet = TRUE;
        }
        else
        {
            WARNING("vtfdCloseFontContext: cRef <= 0\n");
            bRet = FALSE;
        }

    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\vtfd\fdquery.c ===
/******************************Module*Header*******************************\
* Module Name: fdquery.c
*
* Contains all the vtfdQueryXXX functions.  Adapted from BodinD's bitmap font
* driver.
*
* Copyright (c) 1990-1995 Microsoft Corporation
\**************************************************************************/

#include "fd.h"
#include "exehdr.h"

#define OFF_CharWidth   2       //!!!Move to winfont.h
                                //!!!Define OFF_CharTable10

// Retrieve description string from .FON files.

BOOL bDescStr (PVOID pvView, PSZ pszString);

//
// Function prototypes.
//

ULONG
cjVtfdDeviceMetrics (
    PFONTCONTEXT     pfc,
    FD_DEVICEMETRICS *pdevm
    );

VOID
vFill_GlyphData (
    PFONTCONTEXT pfc,
    GLYPHDATA *pgldt,
    UINT iIndex
    );

BOOL
bCreatePath (
    PCHAR pch,
    PCHAR pchEnd,
    PFONTCONTEXT pfc,
    PATHOBJ *ppo,
    FIX fxAB
    );

VOID
vFill_GlyphData (
    PFONTCONTEXT pfc,
    GLYPHDATA *pgldt,
    UINT iIndex
    );

#if defined(_AMD64_) || defined(_IA64_)
#define lCvt(ef, l) ((LONG) (ef * l))
#else
LONG lCvt(EFLOAT ef,LONG l);
#endif

//!!! this function is living in ttfd. should be moved to the engine [bodind]

VOID vAddPOINTQF(POINTQF *, POINTQF *);



/******************************Public*Routine******************************\
*
* BOOL bReconnectVtfdFont(FONTFILE *pff)
*
*
* Effects: If the file is marked gone, we try to reconnect and see if we can
*          use it again. We clear the exception bit so that the system will
*          be able to use this font again.
*
* History:
*  17-Aug-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL bReconnectVtfdFont(FONTFILE *pff)
{
    INT i;

    if ((pff->iType == TYPE_FNT) || (pff->iType == TYPE_DLL16))
    {

        if (!EngMapFontFileFD(pff->iFile, (PULONG*)&pff->pvView, &pff->cjView ))
        {
            WARNING("can not reconnect this vector font !!!\n");
            return FALSE;
        }

        for (i = 0; i < (INT)pff->cFace; i++)
        {
            pff->afd[i].re.pvResData = (PVOID) (
                (BYTE*)pff->pvView + pff->afd[i].re.dpResData
                );
        }
    }
    else
    {
        return FALSE;
    }

// everything is fine again, clear the bit

    pff->fl &= ~FF_EXCEPTION_IN_PAGE_ERROR;
    return TRUE;
}





/******************************Public*Routine******************************\
* PIFIMETRICS vtfdQueryFont
*
* Return a pointer to the IFIMETRICS for the given face.
*
* History:
*  31-Aug-1992 Gilman Wong [gilmanw]
* IFI/DDI merge.
*
*  26-Feb-1992 -by- Wendy Wu [wendywu]
* Adapted from bmfd.
\**************************************************************************/

PIFIMETRICS vtfdQueryFont (
    DHPDEV dhpdev,
    HFF    hff,
    ULONG  iFace,
    ULONG_PTR  *pid
    )
{
    PFONTFILE pff;

//
// Validate handle.
//
    if (hff == HFF_INVALID)
    {
        WARNING("vtfdQueryFaces(): invalid iFile (hff)\n");
        return (PIFIMETRICS) NULL;
    }

//
// We never unlock FONTFILE since it contains IFIMETRICS that engine
// has a pointer to.  hff is actually a pointer to the FONTFILE struct.
//
    pff = (PFONTFILE)hff;

//
// Assume iFace within bounds.
//
    ASSERTDD((iFace >= 1L) && (iFace <= pff->cFace),
             "vtfdQueryFaces: iFace out of range\n");

//
// Return pointer to IFIMETRICS.
//
    return pff->afd[iFace-1].pifi;
}

/******************************Public*Routine******************************\
* LONG vtfdQueryFontCaps
*
* Retrieve the capabilities of the font driver.
*
* History:
*  26-Feb-1992 -by- Wendy Wu [wendywu]
* Adapted from bmfd.
\**************************************************************************/

LONG vtfdQueryFontCaps (
    ULONG  culCaps,
    PULONG pulCaps
    )
{
    ASSERTDD(culCaps == 2, "ERROR - come on - update the font drivers");
    pulCaps[0] = 2L;

    //
    // The vector font driver only returns outlines.
    //

    pulCaps[1] = QC_OUTLINES;
    return(2);
}

/******************************Public*Routine******************************\
* vtfdQueryFontTree
*
* This function returns pointers to per-face information.
*
* Parameters:
*
*   dhpdev      Not used.
*
*   hff         Handle to a font file.
*
*   iFace       Index of a face in the font file.
*
*   iMode       This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFT_LIGATURES -- returns a pointer to the ligature map.
*
*       QFT_KERNPAIRS -- return a pointer to the kerning pair table.
*
*       QFT_GLYPHSET  -- return a pointer to the WC->HGLYPH mapping table.
*
*   pid         Not used.
*
* Returns:
a   Returns a pointer to the requested data.  This data will not change
*   until VtfdfdFree is called on the pointer.  Caller must not attempt to
*   modify the data.  NULL is returned if an error occurs.
*
* History:
*  31-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PVOID
vtfdQueryFontTree (
    DHPDEV  dhpdev,
    HFF     hff,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR   *pid
    )
{
    PFONTFILE pff;

//
// Validate parameters.
//
    if (hff == HFF_INVALID)
    {
        WARNING("vtfdQueryFontTree(): invalid iFile (hff)\n");
        return ((PVOID) NULL);
    }

//
// Convert from handle to pointer.
//
    pff = (PFONTFILE)hff;

    // Note: ulFont values are index-1 based.

    if ((iFace < 1L) || (iFace > pff->cFace))
    {
        WARNING("vtfdQueryFontTree()\n");
        return (NULL);
    }

//
// Which mode?
//
    switch (iMode)
    {
    case QFT_LIGATURES:
    case QFT_KERNPAIRS:

    //
    // There are no ligatures or kerning pairs for the vector fonts,
    // therefore we return NULL
    //
        return ((PVOID) NULL);

    case QFT_GLYPHSET:

        return &pff->afd[iFace - 1].pcp->gset;

    default:

    //
    // Should never get here.
    //
    RIP("gdisrv!vtfdQueryFontTree(): unknown iMode\n");
        return ((PVOID) NULL);
    }
}


/******************************Public*Routine******************************\
* vtfdQueryFontData
*
*   dhpdev      Not used.
*
*   pfo         Pointer to a FONTOBJ.
*
*   iMode       This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFD_GLYPH           -- return glyph metrics only
*
*       QFD_GLYPHANDBITMAP  -- return glyph metrics and bitmap
*
*       QFD_GLYPHANDOUTLINE -- return glyph metrics and outline
*
*       QFD_MAXEXTENTS      -- return FD_DEVICEMETRICS structure
*
*       QFD_MAXGLYPHBITMAP  -- return size of largest glyph AND its metrics
*
*   cData       Count of data items in the pvIn buffer.
*
*   pvIn        An array of glyph handles.
*
*   pvOut       Output buffer.
*
* Returns:
*   If mode is QFD_MAXGLYPHBITMAP, then size of glyph metrics plus
*   largest bitmap is returned.
*
*   Otherwise, if pvOut is NULL, function will return size of the buffer
*   needed to copy the data requested; else, the function will return the
*   number of bytes written.
*
*   FD_ERROR is returned if an error occurs.
*
* History:
*  31-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LONG
vtfdQueryFontData (
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH  hg,
    GLYPHDATA *pgd,
    PVOID   pv,
    ULONG   cjSize
    )
{
    PFONTCONTEXT pfc;
    PBYTE        ajHdr;
    UINT         iIndex, iIndexNext;
    PCHAR        pch, pchEnd;
    PATHOBJ      *ppo;
    PBYTE        pjFirstChar, ajCharTable;
    GLYPHDATA    gd;

// MAKE sure that the file is not gone

    if (PFF(pfo->iFile)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
    // file gone, try to reconnect, if can not reconnect,
    // no questions will be answered about it:

        if (!bReconnectVtfdFont(PFF(pfo->iFile)))
        {
            WARNING("vtfdQueryFontData: EXCEPTION_IN_PAGE_ERROR\n");
            return FD_ERROR;
        }
    }

// If pfo->pvProducer is NULL, then we need to open a font context.

    if ( pfo->pvProducer == (PVOID) NULL )
        pfo->pvProducer = (PVOID) vtfdOpenFontContext(pfo);

    if ( pfo->pvProducer == (PVOID) NULL )
    {
        WARNING("vtfdQueryFontData: pvProducer\n");
        return FD_ERROR;
    }

    pfc = (PFONTCONTEXT) pfo->pvProducer;

// Setup local pointers to font file header. Note that these
// could not be saved at fc creation time, for they could have changed
// after net went down and back up again after reconnecting. [bodind]

    ajHdr = pfc->pre->pvResData;
    pjFirstChar = ajHdr + pfc->dpFirstChar;
    ajCharTable = ajHdr + OFF_jUnused20;

// What mode?

    switch (iMode)
    {

    case QFD_GLYPHANDOUTLINE:
        {

        //
        // Grab pointer to PATHOBJ* array.
        //
            ppo = (PATHOBJ *)pv;


        //
        // Assume the engine will not pass an invalid handle.
        //
            ASSERTDD(hg != HGLYPH_INVALID,
                    "vtfdQueryFontData(QFD_GLYPHANDOUTLINE): invalid hglyph\n");

        //
        // Use default glyph if hglyph out of range.
        //
            if (hg > (HGLYPH)(ajHdr[OFF_LastChar] - ajHdr[OFF_FirstChar]))
                iIndex = ajHdr[OFF_DefaultChar];
            else
                iIndex = hg;

        //
        // Fill in the GLYPHDATA structure.
        //
        if( pgd == NULL )
        {
            pgd = &gd;
        }

        vFill_GlyphData(pfc, pgd, iIndex);
        pgd->hg = hg;

        //
        // Construct the path.
        //
            if (ppo != NULL)
            {
                iIndexNext = iIndex + 1;

                if (pfc->pifi->flInfo & FM_INFO_CONSTANT_WIDTH)
                {
                    iIndex <<= 1;           // each entry is 2-byte long
                    iIndexNext <<= 1;
                }
                else
                {
                    iIndex <<= 2;           // each entry is 4-byte long
                    iIndexNext <<= 2;
                }

                pch = pjFirstChar + READ_WORD(&ajCharTable[iIndex]);
                pchEnd = pjFirstChar + READ_WORD(&ajCharTable[iIndexNext]);

                ASSERTDD((*pch == PEN_UP),
                   "vtfdQueryFontData(QFD_GLYPHANDOUTLINE): First command is not PEN_UP");

                if ( !bCreatePath(pch, pchEnd, pfc, ppo, pgd->fxAB) )
                {
                    return FD_ERROR;
                }
            }
        }

    //
    // Return buffer size needed for all GLYPHDATA.
    //
        return 0;

    case QFD_MAXEXTENTS:
    //
    // If buffer NULL, return size.
    //
        if ( pv == (PVOID) NULL )
            return (sizeof(FD_DEVICEMETRICS));

    //
    // Otherwise, copy the data structure.
    //
        else
            return cjVtfdDeviceMetrics(pfc, (FD_DEVICEMETRICS *) pv);

    default:

        WARNING("vtfdQueryFontData(): unsupported mode\n");
        return FD_ERROR;
    }
}


/******************************Public*Routine******************************\
* vtfdQueryFontFile
*
* A function to query per font file information.
*
* Parameters:
*
*   hff         Handle to a font file.
*
*   ulMode      This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFF_DESCRIPTION -- copies a UNICODE string in the buffer
*                          that describes the contents of the font file.
*
*       QFF_NUMFACES   -- returns number of faces in the font file.
*
*   cjBuf       Maximum number of BYTEs to copy into the buffer.  The
*               driver will not copy more than this many BYTEs.
*
*               This should be zero if pulBuf is NULL.
*
*               This parameter is not used in QFF_NUMFACES mode.
*
*   pulBuf      Pointer to the buffer to receive the data
*               If this is NULL, then the required buffer size
*               is returned as a count of BYTEs.  Notice that this
*               is a PULONG, to enforce 32-bit data alignment.
*
*               This parameter is not used in QFF_NUMFACES mode.
*
* Returns:
*
*   If mode is QFF_DESCRIPTION, then the number of BYTEs copied into
*   the buffer is returned by the function.  If pulBuf is NULL,
*   then the required buffer size (as a count of BYTEs) is returned.
*
*   If mode is QFF_NUMFACES, then number of faces in font file is returned.
*
*   FD_ERROR is returned if an error occurs.
*
* History:
*  09-Mar-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LONG vtfdQueryFontFile (
    HFF     hff,        // handle to font file
    ULONG   ulMode,     // type of query
    ULONG   cjBuf,      // size of buffer (in BYTEs)
    PULONG  pulBuf      // return buffer (NULL if requesting size of data)
    )
{
//
// We never unlock FONTFILE since it contains IFIMETRICS that the engine
// has a pointer to.  hff is actually a pointer to the FONTFILE struct.
//
    ULONG     cjDescription;
    PVOID       pvView;
    ULONG       cjView;
    PIFIMETRICS pifi;
    LPWSTR      pwszDescription;

    ASSERTDD(hff, "vtfdQueryFontFile, hff invalid\n");

    if (PFF(hff)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
    // file gone, try to reconnect, if can not reconnect,
    // no questions will be answered about it:

        if (!bReconnectVtfdFont(PFF(hff)))
        {
            WARNING("vtfdQueryFontFile: EXCEPTION_IN_PAGE_ERROR\n");
            return FD_ERROR;
        }
    }

//
// Which mode?
//
    switch (ulMode)
    {
    case QFF_DESCRIPTION:
    //
    // If .FON format, retrieve the description string from the mapped file view.
    //
        if (PFF(hff)->iType == TYPE_DLL16)
        {
            CHAR achDescription[256];   // max length of string in the 16-bit EXE.

        // check, maybe cRef is 0 so that fvw is not valid:

            if (PFF(hff)->cRef == 0)
            {
                if (!EngMapFontFileFD(PFF(hff)->iFile,(PULONG*)&pvView,&cjView))
                {
                    WARNING("somebody removed the file \n");
                    return FD_ERROR;
                }
            }
            else
            {
                pvView = PFF(hff)->pvView;
                cjView = PFF(hff)->cjView;
            }

            cjDescription = FD_ERROR;
            if (bDescStr(pvView, achDescription))
            {
                cjDescription = (strlen(achDescription) + 1) * sizeof(WCHAR);

            //
            // If there is a buffer, copy the data.
            //
                if ( pulBuf != (PULONG) NULL )
                {
                //
                // Is buffer big enough?
                //
                    if ( cjBuf < cjDescription )
                    {
                        WARNING("vtfdQueryFontFile(): buffer too small for string\n");
                        return (FD_ERROR);
                    }
                    else
                    {
                        vToUNICODEN((LPWSTR)pulBuf, cjDescription/sizeof(WCHAR), achDescription, cjDescription/sizeof(WCHAR));
                    }
                }

            }

        // clean up if need be

            if (PFF(hff)->cRef == 0)
                EngUnmapFontFileFD(PFF(hff)->iFile);

            return(cjDescription);
        }

    //
    // Otherwise, .FNT files do not have a description string.  We may also
    // get here if its a .FON format but bDescStr failed.  We will have
    // to use the facename.
    //

    //
    // Get ptr to the facename in the IFIMETRICS of the first font
    // in this font file.
    //
        pifi = PFF(hff)->afd[0].pifi;
        pwszDescription = (LPWSTR)((PBYTE) pifi + pifi->dpwszFaceName);
        cjDescription = (wcslen(pwszDescription) + 1) * sizeof(WCHAR);

    //
    // If there is a buffer, copy to it.
    //
        if ( pulBuf != (PULONG) NULL )
        {
        //
        // Is buffer big enough?
        //
            if ( cjBuf < cjDescription )
            {
                WARNING("vtfdQueryFontFile(): buffer too small for face\n");
                return (FD_ERROR);
            }
            else
            {
                RtlCopyMemory((PVOID) pulBuf,
                              (PVOID) pwszDescription,
                              cjDescription);
            }
        }

        return(cjDescription);

    case QFF_NUMFACES:

        return PFF(hff)->cFace;

    default:
        WARNING("vtfdQueryFontFile(): unknown mode\n");
        break;
    }

        // Default return.  We should not get here.
    return FD_ERROR;
}


/******************************Public*Routine******************************\
* cjVtfdDeviceMetrics
*
*
* Effects:
*
* Warnings:
*
* History:
*  30-Aug-1992 -by- Gilman Wong [gilmanw]
* Stole it from WendyWu's FdQueryFaceAttr() implementation.
\**************************************************************************/

ULONG
cjVtfdDeviceMetrics (
    PFONTCONTEXT     pfc,
    FD_DEVICEMETRICS *pdevm
    )
{
    PIFIMETRICS   pifi;
    EFLOAT efM11, efM12, efM21, efM22;
    BOOL bScaleOnly;

// Compute the accelerator flags for this font.

    pdevm->flRealizedType = 0; // no bitmaps are produced

    if ((pfc->flags & FC_SIM_ITALICIZE) == 0)
        pdevm->flRealizedType |= FDM_TYPE_ZERO_BEARINGS;

// Make sure nobody updates the font context when we're reading from it.
// !!! not possible, ResetFontContext is gone, [BODIND]

    efM11 = pfc->efM11;
    efM12 = pfc->efM12;
    efM21 = pfc->efM21;
    efM22 = pfc->efM22;

    pdevm->pteBase = pfc->pteUnitBase;
    pdevm->pteSide = pfc->pteUnitSide;

// fxMaxAscender/Descender are the distance from the baseline to the
// top/bottom of the glyph.  fxInkTop/Bottom are vectors along the
// ascent direction.  We need to adjust the sign properly.

    pdevm->fxMaxAscender = pfc->fxInkTop;
    pdevm->fxMaxDescender = -pfc->fxInkBottom;

    bScaleOnly = pfc->flags & FC_SCALE_ONLY;

    pdevm->cxMax = (ULONG)
        ((fxLTimesEf(&pfc->efBase, (LONG)pfc->pifi->fwdMaxCharInc) + 8) >> 4);

// Transform the character increment vector.

    if
    (
    // only report accellerators for horiz case

        (pfc->pifi->flInfo & FM_INFO_CONSTANT_WIDTH) &&
        (pfc->flags & FC_SCALE_ONLY)
    )
    {
        pdevm->lD = (LONG)pdevm->cxMax;
    }
    else // var pitch
    {
        pdevm->lD = 0;
    }

// Transform the StrikeOut and Underline vectors.

    pifi = pfc->pifi;
    pdevm->ptlUnderline1.y  = FXTOLROUND(fxLTimesEf(&efM22, -pifi->fwdUnderscorePosition));
    pdevm->ptlStrikeOut.y   = FXTOLROUND(fxLTimesEf(&efM22, -pifi->fwdStrikeoutPosition));

    pdevm->ptlULThickness.y = pdevm->ptlSOThickness.y = 1;
    pdevm->ptlULThickness.x = pdevm->ptlSOThickness.x = 0;

    if (pfc->flags & FC_SIM_EMBOLDEN)
        pdevm->ptlULThickness.y = pdevm->ptlSOThickness.y = 2;

    if (bScaleOnly)
    {
        pdevm->ptlUnderline1.x = pdevm->ptlStrikeOut.x = 0;

        if (!bPositive(efM22))
        {
            pdevm->ptlULThickness.y = -pdevm->ptlULThickness.y;
            pdevm->ptlSOThickness.y = -pdevm->ptlSOThickness.y;
        }
    }
    else
    {
    // !!!Cache this in HDC if underline or strikeout are used often.

        pdevm->ptlULThickness.x = FXTOLROUND(fxLTimesEf(&efM21, pdevm->ptlULThickness.y));
        pdevm->ptlULThickness.y = FXTOLROUND(fxLTimesEf(&efM22, pdevm->ptlULThickness.y));
        pdevm->ptlSOThickness.x = pdevm->ptlULThickness.x;
        pdevm->ptlSOThickness.y = pdevm->ptlULThickness.y;

        pdevm->ptlUnderline1.x  = FXTOLROUND(fxLTimesEf(&efM21, -pifi->fwdUnderscorePosition));
        pdevm->ptlStrikeOut.x   = FXTOLROUND(fxLTimesEf(&efM21, -pifi->fwdStrikeoutPosition));
    }

// devm, no bitmaps are supported;

    pdevm->cyMax = 0;
    pdevm->cjGlyphMax = 0;

    return(sizeof(FD_DEVICEMETRICS));
}


/******************************Private*Routine*****************************\
* VOID vFill_GlyphData
*
* Fill in the GLYPHDATA structure for the given glyph index.
*
* History:
*  18-Feb-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID vFill_GlyphData(PFONTCONTEXT pfc, GLYPHDATA *pgldt, UINT iIndex)
{
    LONG   lCharInc;
    PBYTE  ajCharTable = (PBYTE)pfc->pre->pvResData + OFF_jUnused20;

    pgldt->gdf.pgb = NULL;
    pgldt->hg = iIndex;                                 //!!!????

// Transform the character increment vector.

    if (pfc->pifi->flInfo & FM_INFO_CONSTANT_WIDTH)
    {
        lCharInc = pfc->pifi->fwdMaxCharInc;
    }
    else
    {
    // We're dealing with variable-width font, get the width from
    // the chartable.  Each entry in CharTable is 4-byte long.

        lCharInc = READ_WORD(ajCharTable + OFF_CharWidth + (iIndex << 2));
    }

    pgldt->fxInkTop = pfc->fxInkTop;
    pgldt->fxInkBottom = pfc->fxInkBottom;

    if (pfc->flags & FC_SCALE_ONLY)
    {
    // here we do rounding to be compat with windows 31, and also to
    // so that we can report the accelerator pdevm->lD  for fixed pitch
    // font as being really equal  to fxD's for such a font

        pgldt->fxD = ((fxLTimesEf(&pfc->efBase, lCharInc) + 8) & 0xfffffff0);

    // Simple scaling transform.

        if (pfc->flags & FC_X_INVERT)
            pgldt->ptqD.x.HighPart = -pgldt->fxD;
        else
            pgldt->ptqD.x.HighPart = pgldt->fxD;

        pgldt->ptqD.x.LowPart = 0;
        pgldt->ptqD.y.HighPart = 0;
        pgldt->ptqD.y.LowPart = 0;

    }
    else
    {
    // in this case we do not do rounding, we want everything consistent:

        pgldt->fxD = fxLTimesEf(&pfc->efBase, lCharInc);

    // Non trivial transform.

        vLTimesVtfl(lCharInc, &pfc->vtflBase, &pgldt->ptqD);
    }

//!!! not sure if these should be calculated differently for non-trivial cases.

    pgldt->fxA = 0;
    pgldt->fxAB = pgldt->fxD;

    if (pfc->flags & FC_SIM_EMBOLDEN)
    {
        pgldt->fxAB += pfc->fxEmbolden;
    }

    if (pfc->flags & FC_SIM_ITALICIZE)
    {
        pgldt->fxAB += pfc->fxItalic;
    }

//!!! rclInk is missing, but not needed I guess (bodind)

}

/******************************Public*Routine******************************\
* vtfdQueryAdvanceWidths                                                   *
*                                                                          *
* A routine to compute advance widths.                                     *
*                                                                          *
* History:                                                                 *
*  Mon 18-Jan-1993 08:13:02 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL vtfdQueryAdvanceWidths
(
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    LONG    *plWidths,
    ULONG    cGlyphs
)
{
    FONTCONTEXT *pfc;
    USHORT      *psWidths = (USHORT *) plWidths;   // True for the cases we handle.
    LONG     dx;
    ULONG    ii;
    PBYTE  ajCharTable;

    if (PFF(pfo->iFile)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
    // file gone, try to reconnect, if can not reconnect,
    // no questions will be answered about it:

        if (!bReconnectVtfdFont(PFF(pfo->iFile)))
        {
            WARNING("vtfdQueryAdvanceWidths: EXCEPTION_IN_PAGE_ERROR\n");
            return FD_ERROR;
        }
    }

// If pfo->pvProducer is NULL, then we need to open a font context.

    if ( pfo->pvProducer == (PVOID) NULL )
        pfo->pvProducer = (PVOID) vtfdOpenFontContext(pfo);

    if ( pfo->pvProducer == (PVOID) NULL )
    {
        WARNING("vtfdQueryAdvanceWidths: pvProducer\n");
        return FD_ERROR;
    }

    pfc = (FONTCONTEXT *) pfo->pvProducer;
    ajCharTable = (PBYTE)pfc->pre->pvResData + OFF_jUnused20;

    ASSERTDD(!(pfc->pifi->flInfo & FM_INFO_CONSTANT_WIDTH),
             "this is a fixed pitch font\n");

    // only report accellerators

    ASSERTDD((pfc->flags & FC_SCALE_ONLY),
             "must not be a rotating xform\n");

// Get the widths.

    for (ii=0; ii<cGlyphs; ii++,phg++,psWidths++)
    {
        dx = READ_WORD(ajCharTable + OFF_CharWidth + (*phg << 2));
        *psWidths = (SHORT) ((lCvt(pfc->efBase,dx) + 8) & 0xfffffff0);
    }
    return(TRUE);
}


/******************************Private*Routine*****************************\
* BOOL bCreatePath
*
* Create a path by reading the vector descriptions contained in the
* memory space pointed to between pch and pchEnd.
*
* History:
*  18-Feb-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

#define CPTS_MAX        5

BOOL
bCreatePath(
    PCHAR pch,
    PCHAR pchEnd,
    PFONTCONTEXT pfc,
    PATHOBJ *ppo,
    FIX fxAB)
{
    UINT        iPt, cPts = 0;
    LONG        lXLast, lDesc;
    POINTL      aptl[CPTS_MAX];
    POINTFIX    aptfx[CPTS_MAX];
    BOOL        bEmbolden, bItalicize, bScaleOnly, bReturn = TRUE;
    EFLOAT      efM11, efM12, efM21, efM22;
    POINTFIX    pfxBaseOffset;
    POINTFIX    ptfxBound;

    efM11 = pfc->efM11;
    efM12 = pfc->efM12;
    efM21 = pfc->efM21;
    efM22 = pfc->efM22;


    lDesc = pfc->pifi->fwdWinDescender;
    bEmbolden = pfc->flags & FC_SIM_EMBOLDEN;
    bItalicize = pfc->flags & FC_SIM_ITALICIZE;
    bScaleOnly = pfc->flags & FC_SCALE_ONLY;

    pfxBaseOffset = pfc->pfxBaseOffset;


// Some points in the glyphs paths may end up on the bottom or right edge of
// the bounding rectangle for a glyph.  Because of GIQ it is possible that
// sometimes these pels will get lit.  However, because our bounding rectangles
// are bottom right exclusive they will never be considered to contain these
// pels.  This is a problem.  We need to adjust by making sure that any points
// which can possibly light a pel on the bottom or right edge of the bounding
// rectangle are adjust either to the right or up.  Note that we only need
// to worry about orientations of 90 degrees because the engine will relax
// the bouding rectangle by one pel at other orientations. There are 8 cases
// altogether when we take flipping into account. [gerritv]


    switch( pfc->flags & ORIENT_MASK )
    {
        case FC_ORIENT_1:
            ptfxBound.x = fxAB - 0x10;
            ptfxBound.y = -pfc->fxInkBottom - 0x10;
            break;
        case FC_ORIENT_2:
            ptfxBound.x = fxAB - 0x10;
            ptfxBound.y = pfc->fxInkTop - 0x10;
            break;
        case FC_ORIENT_3:
            ptfxBound.y = pfc->fxInkTop - 0x10;
            ptfxBound.x = -0x10;
            break;
        case FC_ORIENT_4:
            ptfxBound.y = -pfc->fxInkBottom - 0x10;
            ptfxBound.x = -0x10;
            break;
        case FC_ORIENT_5:
            ptfxBound.x = -pfc->fxInkBottom - 0x10;
            ptfxBound.y = fxAB - 0x10;
            break;
        case FC_ORIENT_6:
            ptfxBound.x = -pfc->fxInkBottom - 0x10;
            ptfxBound.y = -0x10;
            break;
        case FC_ORIENT_7:
            ptfxBound.x = pfc->fxInkTop - 0x10;
            ptfxBound.y = fxAB - 0x10;
            break;
        case FC_ORIENT_8:
            ptfxBound.y = -0x10;
            ptfxBound.x = pfc->fxInkTop - 0x10;
            break;
    }


// The path starts from the top left corner of the cell.

    aptl[0].y = -pfc->pifi->fwdWinAscender;

    aptl[0].x = 0;

    while(pch <= pchEnd)
    {
        if ((*pch != PEN_UP) && (pch != pchEnd))
        {
        // Check if there is space left.  If not, send this batch of points
        // to engine for path construction.

            if (cPts >= CPTS_MAX)
                goto BUILD_PATH;

        // Attach this point to the end of the pointl array.

        // claudebe, NTRAID#440755 and 440756, PREFIX, we could have cPts == 0 and accessing
        //           aptl[-1], since vector font are becoming obsolete and this is very old code
        //           and no customer ever complain about a problem getting the path of a vector font
        //           I'm just doing a minimal fix to prevent accessing aptl[-1]
            if (cPts > 0)
            {
                aptl[cPts].x = (signed char)*pch++ + aptl[cPts-1].x;
                aptl[cPts].y = (signed char)*pch++ + aptl[cPts-1].y;
            } else {
                aptl[cPts].x = (signed char)*pch++ ;
                aptl[cPts].y = (signed char)*pch++ ;
            }

            cPts++;

        }
        else
        {
            if (cPts > 1)
            {
            BUILD_PATH:

                cPts--;

            // If Italic simulation is asked, x coordinates of all the points
            // will be changed.  Save the x of the last point so the next
            // batch will have a correct reference point.

                lXLast = aptl[cPts].x;
#if DEBUG
                {
                    UINT i;
                    DbgPrint("MoveTo (%lx, %lx)\n", aptl[0].x, aptl[0].y);
                    DbgPrint("PolyLineTo cPts = %lx\n",cPts);
                    for (i = 1; i <= cPts; i++)
                    {
                        DbgPrint("   (%lx, %lx)\n",aptl[i].x, aptl[i].y);
                    }
                }
#endif
                if (bItalicize)
                {
                    for (iPt = 0; iPt <= cPts; iPt++)
                        aptl[iPt].x += (lDesc - aptl[iPt].y)>>1;
                }

                if (bScaleOnly)
                {
                    for (iPt = 0; iPt <= cPts; iPt++)
                    {
                        aptfx[iPt].x = (FIX)lCvt(efM11, aptl[iPt].x);
                        aptfx[iPt].y = (FIX)lCvt(efM22, aptl[iPt].y);


                        if( aptfx[iPt].y > ptfxBound.y )
                        {
#if DEBUG
                            DbgPrint("y adjust %x to %x\n", aptfx[iPt].y, ptfxBound.y );
#endif
                            aptfx[iPt].y = ptfxBound.y;
                        }

                        if( aptfx[iPt].x > ptfxBound.x )
                        {
#if DEBUG
                            DbgPrint("x adjust %x %x\n", aptfx[iPt].x, ptfxBound.x );
#endif
                            aptfx[iPt].x = ptfxBound.x;
                        }

                    }
                }
                else
                {
                    for (iPt = 0; iPt <= cPts; iPt++)
                    {
                        aptfx[iPt].x = (FIX)lCvt(efM11, aptl[iPt].x) +
                                       (FIX)lCvt(efM21, aptl[iPt].y);
                        aptfx[iPt].y = (FIX)lCvt(efM12, aptl[iPt].x) +
                                       (FIX)lCvt(efM22, aptl[iPt].y);

                    // only if an orientation flag is set then we must adjust

                        if( pfc->flags & ORIENT_MASK )
                        {

                            if( aptfx[iPt].y > ptfxBound.y )
                            {
#if DEBUG
                                DbgPrint("y adjust %x %x\n", aptfx[iPt].y, ptfxBound.y );
#endif
                                aptfx[iPt].y = ptfxBound.y;
                            }


                            if( aptfx[iPt].x > ptfxBound.x )
                            {
#if DEBUG
                                DbgPrint("x adjust %x %x\n", aptfx[iPt].x, ptfxBound.x );
#endif
                                aptfx[iPt].x = ptfxBound.x;
                            }
                        }
                    }
                }

                bReturn &= PATHOBJ_bMoveTo(ppo, aptfx[0]);
                bReturn &= PATHOBJ_bPolyLineTo(ppo, &aptfx[1], cPts);
#if DEBUG
                {
                    UINT i;
                    DbgPrint("MoveTo (%lx, %lx)\n", aptfx[0].x, aptfx[0].y);
                    DbgPrint("PolyLineTo cPts = %lx\n",cPts);
                    for (i = 1; i <= cPts; i++)
                    {
                        DbgPrint("   (%lx, %lx)\n",aptfx[i].x, aptfx[i].y);
                    }
                }
#endif
                if (bEmbolden)
                {
                    for (iPt = 0; iPt <= cPts; iPt++)
                    {
                    // offset the whole path in the unit base direction

                        aptfx[iPt].x += pfxBaseOffset.x;
                        aptfx[iPt].y += pfxBaseOffset.y;
                    }

                    bReturn &= PATHOBJ_bMoveTo(ppo, aptfx[0]);
                    bReturn &= PATHOBJ_bPolyLineTo(ppo, &aptfx[1], cPts);
                }

                if ((*pch != PEN_UP) && (pch != pchEnd))
                {
                // We got here because the aptl[] and aptfx[] buffer is
                // not big enough.  Move to the last point in PolyLineTo
                // and start storing the next batch of points.

                    aptl[0].x = lXLast;
                    aptl[0].y = aptl[cPts].y;
                    cPts = 1;
                    continue;
                }

                aptl[cPts].x = lXLast;
            }

            pch++;

            aptl[0].x = (signed char)*pch++ + aptl[cPts].x;
            aptl[0].y = (signed char)*pch++ + aptl[cPts].y;
            cPts = 1;
        }
    }

    return(bReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\vtfd\service.h ===
/******************************Module*Header*******************************\
* Module Name: service.h
*
* routines in service.c
*
* Created: 15-Nov-1990 13:00:56
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#if defined(_AMD64_) || defined(_IA64_)

typedef FLOAT EFLOAT;

#else // i386

typedef struct  _FLOATINTERN
{
    LONG    lMant;
    LONG    lExp;
} FLOATINTERN;

typedef FLOATINTERN  EFLOAT;

#endif

typedef EFLOAT *PEFLOAT;

typedef struct _VECTORFL
{
    EFLOAT x;
    EFLOAT y;
} VECTORFL, *PVECTORFL;


VOID vLTimesVtfl(LONG l, VECTORFL *pvtfl, POINTQF *pptq);

#if defined(_AMD64_) || defined(_IA64_)
#define vEToEF(e, pef)	    ( *pef = e)
#define bIsZero(ef)         ( ef == 0 )
#define bPositive(ef)       ( ef >= 0 )
#define	fxLTimesEf(pef, l)  ( (FIX)(*pef * l) )

#else
VOID    ftoef_c(FLOATL, PEFLOAT);

#define vEToEF(e, pef)      ftoef_c(e, pef)
#define bIsZero(ef)         ((ef.lMant == 0) && (ef.lExp == 0))
#define bPositive(ef)       (ef.lMant >= 0)
FIX  fxLTimesEf(EFLOAT *pef, LONG l);

#endif	// _AMD64_ || _IA64_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\vtfd\fontfile.h ===
/******************************Module*Header*******************************\
* Module Name: fontfile.h
*
* (Brief description)
*
* Created: 25-Oct-1990 09:20:11
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

// allowed values for FONTFILE.iType field:

// ORIGINAL FILE IS AN *.FNT FILE which contains a single
// size of the single font

#define TYPE_FNT          1L

// ORIGINAL FILE IS A win 3.0 16 bit *.DLL (*.fon FILE),
// This file is compiled out of many *.fnt files
// that correspond to different sizes of the same face, (e.g. tmsr or helv)
// This is provided to ensure binary compatibility with win 3.0 *.fon files

#define TYPE_DLL16        2L

// ORIGINAL FILE IS A win 3.0 32 bit *.DLL
// This file is compiled out of many *.fnt files using NT tools
// (coff linker and nt resource compiler)

#define TYPE_DLL32        3L

// an fnt file that is embeded in an exe and loaded using FdLoadResData

#define TYPE_EXE          4L

typedef struct _FACEDATA
{
    RES_ELEM     re;         // -> top of the resource within the file
    ULONG        iDefFace;
    CP_GLYPHSET *pcp;
    IFIMETRICS  *pifi;
}FACEDATA, *PFACEDATA;

// file is gone

#define FF_EXCEPTION_IN_PAGE_ERROR 1


typedef struct _FONTFILE    // ff
{
    ULONG       iType;      // original file is *.fnt, 16 bit dll or 32 bit dll
    ULONG_PTR   iFile;      // file handle for EngMapFontFile,EngUnmapFontFile
    PVOID       pvView;     // pointer to the base of the mapped view
    ULONG       cjView;     // size of the mapped view
    FLONG       fl;         // general flags
    ULONG       cRef;       // # no of times this font file is selected
                            // into a font context
    ULONG       cFace;      // # of resources in the file
    FACEDATA    afd[1];     // cFace of them followed by cFace IFIMETRICS

} FONTFILE, *PFONTFILE;


#define PFF(hff)   ((FONTFILE*)(hff))

typedef struct _FONTCONTEXT // fc
{
    PFONTFILE   pff;                // the font file selected into this context
    PIFIMETRICS pifi;

    EFLOAT      efM11;              // Transform matrix.
    EFLOAT      efM12;
    EFLOAT      efM21;
    EFLOAT      efM22;

    FIX         fxInkTop;           // Transformed Ascender.
    FIX         fxInkBottom;        // -Transformed Descender.
    EFLOAT      efBase;
    POINTE      pteUnitBase;
    VECTORFL    vtflBase;

    POINTQF     ptqUnitBase;   // pteUnitBase in POINTQF format,
                               // has to be added to all ptqD's if emboldening
    POINTFIX    pfxBaseOffset; // offset strokes this much for emboldened font
    FIX         fxEmbolden;    // length of the above vector
    FIX         fxItalic;      // add to fxD to get fxAB

    EFLOAT      efSide;
    POINTE      pteUnitSide;

    RES_ELEM    *pre;               // -> beginning of the mapped font file
    FLONG       flags;              // simulation and transform flag
    ULONG       dpFirstChar;        // -> control points of the first char

}FONTCONTEXT, *PFONTCONTEXT;

#define PFC(hfc)   ((FONTCONTEXT*)(hfc))


// Allowed values for flags

#define FC_SIM_EMBOLDEN     1
#define FC_SIM_ITALICIZE    2
#define FC_SCALE_ONLY       4
#define FC_X_INVERT         8
#define FC_ORIENT_1         16
#define FC_ORIENT_2         32
#define FC_ORIENT_3         64
#define FC_ORIENT_4         128
#define FC_ORIENT_5         256
#define FC_ORIENT_6         512
#define FC_ORIENT_7         1024
#define FC_ORIENT_8         2048


#define ORIENT_MASK (FC_ORIENT_1|FC_ORIENT_2|FC_ORIENT_3|FC_ORIENT_4| \
                     FC_ORIENT_5|FC_ORIENT_6|FC_ORIENT_7|FC_ORIENT_8)


// Font file/context allocation/free macros.

#define pffAlloc(cj) ((PFONTFILE)EngAllocMem(0, cj, 'dftV'))
#define pfcAlloc()   ((PFONTCONTEXT)EngAllocMem(0, sizeof(FONTCONTEXT), 'dftV'))
#define vFree(pv)    EngFreeMem((PVOID) pv)

BOOL bXformUnitVector
(
POINTL       *pptl,           // IN,  incoming unit vector
XFORML       *pxf,            // IN,  xform to use
PVECTORFL     pvtflXformed,   // OUT, xform of the incoming unit vector
POINTE       *ppteUnit,       // OUT, *pptqXormed/|*pptqXormed|, POINTE
POINTQF      *pptqUnit,       // out optional
EFLOAT       *pefNorm         // OUT, |*pptqXormed|
);

// default face in the font.

#define FF_FACE_NORMAL          0L
#define FF_FACE_BOLD            1L
#define FF_FACE_ITALIC          2L
#define FF_FACE_BOLDITALIC      3L


extern FD_GLYPHSET *gpgsetVTFD;


#define PEN_UP          (CHAR)0x80
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\vtfd\fontfile.c ===
/******************************Module*Header*******************************\
* Module Name: fontfile.c                                                  *
*                                                                          *
* Contains exported font driver entry points and memory allocation/locking *
* methods from engine's handle manager.  Adapted from BodinD's bitmap font *
* driver.                                                                  *
*                                                                          *
* Copyright (c) 1993-1995 Microsoft Corporation                                 *
\**************************************************************************/

#include "fd.h"

HSEMAPHORE ghsemVTFD;


VOID vVtfdMarkFontGone(FONTFILE *pff, DWORD iExceptionCode)
{

    ASSERTDD(pff, "vVtfdMarkFontGone, pff\n");

// this font has disappeared, probably net failure or somebody pulled the
// floppy with vt file out of the floppy drive

    if (iExceptionCode == STATUS_IN_PAGE_ERROR) // file disappeared
    {
    // prevent any further queries about this font:

        pff->fl |= FF_EXCEPTION_IN_PAGE_ERROR;

        if ((pff->iType == TYPE_FNT) || (pff->iType == TYPE_DLL16))
        {
            EngUnmapFontFileFD(pff->iFile);
        }
    }

    if (iExceptionCode == STATUS_ACCESS_VIOLATION)
    {
        RIP("VTFD!this is probably a buggy vector font file\n");
    }
}

BOOL bvtfdMapFontFileFD(PFONTFILE pff)
{
    return (pff ? (EngMapFontFileFD(pff->iFile, (PULONG*)&pff->pvView, &pff->cjView))
                : FALSE);
}

/******************************Public*Routine******************************\
*
*  vtfdQueryFontDataTE, try except wrapper
*
* Effects:
*
* Warnings:
*
* History:
*  04-Apr-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG vtfdQueryFontDataTE (
    DHPDEV  dhpdev,
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH  hg,
    GLYPHDATA *pgd,
    PVOID   pv,
    ULONG   cjSize
    )
{
    LONG lRet = FD_ERROR;

    if (bvtfdMapFontFileFD((PFONTFILE)pfo->iFile))
    {
        EngAcquireSemaphore(ghsemVTFD);
    
        try
        {
            lRet = vtfdQueryFontData (
                       pfo,
                       iMode,
                       hg,
                       pgd,
                       pv,
                       cjSize
                       );
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("exception in vtfdQueryFontDataTE \n");
            vVtfdMarkFontGone((FONTFILE *)pfo->iFile, GetExceptionCode());
        }
    
        EngReleaseSemaphore(ghsemVTFD);

        EngUnmapFontFileFD(PFF(pfo->iFile)->iFile);
    }

    return lRet;
}

/******************************Public*Routine******************************\
*
* HFF vtfdLoadFontFileTE, try except wrapper
*
*
* History:
*  05-Apr-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



HFF vtfdLoadFontFileTE(
    ULONG cFiles,
    ULONG_PTR *piFile,
    PVOID *ppvView,
    ULONG *pcjView,
    DESIGNVECTOR *pdv,
    ULONG ulLangId,
    ULONG ulFastCheckSum
    )
{
    HFF  hff = (HFF)NULL;
    ULONG_PTR iFile;
    PVOID pvView;
    ULONG cjView;

    if ((cFiles != 1) || pdv)
        return hff;

    iFile  = *piFile;
    pvView = *ppvView;
    cjView = *pcjView;

    EngAcquireSemaphore(ghsemVTFD);

    try
    {

        BOOL bRet = vtfdLoadFontFile(iFile, pvView, cjView, &hff);

        if (!bRet)
        {
            ASSERTDD(hff == (HFF)NULL, "vtfdLoadFontFile, hff != NULL\n");
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("exception in vtfdLoadFontFile \n");

        ASSERTDD(GetExceptionCode() == STATUS_IN_PAGE_ERROR,
                "vtfdLoadFontFile, strange exception code\n");

    // if the file disappeared after mem was allocated, free the mem

        if (hff)
        {
            vFree(hff);
            hff = (HFF) NULL;
        }
    }

    EngReleaseSemaphore(ghsemVTFD);
    
    return hff;
}

/******************************Public*Routine******************************\
*
* BOOL vtfdUnloadFontFileTE , try/except wrapper
*
*
* History:
*  05-Apr-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL vtfdUnloadFontFileTE (HFF hff)
{
    BOOL bRet;

    EngAcquireSemaphore(ghsemVTFD);

    try
    {
        bRet = vtfdUnloadFontFile(hff);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("exception in vtfdUnloadFontFile\n");
        bRet = FALSE;
    }
    
    EngReleaseSemaphore(ghsemVTFD);

    return bRet;
}

/******************************Public*Routine******************************\
*
* LONG vtfdQueryFontFileTE, try/except wrapper
*
* History:
*  05-Apr-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


LONG vtfdQueryFontFileTE (
    HFF     hff,        // handle to font file
    ULONG   ulMode,     // type of query
    ULONG   cjBuf,      // size of buffer (in BYTEs)
    PULONG  pulBuf      // return buffer (NULL if requesting size of data)
    )
{
    LONG lRet = FD_ERROR;
    
    if ((ulMode != QFF_DESCRIPTION) ||
        bvtfdMapFontFileFD(PFF(hff)))
    {
        EngAcquireSemaphore(ghsemVTFD);
    
        try
        {
            lRet = vtfdQueryFontFile (hff,ulMode, cjBuf,pulBuf);
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("exception in  vtfdQueryFontFile\n");
            vVtfdMarkFontGone((FONTFILE *)hff, GetExceptionCode());
        }
    
        EngReleaseSemaphore(ghsemVTFD);

        if (ulMode == QFF_DESCRIPTION)
        {
            EngUnmapFontFileFD(PFF(hff)->iFile);            
        }
    }

    return lRet;
}


/******************************Public*Routine******************************\
*
* BOOL vtfdQueryAdvanceWidthsTE, try/except wrapper
*
* History:
*  05-Apr-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL vtfdQueryAdvanceWidthsTE
(
    DHPDEV   dhpdev,
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    LONG    *plWidths,
    ULONG    cGlyphs
)
{
    BOOL     bRet = FD_ERROR;

    if ((iMode <= QAW_GETEASYWIDTHS) &&
        bvtfdMapFontFileFD((PFONTFILE)pfo->iFile))
    {
        EngAcquireSemaphore(ghsemVTFD);
    
        try
        {
            bRet = vtfdQueryAdvanceWidths (pfo,iMode, phg, plWidths, cGlyphs);
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("exception in vtfdQueryAdvanceWidths \n");
            vVtfdMarkFontGone((FONTFILE *)pfo->iFile, GetExceptionCode());
        }
    
        EngReleaseSemaphore(ghsemVTFD);
    
        EngUnmapFontFileFD(PFF(pfo->iFile)->iFile);        
    }
    return bRet;
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI
*
\**************************************************************************/

DHPDEV
vtfdEnablePDEV(
    DEVMODEW*   pdm,
    PWSTR       pwszLogAddr,
    ULONG       cPat,
    HSURF*      phsurfPatterns,
    ULONG       cjCaps,
    ULONG*      pdevcaps,
    ULONG       cjDevInfo,
    DEVINFO*    pdi,
    HDEV        hdev,
    PWSTR       pwszDeviceName,
    HANDLE      hDriver)
{

    PVOID*   ppdev;

    //
    // Allocate a four byte PDEV for now
    // We can grow it if we ever need to put information in it.
    //

    ppdev = (PVOID*) EngAllocMem(0, sizeof(PVOID), 'dftV');

    return ((DHPDEV) ppdev);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
\**************************************************************************/

VOID
vtfdDisablePDEV(
    DHPDEV  dhpdev)
{
    EngFreeMem(dhpdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID
vtfdCompletePDEV(
    DHPDEV dhpdev,
    HDEV   hdev)
{
    return;
}






// The driver function table with all function index/address pairs

DRVFN gadrvfnVTFD[] =
{
    {   INDEX_DrvEnablePDEV,            (PFN) vtfdEnablePDEV,          },
    {   INDEX_DrvDisablePDEV,           (PFN) vtfdDisablePDEV,         },
    {   INDEX_DrvCompletePDEV,          (PFN) vtfdCompletePDEV,        },
    {   INDEX_DrvQueryFont,             (PFN) vtfdQueryFont,           },
    {   INDEX_DrvQueryFontTree,         (PFN) vtfdQueryFontTree,       },
    {   INDEX_DrvQueryFontData,         (PFN) vtfdQueryFontDataTE,     },
    {   INDEX_DrvDestroyFont,           (PFN) vtfdDestroyFont,         },
    {   INDEX_DrvQueryFontCaps,         (PFN) vtfdQueryFontCaps,       },
    {   INDEX_DrvLoadFontFile,          (PFN) vtfdLoadFontFileTE,      },
    {   INDEX_DrvUnloadFontFile,        (PFN) vtfdUnloadFontFileTE,    },
    {   INDEX_DrvQueryFontFile,         (PFN) vtfdQueryFontFileTE,     },
    {   INDEX_DrvQueryAdvanceWidths ,   (PFN) vtfdQueryAdvanceWidthsTE }
};

/******************************Public*Routine******************************\
* vtfdEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
*  Sun 25-Apr-1993 -by- Patrick Haluptzok [patrickh]
* Change to be same as DDI Enable.
*
* History:
*  12-Dec-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL vtfdEnableDriver(
ULONG iEngineVersion,
ULONG cj,
PDRVENABLEDATA pded)
{
// Engine Version is passed down so future drivers can support previous
// engine versions.  A next generation driver can support both the old
// and new engine conventions if told what version of engine it is
// working with.  For the first version the driver does nothing with it.

    iEngineVersion;

    if ((ghsemVTFD = EngCreateSemaphore()) == (HSEMAPHORE) 0)
    {
        return(FALSE);
    }

    pded->pdrvfn = gadrvfnVTFD;
    pded->c = sizeof(gadrvfnVTFD) / sizeof(DRVFN);
    pded->iDriverVersion = DDI_DRIVER_VERSION_NT5;
    return(TRUE);
}


#if DBG

VOID
VtfdDebugPrint(
    PCHAR DebugMessage,
    ...
    )
{

    va_list ap;

    va_start(ap, DebugMessage);

    EngDebugPrint("VTFD: ", DebugMessage, ap);

    va_end(ap);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gdiext\gdiext.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name

   gdiext.h

Abstract:

    GDI exensions for transparent blt, blending, gradient fill

Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/


typedef LONG  PTFX8;
typedef USHORT COLOR16;

typedef struct _VERTEX
{
    PTFX8   x;
    PTFX8   y;
    COLOR16 Red;
    COLOR16 Green;
    COLOR16 Blue;
    COLOR16 Alpha;
}VERTEX,*PVERTEX;

BOOL
GdxTransparentBlt(
    HDC      hdcDest,
    LONG     DstX,
    LONG     DstY,
    LONG     DstCx,
    LONG     DstCy,
    HANDLE   hSrc,
    LONG     SrcX,
    LONG     SrcY,
    LONG     SrcCx,
    LONG     SrcCy,
    COLORREF TranColor
    );


BOOL
GdxAlphaBlt(
    HDC      hdcDest,
    LONG     DstX,
    LONG     DstY,
    LONG     DstCx,
    LONG     DstCy,
    HANDLE   hSrc,
    LONG     SrcX,
    LONG     SrcY,
    LONG     SrcCx,
    LONG     SrcCy,
    ULONG    fAlpha
    );


BOOL
TriangleMesh(
    HDC       hdc,
    PVERTEX   pVertex,
    ULONG     nVertex,
    PULONG    pMesh,
    ULONG     nCount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gdiext\dllinit.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name

   dllinit.cxx

Abstract:



Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

PGDI_SHARED_MEMORY pGdiSharedMemory = NULL;
PENTRY             pGdiSharedHandleTable = NULL;
PDEVCAPS           pGdiDevCaps = NULL;
W32PID             gW32PID;
INT                gbCheckHandleLevel = 0;

/*++

Routine Description:



Arguments



Return Value



--*/


BOOLEAN
GdxDllInitialize(
    PVOID pvDllHandle,
    ULONG ulReason,
    PCONTEXT pcontext)
{
    NTSTATUS status = 0;
    INT i;
    BOOLEAN  fServer;
    PTEB pteb = NtCurrentTeb();
    BOOL bRet = TRUE;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
        break;

   case DLL_PROCESS_DETACH:
   case DLL_THREAD_DETACH:
        break;

    }

    return(bRet);

    pvDllHandle;
    pcontext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gdiext\tran.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name

   dllinit.cxx

Abstract:



Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

extern "C" {
BOOL
NtGdiTransparentBlt(
    HDC     hdcDst,
    LONG    DstX,
    LONG    DstY,
    LONG    DstCx,
    LONG    DstCy,
    HDC     hdcSrc,
    LONG    SrcX,
    LONG    SrcY,
    LONG    SrcCx,
    LONG    SrcCy,
    COLORREF TranColor
    );
}

BOOL
GdxTransparentBlt(
    HDC      hdcDest,
    LONG     DstX,
    LONG     DstY,
    LONG     DstCx,
    LONG     DstCy,
    HANDLE   hSrc,
    LONG     SrcX,
    LONG     SrcY,
    LONG     SrcCx,
    LONG     SrcCy,
    COLORREF TranColor
    )
{
    BOOL bRet = FALSE;
    PDC_ATTR pdca;

    FIXUP_HANDLE(hdcDest);
    FIXUP_HANDLE(hSrc);

    //
    // metafile
    //


    //
    // emultation
    //

    //
    // Direct Drawing
    //

    #if 1

        bRet = NtGdiTransparentBlt(hdcDest,
                      DstX,
                      DstY,
                      DstCx,
                      DstCy,
                      (HDC)hSrc,
                      SrcX,
                      SrcY,
                      SrcCx,
                      SrcCy,
                      TranColor );
    #endif

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gdiext\trimesh.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name

   trimesh.cxx

Abstract:

    Implement triangle mesh API

Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop

extern "C" {
BOOL
NtGdiTriangleMesh(
    HDC       hdc,
    PVERTEX   pVertex,
    ULONG     nVertex,
    PULONG    pMesh,
    ULONG     nCount
    );
}


BOOL
TriangleMesh(
    HDC       hdc,
    PVERTEX   pVertex,
    ULONG     nVertex,
    PULONG    pMesh,
    ULONG     nCount
    )
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    //
    // metafile
    //


    //
    // emultation
    //

    //
    // Direct Drawing
    //

    #if 1

        bRet = NtGdiTriangleMesh(hdc,
                                 pVertex,
                                 nVertex,
                                 pMesh,
                                 nCount);
    #endif

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gdiext\alpha.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name

   alpha.cxx

Abstract:

   alpha blending functions

Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

extern "C" {
BOOL
NtGdiAlphaBlt(
      HDC,
      LONG,
      LONG,
      LONG,
      LONG,
      HDC,
      LONG,
      LONG,
      LONG,
      LONG,
      ULONG);
}

BOOL
GdxAlphaBlt(
    HDC      hdcDest,
    LONG     DstX,
    LONG     DstY,
    LONG     DstCx,
    LONG     DstCy,
    HANDLE   hSrc,
    LONG     SrcX,
    LONG     SrcY,
    LONG     SrcCx,
    LONG     SrcCy,
    ULONG    fAlpha
    )
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdcDest);
    FIXUP_HANDLE(hSrc);

    //
    // metafile
    //

    //
    // emultation
    //

    //
    // Direct Drawing
    //

    #if 1

        bRet = NtGdiAlphaBlt(
                      hdcDest,
                      DstX,
                      DstY,
                      DstCx,
                      DstCy,
                      (HDC)hSrc,
                      SrcX,
                      SrcY,
                      SrcCx,
                      SrcCy,
                      fAlpha );
    #endif

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gdiext\gdxlocal.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name

   gdxlocal.h

Abstract:



Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/




extern PGDI_SHARED_MEMORY pGdiSharedMemory;
extern PDEVCAPS           pGdiDevCaps;
extern PENTRY             pGdiSharedHandleTable;
extern W32PID             gW32PID;





#define HANDLE_TO_INDEX(h) (ULONG)h & 0x0000ffff
HANDLE GdiFixUpHandle(HANDLE h);

/******************************Public*Macro********************************\
*
*  PSHARED_GET_VALIDATE
*
*  Validate all handle information, return user pointer if the handle
*  is valid or NULL otherwise.
*
* Arguments:
*
*   p       - pointer to assign to pUser is successful
*   h       - handle to object
*   iType   - handle type
*
\**************************************************************************/

#define PSHARED_GET_VALIDATE(p,h,iType)                                 \
{                                                                       \
    UINT uiIndex = HANDLE_TO_INDEX(h);                                  \
    p = NULL;                                                           \
                                                                        \
    if (uiIndex < MAX_HANDLE_COUNT)                                     \
    {                                                                   \
        PENTRY pentry = &pGdiSharedHandleTable[uiIndex];                \
                                                                        \
        if (                                                            \
             (pentry->Objt == iType) &&                                 \
             (pentry->FullUnique == ((ULONG)h >> 16)) &&                \
             (pentry->ObjectOwner.Share.Pid == gW32PID)                 \
           )                                                            \
        {                                                               \
            p = pentry->pUser;                                          \
        }                                                               \
    }                                                                   \
}


#define VALIDATE_HANDLE(bRet, h,iType)                                  \
{                                                                       \
    UINT uiIndex = HANDLE_TO_INDEX(h);                                  \
    bRet = FALSE;                                                       \
                                                                        \
    if (uiIndex < MAX_HANDLE_COUNT)                                     \
    {                                                                   \
        PENTRY pentry = &pGdiSharedHandleTable[uiIndex];                \
                                                                        \
        if (                                                            \
             (pentry->Objt == iType) &&                                 \
             (pentry->FullUnique == ((ULONG)h >> 16)) &&                \
             ((pentry->ObjectOwner.Share.Pid == gW32PID) ||             \
             (pentry->ObjectOwner.Share.Pid == 0))                      \
              )                                                         \
        {                                                               \
           bRet = TRUE;                                                 \
        }                                                               \
    }                                                                   \
}

/******************************Public*Macros******************************\
* FIXUP_HANDLE(h) and FIXUP_HANDLEZ(h)
*
* check to see if the handle has been truncated.
* FIXUP_HANDLEZ() adds an extra check to allow NULL.
*
* Arguments:
*   h - handle to be checked and fix
*
* Return Value:
*
* History:
*
*    25-Jan-1996 -by- Lingyun Wang [lingyunw]
*
\**************************************************************************/



#define HANDLE_FIXUP 0

#if DBG
extern INT gbCheckHandleLevel;
#endif

#define NEEDS_FIXING(h)    (!((ULONG)h & 0xffff0000))

#if DBG
#define HANDLE_WARNING()                                                 \
{                                                                        \
        if (gbCheckHandleLevel == 1)                                     \
        {                                                                \
            WARNING ("truncated handle\n");                              \
        }                                                                \
        ASSERTGDI (gbCheckHandleLevel != 2, "truncated handle\n");       \
}
#else
#define HANDLE_WARNING()
#endif

#if DBG
#define CHECK_HANDLE_WARNING(h, bZ)                                      \
{                                                                        \
    BOOL bFIX = NEEDS_FIXING(h);                                         \
                                                                         \
    if (bZ) bFIX = h && bFIX;                                            \
                                                                         \
    if (bFIX)                                                            \
    {                                                                    \
        if (gbCheckHandleLevel == 1)                                     \
        {                                                                \
            WARNING ("truncated handle\n");                              \
        }                                                                \
        ASSERTGDI (gbCheckHandleLevel != 2, "truncated handle\n");       \
    }                                                                    \
}
#else
#define CHECK_HANDLE_WARNING(h,bZ)
#endif


#if HANDLE_FIXUP
#define FIXUP_HANDLE(h)                                 \
{                                                       \
    if (NEEDS_FIXING(h))                                \
    {                                                   \
        HANDLE_WARNING();                               \
        h = GdiFixUpHandle(h);                          \
    }                                                   \
}
#else
#define FIXUP_HANDLE(h)                                 \
{                                                       \
    CHECK_HANDLE_WARNING(h,FALSE);                      \
}
#endif

#if HANDLE_FIXUP
#define FIXUP_HANDLEZ(h)                                \
{                                                       \
    if (h && NEEDS_FIXING(h))                           \
    {                                                   \
        HANDLE_WARNING();                               \
        h = GdiFixUpHandle(h);                          \
    }                                                   \
}
#else
#define FIXUP_HANDLEZ(h)                                \
{                                                       \
    CHECK_HANDLE_WARNING(h,TRUE);                       \
}
#endif

#define FIXUP_HANDLE_NOW(h)                             \
{                                                       \
    if (NEEDS_FIXING(h))                                \
    {                                                   \
        HANDLE_WARNING();                               \
        h = GdiFixUpHandle(h);                          \
    }                                                   \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\aatext.cxx ===
/******************************Module*Header*******************************\
* Module Name: aatext.cxx                                                  *
*                                                                          *
* Routines for rendering anti aliased text to dib surfaces                 *
*                                                                          *
* Created: 13-Mar-1995 10:44:05                                            *
* Author: Kirk Olynyk [kirko]                                              *
*                                                                          *
* Copyright (c) 1995-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.hxx"

// Function prototypes

typedef VOID (FNCOPYALPHABUFFER)(PBYTE, PBYTE, PBYTE, LONG, PUSHORT *);
typedef VOID (FNSRCTRANCOPY)(PBYTE, LONG, LONG, PBYTE, LONG, LONG, LONG, LONG, 
                              ULONG, ULONG, SURFACE*, FNCOPYALPHABUFFER*);
extern HSEMAPHORE ghsemEUDC2;

extern "C" {
    VOID vSrcTranCopyS4D16(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
    VOID vSrcTranCopyS4D24(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
    VOID vSrcTranCopyS4D32(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
    VOID vSrcOpaqCopyS4D32(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
    VOID vSrcOpaqCopyS4D16(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
    VOID vSrcOpaqCopyS4D24(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);

    VOID vSrcOpaqCopyS8D16(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
    VOID vSrcOpaqCopyS8D24(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
    VOID vSrcOpaqCopyS8D32(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);

    VOID vSrcTranCopyS8D16(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
    VOID vSrcTranCopyS8D24(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
    VOID vSrcTranCopyS8D32(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);

}

// blend macros for cleartype

#define DIVIDE(A,B) ( ((A)+(B)/2) / (B) )

// blend macros for cleartype
// this is k/6, k = 0,1,...,6 in 12.20 format
// Why 12.20 ? well, we are tring to store 6*256 = 1536 = 600h.
// (the largest possible result of multiplying k*dB),
// this fits in eleven bits, so just to be safe we allow 12 bits for
// integer part and 20 bits for the fractional part.
// By using this we avoid doing divides by 6 in trasparent cases and
// in computation of ct lookup table



LONG alAlpha[7] =
{
0,
DIVIDE(1L << 20, 6),
DIVIDE(2L << 20, 6),
DIVIDE(3L << 20, 6),
DIVIDE(4L << 20, 6),
DIVIDE(5L << 20, 6),
DIVIDE(6L << 20, 6),
};



#define HALF20 (1L << 19)
#define ROUND20(X) (((X) + HALF20) >> 20)
//#define ROUND20(X) ((X) >> 20)
#define BLEND(k,B,dB) ((B) + ROUND20(alAlpha[k] * (dB)))
#define BLENDCT(k,F,B,dB) (ULONG)(BLEND(k,B,dB))

// my test program has determined that regardless of whether we do
// proper rounding in ROUND20 or not, we never arrive at a color that is
// diffent by more than 1 from the value computed the old way
// that is using the old formula:
//
// #define BLEND(k,F,B) (ULONG)DIVIDE((k) * (F) + (6 - (k)) * (B), 6)
//
// the only difference is that if we do rounding, we are wrong in only 2%
// of the cases, and if we do not do rounding we are wrong in 38% of the cases.
// But in either case error is very small.
// Because this is done on a per pixel basis in transparent case, we opt for speed
// and do not do rounding. This saves us 3 additions per pixel.


// John Platt has determined that there are 115 distinct filtered states
// when one starts with (2+2+2)x X 1y scaling for cleartype

#define CT_LOOKUP 115

// filtered counts of RGB

typedef struct _F_RGB
{
    BYTE kR;
    BYTE kG;
    BYTE kB;
    BYTE kPadding;
} F_RGB;

// the max number of foreground virt pixels in a subpixel,  2x X 1y , no filtering

#define CT_SAMPLE_NF  2

// the number of distinct nonfiltered states in a whole pixel = 3 x 3 x 3 = 27
// The indices coming from the rasterizer are in [0,26] range

#define CT_MAX_NF ((CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1))

// the max number of foreground virt pixels in a subpixel AFTER filtering, 6

#define CT_SAMPLE_F   6


// size of the storage table, basically 3^5 = 243.
// The table does filtering and index computation (vector quantization) in one step.


#define CT_STORAGE ((CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1))

// The codebook: 115 entries stored as sequential triples of unsigned char
static const F_RGB gaOutTableRGB[CT_LOOKUP] = {
0,0,0,0,
0,0,1,0,
0,0,2,0,
0,1,1,0,
0,1,2,0,
0,1,3,0,
0,2,2,0,
0,2,3,0,
0,2,4,0,
1,0,0,0,
1,0,1,0,
1,0,2,0,
1,1,0,0,
1,1,1,0,
1,1,2,0,
1,1,3,0,
1,2,1,0,
1,2,2,0,
1,2,3,0,
1,2,4,0,
1,3,2,0,
1,3,3,0,
1,3,4,0,
1,3,5,0,
2,0,0,0,
2,0,1,0,
2,0,2,0,
2,1,0,0,
2,1,1,0,
2,1,2,0,
2,1,3,0,
2,2,0,0,
2,2,1,0,
2,2,2,0,
2,2,3,0,
2,2,4,0,
2,3,1,0,
2,3,2,0,
2,3,3,0,
2,3,4,0,
2,3,5,0,
2,4,2,0,
2,4,3,0,
2,4,4,0,
2,4,5,0,
2,4,6,0,
3,1,0,0,
3,1,1,0,
3,1,2,0,
3,1,3,0,
3,2,0,0,
3,2,1,0,
3,2,2,0,
3,2,3,0,
3,2,4,0,
3,3,1,0,
3,3,2,0,
3,3,3,0,
3,3,4,0,
3,3,5,0,
3,4,2,0,
3,4,3,0,
3,4,4,0,
3,4,5,0,
3,4,6,0,
3,5,3,0,
3,5,4,0,
3,5,5,0,
3,5,6,0,
4,2,0,0,
4,2,1,0,
4,2,2,0,
4,2,3,0,
4,2,4,0,
4,3,1,0,
4,3,2,0,
4,3,3,0,
4,3,4,0,
4,3,5,0,
4,4,2,0,
4,4,3,0,
4,4,4,0,
4,4,5,0,
4,4,6,0,
4,5,3,0,
4,5,4,0,
4,5,5,0,
4,5,6,0,
4,6,4,0,
4,6,5,0,
4,6,6,0,
5,3,1,0,
5,3,2,0,
5,3,3,0,
5,3,4,0,
5,4,2,0,
5,4,3,0,
5,4,4,0,
5,4,5,0,
5,5,3,0,
5,5,4,0,
5,5,5,0,
5,5,6,0,
5,6,4,0,
5,6,5,0,
5,6,6,0,
6,4,2,0,
6,4,3,0,
6,4,4,0,
6,5,3,0,
6,5,4,0,
6,5,5,0,
6,6,4,0,
6,6,5,0,
6,6,6,0
};

static const F_RGB gaOutTableBGR[CT_LOOKUP] = {
0,0,0,0,
1,0,0,0,
2,0,0,0,
1,1,0,0,
2,1,0,0,
3,1,0,0,
2,2,0,0,
3,2,0,0,
4,2,0,0,
0,0,1,0,
1,0,1,0,
2,0,1,0,
0,1,1,0,
1,1,1,0,
2,1,1,0,
3,1,1,0,
1,2,1,0,
2,2,1,0,
3,2,1,0,
4,2,1,0,
2,3,1,0,
3,3,1,0,
4,3,1,0,
5,3,1,0,
0,0,2,0,
1,0,2,0,
2,0,2,0,
0,1,2,0,
1,1,2,0,
2,1,2,0,
3,1,2,0,
0,2,2,0,
1,2,2,0,
2,2,2,0,
3,2,2,0,
4,2,2,0,
1,3,2,0,
2,3,2,0,
3,3,2,0,
4,3,2,0,
5,3,2,0,
2,4,2,0,
3,4,2,0,
4,4,2,0,
5,4,2,0,
6,4,2,0,
0,1,3,0,
1,1,3,0,
2,1,3,0,
3,1,3,0,
0,2,3,0,
1,2,3,0,
2,2,3,0,
3,2,3,0,
4,2,3,0,
1,3,3,0,
2,3,3,0,
3,3,3,0,
4,3,3,0,
5,3,3,0,
2,4,3,0,
3,4,3,0,
4,4,3,0,
5,4,3,0,
6,4,3,0,
3,5,3,0,
4,5,3,0,
5,5,3,0,
6,5,3,0,
0,2,4,0,
1,2,4,0,
2,2,4,0,
3,2,4,0,
4,2,4,0,
1,3,4,0,
2,3,4,0,
3,3,4,0,
4,3,4,0,
5,3,4,0,
2,4,4,0,
3,4,4,0,
4,4,4,0,
5,4,4,0,
6,4,4,0,
3,5,4,0,
4,5,4,0,
5,5,4,0,
6,5,4,0,
4,6,4,0,
5,6,4,0,
6,6,4,0,
1,3,5,0,
2,3,5,0,
3,3,5,0,
4,3,5,0,
2,4,5,0,
3,4,5,0,
4,4,5,0,
5,4,5,0,
3,5,5,0,
4,5,5,0,
5,5,5,0,
6,5,5,0,
4,6,5,0,
5,6,5,0,
6,6,5,0,
2,4,6,0,
3,4,6,0,
4,4,6,0,
3,5,6,0,
4,5,6,0,
5,5,6,0,
4,6,6,0,
5,6,6,0,
6,6,6,0
};


// The encoding lookup table. There are 3^5 possible entries corresponding to
// 5 emmiters: BP, RT, GT, BT, RN

BYTE gajStorageTable[CT_STORAGE] = {
  0,  1,  2,  3,  4,  5,  6,  7,  8,
 13, 14, 15, 17, 18, 19, 21, 22, 23,
 33, 34, 35, 38, 39, 40, 43, 44, 45,
 12, 13, 14, 16, 17, 18, 20, 21, 22,
 32, 33, 34, 37, 38, 39, 42, 43, 44,
 56, 57, 58, 61, 62, 63, 66, 67, 68,
 31, 32, 33, 36, 37, 38, 41, 42, 43,
 55, 56, 57, 60, 61, 62, 65, 66, 67,
 79, 80, 81, 84, 85, 86, 88, 89, 90,
  9, 10, 11, 13, 14, 15, 17, 18, 19,
 28, 29, 30, 33, 34, 35, 38, 39, 40,
 52, 53, 54, 57, 58, 59, 62, 63, 64,
 27, 28, 29, 32, 33, 34, 37, 38, 39,
 51, 52, 53, 56, 57, 58, 61, 62, 63,
 75, 76, 77, 80, 81, 82, 85, 86, 87,
 50, 51, 52, 55, 56, 57, 60, 61, 62,
 74, 75, 76, 79, 80, 81, 84, 85, 86,
 95, 96, 97, 99,100,101,103,104,105,
 24, 25, 26, 28, 29, 30, 33, 34, 35,
 47, 48, 49, 52, 53, 54, 57, 58, 59,
 71, 72, 73, 76, 77, 78, 81, 82, 83,
 46, 47, 48, 51, 52, 53, 56, 57, 58,
 70, 71, 72, 75, 76, 77, 80, 81, 82,
 92, 93, 94, 96, 97, 98,100,101,102,
 69, 70, 71, 74, 75, 76, 79, 80, 81,
 91, 92, 93, 95, 96, 97, 99,100,101,
106,107,108,109,110,111,112,113,114
};

BYTE gajStorageTableBloated[CT_STORAGE] = {
  0,  2,  5,  6,  8,  8, 22, 23, 23,
 33, 35, 40, 43, 45, 45, 44, 45, 45,
 61, 63, 63, 66, 68, 68, 67, 68, 68,
 31, 33, 38, 41, 43, 43, 66, 67, 67,
 79, 81, 86, 88, 90, 90, 89, 90, 90,
 84, 86, 86, 88, 90, 90, 89, 90, 90,
 74, 76, 81, 84, 86, 86, 85, 86, 86,
 95, 97,101,103,105,105,104,105,105,
 99,101,101,103,105,105,104,105,105,
 24, 26, 30, 33, 35, 35, 58, 59, 59,
 71, 73, 78, 81, 83, 83, 82, 83, 83,
 96, 98, 98,100,102,102,101,102,102,
 69, 71, 76, 79, 81, 81,100,101,101,
106,108,111,112,114,114,113,114,114,
109,111,111,112,114,114,113,114,114,
 91, 93, 97, 99,101,101,100,101,101,
106,108,111,112,114,114,113,114,114,
109,111,111,112,114,114,113,114,114,
 46, 48, 53, 56, 58, 58, 81, 82, 82,
 92, 94, 98,100,102,102,101,102,102,
 96, 98, 98,100,102,102,101,102,102,
 69, 71, 76, 79, 81, 81,100,101,101,
106,108,111,112,114,114,113,114,114,
109,111,111,112,114,114,113,114,114,
 91, 93, 97, 99,101,101,100,101,101,
106,108,111,112,114,114,113,114,114,
109,111,111,112,114,114,113,114,114
};

static const F_RGB * gaOutTable = gaOutTableRGB;

/* illegal index in gajStorage1[] has been set to the closest legal index,  NT bug #435222 */
BYTE gajStorage1[7*7*7] =
{
0x00,0x01,0x02,0x02,0x05,0x05,0x08,0x00,0x03,0x04,0x05,0x05,0x08,0x08,0x03,0x03,
0x06,0x07,0x08,0x08,0x17,0x10,0x06,0x06,0x07,0x08,0x17,0x17,0x10,0x14,0x14,0x15,
0x16,0x17,0x17,0x14,0x14,0x14,0x15,0x16,0x17,0x2d,0x29,0x29,0x29,0x2a,0x2b,0x2c,
0x2d,0x09,0x0a,0x0b,0x0b,0x0f,0x0f,0x13,0x0c,0x0d,0x0e,0x0f,0x0f,0x13,0x13,0x0c,
0x10,0x11,0x12,0x13,0x13,0x17,0x10,0x10,0x14,0x15,0x16,0x17,0x17,0x24,0x14,0x14,
0x15,0x16,0x17,0x2d,0x24,0x29,0x29,0x2a,0x2b,0x2c,0x2d,0x29,0x29,0x29,0x2a,0x2b,
0x2c,0x2d,0x18,0x19,0x1a,0x1a,0x1e,0x1e,0x23,0x1b,0x1c,0x1d,0x1e,0x1e,0x23,0x23,
0x1f,0x20,0x21,0x22,0x23,0x23,0x28,0x1f,0x24,0x25,0x26,0x27,0x28,0x28,0x24,0x24,
0x29,0x2a,0x2b,0x2c,0x2d,0x24,0x29,0x29,0x2a,0x2b,0x2c,0x2d,0x29,0x29,0x41,0x41,
0x42,0x43,0x44,0x18,0x19,0x1a,0x31,0x31,0x31,0x36,0x2e,0x2f,0x30,0x31,0x31,0x36,
0x36,0x32,0x33,0x34,0x35,0x36,0x36,0x3b,0x32,0x37,0x38,0x39,0x3a,0x3b,0x3b,0x37,
0x37,0x3c,0x3d,0x3e,0x3f,0x40,0x37,0x3c,0x3c,0x41,0x42,0x43,0x44,0x3c,0x3c,0x41,
0x41,0x42,0x43,0x44,0x2e,0x2f,0x30,0x31,0x31,0x49,0x49,0x2e,0x2f,0x30,0x31,0x49,
0x49,0x49,0x45,0x46,0x47,0x48,0x49,0x49,0x4e,0x45,0x4a,0x4b,0x4c,0x4d,0x4e,0x4e,
0x4a,0x4a,0x4f,0x50,0x51,0x52,0x53,0x4a,0x4f,0x4f,0x54,0x55,0x56,0x57,0x4f,0x4f,
0x54,0x54,0x58,0x59,0x5a,0x2e,0x2f,0x30,0x31,0x49,0x49,0x49,0x45,0x46,0x47,0x48,
0x49,0x49,0x49,0x45,0x46,0x47,0x48,0x49,0x49,0x4e,0x5b,0x5b,0x5c,0x5d,0x5e,0x4e,
0x4e,0x5b,0x5b,0x5f,0x60,0x61,0x62,0x53,0x5b,0x5f,0x5f,0x63,0x64,0x65,0x66,0x5f,
0x5f,0x63,0x63,0x67,0x68,0x69,0x45,0x46,0x47,0x48,0x49,0x49,0x49,0x45,0x46,0x47,
0x48,0x49,0x49,0x49,0x5b,0x5b,0x5c,0x5d,0x5e,0x5e,0x4e,0x5b,0x5b,0x5c,0x5d,0x5e,
0x5e,0x62,0x5b,0x6a,0x6a,0x6b,0x6c,0x62,0x62,0x6a,0x6a,0x6a,0x6d,0x6e,0x6f,0x66,
0x6a,0x6a,0x6d,0x6d,0x70,0x71,0x72};

// gamma tables

ULONG gulGamma = DEFAULT_CT_CONTRAST;


// all the info needed to perform blends of fore and background pixels

typedef struct _BLENDINFO
{
    int  iRedL; int  iRedR;  // shift numbers
    int  iGreL; int  iGreR;  // shift numbers
    int  iBluL; int  iBluR;  // shift numbers

    ULONG  flRed;            // mask bits
    ULONG  flGre;            // mask bits
    ULONG  flBlu;            // mask bits

    LONG lRedF;              // foreground components
    LONG lGreF;
    LONG lBluF;

    PBYTE pjGamma;           // pointers to gamma tables
    PBYTE pjGammaInv;

} BLENDINFO;




/********************************************************************
*                                                                   *
*    16.16 fix point numbers representing                           *
*                                                                   *
*        aulB[16] = floor(65536 * (a[k]/16)^(1/gamma) + 1/2)        *
*        aulIB[k] = floor(65536 * (1 - a[k]/16)^(1/gamma) + 1/2)    *
*                                                                   *
*    where               a[k] = k == 0 ? 0 : k+1                    *
*                        gamma = 2.33                               *
********************************************************************/
static const ULONG aulB[16] =
{
    0     , 26846 , 31949 , 36148 , 39781 , 43019 , 45961 , 48672 ,
    51196 , 53564 , 55800 , 57923 , 59948 , 61885 , 63745 , 65536
};

static const ULONG aulIB[16] =
{   0     ,  3650 ,  5587 ,  7612 ,  9735 , 11971 , 14339 , 16863 ,
    19574 , 22516 , 25754 , 29387 , 33586 , 38689 , 45597 , 65536
};

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   pvFillOpaqTable                                                        *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   The case of opaqe text is special because the destiantion pixels       *
*   must be chosen from a set of 16 colors. This routine calculates        *
*   those 16 colors and puts them in an array. This array is addressed     *
*   by the value of the 4-bpp antialiased glyph.                           *
*                                                                          *
*   Let k be the value contained in a 4-bpp antialiased glyph value.       *
*   Thus the allowed range for k is                                        *
*                                                                          *
*                        k = 0,1..15                                       *
*                                                                          *
*   This is interpreted as a blending fraction alpha_k given by            *
*                                                                          *
*                    alpha_k = a_k / 16                                    *
*    where                                                                 *
*                                                                          *
*           a_k = (0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)                 *
*                                                                          *
*    The color values are normalized by the maximum color value            *
*    that a color channel can have, i_max                                  *
*                                                                          *
*    For a single color channel, the normalized foreground and             *
*    background colors are given by                                        *
*                                                                          *
*                      c0 = i0 / i_max ,                                   *
*                                                                          *
*                      c1 = i1 / i_max .                                   *
*                                                                          *
*    The blended and gamma corrected color value is                        *
*                                                                          *
*       c_k = (1 - alpha_k) * c0^gam +  alpha_k * c1^gam)^(1/gam)          *
*                                                                          *
*    The unnormalized blended and gamma corrected color values             *
*    are:                                                                  *
*                                                                          *
*            i_k = floor( i_max * c_k + 1/2)                               *
*                                                                          *
*    wbere 'gam'  is the gamma correction value which I have chosen        *
*    to be equal to 2.33.                                                  *
*                                                                          *
*    In order to speed up the caluclation we cut corners by                *
*    making some approximations. The basic idea is to replace              *
*    the slow process of calculating various powers of real                *
*    numbers by table look up's.                                           *
*                                                                          *
*    The first table G[i] is defined as follows:                           *
*                                                                          *
*        G[i] = floor(g_max * (i/i_max)^gam + 1/2) ,                       *
*                                                                          *
*    where                                                                 *
*                                                                          *
*                    0 <= i <= i_max ,                                     *
*    and                                                                   *
*                    0 <= G[i] <= g_max .                                  *
*                                                                          *
*    The second table is essentially the inverse to G[i], which            *
*    I shall call I[j].                                                    *
*                                                                          *
*        I[j] = floor(i_max * (j / j_max)^(1/gam) + 1/2) ,                 *
*                                                                          *
*                      0 <= j <= j_max .                                   *
*                                                                          *
*                i_max = 31      (255)                                     *
*                g_max = 65536                                             *
*                j_max = 256                                               *
*                                                                          *
*    The complete process of calculating the blended and gamma             *
*    corrected color is given by                                           *
*                                                                          *
*                 g   = 16*G[i0];                                          *
*                 dg  = G[i1] - G[i0];                                     *
*                 c   = 16 * g_max / j_max; // 2^12                        *
*                 for (k = 0; k < 16; k++) {                               *
*                    i[k] = I[ (g + c/2)/c];                               *
*                    g += dg;                                              *
*                 }                                                        *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   cj  ............................... size of each array element in      *
*                                       BYTE's.                            *
*                                                                          *
*   uF  ............................... a 32-bit value whose lowest        *
*                                       16 bits contain the foreground     *
*                                       color                              *
*                                                                          *
*   uB  ............................... a 32-bit value whose lowest 16     *
*                                       bits contain the background        *
*                                       color                              *
*                                                                          *
*   pS  ............................... pointer to destination surface     *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   pointer to color table                                                 *
*                                                                          *
\**************************************************************************/

VOID *pvFillOpaqTable(ULONG size, ULONG uF, ULONG uB, SURFACE *pS)
{
    int  iRedL, iRedR;          // shift numbers
    int  iGreL, iGreR;          // shift numbers
    int  iBluL, iBluR;          // shift numbers
    ULONG uRed, dRed, flRed;
    ULONG uGre, dGre, flGre;
    ULONG uBlu, dBlu, flBlu;
    ULONG ul;

    static ULONG aulCache[16];      // set to zero prior to first call
    static HANDLE hCache;           // set to zero prior to first call
    static ULONG  uFCache;
    static ULONG  uBCache;
    static ULONG  sizeCache;
    static VOID *pv = (VOID*) aulCache;

    // I have been assured of two things....
    // 1) Since this routine is a child of EngTextOut then there
    //    will be only one thread in this routine at any one time.
    //    This means that I do not need to protect the color
    //    table, aulCache[] with a critical section
    // 2) I have been assured that the format of a surface
    //    is unique. Thus if the handle of the surface matches
    //    the handle of the cached color table, then the
    //    formats of the surface are the same.

    if (pS->hGet() == hCache && uB == uBCache && uF == uFCache)
    {
        ASSERTGDI(size == sizeCache, "size != sizeCache");
    }
    else
    {
    sizeCache = size;
    uFCache   = uF;
    uBCache   = uB;
    hCache    = pS->hGet();

#if NEVER
    if (size == sizeof(USHORT))
    {
        ASSERTGDI(uF <= USHRT_MAX, "bad uF");
        ASSERTGDI(uB <= USHRT_MAX, "bad uB");
    }
    else if (size == sizeof(ULONG))
    {
        ASSERTGDI(uF < 0x1000000, "bad uF");
        ASSERTGDI(uB < 0x1000000, "bad uB");
    }
    else
    {
        RIP("bad size");
    }
#endif

    XEPALOBJ xpo;

    if(pS->pPal == NULL)
    {
        PDEVOBJ pdo(pS->hdev());
        xpo.ppalSet(pdo.ppalSurf());
    }
    else
    {
        xpo.ppalSet(pS->pPal);
    }
    
    ASSERTGDI(xpo.bValid(),      "Invalid XEPALOBJ" );


    if (xpo.bIsBitfields())
    {
        flRed = xpo.flRed();
        flGre = xpo.flGre();
        flBlu = xpo.flBlu();

        iRedR = (int) (xpo.cRedRight() + xpo.cRedMiddle() - 8);
        iGreR = (int) (xpo.cGreRight() + xpo.cGreMiddle() - 8);
        iBluR = (int) (xpo.cBluRight() + xpo.cBluMiddle() - 8);
    }
    else
    {
        int cBits;
        ULONG flBits;

        if (size == sizeof(USHORT))
        {
            // assumes standard RGB is 5+5+5 for 16-bit color
            cBits = 5;
            flBits = 0x1f;
        }
        else
        {
            cBits = 8;
            flBits = 0xff;
        }
        if (xpo.bIsRGB())
        {
            flRed = flBits;
            flGre = flRed << cBits;
            flBlu = flGre << cBits;

            iRedR = cBits - 8;
            iGreR = iRedR + cBits;
            iBluR = iGreR + cBits;
        }
        else if (xpo.bIsBGR())
        {
            flBlu = flBits;
            flGre = flBlu << cBits;
            flRed = flGre << cBits;

            iBluR = cBits - 8;
            iGreR = iBluR + cBits;
            iRedR = iGreR + cBits;
        }
        else
        {
            RIP("Palette format not supported\n");
        }
    }

#define GAMMA (ULONG) RFONTOBJ::gTables[0]
/***************************************************************
*                                                              *
*    Now I shall calculate the shift numbers.                  *
*                                                              *
*    I shall explain the shift numbers for the red channel.    *
*    The green and blue channels are treated in the same way.  *
*                                                              *
*    I want to shift the red bits of the red channel colors    *
*    so that the most significant bit of the red channel       *
*    bits corresponds to a value of 2^7. This means that       *
*    if I mask off all of the other color bits, then I         *
*    will end up with a number between zero and 255. This      *
*    process of going to the 0 .. 255 range looks like         *
*                                                              *
*        ((color & flRed) << iRedL) >> iRedR                   *
*                                                              *
*    Only one of iRedL or iRedR is non zero.                   *
*                                                              *
*    I then use this number to index into a 256 element        *
*    gamma correction table. The gamma correction table        *
*    elements are BYTE values that are in the range 0 .. 255.  *
*                                                              *
***************************************************************/
    iRedL = 0;
    if (iRedR < 0)
    {
        iRedL = - iRedR;
        iRedR = 0;
    }
    uRed  = GAMMA[(((uB & flRed) << iRedL) >> iRedR) & 255];
    dRed  = GAMMA[(((uF & flRed) << iRedL) >> iRedR) & 255];
    dRed -= uRed;
    uRed *= 16;

    iGreL = 0;
    if (iGreR < 0)
    {
        iGreL = - iGreR;
        iGreR = 0;
    }
    uGre  = GAMMA[(((uB & flGre) << iGreL) >> iGreR) & 255];
    dGre  = GAMMA[(((uF & flGre) << iGreL) >> iGreR) & 255];
    dGre -= uGre;
    uGre *= 16;

    iBluL = 0;
    if (iBluR < 0)
    {
        iBluL = - iBluR;
        iBluR = 0;
    }
    uBlu  = GAMMA[(((uB & flBlu) << iBluL) >> iBluR) & 255];
    dBlu  = GAMMA[(((uF & flBlu) << iBluL) >> iBluR) & 255];
    dBlu -= uBlu;
    uBlu *= 16;
#undef GAMMA

#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "flRed = %-#x\n"
            "iRedL = %d\n"
            "iRedR = %d\n"
            "uRed  = %-#x\n"
            "dRed  = %-#x\n"
            , flRed, iRedL, iRedR, uRed, dRed
        );
        DbgPrint(
            "flGre = %-#x\n"
            "iGreL = %d\n"
            "iGreR = %d\n"
            "uGre  = %-#x\n"
            "dGre  = %-#x\n"
            , flGre, iGreL, iGreR, uGre, dGre
        );
        DbgPrint(
            "flBlu = %-#x\n"
            "iBluL = %d\n"
            "iBluR = %d\n"
            "uBlu  = %-#x\n"
            "dBlu  = %-#x\n"
            , flBlu, iBluL, iBluR, uBlu, dBlu
        );
    }
#endif

#define IGAMMA (ULONG) RFONTOBJ::gTables[1]

    uRed += dRed;
    uGre += dGre;
    uBlu += dBlu;

    if (size == sizeof(USHORT))
    {
        USHORT *aus = (USHORT*) pv;
        USHORT *pus = aus;

        *pus++  = (USHORT) uB;
#if DBG
        if (gflFontDebug & DEBUG_AA)
        {
            DbgPrint(
                "Table of 16-bit colors ...\n"
                "------------------------------------\n"
                "    %0-#4x %0-#4x %0-#4x = %0-#6x\n"
            ,   (uB & flRed) >> xpo.cRedRight()
            ,   (uB & flGre) >> xpo.cGreRight()
            ,   (uB & flBlu) >> xpo.cBluRight()
            ,   uB
            );
        }
#endif
        while (pus < aus + 15)
        {
    ul  = (((IGAMMA[(uRed += dRed)/16 & 255] << iRedR) >> iRedL) & flRed);
    ul |= (((IGAMMA[(uGre += dGre)/16 & 255] << iGreR) >> iGreL) & flGre);
    ul |= (((IGAMMA[(uBlu += dBlu)/16 & 255] << iBluR) >> iBluL) & flBlu);
            *pus++  = (USHORT) ul;
#if DBG
            if (gflFontDebug & DEBUG_AA)
            {
                DbgPrint(
                    "    %0-#4x %0-#4x %0-#4x = %0-#6x\n"
                ,   IGAMMA[uRed/16 & 255]
                ,   IGAMMA[uGre/16 & 255]
                ,   IGAMMA[uBlu/16 & 255]
                ,   ul
                );
            }
#endif
        }
        *pus = (USHORT) uF;
#if DBG
        if (gflFontDebug & DEBUG_AA)
        {
            DbgPrint(
                "    %0-#4x %0-#4x %0-#4x = %0-#6x\n"
            ,   (uF & flRed) >> xpo.cRedRight()
            ,   (uF & flGre) >> xpo.cGreRight()
            ,   (uF & flBlu) >> xpo.cBluRight()
            ,   uF
            );
        }
#endif
    }
    else
    {
        ASSERTGDI(size == sizeof(ULONG), "bad size");
        ULONG *aul = (ULONG*) pv;
        ULONG *pul = aul;

        *pul++  = uB;
#if DBG
        if (gflFontDebug & DEBUG_AA)
        {
            DbgPrint(
                "Table of 32-bit colors .....\n"
                "------------------------------------\n"
                "    %0-#4x %0-#4x %0-#4x = %0-#8x\n"
            ,   (uB & flRed) >> xpo.cRedRight()
            ,   (uB & flGre) >> xpo.cGreRight()
            ,   (uB & flBlu) >> xpo.cBluRight()
            ,   uB
            );
        }
#endif
        while (pul < aul + 15)
        {
    ul  = (((IGAMMA[(uRed += dRed)/16 & 255] << iRedR) >> iRedL) & flRed);
    ul |= (((IGAMMA[(uGre += dGre)/16 & 255] << iGreR) >> iGreL) & flGre);
    ul |= (((IGAMMA[(uBlu += dBlu)/16 & 255] << iBluR) >> iBluL) & flBlu);
            *pul++  =  ul;
#if DBG
            if (gflFontDebug & DEBUG_AA)
            {
                DbgPrint(
                    "%0-#4x %0-#4x %0-#4x = %0-#8x\n"
                ,   IGAMMA[uRed/16 & 255]
                ,   IGAMMA[uGre/16 & 255]
                ,   IGAMMA[uBlu/16 & 255]
                ,   ul
                );
            }
#endif
        }
        *pul    =  uF;
#if DBG
        if (gflFontDebug & DEBUG_AA)
        {
            DbgPrint(
                "    %0-#4x %0-#4x %0-#4x = %0-#8x\n"
            ,   (uF & flRed) >> xpo.cRedRight()
            ,   (uF & flGre) >> xpo.cGreRight()
            ,   (uF & flBlu) >> xpo.cBluRight()
            ,   uF
            );
        }
#endif
    }
#undef IGAMMA
    }
    return(pv);
}




// Indices into the default palette

#define I_BLACK      0
#define I_DKGRAY   248
#define I_GRAY       7
#define I_WHITE    255

static const BYTE ajWhiteOnBlack[16] = {
    I_BLACK  , I_BLACK  , I_DKGRAY  , I_DKGRAY
  , I_DKGRAY , I_GRAY   , I_GRAY    , I_GRAY
  , I_GRAY   , I_GRAY   , I_GRAY    , I_WHITE
  , I_WHITE  , I_WHITE  , I_WHITE   , I_WHITE
};

static const BYTE ajBlackOnWhite[16] = {
    I_WHITE  , I_WHITE  , I_WHITE   , I_WHITE
  , I_GRAY   , I_GRAY   , I_GRAY    , I_GRAY
  , I_GRAY   , I_DKGRAY , I_DKGRAY  , I_DKGRAY
  , I_DKGRAY , I_DKGRAY , I_BLACK   , I_BLACK
};

static const BYTE ajBlackOnBlack[16] = {
    I_BLACK, I_BLACK, I_BLACK, I_BLACK,
    I_BLACK, I_BLACK, I_BLACK, I_BLACK,
    I_BLACK, I_BLACK, I_BLACK, I_BLACK,
    I_BLACK, I_BLACK, I_BLACK, I_BLACK
};

static const BYTE ajWhiteOnWhite[16] = {
    I_WHITE, I_WHITE, I_WHITE, I_WHITE,
    I_WHITE, I_WHITE, I_WHITE, I_WHITE,
    I_WHITE, I_WHITE, I_WHITE, I_WHITE,
    I_WHITE, I_WHITE, I_WHITE, I_WHITE
};

#if 0
/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcOpaqCopyS4D8                                                       *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Copies a 4bpp gray bitmap onto an 8bpp palettized surface. The         *
*   only case that this routine handles is white text on a black           *
*   background or black text on a white background.                        *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*                 This points to a 4-bit per pixel anti-aliased bitmap     *
*                 whose scans start and end on 32-bit boundaries.          *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*                 That is, this is the number of pixels in from the edge   *
*                 of the start of each scan line that the actual pixels    *
*                 of the image begins. All pixels before and after the     *
*                 image pixels of the scan are to be ignored. This offset  *
*                 has been put in to guarantee that 32-bit boundaries      *
*                 in the 4bpp source correspond to 32-bit boundaries       *
*                 in the destination.                                      *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - exclusive right dst pixel                                *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color                                         *
*    uB         - Background color                                         *
*    pS         - pointer to destination SURFACE                           *
*                                                                          *
* If the destination suface is 8-bits per pixels then the only form        *
* of antialiased text allowed is opaque textout with foreground and        *
* background are either black or white.                                    *
*                                                                          *
* On palette devices (8-bit devices) we are guaranteed to have 4 shades    *
* of gray to work with. These gray come from 4 of the 20 reserved          *
* entries in the palette and are given by:                                 *
*                                                                          *
*                    name           rgb           index                    *
*                                                                          *
*                    BLACK   (0x00, 0x00, 0x00)     0                      *
*                   DKGRAY   (0x80, 0x80, 0x80)    12                      *
*                     GRAY   (0xc0, 0xc0, 0xc0)     7                      *
*                    WHITE   (0xff, 0xff, 0xff)    19                      *
*                                                                          *
* There are, two cases of interest: 1) white text on black; and 2)         *
* black text on white. The various levels of gray seen on the screen       *
* is controled by the 16 values of blending as defined by each of the      *
* 4-bit gray levels in the glyphs images. The allowed value of blending    *
* are:                                                                     *
*                                                                          *
*                   alpha[i] = (i == 0) ? 0 : (i+1)/16                     *
*                                                                          *
*   where i = <value of 4-bit pixel>                                       *
*                                                                          *
* For case 1) (white text on a black background) the gamma corrected       *
* color channel values are given by:                                       *
*                                                                          *
*           c[i] = floor(255*(alpha[i]^(1/gamma)) + 1/2)                   *
*                                                                          *
* which is equivalent to the following table                               *
*                                                                          *
*                 c[16] = {   0, 104, 124, 141,                            *
*                           155, 167, 179, 189,                            *
*                           199, 208, 217, 225,                            *
*                           233, 241, 248, 255   };                        *
*                                                                          *
* This result applies to each of the three color channels.                 *
*                                                                          *
* The problem is that there are only four colors available: BLACK, DKGRAY, *
* GRAY, WHITE with the color values of 0, 128, 192, and 255 respectively.  *
* This means that the color table that is used is an                       *
* approximation to the correct color table given by:                       *
*                                                                          *
*           c' = { BLACK, BLACK,                                           *
*                  DKGRAY, DKGRAY, DKGRAY,                                 *
*                  GRAY, GRAY, GRAY, GRAY, GRAY, GRAY,                     *
*                  WHITE, WHITE, WHITE, WHITE, WHITE };                    *
*                                                                          *
* For case 2) (black text on white) the gamma corrected color channel      *
* values are given by:                                                     *
*                                                                          *
* d[i] = floor(255*((1-alpha[i])^(1/gamma) + 1/2) = c[15 - i]              *
*    =                                                                     *
*    {                                                                     *
*       255, 248, 241, 233,                                                *
*       225, 217, 208, 199,                                                *
*       189, 179, 167, 155,                                                *
*       141, 124, 104,   0                                                 *
*    };                                                                    *
*                                                                          *
* which is approximated by                                                 *
*                                                                          *
*                 d' = {                                                   *
*                   WHITE, WHITE, WHITE, WHITE,                            *
*                   GRAY, GRAY, GRAY, GRAY, GRAY,                          *
*                   DKGRAY, DKGRAY, DKGRAY, DKGRAY, DKGRAY,                *
*                   BLACK, BLACK                                           *
*                   }                                                      *
*                                                                          *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

VOID
vSrcOpaqCopyS4D8(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{
    int cPreamble, cMiddle, cPostamble, A, B;
    const BYTE *ajIndex;
    BYTE jSrc, *pjSrc, *pjDst;

    static const BYTE *apjIndex[4] = {
        ajBlackOnBlack  // uB = 0    uF = 0
    ,   ajBlackOnWhite  // uB = 0xff uF = 0
    ,   ajWhiteOnBlack  // uB = 0    uF = 0xff
    ,   ajWhiteOnWhite  // uB = 0xff uF = 0xff
    };

#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
         "vSrcOpaqCopyS4D8(\n"
         "    PBYTE   pjSrcIn    = %-#x\n"
         "    LONG    SrcLeft    = %d\n"
         "    LONG    DeltaSrcIn = %d\n"
         "    PBYTE   pjDstIn    = %-#x\n"
         "    LONG    DstLeft    = %d\n"
         "    LONG    DstRight   = %d\n"
         "    LONG    DeltaDstIn = %d\n"
         "    LONG    cy         = %d\n"
         "    ULONG   uF         = %-#x\n"
         "    ULONG   uB         = %-#x\n"
         "    SURFACE *pS        = %-#x\n"
         ");\n\n"
        , pjSrcIn
        , SrcLeft
        , DeltaSrcIn
        , pjDstIn
        , DstLeft
        , DstRight
        , DeltaDstIn
        , cy
        , uF
        , uB
        , pS
        );
        DbgBreakPoint();
    }
#endif

    ASSERTGDI((uF == 0xff) || (uF == 0), "Bad Foreground Color\n");
    ASSERTGDI((uB == 0xff) || (uB == 0), "Bad Background Color\n");
    ASSERTGDI((unsigned) pjSrcIn % 4 == 0,
        "Source buffer not 32-bit aligned\n");
    ASSERTGDI((unsigned) DeltaSrcIn % 4 == 0,
        "Source scans are not 32-bit aligned\n");
    /******************************************************************
    * Select the appropriate byte table                               *
    *                                                                 *
    * I take advantage of the restricted values of the foreground and *
    * background colors to form an index into a table. This requires  *
    * that the foreground and bacground colors be either 0 or -1.     *
    ******************************************************************/
    ajIndex = apjIndex[(uB & 1) + (uF & 2)];
    /******************************************************************
    *    Each nyble  of the source maps to a byte in the              *
    *    destination. I want to separate the pixels into three        *
    *    groups: preamble, middle, and postamble. The middle          *
    *    pixels of the destination start and end on 32-bit            *
    *    boundaries. The preamble and postamble are the               *
    *    other pixels on the left and right respectively.             *
    *    The preamble ends on a 32-bit address and the postamble      *
    *    begins on a 32-bit address.                                  *
    *                                                                 *
    *    It is possible for small images (1 or 2 wide) to be          *
    *    contained completely within a DWORD of the destination such  *
    *    that the destination image does not start on, contain, or    *
    *    end on a 32-bit boundary. I treat this situation as          *
    *    special cases.                                               *
    ******************************************************************/
    pjSrcIn += SrcLeft / 2;                // 2 pixels per source byte
    pjDstIn += DstLeft;                    // one byte per dest pixel
    A       = (DstLeft + 3) & ~3;          // A = 4 * ceil(DstLeft/4)
    B       = (DstRight   ) & ~3;          // B = 4 * floor(DstRight/4)
    if (B < A)
    {
        /*****************************************************
        *    There are only three ways that you can get here *
        *                                                    *
        *    1) DstLeft & 3 == 1 && DstRight == DstLeft + 1  *
        *    2) DstLeft & 3 == 1 && DstRight == DstLeft + 2  *
        *    3) DstLeft & 3 == 2 && DstRight == DstLeft + 1  *
        *****************************************************/
        if ((DstLeft & 3) == 1)
        {
            *pjDstIn++ = ajIndex[*pjSrcIn++ & 15];
        }
        if ((DstRight & 3) == 3)
        {
            *pjDstIn = ajIndex[*pjSrcIn >> 4];
        }
    }
    else
    {
        cPreamble  = A - DstLeft;           // # pixels in preamble
        cMiddle    = (B - A)/4;
        cPostamble = DstRight - B;          // # pixels in postamble
        for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
        {
            int cLast;
            int i;

            pjSrc = pjSrcIn;
            pjDst = pjDstIn;
            switch (cPreamble)
            {
            case 3:
                jSrc = *pjSrc++;
                *pjDst++ = ajIndex[jSrc & 15];
                // fall through
            case 2:
                jSrc = *pjSrc;
                *pjDst++ = ajIndex[jSrc >> 4];
                // fall through
            case 1:
                jSrc = *pjSrc++;
                *pjDst++ = ajIndex[jSrc & 15];
                // fall through
            }
            for (i = 0 ; i < cMiddle ; i++)
            {
                jSrc  = *pjSrc++;
                *pjDst++ = ajIndex[jSrc >> 4];
                *pjDst++ = ajIndex[jSrc & 15];

                jSrc  = *pjSrc++;
                *pjDst++ = ajIndex[jSrc >> 4];
                *pjDst++ = ajIndex[jSrc & 15];
            }
            if (cLast = cPostamble)
            {
                cLast -= 1;
                jSrc = *pjSrc++;
                *pjDst++ = ajIndex[jSrc >> 4];
                if (cLast)
                {
                    cLast -= 1;
                    *pjDst++ = ajIndex[jSrc & 15];
                    if (cLast)
                    {
                        jSrc = *pjSrc;
                        *pjDst++ = ajIndex[jSrc >> 4];
                        *pjDst++ = ajIndex[jSrc & 15];
                    }
                }
            }
        }
    }
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcTranCopyS4D8                                                       *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Despite what the title implies this routine is not a `transparent'     *
*   copy of a 4bpp gray scale bitmap onto an arbitrary 8bpp surface.       *
*   What it really does is do an opaque copy of a 4bpp gray scale          *
*   bitmap onto an 8bpp surface EXCEPT for the case where the value        *
*   of the 4bpp gray scale pixel is zero. In that special case, the        *
*   destination pixel is untouched. This routine nearly identical to       *
*   the routine named `vSrcOpaqCopyS4D8' except that this routine tests    *
*   each 4bpp pixel to see if it is zero.                                  *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*                 This points to a 4-bit per pixel anti-aliased bitmap     *
*                 whose scans start and end on 32-bit boundaries.          *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*                 That is, this is the number of pixels in from the edge   *
*                 of the start of each scan line that the actual pixels    *
*                 of the image begins. All pixels before and after the     *
*                 image pixels of the scan are to be ignored. This offset  *
*                 has been put in to guarantee that 32-bit boundaries      *
*                 in the 4bpp source correspond to 32-bit boundaries       *
*                 in the destination.                                      *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - exclusive right dst pixel                                *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color (0x00 or 0xff)                          *
*    uB         - Background color (not used)                              *
*    pS         - pointer to destination SURFACE                           *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

VOID
vSrcTranCopyS4D8(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{
    int cPreamble, cMiddle, cPostamble, A, B;
    const BYTE *ajIndex;
    BYTE jSrc, *pjSrc, *pjDst;

    static const BYTE *apjIndex[2] = {
        ajBlackOnWhite  // uF = 0       // black text
    ,   ajWhiteOnBlack  // uF = 0xFF    // white text
    };

#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
         "vSrcTranCopyS4D8(\n"
         "    PBYTE   pjSrcIn    = %-#x\n"
         "    LONG    SrcLeft    = %d\n"
         "    LONG    DeltaSrcIn = %d\n"
         "    PBYTE   pjDstIn    = %-#x\n"
         "    LONG    DstLeft    = %d\n"
         "    LONG    DstRight   = %d\n"
         "    LONG    DeltaDstIn = %d\n"
         "    LONG    cy         = %d\n"
         "    ULONG   uF         = %-#x\n"
         "    ULONG   uB         = %-#x\n"
         "    SURFACE *pS        = %-#x\n"
         ");\n\n"
        , pjSrcIn
        , SrcLeft
        , DeltaSrcIn
        , pjDstIn
        , DstLeft
        , DstRight
        , DeltaDstIn
        , cy
        , uF
        , uB
        , pS
        );
        DbgBreakPoint();
    }
#endif
    ASSERTGDI((uF == 0xff) || (uF == 0), "Bad Foreground Color\n");
    ASSERTGDI((unsigned) pjSrcIn % 4 == 0,
        "Source buffer not 32-bit aligned\n");
    ASSERTGDI((unsigned) DeltaSrcIn % 4 == 0,
        "Source scans are not 32-bit aligned\n");

static const BYTE ajTranWhiteOnBlack[16] = {
    I_BLACK  , I_BLACK  , I_DKGRAY  , I_DKGRAY
  , I_DKGRAY , I_GRAY   , I_GRAY    , I_GRAY
  , I_GRAY   , I_GRAY   , I_GRAY    , I_WHITE
  , I_WHITE  , I_WHITE  , I_WHITE   , I_WHITE
};

static const BYTE ajBlackOnWhite[16] = {
    I_WHITE  , I_WHITE  , I_WHITE   , I_WHITE
  , I_GRAY   , I_GRAY   , I_GRAY    , I_GRAY
  , I_GRAY   , I_DKGRAY , I_DKGRAY  , I_DKGRAY
  , I_DKGRAY , I_DKGRAY , I_BLACK   , I_BLACK
};
    ajIndex = apjIndex[uF & 1];
    pjSrcIn += SrcLeft / 2;                // 2 pixels per source byte
    pjDstIn += DstLeft;                    // one byte per dest pixel
    A       = (DstLeft + 3) & ~3;          // A = 4 * ceil(DstLeft/4)
    B       = (DstRight   ) & ~3;          // B = 4 * floor(DstRight/4)
    if (B < A)
    {
        if ((DstLeft & 3) == 1)
        {
            jSrc = *pjSrc++;
            if (jSrc & 15)                      // is gray pixel zero?
            {
                *pjDstIn = ajIndex[jSrc & 15];  // no, modify dest
            }
            pjDstIn++;
        }
        if ((DstRight & 3) == 3)
        {
            if (jSrc = *pjSrcIn >> 4)
            {
                *pjDstIn = ajIndex[jSrc];
            }
        }
    }
    else
    {
        cPreamble  = A - DstLeft;
        cMiddle = (B - A)/4;
        cPostamble = DstRight - B;
        for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
        {
            int cLast;
            int i;

            pjSrc = pjSrcIn;
            pjDst = pjDstIn;
            switch (cPreamble)
            {
            case 3:
                jSrc = *pjSrc++;
                if (jSrc & 15)
                {
                    *pjDst = ajIndex[jSrc & 15];
                }
                pjDst++;
                // fall through
            case 2:
                jSrc = *pjSrc;
                if (jSrc >> 4)
                {
                    *pjDst = ajIndex[jSrc >> 4];
                }
                pjDst++;
                // fall through
            case 1:
                jSrc = *pjSrc++;
                if (jSrc & 15)
                {
                    *pjDst = ajIndex[jSrc & 15];
                }
                pjDst++;
                // fall through
            }
            for (i = 0; i < cMiddle ; i++)
            {
                jSrc  = *pjSrc++;
                if (jSrc >> 4)
                {
                    *pjDst = ajIndex[jSrc >> 4];
                }
                pjDst++;
                if (jSrc & 15)
                {
                    *pjDst = ajIndex[jSrc & 15];
                }
                pjDst++;

                jSrc  = *pjSrc++;
                if (jSrc >> 4)
                {
                    *pjDst = ajIndex[jSrc >> 4];
                }
                pjDst++;
                if (jSrc & 15)
                {
                    *pjDst = ajIndex[jSrc & 15];
                }
                pjDst++;
            }
            if (cLast = cPostamble)
            {
                cLast -= 1;
                jSrc = *pjSrc++;
                if (jSrc >> 4)
                {
                    *pjDst = ajIndex[jSrc >> 4];
                }
                pjDst++;
                if (cLast)
                {
                    cLast -= 1;
                    if (jSrc & 15)
                    {
                        *pjDst = ajIndex[jSrc & 15];
                    }
                    pjDst++;
                    if (cLast)
                    {
                        jSrc = *pjSrc;
                        if (jSrc >> 4)
                        {
                            *pjDst = ajIndex[jSrc >> 4];
                        }
                        pjDst++;
                        if (jSrc & 15)
                        {
                            *pjDst = ajIndex[jSrc & 15];
                        }
                        pjDst++;
                    }
                }
            }
        }
    }
}
#endif

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcOpaqCopyS4D16                                                      *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - right(last) dst pixel                                    *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color                                         *
*    uB         - Background color                                         *
*    pS         - pointer to destination SURFACE                           *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

VOID
vSrcOpaqCopyS4D16(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )

{
    int cPreamble, cMiddle, cPostamble, A, B;
    USHORT *aus;                  // array of 16 possible colors
    USHORT *pus;                  // convenient pointer into the color array
//
//  If filling the color table in aus
//  turns out to be time consuming we could cache the table
//  off of the FONTOBJ and check to see if the foreground and
//  background colors have not changed since the last time.
//
#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "vSrcOpaqCopyS4D16(\n"
            "   pjSrcIn    = %-#x\n"
            "   SrcLeft    = %-#x\n"
            "   pjDstIn    = %-#x\n"
            "   DstLeft    = %-#x\n"
            "   DstRight   = %-#x\n"
            "   DeltaDstIn = %-#x\n"
            "   cy         = %-#x\n"
            "   uF         = %-#x\n"
            "   uB         = %-#x\n"
            "   pS         = %-#x\n"
            ,   pjSrcIn
            ,   SrcLeft
            ,   pjDstIn
            ,   DstLeft
            ,   DstRight
            ,   DeltaDstIn
            ,   cy
            ,   uF
            ,   uB
            ,   pS
        );
        DbgBreakPoint();
    }
#endif

    aus = (USHORT*) pvFillOpaqTable(sizeof(*aus), uF, uB, pS);
    A          = (DstLeft + 1) & ~1;
    B          = (DstRight   ) & ~1;
    pjSrcIn   += SrcLeft/2;
    pjDstIn   += DstLeft * sizeof(USHORT);
    cPreamble  = A - DstLeft;
    cMiddle    = (B - A) / 2;
    cPostamble = DstRight - B;
    for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
    {
        int i;
        BYTE jSrc;
        BYTE *pjSrc = pjSrcIn;
        USHORT *pusDst = (USHORT*) pjDstIn;

        if (cPreamble)
        {
            jSrc = *pjSrc++;
            *pusDst++ = aus[jSrc & 15];
        }
        for (i = 0; i < cMiddle; i++)
        {
            jSrc  = *pjSrc++;
            *pusDst++ = aus[jSrc >> 4];
            *pusDst++ = aus[jSrc & 15];
        }
        if (cPostamble)
        {
            jSrc = *pjSrc;
            *pusDst = aus[jSrc >> 4];
        }
    }
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcTranCopyS4D16                                                      *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - right(last) dst pixel                                    *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color                                         *
*    uB         - Background color                                         *
*    pS         - pointer to the FINAL destination SURFACE                 *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/
VOID
vSrcTranCopyS4D16(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{
    ULONG flRed, cRedRight, uRedF, flRedRight;
    ULONG flGre, cGreRight, uGreF, flGreRight;
    ULONG flBlu, cBluRight, uBluF, flBluRight;
    ULONG uT, dT, u;
    CONST ULONG *aul;
    int cPreamble, cMiddle, cPostamble, A, B;
    BYTE j;
    XEPALOBJ xpo;

    if(pS->pPal == NULL)
    {
        PDEVOBJ pdo(pS->hdev());
        xpo.ppalSet(pdo.ppalSurf());
    }
    else
    {
        xpo.ppalSet(pS->pPal);
    }
    
    ASSERTGDI(xpo.bValid(),      "Invalid XEPALOBJ" );

    if (xpo.bIsBitfields())
    {
        flRed      = xpo.flRed();               // masks red bits
        cRedRight  = xpo.cRedRight();

        flGre      = xpo.flGre();               // masks green bits
        cGreRight  = xpo.cGreRight();

        flBlu      = xpo.flBlu();               // masks blu bits
        cBluRight  = xpo.cBluRight();
    }
    else if (xpo.bIsRGB())
    {
        WARNING("16 bit-RGB -- assuming 5+5+5\n");
        flRed     = 0x001f;
        cRedRight = 0;
        flGre     = 0x03e0;
        cGreRight = 5;
        flBlu     = 0x7c00;
        cBluRight = 10;
    }
    else if (xpo.bIsBGR())
    {
        WARNING("16 bit-BGR -- assuming 5+5+5\n");
        flRed     = 0x7c00;
        cRedRight = 10;
        flGre     = 0x03e0;
        cGreRight = 5;
        flBlu     = 0x001f;
        cBluRight = 0;
    }
    else
    {
        RIP("unsuported palette format\n");
    }
    uRedF      = (uF & flRed) >> cRedRight;
    flRedRight = flRed >> cRedRight;

    uGreF      = (uF & flGre) >> cGreRight;
    flGreRight = flGre >> cGreRight;

    uBluF      = (uF & flBlu) >> cBluRight;
    flBluRight = flBlu >> cBluRight;

#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "vSrcTranCopyS4D16(\n"
            "   pjSrcIn    = %-#x\n"
            "   SrcLeft    = %d\n"
            "   DeltaSrcIn = %d\n"
            "   pjDstIn    = %-#x\n"
            "   DstLeft    = %d\n"
            "   DstRight   = %d\n"
            "   DeltaDstIn = %d\n"
            "   cy         = %d\n"
            "   uF         = %-#x\n"
            "   uB         = %-#x\n"
            "   pS         = %-#x\n"
           ,    pjSrcIn
           ,    SrcLeft
           ,    DeltaSrcIn
           ,    pjDstIn
           ,    DstLeft
           ,    DstRight
           ,    DeltaDstIn
           ,    cy
           ,    uF
           ,    uB
           ,    pS
        );
        DbgPrint(
            "   flRed      = %-#x\n"
            "   cRedRight  = %d\n"
            "   uRedF      = %-#x\n"
            "   flRedRight = %-#x\n"
            , flRed, cRedRight, uRedF, flRedRight
        );
        DbgPrint(
            "   flGre      = %-#x\n"
            "   cGreRight  = %d\n"
            "   uGreF      = %-#x\n"
            "   flGreRight = %-#x\n"
            , flGre, cGreRight, uGreF, flGreRight
        );
        DbgPrint(
            "   flBlu      = %-#x\n"
            "   cBluRight  = %d\n"
            "   uBluF      = %-#x\n"
            "   flBluRight = %-#x\n"
            , flBlu, cBluRight, uBluF, flBluRight
        );
            DbgBreakPoint();
    }
#endif

/*****************************************************************************
*                                                                            *
*    The CCC macro blends forground and background colors of a single color  *
*    channel. Gamma correction is taken into account using an approximate    *
*    correction scheme. uB contains all three background colors. We first    *
*    mask off the bits of interest and then shift them down until the        *
*    least significant color bit resides at the lowest bit of the dword.     *
*    The answer is placed in uT ("temporary ULONG"). This must be done for   *
*    each pixel in the destination. The same thing has been done for the     *
*    each of the forground color channels and placed in uRedF, uGreF,        *
*    and uBluF. These values do not change from pixel to pixel and so the    *
*    calculation of these down shifted forground color channel values is     *
*    done up front before the loop. Then for each color channel we           *
*    calculate the difference between the down-shifted forground- and        *
*    background color channels and place the answer in dT ("temporary        *
*    difference"). The approximate gamma correction is done in the           *
*    following manner: If the background color value is smaller than         *
*    the foreground color value then the approximate correction is:          *
*                                                                            *
*        (c_f >= c_b):                                                       *
*                                                                            *
*              c = c_b + alpha_k ^ (1/gamma) * (c_f - c_b)                   *
*                                                                            *
*        (c_f <= c_b):                                                       *
*                                                                            *
*              c = c_b + (1 - (1 - alpha_k)^(1/gamma)) * (c_f - c_b)         *
*                                                                            *
*    where                                                                   *
*                                                                            *
*            c   := blended color                                            *
*            c_b := background color                                         *
*            c_f := foreground color                                         *
*            alpha_k := k'th blending fraction = k == 0 ? 0 : (k+1)/16;      *
*            gamma := 2.33                                                   *
*                                                                            *
*    I have storred all sixteen values of alpha_k ^ (1/gamma) in 16.16       *
*    representation in an array ULONG aulB[16] and I have storred the        *
*    values of 1 - (1 - alpha_k)^(1/gamma) in aulIB[k]                       *
*                                                                            *
*    Thus the blended color value is                                         *
*                                                                            *
*        (c_f >= c_b):                                                       *
*                                                                            *
*            c = (2^16 * c_b + aulB[k] * (c_f - c_b)) / 2^16                 *
*                                                                            *
*                                                                            *
*        (c_f <= c_b):                                                       *
*                                                                            *
*            c = (2^16 * c_b + aulB[15-k] * (c_f - c_b)) / 2^16              *
*    Instead of accessing aulB[15-k], I access aulIB which has               *
*    aulIB[k] = aulB[15-k]                                                   *
*    In the macro below, I actually blend the down-shifted color             *
*    channel values and then shift the answer up and mask it (the            *
*    mask shouldn't be necessary, but this is a precaution).                 *
*                                                                            *
*****************************************************************************/

#define CCC(Color,jj)                                                 \
    uT = (uB & fl##Color) >> c##Color##Right;                         \
    dT = u##Color##F - uT;                                            \
    aul = ((LONG) dT < 0) ? aulIB : aulB;                             \
    u |= (((dT * aul[jj] + (uT << 16)) >> 16) << c##Color##Right) & fl##Color

/******************************************************************************
*                                                                             *
*    The SETCOLOR macro looks at the blending value. If it is zero then       *
*    the destination pixel does not change and we do nothing. If the blending *
*    value is 15 then the destination pixel should take the forground color   *
*    , no blending is necessary. If the blending value is one of 1..14 then   *
*    all three color channels are blended and added together.                 *
*                                                                             *
******************************************************************************/

                #define SETCOLOR(jj)           \
                if (j = (jj))                  \
                {                              \
                    if (j == 15)               \
                    {                          \
                        u = uF;                \
                    }                          \
                    else                       \
                    {                          \
                        u = 0;                 \
                        uB = (ULONG) *pusDst;  \
                        CCC(Red,j);            \
                        CCC(Gre,j);            \
                        CCC(Blu,j);            \
                    }                          \
                    *pusDst = (USHORT) u;      \
                }                              \
                pusDst++

/*********************************************************************
*                                                                    *
*    Each pixel takes 16-bits, half of a DWORD. I will separate      *
*    each scan into three sections: the "preamble", the              *
*    "middle", and the "postamble". The preamble are the set of      *
*    pixels that occur before the first 32-bit boundary in the       *
*    destination. Either a pixel starts on a DWORD or it doesn't.    *
*    Therefore there can be at most one pixel in the preamble.       *
*    The middle section starts and ends on a 32-bit boundary.        *
*    The postamble starts on a 32-bit boundary but ends on an        *
*    address that is not 32-bit aligned. There can be at most        *
*    one pixel in the postamble.                                     *
*                                                                    *
*        A = x-coord of pixel starting on the lowest                 *
*            32-bit aligned address in the scan                      *
*                                                                    *
*          = 2 (pixels/dword)                                        *
*              * ceiling (16 (bits/pixel) * left / 32 (bits/dword))  *
*                                                                    *
*          = 2 * ceiling( left / 2 )                                 *
*                                                                    *
*          = 2 * floor((left + 1) / 2)                               *
*                                                                    *
*          = (left + 1) & ~1;                                        *
*                                                                    *
*                                                                    *
*        B =  x-coord of pixel starting at the highest               *
*             32-bit aligned address in the scan                     *
*                                                                    *
*          = 2 * floor( right / 2)                                   *
*                                                                    *
*          = right & ~1                                              *
*                                                                    *
*                                                                    *
*        cPreamble  = # pixels in preamble                           *
*        cPostamble = # pixels in postamble                          *
*                                                                    *
*    Each nyble  of the gray 4-bpp source bitmap corresponds to a    *
*    pixel in the destination. The pixels of the scan do not         *
*    start on the left edge of the gray 4-bpp bitmap, they are       *
*    indented by SrcLeft pixels. The reason is that the gray         *
*    bitmap was aligned so that the initial starting address         *
*    of the gray bitmap started at a position corresponding to       *
*    a 32-bit aligned address in the destination. Thus there         *
*    is a relationship between cPreamble and SrcLeft. In any         *
*    case we have to move the pointer to the first source pixel      *
*    of interest inward away from the left edge of the gray          *
*    source bitmap. Since we move pointers in BYTE increments        *
*    we must convert the number of pixels (SrcLeft), each            *
*    of which corresponds to an nyble  to a count of bytes. The      *
*    conversion is easy                                              *
*                                                                    *
*        source shift in bytes = floor(SrcLeft/2)                    *
*                                                                    *
*    Similarly, the pointer to the destination must be indented      *
*    by the offset of the x-coordinate of the destination            *
*    rectangle and thus pjDstIn is shifted                           *
*                                                                    *
*********************************************************************/

    A          = (DstLeft + 1) & ~1;
    B          = (DstRight   ) & ~1;
    cPreamble  = A - DstLeft;
    cMiddle    = (B - A)/2;
    cPostamble = DstRight - B;
    pjSrcIn   += SrcLeft / 2;
    pjDstIn   += DstLeft * sizeof(USHORT);
    for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
    {
        int i;
        BYTE jSrc;
        BYTE *pjSrc = pjSrcIn;
        USHORT *pusDst = (USHORT*) pjDstIn;

        if (cPreamble)
        {
            jSrc = *pjSrc;
            SETCOLOR(jSrc & 15);
            pjSrc++;
        }
        for (i = 0; i < cMiddle; i++)
        {
            jSrc  = *pjSrc;
            SETCOLOR(jSrc >> 4);
            SETCOLOR(jSrc & 15);
            pjSrc++;
        }
        if (cPostamble)
        {
            SETCOLOR(*pjSrc >> 4);
        }
    }
#undef SETCOLOR
#undef CCC
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcOpaqCopyS4D24                                                      *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - right(last) dst pixel                                    *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color                                         *
*    uB         - Background color                                         *
*    pS         - pointer to destination SURFACE                           *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

VOID
vSrcOpaqCopyS4D24(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{
    int A;                  // position of first 32-bit aligned pixel
    int B;                  // position of last 32-bit aligned pixel
    int cPreamble;          // The preamble is the set of pixeles
                            // that you need to go through to get
    // nearest 32-bit boundary in the destination

    int cMiddle;            // This is the number of interations
                            // that are done in the middle section
    // in which we are guaranteed 32-bit alignment. Each time through
    // the loop, we use 2 source bytes which corresponds to 4 pixels.
    // In this case of 24-bits per destination pixel, this means that
    // each itteration of the loop affects 3 DWORD's of the destination.
    // This means that cMiddle = (#destination DWORD's)/3 in the
    // middle (32-bit aligned) section.

    int cPostamble;         // The postamble is the set of pixels
                            // that remain after the last 32-bit
    // boundary in the destination. Thus number is can be 0, 1, or 2.

    ULONG  *aul;            // a cache of the 16 possible 24-bit
                            // colors that can be seen on the
                            // destination surface.
#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "vSrcOpaqCopyS4D24(\n"
            "   PBYTE   pjSrcIn     = %-#x\n"
            "   LONG    SrcLeft     = %d\n"
            "   LONG    DeltaSrcIn  = %d\n"
            "   PBYTE   pjDstIn     = %-#x\n"
            "   LONG    DstLeft     = %d\n"
            "   LONG    DstRight    = %d\n"
            "   LONG    DeltaDstIn  = %d\n"
            "   LONG    cy          = %d\n"
            "   ULONG   uF          = %-#x\n"
            "   ULONG   uB          = %-#x\n"
            "   SURFACE *pS         = %-#x\n"
            ,   pjSrcIn
            ,   SrcLeft
            ,   DeltaSrcIn
            ,   pjDstIn
            ,   DstLeft
            ,   DstRight
            ,   DeltaDstIn
            ,   cy
            ,   uF
            ,   uB
            ,   pS
        );
         DbgBreakPoint();
    }
#endif

    aul = (ULONG*) pvFillOpaqTable(sizeof(*aul), uF, uB, pS);
    pjSrcIn   += SrcLeft / 2;         // 2 pixels per src byte
    pjDstIn   += DstLeft * 3;         // 3 bytes per dest pixel
    A          = (DstLeft + 3) & ~3;  // round up to nearest multiple of 4
    B          = (DstRight   ) & ~3;  // round down to nearest multiple of 4

#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "\n"
            "   pjSrcIn     = %-#x\n"
            "   pjDstIn     = %-#x\n"
            "   A           = %d\n"
            "   B           = %d\n"
        ,   pjSrcIn
        ,   pjDstIn
        ,   A
        ,   B
        );
        DbgBreakPoint();
    }
#endif

    if (A <= B)
    {
        cPreamble  = A - DstLeft;       // # pixels in preamble
        cMiddle    = (B - A) / 4;       // each loop does 4 pixels
        cPostamble = DstRight - B;      // # pixels in postample

#if DBG
        if (gflFontDebug & DEBUG_AA)
        {
            DbgPrint(
                "   cPreamble   = %d\n"
                "   cMiddle     = %d\n"
                "   cPostamble  = %d\n"
                , cPreamble, cMiddle, cPostamble
            );
            DbgBreakPoint();
        }
#endif

        for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
        {
            int i;
            BYTE  *ajSrc; // points directly into the gamma correction table
            ULONG *pul;
            BYTE  *pjSrc = pjSrcIn;
            BYTE  *pjDst = pjDstIn;

            switch (cPreamble)
            {
            case 3:
                ajSrc = (BYTE*) & (aul[*pjSrc & 15]);
                *pjDst++ = *ajSrc++;
                *pjDst++ = *ajSrc++;
                *pjDst++ = *ajSrc;
                pjSrc++;
                // fall through
            case 2:
                ajSrc = (BYTE*) & (aul[*pjSrc >> 4]);
                *pjDst++ = *ajSrc++;
                *pjDst++ = *ajSrc++;
                *pjDst++ = *ajSrc;
                // fall through
            case 1:
                ajSrc = (BYTE*) & (aul[*pjSrc & 15]);
                *pjDst++ = *ajSrc++;
                *pjDst++ = *ajSrc++;
                *pjDst++ = *ajSrc;
                pjSrc++;
            case 0:
                ;
            }
            for (pul = (ULONG*) pjDst, i = 0; i < cMiddle; i++)
            {
                /*****************************************************
                *    Each time through the loop four pixels are      *
                *    processed (3 DWORD's in the destination, 2      *
                *    bytes in the source glyph.)                     *
                *****************************************************/
                ULONG c0, c1, c2, c3;
                BYTE j0,j1;
                ASSERTGDI(!((ULONG_PTR) pjDst & 3),"bad alignment\n");
                j0 = *pjSrc++;
                j1 = *pjSrc++;
                c0 = aul[j0 >> 4];
                c1 = aul[j0 & 15];
                c2 = aul[j1 >> 4];
                c3 = aul[j1 & 15];
                *pul++ = (c0      ) + (c1 << 24);
                *pul++ = (c1 >>  8) + (c2 << 16);
                *pul++ = (c2 >> 16) + (c3 <<  8);
            }
            pjDst = (BYTE*) pul;
            if (i = cPostamble)
            {
                /*****************************************************
                *   I do the postamble a byte at a time so that I    *
                *   don't overwrite pixels beyond the scan. If I     *
                *   wrote a DWORD at a time, then I would have to    *
                *   do some tricky masking.                          *
                *****************************************************/
                i--;
                ajSrc = (BYTE*) & (aul[*pjSrc >> 4]);
                *pjDst++ = *ajSrc++;
                *pjDst++ = *ajSrc++;
                *pjDst++ = *ajSrc;
                if (i)
                {
                    i--;
                    ajSrc = (BYTE*) & (aul[*pjSrc & 15]);
                    *pjDst++ = *ajSrc++;
                    *pjDst++ = *ajSrc++;
                    *pjDst++ = *ajSrc;
                    pjSrc++;
                    if (i) {
                        ajSrc = (BYTE*) & (aul[*pjSrc >> 4]);
                        *pjDst++ = *ajSrc++;
                        *pjDst++ = *ajSrc++;
                        *pjDst++ = *ajSrc;
                    }
                }
            }
        }
    }
    else
    {
        /***************************************************************
        *    If the text bitmap is narrow (3 wide or less) then        *
        *    it is possible to have B < A. There are three such cases: *
        *                                                              *
        *     1) DstLeft & 3 == 2 AND DstLeft + 1 == DstRight          *
        *     1) DstLeft & 3 == 1 AND DstLeft + 1 == DstRight          *
        *     2) DstLeft & 3 == 1 AND DstLeft + 2 == DstRight          *
        *                                                              *
        *    I shall treat each of these as a special case             *
        ***************************************************************/
        ASSERTGDI(B < A, "A <= B");
        BYTE *ajSrc; // points directly into the gamma correction table
        BYTE *pjDst = pjDstIn;
        BYTE *pjSrc = pjSrcIn;

#if DBG
        if (gflFontDebug & DEBUG_AA)
        {
            DbgPrint(
                "   SPECIAL CASE: A < B\n"
                "       DstLeft & 3 = %d\n"
                , DstLeft & 3
            );
            DbgBreakPoint();
        }
#endif

        switch (DstLeft & 3)
        {
        case 0:

            RIP("DstLeft & 3 == 0");
            break;

        case 1:

            /********************************************************
            *                                                       *
            *      H   H   H   L   L   L   H   H   H   L   L   L    *
            *    +---------------+---------------+---------------+  *
            *    | 0 | 0 | 0 | 1 | 1 | 1 | 2 | 2 | 2 | 3 | 3 | 3 |  *
            *    +---------------+---------------+---------------+  *
            *                  X   X   X                            *
            *                  ^                                    *
            *                  |                                    *
            *                  pjDst                                *
            *                                                       *
            ********************************************************/
            // copy three bytes from the opaque color table
            ajSrc = (BYTE*) & (aul[*pjSrc & 15]);
            *pjDst++ = *ajSrc++;
            *pjDst++ = *ajSrc++;
            *pjDst++ = *ajSrc;
            if (DstLeft + 1 == DstRight)
                break;
            pjSrc++;                        // done with this source byte
            // fall through
        case 2:

            /*********************************************************
            *                                                        *
            *      H   H   H   L   L   L   H   H   H   L   L   L     *
            *    +---------------+---------------+---------------+   *
            *    | 0 | 0 | 0 | 1 | 1 | 1 | 2 | 2 | 2 | 3 | 3 | 3 |   *
            *    +---------------+---------------+---------------+   *
            *                              X   X   X                 *
            *                              ^                         *
            *                              |                         *
            *                              pjDst                     *
            *                                                        *
            *********************************************************/
            // copy three bytes from the opaque color table
            ajSrc = (BYTE*) & (aul[*pjSrc >> 4]);
            *pjDst++ = *ajSrc++;
            *pjDst++ = *ajSrc++;
            *pjDst   = *ajSrc;
            break;
        }
    }
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcTranCopyS4D24                                                      *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - right(last) dst pixel                                    *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color                                         *
*    uB         - Background color                                         *
*    pS         - pointer to destination SURFACE                           *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

VOID
vSrcTranCopyS4D24(
    PBYTE    pjSrcIn,
    LONG     SrcLeft,
    LONG     DeltaSrcIn,
    PBYTE    pjDstIn,
    LONG     DstLeft,
    LONG     DstRight,
    LONG     DeltaDstIn,
    LONG     cy,
    ULONG    uF,
    ULONG    uB,
    SURFACE *pS
    )
{
#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "vSrcTranCopyS4D24(\n"
            "   PBYTE    pjSrcIn     = %-#x\n"
            "   LONG     SrcLeft     = %d\n"
            "   LONG     DeltaSrcIn  = %d\n"
            "   PBYTE    pjDstIn     = %-#x\n"
            "   LONG     DstLeft     = %d\n"
            "   LONG     DstRight    = %d\n"
            "   LONG     DeltaDstIn  = %d\n"
            "   LONG     cy          = %d\n"
            "   ULONG    uF          = %-#x\n"
            "   ULONG    uB          = %-#x\n"
            "   SURFACE *pS          = %-#x\n"
            "   )\n"
            ,   pjSrcIn
            ,   SrcLeft
            ,   DeltaSrcIn
            ,   pjDstIn
            ,   DstLeft
            ,   DstRight
            ,   DeltaDstIn
            ,   cy
            ,   uF
            ,   uB
            ,   pS
        );
        DbgBreakPoint();
    }
#endif
    ULONG flRed, cRedRight, uRedF, flRedRight;
    ULONG flGre, cGreRight, uGreF, flGreRight;
    ULONG flBlu, cBluRight, uBluF, flBluRight;
    ULONG uT, dT, u;
    CONST ULONG *aul;
    int cPreamble, cMiddle, cPostamble, A, B;
    BYTE j;
    XEPALOBJ xpo;

    if(pS->pPal == NULL)
    {
        PDEVOBJ pdo(pS->hdev());
        xpo.ppalSet(pdo.ppalSurf());
    }
    else
    {
        xpo.ppalSet(pS->pPal);
    }

    ASSERTGDI(xpo.bValid(),      "Invalid XEPALOBJ" );

    if (xpo.bIsBitfields())
    {
        flRed      = xpo.flRed();               // masks red bits
        cRedRight  = xpo.cRedRight();

        flGre      = xpo.flGre();               // masks green bits
        cGreRight  = xpo.cGreRight();

        flBlu      = xpo.flBlu();               // masks blu bits
        cBluRight  = xpo.cBluRight();
    }
    else if (xpo.bIsRGB())
    {
        // assuming 8+8+8
        flRed     = 0x0000ff;
        cRedRight = 0;
        flGre     = 0x00ff00;
        cGreRight = 8;
        flBlu     = 0xff0000;
        cBluRight = 16;
    }
    else if (xpo.bIsBGR())
    {
        // assuming 8+8+8
        flRed     = 0xff0000;
        cRedRight = 16;
        flGre     = 0x00ff00;
        cGreRight = 8;
        flBlu     = 0x0000ff;
        cBluRight = 0;
    }
    else
    {
        RIP("unsuported palette format\n");
    }
    uRedF      = (uF & flRed) >> cRedRight;
    flRedRight = flRed >> cRedRight;

    uGreF      = (uF & flGre) >> cGreRight;
    flGreRight = flGre >> cGreRight;

    uBluF      = (uF & flBlu) >> cBluRight;
    flBluRight = flBlu >> cBluRight;
#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "   flRed      = %-#x\n"
            "   cRedRight  = %d\n"
            "   uRedF      = %-#x\n"
            "   flRedRight = %-#x\n"
            , flRed, cRedRight, uRedF, flRedRight
        );
        DbgPrint(
            "   flGre      = %-#x\n"
            "   cGreRight  = %d\n"
            "   uGreF      = %-#x\n"
            "   flGreRight = %-#x\n"
            , flGre, cGreRight, uGreF, flGreRight
        );
        DbgPrint(
            "   flBlu      = %-#x\n"
            "   cBluRight  = %d\n"
            "   uBluF      = %-#x\n"
            "   flBluRight = %-#x\n"
            , flBlu, cBluRight, uBluF, flBluRight
        );
        DbgBreakPoint();
    }
#endif

/******************************************************************************
*                                                                             *
*    See the discussion of the CCC macro in vSrcTranCopyS4D16()               *
*                                                                             *
*                                                                             *
                                                                             */
#define CCC(Color,jj)                                                 \
    uT = (uB & fl##Color) >> c##Color##Right;                         \
    dT = u##Color##F - uT;                                            \
    aul = ((LONG) dT < 0) ? aulIB : aulB;                             \
    u |= (((dT * aul[jj] + (uT << 16)) >> 16)                         \
                                << c##Color##Right) & fl##Color
/*                                                                            *
*                                                                             *
*                                                                             *
/******************************************************************************/


/******************************************************************************
*                                                                             *
*    The SETCOLOR macro looks at the blending value. If it is zero then       *
*    the destination pixel does not change and we do nothing. If the blending *
*    value is 15 then the destination pixel should take the forground color   *
*    , no blending is necessary. If the blending value is one of 1..14 then   *
*    all three color channels are blended and added together.                 *
*                                                                             *
*                                                                             */

                    #define SETCOLOR(jj)                          \
                        if (j = (jj))                             \
                        {                                         \
                            if (j == 15)                          \
                            {                                     \
                                u = uF;                           \
                            }                                     \
                            else                                  \
                            {                                     \
                                u = 0;                            \
                                *(((BYTE*) & uB)+0) = *(pjDst+0); \
                                *(((BYTE*) & uB)+1) = *(pjDst+1); \
                                *(((BYTE*) & uB)+2) = *(pjDst+2); \
                                CCC(Red,j);                       \
                                CCC(Gre,j);                       \
                                CCC(Blu,j);                       \
                            }                                     \
                            *(pjDst+0) = *(((BYTE*) & u)+0);      \
                            *(pjDst+1) = *(((BYTE*) & u)+1);      \
                            *(pjDst+2) = *(((BYTE*) & u)+2);      \
                        }                                         \
                        pjDst += 3
/*                                                                            *
*                                                                             *
*                                                                             *
/******************************************************************************/

    A          = (DstLeft + 3) & ~3;
    B          = (DstRight   ) & ~3;
    pjSrcIn   += SrcLeft / 2;           // 4-bits  per source pixel
    pjDstIn   += DstLeft * 3;           // 24-bits per destination pixel
    if (A <= B)
    {
        cPreamble  = A - DstLeft;
        cMiddle    = (B - A) / 4;
        cPostamble = DstRight - B;
        for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
        {
            int i;
            BYTE *pjSrc = pjSrcIn;
            BYTE *pjDst = pjDstIn;

            switch (cPreamble)
            {
            case 3:
                SETCOLOR(*pjSrc & 15);
                pjSrc++;
            case 2:
                SETCOLOR(*pjSrc >> 4);
            case 1:
                SETCOLOR(*pjSrc & 15);
                pjSrc++;
            case 0:
                ;
            }
            ASSERTGDI(!((ULONG_PTR) pjDst & 3),"bad alignment\n");
            for (i = 0; i < cMiddle; i++)
            {
                SETCOLOR(*pjSrc >> 4);
                SETCOLOR(*pjSrc & 15);
                pjSrc++;
                SETCOLOR(*pjSrc >> 4);
                SETCOLOR(*pjSrc & 15);
                pjSrc++;
            }
            if (i = cPostamble)
            {
                SETCOLOR(*pjSrc >> 4);
                i--;
                if (i)
                {
                    SETCOLOR(*pjSrc & 15);
                    i--;
                    if (i)
                    {
                        pjSrc++;
                        SETCOLOR(*pjSrc >> 4);
                    }
                }
            }
        }
    }
    else
    {
        /***************************************************************
        *    If the text bitmap is narrow (3 wide or less) then        *
        *    it is possible to have B < A. There are three such cases: *
        *                                                              *
        *     1) DstLeft & 3 == 2 AND DstLeft + 1 == DstRight          *
        *     1) DstLeft & 3 == 1 AND DstLeft + 1 == DstRight          *
        *     2) DstLeft & 3 == 1 AND DstLeft + 2 == DstRight          *
        *                                                              *
        *    I shall treat each of these as a special case             *
        ***************************************************************/
        ASSERTGDI(B < A, "A <= B");
        BYTE *ajSrc; // points directly into the gamma correction table
        BYTE *pjDst = pjDstIn;
        BYTE *pjSrc = pjSrcIn;

#if DBG
        if (gflFontDebug & DEBUG_AA)
        {
            DbgPrint(
                "   SPECIAL CASE: A < B\n"
                "       DstLeft & 3 = %d\n"
                , DstLeft & 3
            );
            DbgBreakPoint();
        }
#endif

        switch (DstLeft & 3)
        {
        case 0:

            RIP("DstLeft & 3 == 0");
            break;

        case 1:

            /********************************************************
            *                                                       *
            *      H   H   H   L   L   L   H   H   H   L   L   L    *
            *    +---------------+---------------+---------------+  *
            *    | 0 | 0 | 0 | 1 | 1 | 1 | 2 | 2 | 2 | 3 | 3 | 3 |  *
            *    +---------------+---------------+---------------+  *
            *                  X   X   X                            *
            *                  ^                                    *
            *                  |                                    *
            *                  pjDst                                *
            *                                                       *
            ********************************************************/
            SETCOLOR(*pjSrc & 15);
            if (DstLeft + 1 == DstRight)
                break;
            pjSrc++;                        // done with this byte
                                            // fall through
        case 2:

            /*********************************************************
            *                                                        *
            *      H   H   H   L   L   L   H   H   H   L   L   L     *
            *    +---------------+---------------+---------------+   *
            *    | 0 | 0 | 0 | 1 | 1 | 1 | 2 | 2 | 2 | 3 | 3 | 3 |   *
            *    +---------------+---------------+---------------+   *
            *                              X   X   X                 *
            *                              ^                         *
            *                              |                         *
            *                              pjDst                     *
            *                                                        *
            *********************************************************/
            SETCOLOR(*pjSrc >> 4);
            break;
        }
    }
#undef SETCOLOR
#undef CCC
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcOpaqCopyS4D32                                                      *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - right(last) dst pixel                                    *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color                                         *
*    uB         - Background color                                         *
*    pS         - pointer to destination SURFACE                           *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

VOID
vSrcOpaqCopyS4D32(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )

{
    int A, B, cPreamble, cMiddle, cPostamble;
    ULONG  *aul;                            // array of 16 possible colors
#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "vSrcOpaqCopyS4D32(\n"
            "   pjSrcIn    = %-#x\n"
            "   SrcLeft    = %-#x\n"
            "   pjDstIn    = %-#x\n"
            "   DstLeft    = %-#x\n"
            "   DstRight   = %-#x\n"
            "   DeltaDstIn = %-#x\n"
            "   cy         = %-#x\n"
            "   uF         = %-#x\n"
            "   uB         = %-#x\n"
            "   pS         = %-#x\n"
           ,    pjSrcIn
           ,    SrcLeft
           ,    DeltaSrcIn
           ,    pjDstIn
           ,    DstLeft
           ,    DstRight
           ,    DeltaDstIn
           ,    cy
           ,    uF
           ,    uB
           ,    pS
        );
        DbgBreakPoint();
    }
#endif
    aul = (ULONG*) pvFillOpaqTable(sizeof(*aul), uF, uB, pS);
    A          = (DstLeft + 1) & ~1;
    B          = (DstRight   ) & ~1;
    cPreamble  = A - DstLeft;        // # pixels in preamble
    cMiddle    = (B - A)/2;
    cPostamble = DstRight - B;       // # pixels in postamble
    pjSrcIn   += SrcLeft / 2;
    pjDstIn   += DstLeft * sizeof(ULONG);
    for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
    {
        int i;
        BYTE *pjSrc = pjSrcIn;
        ULONG *pul  = (ULONG*) pjDstIn;

        if (cPreamble)
        {
            *pul++ = aul[*pjSrc++ & 15];
        }
        for (i = 0; i < cMiddle; i++)
        {
            BYTE j = *pjSrc++;
            *pul++ = aul[j >> 4];
            *pul++ = aul[j & 15];
        }
        if (cPostamble)
        {
            *pul = aul[*pjSrc >> 4];
        }
    }
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcTranCopyS4D32                                                      *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - right(last) dst pixel                                    *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color                                         *
*    uB         - Background color                                         *
*    pS         - pointer to destination SURFACE                           *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

VOID
vSrcTranCopyS4D32(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{

    ULONG flRed, cRedRight, uRedF, flRedRight;
    ULONG flGre, cGreRight, uGreF, flGreRight;
    ULONG flBlu, cBluRight, uBluF, flBluRight;
    ULONG uT, dT, u;
    CONST ULONG *aul;
    int cPreamble, cMiddle, cPostamble, A, B;
    BYTE j;
    XEPALOBJ xpo;

    if(pS->pPal == NULL)
    {
        PDEVOBJ pdo(pS->hdev());
        xpo.ppalSet(pdo.ppalSurf());
    }
    else
    {
        xpo.ppalSet(pS->pPal);
    }
    
    ASSERTGDI(xpo.bValid(),      "Invalid XEPALOBJ" );

    if (xpo.bIsBitfields())
    {
        flRed      = xpo.flRed();               // masks red bits
        cRedRight  = xpo.cRedRight();

        flGre      = xpo.flGre();               // masks green bits
        cGreRight  = xpo.cGreRight();

        flBlu      = xpo.flBlu();               // masks blu bits
        cBluRight  = xpo.cBluRight();
    }
    else if (xpo.bIsRGB())
    {
        // assuming 8+8+8
        flRed     = 0x0000ff;
        cRedRight = 0;
        flGre     = 0x00ff00;
        cGreRight = 8;
        flBlu     = 0xff0000;
        cBluRight = 16;
    }
    else if (xpo.bIsBGR())
    {
        // assuming 8+8+8
        flRed     = 0xff0000;
        cRedRight = 16;
        flGre     = 0x00ff00;
        cGreRight = 8;
        flBlu     = 0x0000ff;
        cBluRight = 0;
    }
    else
    {
        RIP("unsuported palette format\n");
    }
    uRedF      = (uF & flRed) >> cRedRight;
    flRedRight = flRed >> cRedRight;

    uGreF      = (uF & flGre) >> cGreRight;
    flGreRight = flGre >> cGreRight;

    uBluF      = (uF & flBlu) >> cBluRight;
    flBluRight = flBlu >> cBluRight;

#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "vSrcTranCopyS4D32(\n"
            "   PBYTE   pjSrcIn     = %-#x\n"
            "   LONG    SrcLeft     = %d\n"
            "   LONG    DeltaSrcIn  = %d\n"
            "   PBYTE   pjDstIn     = %-#x\n"
            "   LONG    DstLeft     = %d\n"
            "   LONG    DstRight    = %d\n"
            "   LONG    DeltaDstIn  = %d\n"
            "   LONG    cy          = %d\n"
            "   ULONG   uF          = %-#x\n"
            "   ULONG   uB          = %-#x\n"
            "   SURFACE *pS         = %-#x\n"
        ,   pjSrcIn
        ,   SrcLeft
        ,   DeltaSrcIn
        ,   pjDstIn
        ,   DstLeft
        ,   DstRight
        ,   DeltaDstIn
        ,   cy
        ,   uF
        ,   uB
        ,   pS
        );
        DbgPrint(
            "   flRed      = %-#x\n"
            "   cRedRight  = %d\n"
            "   uRedF      = %-#x\n"
            "   flRedRight = %-#x\n"
            , flRed, cRedRight, uRedF, flRedRight
        );
        DbgPrint(
            "   flGre      = %-#x\n"
            "   cGreRight  = %d\n"
            "   uGreF      = %-#x\n"
            "   flGreRight = %-#x\n"
            , flGre, cGreRight, uGreF, flGreRight
        );
        DbgPrint(
            "   flBlu      = %-#x\n"
            "   cBluRight  = %d\n"
            "   uBluF      = %-#x\n"
            "   flBluRight = %-#x\n"
            , flBlu, cBluRight, uBluF, flBluRight
        );
        DbgBreakPoint();
    }
#endif

/*****************************************************************************
*                                                                            *
*    The CCC macro blends forground and background colors of a single color  *
*    channel. Gamma correction is taken into account using an approximate    *
*    correction scheme. uB contains all three background colors. We first    *
*    mask off the bits of interest and then shift them down until the        *
*    least significant color bit resides at the lowest bit of the dword.     *
*    The answer is placed in uT ("temporary ULONG"). This must be done for   *
*    each pixel in the destination. The same thing has been done for the     *
*    each of the forground color channels and placed in uRedF, uGreF,        *
*    and uBluF. These values do not change from pixel to pixel and so the    *
*    calculation of these down shifted forground color channel values is     *
*    done up front before the loop. Then for each color channel we           *
*    calculate the difference between the down-shifted forground- and        *
*    background color channels and place the answer in dT ("temporary        *
*    difference"). The approximate gamma correction is done in the           *
*    following manner: If the background color value is smaller than         *
*    the foreground color value then the approximate correction is:          *
*                                                                            *
*        (c_f >= c_b):                                                       *
*                                                                            *
*              c = c_b + alpha_k ^ (1/gamma) * (c_f - c_b)                   *
*                                                                            *
*        (c_f <= c_b):                                                       *
*                                                                            *
*              c = c_b + (1 - (1 - alpha_k)^(1/gamma)) * (c_f - c_b)         *
*                                                                            *
*    where                                                                   *
*                                                                            *
*            c   := blended color                                            *
*            c_b := background color                                         *
*            c_f := foreground color                                         *
*            alpha_k := k'th blending fraction = k == 0 ? 0 : (k+1)/16;      *
*            gamma := 2.33                                                   *
*                                                                            *
*    I have storred all sixteen values of alpha_k ^ (1/gamma) in 16.16       *
*    representation in an array ULONG aulB[16] and I have storred the        *
*    values of 1 - (1 - alpha_k)^(1/gamma) in aulIB[k]                       *
*                                                                            *
*    Thus the blended color value is                                         *
*                                                                            *
*        (c_f >= c_b):                                                       *
*                                                                            *
*            c = (2^16 * c_b + aulB[k] * (c_f - c_b)) / 2^16                 *
*                                                                            *
*                                                                            *
*        (c_f <= c_b):                                                       *
*                                                                            *
*            c = (2^16 * c_b + aulB[15-k] * (c_f - c_b)) / 2^16              *
*    Instead of accessing aulB[15-k], I access aulIB which has               *
*    aulIB[k] = aulB[15-k]                                                   *
*    In the macro below, I actually blend the down-shifted color             *
*    channel values and then shift the answer up and mask it (the            *
*    mask shouldn't be necessary, but this is a precaution).                 *
*                                                                            *
*****************************************************************************/
#define CCC(Color,jj)                                                 \
    uT = (uB & fl##Color) >> c##Color##Right;                         \
    dT = u##Color##F - uT;                                            \
    aul = ((LONG) dT < 0) ? aulIB : aulB;                             \
    u |= (((dT * aul[jj] + (uT << 16)) >> 16) << c##Color##Right) & fl##Color

/******************************************************************************
*                                                                             *
*    The SETCOLOR macro looks at the blending value. If it is zero then       *
*    the destination pixel does not change and we do nothing. If the blending *
*    value is 15 then the destination pixel should take the forground color   *
*    , no blending is necessary. If the blending value is one of 1..14 then   *
*    all three color channels are blended and added together.                 *
*                                                                             *
******************************************************************************/

                    #define SETCOLOR(jj)    \
                    if (j = (jj))           \
                    {                       \
                        if (j == 15)        \
                        {                   \
                            u = uF;         \
                        }                   \
                        else                \
                        {                   \
                            u = 0;          \
                            uB = *pulDst;   \
                            CCC(Red,j);     \
                            CCC(Gre,j);     \
                            CCC(Blu,j);     \
                        }                   \
                        *pulDst = u;        \
                    }                       \
                    pulDst++

/************************************************************************
*                                                                       *
*    Each nyble of the source bitmap corresponds to 32 bits             *
*    in the destination bitmap. I have decided to arrange things        *
*    so that the inner most loop sets two pixels at a time. The         *
*    first of these two pixels starts on an even address in             *
*    the destination. After separating these 'aligned' pairs            *
*    in the middle of the scan there may be some left over              *
*    at the left (preamble) and the right (postamble). The              *
*    preamble can have at most one pixel in it. If there is             *
*    a pixel in the postamble then it correxponds to the                *
*    low nyble  of the source byte. If there is a pixel in              *
*    the postamble then it corresponds to the high nyble  of            *
*    the source byte. Each time, we have dealt with an odd              *
*    x-coordinate in the destination (corresponding to the              *
*    low nyble  in the source byte) we advance the source pointer       *
*    to the next byte.                                                  *
*                                                                       *
************************************************************************/

    A          = (DstLeft + 1) & ~1; // nearest multiple of 2 left of left edge
    B          = (DstRight   ) & ~1; // nearest multiple of 2 right of right edge
    cPreamble  = A - DstLeft;        // # pixels in preamble
    cMiddle    = (B - A)/2;          // # pixels in middle
    cPostamble = DstRight - B;       // # pixels in postamble
    pjSrcIn   += SrcLeft / 2;        // points to first source byte
    pjDstIn   += DstLeft * sizeof(ULONG);   // points to first dst DWORD
    for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
    {
        int i;
        BYTE jSrc;
        BYTE *pjSrc = pjSrcIn;
        ULONG *pulDst  = (ULONG*) pjDstIn;

        if (cPreamble)
        {
            SETCOLOR(*pjSrc & 15);
            pjSrc++;
        }
        for (i = 0; i < cMiddle; i++)
        {
            jSrc = *pjSrc;
            SETCOLOR(jSrc >> 4);
            SETCOLOR(jSrc & 15);
            pjSrc++;
        }
        if (cPostamble)
        {
            SETCOLOR(*pjSrc >> 4);
        }
    }
#undef SETCOLOR
#undef CCC
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   vOrNonAlignedGrayGlyphEven                                             *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Writes the a single gray glyph to a 4bpp buffer. This is for the       *
*   special case where the destination starts on a non byte (nyble )       *
*   boundary and the glyph images is an even number of pixels wide.        *
*                                                                          *
*   The source gray pixel image is guaranteed to have its initial scan     *
*   start on a 32-bit boundary, all subsequent scans start on byte         *
*   boundaries.                                                            *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pgb         - address of gray GLYPHBITS structure                      *
*   dpSrcScan   - number of bytes between address of start of glyph scans  *
*   pjDstScan   - starting address of glyph image in destination buffer    *
*   dpDstScan   - increment between scan addresses in destination buffer   *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

void
vOrNonAlignedGrayGlyphEven(
    GLYPHBITS*  pgb      ,
    unsigned    dpSrcScan,
    BYTE*       pjDstScan,
    unsigned    dpDstScan
    )
{
/*
       0     1     2     3     4  <-- byte number
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |n  n |n  n |n  n |n  n |n  n |     |     |     |
    | 1  0| 3  2| 5  4| 7  6| 9  8|     |     |     |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    ^                        ^  ^
    pjSrc                   Hi  Lo


       0     1     2     3     4     5  <-- byte number
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |   n |n  n |n  n |n  n |n  n |n    |     |     |
    |    1| 0  3| 2  5| 4  7| 6  9| 8   |     |     |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    ^                             ^
    pjDst                         pjDstLast

*/
#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "void\n"
            "vOrNonAlignedGrayGlyphEven(\n"
            "    GLYPHBITS*  pgb       = %-#x\n"
            "    unsigned    dpSrcScan = %-#x\n"
            "    BYTE*       pjDstScan = %-#x\n"
            "    unsigned    dpDstScan = %-#x\n"
            "    )\n"
          , pgb
          , dpSrcScan
          , pjDstScan
          , dpDstScan
        );
        DbgBreakPoint();
    }
#endif
    BYTE jLo, jHi, *pjSrc, *pjDst, *pjSrcOut, *pjDstScanOut;

    dpSrcScan    = (pgb->sizlBitmap.cx + 1)/2;
    pjSrcOut     = pgb->aj;
    pjDstScanOut = pjDstScan + ((unsigned) pgb->sizlBitmap.cy) * dpDstScan;
    for ( ; pjDstScan < pjDstScanOut ; pjDstScan += dpDstScan)
    {
        pjSrc      = pjSrcOut;
        pjSrcOut  += dpSrcScan;
        for (jLo = 0, pjDst = pjDstScan; pjSrc < pjSrcOut; )
        {
            jHi = *pjSrc++;
            *pjDst++ |= (jLo << 4) + (jHi >> 4);
            jLo = jHi;
        }
        *pjDst |= (jLo << 4);
    }
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   vOrNonAlignedGrayGlyphOdd                                              *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Writes the a single gray glyph to a 4bpp buffer. This is for the       *
*   special case where the destination starts on a non byte (nyble )       *
*   boundary and the glyph images is an odd number of pixels wide.         *
*                                                                          *
*   The source gray pixel image is guaranteed to have its initial scan     *
*   start on a 32-bit boundary, all subsequent scans start on byte         *
*   boundaries.                                                            *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pgb         - address of gray GLYPHBITS structure                      *
*   dpSrcScan   - number of bytes between address of start of glyph scans  *
*   pjDstScan   - starting address of glyph image in destination buffer    *
*   dpDstScan   - increment between scan addresses in destination buffer   *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

void
vOrNonAlignedGrayGlyphOdd(
    GLYPHBITS*  pgb      ,
    unsigned    dpSrcScan,
    BYTE*       pjDstScan,
    unsigned    dpDstScan
    )
{
/*
       0     1     2     3     4  <-- byte number
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |n  n |n  n |n  n |n  n |n    |     |     |     |
    | 1  0| 3  2| 5  4| 7  6| 9   |     |     |     |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    ^                        ^  ^
    pjSrc                   Hi  Lo


       0     1     2     3     4     5  <-- byte number
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |   n |n  n |n  n |n  n |n  n |     |     |     |
    |    1| 0  3| 2  5| 4  7| 6  9|     |     |     |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    ^                             ^
    pjDst                         pjDstLast

*/

    BYTE j1, j0, *pjDst, *pjSrc, *pjDstLast, *pjDstScanOut;
    unsigned cy        = (unsigned) pgb->sizlBitmap.cy;
    unsigned cx        = (unsigned) pgb->sizlBitmap.cx / 2;
    BYTE    *pjSrcScan = &(pgb->aj[0]);
#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "void\n"
            "vOrNonAlignedGrayGlyphOdd(\n"
            "    GLYPHBITS*  pgb       = %-#x\n"
            "    unsigned    dpSrcScan = %-#x\n"
            "    BYTE*       pjDstScan = %-#x\n"
            "    unsigned    dpDstScan = %-#x\n"
            "    )\n"
          , pgb
          , dpSrcScan
          , pjDstScan
          , dpDstScan
        );
        DbgBreakPoint();
    }
#endif
    for (
        pjDstScanOut = pjDstScan + cy * dpDstScan
      ; pjDstScan < pjDstScanOut
      ; pjDstScan += dpDstScan, pjSrcScan += dpSrcScan
      )
    {
        //
        // set the source and destination pointers to point to the
        // start of the scans
        //

        pjSrc = pjSrcScan;
        pjDst = pjDstScan;

        //
        // do the first pixel in the scan
        //

        j1 = *pjSrc;
        *pjDst |= (j1 >> 4) & 0x0f;

        //
        // advance the pointers to the next pixel in the scans
        //

        pjSrc++;
        pjDst++;

        //
        // do the rest of the pixels in the scan
        //

        for (
            pjDstLast = pjDst + cx
          ; pjDst < pjDstLast
          ; pjDst++, pjSrc++
          )
        {
            j0 = j1;
            j1 = *pjSrc;
            *pjDst |= ((j1 >> 4) & 0x0f) | ((j0 << 4) & 0xf0);
        }

        //
        // last pixel in the scan has already been done
        //
    }
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   vOrAlignedGrayGlyphEven                                                *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Writes the a single gray glyph to a 4bpp buffer. This is for the       *
*   special case where the destination starts on a byte aligned boundary   *
*   and the glyph is an even number of pixels wide.                        *
*                                                                          *
*   This routine can be used for glyphs with odd widths.                   *
*                                                                          *
*   The source gray pixel image is guaranteed to have its initial scan     *
*   start on a 32-bit boundary, all subsequent scans start on byte         *
*   boundaries.                                                            *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pgb         - address of gray GLYPHBITS structure                      *
*   dpSrcScan   - number of bytes between address of start of glyph scans  *
*   pjDstScan   - starting address of glyph image in destination buffer    *
*   dpDstScan   - increment between scan addresses in destination buffer   *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

void
vOrAlignedGrayGlyphEven(
    GLYPHBITS*  pgb      ,
    unsigned    dpSrcScan,
    BYTE*       pjDstScan,
    unsigned    dpDstScan
    )
{
/*
       0     1     2     3     4  <-- byte number
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |n  n |n  n |n  n |n  n |n  n |     |     |     |
    | 1  0| 3  2| 5  4| 7  6| 9  8|     |     |     |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    ^                        ^  ^
    pjSrc                   Hi  Lo

       0     1     2     3     4  <-- byte number
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |n  n |n  n |n  n |n  n |n  n |     |     |     |
    | 1  0| 3  2| 5  4| 7  6| 9  8|     |     |     |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    ^                             ^
    pjDst                         pjDstOut

    Note that this routine will also work for source
    glyphs with an odd number of pixels because
    the source glyph is padded with zeros. This means
    that for the case of odd length scans the last
    byte is or'ed into the destination but the
    extra nyble  of the source is guaranteed to have
    the value zero and thus has no effect.

*/

    BYTE *pjDst, *pjSrc, *pjDstOut, *pjDstScanOut;
    unsigned cy        = (unsigned) pgb->sizlBitmap.cy;

    // I round cx up to the nearest byte. This makes no
    // difference for glyphs of even width but it will
    // get that last column for glyphs with odd width.

    unsigned cx        = (unsigned) (pgb->sizlBitmap.cx+1) / 2;
    BYTE    *pjSrcScan = &(pgb->aj[0]);

#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "void\n"
            "vOrAlignedGrayGlyphEven(\n"
            "    GLYPHBITS*  pgb       = %-#x\n"
            "    unsigned    dpSrcScan = %-#x\n"
            "    BYTE*       pjDstScan = %-#x\n"
            "    unsigned    dpDstScan = %-#x\n"
            "    )\n"
          , pgb
          , dpSrcScan
          , pjDstScan
          , dpDstScan
        );
        DbgBreakPoint();
    }
#endif
    for (
        pjDstScanOut = pjDstScan + cy * dpDstScan
      ; pjDstScan < pjDstScanOut
      ; pjDstScan += dpDstScan, pjSrcScan += dpSrcScan
      )
    {
        pjSrc = pjSrcScan;
        pjDst = pjDstScan;
        for (pjDstOut = pjDst + cx ; pjDst < pjDstOut; pjDst++, pjSrc++)
        {
            *pjDst |= *pjSrc;
        }
    }
}

void (*(apfnGray[4]))(GLYPHBITS*, unsigned, BYTE*, unsigned) =
{
    vOrAlignedGrayGlyphEven
  , vOrAlignedGrayGlyphEven         // can handle odd width glyphs
  , vOrNonAlignedGrayGlyphEven
  , vOrNonAlignedGrayGlyphOdd
};

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   draw_gray_nf_ntb_o_to_temp_start                                       *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Assembles a gray glyph string into a temporary 4bpp right and left     *
*   DWORD aligned buffer. This routine assumes a variable pitch font.      *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pGlyphPos  - pointer to an array of cGlyph gray GLYPHPOS structures    *
*   cGlyphs    - count of gray glyphs in array starting at pGlyphPos       *
*   pjDst      - pointer to a 4bpp buffer where string is to be assembled  *
*                This buffer is DWORD aligned at the left and right        *
*                edges of each scan.                                       *
*   ulLeftEdge - screen coordinate corresponding to the left edge of       *
*                the temporary buffer                                      *
*   dpDst      - count of bytes in each scan of the destination buffer     *
*                (this must be a multiple of 4 because the buffer is       *
*                 DWORD aligned on each scan).                             *
*   ulCharInc  - This must be zero.                                        *
*   ulTempTop  - screen coordinate corresponding to the top of the         *
*                destination buffer. This is used to convert the           *
*                glyph positions on the screen to addresses in the         *
*                destination bitmap.                                       *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

extern "C" VOID draw_gray_nf_ntb_o_to_temp_start(
    PGLYPHPOS       pGlyphPos,
    ULONG           cGlyphs,
    PUCHAR          pjDst,
    ULONG           ulLeftEdge,
    ULONG           dpDst,
    ULONG           ulCharInc,
    ULONG           ulTempTop
    )
{
    GLYPHBITS     *pgb;        // pointer to current GLYPHBITS

    int            x;          // pixel offset of the
                               // left edge of the glyph bitmap
                               // from the left edge of the
                               // output (4-bpp) bitmap

    int            y;          // the pixel offset of the top edge
                               // of the glyph bitmap from the top
                               // edge of the output bitmap.

    unsigned       bOddPos;    // (x-coordinate is odd) ? 1 : 0

    unsigned       cx;         // number of pixels per glyph scan
                               // If non zero then the destination
                               // bitmap is out of alignment with
                               // the source glyph by a one nyble
                               // shift and a single byte of the
                               // source will affect two consecutive
                               // bytes of the destination.

    unsigned       dpSrc;      // number of bytes per source scan. Each
                               // scan is BYTE aligned.
                               // = ceil(4*cx/8) = floor((cx+1)/2)

    GLYPHPOS      *pgpOut;     // sentinel for loop

    BYTE          *pj;         // pointer into Buffer corresponding
                               // to the upper left pixel of the
                               // current gray glyph
    pj = pjDst;
    for (pgpOut = pGlyphPos + cGlyphs; pGlyphPos < pgpOut; pGlyphPos++)
    {
        pgb         = pGlyphPos->pgdf->pgb;
        x           = pGlyphPos->ptl.x + pgb->ptlOrigin.x - ulLeftEdge;
        y           = pGlyphPos->ptl.y + pgb->ptlOrigin.y - ulTempTop ;
        bOddPos     = (unsigned) x & 1;
        cx          = (unsigned) pgb->sizlBitmap.cx;
        dpSrc       = (cx + 1)/2;
        pj          = pjDst + (y * dpDst) + (x/2);
        (*(apfnGray[(cx & 1) + 2*bOddPos]))(pgb, dpSrc, pj, dpDst);
    }
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   draw_gray_f_ntb_o_to_temp_start                                        *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Assembles a gray glyph string into a temporary 4bpp right and left     *
*   DWORD aligned buffer. This routine assumes a fixed pitch font with     *
*   character increment equal to ulCharInc                                 *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pGlyphPos  - pointer to an array of cGlyph gray GLYPHPOS structures    *
*   cGlyphs    - count of gray glyphs in array starting at pGlyphPos       *
*   pjDst      - pointer to a 4bpp buffer where string is to be assembled  *
*                This buffer is DWORD aligned at the left and right        *
*                edges of each scan.                                       *
*   ulLeftEdge - screen coordinate corresponding to the left edge of       *
*                the temporary buffer                                      *
*   dpDst      - count of bytes in each scan of the destination buffer     *
*                (this must be a multiple of 4 because the buffer is       *
*                 DWORD aligned on each scan).                             *
*   ulCharInc  - This must be zero.                                        *
*   ulTempTop  - screen coordinate corresponding to the top of the         *
*                destination buffer. This is used to convert the           *
*                glyph positions on the screen to addresses in the         *
*                destination bitmap.                                       *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

extern "C" VOID draw_gray_f_ntb_o_to_temp_start(
    PGLYPHPOS       pGlyphPos,
    ULONG           cGlyphs,
    PUCHAR          pjDst,
    ULONG           ulLeftEdge,
    ULONG           dpDst,
    ULONG           ulCharInc,
    ULONG           ulTempTop
    )
{
    GLYPHBITS     *pgb;        // pointer to current GLYPHBITS

    int            x;          // x-coordinate of the current
                               // character origin with respect
                               // to the upper left pixel of the
                               // output (4-bpp) bitmap

    int            y;          // y-coordinate of the current
                               // character origin with respect
                               // to the upper left pixel of the
                               // output (4-bpp) bitmap

    unsigned       bOddPos;    // (x-coordinate is odd) ? 1 : 0

    unsigned       cx;         // number of pixels per glyph scan
                               // If non zero then the destination
                               // bitmap is out of alignment with
                               // the source glyph by a one nyble
                               // shift and a single byte of the
                               // source will affect two consecutive
                               // bytes of the destination.

    unsigned       dpSrc;      // number of bytes per source scan. Each
                               // scan is BYTE aligned.
                               // = ceil(4*cx/8) = floor((cx+1)/2)

    GLYPHPOS      *pgpOut;     // sentinel for loop

    BYTE          *pj;         // pointer into Buffer corresponding
                               // to the upper left pixel of the
                               // current gray glyph
#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
        "draw_gray_f_ntb_o_to_temp_start(\n"
        "   PGLYPHPOS       pGlyphPos     = %-#x\n"
        "   ULONG           cGlyphs       = %u\n"
        "   PUCHAR          pjDst         = %-#x\n"
        "   ULONG           ulLeftEdge    = %u\n"
        "   ULONG           dpDst         = %u\n"
        "   ULONG           ulCharInc     = %u\n"
        "   ULONG           ulTempTop     = %u\n"
        "   )\n"
        , pGlyphPos
        , cGlyphs
        , pjDst
        , ulLeftEdge
        , dpDst
        , ulCharInc
        , ulTempTop
        );
        DbgBreakPoint();
    }
#endif

    // (x,y) = position of first CHARACTER ORIGIN with respect to
    //         the upper left pixel of the destination 4bpp bitmap

    x  = pGlyphPos->ptl.x - ulLeftEdge;
    y  = pGlyphPos->ptl.y - ulTempTop;

    for (pgpOut = pGlyphPos + cGlyphs; pGlyphPos < pgpOut; x += ulCharInc, pGlyphPos++)
    {
        int xT, yT; // position of UPPER LEFT pixel of glyph
                    // with respect to the upper left pixel
                    // of the bitmap.

        pgb         = pGlyphPos->pgdf->pgb;
        xT          = x + pgb->ptlOrigin.x;
        yT          = y + pgb->ptlOrigin.y;
        bOddPos     = (unsigned) xT & 1;
        cx          = (unsigned) pgb->sizlBitmap.cx;
        dpSrc       = (cx + 1)/2;
        pj          = pjDst + (yT * dpDst) + (xT/2);

#if DBG
        if (gflFontDebug & DEBUG_AA)
        {
            DbgPrint(
            "\n"
            "   pgb     = %-#x\n"
            "       ptlOrigin = (%d,%d)\n"
            "   xT      = %d\n"
            "   yT      = %d\n"
            "   bOddPos = %d\n"
            , pgb
            , pgb->ptlOrigin.x
            , pgb->ptlOrigin.y
            , xT
            , yT
            , bOddPos
            );
            DbgPrint(
            "   cx      = %u\n"
            "   dpSrc   = %u\n"
            "   pj      = %-#x\n"
            "   (cx & 1) + 2*bOddPos = %d\n"
            , cx
            , dpSrc
            , pj
            , (cx & 1) + 2*bOddPos
            );
            DbgBreakPoint();
        }
#endif
        (*(apfnGray[(cx & 1) + 2*bOddPos]))(pgb, dpSrc, pj, dpDst);
    }
}


#if DBG
/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   vDumpGrayBuffer                                                        *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Debug routine for dumping the temporary 4bpp gray string buffer        *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pjBuffer - pointer to gray 4bpp image                                  *
*   dpjScan  - count of bytes per scan                                     *
*   prcl     - rectangle surrounding 4bpp gray image                       *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

void vDumpGrayBuffer(BYTE *pjBuffer, ULONG dpjScan, RECTL *prcl)
{
    BYTE *pj, *pjNext, *pjOut;
    static char achNyble[16] = {
        ' ','1','2','3','4','5','6','7'
       ,'8','9','a','b','c','d','e','f'
    };
    DbgPrint(
        "vDumpGrayBuffer(\n"
        "    pjBuffer = %-#x\n"
        "    dpjScan  = %u\n"
        "    prcl     = %-#x ==> %d %d %d %d\n"
        ")\n"
    ,   pjBuffer
    ,   dpjScan
    ,   prcl
    ,   prcl->left, prcl->top, prcl->right, prcl->bottom
    );
    DbgPrint("+");
    for (ULONG i = 0; i < dpjScan; i++)
        DbgPrint("--");
    DbgPrint("+\n");
    pjOut = pjBuffer + dpjScan * (prcl->bottom - prcl->top);
    for (pj = pjBuffer; pj < pjOut;) {
        DbgPrint("|");
        for (pjNext = pj + dpjScan; pj < pjNext; pj++)
            DbgPrint("%c%c", achNyble[*pj >> 4], achNyble[*pj & 15]);
        DbgPrint("|\n");
    }
    DbgPrint("+");
    for (i = 0; i < dpjScan; i++)
        DbgPrint("--");
    DbgPrint("+\n");
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   vPrintGrayGLYPHBITS                                                    *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Dumps Gray GLYPHBITS to the debug screen                               *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pgb - pointer to a gray GLYPHBITS structure                            *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   none                                                                   *
*                                                                          *
\**************************************************************************/

void vPrintGrayGLYPHBITS(GLYPHBITS *pgb)
{
    BYTE *pj, *pjNext, *pjEnd;
    ptrdiff_t cjScan, i;
    static char achNyble[16] =
    {' ','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};

    DbgPrint(
        "Gray GLYPHBITS at   = %-#x\n"
        "    ptlOrigin  = %d %d\n"
        "    sizlBitmap = %u %u\n"
    ,   pgb
    ,   pgb->ptlOrigin.x
    ,   pgb->ptlOrigin.y
    ,   pgb->sizlBitmap.cx
    ,   pgb->sizlBitmap.cy
    );
    pj     = pgb->aj;
    cjScan = ((ptrdiff_t) pgb->sizlBitmap.cx + 1)/2;
    pjNext = pj + cjScan;
    pjEnd  = pj + cjScan * (ptrdiff_t) pgb->sizlBitmap.cy;
    DbgPrint("+");
    for (i = 0; i < cjScan; i++)
        DbgPrint("--");
    DbgPrint("+\n");
    while (pj < pjEnd) {
        DbgPrint("|");
        while (pj < pjNext) {
            DbgPrint("%c%c" , achNyble[*pj >> 4], achNyble[*pj & 0xf]);
            pj += 1;
        }
        pj = pjNext;
        pjNext += cjScan;
        DbgPrint("|\n");
    }
    DbgPrint("+");
    for (i = 0; i < cjScan; i++)
        DbgPrint("--");
    DbgPrint("+\n\n");
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   vPrintGrayGLYPHPOS                                                     *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Dumps the contents of a Gray GLYPHPOS structure to the                 *
*   debugger.                                                              *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pgpos - a pointer to a gray GLYPHPOS structure                         *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   none                                                                   *
*                                                                          *
\**************************************************************************/

void vPrintGrayGLYPHPOS(GLYPHPOS *pgpos)
{
    DbgPrint("Gray GLYPHPOS at %-#x\n",   pgpos);
    DbgPrint("    hg   = %-#x\n",    pgpos->hg);
    DbgPrint("    pgdf = %-#x\n",    pgpos->pgdf);
    DbgPrint("    ptl  = (%d,%d)\n", pgpos->ptl.x, pgpos->ptl.y);
    // vPrintGrayGLYPHBITS(pgpos->pgdf->pgb);
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   vDump8bppDIB                                                           *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Dumps an 8bpp DIB to the screen. This routine only recognizes the      *
*   four canonical shades of gray, all other colors are marked with        *
*   a question mark                                                        *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   SURFMEM reference.                                                     *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   none                                                                   *
*                                                                          *
\**************************************************************************/

void vDump8bppDIB(SURFMEM& surfmem)
{
    char ch;
    int j;
    BYTE *pjScan, *pj, *pjOut;
    ULONG dpjScan;
    SURFOBJ *pso = surfmem.pSurfobj();

    DbgPrint("Dumping the contents of the 8bpp DIB\n");
    pso = surfmem.pSurfobj();
    pjScan  = (BYTE*) pso->pvBits;
    dpjScan = 4 * ((pso->sizlBitmap.cx + 3) / 4);
    DbgPrint("+");
    for (j = 0; j < pso->sizlBitmap.cx; j++)
    {
        DbgPrint("-");
    }
    DbgPrint("+\n");
    for (j = pso->sizlBitmap.cy; j; j--)
    {
        pj     = pjScan;
        pjOut  = pjScan + pso->sizlBitmap.cx;
        pjScan += dpjScan;
        DbgPrint("|");
        while (pj < pjOut)
        {
            switch (*pj++)
            {
            case   0:   ch = ' '; break;
            case 248:   ch = '+'; break;
            case   7:   ch = '*'; break;
            case 255:   ch = '#'; break;
            default:    ch = '?'; break;
            }
            DbgPrint("%c",ch);
        }
        DbgPrint("|\n");
    }
    DbgPrint("+");
    for (j = 0; j < pso->sizlBitmap.cx; j++)
    {
        DbgPrint("-");
    }
    DbgPrint("+\n");
}
#endif


// make them global for now, easier to debug

ULONG  aulCacheCT[CT_LOOKUP];
HANDLE hCacheCT;
ULONG  uFCacheCT;
ULONG  uBCacheCT;
ULONG  sizeCacheCT;
ULONG  uGammaCacheCT;


VOID vGetBlendInfo (
    ULONG size, SURFACE *pS,            // input
    ULONG uF,                           // foreground color
    BLENDINFO  *pbi                     // output
);



VOID *pvFillOpaqTableCT(
    ULONG      size,
    ULONG      uF,
    ULONG      uB,
    SURFACE   *pS,
    BLENDINFO *pbi,         // must NOT be NULL
    BOOL       bTransparent // in transparent case we must compute bi info,
    );                      // in opaque case do not need to
                            // if the table is up to date


VOID vClearTypeLookupTableLoop(
    ULONG       size,
    SURFACE    *pS,
    BLENDINFO  *pbi,
    ULONG       uF,
    ULONG       uB
)
{
// this can not fail, store the new info

    sizeCacheCT = size;
    uFCacheCT   = uF;
    uBCacheCT   = uB;
    uGammaCacheCT = gulGamma;
    hCacheCT    = pS->hGet();

    ULONG  *pul =           aulCacheCT;
    USHORT *pus = (USHORT*) aulCacheCT;
    ULONG   ul;

    LONG dRedB, dGreB, dBluB; // precompute the diffs outside of the loop
    LONG lRedB, lGreB, lBluB; // precompute outside of the loop

    lRedB  = pbi->pjGamma[((((uB & pbi->flRed) << pbi->iRedL) >> pbi->iRedR) & 255)];
    lGreB  = pbi->pjGamma[((((uB & pbi->flGre) << pbi->iGreL) >> pbi->iGreR) & 255)];
    lBluB  = pbi->pjGamma[((((uB & pbi->flBlu) << pbi->iBluL) >> pbi->iBluR) & 255)];

    dRedB = pbi->lRedF - lRedB;
    dGreB = pbi->lGreF - lGreB;
    dBluB = pbi->lBluF - lBluB;

// the first and last entries are set outside the loop, for perf reasons

    ULONG iTable;
    const F_RGB *pfrgb;

    for
    (
         iTable = 1, pfrgb = &gaOutTable[1];
         iTable < (CT_LOOKUP-1);
         iTable++, pfrgb++
    )
    {
      ULONG ulRT, ulGT, ulBT;

      ulRT = BLENDCT(pfrgb->kR, pbi->lRedF, lRedB, dRedB);
      ulGT = BLENDCT(pfrgb->kG, pbi->lGreF, lGreB, dGreB);
      ulBT = BLENDCT(pfrgb->kB, pbi->lBluF, lBluB, dBluB);

      ASSERTGDI(((ulRT | ulGT | ulBT) & 0xffffff00) == 0,
          "lookup table computation!!!\n");

      ulRT = pbi->pjGammaInv[ulRT];
      ulGT = pbi->pjGammaInv[ulGT];
      ulBT = pbi->pjGammaInv[ulBT];

      ul  = (((ulRT << pbi->iRedR) >> pbi->iRedL) & pbi->flRed);
      ul |= (((ulGT << pbi->iGreR) >> pbi->iGreL) & pbi->flGre);
      ul |= (((ulBT << pbi->iBluR) >> pbi->iBluL) & pbi->flBlu);

      if (size == sizeof(USHORT))
          pus[iTable] = (USHORT)ul;
      else
          pul[iTable] = ul;
    }

    // make sure that blending and gamma correcting did not mess up
    // backgroung and foreground pixels. (not sure that the round trip
    // is guarranteed)

    if (size == sizeof(USHORT))
    {
        pus[0]           = (USHORT)uB; // set the first value to background:
        pus[CT_LOOKUP-1] = (USHORT)uF; // set the last value to foreground
    }
    else
    {
        pul[0]           = uB; // set the first value to background:
        pul[CT_LOOKUP-1] = uF; // set the last value to foreground
    }
}




/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcOpaqCopyS8D16                                                      *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - right(last) dst pixel                                    *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color                                         *
*    uB         - Background color                                         *
*    pS         - pointer to destination SURFACE                           *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

VOID
vSrcOpaqCopyS8D16(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{

    USHORT *aus;
    ULONG   cusDst = DstRight - DstLeft;
    BLENDINFO bi;
    SEMOBJ so(ghsemEUDC2);

    aus = (USHORT*) pvFillOpaqTableCT(sizeof(*aus), uF, uB, pS, &bi, FALSE);
    pjSrcIn   += SrcLeft;
    pjDstIn   += DstLeft * sizeof(USHORT);

    for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
    {
        BYTE   *pjSrc = pjSrcIn;
        USHORT *pusDst = (USHORT*) pjDstIn;
        USHORT *pusDstEnd = pusDst + cusDst;

        for ( ; pusDst < pusDstEnd; pusDst++, pjSrc++)
        {
            *pusDst = aus[*pjSrc];
        }
    }
}


static
ULONG FASTCALL ulBlendPixelCT(BLENDINFO *pbi, ULONG uB, const F_RGB *pfrgb)
{
    ULONG ulRet, ulT;
    LONG  lB, dB;

// shift as ULONG's, store as LONG's.

    lB = pbi->pjGamma[((((uB & pbi->flRed) << pbi->iRedL) >> pbi->iRedR) & 255)];
    dB = pbi->lRedF - lB;
    ulT = BLENDCT(pfrgb->kR, pbi->lRedF, lB, dB);
    ulT = pbi->pjGammaInv[ulT];
    ulRet  = (((ulT << pbi->iRedR) >> pbi->iRedL) & pbi->flRed);

    lB = pbi->pjGamma[((((uB & pbi->flGre) << pbi->iGreL) >> pbi->iGreR) & 255)];
    dB = pbi->lGreF - lB;
    ulT = BLENDCT(pfrgb->kG, pbi->lGreF, lB, dB);
    ulT = pbi->pjGammaInv[ulT];
    ulRet |= (((ulT << pbi->iGreR) >> pbi->iGreL) & pbi->flGre);

    lB = pbi->pjGamma[((((uB & pbi->flBlu) << pbi->iBluL) >> pbi->iBluR) & 255)];
    dB = pbi->lBluF - lB;
    ulT = BLENDCT(pfrgb->kB, pbi->lBluF, lB, dB);
    ulT = pbi->pjGammaInv[ulT];
    ulRet |= (((ulT << pbi->iBluR) >> pbi->iBluL) & pbi->flBlu);

    return ulRet;
}


VOID
vSrcTranCopyS8D16New(
    PBYTE               pjSrcIn,
    LONG                SrcLeft,
    LONG                DeltaSrcIn,
    PBYTE               pjDstIn,
    LONG                DstLeft,
    LONG                DstRight,
    LONG                DeltaDstIn,
    LONG                cy,
    ULONG               uF,
    ULONG               uB,
    SURFACE             *pS,
    FNCOPYALPHABUFFER   *pfnCopyAlphaBuffer,
    PBYTE               pjCopyBuffer
    )
{
    USHORT *aus = NULL;  // points to lookup table
    LONG   cusDst = (LONG)(DstRight - DstLeft);
    BLENDINFO bi;
    ULONG   uB0;  // background pixel in the upper left corner
    SEMOBJ so(ghsemEUDC2);

    pjSrcIn   += SrcLeft;
    pjDstIn   += DstLeft * sizeof(USHORT);

// take the hit, hoping the background will not be variable

    uB0 = uB = *((USHORT *)pjDstIn);
    aus = (USHORT *)pvFillOpaqTableCT(sizeof(USHORT), uF, uB, pS, &bi, TRUE);

    for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
    {
        BYTE   *pjSrc = pjSrcIn;
        USHORT *pusDst = (USHORT*) pjDstIn;
        LONG    cx = cusDst;
        USHORT *pusDstNew;

    // copy dst to the temp buffer according to alpha information

        (*pfnCopyAlphaBuffer)(pjSrc, pjDstIn, pjCopyBuffer, cusDst, &pusDstNew);

        for ( ; cx; cx--, pusDst++, pjSrc++, pusDstNew++)
        {
        // if *pjSrc == 0, we do not touch the destination, therefore
        // we do not need to READ the destination and do not need to blend.
        // This is about 68% of the pixels in winstone scenario.
        // Likewise, if *pjSrc == max_index (ie pure foreground), READ
        // operation is not necessary, the only thing we do is WRITE of the
        // foreground to the destination,

            ULONG kSrc = *pjSrc;

            if (kSrc)
            {
                uB = *pusDstNew; // no hit any more on the read

                if (uB == uB0)   // 25% of the pixels in winstone
                {
                    *pusDst = aus[kSrc]; // background did not change, lucky
                }
                else if (kSrc == (CT_LOOKUP-1)) // 5% of the pixels in winstone
                {
                    *pusDst = (USHORT)uF;
                }
                else // auch, must blend, fortunately only 2% on winstone
                {
                    *pusDst = (USHORT)ulBlendPixelCT(&bi, uB, &gaOutTable[kSrc]);
                }
            }
        }
    }
}



/******************************Public*Routine******************************\
*                                                                          
* Routine Name                                                             
*                                                                          
*   vCopyAlphaBuffer16bpp                                                  
*                                                                          
* Routine Description:                                                     
*
*   This routine copies from 'pjSrc' to 'pjDst' the portions needed for
*   doing blended, as specified by the 'pjAlpha' alpha buffer.  
*
*   The motivation for this routine is that reads from video memory are
*   performance killers, and we want to do reads only where we absolutely
*   need to.  
*
*   I have observed that consecutive word reads from video memory are
*   typically about 4 MB/s on AGP systems; consecutive dword reads are
*   typically about 8 MB/s.
*
*   This is done as the first pass in the blend operation, in order to
*   get all the reads done first for all the read-modify-write operations
*   implicit in a blend.  We very carefully pay attention to the blend
*   buffer we'll be using later to read only those pixels that we'll
*   need.
*
*   We get 2 benefits:
*
*   1. It's easy to combine reads into dword reads.  If we need both
*      pixels in a dword, it's twice as fast to do a single dword read
*      as it is to do 2 consecutive word reads.
*   2. We enable the write portion to be all write-combined, which wouldn't
*      be true if we were doing read-modify-write on a pixel by pixel basis.
*
*                                                                          
* Arguments:                                                               
*                                                                          
*    pjAlpha    - alpha buffer that is actually the source in the blend
*                 operation; this tells us what pixels we'll need to read
*                 from the destination of the blend operation
*    pjSrc      - actually points to the destination of the blend operation
*    pjDst      - points to where we'll store our temporary copy of the
*                 destination of the blend operation
*    cx         - number of pixels to read
*                                                                          
* Return Value:                                                            
*                                                                          
*   None                                                                   
*                                                                          
\**************************************************************************/

// This macro returns TRUE if the specified alpha value is either 
// completely transparent or completely opaque.  In either case, we
// don't actually need to read the destination.
//
// NOTE: For reasons that escape me, the compiler required casts to
//       'unsigned' even though all the parameters were unsigned.

#define TRANSLUCENT(a) ((UCHAR) ((a) - 1) < (CT_LOOKUP - 2))

VOID
vCopyAlphaBuffer16bpp(
    PBYTE   pjAlpha,
    PBYTE   pjSrc,
    PBYTE   pjDst,
    LONG    cx,
    PUSHORT *ppusDstNew
    )
{
    ULONG cj = (ULONG)(((ULONG_PTR) pjSrc) & 3);
    pjDst += cj;
    *ppusDstNew = (USHORT*)pjDst;

    if (((ULONG_PTR) pjSrc) & 2) 
    {
        if (TRANSLUCENT(pjAlpha[0]))
        {
            *((USHORT*) pjDst) = *((USHORT*) pjSrc);
        }
        pjSrc += 2;
        pjDst += 2;
        pjAlpha++;
        cx--;
    }

    while (TRUE)
    {
        cx -= 2;
        if (cx < 0)
            break;

        if (TRANSLUCENT(pjAlpha[0]) || TRANSLUCENT(pjAlpha[1]))
        {
            *((ULONG*) pjDst) = *((ULONG*) pjSrc);
        }
        pjSrc += 4;
        pjDst += 4;
        pjAlpha += 2;
    }
    if (cx & 1)
    {
        if (TRANSLUCENT(pjAlpha[0]))
        {
            *((USHORT*) pjDst) = *((USHORT*) pjSrc);
        }
    }
}


/******************************Public*Routine******************************\
*                                                                          
* Routine Name                                                             
*                                                                          
*   vCopyAlphaBuffer16bppMMX                                                  
*                                                                          
* Routine Description:                                                     
*
*   This routine works the same as 'vCopyAlphaBuffer16bpp', except that
*   it will take advantage of MMX 64-bit operations to improve the read
*   speed even more.  
*
*   I have observed that consecutive dword reads from video memory are
*   typically about 8 MB/s on AGP systems; consecutive qword reads are
*   typically about 11 MB/s.  
*
*   IMPORTANT NOTE: The floating point state is expected to have already
*                   been saved!  
*                                                                          
* Arguments:                                                               
*                                                                          
*    pjAlpha    - alpha buffer that is actually the source in the blend
*                 operation; this tells us what pixels we'll need to read
*                 from the destination of the blend operation
*    pjSrc      - actually points to the destination of the blend operation
*    pjDst      - points to where we'll store our temporary copy of the
*                 destination of the blend operation
*    cx         - number of pixels to read
*                                                                          
* Return Value:                                                            
*                                                                          
*   None                                                                   
*                                                                          
\**************************************************************************/

// Disable the "missing emms" warning.  We don't really need to do it in 
// this routine; instead, we do the emms instruction just before we restore 
// the floating point state.

#pragma warning( disable: 4799 )

VOID
vCopyAlphaBuffer16bppMMX(
    PBYTE   pjAlpha,
    PBYTE   pjSrc,
    PBYTE   pjDst,
    LONG    cx,
    PUSHORT *ppusDstNew
    )
{
    ULONG cj = (ULONG)(((ULONG_PTR) pjSrc) & 7);
    pjDst += cj;
    *ppusDstNew = (USHORT*)pjDst;

    if (((ULONG_PTR) pjSrc) & 2) 
    {
        if (TRANSLUCENT(pjAlpha[0]))
        {
            *((USHORT*) pjDst) = *((USHORT*) pjSrc);
        }
        pjSrc += 2;
        pjDst += 2;
        pjAlpha++;
        cx--;
    }

    if (((ULONG_PTR) pjSrc) & 4)
    {
        if (cx >= 2)
        {
            cx -= 2;
            if (TRANSLUCENT(pjAlpha[0]) || TRANSLUCENT(pjAlpha[1]))
            {
                *((ULONG*) pjDst) = *((ULONG*) pjSrc);
            }
            pjSrc += 4;
            pjDst += 4;
            pjAlpha += 2;
        }
    }

    while (TRUE)
    {
        cx -= 4;
        if (cx < 0)
            break;

        if (TRANSLUCENT(pjAlpha[0]) || TRANSLUCENT(pjAlpha[1]))
        {
            if (TRANSLUCENT(pjAlpha[2]) || TRANSLUCENT(pjAlpha[3]))
            {
                // Do a 64-bit copy using the MMX registers:

            #if defined(_X86_)
            
                _asm
                {
                    mov     esi, pjSrc
                    movq    mm0, [esi]
                    mov     esi, pjDst
                    movq    [esi], mm0
                }

            #endif

            }
            else
            {
                *((ULONG*) pjDst) = *((ULONG*) pjSrc);
            }
        }
        else if (TRANSLUCENT(pjAlpha[2]) || TRANSLUCENT(pjAlpha[3]))
        {
            *((ULONG*) (pjDst + 4)) = *((ULONG*) (pjSrc + 4));
        }
        pjSrc += 8;
        pjDst += 8;
        pjAlpha += 4;
    }
    if (cx & 2)
    {
        if (TRANSLUCENT(pjAlpha[0]) || TRANSLUCENT(pjAlpha[1]))
        {
            *((ULONG*) pjDst) = *((ULONG*) pjSrc);
        }
        pjSrc += 4;
        pjDst += 4;
        pjAlpha += 2;
    }
    if (cx & 1)
    {
        if (TRANSLUCENT(pjAlpha[0]))
        {
            *((USHORT*) pjDst) = *((USHORT*) pjSrc);
        }
    }
}

#define COPY_BUFFER_ENTRIES   1000
#define COPY_BUFFER_SIZE (sizeof(double) * COPY_BUFFER_ENTRIES)
double  gajCopyBuffer[COPY_BUFFER_ENTRIES];

/******************************Public*Routine******************************\
*                                                                          
* Routine Name                                                             
*                                                                          
*   vSrcTranCopyS8D16
*                                                                          
* Routine Description:                                                     
*
*   This routine chooses the optimal SrcTranCopy routine for the display,
*   be it 5-5-5 or 5-6-5 or arbitrary.  It also chooses the appropriate 
*   destination 'copy' routine based on the hardware's capabilities.
*
*   NOTE: I expect this function to disappear, and this logic moved up
*         higher at some point.
*                                                                          
* Arguments:                                                               
*                                                                          
* Return Value:                                                            
*                                                                          
*   None                                                                   
*                                                                          
\**************************************************************************/

VOID
vSrcTranCopyS8D16(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{
// !!! Note that this isn't thread safe or anything

    BYTE* pjCopyBuffer = (BYTE *)gajCopyBuffer;
    BOOL bAlloc = FALSE;
    ULONG cjNeeded = (DstRight - DstLeft) * sizeof(USHORT) + sizeof(double);

    if (cjNeeded > COPY_BUFFER_SIZE)
    {
        pjCopyBuffer = (PBYTE)PALLOCNOZ(cjNeeded, 'oteG');
        if (!pjCopyBuffer)
            return;
        bAlloc = TRUE;
    }

    #if defined(_X86_)
    if (gbMMXProcessor)
    {


        KFLOATING_SAVE fsFpState;

    // This save operation is quite expensive.  We would want to amortize
    // its cost across all the rectangles if there is complex clipping.

        NTSTATUS status = KeSaveFloatingPointState(&fsFpState);

        ASSERTGDI(NT_SUCCESS(status),
            "Unexpected KeSaveFloatingPointState failure");

        vSrcTranCopyS8D16New(pjSrcIn, SrcLeft, DeltaSrcIn, pjDstIn, DstLeft,
                             DstRight, DeltaDstIn, cy, uF, uB, pS,
                             vCopyAlphaBuffer16bppMMX, pjCopyBuffer);

    // Do the 'emms' instruction now that we're done with all of our
    // MMX operations.  I'm not actually sure if we really need to do
    // this because KeRestoreFloatingPointState might handle it anyway,
    // but we're better safe than sorry.
    //
    // NOTE: 'emms' is a very expensive operation.

        _asm emms

        KeRestoreFloatingPointState(&fsFpState);


    }
    else
    #endif
    {
        // We don't have to worry about floating point state in this
        // code path.

        vSrcTranCopyS8D16New(pjSrcIn, SrcLeft, DeltaSrcIn, pjDstIn, DstLeft,
                             DstRight, DeltaDstIn, cy, uF, uB, pS,
                             vCopyAlphaBuffer16bpp, pjCopyBuffer);
    }

    if (bAlloc)
        VFREEMEM(pjCopyBuffer);
}


/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcOpaqCopyS8D24                                                      *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - right(last) dst pixel                                    *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color                                         *
*    uB         - Background color                                         *
*    pS         - pointer to destination SURFACE                           *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

VOID
vSrcOpaqCopyS8D24(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{

    ULONG  *aul;            // a cache of the 252 possible 24-bit
                            // colors that can be seen on the
                            // destination surface.

    ULONG  cjDst = 3 * (DstRight - DstLeft);
    BLENDINFO bi;
    SEMOBJ so(ghsemEUDC2);

    aul = (ULONG*) pvFillOpaqTableCT(sizeof(*aul), uF, uB, pS, &bi, FALSE);

    pjSrcIn += SrcLeft ;            // 1 pixels per src byte
    pjDstIn += DstLeft * 3;         // 3 bytes per dest pixel

    for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
    {
        BYTE  *ajSrc; // points directly into OpaqTable
        BYTE  *pjSrc = pjSrcIn;
        BYTE  *pjDst = pjDstIn;
        BYTE  *pjDstEnd = pjDstIn + cjDst;

        for ( ;pjDst < pjDstEnd; pjSrc++)
        {
            ajSrc = (BYTE*) &aul[*pjSrc];
            *pjDst++ = *ajSrc++;
            *pjDst++ = *ajSrc++;
            *pjDst++ = *ajSrc;
        }
    }
}



VOID
vSrcTranCopyS8D24(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{

    BLENDINFO bi;

    ULONG  *aul;
    ULONG   ulFore = uF & 0xffffff; // 24 bits
    ULONG   ulNewFore;
    ULONG   uB0;
    SEMOBJ so(ghsemEUDC2);

    ULONG  cjDst = 3 * (DstRight - DstLeft);

    pjSrcIn += SrcLeft ;            // 1 pixels per src byte
    pjDstIn += DstLeft * 3;         // 3 bytes per dest pixel

// this is real slow, there 3 reads, must optimize

    uB0 = ((ULONG)pjDstIn[0] <<  0) |
          ((ULONG)pjDstIn[1] <<  8) |
          ((ULONG)pjDstIn[2] << 16) ;

// precompute the table in case we need it:

    aul = (ULONG*) pvFillOpaqTableCT(sizeof(*aul), uF, uB0, pS, &bi, TRUE);

    for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
    {
        BYTE  *ajSrc; // points directly into OpaqTable
        BYTE  *pjSrc = pjSrcIn;
        BYTE  *pjDst = pjDstIn;
        BYTE  *pjDstEnd = pjDstIn + cjDst;

        for ( ;pjDst < pjDstEnd; pjSrc++)
        {
            if (*pjSrc)
            {
                if (*pjSrc == (CT_LOOKUP-1)) // pure foreground
                {
                    ajSrc = (BYTE*)&ulFore;
                }
                else
                {
                    uB = ((ULONG)pjDst[0] <<  0) |
                         ((ULONG)pjDst[1] <<  8) |
                         ((ULONG)pjDst[2] << 16) ;

                    if (uB == uB0)
                    {
                        ajSrc = (BYTE*) &aul[*pjSrc];
                    }
                    else // must blend
                    {
                        ulNewFore = ulBlendPixelCT(&bi, uB, &gaOutTable[*pjSrc]);
                        ajSrc = (BYTE*)&ulNewFore;
                    }
                }

                *pjDst++ = *ajSrc++;
                *pjDst++ = *ajSrc++;
                *pjDst++ = *ajSrc;
            }
            else
            {
                pjDst += 3; // do not touch the background, just inc position
            }
        }
    }
}



/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcOpaqCopyS8D32                                                      *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - right(last) dst pixel                                    *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color                                         *
*    uB         - Background color                                         *
*    pS         - pointer to destination SURFACE                           *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

VOID
vSrcOpaqCopyS8D32(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{
    ULONG  *aul;      // array of 252 possible colors
    ULONG   culDst = (DstRight - DstLeft); // * sizeof(ULONG)
    BLENDINFO bi;
    SEMOBJ so(ghsemEUDC2);

    aul = (ULONG*) pvFillOpaqTableCT(sizeof(*aul), uF, uB, pS, &bi, FALSE);

    pjSrcIn   += SrcLeft;
    pjDstIn   += DstLeft * sizeof(ULONG);

    for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
    {
        BYTE *pjSrc = pjSrcIn;
        ULONG *pul  = (ULONG*) pjDstIn;
        ULONG *pulEnd  = pul + culDst;

        for ( ; pul < pulEnd; pul++, pjSrc++)
        {
            *pul = aul[*pjSrc];
        }
    }
}


VOID
vSrcTranCopyS8D32(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{
    BLENDINFO bi;

    ULONG  *aul;
    ULONG   culDst = (DstRight - DstLeft); // * sizeof(ULONG)
    ULONG   uB0; // dst pixel at the upper left corner
    SEMOBJ so(ghsemEUDC2);

    pjSrcIn   += SrcLeft;
    pjDstIn   += DstLeft * sizeof(ULONG);

// take the hit, hoping the background will not be variable

    uB0 = uB = *((ULONG *)pjDstIn);

// compute the table, get blending info

    aul = (ULONG*) pvFillOpaqTableCT(sizeof(*aul), uF, uB, pS, &bi, TRUE);

    for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
    {
        BYTE *pjSrc = pjSrcIn;
        ULONG *pul  = (ULONG*) pjDstIn;
        ULONG *pulEnd  = pul + culDst;

        for ( ; pul < pulEnd; pul++, pjSrc++)
        {
            ULONG kSrc = *pjSrc;

            if (kSrc)
            {
                if (kSrc == (CT_LOOKUP-1)) // pure foreground
                {
                    *pul = uF; // just write, no read, no recompute
                }
                else
                {
                // now comes the slow read/modify/write operation on a per pixel basis

                    uB = *pul; // read

                    if (uB == uB0)  // lucky, background did not change
                    {
                        *pul = aul[kSrc]; // write
                    }
                    else // blend on the spot
                    {
                        *pul = ulBlendPixelCT(&bi, uB, &gaOutTable[kSrc]);
                    }
                }
            }
        }
    }
}

void
vOrClearTypeGlyph(
    GLYPHBITS*  pgb      ,
    unsigned    dpSrcScan,
    BYTE*       pjDstScan,
    unsigned    dpDstScan
    )
{
    BYTE *pjDst, *pjSrc, *pjDstOut, *pjDstScanOut;
    unsigned cy        = (unsigned) pgb->sizlBitmap.cy;
    unsigned cx        = (unsigned) pgb->sizlBitmap.cx;
    BYTE    *pjSrcScan = &(pgb->aj[0]);

    for
    (
      pjDstScanOut = pjDstScan + cy * dpDstScan;
      pjDstScan < pjDstScanOut;
      pjDstScan += dpDstScan, pjSrcScan += dpSrcScan
    )
    {
        pjSrc = pjSrcScan;
        pjDst = pjDstScan;
        for (pjDstOut = pjDst + cx ; pjDst < pjDstOut; pjDst++, pjSrc++)
        {
            if (*pjDst == 0)
            {
                *pjDst = *pjSrc;
            }
            else if (*pjSrc != 0)
            {
                ULONG kR, kG, kB;

                kR = (ULONG)gaOutTable[*pjDst].kR + (ULONG)gaOutTable[*pjSrc].kR;
                kG = (ULONG)gaOutTable[*pjDst].kG + (ULONG)gaOutTable[*pjSrc].kG;
                kB = (ULONG)gaOutTable[*pjDst].kB + (ULONG)gaOutTable[*pjSrc].kB;

                if (kR > CT_SAMPLE_F) {kR = CT_SAMPLE_F;}
                if (kG > CT_SAMPLE_F) {kG = CT_SAMPLE_F;}
                if (kB > CT_SAMPLE_F) {kB = CT_SAMPLE_F;}

                *pjDst = gajStorage1[kB + 7 * kG + 49 * kR];
            }
        }
    }
}


// rasterizer returns unfiltered data in 2,2,2 format for r,g,b

#define GETRED(j)  (((j) >> 4) & 3)
#define GETGRE(j)  (((j) >> 2) & 3)
#define GETBLU(j)  (((j) >> 0) & 3)

#define R_SET(j)   ((j) & 0X30)
#define B_SET(j)   ((j) & 0X03)

#define FL_LEFT_LEAK   1
#define FL_RIGHT_LEAK  2

// because of the color filtering we may need to expand the original bitmap
// by one column of zero pixels on the left and on the right.
// After we perform the color filtering the column of left edge will pick up
// a non-trivial Blue component (color "leak" from the leftmost pixel in the
// original bitmap) while the column on the right edge will pick up the
// nontrivial Red component from the "leakage" of the rightmost pixel in the
// original bitmap. [BodinD]


ULONG ulClearTypeFilter(GLYPHBITS *pgb, GLYPHDATA *pgd, PRFONT prfnt)
{
    ULONG cx = pgb->sizlBitmap.cx;
    ULONG cy = pgb->sizlBitmap.cy;
    BYTE * pCurrentStorageTable = gajStorageTable;

    if ((cx == 1) && (cy == 1) && (pgb->aj[0] == 0))
    {
    // this is a space glyph

        pgb->sizlBitmap.cx = 0;
        pgb->sizlBitmap.cy = 0;
        return CJ_CTGD(0,0);
    }
#if DBG
    {
        ULONG cx1 = (ULONG)(pgd->rclInk.right  - pgd->rclInk.left);
        ULONG cy1 = (ULONG)(pgd->rclInk.bottom - pgd->rclInk.top);

        ASSERTGDI(cx1 == cx, "cx problem\n");
        ASSERTGDI(cy1 == cy, "cy problem\n");
    }
#endif // DBG

    if (prfnt->ppfe->pifi->flInfo & (FM_INFO_CONSTANT_WIDTH | FM_INFO_OPTICALLY_FIXED_PITCH) /* the font is fixed pitch */
        && prfnt->cache.bSmallMetrics /* only for horizontal transform */
        && (prfnt->ppfe->pifi->usWinWeight <= FW_NORMAL) /* normal or thin weight */
        && 
          (   !_wcsicmp((PWSTR)((BYTE*)prfnt->ppfe->pifi + prfnt->ppfe->pifi->dpwszFamilyName),L"Courier New") 
           || !_wcsicmp((PWSTR)((BYTE*)prfnt->ppfe->pifi + prfnt->ppfe->pifi->dpwszFamilyName),L"Rod") 
           || !_wcsicmp((PWSTR)((BYTE*)prfnt->ppfe->pifi + prfnt->ppfe->pifi->dpwszFamilyName),L"Rod Transparent") 
           || !_wcsicmp((PWSTR)((BYTE*)prfnt->ppfe->pifi + prfnt->ppfe->pifi->dpwszFamilyName),L"Fixed Miriam Transparent") 
           || !_wcsicmp((PWSTR)((BYTE*)prfnt->ppfe->pifi + prfnt->ppfe->pifi->dpwszFamilyName),L"Miriam Fixed") 
           || !_wcsicmp((PWSTR)((BYTE*)prfnt->ppfe->pifi + prfnt->ppfe->pifi->dpwszFamilyName),L"Simplified Arabic Fixed") 
          )
        )
    {
        /* Courier New look too thin with ClearType standard filter, let's use a bloated filter : */
        pCurrentStorageTable = gajStorageTableBloated;
    }


    FLONG flCTBits = 0;
    ULONG cyT = cy;

    for (BYTE *pjScan = pgb->aj; cyT; cyT--, pjScan += cx)
    {
        if (R_SET(pjScan[0]))
            flCTBits |= FL_LEFT_LEAK;

        if (B_SET(pjScan[cx - 1]))
            flCTBits |= FL_RIGHT_LEAK;

        if ((flCTBits & (FL_LEFT_LEAK | FL_RIGHT_LEAK)) == (FL_LEFT_LEAK | FL_RIGHT_LEAK))
            break;
    }

// we need to copy and filter in the same pass for performance reasons,
// we traverse the source backwards, so that we do not overwrite it

    ULONG cxD = cx;

    if (flCTBits & FL_LEFT_LEAK)
        cxD += 1;

    if (flCTBits & FL_RIGHT_LEAK)
        cxD += 1;

    BYTE jP, jT, jN;

    ULONG kBP;          // unfiltered blue count from the previous pixel
    ULONG kRN;          // unfiltered red count from the next pixel
    ULONG kRT, kGT, kBT;   // unfiltered counts from this pixel
    ULONG iStorage;

    BYTE *pjSrcScanEnd;
    BYTE *pjDstScanEnd;

    pjSrcScanEnd = pgb->aj + (cx * cy) - 1;
    pjDstScanEnd = pgb->aj + (cxD * cy) - 1;

    for ( ; pjDstScanEnd > pgb->aj; pjDstScanEnd -= cxD, pjSrcScanEnd -= cx)
    {
        BYTE *pjD1, *pjS1, *pjS0;

        pjD1 = pjDstScanEnd;
        pjS1 = pjSrcScanEnd;
        pjS0 = pjS1 - cx;

    // for the right border pixel jN = 0; jT = 0; jP = *pjS1;
    // therefore:
    //
    // kBP = GETBLU(*pjS1);  // GETBLU(jP);
    // kRN = 0; // GETRED(jN);
    // kRT = 0; // GETRED(jT);
    // kGT = 0; // GETGRE(jT);
    // kBT = 0; // GETBLU(jT);
    //
    // now convert this to a filtered index in the lookup table range
    // this is the trick, filtering and storing is done in one step
    // iStorage = kRN + 3 * (kBT + 3 * (kGT + 3 * (kRT + 3 * kBP)));

        if (flCTBits & FL_RIGHT_LEAK)
        {
            *pjD1-- = pCurrentStorageTable[3 * 3 * 3 * 3 * GETBLU(*pjS1)];
        }

    // initialize the loop in the middle

        for (jN = 0, jT = *pjS1; pjS1 > pjS0; pjS1--, pjD1--, jN = jT, jT = jP)
        {
            jP = (pjS1 == &pjS0[1]) ? 0 : pjS1[-1];

            kBP = GETBLU(jP);
            kRN = GETRED(jN);

            if (kBP || jT || kRN) // must compute, else optimize
            {
                kRT = GETRED(jT);
                kGT = GETGRE(jT);
                kBT = GETBLU(jT);

            // now convert this to a filtered index in the lookup table range
            // this is the trick, filtering and storing is done in one step

                iStorage = kRN + 3 * (kBT + 3 * (kGT + 3 * (kRT + 3 * kBP)));
                *pjD1 = pCurrentStorageTable[iStorage];
            }
            else
            {
                *pjD1 = 0;
            }
        }

    // for the left border pixel jP = 0; jT = 0; jN = pjS0[1];
    // therefore:
    //
    // kBP = 0; // GETBLU(jP);
    // kRN = GETRED(pjS0[1]); // GETRED(jN);
    // kRT = 0; // GETRED(jT);
    // kGT = 0; // GETGRE(jT);
    // kBT = 0; // GETBLU(jT);
    //
    // now convert this to a filtered index in the lookup table range
    // this is the trick, filtering and storing is done in one step
    // iStorage = kRN + 3 * (kBT + 3 * (kGT + 3 * (kRT + 3 * kBP)));
    // i.e. iStorage = kRN, which implies:

        if (flCTBits & FL_LEFT_LEAK)
        {
            *pjD1 = pCurrentStorageTable[ GETRED(pjS0[1]) ];
        }
    }

// fix the size and the origin

    pgb->sizlBitmap.cx = cxD;
    if (flCTBits & FL_LEFT_LEAK)
        pgb->ptlOrigin.x -= 1;

    return CJ_CTGD(cxD, cy);
}




/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   draw_clrt_nf_ntb_o_to_temp_start                                       *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Assembles a cleartype glyph string into a temporary 8bpp right and left*
*   DWORD aligned buffer. This routine assumes a variable pitch font.      *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pGlyphPos  - pointer to an array of cGlyph gray GLYPHPOS structures    *
*   cGlyphs    - count of gray glyphs in array starting at pGlyphPos       *
*   pjDstStart - pointer to a 8bpp buffer where string is to be assembled  *
*                This buffer is DWORD aligned at the left and right        *
*                edges of each scan.                                       *
*   ulLeftEdge - screen coordinate corresponding to the left edge of       *
*                the temporary buffer                                      *
*   lDstDelta  - count of bytes in each scan of the destination buffer     *
*                (this must be a multiple of 4 because the buffer is       *
*                 DWORD aligned on each scan).                             *
*   ulCharInc  - This must be zero.                                        *
*   ulTempTop  - screen coordinate corresponding to the top of the         *
*                destination buffer. This is used to convert the           *
*                glyph positions on the screen to addresses in the         *
*                destination bitmap.                                       *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

extern "C" VOID draw_clrt_nf_ntb_o_to_temp_start(
    PGLYPHPOS       pGlyphPos,
    ULONG           cGlyphs,
    PUCHAR          pjDstStart,
    ULONG           ulLeftEdge,
    ULONG           lDstDelta,
    ULONG           ulCharInc,
    ULONG           ulTempTop
    )
{
    GLYPHBITS     *pgb;        // pointer to current GLYPHBITS
    LONG           x;          // pixel offset of the
                               // left edge of the glyph bitmap
                               // from the left edge of the
                               // output (8-bpp) bitmap
    LONG           y;          // the pixel offset of the top edge
                               // of the glyph bitmap from the top
                               // edge of the output bitmap.
    LONG           cx;         // number of pixels per glyph scan
                               // If non zero then the destination
                               // bitmap is out of alignment with
                               // the source glyph by a one nyble
                               // shift and a single byte of the
                               // source will affect two consecutive
                               // bytes of the destination.
    LONG           cy;
    BYTE          *pjSrc;
    LONG           lDstSkip;
    ULONG          kR;
    ULONG          kG;
    ULONG          kB;
    LONG           i;

    do {
        pgb = pGlyphPos->pgdf->pgb;
        x   = pGlyphPos->ptl.x + pgb->ptlOrigin.x - ulLeftEdge;
        y   = pGlyphPos->ptl.y + pgb->ptlOrigin.y - ulTempTop;

		ASSERTGDI(x >=0,"draw_clrt_nf_ntb_o_to_temp_start x < 0" );
		ASSERTGDI(y >=0,"draw_clrt_nf_ntb_o_to_temp_start y < 0" );


        cy = pgb->sizlBitmap.cy;
        if (cy)
        {
            BYTE *pjDst = pjDstStart + (y * lDstDelta) + x;
            cx = pgb->sizlBitmap.cx;
            lDstSkip = lDstDelta - cx;
            pjSrc = &pgb->aj[0];

            do {
                i = cx;
                do {
                    if (*pjDst == 0)
                    {
                        *pjDst = *pjSrc;
                    }
                    else if (*pjSrc != 0)
                    {
                        kR = (ULONG)gaOutTable[*pjDst].kR + (ULONG)gaOutTable[*pjSrc].kR;
                        kG = (ULONG)gaOutTable[*pjDst].kG + (ULONG)gaOutTable[*pjSrc].kG;
                        kB = (ULONG)gaOutTable[*pjDst].kB + (ULONG)gaOutTable[*pjSrc].kB;

                        if (kR > CT_SAMPLE_F) {kR = CT_SAMPLE_F;}
                        if (kG > CT_SAMPLE_F) {kG = CT_SAMPLE_F;}
                        if (kB > CT_SAMPLE_F) {kB = CT_SAMPLE_F;}

                        *pjDst = gajStorage1[kB + 7 * kG + 49 * kR];
                    }

                    pjDst++;
                    pjSrc++;

                } while (--i != 0);

                pjDst += lDstSkip;

            } while (--cy != 0);
        }

        pGlyphPos++;

    } while (--cGlyphs != 0);
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   draw_clrt_f_ntb_o_to_temp_start                                        *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Assembles a cleartype glyph string into a temporary 4bpp right and left*
*   DWORD aligned buffer. This routine assumes a fixed pitch font with     *
*   character increment equal to ulCharInc                                 *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pGlyphPos  - pointer to an array of cGlyph gray GLYPHPOS structures    *
*   cGlyphs    - count of gray glyphs in array starting at pGlyphPos       *
*   pjDst      - pointer to a 8bpp buffer where string is to be assembled  *
*                This buffer is DWORD aligned at the left and right        *
*                edges of each scan.                                       *
*   ulLeftEdge - screen coordinate corresponding to the left edge of       *
*                the temporary buffer                                      *
*   dpDst      - count of bytes in each scan of the destination buffer     *
*                (this must be a multiple of 4 because the buffer is       *
*                 DWORD aligned on each scan).                             *
*   ulCharInc  - must NOT be zero in this case                             *
*   ulTempTop  - screen coordinate corresponding to the top of the         *
*                destination buffer. This is used to convert the           *
*                glyph positions on the screen to addresses in the         *
*                destination bitmap.                                       *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

extern "C" VOID draw_clrt_f_ntb_o_to_temp_start(
    PGLYPHPOS       pGlyphPos,
    ULONG           cGlyphs,
    PUCHAR          pjDst,
    ULONG           ulLeftEdge,
    ULONG           dpDst,
    ULONG           ulCharInc,
    ULONG           ulTempTop
    )
{
    GLYPHBITS     *pgb;        // pointer to current GLYPHBITS

    int            x;          // x-coordinate of the current
                               // character origin with respect
                               // to the upper left pixel of the
                               // output (4-bpp) bitmap

    int            y;          // y-coordinate of the current
                               // character origin with respect
                               // to the upper left pixel of the
                               // output (4-bpp) bitmap

    unsigned       cx;         // number of pixels per glyph scan
                               // If non zero then the destination
                               // bitmap is out of alignment with
                               // the source glyph by a one nyble
                               // shift and a single byte of the
                               // source will affect two consecutive
                               // bytes of the destination.

    GLYPHPOS      *pgpOut;     // sentinel for loop

    BYTE          *pj;         // pointer into Buffer corresponding
                               // to the upper left pixel of the
                               // current gray glyph

    // (x,y) = position of first CHARACTER ORIGIN with respect to
    //         the upper left pixel of the destination 4bpp bitmap

    x  = pGlyphPos->ptl.x - ulLeftEdge;
    y  = pGlyphPos->ptl.y - ulTempTop;

    for (pgpOut = pGlyphPos + cGlyphs; pGlyphPos < pgpOut; x += ulCharInc, pGlyphPos++)
    {
        int xT, yT; // position of UPPER LEFT pixel of glyph
                    // with respect to the upper left pixel
                    // of the bitmap.

        pgb         = pGlyphPos->pgdf->pgb;
        xT          = x + pgb->ptlOrigin.x;
        yT          = y + pgb->ptlOrigin.y;
        cx          = (unsigned) pgb->sizlBitmap.cx;
        pj          = pjDst + (yT * dpDst) + xT;

        vOrClearTypeGlyph(pgb, cx, pj, dpDst);
    }
}

BYTE ajGammaCT_10[256] = {
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 
0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 
0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 
0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 
0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 
0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 
0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 
0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 
0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 
0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 
0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 
0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 
0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 
0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 
0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 
0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 
0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 
0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 
0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 
0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 
0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 
0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 
0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

BYTE ajGammaCT_11[256] = {
0x00, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x05, 
0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0A, 0x0B, 
0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x10, 0x11, 0x12, 
0x13, 0x14, 0x15, 0x16, 0x16, 0x17, 0x18, 0x19, 
0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x1F, 0x20, 
0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 
0x29, 0x2A, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3E, 
0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 
0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 
0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 
0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 
0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 
0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 
0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 
0x77, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 
0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 
0x90, 0x91, 0x92, 0x93, 0x95, 0x96, 0x97, 0x98, 
0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 
0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA9, 
0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 
0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xBA, 
0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 
0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC9, 0xCA, 0xCB, 
0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 
0xD4, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 
0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE3, 0xE4, 0xE5, 
0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 
0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 
0xF7, 0xF8, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

BYTE ajGammaInvCT_11[256] = {
0x00, 0x02, 0x03, 0x04, 0x06, 0x07, 0x08, 0x0A, 
0x0B, 0x0C, 0x0D, 0x0F, 0x10, 0x11, 0x12, 0x13, 
0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1D, 
0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x26, 
0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 
0x2F, 0x30, 0x31, 0x33, 0x34, 0x35, 0x36, 0x37, 
0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x47, 0x48, 
0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 
0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 
0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 
0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 
0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 
0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 
0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 
0x81, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 
0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 
0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9C, 0x9D, 0x9E, 
0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 
0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 
0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 
0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 
0xBE, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 
0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 
0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 
0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xD9, 0xDA, 
0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 
0xE3, 0xE4, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 
0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xEF, 0xF0, 
0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 
0xF9, 0xFA, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

BYTE ajGammaCT_12[256] = {
 0x00,   0x00,   0x01,   0x01,   0x02,   0x02,   0x03,   0x03,
 0x04,   0x05,   0x05,   0x06,   0x07,   0x07,   0x08,   0x09,
 0x09,   0x0A,   0x0B,   0x0B,   0x0C,   0x0D,   0x0D,   0x0E,
 0x0F,   0x10,   0x10,   0x11,   0x12,   0x13,   0x14,   0x14,
 0x15,   0x16,   0x17,   0x18,   0x18,   0x19,   0x1A,   0x1B,
 0x1C,   0x1C,   0x1D,   0x1E,   0x1F,   0x20,   0x21,   0x22,
 0x22,   0x23,   0x24,   0x25,   0x26,   0x27,   0x28,   0x28,
 0x29,   0x2A,   0x2B,   0x2C,   0x2D,   0x2E,   0x2F,   0x30,
 0x31,   0x31,   0x32,   0x33,   0x34,   0x35,   0x36,   0x37,
 0x38,   0x39,   0x3A,   0x3B,   0x3C,   0x3D,   0x3E,   0x3E,
 0x3F,   0x40,   0x41,   0x42,   0x43,   0x44,   0x45,   0x46,
 0x47,   0x48,   0x49,   0x4A,   0x4B,   0x4C,   0x4D,   0x4E,
 0x4F,   0x50,   0x51,   0x52,   0x53,   0x54,   0x55,   0x56,
 0x57,   0x58,   0x59,   0x5A,   0x5B,   0x5C,   0x5D,   0x5E,
 0x5F,   0x60,   0x61,   0x62,   0x63,   0x64,   0x65,   0x66,
 0x67,   0x68,   0x69,   0x6A,   0x6B,   0x6C,   0x6D,   0x6E,
 0x70,   0x71,   0x72,   0x73,   0x74,   0x75,   0x76,   0x77,
 0x78,   0x79,   0x7A,   0x7B,   0x7C,   0x7D,   0x7E,   0x7F,
 0x80,   0x82,   0x83,   0x84,   0x85,   0x86,   0x87,   0x88,
 0x89,   0x8A,   0x8B,   0x8C,   0x8D,   0x8E,   0x90,   0x91,
 0x92,   0x93,   0x94,   0x95,   0x96,   0x97,   0x98,   0x99,
 0x9B,   0x9C,   0x9D,   0x9E,   0x9F,   0xA0,   0xA1,   0xA2,
 0xA3,   0xA5,   0xA6,   0xA7,   0xA8,   0xA9,   0xAA,   0xAB,
 0xAC,   0xAD,   0xAF,   0xB0,   0xB1,   0xB2,   0xB3,   0xB4,
 0xB5,   0xB7,   0xB8,   0xB9,   0xBA,   0xBB,   0xBC,   0xBD,
 0xBF,   0xC0,   0xC1,   0xC2,   0xC3,   0xC4,   0xC5,   0xC7,
 0xC8,   0xC9,   0xCA,   0xCB,   0xCC,   0xCD,   0xCF,   0xD0,
 0xD1,   0xD2,   0xD3,   0xD4,   0xD6,   0xD7,   0xD8,   0xD9,
 0xDA,   0xDB,   0xDD,   0xDE,   0xDF,   0xE0,   0xE1,   0xE2,
 0xE4,   0xE5,   0xE6,   0xE7,   0xE8,   0xEA,   0xEB,   0xEC,
 0xED,   0xEE,   0xEF,   0xF1,   0xF2,   0xF3,   0xF4,   0xF5,
 0xF7,   0xF8,   0xF9,   0xFA,   0xFB,   0xFD,   0xFE,   0xFF
};

BYTE ajGammaInvCT_12[256] = {
 0x00,   0x03,   0x04,   0x06,   0x08,   0x0A,   0x0B,   0x0D,
 0x0E,   0x10,   0x11,   0x13,   0x14,   0x15,   0x17,   0x18,
 0x19,   0x1B,   0x1C,   0x1D,   0x1F,   0x20,   0x21,   0x22,
 0x24,   0x25,   0x26,   0x27,   0x28,   0x2A,   0x2B,   0x2C,
 0x2D,   0x2E,   0x30,   0x31,   0x32,   0x33,   0x34,   0x35,
 0x36,   0x38,   0x39,   0x3A,   0x3B,   0x3C,   0x3D,   0x3E,
 0x3F,   0x41,   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,
 0x48,   0x49,   0x4A,   0x4B,   0x4C,   0x4D,   0x4E,   0x50,
 0x51,   0x52,   0x53,   0x54,   0x55,   0x56,   0x57,   0x58,
 0x59,   0x5A,   0x5B,   0x5C,   0x5D,   0x5E,   0x5F,   0x60,
 0x61,   0x62,   0x63,   0x64,   0x65,   0x66,   0x67,   0x68,
 0x69,   0x6A,   0x6B,   0x6C,   0x6D,   0x6E,   0x6F,   0x70,
 0x71,   0x72,   0x73,   0x74,   0x75,   0x76,   0x77,   0x78,
 0x79,   0x7A,   0x7B,   0x7C,   0x7D,   0x7E,   0x7F,   0x80,
 0x80,   0x81,   0x82,   0x83,   0x84,   0x85,   0x86,   0x87,
 0x88,   0x89,   0x8A,   0x8B,   0x8C,   0x8D,   0x8E,   0x8F,
 0x90,   0x91,   0x91,   0x92,   0x93,   0x94,   0x95,   0x96,
 0x97,   0x98,   0x99,   0x9A,   0x9B,   0x9C,   0x9D,   0x9D,
 0x9E,   0x9F,   0xA0,   0xA1,   0xA2,   0xA3,   0xA4,   0xA5,
 0xA6,   0xA7,   0xA8,   0xA8,   0xA9,   0xAA,   0xAB,   0xAC,
 0xAD,   0xAE,   0xAF,   0xB0,   0xB1,   0xB1,   0xB2,   0xB3,
 0xB4,   0xB5,   0xB6,   0xB7,   0xB8,   0xB9,   0xB9,   0xBA,
 0xBB,   0xBC,   0xBD,   0xBE,   0xBF,   0xC0,   0xC1,   0xC1,
 0xC2,   0xC3,   0xC4,   0xC5,   0xC6,   0xC7,   0xC8,   0xC8,
 0xC9,   0xCA,   0xCB,   0xCC,   0xCD,   0xCE,   0xCF,   0xCF,
 0xD0,   0xD1,   0xD2,   0xD3,   0xD4,   0xD5,   0xD5,   0xD6,
 0xD7,   0xD8,   0xD9,   0xDA,   0xDB,   0xDB,   0xDC,   0xDD,
 0xDE,   0xDF,   0xE0,   0xE1,   0xE1,   0xE2,   0xE3,   0xE4,
 0xE5,   0xE6,   0xE7,   0xE7,   0xE8,   0xE9,   0xEA,   0xEB,
 0xEC,   0xED,   0xED,   0xEE,   0xEF,   0xF0,   0xF1,   0xF2,
 0xF2,   0xF3,   0xF4,   0xF5,   0xF6,   0xF7,   0xF7,   0xF8,
 0xF9,   0xFA,   0xFB,   0xFC,   0xFC,   0xFD,   0xFE,   0xFF
};

BYTE ajGammaCT_13[256] = {
0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x02, 0x02, 
0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 
0x07, 0x08, 0x08, 0x09, 0x09, 0x0A, 0x0B, 0x0B, 
0x0C, 0x0C, 0x0D, 0x0E, 0x0E, 0x0F, 0x10, 0x10, 
0x11, 0x12, 0x13, 0x13, 0x14, 0x15, 0x15, 0x16, 
0x17, 0x18, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1C, 
0x1D, 0x1E, 0x1F, 0x1F, 0x20, 0x21, 0x22, 0x23, 
0x24, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x29, 
0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x2F, 0x30, 
0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 
0x39, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 
0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4C, 0x4D, 0x4E, 
0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 
0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 
0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 
0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x70, 
0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 
0x79, 0x7A, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 
0x82, 0x83, 0x84, 0x85, 0x87, 0x88, 0x89, 0x8A, 
0x8B, 0x8C, 0x8D, 0x8F, 0x90, 0x91, 0x92, 0x93, 
0x94, 0x95, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 
0x9D, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA6, 
0xA7, 0xA8, 0xA9, 0xAA, 0xAC, 0xAD, 0xAE, 0xAF, 
0xB0, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB8, 0xB9, 
0xBA, 0xBB, 0xBC, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 
0xC4, 0xC5, 0xC6, 0xC7, 0xC9, 0xCA, 0xCB, 0xCC, 
0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD4, 0xD5, 0xD6, 
0xD7, 0xD9, 0xDA, 0xDB, 0xDC, 0xDE, 0xDF, 0xE0, 
0xE2, 0xE3, 0xE4, 0xE5, 0xE7, 0xE8, 0xE9, 0xEA, 
0xEC, 0xED, 0xEE, 0xF0, 0xF1, 0xF2, 0xF3, 0xF5, 
0xF6, 0xF7, 0xF9, 0xFA, 0xFB, 0xFC, 0xFE, 0xFF
};

BYTE ajGammaInvCT_13[256] = {
0x00, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E, 0x10, 
0x12, 0x13, 0x15, 0x17, 0x18, 0x1A, 0x1B, 0x1D, 
0x1E, 0x20, 0x21, 0x23, 0x24, 0x25, 0x27, 0x28, 
0x29, 0x2B, 0x2C, 0x2D, 0x2F, 0x30, 0x31, 0x32, 
0x34, 0x35, 0x36, 0x37, 0x39, 0x3A, 0x3B, 0x3C, 
0x3D, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 
0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 
0x4F, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 
0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 
0x60, 0x61, 0x62, 0x63, 0x64, 0x66, 0x67, 0x68, 
0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 
0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x86, 
0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 
0x8F, 0x90, 0x91, 0x92, 0x92, 0x93, 0x94, 0x95, 
0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9B, 0x9C, 
0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA3, 
0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAA, 
0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB0, 0xB1, 
0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB6, 0xB7, 0xB8, 
0xB9, 0xBA, 0xBB, 0xBC, 0xBC, 0xBD, 0xBE, 0xBF, 
0xC0, 0xC1, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 
0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCB, 0xCC, 
0xCD, 0xCE, 0xCF, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 
0xD4, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD8, 0xD9, 
0xDA, 0xDB, 0xDC, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 
0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE4, 0xE5, 0xE6, 
0xE7, 0xE8, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xEC, 
0xED, 0xEE, 0xEF, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 
0xF3, 0xF4, 0xF5, 0xF6, 0xF6, 0xF7, 0xF8, 0xF9, 
0xFA, 0xFA, 0xFB, 0xFC, 0xFD, 0xFD, 0xFE, 0xFF 
};

BYTE ajGammaCT_14[256] = {
 0x00,   0x00,   0x00,   0x01,   0x01,   0x01,   0x01,   0x02,
 0x02,   0x02,   0x03,   0x03,   0x04,   0x04,   0x04,   0x05,
 0x05,   0x06,   0x06,   0x07,   0x07,   0x08,   0x08,   0x09,
 0x09,   0x0A,   0x0A,   0x0B,   0x0C,   0x0C,   0x0D,   0x0D,
 0x0E,   0x0F,   0x0F,   0x10,   0x10,   0x11,   0x12,   0x12,
 0x13,   0x14,   0x14,   0x15,   0x16,   0x16,   0x17,   0x18,
 0x19,   0x19,   0x1A,   0x1B,   0x1C,   0x1C,   0x1D,   0x1E,
 0x1F,   0x1F,   0x20,   0x21,   0x22,   0x22,   0x23,   0x24,
 0x25,   0x26,   0x26,   0x27,   0x28,   0x29,   0x2A,   0x2B,
 0x2B,   0x2C,   0x2D,   0x2E,   0x2F,   0x30,   0x31,   0x31,
 0x32,   0x33,   0x34,   0x35,   0x36,   0x37,   0x38,   0x39,
 0x39,   0x3A,   0x3B,   0x3C,   0x3D,   0x3E,   0x3F,   0x40,
 0x41,   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,   0x48,
 0x49,   0x4A,   0x4B,   0x4C,   0x4D,   0x4E,   0x4F,   0x50,
 0x51,   0x52,   0x53,   0x54,   0x55,   0x56,   0x57,   0x58,
 0x59,   0x5A,   0x5B,   0x5C,   0x5D,   0x5E,   0x5F,   0x60,
 0x61,   0x62,   0x63,   0x64,   0x65,   0x67,   0x68,   0x69,
 0x6A,   0x6B,   0x6C,   0x6D,   0x6E,   0x6F,   0x70,   0x71,
 0x73,   0x74,   0x75,   0x76,   0x77,   0x78,   0x79,   0x7A,
 0x7C,   0x7D,   0x7E,   0x7F,   0x80,   0x81,   0x82,   0x84,
 0x85,   0x86,   0x87,   0x88,   0x89,   0x8B,   0x8C,   0x8D,
 0x8E,   0x8F,   0x91,   0x92,   0x93,   0x94,   0x95,   0x97,
 0x98,   0x99,   0x9A,   0x9B,   0x9D,   0x9E,   0x9F,   0xA0,
 0xA1,   0xA3,   0xA4,   0xA5,   0xA6,   0xA8,   0xA9,   0xAA,
 0xAB,   0xAD,   0xAE,   0xAF,   0xB0,   0xB2,   0xB3,   0xB4,
 0xB5,   0xB7,   0xB8,   0xB9,   0xBB,   0xBC,   0xBD,   0xBE,
 0xC0,   0xC1,   0xC2,   0xC4,   0xC5,   0xC6,   0xC8,   0xC9,
 0xCA,   0xCB,   0xCD,   0xCE,   0xCF,   0xD1,   0xD2,   0xD3,
 0xD5,   0xD6,   0xD7,   0xD9,   0xDA,   0xDB,   0xDD,   0xDE,
 0xDF,   0xE1,   0xE2,   0xE3,   0xE5,   0xE6,   0xE8,   0xE9,
 0xEA,   0xEC,   0xED,   0xEE,   0xF0,   0xF1,   0xF2,   0xF4,
 0xF5,   0xF7,   0xF8,   0xF9,   0xFB,   0xFC,   0xFE,   0xFF
};

BYTE ajGammaInvCT_14[256] = {
 0x00,   0x05,   0x08,   0x0B,   0x0D,   0x0F,   0x12,   0x14,
 0x16,   0x17,   0x19,   0x1B,   0x1D,   0x1E,   0x20,   0x22,
 0x23,   0x25,   0x26,   0x28,   0x29,   0x2B,   0x2C,   0x2E,
 0x2F,   0x31,   0x32,   0x33,   0x35,   0x36,   0x37,   0x39,
 0x3A,   0x3B,   0x3C,   0x3E,   0x3F,   0x40,   0x41,   0x43,
 0x44,   0x45,   0x46,   0x48,   0x49,   0x4A,   0x4B,   0x4C,
 0x4D,   0x4E,   0x50,   0x51,   0x52,   0x53,   0x54,   0x55,
 0x56,   0x57,   0x59,   0x5A,   0x5B,   0x5C,   0x5D,   0x5E,
 0x5F,   0x60,   0x61,   0x62,   0x63,   0x64,   0x65,   0x66,
 0x67,   0x68,   0x69,   0x6A,   0x6B,   0x6C,   0x6D,   0x6E,
 0x6F,   0x70,   0x71,   0x72,   0x73,   0x74,   0x75,   0x76,
 0x77,   0x78,   0x79,   0x7A,   0x7B,   0x7C,   0x7D,   0x7E,
 0x7F,   0x80,   0x81,   0x82,   0x83,   0x84,   0x85,   0x85,
 0x86,   0x87,   0x88,   0x89,   0x8A,   0x8B,   0x8C,   0x8D,
 0x8E,   0x8F,   0x8F,   0x90,   0x91,   0x92,   0x93,   0x94,
 0x95,   0x96,   0x97,   0x97,   0x98,   0x99,   0x9A,   0x9B,
 0x9C,   0x9D,   0x9E,   0x9E,   0x9F,   0xA0,   0xA1,   0xA2,
 0xA3,   0xA4,   0xA4,   0xA5,   0xA6,   0xA7,   0xA8,   0xA9,
 0xAA,   0xAA,   0xAB,   0xAC,   0xAD,   0xAE,   0xAF,   0xAF,
 0xB0,   0xB1,   0xB2,   0xB3,   0xB4,   0xB4,   0xB5,   0xB6,
 0xB7,   0xB8,   0xB8,   0xB9,   0xBA,   0xBB,   0xBC,   0xBC,
 0xBD,   0xBE,   0xBF,   0xC0,   0xC0,   0xC1,   0xC2,   0xC3,
 0xC4,   0xC4,   0xC5,   0xC6,   0xC7,   0xC8,   0xC8,   0xC9,
 0xCA,   0xCB,   0xCC,   0xCC,   0xCD,   0xCE,   0xCF,   0xCF,
 0xD0,   0xD1,   0xD2,   0xD3,   0xD3,   0xD4,   0xD5,   0xD6,
 0xD6,   0xD7,   0xD8,   0xD9,   0xD9,   0xDA,   0xDB,   0xDC,
 0xDC,   0xDD,   0xDE,   0xDF,   0xDF,   0xE0,   0xE1,   0xE2,
 0xE2,   0xE3,   0xE4,   0xE5,   0xE5,   0xE6,   0xE7,   0xE8,
 0xE8,   0xE9,   0xEA,   0xEB,   0xEB,   0xEC,   0xED,   0xEE,
 0xEE,   0xEF,   0xF0,   0xF1,   0xF1,   0xF2,   0xF3,   0xF3,
 0xF4,   0xF5,   0xF6,   0xF6,   0xF7,   0xF8,   0xF9,   0xF9,
 0xFA,   0xFB,   0xFB,   0xFC,   0xFD,   0xFE,   0xFE,   0xFF
};


BYTE ajGammaCT_15[256] = {
   0x00,   0x00,   0x00,   0x00,   0x01,   0x01,   0x01,   0x01,
   0x01,   0x02,   0x02,   0x02,   0x03,   0x03,   0x03,   0x04,
   0x04,   0x04,   0x05,   0x05,   0x06,   0x06,   0x06,   0x07,
   0x07,   0x08,   0x08,   0x09,   0x09,   0x0A,   0x0A,   0x0B,
   0x0B,   0x0C,   0x0C,   0x0D,   0x0E,   0x0E,   0x0F,   0x0F,
   0x10,   0x10,   0x11,   0x12,   0x12,   0x13,   0x14,   0x14,
   0x15,   0x15,   0x16,   0x17,   0x17,   0x18,   0x19,   0x1A,
   0x1A,   0x1B,   0x1C,   0x1C,   0x1D,   0x1E,   0x1F,   0x1F,
   0x20,   0x21,   0x22,   0x22,   0x23,   0x24,   0x25,   0x25,
   0x26,   0x27,   0x28,   0x29,   0x29,   0x2A,   0x2B,   0x2C,
   0x2D,   0x2E,   0x2E,   0x2F,   0x30,   0x31,   0x32,   0x33,
   0x34,   0x35,   0x35,   0x36,   0x37,   0x38,   0x39,   0x3A,
   0x3B,   0x3C,   0x3D,   0x3E,   0x3F,   0x40,   0x41,   0x41,
   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,   0x48,   0x49,
   0x4A,   0x4B,   0x4C,   0x4D,   0x4E,   0x4F,   0x50,   0x51,
   0x52,   0x53,   0x54,   0x55,   0x56,   0x58,   0x59,   0x5A,
   0x5B,   0x5C,   0x5D,   0x5E,   0x5F,   0x60,   0x61,   0x62,
   0x63,   0x64,   0x66,   0x67,   0x68,   0x69,   0x6A,   0x6B,
   0x6C,   0x6D,   0x6E,   0x70,   0x71,   0x72,   0x73,   0x74,
   0x75,   0x77,   0x78,   0x79,   0x7A,   0x7B,   0x7C,   0x7E,
   0x7F,   0x80,   0x81,   0x82,   0x84,   0x85,   0x86,   0x87,
   0x88,   0x8A,   0x8B,   0x8C,   0x8D,   0x8E,   0x90,   0x91,
   0x92,   0x93,   0x95,   0x96,   0x97,   0x98,   0x9A,   0x9B,
   0x9C,   0x9E,   0x9F,   0xA0,   0xA1,   0xA3,   0xA4,   0xA5,
   0xA7,   0xA8,   0xA9,   0xAB,   0xAC,   0xAD,   0xAE,   0xB0,
   0xB1,   0xB2,   0xB4,   0xB5,   0xB6,   0xB8,   0xB9,   0xBB,
   0xBC,   0xBD,   0xBF,   0xC0,   0xC1,   0xC3,   0xC4,   0xC5,
   0xC7,   0xC8,   0xCA,   0xCB,   0xCC,   0xCE,   0xCF,   0xD1,
   0xD2,   0xD3,   0xD5,   0xD6,   0xD8,   0xD9,   0xDA,   0xDC,
   0xDD,   0xDF,   0xE0,   0xE2,   0xE3,   0xE4,   0xE6,   0xE7,
   0xE9,   0xEA,   0xEC,   0xED,   0xEF,   0xF0,   0xF2,   0xF3,
   0xF5,   0xF6,   0xF8,   0xF9,   0xFB,   0xFC,   0xFE,   0xFF
};


BYTE ajGammaInvCT_15[256] = {
   0x00,   0x06,   0x0A,   0x0D,   0x10,   0x13,   0x15,   0x17,
   0x19,   0x1B,   0x1D,   0x1F,   0x21,   0x23,   0x25,   0x27,
   0x28,   0x2A,   0x2C,   0x2D,   0x2F,   0x30,   0x32,   0x33,
   0x35,   0x36,   0x38,   0x39,   0x3A,   0x3C,   0x3D,   0x3F,
   0x40,   0x41,   0x43,   0x44,   0x45,   0x46,   0x48,   0x49,
   0x4A,   0x4B,   0x4D,   0x4E,   0x4F,   0x50,   0x51,   0x53,
   0x54,   0x55,   0x56,   0x57,   0x58,   0x59,   0x5B,   0x5C,
   0x5D,   0x5E,   0x5F,   0x60,   0x61,   0x62,   0x63,   0x64,
   0x65,   0x67,   0x68,   0x69,   0x6A,   0x6B,   0x6C,   0x6D,
   0x6E,   0x6F,   0x70,   0x71,   0x72,   0x73,   0x74,   0x75,
   0x76,   0x77,   0x78,   0x79,   0x7A,   0x7B,   0x7C,   0x7D,
   0x7D,   0x7E,   0x7F,   0x80,   0x81,   0x82,   0x83,   0x84,
   0x85,   0x86,   0x87,   0x88,   0x89,   0x8A,   0x8A,   0x8B,
   0x8C,   0x8D,   0x8E,   0x8F,   0x90,   0x91,   0x92,   0x92,
   0x93,   0x94,   0x95,   0x96,   0x97,   0x98,   0x99,   0x99,
   0x9A,   0x9B,   0x9C,   0x9D,   0x9E,   0x9F,   0x9F,   0xA0,
   0xA1,   0xA2,   0xA3,   0xA4,   0xA4,   0xA5,   0xA6,   0xA7,
   0xA8,   0xA9,   0xA9,   0xAA,   0xAB,   0xAC,   0xAD,   0xAD,
   0xAE,   0xAF,   0xB0,   0xB1,   0xB1,   0xB2,   0xB3,   0xB4,
   0xB5,   0xB5,   0xB6,   0xB7,   0xB8,   0xB9,   0xB9,   0xBA,
   0xBB,   0xBC,   0xBC,   0xBD,   0xBE,   0xBF,   0xC0,   0xC0,
   0xC1,   0xC2,   0xC3,   0xC3,   0xC4,   0xC5,   0xC6,   0xC6,
   0xC7,   0xC8,   0xC9,   0xC9,   0xCA,   0xCB,   0xCC,   0xCC,
   0xCD,   0xCE,   0xCF,   0xCF,   0xD0,   0xD1,   0xD2,   0xD2,
   0xD3,   0xD4,   0xD5,   0xD5,   0xD6,   0xD7,   0xD7,   0xD8,
   0xD9,   0xDA,   0xDA,   0xDB,   0xDC,   0xDC,   0xDD,   0xDE,
   0xDF,   0xDF,   0xE0,   0xE1,   0xE1,   0xE2,   0xE3,   0xE4,
   0xE4,   0xE5,   0xE6,   0xE6,   0xE7,   0xE8,   0xE8,   0xE9,
   0xEA,   0xEB,   0xEB,   0xEC,   0xED,   0xED,   0xEE,   0xEF,
   0xEF,   0xF0,   0xF1,   0xF1,   0xF2,   0xF3,   0xF4,   0xF4,
   0xF5,   0xF6,   0xF6,   0xF7,   0xF8,   0xF8,   0xF9,   0xFA,
   0xFA,   0xFB,   0xFC,   0xFC,   0xFD,   0xFE,   0xFE,   0xFF
};

BYTE ajGammaCT_16[256] = {
 0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x01,   0x01,
 0x01,   0x01,   0x01,   0x02,   0x02,   0x02,   0x02,   0x03,
 0x03,   0x03,   0x04,   0x04,   0x04,   0x05,   0x05,   0x05,
 0x06,   0x06,   0x07,   0x07,   0x07,   0x08,   0x08,   0x09,
 0x09,   0x0A,   0x0A,   0x0B,   0x0B,   0x0C,   0x0C,   0x0D,
 0x0D,   0x0E,   0x0E,   0x0F,   0x0F,   0x10,   0x10,   0x11,
 0x12,   0x12,   0x13,   0x13,   0x14,   0x15,   0x15,   0x16,
 0x17,   0x17,   0x18,   0x19,   0x19,   0x1A,   0x1B,   0x1B,
 0x1C,   0x1D,   0x1D,   0x1E,   0x1F,   0x1F,   0x20,   0x21,
 0x22,   0x22,   0x23,   0x24,   0x25,   0x26,   0x26,   0x27,
 0x28,   0x29,   0x2A,   0x2A,   0x2B,   0x2C,   0x2D,   0x2E,
 0x2E,   0x2F,   0x30,   0x31,   0x32,   0x33,   0x34,   0x35,
 0x35,   0x36,   0x37,   0x38,   0x39,   0x3A,   0x3B,   0x3C,
 0x3D,   0x3E,   0x3F,   0x40,   0x40,   0x41,   0x42,   0x43,
 0x44,   0x45,   0x46,   0x47,   0x48,   0x49,   0x4A,   0x4B,
 0x4C,   0x4D,   0x4E,   0x4F,   0x50,   0x51,   0x53,   0x54,
 0x55,   0x56,   0x57,   0x58,   0x59,   0x5A,   0x5B,   0x5C,
 0x5D,   0x5E,   0x5F,   0x61,   0x62,   0x63,   0x64,   0x65,
 0x66,   0x67,   0x68,   0x6A,   0x6B,   0x6C,   0x6D,   0x6E,
 0x6F,   0x71,   0x72,   0x73,   0x74,   0x75,   0x77,   0x78,
 0x79,   0x7A,   0x7B,   0x7D,   0x7E,   0x7F,   0x80,   0x82,
 0x83,   0x84,   0x85,   0x87,   0x88,   0x89,   0x8A,   0x8C,
 0x8D,   0x8E,   0x8F,   0x91,   0x92,   0x93,   0x95,   0x96,
 0x97,   0x99,   0x9A,   0x9B,   0x9D,   0x9E,   0x9F,   0xA1,
 0xA2,   0xA3,   0xA5,   0xA6,   0xA7,   0xA9,   0xAA,   0xAB,
 0xAD,   0xAE,   0xB0,   0xB1,   0xB2,   0xB4,   0xB5,   0xB7,
 0xB8,   0xB9,   0xBB,   0xBC,   0xBE,   0xBF,   0xC1,   0xC2,
 0xC4,   0xC5,   0xC6,   0xC8,   0xC9,   0xCB,   0xCC,   0xCE,
 0xCF,   0xD1,   0xD2,   0xD4,   0xD5,   0xD7,   0xD8,   0xDA,
 0xDB,   0xDD,   0xDE,   0xE0,   0xE1,   0xE3,   0xE4,   0xE6,
 0xE7,   0xE9,   0xEB,   0xEC,   0xEE,   0xEF,   0xF1,   0xF2,
 0xF4,   0xF5,   0xF7,   0xF9,   0xFA,   0xFC,   0xFD,   0xFF
};

BYTE ajGammaInvCT_16[256] = {
 0x00,   0x08,   0x0C,   0x10,   0x13,   0x16,   0x18,   0x1B,
 0x1D,   0x20,   0x22,   0x24,   0x26,   0x28,   0x2A,   0x2B,
 0x2D,   0x2F,   0x31,   0x32,   0x34,   0x36,   0x37,   0x39,
 0x3A,   0x3C,   0x3D,   0x3F,   0x40,   0x42,   0x43,   0x44,
 0x46,   0x47,   0x48,   0x4A,   0x4B,   0x4C,   0x4E,   0x4F,
 0x50,   0x51,   0x53,   0x54,   0x55,   0x56,   0x57,   0x59,
 0x5A,   0x5B,   0x5C,   0x5D,   0x5E,   0x60,   0x61,   0x62,
 0x63,   0x64,   0x65,   0x66,   0x67,   0x68,   0x69,   0x6A,
 0x6B,   0x6D,   0x6E,   0x6F,   0x70,   0x71,   0x72,   0x73,
 0x74,   0x75,   0x76,   0x77,   0x78,   0x79,   0x7A,   0x7B,
 0x7C,   0x7D,   0x7D,   0x7E,   0x7F,   0x80,   0x81,   0x82,
 0x83,   0x84,   0x85,   0x86,   0x87,   0x88,   0x89,   0x8A,
 0x8A,   0x8B,   0x8C,   0x8D,   0x8E,   0x8F,   0x90,   0x91,
 0x92,   0x92,   0x93,   0x94,   0x95,   0x96,   0x97,   0x98,
 0x98,   0x99,   0x9A,   0x9B,   0x9C,   0x9D,   0x9E,   0x9E,
 0x9F,   0xA0,   0xA1,   0xA2,   0xA2,   0xA3,   0xA4,   0xA5,
 0xA6,   0xA7,   0xA7,   0xA8,   0xA9,   0xAA,   0xAB,   0xAB,
 0xAC,   0xAD,   0xAE,   0xAF,   0xAF,   0xB0,   0xB1,   0xB2,
 0xB2,   0xB3,   0xB4,   0xB5,   0xB5,   0xB6,   0xB7,   0xB8,
 0xB9,   0xB9,   0xBA,   0xBB,   0xBC,   0xBC,   0xBD,   0xBE,
 0xBF,   0xBF,   0xC0,   0xC1,   0xC2,   0xC2,   0xC3,   0xC4,
 0xC4,   0xC5,   0xC6,   0xC7,   0xC7,   0xC8,   0xC9,   0xCA,
 0xCA,   0xCB,   0xCC,   0xCC,   0xCD,   0xCE,   0xCF,   0xCF,
 0xD0,   0xD1,   0xD1,   0xD2,   0xD3,   0xD3,   0xD4,   0xD5,
 0xD6,   0xD6,   0xD7,   0xD8,   0xD8,   0xD9,   0xDA,   0xDA,
 0xDB,   0xDC,   0xDC,   0xDD,   0xDE,   0xDE,   0xDF,   0xE0,
 0xE1,   0xE1,   0xE2,   0xE3,   0xE3,   0xE4,   0xE5,   0xE5,
 0xE6,   0xE7,   0xE7,   0xE8,   0xE9,   0xE9,   0xEA,   0xEB,
 0xEB,   0xEC,   0xEC,   0xED,   0xEE,   0xEE,   0xEF,   0xF0,
 0xF0,   0xF1,   0xF2,   0xF2,   0xF3,   0xF4,   0xF4,   0xF5,
 0xF6,   0xF6,   0xF7,   0xF7,   0xF8,   0xF9,   0xF9,   0xFA,
 0xFB,   0xFB,   0xFC,   0xFC,   0xFD,   0xFE,   0xFE,   0xFF
};

BYTE ajGammaCT_17[256] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 
0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 
0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07, 
0x07, 0x08, 0x08, 0x09, 0x09, 0x0A, 0x0A, 0x0A, 
0x0B, 0x0B, 0x0C, 0x0C, 0x0D, 0x0D, 0x0E, 0x0E, 
0x0F, 0x0F, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 
0x13, 0x14, 0x15, 0x15, 0x16, 0x16, 0x17, 0x18, 
0x18, 0x19, 0x1A, 0x1A, 0x1B, 0x1C, 0x1C, 0x1D, 
0x1E, 0x1E, 0x1F, 0x20, 0x21, 0x21, 0x22, 0x23, 
0x24, 0x24, 0x25, 0x26, 0x27, 0x27, 0x28, 0x29, 
0x2A, 0x2B, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
0x38, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 
0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 
0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 
0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 
0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 
0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x69, 
0x6A, 0x6B, 0x6C, 0x6D, 0x6F, 0x70, 0x71, 0x72, 
0x73, 0x75, 0x76, 0x77, 0x78, 0x7A, 0x7B, 0x7C, 
0x7D, 0x7F, 0x80, 0x81, 0x83, 0x84, 0x85, 0x86, 
0x88, 0x89, 0x8A, 0x8C, 0x8D, 0x8E, 0x90, 0x91, 
0x92, 0x94, 0x95, 0x97, 0x98, 0x99, 0x9B, 0x9C, 
0x9D, 0x9F, 0xA0, 0xA2, 0xA3, 0xA4, 0xA6, 0xA7, 
0xA9, 0xAA, 0xAC, 0xAD, 0xAE, 0xB0, 0xB1, 0xB3, 
0xB4, 0xB6, 0xB7, 0xB9, 0xBA, 0xBC, 0xBD, 0xBF, 
0xC0, 0xC2, 0xC3, 0xC5, 0xC6, 0xC8, 0xC9, 0xCB, 
0xCD, 0xCE, 0xD0, 0xD1, 0xD3, 0xD4, 0xD6, 0xD8, 
0xD9, 0xDB, 0xDC, 0xDE, 0xE0, 0xE1, 0xE3, 0xE4, 
0xE6, 0xE8, 0xE9, 0xEB, 0xED, 0xEE, 0xF0, 0xF2, 
0xF3, 0xF5, 0xF7, 0xF8, 0xFA, 0xFC, 0xFD, 0xFF
};

BYTE ajGammaInvCT_17[256] = {
0x00, 0x0A, 0x0F, 0x13, 0x16, 0x19, 0x1C, 0x1F, 
0x21, 0x24, 0x26, 0x28, 0x2A, 0x2C, 0x2E, 0x30, 
0x32, 0x34, 0x36, 0x37, 0x39, 0x3B, 0x3C, 0x3E, 
0x40, 0x41, 0x43, 0x44, 0x46, 0x47, 0x48, 0x4A, 
0x4B, 0x4D, 0x4E, 0x4F, 0x51, 0x52, 0x53, 0x54, 
0x56, 0x57, 0x58, 0x59, 0x5B, 0x5C, 0x5D, 0x5E, 
0x5F, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 
0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 
0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 
0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 
0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x87, 
0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 
0x90, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 
0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9C, 
0x9D, 0x9E, 0x9F, 0xA0, 0xA0, 0xA1, 0xA2, 0xA3, 
0xA4, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA8, 0xA9, 
0xAA, 0xAB, 0xAC, 0xAC, 0xAD, 0xAE, 0xAF, 0xAF, 
0xB0, 0xB1, 0xB2, 0xB2, 0xB3, 0xB4, 0xB5, 0xB5, 
0xB6, 0xB7, 0xB8, 0xB8, 0xB9, 0xBA, 0xBB, 0xBB, 
0xBC, 0xBD, 0xBE, 0xBE, 0xBF, 0xC0, 0xC0, 0xC1, 
0xC2, 0xC3, 0xC3, 0xC4, 0xC5, 0xC5, 0xC6, 0xC7, 
0xC7, 0xC8, 0xC9, 0xCA, 0xCA, 0xCB, 0xCC, 0xCC, 
0xCD, 0xCE, 0xCE, 0xCF, 0xD0, 0xD0, 0xD1, 0xD2, 
0xD2, 0xD3, 0xD4, 0xD4, 0xD5, 0xD6, 0xD6, 0xD7, 
0xD8, 0xD8, 0xD9, 0xDA, 0xDA, 0xDB, 0xDC, 0xDC, 
0xDD, 0xDE, 0xDE, 0xDF, 0xE0, 0xE0, 0xE1, 0xE2, 
0xE2, 0xE3, 0xE3, 0xE4, 0xE5, 0xE5, 0xE6, 0xE7, 
0xE7, 0xE8, 0xE9, 0xE9, 0xEA, 0xEA, 0xEB, 0xEC, 
0xEC, 0xED, 0xEE, 0xEE, 0xEF, 0xEF, 0xF0, 0xF1, 
0xF1, 0xF2, 0xF2, 0xF3, 0xF4, 0xF4, 0xF5, 0xF5, 
0xF6, 0xF7, 0xF7, 0xF8, 0xF8, 0xF9, 0xFA, 0xFA, 
0xFB, 0xFB, 0xFC, 0xFD, 0xFD, 0xFE, 0xFE, 0xFF 
};

// 1.8 gamma tables, we use these as default for now

BYTE ajGammaCT_18[256] = {
 0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,
 0x01,   0x01,   0x01,   0x01,   0x01,   0x01,   0x01,   0x02,
 0x02,   0x02,   0x02,   0x02,   0x03,   0x03,   0x03,   0x03,
 0x04,   0x04,   0x04,   0x04,   0x05,   0x05,   0x05,   0x06,
 0x06,   0x06,   0x07,   0x07,   0x08,   0x08,   0x08,   0x09,
 0x09,   0x0A,   0x0A,   0x0A,   0x0B,   0x0B,   0x0C,   0x0C,
 0x0D,   0x0D,   0x0E,   0x0E,   0x0F,   0x0F,   0x10,   0x10,
 0x11,   0x11,   0x12,   0x12,   0x13,   0x13,   0x14,   0x15,
 0x15,   0x16,   0x16,   0x17,   0x18,   0x18,   0x19,   0x1A,
 0x1A,   0x1B,   0x1C,   0x1C,   0x1D,   0x1E,   0x1E,   0x1F,
 0x20,   0x20,   0x21,   0x22,   0x23,   0x23,   0x24,   0x25,
 0x26,   0x26,   0x27,   0x28,   0x29,   0x29,   0x2A,   0x2B,
 0x2C,   0x2D,   0x2E,   0x2E,   0x2F,   0x30,   0x31,   0x32,
 0x33,   0x34,   0x35,   0x35,   0x36,   0x37,   0x38,   0x39,
 0x3A,   0x3B,   0x3C,   0x3D,   0x3E,   0x3F,   0x40,   0x41,
 0x42,   0x43,   0x44,   0x45,   0x46,   0x47,   0x48,   0x49,
 0x4A,   0x4B,   0x4C,   0x4D,   0x4E,   0x4F,   0x50,   0x51,
 0x52,   0x53,   0x54,   0x56,   0x57,   0x58,   0x59,   0x5A,
 0x5B,   0x5C,   0x5D,   0x5F,   0x60,   0x61,   0x62,   0x63,
 0x64,   0x66,   0x67,   0x68,   0x69,   0x6B,   0x6C,   0x6D,
 0x6E,   0x6F,   0x71,   0x72,   0x73,   0x74,   0x76,   0x77,
 0x78,   0x7A,   0x7B,   0x7C,   0x7E,   0x7F,   0x80,   0x81,
 0x83,   0x84,   0x86,   0x87,   0x88,   0x8A,   0x8B,   0x8C,
 0x8E,   0x8F,   0x91,   0x92,   0x93,   0x95,   0x96,   0x98,
 0x99,   0x9A,   0x9C,   0x9D,   0x9F,   0xA0,   0xA2,   0xA3,
 0xA5,   0xA6,   0xA8,   0xA9,   0xAB,   0xAC,   0xAE,   0xAF,
 0xB1,   0xB2,   0xB4,   0xB5,   0xB7,   0xB8,   0xBA,   0xBC,
 0xBD,   0xBF,   0xC0,   0xC2,   0xC3,   0xC5,   0xC7,   0xC8,
 0xCA,   0xCC,   0xCD,   0xCF,   0xD0,   0xD2,   0xD4,   0xD5,
 0xD7,   0xD9,   0xDA,   0xDC,   0xDE,   0xE0,   0xE1,   0xE3,
 0xE5,   0xE6,   0xE8,   0xEA,   0xEC,   0xED,   0xEF,   0xF1,
 0xF3,   0xF4,   0xF6,   0xF8,   0xFA,   0xFB,   0xFD,   0xFF
};

BYTE ajGammaInvCT_18[256] = {
 0x00,   0x0C,   0x11,   0x16,   0x19,   0x1D,   0x20,   0x23,
 0x25,   0x28,   0x2A,   0x2C,   0x2F,   0x31,   0x33,   0x35,
 0x37,   0x39,   0x3A,   0x3C,   0x3E,   0x40,   0x41,   0x43,
 0x45,   0x46,   0x48,   0x49,   0x4B,   0x4C,   0x4E,   0x4F,
 0x50,   0x52,   0x53,   0x55,   0x56,   0x57,   0x59,   0x5A,
 0x5B,   0x5C,   0x5E,   0x5F,   0x60,   0x61,   0x62,   0x64,
 0x65,   0x66,   0x67,   0x68,   0x69,   0x6B,   0x6C,   0x6D,
 0x6E,   0x6F,   0x70,   0x71,   0x72,   0x73,   0x74,   0x75,
 0x76,   0x77,   0x78,   0x79,   0x7A,   0x7B,   0x7C,   0x7D,
 0x7E,   0x7F,   0x80,   0x81,   0x82,   0x83,   0x84,   0x85,
 0x86,   0x87,   0x88,   0x89,   0x8A,   0x8B,   0x8B,   0x8C,
 0x8D,   0x8E,   0x8F,   0x90,   0x91,   0x92,   0x92,   0x93,
 0x94,   0x95,   0x96,   0x97,   0x98,   0x98,   0x99,   0x9A,
 0x9B,   0x9C,   0x9D,   0x9D,   0x9E,   0x9F,   0xA0,   0xA1,
 0xA1,   0xA2,   0xA3,   0xA4,   0xA5,   0xA5,   0xA6,   0xA7,
 0xA8,   0xA9,   0xA9,   0xAA,   0xAB,   0xAC,   0xAC,   0xAD,
 0xAE,   0xAF,   0xAF,   0xB0,   0xB1,   0xB2,   0xB2,   0xB3,
 0xB4,   0xB5,   0xB5,   0xB6,   0xB7,   0xB7,   0xB8,   0xB9,
 0xBA,   0xBA,   0xBB,   0xBC,   0xBC,   0xBD,   0xBE,   0xBF,
 0xBF,   0xC0,   0xC1,   0xC1,   0xC2,   0xC3,   0xC3,   0xC4,
 0xC5,   0xC6,   0xC6,   0xC7,   0xC8,   0xC8,   0xC9,   0xCA,
 0xCA,   0xCB,   0xCC,   0xCC,   0xCD,   0xCE,   0xCE,   0xCF,
 0xD0,   0xD0,   0xD1,   0xD1,   0xD2,   0xD3,   0xD3,   0xD4,
 0xD5,   0xD5,   0xD6,   0xD7,   0xD7,   0xD8,   0xD9,   0xD9,
 0xDA,   0xDA,   0xDB,   0xDC,   0xDC,   0xDD,   0xDE,   0xDE,
 0xDF,   0xDF,   0xE0,   0xE1,   0xE1,   0xE2,   0xE2,   0xE3,
 0xE4,   0xE4,   0xE5,   0xE6,   0xE6,   0xE7,   0xE7,   0xE8,
 0xE9,   0xE9,   0xEA,   0xEA,   0xEB,   0xEC,   0xEC,   0xED,
 0xED,   0xEE,   0xEE,   0xEF,   0xF0,   0xF0,   0xF1,   0xF1,
 0xF2,   0xF3,   0xF3,   0xF4,   0xF4,   0xF5,   0xF5,   0xF6,
 0xF7,   0xF7,   0xF8,   0xF8,   0xF9,   0xF9,   0xFA,   0xFB,
 0xFB,   0xFC,   0xFC,   0xFD,   0xFD,   0xFE,   0xFE,   0xFF
};

BYTE ajGammaCT_19[256] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 
0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x05, 
0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 
0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x0A, 0x0A, 
0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0E, 
0x0E, 0x0F, 0x0F, 0x10, 0x10, 0x11, 0x11, 0x12, 
0x12, 0x13, 0x14, 0x14, 0x15, 0x15, 0x16, 0x16, 
0x17, 0x18, 0x18, 0x19, 0x1A, 0x1A, 0x1B, 0x1C, 
0x1C, 0x1D, 0x1E, 0x1E, 0x1F, 0x20, 0x20, 0x21, 
0x22, 0x23, 0x23, 0x24, 0x25, 0x26, 0x26, 0x27, 
0x28, 0x29, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 
0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 
0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 
0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 
0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 
0x4D, 0x4E, 0x4F, 0x51, 0x52, 0x53, 0x54, 0x55, 
0x56, 0x57, 0x58, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 
0x5F, 0x61, 0x62, 0x63, 0x64, 0x65, 0x67, 0x68, 
0x69, 0x6A, 0x6C, 0x6D, 0x6E, 0x70, 0x71, 0x72, 
0x73, 0x75, 0x76, 0x77, 0x79, 0x7A, 0x7B, 0x7D, 
0x7E, 0x7F, 0x81, 0x82, 0x84, 0x85, 0x86, 0x88, 
0x89, 0x8B, 0x8C, 0x8D, 0x8F, 0x90, 0x92, 0x93, 
0x95, 0x96, 0x98, 0x99, 0x9B, 0x9C, 0x9E, 0x9F, 
0xA1, 0xA2, 0xA4, 0xA5, 0xA7, 0xA8, 0xAA, 0xAC, 
0xAD, 0xAF, 0xB0, 0xB2, 0xB4, 0xB5, 0xB7, 0xB8, 
0xBA, 0xBC, 0xBD, 0xBF, 0xC1, 0xC2, 0xC4, 0xC6, 
0xC7, 0xC9, 0xCB, 0xCC, 0xCE, 0xD0, 0xD2, 0xD3, 
0xD5, 0xD7, 0xD9, 0xDA, 0xDC, 0xDE, 0xE0, 0xE1, 
0xE3, 0xE5, 0xE7, 0xE9, 0xEB, 0xEC, 0xEE, 0xF0, 
0xF2, 0xF4, 0xF6, 0xF7, 0xF9, 0xFB, 0xFD, 0xFF
};

BYTE ajGammaInvCT_19[256] = {
0x00, 0x0E, 0x14, 0x19, 0x1D, 0x20, 0x23, 0x26, 
0x29, 0x2C, 0x2E, 0x31, 0x33, 0x35, 0x37, 0x39, 
0x3B, 0x3D, 0x3F, 0x41, 0x43, 0x45, 0x46, 0x48, 
0x4A, 0x4B, 0x4D, 0x4E, 0x50, 0x51, 0x53, 0x54, 
0x56, 0x57, 0x58, 0x5A, 0x5B, 0x5C, 0x5E, 0x5F, 
0x60, 0x61, 0x63, 0x64, 0x65, 0x66, 0x68, 0x69, 
0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x70, 0x71, 0x72, 
0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 
0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82, 
0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 
0x8B, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x91, 
0x92, 0x93, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 
0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9D, 0x9E, 
0x9F, 0xA0, 0xA1, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 
0xA5, 0xA6, 0xA7, 0xA8, 0xA8, 0xA9, 0xAA, 0xAB, 
0xAB, 0xAC, 0xAD, 0xAE, 0xAE, 0xAF, 0xB0, 0xB1, 
0xB1, 0xB2, 0xB3, 0xB4, 0xB4, 0xB5, 0xB6, 0xB6, 
0xB7, 0xB8, 0xB9, 0xB9, 0xBA, 0xBB, 0xBB, 0xBC, 
0xBD, 0xBD, 0xBE, 0xBF, 0xC0, 0xC0, 0xC1, 0xC2, 
0xC2, 0xC3, 0xC4, 0xC4, 0xC5, 0xC6, 0xC6, 0xC7, 
0xC8, 0xC8, 0xC9, 0xC9, 0xCA, 0xCB, 0xCB, 0xCC, 
0xCD, 0xCD, 0xCE, 0xCF, 0xCF, 0xD0, 0xD1, 0xD1, 
0xD2, 0xD2, 0xD3, 0xD4, 0xD4, 0xD5, 0xD6, 0xD6, 
0xD7, 0xD7, 0xD8, 0xD9, 0xD9, 0xDA, 0xDA, 0xDB, 
0xDC, 0xDC, 0xDD, 0xDD, 0xDE, 0xDF, 0xDF, 0xE0, 
0xE0, 0xE1, 0xE2, 0xE2, 0xE3, 0xE3, 0xE4, 0xE4, 
0xE5, 0xE6, 0xE6, 0xE7, 0xE7, 0xE8, 0xE9, 0xE9, 
0xEA, 0xEA, 0xEB, 0xEB, 0xEC, 0xEC, 0xED, 0xEE, 
0xEE, 0xEF, 0xEF, 0xF0, 0xF0, 0xF1, 0xF2, 0xF2, 
0xF3, 0xF3, 0xF4, 0xF4, 0xF5, 0xF5, 0xF6, 0xF6, 
0xF7, 0xF8, 0xF8, 0xF9, 0xF9, 0xFA, 0xFA, 0xFB, 
0xFB, 0xFC, 0xFC, 0xFD, 0xFD, 0xFE, 0xFE, 0xFF
};

BYTE ajGammaCT_20[256] = {
 0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,
 0x00,   0x00,   0x00,   0x00,   0x01,   0x01,   0x01,   0x01,
 0x01,   0x01,   0x01,   0x01,   0x02,   0x02,   0x02,   0x02,
 0x02,   0x02,   0x03,   0x03,   0x03,   0x03,   0x04,   0x04,
 0x04,   0x04,   0x05,   0x05,   0x05,   0x05,   0x06,   0x06,
 0x06,   0x07,   0x07,   0x07,   0x08,   0x08,   0x08,   0x09,
 0x09,   0x09,   0x0A,   0x0A,   0x0B,   0x0B,   0x0B,   0x0C,
 0x0C,   0x0D,   0x0D,   0x0E,   0x0E,   0x0F,   0x0F,   0x10,
 0x10,   0x11,   0x11,   0x12,   0x12,   0x13,   0x13,   0x14,
 0x14,   0x15,   0x15,   0x16,   0x17,   0x17,   0x18,   0x18,
 0x19,   0x1A,   0x1A,   0x1B,   0x1C,   0x1C,   0x1D,   0x1E,
 0x1E,   0x1F,   0x20,   0x20,   0x21,   0x22,   0x23,   0x23,
 0x24,   0x25,   0x26,   0x26,   0x27,   0x28,   0x29,   0x2A,
 0x2A,   0x2B,   0x2C,   0x2D,   0x2E,   0x2F,   0x2F,   0x30,
 0x31,   0x32,   0x33,   0x34,   0x35,   0x36,   0x37,   0x38,
 0x38,   0x39,   0x3A,   0x3B,   0x3C,   0x3D,   0x3E,   0x3F,
 0x40,   0x41,   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,
 0x49,   0x4A,   0x4B,   0x4C,   0x4D,   0x4E,   0x4F,   0x50,
 0x51,   0x52,   0x54,   0x55,   0x56,   0x57,   0x58,   0x59,
 0x5B,   0x5C,   0x5D,   0x5E,   0x5F,   0x61,   0x62,   0x63,
 0x64,   0x66,   0x67,   0x68,   0x69,   0x6B,   0x6C,   0x6D,
 0x6F,   0x70,   0x71,   0x73,   0x74,   0x75,   0x77,   0x78,
 0x79,   0x7B,   0x7C,   0x7E,   0x7F,   0x80,   0x82,   0x83,
 0x85,   0x86,   0x88,   0x89,   0x8B,   0x8C,   0x8E,   0x8F,
 0x91,   0x92,   0x94,   0x95,   0x97,   0x98,   0x9A,   0x9B,
 0x9D,   0x9E,   0xA0,   0xA2,   0xA3,   0xA5,   0xA6,   0xA8,
 0xAA,   0xAB,   0xAD,   0xAF,   0xB0,   0xB2,   0xB4,   0xB5,
 0xB7,   0xB9,   0xBA,   0xBC,   0xBE,   0xC0,   0xC1,   0xC3,
 0xC5,   0xC7,   0xC8,   0xCA,   0xCC,   0xCE,   0xCF,   0xD1,
 0xD3,   0xD5,   0xD7,   0xD9,   0xDA,   0xDC,   0xDE,   0xE0,
 0xE2,   0xE4,   0xE6,   0xE8,   0xE9,   0xEB,   0xED,   0xEF,
 0xF1,   0xF3,   0xF5,   0xF7,   0xF9,   0xFB,   0xFD,   0xFF
};



BYTE ajGammaInvCT_20[256] = {
 0x00,   0x10,   0x17,   0x1C,   0x20,   0x24,   0x27,   0x2A,
 0x2D,   0x30,   0x32,   0x35,   0x37,   0x3A,   0x3C,   0x3E,
 0x40,   0x42,   0x44,   0x46,   0x47,   0x49,   0x4B,   0x4D,
 0x4E,   0x50,   0x51,   0x53,   0x54,   0x56,   0x57,   0x59,
 0x5A,   0x5C,   0x5D,   0x5E,   0x60,   0x61,   0x62,   0x64,
 0x65,   0x66,   0x67,   0x69,   0x6A,   0x6B,   0x6C,   0x6D,
 0x6F,   0x70,   0x71,   0x72,   0x73,   0x74,   0x75,   0x76,
 0x77,   0x79,   0x7A,   0x7B,   0x7C,   0x7D,   0x7E,   0x7F,
 0x80,   0x81,   0x82,   0x83,   0x84,   0x85,   0x86,   0x87,
 0x87,   0x88,   0x89,   0x8A,   0x8B,   0x8C,   0x8D,   0x8E,
 0x8F,   0x90,   0x91,   0x91,   0x92,   0x93,   0x94,   0x95,
 0x96,   0x97,   0x97,   0x98,   0x99,   0x9A,   0x9B,   0x9C,
 0x9C,   0x9D,   0x9E,   0x9F,   0xA0,   0xA0,   0xA1,   0xA2,
 0xA3,   0xA4,   0xA4,   0xA5,   0xA6,   0xA7,   0xA7,   0xA8,
 0xA9,   0xAA,   0xAA,   0xAB,   0xAC,   0xAD,   0xAD,   0xAE,
 0xAF,   0xB0,   0xB0,   0xB1,   0xB2,   0xB3,   0xB3,   0xB4,
 0xB5,   0xB5,   0xB6,   0xB7,   0xB7,   0xB8,   0xB9,   0xBA,
 0xBA,   0xBB,   0xBC,   0xBC,   0xBD,   0xBE,   0xBE,   0xBF,
 0xC0,   0xC0,   0xC1,   0xC2,   0xC2,   0xC3,   0xC4,   0xC4,
 0xC5,   0xC6,   0xC6,   0xC7,   0xC7,   0xC8,   0xC9,   0xC9,
 0xCA,   0xCB,   0xCB,   0xCC,   0xCC,   0xCD,   0xCE,   0xCE,
 0xCF,   0xD0,   0xD0,   0xD1,   0xD1,   0xD2,   0xD3,   0xD3,
 0xD4,   0xD4,   0xD5,   0xD6,   0xD6,   0xD7,   0xD7,   0xD8,
 0xD9,   0xD9,   0xDA,   0xDA,   0xDB,   0xDC,   0xDC,   0xDD,
 0xDD,   0xDE,   0xDE,   0xDF,   0xE0,   0xE0,   0xE1,   0xE1,
 0xE2,   0xE2,   0xE3,   0xE4,   0xE4,   0xE5,   0xE5,   0xE6,
 0xE6,   0xE7,   0xE7,   0xE8,   0xE9,   0xE9,   0xEA,   0xEA,
 0xEB,   0xEB,   0xEC,   0xEC,   0xED,   0xED,   0xEE,   0xEE,
 0xEF,   0xF0,   0xF0,   0xF1,   0xF1,   0xF2,   0xF2,   0xF3,
 0xF3,   0xF4,   0xF4,   0xF5,   0xF5,   0xF6,   0xF6,   0xF7,
 0xF7,   0xF8,   0xF8,   0xF9,   0xF9,   0xFA,   0xFA,   0xFB,
 0xFB,   0xFC,   0xFC,   0xFD,   0xFD,   0xFE,   0xFE,   0xFF
};

BYTE ajGammaCT_21[256] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 
0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 
0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x0A, 0x0A, 
0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0D, 0x0D, 0x0E, 
0x0E, 0x0E, 0x0F, 0x0F, 0x10, 0x10, 0x11, 0x11, 
0x12, 0x12, 0x13, 0x14, 0x14, 0x15, 0x15, 0x16, 
0x16, 0x17, 0x18, 0x18, 0x19, 0x19, 0x1A, 0x1B, 
0x1B, 0x1C, 0x1D, 0x1D, 0x1E, 0x1F, 0x1F, 0x20, 
0x21, 0x21, 0x22, 0x23, 0x24, 0x24, 0x25, 0x26, 
0x27, 0x28, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2C, 
0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x33, 
0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 
0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 
0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4B, 0x4C, 
0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x53, 0x54, 0x55, 
0x56, 0x57, 0x58, 0x5A, 0x5B, 0x5C, 0x5D, 0x5F, 
0x60, 0x61, 0x62, 0x64, 0x65, 0x66, 0x68, 0x69, 
0x6A, 0x6B, 0x6D, 0x6E, 0x70, 0x71, 0x72, 0x74, 
0x75, 0x76, 0x78, 0x79, 0x7B, 0x7C, 0x7E, 0x7F, 
0x81, 0x82, 0x83, 0x85, 0x86, 0x88, 0x89, 0x8B, 
0x8D, 0x8E, 0x90, 0x91, 0x93, 0x94, 0x96, 0x97, 
0x99, 0x9B, 0x9C, 0x9E, 0xA0, 0xA1, 0xA3, 0xA5, 
0xA6, 0xA8, 0xAA, 0xAB, 0xAD, 0xAF, 0xB0, 0xB2, 
0xB4, 0xB6, 0xB7, 0xB9, 0xBB, 0xBD, 0xBF, 0xC0, 
0xC2, 0xC4, 0xC6, 0xC8, 0xCA, 0xCB, 0xCD, 0xCF, 
0xD1, 0xD3, 0xD5, 0xD7, 0xD9, 0xDB, 0xDD, 0xDF, 
0xE1, 0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEC, 0xEE, 
0xF1, 0xF3, 0xF5, 0xF7, 0xF9, 0xFB, 0xFD, 0xFF
};

BYTE ajGammaInvCT_21[256] = {
0x00, 0x12, 0x19, 0x1F, 0x23, 0x27, 0x2B, 0x2E, 
0x31, 0x34, 0x37, 0x39, 0x3B, 0x3E, 0x40, 0x42, 
0x44, 0x46, 0x48, 0x4A, 0x4C, 0x4E, 0x4F, 0x51, 
0x53, 0x54, 0x56, 0x58, 0x59, 0x5B, 0x5C, 0x5D, 
0x5F, 0x60, 0x62, 0x63, 0x64, 0x66, 0x67, 0x68, 
0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x70, 0x71, 0x72, 
0x73, 0x74, 0x75, 0x76, 0x78, 0x79, 0x7A, 0x7B, 
0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82, 0x83, 
0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 
0x8C, 0x8D, 0x8D, 0x8E, 0x8F, 0x90, 0x91, 0x92, 
0x93, 0x94, 0x95, 0x95, 0x96, 0x97, 0x98, 0x99, 
0x9A, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0x9F, 
0xA0, 0xA1, 0xA2, 0xA3, 0xA3, 0xA4, 0xA5, 0xA6, 
0xA6, 0xA7, 0xA8, 0xA9, 0xA9, 0xAA, 0xAB, 0xAC, 
0xAC, 0xAD, 0xAE, 0xAF, 0xAF, 0xB0, 0xB1, 0xB1, 
0xB2, 0xB3, 0xB4, 0xB4, 0xB5, 0xB6, 0xB6, 0xB7, 
0xB8, 0xB8, 0xB9, 0xBA, 0xBA, 0xBB, 0xBC, 0xBC, 
0xBD, 0xBE, 0xBE, 0xBF, 0xC0, 0xC0, 0xC1, 0xC2, 
0xC2, 0xC3, 0xC4, 0xC4, 0xC5, 0xC5, 0xC6, 0xC7, 
0xC7, 0xC8, 0xC9, 0xC9, 0xCA, 0xCA, 0xCB, 0xCC, 
0xCC, 0xCD, 0xCD, 0xCE, 0xCF, 0xCF, 0xD0, 0xD0, 
0xD1, 0xD2, 0xD2, 0xD3, 0xD3, 0xD4, 0xD5, 0xD5, 
0xD6, 0xD6, 0xD7, 0xD7, 0xD8, 0xD9, 0xD9, 0xDA, 
0xDA, 0xDB, 0xDB, 0xDC, 0xDD, 0xDD, 0xDE, 0xDE, 
0xDF, 0xDF, 0xE0, 0xE0, 0xE1, 0xE2, 0xE2, 0xE3, 
0xE3, 0xE4, 0xE4, 0xE5, 0xE5, 0xE6, 0xE6, 0xE7, 
0xE7, 0xE8, 0xE8, 0xE9, 0xEA, 0xEA, 0xEB, 0xEB, 
0xEC, 0xEC, 0xED, 0xED, 0xEE, 0xEE, 0xEF, 0xEF, 
0xF0, 0xF0, 0xF1, 0xF1, 0xF2, 0xF2, 0xF3, 0xF3, 
0xF4, 0xF4, 0xF5, 0xF5, 0xF6, 0xF6, 0xF7, 0xF7, 
0xF8, 0xF8, 0xF9, 0xF9, 0xFA, 0xFA, 0xFB, 0xFB, 
0xFC, 0xFC, 0xFD, 0xFD, 0xFE, 0xFE, 0xFF, 0xFF
};

BYTE ajGammaCT_22[256] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 
0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 
0x06, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x09, 
0x09, 0x09, 0x0A, 0x0A, 0x0B, 0x0B, 0x0B, 0x0C, 
0x0C, 0x0D, 0x0D, 0x0D, 0x0E, 0x0E, 0x0F, 0x0F, 
0x10, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 0x13, 
0x14, 0x14, 0x15, 0x16, 0x16, 0x17, 0x17, 0x18, 
0x19, 0x19, 0x1A, 0x1A, 0x1B, 0x1C, 0x1C, 0x1D, 
0x1E, 0x1E, 0x1F, 0x20, 0x21, 0x21, 0x22, 0x23, 
0x23, 0x24, 0x25, 0x26, 0x27, 0x27, 0x28, 0x29, 
0x2A, 0x2B, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 
0x31, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 
0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x51, 
0x52, 0x53, 0x54, 0x55, 0x57, 0x58, 0x59, 0x5A, 
0x5B, 0x5D, 0x5E, 0x5F, 0x61, 0x62, 0x63, 0x64, 
0x66, 0x67, 0x69, 0x6A, 0x6B, 0x6D, 0x6E, 0x6F, 
0x71, 0x72, 0x74, 0x75, 0x77, 0x78, 0x79, 0x7B, 
0x7C, 0x7E, 0x7F, 0x81, 0x82, 0x84, 0x85, 0x87, 
0x89, 0x8A, 0x8C, 0x8D, 0x8F, 0x91, 0x92, 0x94, 
0x95, 0x97, 0x99, 0x9A, 0x9C, 0x9E, 0x9F, 0xA1, 
0xA3, 0xA5, 0xA6, 0xA8, 0xAA, 0xAC, 0xAD, 0xAF, 
0xB1, 0xB3, 0xB5, 0xB6, 0xB8, 0xBA, 0xBC, 0xBE, 
0xC0, 0xC2, 0xC4, 0xC5, 0xC7, 0xC9, 0xCB, 0xCD, 
0xCF, 0xD1, 0xD3, 0xD5, 0xD7, 0xD9, 0xDB, 0xDD, 
0xDF, 0xE1, 0xE3, 0xE5, 0xE7, 0xEA, 0xEC, 0xEE, 
0xF0, 0xF2, 0xF4, 0xF6, 0xF8, 0xFB, 0xFD, 0xFF 
};

BYTE ajGammaInvCT_22[256] = {
0x00, 0x15, 0x1C, 0x22, 0x27, 0x2B, 0x2E, 0x32, 
0x35, 0x38, 0x3B, 0x3D, 0x40, 0x42, 0x44, 0x46, 
0x48, 0x4A, 0x4C, 0x4E, 0x50, 0x52, 0x54, 0x55, 
0x57, 0x59, 0x5A, 0x5C, 0x5D, 0x5F, 0x60, 0x62, 
0x63, 0x65, 0x66, 0x67, 0x69, 0x6A, 0x6B, 0x6D, 
0x6E, 0x6F, 0x70, 0x72, 0x73, 0x74, 0x75, 0x76, 
0x77, 0x78, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 
0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 
0x90, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 
0x97, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9C, 
0x9D, 0x9E, 0x9F, 0xA0, 0xA0, 0xA1, 0xA2, 0xA3, 
0xA4, 0xA4, 0xA5, 0xA6, 0xA7, 0xA7, 0xA8, 0xA9, 
0xAA, 0xAA, 0xAB, 0xAC, 0xAD, 0xAD, 0xAE, 0xAF, 
0xAF, 0xB0, 0xB1, 0xB2, 0xB2, 0xB3, 0xB4, 0xB4, 
0xB5, 0xB6, 0xB6, 0xB7, 0xB8, 0xB8, 0xB9, 0xBA, 
0xBA, 0xBB, 0xBC, 0xBC, 0xBD, 0xBE, 0xBE, 0xBF, 
0xC0, 0xC0, 0xC1, 0xC2, 0xC2, 0xC3, 0xC3, 0xC4, 
0xC5, 0xC5, 0xC6, 0xC7, 0xC7, 0xC8, 0xC8, 0xC9, 
0xCA, 0xCA, 0xCB, 0xCB, 0xCC, 0xCD, 0xCD, 0xCE, 
0xCE, 0xCF, 0xCF, 0xD0, 0xD1, 0xD1, 0xD2, 0xD2, 
0xD3, 0xD4, 0xD4, 0xD5, 0xD5, 0xD6, 0xD6, 0xD7, 
0xD7, 0xD8, 0xD9, 0xD9, 0xDA, 0xDA, 0xDB, 0xDB, 
0xDC, 0xDC, 0xDD, 0xDD, 0xDE, 0xDF, 0xDF, 0xE0, 
0xE0, 0xE1, 0xE1, 0xE2, 0xE2, 0xE3, 0xE3, 0xE4, 
0xE4, 0xE5, 0xE5, 0xE6, 0xE6, 0xE7, 0xE7, 0xE8, 
0xE8, 0xE9, 0xE9, 0xEA, 0xEA, 0xEB, 0xEB, 0xEC, 
0xEC, 0xED, 0xED, 0xEE, 0xEE, 0xEF, 0xEF, 0xF0, 
0xF0, 0xF1, 0xF1, 0xF2, 0xF2, 0xF3, 0xF3, 0xF4, 
0xF4, 0xF5, 0xF5, 0xF6, 0xF6, 0xF7, 0xF7, 0xF8, 
0xF8, 0xF9, 0xF9, 0xF9, 0xFA, 0xFA, 0xFB, 0xFB, 
0xFC, 0xFC, 0xFD, 0xFD, 0xFE, 0xFE, 0xFF, 0xFF
};

VOID vGetBlendInfo (
    ULONG size, SURFACE *pS,            // input
    ULONG uF,                           // foreground color
    BLENDINFO  *pbi                     // output
)
{
    BLENDINFO  bi; // local for faster reference

    XEPALOBJ xpo;

    PDEVOBJ pdo(pS->hdev());

    if(pS->pPal == NULL)
    {
        xpo.ppalSet(pdo.ppalSurf());
    }
    else
    {
        xpo.ppalSet(pS->pPal);
    }

    ASSERTGDI(xpo.bValid(),      "Invalid XEPALOBJ" );

    if (xpo.bIsBitfields())
    {
        bi.flRed = xpo.flRed();
        bi.flGre = xpo.flGre();
        bi.flBlu = xpo.flBlu();

        bi.iRedR = (int) (xpo.cRedRight() + xpo.cRedMiddle() - 8);
        bi.iGreR = (int) (xpo.cGreRight() + xpo.cGreMiddle() - 8);
        bi.iBluR = (int) (xpo.cBluRight() + xpo.cBluMiddle() - 8);
    }
    else
    {
        int cBits;
        ULONG flBits;

        if (size == sizeof(USHORT))
        {
            // assumes standard RGB is 5+5+5 for 16-bit color
            cBits = 5;
            flBits = 0x1f;
        }
        else
        {
            cBits = 8;
            flBits = 0xff;
        }
        if (xpo.bIsRGB())
        {
            bi.flRed = flBits;
            bi.flGre = bi.flRed << cBits;
            bi.flBlu = bi.flGre << cBits;

            bi.iRedR = cBits - 8;
            bi.iGreR = bi.iRedR + cBits;
            bi.iBluR = bi.iGreR + cBits;
        }
        else if (xpo.bIsBGR())
        {
            bi.flBlu = flBits;
            bi.flGre = bi.flBlu << cBits;
            bi.flRed = bi.flGre << cBits;

            bi.iBluR = cBits - 8;
            bi.iGreR = bi.iBluR + cBits;
            bi.iRedR = bi.iGreR + cBits;
        }
        else
        {
            RIP("Palette format not supported\n");
        }
    }

/***************************************************************
*                                                              *
*    Now I shall calculate the shift numbers.                  *
*                                                              *
*    I shall explain the shift numbers for the red channel.    *
*    The green and blue channels are treated in the same way.  *
*                                                              *
*    I want to shift the red bits of the red channel colors    *
*    so that the most significant bit of the red channel       *
*    bits corresponds to a value of 2^7. This means that       *
*    if I mask off all of the other color bits, then I         *
*    will end up with a number between zero and 255. This      *
*    process of going to the 0 .. 255 range looks like         *
*                                                              *
*        ((color & flRed) << iRedL) >> iRedR                   *
*                                                              *
*    Only one of iRedL or iRedR is non zero.                   *
*                                                              *
*    I then use this number to index into a 256 element        *
*    gamma correction table. The gamma correction table        *
*    elements are BYTE values that are in the range 0 .. 255.  *
*                                                              *
***************************************************************/

    bi.iRedL = 0;
    if (bi.iRedR < 0)
    {
        bi.iRedL = - bi.iRedR;
        bi.iRedR = 0;
    }

    bi.iGreL = 0;
    if (bi.iGreR < 0)
    {
        bi.iGreL = - bi.iGreR;
        bi.iGreR = 0;
    }

    bi.iBluL = 0;
    if (bi.iBluR < 0)
    {
        bi.iBluL = - bi.iBluR;
        bi.iBluR = 0;
    }

// set gamma, default value is 1.5, a bit low to ensure contrast for thin fonts
// from the color point of view 1.8 might be better

    ULONG ulGamma;

    if (gulGamma != DEFAULT_CT_CONTRAST)
    {
        ulGamma = gulGamma; // overridden via registry or debugger
    }
    else
    {
        ulGamma = pdo.ulGamma();
        if (ulGamma == 0)         // the driver did not set it, we set it to our default
            ulGamma = DEFAULT_CT_CONTRAST;

    }

    if (ulGamma < 1100)
    {
        bi.pjGamma    = ajGammaCT_10;
        bi.pjGammaInv = ajGammaCT_10;
    }
    else if (ulGamma < 1200)
    {
        bi.pjGamma    = ajGammaCT_11;
        bi.pjGammaInv = ajGammaInvCT_11;
    }
    else if (ulGamma < 1300)
    {
        bi.pjGamma    = ajGammaCT_12;
        bi.pjGammaInv = ajGammaInvCT_12;
    }
    else if (ulGamma < 1400)
    {
        bi.pjGamma    = ajGammaCT_13;
        bi.pjGammaInv = ajGammaInvCT_13;
    }
    else if (ulGamma < 1500)
    {
        bi.pjGamma    = ajGammaCT_14;
        bi.pjGammaInv = ajGammaInvCT_14;
    }
    else if (ulGamma < 1600)
    {
        bi.pjGamma    = ajGammaCT_15;
        bi.pjGammaInv = ajGammaInvCT_15;
    }
    else if (ulGamma < 1700)
    {
        bi.pjGamma    = ajGammaCT_16;
        bi.pjGammaInv = ajGammaInvCT_16;
    }
    else if (ulGamma < 1800)
    {
        bi.pjGamma    = ajGammaCT_17;
        bi.pjGammaInv = ajGammaInvCT_17;
    }
    else if (ulGamma < 1900)
    {
        bi.pjGamma    = ajGammaCT_18;
        bi.pjGammaInv = ajGammaInvCT_18;
    }
    else if (ulGamma < 2000)
    {
        bi.pjGamma    = ajGammaCT_19;
        bi.pjGammaInv = ajGammaInvCT_19;
    }
    else if (ulGamma < 2100)
    {
        bi.pjGamma    = ajGammaCT_20;
        bi.pjGammaInv = ajGammaInvCT_20;
    }
    else if (ulGamma < 2200)
    {
        bi.pjGamma    = ajGammaCT_21;
        bi.pjGammaInv = ajGammaInvCT_21;
    }
    else
    {
        bi.pjGamma    = ajGammaCT_22;
        bi.pjGammaInv = ajGammaInvCT_22;
    }

// important; shift as ULONG's, store back as LONG's
// gamma correct at the same step

    bi.lRedF  = bi.pjGamma[((((uF & bi.flRed) << bi.iRedL) >> bi.iRedR) & 255)];
    bi.lGreF  = bi.pjGamma[((((uF & bi.flGre) << bi.iGreL) >> bi.iGreR) & 255)];
    bi.lBluF  = bi.pjGamma[((((uF & bi.flBlu) << bi.iBluL) >> bi.iBluR) & 255)];

// done, copy out, this is faster than doing pbi->xxx all the time...

    *pbi = bi;
}





// default value for few sgi monitors that we have seen
// Actually, it closer to 2.0, but if the monitor is viewed from
// a non 90 degree angle, than effective gamma goes as low as 1.2,
// so we decided to undercompensate and set it to 1.8, slightly below ideal


VOID *pvFillOpaqTableCT(
    ULONG size,
    ULONG uF,
    ULONG uB,
    SURFACE *pS,
    BLENDINFO *pbi,
    BOOL bTransparent
)
{
    // I have been assured of two things....
    // 1) Since this routine is a child of EngTextOut then there
    //    will be only one thread in this routine at any one time.
    //    This means that I do not need to protect the color
    //    table, aulCacheCT[] with a critical section
    // 2) I have been assured that the format of a surface
    //    is unique. Thus if the handle of the surface matches
    //    the handle of the cached color table, then the
    //    formats of the surface are the same.

    BOOL bLookupTableOk = (pS->hGet() == hCacheCT) &&
                          (uB == uBCacheCT)        &&
                          (uF == uFCacheCT)        &&
                          (gulGamma == uGammaCacheCT) ;

    if (bLookupTableOk && !bTransparent) // do not need to do anything, done
    {
        ASSERTGDI(size == sizeCacheCT, "size != sizeCacheCT\n");
    }
    else
    {
        vGetBlendInfo(size, pS, uF, pbi);

        if (!bLookupTableOk) // need to recompute the lookup table
        {
            vClearTypeLookupTableLoop(size, pS, pbi, uF, uB);
        }
    }
    return (PVOID)aulCacheCT;
}

VOID GreSetLCDOrientation(DWORD dwOrientation)
{
    gaOutTable = (dwOrientation & FE_FONTSMOOTHINGORIENTATIONRGB) ? gaOutTableRGB : gaOutTableBGR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\alphablt.cxx ===
/******************************Module*Header*******************************\
* Module Name: alphablt.cxx
*
* Alpha Blending
*
* Created: 21-Jun-1996
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1996-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "stretch.hxx"  // For mirroring code.

/******************************Public*Routine******************************\
* bIsSourceBGRA 
*
*   determine whether a surface is in BGR format
*
* Arguments:
*
*   pSurf          - pointer to the surface
*
* Return Value:
*
*   TRUE if the surface is in BGR format, otherwise FALSE
*
* History:
*
*    12-Aug-1997 -by- Ori Gershony [orig]
*
\**************************************************************************/
BOOL
bIsSourceBGRA(
    PSURFACE pSurf
    )
{
    XEPALOBJ pal(pSurf->ppal());

    //
    // A surface is in BGR format if it's a valid 32BPP surface that's either
    // PAL_BGR or PAL_BITFIELDS with the correct bitfields set.
    //

    return ((pSurf->iFormat() == BMF_32BPP) &&
            (pal.bValid()) &&
            ((pal.bIsBGR()) ||
             ((pal.bIsBitfields()) &&
              (pal.flRed() == 0xff0000) && 
              (pal.flGre() == 0xff00) && 
              (pal.flBlu() == 0xff))));
}


/******************************Public*Routine******************************\
*  psSetupTransparentSrcSurface
*
*   make a temp copy of source surface if needed
*
* Arguments:
*
*   pSurfSrc       - original source surface
*   pSurfDst       - original dset surfaca
*   prclDst        - destination rect
*   pxloSrcTo32    - used only for alpha blend, tran src to 32 BGRA
*   prclSrc        - source rect, change to temp src rect if allocated
*   &surfTmpSrc    - use this surfmem to alloc
*   *bAllocSrcSurf - force temp allocation
*   ulSourceType   - alpha or transparent surface
*   ulTranColor    - transparent color
*
* Return Value:
*
*   drawable surface or NULL
*
* History:
*
*    25-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

PSURFACE
psSetupTransparentSrcSurface(
    PSURFACE  pSurfSrc,
    PSURFACE  pSurfDst,
    PRECTL    prclDst,
    XLATEOBJ *pxloSrcTo32,
    PRECTL    prclSrc,
    SURFMEM  &surfTmpSrc,
    ULONG     ulSourceType,
    ULONG     ulTranColor
    )
{
    BOOL bStatus;

    PSURFACE psurfRet = pSurfSrc;

    LONG DstCx = prclDst->right  - prclDst->left;
    LONG DstCy = prclDst->bottom - prclDst->top;

    LONG SrcCx = prclSrc->right  - prclSrc->left;
    LONG SrcCy = prclSrc->bottom - prclSrc->top;

    BOOL bStretch = ((DstCx != SrcCx) || (DstCy != SrcCy));

    BOOL bSourceIsBGRA = FALSE;
    BOOL bSrcRectExceedsBounds = FALSE;
 
    //
    // if the surface is a bitmap, identity translate and
    // no stretching, then a temp copy of the surface is not
    // needed.
    //

    if (bStretch)
    {
        DEVBITMAPINFO   dbmi;
        PDEVOBJ         pdoSrc( pSurfSrc->hdev());
        XEPALOBJ        palSurf(pSurfSrc->ppal());

        //
        // calculate clipped extents of destinatoin rect
        //

        RECTL rclDstClip = {0,0,pSurfDst->sizl().cx,pSurfDst->sizl().cy};

        //
        // trimmed destination rect is trimmed surface boundary
        // Perf Note: clipping on destination is not taken into account,
        // this could reduce the size of the source copy surface at
        // times.
        //

        if (rclDstClip.left < prclDst->left)
        {
            rclDstClip.left = prclDst->left;
        }

        if (rclDstClip.top < prclDst->top)
        {
            rclDstClip.top = prclDst->top;
        }

        if (rclDstClip.right > prclDst->right)
        {
            rclDstClip.right = prclDst->right;
        }

        if (rclDstClip.bottom > prclDst->bottom)
        {
            rclDstClip.bottom = prclDst->bottom;
        }

        if ((rclDstClip.left < rclDstClip.right) &&
            (rclDstClip.top  < rclDstClip.bottom))
        {
            //
            // does source rect exceed source bounds? (bad)
            //

            if ((prclSrc->left < 0)                    ||
                (prclSrc->right > pSurfSrc->sizl().cx) ||
                (prclSrc->top < 0)                     ||
                (prclSrc->bottom > pSurfSrc->sizl().cy)
               )
            {
                bSrcRectExceedsBounds = TRUE;
            }

            //
            // allocate surface as same size as dst
            //

            if (ulSourceType == SOURCE_ALPHA)
            {
                //
                // does original source contain alpha channel
                //

                bSourceIsBGRA = bIsSourceBGRA (pSurfSrc);

                //
                // allocate 32bpp BGRA surface for source, must be zero init
                //

                dbmi.cxBitmap = rclDstClip.right  - rclDstClip.left;
                dbmi.cyBitmap = rclDstClip.bottom - rclDstClip.top;
                dbmi.iFormat  = BMF_32BPP;
                dbmi.fl       = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;
                XEPALOBJ      palRGB(gppalRGB);
                dbmi.hpal     = (HPALETTE)palRGB.hpal();

                bStatus = surfTmpSrc.bCreateDIB(&dbmi, (VOID *) NULL);

                //
                // since DIB is zero-init, no other initialization is needed to
                // make it transparent (so that portions of dst rect not covered
                // by source rect are not drawn)
                //
                // UNLESS source DIB does not have it's own alpha. In that case, if
                // the source extents do not completely cover dst extents, source
                // must be initialized to 0xffxxxxxx. StretchBlt will write 0x00xxxxxx.
                // After StretchBlt, must make all 0xffxxxxxx to 0x00xxxxxx and all
                // 0x00xxxxxx to 0xffxxxxxx
                //

                if (bStatus && bSrcRectExceedsBounds && !bSourceIsBGRA)
                {
                    RtlFillMemoryUlong(surfTmpSrc.ps->pvBits(),surfTmpSrc.ps->cjBits(),0xFF000000);
                }
            }
            else
            {
                //
                // allocate compatible surface for TransparentBlt
                //

                dbmi.cxBitmap = DstCx;
                dbmi.cyBitmap = DstCy;
                dbmi.iFormat  = pSurfSrc->iFormat();
                dbmi.fl       = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;
                dbmi.hpal     = (HPALETTE)NULL;

                if (palSurf.bValid())
                {
                    dbmi.hpal     = palSurf.hpal();
                }

                bStatus = surfTmpSrc.bCreateDIB(&dbmi, (VOID *) NULL);

                //
                // init DIB to transparent
                // (so that portions of dst rect not covered by source rect are not drawn)
                //

                if (bStatus && bSrcRectExceedsBounds)
                {
                    ULONG i;
                    ULONG cjBits = surfTmpSrc.ps->cjBits();
                    ULONG ulColor4BPP;
                                        
                    switch (pSurfSrc->iFormat())
                    {
                    case BMF_1BPP:
                        if (ulTranColor)
                        {
                            memset(surfTmpSrc.ps->pvBits(),0xff,cjBits);
                        }
                        else
                        {
                            memset(surfTmpSrc.ps->pvBits(),0,cjBits);
                        }
                        break;
                                            
                    case BMF_4BPP:
                        ulColor4BPP = ulTranColor | (ulTranColor << 4);
                        memset(surfTmpSrc.ps->pvBits(),ulColor4BPP,cjBits);
                        break;
                                            
                    case BMF_8BPP:
                        memset(surfTmpSrc.ps->pvBits(),ulTranColor,cjBits);
                        break;
                                            
                    case BMF_16BPP:
                        {
                            PUSHORT pvBits = (PUSHORT) surfTmpSrc.ps->pvBits();
                                                
                            for (i=0; i<(cjBits/sizeof(USHORT)); i++)
                            {
                                *pvBits++ = (USHORT) ulTranColor;
                                                    
                            }
                        }
                        break;
                                       
                    case BMF_24BPP:
                        {
                            BYTE bC1 = ((PBYTE)&ulTranColor)[0];
                            BYTE bC2 = ((PBYTE)&ulTranColor)[1];
                            BYTE bC3 = ((PBYTE)&ulTranColor)[2];
                                                

                            PULONG pulDstY     = (PULONG)surfTmpSrc.ps->pvScan0();
                            PULONG pulDstLastY = (PULONG)((PBYTE)pulDstY + 
                                                          (surfTmpSrc.ps->lDelta() * surfTmpSrc.ps->sizl().cy));
                            while (pulDstY != pulDstLastY)
                            {
                                PBYTE pulDstX     = (PBYTE) pulDstY;
                                PBYTE pulDstLastX = pulDstX + 3 * surfTmpSrc.ps->sizl().cx;
                                                    
                                while (pulDstX < pulDstLastX-2)
                                {
                                    *pulDstX++ = bC1;
                                    *pulDstX++ = bC2;
                                    *pulDstX++ = bC3;
                                }
                                pulDstY = (PULONG)((PBYTE)pulDstY + surfTmpSrc.ps->lDelta());
                            }                                                    
                        }        
                        break;
                                                                                                
                    case BMF_32BPP:
                        {
                            PULONG pvBits = (PULONG) surfTmpSrc.ps->pvBits();
                                                
                            for (i=0; i<(cjBits/sizeof(ULONG)); i++)
                            {
                                *pvBits++ = ulTranColor;
                            }
                        }
                        break;
                    }
                }
            }


            if (bStatus)
            {
                //
                // zero DIB to make non-drawing areas transparent for alphablend
                //

                POINTL   ptlBrushOrg = {0,0};
                RECTL    rclDstCopy  = *prclDst;
                ECLIPOBJ eco;
                ECLIPOBJ *pco = NULL;
                RGNMEMOBJTMP rmo((BOOL)FALSE);

                if (rmo.bValid())
                {

                    //
                    // offset dst rect
                    //

                    rclDstCopy.left   -= rclDstClip.left;
                    rclDstCopy.right  -= rclDstClip.left;
                    rclDstCopy.top    -= rclDstClip.top;
                    rclDstCopy.bottom -= rclDstClip.top;

                    //
                    // will need rect clipping if rclDstCopy exceeds tmp bitmap
                    //

                    if (
                            (rclDstCopy.left   < 0) ||
                            (rclDstCopy.right  > surfTmpSrc.ps->sizl().cx) ||
                            (rclDstCopy.top    < 0) ||
                            (rclDstCopy.bottom > surfTmpSrc.ps->sizl().cy))
                    {
                        ERECTL rclSurface(0,0,surfTmpSrc.ps->sizl().cx,surfTmpSrc.ps->sizl().cy);
                        rmo.vSet((RECTL *) &rclSurface);
                        pco = (ECLIPOBJ *)&eco;
                        ((XCLIPOBJ *)pco)->vSetup(rmo.prgnGet(),(ERECTL)rclDstCopy);
                    }

                    surfTmpSrc.ps->hdev(pSurfSrc->hdev());

                    //
                    //  init with stretch
                    //

                    bStatus = EngStretchBlt (
                                      surfTmpSrc.ps->pSurfobj(),
                                      pSurfSrc->pSurfobj(),
                                      NULL,
                                      (CLIPOBJ *)pco,
                                      pxloSrcTo32,
                                      NULL,
                                      &ptlBrushOrg,
                                      &rclDstCopy,
                                      prclSrc,
                                      NULL,
                                      COLORONCOLOR
                                      );

                    if (bStatus)
                    {
                        //
                        // adjust prclSrc and prclDst to be non-stretch rects
                        //

                        prclSrc->left   = 0;
                        prclSrc->right  = dbmi.cxBitmap;
                        prclSrc->top    = 0;
                        prclSrc->bottom = dbmi.cyBitmap;

                        *prclDst = rclDstClip;

                        //
                        // for alpha bitmaps that did not originally contain an alpha channel,
                        // init alpha to ff.
                        //
                        // PERF: 2 other options to XOR whole bitmap are
                        //      1: use compatible bitmap for source where rclSrc does not exceed src bounds
                        //          This saves memory maybee, saves xor, but require conversion of each scan to 32BRGA
                        //      2: use flag to ignore alpha channel later where rclSrc does not exceed src bounds
                        //

                        if ((ulSourceType == SOURCE_ALPHA) && (!bSourceIsBGRA))
                        {
                            //
                            // ULONGs that are 0xffxxxxxx must be made 0x00xxxxxx
                            // ULONGs that are 0x00xxxxxx must be made 0xffxxxxxx
                            // bitmaps that started out as 0x00BBGGRR (PAL_RGB) are still broken
                            //

                            PULONG pulDstY     = (PULONG)surfTmpSrc.ps->pvScan0();
                            PULONG pulDstLastY = (PULONG)((PBYTE)pulDstY + surfTmpSrc.ps->lDelta() * surfTmpSrc.ps->sizl().cy);

                            while (pulDstY != pulDstLastY)
                            {
                                PULONG pulDstX     = pulDstY;
                                PULONG pulDstLastX = pulDstX + surfTmpSrc.ps->sizl().cx;

                                while (pulDstX != pulDstLastX)
                                {
                                    *pulDstX = *pulDstX ^ 0xff000000;
                                    pulDstX++;
                                }
                                pulDstY = (PULONG)((PBYTE)pulDstY + surfTmpSrc.ps->lDelta());
                            }
                        }

                        //
                        // mark surface to keep, set return status
                        //

                        psurfRet = surfTmpSrc.ps;
                    }
                    else
                    {
                        psurfRet = NULL;
                    }
                }
            }
            else
            {
                psurfRet = NULL;
            }
        }
        else
        {
            psurfRet = NULL;
        }
    }
    else
    {
        //
        // trim src rect to src surface bounds and reduce
        // dst rect accordingly
        //

        if (prclSrc->left < 0)
        {
            prclDst->left = prclDst->left - prclSrc->left;
            prclSrc->left = 0;
        }

        if (prclSrc->right > pSurfSrc->sizl().cx)
        {
            prclDst->right = prclDst->right - (prclSrc->right - pSurfSrc->sizl().cx);
            prclSrc->right = pSurfSrc->sizl().cx;
        }

        if (prclSrc->top < 0)
        {
            prclDst->top = prclDst->top - prclSrc->top;
            prclSrc->top = 0;
        }

        if (prclSrc->bottom > pSurfSrc->sizl().cy)
        {
            prclDst->bottom = prclDst->bottom - (prclSrc->bottom - pSurfSrc->sizl().cy);
            prclSrc->bottom = pSurfSrc->sizl().cy;
        }

        //
        // check dst rect exceeds dst surface, reduce src and rect accordingly
        // WINBUG #82938 2-8-2000 bhouse Fix assumption of surface position
        // Old Comment:
        //     This code assumes that the surface starts at 0,0 and ends at sizl().cx, sizl().cy
        //     which is not true for multimon code.
        // This is not a problem anymore. As this is called only from
        // EngAlphaBlend. According to Nagasae-San all Eng* Apis can assume
        // this surface start of 0,0 requirment.

        if (prclDst->left < 0)
        {
            prclSrc->left += (-prclDst->left);
            prclDst->left  = 0;
        }

        if (prclDst->right > pSurfDst->sizl().cx)
        {
            prclSrc->right += (pSurfDst->sizl().cx - prclDst->right);
            prclDst->right = pSurfDst->sizl().cx;
        }

        if (prclDst->top < 0)
        {
            prclSrc->top += (-prclDst->top);
            prclDst->top  = 0;
        }

        if (prclDst->bottom > pSurfDst->sizl().cy)
        {
            prclSrc->bottom += (pSurfDst->sizl().cy - prclDst->bottom);
            prclDst->bottom = pSurfDst->sizl().cy;
        }

        //
        // check for empty rect
        //

        if (
             (prclDst->left >= prclDst->right) ||
             (prclDst->top  >= prclDst->bottom))
        {
            //
            // indicate empty rect
            //

            prclDst->left = prclDst->right;

        }
        else
        {
            if (pSurfSrc->iType() != STYPE_BITMAP)
            {
                DEVBITMAPINFO   dbmi;
                PDEVOBJ         pdoSrc( pSurfSrc->hdev());
                XEPALOBJ        palSurf(pSurfSrc->ppal());
                LONG DstCx = prclDst->right  - prclDst->left;
                LONG DstCy = prclDst->bottom - prclDst->top;

                //
                // allocate surface as same size as dst
                //

                dbmi.cxBitmap = DstCx;
                dbmi.cyBitmap = DstCy;
                dbmi.iFormat  = pSurfSrc->iFormat();
                dbmi.fl       = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;
                dbmi.hpal     = (HPALETTE)NULL;

                if (palSurf.bValid())
                {
                    dbmi.hpal     = palSurf.hpal();
                }

                bStatus = surfTmpSrc.bCreateDIB(&dbmi, (VOID *) NULL);

                if (bStatus)
                {

                    RECTL  rclCopy;

                    rclCopy.left   = 0;
                    rclCopy.right  = DstCx;
                    rclCopy.top    = 0;
                    rclCopy.bottom = DstCy;

                    surfTmpSrc.ps->hdev(pSurfSrc->hdev());

                    //
                    // if src is same size as dest, init with CopyBits
                    //

                    POINTL ptlCopy;

                    ptlCopy.x = prclSrc->left;
                    ptlCopy.y = prclSrc->top;

                    (*PPFNGET(pdoSrc,CopyBits,pSurfSrc->flags()))(
                              surfTmpSrc.ps->pSurfobj(),
                              pSurfSrc->pSurfobj(),
                              (CLIPOBJ *) NULL,
                              (XLATEOBJ *)NULL,
                              &rclCopy,
                              &ptlCopy);

                    //
                    // adjust prclSrc to be the new rect
                    //

                    *prclSrc = rclCopy;

                    //
                    // mark surface to keep, set return status
                    //

                    psurfRet = surfTmpSrc.ps;
                }
                else
                {
                    psurfRet = NULL;
                }
            }
        }
    }

    return(psurfRet);
}

/******************************Public*Routine******************************\
* psSetupDstSurface
*
*   Create temporary destination surface for alpha and gradient fill,
*   if necessary, and optionally copy bits from the 
*   actual destination surface.
*
* Arguments:
*
*   pSurfDst        -  actual destination surface
*   prclDst         -  rectangle on dest surface
*   surfTmpDst      -  reference to surfmem
*   bForceDstAlloc  -  force allocation of temp dest
*   bCopyFromDst    -  copy bits from actual destination surface
*
* Return Value:
*
*   surface to use, either original or new
*
* History:
*
*    25-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

PSURFACE
psSetupDstSurface(
    PSURFACE pSurfDst,
    PRECTL   prclDst,
    SURFMEM  &surfTmpDst,
    BOOL     bForceDstAlloc,
    BOOL     bCopyFromDst
    )
{
    PSURFACE psurfRet = pSurfDst;

    LONG DstCx = prclDst->right  - prclDst->left;
    LONG DstCy = prclDst->bottom - prclDst->top;

    BOOL bStatus = FALSE;

    if (bForceDstAlloc || (pSurfDst->iType() != STYPE_BITMAP))
    {
        DEVBITMAPINFO   dbmi;
        PDEVOBJ         pdoDst( pSurfDst->hdev());
        XEPALOBJ        palSurf(pSurfDst->ppal());

        //
        // allocate surface
        //

        dbmi.cxBitmap = DstCx;
        dbmi.cyBitmap = DstCy;
        dbmi.iFormat  = pSurfDst->iFormat();
        dbmi.fl       = pSurfDst->bUMPD() ? UMPD_SURFACE : 0;

        dbmi.hpal     = (HPALETTE) 0;

        if (palSurf.bValid())
        {
            dbmi.hpal     = palSurf.hpal();
        }

        bStatus = surfTmpDst.bCreateDIB(&dbmi, (VOID *) NULL);

        if (bStatus)
        {
            RECTL  rclCopy;
            POINTL ptlCopy;

            surfTmpDst.ps->hdev(pSurfDst->hdev());

            rclCopy.left   = 0;
            rclCopy.right  = DstCx;
            rclCopy.top    = 0;
            rclCopy.bottom = DstCy;

            if (bCopyFromDst)
            {
                ptlCopy.x = prclDst->left;
                ptlCopy.y = prclDst->top;
 
                bStatus = (*PPFNGET(pdoDst,CopyBits,pSurfDst->flags()))(
                          surfTmpDst.pSurfobj(),
                          pSurfDst->pSurfobj(),
                          (CLIPOBJ *) NULL,
                          &xloIdent,
                          &rclCopy,
                          &ptlCopy);
            }

            if (bStatus)
            {
                //
                // adjust dst rect
                //
                
                *prclDst = rclCopy;
                psurfRet = surfTmpDst.ps;
            }
            else
            {
                psurfRet = NULL;
            }
        }
        else
        {
            psurfRet = NULL;
        }
    }

    return(psurfRet);
}

#if defined(_X86_)

/**************************************************************************\
* IsMMXProcessor
*
*   determine if the processor supports MMX
*
* Arguments:
*
*   none
*
* Return Value:
*
*   TRUE if MMX
*
* History:
*
*    4/10/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bIsMMXProcessor(VOID)
{
    BOOL  retval = FALSE;

    #if 0

        PVOID pFloatingPointState = (PVOID)PALLOCMEM(sizeof(KFLOATING_SAVE) + sizeof(BOOL),'pftG');

        if (pFloatingPointState != NULL)
        {
            BOOL bRet = EngSaveFloatingPointState(pFloatingPointState,sizeof(KFLOATING_SAVE) + sizeof(BOOL));

            if (bRet)
            {

                __try
                {
                    _asm emms
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    retval = FALSE;
                }

                EngRestoreFloatingPointState(pFloatingPointState);
            }
            else
            {
                WARNING1("bIsMMXProcessor: Failed to save fp state\n");
                retval = FALSE;
            }

            VFREEMEM(pFloatingPointState);
        }
        else
        {
            WARNING1("bIsMMXProcessor: Failed to allocate fpstate\n");
            retval = FALSE;
        }

    #else

   if (ExIsProcessorFeaturePresent(3)) // PF_MMX_INSTRUCTION_AVAILABLE
    {
        retval = TRUE;
    }

    #endif


    return retval;
}

#endif

/**************************************************************************\
*  bDetermineAlphaBlendFunction
*
*   determine alpha blending routine based on src and dst formats
*   and alpha BlendFunction
*
* Arguments:
*
*   pSurfDst       - dest surface
*   pSurfSrc       - src surface
*   ppalDst        - dest palette
*   ppalSrc        - src palette
*   cxDst          - width of alpha blt
*   pAlphaDispatch - blend function and routines
*
* Return Value:
*
*   status
*
* History:
*
*    1/21/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bDetermineAlphaBlendFunction(
    PSURFACE                  pSurfDst,
    PSURFACE                  pSurfSrc,
    XEPALOBJ                 *ppalDst,
    XEPALOBJ                 *ppalSrc,
    XLATE                    *pxlateSrcTo32,
    LONG                      cxDst,
    PALPHA_DISPATCH_FORMAT    pAlphaDispatch
    )
{
    BOOL bRet               = TRUE;
    BOOL bSrcHasAlpha       = FALSE;
    pAlphaDispatch->bUseMMX = FALSE;

    //
    // does src bitmap have alpha
    //

    bSrcHasAlpha = (pAlphaDispatch->BlendFunction.AlphaFormat & AC_SRC_ALPHA);

    //
    // assume default blend, check for special cases
    //

    pAlphaDispatch->pfnGeneralBlend = vAlphaPerPixelOnly;

    //
    // use "over" optimized blend fucntion
    //

    if (bSrcHasAlpha && (pAlphaDispatch->BlendFunction.SourceConstantAlpha == 255))
    {
        pAlphaDispatch->pfnGeneralBlend = vAlphaPerPixelOnly;

        #if defined(_X86_)

            //
            // source and dest alignment must be 8 byte aligned to use mmx
            //

            if (gbMMXProcessor && (cxDst >= 8))
            {
                pAlphaDispatch->pfnGeneralBlend = mmxAlphaPerPixelOnly;
                pAlphaDispatch->bUseMMX         = TRUE;
            }

        #endif
    }
    else
    {
        //
        // if source format doesn't support alpha then use
        // constant alpha routine
        //

        if (bSrcHasAlpha)
        {
            //
            // blend source and dest using SourceAlpha and
            // source bitmaps integral alpha
            //

            pAlphaDispatch->pfnGeneralBlend = vAlphaPerPixelAndConst;

            #if defined(_X86_)

                //
                // source and dest alignment must be 8 byte aligned to use mmx
                //

                if (gbMMXProcessor && (cxDst >= 8))
                {
                    pAlphaDispatch->pfnGeneralBlend = mmxAlphaPerPixelAndConst;
                    pAlphaDispatch->bUseMMX         = TRUE;
                }

            #endif
        }
        else
        {
            //
            // blend src and dest using SourceConstantAlpha.
            //

            pAlphaDispatch->pfnGeneralBlend = vAlphaConstOnly;
        }
    }

    //
    // determine output conversion and storage routines
    //

    switch (pSurfDst->iFormat())
    {
    case BMF_1BPP:
        pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvert1ToBGRA;
        pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRATo1;
        pAlphaDispatch->ulDstBitsPerPixel    = 1;
        break;

    case BMF_4BPP:
        pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvert4ToBGRA;
        pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRATo4;
        pAlphaDispatch->ulDstBitsPerPixel    = 4;
        break;

    case BMF_8BPP:
        pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvert8ToBGRA;
        pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRATo8;
        pAlphaDispatch->ulDstBitsPerPixel    = 8;
        break;

    case BMF_16BPP:

        ASSERTGDI((ppalDst->bIsBitfields()),"AlphaBlt: RGB16 palette must be bitfields");

        if (
             (ppalDst->flRed() == 0xf800) &&
             (ppalDst->flGre() == 0x07e0) &&
             (ppalDst->flBlu() == 0x001f)
           )
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvertRGB16_565ToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToRGB16_565;
        }
        else if (
             (ppalDst->flRed() == 0x7c00) &&
             (ppalDst->flGre() == 0x03e0) &&
             (ppalDst->flBlu() == 0x001f)
           )
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvertRGB16_555ToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToRGB16_555;
        }
        else
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvert16BitfieldsToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToRGB16Bitfields;
        }

        pAlphaDispatch->ulDstBitsPerPixel    = 16;

        break;

    case BMF_24BPP:


        // WINBUG #101656 bhouse 5-4-2000 AlphaBlend reversing R and B channels
        // when rendering to 24BPP

        if (
             (ppalDst->bIsBGR()) ||
             (
               (ppalDst->bIsBitfields()) &&
               (
                 (
                   (ppalDst->flRed() == 0xff0000) &&
                   (ppalDst->flGre() == 0x00ff00) &&
                   (ppalDst->flBlu() == 0x0000ff)
                 ) ||
                 (
                   (ppalDst->flRed() == 0x000000) &&
                   (ppalDst->flGre() == 0x000000) &&
                   (ppalDst->flBlu() == 0x000000)
                 )
               )
             )
           )
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvertBGR24ToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToBGR24;
            pAlphaDispatch->ulDstBitsPerPixel    = 24;
        }
        else
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvertRGB24ToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToRGB24;
            pAlphaDispatch->ulDstBitsPerPixel    = 24;
        }
        break;

    case BMF_32BPP:

        if (
             (ppalDst->bIsBGR()) ||
             (
               (ppalDst->bIsBitfields()) &&
               (
                 (
                   (ppalDst->flRed() == 0xff0000) &&
                   (ppalDst->flGre() == 0x00ff00) &&
                   (ppalDst->flBlu() == 0x0000ff)
                 ) ||
                 (
                   (ppalDst->flRed() == 0x000000) &&
                   (ppalDst->flGre() == 0x000000) &&
                   (ppalDst->flBlu() == 0x000000)
                 )
               )
             )
           )
        {
            //
            // assigned to null indicates no conversion needed
            //

            pAlphaDispatch->pfnLoadDstAndConvert = NULL;
            pAlphaDispatch->pfnConvertAndStore   = NULL;
        }
        else if (ppalDst->flPal() & PAL_RGB)
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvertRGB32ToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToRGB32;
        }
        else
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvert32BitfieldsToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRATo32Bitfields;
        }

        pAlphaDispatch->ulDstBitsPerPixel    = 32;

        break;
    default:
        WARNING("bDetermineAlphaBlendFunction: Illegal bitmap format\n");
        bRet = FALSE;
    }

    //
    // determine input load and conversion routine
    //

    switch (pSurfSrc->iFormat())
    {
    case BMF_1BPP:
        pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvert1ToBGRA;
        pAlphaDispatch->ulSrcBitsPerPixel    = 1;
        break;

    case BMF_4BPP:
        pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvert4ToBGRA;
        pAlphaDispatch->ulSrcBitsPerPixel    = 4;
        break;

    case BMF_8BPP:
        pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvert8ToBGRA;
        pAlphaDispatch->ulSrcBitsPerPixel    = 8;
        break;

    case BMF_16BPP:

        ASSERTGDI((ppalSrc->bIsBitfields()),"AlphaBlt: RGB16 palette must be bitfields");

        if ((ppalSrc->flRed() == 0xf800) &&
            (ppalSrc->flGre() == 0x07e0) &&
            (ppalSrc->flBlu() == 0x001f))
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvertRGB16_565ToBGRA;
        }
        else if ((ppalSrc->flRed() == 0x7c00) &&
                 (ppalSrc->flGre() == 0x03e0) &&
                 (ppalSrc->flBlu() == 0x001f))
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvertRGB16_555ToBGRA;
        }
        else
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvert16BitfieldsToBGRA;
        }

        pAlphaDispatch->ulSrcBitsPerPixel    = 16;

        break;

    case BMF_24BPP:

        // WINBUG #101656 bhouse 5-4-2000 AlphaBlend reversing R and B channels
        // when rendering to 24BPP

        if ((ppalSrc->bIsBGR()) ||
             (
               (ppalSrc->bIsBitfields()) &&
               (
                 (
                   (ppalSrc->flRed() == 0xff0000) &&
                   (ppalSrc->flGre() == 0x00ff00) &&
                   (ppalSrc->flBlu() == 0x0000ff)
                 ) ||
                 (
                   (ppalSrc->flRed() == 0x000000) &&
                   (ppalSrc->flGre() == 0x000000) &&
                   (ppalSrc->flBlu() == 0x000000)
                 )
               )
             )
           )
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvertBGR24ToBGRA;
        }
        else
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvertRGB24ToBGRA;
        }
        
        pAlphaDispatch->ulSrcBitsPerPixel    = 24;

        break;

    case BMF_32BPP:

        if ( 
             (pxlateSrcTo32 == NULL) ||
             (ppalSrc->bIsBGR()) ||
             (
               (ppalSrc->bIsBitfields()) &&
               (
                 (
                   (ppalSrc->flRed() == 0xff0000) &&
                   (ppalSrc->flGre() == 0x00ff00) &&
                   (ppalSrc->flBlu() == 0x0000ff)
                 ) ||
                 (
                   (ppalSrc->flRed() == 0x000000) &&
                   (ppalSrc->flGre() == 0x000000) &&
                   (ppalSrc->flBlu() == 0x000000)
                 )
               )
             )
           )
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = NULL;
        }
        else if (ppalSrc->flPal() & PAL_RGB)
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvertRGB32ToBGRA;
        }
        else
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvert32BitfieldsToBGRA;
        }
        pAlphaDispatch->ulSrcBitsPerPixel = 32;

        break;
    default:
        WARNING("bDetermineAlphaBlendFunction: Illegal bitmap format\n");
        bRet = FALSE;
    }

    //
    // 16/24 bit per pixel blend optimization
    //

    if (pAlphaDispatch->pfnGeneralBlend == vAlphaConstOnly)
    {
        if ((pAlphaDispatch->pfnLoadSrcAndConvert == vLoadAndConvertRGB16_555ToBGRA) &&
            (pAlphaDispatch->pfnLoadDstAndConvert == vLoadAndConvertRGB16_555ToBGRA))
        {
            //
            // use direct 16 bpp blend
            //

            pAlphaDispatch->pfnGeneralBlend = vAlphaConstOnly16_555;

            #if defined(_X86_)

                if (gbMMXProcessor && (cxDst >= 8))
                {
                    pAlphaDispatch->pfnGeneralBlend = mmxAlphaConstOnly16_555;
                    pAlphaDispatch->bUseMMX         = TRUE;
                }

            #endif

            pAlphaDispatch->pfnLoadSrcAndConvert = NULL;
            pAlphaDispatch->pfnLoadDstAndConvert = NULL;
            pAlphaDispatch->pfnConvertAndStore   = NULL;

            //
            // convert blend function from x/255 to y/31
            //

            int ia = pAlphaDispatch->BlendFunction.SourceConstantAlpha;

            ia = (ia * 31 + 128)/255;
            pAlphaDispatch->BlendFunction.SourceConstantAlpha = (BYTE)ia;
        }
        else if ((pAlphaDispatch->pfnLoadSrcAndConvert == vLoadAndConvertRGB16_565ToBGRA) &&
                 (pAlphaDispatch->pfnLoadDstAndConvert == vLoadAndConvertRGB16_565ToBGRA))
        {
            //
            // use direct 16 bpp blend
            //

            pAlphaDispatch->pfnGeneralBlend = vAlphaConstOnly16_565;

            #if defined(_X86_)

                if (gbMMXProcessor && (cxDst >= 8))
                {
                    pAlphaDispatch->pfnGeneralBlend = mmxAlphaConstOnly16_565;
                    pAlphaDispatch->bUseMMX         = TRUE;
                }

            #endif


            pAlphaDispatch->pfnLoadSrcAndConvert = NULL;
            pAlphaDispatch->pfnLoadDstAndConvert = NULL;
            pAlphaDispatch->pfnConvertAndStore   = NULL;

            //
            // convert blend function from x/255 to y/31
            //

            int ia = pAlphaDispatch->BlendFunction.SourceConstantAlpha;

            ia = (ia * 31 + 128)/255;
            pAlphaDispatch->BlendFunction.SourceConstantAlpha = (BYTE)ia;
        }
        else if ((pAlphaDispatch->pfnLoadSrcAndConvert == vLoadAndConvertRGB24ToBGRA) &&
                 (pAlphaDispatch->pfnLoadDstAndConvert == vLoadAndConvertRGB24ToBGRA))
        {
            //
            // use direct 24 bpp blend
            //

            pAlphaDispatch->pfnGeneralBlend = vAlphaConstOnly24;

            #if defined(_X86_)

                if (gbMMXProcessor && (cxDst >= 8))
                {
                    pAlphaDispatch->pfnGeneralBlend = mmxAlphaConstOnly24;
                    pAlphaDispatch->bUseMMX         = TRUE;
                }

            #endif

            pAlphaDispatch->pfnLoadSrcAndConvert = NULL;
            pAlphaDispatch->pfnLoadDstAndConvert = NULL;
            pAlphaDispatch->pfnConvertAndStore   = NULL;
        }
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* EngAlphaBlend
*
*   Implement alpha blending
*
* Arguments:
*
*   psoDst        - destination surface
*   psoSrc        - source surface
*   pco           - clip object
*   pxloSrcTo32   - translate src to 32 bgr
*   pxloDstTo32   - translate dst to 32 bgr
*   pxlo32ToDst   - translate 32bgr to dst
*   prclDst       - dest rect
*   prclSrc       - src rect
*   BlendFunction - blend function
*
* Return Value:
*
*   status
*
* History:
*
*    21-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/
BOOL
EngAlphaBlend(
    SURFOBJ       *psoDst,
    SURFOBJ       *psoSrc,
    CLIPOBJ       *pco,
    XLATEOBJ      *pxlo,
    RECTL         *prclDst,
    RECTL         *prclSrc,
    BLENDOBJ      *pBlendObj
    )
{
    BOOL bRet = TRUE;

    ASSERTGDI((prclSrc->left < prclSrc->right) &&
              (prclSrc->top < prclSrc->bottom) &&
              (prclDst->left < prclDst->right) &&
              (prclDst->top < prclDst->bottom),
        "Invalid rectangles");

    EBLENDOBJ *peBlendObj = (EBLENDOBJ*)pBlendObj;
    PSURFACE pSurfDst  = SURFOBJ_TO_SURFACE(psoDst);
    PSURFACE pSurfSrc  = SURFOBJ_TO_SURFACE(psoSrc);
    PSURFACE pSurfSrcTmp;
    PSURFACE pSurfDstTmp;
    BOOL     bAllocDstSurf = FALSE;
    XLATE   *pxlateSrcTo32 = (XLATE *)peBlendObj->pxloSrcTo32;
    XLATE   *pxlateDstTo32 = (XLATE *)peBlendObj->pxloDstTo32;
    XLATE   *pxlate32ToDst = (XLATE *)peBlendObj->pxlo32ToDst;
    RECTL    rclDstWk = *prclDst;
    RECTL    rclSrcWk = *prclSrc;
    POINTL   ptlSrc;
    CLIPOBJ *pcoDstWk = pco;

    ALPHA_DISPATCH_FORMAT AlphaDispatch;

    //
    // check blend
    //

    AlphaDispatch.BlendFunction = peBlendObj->BlendFunction;

    ASSERTGDI(peBlendObj->BlendFunction.BlendOp == AC_SRC_OVER,
        "Invalid blend");

    //
    // must be alpha to pull palette information from xlates
    //

    SURFMEM  surfTmpDst;
    SURFMEM  surfTmpSrc;

    //
    // For profiling purposes, set a flag in the PDEV to indicate that the
    // driver punted this call.
    //

    {
        PDEVOBJ po(pSurfDst->hdev());
        if (po.bValid())
        {
            po.vDriverPuntedCall(TRUE);
        }
    }

    if(peBlendObj->BlendFunction.BlendFlags & AC_USE_HIGHQUALITYFILTER)
    {
        BOOL bStretch = FALSE;
        
        bStretch = ((rclDstWk.right - rclDstWk.left) != (rclSrcWk.right - rclSrcWk.left)) ||
                   ((rclDstWk.bottom - rclDstWk.top) != (rclSrcWk.bottom - rclSrcWk.top));

        // Call EngHTBlt only when we have to stretch. When we dont have to
        // stretch we fall through to the old 1:1 EngAlphaBlend code.
        if(bStretch)
            return EngHTBlt(psoDst,
                            psoSrc,
                            NULL,
                            pco,
                            pxlo,
                            NULL,
                            &gptlZero,
                            prclDst,
                            prclSrc,
                            NULL,
                            BBPF_DO_ALPHA_BLEND,
                            pBlendObj) == HTBLT_SUCCESS ? TRUE : FALSE ;
    }

    //
    // Synchronize with the device driver before touching the device surface.
    //

    {
        PDEVOBJ poDst(psoDst->hdev);
        poDst.vSync(psoDst, NULL, 0);
            
        PDEVOBJ poSrc(psoSrc->hdev);
        poSrc.vSync(psoSrc, NULL, 0);
    }

    //
    // Get a readable source surface that is stretched to the destination size.
    //

    pSurfSrcTmp = psSetupTransparentSrcSurface(
                        pSurfSrc,
                        pSurfDst,
                        &rclDstWk,
                        (XLATEOBJ *)pxlateSrcTo32,
                        &rclSrcWk,
                        surfTmpSrc,
                        SOURCE_ALPHA,
                        0);

    if ((pSurfSrcTmp != NULL) && (rclDstWk.left != rclDstWk.right))
    {
        //
        // save final reduced dst rect. psSetupDstSurface may change rclDstWk to
        // to a temp dib rect.
        //

        RECTL rclDstSurface = rclDstWk;

        //
        // temp surface rect is now same size as dst rect, just need point offset
        //

        ptlSrc.x = rclSrcWk.left;
        ptlSrc.y = rclSrcWk.top;

        //
        // get a dst surface that can be written to, remember since it may have to
        // be written back
        //

        pSurfDstTmp = psSetupDstSurface(
                            pSurfDst,
                            &rclDstWk,
                            surfTmpDst,
                            FALSE,
                            TRUE);

        if (pSurfDstTmp)
        {
            if (pSurfDstTmp != pSurfDst)
            {
                bAllocDstSurf = TRUE;
            }

            XEPALOBJ palSrc(pSurfSrcTmp->ppal());
            XEPALOBJ palDst(pSurfDstTmp->ppal());

            //
            // must have one valid surface palette. Must pass drawing routines
            // two good palettes so duplicate good pointer
            //

            if (!palSrc.bValid())
            {
                //
                // get source surface palette
                //
                // first try the palette translate, because the sprite code
                // doesn't want to stick the palette in the surface
                //

                XLATE* pxlate = (XLATE*) pxlo;
                if ((pxlate != NULL) && (pxlate->ppalSrc != NULL))
                {
                    palSrc.ppalSet(pxlate->ppalSrc);
                }
                else
                {
                    PDEVOBJ pdo(pSurfSrcTmp->hdev());
                    palSrc.ppalSet(pdo.ppalSurf());
                }

                ASSERTGDI(palSrc.bValid(),"EngAlphaBlend:can't get source palette");
            }

            if (!palDst.bValid())
            {
                //
                // get destination surface palette
                //

                PDEVOBJ pdo(pSurfDstTmp->hdev());

                ASSERTGDI(pdo.bValid(),"EngAlphaBlend:can't get destination palette");

                palDst.ppalSet(pdo.ppalSurf());
            }

            //
            // validate palettes
            //

            if (palSrc.bValid() && palDst.bValid())
            {
                LONG cxDst = rclDstWk.right - rclDstWk.left;

                //
                // if using a temp dst, no need to clip except to bounding rect
                //

                if (bAllocDstSurf)
                {
                    pcoDstWk = NULL;
                }

                //
                // determine blend function
                //

                bRet = bDetermineAlphaBlendFunction(pSurfDstTmp,
                                                    pSurfSrcTmp,
                                                    &palDst,
                                                    &palSrc,
                                                    pxlateSrcTo32,
                                                    cxDst,
                                                    &AlphaDispatch);

                //
                // NOTE:
                // May be able to move setup of expensive EXLATE to and from 32 to
                // here only for case where non-direct blending is needed
                //

                if (bRet)
                {
                    KFLOATING_SAVE fsFpState;

                    //
                    // if alpha routines use MMX, must save and restore floating
                    // point state
                    //
    
                    if (bRet && AlphaDispatch.bUseMMX)
                    {
                        NTSTATUS status = KeSaveFloatingPointState(&fsFpState);
    
                        ASSERTGDI(NT_SUCCESS(status), 
                            "Unexpected KeSaveFloatingPointState failure");
                    }

                    //
                    // Determine the clipping region complexity.
                    //

                    CLIPENUMRECT    clenr;
                    BOOL            bMore;
                    ULONG           ircl;

                    //
                    // default (pcoDstWk = NULL) is use Dst rect as single clip rect,
                    // same as DC_TRIVIAL
                    //

                    bMore = FALSE;
                    clenr.c = 1;
                    clenr.arcl[0] = rclDstWk;

                    if (pcoDstWk != (CLIPOBJ *) NULL)
                    {
                        switch(pcoDstWk->iDComplexity)
                        {
                        case DC_TRIVIAL:
                            break;
                        case DC_RECT:
                            bMore = FALSE;
                            clenr.c = 1;
                            clenr.arcl[0] = pcoDstWk->rclBounds;
                            break;

                        case DC_COMPLEX:
                            bMore = TRUE;
                            ((ECLIPOBJ *) pcoDstWk)->cEnumStart(FALSE,
                                                           CT_RECTANGLES,
                                                           CD_LEFTDOWN,
                                                           CLIPOBJ_ENUM_LIMIT);
                            break;

                        default:
                            RIP("ERROR EngCopyBits bad clipping type");

                        }
                    }

                    //
                    // run through clipping enum
                    //

                    do
                    {
                        if (bMore)
                        {
                            bMore = ((ECLIPOBJ *) pcoDstWk)->bEnum(sizeof(clenr),
                                                              (PVOID) &clenr);
                        }

                        for (ircl = 0; ircl < clenr.c; ircl++)
                        {
                            PRECTL prcl = &clenr.arcl[ircl];

                            //
                            // Insersect the clip rectangle with the target rectangle to
                            // determine visible recangle
                            //

                            if (prcl->left < rclDstWk.left)
                            {
                                prcl->left = rclDstWk.left;
                            }

                            if (prcl->right > rclDstWk.right)
                            {
                                prcl->right = rclDstWk.right;
                            }

                            if (prcl->top < rclDstWk.top)
                            {
                                prcl->top = rclDstWk.top;
                            }

                            if (prcl->bottom > rclDstWk.bottom)
                            {
                                prcl->bottom = rclDstWk.bottom;
                            }

                            //
                            // Process the result if it's a valid rectangle.
                            //

                            if ((prcl->top < prcl->bottom) && (prcl->left < prcl->right))
                            {
                                POINTL pptlSrcOffset;

                                //
                                // Figure out the upper-left coordinates of rects to blt.
                                // NOTE: does not do right->left or bottom->top
                                //

                                pptlSrcOffset.x = ptlSrc.x + prcl->left - rclDstWk.left;
                                pptlSrcOffset.y = ptlSrc.y + prcl->top  - rclDstWk.top;

                                bRet = AlphaScanLineBlend(
                                            (PBYTE)pSurfDstTmp->pvScan0(),
                                            prcl,
                                            pSurfDstTmp->lDelta(),
                                            (PBYTE)pSurfSrcTmp->pvScan0(),
                                            pSurfSrcTmp->lDelta(),
                                            &pptlSrcOffset,
                                            pxlateSrcTo32,
                                            pxlateDstTo32,
                                            pxlate32ToDst,
                                            palDst,
                                            palSrc,
                                            &AlphaDispatch
                                            );
                            }
                        }

                    } while (bMore);

                    //
                    // if there is a dst temp surface, need to blt it to
                    // dst, then free
                    //

                    if (bAllocDstSurf)
                    {
                        PDEVOBJ pdoDst(pSurfDst->hdev());
                        POINTL  ptlCopy = {0,0};

                        (*PPFNGET(pdoDst,CopyBits,pSurfDst->flags()))(
                                  pSurfDst->pSurfobj(),
                                  pSurfDstTmp->pSurfobj(),
                                  pco,
                                  &xloIdent,
                                  &rclDstSurface,
                                  &ptlCopy);
                    }

                    //
                    // restore fp state if MMX used
                    //

                    if (AlphaDispatch.bUseMMX)
                    {
                        KeRestoreFloatingPointState(&fsFpState);
                    }
                }
            }
            else
            {
                bRet = FALSE;
            }
        }
        else
        {
            WARNING1("EngAlphaBlend: failed to allocate and copy surface\n");
            bRet = FALSE;
        }
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* NtGdiAlphaBlend
*
*   Kernel stub for alpha blending
*
* Arguments:
*
*   hdcDst        - dst dc
*   DstX          - dst x origin
*   DstY          - dst y origin
*   DstCx         - dst width
*   DstCy         - dst height
*   hdcSrc        - src dc
*   SrcX          - src x origin
*   SrcY          - src y origin
*   SrcCx         - src width
*   SrcCy         - src height
*   BlendFunction - blend function
*
* Return Value:
*
*   status
*
* History:
*
*    27-Jun-1997 Added rotation support -by- Ori Gershony [orig]
*
*    21-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
NtGdiAlphaBlend(
    HDC                hdcDst,
    LONG               DstX,
    LONG               DstY,
    LONG               DstCx,
    LONG               DstCy,
    HDC                hdcSrc,
    LONG               SrcX,
    LONG               SrcY,
    LONG               SrcCx,
    LONG               SrcCy,
    BLENDFUNCTION      BlendFunction,
    HANDLE             hcmXform
    )
{
    BOOL bStatus = TRUE;
    BOOL bQuickStretch = FALSE;

    //
    // check blend, only support AC_SRC_OVER now
    //

    if ((BlendFunction.BlendOp      != AC_SRC_OVER) ||
        ((BlendFunction.AlphaFormat & (~ AC_SRC_ALPHA)) != 0))
    {
        WARNING1("NtGdiAlphaBlend: invalid blend function\n");
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if ((SrcCx == 0) || (SrcCy == 0))
    {
        //
        // Src rectangle is empty--nothing to do.
        //
        return TRUE;
    }
    
    //
    // no mirroring
    //
    
    if ((DstCx < 0) || (DstCy < 0) || (SrcCx < 0) || (SrcCy < 0)) 
    {
        WARNING1("NtGdiAlphaBlend: mirroring not allowed\n");
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    
    BOOL bMirrorBitmap = (BlendFunction.BlendFlags & AC_MIRRORBITMAP);
    BlendFunction.BlendFlags &= ~AC_MIRRORBITMAP;

    //
    // validate dst DC
    //

    DCOBJ  dcoDst(hdcDst);

    if (!(dcoDst.bValid()) || dcoDst.bStockBitmap())
    {
        WARNING1("NtGdiAlphaBlend failed:  invalid dst DC");
        EngSetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    DCOBJ  dcoSrc(hdcSrc);

    if (dcoSrc.bValid())
    {
        EXFORMOBJ xoDst(dcoDst, WORLD_TO_DEVICE);
        EXFORMOBJ xoSrc(dcoSrc, WORLD_TO_DEVICE);

        //
        // no source rotation
        //

        if (!xoSrc.bRotationOrMirroring())
        {
            //
            // Return null operations.  Don't need to check source for
            // empty because the xforms are the same except translation.
            //

            ERECTL erclSrc(SrcX,SrcY,SrcX+SrcCx,SrcY+SrcCy);
            xoSrc.bXform(erclSrc);
            erclSrc.vOrder();

             
            //
            // If destination has a rotation, compute a bounding box for the
            // resulting parallelogram
            //
            POINTFIX pptfxDst[4];
            ERECTL erclDst;
            BOOL bRotationDst;

            if ((bRotationDst = xoDst.bRotationOrMirroring()))
            {
                //
                // Compute the resulting parallelogram.  In order to make sure we don't lose
                // precision in the rotation, we will store the output of the transformation
                // in fixed point numbers (this is how PlgBlt does it and we want our output
                // to match).
                // 
                POINTL pptlDst[3];

                pptlDst[0].x = DstX;
                pptlDst[0].y = DstY;

                pptlDst[1].x = DstX+DstCx;
                pptlDst[1].y = DstY;

                pptlDst[2].x = DstX;
                pptlDst[2].y = DstY+DstCy;

                xoDst.bXform(pptlDst, pptfxDst, 3);

                if (!xoDst.bRotation()) 
                {
                    //
                    // Mirroring transforms hack:  back in windows 3.1, they used to shift
                    // by one for mirroring transforms.  We need to support this here to
                    // be compatible with NT's BitBlt/StretchBlt that also use this hack, and
                    // also to be compatible with AlphaBlend that calls BitBlt/StretchBlt
                    // code when constant alpha=255 and there's no per-pixel alpha.  Ick!
                    // See BLTRECORD::vOrderStupid for details.  Also see bug 319917.
                    //

                    if (pptfxDst[0].x > pptfxDst[1].x) 
                    {
                        //
                        // Mirroring in x
                        //
                        pptfxDst[0].x += LTOFX(1);
                        pptfxDst[1].x += LTOFX(1);
                        pptfxDst[2].x += LTOFX(1);
                    }

                    if (pptfxDst[0].y > pptfxDst[2].y) 
                    {
                        //
                        // Mirroring in y
                        //
                        pptfxDst[0].y += LTOFX(1);
                        pptfxDst[1].y += LTOFX(1);
                        pptfxDst[2].y += LTOFX(1);
                    }
                }

                //
                // Compute the fourth point using the first three points.
                //
                pptfxDst[3].x = pptfxDst[1].x + pptfxDst[2].x - pptfxDst[0].x;
                pptfxDst[3].y = pptfxDst[1].y + pptfxDst[2].y - pptfxDst[0].y;

                //
                // Compute the bounding box.  Algorithm borrowed from Donald Sidoroff's code
                // in EngPlgBlt.  Basically the first two statements decide whether the indices of
                // the extremas are odd or even, and the last two statements determine exactly what
                // they are.
                //
                int iLeft = (pptfxDst[1].x > pptfxDst[0].x) == (pptfxDst[1].x > pptfxDst[3].x);
                int iTop  = (pptfxDst[1].y > pptfxDst[0].y) == (pptfxDst[1].y > pptfxDst[3].y);
                 
                if (pptfxDst[iLeft].x > pptfxDst[iLeft ^ 3].x)
                {
                    iLeft ^= 3;
                }
                 
                if (pptfxDst[iTop].y > pptfxDst[iTop ^ 3].y)
                {
                    iTop ^= 3;
                }

                erclDst = ERECTL(LONG_CEIL_OF_FIX(pptfxDst[iLeft  ].x),
                                 LONG_CEIL_OF_FIX(pptfxDst[iTop   ].y),
                                 LONG_CEIL_OF_FIX(pptfxDst[iLeft^3].x),
                                 LONG_CEIL_OF_FIX(pptfxDst[iTop^3 ].y));

                //
                // The vertices should now be in vOrder, but it doesn't hurt to verify this...
                //
                ASSERTGDI((erclDst.right  >= erclDst.left), "NtGdiAlphaBlend:  erclDst not in vOrder");
                ASSERTGDI((erclDst.bottom >= erclDst.top),  "NtGdiAlphaBlend:  erclDst not in vOrder");
            }
            else
            {
                //
                // No rotation--just apply the transformation to the rectangle
                //
               
                erclDst = ERECTL(DstX,DstY,DstX+DstCx,DstY+DstCy);
                xoDst.bXform(erclDst);
                erclDst.vOrder();
            }


            if (!erclDst.bEmpty())
            {
                //
                // Accumulate bounds.  We can do this outside the DEVLOCK
                //

                if (dcoDst.fjAccum())
                {
                    dcoDst.vAccumulate(erclDst);
                }

                //
                // Lock the Rao region and the surface if we are drawing on a
                // display surface.  Bail out if we are in full screen mode.
                //

                DEVLOCKBLTOBJ dlo;
                BOOL bLocked;

                bLocked = dlo.bLock(dcoDst, dcoSrc);

                if (bLocked)
                {
                    //
                    // Check pSurfDst, this may be an info DC or a memory DC with default bitmap.
                    //

                    SURFACE *pSurfDst;

                    if ((pSurfDst = dcoDst.pSurface()) != NULL)
                    {
                        XEPALOBJ   palDst(pSurfDst->ppal());
                        XEPALOBJ   palDstDC(dcoDst.ppal());

                        SURFACE *pSurfSrc = dcoSrc.pSurface();

                        //
                        // Basically we check that pSurfSrc is not NULL which
                        // happens for memory bitmaps with the default bitmap
                        // and for info DC's.  Otherwise we continue if
                        // the source is readable or if it isn't we continue
                        // if we are blting display to display or if User says
                        // we have ScreenAccess on this display DC.  Note
                        // that if pSurfSrc is not readable the only way we
                        // can continue the blt is if the src is a display.
                        //

                        if (pSurfSrc != NULL)
                        {
                            if ((pSurfSrc->bReadable()) ||
                                ( (dcoSrc.bDisplay())  &&
                                  ((dcoDst.bDisplay()) || UserScreenAccessCheck() )))
                            {

                                // Make sure that if the user claims that the source contains an 
                                // Alpha channel, it's a 32BPP source.  This is important, because
                                // the driver has no way of checking whether the source is 32BPP.

                                if ((BlendFunction.AlphaFormat & AC_SRC_ALPHA) &&
                                    (!(bIsSourceBGRA(pSurfSrc))))
                                {
                                    WARNING("NtGdiAlphaBlend:  AlphaFormat claims that there is an Alpha channel in a surface that's not 32BPP");
                                    EngSetLastError(ERROR_INVALID_PARAMETER);
                                    return FALSE;
                                }

                                
                                //
                                // With a fixed DC origin we can change the destination to SCREEN coordinates.
                                //

                                //
                                // This is useful later for rotations
                                //
                                ERECTL erclDstOrig = erclDst;                                 

                                erclDst += dcoDst.eptlOrigin();
                                erclSrc += dcoSrc.eptlOrigin();

                                //
                                // Make sure the source rectangle lies completely within the source
                                // surface.
                                //

                                BOOL bBadRects; 

                                // If the source is a Meta device, we must check bounds taking its 
                                // origin into account. 

                                PDEVOBJ pdoSrc( pSurfSrc->hdev() ); 

                                if( pSurfSrc->iType() == STYPE_DEVICE && 
                                    pdoSrc.bValid() && pdoSrc.bMetaDriver())
                                {
                                    bBadRects = ((erclSrc.left < pdoSrc.pptlOrigin()->x) ||
                                                    (erclSrc.top  < pdoSrc.pptlOrigin()->y) ||
                                                    (erclSrc.right  > pdoSrc.pptlOrigin()->x + 
                                                     pSurfSrc->sizl().cx) ||
                                                    (erclSrc.bottom > pdoSrc.pptlOrigin()->y + 
                                                     pSurfSrc->sizl().cy));
                                }
                                else
                                {
                                    bBadRects = ((erclSrc.left < 0) ||
                                                    (erclSrc.top  < 0) ||
                                                    (erclSrc.right  > pSurfSrc->sizl().cx) ||
                                                    (erclSrc.bottom > pSurfSrc->sizl().cy));
                                }

                                if (bBadRects)
                                {
                                    WARNING("NtGdiAlphaBlend -- source rectangle out of surface bounds");
                                }
                                
                                //
                                // Make sure that source and destination rectangles don't overlap if the
                                // source surface is the same as the destination surface.                                
                                //

                                if (pSurfSrc == pSurfDst)
                                {
                                    ERECTL erclIntersection = erclSrc;
                                    erclIntersection *= erclDst;
                                    if (!erclIntersection.bEmpty())
                                    {
                                        bBadRects = TRUE;
                                        WARNING ("NtGdiAlphaBlend -- source and destination rectangles are on the same surface and overlap");
                                    }
                                }
                                    
                                if (!bBadRects)
                                {

                                    //
                                    // check for quick out
                                    //

                                    if ((BlendFunction.SourceConstantAlpha == 255) &&
                                        (!(BlendFunction.AlphaFormat & AC_SRC_ALPHA)) &&
                                        (!(BlendFunction.BlendFlags & AC_USE_HIGHQUALITYFILTER)))
                                    {
                                        // BUGFIX #331222 2-2-2001
                                        // Set stretch mode to COLORONCOLOR for duration of GreStretchBlt call
                                        // AlphaBlend always point samples when stretching

                                        BYTE jStretchBltMode = dcoDst.pdc->jStretchBltMode();

                                        dcoDst.pdc->jStretchBltMode(COLORONCOLOR);

                                        bStatus = GreStretchBlt(
                                            hdcDst,
                                            DstX,
                                            DstY,
                                            DstCx,
                                            DstCy,
                                            hdcSrc,
                                            SrcX,
                                            SrcY,
                                            SrcCx,
                                            SrcCy,
                                            SRCCOPY,
                                            0xffffffff);

                                         bQuickStretch = TRUE;

                                         dcoDst.pdc->jStretchBltMode(jStretchBltMode);

                                    }

                                    //
                                    // no quick out
                                    //

                                    if (bStatus & !bQuickStretch)
                                    {

                                        XEPALOBJ palSrc(pSurfSrc->ppal());
                                        XEPALOBJ palSrcDC(dcoSrc.ppal());
                                        EXLATEOBJ xlo,xlo1,xloSrcDCto32,xloDstDCto32,xlo32toDstDC;
                                        XLATEOBJ *pxlo,*pxloSrcDCto32,*pxloDstDCto32,*pxlo32toDstDC;
    
                                        XEPALOBJ  palRGB(gppalRGB);
    
                                        //
                                        // Get a translate object from source dc to BGRA
                                        //
    
                                        COLORREF crBackColor = dcoSrc.pdc->ulBackClr();
    
                                        //
                                        // src to dst
                                        //

                                        bStatus = xlo.bInitXlateObj(
                                            NULL,
                                            DC_ICM_OFF,
                                            palSrc,
                                            palDst,
                                            palSrcDC,
                                            palDstDC,
                                            dcoSrc.pdc->crTextClr(),
                                            dcoSrc.pdc->crBackClr(),
                                            crBackColor
                                            );
    
                                        pxlo = xlo.pxlo();

                                        //
                                        // src to 32
                                        //

                                        bStatus &= xloSrcDCto32.bInitXlateObj(
                                            NULL,
                                            DC_ICM_OFF,
                                            palSrc,
                                            palRGB,
                                            palSrcDC,
                                            palSrcDC,
                                            dcoSrc.pdc->crTextClr(),
                                            dcoSrc.pdc->crBackClr(),
                                            crBackColor
                                            );
    
                                        pxloSrcDCto32 = xloSrcDCto32.pxlo();
    
                                        //
                                        // translate from dst dc to BGRA
                                        //
    
                                        bStatus &= xloDstDCto32.bInitXlateObj(
                                            NULL,
                                            DC_ICM_OFF,
                                            palDst,
                                            palRGB,
                                            palDstDC,
                                            palDstDC,
                                            dcoSrc.pdc->crTextClr(),
                                            dcoSrc.pdc->crBackClr(),
                                            crBackColor
                                            );
    
                                        pxloDstDCto32 = xloDstDCto32.pxlo();
    
                                        //
                                        // create xlate from 32 to dst dc
                                        //
    
                                        bStatus &= xlo32toDstDC.bInitXlateObj(
                                            NULL,
                                            DC_ICM_OFF,
                                            palRGB,
                                            palDst,
                                            palDstDC,
                                            palDstDC,
                                            dcoSrc.pdc->crTextClr(),
                                            dcoSrc.pdc->crBackClr(),
                                            crBackColor
                                            );
        
                                        pxlo32toDstDC = xlo32toDstDC.pxlo();

                                        // Compute destination clipping

                                        ECLIPOBJ eco(dcoDst.prgnEffRao(), erclDst);

                                        // Check the destination which is reduced by clipping.

                                        if (eco.erclExclude().bEmpty())
                                        {
                                            // NTBUG #456213 2-4-2000 bhouse Clean up use of multiple return
                                            // perf and size: don't return here
                                            return(TRUE);
                                        }

                                        // Compute the exclusion rectangle.

                                        ERECTL erclExclude = eco.erclExclude();

                                        // If we are going to the same source, prevent bad overlap situations
                                        // Expand exclusion rectangle to cover source rectangle

                                        if (dcoSrc.pSurface() == dcoDst.pSurface())
                                        {
                                            if (erclSrc.left   < erclExclude.left)
                                                erclExclude.left   = erclSrc.left;

                                            if (erclSrc.top    < erclExclude.top)
                                                erclExclude.top    = erclSrc.top;

                                            if (erclSrc.right  > erclExclude.right)
                                                erclExclude.right  = erclSrc.right;

                                            if (erclSrc.bottom > erclExclude.bottom)
                                                erclExclude.bottom = erclSrc.bottom;
                                        }

                                        // We might have to exclude the source or the target, get ready to do either.

                                        DEVEXCLUDEOBJ dxo;

                                        // Lock the source and target LDEVs

                                        PDEVOBJ pdoDst(pSurfDst->hdev());

                                        // They can't both be display

                                        if (dcoSrc.bDisplay())
                                        {
                                            ERECTL ercl(0,0,pSurfSrc->sizl().cx,pSurfSrc->sizl().cy);

                                            if (dcoSrc.pSurface() == dcoDst.pSurface())
                                                ercl *= erclExclude;
                                            else
                                                ercl *= erclSrc;

                                            dxo.vExclude(dcoSrc.hdev(),&ercl,NULL);
                                        }
                                        else if (dcoDst.bDisplay())
                                        {
                                            dxo.vExclude(dcoDst.hdev(),&erclExclude,&eco);
                                        }

                                        //
                                        // Note Win2k App compat: We do
                                        // mirroring only when the caller has
                                        // asked for it. This it to make sure
                                        // apps that worked on win2k are not 
                                        // suddenly mirrored causing problems. 
                                        //
                                        // If we need to do RTL layout then
                                        // we create a temporary surface and
                                        // mirror the source into it. Then
                                        // we use it as the source surface.
                                        //

                                        SURFMEM surfMirrorSrc;

                                        if (bMirrorBitmap &&
                                            (MIRRORED_DC(dcoDst.pdc)) &&
                                            (!MIRRORED_DC_NO_BITMAP_FLIP(dcoDst.pdc)))
                                        {

                                            // Create temporary surface

                                            DEVBITMAPINFO dbmi;

                                            dbmi.cxBitmap = pSurfSrc->sizl().cx;
                                            dbmi.cyBitmap = pSurfSrc->sizl().cy; 
                                            dbmi.iFormat = pSurfSrc->iFormat();
                                            dbmi.fl = 0;
                                            XEPALOBJ palMirrorSrc(pSurfSrc->ppal());
                                            dbmi.hpal = (HPALETTE)palMirrorSrc.hpal();

                                            surfMirrorSrc.bCreateDIB(&dbmi,(VOID*)NULL);

                                            if(!surfMirrorSrc.bValid())
                                            {
                                                WARNING("NtGdiAlphaBlend: Could not create surface to mirror the source");
                                                return FALSE;
                                            }

                                            ERECTL erclMirrorSrc(0,0,pSurfSrc->sizl().cx,pSurfSrc->sizl().cy);
                                            EPOINTL eptlMirrorSrcTopLeft(0,0);

                                            // Copy source surface into the
                                            // temporary

                                            if(!(*PPFNGET(pdoSrc,CopyBits,pSurfSrc->flags()))(
                                                            surfMirrorSrc.ps->pSurfobj(),
                                                            pSurfSrc->pSurfobj(),
                                                            NULL,
                                                            NULL,
                                                            &erclMirrorSrc,
                                                            &eptlMirrorSrcTopLeft))
                                            {
                                                WARNING("NtGdiAlphaBlend: Could not mirror the source");
                                                return FALSE;
                                            }

                                            // Mirror the temporary surface.
                                            (*apfnMirror[surfMirrorSrc.ps->iFormat()])(surfMirrorSrc.ps);

                                            // Use temporary surface as source.
                                            pSurfSrc = surfMirrorSrc.ps;

                                        }


                                        //
                                        // If the destination requires rotation, we allocate a surface and rotate the
                                        // source surface into it.
                                        //

                                        SURFMEM surfMemTmpSrc;

                                        //
                                        // If the source is 32bits and has no per pixel Alpha, we need to first copy it
                                        // and then add per pixel Alpha information (all this before the rotation).
                                        //
                                        
                                        SURFMEM surfMemTmpSrcPreRotate;
                                        
                                        if (bRotationDst)
                                        {
                                            //
                                            // allocate 32bpp BGRA surface for source, must be zero init
                                            //
                                            
                                            DEVBITMAPINFO   dbmi;
                                            
                                            dbmi.cxBitmap = erclDst.right  - erclDst.left;
                                            dbmi.cyBitmap = erclDst.bottom - erclDst.top;
                                            dbmi.iFormat  = BMF_32BPP;
                                            dbmi.fl       = 0;
                                            XEPALOBJ      palRGB(gppalRGB);
                                            dbmi.hpal     = (HPALETTE)palRGB.hpal();

                                            bStatus &= surfMemTmpSrc.bCreateDIB(&dbmi, (VOID *) NULL);

                                            //
                                            // init DIB to transparent
                                            // (so that portions of dst rect not covered by source rect are not drawn)
                                            //
                                            if (bStatus)
                                            {
                                                if (!(BlendFunction.AlphaFormat & AC_SRC_ALPHA))
                                                {
                                                    //
                                                    // Source has no per pixel Alpha.  Need to first
                                                    // copy source to a new bitmap, then set the per pixel Alpha,
                                                    // and only then rotate.
                                                    //
                                                    DEVBITMAPINFO   dbmiPreRotate;

                                                    dbmiPreRotate.cxBitmap = erclSrc.right  - erclSrc.left;
                                                    dbmiPreRotate.cyBitmap = erclSrc.bottom - erclSrc.top;
                                                    dbmiPreRotate.iFormat  = BMF_32BPP;
                                                    dbmiPreRotate.fl       = 0;
                                                    XEPALOBJ      palRGB(gppalRGB);
                                                    dbmiPreRotate.hpal     = (HPALETTE)palRGB.hpal();
                                                    
                                                    bStatus = surfMemTmpSrcPreRotate.bCreateDIB(&dbmiPreRotate, (VOID *) NULL);

                                                    if (bStatus)
                                                    {

                                                        //
                                                        // Make sure the bitmap starts at (0,0), but remember the original
                                                        // starting point in eptlSrcTopLeft
                                                        //
                                                        EPOINTL eptlSrcTopLeft (erclSrc.left, erclSrc.top);
                                                    
                                                        // Make sure the subtraction doesn't overflow
                                                        if (((erclSrc.left < 0) && 
                                                             (-erclSrc.left > MAXLONG/2) && 
                                                             (erclSrc.right > MAXLONG/2)) ||
                                                            ((erclSrc.top < 0) && 
                                                             (-erclSrc.top > MAXLONG/2) && 
                                                             (erclSrc.top > MAXLONG/2)))
                                                        {
                                                            //
                                                            // Fail the call
                                                            //
                                                            WARNING("NtGdiAlphaBlend:  source rectangle too large\n");
                                                            EngSetLastError(ERROR_INVALID_PARAMETER);
                                                            return FALSE;
                                                        }

                                                        erclSrc -= eptlSrcTopLeft;
                                                    
                                                        //
                                                        // Only call EngCopyBits for non-empty rectangles
                                                        //
                                                        if ((erclSrc.right  > erclSrc.left) && 
                                                            (erclSrc.bottom > erclSrc.top) &&
                                                            (eptlSrcTopLeft.x <= pSurfSrc->sizl().cx) &&
                                                            (eptlSrcTopLeft.y <= pSurfSrc->sizl().cy))
                                                        {
                                                            EngCopyBits(
                                                                surfMemTmpSrcPreRotate.ps->pSurfobj(),
                                                                pSurfSrc->pSurfobj(),
                                                                NULL,
                                                                pxloSrcDCto32,
                                                                &erclSrc,
                                                                &eptlSrcTopLeft
                                                                );
                                                        }
                                                        
                                                        
                                                        //
                                                        // Now set the Alpha channel to 255 (opaque)
                                                        //
                                                        
                                                        PULONG pulDstY     = (PULONG)surfMemTmpSrcPreRotate.ps->pvScan0();
                                                        PULONG pulDstLastY = (PULONG)((PBYTE)pulDstY + 
                                                                                      (surfMemTmpSrcPreRotate.ps->lDelta() * 
                                                                                       surfMemTmpSrcPreRotate.ps->sizl().cy));
                                                        LONG DstYCount = 0;
                                                        while (pulDstY != pulDstLastY)
                                                        {
                                                            if ((DstYCount >= erclSrc.top) &&
                                                                (DstYCount < erclSrc.bottom))
                                                            {
                                                                PULONG pulDstX     = pulDstY;
                                                                PULONG pulDstLastX = pulDstX + surfMemTmpSrcPreRotate.ps->sizl().cx;
                                                                LONG DstXCount = 0;
                                                                while (pulDstX != pulDstLastX)
                                                                {
                                                                    if ((DstXCount >= erclSrc.left) &&
                                                                        (DstXCount < erclSrc.right))
                                                                    {
                                                                        *pulDstX = *pulDstX | 0xff000000;
                                                                    }
                                                                    DstXCount++;
                                                                    pulDstX++;
                                                                }
                                                            }
                                                            
                                                            DstYCount++;
                                                            pulDstY = (PULONG)((PBYTE)pulDstY + surfMemTmpSrcPreRotate.ps->lDelta());
                                                        }                                                    
                                                    

                                                        // 
                                                        // Set source surface to pre rotated bitmap, and set color
                                                        // translation to trivial
                                                        //
                                                        pSurfSrc = surfMemTmpSrcPreRotate.ps;

                                                        pxloSrcDCto32 = &xloIdent;

                                                        //
                                                        // Now we have an Alpha channel
                                                        //
                                                        BlendFunction.AlphaFormat |= AC_SRC_ALPHA;
                                                        
                                                    }
                                                }
                                                //
                                                // Source is 32bit with per pixel Alpha.  Make sure everything
                                                // is transparent before the EngPlgBlt call.
                                                //
                                                RtlFillMemoryUlong(surfMemTmpSrc.ps->pvBits(),
                                                                   surfMemTmpSrc.ps->cjBits(),
                                                                   0x00000000);
                                            }
                                            if (!bStatus)
                                            {
                                                //
                                                // Fail the call
                                                //
                                                WARNING("NtGdiAlphaBlend:  failed to create temporary DIB\n");
                                                EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                                                return FALSE;
                                            }
                                  
    
                                            //
                                            // Now define the parallelogram the source bitmap is mapped to in surfMemTmpSrc
                                            //
      
                                            EPOINTFIX eptlNewSrc[3];
    
                                            eptlNewSrc[0] = EPOINTFIX(
                                                pptfxDst[0].x - LTOFX(erclDstOrig.left), 
                                                pptfxDst[0].y - LTOFX(erclDstOrig.top)
                                                );

                                            eptlNewSrc[1] = EPOINTFIX(
                                                pptfxDst[1].x - LTOFX(erclDstOrig.left), 
                                                pptfxDst[1].y - LTOFX(erclDstOrig.top)
                                                );
    
                                            eptlNewSrc[2] = EPOINTFIX(
                                                pptfxDst[2].x - LTOFX(erclDstOrig.left), 
                                                pptfxDst[2].y - LTOFX(erclDstOrig.top)
                                                );

                                            EngPlgBlt(
                                                surfMemTmpSrc.ps->pSurfobj(),
                                                pSurfSrc->pSurfobj(),
                                                NULL,   // No mask
                                                NULL,   // No clipping object
                                                pxloSrcDCto32,
                                                NULL,   // No color adjustment
                                                NULL,   
                                                eptlNewSrc,
                                                &erclSrc,
                                                NULL,
                                                COLORONCOLOR 
                                                );


                                            //
                                            // Now adjust the local variables.  First fix color translation.         
                                            //

                                            //
                                            // src to dst
                                            //

                                            bStatus = xlo1.bInitXlateObj(
                                                NULL,
                                                DC_ICM_OFF,
                                                palRGB,
                                                palDst,
                                                NULL,
                                                palDstDC,
                                                dcoSrc.pdc->crTextClr(),
                                                dcoSrc.pdc->crBackClr(),
                                                crBackColor
                                                );
    
                                            pxlo = xlo1.pxlo();

                                            //
                                            // src to 32
                                            //

                                            pxloSrcDCto32 = &xloIdent;


                                            pSurfSrc = surfMemTmpSrc.ps;
                                            erclSrc.left = 0;
                                            erclSrc.top = 0;
                                            erclSrc.right = erclDst.right - erclDst.left;
                                            erclSrc.bottom = erclDst.bottom - erclDst.top;
                                        }

                                        if (bStatus)
                                        {
                                            //
                                            // Inc the target surface uniqueness
                                            //

                                            INC_SURF_UNIQ(pSurfDst);

                                            //
                                            // Dispatch the call.  Give it no mask.
                                            //

                                            //
                                            // Check were on the same PDEV, we can't blt between
                                            // different PDEV's.  We could make blting between different
                                            // PDEV's work easily.  All we need to do force EngBitBlt to
                                            // be called if the PDEV's aren't equal in the dispatch.
                                            // EngBitBlt does the right thing.
                                            //

                                            if (dcoDst.hdev() == dcoSrc.hdev())
                                            {
                                                EBLENDOBJ eBlendObj;

                                                eBlendObj.BlendFunction = BlendFunction;
                                                eBlendObj.pxloSrcTo32   = pxloSrcDCto32;
                                                eBlendObj.pxloDstTo32   = pxloDstDCto32;
                                                eBlendObj.pxlo32ToDst   = pxlo32toDstDC;

                                                //
                                                // dispatch to driver or engine
                                                //

                                                if ( (erclDst.right - erclDst.left) == (erclSrc.right - erclSrc.left) &&
                                                     (erclDst.bottom - erclDst.top) == (erclSrc.bottom - erclSrc.top) )
                                                {
                                                    eBlendObj.BlendFunction.BlendFlags &= ~AC_USE_HIGHQUALITYFILTER;
                                                }

                                                bStatus = (*PPFNGET(pdoDst,AlphaBlend, pSurfDst->flags())) (
                                                    pSurfDst->pSurfobj(),
                                                    pSurfSrc->pSurfobj(),
                                                    &eco,
                                                    pxlo,
                                                    &erclDst,
                                                    &erclSrc,
                                                    (BLENDOBJ *)&eBlendObj
                                                    );
                                            }
                                            else
                                            {
                                                WARNING1("NtGdiAlphaBlend failed: source and destination surfaces not on same PDEV");
                                                EngSetLastError(ERROR_INVALID_PARAMETER);
                                                bStatus = FALSE;
                                            }
                                        
                                        }
                                        else
                                        {
                                            WARNING1("bInitXlateObj failed in NtGdiAlphaBlend\n");
                                            EngSetLastError(ERROR_INVALID_HANDLE);
                                            bStatus = FALSE;
                                        }
                                    }
                                    else
                                    {
                                        //
                                        // Nothing to do--the call to GreStretchBlt succeeded.
                                        //
                                        NULL;
                                    }
                                }
                                else
                                {
                                    EngSetLastError(ERROR_INVALID_PARAMETER);
                                    bStatus = FALSE;
                                }
                            }
                            else
                            {
                                WARNING1("NtGdiAlphaBlend failed - trying to read from unreadable surface\n");
                                EngSetLastError(ERROR_INVALID_HANDLE);
                                bStatus = FALSE;
                            }
                        }
                        else
                        {
                            bStatus = TRUE; // pSurfSrc is NULL
                        }
                    }
                    else
                    {
                        bStatus = TRUE; // pSurfDst is NULL
                    }
                }
                else
                {
                    //
                    // Return True if we are in full screen mode.
                    //

                    bStatus = dcoDst.bFullScreen() | dcoSrc.bFullScreen();
                }
            }
            else
            {
                bStatus = TRUE; // erclDst is empty
            }
        }
        else
        {
            bStatus = FALSE;
            EngSetLastError(ERROR_INVALID_PARAMETER);
            WARNING1("Error in NtGdiAlphaBlend:  source rotation is not allowed");
        }        
    } 
    else
    {
        bStatus = FALSE;
        EngSetLastError(ERROR_INVALID_PARAMETER);
        WARNING1("NtGdiAlphaBlend failed:  invalid src DC");
    }
    
    return(bStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\alphatran.cxx ===
/******************************Module*Header*******************************\
* Module Name: tranblt.cxx
*
* Transparent BLT
*
* Created: 21-Jun-1996
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1996-1999 Microsoft Corporation
\**************************************************************************/
#include "precomp.hxx"


/**************************************************************************\
*
* XLATE_TO_BGRA  - match palette indexed color to BGRA
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/9/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#define XLATE_TO_BGRA(pxlo,cIndex,ulDst)                \
        if (cIndex > pxlo->cEntries)                    \
        {                                               \
            cIndex = cIndex % pxlo->cEntries;           \
        }                                               \
                                                        \
        ulDst = ((XLATE *) pxlo)->ai[cIndex]

/******************************Public*Routine******************************\
* Routines to load a pixel and convert it to BGRA representaion for
* blending operations
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/2/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert1ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    XLATEOBJ *pxlo
    )
{
    BYTE SrcByte;

    ASSERTGDI((pxlo->flXlate & XO_TABLE),"vLoadAndConvert1ToBGRA: xlate must be XO_TABLE");

    if (pxlo->flXlate & XO_TABLE)
    {

        pSrcAddr = pSrcAddr + (SrcX >> 3);

        LONG cxUnalignedStart = 7 & (8 - (SrcX & 7));

        cxUnalignedStart = MIN(SrcCx,cxUnalignedStart);

        //
        // unaligned start
        //

        if (cxUnalignedStart)
        {
            LONG iDst = 7 - (SrcX & 0x07);
            SrcByte = *pSrcAddr;
            pSrcAddr++;

            while (cxUnalignedStart--)
            {
                ULONG ulDst = ((SrcByte & (1 << iDst)) >> iDst);

                XLATE_TO_BGRA(pxlo,ulDst,ulDst);

                ulDst = ulDst | 0xFF000000;

                *pulDstAddr = ulDst;

                pulDstAddr++;
                SrcCx--;
                iDst--;
            }
        }

        //
        // aligned whole bytes
        //

        while (SrcCx >= 8)
        {
            ULONG ulDst;
            ULONG ulIndex;

            SrcCx -= 8;

            SrcByte = *pSrcAddr;

            ulIndex = (ULONG)((SrcByte & 0x80) >> 7);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *(pulDstAddr + 0) = ulDst | 0xff000000;

            ulIndex = ((SrcByte & 0x40) >> 6);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *(pulDstAddr + 1) = ulDst | 0xff000000;

            ulIndex = ((SrcByte & 0x20) >> 5);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *(pulDstAddr + 2) = ulDst | 0xff000000;

            ulIndex = ((SrcByte & 0x10) >> 4);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *(pulDstAddr + 3) = ulDst | 0xff000000;

            ulIndex = ((SrcByte & 0x08) >> 3);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *(pulDstAddr + 4) = ulDst | 0xff000000;

            ulIndex = ((SrcByte & 0x04) >> 2);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *(pulDstAddr + 5) = ulDst | 0xff000000;

            ulIndex = ((SrcByte & 0x02) >> 1);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *(pulDstAddr + 6) = ulDst | 0xff000000;

            ulIndex = ((SrcByte & 0x01) >> 0);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *(pulDstAddr + 7) = ulDst | 0xff000000;

            pSrcAddr++;
            pulDstAddr+=8;
        }

        //
        // unaligned end
        //

        if (SrcCx)
        {
            BYTE SrcByte = *pSrcAddr;
            LONG iDst    = 7;

            while (SrcCx)
            {
                ULONG ulDst = ((SrcByte & (1 << iDst)) >> iDst);

                XLATE_TO_BGRA(pxlo,ulDst,ulDst);

                *pulDstAddr = ulDst | 0xff000000;

                pulDstAddr++;
                SrcCx--;
                iDst--;
            }
        }
    }
}

/**************************************************************************\
* vLoadAndConvert4ToBGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert4ToBGRA(
    PULONG    pulDstAddr,
    PBYTE     pSrcAddr,
    LONG      SrcX,
    LONG      SrcCx,
    XLATEOBJ *pxlo
    )
{
    ASSERTGDI((pxlo->flXlate & XO_TABLE),"vLoadAndConvert1ToBGRA: xlate must be XO_TABLE");

    if (pxlo->flXlate & XO_TABLE)
    {
        ULONG ulIndex;
        ULONG ulDst;
        BYTE  SrcByte;
        LONG  cxUnalignedStart;

        pSrcAddr         = pSrcAddr + (SrcX >> 1);
        cxUnalignedStart = 1 & (2 - (SrcX & 1));
        cxUnalignedStart = MIN(SrcCx,cxUnalignedStart);

        //
        // unaligned start
        //

        if (cxUnalignedStart)
        {
            SrcByte = *pSrcAddr;

            ulIndex = (SrcByte & 0x0f);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);

            *pulDstAddr = ulDst | 0xff000000;
            pSrcAddr++;
            pulDstAddr++;
            SrcCx--;
        }

        //
        // aligned whole bytes
        //

        while (SrcCx >= 2)
        {
            SrcCx -= 2;

            SrcByte = *pSrcAddr;

            ulIndex = (SrcByte >> 4);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *(pulDstAddr + 0) = ulDst | 0xff000000;

            ulIndex = (SrcByte & 0x0f);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *(pulDstAddr + 1) = ulDst | 0xff000000;

            pSrcAddr++;
            pulDstAddr+=2;
        }

        //
        // unaligned end
        //

        if (SrcCx)
        {
            SrcByte = *pSrcAddr;
            ulIndex = (SrcByte >> 4);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *pulDstAddr = ulDst | 0xff000000;
        }
    }
}

/**************************************************************************\
* vLoadAndConvert8ToBGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert8ToBGRA(
    PULONG    pulDstAddr,
    PBYTE     pSrcAddr,
    LONG      SrcX,
    LONG      SrcCx,
    XLATEOBJ *pxlo
    )
{
    ASSERTGDI((pxlo->flXlate & XO_TABLE),"vLoadAndConvert1ToBGRA: xlate must be XO_TABLE");

    if (pxlo->flXlate & XO_TABLE)
    {
        PBYTE pjSrc = pSrcAddr + SrcX;
        PBYTE pjEnd = pjSrc + SrcCx;

        while (pjSrc != pjEnd)
        {
            ALPHAPIX apix;
            BYTE     jTemp;
            ULONG    ulDst;

            ulDst = (ULONG)*pjSrc;
            XLATE_TO_BGRA(pxlo,ulDst,ulDst);

            apix.ul = ulDst | 0xff000000;

            *pulDstAddr = apix.ul;

            pulDstAddr++;
            pjSrc++;
        }
    }

}

/**************************************************************************\
* vLoadAndConvertRGB16_565ToBGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvertRGB16_565ToBGRA(
    PULONG    pulDstAddr,
    PBYTE     pSrcAddr,
    LONG      SrcX,
    LONG      SrcCx,
    XLATEOBJ *pxlo
    )
{
    PUSHORT pusSrc = (PUSHORT)pSrcAddr + SrcX;
    ULONG    ul;

    //
    // unaligned single at start
    //

    if ((ULONG_PTR)pusSrc & 0x02)
    {
        ul = *pusSrc;

        *pulDstAddr =    (((ul << 8) & 0xf80000)
                        | ((ul << 3) & 0x070000)
                        | ((ul << 5) & 0x00fc00)
                        | ((ul >> 1) & 0x000300)
                        | ((ul << 3) & 0x0000f8)
                        | ((ul >> 2) & 0x000007)
                        | 0xff000000);

        pusSrc++;
        pulDstAddr++;
        SrcCx--;
    }

    //
    // aligned
    //

    PUSHORT pusEnd = pusSrc + (SrcCx & ~1);

    while (pusSrc != pusEnd)
    {
        ul = *(PULONG)pusSrc;

        *pulDstAddr =    (((ul << 8) & 0xf80000)
                        | ((ul << 3) & 0x070000)
                        | ((ul << 5) & 0x00fc00)
                        | ((ul >> 1) & 0x000300)
                        | ((ul << 3) & 0x0000f8)
                        | ((ul >> 2) & 0x000007)
                        | 0xff000000);


        *(pulDstAddr+1) = (((ul >> 8) & 0xf80000)
                        | ((ul >> 13) & 0x070000)
                        | ((ul >> 11) & 0x00fc00)
                        | ((ul >> 17) & 0x000300)
                        | ((ul >> 13) & 0x0000f8)
                        | ((ul >> 18) & 0x000007)
                        | 0xff000000);

        pusSrc+= 2;
        pulDstAddr+=2;
    }

    //
    // end unaligned
    //

    if (SrcCx & 1)
    {
        ul = *pusSrc;

        *pulDstAddr =    (((ul << 8) & 0xf80000)
                        | ((ul << 3) & 0x070000)
                        | ((ul << 5) & 0x00fc00)
                        | ((ul >> 1) & 0x000300)
                        | ((ul << 3) & 0x0000f8)
                        | ((ul >> 2) & 0x000007)
                        | 0xff000000);

    }
}

/**************************************************************************\
* vLoadAndConvertRGB16_555ToBGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvertRGB16_555ToBGRA(
    PULONG    pulDstAddr,
    PBYTE     pSrcAddr,
    LONG      SrcX,
    LONG      SrcCx,
    XLATEOBJ *pxlo
    )
{
    PUSHORT pusSrc = (PUSHORT)pSrcAddr + SrcX;
    ULONG   ul;

    //
    // unaligned single at start
    //

    if ((ULONG_PTR)pusSrc & 0x02)
    {
        ul = *pusSrc;

        *pulDstAddr = (((ul << 9) & 0xf80000)
                    | ((ul << 4) & 0x070000)
                    | ((ul << 6) & 0x00f800)
                    | ((ul << 1) & 0x000700)
                    | ((ul << 3) & 0x0000f8)
                    | ((ul >> 2) & 0x000007)
                    | 0xff000000);

        pusSrc++;
        pulDstAddr++;
        SrcCx--;
    }

    //
    // aligned
    //

    PUSHORT pusEnd = pusSrc + (SrcCx & ~1);

    while (pusSrc != pusEnd)
    {
        ULONG ul = *(PULONG)pusSrc;

        *pulDstAddr = (((ul << 9) & 0xf80000)
                    | ((ul << 4) & 0x070000)
                    | ((ul << 6) & 0x00f800)
                    | ((ul << 1) & 0x000700)
                    | ((ul << 3) & 0x0000f8)
                    | ((ul >> 2) & 0x000007)
                    | 0xff000000);

        *(pulDstAddr+1) = (((ul >> 7) & 0xf80000)
                        | ((ul >> 12) & 0x070000)
                        | ((ul >> 10) & 0x00f800)
                        | ((ul >> 15) & 0x000700)
                        | ((ul >> 13) & 0x0000f8)
                        | ((ul >> 18) & 0x000007)
                        | 0xff000000);

        pusSrc+= 2;
        pulDstAddr+=2;
    }

    //
    // end unaligned
    //

    if (SrcCx & 1)
    {
        ul = *pusSrc;

        *pulDstAddr = (((ul << 9) & 0xf80000)
                    | ((ul << 4) & 0x070000)
                    | ((ul << 6) & 0x00f800)
                    | ((ul << 1) & 0x000700)
                    | ((ul << 3) & 0x0000f8)
                    | ((ul >> 2) & 0x000007)
                    | 0xff000000);
    }
}

/**************************************************************************\
* vLoadAndConvert16BitfieldsToBGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert16BitfieldsToBGRA(
    PULONG    pulDstAddr,
    PBYTE     pSrcAddr,
    LONG      SrcX,
    LONG      SrcCx,
    XLATEOBJ *pxlo
    )
{
    PUSHORT pusSrc = (PUSHORT)pSrcAddr + SrcX;
    PUSHORT pusEnd = pusSrc + SrcCx;
    while (pusSrc != pusEnd)
    {
        ULONG ulTmp;

        ulTmp = *pusSrc;

        ulTmp = (((XLATE *)pxlo)->ulTranslate(ulTmp));

        *pulDstAddr = ulTmp | 0xff000000;

        pusSrc++;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvertRGB24ToBGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvertRGB24ToBGRA(
    PULONG    pulDstAddr,
    PBYTE     pSrcAddr,
    LONG      SrcX,
    LONG      SrcCx,
    XLATEOBJ *pxlo
    )
{
    PBYTE pjSrc = pSrcAddr + 3 * SrcX;
    PBYTE pjEnd = pjSrc    + 3 * SrcCx;

    while (pjSrc != pjEnd)
    {
        ALPHAPIX pixRet;

        pixRet.pix.r = *(((PBYTE)pjSrc));
        pixRet.pix.g = *(((PBYTE)pjSrc)+1);
        pixRet.pix.b = *(((PBYTE)pjSrc)+2);
        pixRet.pix.a = 0xff;

        *pulDstAddr = pixRet.ul;

        pjSrc += 3;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvertBGR24ToBGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    5/4/2000 bhouse
*
\**************************************************************************/

VOID
vLoadAndConvertBGR24ToBGRA(
    PULONG    pulDstAddr,
    PBYTE     pSrcAddr,
    LONG      SrcX,
    LONG      SrcCx,
    XLATEOBJ *pxlo
    )
{
    PBYTE pjSrc = pSrcAddr + 3 * SrcX;
    PBYTE pjEnd = pjSrc    + 3 * SrcCx;

    while (pjSrc != pjEnd)
    {
        ALPHAPIX pixRet;

        pixRet.pix.b = *(((PBYTE)pjSrc));
        pixRet.pix.g = *(((PBYTE)pjSrc)+1);
        pixRet.pix.r = *(((PBYTE)pjSrc)+2);
        pixRet.pix.a = 0xff;

        *pulDstAddr = pixRet.ul;

        pjSrc += 3;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvertRGB32ToBGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvertRGB32ToBGRA(
    PULONG    pulDstAddr,
    PBYTE     pSrcAddr,
    LONG      SrcX,
    LONG      SrcCx,
    XLATEOBJ *pxlo
    )
{
    PULONG pulSrc = (PULONG)pSrcAddr + SrcX;
    PULONG pulEnd = pulSrc + SrcCx;

    while (pulSrc != pulEnd)
    {
        ALPHAPIX pixIn;
        ALPHAPIX pixOut;

        pixIn.ul = *pulSrc;

        pixOut.pix.r = pixIn.pix.b;
        pixOut.pix.g = pixIn.pix.g;
        pixOut.pix.b = pixIn.pix.r;
        pixOut.pix.a = 0xff;

        *pulDstAddr = pixOut.ul;

        pulSrc++;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvert32BitfieldsToBGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert32BitfieldsToBGRA(
    PULONG    pulDstAddr,
    PBYTE     pSrcAddr,
    LONG      SrcX,
    LONG      SrcCx,
    XLATEOBJ *pxlo
    )
{
    PULONG pulSrc = (PULONG)pSrcAddr + SrcX;
    PULONG pulEnd = pulSrc + SrcCx;

    while (pulSrc != pulEnd)
    {
        ULONG ulTmp;

        ulTmp = *pulSrc;

        ulTmp = (((XLATE *)pxlo)->ulTranslate(ulTmp));
        ulTmp |= 0xff000000;

        *pulDstAddr = ulTmp;

        pulSrc++;
        pulDstAddr++;
    }
}

//
//
// STORE ROUTINES
//
//

#define PALETTE_MATCH(pixIn,ppalDst,ppalDstDC)                \
{                                                             \
    BYTE jSwap;                                               \
                                                              \
    pixIn.pix.a  = 0x02;                                      \
    jSwap        = pixIn.pix.r;                               \
    pixIn.pix.r  = pixIn.pix.b;                               \
    pixIn.pix.b  = jSwap;                                     \
                                                              \
    pixIn.ul = ulGetNearestIndexFromColorref(                 \
                            ppalDst,                          \
                            ppalDstDC,                        \
                            pixIn.ul,                         \
                            ppalDst.cEntries() ?              \
                                SE_DO_SEARCH_EXACT_FIRST  :   \
                                SE_DONT_SEARCH_EXACT_FIRST    \
                                                              \
                            );                                \
}                                                             \

/**************************************************************************\
* vConvertAndSaveBGRATo1
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRATo1(
    PBYTE       pDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    XLATEOBJ    *pxlo,
    XEPALOBJ    ppalDst,
    XEPALOBJ    ppalDstDC
    )
{
    PBYTE pjDst = pDst + (DstX >> 3);
    LONG  iDst  = DstX & 7;

    //
    // unaligned byte
    //

    if (iDst)
    {
        BYTE DstByte     = *pjDst;
        LONG iShift      = 7 - iDst;
        LONG cxUnaligned = iShift + 1;

        cxUnaligned = MIN(cxUnaligned,cx);
        cx -= cxUnaligned;

        while (cxUnaligned--)
        {
            ALPHAPIX  pixIn;

            pixIn.ul = *pulSrc;

            PALETTE_MATCH(pixIn,ppalDst,ppalDstDC);

            pixIn.ul = pixIn.ul << iShift;

            DstByte = DstByte & (~(1 << iShift));
            DstByte |= (BYTE)pixIn.ul;
            pulSrc++;
            iShift--;
        }

        *pjDst = DstByte;
        pjDst++;
    }

    //
    // aligned whole bytes
    //

    while (cx >= 8)
    {
        ALPHAPIX  pixIn;
        BYTE DstByte;

        pixIn.ul = *pulSrc;
        PALETTE_MATCH(pixIn,ppalDst,ppalDstDC);
        DstByte      = (BYTE)(pixIn.ul << 7);

        pixIn.ul = *(pulSrc+1);
        PALETTE_MATCH(pixIn,ppalDst,ppalDstDC);
        DstByte     |= (BYTE)(pixIn.ul << 6);

        pixIn.ul = *(pulSrc+2);
        PALETTE_MATCH(pixIn,ppalDst,ppalDstDC);
        DstByte     |= (BYTE)(pixIn.ul << 5);

        pixIn.ul = *(pulSrc+3);
        PALETTE_MATCH(pixIn,ppalDst,ppalDstDC);
        DstByte     |= (BYTE)(pixIn.ul << 4);

        pixIn.ul = *(pulSrc+4);
        PALETTE_MATCH(pixIn,ppalDst,ppalDstDC);
        DstByte     |= (BYTE)(pixIn.ul << 3);

        pixIn.ul = *(pulSrc+5);
        PALETTE_MATCH(pixIn,ppalDst,ppalDstDC);
        DstByte     |= (BYTE)(pixIn.ul << 2);

        pixIn.ul = *(pulSrc+6);
        PALETTE_MATCH(pixIn,ppalDst,ppalDstDC);
        DstByte     |= (BYTE)(pixIn.ul << 1);

        pixIn.ul = *(pulSrc+7);
        PALETTE_MATCH(pixIn,ppalDst,ppalDstDC);
        DstByte     |= (BYTE)(pixIn.ul << 0);

        *pjDst = DstByte;

        pjDst++;
        pulSrc += 8;
        cx -= 8;
    }

    //
    // unaligned end
    //

    if (cx)
    {
        BYTE iShift = 7;
        BYTE DstByte = *pjDst;

        while (cx--)
        {
            ALPHAPIX  pixIn;

            pixIn.ul = *pulSrc;

            PALETTE_MATCH(pixIn,ppalDst,ppalDstDC);

            pixIn.ul = pixIn.ul << iShift;
            DstByte = DstByte & (~(1 << iShift));
            DstByte |= (BYTE)pixIn.ul;
            pulSrc++;
            iShift--;
        }

        *pjDst = DstByte;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRATo4
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRATo4(
    PBYTE       pDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    XLATEOBJ    *pxlo,
    XEPALOBJ    ppalDst,
    XEPALOBJ    ppalDstDC
    )
{
    PBYTE pjDst = pDst + (DstX >> 1);
    LONG  iDst  = DstX & 1;

    PBYTE pxlate = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate == NULL)
    {
        WARNING("vConvertAndSaveBGRA: To4Failed to generate rgb333 xlate table\n");
        return;
    }

    //
    // make sure params are valid
    //

    if (cx == 0)
    {
        return;
    }

    //
    // unaligned byte
    //

    if (iDst)
    {
        BYTE DstByte     = *pjDst;
        ALPHAPIX  pixIn;

        pixIn.ul = *pulSrc;

        pixIn.ul = XLATEOBJ_BGR32ToPalSurf(pxlo,pxlate,pixIn.ul);

        DstByte = (DstByte & 0xf0) | (BYTE)pixIn.ul;

        *pjDst = DstByte;
        pjDst++;
        pulSrc++;
        cx--;
    }

    //
    // aligned whole bytes
    //

    while (cx >= 2)
    {
        BYTE DstByte;
        ALPHAPIX  pixIn;

        pixIn.ul = *pulSrc;
        pixIn.ul = XLATEOBJ_BGR32ToPalSurf(pxlo,pxlate,pixIn.ul);
        DstByte = (BYTE)(pixIn.ul << 4);

        pixIn.ul = *(pulSrc+1);
        pixIn.ul = XLATEOBJ_BGR32ToPalSurf(pxlo,pxlate,pixIn.ul);
        DstByte |= (BYTE)(pixIn.ul);

        *pjDst = DstByte;

        pjDst++;
        pulSrc += 2;
        cx -= 2;
    }

    //
    // unaligned end
    //

    if (cx)
    {
        BYTE DstByte = *pjDst;
        ALPHAPIX  pixIn;

        pixIn.ul = *pulSrc;

        pixIn.ul = XLATEOBJ_BGR32ToPalSurf(pxlo,pxlate,pixIn.ul);

        DstByte = (DstByte & 0x0f) | (BYTE)(pixIn.ul << 4);

        *pjDst = DstByte;
    }
}


/**************************************************************************\
* vConvertAndSaveBGRATo8
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRATo8(
    PBYTE       pDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    XLATEOBJ    *pxlo,
    XEPALOBJ    ppalDst,
    XEPALOBJ    ppalDstDC
    )
{
    PBYTE pxlate = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate == NULL)
    {
        WARNING("vConvertAndSaveBGRATo8: Failed to generate rgb333 xlate table\n");
        return;
    }

    PBYTE pjDst = (PBYTE)pDst + DstX;
    PBYTE pjEnd = pjDst + cx;

    while (pjDst != pjEnd)
    {
        ALPHAPIX  pixIn;

    pixIn.ul = *pulSrc;
    
    pixIn.ul = XLATEOBJ_BGR32ToPalSurf(pxlo,pxlate,pixIn.ul);

    *pjDst = (BYTE)pixIn.ul;

        pulSrc++;
        pjDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToRGB16_565
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB16_565(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    XLATEOBJ    *pxlo,
    XEPALOBJ    ppalDst,
    XEPALOBJ    ppalDstDC
    )
{
    PUSHORT pusDst = (PUSHORT)pjDst + DstX;
    PUSHORT pusEnd = pusDst + cx;

    while (pusDst != pusEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

    pixIn.ul = *pulSrc;
    
    pixOut.ul =    ((pixIn.pix.r & 0xf8) << 8) |
               ((pixIn.pix.g & 0xfc) << 3) |
                       ((pixIn.pix.b & 0xf8) >> 3);


    *pusDst = (USHORT)pixOut.ul;

        pulSrc++;
        pusDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToRGB16_555
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB16_555(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    XLATEOBJ    *pxlo,
    XEPALOBJ    ppalDst,
    XEPALOBJ    ppalDstDC
    )
{
    PUSHORT pusDst = (PUSHORT)pjDst + DstX;
    PUSHORT pusEnd = pusDst + cx;

    while (pusDst != pusEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

    pixIn.ul = *pulSrc;

    pixOut.ul =    ((pixIn.pix.r & 0xf8) << 7) |
                       ((pixIn.pix.g & 0xf8) << 2) |
                       ((pixIn.pix.b & 0xf8) >> 3);

    *pusDst = (USHORT)pixOut.ul;
        
    pulSrc++;
        pusDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRATo16Bitfields
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB16Bitfields(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    XLATEOBJ    *pxlo,
    XEPALOBJ    ppalDst,
    XEPALOBJ    ppalDstDC
    )
{
    PUSHORT pusDst = (PUSHORT)pjDst + DstX;
    PUSHORT pusEnd = pusDst + cx;

    while (pusDst != pusEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

    pixIn.ul = *pulSrc;

    pixOut.ul = (((XLATE *)pxlo)->ulTranslate(pixIn.ul));

    *pusDst = (USHORT)pixOut.ul;
        
    pulSrc++;
        pusDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToRGB24
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB24(
    PBYTE       pDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    XLATEOBJ    *pxlo,
    XEPALOBJ    ppalDst,
    XEPALOBJ    ppalDstDC
    )
{
    PBYTE pjDst = (PBYTE)pDst + (3 * DstX);
    PBYTE pjEnd = pjDst + (3 * cx);

    while (pjDst != pjEnd)
    {
        ALPHAPIX  pixIn;

    pixIn.ul = *pulSrc;

    *pjDst     = pixIn.pix.r;
    *(pjDst+1) = pixIn.pix.g;
    *(pjDst+2) = pixIn.pix.b;
        
    pulSrc++;
        pjDst+=3;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToBGR24
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    5/4/2000 bhouse
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToBGR24(
    PBYTE       pDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    XLATEOBJ    *pxlo,
    XEPALOBJ    ppalDst,
    XEPALOBJ    ppalDstDC
    )
{
    PBYTE pjDst = (PBYTE)pDst + (3 * DstX);
    PBYTE pjEnd = pjDst + (3 * cx);

    while (pjDst != pjEnd)
    {
        ALPHAPIX  pixIn;

    pixIn.ul = *pulSrc;

    *pjDst     = pixIn.pix.b;
    *(pjDst+1) = pixIn.pix.g;
    *(pjDst+2) = pixIn.pix.r;
        
    pulSrc++;
        pjDst+=3;
    }
}


/**************************************************************************\
* vConvertAndSaveBGRATo32Bitfields
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRATo32Bitfields(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    XLATEOBJ    *pxlo,
    XEPALOBJ    ppalDst,
    XEPALOBJ    ppalDstDC
    )
{
    PULONG pulDst = (PULONG)pjDst + DstX;
    PULONG pulEnd = pulDst + cx;
    while (pulDst != pulEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

    pixIn.ul = *pulSrc;

    pixOut.ul = (((XLATE *)pxlo)->ulTranslate(pixIn.ul));

    *pulDst = pixOut.ul;
        
    pulSrc++;
        pulDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToRGB32
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB32(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    XLATEOBJ    *pxlo,
    XEPALOBJ    ppalDst,
    XEPALOBJ    ppalDstDC
    )
{
    PULONG pulDst = (PULONG)pjDst + DstX;
    PULONG pulEnd = pulDst + cx;
    while (pulDst != pulEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

    pixIn.ul = *pulSrc;

    pixOut.pix.r = pixIn.pix.b;
    pixOut.pix.g = pixIn.pix.g;
    pixOut.pix.b = pixIn.pix.r;
    pixOut.pix.a = 0;

    *pulDst = pixOut.ul;

        pulSrc++;
        pulDst++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\alphaimg.cxx ===
/******************************Module*Header*******************************\
* Module Name: alphaimg.cxx
*
* Low level alpha blending routines
*
* Created: 21-Jun-1996
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1996-1999 Microsoft Corporation
\**************************************************************************/
#include "precomp.hxx"

                
/**************************************************************************\
* Explanation of algorithm for AlphaPerPixelOnly routines
* -------------------------------------------------------
*
* The inner loop of each routine computes:
* 
*   Dst = Alpha * Src + (1-Alpha) * Dst
*
*
* The source pixel is assumed to have been premultiplied
* with the alpha value, which leaves this:
*
*   Dst = Src + (1-Alpha) * Dst
*
*
* Because the alpha is stored as a byte, we must actually compute
*
*   Dst = Src + (255-SrcAlpha) * Dst / 255
*
*
* A close approximation to 1/255 is 257/65536; we use this to replace
* the divide with shifts and adds. That is, X/255 becomes:
*
*   ((X<<8) + X) >> 16
*
* or:
*
*   (X + (X>>8)) >> 8
*
*
* We improve the accuracy of this approximation by adding a rounding
* step after the multiply. 
*
* In particular, this gives exact results
* where SrcAlpha is 0 or 255, important for versions of the routine
* which do not special case those values (such as mmxAlphaPerPixelOnly).
*
* The resulting algorithm is:
*
*   T1  = Dst * (255 - SrcAlpha) + 128
*   T2  = T1 >> 8
*   T3  = (T1 + T2) >> 8;
*   Dst = Src + T2
*
* Finally, the above must be done to each of the 4 components of the pixel.
* Most versions of the routine do 2 components in a single
* DWORD. The algorithm is therefore done twice per pixel, 
* once for each set of 2 components, and the two iterations are interleaved.
*
\**************************************************************************/

/**************************************************************************\
* vAlphaPerPixelOnly
*   
*   Used when the source has per-pixel alpha values and the
*   SourceConstantAlpha is 255.
*
*       Dst = Src + (1-SrcAlpha) * Dst
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*
* Return Value:
*
*   none
*
* History:
*
*    1/23/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#if !defined(_X86_)

VOID
vAlphaPerPixelOnly(
    ALPHAPIX       *ppixDst,
    ALPHAPIX       *ppixSrc,
    LONG           cx,
    BLENDFUNCTION  BlendFunction
    )
{
    ALPHAPIX pixSrc;
    ALPHAPIX pixDst;
    BYTE     alpha;

    while (cx--)
    {
        pixSrc = *ppixSrc;
	alpha = pixSrc.pix.a;

        if (alpha != 0)
        {
            pixDst = *ppixDst;

            if (alpha == 255)
            {
                pixDst = pixSrc;
            }
            else
            {
                //
                // Dst = Src + (1-Alpha) * Dst
                //

                ULONG Multa = 255 - alpha;
                ULONG _D1_00AA00GG = (pixDst.ul & 0xff00ff00) >> 8;
                ULONG _D1_00RR00BB = (pixDst.ul & 0x00ff00ff);
                
                ULONG _D2_AAAAGGGG = _D1_00AA00GG * Multa + 0x00800080;
                ULONG _D2_RRRRBBBB = _D1_00RR00BB * Multa + 0x00800080;
                
                ULONG _D3_00AA00GG = (_D2_AAAAGGGG & 0xff00ff00) >> 8;
                ULONG _D3_00RR00BB = (_D2_RRRRBBBB & 0xff00ff00) >> 8;
                
                
                ULONG _D4_AA00GG00 = (_D2_AAAAGGGG + _D3_00AA00GG) & 0xFF00FF00;
                ULONG _D4_00RR00BB = ((_D2_RRRRBBBB + _D3_00RR00BB) & 0xFF00FF00) >> 8;
                
                pixDst.ul = pixSrc.ul + _D4_AA00GG00 + _D4_00RR00BB;
            }

            *ppixDst = pixDst;
        }

        ppixSrc++;
        ppixDst++;
    }
}

#endif

/**************************************************************************\
* vAlphaPerPixelAndConst
*   
*   Used when the source has per-pixel alpha values and the
*   SourceConstantAlpha is not 255.
*
*       if SrcAlpha == 255 then
*
*           Dst = Dst + ConstAlpha * (Src - Dst)
*
*       else
*
*           Src = Src * ConstAlpha
*           Dst = Src + (1 - SrcAlpha) Dst       
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*
* Return Value:
*
*   None
*
* History:
*
*    3/12/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vAlphaPerPixelAndConst(
    ALPHAPIX       *ppixDst,
    ALPHAPIX       *ppixSrc,
    LONG           cx,
    BLENDFUNCTION  BlendFunction
    )
{
    ALPHAPIX pixSrc;
    ALPHAPIX pixDst;
    BYTE     ConstAlpha = BlendFunction.SourceConstantAlpha;
    BYTE     alpha; 

    while (cx--)
    {
        pixSrc = *ppixSrc;
	alpha = pixSrc.pix.a;

        if (alpha != 0)
        {
            pixDst = *ppixDst;

            if (alpha == 255)
            {
                //
                // Blend: D = sA * S + (1-sA) * D
                //
                // red and blue
                //
        
                ULONG uB00rr00bb = pixDst.ul & 0x00ff00ff;
                ULONG uF00rr00bb = pixSrc.ul & 0x00ff00ff;
        
                ULONG uMrrrrbbbb = ((uB00rr00bb<<8)-uB00rr00bb) + 
                                   (ConstAlpha * (uF00rr00bb - uB00rr00bb)) + 0x00800080;
        
                ULONG uM00rr00bb = (uMrrrrbbbb & 0xff00ff00) >> 8;
        
                ULONG uD00rr00bb = ((uMrrrrbbbb+uM00rr00bb) & 0xff00ff00)>>8;
        
                //
                // alpha and green
                //
        
                ULONG uB00aa00gg = (pixDst.ul >> 8) & 0xff00ff;
                ULONG uF00aa00gg = (pixSrc.ul >> 8) & 0xff00ff;
        
                ULONG uMaaaagggg = ((uB00aa00gg <<8)-uB00aa00gg) +
                                   (ConstAlpha * (uF00aa00gg-uB00aa00gg)) + 0x00800080;
        
                ULONG uM00aa00gg = (uMaaaagggg & 0xff00ff00)>>8;
        
                ULONG uDaa00gg00 = (uMaaaagggg + uM00aa00gg) & 0xff00ff00;
        
                pixDst.ul  = uD00rr00bb + uDaa00gg00;
            }
            else
            {
                //
                // disolve
                //

                ULONG ul_B_00AA00GG = (pixSrc.ul & 0xff00ff00) >> 8;
                ULONG ul_B_00RR00BB = (pixSrc.ul & 0x00ff00ff);
        
                ULONG ul_T_AAAAGGGG = ul_B_00AA00GG * ConstAlpha + 0x00800080;
                ULONG ul_T_RRRRBBBB = ul_B_00RR00BB * ConstAlpha + 0x00800080;
        
                ULONG ul_T_00AA00GG = (ul_T_AAAAGGGG & 0xFF00FF00) >> 8;
                ULONG ul_T_00RR00BB = (ul_T_RRRRBBBB & 0xFF00FF00) >> 8;
        
                ULONG ul_C_AA00GG00 = ((ul_T_AAAAGGGG + ul_T_00AA00GG) & 0xFF00FF00);
                ULONG ul_C_00RR00BB = ((ul_T_RRRRBBBB + ul_T_00RR00BB) & 0xFF00FF00) >> 8;
        
                pixSrc.ul = (ul_C_AA00GG00 | ul_C_00RR00BB);

                //
                // over
                //


                ULONG Multa = 255 - pixSrc.pix.a;
                ULONG _D1_00AA00GG = (pixDst.ul & 0xff00ff00) >> 8;
                ULONG _D1_00RR00BB = (pixDst.ul & 0x00ff00ff);

                ULONG _D2_AAAAGGGG = _D1_00AA00GG * Multa + 0x00800080;
                ULONG _D2_RRRRBBBB = _D1_00RR00BB * Multa + 0x00800080;

                ULONG _D3_00AA00GG = (_D2_AAAAGGGG & 0xff00ff00) >> 8;
                ULONG _D3_00RR00BB = (_D2_RRRRBBBB & 0xff00ff00) >> 8;


                ULONG _D4_AA00GG00 = (_D2_AAAAGGGG + _D3_00AA00GG) & 0xFF00FF00;
                ULONG _D4_00RR00BB = ((_D2_RRRRBBBB + _D3_00RR00BB) & 0xFF00FF00) >> 8;

                pixDst.ul = pixSrc.ul + _D4_AA00GG00 + _D4_00RR00BB;
            }

            *ppixDst = pixDst;
        }
        
	ppixSrc++;
        ppixDst++;
    }
}

/******************************Public*Routine******************************\
* vAlphaConstOnly
*   
*   Used when the source does not have per-pixel alpha values,
*   and SourceConstantAlpha is not 255.
*
*           Dst = Dst + ConstAlpha * (Src - Dst)
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*
* Return Value:
*   
*   None
*
* History:
*
*    12/2/1996 Mark Enstrom [marke]
*
\**************************************************************************/
#if !defined (_X86_)

VOID
vAlphaConstOnly(
    ALPHAPIX       *ppixDst,
    ALPHAPIX       *ppixSrc,
    LONG           cx,
    BLENDFUNCTION  BlendFunction
    )
{
    PULONG   pulSrc = (PULONG)ppixSrc;
    PULONG   pulDst = (PULONG)ppixDst;
    PULONG   pulSrcEnd = pulSrc + cx;
    BYTE     ConstAlpha = BlendFunction.SourceConstantAlpha;

    //
    // Blend: D = sA * S + (1-sA) * D
    //

    while (pulSrc != pulSrcEnd)
    {
        ULONG ulDst = *pulDst;
        ULONG ulSrc = *pulSrc;
        ULONG uB00rr00bb = ulDst & 0x00ff00ff;
        ULONG uF00rr00bb = ulSrc & 0x00ff00ff;

        ULONG uMrrrrbbbb; 
        ULONG uM00rr00bb; 
        ULONG uD00rr00bb; 
        ULONG uB00aa00gg;
        ULONG uF00aa00gg;
        ULONG uMaaaagggg;
        ULONG uM00aa00gg;
        ULONG uDaa00gg00;

        //
        // red and blue
        //

        uB00rr00bb = ulDst & 0x00ff00ff;
        uF00rr00bb = ulSrc & 0x00ff00ff;

        uMrrrrbbbb = ((uB00rr00bb<<8)-uB00rr00bb) + 
                     (ConstAlpha * (uF00rr00bb - uB00rr00bb)) + 0x00800080;

        uM00rr00bb = (uMrrrrbbbb & 0xff00ff00) >> 8;

        uD00rr00bb = ((uMrrrrbbbb+uM00rr00bb) & 0xff00ff00)>>8;

        //
        // alpha and green
        //

        uB00aa00gg = (ulDst >> 8) & 0xff00ff;
        uF00aa00gg = (ulSrc >> 8) & 0xff00ff;

        uMaaaagggg = ((uB00aa00gg <<8)-uB00aa00gg) +
                     (ConstAlpha * (uF00aa00gg-uB00aa00gg)) + 0x00800080;

        uM00aa00gg = (uMaaaagggg & 0xff00ff00)>>8;

        uDaa00gg00 = (uMaaaagggg + uM00aa00gg) & 0xff00ff00;

        *pulDst = uD00rr00bb + uDaa00gg00;

        pulSrc++;
        pulDst++;
    }
}

/**************************************************************************\
* vAlphaConstOnly16_555
*
*   Optimized version of vAlphaConstOnly used when source and destination
*   are both 16_555.
*
*           Dst = Dst + ConstAlpha * (Src - Dst)
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*
* Return Value:
*   
*   None
*
* History:
*
*    12/2/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vAlphaConstOnly16_555(
    ALPHAPIX       *ppixDst,
    ALPHAPIX       *ppixSrc,
    LONG           cx,
    BLENDFUNCTION  BlendFunction
    )
{
    PUSHORT  pusSrc = (PUSHORT)ppixSrc;
    PUSHORT  pusDst = (PUSHORT)ppixDst;
    PUSHORT  pusSrcEnd = pusSrc + cx;
    BYTE     ConstAlpha = BlendFunction.SourceConstantAlpha;

    //
    // Blend: D = sA * S + (1-sA) * D
    //

    while (pusSrc != pusSrcEnd)
    {
        USHORT usDst = *pusDst;
        USHORT usSrc = *pusSrc;

        ULONG uB00rr00bb;
        ULONG uF00rr00bb;
        ULONG uMrrrrbbbb; 
        ULONG uM00rr00bb; 
        ULONG uDrrxxbbxx; 
        ULONG uB000000gg;
        ULONG uF000000gg;
        ULONG uM0000gggg;
        ULONG uM000000gg;
        ULONG uD0000ggxx;

        //
        // red and blue
        //

        uB00rr00bb = (usDst & 0x7c1f); // uB 0rrr rr00 000b bbbb
        uF00rr00bb = (usSrc & 0x7c1f); // uS 0rrr rr00 000b bbbb

        uMrrrrbbbb = ((uB00rr00bb<<5)-uB00rr00bb) + 
                     (ConstAlpha * (uF00rr00bb - uB00rr00bb)) + 0x00004010;

        uM00rr00bb = (uMrrrrbbbb & 0x000F83E0) >> 5;

        uDrrxxbbxx = ((uMrrrrbbbb+uM00rr00bb) >> 5) &  0x7c1f;

        //
        // green
        //

        uB000000gg = (usDst & 0x3e0) >> 5;
        uF000000gg = (usSrc & 0x3e0) >> 5;

        uM0000gggg = ((uB000000gg <<5)-uB000000gg) +
                     (ConstAlpha * (uF000000gg-uB000000gg)) + 0x00000010;

        uM000000gg = (uM0000gggg & 0x000003E0)>>5;

        uD0000ggxx = (uM0000gggg + uM000000gg) & 0x03E0;

        *pusDst = (USHORT)(uDrrxxbbxx  |  uD0000ggxx);

        pusSrc++;
        pusDst++;
    }
}

/**************************************************************************\
* vAlphaConstOnly16_565
*
*   Optimized version of vAlphaConstOnly used when source and destination
*   are both 16_565.
*
*           Dst = Dst + ConstAlpha * (Src - Dst)
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*
* Return Value:
*   
*   None
*
* History:
*
*    12/2/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vAlphaConstOnly16_565(
    ALPHAPIX       *ppixDst,
    ALPHAPIX       *ppixSrc,
    LONG           cx,
    BLENDFUNCTION  BlendFunction
    )
{
    PUSHORT  pusSrc = (PUSHORT)ppixSrc;
    PUSHORT  pusDst = (PUSHORT)ppixDst;
    PUSHORT  pusSrcEnd = pusSrc + cx;
    BYTE     ConstAlpha = BlendFunction.SourceConstantAlpha;

    //
    // Blend: D = sA * S + (1-sA) * D
    //

    while (pusSrc != pusSrcEnd)
    {
        USHORT usDst = *pusDst;
        USHORT usSrc = *pusSrc;

        ULONG uB00rr00bb;
        ULONG uF00rr00bb;
        ULONG uMrrrrbbbb; 
        ULONG uM00rr00bb; 
        ULONG uDrrxxbbxx; 
        ULONG uB000000gg;
        ULONG uF000000gg;
        ULONG uM0000gggg;
        ULONG uM000000gg;
        ULONG uD0000ggxx;

        //
        // red and blue
        //

        uB00rr00bb = (usDst & 0xf81f); // uB 0rrr rr00 000b bbbb
        uF00rr00bb = (usSrc & 0xf81f); // uS 0rrr rr00 000b bbbb

        uMrrrrbbbb = ((uB00rr00bb<<5)-uB00rr00bb) + 
                     (ConstAlpha * (uF00rr00bb - uB00rr00bb)) + 0x00008010;

        uM00rr00bb = (uMrrrrbbbb & 0x001F03E0) >> 5;

        uDrrxxbbxx = ((uMrrrrbbbb+uM00rr00bb) >> 5) &  0xf81f;

        //
        // green
        //

        uB000000gg = (usDst & 0x7e0) >> 5;
        uF000000gg = (usSrc & 0x7e0) >> 5;

        uM0000gggg = ((uB000000gg <<6)-uB000000gg) +
                     (2 * ConstAlpha * (uF000000gg-uB000000gg)) + 0x00000020;

        uM000000gg = (uM0000gggg & 0x00000fc0)>>6;

        uD0000ggxx = ((uM0000gggg + uM000000gg) & 0x0fc0) >> 1;

        *pusDst = (USHORT)(uDrrxxbbxx  |  uD0000ggxx);

        pusSrc++;
        pusDst++;
    }
}

#endif

/******************************Public*Routine******************************\
* vAlphaConstOnly24
*   
*   Optimized version of vAlphaConstOnly used when source and destination
*   are both 24bpp.
*
* Arguments:
*   
*   pixDst,      
*   pixSrc,      
*   cx,          
*   BlendFunction
*
* Return Value:
*
*
*
* History:
*
*    12/2/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vAlphaConstOnly24(
    ALPHAPIX     *ppixDst,
    ALPHAPIX     *ppixSrc,
    LONG          cx,
    BLENDFUNCTION BlendFunction
    )
{
    BYTE    ConstAlpha = BlendFunction.SourceConstantAlpha;
    PBYTE   pjSrc      = (PBYTE)ppixSrc;
    PBYTE   pjDst      = (PBYTE)ppixDst;
    PBYTE   pjSrcEnd   = pjSrc + 3*cx;

    while (pjSrc != pjSrcEnd)
    {
        ULONG ulDst = (*pjDst) << 16;
        ULONG ulSrc = (*pjSrc) << 16;

        ULONG uB00rr00bb;
        ULONG uF00rr00bb;
        ULONG uMrrrrbbbb; 
        ULONG uM00rr00bb; 
        ULONG uD00rr00bb; 
        ULONG uB000000gg;
        ULONG uF000000gg;
        ULONG uM0000gggg;
        ULONG uM000000gg;
        ULONG uD000000gg;

        //
        // red and blue
        //

        uB00rr00bb = uB00rr00bb = ulDst | (*(pjDst+1)); 
        uF00rr00bb = uF00rr00bb = ulSrc | (*(pjSrc+1)); 

        uMrrrrbbbb = ((uB00rr00bb<<8)-uB00rr00bb) + 
                     (ConstAlpha * (uF00rr00bb - uB00rr00bb)) + 0x00800080;

        uM00rr00bb = (uMrrrrbbbb & 0xff00ff00) >> 8;

        uD00rr00bb = ((uMrrrrbbbb+uM00rr00bb) & 0xff00ff00)>>8;

        //
        // green
        //

        uB000000gg = *(pjDst+2);
        uF000000gg = *(pjSrc+2);

        uM0000gggg = ((uB000000gg <<8)-uB000000gg) +
                     (ConstAlpha * (uF000000gg-uB000000gg)) + 0x00000080;

        uM000000gg = (uM0000gggg & 0x0000ff00)>>8;

        uD000000gg = ((uM0000gggg + uM000000gg) & 0x0000ff00) >> 8;

        *pjDst     = (BYTE)(uD00rr00bb >> 16);
        *(pjDst+1) = (BYTE)(uD00rr00bb);
        *(pjDst+2) = (BYTE)(uD000000gg);

        pjSrc+=3;
        pjDst+=3;
    }
}



/******************************Public*Routine******************************\
* AlphaScanLineBlend
*
*   Blends source and destionation surfaces one scan line at a time. 
*
*   Allocate a scan line buffer for xlate of src to 32BGRA if needed.
*   Allocate a scan line buffer for xlate of dst to 32BGRA if needed.
*   Blend scan line using blend function from pAlphaDispatch
*   Write scan line back to dst (if needed)
*      
* Arguments:
*   
*   pDst           - pointer to dst surface       
*   pDstRect       - Dst output rect
*   DeltaDst       - dst scan line delat
*   pSrc           - pointer to src surface
*   DeltaSrc       - src scan line delta      
*   pptlSrc        - src offset
*   pxloSrcTo32    - xlateobj from src to 32BGR
*   pxlo32ToDst    - xlateobj from 32BGR to dst
*   palDst         - destination palette
*   palSrc         - source palette
*   pAlphaDispatch - blend data and function pointers
*
* Return Value:
*
*   Status
*
* History:
*
*    10/14/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
AlphaScanLineBlend(
    PBYTE                    pDst,                   
    PRECTL                   pDstRect,               
    LONG                     DeltaDst,               
    PBYTE                    pSrc,                   
    LONG                     DeltaSrc,               
    PPOINTL                  pptlSrc,                
    XLATEOBJ                *pxloSrcTo32,                   
    XLATEOBJ                *pxloDstTo32,                   
    XLATEOBJ                *pxlo32ToDst,
    XEPALOBJ                 palDst,                 
    XEPALOBJ                 palSrc,                 
    PALPHA_DISPATCH_FORMAT   pAlphaDispatch
    )
{
    //
    // get two scanlines of RGBA data, blend pixels, store
    //

    LONG     cx = pDstRect->right - pDstRect->left;
    LONG     cy = pDstRect->bottom - pDstRect->top;
    LONG     ScanBufferWidth = cx * 4;
    LONG     AllocationSize = 0;
    LONG     lSrcBytesPerPixel = pAlphaDispatch->ulSrcBitsPerPixel/8;
    LONG     lDstBytesPerPixel = pAlphaDispatch->ulDstBitsPerPixel/8;
    PBYTE    pjSrcTempScanBuffer = NULL;
    PBYTE    pjDstTempScanBuffer = NULL;
    PBYTE    pjAlloc = NULL;
    PBYTE    pjDstTmp;
    PBYTE    pjSrcTmp;
    XEPALOBJ palDstDC = (XEPALOBJ)((XLATE *) pxlo32ToDst)->ppalDstDC;

    //
    // calculate destination starting address
    //
        
    if (lDstBytesPerPixel)
    {
        pjDstTmp = pDst + lDstBytesPerPixel * pDstRect->left + DeltaDst * pDstRect->top;
    }
    else if (pAlphaDispatch->ulDstBitsPerPixel == 1)
    {
        pjDstTmp = pDst + pDstRect->left/8 + DeltaDst * pDstRect->top;
    }
    else
    {
        pjDstTmp = pDst + pDstRect->left/2 + DeltaDst * pDstRect->top;
    }

    //
    // calculate source starting address
    //

    if (lSrcBytesPerPixel)
    {
        pjSrcTmp = pSrc + lSrcBytesPerPixel * pptlSrc->x + DeltaSrc * pptlSrc->y;
    }
    else if (pAlphaDispatch->ulSrcBitsPerPixel == 1)
    {
        pjSrcTmp = pSrc + pptlSrc->x/8 + DeltaSrc * pptlSrc->y;
    }
    else
    {
        pjSrcTmp = pSrc + pptlSrc->x/2 + DeltaSrc * pptlSrc->y;
    }

    //
    // calculate size of needed scan line buffer
    //

    if (pAlphaDispatch->pfnLoadDstAndConvert != NULL)
    {
        AllocationSize += ScanBufferWidth;
    }

    if (pAlphaDispatch->pfnLoadSrcAndConvert != NULL)
    {
        AllocationSize += ScanBufferWidth;
    }

    //
    // allocate scan line buffer memory
    //

    if (AllocationSize) {
       pjAlloc = (PBYTE)PALLOCMEM(AllocationSize,'plaG');

       if (pjAlloc == NULL)
       {
	  return(FALSE);
       }
    }

    PBYTE pjTemp = pjAlloc;

    if (pAlphaDispatch->pfnLoadSrcAndConvert != NULL)
    {
        pjSrcTempScanBuffer = pjTemp;
        pjTemp += ScanBufferWidth;
    }

    if (pAlphaDispatch->pfnLoadDstAndConvert != NULL)
    {
        pjDstTempScanBuffer = pjTemp;
        pjTemp += ScanBufferWidth;
    }

    //
    // Blend scan lines
    //

    while (cy--)
    {
        PBYTE pjSource = pjSrcTmp;
        PBYTE pjDest   = pjDstTmp;

        //
        // get src scan line if needed
        //

        if (pjSrcTempScanBuffer)
        {
            (*pAlphaDispatch->pfnLoadSrcAndConvert)(
                                (PULONG)pjSrcTempScanBuffer,
                                pjSrcTmp,
                                0,
                                cx,
                                pxloSrcTo32
                                );


            pjSource = pjSrcTempScanBuffer;
        }

        //
        // get dst scan line if needed
        //

        if (pjDstTempScanBuffer)
        {
            (*pAlphaDispatch->pfnLoadDstAndConvert)(
                                (PULONG)pjDstTempScanBuffer,
                                pjDstTmp,
                                0,
                                cx,
                                pxloDstTo32
                                );

            pjDest = pjDstTempScanBuffer;
        }

        //
        // blend
        //

        (*pAlphaDispatch->pfnGeneralBlend)(
                               (PALPHAPIX)pjDest,
                               (PALPHAPIX)pjSource,
                               cx,
                               pAlphaDispatch->BlendFunction);

        //
        // write buffer back if needed
        //

        if (pjDstTempScanBuffer)
        {
            (*pAlphaDispatch->pfnConvertAndStore)(
                                pjDstTmp,
                                (PULONG)pjDstTempScanBuffer,
                                cx,
                                0,
                                pxlo32ToDst,
                                palDst,
                                palDstDC);
        }

        pjDstTmp += DeltaDst;
        pjSrcTmp += DeltaSrc;
    }

    //
    // free scan line buffer memory
    //

    if (AllocationSize) VFREEMEM(pjAlloc);

    return(TRUE);
}

#if defined(_X86_)

//
// MMX assembly code from intel
//

typedef unsigned __int64 QWORD;

/**************************************************************************\
* mmxAlphaPerPixelOnly
*   
*   Used when the source has per-pixel alpha values and the
*   SourceConstantAlpha is 255.
*
*       Dst = Src + (1-SrcAlpha) * Dst
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*
* Return Value:
*
*   none
*
* History:
*
*    3/12/1997 Mark Enstrom [marke]
*
\**************************************************************************/

/**************************************************************************
  THIS FUNCTION DOES NOT DO ANY PARAMETER VALIDATION
  DO NOT CALL THIS FUNCTION WITH WIDTH == 0

  This function operates on 32 bit pixels (BGRA) in a row of a bitmap.
  This function performs the following:

  		SrcTran = 255 - pixSrc.a
		pixDst.r = pixSrc.r + (((SrcTran * pixDst.r)+127)/255);
		pixDst.g = pixSrc.g + (((SrcTran * pixDst.g)+127)/255);
		pixDst.b = pixSrc.b + (((SrcTran * pixDst.b)+127)/255);
		pixDst.a = pixSrc.a + (((SrcTran * pixDst.a)+127)/255);

  pDst is assumed to be aligned to a DWORD boundary when passed to this function.
  Step 1:
	Check pDst for QWORD alignment.  If aligned, do Step 2.  If unaligned, do first pixel
	as a DWORD, then do Step 2.
  Step 2:
	QuadAligned
	pDst is QWORD aligned.  If two pixels can be done as a QWORD, do Step 3.  If only one
	pixel left, do as a DWORD.
  Step 3:
	Load two source pixels, S1 and S2.  Get (255 - alpha value) for each source pixel, 255-S1a and 255-S2a.
	Copy 255-S1a as four words into an MMX register.  Copy 255-S2a as four words into an MMX register.
	Load two destination pixels, D1 and D2.  Expand each byte in D1 into four words
	of an MMX register.  If at least four pixels can be done, do Step 4.  If not, jump over
	FourPixelsPerPass and finish doing two pixels at TwoPixelsLeft, Step 5.
  Step 4:
	FourPixelsPerPass
	Expand each byte in D2 into four words of an MMX register.  Multiply each byte
	of D1 by 255-S1a.  Multiply each byte of D2 by 255-S2a.  Add 128 to each intermediate result
	of both pixels.  Copy the results of each pixel into an MMX register.  Shift each result of
	both pixels by 8.  Add the shifted results to the copied results.  Shift these results by 8.
	Pack the results into one MMX register.  Add the packed results to the source pixels.  Store result
	over destination pixels.  Stay in FourPixelsPerPass loop until there are less than four pixels to do.
  Step 5:
    TwoPixelsLeft
	Do same as Step 4 above; but do not loop.
  Step 6:
	OnePixelLeft
	If there is one pixel left (odd number of original pixels) do last pixel as a DWORD.
**************************************************************************/
VOID
mmxAlphaPerPixelOnly(
    ALPHAPIX       *pDst,
    ALPHAPIX       *pSrc,
	LONG			Width,
	BLENDFUNCTION	BlendFunction)
{
	static QWORD W128 = 0x0080008000800080;
	static QWORD AlphaMask = 0x000000FF000000FF;

	_asm
	{
        mov			esi, pSrc
        mov			edi, pDst
    
        movq		mm7, W128		// |  0  | 128 |  0  | 128 |  0  | 128 |  0  | 128 |
                                    //	This register never changes
        pxor		mm6, mm6		// |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
                                    //	This register never changes
    
        mov			ecx, Width
                                    // Step 1:
        test		edi, 7			// Test first pixel for QWORD alignment
        jz			QuadAligned		// if unaligned,
    
        jmp			Do1Pixel		// do first pixel only
    
    QuadAligned:					// Step 2:
        mov			eax, ecx		// Save the width in eax for later (see OnePixelLeft:)
        shr			ecx, 1			// Want to do 2 pixels (1 quad) at once, so make ecx even
        test		ecx, ecx		// Make sure there is at least 1 quad to do
        jz			OnePixelLeft	// If we take this jump, width was 1 (aligned) or 2 (unaligned)
    
                                    // Step 3:
        movq		mm0, [esi]		// | S2a | S2r | S2g | S2b | S1a | S1r | S1g | S1b |
        psrld		mm0, 24			// |  0  |  0  | 0 |  S2a  |  0  |  0  | 0 |  S1a  |
        pxor		mm0, AlphaMask	// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
        movq		mm1, mm0		// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
    
        punpcklwd	mm0, mm0		// |     0	   |     0	   |  255-S1a  |  255-S1a  |
        movq		mm2, [edi]		// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
        punpckhwd	mm1, mm1		// |     0	   |     0	   |  255-S2a  |  255-S2a  |
        movq		mm3, mm2		// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
    
        punpckldq	mm0, mm0		// |  255-S1a  |  255-S1a  |  255-S1a  |  255-S1a  |
        punpckldq	mm1, mm1		// |  255-S2a  |  255-S2a  |  255-S2a  |  255-S2a  |
        punpcklbw	mm2, mm6		// |  0  | D1a |  0  | D1r |  0  | D1g |  0  | D1b |
    
        dec			ecx
        jz			TwoPixelsLeft
    
    FourPixelsPerPass:				// Step 4:
        // Indenting indicates operations on the next set of pixels
        // Within this loop, instructions will pair as shown for the Pentium processor
                                    //	T1 = 255-S1a	T2 = 255-S2a
        punpckhbw	mm3, mm6		// |  0  | D2a |  0  | D2r |  0  | D2g |  0  | D2b |
        pmullw		mm2, mm0		// |   T1*D1a  |   T1*D1r  |   T1*D1g  |   T1*D1b  |
    
        movq		mm0, [esi+8]	// | S2a | S2r | S2g | S2b | S1a | S1r | S1g | S1b |
        pmullw		mm3, mm1		// |   T2*D2a  |   T2*D2r  |   T2*D2g  |   T2*D2b  |
    
        psrld		mm0, 24			// |  0  |  0  | 0 |  S2a  |  0  |  0  | 0 |  S1a  |
        add			esi, 8			// pSrc++;
    
        pxor		mm0, AlphaMask	// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
        paddusw		mm2, mm7		// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
    
        paddusw		mm3, mm7		// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
        movq		mm1, mm0		// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
    
        movq		mm4, mm2		// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
        punpcklwd	mm0, mm0		// |     0	   |     0	   |  255-S1a  |  255-S1a  |
    
        movq		mm5, mm3		// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
        punpckhwd	mm1, mm1		// |     0	   |     0	   |  255-S2a  |  255-S2a  |
                                    //	TDXx' = TX*DXx+128
        psrlw		mm2, 8			// |  TD1a'>>8 |  TD1r'>>8 |  TD1g'>>8 |  TD1b'>>8 |
    
                                    //  TDXx" = (TX*DXx+128)+(TDXx'>>8)
        psrlw		mm3, 8			// |  TD2a'>>8 |  TD2r'>>8 |  TD2g'>>8 |  TD2b'>>8 |
        paddusw		mm4, mm2		// |  TD1a"    |  TD1r"    |  TD1g"    |  TD1b"    |
    
        paddusw		mm5, mm3		// |  TD2a"    |  TD2r"    |  TD2g"    |  TD2b"    |
        psrlw		mm4, 8			// |  TD1a">>8 |  TD1r">>8 |  TD1g">>8 |  TD1b">>8 |
    
        movq		mm2, [edi+8]	// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
        psrlw		mm5, 8			// |  TD2a">>8 |  TD2r">>8 |  TD2g">>8 |  TD2b">>8 |
    
        movq		mm3, mm2		// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
        packuswb	mm4, mm5		// |TD2a'"|TD2r'"|TD2g'"|TD2b'"|TD1a'"|TD1r'"|TD1g'"|TD1b'"|  
    
        paddusb		mm4, [esi-8]
        punpckldq	mm0, mm0		// |  255-S1a  |  255-S1a  |  255-S1a  |  255-S1a  |
    
        movq		[edi], mm4
        punpckldq	mm1, mm1		// |  255-S2a  |  255-S2a  |  255-S2a  |  255-S2a  |
    
        punpcklbw	mm2, mm6		// |  0  | D1a |  0  | D1r |  0  | D1g |  0  | D1b |
        add			edi, 8			//	pDst++;
        
        dec			ecx
        jnz			FourPixelsPerPass
    
    TwoPixelsLeft:					// Step 5:
        punpckhbw	mm3, mm6		// |  0  | D2a |  0  | D2r |  0  | D2g |  0  | D2b |
        pmullw		mm2, mm0		// |   T1*D1a  |   T1*D1r  |   T1*D1g  |   T1*D1b  |
        pmullw		mm3, mm1		// |   T2*D2a  |   T2*D2r  |   T2*D2g  |   T2*D2b  |
    
        paddusw		mm2, mm7		// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
        paddusw		mm3, mm7		// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
    
        movq		mm4, mm2		// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
        movq		mm5, mm3		// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
    
        psrlw		mm2, 8			// |  TD1a'>>8 |  TD1r'>>8 |  TD1g'>>8 |  TD1b'>>8 |
        psrlw		mm3, 8			// |  TD2a'>>8 |  TD2r'>>8 |  TD2g'>>8 |  TD2b'>>8 |
    
        paddusw		mm4, mm2		// |  TD1a"    |  TD1r"    |  TD1g"    |  TD1b"    |
        paddusw		mm5, mm3		// |  TD2a"    |  TD2r"    |  TD2g"    |  TD2b"    |
    
        psrlw		mm4, 8			// |  TD1a">>8 |  TD1r">>8 |  TD1g">>8 |  TD1b">>8 |
        psrlw		mm5, 8			// |  TD2a">>8 |  TD2r">>8 |  TD2g">>8 |  TD2b">>8 |
    
        packuswb	mm4, mm5		// |TD2a'"|TD2r'"|TD2g'"|TD2b'"|TD1a'"|TD1r'"|TD1g'"|TD1b'"|  
    
        paddusb		mm4, [esi]
    
        movq		[edi], mm4
    
        add			edi, 8
        add			esi, 8
    
    OnePixelLeft:				    // Step 6:
        // This tests for 0 or 1 pixel left in row - eax contains real width, not width/2
        // If 0, there were an even number of pixels and we're done
        // If 1, there is an odd number of pixels and we need to do one more
        test		eax, 1	
        jz			Done
    
    Do1Pixel:						// make as a macro if used in asm file
                                    // T = 255-S1x
        movd		mm0, DWORD PTR[esi]		// |  0  |  0  |  0  |  0  | S1a | S1r | S1g | S1b |
        psrld		mm0, 24			// |  0  |  0  |  0  |  0  |  0  |  0  | 0 |  S1a  |
        pxor		mm0, AlphaMask	// |  0  |  0  |  0  | 255 |  0  |  0  | 0 |255-S1a|
        punpcklwd	mm0, mm0		// |     0	   |     0	   |  255-S1a  |  255-S1a  |
        punpckldq	mm0, mm0		// |  255-S1a  |  255-S1a  |  255-S1a  |  255-S1a  |
    
        movd		mm1, [edi]		// |  0  |  0  |  0  |  0  | D1a | D1r | D1g | D1b |
        punpcklbw	mm1, mm6		// |  0  | D1a |  0  | D1r |  0  | D1g |  0  | D1b |
        pmullw		mm0, mm1		// |	 T*D1a |	 T*D1r |	 T*D1g |	 T*D1b |
        paddusw		mm0, mm7		// | T*D1a+128 | T*D1r+128 | T*D1g+128 | T*D1b+128 |
        movq		mm1, mm0		// | T*D1a+128 | T*D1r+128 | T*D1g+128 | T*D1b+128 |
        psrlw		mm0, 8			// |  TD1a'>>8 |  TD1r'>>8 |  TD1g'>>8 |  TD1b'>>8 |
        paddusw		mm0, mm1		// |  TD1a"    |  TD1r"    |  TD1g"    |  TD1b"    |
        psrlw		mm0, 8			// |  TD1a">>8 |  TD1r">>8 |  TD1g">>8 |  TD1b">>8 |
        movd        mm1, [esi]
        packuswb	mm0, mm0		// |TD2a'"|TD2r'"|TD2g'"|TD2b'"|TD1a'"|TD1r'"|TD1g'"|TD1b'"|  
        paddusb		mm0, mm1
        movd		[edi], mm0
        add			edi, 4			//	pDst++;
        add			esi, 4			//	pSrc++;
    
        test		ecx, ecx
        jz			Done			// just processed the last pixel of the row
        dec			ecx
        jmp			QuadAligned		// just processed the first pixel of the row
    
    Done:
        emms						// remove for optimizations, have calling function do emms
	}
}

/**************************************************************************\
* mmxAlphaPerPixelAndConst
*   
*   Used when the source has per-pixel alpha values and the
*   SourceConstantAlpha is not 255.
*
*       if SrcAlpha == 255 then
*
*           Dst = Dst + ConstAlpha * (Src - Dst)
*
*       else
*
*           Src = Src * ConstAlpha
*           Dst = Src + (1 - SrcAlpha) Dst       
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*
* Return Value:
*
*   None
*
* History:
*
*    3/12/1997 Mark Enstrom [marke]
*
\**************************************************************************/

/**************************************************************************
  THIS FUNCTION DOES NOT DO ANY PARAMETER VALIDATION
  DO NOT CALL THIS FUNCTION WITH WIDTH == 0

  This function operates on 32 bit pixels (BGRA) in a row of a bitmap.
  This function performs the following:
	first,
  		pixSrc.r = (((ConstAlpha * pixSrc.r)+127)/255);
		pixSrc.g = (((ConstAlpha * pixSrc.g)+127)/255);
		pixSrc.b = (((ConstAlpha * pixSrc.b)+127)/255);
		pixSrc.a = (((ConstAlpha * pixSrc.a)+127)/255);
	then,
  		SrcTran = 255 - pixSrc.a
		pixDst.r = pixSrc.r + (((SrcTran * pixDst.r)+127)/255);
		pixDst.g = pixSrc.g + (((SrcTran * pixDst.g)+127)/255);
		pixDst.b = pixSrc.b + (((SrcTran * pixDst.b)+127)/255);
		pixDst.a = pixSrc.a + (((SrcTran * pixDst.a)+127)/255);

  pDst is assumed to be aligned to a DWORD boundary when passed to this function.
  Step 1:
	Check pDst for QWORD alignment.  If aligned, do Step 2.  If unaligned, do first pixel
	as a DWORD, then do Step 2.
  Step 2:
	QuadAligned
	pDst is QWORD aligned.  If two pixels can be done as a QWORD, do Step 3.  If only one
	pixel left, do as a DWORD.
  Step 3:
	Load two source pixels, S1 and S2, as one QWORD.  Expand S1 and S2 as four words into two MMX registers.
	Multiply each word in S1 and S2 by ConstAlpha.  Add 128 to each result of both pixels.  Copy the results
	of each pixel into an MMX register.  Shift each result of both pixels by 8.  Add the shifted results
	to the copied results.  Shift these results by 8.  Pack the results into one MMX register...this will
	be used later.
	Shift the packed results by 24 to get only the alpha value for each pixel.
  Step 4:
	Get (255 - new alpha value) for each pixel, 255-S1a and 255-S2a.
	Copy 255-S1a as four words into an MMX register.  Copy 255-S2a as four words into an MMX register.
	Load two destination pixels, D1 and D2.  Expand D1 and D2 as four words into two MMX registers.
	Multiply each byte of D1 by 255-S1a.  Multiply each byte of D2 by 255-S2a.  Add 128 to each intermediate
	result of both pixels.  Copy the results of each pixel into an MMX register.  Shift each result of
	both pixels by 8.  Add the shifted results to the copied results.  Shift these results by 8.
	Pack the results into one MMX register.  Add the packed results to the new source pixels saved from
	above.  Store result over destination pixels.  Stay in TwoPixelsAtOnceLoop loop until there is less than
	two pixels to do.
  Step 5:
	OnePixelLeft
	If there is one pixel left (odd number of original pixels) do last pixel as a DWORD.
**************************************************************************/
VOID
mmxAlphaPerPixelAndConst(
    ALPHAPIX	  *pDst,
    ALPHAPIX	  *pSrc,
	LONG 	       Width,
    BLENDFUNCTION  BlendFunction
    )
{
    BYTE    ConstAlpha = BlendFunction.SourceConstantAlpha;
	static QWORD W128 = 0x0080008000800080;
	static QWORD AlphaMask = 0x000000FF000000FF;
	static QWORD Zeros = 0;
	_asm
	{
        mov			esi, pSrc
        mov			edi, pDst
    
        movq		mm7, W128		// This register never changes
        pxor		mm4, mm4		// This register never changes
    
        xor			eax, eax
        mov			al, ConstAlpha	
        movd		mm5, eax		// |		   |		   |		   |		CA |
        punpcklwd	mm5, mm5		// |		   |		   |		CA |		CA |
        punpcklwd	mm5, mm5		// |		CA |		CA |		CA |		CA |
                                    // This register never changes
    
        mov			ecx, Width
                                    // Step 1:
        test		edi, 7			// Test first pixel for QWORD alignment
        jz			QuadAligned		// if unaligned,
    
        jmp			Do1Pixel		// do first pixel only
    
    QuadAligned:					// Step 2:
        mov			eax, ecx		// Save the width in eax for later (see OnePixelLeft:)
        shr			ecx, 1			// Want to do 2 pixels (1 quad) at once, so make ecx even
        test		ecx, ecx		// Make sure there is at least 1 quad to do
        jz			OnePixelLeft	// If we take this jump, width was 1 (aligned) or 2 (unaligned)
    
    TwoPixelsAtOnceLoop:			// Step 3:
        // Within this loop, instructions will pair as shown for the Pentium processor
    
        /* Dissolve
            pixSrc.r = (((ConstAlpha * pixSrc.r)+127)/255);
            pixSrc.g = (((ConstAlpha * pixSrc.g)+127)/255);
            pixSrc.b = (((ConstAlpha * pixSrc.b)+127)/255);
            pixSrc.a = (((ConstAlpha * pixSrc.a)+127)/255);
        */
    
        movq		mm0, [esi]			// | S2a | S2r | S2g | S2b | S1a | S1r | S1g | S1b |
    
        movq		mm1, mm0			// | S2a | S2r | S2g | S2b | S1a | S1r | S1g | S1b |
        punpcklbw	mm0, mm4			// |  0  | S1a |  0  | S1r |  0  | S1g |  0  | S1b |
    
        punpckhbw	mm1, mm4			// |  0  | S2a |  0  | S2r |  0  | S2g |  0  | S2b |
        pmullw		mm0, mm5			// |	CA*S1a |    CA*S1r |	 CA*S1g |	CA*S1b |
    
        add			esi, 8			//	pSrc++;
        pmullw		mm1, mm5			// |	CA*S2a |	CA*S2r |	 CA*S2g |	CA*S2b |
    
        paddusw		mm1, mm7			// |CA*S2a+128 |CA*S2r+128 |CA*S2g+128 |CA*S2b+128 |
        paddusw		mm0, mm7			// |CA*S1a+128 |CA*S1r+128 |CA*S1g+128 |CA*S1b+128 |
    
        movq		mm2, mm0			// |CA*S1a+128 |CA*S1r+128 |CA*S1g+128 |CA*S1b+128 |
        psrlw		mm0, 8				// |  S1a'>>8 |  S1r'>>8 |  S1g'>>8 |  S1b'>>8 |
    
                                    //	S1x' = CA*S1x+128		 S2x' = CA*S2x+128
        movq		mm3, mm1			// |CA*S2a+128 |CA*S2r+128 |CA*S2g+128 |CA*S2b+128 |
        psrlw		mm1, 8				// |  S2a'>>8 |  S2r'>>8 |  S2g'>>8 |  S2b'>>8 |
    
                                    //	S1x" = (CA*S1x+128)>>8  S2x" = (CA*S2x+128)>>8
        paddusw		mm0, mm2			// |  S1a"    |  S1r"    |  S1g"    |  S1b"    |
        paddusw		mm1, mm3			// |  S2a"    |  S2r"    |  S2g"    |  S2b"    |
    
        psrlw		mm0, 8				// |  S1a">>8 |  S1r">>8 |  S1g">>8 |  S1b">>8 |
    
                                    //	SXx'" = ((CA*SXx+128)>>8)>>8)
        psrlw		mm1, 8				// |  S2a">>8 |  S2r">>8 |  S2g">>8 |  S2b">>8 |
        packuswb	mm0, mm1			// |S2a'"|S2r'"|S2g'"|S2b'"|S1a'"|S1r'"|S1g'"|S1b'"|
    
        movq		mm6, mm0
        psrld		mm0, 24				// |  0  |  0  | 0 |  S2a  |  0  |  0  | 0 |  S1a  |
    
        /* Over
            SrcTran = 255 - pixSrc.a
            pixDst.r = pixSrc.r + (((SrcTran * pixDst.r)+128)/255);
            pixDst.g = pixSrc.g + (((SrcTran * pixDst.g)+128)/255);
            pixDst.b = pixSrc.b + (((SrcTran * pixDst.b)+128)/255);
            pixDst.a = pixSrc.a + (((SrcTran * pixDst.a)+128)/255);
        */
                                    // Step 4:
        pxor		mm0, AlphaMask		// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
    
        movq		mm1, mm0			// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
        punpcklwd	mm0, mm0			// |     0	   |     0	   |   255-S1a |   255-S1a |
    
        movq		mm2, [edi]			// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
        punpcklwd	mm0, mm0			// |   255-S1a |   255-S1a |   255-S1a |   255-S1a |
    
        movq		mm3, mm2			// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
        punpckhwd	mm1, mm1			// |     0	   |     0	   |   255-S2a |   255-S2a |
    
        punpcklwd	mm1, mm1			// |   255-S2a |   255-S2a |   255-S2a |   255-S2a |
    
        punpckhbw	mm3, mm4			// |  0  | D2a |  0  | D2r |  0  | D2g |  0  | D2b |
    
                                    //	T1 = 255-S1a	T2 = 255-S2a
        punpcklbw	mm2, mm4			// |  0  | D1a |  0  | D1r |  0  | D1g |  0  | D1b |
        pmullw		mm1, mm3			// |	T2*D2a |	T2*D2r |	 T2*D2g |	T2*D2b |
    
        add			edi, 8			//	pDst++;
        pmullw		mm0, mm2			// |	T1*D1a |	T1*D1r |	 T1*D1g |	T1*D1b |
    
        paddusw		mm0, mm7			// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
        paddusw		mm1, mm7			// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
    
        movq		mm3, mm1			// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
                                    //  TDXx' = TX*DXx+128
        psrlw		mm1, 8				// |  TD2a'>>8 |  TD2r'>>8 |  TD2g'>>8 |  TD2b'>>8 |
    
        movq		mm2, mm0			// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
        psrlw		mm0, 8				// |  TD1a'>>8 |  TD1r'>>8 |  TD1g'>>8 |  TD1b'>>8 |
                                    //  TDXx" = (TX*DXx+128)+(TDXx'>>8)
        paddusw		mm1, mm3			// |  TD2a"    |  TD2r"    |  TD2g"    |  TD2b"    |
        paddusw		mm0, mm2			// |  TD1a"    |  TD1r"    |  TD1g"    |  TD1b"    |
    
        psrlw		mm1, 8				// |  TD2a">>8 |  TD2r">>8 |  TD2g">>8 |  TD2b">>8 |
    
        psrlw		mm0, 8				// |  TD1a">>8 |  TD1r">>8 |  TD1g">>8 |  TD1b">>8 |
    
        packuswb	mm0, mm1		// |TD2a'"|TD2r'"|TD2g'"|TD2b'"|TD1a'"|TD1r'"|TD1g'"|TD1b'"|  
                                    //	SXx = SXx'"	TDXx = TDXx'"
        paddusb		mm0, mm6// |S2a+TD2a|S2r+TD2r|S2g+TD2g|S2b+TD2b|S1a+TD1a|S1r+TD1r|S1g+TD1g|S1b+TD1b|
    
        movq		[edi-8], mm0
    
        dec			ecx
        jnz			TwoPixelsAtOnceLoop
    
    OnePixelLeft:					// Step 5:
        // This tests for 0 or 1 pixel left in row - eax contains real width, not width/2
        // If 0, there were an even number of pixels and we're done
        // If 1, there is an odd number of pixels and we need to do one more
        test		eax, 1	
        jz			Done
        
    Do1Pixel:						// make as a macro if used in asm file
    
        /* Dissolve
            pixSrc.r = (((ConstAlpha * pixSrc.r)+127)/255);
            pixSrc.g = (((ConstAlpha * pixSrc.g)+127)/255);
            pixSrc.b = (((ConstAlpha * pixSrc.b)+127)/255);
            pixSrc.a = (((ConstAlpha * pixSrc.a)+127)/255);
        */
    
        movd		mm0, [esi]			// | S2a | S2r | S2g | S2b | S1a | S1r | S1g | S1b |
        punpcklbw	mm0, mm4			// |  0  | S1a |  0  | S1r |  0  | S1g |  0  | S1b |
    
        pmullw		mm0, mm5			// |	CA*S1a |    CA*S1r |	 CA*S1g |	CA*S1b |
        paddusw		mm0, mm7			// |CA*S1a+128 |CA*S1r+128 |CA*S1g+128 |CA*S1b+128 |
        movq		mm2, mm0			// |CA*S1a+128 |CA*S1r+128 |CA*S1g+128 |CA*S1b+128 |
    
                                    //	 S1x' = CA*S1x+128		 S2x' = CA*S2x+128
        psrlw		mm0, 8				// |  S1a'>>8 |  S1r'>>8 |  S1g'>>8 |  S1b'>>8 |
                                    //	 S1x" = (CA*S1x+128)>>8 S2x" = (CA*S2x+128)>>8
        paddusw		mm0, mm2			// |  S1a"    |  S1r"    |  S1g"    |  S1b"    |
        psrlw		mm0, 8				// |  S1a">>8 |  S1r">>8 |  S1g">>8 |  S1b">>8 |
        packuswb	mm0, mm0			// |S2a'"|S2r'"|S2g'"|S2b'"|S1a'"|S1r'"|S1g'"|S1b'"|
        movq		mm6, mm0
        psrld		mm0, 24				// |  0  |  0  | 0 |  S2a  |  0  |  0  | 0 |  S1a  |
    
        /* Over
            SrcTran = 255 - pixSrc.a
            pixDst.r = pixSrc.r + (((SrcTran * pixDst.r)+128)/255);
            pixDst.g = pixSrc.g + (((SrcTran * pixDst.g)+128)/255);
            pixDst.b = pixSrc.b + (((SrcTran * pixDst.b)+128)/255);
            pixDst.a = pixSrc.a + (((SrcTran * pixDst.a)+128)/255);
        */
    
        pxor		mm0, AlphaMask		// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
        punpcklwd	mm0, mm0			// |  0  |  0  |  0  |  0  |  0  |  0  |255-S1a|255-S1a|
        punpckldq	mm0, mm0			// |    255-S1a|    255-S1a|    255-S1a|    255-S1a|
        movd		mm2, [edi]			// |  0  |  0  |  0  |  0  | D1a | D1r | D1g | D1b |
        punpcklbw	mm2, mm4			// |	   D1a |	   D1r |	   D1g |	   D1b |
                                    //	T = 255-S1x
        pmullw		mm0, mm2			// |	 T*D1a |	 T*D1r |	 T*D1g |	 T*D1b |
        paddusw		mm0, mm7			// | T*D1a+128 | T*D1r+128 | T*D1g+128 | T*D1b+128 |
        movq		mm1, mm0			// | T*D1a+128 | T*D1r+128 | T*D1g+128 | T*D1b+128 |
        psrlw		mm0, 8				// |  TD1a'>>8 |  TD1r'>>8 |  TD1g'>>8 |  TD1b'>>8 |
        paddusw		mm0, mm1			// |  TD1a"    |  TD1r"    |  TD1g"    |  TD1b"    |
        psrlw		mm0, 8
        packuswb	mm0, mm0		// |TD2a'"|TD2r'"|TD2g'"|TD2b'"|TD1a'"|TD1r'"|TD1g'"|TD1b'"|  
        paddusb		mm0, mm6  
        movd		[edi], mm0
        add			edi, 4			// pDst++;
        add			esi, 4			// pSrc++;
    
        test		ecx, ecx
        jz			Done			// just processed the last pixel of the row
        dec			ecx
        jmp			QuadAligned		// just processed the first pixel of the row
    
    Done:
        emms						// remove for optimizations, have calling function do emms
	}
}

/**************************************************************************\
* mmxAlphaConstOnly16_555
*
*   Optimized version of mmxAlphaConstOnly used when source and destination
*   are both 16_555.
*
*           Dst = Dst + ConstAlpha * (Src - Dst)
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*
* Return Value:
*   
*   None
*
\**************************************************************************/

/**************************************************************************
  THIS FUNCTION DOES NOT DO ANY PARAMETER VALIDATION

  This function operates on 16 bit pixels (5 for Red, 5 for Green, and 5 for Blue) in a row of a bitmap.
  It blends source and destination bitmaps, without alpha channels, using a constant alpha input.
  The function performs the following on each byte:

  For red, green, and blue:
  tmp1 = Alpha(Src - Dst) + 16 + (Dst * 31)
  tmp2 = tmp1 / 32
  tmp2 = tmp2 + tmp1
  tmp2 = tmp2 / 32
  Dst = tmp2

  pDst is assumed to be aligned to a DWORD boundary when passed to this function.

  Red and blue are processed together in the same register.  Green is processed separately.
  For two pixels at once, the reds and blues for both pixels are processed in the same register; and the
  greens are processed together in a separate register.

  The loop structure is as follows:
  Step 1:
	Check pDst for QWORD alignment.  If aligned, do Step 2.  If unaligned, do first pixel
	as a DWORD (OnePixelLeft:), then do Step 2.
  Step 2:
  (QuadAligned:)
	pDst is QWORD aligned.  If two pixels can be done as a QWORD, do Step 3.  If only one
	pixel left, do as a DWORD.
  Step 3:
  (TwoPixelsAtOnceLoop:)
	Perform the above function, using MMX instructions, on two pixels per pass of the loop.
  Step 4:
  (OnePixelLeft:)
	If there is one pixel left (odd number of original pixels) do last pixel as a DWORD.
**************************************************************************/
VOID
mmxAlphaConstOnly16_555(
    PALPHAPIX     pDst,
    PALPHAPIX     pSrc,
    LONG          Width,
    BLENDFUNCTION BlendFunction
    )
{
	static QWORD RMask  = 0x007C0000007C0000;
	static QWORD GMask  = 0x0000000003E003E0;
	static QWORD BMask  = 0x0000001F0000001F;
	static QWORD RBConst = 0x0010001000100010;
	static QWORD GConst = 0x0000000000100010;
	static QWORD RedMask  =  0x001F0000001F0000;
	static QWORD CA;	// ConstAlpha in 4 words of a qword
    BYTE         ConstAlpha = BlendFunction.SourceConstantAlpha;

	_asm
	{
		mov			ecx, Width		// Make sure there is at least one pixel to do
		test		ecx, ecx
		jz			Done

		mov			esi, pSrc
		mov			edi, pDst

		xor			eax, eax
		mov			al, ConstAlpha
		movd		mm5, eax		// |		   |		   |		   |		CA |
		punpcklwd	mm5, mm5		// |		   |		   |		CA |		CA |
		punpcklwd	mm5, mm5		// |		CA |		CA |		CA |		CA |
		movq		CA, mm5
									// Step 1:
		test		edi, 7			// Test first pixel for QWORD alignment
		jz			QuadAligned		// if unaligned,

		jmp			Do1Pixel		// do first pixel only

	QuadAligned:					// Step 2:
		mov			eax, ecx		// Save the width in eax for later (see OnePixelLeft:)
		shr			ecx, 1			// Want to do 2 pixels (1 quad) at once, so make ecx even
		test		ecx, ecx		// Make sure there is at least 1 quad to do
		jz			OnePixelLeft	// If we take this jump, width was 1 (aligned) or 2 (unaligned)

	TwoPixelsAtOnceLoop:			// Step 3:
		movd		mm0, [edi]	// | 0 | 0 | 0 | 0 | D2xrrrrrgg | D2gggbbbbb | D1xrrrrrgg | D1gggbbbbb |
		pxor		mm7, mm7
									
		movd		mm1, [esi]	// | 0 | 0 | 0 | 0 | S2xrrrrrgg | S2gggbbbbb | S1xrrrrrgg | S1gggbbbbb |
		movq		mm2, mm0	// | 0 | 0 | 0 | 0 | D2xrrrrrgg | D2gggbbbbb | D1xrrrrrgg | D1gggbbbbb |

		movq		mm3, mm1	// | 0 | 0 | 0 | 0 | S2xrrrrrgg | S2gggbbbbb | S1xrrrrrgg | S1gggbbbbb |
		punpcklbw	mm0, mm7	// | D2xrrrrrgg | D2gggbbbbb | D1xrrrrrgg | D1gggbbbbb |

		punpcklbw	mm1, mm7	// | S2xrrrrrgg | S2gggbbbbb | S1xrrrrrgg | S1gggbbbbb |
		movq		mm4, mm0	// | D2xrrrrrgg | D2gggbbbbb | D1xrrrrrgg | D1gggbbbbb |

		pand		mm0, RMask	// |  D2rrrrr00 |     0      |  D1rrrrr00 |     0      |
		movq		mm5, mm1	// | S2xrrrrrgg | S2gggbbbbb | S1xrrrrrgg | S1gggbbbbb |

		pand		mm4, BMask	// |     0      |    D2bbbbb |     0      |    D1bbbbb |
		psrlw		mm0, 2		// |    D2rrrrr |     0      |    D1rrrrr |     0      |

		pand		mm1, RMask	// |  S2rrrrr00 |     0      |  S1rrrrr00 |     0      |
		por			mm0, mm4	// |    D2rrrrr |    D2bbbbb |    D1rrrrr |    D1bbbbb |

		pand		mm5, BMask	// |     0      |    S2bbbbb |     0      |    S1bbbbb |
		movq		mm4, mm0	// |    D2rrrrr |    D2bbbbb |    D1rrrrr |    D1bbbbb |

		pand		mm2, GMask	// |     0      |     0      |D2ggggg00000|D1ggggg00000|
		psllw		mm4, 5		// |   D2r*32   |   D2b*32   |   D1r*32   |   D1b*32   |

		pand		mm3, GMask	// |     0      |     0      |S2ggggg00000|S1ggggg00000|
		psrlw		mm1, 2		// |    S2rrrrr |     0      |    S1rrrrr |     0      |

		por			mm5, mm1	// |    S2rrrrr |    S2bbbbb |    S1rrrrr |    S1bbbbb |
		movq		mm6, mm2	// |     0      |     0      |D2ggggg00000|D1ggggg00000|

		psubw		mm5, mm0	// |   S2r-D2r  |   S2b-D2b  |   S1r-D1r  |   S1b-D1b  |
		psrlw		mm2, 5		// |     0      |     0      |    D2ggggg |    D1ggggg |

		pmullw		mm5, CA		// |    CA2r    |    CA2b    |    CA1r    |    CA1b    |
		psubw		mm4, mm0	// | D2r*(32-1) | D2b*(32-1) | D1r*(32-1) | D1b*(32-1) |

		paddw		mm4, RBConst// |   CA2r+c   |   CA2b+c   |   CA1r+c   |   CA1b+c   |
		psrlw		mm3, 5		// |     0      |     0      |    S2ggggg |    S1ggggg |

		psubw		mm3, mm2	// |     0      |     0      |   S2g-D2g  |   S1g-D1g  |
		add			esi, 4		// pSrc++;

		pmullw		mm3, CA		// |     0      |     0      |    CA2g    |    CA1g    |
		paddw		mm4, mm5	// RBtmp1 = Alpha(RBSrc - RBDst) + 16 + (RBDst * 31)

		psubw		mm6, mm2	// |     0      |     0      | D2g*(32-1) | D1g*(32-1) |
		add			edi, 4		// pDst++;

		paddw		mm6, GConst	// |     0      |     0      |   CA2g+c   |   CA1g+c   |
		movq		mm1, mm4	// RBtmp1 = Alpha(RBSrc - RBDst) + 16 + (RBDst * 31)

		paddw		mm6, mm3	// Gtmp1 = Alpha(GSrc - GDst) + 16 + (GDst * 31)
		psrlw		mm4, 5		// RBtmp2 = RBtmp1 / 32

		movq		mm5, mm6	// Gtmp1 = Alpha(GSrc - GDst) + 16 + (GDst * 31)
		paddw		mm1, mm4	// RBtmp2 = RBtmp2 + RBtmp1

		psrlw		mm6, 5		// Gtmp2 = Gtmp1 / 32

		paddw		mm5, mm6	// Gtmp2 = Gtmp2 + Gtmp1
		psrlw		mm1, 5		// RBtmp2 = RBtmp2 / 32

		pand		mm5, GMask	// Gtmp2 = Gtmp2 / 32, but keep bit position
		movq		mm4, mm1	// RBtmp2 = RBtmp2 / 32

		pand		mm4, RedMask// Mask to get red

		pand		mm1, BMask	// Mask to get blue
		psllw		mm4, 2		// Line up the red

		por			mm4, mm1	// Combine reds and blues in proper bit location

		packuswb	mm4, mm7	// | 0 | 0 | 0 | 0 | D20rrrrrgg | D2gggbbbbb | D10rrrrrgg | D1gggbbbbb |

		por			mm4, mm5	// | 0 | 0 | 0 | 0 | D20rrrrrgg | D2gggbbbbb | D10rrrrrgg | D1gggbbbbb |

		movd		[edi-4], mm4

		dec			ecx
		jnz			TwoPixelsAtOnceLoop

	OnePixelLeft:						// Step 4:
		// This tests for 0 or 1 pixel left in row - eax contains real width, not width/2
		// If 0, there was an even number of pixels and we're done
		// If 1, there is an odd number of pixels and we need to do one more
		test		eax, 1	
		jz			Done

	Do1Pixel:							// make as a macro if used in asm file

		movzx   edx,WORD PTR[edi]       // edx = D 0000 0000 0rrr rrgg gggb bbbb
        movzx   ebx,WORD PTR[esi]       // ebx = S 0000 0000 0rrr rrgg gggb bbbb

		movd		mm0, edx	// | 0 | 0 | 0 | 0 | 0 | 0 | D1xrrrrrgg | D1gggbbbbb |
		pxor		mm7, mm7
									
		movd		mm1, ebx	// | 0 | 0 | 0 | 0 | 0 | 0 | S1xrrrrrgg | S1gggbbbbb |
		movq		mm2, mm0	// | 0 | 0 | 0 | 0 | 0 | 0 | D1xrrrrrgg | D1gggbbbbb |
									
		movq		mm3, mm1	// | 0 | 0 | 0 | 0 | 0 | 0 | S1xrrrrrgg | S1gggbbbbb |
		punpcklbw	mm0, mm7	// | 0 | 0 | D1xrrrrrgg | D1gggbbbbb |

		punpcklbw	mm1, mm7	// | 0 | 0 | S1xrrrrrgg | S1gggbbbbb |
		movq		mm4, mm0	// | 0 | 0 | D1xrrrrrgg | D1gggbbbbb |

		pand		mm0, RMask	// | 0 | 0 |  D1rrrrr00 |     0      |
		movq		mm5, mm1	// | 0 | 0 | S1xrrrrrgg | S1gggbbbbb |

		pand		mm4, BMask	// | 0 | 0 |     0      |    D1bbbbb |
		psrlw		mm0, 2		// | 0 | 0 |    D1rrrrr |     0      |

		pand		mm1, RMask	// | 0 | 0 |  S1rrrrr00 |     0      |
		por			mm0, mm4	// | 0 | 0 |    D1rrrrr |    D1bbbbb |

		pand		mm5, BMask	// | 0 | 0 |     0      |    S1bbbbb |
		movq		mm4, mm0	// | 0 | 0 |    D1rrrrr |    D1bbbbb |

		pand		mm2, GMask	// | 0 | 0 |     0      |D1ggggg00000|
		psllw		mm4, 5		// | 0 | 0 |   D1r*32   |   D1b*32   |

		pand		mm3, GMask	// | 0 | 0 |     0      |S1ggggg00000|
		psrlw		mm1, 2		// | 0 | 0 |    S1rrrrr |     0      |

		por			mm5, mm1	// | 0 | 0 |    S1rrrrr |    S1bbbbb |
		movq		mm6, mm2	// | 0 | 0 |     0      |D1ggggg00000|

		psubw		mm5, mm0	// | 0 | 0 |   S1r-D1r  |   S1b-D1b  |
		psrlw		mm2, 5		// | 0 | 0 |     0      |    D1ggggg |

		pmullw		mm5, CA		// | 0 | 0 |    CA1r    |    CA1b    |
		psubw		mm4, mm0	// | 0 | 0 | D1r*(32-1) | D1b*(32-1) |

		paddw		mm4, RBConst// | 0 | 0 |   CA1r+c   |   CA1b+c   |
		psrlw		mm3, 5		// | 0 | 0 |     0      |    S1ggggg |

		psubw		mm3, mm2	// | 0 | 0 |     0      |   S1g-D1g  |
		add			esi, 2		// pSrc++;

		pmullw		mm3, CA		// | 0 | 0 |     0      |    CA1g    |
		paddw		mm4, mm5	// RBtmp1 = Alpha(RBSrc - RBDst) + 16 + (RBDst * 31)

		psubw		mm6, mm2	// | 0 | 0 |     0      | D1g*(32-1) |
		add			edi, 2		// pDst++;

		paddw		mm6, GConst	// | 0 | 0 |     0      |   CA1g+c   |
		movq		mm1, mm4	// RBtmp1 = Alpha(RBSrc - RBDst) + 16 + (RBDst * 31)

		paddw		mm6, mm3	// Gtmp1 = Alpha(GSrc - GDst) + 16 + (GDst * 31)
		psrlw		mm4, 5		// RBtmp2 = RBtmp1 / 32

		movq		mm5, mm6	// Gtmp1 = Alpha(GSrc - GDst) + 16 + (GDst * 31)
		paddw		mm1, mm4	// RBtmp2 = RBtmp2 + RBtmp1

		psrlw		mm6, 5		// Gtmp2 = Gtmp1 / 32

		paddw		mm5, mm6	// Gtmp2 = Gtmp2 + Gtmp1
		psrlw		mm1, 5		// RBtmp2 = RBtmp2 / 32

		pand		mm5, GMask	// Gtmp2 = Gtmp2 / 32, but keep bit position
		movq		mm4, mm1	// RBtmp2 = RBtmp2 / 32

		pand		mm4, RedMask// Mask to get red

		pand		mm1, BMask	// Mask to get blue
		psllw		mm4, 2		// Line up the red

		por			mm4, mm1	// Combine reds and blues in proper bit location

		packsswb	mm4, mm7	// | 0 | 0 | D10rrrrr00 | D1000bbbbb |

		por			mm4, mm5	// | 0 | 0 | D10rrrrrgg | D1gggbbbbb |

		movd		edx, mm4

		mov			[edi-2], dx

		test		ecx, ecx
		jz			Done		// just processed the last pixel of the row
		dec			ecx
		jmp			QuadAligned	// just processed the first pixel of the row

	Done:
		emms					// remove for optimizations, have calling function do emms
	}
}

/**************************************************************************\
* mmxAlphaConstOnly16_565
*
*   Optimized version of mmxAlphaConstOnly used when source and destination
*   are both 16_565.
*
*           Dst = Dst + ConstAlpha * (Src - Dst)
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*
* Return Value:
*   
*   None
*
\**************************************************************************/

/**************************************************************************
  THIS FUNCTION DOES NOT DO ANY PARAMETER VALIDATION

  This function operates on 16 bit pixels (5 for Red, 6 for Green, and 5 for Blue) in a row of a bitmap.
  It blends source and destination bitmaps, without alpha channels, using a constant alpha input.
  The function performs the following:

  For red and blue:
  tmp1 = Alpha(Src - Dst) + 16 + (Dst * 31)
  tmp2 = tmp1 / 32
  tmp2 = tmp2 + tmp1
  tmp2 = tmp2 / 32
  Dst = tmp2

  For green:
  tmp1 = Alpha(Src - Dst) + 32 + (Dst * 63)
  tmp2 = tmp1 / 32
  tmp2 = tmp2 + tmp1
  tmp2 = tmp2 / 32
  Dst = tmp2

  pDst is assumed to be aligned to a DWORD boundary when passed to this function.

  Red and blue are processed together in the same register.  Green is processed separately.
  For two pixels at once, the reds and blues for both pixels are processed in the same register; and the
  greens are processed together in a separate register.

  The loop structure is as follows:
  Step 1:
	Check pDst for QWORD alignment.  If aligned, do Step 2.  If unaligned, do first pixel
	as a DWORD (OnePixelLeft:), then do Step 2.
  Step 2:
  (QuadAligned:)
	pDst is QWORD aligned.  If two pixels can be done as a QWORD, do Step 3.  If only one
	pixel left, do as a DWORD.
  Step 3:
  (TwoPixelsAtOnceLoop:)
	Perform the above function, using MMX instructions, on two pixels per pass of the loop.
  Step 4:
  (OnePixelLeft:)
	If there is one pixel left (odd number of original pixels) do last pixel as a DWORD.
**************************************************************************/
VOID
mmxAlphaConstOnly16_565(
    PALPHAPIX     pDst,
    PALPHAPIX     pSrc,
    LONG          Width,
    BLENDFUNCTION BlendFunction
    )
{
	static QWORD RMask  = 0x00FF000000FF0000;
	static QWORD GMask  = 0x0000000007E007E0;
	static QWORD BMask  = 0x0000001F0000001F;
	static QWORD RBConst = 0x0010001000100010;
	static QWORD GConst = 0x0000000000200020;
	static QWORD GreenMask  =  0x000000000FC00FC0;
	static QWORD CA;	// ConstAlpha in 4 words of a qword
    BYTE         ConstAlpha = BlendFunction.SourceConstantAlpha;

	_asm
	{
		mov			ecx, Width		// Make sure there is at least one pixel to do
		test		ecx, ecx
		jz			Done

		mov			esi, pSrc
		mov			edi, pDst

		xor			eax, eax
		mov			al, ConstAlpha
		movd		mm5, eax		// |		   |		   |		   |		CA |
		punpcklwd	mm5, mm5		// |		   |		   |		CA |		CA |
		punpcklwd	mm5, mm5		// |		CA |		CA |		CA |		CA |
		movq		CA, mm5
									// Step 1:
		test		edi, 7			// Test first pixel for QWORD alignment
		jz			QuadAligned		// if unaligned,

		jmp			Do1Pixel		// do first pixel only

	QuadAligned:					// Step 2:
		mov			eax, ecx		// Save the width in eax for later (see OnePixelLeft:)
		shr			ecx, 1			// Want to do 2 pixels (1 quad) at once, so make ecx even
		test		ecx, ecx		// Make sure there is at least 1 quad to do
		jz			OnePixelLeft	// If we take this jump, width was 1 (aligned) or 2 (unaligned)

	TwoPixelsAtOnceLoop:			// Step 3:
		movd		mm0, [edi]		// | 0 | 0 | 0 | 0 | D2rrrrrggg | D2gggbbbbb | D1rrrrrggg | D1gggbbbbb |
		pxor		mm7, mm7		
									
		movd		mm1, [esi]		// | 0 | 0 | 0 | 0 | S2rrrrrggg | S2gggbbbbb | S1rrrrrggg | S1gggbbbbb |
		movq		mm2, mm0		// | 0 | 0 | 0 | 0 | D2rrrrrggg | D2gggbbbbb | D1rrrrrggg | D1gggbbbbb |
									
		movq		mm3, mm1		// | 0 | 0 | 0 | 0 | S2rrrrrggg | S2gggbbbbb | S1rrrrrggg | S1gggbbbbb |
		punpcklbw	mm0, mm7		// | D2rrrrrggg | D2gggbbbbb | D1rrrrrggg | D1gggbbbbb |
									
		punpcklbw	mm1, mm7		// | S2rrrrrggg | S2gggbbbbb | S1rrrrrggg | S1gggbbbbb |
		movq		mm4, mm0		// | D2rrrrrggg | D2gggbbbbb | D1rrrrrggg | D1gggbbbbb |

		pand		mm0, RMask		// | D2rrrrr000 |     0      | D1rrrrr000 |     0      |
		movq		mm5, mm1		// | S2rrrrrggg | S2gggbbbbb | S1rrrrrggg | S1gggbbbbb |
									
		pand		mm4, BMask		// |     0      |	 D2bbbbb |     0      |	   D1bbbbb |
		psrlw		mm0, 3			// |    D2rrrrr |     0      |    D1rrrrr |     0      |
									
		pand		mm1, RMask		// | S2rrrrr000 |     0      | S1rrrrr000 |     0      |
		por			mm0, mm4		// |    D2rrrrr |    D2bbbbb |    D1rrrrr |    D1bbbbb |
									
		pand		mm5, BMask		// |     0      |    S2bbbbb |     0      |    S1bbbbb |
		movq		mm4, mm0		// |    D2rrrrr |    D2bbbbb |    D1rrrrr |    D1bbbbb |
									
		pand		mm2, GMask		// |     0      |     0      |D2gggggg00000|D1gggggg00000|
		psllw		mm4, 5			// |   D2r*32   |   D2b*32   |   D1r*32   |   D1b*32   |
									
		pand		mm3, GMask		// |     0      |     0      |S2gggggg00000|S1gggggg00000|
		psrlw		mm1, 3			// |    S2rrrrr |     0      |    S1rrrrr |     0      |
									
		por			mm5, mm1		// |    S2rrrrr |    S2bbbbb |    S1rrrrr |    S1bbbbb |
		movq		mm6, mm2		// |     0      |     0      |D2gggggg00000|D1gggggg00000|

		psubw		mm5, mm0		// |   S2r-D2r  |   S2b-D2b  |   S1r-D1r  |   S1b-D1b  |
		psrlw		mm2, 5			// |     0      |     0      |   D2gggggg |   D1gggggg |
									
		pmullw		mm5, CA			// |    CA2r    |    CA2b    |    CA1r    |    CA1b    |
		psubw		mm4, mm0		// | D2r*(32-1) | D2b*(32-1) | D1r*(32-1) | D1b*(32-1) |
									
		paddw		mm4, RBConst	// |   CA2r+c   |   CA2b+c   |   CA1r+c   |   CA1b+c   |
		psrlw		mm3, 5			// |     0      |     0      |   S2gggggg |   S1gggggg |
									
		psubw		mm3, mm2		// |     0      |     0      |   S2g-D2g  |   S1g-D1g  |
		add			esi, 4			// pSrc++;
									
		pmullw		mm3, CA			// |     0      |     0      |    CA2g    |    CA1g    |
		psllw		mm6, 1			// |     0      |     0      |D2gggggg000000|D1gggggg000000|
									
		paddw		mm4, mm5		// RBtmp1 = Alpha(RBSrc - RBDst) + 16 + (RBDst * 31)
		psubw		mm6, mm2		// |     0      |     0      | D2g*(64-1) | D1g*(64-1) |
									
		paddw		mm6, GConst		// |     0      |     0      |   CA2g+c   |   CA1g+c   |
		movq		mm1, mm4		// RBtmp1 = Alpha(RBSrc - RBDst) + 16 + (RBDst * 31)
									
		add			edi, 4			// pDst++;
		psllw		mm3, 1			// |     0      |     0      |CA2gggggg000000|CA1gggggg000000|
									
		paddw		mm6, mm3		// Gtmp1 = Alpha(GSrc - GDst) + 32 + (GDst * 63)
		psrlw		mm4, 5			// RBtmp2 = RBtmp1 / 32
									
		movq		mm5, mm6		// Gtmp1 = Alpha(GSrc - GDst) + 32 + (GDst * 63)
		paddw		mm1, mm4		// RBtmp2 = RBtmp2 + RBtmp1

		psrlw		mm6, 6			// Gtmp2 = Gtmp1 / 32

		paddw		mm5, mm6		// Gtmp2 = Gtmp2 + Gtmp1
		psrlw		mm1, 5			// RBtmp2 = RBtmp2 / 32

		pand		mm5, GreenMask	// Gtmp2 = Gtmp2 / 32, but keep bit position
		movq		mm4, mm1		// RBtmp2 = RBtmp2 / 32

		pand		mm4, RMask		// Mask to get red
		psrlw		mm5, 1			// Align the green

		pand		mm1, BMask		// Mask to get blue
		psllw		mm4, 3			// Align the red

		por			mm4, mm1		// Combine reds and blues in proper bit location

		packuswb	mm4, mm7		// | 0 | 0 | 0 | 0 | D2rrrrr000 | D2000bbbbb | D1rrrrr000 | D1000bbbbb |

		por			mm4, mm5		// | 0 | 0 | 0 | 0 | D2rrrrrggg | D2gggbbbbb | D1rrrrrggg | D1gggbbbbb |

		movd		[edi-4], mm4

		dec			ecx
		jnz			TwoPixelsAtOnceLoop

	OnePixelLeft:						// Step 4:
		// This tests for 0 or 1 pixel left in row - eax contains real width, not width/2
		// If 0, there were an even number of pixels and we're done
		// If 1, there is an odd number of pixels and we need to do one more
		test		eax, 1	
		jz			Done

	Do1Pixel:							// make as a macro if used in asm file
		movzx   edx,WORD PTR[edi]       // edx = D 0000 0000 rrrr rggg gggb bbbb
        movzx   ebx,WORD PTR[esi]       // ebx = S 0000 0000 rrrr rggg gggb bbbb

		movd		mm0, edx		// | 0 | 0 | 0 | 0 | 0 | 0 | D1xrrrrrgg | D1gggbbbbb |
		pxor		mm7, mm7		
										
		movd		mm1, ebx		// | 0 | 0 | 0 | 0 | 0 | 0 | S1rrrrrggg | S1gggbbbbb |
		movq		mm2, mm0		// | 0 | 0 | 0 | 0 | 0 | 0 | D1rrrrrggg | D1gggbbbbb |
										
		movq		mm3, mm1		// | 0 | 0 | 0 | 0 | 0 | 0 | S1rrrrrggg | S1gggbbbbb |
		punpcklbw	mm0, mm7		// | 0 | 0 | D1rrrrrggg | D1gggbbbbb |
									
		punpcklbw	mm1, mm7		// | 0 | 0 | S1rrrrrggg | S1gggbbbbb |
		movq		mm4, mm0		// | 0 | 0 | D1rrrrrggg | D1gggbbbbb |
									
		pand		mm0, RMask		// | 0 | 0 | D1rrrrr000 |     0      |
		movq		mm5, mm1		// | 0 | 0 | S1rrrrrggg | S1gggbbbbb |
									
		pand		mm4, BMask		// | 0 | 0 |     0      |    D1bbbbb |
		psrlw		mm0, 3			// | 0 | 0 |    D1rrrrr |     0      |
									
		pand		mm1, RMask		// | 0 | 0 | S1rrrrr000 |     0      |
		por			mm0, mm4		// | 0 | 0 |    D1rrrrr |    D1bbbbb |
									
		pand		mm5, BMask		// | 0 | 0 |     0      |    S1bbbbb |
		movq		mm4, mm0		// | 0 | 0 |    D1rrrrr |    D1bbbbb |
									
		pand		mm2, GMask		// | 0 | 0 |     0      |D1gggggg00000|
		psllw		mm4, 5			// | 0 | 0 |   D1r*32   |   D1b*32   |
									
		pand		mm3, GMask		// | 0 | 0 |     0      |S1gggggg00000|
		psrlw		mm1, 3			// | 0 | 0 |    S1rrrrr |     0      |
									
		por			mm5, mm1		// | 0 | 0 |    S1rrrrr |    S1bbbbb |
		movq		mm6, mm2		// | 0 | 0 |     0      |D1gggggg00000|
									
		psubw		mm5, mm0		// | 0 | 0 |   S1r-D1r  |   S1b-D1b  |
		psrlw		mm2, 5			// | 0 | 0 |     0      |   D1gggggg |
									
		pmullw		mm5, CA			// | 0 | 0 |    CA1r    |    CA1b    |
		psubw		mm4, mm0		// | 0 | 0 | D1r*(32-1) | D1b*(32-1) |
									
		paddw		mm4, RBConst	// | 0 | 0 |   CA1r+c   |   CA1b+c   |
		psrlw		mm3, 5			// | 0 | 0 |     0      |   S1gggggg |
									
		psubw		mm3, mm2		// | 0 | 0 |     0      |   S1g-D1g  |
		add			esi, 2			// pSrc++;
									
		pmullw		mm3, CA			// | 0 | 0 |     0      |    CA1g    |
		paddw		mm4, mm5		// RBtmp1 = Alpha(RBSrc - RBDst) + 16 + (RBDst * 31)
									
		psllw		mm6, 1			// | 0 | 0 |     0      |D1gggggg000000|
									
		psubw		mm6, mm2		// | 0 | 0 |     0      | D1g*(64-1) |
		add			edi, 2			// pDst++;
									
		paddw		mm6, GConst		// | 0 | 0 |     0      |   CA1g+c   |
		movq		mm1, mm4		// RBtmp1 = Alpha(RBSrc - RBDst) + 16 + (RBDst * 31)
									
		psllw		mm3, 1			// | 0 | 0 |     0      |CA1gggggg000000|
									
		paddw		mm6, mm3		// Gtmp1 = Alpha(GSrc - GDst) + 32 + (GDst * 63)
		psrlw		mm4, 5			// RBtmp2 = RBtmp1 / 32
									
		movq		mm5, mm6		// Gtmp1 = Alpha(GSrc - GDst) + 32 + (GDst * 63)
		paddw		mm1, mm4		// RBtmp2 = RBtmp2 + RBtmp1

		psrlw		mm6, 6			// Gtmp2 = Gtmp1 / 32

		paddw		mm5, mm6		// Gtmp2 = Gtmp2 + Gtmp1
		psrlw		mm1, 5			// RBtmp2 = RBtmp2 / 32

		pand		mm5, GreenMask	// Gtmp2 = Gtmp2 / 32, but keep bit position
		movq		mm4, mm1		// RBtmp2 = RBtmp2 / 32

		pand		mm4, RMask		// Mask to get red
		psrlw		mm5, 1			// Align the green

		pand		mm1, BMask		// Mask to get blue
		psllw		mm4, 3			// Align the red

		por			mm4, mm1		// Combine reds and blues in proper bit location

		packuswb	mm4, mm7		// | 0 | 0 | D1rrrrr000 | D1000bbbbb |

		por			mm4, mm5		// | 0 | 0 | D1rrrrrggg | D1gggbbbbb |

		movd		edx, mm4

		mov			[edi-2], dx

		test		ecx, ecx
		jz			Done			// just processed the last pixel of the row
		dec			ecx
		jmp			QuadAligned		// just processed the first pixel of the row

	Done:
		emms						// remove for optimizations, have calling function do emms
	}
}

/**************************************************************************\
* mmxAlphaConstOnly24
*
*   Optimized version of mmxAlphaConstOnly used when source and destination
*   are both 24bpp.
*
*           Dst = Dst + ConstAlpha * (Src - Dst)
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*
* Return Value:
*   
*   None
*
\**************************************************************************/

/**************************************************************************
  THIS FUNCTION DOES NOT DO ANY PARAMETER VALIDATION

  This function operates on 24 bit pixels (8 bits each for Red, Green, and Blue) in a row of a bitmap.
  It blends source and destination bitmaps, without alpha channels, using a constant alpha input.
  The function performs the following on each byte:

  tmp1 = Alpha(Src - Dst) + 128 + (Dst * 127)

  tmp2 = tmp1 shr 8 (move high byte to low byte)
  tmp2 = tmp2 + tmp1
  tmp2 = tmp2 shr 8 (move high byte to low byte)
  Dst = tmp2

  pDst is assumed to be aligned to a DWORD boundary when passed to this function.
  The loop structure is as follows:
  Step 1:
	Multiply width in pixels by 3 to get width in bytes.  Byte count is kept in ecx and eax.
	ecx is used as the loop counter.
  Step 2:
	Check pDst for QWORD alignment.  If aligned, do Step 3.  If unaligned, test to see if there
	are at least 4 bytes to do...if yes, do four bytes at once (Do1DWORD:) and then do Step 3.
	If no, there are only 3 bytes to do; so do them one at a time (OneToThreeBytesLeft:).
  Step 3:
  (QuadAligned:)
	pDst is QWORD aligned.  We want to do 8 bytes (1 quad) at once, so divide byte count by 8 to get loop
	count.  If ecx is 0 at this point, there are no more quads to do; so do 0 to 7 bytes (NoQuadsLeft:),
	in Step 5.
  Step 4:
  (Do1QUAD:)
	Perform the above function, using MMX instructions, on 8 bytes per pass of the loop.
  Step 5:
  (NoQuadsLeft:)
	Mask eax with 7 to get the byte count modulo 8, 0 to 7 bytes left.  Copy eax into ecx.  Test to see
	if there are at least 4 bytes to do...if yes, do four bytes at once (Do1DWORD:); if no, there are
	only 3 bytes to do, so do them one at a time (OneToThreeBytesLeft:).
  Step 6:
  (Do1DWORD:)
	Perform the above function, using MMX instructions, on 4 bytes.  Do Step 3 (QuadAligned:) to see if
	there are more bytes to do.
  Step 7:
  (OneToThreeBytesLeft:)
	Do one byte at a time.  This will happen if there are less than 4 bytes left to do.
**************************************************************************/
VOID
mmxAlphaConstOnly24(
    PALPHAPIX     pDst,
    PALPHAPIX     pSrc,
    LONG          Width,
    BLENDFUNCTION BlendFunction
    )
{
	static QWORD WordConst = 0x0080008000800080;
	static QWORD WordMask = 0xFF00FF00FF00FF00;
	static QWORD ByteConst = 0x0000000000000080;
	static QWORD ByteMask = 0x000000000000FF00;
	static QWORD CA;	// ConstAlpha in 4 words of a qword
    BYTE         ConstAlpha = BlendFunction.SourceConstantAlpha;
	
	_asm
	{
		mov			ecx, Width		// Make sure there is at least one pixel to do
		test		ecx, ecx
		jz			Done

		mov			esi, pSrc
		mov			edi, pDst

		xor			eax, eax
		mov			al, ConstAlpha
		movd		mm5, eax		// |		   |		   |		   |		CA |
		punpcklwd	mm5, mm5		// |		   |		   |		CA |		CA |
		punpcklwd	mm5, mm5		// |		CA |		CA |		CA |		CA |
		movq		CA, mm5

									// Step 1:
		lea			ecx, [2*ecx+ecx]// NumPixels * 3 bytes/pixel = NumBytes

									// Step 2:
		test		edi, 7			// Test first pixel for QWORD alignment
		jz			QuadAligned		// If unaligned,

		cmp			ecx, 4			//	test to see if there are 4 bytes to do
		jae			Do1DWORD		//	if yes, do 4 bytes
		jmp			OneToThreeBytesLeft// if no, do 1 to 3 bytes

	QuadAligned:					// Step 3:
		mov			eax, ecx		// Save the width in eax for later (see NoQuadsLeft:)
		shr			ecx, 3			// Want to do 8 bytes at once, so divide 
									//		byte count by 8 to get loop count
		test		ecx, ecx		// Make sure there is at least 1 QUAD (8 bytes) to do
		jz			NoQuadsLeft		// If we take this jump, there are 0 to 7 bytes left

	Do1QUAD:						// Step 4:
		movq		mm0, [edi]		// | D8 | D7 | D6 | D5 | D4 | D3 | D2 | D1 |
		pxor		mm7, mm7							
														
		movq		mm1, [esi]		// | S8 | S7 | S6 | S5 | S4 | S3 | S2 | S1 |
		movq		mm2, mm0		// | D8 | D7 | D6 | D5 | D4 | D3 | D2 | D1 |
														
		movq		mm3, mm1		// | S8 | S7 | S6 | S5 | S4 | S3 | S2 | S1 |
		punpcklbw	mm0, mm7		// |	  D4 |      D3 |      D2 |	    D1 |
													
		movq		mm4, mm0		// |	  D4 |      D3 |      D2 |	    D1 |
		punpcklbw	mm1, mm7		// |	  S4 |      S3 |      S2 |	    S1 |
													
		punpckhbw	mm2, mm7		// |	  D8 |      D7 |      D6 |	    D5 |
		psubw		mm1, mm0		// |   S4-D4 |   S3-D3 |   S2-D2 |   S1-D1 |
													
		pmullw		mm1, CA			// |   CA4   |   CA3   |   CA2   |   CA1   |
		punpckhbw	mm3, mm7		// |	  S8 |      S7 |      S6 |	    S5 |
													
		psubw		mm3, mm2		// |   S8-D8 |   S7-D7 |   S6-D6 |   S5-D5 |
		movq		mm6, mm2		// |	  D8 |      D7 |      D6 |	    D5 |
													
		pmullw		mm3, CA			// |   CA8   |   CA7   |   CA6   |   CA5   |
		psllw		mm4, 8			// | D4*128  | D3*128  | D2*128  | D1*128  |
													
		psllw		mm6, 8			// | D8*128  | D7*128  | D6*128  | D5*128  |
		psubw		mm4, mm0		// | D4*127  | D3*127  | D2*127  | D1*127  |

		paddw		mm4, WordConst	// | D4*127+C| D3*127+C| D2*127+C| D1*127+C|
		psubw		mm6, mm2		// | D8*127  | D7*127  | D6*127  | D5*127  |

		paddw		mm6, WordConst	// | D8*127+C| D7*127+C| D6*127+C| D5*127+C|
		paddw		mm4, mm1		// tmp1 = Alpha(Src1 - Dst1) + 128 + (Dst1 * 127)

		paddw		mm6, mm3		// tmp2 = Alpha(Src2 - Dst2) + 128 + (Dst2 * 127)
		movq		mm3, mm4		// tmp1 = Alpha(Src1 - Dst1) + 128 + (Dst1 * 127)

		movq		mm5, mm6		// tmp2 = Alpha(Src2 - Dst2) + 128 + (Dst2 * 127)
		psrlw		mm4, 8			// tmp3 = tmp1 shr 8 (move high byte to low byte)

		psrlw		mm6, 8			// tmp4 = tmp2 shr 8 (move high byte to low byte)
		paddw		mm4, mm3		// tmp3 = tmp3 + tmp1

		paddw		mm6, mm5		// tmp4 = tmp4 + tmp2
		psrlw		mm4, 8			// tmp3 = tmp3 shr 8 (move high byte to low byte)

		psrlw		mm6, 8			// tmp4 = tmp4 shr 8 (move high byte to low byte)
		add			edi, 8			//	pDst++;

		packuswb	mm4, mm6		// | D8 | D7 | D6 | D5 | D4 | D3 | D2 | D1 |
		add			esi, 8			//	pSrc++;

		movq		[edi-8], mm4

		dec			ecx
		jnz			Do1QUAD

	NoQuadsLeft:						// Step 5:
		// This tests for 0 to 7 bytes left in row - eax contains initial byte count
		and			eax, 7				// 0 to 7 bytes left to do
		jz			Done				
		cmp			eax, 4				// Test to see if there are 4 bytes to do
		mov			ecx, eax			
		jae			Do1DWORD			//	if yes, do 4 bytes
		jmp			OneToThreeBytesLeft	//  if no, do 1 to 3 bytes

									// Step 6:
	Do1DWORD:						// make as a macro if used in asm file
		movd		mm0, [edi]		// |  0 |  0 |  0 |  0 | D4 | D3 | D2 | D1 |
		pxor		mm7, mm7		
										
		movd		mm1, [esi]		// |  0 |  0 |  0 |  0 | S4 | S3 | S2 | S1 |
		punpcklbw	mm0, mm7		// |	  D4 |      D3 |      D2 |	    D1 |
									
		movq		mm4, mm0		// |	  D4 |      D3 |      D2 |	    D1 |
		punpcklbw	mm1, mm7		// |	  S4 |      S3 |      S2 |	    S1 |
									
		psllw		mm4, 8			// | D4*128 | D3*128  | D2*128  | D1*128  |
		psubw		mm1, mm0		// |  S4-D4 |  S3-D3  |  S2-D2  |  S1-D1  |
									
		pmullw		mm1, CA			// |   CA4  |   CA3   |   CA2   |   CA1   |
		psubw		mm4, mm0		// | D4*127 | D3*127  | D2*127  | D1*127  |

		paddw		mm4, WordConst	// | D4*127+C| D3*127+C| D2*127+C| D1*127+C|

		paddw		mm4, mm1		// tmp1 = Alpha(Src1 - Dst1) + 128 + (Dst1 * 127)
									
		movq		mm3, mm4		// tmp1 = Alpha(Src1 - Dst1) + 128 + (Dst1 * 127)

		psrlw		mm4, 8			// tmp2 = tmp1 shr 8 (move high byte to low byte)
									
		paddw		mm4, mm3		// tmp2 = tmp2 + tmp1

		psrlw		mm4, 8			// tmp2 = tmp2 shr 8 (move high byte to low byte)
		add			edi, 4			//	pDst++;

		packuswb	mm4, mm4		// | D4 | D3 | D2 | D1 | D4 | D3 | D2 | D1 |
		add			esi, 4			//	pSrc++;

		movd		[edi-4], mm4

		sub			ecx, 4			// Just did 4 bytes at the beginning or end of a scan line
		jmp			QuadAligned		// Jump to QuadAligned to determine if there are more bytes to do

	OneToThreeBytesLeft:			// Step 7:

		movzx   edx,BYTE PTR[edi]   // edx = Dest Byte
		movzx   ebx,BYTE PTR[esi]   // ebx = Src Byte

		movd		mm0, edx		// | 0 | 0 | 0 | 0 | 0 | 0 | 0 | Db |
		pxor		mm7, mm7		
										
		movd		mm1, ebx		// | 0 | 0 | 0 | 0 | 0 | 0 | 0 | Sb |
		movq		mm2, mm0		// | 0 | 0 | 0 | 0 | 0 | 0 | 0 | Db |
										
		psllw		mm2, 8			// | 0 | 0 | 0 | 0 | 0 | 0 | Db|  0 |
		psubw		mm1, mm0		// | 0 | 0 | 0 | Sb-Db |

		pmullw		mm1, CA			// | 0 | 0 | 0 | CAb   |
		psubw		mm2, mm0		// | 0 | 0 | 0 | Db*127|

		paddw		mm2, ByteConst	// | 0 | 0 | 0 |Db*127+128|

		paddw		mm1, mm2		// tmp1 = Alpha(Src1 - Dst1) + 128 + (Dst1 * 127)

		movq		mm2, mm1		// tmp1 = Alpha(Src1 - Dst1) + 128 + (Dst1 * 127)

		psrlw		mm2, 8			// tmp2 = tmp2 shr 8

		paddw		mm2, mm1		// tmp2 = tmp2 + tmp1

		psrlw		mm2, 8			// tmp2 = tmp2 shr 8

		movd		edx, mm2

		mov			BYTE PTR[edi], dl

		inc			edi
		inc			esi

		dec			ecx
		jnz			OneToThreeBytesLeft

	Done:
		emms						// remove for optimizations, have calling function do emms
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\bbddi.cxx ===
/******************************Public*Routine******************************\
* bbddi.cxx
*
* This contains the bitblt simulations code.
*
* Copyright (c) 1993-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* EngBitBlt
*
* DDI entry point.  Blts to a engine managed surface.
*
* History:
*  16-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
EngBitBlt(
    SURFOBJ    *psoDst,                  // Target surface
    SURFOBJ    *psoSrc,                  // Source surface
    SURFOBJ    *psoMask,                 // Mask
    CLIPOBJ    *pco,                     // Clip through this
    XLATEOBJ   *pxlo,                    // Color translation
    RECTL      *prclDst,                 // Target offset and extent
    POINTL     *pptlSrc,                 // Source offset
    POINTL     *pptlMask,                // Mask offset
    BRUSHOBJ   *pdbrush,                 // Brush data (from cbRealizeBrush)
    POINTL     *pptlBrush,               // Brush offset (origin)
    ROP4        rop4                     // Raster operation
    )
{

    //
    // Validate the ROP
    //

    ASSERTGDI(psoDst != (SURFOBJ *) NULL, "NULL target passed in\n");
    ASSERTGDI(prclDst != (PRECTL) NULL, "Target range\n");
    ASSERTGDI(prclDst->left <= prclDst->right, "ERROR Target width not ordered\n");
    ASSERTGDI(prclDst->top <= prclDst->bottom, "ERROR Target height not ordered\n");
    ASSERTGDI(!(ROP4NEEDPAT(rop4) && (pdbrush == (BRUSHOBJ *) NULL)), "EngBitBlt: Pattern\n");
    ASSERTGDI(!(ROP4NEEDPAT(rop4) && (pdbrush->iSolidColor == 0xFFFFFFFF) && (pptlBrush == (PPOINTL) NULL)), "EngBitBlt: Pattern offset\n");
    ASSERTGDI(!((psoSrc == (SURFOBJ *) NULL) && ROP4NEEDSRC(rop4)), "EngBitBlt: Source\n");
    ASSERTGDI(!((pptlSrc == (PPOINTL) NULL) && ROP4NEEDSRC(rop4)), "EngBitBlt: Source offset\n");

    PSURFACE pSurfDst  = SURFOBJ_TO_SURFACE_NOT_NULL(psoDst);
    PSURFACE pSurfSrc  = SURFOBJ_TO_SURFACE(psoSrc);
    PSURFACE pSurfMask = SURFOBJ_TO_SURFACE(psoMask);

    RECTL rclSrc;

    ASSERTGDI(pSurfDst->iFormat() != BMF_JPEG, "EngBitBlt: dst BMF_JPEG not supported\n");
    ASSERTGDI(pSurfDst->iFormat() != BMF_PNG, "EngBitBlt: dst BMF_PNG not supported\n");
    ASSERTGDI(!(ROP4NEEDSRC(rop4) && (pSurfSrc->iFormat() == BMF_JPEG)), "EngBitBlt: src BMF_JPEG not supported\n");
    ASSERTGDI(!(ROP4NEEDSRC(rop4) && (pSurfSrc->iFormat() == BMF_PNG)), "EngBitBlt: src BMF_PNG not supported\n");

    if (psoDst->iType == STYPE_BITMAP)
    {
        //
        // For profiling purposes, set a flag in the PDEV to indicate that the
        // driver punted this call.
        //

        {
            PDEVOBJ po(pSurfDst->hdev());
            if (po.bValid())
            {
                po.vDriverPuntedCall(TRUE);
            }
        }

        //
        // Synchronize with the device driver before touching the device surface.
        //

        {
            PDEVOBJ po(pSurfDst->hdev());
            po.vSync(psoDst,NULL, 0);
        }

        //
        // inc surface uniq for all cases
        //

        INC_SURF_UNIQ(pSurfDst);

        //
        // Quick check for dst and pattern rops, and source copy
        //

        switch(rop4)
        {
        case 0x00000000:                        // DDx      (BLACKNESS)
        case 0x0000FFFF:                        // DDxn     (WHITENESS)

            vDIBSolidBlt(pSurfDst,
                         prclDst,
                         pco,
                         ((rop4 != 0) ? ~0 : 0),
                         0);
            return(TRUE);

        case 0x0000F0F0:                        // P        (PATCOPY)
        case 0x00000F0F:                        // Pn       (NOTPATCOPY)

            if (pdbrush->iSolidColor != 0xFFFFFFFF)
            {
                vDIBSolidBlt(pSurfDst,
                             prclDst,
                             pco,
                             (rop4 & 0x00000001) ? ~(pdbrush->iSolidColor) : pdbrush->iSolidColor,
                             0);

                return(TRUE);
            }

            if ((pSurfDst->iFormat() == BMF_8BPP) && (rop4 == 0x0000F0F0))
            {

                //
                // We only support 8x8 DIB8 patterns with SRCCOPY right now
                //

                if (pvGetEngRbrush(pdbrush))    // Can we use this brush?
                {
                    if ((((EBRUSHOBJ *) pdbrush)->pengbrush()->cxPat == 8) &&
                        (((EBRUSHOBJ *) pdbrush)->pengbrush()->cyPat == 8))

                    {
                        vDIBPatBltSrccopy8x8(pSurfDst,
                                             pco,
                                             prclDst,
                                             pdbrush,
                                             pptlBrush,
                                             vPatCpyRect8_8x8);

                        return(TRUE);
                    }
                }
            }

            if (pSurfDst->iFormat() >= BMF_8BPP)
            {
                if (pvGetEngRbrush(pdbrush))    // Can we use this brush?
                {
                    if (((EBRUSHOBJ *) pdbrush)->pengbrush()->cxPat >= 4)
                    {
                        vDIBPatBlt(pSurfDst,
                                   pco,
                                   prclDst,
                                   pdbrush,
                                   pptlBrush,
                                   (rop4 == 0x0000F0F0) ? DPA_PATCOPY : DPA_PATNOT);

                        return(TRUE);
                    }
                }
            }
            else if ((pSurfDst->iFormat() == BMF_4BPP) &&
                        (rop4 == 0x0000F0F0))
            {

                //
                // We only support 8x8 DIB4 patterns with SRCCOPY right now
                //

                if (pvGetEngRbrush(pdbrush))    // Can we use this brush?
                {
                    if ((((EBRUSHOBJ *) pdbrush)->pengbrush()->cxPat == 8) &&
                        (((EBRUSHOBJ *) pdbrush)->pengbrush()->cyPat == 8))
                    {
                        ASSERTGDI(((EBRUSHOBJ *) pdbrush)->pengbrush()->lDeltaPat == 4,
                            "BBDDI.CXX: lDeltaPat != 4");

                        vDIBPatBltSrccopy8x8(pSurfDst,
                                             pco,
                                             prclDst,
                                             pdbrush,
                                             pptlBrush,
                                             vPatCpyRect4_8x8);

                        return(TRUE);
                    }
                }
            }
            else if ((pSurfDst->iFormat() == BMF_1BPP) &&
                        (rop4 == 0x0000F0F0))
            {
                //
                // We support 8x8 and 6x6 DIB1 patterns with SRCCOPY
                //

                if (pvGetEngRbrush(pdbrush))     // Can we use this brush?
                {
                    //
                    // Look for 8x8 patterns
                    //

                    if ((((EBRUSHOBJ *) pdbrush)->pengbrush()->cxPat == 8) &&
                        (((EBRUSHOBJ *) pdbrush)->pengbrush()->cyPat == 8) )
                    {
                        ASSERTGDI(((EBRUSHOBJ *) pdbrush)->pengbrush()->lDeltaPat == 4,
                            "BBDDI.CXX: lDeltaPat != 4");

                        vDIBPatBltSrccopy8x8(pSurfDst,
                                              pco,
                                              prclDst,
                                              pdbrush,
                                              pptlBrush,
                                              vPatCpyRect1_8x8 );

                        return(TRUE);
                    }

                    //
                    // Look for 6x6 patterns
                    //

                    if ((((EBRUSHOBJ *)pdbrush)->pengbrush()->cxPat == 6) &&
                        (((EBRUSHOBJ *)pdbrush)->pengbrush()->cyPat == 6) )
                    {


                        ASSERTGDI(((EBRUSHOBJ *) pdbrush)->pengbrush()->lDeltaPat == 8,
                            "BBDDI.CXX: lDeltaPat != 8");

                        vDIBnPatBltSrccopy6x6(pSurfDst,
                                              pco,
                                              prclDst,
                                              pdbrush,
                                              pptlBrush,
                                              vPatCpyRect1_6x6 );

                        return(TRUE);
                    }
                }
            }

            break;

        case 0x00005A5A:                        // DPx

            if (pdbrush->iSolidColor != 0xFFFFFFFF)
            {
                vDIBSolidBlt(pSurfDst,
                             prclDst,
                             pco,
                             pdbrush->iSolidColor,
                             1);

                return(TRUE);
            }

            if (pSurfDst->iFormat() >= BMF_8BPP)
            {
                if (pvGetEngRbrush(pdbrush))    // Can we use this brush?
                {
                    if (((EBRUSHOBJ *) pdbrush)->pengbrush()->cxPat >= 4)
                    {
                        vDIBPatBlt(pSurfDst,
                                   pco,
                                   prclDst,
                                   pdbrush,
                                   pptlBrush,
                                   DPA_PATXOR);

                        return(TRUE);
                    }
                }
            }

            break;

        //
        // Dn degenerates to DPx with a pattern of all ones (0xFFFFFFFF)
        //

        case 0x00005555:                        // Dn       (DSTINVERT)

            vDIBSolidBlt(pSurfDst,
                         prclDst,
                         pco,
                         (ULONG)~0,
                         1);
            return(TRUE);

        //
        // 0xCCAA with a mask surface of NULL really means EngTransparentBlt
        // or EngDrawStream.
        // We do this as an optimization; see the tops of EngTransparentBlt
        // and EngDrawStream for details.
        //

        case 0x0000CCAA:                        // Transparent blt or DrawStream
                                                

            if (psoMask == NULL)
            {
                if(pdbrush->pvRbrush == NULL)
                {
                    rclSrc.left   = pptlSrc->x;
                    rclSrc.right  = pptlSrc->x + (prclDst->right - prclDst->left);
                    rclSrc.top    = pptlSrc->y;
                    rclSrc.bottom = pptlSrc->y + (prclDst->bottom - prclDst->top);
    
                    return(EngTransparentBlt(psoDst,
                                             psoSrc,
                                             pco,
                                             pxlo,
                                             prclDst,
                                             &rclSrc,
                                             pdbrush->iSolidColor,
                                             TRUE));
                }
                else
                {
                    PDRAWSTREAMINFO pdsi = (PDRAWSTREAMINFO) pdbrush->pvRbrush;

                    pdsi->bCalledFromBitBlt = TRUE;

                    return(EngDrawStream(psoDst, psoSrc, pco, pxlo, prclDst,
                                         pdsi->pptlDstOffset,
                                         pdsi->ulStreamLength,
                                         pdsi->pvStream,
                                         (DSSTATE*) pdsi));
                }
            }
            break;

        //
        // We special case source copy since it must be one of the two following cases:
        //  a) DIB to DIB, which will just call EngCopyBits.
        //  b) Device format to DIB, which will just call DrvCopyBits.
        //
        // We also expect source copy to occur A LOT!
        //

        case 0x0000CCCC:

            if (pSurfSrc->iType() == STYPE_BITMAP)
            {
                return(EngCopyBits(psoDst,
                                   psoSrc,
                                   pco,
                                   pxlo,
                                   prclDst,
                                   pptlSrc));
            }
            else
            {
                PDEVOBJ pdoSrc(pSurfSrc->hdev());

                return((*PPFNDRV(pdoSrc,CopyBits)) (psoDst,
                                                    psoSrc,
                                                    pco,
                                                    pxlo,
                                                    prclDst,
                                                    pptlSrc));
            }
        }

        //
        // Synchronize with the device driver before touching the device surface.
        //

        if ((psoSrc != (SURFOBJ *) NULL))
        {
            PDEVOBJ po(pSurfSrc->hdev());
            po.vSync(psoSrc, NULL, 0);
        }

        //
        // We have to create an empty DIB incase DrvCopyBits needs to be performed.
        // We also have to have a POINTL for the final blt for use as the source org.
        //

        SURFMEM SurfDimo;

        //
        // Handle the Device ==> DIB conversion if required
        //

        if (ROP4NEEDSRC(rop4) && (pSurfSrc->iType() != STYPE_BITMAP))
        {
            PDEVOBJ pdoSrc(pSurfSrc->hdev());

            //
            // Allocate an intermediate DIB for a source.
            //

            ERECTL erclTmp(0L,
                           0L,
                           prclDst->right - prclDst->left,
                           prclDst->bottom - prclDst->top);

            DEVBITMAPINFO   dbmi;
            dbmi.iFormat    = pSurfDst->iFormat();
            dbmi.cxBitmap   = erclTmp.right;
            dbmi.cyBitmap   = erclTmp.bottom;
            dbmi.hpal       = 0;
            dbmi.fl         = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;

            if (!SurfDimo.bCreateDIB(&dbmi, NULL))
            {
                WARNING("bCreateDIB failed in EngBitBlt\n");
                return(FALSE);
            }

            (*PPFNDRV(pdoSrc,CopyBits)) ( (SURFOBJ *) SurfDimo.pSurfobj(),
                                          psoSrc,
                                          (CLIPOBJ *) NULL,
                                          pxlo,
                                          (PRECTL) &erclTmp,
                                          pptlSrc);


            //
            // Make psoSrc and pptlSrc point to the correct thing.
            //

            pptlSrc  = (POINTL *) &gptl00;
            pSurfSrc = SurfDimo.ps;

            //
            // Color translation has already been performed, so make
            // the XLATE an identity.
            //

            pxlo = &xloIdent;
        }

        //
        // Call BltLnk to perform the ROP
        //

        if (!BltLnk(pSurfDst,
                    pSurfSrc,
                    pSurfMask,
                    (ECLIPOBJ *)  pco,
                    (XLATE *) pxlo,
                    prclDst,
                    pptlSrc,
                    pptlMask,
                    pdbrush,
                    pptlBrush,
                    rop4)
            )
        {
            WARNING1("BltLnk Returns FALSE\n");
        }
    }
    else
    {

        //
        // We have to do simulations on a device surface
        //

        return(SimBitBlt(psoDst,psoSrc,psoMask,
                         pco,pxlo,
                         prclDst,pptlSrc,pptlMask,
                         pdbrush,pptlBrush,rop4, NULL));
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* EngEraseSurface
*
* Asks GDI to erase the surface.  The rcl will be filled with
* iColor.
*
* History:
*  02-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
EngEraseSurface(
    SURFOBJ *pso,
    PRECTL   prcl,
    ULONG    iColor
    )
{

    PSURFACE pSurf = (SURFACE *)(SURFOBJ_TO_SURFACE(pso));

    if(pSurf == 0)
        return FALSE;

    ASSERTGDI(prcl != (PRECTL) NULL, "ERROR EngEraseSurface1");
    ASSERTGDI(prcl->left >= 0, "ERROR EngEraseSurface2");
    ASSERTGDI(prcl->top >= 0, "ERROR EngEraseSurface3");
    ASSERTGDI(prcl->right <= pSurf->sizl().cx, "ERROR EngEraseSurface4");
    ASSERTGDI(prcl->bottom <= pSurf->sizl().cy, "ERROR EngEraseSurface5");

    //
    // Synchronize with the device driver before touching the device surface.
    //
    {
        PDEVOBJ po(pSurf->hdev());
        po.vSync(pso,NULL, 0);
    }

    vDIBSolidBlt(pSurf, prcl, (CLIPOBJ *) NULL, iColor, 0);
    return(TRUE);
}

/******************************Public*Routine******************************\
* SimBitBlt
*
* The engine sends EngBitBlt here if a DEVICE surface is passed as psoTrg
*
* History:
*  23-Feb-1994 -by-  Eric Kutter [erick]
* Made it callable from other functions - allow device to device blts.
*
*  09-Sep-1992 -by- Donald Sidoroff [donalds]
* Made it callable from EngBitBlt only.
*
*  07-Sep-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
SimBitBlt(
    SURFOBJ    *psoDst,                 // Target surface
    SURFOBJ    *psoSrc,                 // Source surface
    SURFOBJ    *psoMask,                // Mask
    CLIPOBJ    *pco,                    // Clip through this
    XLATEOBJ   *pxlo,                   // Color translation
    RECTL      *prclDst,                // Target offset and extent
    POINTL     *pptlSrc,                // Source offset
    POINTL     *pptlMask,               // Mask offset
    BRUSHOBJ   *pdbrush,                // Brush data (from cbRealizeBrush)
    POINTL     *pptlBrush,              // Brush offset (origin)
    ROP4        rop4,                   // Raster operation
    PVOID       pdlo                    // for unlock if necessary
    )
{
    BOOL bNeedSrc = ROP4NEEDSRC(rop4);

    PSURFACE pSurfDst = (SURFACE *)(SURFOBJ_TO_SURFACE(psoDst));
    PSURFACE pSurfSrc = (SURFACE *)(SURFOBJ_TO_SURFACE(psoSrc));

    PDEVOBJ pdoDst(pSurfDst->hdev());

    ASSERTGDI(pdoDst.bValid(), "EngPuntBlt poDst.bValid");

    //
    // if source and destination are both engine managed
    // bitmaps, then BitBlt directly
    //

    if (
         (pSurfDst->iType() == STYPE_BITMAP) &&
         ((!bNeedSrc) || (pSurfSrc->iType() == STYPE_BITMAP)) &&
         (psoMask == NULL)
       )
    {
        BOOL bReturn;

        if (!pdoDst.bUMPD())
        {
            bReturn = (*(pSurfDst->pfnBitBlt())) (
                  psoDst,
                  psoSrc,
                  psoMask,
                  pco,
                  pxlo,
                  prclDst,
                  pptlSrc,
                  pptlMask,
                  pdbrush,
                  pptlBrush,
                  rop4);
        }
        else
        {
            bReturn = EngBitBlt(
                  psoDst,
                  psoSrc,
                  psoMask,
                  pco,
                  pxlo,
                  prclDst,
                  pptlSrc,
                  pptlMask,
                  pdbrush,
                  pptlBrush,
                  rop4);
        }
        return(bReturn);
    }

    //
    // For profiling purposes, set a flag in the PDEV to indicate that the
    // driver punted this call.
    //
    {
        PDEVOBJ po(pSurfDst->hdev());
        if (po.bValid())
        {
            po.vDriverPuntedCall(TRUE);
        }
    }

    // Get the bounds of the destination rectangle

    RECTL rclDstBounds;

    if( pSurfDst->iType() == STYPE_DEVICE &&
        pdoDst.bValid() && pdoDst.bMetaDriver())
    {
        rclDstBounds.left   = pdoDst.pptlOrigin()->x;
        rclDstBounds.top    = pdoDst.pptlOrigin()->y;
        rclDstBounds.right  = pdoDst.pptlOrigin()->x + pSurfDst->sizl().cx;
        rclDstBounds.bottom = pdoDst.pptlOrigin()->y + pSurfDst->sizl().cy;
    }
    else
    {
        rclDstBounds.left   = 0;
        rclDstBounds.top    = 0;
        rclDstBounds.right  = pSurfDst->sizl().cx;
        rclDstBounds.bottom = pSurfDst->sizl().cy;
    }


    //
    // Set up new rectangle clipped to destination surface.  Clip source
    // pointl and mask pointl accordingly.
    //

    RECTL rclReduced = *prclDst;
    POINTL ptlSrc;
    POINTL ptlMask;

    if (bNeedSrc)
    {
        ptlSrc = *pptlSrc;
    }

    if (psoMask != NULL)
    {
        ptlMask = *pptlMask;
    }

    if (rclReduced.top < rclDstBounds.top)
    {
        ptlSrc.y += (rclDstBounds.top-rclReduced.top);
        ptlMask.y += (rclDstBounds.top-rclReduced.top);
        rclReduced.top = rclDstBounds.top;
    }

    if (rclReduced.left < rclDstBounds.left)
    {
        ptlSrc.x += (rclDstBounds.left-rclReduced.left);
        ptlMask.x += (rclDstBounds.left-rclReduced.left);
        rclReduced.left = rclDstBounds.left;
    }

    if (rclReduced.bottom > rclDstBounds.bottom)
    {
        rclReduced.bottom = rclDstBounds.bottom;
    }

    if (rclReduced.right > rclDstBounds.right)
    {
        rclReduced.right = rclDstBounds.right;
    }

    if( rclReduced.top >= rclReduced.bottom ||
        rclReduced.left >= rclReduced.right )
    {
        // Destination rectangle is outside of the
        // destination surface
        return TRUE;
    }

    //
    // Ok we clipped everything to our reduced rectangle, now use the clipped offsets.
    //

    prclDst = &rclReduced;
    pptlSrc = &ptlSrc;
    pptlMask = &ptlMask;


    //
    // Set up our temporary DIB rectangle to blt to.
    //

    ERECTL erclDst(0, 0, prclDst->right - prclDst->left,
                         prclDst->bottom - prclDst->top);

    //
    // iDitherFormat must match destination format
    //

    if (pSurfDst->iFormat() != pdoDst.iDitherFormat())
    {
        WARNING("SimBitBlt: pSurfDst->iFormat != pdoDst.iDitherFormat\n");
        return(FALSE);
    }

    //
    // We have to create an empty DIB incase DrvCopyBits needs to be performed.
    // We also have to have a POINTL for the final blt for use as the source org.
    //

    SURFMEM SurfDimoSrc;

    //
    // Handle the Device ==> DIB conversion if required
    //

    if (bNeedSrc && (pSurfSrc->iType() != STYPE_BITMAP))
    {

        PDEVOBJ pdoSrc(pSurfSrc->hdev());

        //
        // Allocate an intermediate DIB for a source.
        //

        DEVBITMAPINFO dbmiSrc;
        dbmiSrc.iFormat    = pdoDst.iDitherFormat();
        dbmiSrc.cxBitmap   = erclDst.right;
        dbmiSrc.cyBitmap   = erclDst.bottom;
        dbmiSrc.hpal       = 0;
        dbmiSrc.fl         = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;

        if (!SurfDimoSrc.bCreateDIB(&dbmiSrc, NULL))
        {
            WARNING("Failed dimoSrc memory alloc in EngPuntBlt\n");
            return(FALSE);
        }


        (*PPFNGET(pdoSrc,CopyBits,pSurfSrc->flags())) (SurfDimoSrc.pSurfobj(),
                                                       psoSrc,
                                                       (CLIPOBJ *) NULL,
                                                       pxlo,
                                                       (PRECTL) &erclDst,
                                                       pptlSrc);

        //
        // Make psoSrc and pptlSrc point to the correct thing.
        //

        pptlSrc = &gptl00;
        psoSrc  = SurfDimoSrc.pSurfobj();

        //
        // Color translation has already been performed, so make
        // the XLATEOBJ an identity.
        //

        pxlo = &xloIdent;
    }


    DEVBITMAPINFO dbmiDst;
    dbmiDst.iFormat    = pdoDst.iDitherFormat();
    dbmiDst.cxBitmap   = erclDst.right;
    dbmiDst.cyBitmap   = erclDst.bottom;
    dbmiDst.hpal       = 0;
    dbmiDst.fl         = pSurfDst->bUMPD() ? UMPD_SURFACE : 0;

    SURFMEM SurfDimoDst;

    SurfDimoDst.bCreateDIB(&dbmiDst, NULL);

    if (!SurfDimoDst.bValid())
    {
        return(FALSE);
    }

    POINTL ptlDst;
    ptlDst.x = prclDst->left;
    ptlDst.y = prclDst->top;

    POINTL ptlBrush;

    if (pptlBrush != (POINTL *) NULL)
    {
        ptlBrush.x = pptlBrush->x - prclDst->left;
        ptlBrush.y = pptlBrush->y - prclDst->top;
    }

    //
    // if we are going out to the user mode printer driver
    // unlock the DEVLOCKBLTOBJ.  Only the src might be locked
    // and from here we are only going to deal with the temp src dib
    // so it's safe to unlock here.
    //

    if (pdoDst.bPrinter() && pdlo)
    {
       ((DEVLOCKBLTOBJ *)pdlo)->vUnLock();
    }

    // WINBUG #206475 bhouse 10-18-2000 Old potential perf bug
    // We should only copy the destination if the ROP requires
    // destination data.

    (*PPFNGET(pdoDst,CopyBits,pSurfDst->flags())) (SurfDimoDst.pSurfobj(),
                                                   psoDst,
                                                   (CLIPOBJ *) NULL,
                                                   &xloIdent,
                                                   &erclDst,
                                                   &ptlDst);

    ASSERTGDI(SurfDimoDst.ps->iType() == STYPE_BITMAP, "ERROR dimoDst.iType 1");

    //
    // Call off to BitBlt, if it fails who cares.
    //

    EngBitBlt(SurfDimoDst.pSurfobj(),
              psoSrc,
              psoMask,
              (ECLIPOBJ *)  NULL,
              pxlo,
              &erclDst,
              pptlSrc,
              pptlMask,
              pdbrush,
              &ptlBrush,
              rop4);

    //
    // Inc output surface uniqueness
    //

    INC_SURF_UNIQ(pSurfDst);

    return((*PPFNGET(pdoDst,CopyBits,pSurfDst->flags())) (
                                            psoDst,
                                            SurfDimoDst.pSurfobj(),
                                            pco,
                                            &xloIdent,
                                            prclDst,
                                            &gptl00));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\atmstub.h ===
/******************************Module*Header*******************************\
* Module Name: atmstub.h
*
* Created: 23-Apr-1990
* Author: Xudong Wu [tessiew]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

DHPDEV APIENTRY atmfdEnablePDEV(
    DEVMODEW *pdm,
    LPWSTR    pwszLogAddress,
    ULONG     cPat,
    HSURF    *phsurfPatterns,
    ULONG     cjCaps,
    ULONG    *pdevcaps,
    ULONG     cjDevInfo,
    DEVINFO  *pdi,
    HDEV      hdev,
    LPWSTR    pwszDeviceName,
    HANDLE    hDriver
    );

VOID APIENTRY atmfdCompletePDEV(
    DHPDEV dhpdev,
    HDEV hdev
    );

VOID APIENTRY atmfdDisablePDEV(
    DHPDEV dhpdev
    );


ULONG_PTR APIENTRY atmfdLoadFontFile(
    ULONG     cFiles,
    ULONG_PTR  *piFile,
    PVOID     *ppvView,
    ULONG     *pcjView,
    DESIGNVECTOR *pdv,
    ULONG     ulLangID,
    ULONG     ulFastCheckSum
    );

LONG APIENTRY atmfdQueryFontFile(
    ULONG_PTR   iFile,
    ULONG      ulMode,
    ULONG      cjBuf,
    ULONG      *pulBuf
    );

BOOL APIENTRY atmfdUnloadFontFile(
    ULONG_PTR   iFile
    );

PIFIMETRICS APIENTRY atmfdQueryFont(
    DHPDEV    dhpdev,
    ULONG_PTR  iFile,
    ULONG     iFace,
    ULONG_PTR *pid
    );

LONG APIENTRY atmfdQueryFontCaps(
    ULONG   culCaps,
    ULONG  *pulCaps
    );

PVOID APIENTRY atmfdQueryFontTree(
    DHPDEV    dhpdev,
    ULONG_PTR  iFile,
    ULONG     iFace,
    ULONG     iMode,
    ULONG_PTR *pid
    );

LONG APIENTRY atmfdQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    );

BOOL APIENTRY atmfdQueryAdvanceWidths(
    DHPDEV   dhpdev,
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    PVOID    pvWidths,
    ULONG    cGlyphs
    );

LONG APIENTRY atmfdQueryTrueTypeOutline(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    HGLYPH      hglyph,
    BOOL        bMetricsOnly,
    GLYPHDATA  *pgldt,
    ULONG       cjBuf,
    TTPOLYGONHEADER *ppoly
    );

LONG APIENTRY atmfdQueryTrueTypeTable(
    ULONG_PTR   iFile,
    ULONG      ulFont,
    ULONG      ulTag,
    PTRDIFF    dpStart,
    ULONG      cjBuf,
    BYTE       *pjBuf,
    PBYTE      *ppjTable,
    ULONG      *pcjTable
    );

PFD_GLYPHATTR atmfdQueryGlyphAttrs (
    FONTOBJ *pfo,
    ULONG   iMode
    );

PVOID APIENTRY atmfdGetTrueTypeFile (
    ULONG_PTR   iFile,
    ULONG      *pcj
    );

ULONG APIENTRY atmfdFontManagement(
    SURFOBJ *pso,
    FONTOBJ *pfo,
    ULONG    iMode,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut
    );

VOID APIENTRY atmfdDestroyFont(
    FONTOBJ *pfo
    );

VOID APIENTRY atmfdFree(
    PVOID   pv,
    ULONG_PTR id
    );

ULONG APIENTRY atmfdEscape(
    SURFOBJ *pso,
    ULONG    iEsc,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\bltlnkfn.cxx ===
/******************************Module*Header*******************************\
* Module Name:
*
*       bltlnkfnc.cxx
*
* Abstract
*
*       This module implements 2 operand ROP functions used by bltlnk
*       as well as the routines needed to:
*
*           1: Perform masked bitblt operations
*           2: Perform color expansion
*           3: Read and expand patterns
*
* Author:
*
*   Mark Enstrom    (marke) 9-27-93
*
* Copyright (c) 1993-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

extern ULONG DbgBltLnk;
ULONG  DbgMask = 0;
ULONG  DbgPat  = 0;

BYTE    StartMask[] = {0xff,0x7f,0x3f,0x1f,0x0f,0x07,0x03,0x01,0x00};
BYTE    EndMask[]   = {0x00,0x80,0xc0,0xe0,0xf0,0xf8,0xfc,0xfe,0xff};

//
//
// the following routins are the 16 ROP 2 functions generated
// by a combination of two variables:
//
//      ROP             Function
// -----------------------------
//      0                0
//      1               ~(S | D)
//      2               ~S &  D
//      3               ~S
//      4                S & ~D
//      5                    ~D
//      6                S ^  D
//      7               ~S | ~D
//      8                S &  D
//      9               ~(S ^ D)
//      A                     D
//      B               ~S |  D
//      C                S
//      D                S | ~D
//      E                S |  D
//      F                1
//
//
//      Each of these functions expects as input an array for S and and
//      Array for D and output is written to another array, Y
//


/******************************Public*Routine******************************\
* Routine Name:
*
*   vRop2Function 0 - F
*
* Routine Description:
*
*   Perform Rop2 logical combination of cx DWORDS from pulSBuffer and
*   pulDBuffer into pulDstBuffer
*
* Arguments:
*
*   pulDstBuffer - pointer to destination buffer
*   pulDBuffer   - pointer to source for destination data
*   pulSBuffer   - pointer to source for source data
*   cx           - number of DWORDS to combine
*
* Return Value:
*
*   none
*
\**************************************************************************/

VOID
vRop2Function0(
        PULONG  pulDstBuffer,
        PULONG  pulDBuffer,
        PULONG  pulSBuffer,
        ULONG   cx
    )
{
    DONTUSE(pulDBuffer);
    DONTUSE(pulSBuffer);
    memset((void *)pulDstBuffer,0,(int)(cx<<2));
}


VOID
vRop2Function1(
        PULONG  pulDstBuffer,
        PULONG  pulDBuffer,
        PULONG  pulSBuffer,
        ULONG   cx
    )
{
    while (cx--) {
        *pulDstBuffer++ = ~(*pulSBuffer++ | *pulDBuffer++);
    }
    return;
}

VOID
vRop2Function2(
        PULONG  pulDstBuffer,
        PULONG  pulDBuffer,
        PULONG  pulSBuffer,
        ULONG   cx
    )
{
    while (cx--) {
        *pulDstBuffer++ = (~*pulSBuffer++ & *pulDBuffer++);
    }

    return;
}

VOID
vRop2Function3(
        PULONG  pulDstBuffer,
        PULONG  pulDBuffer,
        PULONG  pulSBuffer,
        ULONG   cx
    )
{

    DONTUSE(pulDBuffer);
    while (cx--) {
        *pulDstBuffer++ = ~*pulSBuffer++;
    }

    return;
}

VOID
vRop2Function4(
        PULONG  pulDstBuffer,
        PULONG  pulDBuffer,
        PULONG  pulSBuffer,
        ULONG   cx
    )
{
    while (cx--) {
        *pulDstBuffer++ = *pulSBuffer++ & ~*pulDBuffer++;
    }

    return;
}

VOID
vRop2Function5(
        PULONG  pulDstBuffer,
        PULONG  pulDBuffer,
        PULONG  pulSBuffer,
        ULONG   cx
    )
{
    DONTUSE(pulSBuffer);
    while (cx--) {
        *pulDstBuffer++ = ~*pulDBuffer++;
    }

    return;
}



VOID
vRop2Function6(
        PULONG  pulDstBuffer,
        PULONG  pulDBuffer,
        PULONG  pulSBuffer,
        ULONG   cx
    )
{
    while (cx--) {
        *pulDstBuffer++ = *pulSBuffer++ ^ *pulDBuffer++;
    }

    return;
}

VOID
vRop2Function7(
        PULONG  pulDstBuffer,
        PULONG  pulDBuffer,
        PULONG  pulSBuffer,
        ULONG   cx
    )
{
    while (cx--) {
        *pulDstBuffer++ = ~(*pulSBuffer++ & *pulDBuffer++);
    }

    return;
}

VOID
vRop2Function8(
        PULONG  pulDstBuffer,
        PULONG  pulDBuffer,
        PULONG  pulSBuffer,
        ULONG   cx
    )
{
    while (cx--) {
        *pulDstBuffer++ = *pulSBuffer++ & *pulDBuffer++;
    }

    return;
}

VOID
vRop2Function9(
        PULONG  pulDstBuffer,
        PULONG  pulDBuffer,
        PULONG  pulSBuffer,
        ULONG   cx
    )
{
    while (cx--) {
        *pulDstBuffer++ = ~(*pulSBuffer++ ^ *pulDBuffer++);
    }

    return;
}

VOID
vRop2FunctionA(
        PULONG  pulDstBuffer,
        PULONG  pulDBuffer,
        PULONG  pulSBuffer,
        ULONG   cx
    )
{
    DONTUSE(pulSBuffer);

    memcpy((void *)pulDstBuffer,(void *)pulDBuffer,(int)(cx<<2));

    return;
}

VOID
vRop2FunctionB(
        PULONG  pulDstBuffer,
        PULONG  pulDBuffer,
        PULONG  pulSBuffer,
        ULONG   cx
    )
{
    while (cx--) {
        *pulDstBuffer++ = (~*pulSBuffer++) | *pulDBuffer++;
    }

    return;
}

VOID
vRop2FunctionC(
        PULONG  pulDstBuffer,
        PULONG  pulDBuffer,
        PULONG  pulSBuffer,
        ULONG   cx
    )
{
    DONTUSE(pulDBuffer);

    memcpy((void *)pulDstBuffer,(void *)pulSBuffer,(int)(cx<<2));

    return;
}

VOID
vRop2FunctionD(
        PULONG  pulDstBuffer,
        PULONG  pulDBuffer,
        PULONG  pulSBuffer,
        ULONG   cx
    )
{
    while (cx--) {
        *pulDstBuffer++ = *pulSBuffer++ | (~*pulDBuffer++);
    }

    return;
}

VOID
vRop2FunctionE(
        PULONG  pulDstBuffer,
        PULONG  pulDBuffer,
        PULONG  pulSBuffer,
        ULONG   cx
    )
{
    while (cx--) {
        *pulDstBuffer++ = *pulSBuffer++ | *pulDBuffer++;
    }

    return;
}

VOID
vRop2FunctionF(
        PULONG  pulDstBuffer,
        PULONG  pulDBuffer,
        PULONG  pulSBuffer,
        ULONG   cx
    )
{

    DONTUSE(pulSBuffer);
    DONTUSE(pulDBuffer);

    memset((void *)pulDstBuffer,0xFF,(int)cx<<2);
}


/******************************Public*Routine******************************\
* Routine Name:
*
* BltLnkSrcCopyMsk1
*
* Routine Description:
*
*   Routines to store src to dst based on 1 bit per pixel mask.
*
* Arguments:
*
*   pBltInfo   - pointer to BLTINFO        structure (src and dst info)
*   pMaskInfo  - pointer to MASKINFO structure (pjMsk,ixMsk etc)
*   Bytes      - Number of Bytes per pixel
*   Buffer0    - Pointer to a temporary scan line buffer used to read mask
*   Buffer1    - Pointer to a temporary scan line buffer used align src
*                if necessary. Only used for Mask Blt, not ROPs which
*                are already aligned
*
* Return Value:
*
*   none
*
\**************************************************************************/

VOID
BltLnkSrcCopyMsk1 (
    PBLTINFO         pBltInfo,
    PBLTLNK_MASKINFO pMaskInfo,
    PULONG           Buffer0,
    PULONG           Buffer1
)

{

    PBYTE           pjSrcTmp = pBltInfo->pjSrc;
    PBYTE           pjDstTmp = pBltInfo->pjDst;
    PBYTE           pjSrc;
    PBYTE           pjDst;
    ULONG           ixDst;
    ULONG           ixMsk;
    ULONG           iyMsk    = pMaskInfo->iyMsk;
    PBYTE           pjMsk    = pMaskInfo->pjMsk;
    LONG            cx;
    ULONG           cy       = pBltInfo->cy;
    PBYTE           pjBuffer = (PBYTE)&Buffer0[0];
    BYTE            Mask;

    //
    // if src and dst are not aligned then use SrcBlt1 to
    // copy each scan line to temp buffer Buffer1 first
    // to align it to dst
    //

    while (cy--)
    {

        cx = (LONG)pBltInfo->cx;

        pjSrc = pjSrcTmp + (pBltInfo->xSrcStart >> 3);
        pjDst = pjDstTmp + (pBltInfo->xDstStart >> 3);

        ixMsk   = pMaskInfo->ixMsk;
        ixDst   = pBltInfo->xDstStart;

        //
        // check Src and Dst alignment, if Src and Dst are not aligned,
        // copy Src to a temp buffer at Dst alignment
        //

        if ((pBltInfo->xSrcStart & 0x07) != (pBltInfo->xDstStart & 0x07))
        {
            //
            // copy and align src to dst
            //

            BltLnkReadPat1((PBYTE)Buffer1,
                           ixDst & 0x07,
                           pjSrc,
                           cx,
                           pBltInfo->xSrcStart & 0x07,
                           cx,0);

            pjSrc = (PBYTE)Buffer1;

        }

        //
        // align mask using BltLnkReadPat1
        //

        BltLnkReadPat1((PBYTE)Buffer0,ixDst,pjMsk,pMaskInfo->cxMsk,ixMsk,cx,0);

        pjBuffer = (PBYTE)Buffer0;

        //
        // If pMaskInfo->NegateMsk is FALSE, then when a mask bit is set
        // the Src is written to Dst, Dst is unchanged when the mask is clear.
        //
        // If pMaskInfo->NegateMsk is TRUE, then when a mask bit is clear
        // the Src is written to Dst, Dst is unchanged when the mask is set.
        //
        // ReadPat1 will zero partial bits at the beginning and end of a
        // scan line, this work fine for !Negate because zero mask bits are
        // not copied. However, for Negate masks, partial bits at the
        // beginning and end of scan lines must be masked so that these
        // bits are "1"s so that Src will not be copied to Dst. This is
        // done by ORing start and end masks onto the mask line.
        //

        if (!pMaskInfo->NegateMsk)
        {
            while (cx>0)
            {
                Mask = *pjBuffer;

                if (Mask == 0xFF)
                {
                    *pjDst = *pjSrc;
                } else if (Mask != 0) {
                    *pjDst = (*pjSrc & Mask) | (*pjDst & ~Mask);
                }

                pjSrc++;
                pjDst++;
                pjBuffer++;

                cx -= 8;

                //
                // check if this was a partial byte,
                // in that case restore partial byte
                // to cx (cx -= 8 -(ixDst & 0x07))
                // but since already did cx -= 8,add
                // ixDst & 0x07 back in
                //

                if (ixDst & 0x07)
                {
                    cx += ixDst & 0x07;

                    //
                    // zero ixDst, will not be needed again
                    //

                    ixDst = 0;
                }
            }

        } else {


            //
            // In this case write src to dst bits when mask == 0.
            // This means the beggining and end cases must have
            // mask set to 1 for the bits of partial bytes that are
            // not to be touched.
            //
            // ie : starting ixDst = 2
            //                 Ŀ
            //      Mask =     01234567
            //                 
            //                 Ŀ
            //      or with    11000000
            //                 
            //
            //      to make sure pixels 0 and 1 are not written.
            //      this is 0xFF << 6 = 0xFF << (8 - (ixDst & 7))
            //

            pjBuffer[0] |= (BYTE) (0xff << (8 - (ixDst & 0x07)));

            //
            //  for the ending case, want to set all bits after the
            //  last.
            //
            //  ie: ixDst = 2, cx = 8. This means store byte 0
            //  bits 2,3,4,5,6,7 and byte 1 bits 0 and 1
            //                                Ŀ
            //  In this case the mask must be 00111111
            //                                
            //  which is 0xFF >> 2 = (ixDst + cx) & 0x07
            //


            pjBuffer[((ixDst&0x07) + cx) >> 3] |=
                        (BYTE) (0xff >> ((ixDst + cx) & 0x07));

            while (cx>0)
            {
                Mask = *pjBuffer;

                if (Mask == 0x00)
                {
                    *pjDst = *pjSrc;
                } else if (Mask != 0xFF) {
                    *pjDst = (*pjDst & Mask) | (*pjSrc & ~Mask);
                }
                pjSrc++;
                pjDst++;
                pjBuffer++;

                cx -= 8;

                //
                // check if this was a partial byte,
                // in that case restore partial byte
                // to cx (cx -= 8 -(ixDst & 0x07))
                // but since already did cx -= 8,add
                // ixDst & 0x07 back in
                //

                if (ixDst & 0x07) {
                    cx += ixDst & 0x07;

                    //
                    // zero ixDst, will not be needed again
                    //

                    ixDst = 0;
                }
            }
        }


        //
        // increment for next scan line
        //

        pjDstTmp = pjDstTmp + pBltInfo->lDeltaDst;
        pjSrcTmp = pjSrcTmp + pBltInfo->lDeltaSrc;

        if (pBltInfo->yDir > 0) {

            iyMsk++;

            pjMsk += pMaskInfo->lDeltaMskDir;

            if ((LONG)iyMsk >= pMaskInfo->cyMsk)
            {
                iyMsk = 0;
                pjMsk = pMaskInfo->pjMskBase;
            }

        } else {

            if (iyMsk == 0)
            {
                iyMsk = pMaskInfo->cyMsk - 1;
                pjMsk = pMaskInfo->pjMskBase +
                                (pMaskInfo->lDeltaMskDir * (pMaskInfo->cyMsk - 1));
            }
            else
            {
                iyMsk--;
                pjMsk += pMaskInfo->lDeltaMskDir;
            }

        }

    }
}


/******************************Public*Routine******************************\
* Routine Name:
*
*   BltLnkSrcCopyMsk4
*
* Routine Description:
*
*   Routines to store src to dst based on 1 bit per pixel mask.
*
* Arguments:
*
*   pBltInfo   - pointer to BLTINFO        structure (src and dst info)
*   pMaskInfo  - pointer to MASKINFO structure (pjMsk,ixMsk etc)
*   Bytes      - Number of Bytes per pixel
*   Buffer     - Pointer to a temporary buffer that may be used
*
* Return Value:
*
*   none
*
\**************************************************************************/

VOID
BltLnkSrcCopyMsk4 (
    PBLTINFO         pBltInfo,
    PBLTLNK_MASKINFO pMaskInfo,
    PULONG           Buffer0,
    PULONG           Buffer1

)

{

    PBYTE   pjSrcTmp  = pBltInfo->pjSrc;
    PBYTE   pjDstTmp  = pBltInfo->pjDst;
    PBYTE   pjSrc;
    PBYTE   pjDst;
    BYTE    jMsk;
    BYTE    jSrc;
    BYTE    jDst;
    BYTE    jDstNew;
    ULONG   ixSrc;
    ULONG   ixDst;
    ULONG   ixMsk;
    ULONG   iyMsk     = pMaskInfo->iyMsk;
    PBYTE   pjMsk     = pMaskInfo->pjMsk;
    ULONG   cx;
    ULONG   cy        = pBltInfo->cy;

    DONTUSE(Buffer0);
    DONTUSE(Buffer1);

    while (cy--) {

        cx    = pBltInfo->cx;

        pjSrc = pjSrcTmp + (pBltInfo->xSrcStart >> 1);
        pjDst = pjDstTmp + (pBltInfo->xDstStart >> 1);

        ixMsk = pMaskInfo->ixMsk;
        ixSrc = pBltInfo->xSrcStart;
        ixDst = pBltInfo->xDstStart;
        //
        // load first mask byte and align it
        //
        jMsk = pjMsk[ixMsk >> 3] ^ pMaskInfo->NegateMsk;
        jMsk <<= ixMsk & 0x7;
        //
        // if destination is on odd nibble we'll handle it now so the main
        // loop can process two nibbles per pass
        //
        if (ixDst & 1)
        {
            if (jMsk & 0x80)
            {
                if (ixSrc & 1)
                    *pjDst = (*pjDst & 0xf0) | (*pjSrc & 0x0f);
                else
                    *pjDst = (*pjDst & 0xf0) | ((*pjSrc & 0xf0) >> 4);
            }
            pjDst++;
            ixSrc++;
            if (!(ixSrc & 1))
                pjSrc++;
            jMsk <<= 1;
            ixMsk++;
            cx--;
        }
        ixSrc &= 1;
        //
        // main loop, pack two pixels into each output byte per pass
        //
        while (cx >= 2)
        {
            BYTE jMskTmp;
            //
            // calculate the mask bits for both pixels
            //
            if ((LONG)ixMsk == pMaskInfo->cxMsk)
                ixMsk = 0;
            if (!(ixMsk & 0x07))
                jMsk = pjMsk[ixMsk >> 3] ^ pMaskInfo->NegateMsk;

            jMskTmp = jMsk;
            jMsk <<= 1;

            if ((LONG)++ixMsk == pMaskInfo->cxMsk)
                ixMsk = 0;
            if (!(ixMsk & 0x07))
                jMsk = pjMsk[ixMsk >> 3] ^ pMaskInfo->NegateMsk;
            //
            // determine whether first nibble uses source
            //
            if (jMskTmp & 0x80)
            {
                if (jMsk & 0x80)
                {
                    if (ixSrc)
                        *pjDst = (*pjSrc << 4) | ((pjSrc[1] & 0xf0) >> 4);
                    else
                        *pjDst = *pjSrc;
                }
                else
                {
                    if (ixSrc)
                        *pjDst = (*pjDst & 0x0f) | (*pjSrc << 4);
                    else
                        *pjDst = (*pjDst & 0x0f) | (*pjSrc & 0xf0);
                }
            }
            else
            {
                if (jMsk & 0x80)
                {
                    if (ixSrc)
                        *pjDst = (*pjDst & 0xf0) | ((*pjSrc & 0xf0) >> 4);
                    else
                        *pjDst = (*pjDst & 0xf0) | (*pjSrc & 0x0f);
                }
            }
            jMsk <<= 1;
            ixMsk++;
            pjDst++;
            pjSrc++;
            cx -= 2;
        }
        //
        // handle remaining nibble if there is one
        //
        if (cx)
        {
            if ((LONG)ixMsk == pMaskInfo->cxMsk)
                ixMsk = 0;
            if (!(ixMsk & 0x07))
                jMsk = pjMsk[ixMsk >> 3] ^ pMaskInfo->NegateMsk;
            if (jMsk & 0x80)
            {
                if (ixSrc)
                    *pjDst = (*pjDst & 0x0f) | (*pjSrc << 4);
                else
                    *pjDst = (*pjDst & 0x0f) | (*pjSrc & 0xf0);
            }
        }
        //
        // increment for next scan line
        //

        pjDstTmp = pjDstTmp + pBltInfo->lDeltaDst;
        pjSrcTmp = pjSrcTmp + pBltInfo->lDeltaSrc;

        if (pBltInfo->yDir > 0) {

            iyMsk++;

            pjMsk += pMaskInfo->lDeltaMskDir;

            if ((LONG)iyMsk >= pMaskInfo->cyMsk)
            {
                iyMsk = 0;
                pjMsk = pMaskInfo->pjMskBase;
            }

        } else {

            if (iyMsk == 0)
            {
                iyMsk = pMaskInfo->cyMsk - 1;
                pjMsk = pMaskInfo->pjMskBase +
                                (pMaskInfo->lDeltaMskDir * (pMaskInfo->cyMsk - 1));
            }
            else
            {
                iyMsk--;
                pjMsk += pMaskInfo->lDeltaMskDir;
            }

        }

    }

}


/******************************Public*Routine******************************\
* Routine Name:
*
* BltLnkSrcCopyMsk8
*
* Routine Description:
*
*   Routines to store src to dst based on 1 bit per pixel mask.
*
* Arguments:
*
*   pBltInfo   - pointer to BLTLNKCOPYINFO structure (src and dst info)
*   pMaskInfo  - pointer to MASKINFO structure (pjMsk,ixMsk etc)
*   Bytes      - Number of Bytes per pixel
*   Buffer     - Pointer to a temporary buffer that may be used
*
* Return Value:
*
*   none
*
\**************************************************************************/

VOID
BltLnkSrcCopyMsk8 (
    PBLTINFO         pBltInfo,
    PBLTLNK_MASKINFO pMaskInfo,
    PULONG           Buffer0,
    PULONG           Buffer1
)
{

    ULONG   jMsk     = 0;
    LONG    ixMsk;
    LONG    cxMsk    = pMaskInfo->cxMsk;
    LONG    iyMsk    = pMaskInfo->iyMsk;
    LONG    icx;
    LONG    cx;
    ULONG   cy       = pBltInfo->cy;
    PBYTE   pjSrcTmp = pBltInfo->pjSrc;
    PBYTE   pjDstTmp = pBltInfo->pjDst;
    PBYTE   pjSrc;
    PBYTE   pjDst;
    PBYTE   pjMsk    = pMaskInfo->pjMsk;
    BYTE    Negate   = pMaskInfo->NegateMsk;
    ULONG   icxDst;
    LONG    DeltaMsk;




    DONTUSE(Buffer0);
    DONTUSE(Buffer1);

    while (cy--)
    {

        //
        // init loop params
        //

        cx      = (LONG)pBltInfo->cx;
        ixMsk   = pMaskInfo->ixMsk;
        pjSrc   = pjSrcTmp + pBltInfo->xSrcStart;
        pjDst   = pjDstTmp + pBltInfo->xDstStart;

        //
        // finish the scan line 8 mask bits at a time
        //

        while (cx > 0)
        {

            jMsk = (ULONG)(pjMsk[ixMsk>>3] ^ Negate);

            //
            // icx is the number of pixels left in the mask byte
            //

            icx = 8 - (ixMsk & 0x07);

            //
            // icx is the number of pixels to operate on with this mask byte.
            // Must make sure that icx is less than cx, the number of pixels
            // remaining in the blt and cx is less than DeltaMsk, the number
            // of bits in the mask still valid. If icx is reduced because of
            // cx of DeltaMsk, then jMsk must be shifted right to compensate.
            //

            DeltaMsk = cxMsk - ixMsk;
            icxDst   = 0;

            if (icx > cx) {
                icxDst = icx - cx;
                icx    = cx;
            }

            if (icx > DeltaMsk) {
                icxDst = icxDst + (icx - DeltaMsk);
                icx    = DeltaMsk;
            }

            //
            // icxDst is now the number of pixels that can't be stored off
            // the right side of the mask
            //
            // Bit   7 6 5 4 3 2 1 0
            //      Ŀ
            // ixMsk01234567  if mask 7 and 6 can't be written, this
            //        mask gets shifted right 2 to
            //
            //
            // Bit   7 6 5 4 3 2 1 0
            //      Ŀ
            // ixMsk  012345
            //      
            //
            //
            //
            // the number of mask bits valid = 8 minus the offset (ixMsk & 0x07)
            // minus the number of pixels that can't be stored because cx
            // runs out or because cxMsk runs out (icxDst)
            //

            cx -= icx;
            ixMsk += icx;

            if (jMsk != 0) {

                jMsk  = jMsk >> icxDst;

                switch (icx)
                {
                case 8:
                    if (jMsk & 0x01)
                    {
                        *(pjDst+7) = *(pjSrc+7);
                    }
                    jMsk >>= 1;
                case 7:
                    if (jMsk & 0x01)
                    {
                        *(pjDst+6) = *(pjSrc+6);
                    }
                    jMsk >>= 1;
                case 6:
                    if (jMsk & 0x01)
                    {
                        *(pjDst+5) = *(pjSrc+5);
                    }
                    jMsk >>= 1;
                case 5:
                    if (jMsk & 0x01)
                    {
                        *(pjDst+4) = *(pjSrc+4);
                    }
                    jMsk >>= 1;
                case 4:
                    if (jMsk & 0x01)
                    {
                        *(pjDst+3) = *(pjSrc+3);
                    }
                    jMsk >>= 1;
                case 3:
                    if (jMsk & 0x01)
                    {
                        *(pjDst+2) = *(pjSrc+2);
                    }
                    jMsk >>= 1;
                case 2:
                    if (jMsk & 0x01)
                    {
                        *(pjDst+1) = *(pjSrc+1);
                    }
                    jMsk >>= 1;
                case 1:
                    if (jMsk & 0x01)
                    {
                        *pjDst = *pjSrc;
                    }
                }
            }

            pjSrc += icx;
            pjDst += icx;

            if (ixMsk == cxMsk)
            {
                ixMsk = 0;
            }

        }

        //
        // Increment address to the next scan line.
        //

        pjDstTmp = pjDstTmp + pBltInfo->lDeltaDst;
        pjSrcTmp = pjSrcTmp + pBltInfo->lDeltaSrc;


        //
        // Increment Mask address to the next scan line or
        // back to ther start if iy exceeds cy
        //

        if (pBltInfo->yDir > 0) {

            iyMsk++;

            pjMsk += pMaskInfo->lDeltaMskDir;

            if ((LONG)iyMsk >= pMaskInfo->cyMsk)
            {
                iyMsk = 0;
                pjMsk = pMaskInfo->pjMskBase;
            }

        } else {

            if (iyMsk == 0)
            {
                iyMsk = pMaskInfo->cyMsk - 1;
                pjMsk = pMaskInfo->pjMskBase +
                                (pMaskInfo->lDeltaMskDir * (pMaskInfo->cyMsk - 1));
            }
            else
            {
                iyMsk--;
                pjMsk += pMaskInfo->lDeltaMskDir;
            }

        }

    }
}

/******************************Public*Routine******************************\
* Routine Name:
*
* BltLnkSrcCopyMsk16
*
* Routine Description:
*
*   Routines to store src to dst based on 1 bit per pixel mask.
*
* Arguments:
*
*   pBltInfo   - pointer to BLTINFO        structure (src and dst info)
*   pMaskInfo  - pointer to MASKINFO structure (pjMsk,ixMsk etc)
*   Bytes      - Number of Bytes per pixel
*   Buffer     - Pointer to a temporary buffer that may be used
*
* Return Value:
*
*   none
*
\**************************************************************************/
VOID
BltLnkSrcCopyMsk16 (
    PBLTINFO         pBltInfo,
    PBLTLNK_MASKINFO pMaskInfo,
    PULONG           Buffer0,
    PULONG           Buffer1
)
{

    ULONG   jMsk     = 0;
    LONG    ixMsk;
    LONG    cxMsk    = pMaskInfo->cxMsk;
    LONG    iyMsk    = pMaskInfo->iyMsk;
    LONG    icx;
    LONG    cx;
    ULONG   cy        = pBltInfo->cy;
    PUSHORT pusSrcTmp = (PUSHORT)pBltInfo->pjSrc;
    PUSHORT pusDstTmp = (PUSHORT)pBltInfo->pjDst;
    PUSHORT pusSrc;
    PUSHORT pusDst;
    PBYTE   pjMsk    = pMaskInfo->pjMsk;
    BYTE    Negate   = pMaskInfo->NegateMsk;
    ULONG   icxDst;
    LONG    DeltaMsk;




    DONTUSE(Buffer0);
    DONTUSE(Buffer1);

    while (cy--)
    {
        //
        // for each scan line, first do the writes necessary to
        // align the mask (ixMsk) to zero, then operate on the
        // mask 1 byte at a time (8 pixels) or cxMsk, whichever
        // is less
        //

        //
        // init loop params
        //

        cx       = (LONG)pBltInfo->cx;
        ixMsk    = pMaskInfo->ixMsk;
        pusSrc   = pusSrcTmp + pBltInfo->xSrcStart;
        pusDst   = pusDstTmp + pBltInfo->xDstStart;

        //
        // finish the aligned scan line 8 mask bits at a time
        //

        while (cx > 0)
        {

            jMsk = (ULONG)(pjMsk[ixMsk>>3] ^ Negate);

            //
            // icx is the number of pixels left in the mask byte
            //

            icx = 8 - (ixMsk & 0x07);

            //
            // icx is the number of pixels to operate on with this mask byte.
            // Must make sure that icx is less than cx, the number of pixels
            // remaining in the blt and cx is less than DeltaMsk, the number
            // of bits in the mask still valid. If icx is reduced because of
            // cx of DeltaMsk, then jMsk must be shifted right to compensate.
            //

            DeltaMsk = cxMsk - ixMsk;
            icxDst   = 0;

            if (icx > cx) {
                icxDst = icx - cx;
                icx    = cx;
            }

            if (icx > DeltaMsk) {
                icxDst = icxDst + (icx - DeltaMsk);
                icx    = DeltaMsk;
            }

            //
            // icxDst is now the number of pixels that can't be stored off
            // the right side of the mask
            //
            // Bit   7 6 5 4 3 2 1 0
            //      Ŀ
            // ixMsk01234567  if mask 7 and 6 can't be written, this
            //        mask gets shifted right 2 to
            //
            //
            // Bit   7 6 5 4 3 2 1 0
            //      Ŀ
            // ixMsk  012345
            //      
            //
            //
            //
            // the number of mask bits valid = 8 minus the offset (MskAln)
            // minus the number of pixels that can't be stored because cx
            // runs out or because cxMsk runs out (icxDst)
            //

            cx -= icx;
            ixMsk += icx;


            if (jMsk != 0) {

                jMsk  = jMsk >> icxDst;

                switch (icx)
                {
                case 8:
                    if (jMsk & 0x01)
                    {
                        *(pusDst+7) = *(pusSrc+7);
                    }
                    jMsk >>= 1;
                case 7:
                    if (jMsk & 0x01)
                    {
                        *(pusDst+6) = *(pusSrc+6);
                    }
                    jMsk >>= 1;
                case 6:
                    if (jMsk & 0x01)
                    {
                        *(pusDst+5) = *(pusSrc+5);
                    }
                    jMsk >>= 1;
                case 5:
                    if (jMsk & 0x01)
                    {
                        *(pusDst+4) = *(pusSrc+4);
                    }
                    jMsk >>= 1;
                case 4:
                    if (jMsk & 0x01)
                    {
                        *(pusDst+3) = *(pusSrc+3);
                    }
                    jMsk >>= 1;
                case 3:
                    if (jMsk & 0x01)
                    {
                        *(pusDst+2) = *(pusSrc+2);
                    }
                    jMsk >>= 1;
                case 2:
                    if (jMsk & 0x01)
                    {
                        *(pusDst+1) = *(pusSrc+1);
                    }
                    jMsk >>= 1;
                case 1:
                    if (jMsk & 0x01)
                    {
                        *pusDst = *pusSrc;
                    }
                }
            }

            pusSrc += icx;
            pusDst += icx;

            if (ixMsk == cxMsk)
            {
                ixMsk = 0;
            }

        }

        //
        // Increment address to the next scan line. Note: lDelta
        // is in bytes
        //

        pusDstTmp = (PUSHORT)((PBYTE)pusDstTmp + pBltInfo->lDeltaDst);
        pusSrcTmp = (PUSHORT)((PBYTE)pusSrcTmp + pBltInfo->lDeltaSrc);

        //
        // Increment Mask address to the next scan line or
        // back to ther start if iy exceeds cy
        //

        if (pBltInfo->yDir > 0) {

            iyMsk++;

            pjMsk += pMaskInfo->lDeltaMskDir;

            if ((LONG)iyMsk >= pMaskInfo->cyMsk)
            {
                iyMsk = 0;
                pjMsk = pMaskInfo->pjMskBase;
            }

        } else {

            if (iyMsk == 0)
            {
                iyMsk = pMaskInfo->cyMsk - 1;
                pjMsk = pMaskInfo->pjMskBase +
                                (pMaskInfo->lDeltaMskDir * (pMaskInfo->cyMsk - 1));
            }
            else
            {
                iyMsk--;
                pjMsk += pMaskInfo->lDeltaMskDir;
            }

        }

    }
}


/******************************Public*Routine******************************\
* Routine Name:
*
* BltLnkSrcCopyMsk24
*
* Routine Description:
*
*   Routines to store src to dst based on 1 bit per pixel mask.
*
* Arguments:
*
*   pBltInfo   - pointer to BLTINFO        structure (src and dst info)
*   pMaskInfo  - pointer to MASKINFO structure (pjMsk,ixMsk etc)
*   Bytes      - Number of Bytes per pixel
*   Buffer     - Pointer to a temporary buffer that may be used
*
* Return Value:
*
*   none
*
\**************************************************************************/
VOID
BltLnkSrcCopyMsk24 (
    PBLTINFO         pBltInfo,
    PBLTLNK_MASKINFO pMaskInfo,
    PULONG           Buffer0,
    PULONG           Buffer1
)
{

    ULONG   jMsk     = 0;
    LONG    ixMsk;
    LONG    cxMsk    = pMaskInfo->cxMsk;
    LONG    iyMsk    = pMaskInfo->iyMsk;
    LONG    icx;
    LONG    cx;
    ULONG   cy       = pBltInfo->cy;
    PBYTE   pjSrcTmp = pBltInfo->pjSrc;
    PBYTE   pjDstTmp = pBltInfo->pjDst;
    PBYTE   pjSrc;
    PBYTE   pjDst;
    PBYTE   pjMsk    = pMaskInfo->pjMsk;
    BYTE    Negate   = pMaskInfo->NegateMsk;
    ULONG   icxDst;
    LONG    DeltaMsk;




    DONTUSE(Buffer0);
    DONTUSE(Buffer1);

    while (cy--)
    {

        //
        // for each scan line, first do the writes necessary to
        // align the mask (ixMsk) to zero, then operate on the
        // mask 1 byte at a time (8 pixels) or cxMsk, whichever
        // is less
        //

        //
        // init loop params
        //

        cx      = (LONG)pBltInfo->cx;
        ixMsk   = pMaskInfo->ixMsk;
        pjSrc   = pjSrcTmp + 3 * pBltInfo->xSrcStart;
        pjDst   = pjDstTmp + 3 * pBltInfo->xDstStart;

        //
        // finish the aligned scan line 8 mask bits at a time
        //

        while (cx > 0)
        {


            jMsk = (ULONG)(pjMsk[ixMsk>>3] ^ Negate);

            //
            // icx is the number of pixels left in the mask byte
            //

            icx = 8 - (ixMsk & 0x07);

            //
            // icx is the number of pixels to operate on with this mask byte.
            // Must make sure that icx is less than cx, the number of pixels
            // remaining in the blt and cx is less than DeltaMsk, the number
            // of bits in the mask still valid. If icx is reduced because of
            // cx of DeltaMsk, then jMsk must be shifted right to compensate.
            //

            DeltaMsk = cxMsk - ixMsk;
            icxDst   = 0;

            if (icx > cx) {
                icxDst = icx - cx;
                icx    = cx;
            }

            if (icx > DeltaMsk) {
                icxDst = icxDst + (icx - DeltaMsk);
                icx    = DeltaMsk;
            }

            //
            // icxDst is now the number of pixels that can't be stored off
            // the right side of the mask
            //
            // Bit   7 6 5 4 3 2 1 0
            //      Ŀ
            // ixMsk01234567  if mask 7 and 6 can't be written, this
            //        mask gets shifted right 2 to
            //
            //
            // Bit   7 6 5 4 3 2 1 0
            //      Ŀ
            // ixMsk  012345
            //      
            //
            //
            //
            // the number of mask bits valid = 8 minus the offset (MskAln)
            // minus the number of pixels that can't be stored because cx
            // runs out or because cxMsk runs out (icxDst)
            //

            cx -= icx;
            ixMsk += icx;

            if (jMsk != 0) {

                jMsk  = jMsk >> icxDst;

                switch (icx)
                {
                case 8:
                    if (jMsk & 0x01)
                    {
                        *(pjDst+23) = *(pjSrc+23);
                        *(pjDst+22) = *(pjSrc+22);
                        *(pjDst+21) = *(pjSrc+21);
                    }
                    jMsk >>= 1;
                case 7:
                    if (jMsk & 0x01)
                    {
                        *(pjDst+20) = *(pjSrc+20);
                        *(pjDst+19) = *(pjSrc+19);
                        *(pjDst+18) = *(pjSrc+18);
                    }
                    jMsk >>= 1;
                case 6:
                    if (jMsk & 0x01)
                    {
                        *(pjDst+17) = *(pjSrc+17);
                        *(pjDst+16) = *(pjSrc+16);
                        *(pjDst+15) = *(pjSrc+15);
                    }
                    jMsk >>= 1;
                case 5:
                    if (jMsk & 0x01)
                    {
                        *(pjDst+14) = *(pjSrc+14);
                        *(pjDst+13) = *(pjSrc+13);
                        *(pjDst+12) = *(pjSrc+12);
                    }
                    jMsk >>= 1;
                case 4:
                    if (jMsk & 0x01)
                    {
                        *(pjDst+11) = *(pjSrc+11);
                        *(pjDst+10) = *(pjSrc+10);
                        *(pjDst+9)  = *(pjSrc+9);
                    }
                    jMsk >>= 1;
                case 3:
                    if (jMsk & 0x01)
                    {
                        *(pjDst+8) = *(pjSrc+8);
                        *(pjDst+7) = *(pjSrc+7);
                        *(pjDst+6) = *(pjSrc+6);
                    }
                    jMsk >>= 1;
                case 2:
                    if (jMsk & 0x01)
                    {
                        *(pjDst+5) = *(pjSrc+5);
                        *(pjDst+4) = *(pjSrc+4);
                        *(pjDst+3) = *(pjSrc+3);
                    }
                    jMsk >>= 1;
                case 1:
                    if (jMsk & 0x01)
                    {
                        *(pjDst+2) = *(pjSrc+2);
                        *(pjDst+1) = *(pjSrc+1);
                        *pjDst     = *pjSrc;
                    }
                }
            }

            pjSrc += 3*icx;
            pjDst += 3*icx;

            if (ixMsk == cxMsk)
            {
                ixMsk = 0;
            }

        }

        //
        // increment to next scan line
        //

        pjDstTmp = pjDstTmp + pBltInfo->lDeltaDst;
        pjSrcTmp = pjSrcTmp + pBltInfo->lDeltaSrc;

        //
        // Increment Mask address to the next scan line or
        // back to ther start if iy exceeds cy
        //

        if (pBltInfo->yDir > 0) {

            iyMsk++;

            pjMsk += pMaskInfo->lDeltaMskDir;

            if ((LONG)iyMsk >= pMaskInfo->cyMsk)
            {
                iyMsk = 0;
                pjMsk = pMaskInfo->pjMskBase;
            }

        } else {

            if (iyMsk == 0)
            {
                iyMsk = pMaskInfo->cyMsk - 1;
                pjMsk = pMaskInfo->pjMskBase +
                                (pMaskInfo->lDeltaMskDir * (pMaskInfo->cyMsk - 1));
            }
            else
            {
                iyMsk--;
                pjMsk += pMaskInfo->lDeltaMskDir;
            }

        }

    }
}


/******************************Public*Routine******************************\
* Routine Name:
*
* BltLnkSrcCopyMsk32
*
* Routine Description:
*
*   Routines to store src to dst based on 1 bit per pixel mask.
*
* Arguments:
*
*   pBltInfo   - pointer to BLTINFO        structure (src and dst info)
*   pMaskInfo  - pointer to MASKINFO structure (pjMsk,ixMsk etc)
*   Bytes      - Number of Bytes per pixel
*   Buffer     - Pointer to a temporary buffer that may be used
*
* Return Value:
*
*   none
*
\**************************************************************************/

VOID
BltLnkSrcCopyMsk32 (
    PBLTINFO         pBltInfo,
    PBLTLNK_MASKINFO pMaskInfo,
    PULONG           Buffer0,
    PULONG           Buffer1
)
{

    ULONG   jMsk     = 0;
    LONG    ixMsk;
    LONG    cxMsk    = pMaskInfo->cxMsk;
    LONG    iyMsk    = pMaskInfo->iyMsk;
    LONG    icx;
    LONG    cx;
    ULONG   cy        = pBltInfo->cy;
    PULONG  pulSrcTmp = (PULONG)pBltInfo->pjSrc;
    PULONG  pulDstTmp = (PULONG)pBltInfo->pjDst;
    PULONG  pulSrc;
    PULONG  pulDst;
    PBYTE   pjMsk    = pMaskInfo->pjMsk;
    BYTE    Negate   = pMaskInfo->NegateMsk;
    ULONG   icxDst;
    LONG    DeltaMsk;




    DONTUSE(Buffer0);
    DONTUSE(Buffer1);

    while (cy--)
    {

        //
        // for each scan line, first do the writes necessary to
        // align the mask (ixMsk) to zero, then operate on the
        // mask 1 byte at a time (8 pixels) or cxMsk, whichever
        // is less
        //

        //
        // init loop params
        //

        cx       = (LONG)pBltInfo->cx;
        ixMsk    = pMaskInfo->ixMsk;
        pulSrc   = pulSrcTmp + pBltInfo->xSrcStart;
        pulDst   = pulDstTmp + pBltInfo->xDstStart;

        //
        // finish the aligned scan line 8 mask bits at a time
        //

        while (cx > 0)
        {

            jMsk = (ULONG)(pjMsk[ixMsk>>3] ^ Negate);

            //
            // icx is the number of pixels left in the mask byte
            //

            icx = 8 - (ixMsk & 0x07);

            //
            // icx is the number of pixels to operate on with this mask byte.
            // Must make sure that icx is less than cx, the number of pixels
            // remaining in the blt and cx is less than DeltaMsk, the number
            // of bits in the mask still valid. If icx is reduced because of
            // cx of DeltaMsk, then jMsk must be shifted right to compensate.
            //

            DeltaMsk = cxMsk - ixMsk;
            icxDst   = 0;

            if (icx > cx) {
                icxDst = icx - cx;
                icx    = cx;
            }

            if (icx > DeltaMsk) {
                icxDst = icxDst + (icx - DeltaMsk);
                icx    = DeltaMsk;
            }

            //
            // icxDst is now the number of pixels that can't be stored off
            // the right side of the mask
            //
            // Bit   7 6 5 4 3 2 1 0
            //      Ŀ
            // ixMsk01234567  if mask 7 and 6 can't be written, this
            //        mask gets shifted right 2 to
            //
            //
            // Bit   7 6 5 4 3 2 1 0
            //      Ŀ
            // ixMsk  012345
            //      
            //
            // the number of mask bits valid = 8 minus the offset (MskAln)
            // minus the number of pixels that can't be stored because cx
            // runs out or because cxMsk runs out (icxDst)
            //

            cx -= icx;
            ixMsk += icx;

            if (jMsk != 0) {

                jMsk  = jMsk >> icxDst;

                switch (icx)
                {
                case 8:
                    if (jMsk & 0x01)
                    {
                        *(pulDst+7) = *(pulSrc+7);
                    }
                    jMsk >>= 1;
                case 7:
                    if (jMsk & 0x01)
                    {
                        *(pulDst+6) = *(pulSrc+6);
                    }
                    jMsk >>= 1;
                case 6:
                    if (jMsk & 0x01)
                    {
                        *(pulDst+5) = *(pulSrc+5);
                    }
                    jMsk >>= 1;
                case 5:
                    if (jMsk & 0x01)
                    {
                        *(pulDst+4) = *(pulSrc+4);
                    }
                    jMsk >>= 1;
                case 4:
                    if (jMsk & 0x01)
                    {
                        *(pulDst+3) = *(pulSrc+3);
                    }
                    jMsk >>= 1;
                case 3:
                    if (jMsk & 0x01)
                    {
                        *(pulDst+2) = *(pulSrc+2);
                    }
                    jMsk >>= 1;
                case 2:
                    if (jMsk & 0x01)
                    {
                        *(pulDst+1) = *(pulSrc+1);
                    }
                    jMsk >>= 1;
                case 1:
                    if (jMsk & 0x01)
                    {
                        *pulDst = *pulSrc;
                    }
                }
            }

            pulSrc += icx;
            pulDst += icx;

            if (ixMsk == cxMsk)
            {
                ixMsk = 0;
            }

        }

        //
        // Increment to next scan line, note: lDelta is
        // in bytes.
        //

        pulDstTmp = (PULONG)((PBYTE)pulDstTmp + pBltInfo->lDeltaDst);
        pulSrcTmp = (PULONG)((PBYTE)pulSrcTmp + pBltInfo->lDeltaSrc);

        //
        // Increment Mask address to the next scan line or
        // back to ther start if iy exceeds cy
        //

        if (pBltInfo->yDir > 0) {

            iyMsk++;

            pjMsk += pMaskInfo->lDeltaMskDir;

            if ((LONG)iyMsk >= pMaskInfo->cyMsk)
            {
                iyMsk = 0;
                pjMsk = pMaskInfo->pjMskBase;
            }

        } else {

            if (iyMsk == 0)
            {
                iyMsk = pMaskInfo->cyMsk - 1;
                pjMsk = pMaskInfo->pjMskBase +
                                (pMaskInfo->lDeltaMskDir * (pMaskInfo->cyMsk - 1));
            }
            else
            {
                iyMsk--;
                pjMsk += pMaskInfo->lDeltaMskDir;
            }

        }

    }
}



/******************************Public*Routine******************************\
* BltLnkReadPat
*
* Routine Description:
*
*   Read pattern into a scan line buffer for 8,16,24,32 Bpp
*
* Arguments:
*
*   pjDst         - destination buffer
*   pjPat         - pattern starting address
*   cxPat         - Width of pattern
*   ixPat         - initial pattern offset
*   ByteCount     - Number of Bytes to transfer
*   BytesPerPixel - Number of Bytes per pixel(1,2,3,4)
*
* Return Value:
*
*
\**************************************************************************/

VOID
BltLnkReadPat(
    PBYTE   pjDst,
    ULONG   ixDst,
    PBYTE   pjPat,
    ULONG   cxPat,
    ULONG   ixPat,
    ULONG   PixelCount,
    ULONG   BytesPerPixel
)
{
    ULONG   ixPatTemp = ixPat;
    ULONG   ByteCount = PixelCount;

    DONTUSE(ixDst);

    //
    // expand byte count by number of bytes per
    // pixel
    //

    if (BytesPerPixel == 2) {
        ByteCount = ByteCount << 1;
    } else if (BytesPerPixel == 3) {
        ByteCount = ByteCount *3;
    } else if (BytesPerPixel == 4) {
        ByteCount = ByteCount << 2;
    }


    while (ByteCount--) {

        //
        // make sure ixPat stays within the pattern
        //

        if (ixPatTemp == cxPat) {
            ixPatTemp = 0;
        }

        *pjDst++ = pjPat[ixPatTemp++];

    }
}




/******************************Public*Routine******************************\
* Routine Name:
*
*   BltLnkReadPat4
*
* Routine Description:
*
*   Build a byte array of specified length from a 4 bit per pixel mask
*
* Arguments:
*
*   pjDst       - byte pointer to store pattern
*   pjPat       - Starting Pat address
*   cxPat       - Pattern width in nibbles
*   ixPat       - Starting nibble offset in pattern
*   PixelCount  - Number of pixels (nibbles) to transfer
*   BytesPerPixel - Only used in ReadPat(8,16,24,32)
*
* Return Value:
*
*   none
*
\**************************************************************************/

VOID
BltLnkReadPat4 (
    PBYTE   pjDst,
    ULONG   ixDst,
    PBYTE   pjPat,
    ULONG   cxPat,
    ULONG   ixPat,
    ULONG   PixelCount,
    ULONG   BytesPerPixel
)
{
    BYTE    jDst;
    LONG    iOffset;
    LONG    Cnt;

    DONTUSE(BytesPerPixel);
    //
    // handle case where destination starts on odd nibble
    //
    if ((ixDst & 1) && PixelCount)
    {
        jDst = pjPat[ixPat >> 1];
        if (!(ixPat & 1))
            jDst >>= 4;
        *pjDst++ = jDst & 0x0f;
        ixPat++;
        PixelCount--;
    }
    //
    // test whether it is worthwhile to implement fast version
    // the offset needs to be a multiple of cxPat and even
    //
    iOffset = cxPat;
    if (iOffset & 1)
        iOffset *= 2;
    if ((LONG)PixelCount > iOffset)
    {
        PixelCount -= iOffset;
        iOffset >>= 1;
        Cnt = iOffset;
    }
    else
    {
        Cnt = PixelCount >> 1;
        PixelCount &= 1;
    }

    //
    // handle packing two nibbles per loop to one destination byte
    //
    while (Cnt--)
    {
        if (ixPat == cxPat)
            ixPat = 0;
        jDst = pjPat[ixPat >> 1];
        if (!(ixPat & 1))
        {
            if (++ixPat == cxPat)
            {
                ixPat = 0;
                jDst = (jDst & 0xf0) | ((pjPat[0] & 0xf0) >> 4);
            }
        }
        else
        {
            if (++ixPat == cxPat)
                ixPat = 0;
            jDst = (jDst << 4) | ((pjPat[ixPat >> 1] & 0xf0) >> 4);
        }
        *pjDst++ = jDst;
        ixPat++;
    }
    //
    // test for fast mode
    //
    if (PixelCount > 1)
    {
        // loop while copying from the beginning of the pattern to the end
        // we loop multiple times so that the Src and Dst don't overlap.
        // each pass allows us to copy twice as many bytes the next time
        // (a single RtlMoveMemory doesn't work)
        Cnt = PixelCount >> 1;
        while (1)
        {
            LONG i = iOffset;
            if (i > Cnt)
                i = Cnt;
            RtlCopyMemory(pjDst,&pjDst[-iOffset],i);
            pjDst += i;
            if (!(Cnt -= i))
                break;
            iOffset *= 2;
        }
        if (PixelCount & 1)
            *pjDst = pjDst[-iOffset] & 0xf0;
    }
    //
    // handle case where destination ends on odd nibble
    //
    else if (PixelCount & 1)
    {
        if (ixPat == cxPat)
            ixPat = 0;
        if (ixPat & 1)
            *pjDst = pjPat[ixPat >> 1] << 4;
        else
            *pjDst = pjPat[ixPat >> 1] & 0xf0;
    }
}



/******************************Public*Routine******************************\
* Routine Name:
*
*   BltLnkReadPat1
*
* Routine Description:
*
*   Build a byte array of specified length from a 1 bit per pixel mask
*
* Arguments:
*
*   pjDst         - byte pointer to store pattern
*   ixDst         - starting bit offset in Dst
*   pjPat         - Starting Pat address
*   cxPat         - Pattern width in bits
*   ixPat         - Starting bit offset in pattern
*   PixelCount    - Number of pixels (bits) to transfer
*   BytesPerPixel - Only used in ReadPat(8,16,24,32)
*
* Return Value:
*
*   none
*
\**************************************************************************/
VOID
BltLnkReadPat1 (
    PBYTE   pjDst,
    ULONG   ixDst,
    PBYTE   pjPat,
    ULONG   cxPat,
    ULONG   ixPat,
    ULONG   PixelCount,
    ULONG   BytesPerPixel
)
{
    ULONG   jDst;
    ULONG   jPat;
    ULONG   DstAln;
    ULONG   PatAln;
    ULONG   icx;

    DONTUSE(BytesPerPixel);

    jDst = 0;

    DstAln = ixDst & 0x07;
    PatAln = ixPat & 0x07;

    while (PixelCount>0) {

        jPat = pjPat[ixPat>>3] & StartMask[PatAln];

        if (DstAln > PatAln)
        {
            icx  = 8 - DstAln;

            if (icx > PixelCount)
            {
                icx = PixelCount;
            }

            if (icx > (cxPat - ixPat)) {
                icx = cxPat - ixPat;
            }

            jPat &= EndMask[PatAln + icx];

            jPat = jPat >> (DstAln - PatAln);

        } else {

            icx  = 8 - PatAln;

            if (icx > PixelCount)
            {
                icx = PixelCount;
            }

            if (icx > (cxPat - ixPat)) {
                icx = cxPat - ixPat;
            }

            jPat &= EndMask[PatAln + icx];

            jPat = jPat << (PatAln - DstAln);

        }

        jDst |= jPat;
        ixDst += icx;
        DstAln = ixDst & 0x07;
        ixPat += icx;
        PatAln = ixPat & 0x07;
        PixelCount    -= icx;

        if (ixPat == cxPat) {
            ixPat  = 0;
            PatAln = 0;
        }

        if (!(ixDst & 0x07) || (PixelCount == 0)) {
            *pjDst = (BYTE)jDst;
            pjDst++;
            jDst = 0;
        }
    }
}



/******************************Public*Routine******************************\
* Routine Name:
*
*   BltLnkPatMaskCopy1
*
* Routine Description:
*
*   Transparent Color Expansion to 1bpp
*
*   Src is a 1 Bpp mask, where src is 0, copy 1 pixel solid color
*   to Dst. Where src is 1, leave Dst unchanged.
*
*
*
* Arguments:
*
*   pBltInfo - Pointer to BLTINFO structure containing Dst and Src information
*   ulPat    - Solid color pattern
*   pBuffer  - Scan line buffer if needed
*   Invert   - XOR mask used on Src to determine whether to write
*              through "1" pixels or "0" pixels
*
* Return Value:
*
*   none
*
\**************************************************************************/

VOID
BltLnkPatMaskCopy1(
    PBLTINFO        pBltInfo,
    ULONG           ulPat,
    PULONG          pBuffer,
    BYTE            Invert
)
{
    ULONG   cx;
    ULONG   cy       = pBltInfo->cy;
    PBYTE   pjSrcTmp = pBltInfo->pjSrc;
    PBYTE   pjDstTmp = pBltInfo->pjDst;
    PBYTE   pjSrc;
    PBYTE   pjDst;
    ULONG   ixDst;
    ULONG   SrcAln;
    ULONG   DstAln;
    LONG    ByteCount;
    BYTE    Pat;

    //
    // For each scan line, first make sure Src and Dst are aligned.
    // If they are not aligned then copy Src to a temp buffer at
    // Dst alignment.
    //
    // Next, the start and end of the scan line must be masked so that
    // partial byte writes only store the correct bits. This is done by
    // ORing "1"s to the start and end of the scan line where appropriate.
    //
    // Finally, the logic operation is performed:
    //
    // Dst = (Mask & Dst) | (~Mask & Pat);
    //
    // Pat is ulPat[0] replicated to 8 bits
    //

    Pat = (BYTE) (ulPat & 0x01);
    Pat |= Pat << 1;
    Pat |= Pat << 2;
    Pat |= Pat << 4;

    SrcAln = pBltInfo->xSrcStart & 0x07;
    DstAln = pBltInfo->xDstStart & 0x07;
    ixDst  = pBltInfo->xDstStart;
    cx     = pBltInfo->cx;

    while(cy--) {

        pjSrc   = pjSrcTmp + (pBltInfo->xSrcStart >> 3);
        pjDst   = pjDstTmp + (pBltInfo->xSrcStart >> 3);

        BltLnkReadPat1((PBYTE)pBuffer,DstAln,pjSrc,cx,SrcAln,cx,0);
        pjSrc = (PBYTE)pBuffer;


        if (Invert == 0)
        {
            //
            // mask start and end byte, if invert = 0x00 then start and end cases
            // are masked by ORing with "1"s
            //

            pjSrc[0] |= (BYTE) (0xff >> (8 - DstAln));
            pjSrc[(ixDst + cx) >> 3] |= (BYTE) (0xff << ((ixDst + cx) & 0x07));


            //
            // Number of whole bytes to transfer
            //

            ByteCount = (DstAln + cx + 7) >> 3;

            while (ByteCount--)
            {
                BYTE    Mask = *pjSrc;

                *pjDst = (Mask & *pjDst) | (~Mask & Pat);

                pjDst++;
                pjSrc++;
            }

        } else {

            //
            // mask start and end byte, if invert = 0xFF then start and end cases
            // are already masked to '0's by ReadPat1
            //

            //
            // Number of whole bytes to transfer
            //

            ByteCount = (DstAln + cx + 7) >> 3;

            while (ByteCount--)
            {
                BYTE    Mask = *pjSrc;

                *pjDst = (~Mask & *pjDst) | (Mask & Pat);

                pjDst++;
                pjSrc++;
            }

        }

        pjDstTmp = pjDstTmp + pBltInfo->lDeltaDst;
        pjSrcTmp = pjSrcTmp + pBltInfo->lDeltaSrc;

    }

    return;
}


/******************************Public*Routine******************************\
* Routine Name:
*
*   BltLnkPatMaskCopy4
*
* Routine Description:
*
*   Transparent Color Expansion to 4bpp
*
*   Src is a 1 Bpp mask, where src is 0, copy 1 pixel solid color
*   to Dst. Where src is 1, leave Dst unchanged.
*
*
*
* Arguments:
*
*   pBltInfo - Pointer to BLTINFO structure containing Dst and Src information
*   ulPat    - Solid color pattern
*   pBuffer  - Scan line buffer if needed
*   Invert   - XOR mask used on Src to determine whether to write
*              through "1" pixels or "0" pixels
*
* Return Value:
*
*   none
*
\**************************************************************************/

VOID
BltLnkPatMaskCopy4(
    PBLTINFO        pBltInfo,
    ULONG           ulPat,
    PULONG          pBuffer,
    BYTE            Invert
)
{
    ULONG   ulSrc;
    ULONG   cy       = pBltInfo->cy;
    PBYTE   pjSrcTmp = pBltInfo->pjSrc;
    PBYTE   pjDstTmp = pBltInfo->pjDst;
    PBYTE   pjSrc;
    PBYTE   pjDst;
    ULONG   ixSrc;
    ULONG   ixDst;
    ULONG   jDst    = 0;
    ULONG   jDstNew = 0;
    UCHAR   ucPat0  = (UCHAR)ulPat & 0xF0;
    UCHAR   ucPat1  = (UCHAR)ulPat & 0x0F;

    DONTUSE(pBuffer);

    //
    // for each scan line perform the transparency mask function
    //

    while(cy--)
    {

        PUCHAR  pjDstEnd;
        LONG    xMask = 8 - (pBltInfo->xSrcStart & 0x0007);
        UCHAR   ucMask;
        ixDst = pBltInfo->xDstStart;

        pjSrc = pjSrcTmp + (pBltInfo->xSrcStart >> 3);

        ucMask = (*pjSrc++ ^ Invert);

        ulSrc = (ULONG)ucMask << (16 - xMask);

        pjDst = pjDstTmp + (pBltInfo->xSrcStart >> 1);

        pjDstEnd = pjDst + pBltInfo->cx;

        //
        // write partial nibble if needed
        //

        if ((ULONG_PTR)pjDst & 0x01)
        {
            if (!(ulSrc & 0x8000))
            {
                *pjDst = (*pjDst & 0xf0) | ucPat1;
            }

            pjDst++;
            ulSrc <<=1;
            xMask--;
        }

        //
        // aligned 2-byte stores
        //

        while (pjDst < (pjDstEnd - 1))
        {

            //
            // Need a new mask byte?
            //

            if (xMask < 2)
            {
                ucMask = (*pjSrc++ ^ Invert);

                ulSrc |= ucMask << (8 - xMask);

                xMask += 8;
            }

            //
            // 2-nibble aligned store
            //

            switch (ulSrc & 0xc000)
            {
            case 0x0:

                //
                // write both
                //

                *pjDst = (UCHAR)ulPat;
                break;

            case 0x8000:

                //
                // don't write 0, write 1
                //

                *pjDst = (*pjDst & 0xf0) | ucPat1;
                break;

            case 0x4000:

                //
                // write 0, don't write 1
                //

                *pjDst = (*pjDst & 0x0f) | ucPat0;
                break;

                //
                // case c000 does not draw anything
                //
            }

            pjDst++;
            ulSrc <<=2;
            xMask -= 2;
        }

        //
        // check if a partial jDst needs to be stored
        //

        if ((pjDst != pjDstEnd) && (!(ulSrc & 0x8000)))
        {
            *pjDst = (*pjDst & 0x0f) | ucPat0;
        }

        pjDstTmp = pjDstTmp + pBltInfo->lDeltaDst;
        pjSrcTmp = pjSrcTmp + pBltInfo->lDeltaSrc;

    }

    return;
}


/******************************Public*Routine******************************\
* Routine Name:
*
*   BltLnkPatMaskCopy8
*
* Routine Description:
*
*   Transparent Color Expansion to 8bpp
*
*   Src is a 1 Bpp mask, where src is 0, copy 1 pixel solid color
*   to Dst. Where src is 1, leave Dst unchanged.
*
* Arguments:
*
*   pBltInfo - Pointer to BLTINFO structure containing Dst and Src information
*   ulPat    - Solid color pattern
*   pBuffer  - Scan line buffer if needed
*   Invert   - XOR mask used on Src to determine whether to write
*              through "1" pixels or "0" pixels
*
* Return Value:
*
*   none
*
\**************************************************************************/

VOID
BltLnkPatMaskCopy8 (
    PBLTINFO        pBltInfo,
    ULONG           ulPat,
    PULONG          pBuffer,
    BYTE            Invert
)
{

    ULONG   jMsk     = 0;
    LONG    ixSrc;
    LONG    icx;
    LONG    cx;
    ULONG   cy       = pBltInfo->cy;
    PBYTE   pjSrcTmp = pBltInfo->pjSrc;
    PBYTE   pjDstTmp = pBltInfo->pjDst;
    PBYTE   pjSrc;
    PBYTE   pjDst;
    ULONG   icxDst;



    DONTUSE(pBuffer);

    while (cy--)
    {
        //
        // for each scan line, first do the writes necessary to
        // align ixSrc to zero, then operate on the
        // Src 1 byte at a time (8 pixels) or cxSrc, whichever
        // is less
        //

        //
        // init loop params
        //

        cx      = (LONG)pBltInfo->cx;
        ixSrc   = pBltInfo->xSrcStart;
        pjSrc   = pjSrcTmp;
        pjDst   = pjDstTmp + pBltInfo->xDstStart;

        //
        // finish the aligned scan line 8 mask bits at a time
        //

        while (cx > 0)
        {

            jMsk = (ULONG)pjSrc[ixSrc>>3] ^ Invert;

            //
            // icx is the number of pixels left in the mask byte
            //

            icx = 8 - (ixSrc & 0x07);

            //
            // icx is the number of pixels to operate on with this mask byte.
            // Must make sure that icx is less than cx, the number of pixels
            // remaining in the blt. If icx is reduced because of
            // cx, then jMsk must be shifted right to compensate.
            //

            icxDst   = 0;

            if (icx > cx) {
                icxDst = icx - cx;
                icx    = cx;
            }

            //
            // icxDst is now the number of pixels that can't be stored off
            // the right side of the mask
            //
            // Bit   7 6 5 4 3 2 1 0
            //      Ŀ
            // ixMsk01234567  if mask 7 and 6 can't be written, this
            //        mask gets shifted right 2 to
            //
            //
            // Bit   7 6 5 4 3 2 1 0
            //      Ŀ
            // ixMsk  012345
            //      
            //
            // the number of mask bits valid = 8 minus the offset (ixSrc & 0x07)
            // minus the number of pixels that can't be stored because cx
            // runs out or because cxMsk runs out (icxDst)
            //

            cx    -= icx;
            ixSrc += icx;

            if (jMsk != 0xFF) {

                jMsk  = jMsk >> icxDst;

                switch (icx)
                {
                case 8:
                    if (!(jMsk & 0x01))
                    {
                        *(pjDst+7) = (BYTE)ulPat;
                    }
                    jMsk >>= 1;
                case 7:
                    if (!(jMsk & 0x01))
                    {
                        *(pjDst+6) = (BYTE)ulPat;
                    }
                    jMsk >>= 1;
                case 6:
                    if (!(jMsk & 0x01))
                    {
                        *(pjDst+5) = (BYTE)ulPat;
                    }
                    jMsk >>= 1;
                case 5:
                    if (!(jMsk & 0x01))
                    {
                        *(pjDst+4) = (BYTE)ulPat;
                    }
                    jMsk >>= 1;
                case 4:
                    if (!(jMsk & 0x01))
                    {
                        *(pjDst+3) = (BYTE)ulPat;
                    }
                    jMsk >>= 1;
                case 3:
                    if (!(jMsk & 0x01))
                    {
                        *(pjDst+2) = (BYTE)ulPat;
                    }
                    jMsk >>= 1;
                case 2:
                    if (!(jMsk & 0x01))
                    {
                        *(pjDst+1) = (BYTE)ulPat;
                    }
                    jMsk >>= 1;
                case 1:
                    if (!(jMsk & 0x01))
                    {
                        *pjDst = (BYTE)ulPat;
                    }
                }
            }

            pjDst += icx;

        }

        //
        // increment 8 bpp Dst and 1 bpp Src to next scan line
        //

        pjDstTmp = pjDstTmp + pBltInfo->lDeltaDst;
        pjSrcTmp = pjSrcTmp + pBltInfo->lDeltaSrc;
    }
}


/******************************Public*Routine******************************\
* Routine Name:
*
*   BltLnkPatMaskCopy16
*
* Routine Description:
*
*   Transparent Color Expansion to 16bpp
*
*   Src is a 1 Bpp mask, where src is 0, copy 1 pixel solid color
*   to Dst. Where src is 1, leave Dst unchanged.
*
* Arguments:
*
*   pBltInfo - Pointer to BLTINFO structure containing Dst and Src information
*   ulPat    - Solid color pattern
*   pBuffer  - Scan line buffer if needed
*   Invert   - XOR mask used on Src to determine whether to write
*              through "1" pixels or "0" pixels
*
* Return Value:
*
*   none
*
\**************************************************************************/

VOID
BltLnkPatMaskCopy16 (
    PBLTINFO        pBltInfo,
    ULONG           ulPat,
    PULONG          pBuffer,
    BYTE            Invert
)
{

    ULONG   jMsk = 0;
    LONG    ixSrc;
    LONG    icx;
    LONG    cx;
    ULONG   cy        = pBltInfo->cy;
    PBYTE   pjSrcTmp  = pBltInfo->pjSrc;
    PUSHORT pusDstTmp = (PUSHORT)pBltInfo->pjDst;
    PBYTE   pjSrc;
    PUSHORT pusDst;
    ULONG   icxDst;



    DONTUSE(pBuffer);

    while (cy--)
    {
        //
        // for each scan line, first do the writes necessary to
        // align ixSrc to zero, then operate on the
        // Src 1 byte at a time (8 pixels) or cxSrc, whichever
        // is less
        //

        //
        // init loop params
        //

        cx      = (LONG)pBltInfo->cx;
        ixSrc   = pBltInfo->xSrcStart;
        pjSrc   = pjSrcTmp;
        pusDst  = pusDstTmp + pBltInfo->xDstStart;

        //
        // load first mask byte if the mask is not aligned to 0
        //

        //
        // finish the aligned scan line 8 mask bits at a time
        //

        while (cx > 0)
        {

            jMsk = (ULONG)pjSrc[ixSrc>>3] ^ Invert;

            //
            // icx is the number of pixels left in the mask byte
            //

            icx = 8 - (ixSrc & 0x07);

            //
            // icx is the number of pixels to operate on with this mask byte.
            // Must make sure that icx is less than cx, the number of pixels
            // remaining in the blt. If icx is reduced because of
            // cx, then jMsk must be shifted right to compensate.
            //

            icxDst   = 0;

            if (icx > cx) {
                icxDst = icx - cx;
                icx    = cx;
            }

            //
            // icxDst is now the number of pixels that can't be stored off
            // the right side of the mask
            //
            // Bit   7 6 5 4 3 2 1 0
            //      Ŀ
            // ixMsk01234567  if mask 7 and 6 can't be written, this
            //        mask gets shifted right 2 to
            //
            //
            // Bit   7 6 5 4 3 2 1 0
            //      Ŀ
            // ixMsk  012345
            //      
            //
            //
            //
            // the number of mask bits valid = 8 minus the offset (ixSrc & 0x07)
            // minus the number of pixels that can't be stored because cx
            // runs out or because cxMsk runs out (icxDst)
            //

            cx    -= icx;
            ixSrc += icx;

            if (jMsk != 0xFF) {

                jMsk  = jMsk >> icxDst;

                switch (icx)
                {
                case 8:
                    if (!(jMsk & 0x01))
                    {
                        *(pusDst+7) = (USHORT)ulPat;
                    }
                    jMsk >>= 1;
                case 7:
                    if (!(jMsk & 0x01))
                    {
                        *(pusDst+6) = (USHORT)ulPat;
                    }
                    jMsk >>= 1;
                case 6:
                    if (!(jMsk & 0x01))
                    {
                        *(pusDst+5) = (USHORT)ulPat;
                    }
                    jMsk >>= 1;
                case 5:
                    if (!(jMsk & 0x01))
                    {
                        *(pusDst+4) = (USHORT)ulPat;
                    }
                    jMsk >>= 1;
                case 4:
                    if (!(jMsk & 0x01))
                    {
                        *(pusDst+3) = (USHORT)ulPat;
                    }
                    jMsk >>= 1;
                case 3:
                    if (!(jMsk & 0x01))
                    {
                        *(pusDst+2) = (USHORT)ulPat;
                    }
                    jMsk >>= 1;
                case 2:
                    if (!(jMsk & 0x01))
                    {
                        *(pusDst+1) = (USHORT)ulPat;
                    }
                    jMsk >>= 1;
                case 1:
                    if (!(jMsk & 0x01))
                    {
                        *pusDst = (USHORT)ulPat;
                    }
                }
            }

            pusDst += icx;

        }

        //
        // increment 16 bpp Dst and 1 bpp Src to next scan line
        //

        pusDstTmp = (PUSHORT)((PBYTE)pusDstTmp + pBltInfo->lDeltaDst);
        pjSrcTmp  = pjSrcTmp  + pBltInfo->lDeltaSrc;
    }
}


/******************************Public*Routine******************************\
* Routine Name:
*
*   BltLnkPatMaskCopy24
*
* Routine Description:
*
*   Transparent Color Expansion to 24bpp
*
*   Src is a 1 Bpp mask, where src is 0, copy 1 pixel solid color
*   to Dst. Where src is 1, leave Dst unchanged.
*
* Arguments:
*
*   pBltInfo - Pointer to BLTINFO structure containing Dst and Src information
*   ulPat    - Solid color pattern
*   pBuffer  - Scan line buffer if needed
*   Invert   - XOR mask used on Src to determine whether to write
*              through "1" pixels or "0" pixels
*
* Return Value:
*
*   none
*
\**************************************************************************/

VOID
BltLnkPatMaskCopy24 (
    PBLTINFO        pBltInfo,
    ULONG           ulPat,
    PULONG          pBuffer,
    BYTE            Invert
)
{

    ULONG   jMsk     = 0;
    LONG    ixSrc;
    LONG    icx;
    LONG    cx;
    ULONG   cy       = pBltInfo->cy;
    PBYTE   pjSrcTmp = pBltInfo->pjSrc;
    PBYTE   pjDstTmp = pBltInfo->pjDst;
    PBYTE   pjSrc;
    PBYTE   pjDst;
    ULONG   icxDst;
    BYTE    jPat0 = (BYTE)ulPat;
    BYTE    jPat1 = (BYTE)(ulPat >> 8);
    BYTE    jPat2 = (BYTE)(ulPat >> 16);

    DONTUSE(pBuffer);

    while (cy--)
    {
        //
        // for each scan line, first do the writes necessary to
        // align ixSrc to zero, then operate on the
        // Src 1 byte at a time (8 pixels) or cxSrc, whichever
        // is less
        //

        //
        // init loop params
        //

        cx      = (LONG)pBltInfo->cx;
        ixSrc   = pBltInfo->xSrcStart;
        pjSrc   = pjSrcTmp;
        pjDst   = pjDstTmp + 3 * pBltInfo->xDstStart;

        //
        // finish the aligned scan line 8 mask bits at a time
        //

        while (cx > 0)
        {

            jMsk = (ULONG)pjSrc[ixSrc>>3] ^ Invert;

            //
            // icx is the number of pixels left in the mask byte
            //

            icx = 8 - (ixSrc & 0x07);

            //
            // icx is the number of pixels to operate on with this mask byte.
            // Must make sure that icx is less than cx, the number of pixels
            // remaining in the blt. If icx is reduced because of
            // cx, then jMsk must be shifted right to compensate.
            //

            icxDst   = 0;

            if (icx > cx) {
                icxDst = icx - cx;
                icx    = cx;
            }

            //
            // icxDst is now the number of pixels that can't be stored off
            // the right side of the mask
            //
            // Bit   7 6 5 4 3 2 1 0
            //      Ŀ
            // ixMsk01234567  if mask 7 and 6 can't be written, this
            //        mask gets shifted right 2 to
            //
            //
            // Bit   7 6 5 4 3 2 1 0
            //      Ŀ
            // ixMsk  012345
            //      
            //
            //
            // the number of mask bits valid = 8 minus the offset (ixSrc & 0x07)
            // minus the number of pixels that can't be stored because cx
            // runs out or because cxMsk runs out (icxDst)
            //

            cx    -= icx;
            ixSrc += icx;

            if (jMsk != 0xFF) {

                jMsk  = jMsk >> icxDst;

                switch (icx)
                {
                case 8:
                    if (!(jMsk & 0x01))
                    {
                        *(pjDst+23) = (BYTE)jPat2;
                        *(pjDst+22) = (BYTE)jPat1;
                        *(pjDst+21) = (BYTE)jPat0;
                    }
                    jMsk >>= 1;
                case 7:
                    if (!(jMsk & 0x01))
                    {
                        *(pjDst+20) = (BYTE)jPat2;
                        *(pjDst+19) = (BYTE)jPat1;
                        *(pjDst+18) = (BYTE)jPat0;
                    }
                    jMsk >>= 1;
                case 6:
                    if (!(jMsk & 0x01))
                    {
                        *(pjDst+17) = (BYTE)jPat2;
                        *(pjDst+16) = (BYTE)jPat1;
                        *(pjDst+15) = (BYTE)jPat0;
                    }
                    jMsk >>= 1;
                case 5:
                    if (!(jMsk & 0x01))
                    {
                        *(pjDst+14) = (BYTE)jPat2;
                        *(pjDst+13) = (BYTE)jPat1;
                        *(pjDst+12) = (BYTE)jPat0;
                    }
                    jMsk >>= 1;
                case 4:
                    if (!(jMsk & 0x01))
                    {
                        *(pjDst+11) = (BYTE)jPat2;
                        *(pjDst+10) = (BYTE)jPat1;
                        *(pjDst+9)  = (BYTE)jPat0;
                    }
                    jMsk >>= 1;
                case 3:
                    if (!(jMsk & 0x01))
                    {
                        *(pjDst+8) = (BYTE)jPat2;
                        *(pjDst+7) = (BYTE)jPat1;
                        *(pjDst+6) = (BYTE)jPat0;
                    }
                    jMsk >>= 1;
                case 2:
                    if (!(jMsk & 0x01))
                    {
                        *(pjDst+5) = (BYTE)jPat2;
                        *(pjDst+4) = (BYTE)jPat1;
                        *(pjDst+3) = (BYTE)jPat0;
                    }
                    jMsk >>= 1;
                case 1:
                    if (!(jMsk & 0x01))
                    {
                        *(pjDst+2) = (BYTE)jPat2;
                        *(pjDst+1) = (BYTE)jPat1;
                        *pjDst     = (BYTE)jPat0;
                    }
                }
            }

            pjDst += icx * 3;

        }

        //
        // increment 24 bpp Dst and 1 bpp Src to next scan line
        //

        pjDstTmp = pjDstTmp + pBltInfo->lDeltaDst;
        pjSrcTmp = pjSrcTmp + pBltInfo->lDeltaSrc;
    }
}


/******************************Public*Routine******************************\
* Routine Name:
*
*   BltLnkPatMaskCopy32
*
* Routine Description:
*
*   Transparent Color Expansion to 32bpp
*
*   Src is a 1 Bpp mask, where src is 0, copy 1 pixel solid color
*   to Dst. Where src is 1, leave Dst unchanged.
*
* Arguments:
*
*   pBltInfo - Pointer to BLTINFO structure containing Dst and Src information
*   ulPat    - Solid color pattern
*   pBuffer  - Scan line buffer if needed
*   Invert   - XOR mask used on Src to determine whether to write
*              through "1" pixels or "0" pixels
*
* Return Value:
*
*   none
*
\**************************************************************************/

VOID
BltLnkPatMaskCopy32 (
    PBLTINFO        pBltInfo,
    ULONG           ulPat,
    PULONG          pBuffer,
    BYTE            Invert
)
{

    ULONG   jMsk = 0;
    LONG    ixSrc;
    LONG    icx;
    LONG    cx;
    ULONG   cy        = pBltInfo->cy;
    PBYTE   pjSrcTmp  = pBltInfo->pjSrc;
    PULONG  pulDstTmp = (PULONG)pBltInfo->pjDst;
    PBYTE   pjSrc;
    PULONG  pulDst;
    ULONG   icxDst;

    DONTUSE(pBuffer);



    while (cy--)
    {
        //
        // for each scan line, first do the writes necessary to
        // align ixSrc to zero, then operate on the
        // Src 1 byte at a time (8 pixels) or cxSrc, whichever
        // is less
        //

        //
        // init loop params
        //

        cx      = (LONG)pBltInfo->cx;
        ixSrc   = pBltInfo->xSrcStart;
        pjSrc   = pjSrcTmp;
        pulDst  = pulDstTmp + pBltInfo->xDstStart;

        //
        // finish the aligned scan line 8 mask bits at a time
        //

        while (cx > 0)
        {

            jMsk = (ULONG)pjSrc[ixSrc>>3] ^ Invert;

            //
            // icx is the number of pixels left in the mask byte
            //

            icx = 8 - (ixSrc & 0x07);

            //
            // icx is the number of pixels to operate on with this mask byte.
            // Must make sure that icx is less than cx, the number of pixels
            // remaining in the blt. If icx is reduced because of
            // cx, then jMsk must be shifted right to compensate.
            //

            icxDst   = 0;

            if (icx > cx) {
                icxDst = icx - cx;
                icx    = cx;
            }

            //
            // icxDst is now the number of pixels that can't be stored off
            // the right side of the mask
            //
            // Bit   7 6 5 4 3 2 1 0
            //      Ŀ
            // ixMsk01234567  if mask 7 and 6 can't be written, this
            //        mask gets shifted right 2 to
            //
            //
            // Bit   7 6 5 4 3 2 1 0
            //      Ŀ
            // ixMsk  012345
            //      
            //
            //
            //
            // the number of mask bits valid = 8 minus the offset (ixSrc & 0x07)
            // minus the number of pixels that can't be stored because cx
            // runs out or because cxMsk runs out (icxDst)
            //

            cx    -= icx;
            ixSrc += icx;

            if (jMsk != 0xFF) {

                jMsk  = jMsk >> icxDst;


                switch (icx)
                {
                case 8:
                    if (!(jMsk & 0x01))
                    {
                        *(pulDst+7) = ulPat;
                    }
                    jMsk >>= 1;
                case 7:
                    if (!(jMsk & 0x01))
                    {
                        *(pulDst+6) = ulPat;
                    }
                    jMsk >>= 1;
                case 6:
                    if (!(jMsk & 0x01))
                    {
                        *(pulDst+5) = ulPat;
                    }
                    jMsk >>= 1;
                case 5:
                    if (!(jMsk & 0x01))
                    {
                        *(pulDst+4) = ulPat;
                    }
                    jMsk >>= 1;
                case 4:
                    if (!(jMsk & 0x01))
                    {
                        *(pulDst+3) = ulPat;
                    }
                    jMsk >>= 1;
                case 3:
                    if (!(jMsk & 0x01))
                    {
                        *(pulDst+2) = ulPat;
                    }
                    jMsk >>= 1;
                case 2:
                    if (!(jMsk & 0x01))
                    {
                        *(pulDst+1) = ulPat;
                    }
                    jMsk >>= 1;
                case 1:
                    if (!(jMsk & 0x01))
                    {
                        *pulDst = ulPat;
                    }
                }
            }

            pulDst += icx;

        }

        //
        // increment 32 bpp Dst and 1 bpp Src to next scan line
        //

        pulDstTmp = (PULONG)((PBYTE)pulDstTmp + pBltInfo->lDeltaDst);
        pjSrcTmp  = pjSrcTmp  + pBltInfo->lDeltaSrc;
    }
}



/******************************Public*Routine******************************\
* Routine Name:
*
*   BltLnkAccel6666
*
* Routine Description:
*
*   Special case accelerator for 8bpp to 8bpp no translation ROP 6666
*   D = S xor D
*
* Arguments:
*
*   pjSrcStart   - address of first src byte
*   pjDstStart   - address of first dst byte
*   lDeltaSrcDir - delta address for src scan lines
*   lDeltaDstDir - delta address for dst scan lines
*   cx           - pixels per scan line
*   cy           - number of scan lines
*
* Return Value:
*
*   none
*
\**************************************************************************/

VOID
BltLnkAccel6666 (
    PBYTE pjSrcStart,
    PBYTE pjDstStart,
    LONG  lDeltaSrcDir,
    LONG  lDeltaDstDir,
    LONG  cx,
    LONG  cy
)
{

    //
    // ROP 6666   8Bpp
    //

    ULONG ulCx4   = cx >> 2;
    ULONG ulCxOdd = cx & 0x03;
    ULONG ulCxTemp;
    ULONG ulSrc;
    PBYTE pjSrc;
    PBYTE pjDst;

    while(cy--)
    {

        pjSrc = pjSrcStart;
        pjDst = pjDstStart;

        //
        // NOTE PERF: We can have the loop handle dword aligned pels and
        // take care of the non-aligned head/tail separately.
        //

        for (ulCxTemp = ulCx4; ulCxTemp > 0; ulCxTemp--)
        {
            ulSrc = *(DWORD UNALIGNED *)pjSrc;
            if (ulSrc != 0) {
                *(DWORD UNALIGNED *)pjDst ^= ulSrc;
            }
            pjSrc += 4;
            pjDst += 4;
        }

        for (ulCxTemp = ulCxOdd; ulCxTemp > 0; ulCxTemp--)
        {
            *pjDst++ ^= *pjSrc++;
        }

        pjDstStart = pjDstStart + lDeltaDstDir;
        pjSrcStart = pjSrcStart + lDeltaSrcDir;
    }
}


/******************************Public*Routine******************************\
* Routine Name:
*
*   BltLnkAccel8888
*
* Routine Description:
*
*   Special case accelerator for 8bpp to 8bpp no translation ROP 8888
*   D = S and D
*
* Arguments:
*
*   pjSrcStart   - address of first src byte
*   pjDstStart   - address of first dst byte
*   lDeltaSrcDir - delta address for src scan lines
*   lDeltaDstDir - delta address for dst scan lines
*   cx           - pixels per scan line
*   cy           - number of scan lines
*
* Return Value:
*
*   none
*
\**************************************************************************/

VOID
BltLnkAccel8888(
    PBYTE pjSrcStart,
    PBYTE pjDstStart,
    LONG  lDeltaSrcDir,
    LONG  lDeltaDstDir,
    LONG  cx,
    LONG  cy
)
{

    //
    // With no translation, we can go a dword at a time and really
    // fly
    //

    ULONG ulCx4   = cx >> 2;
    ULONG ulCxOdd = cx & 0x03;
    ULONG ulCxTemp;
    ULONG ulSrc;
    PBYTE pjSrc;
    PBYTE pjDst;

    while(cy--)
    {
        pjSrc = pjSrcStart;
        pjDst = pjDstStart;

        //
        // NOTE PERF: We can have the loop handle dword aligned pels and
        // take care of the non-aligned head/tail separately.
        // We could also special-case source 0 and 0xFF to avoid
        // unnecessary reads and writes
        //

        for (ulCxTemp = ulCx4; ulCxTemp > 0; ulCxTemp--)
        {
            ulSrc = *(DWORD UNALIGNED *)pjSrc;

            if (ulSrc != ~0) {
                if (ulSrc == 0) {
                    *(DWORD UNALIGNED *)pjDst = 0;
                } else {
                    *(DWORD UNALIGNED *)pjDst &= ulSrc;
                }
            }

            pjSrc += 4;
            pjDst += 4;
        }

        for (ulCxTemp = ulCxOdd; ulCxTemp > 0; ulCxTemp--)
        {
            *pjDst++ &= *pjSrc++;
        }

        pjDstStart = pjDstStart + lDeltaDstDir;
        pjSrcStart = pjSrcStart + lDeltaSrcDir;
    }
    return;
}


/******************************Public*Routine******************************\
* Routine Name:
*
*   BltLnkAccelEEEE
*
* Routine Description:
*
*   Special case accelerator for 8bpp to 8bpp no translation ROP EEEE7
*   D = S or D
*
* Arguments:
*
*   pjSrcStart   - address of first src byte
*   pjDstStart   - address of first dst byte
*   lDeltaSrcDir - delta address for src scan lines
*   lDeltaDstDir - delta address for dst scan lines
*   cx           - pixels per scan line
*   cy           - number of scan lines
*
* Return Value:
*
*   none
*
\**************************************************************************/

VOID
BltLnkAccelEEEE (
    PBYTE pjSrcStart,
    PBYTE pjDstStart,
    LONG  lDeltaSrcDir,
    LONG  lDeltaDstDir,
    LONG  cx,
    LONG  cy
)

{

    //
    // With no translation, we can go a dword at a time and really
    // fly
    //

    ULONG ulCx4   = cx >> 2;
    ULONG ulCxOdd = cx & 0x03;
    ULONG ulCxTemp;
    ULONG ulSrc;
    PBYTE pjSrc;
    PBYTE pjDst;

    while(cy--)
    {
        pjSrc = pjSrcStart;
        pjDst = pjDstStart;

        //
        // NOTE PERF: We can have the loop handle dword aligned pels and
        // take care of the non-dword-aligned pels separately.
        // We could also special-case source 0 and 0xFF to avoid
        // unnecessary reads and writes
        //

        for (ulCxTemp = ulCx4; ulCxTemp > 0; ulCxTemp--)
        {
            ulSrc = *(DWORD UNALIGNED *)pjSrc;

            if (ulSrc != 0) {
                if (ulSrc == ~0) {
                    *(DWORD UNALIGNED *)pjDst = 0xffffffff;
                } else {
                    *(DWORD UNALIGNED *)pjDst |= ulSrc;
                }
            }
            pjSrc += 4;
            pjDst += 4;
        }

        for (ulCxTemp = ulCxOdd; ulCxTemp > 0; ulCxTemp--)
        {
            *pjDst++ |= *pjSrc++;
        }

        pjDstStart = pjDstStart + lDeltaDstDir;
        pjSrcStart = pjSrcStart + lDeltaSrcDir;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\atmstub.c ===
/******************************Module*Header*******************************\
* Module Name: atmstub.c
*
* Copyright (c) 1998-1999 Microsoft Corporation
\**************************************************************************/

#include "engine.h"
#include "atmstub.h"

#define ARRAYSIZE(a)                (sizeof(a) / sizeof(*(a)))
#define ESC_NOT_SUPPORTED           0
#define ESC_IS_SUPPORTED            1
#define BEG_OF_ATM_ESCAPE_LIST      0x2500
#define END_OF_ATM_ESCAPE_LIST      0x2600  //Allocated 256 escapes to ATM.


DRVFN atmfdCallBlock[] =
{
    {INDEX_DrvEnablePDEV,               (PFN)atmfdEnablePDEV},
    {INDEX_DrvDisablePDEV,              (PFN)atmfdDisablePDEV},
    {INDEX_DrvCompletePDEV,             (PFN)atmfdCompletePDEV},
    {INDEX_DrvLoadFontFile,             (PFN)atmfdLoadFontFile},
    {INDEX_DrvQueryFontCaps,            (PFN)atmfdQueryFontCaps},
    {INDEX_DrvUnloadFontFile,           (PFN)atmfdUnloadFontFile},
    {INDEX_DrvQueryFontFile,            (PFN)atmfdQueryFontFile},
    {INDEX_DrvQueryFont,                (PFN)atmfdQueryFont},
    {INDEX_DrvFree,                     (PFN)atmfdFree},
    {INDEX_DrvQueryFontTree,            (PFN)atmfdQueryFontTree},
    {INDEX_DrvQueryFontData,            (PFN)atmfdQueryFontData},
    {INDEX_DrvDestroyFont,              (PFN)atmfdDestroyFont},
    {INDEX_DrvQueryAdvanceWidths,       (PFN)atmfdQueryAdvanceWidths},
    {INDEX_DrvQueryTrueTypeOutline,     (PFN)atmfdQueryTrueTypeOutline},
    {INDEX_DrvQueryTrueTypeTable,       (PFN)atmfdQueryTrueTypeTable},
    {INDEX_DrvEscape,                   (PFN)atmfdEscape},
    {INDEX_DrvFontManagement,           (PFN)atmfdFontManagement},
    {INDEX_DrvGetTrueTypeFile,          (PFN)atmfdGetTrueTypeFile},
    {INDEX_DrvQueryGlyphAttrs,          (PFN)atmfdQueryGlyphAttrs},
};
UINT ARRAYSIZE_atmfdCallBlock = ARRAYSIZE(atmfdCallBlock);

//Typedefs for functions pointers...
typedef BOOL (APIENTRY *DRV_ENABLE_DRIVER)(ULONG, ULONG, PDRVENABLEDATA);
typedef LONG (APIENTRY *DRV_QUERY_FONT_CAPS)(ULONG, PULONG);
typedef BOOL (APIENTRY *DRV_UNLOAD_FONT_FILE)(ULONG_PTR);
typedef LONG (APIENTRY *DRV_QUERY_FONT_FILE)(ULONG_PTR, ULONG, ULONG, PULONG);
typedef PIFIMETRICS (APIENTRY *DRV_QUERY_FONT)(DHPDEV, ULONG_PTR, ULONG, ULONG_PTR*);
typedef VOID (APIENTRY *DRV_FREE)(PVOID, ULONG_PTR);
typedef PVOID (APIENTRY *DRV_QUERY_FONT_TREE)(DHPDEV, ULONG_PTR, ULONG, ULONG, ULONG_PTR*);
typedef LONG (APIENTRY *DRV_QUERY_FONT_DATA)(DHPDEV, FONTOBJ*, ULONG, HGLYPH, GLYPHDATA*, PVOID, ULONG);
typedef VOID (APIENTRY *DRV_DESTROY_FONT)(FONTOBJ*);
typedef BOOL (APIENTRY *DRV_QUERY_ADVANCE_WIDTHS)(DHPDEV, FONTOBJ*, ULONG, PHGLYPH, PVOID, ULONG);
typedef LONG (APIENTRY *DRV_QUERY_TRUE_TYPE_OUTLINE)(DHPDEV, FONTOBJ*, HGLYPH, BOOL, GLYPHDATA*, ULONG, TTPOLYGONHEADER*);
typedef ULONG (APIENTRY *DRV_ESCAPE)(SURFOBJ*, ULONG, ULONG, PVOID, ULONG, PVOID);
typedef ULONG (APIENTRY *DRV_FONT_MANAGEMENT)(SURFOBJ*, FONTOBJ*, ULONG, ULONG, PVOID, ULONG, PVOID);
typedef PVOID (APIENTRY *DRV_GET_TRUE_TYPE_FILE)(ULONG_PTR, PULONG);
typedef ULONG_PTR (APIENTRY *DRV_LOAD_FONT_FILE)(ULONG, PULONG_PTR, PVOID*, PULONG, PDESIGNVECTOR, ULONG, ULONG);
typedef LONG (APIENTRY *DRV_QUERY_TRUE_TYPE_TABLE)(ULONG_PTR, ULONG, ULONG, PTRDIFF, ULONG, PBYTE, PBYTE*, PULONG);
typedef PFD_GLYPHATTR (APIENTRY *DRV_QUERY_GLYPH_ATTRS)(FONTOBJ*, ULONG);

//Globals...
//Function pointers....
DRV_ENABLE_DRIVER               pAtmfdEnableDriver = NULL;
DRV_LOAD_FONT_FILE              pAtmfdLoadFontFile = NULL;
DRV_UNLOAD_FONT_FILE            pAtmfdUnloadFontFile = NULL;
DRV_QUERY_FONT_FILE             pAtmfdQueryFontFile = NULL;
DRV_QUERY_FONT                  pAtmfdQueryFont = NULL;
DRV_FREE                        pAtmfdFree = NULL;
DRV_QUERY_FONT_TREE             pAtmfdQueryFontTree = NULL;
DRV_QUERY_FONT_DATA             pAtmfdQueryFontData = NULL;
DRV_DESTROY_FONT                pAtmfdDestroyFont = NULL;
DRV_QUERY_ADVANCE_WIDTHS        pAtmfdQueryAdvanceWidths = NULL;
DRV_QUERY_TRUE_TYPE_OUTLINE     pAtmfdQueryTrueTypeOutline = NULL;
DRV_QUERY_TRUE_TYPE_TABLE       pAtmfdQueryTrueTypeTable = NULL;
DRV_ESCAPE                      pAtmfdEscape = NULL;
DRV_FONT_MANAGEMENT             pAtmfdFontManagement = NULL;
DRV_GET_TRUE_TYPE_FILE          pAtmfdGetTrueTypeFile = NULL;
DRV_QUERY_GLYPH_ATTRS           pAtmfdQueryGlyphAttrs = NULL;

HANDLE                          atmfdHandle = NULL;
BOOL                            driverFailedLoad = FALSE;
ULONG                           engineVersion = 0;
DRVENABLEDATA                   atmfdFuncData = {0};


//------------------------------------------------------------------------------
static PVOID FindFunc(
    ULONG     funcIndex)
{
    PVOID   result = NULL;
    UINT    i;

    for (i = 0; i < ARRAYSIZE_atmfdCallBlock; i++)
    {
        if (atmfdFuncData.pdrvfn[i].iFunc == funcIndex)
        {
            result = (PVOID)atmfdFuncData.pdrvfn[i].pfn;
            break;
        }
    }
    
    return result;
}


//------------------------------------------------------------------------------
static BOOL InitializeDriver(void)
{
    BOOL    result = FALSE;

    GreAcquireSemaphore(ghsemAtmfdInit);

    //Has the driver already been loaded?
    if (atmfdHandle != NULL)
    {
        result = TRUE;
        goto ExitPoint;
    }

    //Have we attempted to load the driver previously but failed?
    if (driverFailedLoad == TRUE)
        goto ExitPoint;

    //Load an image of the ATM font driver...
    if ((atmfdHandle = EngLoadImage(L"ATMFD.DLL")) == NULL)
        goto ExitPoint;

    //Get a pointer to the DrvEnableDriver function...
    if ((pAtmfdEnableDriver = EngFindImageProcAddress(atmfdHandle, "DrvEnableDriver")) == NULL)
        goto ExitPoint;

    //Initialize the ATMFD driver...
    if ((*pAtmfdEnableDriver)(engineVersion, sizeof(atmfdFuncData), &atmfdFuncData) == FALSE)
        goto ExitPoint;

    //Check driver version number...
    if (atmfdFuncData.iDriverVersion != DDI_DRIVER_VERSION_NT5)
        goto ExitPoint;

    //Now get the rest of the function pointers...
    if ((pAtmfdLoadFontFile = FindFunc(INDEX_DrvLoadFontFile)) == NULL)
        goto ExitPoint;
    if ((pAtmfdUnloadFontFile = FindFunc(INDEX_DrvUnloadFontFile)) == NULL)
        goto ExitPoint;
    if ((pAtmfdQueryFontFile = FindFunc(INDEX_DrvQueryFontFile)) == NULL)
        goto ExitPoint;
    if ((pAtmfdQueryFont = FindFunc(INDEX_DrvQueryFont)) == NULL)
        goto ExitPoint;
    if ((pAtmfdFree = FindFunc(INDEX_DrvFree)) == NULL)
        goto ExitPoint;
    if ((pAtmfdQueryFontTree = FindFunc(INDEX_DrvQueryFontTree)) == NULL)
        goto ExitPoint;
    if ((pAtmfdQueryFontData = FindFunc(INDEX_DrvQueryFontData)) == NULL)
        goto ExitPoint;
    if ((pAtmfdDestroyFont = FindFunc(INDEX_DrvDestroyFont)) == NULL)
        goto ExitPoint;
    if ((pAtmfdQueryAdvanceWidths = FindFunc(INDEX_DrvQueryAdvanceWidths)) == NULL)
        goto ExitPoint;
    if ((pAtmfdQueryTrueTypeOutline = FindFunc(INDEX_DrvQueryTrueTypeOutline)) == NULL)
        goto ExitPoint;
    if ((pAtmfdQueryTrueTypeTable = FindFunc(INDEX_DrvQueryTrueTypeTable)) == NULL)
        goto ExitPoint;
    if ((pAtmfdEscape = FindFunc(INDEX_DrvEscape)) == NULL)
        goto ExitPoint;
    if ((pAtmfdFontManagement = FindFunc(INDEX_DrvFontManagement)) == NULL)
        goto ExitPoint;
    if ((pAtmfdGetTrueTypeFile = FindFunc(INDEX_DrvGetTrueTypeFile)) == NULL)
        goto ExitPoint;
    if ((pAtmfdQueryGlyphAttrs = FindFunc(INDEX_DrvQueryGlyphAttrs)) == NULL)
        goto ExitPoint;

    result = TRUE;
ExitPoint:
    if (result == FALSE)
    {
        driverFailedLoad = TRUE;
        if (atmfdHandle != NULL)
        {
            EngUnloadImage(atmfdHandle);
            atmfdHandle = NULL;
        }
    }

    GreReleaseSemaphore(ghsemAtmfdInit);

    return result;
}


//------------------------------------------------------------------------------
BOOL APIENTRY atmfdEnableDriver(
    ULONG           iEngineVersion,
    ULONG           cj,
    PDRVENABLEDATA  pded) 
// Requests that the driver fill a structure with pointers to supported                 
// functions and other control information. The function returns TRUE if                 
// the driver is enabled FALSE otherwise.                                                                               
{
    engineVersion = iEngineVersion;
    if (cj >= sizeof(DRVENABLEDATA))
    {
        pded->pdrvfn = atmfdCallBlock;
        pded->c = ARRAYSIZE_atmfdCallBlock;
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT5;
        return TRUE;
    }
    return FALSE;
}


//------------------------------------------------------------------------------
VOID APIENTRY atmfdDisableDriver(void) 
{
    if (atmfdHandle)
    {
        EngUnloadImage(atmfdHandle);
        atmfdHandle = NULL;
    }
}


//------------------------------------------------------------------------------
DHPDEV APIENTRY atmfdEnablePDEV(
    DEVMODEW*   pdm,
    PWSTR       pwszLogAddr,
    ULONG       cPat,
    HSURF*      phsurfPatterns,
    ULONG       cjCaps,
    ULONG*      pdevcaps,
    ULONG       cjDevInfo,
    DEVINFO*    pdi,
    HDEV        hdev,
    PWSTR       pwszDeviceName,
    HANDLE      hDriver)
{
    return ((DHPDEV) EngAllocMem(FL_ZERO_MEMORY, 4, 0));
}


//------------------------------------------------------------------------------
VOID APIENTRY atmfdDisablePDEV(
    DHPDEV  dhpdev)
{
    EngFreeMem(dhpdev);
}


//------------------------------------------------------------------------------
VOID APIENTRY atmfdCompletePDEV(
    DHPDEV dhpdev,
    HDEV   hdev)
{
    return;
}


//------------------------------------------------------------------------------
ULONG_PTR APIENTRY atmfdLoadFontFile(      //Returns IFILE value
    ULONG           cFiles,  // number of font files associated with this font
    PULONG_PTR      piFile,  // handles for individual files, cFiles of them
    PVOID           *ppvView, // array of cFiles views
    PULONG          pcjView, // array of their sizes
    PDESIGNVECTOR   pdv,
    ULONG           ulLangID,
    ULONG           ulFastCheckSum)
{
    if (InitializeDriver())
        return (*pAtmfdLoadFontFile)(cFiles, piFile, ppvView, pcjView, pdv, ulLangID, ulFastCheckSum);
    else
        return 0;
}


//------------------------------------------------------------------------------
LONG APIENTRY atmfdQueryFontCaps(
    ULONG   culCaps,
    PULONG  pulCaps)
{
    if (culCaps >= 2)
    {
        pulCaps[0] = 2L;
        pulCaps[1] = QC_OUTLINES | QC_1BIT | QC_4BIT;
        return 2;
    }
    else
        return FD_ERROR;
}


//------------------------------------------------------------------------------
BOOL APIENTRY atmfdUnloadFontFile(
    ULONG_PTR iFile)
{
    return (*pAtmfdUnloadFontFile)(iFile);
}


//------------------------------------------------------------------------------
LONG APIENTRY atmfdQueryFontFile(
    ULONG_PTR   iFile,  
    ULONG       ulMode,  
    ULONG       cjBuf,  
    PULONG      pulBuf) 
{
    return (*pAtmfdQueryFontFile)(iFile, ulMode, cjBuf, pulBuf);
}


//------------------------------------------------------------------------------
PIFIMETRICS APIENTRY atmfdQueryFont(
    DHPDEV      dhpdev, 
    ULONG_PTR   iFile, 
    ULONG       iFace, 
    ULONG_PTR  *pid)
{
    return (*pAtmfdQueryFont)(dhpdev, iFile, iFace, pid);
}


//------------------------------------------------------------------------------
VOID APIENTRY atmfdFree(
    PVOID pv,
    ULONG_PTR id)
{
    (*pAtmfdFree)(pv, id);
}


//------------------------------------------------------------------------------
PVOID APIENTRY atmfdQueryFontTree(
    DHPDEV      dhpdev, 
    ULONG_PTR   iFile, 
    ULONG       iFace, 
    ULONG       iMode, 
    ULONG_PTR  *pid) 
{
    return (*pAtmfdQueryFontTree)(dhpdev, iFile, iFace, iMode, pid);
}


//------------------------------------------------------------------------------
LONG APIENTRY atmfdQueryFontData(
    DHPDEV      dhpdev, 
    FONTOBJ     *pfo, 
    ULONG       iMode, 
    HGLYPH      hg, 
    GLYPHDATA   *pgd, 
    PVOID       pv, 
    ULONG       cjSize) 
{
    return (*pAtmfdQueryFontData)(dhpdev, pfo, iMode, hg, pgd, pv, cjSize);
}


//------------------------------------------------------------------------------
VOID APIENTRY atmfdDestroyFont(
    FONTOBJ *pfo) 
{
    (*pAtmfdDestroyFont)(pfo);
}


//------------------------------------------------------------------------------
BOOL APIENTRY atmfdQueryAdvanceWidths(
    DHPDEV      dhpdev,
    FONTOBJ     *pfo,
    ULONG       iMode,
    PHGLYPH     pGlyphHandle,
    PVOID       widths,
    ULONG       numOfGlyphs)
{
    return (*pAtmfdQueryAdvanceWidths)(dhpdev, pfo, iMode, pGlyphHandle, widths, numOfGlyphs);
}


//------------------------------------------------------------------------------
LONG APIENTRY atmfdQueryTrueTypeOutline(
    DHPDEV              dhpdev, 
    FONTOBJ             *pfo, 
    HGLYPH              hg, 
    BOOL                metricsOnly,
    GLYPHDATA           *pgd, 
    ULONG               cjSize,
    TTPOLYGONHEADER     *pgHead)
{
    return (*pAtmfdQueryTrueTypeOutline)(dhpdev, pfo, hg, metricsOnly, pgd, cjSize, pgHead);
}


//------------------------------------------------------------------------------
LONG APIENTRY atmfdQueryTrueTypeTable(
    ULONG_PTR   iFile,
    ULONG       ulFont,
    ULONG       ulTag,
    PTRDIFF     dpStart,
    ULONG       cjBuf,
    PBYTE       pjBuf,
    PBYTE       *ppjTable,
    PULONG      pcjTable)
{
    return (*pAtmfdQueryTrueTypeTable)(iFile, ulFont, ulTag, dpStart, cjBuf, pjBuf, ppjTable, pcjTable);
}


//------------------------------------------------------------------------------
PFD_GLYPHATTR APIENTRY atmfdQueryGlyphAttrs(
    FONTOBJ       *pfo,
    ULONG          iMode)
{
    return (*pAtmfdQueryGlyphAttrs)(pfo, iMode);
}


//------------------------------------------------------------------------------
ULONG APIENTRY atmfdEscape(
    SURFOBJ *pso,
    ULONG    iEsc,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut)
{
    return atmfdFontManagement(pso, NULL, iEsc, cjIn, pvIn, cjOut, pvOut);
}


//------------------------------------------------------------------------------
ULONG APIENTRY atmfdFontManagement(
    SURFOBJ *pso,
    FONTOBJ *pfo,
    ULONG    iEsc,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut)
{
    ULONG   result = ESC_NOT_SUPPORTED;
    BOOL    callDriver = FALSE;

    switch(iEsc)
    {
        case QUERYESCSUPPORT:
        {
            switch (*((PULONG)pvIn))
            {
                case QUERYESCSUPPORT:
                case GETEXTENDEDTEXTMETRICS:
                    result = ESC_IS_SUPPORTED;
                    break;
                default:
                    if ((*((PULONG)pvIn) > BEG_OF_ATM_ESCAPE_LIST) && (*((PULONG)pvIn) < END_OF_ATM_ESCAPE_LIST))
                        result = ESC_IS_SUPPORTED;
            }
            break;
        }
        case GETEXTENDEDTEXTMETRICS:
        {
            callDriver = TRUE;
            break;
        }
        default:
        {
            if ((iEsc <= BEG_OF_ATM_ESCAPE_LIST) || (iEsc >= END_OF_ATM_ESCAPE_LIST))
                break;

            callDriver = TRUE;
            break;
        }
    }
    if (callDriver)
    {
        if (InitializeDriver() == TRUE)
        {
            return (*pAtmfdFontManagement)(pso, pfo, iEsc, cjIn, pvIn, cjOut, pvOut);
        }
    }
    return result;
}


//------------------------------------------------------------------------------
PVOID APIENTRY atmfdGetTrueTypeFile(
    ULONG_PTR   iFile,
    PULONG      pcj)
{
    return (*pAtmfdGetTrueTypeFile)(iFile, pcj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\brushapi.cxx ===
/******************************Module*Header*******************************\
* Module Name: brushapi.cxx                                                *
*                                                                          *
* Contains all the various GDI versions of Brush creation.                 *
*                                                                          *
* Created: 06-Nov-1990 14:46:03                                            *
* Author: Walt Moore [waltm]                                               *
*                                                                          *
* Copyright (c) 1990-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.hxx"
#include "engline.hxx"

// Default wide-line style arrays:

ULONG gaulGeometricDot[]              = { 1, 1 };
ULONG gaulGeometricDash[]             = { 3, 1 };
ULONG gaulGeometricDashDot[]          = { 3, 1, 1, 1 };
ULONG gaulGeometricDashDotDot[]       = { 3, 1, 1, 1, 1, 1 };

// Default cosmetic style arrays (must all sum to 8):

LONG_FLOAT galeCosmeticDot[]        = { {1}, {1}, {1}, {1},
                                        {1}, {1}, {1}, {1} };
LONG_FLOAT galeCosmeticDash[]       = { {6}, {2} };
LONG_FLOAT galeCosmeticDashDot[]    = { {3}, {2}, {1}, {2} };
LONG_FLOAT galeCosmeticDashDotDot[] = { {3}, {1}, {1}, {1}, {1}, {1} };


/**************************************************************************\
* hCreateSolidBrushInternal(clrr, bPen)
*
* Creates a solid brush.  Whether or not the brush is solid or dithered
* will depend on what mode the DC is in at realization time.
*
\**************************************************************************/

HBRUSH
hCreateSolidBrushInternal(
    COLORREF clrr,
    BOOL     bPen,
    HBRUSH   hbr,
    BOOL     bSharedMem)
{
    HBRUSH hbrReturn = NULL;

    if (hbr)
    {
        //
        // If an already created brush is passed, just try to set it.
        //

        if (GreSetSolidBrushInternal(hbr,clrr,bPen,FALSE))
        {
            hbrReturn = hbr;
        }
    }
    else
    {
        BRUSHMEMOBJ brmo(clrr, HS_DITHEREDCLR, bPen, bSharedMem);

        if (brmo.bValid())
        {
            brmo.vKeepIt();
            brmo.vEnableDither();

            hbrReturn = brmo.hbrush();
        }
    }

    return hbrReturn;
}


/**************************************************************************\
* GreCreateSolidBrush()
*
\**************************************************************************/

HBRUSH
GreCreateSolidBrush(
    COLORREF clrr)
{
    return(hCreateSolidBrushInternal(clrr,FALSE,NULL,FALSE));
}

/**************************************************************************\
* NtGdiCreateSolidBrush()
*
\**************************************************************************/

HBRUSH
APIENTRY
NtGdiCreateSolidBrush(
    COLORREF cr,
    HBRUSH   hbr
    )
{
    HBRUSH hbrush;

    hbrush = hCreateSolidBrushInternal(cr, FALSE, hbr, TRUE);

    return (hbrush);
}




/**************************************************************************\
* hCreateHatchBrushInternal(ulStyle, clrr, bPen)
*
* Creates a hatch brush.
*
* History:
*  07-Jun-1995 -by- Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

HBRUSH
hCreateHatchBrushInternal(
    ULONG ulStyle,
    COLORREF clrr,
    BOOL bPen)
{
    HBRUSH hbr = NULL;

    if (ulStyle <= HS_API_MAX-1)
    {
        BRUSHMEMOBJ brmo(clrr, ulStyle, bPen, FALSE);

        if (brmo.bValid())
        {
            brmo.vKeepIt();
            hbr = brmo.hbrush();
        }
    }


    return hbr;
}

/**************************************************************************\
* NtGdiCreateHatchBrushInternal(ulStyle, clrr, bPen)
*
\**************************************************************************/


HBRUSH
APIENTRY
NtGdiCreateHatchBrushInternal(
    ULONG    ulStyle,
    COLORREF cr,
    BOOL     bPen
    )
{
    HBRUSH   hbrush;

    hbrush = hCreateHatchBrushInternal (ulStyle, cr, bPen);

    return (hbrush);

}

/******************************Public*Routine******************************\
* NtGdiCreatePatternBrushInternal()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HBRUSH
APIENTRY
NtGdiCreatePatternBrushInternal(
    HBITMAP hbm,
    BOOL    bPen,
    BOOL    b8X8
    )
{
    HBRUSH  hbrush;

    hbrush = GreCreatePatternBrushInternal(hbm,bPen,b8X8);

    return (hbrush);
}

/******************************Public*Routine******************************\
* NtGdiCreateDIBBrush()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HBRUSH
APIENTRY
NtGdiCreateDIBBrush(
    PVOID pv,
    FLONG fl,
    UINT  cj,
    BOOL  b8X8,
    BOOL  bPen,
    PVOID pClient
    )
{
    HBRUSH hbrRet;
    PVOID pvTmp;

    pvTmp = AllocFreeTmpBuffer(cj);

    if (pvTmp)
    {
        hbrRet = (HBRUSH)1;

        __try
        {
            ProbeForRead(pv,cj, sizeof(BYTE));
            RtlCopyMemory(pvTmp,pv,cj);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            // SetLastError(GetExceptionCode());

            hbrRet = (HBRUSH)0;
        }

        if (hbrRet)
        {
            hbrRet = GreCreateDIBBrush(pvTmp,fl,cj,b8X8,bPen,pClient);
        }
        FreeTmpBuffer(pvTmp);
    }
    else
    {
        // SetLastError();
        hbrRet = (HBRUSH)0;
    }

    return(hbrRet);
}



/**************************************************************************\
* GreCreatePatternBrushInternal(hbm, bPen)
*
* Creates a pattern brush from the bitmap passed in.
*
* History:
*  Mon 24-Jun-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

HBRUSH GreCreatePatternBrushInternal(
    HBITMAP hbm,
    BOOL bPen,
    BOOL b8X8)
{
    HBRUSH  hbrReturn = (HBRUSH) 0;
    SURFREF SurfBmo((HSURF)hbm);

    if (SurfBmo.bValid())
    {
        if (SurfBmo.ps->bApiBitmap())
        {
            HBITMAP hbmClone;

            if (b8X8)
                hbmClone = hbmCreateClone(SurfBmo.ps,8,8);
            else
                hbmClone = hbmCreateClone(SurfBmo.ps,0,0);

            if (hbmClone != (HBITMAP) 0)
            {
                XEPALOBJ pal(SurfBmo.ps->ppal());

                BRUSHMEMOBJ brmo(hbmClone, hbm, pal.bIsMonochrome(), DIB_RGB_COLORS,
                                 BR_IS_BITMAP, bPen);

                if (brmo.bValid())
                {
                    hbrReturn = brmo.hbrush();
                    brmo.vKeepIt();
                }                            // hmgr logs error code
            }                                // hmgr logs error code
        }
        else
        {
            WARNING("GreCreatePatternBrushInternal: Invalid surface");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }

    return(hbrReturn);
}

HBRUSH GreCreatePatternBrush(HBITMAP hbm)
{
    return(GreCreatePatternBrushInternal(hbm,FALSE,FALSE));
}

/******************************Public*Routine******************************\
* GreCreateDIBBrush
*
* Creates a DIB pattern brush.
*
* History:
*  02-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HBRUSH
GreCreateDIBBrush(PVOID pv, FLONG fl, UINT cjMax, BOOL b8X8, BOOL bPen, PVOID pClient)
{
// Validate your parameters.

    if ((pv == (PVOID) 0)                  ||
        (cjMax < sizeof(BITMAPINFOHEADER)) ||
        (((BITMAPINFOHEADER *) pv)->biSize > cjMax) ||
        ((fl != DIB_PAL_INDICES) &&
         (fl != DIB_PAL_COLORS)  &&
         (fl != DIB_RGB_COLORS)))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HBRUSH) 0);
    }

// Compute offset to the bits

    UINT cjHeader = ((BITMAPINFOHEADER *) pv)->biSize;
    PBYTE pjBits = ((PBYTE) pv) + cjHeader;
    PUSHORT pusIndices;
    UINT  uiBits,cSize,uiCompression;
    UINT  cPalEntriesTotal;
    LPBITMAPINFO pbmiTmp = NULL;

    UINT cPalEntryMax;

    uiBits = ((BITMAPINFOHEADER *) pv)->biBitCount;

    pusIndices = (PUSHORT) pjBits;

    cSize = sizeof(RGBQUAD);

    cPalEntriesTotal = (UINT) ((BITMAPINFOHEADER *) pv)->biClrUsed;

    uiCompression = ((BITMAPINFOHEADER *) pv)->biCompression;

// Check proper settings for compression.
    if (uiCompression == BI_BITFIELDS)
    {
        cPalEntriesTotal = 3;

        if (fl == DIB_PAL_COLORS)
            fl = DIB_RGB_COLORS;

        if ((uiBits != 16) && (uiBits != 32))
        {
            WARNING("CreateDIBPatternBrush given invalid data for BI_BITFIELDS\n");
            return((HBRUSH) 0);
        }
    }
    else if (uiCompression == BI_RGB)
    {
        switch(uiBits)
        {
        case 1:
            cPalEntryMax = 2;
            break;
        case 4:
            cPalEntryMax = 16;
            break;
        case 8:
            cPalEntryMax = 256;
            break;
        case 16:
        case 24:
        case 32:
            cPalEntryMax =
            cPalEntriesTotal = 0;

        // Win3.1 ignores the DIB_PAL_COLORS flag when non-indexed passed in.

            if (fl == DIB_PAL_COLORS)
                fl = DIB_RGB_COLORS;

            break;
        default:
            WARNING("GreCreateDIBPatternBrushPt failed because of invalid bit count BI_RGB");
            return((HBRUSH) 0);
        }

        if (cPalEntriesTotal == 0)
        {
            cPalEntriesTotal = cPalEntryMax;
        }
        else
            cPalEntriesTotal = MIN(cPalEntryMax, cPalEntriesTotal);
    }
    else if (uiCompression == BI_RLE4)
    {
        if (uiBits != 4)
        {
            WARNING("CreateDIBrush RLE4 invalid bpp\n");
            return((HBRUSH) 0);
        }

        if (cPalEntriesTotal == 0)
        {
            cPalEntriesTotal = 16;
        }
    }
    else if (uiCompression == BI_RLE8)
    {
        if (uiBits != 8)
        {
            WARNING("CreateDIBrush RLE8 invalid bpp\n");
            return((HBRUSH) 0);
        }

        if (cPalEntriesTotal == 0)
        {
            cPalEntriesTotal = 256;
        }
    }
    else
    {
    // We don't support any other compressions for creating a brush on NT.

        WARNING("Unknown Compression passed in - failed CreateDIBPatternBrush\n");
        return((HBRUSH) 0);
    }

// Check for the DIB_PAL_COLORS case.

    if (fl == DIB_PAL_COLORS)
        cSize = sizeof(USHORT);
    else if (fl == DIB_PAL_INDICES)
        cSize = 0;

// Validate that buffer is large enough to include color table.  Guarantees
// that pjBits is within the bounds of the pv buffer passed in.

    UINT cjColorTable = (((cSize * cPalEntriesTotal) + 3) & ~3);

    if (cjColorTable > (cjMax - cjHeader))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(0);
    }

    pjBits += cjColorTable; // now, pjBits = pv + cjHeader + cjColorTable

//
// Sundown: safe to truncate to INT since pjBits - pv will not exceed 4GB
// (validation above ensures that difference is <= cjMax)
//

    INT cjBits = cjMax - (INT)(pjBits - (PBYTE)pv);

// Store the handle to bitmap just like a pattern brush, only mark
// it as a DIB.

    HBITMAP hbmDIB;

    FLONG flCreate = DIB_RGB_COLORS;

    if (fl != DIB_RGB_COLORS)
    {
        flCreate = DIB_PAL_NONE;
    }


    hbmDIB = GreCreateDIBitmapReal(
                                  (HDC) 0,
                                  CBM_INIT | CBM_CREATEDIB,
                                  pjBits,
                                  (BITMAPINFO *)pv,
                                  flCreate,
                                  cjMax,
                                  cjBits,
                                  NULL,
                                  0,
                                  NULL,
                                  CDBI_INTERNAL,
                                  0,
                                  NULL);

    if (hbmDIB == (HBITMAP) 0)
    {
        WARNING("GreCreateDIBPatternBrush failed because GreCreateDIBitmap failed");
        return((HBRUSH) 0);
    }

    if (b8X8)
    {
        SURFREF so((HSURF)hbmDIB);
        ASSERTGDI(so.bValid(), "ERROR just created and already dead");

        SIZEL sizlNew = so.ps->sizl();

        if (so.ps->sizl().cx > 8)
        {
            sizlNew.cx = 8;
        }

        if (so.ps->sizl().cy > 8)
        {
            sizlNew.cy = 8;
        }

        so.ps->sizl(sizlNew);
    }

// Now if we are creating a DIB_PAL_COLORS DIB brush we need to save the
// indices in the palette, so at runtime we can do the right thing.

    if (fl == DIB_PAL_COLORS)
    {
        SURFREF so((HSURF)hbmDIB);
        ASSERTGDI(so.bValid(), "ERROR GreCreateDIBBrush surface\n");

        XEPALOBJ pal(so.ps->ppal());

        pal.flPal(PAL_BRUSHHACK);

        ASSERTGDI(pal.bValid(), "ERROR GreCreateDIBBrush pal.bValid\n");
        ASSERTGDI(!pal.bIsPalDefault(), "ERROR GreCreateDIBBrush pal.bIsPal\n");

        RtlCopyMemory((PUSHORT) pal.apalColorGet(), pusIndices,
                      cPalEntriesTotal << 1);

    // Remember how big the color table is

        pal.cColorTableLength(cPalEntriesTotal);
    }

    BRUSHMEMOBJ brmo(hbmDIB, (HBITMAP)pClient, FALSE, fl, BR_IS_DIB, bPen);

    HBRUSH hbrRet;

    if (brmo.bValid())
    {
        brmo.vKeepIt();
        brmo.iUsage(fl);
        hbrRet = brmo.hbrush();
    }
    else
    {
        bDeleteSurface((HSURF)hbmDIB);
        hbrRet = (HBRUSH) 0;
    }

    return(hbrRet);
}

/******************************Public*Routine******************************\
* GreMarkUndeletableBrush
*
* Private API for USER.
*
* Mark a Brush as undeletable.  This must be called before the Brush is ever
* passed out to an application.
*
* History:
*  13-Sep-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID GreMarkUndeletableBrush(HBRUSH hbr)
{
    if(hbr == NULL)
    {
        WARNING("GreMarkUndeletableBrush called with NULL handle");
    }
    else if(!HmgMarkUndeletable((HOBJ)hbr, BRUSH_TYPE))
    {
        RIP("GreMarkUndeletableBrush failed to mark handle undeletable");
    }
}

/******************************Public*Routine******************************\
* GreMarkDeletableBrush
*
* Private API for USER.
*
* This can be called anytime by USER to make the Brush deletable.  We need
* to check they don't do this on our global objects.
*
* History:
*  13-Sep-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID GreMarkDeletableBrush(HBRUSH hbr)
{
    BRUSHSELOBJ bro(hbr);

    if (bro.bValid())
    {
        if(!bro.bIsGlobal())
        {
            if (hbr == NULL)
            {
                WARNING("GreMarkDeletableBrush called with NULL handle");
            }
            else if (!HmgMarkDeletable((HOBJ)hbr,BRUSH_TYPE))
            {
                RIP("GreMarkDeletableBrush failed to mark handle deletable");
            }
        }
    }
    else
    {
        WARNING("ERROR User gives Gdi invalid Brush");
    }
}

/******************************Public*Routine******************************\
* GreCreatePen
*
* API creates a logical pen.
*
* History:
*  08-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HPEN GreCreatePen(int iPenStyle, int ulWidth, COLORREF clrr, HBRUSH hbr)
{
    HPEN hRet = 0;

    PW32THREAD pthread = W32GetCurrentThread();

    ASSERTGDI(!hbr,"GreCreatePen - hbr\n");

    switch(iPenStyle)
    {
    case PS_NULL:
    case PS_SOLID:
    case PS_DASH:
    case PS_DOT:
    case PS_DASHDOT:
    case PS_DASHDOTDOT:
    case PS_INSIDEFRAME:
        break;

    default:
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HPEN) 0);
    }

    hRet = GreExtCreatePen(iPenStyle,
                           ulWidth,
                           BS_SOLID,
                           clrr,
                           0,
                           0,
                           0,
                           (PULONG) NULL,
                           0,
                           TRUE,
                           hbr);

    return (hRet);
}

/******************************Public*Routine******************************\
* GreExtCreatePen
*
* API creates an old-style or extended logical pen.
*
* History:
*  23-Jan-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HPEN GreExtCreatePen(
ULONG  flPenStyle,
ULONG  ulWidth,
ULONG  iBrushStyle,
ULONG  ulColor,
ULONG_PTR   lClientHatch,
ULONG_PTR   lHatch,
ULONG  cstyle,
PULONG pulStyle,
ULONG  cjDIB,
BOOL   bOldStylePen,
HBRUSH hbrush)
{
    BOOL bInvalidParm = FALSE;
    BOOL bDefaultStyle = FALSE;
    PFLOAT_LONG pstyle = (PFLOAT_LONG) NULL;

    ULONG iType  = flPenStyle & PS_TYPE_MASK;
    ULONG ulStyle = flPenStyle & PS_STYLE_MASK;
    ULONG iJoin;
    ULONG iEndCap;

// We take the absoluate value of the integer width, like Win3 does:

    LONG lWidthPen = ABS((LONG) ulWidth);

// Make sure no weird bits are set where none of our fields are:

    if ((flPenStyle &
        ~(PS_TYPE_MASK | PS_STYLE_MASK | PS_ENDCAP_MASK | PS_JOIN_MASK)) != 0)
    {
        bInvalidParm = TRUE;
    }

// Don't do any more parameter checking for NULL pens:

    if (ulStyle == PS_NULL)
        return(STOCKOBJ_NULLPEN);

// Do some more parameter checking.

    switch(iType)
    {
    case PS_GEOMETRIC:
        break;
    case PS_COSMETIC:
        if ((iBrushStyle == BS_SOLID) ||
           ((iBrushStyle == BS_HATCHED) &&
            ((lHatch == HS_SOLIDTEXTCLR) || (lHatch == HS_SOLIDBKCLR))))
        {
            break;
        }
    default:
        bInvalidParm = TRUE;
    }

    if (lWidthPen != 1 && iType == PS_COSMETIC && !bOldStylePen)
    {
        bInvalidParm = TRUE;
    }

    switch(flPenStyle & PS_JOIN_MASK)
    {
    case PS_JOIN_ROUND: iJoin = JOIN_ROUND; break;
    case PS_JOIN_BEVEL: iJoin = JOIN_BEVEL; break;
    case PS_JOIN_MITER: iJoin = JOIN_MITER; break;
    default:
        bInvalidParm = TRUE;
    }

    switch(flPenStyle & PS_ENDCAP_MASK)
    {
    case PS_ENDCAP_ROUND:  iEndCap = ENDCAP_ROUND;  break;
    case PS_ENDCAP_FLAT:   iEndCap = ENDCAP_BUTT;   break;
    case PS_ENDCAP_SQUARE: iEndCap = ENDCAP_SQUARE; break;
    default:
        bInvalidParm = TRUE;
    }

// Zero length array allowed iff not doing a user-supplied style,
// and aribtrarily limit the style array size:

    if ((ulStyle == PS_USERSTYLE && cstyle == 0) ||
        (ulStyle != PS_USERSTYLE && cstyle != 0) ||
        cstyle > STYLE_MAX_COUNT)
    {
        bInvalidParm = TRUE;
    }

    if (iType == PS_GEOMETRIC)
    {
        switch(ulStyle)
        {
        case PS_DOT:
            cstyle = sizeof(gaulGeometricDot) / sizeof(ULONG);
            pulStyle = gaulGeometricDot;
            break;
        case PS_DASH:
            cstyle = sizeof(gaulGeometricDash) / sizeof(ULONG);
            pulStyle = gaulGeometricDash;
            break;
        case PS_DASHDOT:
            cstyle = sizeof(gaulGeometricDashDot) / sizeof(ULONG);
            pulStyle = gaulGeometricDashDot;
            break;
        case PS_DASHDOTDOT:
            cstyle = sizeof(gaulGeometricDashDotDot) / sizeof(ULONG);
            pulStyle = gaulGeometricDashDotDot;
            break;
        case PS_USERSTYLE:
        case PS_SOLID:
            break;
        case PS_INSIDEFRAME:
            break;
        case PS_ALTERNATE:
        default:
            bInvalidParm = TRUE;
        }
    }
    else
    {
        switch(ulStyle)
        {
        case PS_DOT:
            cstyle = sizeof(galeCosmeticDot) / sizeof(LONG_FLOAT);
            pstyle = &galeCosmeticDot[0].el;
            bDefaultStyle = TRUE;
            break;
        case PS_DASH:
            cstyle = sizeof(galeCosmeticDash) / sizeof(LONG_FLOAT);
            pstyle = &galeCosmeticDash[0].el;
            bDefaultStyle = TRUE;
            break;
        case PS_DASHDOT:
            cstyle = sizeof(galeCosmeticDashDot) / sizeof(LONG_FLOAT);
            pstyle = &galeCosmeticDashDot[0].el;
            bDefaultStyle = TRUE;
            break;
        case PS_DASHDOTDOT:
            cstyle = sizeof(galeCosmeticDashDotDot) / sizeof(LONG_FLOAT);
            pstyle = &galeCosmeticDashDotDot[0].el;
            bDefaultStyle = TRUE;
            break;
        case PS_USERSTYLE:
        case PS_SOLID:
            break;
        case PS_ALTERNATE:
            break;
        case PS_INSIDEFRAME:

        // Don't allow PS_INSIDEFRAME with new style cosmetic pens:

            if (!bOldStylePen)
                bInvalidParm = TRUE;
            break;
        default:
            bInvalidParm = TRUE;
        }
    }

    if (bInvalidParm)
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HPEN) 0);
    }

    if (cstyle > 0 && pstyle == (PFLOAT_LONG) NULL)
    {
        pstyle = (PFLOAT_LONG) PALLOCNOZ(cstyle * sizeof(FLOAT_LONG),'ytsG');
        if (pstyle == (PFLOAT_LONG) NULL)
        {
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            return((HPEN) 0);
        }

        PFLOAT_LONG ple    = pstyle;
        PFLOAT_LONG pleEnd = ple + cstyle;

        if (iType == PS_COSMETIC || bOldStylePen)
        {
        // Handle cosmetic styles:

            LONG lMin = 1;
            LONG lMax = 1;
            LONG lSum = 0;

            while (ple < pleEnd)
            {
                ple->l = (LONG) *pulStyle;
                lMin = MIN(lMin, ple->l);
                lMax = MAX(lMax, ple->l);
                lSum += ple->l;

                pulStyle++;
                ple++;
            }

            if (lMin <= 0 || lMax > STYLE_MAX_VALUE || lSum > STYLE_MAX_VALUE)
                bInvalidParm = TRUE;
        }
        else
        {
        // Handle geometric styles:

            LONG lSum = 0;
            LONG lMin = 0;
            while (ple < pleEnd)
            {
                LONG lLength = (LONG) *pulStyle;

            // Default styles are based on multiples of the pen width:

                if (ulStyle != PS_USERSTYLE)
                {
                // For round and square caps, shorten dashes and lengthen
                // the gaps:

                    if (iEndCap != ENDCAP_BUTT)
                        lLength += ((ple - pstyle) & 1) ? 1 : -1;

                // Don't really care about overflow on this multiplication:

                    lLength *= lWidthPen;
                }

                lMin = MIN(lMin, lLength);
                lSum += lLength;

                EFLOATEXT efLength(lLength);
                efLength.vEfToF(ple->e);

                pulStyle++;
                ple++;
            }

            if (lMin < 0 || lSum <= 0)
                bInvalidParm = TRUE;
        }

        if (bInvalidParm)
        {
        // At least one entry in the style array has to be non-zero:

            VFREEMEM(pstyle);
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return((HPEN) 0);
        }
    }

    HBRUSH hbr = 0;

    switch(iBrushStyle)
    {
    case BS_HOLLOW:
        if (pstyle != (PFLOAT_LONG) NULL && !bDefaultStyle)
            VFREEMEM(pstyle);

        return(STOCKOBJ_NULLPEN);

    case BS_SOLID:
        hbr = hCreateSolidBrushInternal(ulColor,
                                        TRUE,
                                        hbrush,
                                        (lWidthPen == 0) && (ulStyle == PS_SOLID));
        break;

    case BS_HATCHED:
        hbr = hCreateHatchBrushInternal((ULONG) lHatch, ulColor, TRUE);
        break;

    case BS_PATTERN:
        hbr = GreCreatePatternBrushInternal((HBITMAP) lHatch, TRUE,FALSE);
        break;

    case BS_DIBPATTERNPT:
        hbr = GreCreateDIBBrush((PVOID) lHatch, ulColor,
                                          (UINT) cjDIB, FALSE, TRUE, (PVOID)lClientHatch);
        break;

    case BS_DIBPATTERN:
        RIP("BS_DIBPATTERN not supported in server");

    default:
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }

    if (hbr == (HBRUSH) 0)
    {
        if (pstyle != (PFLOAT_LONG) NULL && !bDefaultStyle)
            VFREEMEM(pstyle);

        return((HPEN) 0);
    }

    BRUSHSELOBJ bso(hbr);

    // we had better validate this since it is just a handle, it could already
    // have been deleted.

    if (!bso.bValid())
    {
        WARNING("Created invalid pen\n");

        if (pstyle != (PFLOAT_LONG) NULL && !bDefaultStyle)
            VFREEMEM(pstyle);

        return((HPEN)0);
    }

    bso.vSetPen();
    bso.flStylePen(flPenStyle);
    bso.iEndCap(iEndCap);
    bso.iJoin(iJoin);
    bso.pstyle(pstyle);
    bso.cstyle(cstyle);
    bso.lWidthPen(lWidthPen);
    if (bDefaultStyle)
        bso.vSetDefaultStyle();
    bso.lBrushStyle (iBrushStyle);
    bso.lHatch (lClientHatch);

    if (iType == PS_GEOMETRIC || bOldStylePen)
    {
    // Geometric line widths are FLOATs in the LINEATTRS structure, so
    // we have to keep a FLOAT version of its width around too:

        EFLOATEXT efWidth(lWidthPen);
        FLOATL    l_eWidth;

        efWidth.vEfToF(l_eWidth);
        bso.l_eWidthPen(l_eWidth);
    }

// we need to add the pen/extpen bits to handle type for the client

    HBRUSH hbrPen = (HBRUSH) MODIFY_HMGR_TYPE(hbr,LO_EXTPEN_TYPE);

    if (bOldStylePen)
    {
        bso.vSetOldStylePen();
        bso.vDisableDither();
        if (ulStyle == PS_INSIDEFRAME)
        {
            bso.vEnableDither();
            bso.vSetInsideFrame();
        }
        hbrPen = (HBRUSH) MODIFY_HMGR_TYPE(hbr,LO_PEN_TYPE);
    }
    else if (iType == PS_COSMETIC)
    {
    // For now, cosmetic lines must also be solid colored:

        bso.vDisableDither();
    }
    else
    {
    // We also support inside frame for geometric ExtCreatePen pens:

        if (ulStyle == PS_INSIDEFRAME)
        {
            bso.vSetInsideFrame();
        }
    }

// we now set the new pen handle type.  This must be done while the pen is locked

    HmgModifyHandleType((HOBJ)hbrPen);

    ASSERTGDI(!bInvalidParm, "Invalid parm?");
    return((HPEN) hbrPen);
}

/******************************Public*Routine******************************\
* GreCreatePenIndirect
*
* API creates a logical pen.
*
* History:
*  08-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HPEN GreCreatePenIndirect(LPLOGPEN lpLogPen)
{
    return(GreCreatePen((int)lpLogPen->lopnStyle,
                        (int)lpLogPen->lopnWidth.x,
                        lpLogPen->lopnColor,0));
}

/******************************Public*Routine******************************\
* GreMonoBitmap
*
* Is the specified bitmap monochromatic?
*
* History:
*  18-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL NtGdiMonoBitmap(HBITMAP hbm)
{
    SURFREF   SurfBmo((HSURF)hbm);

    if (!SurfBmo.bValid())
        return(FALSE);

    XEPALOBJ pal(SurfBmo.ps->ppal());
        return(pal.bIsMonochrome());
}

/******************************Public*Routine******************************\
* GreGetObjectBitmapHandle
*
* Gets the handle of the bitmap associated with this brush
*
* History:
*  09-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

HBITMAP GreGetObjectBitmapHandle(
HBRUSH  hbr,
UINT   *piUsage)
{
    BRUSHSELOBJ ebo(hbr);

    if (!ebo.bValid())
    {
        return((HBITMAP) 0);
    }

    HBITMAP hbm = ebo.hbmPattern();

    if (ebo.bPalColors())
    {
        *piUsage = DIB_PAL_COLORS;
    }
    else if (ebo.bPalIndices())
    {
        *piUsage = DIB_PAL_INDICES;
    }
    else
    {
        *piUsage = DIB_RGB_COLORS;
    }

    return(hbm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\bltlnk.cxx ===
/******************************Module*Header*******************************\
* Module Name:
*
*   bltlnk.cxx
*
* Abstract
*
*   This module does general bit blt functions for 1,4,8,16,24,and 32 bpp
*   DIB format bitmaps. SrcBltxx routines are used to align and copy data.
*
* Author:
*
*   Mark Enstrom    (marke) 9-27-93
*
* Copyright (c) 1993-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

PVOID pvGetEngRbrush(BRUSHOBJ *pbo);

extern PFN_SRCCPY SrcCopyFunctionTable[];

PFN_BLTLNKROP RopFunctionTable[] = {
    vRop2Function0,vRop2Function1,vRop2Function2,vRop2Function3,
    vRop2Function4,vRop2Function5,vRop2Function6,vRop2Function7,
    vRop2Function8,vRop2Function9,vRop2FunctionA,vRop2FunctionB,
    vRop2FunctionC,vRop2FunctionD,vRop2FunctionE,vRop2FunctionF
};

#define DBG_BLTLNK 0


#if DBG_BLTLNK
    ULONG   DbgBltLnk = 0;
#endif

#define SCAN_LINE_BUFFER_LENGTH 64


/******************************Public*Routine******************************\
*
* Routine Name
*
*   BltLnk
*
* Routine Description:
*
*   BltLnk prepares all parameters then breaks the BitBlt region into
*   rectangles based on clip information. Each rect is sent to BltLnkRect
*   for operation.
*
* Arguments:
*
*   pdioDst     -   Destination surface information
*   pdioSrc     -   Source surface information
*   pdioMsk     -   Mask information
*   pco         -   Clip Object
*   pxlo        -   Color translation object
*   prclDst     -   Destination rectangle
*   pptlSrc     -   Source Starting offset point
*   pptlMsk     -   Mask Starting offset point
*   pdbrush     -   Brush Information
*   pptlBrush   -   Brush Starting offset point
*   rop4        -   Logical Raster Operation
*
* Return Value:
*
*   BOOLEAN Status
*
\**************************************************************************/

BOOL
BltLnk(
    SURFACE    *pdioDst,            // Target surface
    SURFACE    *pdioSrc,            // Source surface
    SURFACE    *pdioMsk,            // Msk
    ECLIPOBJ   *pco,                // Clip through this
    XLATE      *pxlo,               // Color translation
    RECTL      *prclDst,            // Target offset and extent
    POINTL     *pptlSrc,            // Source offset
    POINTL     *pptlMsk,            // Msk offset
    BRUSHOBJ   *pdbrush,            // Brush data (from cbRealizeBrush)
    POINTL     *pptlBrush,          // Brush offset (origin)
    ROP4        rop4)               // Raster operation
{

    BOOL            bMore;
    ULONG           ircl;
    LONG            MaxWidth;
    BLTLNKINFO      bltInfo;
    CLIPENUMRECT    clenr;
    BYTE            Rop3Low;
    BYTE            Rop3High;
    BYTE            RopSrcLow;
    BYTE            RopSrcHigh;
    BYTE            RopDstLow;
    BYTE            RopDstHigh;
    BOOL            bNeedMsk     = FALSE;
    BOOL            bNeedPat     = FALSE;
    BOOL            bNeedSrc     = FALSE;
    BOOL            bNeedDst     = FALSE;
    BOOL            bNeedPatLow  = FALSE;
    BOOL            bNeedSrcLow  = FALSE;
    BOOL            bNeedDstLow  = FALSE;
    BOOL            bNeedPatHigh = FALSE;
    BOOL            bNeedSrcHigh = FALSE;
    BOOL            bNeedDstHigh = FALSE;
    BOOL            bLocalAlloc  = FALSE;
    SURFMEM         SurfDimo;
    PENGBRUSH       pBrush = NULL;



    #if DBG_BLTLNK

        if (DbgBltLnk >= 1)
        {

            DbgPrint("BltLnk: rop4 = %lx\n",rop4);
            DbgPrint("pdioDst = 0x%p\n",pdioDst);
            DbgPrint("pdioSrc = 0x%p\n",pdioSrc);

            DbgPrint("  Destination Format = %li\n",pdioDst->iFormat());

            DbgPrint("  prclDst = %li,%li to %li,%li\n",
                        prclDst->left,
                        prclDst->top,
                        prclDst->right,
                        prclDst->bottom);

        }

    #endif

    //
    // make sure destination format is not a device format or
    // unknown format
    //

    ASSERTGDI(pdioDst->iFormat() != 0, "ERROR device dst format in BltLnk\n");
    ASSERTGDI(pdioDst->iFormat() <= 7, "ERROR invalid dst format in BltLnk\n");

    //
    //  check rectangle bounds
    //

    ASSERTGDI(prclDst->left < prclDst->right,        "ERROR prclDst->left < right");
    ASSERTGDI(prclDst->top  < prclDst->bottom,       "ERROR prclDst->top < bottom");

    //
    // calculate the widest blt using based on the width of scan line storage
    //
    // These numbers assume worst case unaligned transfers
    //

    switch(pdioDst->iFormat())
    {
    case BMF_1BPP:
        MaxWidth = (SCAN_LINE_BUFFER_LENGTH << 5) -62;
        break;
    case BMF_4BPP:
        MaxWidth = (SCAN_LINE_BUFFER_LENGTH << 3) -14;
        break;
    case BMF_8BPP:
        MaxWidth = (SCAN_LINE_BUFFER_LENGTH << 2) -6;
        break;
    case BMF_16BPP:
        MaxWidth = (SCAN_LINE_BUFFER_LENGTH << 1) -2;
        break;
    case BMF_24BPP:
        MaxWidth = ((SCAN_LINE_BUFFER_LENGTH * 4) / 3) - 2;
        break;
    case BMF_32BPP:
        MaxWidth = SCAN_LINE_BUFFER_LENGTH;
        break;
    }

    //
    // set bltInfo params
    //

    if (pxlo == NULL)
    {
        bltInfo.pxlo    = &xloIdent;
    }
    else
    {
        bltInfo.pxlo    = pxlo;
    }

    bltInfo.pdioDst = pdioDst;
    bltInfo.pdioSrc = pdioSrc;
    bltInfo.pco     = (ECLIPOBJ *)pco;
    bltInfo.rclDst  = *prclDst;
    bltInfo.pdbrush = (EBRUSHOBJ *) pdbrush;

    //
    //  rop4 is a logical combination of Src,Dst,Pattern,Mask
    //
    //  rop4[15:08] represents the rop3 used when Mask is high
    //  rop4[07:00] represents the rop3 used when Mask is low
    //
    //  When rop4[15:08] == rop4[07:00], this indicates that no mask
    //  is needed for the operation.
    //
    //  rop3 [07:04] represents the rop2 to be used is pattern is high
    //  rop3 [03:00] represents the rop2 to be used is pattern is low
    //
    //  when rop3[07:04] == rop3[03:00], this indicates that no pattern
    //  is needed for the operation.
    //
    //  By exchanging Src and Dst with Pattern and Mask, it is possible
    //  to compare rop4s to also determine is Src and Dst are needed for
    //  the logical operation. BltLnk does this below.
    //
    //  A rop2 represents 16 different ways 2 variables may be combined, this
    //  is the basic logic element used in BltLnk.
    //
    //  As an example of logic reduction rop4 = B8B8 would
    //  immediatly reduce to a rop3 because rop4[15:08] == rop4[07:00]. This
    //  leaves rop3 = B8. This is expressed as a Karnaugh map as:
    //
    //
    //   PS  00 01 11 10
    //      Ŀ
    //   D 0 0 0 0 1
    //      Ĵ
    //     1 0 1 1 1
    //      
    //  This reduces to a logic operation of Dst = (Pat & ~Src) | (Dst & Src)
    //
    //  This is a special case rop handled by unique functions, but in gereral BltLnk
    //  will handle a rop like this by reducing it to functions of rop2s, in this case
    //
    //  Pat and (Src and Dst)  OR  ~pat and (~Src or Dst)
    //
    //  BltLnk will always try to manipulate the variables so that a rop2
    //  function may be performed directly. If this is not possible, a rop3
    //  functions is broken into 2 rop2 functions, one for pat=high and one
    //  for pat = low. (or mask in a rop3 in which pat is not needed but mask is)
    //  For a full rop4, two rop 3 passes are made, one for mask = high and
    //  one for mask = low.
    //
    //  Actual Mask Blt, rop4 = AACC is handled by a special case accelerator.
    //
    //  Masked Solid fill (Src = 1bpp mask), rop4 = B8B8 is also handled by a
    //  special case accelerator.
    //

    Rop3Low    = (BYTE)(rop4 & 0xff);
    Rop3High   = (BYTE)(rop4 >> 8);

    RopSrcLow  = (Rop3Low & 0xC3) | ((Rop3Low & 0x0C) << 2) | ((Rop3Low & 0x30) >> 2);
    RopDstLow  = (Rop3Low & 0xA5) | ((Rop3Low & 0x0A) << 3) | ((Rop3Low & 0x50) >> 3);

    RopSrcHigh = (Rop3High & 0xC3)|((Rop3High & 0x0C) << 2)|((Rop3High & 0x30) >> 2);
    RopDstHigh = (Rop3High & 0xA5)|((Rop3High & 0x0A) << 3)|((Rop3High & 0x50) >> 3);

    #if DBG_BLTLNK
        if (DbgBltLnk >= 2)
        {
            DbgPrint    ("  RopSrcLow = %lx, RopDstLow = %lx\n",
                            RopSrcLow,RopDstLow);
            DbgPrint    ("  RopSrcHigh = %lx, RopDstHigh = %lx\n",
                            RopSrcHigh,RopDstHigh);
        }
    #endif

    //
    // if rop4[15:08] = rop4[07:00] then no mask is needed
    //

    if ((rop4 & 0xff) != ((rop4) >> 8))
    {
        bNeedMsk = TRUE;
    }

    //
    // if Rop3Low[7:4]  = Rop3Low[3:0] and
    // if Rop3High[7:4] = Rop3High[3:0] Then no pat is needed
    //

    if ((Rop3Low & 0x0f) != ((Rop3Low & 0xf0) >> 4))
    {
        bNeedPatLow = TRUE;
    }

    if ((Rop3High & 0x0f) != ((Rop3High & 0xf0) >> 4))
    {
        bNeedPatHigh = TRUE;
    }

    bNeedPat = bNeedPatLow || bNeedPatHigh;

    //
    // if RopSrcLow[7:4]  = RopSrcLow[3:0] and
    // if RopSrcHigh[7:4] = RopSrcHigh[3:0] Then no src is needed
    //

    if ((RopSrcLow & 0x0F) != ((RopSrcLow & 0xF0) >> 4))
    {
        bNeedSrcLow = TRUE;
    }

    if ((RopSrcHigh & 0x0F) != ((RopSrcHigh & 0xF0) >> 4))
    {
        bNeedSrcHigh = TRUE;
    }

    bNeedSrc = bNeedSrcLow || bNeedSrcHigh;

    //
    // if RopDstLow[7:4]  = RopDstLow[3:0] and
    // if RopDstHigh[7:4] = RopDstHigh[3:0] Then no Dst is needed
    //

    if (((RopDstLow & 0x0f) != ((RopDstLow & 0xF0) >> 4)))
    {
        bNeedDstLow = TRUE;
    }

    if (((RopDstHigh & 0x0f) != ((RopDstHigh & 0xF0) >> 4)))
    {
        bNeedDstHigh = TRUE;
    }

    bNeedDst = bNeedDstHigh || bNeedDstLow;

    //
    // get the brush realization if we'll need it. This is either
    // when the rop specifies a pattern is needed or when the rop specifies
    // that a mask is needed but no mask is passed in, meaning the mask
    // must be taken from the brush
    //

    if ((bNeedPat) || (bNeedMsk && (pdioMsk == (SURFACE*) NULL)))
    {
        if ((pdbrush != NULL) && (pdbrush->iSolidColor == -1))
        {
            pBrush = (PENGBRUSH) pvGetEngRbrush(pdbrush);
        }
        else
        {
            pBrush = (PENGBRUSH) pdbrush;
        }
    }


    #if DBG_BLTLNK
        if (DbgBltLnk >= 2)
        {
            DbgPrint("  pBrush    = %p\n",pBrush);
            DbgPrint("  bNeedMsk  = %x\n",bNeedMsk);
            DbgPrint("  bNeedPat  = %x\n",bNeedPat);
            DbgPrint("  bNeedSrc  = %x\n",bNeedSrc);
            DbgPrint("  bNeedDst  = %x\n",bNeedDst);
        }
    #endif

    //
    // Compute the direction of clipping enumeration
    //

    bltInfo.xDir = bltInfo.yDir = 1L;
    bltInfo.iDir = CD_ANY;

    //
    // Get clip rectangle enumeration and directions set up. BltLnkRect
    // always performs blt operations left to right using a temp
    // scan line buffer.
    // xDir is set to 1 or -1 as a flag
    // for accelerators to not accelerate a special case if xDir < 0
    //

    if (bNeedSrc)
    {
        ASSERTGDI(pdioSrc != (SURFACE*) NULL, "ERROR: Bltlnk: no pdioSrc");

        //
        // fill out bltinfo for calls to BltLnkRect
        //

        bltInfo.pjSrc = (PBYTE) pdioSrc->pvScan0();
        bltInfo.lDeltaSrc = pdioSrc->lDelta();
        bltInfo.xSrcOrg = pptlSrc->x;
        bltInfo.ySrcOrg = pptlSrc->y;

        #if DBG_BLTLNK

            if (DbgBltLnk >= 1) {
                DbgPrint("  Src Format = %li\n",pdioSrc->iFormat());
                DbgPrint("  Src Point  = %li,%li\n",pptlSrc->x,pptlSrc->y);
            }

            if (DbgBltLnk >= 2)
            {
                DbgPrint("  pjSrc = %p, lDeltaSrc = %li\n",
                                    bltInfo.pjSrc,bltInfo.lDeltaSrc);
                DbgPrint("  xSrcOrg = %li, ySrcOrg = %li\n",
                                    bltInfo.xSrcOrg,bltInfo.ySrcOrg);
            }

        #endif

        //
        // Only BLT bottom to top if the source and destination are on the
        // same surface and the Dst is below the Src.
        //
        //             Ŀ
        //        ĳSrc    
        //        Dst        
        //                   
        //            
        //        
        //
        // Also check if it is the same surface for BLTs that must be
        // done right to left. This is a case where the starting scan
        // lines for Src and Dst are the same and the Src is to the
        // left of the dst.  We do this by comparing the pvScan0 pointers.
	// The reason is that if we were to compare surface pointers or
	// handles this won't work on some drivers that punt this call
	// to GDI but pass us different SURFOBJs for the source and
	// destination even when they're really the same surface.
        //
        //     Ŀ
        //     Src Dst    
        //                
        //                
        //     
        //

        if (pdioSrc->pvScan0() == pdioDst->pvScan0())
        {

            if (pptlSrc->y < prclDst->top)
            {
                bltInfo.yDir = -1;
                bltInfo.iDir = CD_RIGHTUP;
            }

            //
            // check if:
            //
            //      Src scan line = Dst Scan line AND Src < Dst
            //          and width > Scan line buffer
            //  OR
            //      MaskBlt needing Src for RopHigh and RopLow
            //          AND Src and Dst rect intersect
            //

            if ((pptlSrc->y == prclDst->top) &&
                (pptlSrc->x < prclDst->left))
            {

                //
                // This blt requires right to left operation. This will
                // disable special accelerators in BltLnkRect.
                //

                bltInfo.xDir = -1;
            }

            //
            // cases requiring  temp Src:
            //

            if (
                    (bNeedMsk && bNeedSrcLow && bNeedSrcHigh)       ||
                    (
                      ((bltInfo.xDir == -1) || (bltInfo.yDir == -1)) &&
                      ((prclDst->right - prclDst->left) > MaxWidth)
                    )
               )
            {

                //
                // create a temp src surface of width prclDst->right - prclDst->left
                // and height prclDst->bottom - prclDst->top
                //

                DEVBITMAPINFO dbmi;
                dbmi.iFormat  = pdioSrc->iFormat();
                dbmi.cxBitmap = prclDst->right - prclDst->left;
                dbmi.cyBitmap = prclDst->bottom - prclDst->top;
                dbmi.hpal     = (HPALETTE) 0;
                dbmi.fl       = BMF_TOPDOWN;

                SurfDimo.bCreateDIB(&dbmi, (PVOID) NULL);

                if (!SurfDimo.bValid())
                {
                    //
                    // (common return?)
                    //

                    return(FALSE);
                }

                //
                // fill DIB with data from actual Src
                //

                POINTL ptlSrc;
                ptlSrc.x = pptlSrc->x;
                ptlSrc.y = pptlSrc->y;

                RECTL rclDst;
                rclDst.left   = 0;
                rclDst.right  = dbmi.cxBitmap;
                rclDst.top    = 0;
                rclDst.bottom = dbmi.cyBitmap;

                if (!EngCopyBits(SurfDimo.pSurfobj(),
                                 pdioSrc->pSurfobj(),
                                (CLIPOBJ *)NULL,
                                &xloIdent,
                                &rclDst,
                                &ptlSrc)
                   )
                {

                    //
                    // return error
                    //

                    return(FALSE);
                }

                //
                // fill in new Src info for BltLnkRect
                //

                bltInfo.pjSrc     = (PBYTE) SurfDimo.ps->pvScan0();
                bltInfo.lDeltaSrc = SurfDimo.ps->lDelta();
                bltInfo.xSrcOrg   = 0;
                bltInfo.ySrcOrg   = 0;

                #if DBG_BLTLNK

                    if (DbgBltLnk >= 1) {
                        DbgPrint("  Allocate temp buffer: pjSrc = 0x%p\n",bltInfo.pjSrc);
                        DbgPrint("  lDeltaSrc = 0x%lx, SrcOrg = (0,0)\n",bltInfo.lDeltaSrc);
                    }

                #endif

            }
        }

        //
        // set DeltaSrcDir based on yDir
        //

        if (bltInfo.yDir == 1)
        {
            bltInfo.lDeltaSrcDir =  bltInfo.lDeltaSrc;
        } else {
            bltInfo.lDeltaSrcDir = -bltInfo.lDeltaSrc;
        }

    } else {

        //
        // no src to worry about
        //

        bltInfo.pjSrc = (PBYTE) NULL;
    }

    //
    // Set up the destination information in bltInfo based on +/- yDir
    //
    // pjDst points to the upper left corner of the dest bitmap
    //
    // lDeltaDst is the number of (bytes) from one scan line to the next
    //

    bltInfo.pjDst     = (PBYTE) pdioDst->pvScan0();
    bltInfo.lDeltaDst = pdioDst->lDelta();


    if (bltInfo.yDir == 1)
    {
        bltInfo.lDeltaDstDir = bltInfo.lDeltaDst;
    } else {
        bltInfo.lDeltaDstDir = -bltInfo.lDeltaDst;
    }

    #if DBG_BLTLNK
        if (DbgBltLnk >= 2)
        {
            DbgPrint("  pjDst = %p, lDeltaDst = %li\n",bltInfo.pjDst,bltInfo.lDeltaDst);
        }
    #endif

    //
    // Set up the Mask
    //

    if (!bNeedMsk || (pdioMsk == (SURFACE*) NULL))
    {
        //
        // no mask to deal with
        //

        bltInfo.pdioMsk = (SURFACE*) NULL;
        bltInfo.pjMsk = (PBYTE) NULL;
    } else {

        ASSERTGDI(pdioMsk->iType() == STYPE_BITMAP, "ERROR: BltLnk: Mask is not STYPE_BITMAP\n");
        ASSERTGDI(pdioMsk->iFormat() == BMF_1BPP, "ERROR: BltLnk: Mask not 1Bpp\n");
        ASSERTGDI(pptlMsk->x >= 0, "Illegal mask offset x\n");
        ASSERTGDI(pptlMsk->y >= 0, "Illegal mask offset y\n");

        //
        // info for BltLnkRect
        //

        bltInfo.pdioMsk = pdioMsk;
        bltInfo.pjMsk = (PBYTE) pdioMsk->pvScan0();
        bltInfo.cxMsk = (pdioMsk->sizl()).cx;
        bltInfo.cyMsk = (pdioMsk->sizl()).cy;
        bltInfo.xMskOrg = pptlMsk->x;
        bltInfo.yMskOrg = pptlMsk->y;

        //
        // Normalize mask x
        //

        if (bltInfo.xMskOrg >= (LONG)bltInfo.cxMsk)
        {
            bltInfo.xMskOrg %= bltInfo.cxMsk;
        } else {
            if (bltInfo.xMskOrg < 0)
            {
                bltInfo.xMskOrg = (bltInfo.cxMsk - 1) -
                                  ((-bltInfo.xMskOrg - 1) % bltInfo.cxMsk);
            }
        }

        //
        // Normalize Mask y
        //

        if (bltInfo.yMskOrg >= (LONG)bltInfo.cyMsk)
        {
            bltInfo.yMskOrg %= bltInfo.cyMsk;
        } else {
            if (bltInfo.yMskOrg < 0)
            {
                bltInfo.yMskOrg = (bltInfo.cyMsk - 1) -
                                  ((-bltInfo.yMskOrg - 1) % bltInfo.cyMsk);
            }
        }

        //
        // Scan line offsets
        //

        bltInfo.lDeltaMsk = pdioMsk->lDelta();

        if (bltInfo.yDir == 1)
        {
            bltInfo.lDeltaMskDir = bltInfo.lDeltaMsk;
        } else {
            bltInfo.lDeltaMskDir = -bltInfo.lDeltaMsk;
        }

        #if DBG_BLTLNK
            if (DbgBltLnk >= 2)
            {
                DbgPrint("  pjMask    = %p\n",bltInfo.pjMsk);
                DbgPrint("  cxMask    = %li\n",bltInfo.cxMsk);
                DbgPrint("  cyMask    = %li\n",bltInfo.cyMsk);
                DbgPrint("  xMskOrg   = %li\n",bltInfo.xMskOrg);
                DbgPrint("  yMskOrg   = %li\n",bltInfo.yMskOrg);
                DbgPrint("  yMskDelta = %li\n",bltInfo.lDeltaMsk);
            }
        #endif
    }

    //
    // Set up the pat and possibly the mask if a mask is included in pat
    //

    if (!bNeedPat)
    {
        //
        // no Pat in this Blt
        //

        bltInfo.pjPat = (PBYTE) NULL;

    } else {

        //
        // check for valid brush pointer
        //

        if (pdbrush == (BRUSHOBJ *) NULL) {
            RIP("ERROR BltLnk brush Null");
            return(FALSE);
        }

        ircl = pdbrush->iSolidColor;

        //
        // check for solid color of 0xffffffff... this indicates
        // a real brush, not a solid color
        //

        if (ircl == 0xFFFFFFFF)
        {

            if (pBrush != (PENGBRUSH) NULL)
            {

                bltInfo.iSolidColor = ircl;

                //
                // Could have a brush that just has mask information.
                //

                if (pBrush->pjPat != (PBYTE) NULL)
                {

                    //
                    // fill in Pat info for BltLnkrect
                    //

                    bltInfo.lDeltaPat = pBrush->lDeltaPat;
                    bltInfo.pjPat = pBrush->pjPat;
                    bltInfo.cxPat = pBrush->cxPat;
                    bltInfo.cyPat = pBrush->cyPat;
                    bltInfo.xPatOrg = pptlBrush->x;
                    bltInfo.yPatOrg = pptlBrush->y;

                    if (bltInfo.yDir == 1)
                    {
                        bltInfo.lDeltaPatDir = bltInfo.lDeltaPat;
                    } else {
                        bltInfo.lDeltaPatDir = -bltInfo.lDeltaPat;
                    }
                }

            } else {

                //
                // routine failed due to brush, return
                //

                return(FALSE);
            }
        } else {

            //
            // Set pjPat to Null.
            //

            bltInfo.pjPat = (PBYTE) NULL;

            //
            // Build iSolidColor into a 32 bit quantity
            //
            // Note cascaded fall through on switch to build up iColor.
            //

            switch(pdioDst->iFormat())
            {
            case BMF_1BPP:

                if (ircl) {
                    ircl = 0xFFFFFFFF;
                }
                break;

            case BMF_4BPP:

                ircl = ircl | (ircl << 4);

            case BMF_8BPP:

                ircl = ircl | (ircl << 8);

            case BMF_16BPP:

                ircl = ircl | (ircl << 16);
            }

            bltInfo.iSolidColor = ircl;
        }
    }

    //
    // Check if there is a mask with this brush.  The Mask passed
    // in with the call takes precedence over the brush mask.
    //

    if ((bNeedMsk) &&
        (bltInfo.pjMsk == (PBYTE) NULL) &&
        (pBrush != (PENGBRUSH) NULL) &&
        (pBrush->pjMsk != (PBYTE) NULL))
    {

        bltInfo.pjMsk       = pBrush->pjMsk;
        bltInfo.cxMsk       = pBrush->cxMsk;
        bltInfo.cyMsk       = pBrush->cyMsk;
        bltInfo.lDeltaMsk   = pBrush->lDeltaMsk;
        bltInfo.xMskOrg     = prclDst->left - pptlBrush->x;
        bltInfo.yMskOrg     = prclDst->top  - pptlBrush->y;

        //
        // Normalize Mask x
        //

        if (bltInfo.xMskOrg >= (LONG)bltInfo.cxMsk)
        {
            bltInfo.xMskOrg %= bltInfo.cxMsk;
        } else {
            if (bltInfo.xMskOrg < 0)
            {
                bltInfo.xMskOrg = (bltInfo.cxMsk-1) -
                                  ((-bltInfo.xMskOrg-1) % bltInfo.cxMsk);
            }
        }

        //
        // Normalize Mask y
        //

        if (bltInfo.yMskOrg >= (LONG)bltInfo.cyMsk)
        {
            bltInfo.yMskOrg %= bltInfo.cyMsk;
        } else {
            if (bltInfo.yMskOrg < 0)
            {
                bltInfo.yMskOrg = (bltInfo.cyMsk-1) -
                                  ((-bltInfo.yMskOrg-1) % bltInfo.cyMsk);
            }
        }

        //
        // set sign on lDeltaMask based on a bottom to top or
        // top to bottom blt
        //

        if (bltInfo.yDir == 1)
        {
            bltInfo.lDeltaMskDir = bltInfo.lDeltaMsk;
        } else {
            bltInfo.lDeltaMskDir = -bltInfo.lDeltaMsk;
        }
    }

    //
    // make sure that if a mask is specified by the rop ,then a mask is available
    //

    if (bNeedMsk && (bltInfo.pjMsk == (PBYTE)NULL)) {

        RIP("ERROR: Bltlnk: ROP specifies mask but mask is null");
        return(FALSE);
    }

    //
    // set up clipping boundaries and call blt routine for each rect
    //

    if (pco != (CLIPOBJ *) NULL)
    {
        switch(pco->iDComplexity)
        {
        case DC_TRIVIAL:

            //
            // use the target for clipping
            //

            bMore = FALSE;
            clenr.c = 1;
            clenr.arcl[0] = *prclDst;
            break;

        case DC_RECT:

            //
            // use the bounding rect for clipping
            //

            bMore = FALSE;
            clenr.c = 1;
            clenr.arcl[0] = pco->rclBounds;
            break;

        case DC_COMPLEX:

            //
            // set up clipping enumeration
            //

            bMore = TRUE;
            ((ECLIPOBJ *) pco)->cEnumStart(FALSE,CT_RECTANGLES,bltInfo.iDir,CLIPOBJ_ENUM_LIMIT);
            break;

        default:
            RIP("ERROR: BltLnk - bad clipping type");
            return (FALSE);
        }

    } else {

        //
        // use target for clipping
        //

        bMore = FALSE;
        clenr.c = 1;
        clenr.arcl[0] = *prclDst;
    }

    //
    // blt each rect
    //

    do
    {

        if (bMore)
        {
            bMore = ((ECLIPOBJ *) pco)->bEnum(sizeof(clenr), (PVOID) &clenr);
        }

        for (ircl = 0; ircl < clenr.c; ircl++)
        {
            PRECTL prcl = &clenr.arcl[ircl];

            if (prcl->left < prclDst->left) {
                prcl->left = prclDst->left;
            }

            if (prcl->right > prclDst->right){
                prcl->right = prclDst->right;
            }

            if (prcl->top < prclDst->top) {
                prcl->top = prclDst->top;
            }

            if (prcl->bottom > prclDst->bottom){
                prcl->bottom = prclDst->bottom;
            }

            //
            // We check for NULL or inverted rectanges because we may get them.
            //

            if (prcl->top  < prcl->bottom)
            {
                ASSERTGDI(prcl->top >= 0,  "ERROR prcl->top >= 0");
                ASSERTGDI(prcl->left >= 0, "ERROR prcl->left >= 0");

                //
                // call BltLnkRect once for each vertical stripe that has width <=
                // to the size of the temporary scan line storage
                //
                // ulong count = (prcl->right - prcl->left)/(pixels per ulong) + 1;
                //

                while ((prcl->right - prcl->left) > 0)
                {

                    RECTL    TempRect;


                    TempRect.left  = prcl->right;
                    TempRect.right = prcl->right;

                    if (!bLocalAlloc) {
                        if ((prcl->right - prcl->left) > MaxWidth)
                        {
                            prcl->right    = prcl->left + MaxWidth;
                            TempRect.left  = prcl->right;
                        }
                    }

                    //
                    // if there is a mask, 2 passes will be required, one with negative
                    // mask using the Rop3Low and then once with a positive mask flag
                    // using Rop3High
                    //

                    if (Rop3Low != 0xAA)
                    {

                        bltInfo.rop3       = Rop3Low;
                        bltInfo.RopSrc     = RopSrcLow;
                        bltInfo.RopDst     = RopDstLow;
                        bltInfo.bNeedSrc   = bNeedSrcLow;
                        bltInfo.bNeedDst   = bNeedDstLow;
                        bltInfo.bNeedPat   = bNeedPatLow;
                        bltInfo.bNeedMsk   = bNeedMsk;
                        bltInfo.NegateMsk  = 0x00;
                        BltLnkRect(&bltInfo,prcl);

                    }

                    if (bNeedMsk &&(Rop3High != 0xAA) )
                    {

                        //
                        // perform second call to write the high mask ROP pixels
                        //

                        bltInfo.rop3       = Rop3High;
                        bltInfo.RopSrc     = RopSrcHigh;
                        bltInfo.RopDst     = RopDstHigh;
                        bltInfo.bNeedSrc   = bNeedSrcHigh;
                        bltInfo.bNeedDst   = bNeedDstHigh;
                        bltInfo.bNeedPat   = bNeedPatHigh;
                        bltInfo.bNeedMsk   = bNeedMsk;
                        bltInfo.NegateMsk  = 0xFF;

                        BltLnkRect(&bltInfo,prcl);
                    }


                    prcl->left  = TempRect.left;
                    prcl->right = TempRect.right;

                }

            }

        }

    } while (bMore);

    return(TRUE);
}



/******************************Public*Routine******************************\
*
* Routine Name:
*
*   BltLnkRect
*
* Routine Description:
*
*   Perform rectangular BitBlt using rop3 passed from BltLnk. The rops are
*   performed  using  temporary  scan  line  buffers  so  that the logical
*   operations are done 1 DWORD at a time.  The Src data is  copied to the
*   temporary  buffer using  SrcBlt  so the  the bitmap  format  and color
*   translation is done to match Src to Dst. Also Src alignment in matched
*   to Dst alignment  in SrcBlt.  The result of the logical combination is
*   copied to the destination using the appropriate SrcBlt routine.
*
* Arguments:
*
*   pBlt        -   BLT specific information
*   prcl        -   clipping rectangle
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID
BltLnkRect(
    PBLTLNKINFO pBlt,
    PRECTL      prcl
)

{
    LONG            cy;
    LONG            DwordCount;
    ULONG           ByteOffset;
    ULONG           PixelOffset;
    ULONG           PixelCount;
    ULONG           rop2;
    BLTINFO         SrcCopyBltInfo;
    BLTINFO         DstCopyBltInfo;
    PFN_SRCCPY      pfnSrcCopy;
    PFN_SRCCPY      pfnDstCopy;
    PFN_BLTLNKROP   pfnRop1,pfnRop2;
    PFN_READPAT     pfnReadPat;
    PFN_SRCCOPYMASK pfnCopyMask;
    ULONG           SrcBuffer[SCAN_LINE_BUFFER_LENGTH];
    ULONG           DstBuffer[SCAN_LINE_BUFFER_LENGTH];
    ULONG           RopBuffer0[SCAN_LINE_BUFFER_LENGTH];
    ULONG           RopBuffer1[SCAN_LINE_BUFFER_LENGTH];
    PBYTE           pjSrc = (PBYTE)NULL;
    PBYTE           pjDst = (PBYTE)NULL;
    PBYTE           pjPat = (PBYTE)NULL;
    ULONG           cxPat;
    ULONG           ixPat;
    LONG            cyPat;
    LONG            iyPat;
    ULONG           ixMsk;
    LONG            iyMsk;
    ULONG           iSolidColor;
    ULONG           ulDstStart;
    ULONG           Index;
    ULONG           ulIndex;
    ULONG           BytesPerPixel   = 0;
    ULONG           ByteOffset24Bpp = 0;
    BLTLNK_MASKINFO bmskMaskInfo;



    #if DBG_BLTLNK
        if (DbgBltLnk >= 1)
        {
            DbgPrint("BltLnkRect:\n");
            DbgPrint("  prcl = %li,%li to %li,%li\n",
                        prcl->left,prcl->top,prcl->right,prcl->bottom);
            DbgPrint("  yDir = %li, xDir = %li\n",
                        pBlt->yDir,pBlt->xDir);
            DbgPrint("  pjSrc = 0x%lx, pjDst = 0x%lx\n",pBlt->pjSrc,pBlt->pjDst);

        }

        if (DbgBltLnk >= 2)
        {
            DbgPrint("  Address of SrcBuffer  = 0x%p\n",&SrcBuffer[0]);
            DbgPrint("  Address of DstBuffer  = 0x%p\n",&DstBuffer[0]);
            DbgPrint("  Address of RopBuffer0 = 0x%p\n",&RopBuffer0[0]);
            DbgPrint("  Address of RopBuffer1 = 0x%p\n",&RopBuffer1[0]);
        }
    #endif

    //
    // Calculate all temporary parameters needed to perform the BitBlt
    // based on source and destination bitmap formats (which may be different)
    //
    // cy = number of scan lines to Blt
    //

    cy          = prcl->bottom - prcl->top;
    PixelCount  = prcl->right - prcl->left;

    #if DBG_BLTLNK
        if (DbgBltLnk >= 2)
        {
            DbgPrint("  cy = %li\n",cy);
        }
    #endif

    //
    // calculate parameters for:
    //
    //           1) SrcBlt routine to load source into DWORD buffer
    //              transformed to Dst alignment, format and color
    //           2) ROP2 routine to operate on DWORDS
    //           3) SrcBlt routine to store DWORD buffer to pjDst
    //

    switch(pBlt->pdioDst->iFormat())
    {
    case BMF_1BPP:
        ulDstStart      = prcl->left  >> 5;
        ByteOffset      = (prcl->left >> 3) & 0x03;
        PixelOffset     = prcl->left & 0x1f;
        DwordCount      = (PixelOffset + PixelCount + 31) >> 5;
        break;
    case BMF_4BPP:
        ulDstStart      = prcl->left  >> 3;
        ByteOffset      = (prcl->left >> 1) & 0x03;
        PixelOffset     = prcl->left & 0x07;
        DwordCount      = (PixelOffset + PixelCount + 7) >> 3;
        break;
    case BMF_8BPP:
        ulDstStart      = prcl->left  >> 2;
        ByteOffset      = prcl->left & 0x03;
        PixelOffset     = prcl->left & 0x03;
        DwordCount      = (PixelOffset + PixelCount + 3) >> 2;
        BytesPerPixel   = 1;
        break;
    case BMF_16BPP:
        ulDstStart      = prcl->left  >> 1;
        ByteOffset      = (prcl->left & 0x01) << 1;
        PixelOffset     = prcl->left & 0x01;
        DwordCount      = (PixelOffset + PixelCount + 1) >> 1;
        BytesPerPixel   = 2;
        break;
    case BMF_24BPP:
        ulDstStart      = (prcl->left  * 3) >> 2;
        ByteOffset      = (prcl->left * 3) & 0x03;
        PixelOffset     = 0;
        ByteOffset24Bpp = ByteOffset;
        BytesPerPixel   = 3;
        DwordCount      = (ByteOffset + 3 * PixelCount + 3) >> 2;
        break;
    case BMF_32BPP:
        ulDstStart      = prcl->left;
        DwordCount      = PixelCount;
        ByteOffset      = 0;
        PixelOffset     = 0;
        BytesPerPixel   = 4;
        break;
    }

    #if DBG_BLTLNK
        if (DbgBltLnk >= 2)
        {
            DbgPrint("  ulDstStart  = %li\n",ulDstStart);
            DbgPrint("  DwordCount  = %li\n",DwordCount);
            DbgPrint("  ByteOffset  = 0x%lx\n",ByteOffset);
            DbgPrint("  PixelOffset = 0x%lx\n",PixelOffset);
        }
    #endif

    //
    // if there is a pat that isn't a solid color then
    // set up params based on prcl
    //

    if (pBlt->pjPat != (PBYTE) NULL)
    {

        //
        // Set up format-specific pattern parameters for the call to
        // ReadPat. Note: there is only one call for reading
        // 8,16,24 and 32 Bpp patterns so cxPat, the pixel count is
        // adjusted to become a byte count for these cases. ixPat is
        // also adjusted to be a byte offset in these cases.
        //

        switch(pBlt->pdioDst->iFormat())
        {
        case BMF_1BPP:
            cxPat       = pBlt->cxPat;
            ixPat       = prcl->left - pBlt->xPatOrg;
            pfnReadPat  = BltLnkReadPat1;
            break;
        case BMF_4BPP:
            cxPat       = pBlt->cxPat;
            ixPat       = prcl->left - pBlt->xPatOrg;
            pfnReadPat  = BltLnkReadPat4;
            break;
        case BMF_8BPP:
            cxPat       = pBlt->cxPat;
            ixPat       = prcl->left - pBlt->xPatOrg;
            pfnReadPat  = BltLnkReadPat;
            break;
        case BMF_16BPP:
            cxPat       = pBlt->cxPat << 1;
            ixPat       = ((prcl->left - pBlt->xPatOrg) << 1);
            pfnReadPat  = BltLnkReadPat;
            break;
        case BMF_24BPP:
            cxPat       = pBlt->cxPat * 3;
            ixPat       = ((prcl->left - pBlt->xPatOrg) * 3);
            pfnReadPat  = BltLnkReadPat;
            break;
        case BMF_32BPP:
            cxPat       = pBlt->cxPat << 2;
            ixPat       = ((prcl->left - pBlt->xPatOrg) << 2);
            pfnReadPat  = BltLnkReadPat;
            break;
        }

        //
        // Normalize Pattern:
        //
        // make sure starting ixPat is within pattern limits
        // and set up iyPat and cyPat
        //

        if (ixPat >= cxPat)
        {
            ixPat %= cxPat;
        }// else if (ixPat < 0) {
         //   ixPat = (cxPat - 1) - ((-(LONG)ixPat - 1) % cxPat);
         // }

        cyPat = pBlt->cyPat;
        iyPat = prcl->top - pBlt->yPatOrg;

        if (pBlt->yDir < 0)
        {
            iyPat = iyPat + (cy - 1);
        }

        if (iyPat >= cyPat)
        {
            iyPat %= cyPat;
        } else if (iyPat < 0) {
            iyPat = (cyPat - 1) - ((-(LONG)iyPat - 1) % cyPat);
        }

        pjPat = pBlt->pjPat + (iyPat * pBlt->lDeltaPat);

        #if DBG_BLTLNK
            if (DbgBltLnk >= 2)
            {
                DbgPrint("  cxPat     = 0x%lx cyPat = 0x%lx\n",cxPat,cyPat);
                DbgPrint("  ixPat     = 0x%lx iyPat = 0x%lx\n",ixPat,iyPat);
                DbgPrint("  pjPat     = 0x%p\n",pjPat);
                DbgPrint("  lDeltaPat = 0x%lx\n",pBlt->lDeltaPat);
            }
        #endif

    } else {

        //
        // solid color for pat
        //

        iSolidColor = pBlt->iSolidColor;

        #if DBG_BLTLNK
            if (DbgBltLnk >= 2)
            {
                DbgPrint("  iSolidColor = 0x%lx\n",iSolidColor);
            }
        #endif

    }

    //
    // pjDst pointer to the beginning of the Dst scan line
    //
    // ulDstStart is added to (PULONG)pjDst to get the
    // address of the first ULONG containing pixels needed in
    // the blt
    //

    if (pBlt->yDir > 0)
    {
        pjDst = pBlt->pjDst + prcl->top * pBlt->lDeltaDst;
    } else {
        pjDst = pBlt->pjDst + (prcl->bottom - 1) * pBlt->lDeltaDst;
    }

    #if DBG_BLTLNK
        if (DbgBltLnk >= 2)
        {
            DbgPrint("  ulDstStart     = 0x%lx\n",ulDstStart);
            DbgPrint("  starting pjDst = 0x%p\n",pjDst);
            DbgPrint("  Byte Offset    = 0x%lx\n",ByteOffset);
        }
    #endif

    //
    // calculate Src parameters if the Src is needed. Src paramters are
    // used to load the entire Src into the temp buffer, aligned to
    // Dst and converted to Dst format, one scan line at a time
    //

    if (pBlt->pjSrc != (PBYTE) NULL)
    {

        //
        // set up color translate routines
        //

        SrcCopyBltInfo.pxlo = pBlt->pxlo;

        //
        // ySrc is the offset in scan lines from the start of the src bitmap
        //
        // xSrctart is the pixel offset from the strart of the scan line
        //      to the first pixel neded
        //
        // xSrcEnd is 1 pixel beyond the last one needed for the scan line
        //

        pBlt->ySrc      = pBlt->ySrcOrg   + prcl->top - pBlt->rclDst.top;
        pBlt->xSrcStart = pBlt->xSrcOrg   + prcl->left - pBlt->rclDst.left;
        pBlt->xSrcEnd   = pBlt->xSrcStart + (PixelCount);

        //
        // initialize pjSrc to point to the start of each scan line to be
        // copied
        //

        pjSrc = pBlt->pjSrc;

        if (pBlt->yDir > 0)
        {
            pjSrc = pjSrc + (pBlt->ySrc * pBlt->lDeltaSrc);
        } else {
            pjSrc = pjSrc + (pBlt->ySrc + cy - 1) * pBlt->lDeltaSrc;
        }

        #if DBG_BLTLNK
            if (DbgBltLnk >= 2)
            {
                DbgPrint("  starting pjSrc = %p\n",pjSrc);
                DbgPrint("  ySrc           = %li\n",pBlt->ySrc);
                DbgPrint("  xSrcStart      = %li\n",pBlt->xSrcStart);
                DbgPrint("  ySrcEnd        = %li\n",pBlt->xSrcEnd);
            }
        #endif

    }

    //
    // set up mask params
    //

    if (pBlt->bNeedMsk)
    {

        bmskMaskInfo.cxMsk = pBlt->cxMsk;
        ixMsk = pBlt->xMskOrg + prcl->left - pBlt->rclDst.left;
        iyMsk = pBlt->yMskOrg + prcl->top  - pBlt->rclDst.top;

        //
        // # of pixels offsets to first pixel for src from start of scan
        //

        if (pBlt->yDir < 0)
        {
            iyMsk += (cy - 1);
        }

        //
        // Normalize Msk again since prcl->left-pBlt->rclDst.left has
        // been added.
        //
        // ixMsk should not be < 0 because MskOrg has already
        // been normalized.
        //

        ASSERTGDI(iyMsk >= 0, " ERROR, negative iyMsk that has already been normalized");

        if (ixMsk >= pBlt->cxMsk)
        {
            ixMsk = ixMsk % pBlt->cxMsk;
        }

        if (iyMsk >= pBlt->cyMsk)
        {
            iyMsk = iyMsk % pBlt->cyMsk;
        }

        //
        // info for SrcCopyMsk routines
        //

        bmskMaskInfo.pjMskBase    = pBlt->pjMsk;
        bmskMaskInfo.pjMsk        = pBlt->pjMsk + (iyMsk * pBlt->lDeltaMsk);
        bmskMaskInfo.ixMsk        = ixMsk;
        bmskMaskInfo.cxMsk        = pBlt->cxMsk;
        bmskMaskInfo.iyMsk        = iyMsk;
        bmskMaskInfo.cyMsk        = pBlt->cyMsk;
        bmskMaskInfo.NegateMsk    = pBlt->NegateMsk;
        bmskMaskInfo.lDeltaMskDir = pBlt->lDeltaMskDir;

        //
        // select mask store routine
        //

        switch(pBlt->pdioDst->iFormat())
        {
        case BMF_1BPP:
            pfnCopyMask = BltLnkSrcCopyMsk1;
            break;
        case BMF_4BPP:
            pfnCopyMask = BltLnkSrcCopyMsk4;
            break;
        case BMF_8BPP:
            pfnCopyMask   = BltLnkSrcCopyMsk8;
            break;
        case BMF_16BPP:
            pfnCopyMask   = BltLnkSrcCopyMsk16;
            break;
        case BMF_24BPP:
            pfnCopyMask   = BltLnkSrcCopyMsk24;
            break;
        case BMF_32BPP:
            pfnCopyMask   = BltLnkSrcCopyMsk32;
            break;
        }
    }

    ////////////////////////////////////////////////////////////////
    //                                                            //
    // Place Accelerators Here for special cases that can not     //
    // go through the normal load/combine/store procedure. Only   //
    // positive x and y blts are accelerated (left to right),     //
    // top to bottom.                                             //
    //                                                            //
    ////////////////////////////////////////////////////////////////

    if ((pBlt->xDir > 0) && (pBlt->yDir > 0)) {

        //
        // Mask Blt
        //

        if ((pBlt->rop3 == 0xCC) &&
             pBlt->bNeedMsk &&
            (pBlt->pdioSrc->iFormat() == pBlt->pdioDst->iFormat()) &&
            (pBlt->pxlo->bIsIdentity()))
        {

            //
            // customize DstCopyBltInfo for MaskBlt 0xAACC or 0xCCAA will
            // reach this point with a rop3 of CC. Color translations use the
            // normal path.
            //

            DstCopyBltInfo.pjDst     = pjDst;
            DstCopyBltInfo.pjSrc     = pjSrc;
            DstCopyBltInfo.xDir      = 1;
            DstCopyBltInfo.yDir      = pBlt->yDir;
            DstCopyBltInfo.cx        = PixelCount;
            DstCopyBltInfo.cy        = cy;
            DstCopyBltInfo.lDeltaSrc = pBlt->lDeltaSrcDir;
            DstCopyBltInfo.lDeltaDst = pBlt->lDeltaDstDir;
            DstCopyBltInfo.xSrcStart = pBlt->xSrcStart;
            DstCopyBltInfo.xSrcEnd   = pBlt->xSrcStart + PixelCount;
            DstCopyBltInfo.xDstStart = prcl->left;
            DstCopyBltInfo.yDstStart = 0;
            DstCopyBltInfo.pxlo      = &xloIdent;

            (*pfnCopyMask)(&DstCopyBltInfo,&bmskMaskInfo,&SrcBuffer[0],&DstBuffer[0]);

            return;
        }

        //
        // ROP B8B8, src = 1bpp, translate to 00,ff. this is a src of 1bpp used as a mask
        // to blt a solid color to dst as  Dst = (Src & Dst)  | (~Src & Pat)
        //
        // Also accelerate ROP E2E2 which is the opposite of B8B8 ie:
        //
        //                                 Dst = (~Src & Dst)  | (Src & Pat)
        //

        if ( ((pBlt->rop3 == 0xB8) || (pBlt->rop3 == 0xE2)) &&
             (!pBlt->bNeedMsk) &&
             (pBlt->iSolidColor != 0xffffffff) &&
             (pBlt->pdioSrc->iFormat() == BMF_1BPP) &&
             ((pBlt->pdioDst->iFormat() >= BMF_8BPP) &&
              (pBlt->pdioDst->iFormat() <= BMF_32BPP)) )
        {
            PFN_PATMASKCOPY pfnCopy;
            ULONG colormask;

            switch (pBlt->pdioDst->iFormat())
            {
                //
                // BltLnkPatMaskCopy4 (and probably BltLnkPatMaskCopy1) are
                // broken, so don't use them for now.
                //

            case BMF_8BPP:
                pfnCopy = BltLnkPatMaskCopy8;
                colormask = 0x0000ff;
                break;
            case BMF_16BPP:
                pfnCopy = BltLnkPatMaskCopy16;
                colormask = 0x00ffff;
                break;
            case BMF_24BPP:
                pfnCopy = BltLnkPatMaskCopy24;
                colormask = 0xffffff;
                break;
            case BMF_32BPP:
                pfnCopy = BltLnkPatMaskCopy32;
                colormask = 0xffffff;
                break;
            default:
                RIP("Unexpected case.");
            }

            PULONG pulTranslate = pBlt->pxlo->pulXlate;

            if ( ((pulTranslate[1] & colormask) == colormask) &&
                 ((pulTranslate[0] & colormask) == 0))
            {

                BYTE Invert = 0x00;

                if (pBlt->rop3 == 0xE2) {
                    Invert = 0xFF;
                }

                //
                // set up blt info
                //

                DstCopyBltInfo.pjDst     = pjDst;
                DstCopyBltInfo.pjSrc     = pjSrc;
                DstCopyBltInfo.xDir      = 1;
                DstCopyBltInfo.yDir      = pBlt->yDir;
                DstCopyBltInfo.cx        = PixelCount;
                DstCopyBltInfo.cy        = cy;
                DstCopyBltInfo.lDeltaSrc = pBlt->lDeltaSrcDir;
                DstCopyBltInfo.lDeltaDst = pBlt->lDeltaDstDir;
                DstCopyBltInfo.xSrcStart = pBlt->xSrcStart;
                DstCopyBltInfo.xSrcEnd   = pBlt->xSrcStart + PixelCount;
                DstCopyBltInfo.xDstStart = prcl->left;
                DstCopyBltInfo.yDstStart = 0;
                DstCopyBltInfo.pxlo      = pBlt->pxlo;

                (*pfnCopy)(&DstCopyBltInfo,pBlt->iSolidColor,&SrcBuffer[0],Invert);

                return;
            }
        }

        //
        // accelerators for VGA 256 special cases
        //

        if ((!pBlt->bNeedMsk) &&
            (pBlt->bNeedSrc) &&
            (pBlt->bNeedDst) &&
            (pBlt->pdioDst->iFormat() == BMF_8BPP) &&
            (pBlt->pdioSrc->iFormat() == BMF_8BPP) &&
            (pBlt->pxlo->bIsIdentity())
           )
        {
            //
            // ROP 6666 DSx
            //

            if (pBlt->rop3 == 0x66)
            {
                BltLnkAccel6666(
                            pjSrc + pBlt->xSrcStart,
                            pjDst + prcl->left,
                            pBlt->lDeltaSrcDir,
                            pBlt->lDeltaDstDir,
                            PixelCount,
                            cy
                            );
                return;
            }

            //
            // ROP 8888 DSa
            //

            if (pBlt->rop3 == 0x88)
            {
                BltLnkAccel8888(
                            pjSrc + pBlt->xSrcStart,
                            pjDst + prcl->left,
                            pBlt->lDeltaSrcDir,
                            pBlt->lDeltaDstDir,
                            PixelCount,
                            cy
                            );
                return;
            }

            //
            // ROP EEEE DSo
            //

            if (pBlt->rop3 == 0xEE)
            {
                BltLnkAccelEEEE(
                            pjSrc + pBlt->xSrcStart,
                            pjDst + prcl->left,
                            pBlt->lDeltaSrcDir,
                            pBlt->lDeltaDstDir,
                            PixelCount,
                            cy
                            );
                return;
            }
        }

        //
        // END OF ACCELERATORS
        //

    }

    ////////////////////////////////////////////////////////////////
    //                                                            //
    // Non-accelerated cases                                      //
    //                                                            //
    ////////////////////////////////////////////////////////////////


    if (pBlt->bNeedSrc)
    {
        //
        // fill out the SrcCopyBltInfo structure to be used by SrcBltxxx routine
        // to read the src bitmap and copy it to dst format and alignment
        //

        SrcCopyBltInfo.pjDst     = (PBYTE)(&SrcBuffer[0]) + ByteOffset24Bpp;
        SrcCopyBltInfo.pjSrc     = pjSrc;
        SrcCopyBltInfo.xDir      = 1;
        SrcCopyBltInfo.yDir      = pBlt->yDir;
        SrcCopyBltInfo.cx        = PixelCount;
        SrcCopyBltInfo.cy        = 1;
        SrcCopyBltInfo.lDeltaSrc = 1;
        SrcCopyBltInfo.lDeltaDst = 1;
        SrcCopyBltInfo.xSrcStart = pBlt->xSrcStart;
        SrcCopyBltInfo.xSrcEnd   = pBlt->xSrcStart + SrcCopyBltInfo.cx;
        SrcCopyBltInfo.xDstStart = PixelOffset;
        SrcCopyBltInfo.yDstStart = 1;
        SrcCopyBltInfo.pxlo      = pBlt->pxlo;

        //
        // select SrcCopy routine based on bitmap formats and color translation
        //

        Index = (pBlt->pdioDst->iFormat() << 5) | (pBlt->pdioSrc->iFormat() << 2);

        if (pBlt->pxlo->bIsIdentity())
        {
            Index += 1;
        }

        pfnSrcCopy = SrcCopyFunctionTable[Index];

    }

    //
    // fill out the DstCopyBltInfo structure to be used by SrcBltxxx routine
    // to copy the dst scan line to the actual destination
    //


    DstCopyBltInfo.pjDst     = pjDst;
    DstCopyBltInfo.pjSrc     = (PBYTE)&DstBuffer[0] + ByteOffset24Bpp;
    DstCopyBltInfo.xDir      = 1;
    DstCopyBltInfo.yDir      = pBlt->yDir;
    DstCopyBltInfo.cx        = PixelCount;
    DstCopyBltInfo.cy        = 1;
    DstCopyBltInfo.lDeltaSrc = 1;
    DstCopyBltInfo.lDeltaDst = 1;
    DstCopyBltInfo.xSrcStart = PixelOffset;
    DstCopyBltInfo.xSrcEnd   = PixelOffset + DstCopyBltInfo.cx;
    DstCopyBltInfo.xDstStart = prcl->left;
    DstCopyBltInfo.yDstStart = 0;
    DstCopyBltInfo.pxlo      = &xloIdent;

    //
    // select DstCopy routine based on bitmap formats and color translation,
    // only need SrcCopy routine selection if not using mask
    //

    if (!pBlt->bNeedMsk)
    {

        Index = (pBlt->pdioDst->iFormat() << 5) | (pBlt->pdioDst->iFormat() << 2);

        //
        // color translation already done
        //

        Index += 1;

        pfnDstCopy = SrcCopyFunctionTable[Index];
    }

    //
    // define the ROP function, there are 4 possible ROP functions:
    //
    //  if Pat is not need then it is a ROP 2 without Pat
    //
    //  if Dst is not need then it is a ROP 2 without Dst
    //
    //  if Src is not need then it is a ROP 2 without Src
    //
    //  If src,dst and pat are needed to calculate the new dest then it is a
    //  full ROP3
    //
    //

    if (!pBlt->bNeedPat)
    {

        rop2 = pBlt->rop3 & 0x0F;

        #if DBG_BLTLNK
            if (DbgBltLnk >= 2)
            {
                DbgPrint("  Select no pat rop, rop2 function = %li\n",rop2);
            }
        #endif

        //
        // ROP without Pat
        //

        pfnRop1 = RopFunctionTable[rop2];

        //
        // blt each scan line
        //

        Index = cy;

        while (Index--)
        {

            if (pBlt->bNeedSrc)
            {

                //
                // get src scan line if offset or
                // color translation are needed
                //

                (*pfnSrcCopy)(&SrcCopyBltInfo);

                //
                // update pointer for next src line
                //

                SrcCopyBltInfo.pjSrc += pBlt->lDeltaSrcDir;
            }

            //
            // ROP the buffers together
            //

            (*pfnRop1)(&DstBuffer[0],(PULONG)pjDst + ulDstStart,&SrcBuffer[0],DwordCount);

            //
            // copy the buffer to the dest
            //

            if (!pBlt->bNeedMsk)
            {

                (*pfnDstCopy)(&DstCopyBltInfo);

            } else {

                //
                // call store routine with mask
                //

                (*pfnCopyMask)(&DstCopyBltInfo,&bmskMaskInfo,&RopBuffer0[0],NULL);

                //
                // increment to the next mask scan line,
                // check for going off the edge. This must
                // be done for pos and neg blts
                //
                // should be an inline function!
                //

                if (pBlt->yDir > 0) {

                    iyMsk++;
                    bmskMaskInfo.pjMsk += pBlt->lDeltaMskDir;

                    if (iyMsk >= pBlt->cyMsk)
                    {
                        iyMsk = 0;
                        bmskMaskInfo.pjMsk = pBlt->pjMsk;
                    }

                } else {

                    if (iyMsk == 0)
                    {
                        iyMsk = pBlt->cyMsk - 1;
                        bmskMaskInfo.pjMsk = pBlt->pjMsk +
                                             (pBlt->lDeltaMsk * (pBlt->cyMsk - 1));
                    }
                    else
                    {
                        iyMsk--;
                        bmskMaskInfo.pjMsk += pBlt->lDeltaMskDir;
                    }
                }
            }

            //
            // increment to the next scan line
            //

            pjDst += pBlt->lDeltaDstDir;
            DstCopyBltInfo.pjDst = pjDst;

        }

    //
    // ROP that doesn't require Dst
    //

    } else if (!pBlt->bNeedDst) {

        rop2 = pBlt->RopDst & 0x0f;
        pfnRop1 = RopFunctionTable[rop2];

        #if DBG_BLTLNK
            if (DbgBltLnk >= 2)
            {
                DbgPrint("  Select no dst rop, rop2 function = %lx\n",rop2);
            }
        #endif

        //
        // fill in solid color if there is no pjPat;
        //

        if (pjPat == (PBYTE) NULL)
        {

            if (pBlt->pdioDst->iFormat() != BMF_24BPP)
            {

                //
                // fill in RopBuffer1 with the 32 bit solid color.
                // Number of DWORDS = Number of BYTES/4
                //

                ulIndex = DwordCount;

                while (ulIndex > 0)
                {
                    RopBuffer1[--ulIndex] = iSolidColor;
                }

            } else {

                PBYTE   pjSolidPat = (PBYTE)(&RopBuffer1[0]) + ByteOffset24Bpp;

                //
                // read in 24bpp solid color
                //

                ulIndex = PixelCount;

                while (ulIndex > 0)
                {
                    *pjSolidPat     = (BYTE)(iSolidColor         & 0x0000FF);
                    *(pjSolidPat+1) = (BYTE)((iSolidColor >>  8) & 0x0000FF);
                    *(pjSolidPat+2) = (BYTE)((iSolidColor >> 16) & 0x0000FF);
                    pjSolidPat+=3;
                    ulIndex--;
                }

            }
        }

        //
        // ROP without Dst
        //

        while (cy--)
        {

            if (pBlt->bNeedSrc)
            {

                //
                // get src scan line
                //

                (*pfnSrcCopy)(&SrcCopyBltInfo);

                //
                // update pointer for next src line
                //

                SrcCopyBltInfo.pjSrc  += pBlt->lDeltaSrcDir;
            }

            if (pjPat != (PBYTE) NULL)
            {

                if (pjPat != (PBYTE) NULL)
                {

                    (*pfnReadPat)((PBYTE)&RopBuffer1[0]+ByteOffset,PixelOffset,pjPat,cxPat,ixPat,PixelCount,BytesPerPixel);

                    if (pBlt->yDir == 1) {

                        iyPat++;
                        pjPat += pBlt->lDeltaPatDir;

                        if (iyPat >= cyPat)
                        {
                            iyPat = 0;
                            pjPat = pBlt->pjPat;
                        }

                    } else {

                        if (iyPat == 0)
                        {
                            iyPat = cyPat - 1;
                            pjPat = pBlt->pjPat +
                                              (pBlt->lDeltaPat * (cyPat - 1));
                        }
                        else
                        {
                            iyPat--;
                            pjPat -= pBlt->lDeltaPat;
                        }

                    }

                }
            }

            //
            // ROP the buffers together
            //

            (*pfnRop1)(&DstBuffer[0],&RopBuffer1[0],&SrcBuffer[0],DwordCount);

            //
            // copy the result to the screen
            //

            if (!pBlt->bNeedMsk)
            {

                (*pfnDstCopy)(&DstCopyBltInfo);

            } else {

                //
                // call store routine with mask
                //

                (*pfnCopyMask)(&DstCopyBltInfo,&bmskMaskInfo,&SrcBuffer[0],NULL);

                //
                // increment to the next mask scan line,
                // check for going off the edge. This must
                // be done for pos and neg blts
                //
                // should be an inline function!
                //

                if (pBlt->yDir > 0) {

                    iyMsk++;
                    bmskMaskInfo.pjMsk += pBlt->lDeltaMskDir;

                    if (iyMsk >= pBlt->cyMsk)
                    {
                        iyMsk = 0;
                        bmskMaskInfo.pjMsk = pBlt->pjMsk;
                    }

                } else {

                    if (iyMsk == 0)
                    {
                        iyMsk = pBlt->cyMsk - 1;
                        bmskMaskInfo.pjMsk = pBlt->pjMsk +
                                             (pBlt->lDeltaMsk * (pBlt->cyMsk - 1));
                    }
                    else
                    {
                        iyMsk--;
                        bmskMaskInfo.pjMsk += pBlt->lDeltaMskDir;
                    }
                }
            }

            //
            // increment to the next scan line
            //

            pjDst += pBlt->lDeltaDstDir;
            DstCopyBltInfo.pjDst = pjDst;
        }

    //
    // ROP that doesn't require Src
    //

    } else if (!pBlt->bNeedSrc) {

        //
        // fill in solid color if there is no pjPat;
        //

        if (pjPat == (PBYTE) NULL)
        {

            if (pBlt->pdioDst->iFormat() != BMF_24BPP)
            {

                //
                // Replicate solid pattern to buffer
                // Number of DWORDS = Number of BYTES/4
                //

                ulIndex = DwordCount;

                while (ulIndex > 0)
                {
                    RopBuffer1[--ulIndex] = iSolidColor;
                }

            } else {

                PBYTE   pjSolidPat = (PBYTE)(&RopBuffer1[0]) + ByteOffset24Bpp;

                ulIndex = PixelCount;

                //
                // read in 24bpp solid color
                //

                while (ulIndex > 0)
                {
                    *pjSolidPat   = (BYTE)(iSolidColor         & 0x0000FF);
                    *(pjSolidPat+1) = (BYTE)((iSolidColor >>  8) & 0x0000FF);
                    *(pjSolidPat+2) = (BYTE)((iSolidColor >> 16) & 0x0000FF);
                    pjSolidPat+=3;
                    ulIndex--;
                }

            }
        }

        //
        // Rop without SRC
        //

        rop2 = pBlt->RopSrc & 0x0f;

        #if DBG_BLTLNK
            if (DbgBltLnk >= 2)
            {
                DbgPrint("  Select no src rop, rop2 function = %lx\n",rop2);
            }
        #endif

        pfnRop1 = RopFunctionTable[rop2];

        //
        // blt each scan line
        //

        Index = cy;

        while (Index--)
        {

            //
            // will need pat for sure
            //

            if (pBlt->bNeedPat)
            {

                if (pjPat != (PBYTE) NULL)
                {

                    (*pfnReadPat)((PBYTE)&RopBuffer1[0]+ByteOffset,PixelOffset,pjPat,cxPat,ixPat,PixelCount,BytesPerPixel);

                    if (pBlt->yDir == 1) {

                        iyPat++;
                        pjPat += pBlt->lDeltaPatDir;

                        if (iyPat >= cyPat)
                        {
                            iyPat = 0;
                            pjPat = pBlt->pjPat;
                        }

                    } else {

                        if (iyPat == 0)
                        {
                            iyPat = cyPat - 1;
                            pjPat = pBlt->pjPat +
                                              (pBlt->lDeltaPat * (cyPat - 1));
                        }
                        else
                        {
                            iyPat--;
                            pjPat -= pBlt->lDeltaPat;
                        }

                    }

                }
            }

            //
            // ROP the memory buffers together
            //

            (*pfnRop1)(&DstBuffer[0],(PULONG)pjDst + ulDstStart,&RopBuffer1[0],DwordCount);

            //
            // copy the result to the dest
            //

            if (!pBlt->bNeedMsk)
            {

                (*pfnDstCopy)(&DstCopyBltInfo);

            } else {

                //
                // call store routine with mask
                //

                (*pfnCopyMask)(&DstCopyBltInfo,&bmskMaskInfo,&SrcBuffer[0],NULL);

                //
                // increment to the next mask scan line,
                // check for going off the edge. This must
                // be done for pos and neg blts
                //
                // should be an inline function!
                //

                if (pBlt->yDir > 0) {

                    iyMsk++;
                    bmskMaskInfo.pjMsk += pBlt->lDeltaMskDir;

                    if (iyMsk >= pBlt->cyMsk)
                    {
                        iyMsk = 0;
                        bmskMaskInfo.pjMsk = pBlt->pjMsk;
                    }

                } else {

                    if (iyMsk == 0)
                    {
                        iyMsk = pBlt->cyMsk - 1;
                        bmskMaskInfo.pjMsk = pBlt->pjMsk +
                                             (pBlt->lDeltaMsk * (pBlt->cyMsk - 1));
                    }
                    else
                    {
                        iyMsk--;
                        bmskMaskInfo.pjMsk += pBlt->lDeltaMskDir;
                    }
                }
            }

            //
            // increment to next dest
            //

            pjDst += pBlt->lDeltaDstDir;
            DstCopyBltInfo.pjDst = pjDst;
        }

    //
    //  FULL rop3
    //

    }  else {

        PULONG  pTmpDstBuffer;
        PULONG  pTmpRopBuffer0;
        PULONG  pTmpRopBuffer1;
        PULONG  pTmpSrcBuffer;
        ULONG   SrcColor;

        //
        // full ROP 3, perform in 2 passes through ROP 2, 1 for
        // not Pat and one for Pat. This rop will need src,dst and pat
        //

        rop2 = pBlt->rop3;

        #if DBG_BLTLNK
            if (DbgBltLnk >= 2)
            {
                DbgPrint("  Select full rop, rop2 function = %lx\n",rop2 & 0x0f);
                DbgPrint("                   rop2 function = %lx\n",(rop2 & 0xf0) >> 4);
            }
        #endif

        pfnRop1 = RopFunctionTable[   rop2 & 0x0f ];
        pfnRop2 = RopFunctionTable[ ( rop2 & 0xf0 ) >> 4 ];

        Index = cy;

        while (Index--)
        {

            //
            // get src scan line
            //

            (*pfnSrcCopy)(&SrcCopyBltInfo);

            //
            // update pointer for next src line
            //

            SrcCopyBltInfo.pjSrc  += pBlt->lDeltaSrcDir;

            //
            // set dst buffer pointer to dst
            //

            pTmpDstBuffer = (PULONG)pjDst + ulDstStart;

            //
            // perform both rop passes
            //

            (*pfnRop1)(&RopBuffer0[0],pTmpDstBuffer,&SrcBuffer[0],DwordCount);
            (*pfnRop2)(&RopBuffer1[0],pTmpDstBuffer,&SrcBuffer[0],DwordCount);


            if (pjPat != (PBYTE) NULL)
            {

                //
                // fill up a buffer with the pattern
                //

                (*pfnReadPat)((PBYTE)&SrcBuffer[0] + ByteOffset,PixelOffset,pjPat,cxPat,ixPat,PixelCount,BytesPerPixel);

                if (pBlt->yDir == 1) {

                    iyPat++;
                    pjPat += pBlt->lDeltaPatDir;

                    if (iyPat >= cyPat)
                    {
                        iyPat = 0;
                        pjPat = pBlt->pjPat;
                    }

                } else {

                    if (iyPat == 0)
                    {
                        iyPat = cyPat - 1;
                        pjPat = pBlt->pjPat +
                                          (pBlt->lDeltaPat * (cyPat - 1));
                    }
                    else
                    {
                        iyPat--;
                        pjPat -= pBlt->lDeltaPat;
                    }

                }

                //
                // combine ROPs based on pat
                //

                pTmpDstBuffer  = &DstBuffer[0];
                pTmpRopBuffer0 = &RopBuffer0[0];
                pTmpRopBuffer1 = &RopBuffer1[0];
                pTmpSrcBuffer  = &SrcBuffer[0];

                ulIndex = DwordCount;

                while (ulIndex > 0)
                {

                    SrcColor = *pTmpSrcBuffer;

                    *pTmpDstBuffer = (*pTmpRopBuffer1 &  SrcColor |
                                      *pTmpRopBuffer0 & ~SrcColor);

                    pTmpSrcBuffer++;
                    pTmpDstBuffer++;
                    pTmpRopBuffer0++;
                    pTmpRopBuffer1++;
                    ulIndex--;
                }

            } else {

                //
                // solid pattern
                //

                if (pBlt->pdioDst->iFormat() != BMF_24BPP)
                {

                    pTmpDstBuffer  = &DstBuffer[0];
                    pTmpRopBuffer0 = &RopBuffer0[0];
                    pTmpRopBuffer1 = &RopBuffer1[0];

                    ulIndex = DwordCount;

                    while (ulIndex > 0)
                    {

                        *pTmpDstBuffer = (*pTmpRopBuffer1 &  iSolidColor |
                                          *pTmpRopBuffer0 & ~iSolidColor);
                        pTmpDstBuffer++;
                        pTmpRopBuffer0++;
                        pTmpRopBuffer1++;
                        ulIndex--;
                    }

                } else {

                    //
                    // fill up a buffer with 24bpp solid pat
                    //

                    PBYTE   pjSolidPat = (PBYTE)(&SrcBuffer[0]) + ByteOffset24Bpp;

                    //
                    // read in 24bpp solid color
                    //

                    ulIndex = PixelCount;

                    while (ulIndex>0)
                    {
                        *pjSolidPat     = (BYTE)(iSolidColor         & 0x0000FF);
                        *(pjSolidPat+1) = (BYTE)((iSolidColor >>  8) & 0x0000FF);
                        *(pjSolidPat+2) = (BYTE)((iSolidColor >> 16) & 0x0000FF);
                        pjSolidPat+=3;
                        ulIndex--;
                    }

                    //
                    // combine ROPs based on pat
                    //

                    pTmpDstBuffer  = &DstBuffer[0];
                    pTmpRopBuffer0 = &RopBuffer0[0];
                    pTmpRopBuffer1 = &RopBuffer1[0];
                    pTmpSrcBuffer  = &SrcBuffer[0];

                    ulIndex = DwordCount;

                    while (ulIndex > 0)
                    {

                        SrcColor = *pTmpSrcBuffer;

                        *pTmpDstBuffer = (*pTmpRopBuffer1 &  SrcColor |
                                          *pTmpRopBuffer0 & ~SrcColor);
                        pTmpSrcBuffer++;
                        pTmpDstBuffer++;
                        pTmpRopBuffer0++;
                        pTmpRopBuffer1++;
                        ulIndex--;
                    }


                }

            }

            //
            // write out temp buffer to destination
            //

            if (!pBlt->bNeedMsk)
            {

                (*pfnDstCopy)(&DstCopyBltInfo);

            } else {

                //
                // call store routine with mask
                //

                (*pfnCopyMask)(&DstCopyBltInfo,&bmskMaskInfo,&SrcBuffer[0],NULL);

                //
                // increment to the next mask scan line,
                // check for going off the edge. This must
                // be done for pos and neg blts
                //
                // should be an inline function!
                //

                if (pBlt->yDir > 0) {

                    iyMsk++;
                    bmskMaskInfo.pjMsk += pBlt->lDeltaMskDir;

                    if (iyMsk >= pBlt->cyMsk)
                    {
                        iyMsk = 0;
                        bmskMaskInfo.pjMsk = pBlt->pjMsk;
                    }

                } else {

                    if (iyMsk == 0)
                    {
                        iyMsk = pBlt->cyMsk - 1;
                        bmskMaskInfo.pjMsk = pBlt->pjMsk +
                                             (pBlt->lDeltaMsk * (pBlt->cyMsk - 1));
                    }
                    else
                    {
                        iyMsk--;
                        bmskMaskInfo.pjMsk += pBlt->lDeltaMskDir;
                    }
                }
            }

            //
            // increment Dst to next scan line
            //

            pjDst += pBlt->lDeltaDstDir;
            DstCopyBltInfo.pjDst = pjDst;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\brushddi.cxx ===
/******************************Module*Header*******************************\
* Module Name: brushddi.cxx
*
* This provides the call backs necesary for brush realization.
*
* Created: 25-Apr-1991 20:59:49
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

BOOL
EngRealizeBrush(
    BRUSHOBJ *pbo,
    SURFOBJ  *psoTarget,
    SURFOBJ  *psoPattern,
    SURFOBJ  *psoMask,
    XLATEOBJ *pxlo,
    ULONG    iHatch
    );

BOOL
bGetRealizedBrush(
    BRUSH *pbrush,
    EBRUSHOBJ *pebo,
    PFN_DrvRealizeBrush pfnDrv
    );


#if DBG
ULONG dbrushalloc = 0, dbrushcachecheck = 0;
ULONG dbrushcachegrabbed = 0, dbrushcachehit = 0;
#endif


/******************************Public*Routine******************************\
* BRUSHOBJ_pvAllocRbrush
*
* Allocates memory for the driver's realization of a brush.  This is always
* called by the driver, never by the engine.
*
* History:
*  25-Apr-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

PVOID
BRUSHOBJ_pvAllocRbrush(
    BRUSHOBJ *pbo, ULONG cj
    )
{
    ASSERTGDI(cj != 0, "ERROR GDI BRUSHOBJ_pvAllocRbrush cj = 0");
    ASSERTGDI(pbo->iSolidColor == 0xFFFFFFFF,
            "ERROR GDI BRUSHOBJ_pvAllocRbrush solid color brush passed in");

    DBRUSH *pdbrush;

#if DBG
    dbrushalloc++;
#endif

    //
    // If there's a cached DBRUSH, try to use it instead of allocating
    //
    if (gpCachedDbrush != NULL)
    {

#if DBG
        dbrushcachecheck++;
#endif
        //
        // Try to grab the cached DBRUSH
        //

        if ((pdbrush =
                (PDBRUSH) InterlockedExchangePointer((PVOID *)&gpCachedDbrush,
                                              NULL))
                != NULL)
        {

#if DBG
        dbrushcachegrabbed++;
#endif

            //
            // Got the cached DBRUSH; see if it's big enough
            //
            // Note: -4 because we define the realization buffer start as aj[0]
            //

            if (pdbrush->ulSizeGet() >= (sizeof(DBRUSH) - 4 + cj))
            {

#if DBG
                dbrushcachehit++;
#endif
                //
                // It's big enough, so we'll use it and we're done
                //
                return(pbo->pvRbrush = pdbrush->aj);
            }
            else
            {
                //
                // Not big enough; free it and do a normal allocation
                //
                VFREEMEM(pdbrush);
            }
        }
    }

    // Note: -4 because we define the realization buffer start as aj[0]
    if ((pdbrush = (DBRUSH *)PALLOCMEM(ULONGSIZE_T(sizeof(DBRUSH) - 4 + cj),'rbdG'))
            != NULL)
    {
        //
        // Remember the size of the allocation, for caching.
        //
        pdbrush->ulSizeSet(sizeof(DBRUSH) - 4 + cj);

        return(pbo->pvRbrush = pdbrush->aj);
    }
    else
    {
        WARNING("Failed memory alloc BRUSHOBJ_pvAllocRbrush\n");
        return(NULL);
    }
}


//
// User mode printer driver support
//

PVOID
BRUSHOBJ_pvAllocRbrushUMPD(
    BRUSHOBJ    *pbo,
    ULONG       cj
    )

{
    if (pbo->pvRbrush == NULL)
    {
        DBRUSH  *pdbrush;

        cj += MAGIC_DBR_DIFF;

        if (pdbrush = (DBRUSH *) EngAllocUserMem(cj, UMPD_MEMORY_TAG))
        {
            pdbrush->ulSizeSet(cj);
            pdbrush->bMultiBrush(FALSE);
            pdbrush->bUMPDRBrush(TRUE);

            pbo->pvRbrush = pdbrush->aj;
        }
    }
    else
    {
        RIP("BRUSHOBJ_pvAllocRbrush when pvRbrush is not NULL\n");
    }

    return pbo->pvRbrush;
}



/******************************Public*Routine******************************\
* vTryToCacheRealization
*
* Attempt to cache the realization pointed to by pdbrush and described by pebo
* in the logical brush pointed to by pbrush. The way this works is that only
* the first realization of the logical brush can be cached. crFore is the key
* that indicates when the cached realization is valid. If crFore is not -1 when
* the logical brush is being realized, we just go realize the brush; if it's
* not -1, we check the cache ID fields to see if we can use the cached fields.
* InterlockedExchange() is used below to set crFore to make sure the cache ID
* fields are set before crFore. bCacheGrabbed() is used to protect the setting
* of the cache ID fields; once it's set, no one else can modify the cache ID
* fields, but no one else will try to use them until crFore is not -1.
*
* Also initializes the reference count in the realization to indicates either
* 1 or 2 current uses, depending on whether caching took place.
*
* History:
*  31-Oct-1993 -by- Michael Abrash [mikeab]
* Wrote it.
\**************************************************************************/

VOID
vTryToCacheRealization(
    EBRUSHOBJ *pebo,
    PRBRUSH prbrush,
    PBRUSH pbrush,
    BOOL bType
    )
{
// Reference count the realization once for being selected into this DC. This
// assumes we won't succeed in caching the brush next; if we do, we do a double
// reference count, once for caching in the logical brush and once for
// selecting into the DC

    prbrush->cRef(1);

// See if we can cache this realization in the logical brush; we can't if
// another realization has already been cached in the logical brush

    if ( !pbrush->bCacheGrabbed() )
    {

    // Try to grab the "can cache" flag; if we don't get it, someone just
    // sneaked in and got it ahead of us, so we're out of luck and can't cache

        if ( pbrush->bGrabCache() )
        {

        // We got the "can cache" flag, so now we can cache this realization
        // in the logical brush

        // It's cached in the brush, so it won't be deleted until the logical
        // brush goes away and it's not selected into any DCs, so reference
        // count the realization again. We don't need to do an
        // InterlockedIncrement here because until crFore is set, no one else
        // can get at this realization. InterlockedExchange() is used below to
        // set crFore to make sure the reference count is set before anyone
        // else can see the caching info

            prbrush->cRef(2);

        // These cache ID fields must be set before crFore, because crFore
        // is the key that indicates when the cached realization is valid.
        // If crFore is -1 when the logical brush is being realized, we
        // just go realize the brush; if it's not -1, we check the cache ID
        // fields to see if we can use the cached fields.
        // InterlockedExchange() is used below to set crFore to make sure
        // the cache ID fields are set before crFore

            if (bType == CR_ENGINE_REALIZATION)
            {
                pbrush->SetEngineRealization();
            }
            else
            {
                pbrush->SetDriverRealization();
            }
            pbrush->crBack(pebo->crCurrentBack());
            pbrush->ulPalTime(pebo->ulDCPalTime());
            pbrush->ulSurfTime(pebo->ulSurfPalTime());
            pbrush->ulRealization((ULONG_PTR)prbrush);
            pbrush->hdevRealization(pebo->psoTarg()->hdev());
            pbrush->crPalColor(pebo->crDCPalColor());

        // This must be set last, because once it's set, other selections of
        // this logical brush will attempt to use the cached brush. The use of
        // InterlockedExchange in this method enforces this

            pbrush->crForeLocked(pebo->crCurrentText());

        // The realization is now cached in the logical brush

        }
    }
}

/******************************Public*Routine******************************\
* BRUSHOBJ_pvGetRbrush
*
* Returns a pointer to the driver's realization of the brush.
*
* History:
*  31-Oct-1993 -by- Michael Abrash
* Rewrote to cache the first realization in the logical brush.
*
*  8-Sep-1992 -by- Paul Butzi
* Rewrote it.
*
*  Wed 05-Jun-1991 -by- Patrick Haluptzok [patrickh]
* major revision
*
*  25-Apr-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

PVOID
BRUSHOBJ_pvGetRbrush(
    BRUSHOBJ *pbo
    )
{
    EBRUSHOBJ *pebo = (EBRUSHOBJ *) pbo;

    ASSERTGDI(pbo->iSolidColor == 0xFFFFFFFF, "ERROR GDI iSolidColor");

    //
    // Check if the brush has already been realized.
    //

    if (pebo->pvRbrush != NULL)
    {
        return(pebo->pvRbrush);
    }

    //
    // Get this thing realized.
    //

    PDEVOBJ pdo(pebo->psoTarg()->hdev());

    if (!bGetRealizedBrush(pebo->pbrush(), pebo, PPFNDRV(pdo, RealizeBrush)))
    {
        if (pebo->pvRbrush != NULL)
        {
            VFREEMEM(DBRUSHSTART(pebo->pvRbrush));  // free the DBRUSH
            pebo->pvRbrush = NULL; // mark that there's no realization
        }

        return(NULL);
    }

    //
    // Try to cache the realization in the logical brush
    //

    vTryToCacheRealization(pebo,
                           (PDBRUSH) DBRUSHSTART(pebo->pvRbrush),
                           pebo->pbrush(),
                           CR_DRIVER_REALIZATION);

    return pebo->pvRbrush;
}

//
// User mode printer driver support
//

PVOID
BRUSHOBJ_pvGetRbrushUMPD(
    BRUSHOBJ *pbo
    )

{
    EBRUSHOBJ *pebo = (EBRUSHOBJ *) pbo;

    if (pbo->iSolidColor != 0xFFFFFFFF)
    {
        RIP("BRUSHOBJ_pvGetRbrush called for solid brush\n");
        return NULL;
    }

    //
    // Check if the brush has already been realized
    //

    if (pebo->pvRbrush != NULL)
        return pebo->pvRbrush;

    //
    // Realize the brush
    //

    PDEVOBJ pdo(pebo->psoTarg()->hdev());

    if (!bGetRealizedBrush(pebo->pbrush(), pebo, PPFNDRV(pdo, RealizeBrush)))
    {
        if (pebo->pvRbrush != NULL)
        {
            EngFreeUserMem(DBRUSHSTART(pebo->pvRbrush));
            pebo->pvRbrush = NULL;
        }

        return NULL;
    }

#if defined(_WIN64)
    //
    // if we are doing WOW64 printing, skip the caching.
    //

    PW32THREAD pThread = W32GetCurrentThread();
    
    if (pThread->pClientID == NULL)
#endif
    {
        // Try to cache the realization in the logical brush
    
        vTryToCacheRealization(pebo, (PDBRUSH)DBRUSHSTART(pebo->pvRbrush),
                pebo->pbrush(), CR_DRIVER_REALIZATION);
    }

    return pebo->pvRbrush;
}


/******************************Public*Routine******************************\
* BRUSHOBJ_ulGetBrushColor
*
* Returns the RGB color for a solid brush.
*
*  Oct-18-1995 -by- Lingyun Wang
* Wrote it.
\**************************************************************************/
ULONG
BRUSHOBJ_ulGetBrushColor(
    BRUSHOBJ *pbo
    )
{
    EBRUSHOBJ *pebo = (EBRUSHOBJ *) pbo;

    if (pebo->bIsSolid())
    {
        if(pebo->flColorType & BR_ORIGCOLOR)
        {
            pebo->flColorType &= ~BR_ORIGCOLOR;
            return ((ULONG)(pebo->crOrignal()));
        }
        else
        {
            return ((ULONG)(pebo->crRealized()));
        }
    }
    else
    {
        return (ULONG)(-1);
    }
}

/******************************Public*Routine******************************\
* BRUSHOBJ_hGetColorTransform
*
* Retuens the color transform for a brush.
*
*  Feb-14-1997 -by- Hideyuki Nagase
* Wrote it.
***************************************************************************/

HANDLE
BRUSHOBJ_hGetColorTransform(
    BRUSHOBJ *pbo
    )
{
    ICMAPI(("BRUSHOBJ_hGetColorTransform()\n"));

    if (pbo == NULL)
    {
        WARNING("BRUSHOBJ_hGetColorTransform() BRUSHOBJ is NULL\n");
        return(NULL);
    }

    EBRUSHOBJ *pebo = (EBRUSHOBJ *) pbo;

    //
    // if ICM is not enabled for this. Or if ICM is done by host,
    // Color transform handle is for host ICM it is no meanings
    // for device driver. then just return NULL.
    //
    if (pebo->bIsDeviceICM())
    {
        if (pebo->hcmXform())
        {
            COLORTRANSFORMOBJ CXFormObj(pebo->hcmXform());

            if (CXFormObj.bValid())
            {
                return(CXFormObj.hGetDeviceColorTransform());
            }

            ICMMSG(("BRUSHOBJ_hGetColorTransform() COLORTRANSFORMOBJ is invalid\n"));
        }
        else
        {
            ICMMSG(("BRUSHOBJ_hGetColorTransform() Ident. color transform\n"));
        }
    }
    else
    {
        ICMMSG(("BRUSHOBJ_hGetColorTransform() ICM on device is not enabled\n"));
    }

    return(NULL);
}

/******************************Public*Routine******************************\
* pvGetEngRbrush
*
* Returns:  A pointer to the engines's realization of a logical brush.
*
* Only the engine calls this, it is not exported.
*
* History:
*  31-Oct-1993 -by- Michael Abrash
* Rewrote to cache the first realization in the logical brush.
*
*  8-Sep-1992 -by- Paul Butzi
* Rewrote it.
*
*  Wed 05-Jun-1991 -by- Patrick Haluptzok [patrickh]
* major revision
*
*  25-Apr-1991 -by- Patrick Haluptzok patrickh
* Wrote it - First pass.
\**************************************************************************/

PVOID
pvGetEngRbrush(
    BRUSHOBJ *pbo
    )
{
    EBRUSHOBJ *pebo = (EBRUSHOBJ *) pbo;

    ASSERTGDI(pbo->iSolidColor == 0xFFFFFFFF, "ERROR GDI iSolidColor");

// Check if the brush has already been realized.

    if (pebo->pengbrush() != (PVOID) NULL)
    {
        return pebo->pengbrush();
    }

// Get this thing realized.

    PDEVOBJ pdo(pebo->psoTarg()->hdev());

    if (!bGetRealizedBrush(pebo->pbrush(), pebo, EngRealizeBrush))
    {
        if (pebo->pengbrush() != NULL)
        {
            VFREEMEM(pebo->pengbrush());  // free the DBRUSH
            pebo->pengbrush(NULL);  // mark that there's no realization
        }

        return(NULL);
    }

// Try to cache the realization in the logical brush

    vTryToCacheRealization(pebo, pebo->pengbrush(), pebo->pbrush(),
            CR_ENGINE_REALIZATION);

    return(pebo->pengbrush());
}


/******************************Public*Routine******************************\
* bGetRealizedBrush
*
* Returns: Pointer to a Realized brush.
*
* NOTE: The surface in pebo->psoTarg() is the surface of the original
*       destination of the drawing call.  If a display driver was called,
*       but it punts by calling back to the engine with an engine-managed
*       bitmap it created, psoTarg() will still point to the original
*       display surface, not the DIB surface.  The surface will have the
*       same hdev, iFormat, etc., but this means that the iType will be
*       wrong, so don't reference it!  (EngRealizeBrush actually accounts
*       for this little lie.)
*
* History:
*  14-Jul-1992 -by-  Eric Kutter [erick]
*   added exception handling, changed from VOID to BOOL
*
*  Mon 07-Oct-1991 -by- Patrick Haluptzok [patrickh]
* add support for DIB_PAL_COLORS flag.
*
*  04-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
bGetRealizedBrush(
    BRUSH *pbrush,
    EBRUSHOBJ *pebo,
    PFN_DrvRealizeBrush pfnDrv
    )
{
    ASSERTGDI(pebo->iSolidColor == 0xFFFFFFFF, "ERROR GDI iSolidColor");
    ASSERTGDI(pfnDrv != (PFN_DrvRealizeBrush) 0, "ERROR pfnDrv");

    //
    // quick out if it is a NULL brush
    //

    if (pbrush->ulStyle() == HS_NULL)
    {
        WARNING1("You are doing output calls with a NULL brush\n");
        return(FALSE);
    }

    //
    // Dispatch off to driver to get brush realized.
    //

    ULONG       ulStyle = pbrush->ulStyle();
    SURFOBJ    *psoPattern;
    SURFOBJ    *psoMask = NULL;
    XEPALOBJ    palSrc;
    XEPALOBJ    palDest;
    SURFREF     SurfBmoPattern;
    EXLATEOBJ   exlo;
    XLATE      *pxlo = NULL;
    SURFMEM     SurfDimo;

    //
    // We default to this.
    //

    PDEVOBJ po(pebo->psoTarg()->hdev());
    ASSERTGDI(po.bValid(), "ERROR BRUSHOBJ_ 5");

    //
    // We need to hold the Devlock to protect against dynamic mode changes
    // while we muck around in the driver.  If we're being call by the
    // driver, we're guaranteed to already be holding it, so we only have
    // to do this if we're being called by GDI's Eng functions.
    //

    DEVLOCKOBJ dlo;
    if (pfnDrv == EngRealizeBrush)
    {
        dlo.vLock(po);
    }
    else
    {
        dlo.vInit();
    }

    if (pbrush->ulStyle() < HS_DDI_MAX)
    {
        //
        // For hatch brushes, the pattern is also the mask
        //

        SurfBmoPattern.vAltLock((HSURF)po.hbmPattern(pbrush->ulStyle()));
        psoMask = SurfBmoPattern.pSurfobj();

        if (exlo.pCreateXlateObject(2))
        {
            ULONG ulValue1, ulValue2;

            if (pebo->bIsCMYKColor())
            {
                //
                // We are in CMYK color context, we just set CMYK color
                //
                ulValue1 = pebo->crCurrentBack();
                ulValue2 = pebo->crRealized();

                exlo.pxlo()->vSetIndex(0, ulValue1);
                exlo.pxlo()->vSetIndex(1, ulValue2);

                pxlo = exlo.pxlo();
                pxlo->vCheckForICM(pebo->hcmXform(),pebo->lIcmMode());
                pxlo->ppalSrc = ppalMono;
                pxlo->ppalDst = pebo->palSurf().ppalGet();
                pxlo->ppalDstDC = pebo->palDC().ppalGet();
            }
            else
            {
                ulValue1 = ulGetNearestIndexFromColorref(
                                    pebo->palSurf(),
                                    pebo->palDC(),
                                    pebo->crCurrentBack()
                                    );

                ulValue2 = ulGetNearestIndexFromColorref(
                                    pebo->palSurf(),
                                    pebo->palDC(),
                                    pebo->crRealized()
                                    );

                //
                // Windows compability issue:
                // force to draw on the background
                //
                // We force the forground to be mapped
                // to an index opposite to the background
                //

                if ((pebo->psoTarg()->iFormat() == BMF_1BPP) &&
                    (pebo->palSurf().bIsIndexed()) &&
                    (pebo->crCurrentBack() !=  pebo->crRealized()) &&
                    (ulValue1 == ulValue2))
                {
                     ulValue2 = 1-ulValue1;
                }

                exlo.pxlo()->vSetIndex(0, ulValue1);
                exlo.pxlo()->vSetIndex(1, ulValue2);

                pxlo = exlo.pxlo();
                pxlo->vCheckForICM(pebo->hcmXform(),pebo->lIcmMode());
                pxlo->vCheckForTrivial();
                pxlo->ppalSrc = ppalMono;
                pxlo->ppalDst = pebo->palSurf().ppalGet();
                pxlo->ppalDstDC = pebo->palDC().ppalGet();
            }
            pxlo->iForeDst = ulValue1;
            pxlo->iBackDst = ulValue2;
            pxlo->flPrivate |= XLATE_FROM_MONO;
        }
        else
        {
            WARNING("ERROR failed to create hatch xlate\n");
            return(FALSE);
        }
    }
    else if (pbrush->ulStyle() < HS_NULL)
    {
        //
        // For solid brushes.
        //

        ASSERTGDI(pbrush->flAttrs() & BR_IS_SOLID, "ERROR non-solid brush");
        ASSERTGDI((pbrush->flAttrs() & BR_DITHER_OK) ||
                  (po.bCapsForceDither()),
                  "ERROR BRUSHOBJ_ 1");

        //
        // We will not dither CMYK color brush. Driver should not call BRUSHOBJ_pvGetRbrush 
        // with CMYK solid color brush.
        //

        if (pebo->bIsCMYKColor())
        {
            WARNING("ERROR bGetRealizedBrush() Can't dither CMYK color brush\n");
            return (FALSE);
        }

        //
        // This means they want us to dither the color and nothing
        // in their palette is close enough that we can't just use
        // a solid color.
        //

        if (pebo->crRealized() & 0x01000000)
        {
            pebo->crRealized(rgbFromColorref(pebo->palSurf(),
                                             pebo->palDC(),
                                             pebo->crRealized()));
        }

        //
        // Use the nifty DitherOnRealize option, if the driver supports it and
        // we're not realizing the brush on behalf of the engine simulations
        // (since the engine will be drawing, it will need its own realization,
        // not the driver's):
        //

        if ((po.flGraphicsCaps() & GCAPS_DITHERONREALIZE) &&
            (pfnDrv != EngRealizeBrush))
        {
            if ((*pfnDrv) (pebo,
                           pebo->psoTarg()->pSurfobj(),
                           (SURFOBJ *) NULL,
                           (SURFOBJ *) NULL,
                           NULL,
                           pebo->crRealized() | RB_DITHERCOLOR))
            {
                return(TRUE);
            }
        }

        DEVBITMAPINFO dbmi;

        if (pebo->psoTarg()->iFormat() == BMF_1BPP)
        {
            dbmi.iFormat = BMF_1BPP;
        }
        else
        {
            dbmi.iFormat = po.iDitherFormat();
        }

        dbmi.cxBitmap = po.cxDither();
        dbmi.cyBitmap = po.cyDither();
        dbmi.hpal = 0;
        dbmi.fl = BMF_TOPDOWN;

        if (!SurfDimo.bCreateDIB(&dbmi, NULL))
        {
            WARNING("Failed memory alloc in dither brush\n");
            return(FALSE);
        }

        ULONG iRes;
        ULONG iDitherMode = ((pebo->psoTarg()->iFormat() == BMF_1BPP) ? DM_MONOCHROME: DM_DEFAULT);

        if (PPFNVALID(po, DitherColor))
        {
            iRes = (*PPFNDRV(po, DitherColor)) (
                   po.bUMPD() ? (DHPDEV)po.ppdev : po.dhpdev(),
                   iDitherMode,
                   pebo->crRealized(),
                   (PULONG) SurfDimo.ps->pvBits());
        }
        else
        {
            iRes = EngDitherColor(po.hdev(),
                                  iDitherMode,
                                  pebo->crRealized(),
                                  (PULONG) SurfDimo.ps->pvBits());
        }

        switch (iRes)
        {
        case DCR_DRIVER:
            pxlo = &xloIdent;
            break;

        case DCR_HALFTONE:
        {
            if ((po.pDevHTInfo() == NULL) && !po.bEnableHalftone(NULL))
                return(FALSE);

            DEVICEHALFTONEINFO *pDevHTInfo = (DEVICEHALFTONEINFO *)po.pDevHTInfo();

            COLORTRIAD ColorTriad;
            CHBINFO    CHBInfo;
            COLORREF   cr = pebo->crRealized();

            ColorTriad.Type              = COLOR_TYPE_RGB;
            ColorTriad.BytesPerPrimary   = sizeof(BYTE);
            ColorTriad.BytesPerEntry     = sizeof(DWORD);
            ColorTriad.PrimaryOrder      = PRIMARY_ORDER_RGB;
            ColorTriad.PrimaryValueMax   = 255;
            ColorTriad.ColorTableEntries = 1;
            ColorTriad.pColorTable       = (LPVOID)&cr;

            CHBInfo.Flags = (BYTE)((po.GdiInfo()->flHTFlags & HT_FLAG_OUTPUT_CMY) ?
                                                        0 : CHBF_USE_ADDITIVE_PRIMS);

        // Control ICM bits for halftoning

            if ((pebo->bIsAppsICM()) ||
                (!pebo->bDeviceCalibrate() && (pebo->bIsHostICM() || pebo->bIsDeviceICM())))
            {
                ICMDUMP(("bGetRealizedBrush(): ICM with Halftone (Dynamic Bit On)\n"));

                // Some kind of ICM (ICM on Application, Graphics Engine or Device)
                // is enabled, so tell halftoning code to disable thier color adjustment.

                CHBInfo.Flags |= CHBF_ICM_ON;
            }
            else
            {
                ICMDUMP(("bGetRealizedBrush(): ICM with Halftone (Dynamic Bit Off)\n"));
            }

            if ((pDevHTInfo->cxPattern != dbmi.cxBitmap) ||
                (pDevHTInfo->cyPattern != dbmi.cyBitmap))
            {
                SurfDimo.ps->bDeleteSurface();
                dbmi.cxBitmap = pDevHTInfo->cxPattern;
                dbmi.cyBitmap = pDevHTInfo->cyPattern;

                if (!SurfDimo.bCreateDIB(&dbmi, NULL))
                {
                    WARNING("Failed memory alloc in dither brush1\n");
                    return(FALSE);
                }
            }

            switch(po.GdiInfo()->ulHTOutputFormat)
            {
            case HT_FORMAT_1BPP:
                CHBInfo.DestSurfaceFormat = (BYTE)BMF_1BPP;
                break;
            case HT_FORMAT_4BPP:
                CHBInfo.DestSurfaceFormat = (BYTE)BMF_4BPP;
                break;
            case HT_FORMAT_4BPP_IRGB:
                CHBInfo.DestSurfaceFormat = (BYTE)BMF_4BPP_VGA16;
                break;
            case HT_FORMAT_8BPP:
                CHBInfo.DestSurfaceFormat = (BYTE)BMF_8BPP_VGA256;
                break;
            case HT_FORMAT_16BPP:
                //
                // Need to switch between BMF_16BPP_555 and BMF_16BPP_565
                //
                CHBInfo.DestSurfaceFormat = (BYTE)BMF_16BPP_555;
                break;
            case HT_FORMAT_32BPP:
                CHBInfo.DestSurfaceFormat = (BYTE)BMF_32BPP;
                break;
            default:
                WARNING("Halftone format not supported\n");
                return(FALSE);
            }

            CHBInfo.DestScanLineAlignBytes = BMF_ALIGN_DWORD;
            CHBInfo.DestPrimaryOrder       = (BYTE)po.GdiInfo()->ulPrimaryOrder;

        // Brushes, unlike scanned in images, have linear RGB gamma.
        // Use a gamma value of 1 can produce lighter, closer to wfw halftone
        // images for solid brushes.  This is to fix powerpnt shaded background
        // printing.  Other apps that print black text on dark background will
        // benefit from this fix as well.

            COLORADJUSTMENT ca = *pebo->pColorAdjustment();
            ca.caRedGamma = 10000;
            ca.caGreenGamma = 10000;
            ca.caBlueGamma = 10000;

            if (HT_CreateHalftoneBrush(
                              pDevHTInfo,
                              (PHTCOLORADJUSTMENT)&ca,
                              &ColorTriad,
                              CHBInfo,
                              (PULONG)SurfDimo.ps->pvBits()) > 0)
            {
            // Set up the translate object.

                if (po.bHTPalIsDevPal())
                {
                    pxlo = &xloIdent;
                }
                else
                {
                    EPALOBJ palHT((HPALETTE)pDevHTInfo->DeviceOwnData);

                    palDest.ppalSet(pebo->psoTarg()->ppal());

                    if (!exlo.bInitXlateObj(
                                    pebo->hcmXform(),
                                    pebo->lIcmMode(),
                                    palHT, palDest,
                                    pebo->palDC(),
                                    pebo->palDC(),
                                    pebo->crCurrentText(),
                                    pebo->crCurrentBack(),
                                    0x00FFFFFF
                                    ))
                    {
                        WARNING("Failed to create an xlate bGetRealizedBrush DIB_PAL_COLORS\n");
                        return(FALSE);
                    }

                    pxlo = exlo.pxlo();
                }
                break;
            }
        } // case DCR_HALFTONE

        default:
            WARNING("DrvDitherColor returned invalid value or failed\n");
            return(FALSE);
        } // switch (iRes)
    }
    else // if (pbrush->ulStyle() >= HS_NULL)
    {
        BOOL bIcmBrush = FALSE;

        //
        // For bitmap/pattern brushes.
        //

        HSURF hDIB = (HSURF)pbrush->hbmPattern();

        ASSERTGDI(pbrush->ulStyle() <= HS_PATMSK, "ERROR ulStyle is bad");

    // ICM is enabled ? and the Brush is DIB ? For Device Depend Bitmap, we will
    // not enable ICM. Only for DIB.

        if (pebo->bIsHostICM())
        {
            if (pebo->hcmXform() != NULL)
            {
                if (pbrush->flAttrs() & BR_IS_DIB)
                {
                // if ICM is enabled, the BRUSHOBJ should have color transform.

                    if (pbrush->iUsage() == DIB_RGB_COLORS)
                    {
                        ICMMSG(("bGetRealizedBrush: TRY Find ICM DIB\n"));

                    // Find color translated brush DIB.

                        HSURF hIcmDIB = (HSURF)(pbrush->hFindIcmDIB(pebo->hcmXform()));

                        if (hIcmDIB == NULL)
                        {
                        // Somehow, we could not find DIB, just use orginal.

                            WARNING1("bGetRealizedBrush(): hFindIcmDIB() returns NULL\n");
                        }
                        else
                        {
                        // Replace DIB handle with ICM-ed DIB.

                            hDIB      = hIcmDIB;
                            bIcmBrush = TRUE;
                        }
                    }
                    else
                    {
                    // if DIB is other than DIB_RGB_COLORS, ICM DIB will not be used.

                        ICMMSG(("bGetRealizedBrush(): Brush color is not DIB_RGB_COLORS\n"));
                    }
                }
                else if (pbrush->flAttrs() & BR_IS_MONOCHROME)
                {
                    ICMMSG(("bGetRealizedBrush(): Brush color is BR_IS_MONOCHROME\n"));

                    bIcmBrush = TRUE;
                }
            }
            else
            {
            // ICM is enabled, but no color transform, it means identical color transform
            // so, there is no ICM-ed DIB.

                ICMMSG(("bGetRealizedBrush(): Color transform is identical\n"));
          
            // If we are in CMYK mode, we must have color transform.

                if (!pebo->bIsCMYKColor())
                {
                    bIcmBrush = TRUE;
                }
            }
        }
        else if (pebo->bIsAppsICM() || pebo->bIsDeviceICM())
        {
            bIcmBrush = TRUE;
        }

        SurfBmoPattern.vAltLock(hDIB);

        if(!SurfBmoPattern.bValid())
        {
            WARNING("WARNING:bGetRealizedBrush(): Invalid SurfBmopattern\n");
            return(FALSE);
        }           

        palSrc.ppalSet(SurfBmoPattern.ps->ppal());
        palDest.ppalSet(pebo->psoTarg()->ppal());

        if (pbrush->bPalColors())
        {
            ASSERTGDI(palSrc.bValid(), "ERROR3invalid hpal pvGetEngRbrush\n");

            if (!exlo.bMakeXlate((PUSHORT) palSrc.apalColorGet(),
                                 pebo->palDC(),
                                 pebo->psoTarg(),
                                 palSrc.cColorTableLength(),
                                 palSrc.cEntries()))
            {
                WARNING("Failed to create an xlate bGetRealizedBrush DIB_PAL_COLORS\n");
                return(FALSE);
            }

            pxlo = exlo.pxlo();
        }
        else if (pbrush->bPalIndices())
        {
            if (SurfBmoPattern.ps->iFormat() != pebo->psoTarg()->iFormat())
            {
                WARNING("Output failed: DIB_PAL_INDICES brush not compatible with dest surface\n");
                return(FALSE);
            }

            pxlo = &xloIdent;
        }
        else
        {
        // With our wonderful API we can't fail a brush selection like Windows would.
        // Instead we let the app think he selected the bitmap brush in and then at
        // realize time if that wasn't a valid selection we fail the realize.  Good
        // luck writing new apps.

            PPALETTE ppalSrcTmp;

        // We need to make sure this could be selected into this DC.  If it is a device
        // managed bitmap, it must be the same device.

            if ((
                 (SurfBmoPattern.ps->iType() != STYPE_BITMAP) ||
                 (SurfBmoPattern.ps->dhsurf() != 0)
                )
                 &&
                (SurfBmoPattern.ps->hdev() != po.hdev()))
            {
                WARNING1("bGetRealizedBrush failed Device surface for another PDEV\n");
                return (FALSE);
            }
            else if (SurfBmoPattern.ps->ppal() != NULL)
            {
            // No problem, we already have color information.

                ppalSrcTmp = SurfBmoPattern.ps->ppal();
            }
            else
            {
                if (SurfBmoPattern.ps->iFormat() == po.iDitherFormat())
                {
                    if (po.bIsPalManaged())
                    {
                        ppalSrcTmp = (PPALETTE) NULL;
                    }
                    else
                    {
                        ppalSrcTmp = po.ppalSurf();
                    }
                }
                else if (SurfBmoPattern.ps->iFormat() == pebo->iMetaFormat())
                {
                // We can try to use palette from meta.

                    ppalSrcTmp = pebo->palMeta().ppalGet();
                }
                else if (SurfBmoPattern.ps->iFormat() == BMF_8BPP)
                {
                    if (po.bIsPalManaged())
                    {
                        ppalSrcTmp = (PPALETTE) NULL;
                    }
                    else
                    {
                        ppalSrcTmp = ppalDefaultSurface8bpp;
                    }
                }
                else 
                {
                    if (po.bMetaDriver())
                        ppalSrcTmp = (PPALETTE) NULL;
                    else
                    {
                        WARNING("bGetRealizedBrush failed - bitmap not compatible with surface\n");
                        return FALSE;
                    }
                }
            }

            // Replace source palette with proper one which decided in above.

            palSrc.ppalSet(ppalSrcTmp);

            if (!exlo.bInitXlateObj(
                            (bIcmBrush ? pebo->hcmXform() : NULL),
                            (bIcmBrush ? pebo->lIcmMode() : DC_ICM_OFF),
                            palSrc,
                            palDest,
                            pebo->palDC(),
                            pebo->palDC(),
                            pebo->crCurrentText(),
                            pebo->crCurrentBack(),
                            0x00FFFFFF
                            ))
            {
                WARNING("Failed to create an xlate pvGetRbrush\n");
                return (FALSE);
            }

            pxlo = exlo.pxlo();
        }
    }

// Do the right thing if a pattern is provided

    if (SurfBmoPattern.bValid())
    {
        psoPattern = SurfBmoPattern.pSurfobj();
    }
    else
    {
    // Check for dithering

        if (SurfDimo.bValid())
        {
            psoPattern = SurfDimo.pSurfobj();
        }
        else
            psoPattern = (SURFOBJ *) NULL;
    }

// Call off to driver to the RealizeBrush

    return((*pfnDrv) (pebo, pebo->psoTarg()->pSurfobj(),
                    psoPattern, psoMask,
                    pxlo,
                    ulStyle));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\brushobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: brushobj.cxx
*
* Support for brmemobj.hxx and brushobj.hxx.
*
* Created: 06-Dec-1990 12:02:24
* Author: Walt Moore [waltm]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern "C" BOOL bInitBRUSHOBJ();
extern "C" BOOL bInitBrush(int iBrush, COLORREF cr,
                           DWORD dwHS, PULONG_PTR pdw, BOOL bEnableDither);

#pragma alloc_text(INIT, bInitBRUSHOBJ)
#pragma alloc_text(INIT, bInitBrush)

// Global pointer to the last RBRUSH freed, if any (for one-deep caching).
PRBRUSH gpCachedDbrush = NULL;
PRBRUSH gpCachedEngbrush = NULL;

#define MAX_STOCKBRUSHES 4*1024 
LONG gStockBrushFree = MAX_STOCKBRUSHES;

//#define DBG_STOCKBRUSHES 1

#if DBG_STOCKBRUSHES
#define STOCKWARNING DbgPrint
#define STOCKINFO    DbgPrint
#else
#define STOCKWARNING
#define STOCKINFO
#endif

extern "C" HFASTMUTEX ghfmMemory;

#if DBG
LONG bo_inits, bo_realize, bo_notdirty, bo_cachehit;
LONG bo_missnotcached, bo_missfg, bo_missbg, bo_misspaltime, bo_misssurftime;
#endif

/****************************Global*Public*Data******************************\
*
* These are the 5 global brushes and 3 global pens maintained by GDI.
* These are retrieved through GetStockObject.
*
* History:
*  20-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HBRUSH ghbrText;
HBRUSH ghbrBackground;
HBRUSH ghbrGrayPattern;
PBRUSH gpbrText;
PBRUSH gpbrNull;
PBRUSH gpbrBackground;
PPEN   gpPenNull;

HBRUSH ghbrDCBrush;
PBRUSH gpbrDCBrush;

HBRUSH ghbrDCPen;
PBRUSH gpbrDCPen;


// Uniqueness so a logical handle can be reused without having it look like
// the same brush as before. We don't really care where this starts.

ULONG BRUSH::_ulGlobalBrushUnique = 0;

ULONG gCacheHandleEntries[GDI_CACHED_HADNLE_TYPES] = {
                                CACHE_BRUSH_ENTRIES ,
                                CACHE_PEN_ENTRIES   ,
                                CACHE_REGION_ENTRIES,
                                CACHE_LFONT_ENTRIES
                               };

ULONG gCacheHandleOffsets[GDI_CACHED_HADNLE_TYPES] = {
                                                        0,
                                                        CACHE_BRUSH_ENTRIES,
                                                        (
                                                            CACHE_BRUSH_ENTRIES +
                                                            CACHE_PEN_ENTRIES
                                                        ),
                                                        (
                                                            CACHE_BRUSH_ENTRIES +
                                                            CACHE_PEN_ENTRIES   +
                                                            CACHE_PEN_ENTRIES
                                                        )
                                                      };

/******************************Public*Routine******************************\
* bPEBCacheHandle
*
*   Try to place the object(handle) in a free list on the PEB. The objects
*   are removed from this list in user mode.
*
* Arguments:
*
*   Handle     - handle to cache
*   HandleType - type of handle to attempt cache
*   pBrushattr - pointer to user-mode object
*
* Return Value:
*
*   TRUE if handle is cached, FALSE otherwise
*
* History:
*
*    30-Jan-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bPEBCacheHandle(
    HANDLE          Handle,
    HANDLECACHETYPE HandleType,
    POBJECTATTR     pObjectattr,
    PENTRY          pentry
    )
{
    BOOL bRet = FALSE;
    PBRUSHATTR pBrushattr = (PBRUSHATTR)pObjectattr;
    PW32PROCESS pw32Process = W32GetCurrentProcess();
    PPEB Peb;

#if !defined(_GDIPLUS_)

    ASSERTGDI(((HandleType == BrushHandle)  || (HandleType == PenHandle)    ||
               (HandleType == RegionHandle) ||(HandleType == LFontHandle)
              ),"hGetPEBHandle: illegal handle type");

    Peb = PsGetProcessPeb(pw32Process->Process);
    if (Peb != NULL)
    {
        PGDIHANDLECACHE pCache = (PGDIHANDLECACHE)(&Peb->GdiHandleBuffer[0]);
        BOOL bStatus;

        //
        // Lock Handle cache on PEB
        //

        LOCK_HANDLE_CACHE(pCache,PsGetCurrentThread(),bStatus);

        if (bStatus)
        {
            //
            // are any free slots still availablle
            //

            if (pCache->ulNumHandles[HandleType] < gCacheHandleEntries[HandleType])
            {
                ULONG Index = gCacheHandleOffsets[HandleType];
                PHANDLE pHandle,pMaxHandle;

                //
                // calculate handle offset in PEB array
                //

                pHandle    = &(pCache->Handle[Index]);
                pMaxHandle = pHandle + gCacheHandleEntries[HandleType];

                //
                // search array for a free entry
                //

                while (pHandle != pMaxHandle)
                {
                    if (*pHandle == NULL)
                    {
                        //
                        // for increased robust behavior, increment handle unique
                        //

                        pentry->FullUnique += UNIQUE_INCREMENT;
                        Handle = (HOBJ)MAKE_HMGR_HANDLE((ULONG)(ULONG_PTR)Handle & INDEX_MASK, pentry->FullUnique);
                        pentry->einfo.pobj->hHmgr = Handle;

                        //
                        // store handle in cache and inc stored count
                        //

                        *pHandle = Handle;
                        pCache->ulNumHandles[HandleType]++;
                        bRet = TRUE;

                        //
                        // clear to be deleted and select flags,
                        // set cached flag
                        //

                        pBrushattr->AttrFlags &= ~(ATTR_TO_BE_DELETED | ATTR_CANT_SELECT);
                        pBrushattr->AttrFlags |= ATTR_CACHED;

                        break;
                    }
                    pHandle++;
                }

                ASSERTGDI(bRet,"bPEBCacheHandle: count indicates free handle, but none free\n");
            }
            UNLOCK_HANDLE_CACHE(pCache);
        }
    }

#endif

    return(bRet);
}

/******************************Public*Routine******************************\
* BRUSHMEMOBJ::pbrAllocBrush(bPen)
*
* Base constructor for brush memory object.  This constructor is to be
* called by the various public brush constructors only.
*
* History:
*  29-Oct-1992 -by- Michael Abrash [mikeab]
* changed to allocate but not get a handle or lock (so the brush can be fully
* set up before the handle exists, exposing the data to the outside world).
*
*  Wed 19-Jun-1991 -by- Patrick Haluptzok [patrickh]
* 0 out the brush.
*
*  Thu 06-Dec-1990 12:02:41 -by- Walt Moore [waltm]
* Wrote it.
\**************************************************************************/

PBRUSH BRUSHMEMOBJ::pbrAllocBrush(BOOL bPen)
{
    PBRUSH pbrush;

    bKeep = FALSE;

    // Allocate a new brush or pen
    //
    // Note: if anyone decides to try turning off zeroinit for performance,
    // make sure to initialize the pen's psytle and cstyle to zero.  Of
    // course, other dependencies may creep in, so do this very very very
    // carefully (if you even dare!).

    if ((pbrush = (PBRUSH)ALLOCOBJ(bPen ? sizeof(PEN) : sizeof(BRUSH),
            BRUSH_TYPE, TRUE)) != NULL)
    {
        pbrush->pBrushattr(&pbrush->_Brushattr);

        pbrush->pIcmDIBList(NULL);  // no ICM translated DIBs

        pbrush->iUsage(0);

        // Set up as initially not caching any realization

        pbrush->vSetNotCached();    // no one's trying to cache a realization
                                    // in this logical brush yet
        pbrush->crFore((COLORREF)BO_NOTCACHED);
                                    // no cached realization yet (no need to
                                    // worry about crFore not being set when
                                    // someone tries to check for caching,
                                    // because we don't have a handle yet, and
                                    // we'll lock when we do get the handle,
                                    // forcing writes to flush)
        pbrush->ulBrushUnique(pbrush->ulGlobalBrushUnique());
                                    // set the uniqueness so the are-you-
                                    // really-dirty check in vInitBrush will
                                    // know this is not the brush in the DC

    }

    return(pbrush);
}


/******************************Public*Routine******************************\
* BRUSHMEMOBJ::BRUSHMEMOBJ
*
* Create a pattern brush or a DIB brush.
*
* History:
*  29-Oct-1992 -by- Michael Abrash [mikeab]
* changed to get handle only after fully initialized
*
*  14-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BRUSHMEMOBJ::BRUSHMEMOBJ(HBITMAP hbmClone, HBITMAP hbmClient,BOOL bMono,
                            FLONG flDIB, FLONG flType, BOOL bPen)
{
    if (flDIB == DIB_PAL_COLORS)
    {
        flType |= BR_IS_DIBPALCOLORS;
    }
    else if (flDIB == DIB_PAL_INDICES)
    {
        flType |= BR_IS_DIBPALINDICES;
    }

    PBRUSH pbrush;

    if ((pbp.pbr = pbrush = pbrAllocBrush(bPen)) != NULL)
    {
        pbrush->crColor(0);
        pbrush->ulStyle(HS_PAT);
        pbrush->hbmPattern(hbmClone);
        pbrush->hbmClient(hbmClient);

        pbrush->AttrFlags(0);

        pbrush->flAttrs(flType);

        if (bMono)
        {
            pbrush->flAttrs(pbrush->flAttrs() |
                            (BR_NEED_BK_CLR | BR_NEED_FG_CLR | BR_IS_MONOCHROME));
        }

    // Now that everything is set up, create the handle and expose this logical
    // brush

        if (HmgInsertObject(pbrush, HMGR_ALLOC_ALT_LOCK, BRUSH_TYPE) == 0)
        {
            FREEOBJ(pbrush, BRUSH_TYPE);
            pbp.pbr = NULL;
        }
    }
    else
    {
        WARNING1("Brush allocation failed\n");
    }
}

/******************************Public*Routine******************************\
* GreSetSolidBrush
*
* Chicago API to change the color of a solid color brush.
*
* History:
*  19-Apr-1994 -by- Patrick Haluptzok patrickh
* Made it a function that User can call too.
*
*  03-Dec-1993 -by-  Eric Kutter [erick]
* Wrote it - bReset.
\**************************************************************************/

BOOL GreSetSolidBrush(HBRUSH hbr, COLORREF clr)
{
    return(GreSetSolidBrushInternal(hbr, clr, FALSE, TRUE));
}

BOOL GreSetSolidBrushInternal(
    HBRUSH hbr,
    COLORREF clr,
    BOOL bPen,
    BOOL bUserCalled
    )
{
    BOOL bReturn = FALSE;

    BRUSHSELOBJ ebo(hbr);

    PBRUSH pbrush = ebo.pbrush();

    if (pbrush != NULL)
    {
        if ((pbrush->flAttrs() & BR_IS_SOLID) &&
            ((!pbrush->bIsGlobal()) || bUserCalled) &&
            ((!!pbrush->bIsPen()) == bPen))
        {

        #if DBG
            if (bPen)
            {
                ASSERTGDI(((PPEN) pbrush)->pstyle() == NULL ||
                        (pbrush->flAttrs() & BR_IS_DEFAULTSTYLE),
                        "GreSetSolidBrush - bad attrs\n");
            }
        #endif

            ASSERTGDI(pbrush->hbmPattern() == NULL,
                      "ERROR how can solid have pat");
            PRBRUSH prbrush = (PRBRUSH) NULL;
            RBTYPE rbType;

            {
                //
                // Can't do the delete of the RBRUSH under MLOCK, takes too
                // long and it may try and grab it again.
                //

                MLOCKFAST mlo;

                //
                // User may call when the brush is selected in a DC, but
                // the client side should only ever call on a brush that's
                // not in use.
                //

                if ((pbrush->cShareLockGet() == 1) || bUserCalled)
                {
                    bReturn = TRUE;
                    pbrush->crColor(clr);

                    HANDLELOCK HandleLock(PENTRY_FROM_POBJ(pbrush), FALSE);

                    if (HandleLock.bValid())
                    {
                        if (pbrush->cShareLockGet() == 1)
                        {
                            //
                            // Nobody is using it and we have the handle lock
                            // so noone can select it in till we are done. So
                            // clean out the old realization now.
                            //

                            if ((pbrush->crFore() != BO_NOTCACHED) &&
                                !pbrush->bCachedIsSolid())
                            {
                                prbrush = (PRBRUSH) pbrush->ulRealization();
                                rbType = pbrush->bIsEngine() ? RB_ENGINE
                                                             : RB_DRIVER;
                            }

                            // Set up as initially not caching any realization

                            pbrush->vSetNotCached();
                                        // no one's trying to cache a realization
                                        // in this logical brush yet

                            pbrush->crFore((COLORREF)BO_NOTCACHED);
                                        // no cached realization yet (no need to
                                        // worry about crFore not being set when
                                        // someone tries to check for caching,
                                        // because we don't have a handle yet, and
                                        // we'll lock when we do get the handle,
                                        // forcing writes to flush)

                            if (!bUserCalled)
                            {
                                //
                                // If it's not User calling we are resetting the
                                // attributes / type.
                                //

                                pbrush->ulStyle(HS_DITHEREDCLR);
                                pbrush->flAttrs(BR_IS_SOLID | BR_DITHER_OK);
                            }
                            else
                            {
                                pbrush->vClearSolidRealization();
                            }
                        }
                        else
                        {
                            //ASSERTGDI(bUserCalled,
                            //          "Client side is hosed, shouldn't "
                            //          "call this with it still selected");
                            ASSERTGDI(pbrush->flAttrs() & BR_IS_SOLID,
                                      "ERROR not solid");
                            ASSERTGDI(pbrush->ulStyle() == HS_DITHEREDCLR,
                                      "ERROR not HS_DI");

                            //
                            // Mark this brushes realization as dirty by setting
                            // it's cache id's to invalid states.  Note that if a
                            // realization hasn't been cached yet this will cause
                            // no problem either.
                            //

                            pbrush->crBack(0xFFFFFFFF);
                            pbrush->ulPalTime(0xFFFFFFFF);
                            pbrush->ulSurfTime(0xFFFFFFFF);

                            //
                            // This brush is being used other places, check for
                            // any DC's that have this brush selected in and mark
                            // their realizations dirty.
                            //
                            // Note there is the theoretical possibility that
                            // somebody is realizing the brush while we are
                            // marking them dirty and they won't pick up the new
                            // color.  We set the color first and set the
                            // uniqueness last so that it is extremely unlikely
                            // (maybe impossible) that someone gets a realization
                            // that incorrectly thinks it has the proper
                            // realization.  This is fixable by protecting access
                            // to the realization and cache fields but we aren't
                            // going to do it for Daytona.
                            //
                            // Mark every DC in the system that has this brush
                            // selected as a dirty brush.
                            //

                            HOBJ hobj = (HOBJ) 0;
                            DC  *pdc;

                            while ((pdc = (DC *) HmgSafeNextObjt(hobj, DC_TYPE))
                                       != NULL) 
                            {
                                if (pdc->peboFill()->pbrush() == pbrush)
                                {
                                    pdc->flbrushAdd(DIRTY_FILL);
                                }

                                hobj = (HOBJ) pdc->hGet();
                            }

                        }

                        HandleLock.vUnlock();
                    }

                    //
                    // Set the uniqueness so the are-you-
                    // really-dirty check in vInitBrush will
                    // not think an old realization is still valid.
                    //

                    pbrush->ulBrushUnique(pbrush->ulGlobalBrushUnique());
                }
                else
                {
                    WARNING1("Error, SetSolidBrush with cShare != 1");
                }
            }

            if (prbrush)
            {
                prbrush->vRemoveRef(rbType);
            }
        }
        #if DBG
        else
        {
            if (bPen)
            {
                WARNING1("bPen True\n");
            }

            if (pbrush->bIsPen())
            {
                WARNING1("bIsPen True\n");
            }

            if (bUserCalled)
            {
                WARNING1("bUserCalled\n");
            }

            if (pbrush->bIsGlobal())
            {
                WARNING1("bIsGlobal\n");
            }

            if (pbrush->flAttrs() & BR_IS_SOLID)
            {
                WARNING1("BR_IS_SOLID is set\n");
            }

            WARNING1("GreSetSolidBrush not passed a solid color brush\n");
        }
        #endif
    }
    #if DBG
    else
    {
        WARNING1("GreSetSolidBrush failed to lock down brush\n");
    }
    #endif

    return(bReturn);
}

/******************************Public*Routine******************************\
* GreSetSolidBrushLight:
*
*   Private version of GreSetSolidBrush, user can't call
*
* Arguments:
*
*   pbrush      - pointer to log brush
*   clr         - new color
*   bPen        - Brush is a pen
*
* Return Value:
*
*   Status
*
* History:
*
*    2-Nov-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
GreSetSolidBrushLight(
    PBRUSH   pbrush,
    COLORREF clr,
    BOOL     bPen
    )
{
    BOOL bReturn = FALSE;

    if (pbrush != NULL)
    {
        if (
            (pbrush->flAttrs() & BR_IS_SOLID) &&
            (!pbrush->bIsGlobal())
           )
        {
            //
            // make sure bPen flag matches brush type
            //

            if ((bPen != 0) == (pbrush->bIsPen() != 0))
            {

                #if DBG
                    if (bPen)
                    {
                        ASSERTGDI(((PPEN) pbrush)->pstyle() == NULL ||
                                (pbrush->flAttrs() & BR_IS_DEFAULTSTYLE),
                                "GreSetSolidBrushLight - illegal PEN attrs\n");
                    }
                #endif

                ASSERTGDI(pbrush->hbmPattern() == NULL,
                          "ERROR how can solid have pat");
                PRBRUSH prbrush = (PRBRUSH) NULL;
                RBTYPE rbType;

                {
                    //
                    // Grab the handle lock to stabize the lock counts.
                    // Do not attempt to free the realized brush under
                    // this lock; it may take to long.
                    //

                    ASSERTGDI(pbrush->hGet(),
                              "ERROR brush obj has no handle\n");

                    HANDLELOCK HandleLock(PENTRY_FROM_POBJ(pbrush),FALSE);

                    if (HandleLock.bValid())
                    {
                        if (pbrush->cShareLockGet() == 1)
                        {
                            bReturn = TRUE;
                            pbrush->crColor(clr);

                            //
                            // Nobody is using it and we have the HANDLELOCK
                            // so noone can select it in till we are done. So
                            // clean out the old realization now.
                            //

                            if ((pbrush->crFore() != BO_NOTCACHED) &&
                                !pbrush->bCachedIsSolid())
                            {
                                prbrush = (PRBRUSH) pbrush->ulRealization();
                                rbType = pbrush->bIsEngine() ? RB_ENGINE
                                                             : RB_DRIVER;
                            }

                            //
                            // Set up as initially not caching any realization
                            //

                            pbrush->vSetNotCached();
                                        // no one's trying to cache a realization
                                        // in this logical brush yet

                            pbrush->crFore((COLORREF)BO_NOTCACHED);
                                        // no cached realization yet (no need to
                                        // worry about crFore not being set when
                                        // someone tries to check for caching,
                                        // because we don't have a handle yet, and
                                        // we'll lock when we do get the handle,
                                        // forcing writes to flush)

                            //
                            // we are resetting the attributes / type.
                            //

                            if (bPen)
                            {
                                pbrush->ulStyle(HS_DITHEREDCLR);

                                FLONG flOldAttrs = pbrush->flAttrs() &
                                                   (BR_IS_PEN | BR_IS_OLDSTYLEPEN);
                                pbrush->flAttrs(BR_IS_SOLID | flOldAttrs);
                            }
                            else
                            {
                                pbrush->ulStyle(HS_DITHEREDCLR);
                                pbrush->flAttrs(BR_IS_SOLID | BR_DITHER_OK);
                            }

                            //
                            // Set the uniqueness so the are-you-
                            // really-dirty check in vInitBrush will
                            // not think an old realization is still valid.
                            //

                            pbrush->ulBrushUnique(pbrush->ulGlobalBrushUnique());
                        }
                        else
                        {
                            WARNING1("Error, SetSolidBrush with cShare != 1");
                        }

                        HandleLock.vUnlock();
                    }
                }

                if (prbrush)
                {
                    prbrush->vRemoveRef(rbType);
                }
            }
        }
        #if DBG
        else
        {
            if (pbrush->bIsGlobal())
            {
                WARNING1("bIsGlobal\n");
            }

            if (pbrush->flAttrs() & BR_IS_SOLID)
            {
                WARNING1("BR_IS_SOLID is set\n");
            }

            WARNING("GreSetSolidBrush not passed a solid color brush\n");
        }
        #endif
    }
    #if DBG
    else
    {
        WARNING1("GreSetSolidBrush failed to lock down brush\n");
    }
    #endif

    return(bReturn);
}


/******************************Public*Routine******************************\
* GreGetBrushColor
*
* Call for User to retrieve the color from any brush owned by any process
* so User can repaint the background correctly in full drag.  To make sure
* we don't hose an app we need to hold the mult-lock while we do this so
* any operation by the app (such as a Delete) will wait and not fail
* because we're temporarily locking the brush down to peek inside of it.
*
* History:
*  14-Jun-1994 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

COLORREF GreGetBrushColor(HBRUSH hbr)
{
    COLORREF clrRet = 0xFFFFFFFF;

    //
    // Grab the multi-lock so everyone waits while do our quick hack
    // to return the brush color.
    //

    MLOCKFAST mlo;

    //
    // Lock it down but don't check ownership because we want to succeed
    // no matter what.
    //

    //
    // using try except to make sure we will not crash
    // when a bad handle passed in.
    //
    __try
    {
        PENTRY pentry = &gpentHmgr[HmgIfromH(hbr)];

        PBRUSH pbrush = (PBRUSH)(pentry->einfo.pobj);

        if (pbrush)
        {
            if ((pbrush->ulStyle() == HS_SOLIDCLR) ||
                (pbrush->ulStyle() == HS_DITHEREDCLR))
            {
                clrRet = pbrush->crColor();
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING1("GreGetBrushColor - bad handle passed in\n");
    }

    return(clrRet);
}

/******************************Public*Routine******************************\
* BRUSHMEMOBJ::BRUSHMEMOBJ
*
* Creates hatched brushes and solid color brushes.
*
* History:
*  29-Oct-1992 -by- Michael Abrash [mikeab]
* changed to get handle only after fully initialized
*
*  Wed 26-Feb-1992 -by- Patrick Haluptzok [patrickh]
* rewrote to subsume other constructors, add new hatch styles.
*
*  Sun 19-May-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

BRUSHMEMOBJ::BRUSHMEMOBJ(COLORREF cr, ULONG ulStyle_, BOOL bPen, BOOL bSharedMem)
{
    if (ulStyle_ > HS_NULL)
    {
        WARNING1("Invalid style type\n");
        pbp.pbr = NULL;
        return;
    }

    PBRUSH pbrush;

    if ((pbp.pbr = pbrush = pbrAllocBrush(bPen)) == NULL)
    {
        WARNING1("Brush allocation failed\n");
        return;
    }

    pbrush->crColor(cr);
    pbrush->ulStyle(ulStyle_);
    pbrush->hbmPattern(0);
    pbrush->AttrFlags(0);

    if (ulStyle_ < HS_DDI_MAX)
    {
    // The old hatch brushes have been extended to include all the default
    // patterns passed back by the driver.  There are 19 default pattens.

        pbrush->flAttrs(BR_IS_HATCH | BR_NEED_BK_CLR | BR_IS_MASKING);
        goto CreateHandle;
    }

// Handle the other brush types

    switch(ulStyle_)
    {
    case HS_SOLIDCLR:
        pbrush->flAttrs(BR_IS_SOLID);
        break;

    case HS_DITHEREDCLR:
        pbrush->flAttrs(BR_IS_SOLID | BR_DITHER_OK);
        break;

    case HS_SOLIDTEXTCLR:
        pbrush->flAttrs(BR_IS_SOLID | BR_NEED_FG_CLR);
        break;

    case HS_DITHEREDTEXTCLR:
        pbrush->flAttrs(BR_IS_SOLID | BR_NEED_FG_CLR | BR_DITHER_OK);
        break;

    case HS_SOLIDBKCLR:
        pbrush->flAttrs(BR_IS_SOLID | BR_NEED_BK_CLR);
        break;

    case HS_DITHEREDBKCLR:
        pbrush->flAttrs(BR_IS_SOLID | BR_NEED_BK_CLR | BR_DITHER_OK);
        break;

    case HS_NULL:
        pbrush->flAttrs(BR_IS_NULL);
        break;

    default:
        RIP("ERROR BRUSHMEMOBJ hatches invalid type");
    }

// Now that everything is set up, create the handle and expose this logical
// brush

CreateHandle:

    if (HmgInsertObject(pbrush, HMGR_ALLOC_ALT_LOCK, BRUSH_TYPE) == 0)
    {
        FREEOBJ(pbrush, BRUSH_TYPE);
        pbp.pbr = NULL;
    }
    else
    {
        if (bSharedMem)
        {
            //
            //  Setup the user mode BRUSHATTR
            //

            PBRUSHATTR pUser = (PBRUSHATTR)HmgAllocateObjectAttr();

            if (pUser)
            {
                HANDLELOCK BrushLock;

                BrushLock.bLockHobj((HOBJ)pbrush->hHmgr,BRUSH_TYPE);

                if (BrushLock.bValid())
                {

                    PENTRY pent = BrushLock.pentry();

                    //
                    // fill up the brushattr
                    //

                    *pUser = pbrush->_Brushattr;

                    pent->pUser = (PVOID)pUser;
                    pbrush->pBrushattr(pUser);

                    BrushLock.vUnlock();
                }
            }
        }
    }
}

/******************************Public*Routine******************************\
* EBRUSHOBJ::vInitBrush
*
* Initializes the brush user object. If the color can be represented
* without dithering, we set iSolidColor.
*
* History:
*  Tue 08-Dec-1992 -by- Michael Abrash [mikeab]
* Rewrote for speed.
*
*  Sun 23-Jun-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

VOID
EBRUSHOBJ::vInitBrush(
    PDC         pdc,                    // current dc or a fake dc with only back/foreground clr info
    PBRUSH      pbrushIn,               // Current logical brush
    XEPALOBJ    palDC,                  // Target's DC palette
    XEPALOBJ    palSurf,                // Target's surface palette
    SURFACE    *pSurface,               // Target surface
    BOOL        bCanDither              // If FALSE then never dither
    )
{

// Note: If more members of pdc are accessed in the future, then code must be
// added in drvsup.cxx to initialize the members in each place a fake DC
// object is initialized. There's also a fake DC in bDynamicModeChange in
// opendc.cxx which must be updated.

// If the palSurf isn't valid, then the target is a bitmap for a palette
// managed device; therefore the palette means nothing until we actually blt,
// and only the DC palette is relevant. Likewise, if the target is a palette
// managed surface, the brush is realized as indices into the logical palette,
// and unless the logical palette is changed, the brush doesn't need to be
// rerealized. This causes us effectively to check the logical palette time
// twice, but that's cheaper than checking whether we need to check the surface
// palette time and then possibly checking it.

    ULONG ulSurfTime = (palSurf.bValid() && !palSurf.bIsPalManaged()) ?
                        palSurf.ulTime() : 1;

#if DBG
    bo_inits++;
#endif

// If the brush really is dirty, we have to set this anyway; if it's not dirty,
// this takes care of the case where the surface has changed out from under us,
// and then a realization is required and we would otherwise fault trying to
// access the target surface structure in the process of realization.

    psoTarg1 = pSurface;        // surface for which brush is realized
                                // The journaling code depends on this
                                // being set correctly.  This has the PDEV
                                // for the device it's selected into.

    COLORREF crTextDC = pdc->crTextClr();
    COLORREF crBackDC = pdc->crBackClr();

    LONG     lIcmModeDC = pdc->lIcmMode();
    HANDLE   hcmXformDC = pdc->hcmXform();

// See if the brush really isn't dirty and doesn't need to be rerealized

    if ( ( pbrushIn->ulBrushUnique() == _ulUnique ) &&
         (!bCareAboutFg() || (crCurrentText() == crTextDC) ) &&
         (!bCareAboutBg() || (crCurrentBack() == crBackDC) ) &&
         (palDC.ulTime() == ulDCPalTime()) &&
         (ulSurfTime == ulSurfPalTime()) &&
         (pbrushIn != gpbrDCBrush)&&
         (pbrushIn != gpbrDCPen) &&
         (lIcmMode() == lIcmModeDC) &&
         (hcmXform() == hcmXformDC) &&
         (bCanDither == _bCanDither))
    {
#if DBG
        bo_notdirty++;
#endif
          return;
    }

// Get Cached Values

    flAttrs = pbrushIn->flAttrs();

// Remember the characteristics of the brush

    _pbrush = pbrushIn;
    _ulUnique = pbrushIn->ulBrushUnique();   // brush uniqueness
    crCurrentText1 = crTextDC;   // text color at realization time
    crCurrentBack1 = crBackDC;   // background color at realization time
    _ulDCPalTime = palDC.ulTime(); // DC palette set time at realization time
    _ulSurfPalTime = ulSurfTime;   // surface palette set time at realization time
    _bCanDither = bCanDither;       // dither enabled?

// Initialize ICM stuffs

    BOOL bCMYKColorSolid = FALSE;

    flColorType = 0; // Initialized with zero.

// Set icm modes

    if (IS_ICM_ON(lIcmModeDC))
    {
        BOOL bIcmBrush = FALSE;

    // color translation should happen, check we have nessesary data for ICM.

        if (flAttrs & (BR_IS_SOLID|BR_IS_HATCH|BR_IS_MONOCHROME))
        {
            if (IS_ICM_HOST(lIcmModeDC))
            {
            // DC attributes should have ICM-ed color.
            //
            // (or with null-ColorTransform, no color translation happen)

                if (flAttrs & (BR_IS_SOLID|BR_IS_MONOCHROME))
                {
                    if ((flAttrs & (BR_NEED_FG_CLR|BR_NEED_BK_CLR)) ||
                        (pbrushIn == gpbrDCBrush) || (pbrushIn == gpbrDCPen))
                    {
                        bIcmBrush = TRUE;
                    }
                }

                if (bIcmBrush == FALSE)
                {
                    if (pbrushIn->bIsPen())
                    {
                        if ((hcmXformDC == NULL) || pdc->bValidIcmPenColor())
                        {
                            bIcmBrush = TRUE;
                        }
                        else
                        {
                            ICMMSG(("vInitBrush():ERROR: No ICMed pen color for this brush\n"));
                        }
                    }
                    else
                    {
                        if ((hcmXformDC == NULL) || pdc->bValidIcmBrushColor())
                        {
                            bIcmBrush = TRUE;
                        }
                        else
                        {
                            ICMMSG(("vInitBrush():ERROR: No ICMed brush color for this brush\n"));
                        }
                    }
                }
            }
            else // other ICM modes (Device and Apps)
            {
                bIcmBrush = TRUE;
            }
        }
        else if (flAttrs & BR_IS_DIB)
        {
            if (IS_ICM_HOST(lIcmModeDC))
            {
            // Brush should have ICM-ed DIB
            //
            // (or with null-ColorTransform, no color translation happen)

                if ((hcmXformDC == NULL) || pbrushIn->hFindIcmDIB(hcmXformDC))
                {
                    bIcmBrush = TRUE;
                }
                else
                {
                    ICMMSG(("vInitBrush():ERROR: No ICMed DIB for this brush\n"));
                }
            }
            else // other ICM modes (Device and Apps)
            {
                bIcmBrush = TRUE;
            }
        }
        else
        {
        // Other stlyes, no ICM
        }

        if (bIcmBrush)
        {
            lIcmMode(lIcmModeDC); // ICM mode
            hcmXform(hcmXformDC); // ICM molor Transform handle

        // setup colortype flag.

            if (bIsAppsICM() || bIsHostICM())
            {
                flColorType |= BR_HOST_ICM;
            }
            else if (bIsDeviceICM())
            {
                flColorType |= BR_DEVICE_ICM;
            }

        // If the brush is solid, iSolidColor will have CMKY color. Otherwise,
        // iSolidColor will be 0xFFFFFFFF and flColorType does not have BR_CMYKCOLOR.

            bCMYKColorSolid = (bIsCMYKColor() && (flAttrs & BR_IS_SOLID));

            if (bCMYKColorSolid)
            {
                flColorType |= BR_CMYKCOLOR;    // color type is CMYK color
            }
        }
        else
        {
            ICMMSG(("vInitBrush():This brush is not ICMed\n"));

            lIcmMode(DC_ICM_OFF); // ICM mode
            hcmXform(NULL); // ICM molor Transform handle
        }
    }
    else
    {
        lIcmMode(DC_ICM_OFF); // ICM mode
        hcmXform(NULL);       // ICM molor Transform handle
    }

// Get the target PDEV

    PDEVOBJ po(pSurface->hdev());
    ASSERTGDI(po.bValid(), "ERROR BRUSHOBJ PDEVOBJ");

// Set palettes

    palDC1.ppalSet(palDC.ppalGet());
    palSurf1.ppalSet(palSurf.ppalGet());
    palMeta1.ppalSet(po.ppalSurfNotDynamic());
    _iMetaFormat = po.iDitherFormatNotDynamic();

    ASSERTGDI(pSurface != NULL,       "ERROR BRUSHOBJ::bInit0");
    ASSERTGDI(palDC.bValid(),    "ERROR BRUSHOBJ::bInit4");

// Clean up what was already here

// If this brush object had an engine brush realization, get rid of it

    if (pengbrush1 != (PENGBRUSH) NULL)
    {
        PRBRUSH prbrush = pengbrush1;   // point to engine brush realization
        prbrush->vRemoveRef(RB_ENGINE); // decrement the reference count on the
                                        // realization and free the brush if
                                        // this is the last reference
        pengbrush1 = NULL;  // mark that there's no realization
    }

// If this brush object had a device brush realization, get rid of it

    if (pvRbrush != (PVOID) NULL)
    {
        PRBRUSH prbrush = (PDBRUSH)DBRUSHSTART(pvRbrush);
                                // point to DBRUSH (pvRbrush points to
                                // realization, which is at the end of DBRUSH)
        prbrush->vRemoveRef(RB_DRIVER);
                                // decrement the reference count on the
                                // realization and free the brush if
                                // this is the last reference
        pvRbrush = NULL;    // mark that there's no realization
    }

// Remember the color so we do the realization code correctly later
// if it's a dithered brush.  We may need this even if we have
// a hit in the cache since we have driver/engine distinction.

    if (flAttrs & BR_IS_SOLID)
    {
        if (flAttrs & BR_NEED_FG_CLR)
        {
            crRealize = crCurrentText();     // use text brush

            if (bIsHostICM())
                crRealizeOrignal = pdc->ulTextClr();
        }
        else if (flAttrs & BR_NEED_BK_CLR)
        {
            crRealize = crCurrentBack();     // use back brush
            
            if (bIsHostICM())
                crRealizeOrignal = pdc->ulBackClr();
        }
        else if (pbrushIn == gpbrDCBrush)
        {
            crRealize = pdc->crDCBrushClr(); // use DC brush

            if (bIsHostICM())
                crRealizeOrignal = pdc->ulDCBrushClr();
        }
        else if (pbrushIn == gpbrDCPen)
        {
            crRealize = pdc->crDCPenClr();   // use DC pen

            if (bIsHostICM())
                crRealizeOrignal = pdc->ulDCPenClr();
        }
        else
        {
            crRealize = pbrushIn->crColor();

            if (bIsHostICM())
            {
                crRealizeOrignal = crRealize;

                if (pbrushIn->bIsPen())
                {
                    if (pdc->bValidIcmPenColor())
                    {
                        crRealize = pdc->crIcmPenColor();   // use ICM translated pen
                    }
                }
                else
                {
                    if (pdc->bValidIcmBrushColor())
                    {
                        crRealize = pdc->crIcmBrushColor(); // use ICM translated brush
                    }
                }
            }
        }
    }
    else if (flAttrs & BR_IS_HATCH)
    {
        crRealize = pbrushIn->crColor();

        if (bIsHostICM())
        {
            crRealizeOrignal = crRealize;

            if (pbrushIn->bIsPen())
            {
                if (pdc->bValidIcmPenColor())
                {
                    crRealize = pdc->crIcmPenColor();
                }
            }
            else
            {
                if (pdc->bValidIcmBrushColor())
                {
                    crRealize = pdc->crIcmBrushColor();
                }
            }
        }
    }

// See if there's a cached realization that we can use
// Note that the check for crFore MUST come first, because if and only if
// that field is not BO_NOTCACHED is there a valid cached realization.

#if DBG
    bo_realize++;

    if ( (pbrushIn->crFore() == BO_NOTCACHED) )
    {
        bo_missnotcached++;
    }
    else if ( pbrushIn->bCareAboutFg() &&
          (pbrushIn->crFore() != crTextDC) )
    {
        bo_missfg++;
    }
    else if (pbrushIn->bCareAboutBg() &&
           (pbrushIn->crBack() != crBackDC) )
    {
        bo_missbg++;
    }
    else if ( pbrushIn->ulPalTime() != ulDCPalTime() )
    {
        bo_misspaltime++;
    }
    else if ( pbrushIn->ulSurfTime() != ulSurfPalTime() )
    {
        bo_misssurftime++;
    }
    else
    {
        bo_cachehit++;
    }
#endif

    if (
         (pbrushIn->crFore() != BO_NOTCACHED) &&
         (
           (!pbrushIn->bCareAboutFg()) ||
           (pbrushIn->crFore() == crTextDC)
         ) &&
         (
           (!pbrushIn->bCareAboutBg()) ||
           (pbrushIn->crBack() == crBackDC)
         ) &&
         (pbrushIn->ulPalTime() == ulDCPalTime()) &&
         (pbrushIn->ulSurfTime() == ulSurfPalTime()) &&
         (pbrushIn->hdevRealization() == po.hdev()) &&
         (pbrushIn != gpbrDCBrush) &&
         (pbrushIn != gpbrDCPen)
       )
    {

    // Uncache the realization according to the realization type (solid,
    // driver realization, or engine realization)

        if (pbrushIn->bCachedIsSolid())
        {
        // Retrieve the cached solid color and done

            iSolidColor = (ULONG)pbrushIn->ulRealization();
            crPaletteColor = pbrushIn->crPalColor();
        }
        else
        {
        // See whether this is an engine or driver realization

            PRBRUSH prbrush = (PRBRUSH)pbrushIn->ulRealization();

            if (pbrushIn->bIsEngine())
            {
                pengbrush1 = (PENGBRUSH)prbrush;
            }
            else
            {
            // Skip over the RBRUSH at the start of the DBRUSH, so that the
            // driver doesn't see that

                pvRbrush = (PVOID)(((PDBRUSH)prbrush)->aj);
            }

        // Whether this was an engine or driver realization, now we've got
        // it selected into another DC, so increment the reference count
        // so it won't get deleted until it's no longer selected into any
        // DC and the logical brush no longer exists

            prbrush->vAddRef();

        // Indicate that this is a pattern brush

            iSolidColor    = 0xffffffff;
            crPaletteColor = pbrushIn->crPalColor();
        }

    // Nothing more to do once we've found that the realization is cached;
    // this tells us all we hoped to find out in this call, either the
    // solid color for the realization or else that the realization isn't
    // solid (in which case we probably found the realization too, although
    // if the cached realization is driver and this time the engine will do
    // the drawing, or vice-versa, the cached realization won't help us)

        return;
    }

    // If brush isn't based on color (if it is a bitmap or hatch), we're done
    // here, because all we want to do is set iSolidColor if possible

    if (!(flAttrs & BR_IS_SOLID))
    {
        iSolidColor = crPaletteColor = 0xffffffff;
        return;
    }

    // See if we can find exactly the color we want

    if (bCMYKColorSolid)
    {
        // crRealize is CMKY color just set it to iSolidColor

        iSolidColor = crPaletteColor = crRealize;
    }
    else if (po.bCapsForceDither() && bCanDither)
    {
        // printer drivers may set the FORCEDITHER flag.  In this case, we always
        // want to dither brushes, even if they map to a color in the drivers palette.

        iSolidColor    = 0xffffffff;
        crPaletteColor = crRealize;
    }
    else
    {
        iSolidColor =
             ulGetMatchingIndexFromColorref(
                            palSurf,
                            palDC,
                            crRealize
                            );
        crPaletteColor = rgbFromColorref(palSurf,
                            palDC,
                            crRealize
                            );
    }

    // Under CMYK color context, there is no dither.

    if ((iSolidColor == 0xFFFFFFFF) && (!bCMYKColorSolid))
    {

    // Not an exact match. If we can dither, then we're done for now; we'll
    // realize the brush when the driver wants it, so if all conditions are
    // met for dithering this brush, then we're done
    // we dither the brush if the caller says we can and if either the brush
    // says it is ditherable or the driver has requested dithering.

        if (((flAttrs & BR_DITHER_OK) || (po.bCapsForceDither())) &&
            bCanDither)
        {
        // ...and the PDEV allows color dithering and either the bitmap is
        // for a palette managed device, or if the surface and device
        // palettes are the same palette, or if the destination surface is
        // monochrome and the pdev has hooked mono dithering.
        //
        // Note: There is a dynamic mode change synchronization hole here
        //       between the time we check GCAPS_COLOR_DITHER/MONO_DITHER
        //       and the time that we go to actually realize the brush --
        //       the driver's capabilities may have changed in the mean
        //       time.  Note that this will happen only when drawing to
        //       DIB based compatible bitmaps.  Since it will be rare, and
        //       since we won't fall over, I'm letting it through...

            if (
                (
                 (
                  (!palSurf.bValid()) ||
                  (palSurf.ppalGet() == po.ppalSurfNotDynamic())
                 ) &&
                 (po.flGraphicsCapsNotDynamic() & GCAPS_COLOR_DITHER)
                ) ||
                (palSurf.bIsMonochrome() &&
                 (po.flGraphicsCapsNotDynamic() & GCAPS_MONO_DITHER)
                )
               )
            {
            // ...then we can dither this brush, so we can't set iSolidColor
            // and we're done. Dithering will be done when the driver
            // requests realization
            //
                crPaletteColor = crRealize;
                return;
            }
        }

    // We can't dither and there's no exact match, so find the nearest
    // color and that'll have to do

        if (pSurface->iFormat() == BMF_1BPP)
        {

        // For monochrome surface, we'll have background mapped to
        // background and everything else mapped to foreground.

            iSolidColor = ulGetNearestIndexFromColorref(
                                                palSurf,
                                                palDC,
                                                crBackDC,
                                                SE_DONT_SEARCH_EXACT_FIRST
                                                );
            crPaletteColor = rgbFromColorref(palSurf,
                                             palDC,
                                             crBackDC);

            if (crBackDC != crRealize)
            {
                iSolidColor = 1 - iSolidColor;

                // Obtain corresponding color from index.

                PAL_ULONG ulPalTemp;
                ulPalTemp.pal  = palSurf.palentryGet(iSolidColor);
                crPaletteColor = ulPalTemp.ul;
            }
        }
        else
        {
            iSolidColor = ulGetNearestIndexFromColorref(
                                                palSurf,
                                                palDC,
                                                crRealize,
                                                SE_DONT_SEARCH_EXACT_FIRST
                                                );
            crPaletteColor = rgbFromColorref(palSurf,
                                             palDC,
                                             crRealize);
        }
    }

// See if we can cache this brush color in the logical brush; we can't if
// another realization has already been cached in the logical brush
// See vTryToCacheRealization, in BRUSHDDI.CXX, for a detailed explanation
// of caching in the logical brush

    if ( !pbrushIn->bCacheGrabbed() )
    {

    // Try to grab the "can cache" flag; if we don't get it, someone just
    // sneaked in and got it ahead of us, so we're out of luck and can't
    // cache

        if ( pbrushIn->bGrabCache() )
        {

        // We got the "can cache" flag, so now we can cache this realization
        // in the logical brush

        // These cache ID fields must be set before crFore, because crFore
        // is the key that indicates when the cached realization is valid.
        // If crFore is -1 when the logical brush is being realized, we
        // just go realize the brush; if it's not -1, we check the cache ID
        // fields to see if we can use the cached fields.
        // InterlockedExchange() is used below to set crFore to make sure
        // the cache ID fields are set before crFore

            pbrushIn->crBack(crCurrentBack1);
            pbrushIn->ulPalTime(ulDCPalTime());
            pbrushIn->ulSurfTime(ulSurfPalTime());
            pbrushIn->ulRealization(iSolidColor);
            pbrushIn->crPalColor(crPaletteColor);
            pbrushIn->SetSolidRealization();

        // This must be set last, because once it's set, other selections
        // of this logical brush will attempt to use the cached brush. The
        // use of InterlockedExchange in this method enforces this

            pbrushIn->crForeLocked(crCurrentText1);

        // The realization is now cached in the logical brush

        }
    }

    return;
}


/******************************Public*Routine******************************\
* EBRUSHOBJ::vNuke()
*
* Clean up framed EBRUSHOBJ
*
* History:
*  20-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID EBRUSHOBJ::vNuke()
{
    if (pengbrush1 != (PENGBRUSH) NULL)
    {
        PRBRUSH prbrush = pengbrush1;   // point to engine brush realization
        prbrush->vRemoveRef(RB_ENGINE); // decrement the reference count on the
                                        // realization and free the brush if
                                        // this is the last reference
    }

    if (pvRbrush != (PVOID) NULL)
    {
        PRBRUSH prbrush = (PDBRUSH)DBRUSHSTART(pvRbrush);
                                // point to DBRUSH (pvRbrush points to
                                // realization, which is at the end of DBRUSH)
        prbrush->vRemoveRef(RB_DRIVER);
                                // decrement the reference count on the
                                // realization and free the brush if
                                // this is the last reference
    }
}





// This is the brusheng.cxx section

/******************************Public*Routine******************************\
* bInitBRUSHOBJ
*
* Initializes the default brushes and and the dclevel default values for
* brushes and pens.
*
* Explanation of the NULL brush (alias Hollow Brush)
* The Null brush is special.  Only 1 is ever created
* (at initialization time in hbrNull).  The only API's for
* getting a Null brush are CreateBrushIndirect and GetStockObject which
* both return "the 1 and only 1" Null brush.  A Null brush is never
* realized by a driver or the engine.  No output call should ever occur
* that requires a brush if the brush is NULL, the engine should stop
* these before they get to the driver.
*
* History:
*  20-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

extern "C" BOOL bInitBrush(
    int       iBrush,
    COLORREF  cr,
    DWORD     dwHS,
    PULONG_PTR pdw,
    BOOL      bEnableDither
    )
{
    BOOL bSuccess = FALSE;
    BRUSHMEMOBJ brmo(cr,dwHS,FALSE,FALSE);

    if (brmo.bValid())
    {
        brmo.vKeepIt();
        brmo.vGlobal();

        if (bEnableDither)
            brmo.vEnableDither();

        if (pdw)
            *pdw = (ULONG_PTR)brmo.pbrush();

        bSetStockObject(brmo.hbrush(),iBrush);

        // init DcAttrDefault brush
        if (iBrush == WHITE_BRUSH)
        {
            DcAttrDefault.hbrush = brmo.hbrush();
        }

        bSuccess = TRUE;
    }
    else
    {
    #if DBG
        DbgPrint("couldn't create default brush %lx, %lx\n",cr,iBrush);
    #endif
        return(FALSE);
    }
    return(bSuccess);
}

BOOL bInitBRUSHOBJ()
{
    if (!bInitBrush(WHITE_BRUSH,(COLORREF)RGB(0xFF,0xFF,0xFF),
                    HS_DITHEREDCLR,(PULONG_PTR)&dclevelDefault.pbrFill,FALSE)                 ||
        !bInitBrush(BLACK_BRUSH, (COLORREF)RGB(0x0, 0x0, 0x0), HS_DITHEREDCLR,NULL,FALSE) ||
        !bInitBrush(GRAY_BRUSH,  (COLORREF)RGB(0x80,0x80,0x80),HS_DITHEREDCLR,NULL,TRUE)  ||
        !bInitBrush(DKGRAY_BRUSH,(COLORREF)RGB(0x40,0x40,0x40),HS_DITHEREDCLR,NULL,TRUE)  ||
        !bInitBrush(LTGRAY_BRUSH,(COLORREF)RGB(0xc0,0xc0,0xc0),HS_DITHEREDCLR,NULL,TRUE)  ||
        !bInitBrush(NULL_BRUSH,  (COLORREF)0,HS_NULL,(PULONG_PTR)&gpbrNull,FALSE))
    {
        return(FALSE);
    }

// Init default Null Pen

    {
        BRUSHMEMOBJ brmo((COLORREF) 0, HS_NULL, TRUE, FALSE);  // TRUE signifies a pen

        if (brmo.bValid())
        {
            brmo.vKeepIt();
            brmo.vGlobal();
            brmo.vSetOldStylePen();
            brmo.flStylePen(PS_NULL);
            brmo.lWidthPen(1);
            HmgModifyHandleType((HOBJ)MODIFY_HMGR_TYPE(brmo.hbrush(),LO_PEN_TYPE));
            bSetStockObject(brmo.hbrush(),NULL_PEN);
            gpPenNull = (PPEN)brmo.pbrush();
        }
        else
        {
            WARNING("Failed Null Pen");
            return(FALSE);
        }
    }

// Init default Black Pen

    {
        BRUSHMEMOBJ brmo((COLORREF) (RGB(0,0,0)), HS_DITHEREDCLR, TRUE, FALSE);

        if (brmo.bValid())
        {
            brmo.vKeepIt();
            brmo.vGlobal();
            brmo.vSetOldStylePen();
            brmo.flStylePen(PS_SOLID);
            brmo.lWidthPen(0);
            brmo.l_eWidthPen(IEEE_0_0F);
            brmo.iJoin(JOIN_ROUND);
            brmo.iEndCap(ENDCAP_ROUND);
            brmo.pstyle((PFLOAT_LONG) NULL);
            HmgModifyHandleType((HOBJ)MODIFY_HMGR_TYPE(brmo.hbrush(),LO_PEN_TYPE));
            bSetStockObject(brmo.hbrush(),BLACK_PEN);
            DcAttrDefault.hpen = (HPEN)brmo.hbrush();
            dclevelDefault.pbrLine = brmo.pbrush();
        }
        else
        {
            WARNING("failed black pen");
            return(FALSE);
        }
    }

// Init default White Pen

    {
        BRUSHMEMOBJ brmo((COLORREF) (RGB(0xFF,0xFF,0xFF)), HS_DITHEREDCLR, TRUE, FALSE);

        if (brmo.bValid())
        {
            brmo.vKeepIt();
            brmo.vGlobal();
            brmo.vSetOldStylePen();
            brmo.flStylePen(PS_SOLID);
            brmo.lWidthPen(0);
            brmo.l_eWidthPen(IEEE_0_0F);
            brmo.iJoin(JOIN_ROUND);
            brmo.iEndCap(ENDCAP_ROUND);
            brmo.pstyle((PFLOAT_LONG) NULL);
            HmgModifyHandleType((HOBJ)MODIFY_HMGR_TYPE(brmo.hbrush(),LO_PEN_TYPE));
            bSetStockObject(brmo.hbrush(),WHITE_PEN);
        }
        else
        {
            WARNING("Failed white pen");
            return(FALSE);
        }
    }

// Init the stock DC Pen

    {
        BRUSHMEMOBJ brmo((COLORREF) (RGB(0,0,0)), HS_DITHEREDCLR, TRUE, FALSE);

        if (brmo.bValid())
        {
            brmo.vKeepIt();
            brmo.vGlobal();
            brmo.vSetOldStylePen();
            brmo.flStylePen(PS_SOLID);
            brmo.lWidthPen(0);
            brmo.l_eWidthPen(IEEE_0_0F);
            brmo.iJoin(JOIN_ROUND);
            brmo.iEndCap(ENDCAP_ROUND);
            brmo.pstyle((PFLOAT_LONG) NULL);
            HmgModifyHandleType((HOBJ)MODIFY_HMGR_TYPE(brmo.hbrush(),LO_PEN_TYPE));
            bSetStockObject(brmo.hbrush(),DC_PEN);
            ghbrDCPen = brmo.hbrush();
            gpbrDCPen = brmo.pbrush();

        }
        else
        {
            WARNING("Failed DC pen");
            return(FALSE);
        }
    }


// init the text brush

    {
        BRUSHMEMOBJ brmo((COLORREF) (RGB(0,0,0)),HS_DITHEREDTEXTCLR,FALSE,FALSE);

        if (brmo.bValid())
        {
            brmo.vKeepIt();
            brmo.vGlobal();
            ghbrText = brmo.hbrush();
            gpbrText = brmo.pbrush();
        }
        else
        {
            WARNING("Could not create default text brush");
            return(FALSE);
        }
    }

// init the background brush

    {
        BRUSHMEMOBJ brmo((COLORREF) (RGB(0xff,0xff,0xff)),HS_DITHEREDBKCLR,FALSE,FALSE);

        if (brmo.bValid())
        {
            brmo.vKeepIt();
            brmo.vGlobal();
            ghbrBackground = brmo.hbrush();
            gpbrBackground = brmo.pbrush();
        }
        else
        {
            WARNING("Could not create default background brush");
            return(FALSE);
        }
    }

// init the global pattern gray brush

    {
        static WORD patGray[8] = { 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa };
        HBITMAP hbmGray;

        hbmGray = GreCreateBitmap(8, 8, 1, 1, (LPBYTE)patGray);

        if (hbmGray == (HBITMAP) 0)
        {
            WARNING1("bInitBRUSHOBJ failed GreCreateBitmap\n");
            return(FALSE);
        }

        ghbrGrayPattern = GreCreatePatternBrush(hbmGray);

        if (ghbrGrayPattern == (HBRUSH) 0)
        {
            WARNING1("bInitBRUSHOBJ failed GreCreatePatternBrush\n");
            return(FALSE);
        }
        GreDeleteObject(hbmGray);
        GreSetBrushOwnerPublic((HBRUSH)ghbrGrayPattern);
    }

// init the stock DC brush
    {
        BRUSHMEMOBJ brmo((COLORREF) (RGB(0xff,0xff,0xff)),HS_DITHEREDCLR,FALSE,FALSE);

        if (brmo.bValid())
        {
            brmo.vKeepIt();
            brmo.vGlobal();

            bSetStockObject(brmo.hbrush(), DC_BRUSH);

            ghbrDCBrush = brmo.hbrush();
            gpbrDCBrush = brmo.pbrush();

        }
        else
        {
            WARNING("Could not create direct dc brush");
            return(FALSE);
        }
    }


    return(TRUE);
}



/******************************Public*Routine******************************\
* GreSelectBrush
*
* Selects the given brush into the given DC.  Fast SelectObject
*
* History:
*  Thu 21-Oct-1993 -by- Patrick Haluptzok [patrickh]
* wrote it.
\**************************************************************************/

HBRUSH GreSelectBrush(HDC hdc, HBRUSH hbrush)
{
    HBRUSH  hbrReturn = (HBRUSH) 0;

    //
    // Try to lock the DC. If we fail, we just return failure.
    //

    XDCOBJ dco(hdc);

    if (dco.bValid())
    {
        //
        // call DC locked version
        //

        hbrReturn = GreDCSelectBrush(dco.pdc,hbrush);
        dco.vUnlockFast();
    }

    return(hbrReturn);
}

/******************************Public*Routine******************************\
* GreDCSelectBrush
*
*   Select brush with dc already locked
*
* Arguments:
*
*   pdc     - locked DC pointer
*   hbrush  - brush to select
*
* Return Value:
*
*   Old hbrush or NULL
*
* History:
*
*    19-May-1995 : copied from GreSelectBrush
*
\**************************************************************************/

HBRUSH
GreDCSelectBrush(
    PDC    pdc,
    HBRUSH hbrush
    )
{
    HBRUSH hbrReturn = (HBRUSH) 0;
    PBRUSH pbrush = NULL;

    XDCOBJ dco;

    dco.pdc = pdc;

    if (dco.bValid())
    {
        HBRUSH  hbrOld;

        //
        // The DC is locked. Set the return value to the old brush in the DC.
        //

        hbrOld = (HBRUSH) (dco.pdc->pbrushFill())->hGet();

        //
        // the return value should be the one cached in the dc
        //

        hbrReturn = dco.pdc->hbrush();

        //
        // If the new brush is the same as the old brush, nothing to do.
        //

        if (DIFFHANDLE(hbrush,hbrOld))
        {
            //
            // Try to lock down the logical brush so we can get the pointer out.
            //

            pbrush = (BRUSH *)HmgShareCheckLock((HOBJ)hbrush, BRUSH_TYPE);

            if (pbrush)
            {
                //
                // Undo the lock from when the brush was selected.
                //

                DEC_SHARE_REF_CNT_LAZY0(dco.pdc->pbrushFill());

                //
                // Changing pbrushfill, set flag to force re-realization
                //
                dco.ulDirtyAdd(DIRTY_FILL);
 
                //
                // Save the pointer to the logical brush in the DC. We don't
                // unlock the logical brush, because the alt lock count in the
                // logical brush is the reference count for DCs in which the brush
                // is currently selected; this protects us from having the actual
                // logical brush deleted while it's selected into a DC, and allows
                // us to reference the brush with a pointer rather than having to
                // lock down the logical brush every time.
                //

                dco.pdc->pbrushFill(pbrush);
            }
            else
            {
                WARNING1("SelectBrush got invalid brush handle\n");

                hbrReturn = NULL;
            }
        }
        else
        {
            pbrush = dco.pdc->pbrushFill();
        }

        if (pbrush != NULL)
        {
            if (hbrReturn != NULL)
            {
                //
                // must still check brush for new color
                //

                PBRUSHATTR pUser = pbrush->_pBrushattr;

                //
                // if the brush handle is a cached solid brush,
                // call GreSetSolidBrushInternal to change the color
                //

                if (pUser != &pbrush->_Brushattr)
                {
                    if (pUser->AttrFlags & ATTR_NEW_COLOR)
                    {
                        //
                        // force re-realization in case handle was same
                        //

                        dco.ulDirtyAdd(DIRTY_FILL);

                        //
                        // set the new color for the cached brush.
                        // Note: since pbrush is pulled straight
                        // from the DC, it's reference count will
                        // be 1, which is needed by SetSolidBrush
                        //

                        if (!GreSetSolidBrushLight(pbrush,pUser->lbColor,FALSE))
                        {
                            WARNING1("GreSyncbrush failed to setsolidbrushiternal\n");
                        }

                        pUser->AttrFlags &= ~ATTR_NEW_COLOR;
                    }
                }
            }

            dco.pdc->hbrush(hbrush);
            dco.pdc->ulDirtySub(DC_BRUSH_DIRTY);
        }
    }

    return(hbrReturn);
}

/******************************Public*Routine******************************\
* GreDCSelectPen
*   Selects a hpen into the given pdc
*
* Arguments:
*
*   pdc  - locked dc
*   hpen - hpen to select
*
* Return Value:
*
*   old hpen
*
* History:
*
*    29-Jan-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

HPEN GreDCSelectPen(
    PDC  pdc,
    HPEN hpen
    )
{
    HPEN hpReturn = (HPEN) NULL;
    PPEN ppen     = NULL;

    //
    // Try to lock the DC. If we fail, we just return failure.
    //

    XDCOBJ dco;

    dco.pdc = pdc;

    if (dco.bValid())
    {
        HPEN hpOld;
        BOOL bRealize = FALSE;

        //
        // hpOld is the pen (LINE BRUSH) currently realized in the DC
        //

        hpOld = (HPEN) (dco.pdc->pbrushLine())->hGet();

        //
        // Set the return value to the old pen in the DCATTR.
        // This is the last hpen the user selected
        //

        hpReturn = (HPEN)dco.pdc->hpen();

        //
        // If the new pen is the same as the old pen, nothing to do.
        //

        if (DIFFHANDLE(hpen, hpOld))
        {
            //
            // Try to lock down the logical brush so we can get the pointer out.
            //

            ppen = (PEN *)HmgShareCheckLock((HOBJ)hpen, BRUSH_TYPE);

            if (ppen && ppen->bIsPen())
            {
                //
                // Undo the lock from when the pen was selected.
                //

                DEC_SHARE_REF_CNT_LAZY0(dco.pdc->pbrushLine());

                //
                // Mark line relization is invalid.
                //

                dco.ulDirtyAdd(DIRTY_LINE);

                //
                // Save the pointer to the logical brush in the DC. We don't
                // unlock the logical brush, because the alt lock count in the
                // logical brush is the reference count for DCs in which the brush
                // is currently selected; this protects us from having the actual
                // logical brush deleted while it's selected into a DC, and allows
                // us to reference the brush with a pointer rather than having to
                // lock down the logical brush every time.
                //

                dco.pdc->pbrushLine(ppen);

                //
                // The pen changed, so realize the new LINEATTRS, based on
                // the current world transform.
                //

                bRealize = TRUE;
            }
            else
            {
                WARNING1("SelectPen got invalid pen handle\n");

                //
                // If this is not pen, can't select it as pen.
                //

                if (ppen)
                {
                    DEC_SHARE_REF_CNT(ppen);
                    ppen = NULL;
                }

                hpReturn = NULL;
            }
        }
        else
        {
            ppen = (PPEN)dco.pdc->pbrushLine();
        }

        //
        // In case the handle stays the same, but the pen is new
        // due to re-use of a user hpen, so re-realize it.
        //

        if (ppen != (PPEN) NULL)
        {
            if (hpReturn != NULL)
            {
                PBRUSHATTR pUser = ppen->_pBrushattr;

                //
                // if the brush handle is a cached solid brush,
                // call GreSetSolidBrushInternal to change the color
                //

                if (pUser != &ppen->_Brushattr)
                {
                    if (pUser->AttrFlags & ATTR_NEW_COLOR)
                    {
                        //
                        // set the new color for the cached brush.
                        // Note: since pbrush is pulled straight
                        // from the DC, it's reference count will
                        // be 1, which is needed by SetSolidBrush
                        //

                        if (!GreSetSolidBrushLight(ppen,pUser->lbColor,TRUE))
                        {
                            WARNING ("GreDCSelectPen failed to setsolidbrushiternal\n");
                        }

                        dco.ulDirtyAdd(DIRTY_LINE);
                        pUser->AttrFlags &= ~ATTR_NEW_COLOR;
                        bRealize = TRUE;
                    }
                }

                if (bRealize)
                {
                    //
                    // The pen changed, so realize the new LINEATTRS, based on
                    // the current world transform.
                    //
 
                    EXFORMOBJ exo(dco, WORLD_TO_DEVICE);

                    dco.pdc->vRealizeLineAttrs(exo);

                    LINEATTRS *pla = dco.plaRealized();
                }
            }

            dco.pdc->hpen(hpen);
            dco.pdc->ulDirtySub(DC_PEN_DIRTY);
        }
    }

    return(hpReturn);
}

/******************************Public*Routine******************************\
* GreSelectPen
*
* Selects the given brush into the given DC.  Fast SelectObject
*
* History:
*  Thu 21-Oct-1993 -by- Patrick Haluptzok [patrickh]
* wrote it.
\**************************************************************************/

HPEN GreSelectPen(HDC hdc, HPEN hpen)
{
    HPEN  hpenReturn = (HPEN) 0;

    //
    // Try to lock the DC. If we fail, we just return failure.
    //

    XDCOBJ dco(hdc);

    if (dco.bValid())
    {
        //
        // call DC locked version
        //

        hpenReturn = GreDCSelectPen(dco.pdc,hpen);
        dco.vUnlockFast();
    }

    return(hpenReturn);
}

/******************************Public*Routine******************************\
* bDeleteBrush
*
* This will delete the brush.  The brush can only be deleted if it's not
* global and not being used by anyone else.
*
* History:
*
* 7-Feb-1996 -by- Mark Enstrom [marke]
*   Add PEB caching for brush and pen objects
* 23-May-1991 -by- Patrick Haluptzok patrickh
*   Wrote it.
\**************************************************************************/

BOOL bDeleteBrush(HBRUSH hbrush, BOOL bCleanup)
{
    PBRUSHPEN       pbp;
    BOOL            bReturn = TRUE;
    HBRUSH          hbrushNew;
    BOOL            bDelete = TRUE;
    PBRUSHATTR      pUser = NULL;
    PENTRY          pentTmp;
    BOOL            bMakeNonStock = FALSE;

    //
    // check handle for user-mode brush
    //

    if (!bCleanup)
    {
        HANDLELOCK BrushLock;

        BrushLock.bLockHobj((HOBJ)hbrush,BRUSH_TYPE);

        if (BrushLock.bValid())
        {
            POBJ pobj = BrushLock.pObj();
            pUser = (PBRUSHATTR)BrushLock.pUser();

            ASSERTGDI(pobj->cExclusiveLock == 0, "deletebrush - exclusive lock not 0\n");

            //
            // If Brush is still in use, mark for lazy deletion and return true
            //

            if (BrushLock.ShareCount() > 0)
            {
                ((PBRUSH)pobj)->AttrFlags(ATTR_TO_BE_DELETED);
                bDelete = FALSE;
            }
            else if (pUser != (PBRUSHATTR)NULL)
            {
                if (!(pUser->AttrFlags & ATTR_CACHED))
                {
                    BOOL bPen = ((PPEN)pobj)->bIsPen();
                    INT iType = LO_TYPE(hbrush);

                    #if DBG

                        //
                        // make sure handle type agrees with bPen
                        //

                        if (bPen)
                        {

                            ASSERTGDI(((iType == LO_PEN_TYPE) || (iType == LO_EXTPEN_TYPE)),
                                      "bDeleteBrush Error: PEN TYPE NOT LO_PEN OR LO_EXTPEN");
                        }
                        else
                        {
                            ASSERTGDI((iType == LO_BRUSH_TYPE),
                                      "bDeleteBrush error: BRUSH type not LO_BRUSH_TYPE");
                        }

                    #endif

                    //
                    // try to cache the solid brush
                    // don't cache LO_EXTPEN_TYPE
                    //

                    if ((((PBRUSH)pobj)->flAttrs() & BR_IS_SOLID) &&
                        (!bPen || iType != LO_EXTPEN_TYPE))
                    {
                    BOOL bStatus;

                    bStatus = bPEBCacheHandle(hbrush,bPen?PenHandle:BrushHandle,(POBJECTATTR)pUser,(PENTRY)BrushLock.pentry());
                    if (bStatus)
                    {
                        bDelete = FALSE;
                    }
                }
                }
                else
                {
                    //
                    // brush is already cached
                    //

                    WARNING1("Trying to delete brush marked as cached\n");

                    bDelete = FALSE;
                }
            }

            if (bDelete)
            {
                if (bMakeNonStock = ((PBRUSH)pobj)->bIsMakeNonStock())
                {
                    ((PBRUSH)pobj)->vClearMakeNonStock();
                }
            }

            BrushLock.vUnlock();
        }
    }

    if (bDelete)
    {
        if (bMakeNonStock)
        {
            STOCKINFO("Brush(%p) is marked MakeNonStock. Doing it\n", hbrush);
            if(!GreMakeBrushNonStock(hbrush))
                STOCKWARNING("GreMakeBrushNonStock (%p) failed\n", hbrush);
        }

        //
        // Try and remove handle from Hmgr.  This will fail if the brush
        // is locked down on any threads or if it has been marked global
        // or undeletable.
        //

        pbp.pbr = (PBRUSH) HmgRemoveObject((HOBJ)hbrush, 0, 0, FALSE, BRUSH_TYPE);


        if (pbp.pbr!= NULL)
        {
            //
            // Free the style array memory if there is some and it's
            // not pointing to our stock default styles:
            //

            if (pbp.pbr->bIsPen())
            {
                if ((pbp.ppen->pstyle() != (PFLOAT_LONG) NULL) &&
                    !pbp.ppen->bIsDefaultStyle())
                {
                    //
                    // We don't set the field to NULL since this brush
                    // is on it's way out.
                    //

                    VFREEMEM(pbp.ppen->pstyle());
                }
            }

            //
            // Free the bitmap pattern in the brush.
            //

            if (pbp.pbr->hbmPattern())
            {
                //
                // We don't set the field to NULL since this brush
                // is on it's way out.
                //

                BOOL bTemp = bDeleteSurface((HSURF)pbp.pbr->hbmPattern());

                ASSERTGDI(bTemp, "ERROR How could pattern brush failed deletion?");
            }

            //
            // Un-reference count the realization cached in the logical brush,
            // if any. We don't have to worry about anyone else being in the
            // middle of trying to cache a realization for this brush because
            // we have removed it from Hmgr and noone else has it locked down.
            // We only have to do this if there is a cached realization and the
            // brush is non-solid.
            //

            if ((pbp.pbr->crFore() != BO_NOTCACHED) &&
                !pbp.pbr->bCachedIsSolid())
            {
                ASSERTGDI(pbp.pbr->ulRealization() != NULL,
                          "ERROR ulRealization() is NULL");

                ((PRBRUSH)pbp.pbr->ulRealization())->vRemoveRef(
                        pbp.pbr->bIsEngine() ? RB_ENGINE : RB_DRIVER);
            }

            //
            // Brush is DIB pattern ? if so we may need to free ICM DIBs
            //

            if (pbp.pbr->flAttrs() & BR_IS_DIB)
            {
                //
                // Free cached color translated ICM DIBs.
                //
                pbp.pbr->vDeleteIcmDIBs();
            }

            FREEOBJ(pbp.pbr, BRUSH_TYPE);

            //
            // free pUser
            //

            if (!bCleanup && (pUser != (PBRUSHATTR)NULL))
            {
                HmgFreeObjectAttr((POBJECTATTR)pUser);
            }
        }
        else
        {
            //
            // Under Win31 deleting stock objects returns True.
            //

            BRUSHSELOBJ bo(hbrush);

            if (!bo.bValid() || !bo.bIsGlobal())
                bReturn = FALSE;
        }

    }

    return(bReturn);
}

/******************************Public*Routine******************************\
* GreSetBrushGlobal
*
* Sets the brush to be a global one.
*
\**************************************************************************/

void
GreSetBrushGlobal(HBRUSH hbr)
{
    BRUSHSELOBJ ebo(hbr);

    if (ebo.bValid())
    {
        ebo.vGlobal();
    }
}


/******************************Public*Routine******************************\
* GreMakeBrushStock
*
* Make the brush a stock brush.
*
\**************************************************************************/
HBRUSH
GreMakeBrushStock(HBRUSH hbr)
{
    BRUSHSELOBJAPI ebo(hbr);
    HANDLE bRet = 0;
    BOOL bHandleModified = TRUE;

    // Can make the brush a stock brush only when:
    //     (1) It is valid 
    //     (2) Its not global already (i.e already stock)
    //     (3) Its not a DIBSection based brush. 
    //     (4) Its not selected into any DC already.

    if (!ebo.bValid() || ebo.bIsGlobal() || ebo.pbrush()->cShareLockGet() > 0)
    {
        STOCKWARNING("GreMakeBrushStock (%p) invalid/global/selected\n",hbr);
        return (HBRUSH)0;
    }

    bRet = (HANDLE)((ULONG_PTR)hbr | GDISTOCKOBJ);

    if (InterlockedDecrement(&gStockBrushFree) >= 0 &&
        GreSetBrushOwner((HBRUSH)hbr,OBJECT_OWNER_PUBLIC) &&
        (bHandleModified = HmgLockAndModifyHandleType((HOBJ)bRet)))
    {
        ebo.pbrush()->flAttrs(ebo.pbrush()->flAttrs() | BR_IS_GLOBAL);
        return (HBRUSH)bRet;
    }
    else
    {
        if (!bHandleModified)
            GreSetBrushOwner((HBRUSH)hbr,OBJECT_OWNER_CURRENT);

        STOCKWARNING("GreMakeBrushStock (%p) Count/GreSetBrushOwner/ModifyH failed\n",bRet);
        InterlockedIncrement(&gStockBrushFree);
        bRet = 0;
    }

    return (HBRUSH)bRet;
}

/******************************Public*Routine******************************\
* GreMakeBrushNonStock
*
* Makes the brush a non stock brush
*
\**************************************************************************/
HBRUSH
GreMakeBrushNonStock(HBRUSH hbr)
{
    HANDLE bRet = 0;
    BRUSHSELOBJAPI ebo(hbr);

    // Can make a stock brush non stock only when
    //     (1) It is valid
    //     (2) It is a global brush
    //     (3) It is not a Fixed stock brush
    if (ebo.bValid() && ebo.bIsGlobal() && !ebo.pbrush()->bIsFixedStock())
    {
        bRet = (HANDLE)((ULONG_PTR)hbr & ~GDISTOCKOBJ);
        if (ebo.pbrush()->cShareLockGet() > 0)
        {
            // The brush has more than one share lock. This means it will need
            // to be lazy deleted.
            ebo.pbrush()->vSetMakeNonStock();

            STOCKINFO("GreMakeBrushNonStock (%p) is selected. Delay it\n", hbr);
        }
        else if(HmgLockAndModifyHandleType((HOBJ)bRet))
        {
            ebo.pbrush()->flAttrs(ebo.pbrush()->flAttrs() & ~BR_IS_GLOBAL);
            if(!GreSetBrushOwner((HBRUSH)bRet,OBJECT_OWNER_CURRENT))
            {
                bRet = 0;
                STOCKWARNING("GreMakeBrushNonStock (%p) GreSetBrushOwner failed\n", bRet);
            }
            else
            {
                InterlockedIncrement(&gStockBrushFree);
            }
        }
        else
        {
            bRet = 0;
        }
    }
    return (HBRUSH)bRet;
}

/******************************Public*Routine******************************\
* GreSetBrushOwner
*
* Sets the brush owner.
*
\**************************************************************************/


BOOL
GreSetBrushOwner(
    HBRUSH hbr,
    W32PID lPid
    )
{
    // If it is a global brush which by design are public we dont need to
    // do anything.
    {
        BRUSHSELOBJ ebo(hbr);

        if (ebo.bValid())
        {
            if (ebo.bIsGlobal())
                return TRUE;
        }
    }

    BOOL bStatus = FALSE;
    PBRUSHATTR pBrushattr = NULL;
    PENTRY pentry;
    UINT uiIndex = (UINT) HmgIfromH(hbr);

    if (uiIndex < gcMaxHmgr)
    {
        pentry = &gpentHmgr[uiIndex];

        if (lPid == OBJECT_OWNER_CURRENT)
        {
            pBrushattr = (PBRUSHATTR)HmgAllocateObjectAttr();
        } 

        //
        // Accquire handle lock. Don't check PID here because owner could
        // be NONE, not PUBLIC
        //

        HANDLELOCK HandleLock(pentry, FALSE);

        if (HandleLock.bValid())
        {
            POBJ pobj = pentry->einfo.pobj;

            if ((pentry->Objt == BRUSH_TYPE) && (pentry->FullUnique== HmgUfromH(hbr)))
            {
                PBRUSH pBrush = (PBRUSH)pobj;

                if ((pobj->cExclusiveLock == 0) ||
                    (pobj->Tid == (PW32THREAD)PsGetCurrentThread()))
                {
                    //
                    // Handle is locked. It is illegal to accquire the hmgr
                    // resource when a handle is locked.
                    //

                    if ((lPid == OBJECT_OWNER_NONE) ||
                        (lPid == OBJECT_OWNER_PUBLIC))
                    {
                        //
                        // free PBRUSHATTR if PID matches current process
                        // transfer brushattributes to kernel mode.

                        if (HandleLock.Pid() == W32GetCurrentPID())
                        {
                            //
                            // If user mode BRUSHATTR is allocated for this
                            // brush
                            //

                            if (pBrush->pBrushattr() != &pBrush->_Brushattr)
                            {
                                // Copy pBrushattr() to _BrushAttr
                                pBrush->_Brushattr = *(pBrush->pBrushattr());
                                // Free BRUSHATTR at bottom of function
                                pBrushattr = pBrush->pBrushattr();
                                // Set pBrushAttr to point to internal
                                pBrush->pBrushattr(&pBrush->_Brushattr);
                                // Clear entry
                                pentry->pUser = NULL;
                            }

                            // Set Brush owner to NONE or PUBLIC
                            HandleLock.Pid(lPid);
                            // dec process handle count
                            HmgDecProcessHandleCount(W32GetCurrentPID());

                            bStatus = TRUE;

                        }
                        else if (HandleLock.Pid() == OBJECT_OWNER_NONE)
                        {
                            // Allow to set from NONE to PUBLIC or NONE
                            HandleLock.Pid(lPid);

                            bStatus = TRUE;

                        }

                        //
                        // Move bitmap owner if needed. No need to do this if
                        // we are doing OBJECT_OWNER_NONE.
                        //

                        if (bStatus && lPid == OBJECT_OWNER_PUBLIC)
                        {
                            if (pBrush->hbmPattern() != (HBITMAP)NULL)
                            {
                                GreSetBitmapOwner(pBrush->hbmPattern(), OBJECT_OWNER_PUBLIC);
                            }
                        }
                    }
                    else if (lPid == OBJECT_OWNER_CURRENT)
                    {
                        //
                        // can only set to OBJECT_OWNER_CURRENT if Brush is
                        // not owned, or already owned by current pid.
                        //

                        lPid = W32GetCurrentPID();

                        if (HandleLock.Pid() == lPid ||
                            HandleLock.Pid() == OBJECT_OWNER_NONE ||
                            HandleLock.Pid() == OBJECT_OWNER_PUBLIC)
                        {
                            BOOL bIncHandleCount = FALSE;

                            bStatus = TRUE;

                            // only inc handle count if assigning new pid
                            if (HandleLock.Pid() != lPid)
                            {
                                // dont check quota for Brushes. ???
                                if (HmgIncProcessHandleCount(lPid,BRUSH_TYPE))
                                    bIncHandleCount = TRUE;
                            }

                            //
                            // Check if user object already allocated for this
                            // handle
                            //

                            if (pentry->pUser == NULL)
                            {
                                if (pBrushattr != NULL)
                                {
                                    // Set BrushAttr pointer
                                    pBrush->pBrushattr(pBrushattr);
                                    // Set pUser in ENTRY
                                    pentry->pUser = pBrushattr;
                                    // copy clean brush attrs
                                    *pBrushattr = pBrush->_Brushattr;
                                    // Set pBrushattr to NULL so it is not freed
                                    pBrushattr = NULL;
                                }
                                else
                                {
                                    WARNING("GreSetBrushOwner failed - No BRUSHATTR available");

                                    bStatus = FALSE;

                                    // reduce handle quota count
                                    if (bIncHandleCount)
                                        HmgDecProcessHandleCount(lPid);
                                }
                            }

                            if (bStatus)
                            {
                                // Set new owner
                                HandleLock.Pid(lPid);
                           
                                // 
                                // Move bitmap owner if needed.
                                //
                                if (pBrush->hbmPattern() != (HBITMAP)NULL)
                                {
                                    GreSetBitmapOwner(pBrush->hbmPattern(), OBJECT_OWNER_CURRENT);
                                }
                            }
                        }
                        else
                        {
                            WARNING("GreSetBrushOwner failed, trying to set directly from one PID to another");
                        }
                    }
                    else
                    {
                        WARNING("GreSetBrushOwner failed, bad lPid");
                    }
                }
                else
                {
                    WARNING("GreSetBrushOwner failed - Handle is exclusivly locked");
                }
            }
            else
            {
                WARNING("GreSetBrushOwner failed - bad unique or object type");
            }

            HandleLock.vUnlock();
        }
    }
    else
    {
        WARNING("GtreSetBrushOwner failed - invalid handle index\n");
    }

    // free pBrushattr if needed
    if (pBrushattr)
    {
        HmgFreeObjectAttr((POBJECTATTR)pBrushattr);
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* vFreeOrCacheRbrush
*
* Either frees the current RBRUSH (the one pointed to by the this pointer) or
* puts it in the 1-deep RBRUSH cache, if the cache is empty.
*
* History:
*
*  30-Sep-1996 -by- Tom Zakrajsek [tomzak]
* Fixed it for multi brushes (DDML).
*
*  14-Dec-1993 -by- Michael Abrash [mikeab]
* Wrote it.
\**************************************************************************/

VOID MulDestroyBrushInternal(VOID*);

VOID RBRUSH::vFreeOrCacheRBrush(RBTYPE rbtype)
{
    //
    // If RBRUSH is for UMPD, just free it
    //

    if (bUMPDRBrush())
    {
        EngFreeUserMem(this);
        return;
    }

    PRBRUSH *pprbrush;

    // The bMultiBrush check is only valid for DRIVER realizations.
    // Otherwise, it is assumed false.

    BOOL bMulti = FALSE;

    if (rbtype == RB_DRIVER)
    {
        pprbrush = &gpCachedDbrush;
        bMulti = bMultiBrush();

        if (bMulti)
        {
            PVOID pvRbrush = (PVOID)(((PDBRUSH)this)->aj);
            MulDestroyBrushInternal(pvRbrush);
        }
    }
    else
    {
        pprbrush = &gpCachedEngbrush;
    }

    // If there's already a cached RBRUSH, or this is a DDML brush
    // just free this.

    if ((*pprbrush != NULL) || (bMulti == TRUE))
    {
        VFREEMEM(this);
    }
    else
    {
        PRBRUSH pOldRbrush;

        // There's no cached RBRUSH, and it's not a DDML brush,
        // so cache this one.

        if ((pOldRbrush = (PRBRUSH)
               InterlockedExchangePointer((PVOID *)pprbrush, this))
               != NULL)
        {
            // Before we could cache this one, someone else cached another one,
            // which we just acquired responsibility for, so free it.

            VFREEMEM(pOldRbrush);
        }
    }
}


/******************************Public*Routine******************************\
* BRUSH::hFindIcmDIB
*
*   Search  ICM DIBs associated with brush until a match is found
*
* Arguments:
*
* Return Value:
*
* History:
*
*    9/25/1996 Mark Enstrom [marke]
*
\**************************************************************************/

HBITMAP BRUSH::hFindIcmDIB(HANDLE hcmXform)
{
    ICMMSG(("hFindIcmDIB: FIND ICM DIB \n"));

    if (hcmXform == NULL)
    {
        return _hbmPattern;
    }
    else
    {
        GreAcquireFastMutex(ghfmMemory);

        PICM_DIB_LIST pDIBList = pIcmDIBList();

        while (pDIBList != NULL)
        {
            if (pDIBList->hcmXform == hcmXform)
              {
                GreReleaseFastMutex(ghfmMemory);
                return(pDIBList->hDIB);
            }

            pDIBList = pDIBList->pNext;
        }

        GreReleaseFastMutex(ghfmMemory);

        return(NULL);
    }
}

BOOL BRUSH::bAddIcmDIB(HANDLE hcmXform,HBITMAP hDIB)
{
    ICMMSG(("bAddIcmDIB: ADD ICM DIB \n"));

    BOOL bRet = FALSE;

    //
    // Check current hcmform is not on the list.
    //
    if (hFindIcmDIB(hcmXform))
    {
        ICMMSG(("bAddIcmDIB(): The DIB for hcmXform is exist\n"));

        //
        // hcmXform is exist,
        //
        // Do we need to do delete existing one and insert new one ??
        //
        return (FALSE);
    }

    SURFREF SurfDIB((HSURF) hDIB);

    if (SurfDIB.bValid())
    {
        PICM_DIB_LIST pDIBList = (PICM_DIB_LIST)PALLOCNOZ(sizeof(ICM_DIB_LIST),'ldbG');

        if (pDIBList)
        {
            //
            // Inc. ref. count
            //
            {
                SURFACE *ps = SurfDIB.ps;
                ps->vInc_cRef();
            }

            //
            // Fill DIBList cell.
            //
            pDIBList->hcmXform = hcmXform;
            pDIBList->hDIB     = hDIB;
            pDIBList->pNext    = pIcmDIBList();

            //
            // Updates list.
            //
            GreAcquireFastMutex(ghfmMemory);
            pIcmDIBList(pDIBList);
            GreReleaseFastMutex(ghfmMemory);

            bRet = TRUE;
        }
        else
        {
            bRet = FALSE;
        }
    }

    return(bRet);
}

VOID BRUSH::vDeleteIcmDIBs(VOID)
{
    ICMMSG(("vDeleteIcmDIBs: Free ICM DIB \n"));

    PICM_DIB_LIST pDIBList = pIcmDIBList();

    GreAcquireFastMutex(ghfmMemory);

    while (pDIBList != NULL)
    {
        PICM_DIB_LIST pNext = pDIBList->pNext;
        HSURF hSurf = (HSURF) pDIBList->hDIB;
        BOOL  bValidSurface = FALSE;

        //
        // Dec. ref count, before deleting
        //
        {
            SURFREF SurfDIB(hSurf);
            if (SurfDIB.bValid())
            {
                SURFACE *ps = SurfDIB.ps;
                ps->vDec_cRef();
                bValidSurface = TRUE;
            }
        }

        if (bValidSurface)
        {
            //
            // Delete ICM-ed DIB surface.
            //
            if (!bDeleteSurface((HSURF)pDIBList->hDIB))
            {
                ICMMSG(("vDeleteICMDIBs(): bDeleteSurface is failed\n"));
            }
        }
        else
        {
            ICMMSG(("vDeleteICMDIBs(): Invalid surface\n"));
        }

        //
        // free the cell.
        //
        VFREEMEM(pDIBList);
        pDIBList = pNext;
    }

    GreReleaseFastMutex(ghfmMemory);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\clipline.cxx ===
/******************************Module*Header*******************************\
* Module Name: clipline.cxx
*
* This module handles the clipping of lines to a rectangular region.
*
* Created: 07-Mar-1991 13:31:00
* Author: Eric Kutter [erick]
*
* Copyright (c) 1991-1999 Microsoft Corporation
*
* (General description of its use)
*    Given a dda and region.
*
*    0.  setup dda
*    1.  find first scan
*        if (!scan) exit
*        find first segment
*enter
*        if (done) exit
*    2.  do
*        {
*    2.A.  do
*          {
*    2.A.1.  find end of segment
*    2.A.2.  record segment (check for connection)
*    2.A.3.  advance to next segment
*            if (segment && (out of room))
*                return(TRUE);
*          } while (segment)
*
*    2.C   advance to next scan
*          find first segment
*        } while (scan)
*
*        set done
*
\**************************************************************************/

#include "precomp.hxx"

//#define CLIPDEBUG

#ifdef CLIPDEBUG
FLONG MSGLEVEL  = 5;
#endif

/**************************************************************************\
 *
\**************************************************************************/

#ifdef CLIPDEBUG
VOID XCLIPOBJ::DBGDISPLAYSTATE(PSZ psz)
{
    DbgPrint("\t%s\n",psz);
    DbgPrint("\t\tpcle->ptB = (%ld,%ld), pcle->ptC = (%ld,%ld), pcle->ptF = (%ld,%ld)\n",
              pcle->ptB.x,pcle->ptB.y,pcle->ptC.x,pcle->ptC.y,pcle->ptF.x,pcle->ptF.y);

    DbgPrint("\t\tiWall = %ld, cScans = %ld\n",enmr.iWall, enmr.cScans);
}

VOID XCLIPOBJ::DBGDISPLAYDDA()
{
    DbgPrint("\tDDA: ");
    DbgPrint("\t\tpt0 = (%ld,%ld), pt1 = (%ld,%ld)\n",
             pcle->dda.lX0,pcle->dda.lY0,pcle->dda.lX1,pcle->dda.lY1);
}
#endif

/******************************Member*Function*****************************\
* EPATHOBJ::vUpdateCosmeticStyleState(pso, pla)
*
* Updates the style state when a path is completely clipped away, for
* cosmetic lines.
*
* History:
*  3-Nov-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID EPATHOBJ::vUpdateCosmeticStyleState(SURFACE* pSurf, LINEATTRS* pla)
{
    DDA_CLIPLINE dda;       // For calculating line length in pixels
    ULONG        xStep;     // Advance xStep/xyDensity style units for each
                            //   pel if line is x-styled
    ULONG        yStep;     // Advance yStep/xyDensity units
    ULONG        xyDensity;
    STYLEPOS     spTotal2;  // Twice the sum of the style array

    if (pla->fl & LA_ALTERNATE)
    {
    // Style information for alternate lines is special:

        xStep     = 1;
        yStep     = 1;
        xyDensity = 1;
        spTotal2  = 2;
    }
    else
    {
    // Get styling information about device:

        PDEVOBJ po(pSurf->hdev());

        xStep     = po.xStyleStep();
        yStep     = po.yStyleStep();
        xyDensity = po.denStyleStep();

        PFLOAT_LONG pstyle = pla->pstyle + pla->cstyle;
        spTotal2 = 0;

        while (pstyle > pla->pstyle)
        {
            pstyle--;
            spTotal2 += pstyle->l;
        }

        ASSERTGDI((spTotal2 & ~0x7fffL) == 0, "Style array too long");
        ASSERTGDI(spTotal2 != 0, "Zero style array?");
        ASSERTGDI(xyDensity > 0, "Zero xyDensity?");
        spTotal2 = 2 * spTotal2 * xyDensity;
    }

// Find the beginning of the last subpath in the path:

    PATHRECORD* ppr = ppath->pprlast;
    while (!(ppr->flags & PD_BEGINSUBPATH))
        ppr = ppr->pprprev;

// Initialize the style state appropriately:

    ASSERTGDI((ppr->flags & PD_RESETSTYLE) || (ppr == ppath->pprfirst),
              "Expected PD_RESETSTYLE on subpaths after first");

    STYLEPOS sp = 0;
    if (!(ppr->flags & PD_RESETSTYLE))
    {
        sp = HIWORD(pla->elStyleState.l) * xyDensity
           + LOWORD(pla->elStyleState.l);
    }

    POINTFIX* pptfx0   = &ppr->aptfx[0];
    POINTFIX* pptfx1   = &ppr->aptfx[1];
    POINTFIX* pptfxEnd = &ppr->aptfx[ppr->count];

// Loop through all PATHRECORDs in path:

    while (TRUE)
    {
    // Loop through all points in PATHRECORD:

        while (pptfx1 < pptfxEnd)
        {
            if (dda.bInit(pptfx0, pptfx1))
            {
                STYLEPOS spStyleStep;
                BOOL     bXStyled;
                LONG     lDelta;

            // Determine if x-styled or y-styled:

                FIX dx = ABS(pptfx1->x - pptfx0->x);
                FIX dy = ABS(pptfx1->y - pptfx0->y);

                if (xStep == yStep)
                    bXStyled = (dx >= dy);
                else
                {
                    bXStyled = UInt32x32To64(xStep,dx) >= UInt32x32To64(yStep,dy);
                }

            // Calculate new style state at the end of this line:

                if ((bXStyled  &&  dda.bXMajor()) ||
                    (!bXStyled && !dda.bXMajor()))
                {
                    spStyleStep = xStep;
                    lDelta      = dda.lX1 - dda.lX0 + 1;
                }
                else
                {
                    spStyleStep = yStep;
                    lDelta      = dda.lY1 - dda.lY0 + 1;
                }

                ASSERTGDI(lDelta > 0, "Expected positive lDelta");

                if ((lDelta & ~0xffffL) == 0)
                {
                    sp += lDelta * spStyleStep;
                    if (sp >= spTotal2)
                        sp %= spTotal2;
                }
                else
                {
                    ULONGLONG euq = UInt32x32To64((ULONG) lDelta, (ULONG) spStyleStep)
                                   + (ULONGLONG) sp;
                    DIVREM(euq,(ULONG) spTotal2, (ULONG*) &sp);
                }
            }

            pptfx0 = pptfx1;
            pptfx1++;
        }

        ppr = ppr->pprnext;
        if (ppr == (PATHRECORD*) NULL)
            break;

        pptfx1   = &ppr->aptfx[0];
        pptfxEnd = &ppr->aptfx[ppr->count];
    }

    pla->elStyleState.l = MAKELONG(sp % xyDensity, sp / xyDensity);
}

/******************************Member*Function*****************************\
* VOID XCLIPOBJ::vUpdateStyleState()
*
* Updates the style state (spStyleEnd) for the end of the current line.
*
* History:
*  20-Feb-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID XCLIPOBJ::vUpdateStyleState()
{
    BOOL     bXStyled;
    LONG     lDelta;        // Length of line in style-major direction
    STYLEPOS spStyleStep;   // Step size for style-major direction of line

    {
    // Determine if x-styled or y-styled

        FIX dx = ABS(pcle->ptfx0.x - pcle->pptfx1->x);
        FIX dy = ABS(pcle->ptfx0.y - pcle->pptfx1->y);

        if (pcle->xStep == pcle->yStep)
            bXStyled = (dx >= dy);
        else
        {
            bXStyled = UInt32x32To64(pcle->xStep, dx) >= UInt32x32To64(pcle->yStep, dy);
        }
    }

// Now calculate new style state at the end of this line:

    pcle->spStyleEnd = pcle->spStyleStart;
    ASSERTGDI(pcle->spStyleEnd >= 0, "Negative style state");

    if (bXStyled)
    {
        spStyleStep = pcle->xStep;
        lDelta = ABS(pcle->lX1 - pcle->lX0) + 1;
    }
    else
    {
        spStyleStep = pcle->yStep;
        lDelta = ABS(pcle->lY1 - pcle->lY0) + 1;
    }

    if ((lDelta & ~0xffffL) == 0)
    {
        pcle->spStyleEnd += lDelta * spStyleStep;
        if (pcle->spStyleEnd >= pcle->spTotal2)
            pcle->spStyleEnd %= pcle->spTotal2;
    }
    else
    {
        WARNING("Long style state comp");

        ULONGLONG euq = UInt32x32To64((ULONG) lDelta, (ULONG) spStyleStep)
                        + (ULONGLONG) pcle->spStyleEnd;
        DIVREM(euq, pcle->spTotal2, (PULONG) &pcle->spStyleEnd);
    }
}

/******************************Member*Function*****************************\
* BOOL XCLIPOBJ::bEnumStartLine
*
* History:
*  20-Feb-1992 -by- J. Andrew Goossen [andrewgo]
* Adding styling support.
*
*  22-Mar-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL XCLIPOBJ::bEnumStartLine(
    FLONG    flPath)
{
    ASSERTGDI((PD_ALL & CLO_ALL) == 0,"PD_ALL and CLIPOBJ_ALL != 0\n");

// reset all flags except CLO_PATHDONE.

    pcle->fl = (pcle->fl & CLO_PATHDONE) | flPath;

// initialize the dda

    if (!pcle->dda.bInit(&pcle->ptfx0,pcle->pptfx1))
    {
        vSetLineDone();
        return(FALSE);
    }

    pcle->lX0 = pcle->dda.lX0;
    pcle->lY0 = pcle->dda.lY0;
    pcle->lX1 = pcle->dda.lX1;
    pcle->lY1 = pcle->dda.lY1;

    pcle->dda.vUnflip(&pcle->lX0, &pcle->lY0);
    pcle->dda.vUnflip(&pcle->lX1, &pcle->lY1);

// if this is the first line of the sub path

    if (pcle->fl & PD_BEGINSUBPATH)
    {
        pcle->ptfxStartSub = pcle->ptfx0;
    }

    if (bStyling())
    {
    // the style state at the start of this line is the same as the style
    // state for the end of the previous line, unless told differently:

        pcle->spStyleStart = pcle->spStyleEnd;
        if (pcle->fl & PD_RESETSTYLE)
        {
            pcle->spStyleStart = 0;
        }

    // calculate style state at end of this line:

        vUpdateStyleState();
    }

    return(TRUE);
}

/******************************Member*Function*****************************\
* BOOL XCLIPOBJ::bRecordSegment()
*
*   Find the exit point of the current segment and record the run.  If there
*   is not enough room to record the run, return false.
*
* On Entry:
*
*   guaranteed intersection with segment
*
*   enmr.pscn   - current scan
*   ptB         - entry point into segment
*   ptE,ptF     - exit intersection from scan
*
* On Exit:
*
*   if room to record the run, return TRUE otherwise return false.
*
*   iC          - exiting index from segment
*
* History:
*  11-Mar-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

// This is inline since it gets called from only one place:

inline BOOL XCLIPOBJ::bRecordSegment()
{
    enmr.iWall += enmr.iOff;

    LONG x = xWall(0);

// if line intersects wall before exits scan...

    if (bLeftToRight() == (x > pcle->ptE.x))
    {
    // line exits scan before intersecting next wall...

        return(bRecordRun(pcle->iE));
    }
    else
    {
        bIntersectWall(x, &pcle->ptC, NULL, &pcle->iC);

        return(bRecordRun(pcle->iC));
    }
}

/******************************Member*Function*****************************\
* BOOL XCLIPOBJ::bSetup()
*
*   If this is the first call for a line, setup the enumeration data structure.
*   The first point may need adjusting if the previous line of the sub path
*   ended on the same point this line starts.
*
*   Otherwise, just the temporary data structure needs to be initialized as
*   well as recording the last run that wouldn't fit in the previous call.
*
*   If this is the closing line of a sub path, the last point might need to
*   be adjusted if it lies on the first point of the first line of the
*   sub-path.
*
* On Exit:
*
*   bRecordSegment() needs to be called to record the current segment.
*
*   true        - if segment found
*
*   ptB,iStart  - begining of current segment
*   ptE,ptF,iE  - intersection leaving previous scan or first point.
*   pscn        - first scan to be processed.
*
* History:
*  07-Mar-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL XCLIPOBJ::bSetup()
{
// setup CLIPOBJ fields
// Is this the first call for this line

    if (!bRecordPending())       // First call
    {
    // init pclt variables

    // setup CLIPOBJ fields

        pcle->iE = -1;       // last index of previous run

        vSetLeftToRight(pcle->lX0 <= pcle->lX1);

        if (pcle->lY0 <= pcle->lY1)
            pcle->fl |= CLO_TOPTOBOTTOM;

    // Check if we have to further clip to the rclBounds (it would be
    // nice to have a flag in the CLIPOBJ telling us that we also have
    // to clip the rclBounds...)

        if ((pcle->lY0 < rclBounds.top     && pcle->lY1 < rclBounds.top) ||
            (pcle->lY0 >= rclBounds.bottom && pcle->lY1 >= rclBounds.bottom))
            return(FALSE);

    // Calculate the intersections of the line with rclBounds:

        if (bTopToBottom())
        {
            if (pcle->lY0 < rclBounds.top)
            {
                POINTL ptlTop;
                vIntersectScan(rclBounds.top, NULL, &ptlTop, &pcle->iE);
                pcle->lX0 = ptlTop.x;
                pcle->lY0 = ptlTop.y;
                ASSERTGDI(pcle->lY0 == rclBounds.top, "TtoB top wrong");
            }

            if (pcle->lY1 >= rclBounds.bottom)
            {
                POINTL ptlBottom;
                LONG   iEnd;
                vIntersectScan(rclBounds.bottom, &ptlBottom, NULL, &iEnd);
                pcle->lX1 = ptlBottom.x;
                pcle->lY1 = ptlBottom.y;
                ASSERTGDI(pcle->lY1 == rclBounds.bottom - 1, "TtoB bottom wrong");
            }
        }
        else
        {
            if (pcle->lY1 < rclBounds.top)
            {
                POINTL ptlTop;
                LONG   iEnd;
                vIntersectScan(rclBounds.top, &ptlTop, NULL, &iEnd);
                pcle->lX1 = ptlTop.x;
                pcle->lY1 = ptlTop.y;
                ASSERTGDI(pcle->lY1 == rclBounds.top, "BtoT top wrong");
            }

            if (pcle->lY0 >= rclBounds.bottom)
            {
                POINTL ptlBottom;
                vIntersectScan(rclBounds.bottom, NULL, &ptlBottom, &pcle->iE);
                pcle->lX0 = ptlBottom.x;
                pcle->lY0 = ptlBottom.y;
                ASSERTGDI(pcle->lY0 == rclBounds.bottom - 1, "BtoT bottom wrong");
            }
        }

    // Check if we have to further clip to the rclBounds:

        if ((pcle->lX0 < rclBounds.left   && pcle->lX1 < rclBounds.left) ||
            (pcle->lX0 >= rclBounds.right && pcle->lX1 >= rclBounds.right))
            return(FALSE);

        if (bLeftToRight())
        {
            if (pcle->lX0 < rclBounds.left)
            {
                POINTL ptlLeft;
                bIntersectWall(rclBounds.left, NULL, &ptlLeft, &pcle->iE);
                pcle->lX0 = ptlLeft.x;
                pcle->lY0 = ptlLeft.y;
                ASSERTGDI(pcle->lX0 == rclBounds.left, "LtoR left wrong");
            }

            if (pcle->lX1 >= rclBounds.right)
            {
                POINTL ptlRight;
                LONG   iEnd;
                bIntersectWall(rclBounds.right, &ptlRight, NULL, &iEnd);
                pcle->lX1 = ptlRight.x;
                pcle->lY1 = ptlRight.y;
                ASSERTGDI(pcle->lX1 == rclBounds.right - 1, "LtoR right wrong");
            }
        }
        else
        {
            if (pcle->lX1 < rclBounds.left)
            {
                POINTL ptlLeft;
                LONG   iEnd;
                bIntersectWall(rclBounds.left, &ptlLeft, NULL, &iEnd);
                pcle->lX1 = ptlLeft.x;
                pcle->lY1 = ptlLeft.y;
                ASSERTGDI(pcle->lX1 == rclBounds.left, "RtoL left wrong");
            }

            if (pcle->lX0 >= rclBounds.right)
            {
                POINTL ptlRight;
                bIntersectWall(rclBounds.right, NULL, &ptlRight, &pcle->iE);
                pcle->lX0 = ptlRight.x;
                pcle->lY0 = ptlRight.y;
                ASSERTGDI(pcle->lX0 == rclBounds.right - 1, "RtoL right wrong");
            }
        }

        ASSERTGDI(pcle->lY0 >= rclBounds.top  && pcle->lY0 < rclBounds.bottom &&
                  pcle->lY1 >= rclBounds.top  && pcle->lY1 < rclBounds.bottom &&
                  pcle->lX0 >= rclBounds.left && pcle->lX0 < rclBounds.right  &&
                  pcle->lX1 >= rclBounds.left && pcle->lX1 < rclBounds.right,
                  "Line out of rclBounds");

        pcle->ptF.x = pcle->lX0;
        pcle->ptF.y = pcle->lY0;

    // setup enmr fields

        vSetRecordPending();

    // find first segment of first scan containing runs

        if (!bFindFirstScan())
            return(FALSE);
    }
    else                          // following calls for this segment
    {
    // record the segment that wouldn't fit last time.
    // guaranteed success!

        bRecordRun(pcle->iC);

    // find the next segment to get back in sync with the enumeration.
    // if there is no next segment in this scan, find the next scan.
    // if there is no next scan containing any segments, return false.

        if (bFindNextSegment())
            return(TRUE);

    // Are there more scans?

        if (!bFindNextScan())
            return(FALSE);
    }

// need to find a segment.  If no segment found in scan, goto the next scan.

    do
    {
        if (bFindFirstSegment())
            return(TRUE);

    } while (bFindNextScan());

// didn't find any.  Done with this line.

    return(FALSE);
}

/******************************Member*Function*****************************\
* BOOL XCLIPOBJ::bEnumLine()
*
*   Fill the CLIPLINE data structure with line segments for the current line.
*   If there are too many segments to fit in the structure, TRUE is returned
*   and this routine must be called again with the same line.  Each new line
*   must first be initialized by calling vEnumStartLine.
*
* {
*     1.  if (done) exit
*
*     2.  do
*         {
*     2.A.  do
*           {
*     2.A.1.  find end of segment
*     2.A.2.  record segment
*     2.A.3.  advance to next segment
*             if (segment && (out of room))
*                 return(TRUE);
*     2.A   } while (segments)
*
*     2.C   advance to next scan
*     2.D   find first segment
*     2.  } while (scan)
*     3.  return(FALSE)
* }
*
* RETURN:
*   TRUE    - there are more segments and this routine should be called again
*   FALSE   - no more segments.  Use vEnumStartLine to prepare next line.
*
* History:
*  07-Mar-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL XCLIPOBJ::bEnumLine(
    ULONG cj,
    PCLIPLINE pcl)
{
    pcl->ptfxA       = pcle->ptfx0;
    pcl->ptfxB       = *pcle->pptfx1;
    pcl->c           = 0;

    if (bStyling())
        pcl->lStyleState = lGetStyleState(pcle->spStyleStart);

// if we have already completed the enumeration

    if (bLineDone())
        return(FALSE);

// setup the run structure

    pcle->cMaxRuns  = (cj - offsetof(CLIPLINE,arun)) / sizeof(RUN);
    pcle->prun      = pcl->arun;
    pcle->pcRuns    = &pcl->c;
    pcle->iPrevStop = LONG_MAX; // If this is a valid stop, there is no way there
                                // could be anothr run after it anyways.

// there must be room for at least 1 segment, otherwise tell them we are done.

    if (pcle->cMaxRuns == 0)
        return(FALSE);

// setup intial state.

    if (!bSetup())
    {
        vSetLineDone();
        return(FALSE);
    }

// enumerate through the scans and segments

    for (;;)
    {
    // enumerate through the segments

        do
        {
            if (!bRecordSegment())
                return(TRUE);

        } while (bFindNextSegment());

    // find the next scan with intersecting segments

        do
        {
            if (!bFindNextScan())
            {
                vSetLineDone();
                return(FALSE);
            }
        } while (!bFindFirstSegment());
    }
}

/******************************Public*Routine******************************\
* BOOL XCLIPOBJ::bFindFirstScan()
*
*   if (topdown)
*   {
*       find first scan ending below first point
*       return(does the line intersect the scan)
*   }
*   else (bottom up
*   {
*       find first scan ending above point
*       return(does the line intersect the scan)
*   }
*
* On Entry:
*   pcle->ptF.y - first Y coordinate of line
*   pcle->lY1   - last Y coordinate of line
*
* On Exit:
*   enmr.pscn   - current scan
*   enmr.cScans - number of scans still to traverse
*
* History:
*  07-Mar-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL XCLIPOBJ::bFindFirstScan()
{
    if (prgn->cScans <= 2)          // empty region
        return(FALSE);

    enmr.cScans = prgn->cScans - 2; // ignore first and last (no walls)

// Start from the top or bottom?

    if (bTopToBottom())
    {
        enmr.pscn = pscnGet(prgn->pscnHead());    // ignore first scan (empty)

    // while the scans are above the start of the line

        while (bEmptyScan() || (enmr.pscn->yBottom <= pcle->ptF.y))
        {
            if (--enmr.cScans == 0)
                return(FALSE);

            enmr.pscn = pscnGet(enmr.pscn);
        }

        return(enmr.pscn->yTop <= pcle->lY1);      // is the line between scans
    }
    else // bottom up
    {
        enmr.pscn = pscnGot(pscnGot(prgn->pscnTail));  // ignore last scan

    // while the scans are below the start of the line

        while (bEmptyScan() || (enmr.pscn->yTop > pcle->ptF.y))
        {
            if (--enmr.cScans == 0)
                return(FALSE);

            enmr.pscn = pscnGot(enmr.pscn);
        }

        return(enmr.pscn->yBottom > pcle->lY1);
    }
}

/******************************Member*Function*****************************\
* BOOL XCLIPOBJ::bFindNextScan()
*
* On Entry:
*
*   enmr.pscn   - last scan searched
*   enmr.cScans - total remaining scans (some may be empty)
*
* On Exit:
*
*   if there are more scans to search, return true with:
*   enmr.pscn   - next scan to search
*
* History:
*  09-Mar-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL XCLIPOBJ::bFindNextScan()
{
// Start from the top or bottom?

    if (bTopToBottom())
    {
        do {
            if (enmr.cScans == 1)               // already on last scan
                return(FALSE);

            --enmr.cScans;

            enmr.pscn = pscnGet(enmr.pscn);

            if (enmr.pscn->yTop > pcle->lY1)    // does line end before scan?
                return(FALSE);

        } while (bEmptyScan());
    }
    else // bottom to top
    {
        do {
            if (enmr.cScans == 1)               // already on last scan
                return(FALSE);

            --enmr.cScans;

            enmr.pscn = pscnGot(enmr.pscn);

            if (enmr.pscn->yBottom <= pcle->lY1)// does line end before scan?
                return(FALSE);

        } while (bEmptyScan());
    }

    return(TRUE);
}

/******************************Member*Function*****************************\
* BOOL XCLIPOBJ::bFindFirstSegment()
*
* On Entry:
*
*   enmr.pscn   - current scan
*   ptF         - exit point from previous scan containing segments.  For
*                 the first scan, this is lX0,lY0.
* On Exit:
*
*   if no intersections, return FALSE, otherwise
*
*   ptB,iStart  - intersection entering first segment
*   ptE,ptF,iE  - intersection exiting scan
*   xWall(0)    - last wall intersected
*
* History:
*  08-Mar-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL XCLIPOBJ::bFindFirstSegment()
{
// setup the intersections entering and leaving the current scan.

    pcle->ptB = pcle->ptF;

    if (bTopToBottom())
    {
        pcle->lYEnter = enmr.pscn->yTop;
        pcle->lYLeave = enmr.pscn->yBottom;
    }
    else
    {
        pcle->lYEnter = enmr.pscn->yBottom;
        pcle->lYLeave = enmr.pscn->yTop;
    }

    if (bTopToBottom() == (pcle->ptB.y < pcle->lYEnter))
    {
        vIntersectScan(pcle->lYEnter,NULL,&pcle->ptB,&pcle->iStart);
    }
    else
    {
        pcle->iStart  = pcle->iE;
        pcle->lYEnter = pcle->ptB.y;
    }

    if (bTopToBottom() == (pcle->lY1 >= pcle->lYLeave))
    {
        vIntersectScan(pcle->lYLeave,&pcle->ptE,&pcle->ptF,&pcle->iE);
    }
    else
    {
    // The line ends in this scan:

        pcle->ptE.y   = pcle->lY1;
        pcle->ptE.x   = pcle->lX1;
        pcle->lYLeave = pcle->lY1 + 1;

    // Calculate the iPosition of the line's last pixel in the scan.
    // If we didn't have to take into account rclBounds, this would
    // simply be pcle->iE = pcle->dda.lX1 - pcle->dda.lX0:

    // Unnormalize the (unclipped) start of the line:

        EPOINTL eptlStart(pcle->dda.lX0, pcle->dda.lY0);

        pcle->dda.vUnflip(&eptlStart.x, &eptlStart.y);

    // Compute the length in the line's major direction:

        if (pcle->dda.bDFlip())
            pcle->iE = ABS(pcle->lY1 - eptlStart.y);
        else
            pcle->iE = ABS(pcle->lX1 - eptlStart.x);
    }

// find first wall intersecting line. Do this by means of a binary search

    enmr.iFinal = enmr.pscn->cWalls - 1;
    enmr.iWall  = 0;    // must be 0 for special cases

// Special case if the line enters the scan before the first or after the
// last segment.  This makes the general case much simpler.

    if (pcle->ptB.x >= xWall(enmr.iFinal))
    {
        enmr.iWall = enmr.iFinal;

        if (bLeftToRight())
            return(FALSE);

        enmr.iWall++;
    }
    else if (pcle->ptB.x < xWall(0))
    {
        if (!bLeftToRight())
            return(FALSE);

        enmr.iWall--;
    }
    else
    {
    // if the line starts somewhere in the middle of the scan find the first
    // wall to the right of the entrance via a binary search.

        LONG iLow   = 0;
        LONG iHigh  = enmr.iFinal;

        for (;;)
        {
            enmr.iWall = (iLow + iHigh) / 2;

            if (pcle->ptB.x < xWall(0))   // to the left
            {
            // enters after previous wall?

                if (pcle->ptB.x >= xWall(-1))
                    break;

            // keep searching

                iHigh = enmr.iWall - 1;
            }
            else
            {
            // enters before next wall?

                if (pcle->ptB.x < xWall(1))
                {
                    ++enmr.iWall;
                    break;
                }

            // keep searching

                iLow = enmr.iWall + 1;
            }
        }

    // WARNING! SLEEZY! subtract one if left to right.
    // sets iWall to wall before entering scan.

        enmr.iWall -= bLeftToRight();
    }

// set pcle->ptB to first intersection.  Already set if starting inside segment.
// If we are starting inside a segment, iWall will be odd if we are moving
// right and even if we are moving left.  If we are outside of a segment when
// the scan is entered, compute the intersection with the first wall.

    if (bLeftToRight() == (BOOL)(enmr.iWall & 1))
    {
        enmr.iWall += enmr.iOff;

        LONG x = xWall(0);

        if (bLeftToRight() == (x > pcle->ptE.x))
        {
        // line exits scan before intersecting next wall...

            return(FALSE);
        }

        bIntersectWall(x,NULL,&pcle->ptB,&pcle->iStart);
    }

    return(TRUE);
}

/******************************Member*Function*****************************\
* BOOL XCLIPOBJ::bFindNextSegment()
*
* On Entry:
*
*   ptE,ptF     - intersection exiting scan
*   xWall(0)    - exiting wall of previous segment
*
* On Exit:
*
*   if no intersections, return FALSE, otherwise
*
*   ptB         - intersection entering next segment
*   ptE,ptF     - intersection exiting scan
*   xWall(0)    - exiting wall of new segment
*
* History:
*  12-Mar-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL XCLIPOBJ::bFindNextSegment()
{
// if we are past the last segment...

    if (bLeftToRight())
    {
        if (enmr.iWall >= enmr.iFinal)
            return(FALSE);
    }
    else
    {
        if (enmr.iWall <= 0)
            return(FALSE);
    }

// find the intersection

    enmr.iWall += enmr.iOff;

    LONG x = xWall(0);

    if (bLeftToRight() == (x > pcle->ptE.x))
    {
    // line exits scan before intersecting next wall...

        return(FALSE);
    }

    bIntersectWall(x,NULL,&pcle->ptB,&pcle->iStart);

    return(TRUE);
}

/******************************Member*Function*****************************\
* BOOL XCLIPOBJ::bRecordRun(LONG& iStop)
*
* On Entry:
*
*   pcle->iStart  - index of start - 1
*   iStop   - index of end of run
*
* On Exit:
*
*   iC      - same as iStop if can't record
*
* History:
*  12-Mar-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL XCLIPOBJ::bRecordRun(LONG& iStop)
{
// don't record if going backwards

    if (iStop <= pcle->iStart)
        return(TRUE);

// do we append the run?

    if (pcle->iStart != pcle->iPrevStop)
    {
    // Are we out of room?

        if (*pcle->pcRuns == pcle->cMaxRuns)
        {
            pcle->iC = iStop;
            return(FALSE);
        }

    // set the run

        pcle->prun->iStop  = iStop;
        pcle->prun->iStart = pcle->iStart + 1;

    // increment the count

        (*pcle->pcRuns)++;
        pcle->prun++;
    }
    else // append the run
    {
        ASSERTGDI(*pcle->pcRuns > 0,"CLIPOBJ::bRecordRun,cruns == 0\n");
        pcle->prun[-1].iStop = iStop;
    }

    pcle->iPrevStop = iStop;

    return(TRUE);
}

/******************************Member*Function*****************************\
* VOID XCLIPOBJ::vIntersectScan
*
* On Entry:
*
*   y - y coordinate of scan to intersect
*
* On Exit:
*
*   ppt0 - last point before intersection (may be NULL)
*   ppt1 - first point after intersection
*   pi0  - run position for ppt0.
*          run position for ppt1 = pi0 + 1;
*
* History:
*  27-Mar-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID XCLIPOBJ::vIntersectScan(LONG y, PPOINTL ppt0, PPOINTL ppt1, PLONG pi0)
{
    if (pcle->dda.bVFlip())
        y = -y + 1;

    if (!pcle->dda.bDFlip())
        vIntersectHorizontal(&pcle->dda,y,ppt0,ppt1,pi0);
    else
        vIntersectVertical(&pcle->dda,y,ppt0,ppt1,pi0);
}

/******************************Member*Function*****************************\
* BOOL XCLIPOBJ::bIntersectWall
*
*   Compute the intersection of the line with the current wall + i.
*   The important results are the last pel before the intersection and
*   the first pel after the intersection as well as the run index of the
*   last pel before the intersection.
*
* On Entry:
*
*   x - wall column
*
* On Exit:
*
*   always assumes there will be an intersection with the given wall, so
*   always returns TRUE
*
*   ppt0 - last point before intersection (may be NULL)
*   ppt1 - first point after intersection (may be NULL)
*   pi0  - run position for ppt0.
*          run position for ppt1 = pi0 + 1;
*
* History:
*  27-Mar-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL XCLIPOBJ::bIntersectWall(LONG x, PPOINTL ppt0, PPOINTL ppt1, PLONG pi0)
{
    if (pcle->dda.bHFlip())
        x = -x + 1;

    if (!pcle->dda.bDFlip())
        vIntersectVertical(&pcle->dda,x,ppt0,ppt1,pi0);
    else
        vIntersectHorizontal(&pcle->dda,x,ppt0,ppt1,pi0);

    return(TRUE);
}

/******************************Public*Routine******************************\
* LONG yCompute(x)
*
* For the given column x, calculate the y-coordinate of the pixel
* on the line that will be lit:

* History:
*  27-Aug-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

inline LONG DDA_CLIPLINE::yCompute(LONG x)
{
    LONGLONG eq = Int32x32To64((LONG) dN, x - ptlOrg.x) + eqGamma;
    ASSERTGDI(eq >= 0, "Negative x not expected");
    return((LONG) DIV(eq,dM) + ptlOrg.y);
}

/******************************Public*Routine******************************\
* LONG xCompute(y)
*
* For the given row y, calculates the x-coordinate of the rightmost
* pixel that will be lit on the line:
*
* History:
*  27-Aug-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

inline LONG DDA_CLIPLINE::xCompute(LONG y)
{
    LONGLONG eq = Int32x32To64((LONG) dM, y - ptlOrg.y + 1) - eqGamma - 1;
    ASSERTGDI(eq >= 0, "Negative y not expected");
    return((LONG) DIV(eq,dN) + ptlOrg.x);
}

/******************************Public*Routine******************************\
* VOID vIntersectHorizontal(pdda, yBorder, ppt0, ppt1, pi0)
*
* Calculates ppt0, the last point on the line given by pdda before a
* horizontal bound at yBorder.  Also calculates ppt1, the next point on
* the line that would be lit.
*
* History:
*  27-Aug-1992 -by- J. Andrew Goossen [andrewgo]
* Rewrote it.
*
*  12-Mar-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vIntersectHorizontal(
    DDA_CLIPLINE* pdda,
    LONG          yBorder,
    POINTL*       ppt0,     // may be NULL
    POINTL*       ppt1,     // may be NULL
    LONG*         pi0)
{
    LONG xLast = pdda->xCompute(yBorder - 1);

// calculation

    if (ppt0 != (POINTL*) NULL)
    {
        ppt0->x = xLast;
        ppt0->y = yBorder - 1;
        pdda->vUnflip(&ppt0->x, &ppt0->y);
    }

    if (ppt1 != (POINTL*) NULL)
    {
        ppt1->x = xLast + 1;
        ppt1->y = yBorder;
        pdda->vUnflip(&ppt1->x, &ppt1->y);
    }

    ASSERTGDI(xLast <= pdda->lX1, "xLast out of bounds");

    *pi0 = xLast - pdda->lX0;
}

/******************************Public*Routine******************************\
* VOID vIntersectVertical(pdda, xBorder, ppt0, ppt1, pi0)
*
* Calculates ppt0, the last point on the line given by pdda before a
* vertical bound at xBorder.  Also calculates ppt1, the next point on
* the line that would be lit.
*
* History:
*  27-Aug-1992 -by- J. Andrew Goossen [andrewgo]
* Rewrote it.
*
*  12-Mar-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vIntersectVertical(
    DDA_CLIPLINE* pdda,
    LONG          xBorder,
    POINTL*       ppt0,     // may be NULL
    POINTL*       ppt1,     // may be NULL
    LONG*         pi0)
{
// compute the coordinates and run index

    LONG xLast = xBorder - 1;

    if (ppt0 != (POINTL*) NULL)
    {
        ppt0->x = xBorder - 1;
        ppt0->y = pdda->yCompute(xBorder - 1);
        pdda->vUnflip(&ppt0->x, &ppt0->y);
    }

    if (ppt1 != (POINTL*) NULL)
    {
        ppt1->x = xBorder;
        ppt1->y = pdda->yCompute(xBorder);
        pdda->vUnflip(&ppt1->x, &ppt1->y);
    }

    ASSERTGDI(xLast <= pdda->lX1, "xLast out of bounds");

    *pi0 = xLast - pdda->lX0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\clipobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: clipobj.cxx
*
* Clipping object non-inline methods
*
* Created: 15-Sep-1990 15:25:02
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* XCLIPOBJ::vSetup
*
* Create an XCLIPOBJ.
*
* input:
*
*   prgn_       - region to build clipobj from
*   erclExcl    - Only intrested in the part of the region that intersects this
*   iForcedClip - CLIP_NOFORCE     - will be trivial if erclExcl is fully bounded
*                 CLIP_FORCE       - will never be trivial
*                 CLIP_NOFORCETRIV - will be trivial if single rectangle
*
* output/clipobj:
*
*   iUniq          - iUniq from region
*
*   rclBounds      - bounds of the clipping area
*                    intersection of erclExcl and region bounds.  It may further
*                    be reduced to only bound rectangles that touch erclExcl.
*
*   iDComplexity   - complexity of part of region that intersects drawing
*
*       TRIVIAL    - all parts of erclExcl are visible.  The object may
*                    span multiple scans but is fully contained.
*
*       RECT       - The object (bounded by erclExcl) need only be clipped
*                    against a single rectangle set in rclBounds.
*
*       COMPLEX    - enumeration is needed to get a list of rectangles to clip against
*
*   iFComplexity   - full region complexity, RECT, RECT4, COMPLEX
*
*   iMode          - TC_RECTANGLES - internal storage mode
*
*   fjOptions      - OC_RESERVED - this bit used to be called OC_BANK_CLIP and
*                    is set by banking drivers. This bit has been obsoleted,
*                    but because 4.0 drivers may still set the bit we can't
*                    re-use it for something else.
*
*
*   hidden fields:
*
*   cObj           - number of rectangles that intersect erclExcl
*
* History:
*  06-Oct-1993 -by-  Eric Kutter [erick]
* Update documentation, remove traps, add paths
*
*  24-Jul-1991 -by- Donald Sidoroff [donalds]
* Updated to DDI spec.
*
*  15-Sep-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

#define CMAXOBJ 10

VOID XCLIPOBJ::vSetup(REGION *prgn_, ERECTL& erclExcl, int iForcedClip)
{
// Set up the internal fields

    prgn = prgn_;

// Initialize as many of the CLIPOBJ fields as we can:

    *((ULONG*)&iDComplexity) = 0;   // iDComplexity = DC_TRIVIAL, 
                                    //   iMode = TC_RECTANGLES,
                                    //   fjOptions = 0,
                                    //   iFComplexity = invalid
    rclBounds.bottom         = erclExcl.bottom;
    rclBounds.right          = erclExcl.right;
    rclBounds.top            = erclExcl.top;
    rclBounds.left           = erclExcl.left;
    iUniq                    = prgn->iUnique;

    if ((prgn->sizeRgn <= SINGLE_REGION_SIZE)  &&
        (rclBounds.left   >= prgn->rcl.left)   &&
        (rclBounds.top    >= prgn->rcl.top)    &&
        (rclBounds.right  <= prgn->rcl.right)  &&
        (rclBounds.bottom <= prgn->rcl.bottom) &&
        (iForcedClip != CLIP_FORCE))
    {
        // Unfortunately, some callers may give us an empty or crossed
        // 'erclExcl', and we have to watch for that case:

        if ((rclBounds.top  < rclBounds.bottom) &&
            (rclBounds.left < rclBounds.right))
        {

        // This is the trivial acceptance case, which will be the most common
        // case.  The region is a single rectangle that bounds the drawing.
        // We've already set up for trivial clipping.

            return;
        }
    }

// Calculate the intersection of the drawing bounds with the region
// bounds:

    rclBounds.left   = max(rclBounds.left,   prgn->rcl.left);
    rclBounds.top    = max(rclBounds.top,    prgn->rcl.top);
    rclBounds.right  = min(rclBounds.right,  prgn->rcl.right);
    rclBounds.bottom = min(rclBounds.bottom, prgn->rcl.bottom);

    if ((rclBounds.left >= rclBounds.right) ||
        (rclBounds.top  >= rclBounds.bottom))
    {
    // This takes care of the trivial rejection case.  It is the caller's
    // responsibility to again check for this case by calling 'bEmpty'
    // on 'rclBounds' -- in which case, we have to collapse the rectangle:

        rclBounds.left = rclBounds.right;
        return;
    }

    if ((prgn->sizeRgn <= SINGLE_REGION_SIZE) &&
        (iForcedClip != CLIP_FORCE))
    {
    // If the region is a single rectangle, the region bound IS the
    // region, so we're done.  Note that the trivial rejection case
    // may come through this case -- it's the caller's responsibility
    // to check that the rectangle is not empty.

        if (iForcedClip != CLIP_NOFORCETRIV)
            iDComplexity = DC_RECT;

        return;
    }

// Darn, now we have to do some real work.

    ERECTL *percl = (ERECTL *) &rclBounds;

    cObjs   = 0;        // Initialize object count

    if (prgn->sizeRgn > QUANTUM_REGION_SIZE)
        iFComplexity = FC_COMPLEX;
    else
        if (prgn->sizeRgn > SINGLE_REGION_SIZE)
            iFComplexity = FC_RECT4;

// Traverse the scans

    ERECTL  erclAcc(0, 0, 0, 0);            // Accumulate segments here
    PSCAN   pscn = prgn->pscnHead();
    COUNT   cScan = prgn->cScans;
    COUNT   iWall;
    BOOL    bSimple = (iForcedClip != CLIP_FORCE);  // Assume DC_TRIVIAL clipping unless forced

    COUNT   cHit = 0;

// find the first one inside

    while (cScan && (percl->top >= pscn->yBottom))
    {
        pscn = pscnGet(pscn);
        --cScan;
    }

    while (cScan--)
    {
        if (pscn->yTop >= percl->bottom)   // Have we passed the rectangle?
            break;

        BOOL    bBounded = FALSE;       // Assume rectangle is unbounded

        for (iWall = 0; iWall != pscn->cWalls; iWall += 2)
        {
        // If the right edge of the segment is to the left of the rectangle
        // advance to the next scan segment and test again.

            if (pscn->ai_x[iWall + 1].x <= percl->left)
                continue;

        // If the left edge of the segment is to the right of the rectangle
        // goto the next scan.

            if (pscn->ai_x[iWall].x >= percl->right)
                break;

        // Increment count of objects

            cObjs++;

        // this is getting rediculous, we assume it is complex

            if (cObjs >= CMAXOBJ)
            {
                iDComplexity = DC_COMPLEX;
                cObjs = (COUNT)-1;
                return;
            }

        // OK, we now know that SOME part of the rectangle overlaps
        // this scan segment. Find the overlap and accumulate it.

            RECTL   rclTmp;

            rclTmp.left = pscn->ai_x[iWall].x;
            rclTmp.right = pscn->ai_x[iWall + 1].x;
            rclTmp.top = pscn->yTop;
            rclTmp.bottom = pscn->yBottom;

            erclAcc += rclTmp;      // Expand the accumlated rectangle

        // Now see if this rectangle peeks out past the segment.  If
        // it doesn't, then we still might be simply clipped.

            if ((percl->left >= pscn->ai_x[iWall].x) &&
                (percl->right <= pscn->ai_x[iWall + 1].x))
            {
                bBounded = TRUE;
            }
        }

    // If the rectangle was not left/right bounded by some segment in
    // the scan, then this can't be a simple clip case.

        bSimple &= bBounded;

        pscn = pscnGet(pscn);
    }

// Clip the exclusion rectangle against the accumulated rectangle

    *percl *= erclAcc;

    if (!bSimple)
    {
        iDComplexity = (BYTE)(cObjs == 1 ? DC_RECT : DC_COMPLEX);
    }
    else
    {
        if ((iForcedClip == CLIP_NOFORCE) && !percl->bEqual(erclExcl))
            iDComplexity = DC_RECT;
    }
}

/******************************Public*Routine******************************\
* ULONG XCLIPOBJ::cEnumStart(bAll, iType, iDir, cLimit)
*
* Set up the enumerator for the clipping object
*
* History:
*  24-Jul-1991 -by- Donald Sidoroff [donalds]
* Updated to DDI spec.
*
*  19-Sep-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/
extern "C" ULONG CLIPOBJ_cEnumStart(
CLIPOBJ *pco,
BOOL  bAll,
ULONG iType,
ULONG iDir,
ULONG cLimit)
{
    return (*(XCLIPOBJ *)pco).cEnumStart(bAll, iType, iDir, cLimit);
}


ULONG XCLIPOBJ::cEnumStart(
BOOL  bAll,
ULONG iType,
ULONG iDir,
ULONG cLimit)
{
// We may need to merge trapezoid region with the bounding rect if the flag
// indicate so.

// Handle any old direction requests

    if (iDir == CD_ANY)
        iDir = CD_RIGHTDOWN;

// Save the info in the enumerator

    enmr.iType = iType;
    enmr.iDir = iDir;
    enmr.bAll = bAll;

// If we are enumerating the entire region, use the region bounding box
// otherwise use the exclusion rectangle

    if (enmr.bAll)
        enmr.ercl = *((ERECTL *) &prgn->rcl);
    else
    {
        enmr.ercl = *((ERECTL *) &rclBounds);
    }

// Now we have to do some actual work
// Set up top to bottom info

    enmr.cScans = prgn->cScans - 1;
    enmr.yCurr = 0;
    enmr.yFinal = 0;

// Start from the top or bottom?  Also, find the scan before the first scan
// that intersects the rclBounds.  By finding the previous scan, we can let
// the normal enumeration find the first wall.

    PSCAN pscn1;

    if (iDir < CD_RIGHTUP)
    {
    // top to bottom

        enmr.pscn = prgn->pscnHead();
        enmr.yDelta = 1;

        if (!enmr.bAll)
        {
            pscn1 = pscnGet(enmr.pscn);

            while (pscn1->yBottom <= enmr.ercl.top)
            {
                --enmr.cScans;

                if (enmr.cScans == 0)
                    return((ULONG)-1);

                enmr.pscn = pscn1;
                pscn1     = pscnGet(pscn1);
            }
        }
    }
    else
    {
    // bottom to top

        enmr.pscn = pscnGot(prgn->pscnTail);
        enmr.yDelta = -1;

        if (!enmr.bAll)
        {
            pscn1 = pscnGot(enmr.pscn);

            while (pscn1->yTop >= enmr.ercl.bottom)
            {
                --enmr.cScans;

                if (enmr.cScans == 0)
                    return((ULONG)-1);

                enmr.pscn = pscn1;
                pscn1     = pscnGot(pscn1);
            }
        }
    }

// Left to right info

    enmr.iWall = 0;
    enmr.iFinal = 0;

// Going left or right?

    if (iDir & 1)
        enmr.iOff = (COUNT) -2;
    else
        enmr.iOff = 2;

    if (enmr.bAll)
        return(cObjs <= cLimit ? cObjs : (ULONG) -1);

    return((ULONG) -1);
}

/******************************Public*Routine******************************\
* ULONG XCLIPOBJ::cEnum(cj, pv)
*
* Get the next batch of rectangles or trapezoids from the clipping object
*
* History:
*  24-Jul-1991 -by- Donald Sidoroff [donalds]
* Updated to DDI spec.
*
*  15-Sep-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/
extern "C" BOOL CLIPOBJ_bEnum(CLIPOBJ* pco, ULONG cj, ULONG *pv)
{
    return (*(XCLIPOBJ *)pco).bEnum(cj, (VOID *)pv);
}

BOOL XCLIPOBJ::bEnum(ULONG cj,PVOID pv)
{
    // Good old rectangle to rectangle enumeration

    ENUMRECTS *penrc = (ENUMRECTS *) pv;
    RECTL     *prcl = penrc->arcl;

    cj -= offsetof(ENUMRECTS,arcl);

    penrc->c = 0;

    if (enmr.bAll)
    {
        ULONG const RightToLeft = enmr.iDir & 1;
        ULONG const TopToBottom = enmr.iDir < CD_RIGHTUP;
        ULONG RectsWanted = cj / sizeof(RECTL);
        PSCAN pCurrentScan = enmr.pscn;
        COUNT CurrentWall = enmr.iWall;
        COUNT FinalWall = enmr.iFinal;
        int long Offset = enmr.iOff;

        while (enmr.cScans)
        {
            if (CurrentWall == FinalWall)
            {
            // go to the next scan

                if (TopToBottom)
                    pCurrentScan = pscnGet(pCurrentScan);
                else
                    pCurrentScan = pscnGot(pCurrentScan);

                enmr.cScans--;

                if(!pCurrentScan->cWalls)
                {
                    continue;
                }

                if (RightToLeft)
                {
                    CurrentWall = pCurrentScan->cWalls - 2;
                    FinalWall = (COUNT) -2;
                }
                else
                {
                    CurrentWall = 0;
                    FinalWall = pCurrentScan->cWalls;
                }
            }

            prcl->left   = pCurrentScan->ai_x[CurrentWall].x;
            prcl->right  = pCurrentScan->ai_x[CurrentWall + 1].x;
            prcl->top    = pCurrentScan->yTop;
            prcl->bottom = pCurrentScan->yBottom;

            CurrentWall += Offset;

            prcl++;
            penrc->c++;
            --RectsWanted;

            if (!RectsWanted)
            {
                // this is the only time we need to save state, no?
                enmr.iWall = CurrentWall;
                enmr.iFinal = FinalWall;
                enmr.pscn = pCurrentScan;
                return(TRUE);
            }
        }
    }
    else // and the not all case
    {

        ERECTL erclSrc;
        erclSrc.top    = enmr.pscn->yTop;      // Reset source top
        erclSrc.bottom = enmr.pscn->yBottom;   // and bottom

        while (enmr.cScans)
        {
        // do we need a new scan?

            if (enmr.iWall == enmr.iFinal)
            {
            // go to the next scan and see if we are done

                if (enmr.iDir < CD_RIGHTUP)
                {
                // top to bottom

                    if (enmr.pscn->yBottom >= enmr.ercl.bottom)
                    {
                        enmr.cScans = 0;
                        break;
                    }
                    enmr.pscn = pscnGet(enmr.pscn);
                }
                else
                {
                // bottom to top

                    if (enmr.pscn->yTop <= enmr.ercl.top)
                    {
                        enmr.cScans = 0;
                        break;
                    }
                    enmr.pscn = pscnGot(enmr.pscn);
                }

                enmr.cScans--;

            // setup the scan

                erclSrc.top    = enmr.pscn->yTop;      // Reset source top
                erclSrc.bottom = enmr.pscn->yBottom;   // and bottom

            // find the first rectangle within the scan

                if (enmr.iDir & 1)
                {
                // right to left

                    enmr.iWall = enmr.pscn->cWalls - 2;
                    enmr.iFinal = (COUNT) -2;

                    while ((enmr.iWall != -2) &&
                           (enmr.pscn->ai_x[enmr.iWall].x >= enmr.ercl.right))
                    {
                        enmr.iWall -= 2;
                    }
                }
                else
                {
                // left to right

                    enmr.iWall = 0;
                    enmr.iFinal = enmr.pscn->cWalls;

                    while ((enmr.iWall != enmr.iFinal) &&
                           (enmr.pscn->ai_x[enmr.iWall+1].x <= enmr.ercl.left))
                    {
                        enmr.iWall += 2;
                    }
                }

                continue;
            }

        // get the left and right from the scan

            erclSrc.left = enmr.pscn->ai_x[enmr.iWall].x;
            erclSrc.right = enmr.pscn->ai_x[enmr.iWall + 1].x;

        // intersect the side walls.  If the rectangles don't overlap, we
        // are done with this scan.

            prcl->left  = max(enmr.ercl.left,erclSrc.left);
            prcl->right = min(enmr.ercl.right,erclSrc.right);

            if (prcl->left >= prcl->right)
            {
                enmr.iWall = enmr.iFinal;
                continue;
            }

        // compute the top and bottom - these should be moved out of inner loop(erick)

            prcl->top    = max(enmr.ercl.top,erclSrc.top);
            prcl->bottom = min(enmr.ercl.bottom,erclSrc.bottom);

            ASSERTGDI(prcl->top < prcl->bottom,"CLIPOBJ_benum, top >= bottom\n");

        // advance to the next rectangle

            enmr.iWall += enmr.iOff;

            prcl++;
            cj -= sizeof(RECTL);
            penrc->c++;

            if (cj < sizeof(RECTL))
                return(TRUE);
        }
    }
    return(FALSE);
}

/******************************Public*Routine******************************\
* PATHOBJ *XCLIPOBJ::ppoGetPath()
*
* Create PATHOBJ from the clipping region.
*
* NOTE: This does NOT take the multi-monitor offset into account, so this
*       may not be used by display drivers.
*
* History:
*  09-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/
extern "C" PATHOBJ *CLIPOBJ_ppoGetPath(CLIPOBJ *pco)
{
    return (*(XCLIPOBJ*)pco).ppoGetPath();
}


PATHOBJ *XCLIPOBJ::ppoGetPath()
{
// Allocate a PATHOBJ from the heap. We will free this memory only if
// this function fails. Otherwise, we will rely on the device driver to
// call EngDeletePath later on to free the memory.

    PVOID pepo = PALLOCNOZ(sizeof(EPATHOBJ),'oppG');
    if (pepo == (PVOID) NULL)
    {
        return((PATHOBJ *) NULL);
    }

    // Sigh, we have to create a path for this region.

    PATHMEMOBJ pmo;
    if (!pmo.bValid())
    {
        VFREEMEM(pepo);
        return(NULL);
    }

    EXFORMOBJ exo(IDENTITY);
    ASSERTGDI(exo.bValid(), "Invalid Identity transform");

    {
        // pmoRect will contain an intermediate rectangular path that will
        // in turn be processed into a diagonalized path that will be
        // contained in pmo.

        RTP_PATHMEMOBJ pmoRect;
        if
        (
            !pmoRect.bValid()               ||
            !bCreate(pmoRect, &exo)         ||
            !pmoRect.bDiagonalizePath(&pmo)
        )
        {
            VFREEMEM(pepo);
            return(NULL);
        }
        // pmoRect passes out of scope.  Since I have NOT called
        // pmoRect.vKeepIt() the memory of the rectangular path will
        // be freed, while the diagonalized path as embodied in pmo
        // will live on.
    }

    // OK, nothing can fail now.  We will keep the diagonalized path
    // by marking it as permanent.  We will allow the destructor to
    // kill the rectangular path in pmo.

    pmo.vKeepIt();

    // Make sure we copy the accelerator fields to the path we'll be
    // giving out:

    *((EPATHOBJ*) pepo) = pmo;

    // Now lock down the object and point our path to it:

    ((EPATHOBJ *) pepo)->vLock(pmo.hpath());

    return((PATHOBJ *) pepo);
}

/******************************Public*Routine******************************\
* VOID XCLIPOBJ::vFindScan(prcl, y)
*
* Search for the scan that contains the given point
*
* History:
*  13-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID XCLIPOBJ::vFindScan(
RECTL   *prcl,
LONG     y)
{
    if (y < enmr.pscn->yTop)
    {
        while (y < enmr.pscn->yTop)
            enmr.pscn = pscnGot(enmr.pscn);

        prcl->top    = max(enmr.pscn->yTop, rclBounds.top);
        prcl->bottom = min(enmr.pscn->yBottom, rclBounds.bottom);
        prcl->left   = prcl->right;

        if (prcl->top >= prcl->bottom)
            prcl->top    =  NEG_INFINITY;

        if (prcl->top    == NEG_INFINITY)
            prcl->bottom =  NEG_INFINITY;
    } 
    else if (y >= enmr.pscn->yBottom)
    {
        while (y >= enmr.pscn->yBottom)
            enmr.pscn = pscnGet(enmr.pscn);

        prcl->top    = max(enmr.pscn->yTop, rclBounds.top);
        prcl->bottom = min(enmr.pscn->yBottom, rclBounds.bottom);
        prcl->left   = prcl->right;

        if (prcl->top >= prcl->bottom)
            prcl->bottom =  POS_INFINITY;

        if (prcl->bottom == POS_INFINITY)
            prcl->top    =  POS_INFINITY;
    }
}

/******************************Public*Routine******************************\
* VOID XCLIPOBJ::vFindSegment(prcl, x, y)
*
* Search for the segment in the current scan that contains the given point
*
* History:
*  13-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID XCLIPOBJ::vFindSegment(
RECTL   *prcl,
LONG     x,
LONG     y)
{
    DONTUSE(y);

    COUNT   iWall;
    LONG    xLeft;
    LONG    xRight;

    for (iWall = 0; iWall != enmr.pscn->cWalls; iWall += 2)
    {
        if ((x >= enmr.pscn->ai_x[iWall].x) &&
            (x < enmr.pscn->ai_x[iWall + 1].x))
        {
            xLeft  = max(enmr.pscn->ai_x[iWall].x, rclBounds.left);
            xRight = min(enmr.pscn->ai_x[iWall + 1].x, rclBounds.right);

            if (xLeft < xRight)
            {
                prcl->left = xLeft;
                prcl->right = xRight;
            }
    
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\cache.cxx ===
/******************************Module*Header*******************************\
* Module Name: cache.cxx                                                   *
*                                                                          *
* Non-inline methods for font cache objects.                               *
*                                                                          *
* Created: 11-Apr-1991 16:54:54                                            *
* Author: Gilman Wong [gilmanw]                                            *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                                 *
\**************************************************************************/

#include "precomp.hxx"

extern "C" VOID vInitFontCache();

#pragma alloc_text(INIT, vInitFontCache)

#define COPYSMALLMETRICS(pgdn, pgd)                                    \
{                                                                      \
    RtlCopyMemory((PVOID)(pgdn), (PVOID)(pgd), offsetof(GLYPHDATA,fxInkTop)); \
}

#define ROUND_TO_PAGE(x)  (((x)+PAGE_SIZE-1)&~(PAGE_SIZE-1))

// binary cache search

extern BYTE acBits[16];
extern INT  aiStart[17];

/******************************Public*Routine******************************\
* vInitFontCache
*
* Initializes the CACHE_PARM structure from the [FontCache] section of
* WIN.INI.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
\**************************************************************************/

#define CJMININCREMENT     0x2000
#define CJMAX              (8 * 0x2000)


/******************************Public*Routine******************************\
* RFONTOBJ::bInitCache
*
* UNICODE GLYPHDATA CACHE:
*
* Reserves and commits glyphbit cache memory and allocates GLYPHDATA memory
* from the heap in 1024 bytes chunks.
*
*                        ______          ______        ______
*     pgdThreshold-->   |      |        |      |      |      |
*                       | G D  |        | G D  |      | G D  |
*                       | l a  |        | l a  |      | l a  |
*     pgdNext-->        | y t  |        | y t  |      | y t  |
*                       | p a  |        | p a  |      | p a  |
*                       | h    |        | h    |      | h    |
*                       |------|        |------|      |------|
*     pc->pdblBase   -->| link |  -->   | link | -->  | NULL |
*                       |______|        |______|      |______|
*                                                     | WCPG |
*                                                     |______|
*
*
*
*
*
*
* Preloads the default glyph, in anticipation of need, and to avoid
* loading it multiple times.
*
* Builds empty WCGP, sets RFONT mode to cache.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*
*  31-Nov-1994 -by- Gerrit van Wingerden
* Re-rewrote it to cache GLYPHDATA more effieciently.
*
*  21-Apr-1992 -by- Paul Butzi
* Rewrote it.
*
*  15-Apr-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/


// we want number divisible by 8 containing about 75 glyphs,
// almost an upper limit on number of glyphs in the metrics cache
// when running winstone memory constrained scenario

#define GD_INC  (76 * offsetof(GLYPHDATA,fxInkTop))

// GD_INC amounts to 1520 == 000005f0H, far less than a page.

// according to Kirk's statistics, very few realizations cache more
// than 60 glyphs, so we shall start with a block which contains about
// 60 glyphs

#define C_GLYPHS_IN_BLOCK 64


BOOL RFONTOBJ::bInitCache(FLONG flType)
{

    #if DBG
    IFIOBJ ifio(prfnt->ppfe->pifi);
    TRACE_CACHE((
        " -- TRACE_CACHE --\n"
        "    RFONTOBJ::bInitCache\n"
        "    FaceName = \"%ws\"\n"
        "    ExAllocatePoolWithTag\n",
        ifio.pwszFaceName()
        ));
    #endif

    CACHE *pc = &(prfnt->cache);

// Set the pointer to null.  vDeleteCache will free memory from
// any non-null pointers.  This simplifies cleanup, since bRealize
// ensures that vDeleteCache is called if this routine fails.

// metrics portion

    pc->pdblBase = NULL;
    pc->cMetrics = 0;     // no metrics in the cache yet

// glyphbits portion

    pc->cjbbl    = pc->cBlocks = pc->cBlocksMax = 0;
    pc->pbblBase = pc->pbblCur = NULL;
    pc->pgbNext  = pc->pgbThreshold = NULL;

    pc->cjbblInitial = 0;     // no bits in the cache to begin with.
    pc->cGlyphs  = 0;     // no bits in the cache to begin with.
    pc->cjTotal  = 0;     // nothing used yet

// aux mem portion

    pc->pjAuxCacheMem = NULL;
    pc->cjAuxCacheMem = 0;
    prfnt->wcgp = NULL;

// First, figure out how big the max glyph will be
// Default is zero - glyphdata size is not counted!

    pc->cjGlyphMax = 0;
    switch ( prfnt->ulContent )
    {
    case FO_HGLYPHS:
    case FO_GLYPHBITS:
        pc->cjGlyphMax = prfnt->cjGlyphMax;
        break;

    case FO_PATHOBJ:

    // oh, yeah?  Got a better guess?
    // Here we are putting an upper bound on glyph outline data.
    // Unlike the bitmap case, in the outline case the font driver
    // can not give us a cjGlyphMax number we can trust to be sufficient
    // for all glyphs.
    // Even if the font driver new this number, bFlatten may
    // alter ie. increase the number of points so much that even as huge a
    // number as cjMax/2 may not suffice for some glyphs. So we
    // had better be prepared to fail gracefully in the pgbCheckGlyphbits
    // routine if that is the case.

        pc->cjGlyphMax = CJMAX / 2;
        break;
    }

// this is used in few places below, remember it:

    ULONG  cjGlyphMaxX2 = 2 * pc->cjGlyphMax;

// if we can't even get one glyph in a maximum size cache, don't cache
// Note that we need room for the default glyph and one other glyph

    prfnt->flType = flType;

    if ((prfnt->ulContent != FO_HGLYPHS) && (cjGlyphMaxX2 > CJMAX))
    {
    //
    // Glyph exceeds maximum cache memory size, so we will revert to
    // caching just the metrics.  This will speed up things like
    // GetCharWidths, and stuff that just *has* to have the glyphs
    // will use the lookaside stuff (previously called BigGlyph)

        prfnt->flType |= RFONT_TYPE_NOCACHE;

    }

// get the width of the break character

    HGLYPH hg = hgXlat(prfnt->ppfe->pifi->wcBreakChar);

// do not bother to store this in the cache

    PDEVOBJ pdo(prfnt->hdevProducer);

// Call font driver to get the metrics.

    ULONG ulMode = QFD_GLYPHANDBITMAP;
    if (prfnt->ulContent == FO_PATHOBJ)
    {
        ulMode = QFD_GLYPHANDOUTLINE;
    }

    GLYPHDATA gd;

    if (pdo.QueryFontData(
            prfnt->dhpdev,
            pfo(),
            ulMode,
            hg,
            &gd,
            NULL,
            0) == FD_ERROR)
    {
        WARNING("bGetBreak: QueryFontData failed\n");
        return FALSE;
    }

    prfnt->fxBreak = gd.fxD;
    prfnt->hgBreak = hg;

// Now we have everything ready to fly.  Handle some little details:
// set up the cache semaphore.

    if(!(prfnt->ppfe->flPFE & PFE_EUDC))
    {
        prfnt->hsemEUDC = GreCreateSemaphore();
        
        if (!prfnt->hsemEUDC)
            return FALSE;
    }
    else
        prfnt->hsemEUDC = NULL;

    prfnt->hsemCache = GreCreateSemaphore();
    
    if (!prfnt->hsemCache)
    {
        if (prfnt->hsemEUDC)
        {
            GreDeleteSemaphore(prfnt->hsemEUDC);
            prfnt->hsemEUDC = NULL;
        }
        
        WARNING("Semaphore creation failed in bInitCache\n");
        return FALSE;
    }

    return TRUE;
}

BOOL
RFONTOBJ::bAllocateCache(RFONTOBJ* prfoBase)
{
    FLONG flType = prfnt->flType;
    WCGP *wcgp;
    CACHE *pc = &(prfnt->cache);
    ULONG  cjGlyphMaxX2 = 2 * pc->cjGlyphMax;
    FLONG  flEUDC = 0;

// calculate the size of the WCGP structure

    GISET       *pgiset;
    FD_GLYPHSET *pfdg;
    ULONG cRuns;
    ULONG cGlyphsTotal;

    if (flType & RFONT_TYPE_UNICODE)
    {
        pfdg         = prfnt->pfdg;
        cRuns        = pfdg->cRuns;
        cGlyphsTotal = pfdg->cGlyphsSupported;
    }
    else // RFONT_TYPE_HGLYPH
    {
        if (prfnt->ppfe->pgiset)
        {
            pgiset       = prfnt->ppfe->pgiset;
            cRuns        = pgiset->cGiRuns;
            cGlyphsTotal = pgiset->cgiTotal;
        }
        else
        {
        // The mapper should have prevented us from getting here.
        // However, in case we have a bug in the mapper we still do
        // not want to go down in flames:

            WARNING("gdi: attempting to init cache for non glyph index font\n");
            return FALSE;
        }
    }

    ULONGSIZE_T sizeWCGP = (ULONGSIZE_T)(offsetof(WCGP, agpRun)      +
                                         cRuns * sizeof(GPRUN)       +
                                         cGlyphsTotal * sizeof(GLYPHDATA*));

#if DBG
    if (flType & RFONT_TYPE_UNICODE)
    {
        SIZE_T cGlyphs = 0;

        for (UINT i = 0; i < pfdg->cRuns; i += 1)
        {
            cGlyphs += pfdg->awcrun[i].cGlyphs;
        }
        ASSERTGDI(cGlyphs == pfdg->cGlyphsSupported, "cache.cxx, cGlyphs init\n");
    }
#endif

// The distribution of metics per realized font w/ Winstone97 is:
//
//      43% <= 0 Metrics
//      50% <= 6 Metrics
//      76% <= 32 Metrics
//      99% <= 216 Metrics
//      100% <= 249 Metrics
//
// Make the allocation either be smaller than a page or be multiples
// of the pages size due to the current pool allocation scheme.
//
// If the 32 GD's + the runs and pointers fit with plenty of space
// left then use that.  Otherwize, otherwize round up to the page
// boundary (but watch that at least a few fit).
//
// We round up to a page boundary if we're going to use more than 3K
// on the premise that we are more likely to be able to page it out
// if we don't have multiple uses for it.

// now figure out how much space we will need for at least the WCPG
// and one "block" of glyphdata structures.
// Insure that the DATABLOCK's following the GLYPHDATA pointers is
// maximally aligned

    ULONGSIZE_T dpDATABLOCK = ALIGN8(sizeWCGP);

    ULONGSIZE_T cjInitData;

    int GlyphDataSize = bSmallMetrics() ?
                            offsetof(GLYPHDATA,fxInkTop) :
                            sizeof(GLYPHDATA);

    if ((dpDATABLOCK + GDI_POOL_HEADER_SIZE + (GlyphDataSize * 32)) <= (PAGE_SIZE*3/4))
    {
    // Use a partial page

        cjInitData = dpDATABLOCK + (32 * GlyphDataSize);
    }
    else
    {
    // Use a full page but make sure that at least a few fit.  If
    // there's less that 128 bytes left on the last page allocate
    // another.
    // round up to page, somewhat arbitrary

        cjInitData = ROUND_TO_PAGE(dpDATABLOCK);

        if ((cjInitData - dpDATABLOCK) < 128){
            cjInitData += PAGE_SIZE;
        }
    }

    BYTE *pjRunAndData;

// Allocate enough memory for the WCGP and one GLYPHDATA block

    if ((pjRunAndData = (BYTE*)PALLOCNOZ(cjInitData, 'cacG')) == NULL)
    {
        WARNING("win32k!bAllocateCache failed on first attempt \n");

        // not enough memory, try to clean up all inactive RFONT lists
        // release the fmCache semaphores for both linked fonts if any
        // and the base font, otherwise it might cause deadlock

        if (prfoBase)
        {
            PRFONT   prfntBase = prfoBase->prfntFont();

            {
                GreAcquireSemaphore(prfntBase->hsemEUDC);
                
                if (prfntBase->flEUDCState & TT_SYSTEM_INITIALIZED)
                {
                    ASSERTGDI(prfoBase->prfntSystemTT(), "bAllocate cache NULL prfntSysTT\n");
                    if (prfoBase->prfntSystemTT())
                    {
                        flEUDC |= TT_SYSTEM_INITIALIZED;
                        prfntBase->flEUDCState &= ~TT_SYSTEM_INITIALIZED;
                        GreReleaseSemaphore(prfoBase->prfntSystemTT()->hsemCache);
                    }
                }
            
                if (prfntBase->flEUDCState & EUDC_INITIALIZED)
                {
                    flEUDC |= EUDC_INITIALIZED;
                    prfntBase->flEUDCState &= ~EUDC_INITIALIZED;
                    if (prfoBase->prfntSysEUDC())
                    {
                        GreReleaseSemaphore(prfoBase->prfntSysEUDC()->hsemCache);
                    }
                    if (prfoBase->prfntDefEUDC())
                    {
                        GreReleaseSemaphore(prfoBase->prfntDefEUDC()->hsemCache);
                    }

                    for( UINT ii = 0; ii < prfoBase->uiNumFaceNameLinks(); ii++ )
                    {
                       if( prfntBase->paprfntFaceName[ii] != NULL )                    
                       {
                           GreReleaseSemaphore(prfntBase->paprfntFaceName[ii]->hsemCache);
                       }
                    }
                }

                GreReleaseSemaphore(prfntBase->hsemEUDC);
            }
            GreReleaseSemaphore(prfntBase->hsemCache);
        }
        else
        {
            GreReleaseSemaphore(prfnt->hsemCache);
        }
        
        //
        // Winbug 399722: instead of using semaphores to secure the
        // InactiveRont list cleanup process (which caused deadlock),
        // we restrict the process's access to the UMPD pdev's.
        //

        PPDEV ppdev;

        GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);
        for (ppdev=gppdevList; ppdev; ppdev=ppdev->ppdevNext)
        {
            PDEVOBJ pdo((HDEV)ppdev);

            if (!pdo.bFontDriver()
                &&
                (!pdo.bUMPD() || pdo.pid() == (PW32PROCESS)W32GetCurrentProcess())
               )
            {
                ppdev->cPdevRefs++;
                break;
            }
        }
        GreReleaseSemaphoreEx(ghsemDriverMgmt);

        while(ppdev)
        {
            PDEVOBJ pdoCurrent((HDEV)ppdev);
            
            vRemoveAllInactiveRFONTs(ppdev);

            GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);
            
            for (ppdev = ppdev->ppdevNext; ppdev; ppdev=ppdev->ppdevNext)
            {
                PDEVOBJ pdoNext((HDEV)ppdev);

                if (!pdoNext.bFontDriver()
                    &&
                    (!pdoNext.bUMPD() || pdoNext.pid() == (PW32PROCESS)W32GetCurrentProcess())
                   )
                {
                    ppdev->cPdevRefs++;
                    break;
                }
            }
            GreReleaseSemaphoreEx(ghsemDriverMgmt);

            pdoCurrent.vUnreferencePdev();
        }

        // Grab the fmCache semaphore again

        if (prfoBase)
        {
            PRFONT   prfntBase = prfoBase->prfntFont();

            GreAcquireSemaphore(prfntBase->hsemCache);

            {
                GreAcquireSemaphore(prfntBase->hsemEUDC);
                
                if ((flEUDC & TT_SYSTEM_INITIALIZED) && 
                        !(prfntBase->flEUDCState & TT_SYSTEM_INITIALIZED) )
                {
                    prfntBase->flEUDCState |= TT_SYSTEM_INITIALIZED;
                    GreAcquireSemaphore(prfoBase->prfntSystemTT()->hsemCache);
                }
                if ((flEUDC & EUDC_INITIALIZED) &&
                        !(prfntBase->flEUDCState & EUDC_INITIALIZED) )
                {
                    prfntBase->flEUDCState |= EUDC_INITIALIZED;

                    if (prfoBase->prfntSysEUDC())
                    {
                        GreAcquireSemaphore(prfoBase->prfntSysEUDC()->hsemCache);
                    }
                    if (prfoBase->prfntDefEUDC())
                    {
                        GreAcquireSemaphore(prfoBase->prfntDefEUDC()->hsemCache);
                    }

                    for( UINT ii = 0; ii < prfoBase->uiNumFaceNameLinks(); ii++ )
                    {
                       if( prfntBase->paprfntFaceName[ii] != NULL )                    
                       {
                           GreAcquireSemaphore(prfntBase->paprfntFaceName[ii]->hsemCache);
                       }
                    }
                }
                
                GreReleaseSemaphore(prfntBase->hsemEUDC);
            }
        }
        else
        {
            GreAcquireSemaphore(prfnt->hsemCache);
        }

        // Check whether the cache has been allocated
        // while we clean up the inactive RFONTs.
        // Don't allocate again if it has been done.

        if (prfnt->wcgp)
        {
            return TRUE;
        }
        else
        {
            if ((pjRunAndData = (BYTE*)PALLOCNOZ(cjInitData, 'cacG')) == NULL)
            {
                WARNING("win32k!bAllocateCache failed to on second attempt\n");
                SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
                return (FALSE);
            }
        }
    }

// The debug pool allocation functions do not return
// page aligned memory.
#if 0
    #if DBG
    if (cjInitData >= (PAGE_SIZE - GDI_POOL_HEADER_SIZE))
    {
        if ((((ULONG_PTR)pjRunAndData) & (PAGE_SIZE - 1)) != 0)
            DbgPrint("pjRunAndData alignment (0x%08lx, 0x%p)\n",
                     cjInitData, pjRunAndData);
    }
    #endif
#endif

// Set up the WCPG stucture

    prfnt->wcgp = (WCGP *) pjRunAndData;
    wcgp = prfnt->wcgp;
    wcgp->cRuns = cRuns;
    wcgp->pgdDefault = (GLYPHDATA *) NULL;

    GLYPHDATA **ppgd = (GLYPHDATA **)&(wcgp->agpRun[wcgp->cRuns]);

// init all glyphdata pointers to zero

    RtlZeroMemory(ppgd, sizeof(GLYPHDATA*) * cGlyphsTotal);

    if (flType & RFONT_TYPE_UNICODE)
    {
        for (UINT i = 0; i < cRuns; i += 1 )
        {
            GPRUN *pRun = &wcgp->agpRun[i];
            WCRUN *pWCRun = &(pfdg->awcrun[i]);
            pRun->apgd = ppgd;
            pRun->wcLow = (UINT) pWCRun->wcLow;
            pRun->cGlyphs = pWCRun->cGlyphs;
            ppgd += pRun->cGlyphs;
        }
    }
    else // RFONT_TYPE_HGLYPH
    {
        for (UINT i = 0; i < cRuns; i += 1 )
        {
            GPRUN *pRun = &wcgp->agpRun[i];
            GIRUN *pgiRun = &(pgiset->agirun[i]);

            pRun->apgd = ppgd;
            pRun->wcLow = pgiRun->giLow;
            pRun->cGlyphs = pgiRun->cgi;
            ppgd += pRun->cGlyphs;
        }
    }

// Now we will set up the parameters for the GLYPHDATA
// part of the cache. We are assured we are aligned properly.

    pc->pdblBase = (DATABLOCK *)(pjRunAndData + dpDATABLOCK);

// init head to null. This value will stay null always.

    pc->pdblBase->pdblNext = (DATABLOCK*)NULL;

    pc->pgdNext = &pc->pdblBase->agd[0];

// end of the current block and first block, same in this case

    pc->pjFirstBlockEnd = pjRunAndData + cjInitData;
    pc->pgdThreshold = (GLYPHDATA *)pc->pjFirstBlockEnd;

// Now, the GLYPHDATA portion is all set.  Go ahead and set up the
// space for the GLYPHBITS or PATHOBJS if needed.

    if ((prfnt->ulContent != FO_HGLYPHS) &&
       !(prfnt->flType & RFONT_TYPE_NOCACHE))
    {
    // 47% <= 0 Glyphs
    // 55% <= 1 Glyphs
    // 75% <= 16 Glyphs
    // 95% <= 58 Glyphs
    // 100% <= 217 Glyphs
    //
    // Special case the first allocation, since most realizations use
    // <= 16 Glyphs. Make the first allocation 16 glyphs if that size fits
    // well within a page boundary.
    //
    // Subsequent allocations will be in page aligned allocations w/
    // enough to hold 16 max sized glyphs.  This will be limited to
    // CJMAX KB
    //
    // If caching glyphs, at least 2 glyphs (default one and another one,
    // see NOCACHE above, will fit in CJMAX).

        if (prfnt->ulContent == FO_PATHOBJ)
        {
        // this seems to work and this is what we did before DavidFie changes
        // for PATHOBJ case

            pc->cjbbl = pc->cjbblInitial = cjGlyphMaxX2;
        }
        else
        {

            ULONG cjBytes = 16 * pc->cjGlyphMax;

            ULONG AllocationSize = ROUND_TO_PAGE(cjBytes);

            if (AllocationSize <= CJMININCREMENT)
            {
                pc->cjbbl = AllocationSize;
                pc->cjbblInitial = (cjBytes < (PAGE_SIZE*3/4)) ?
                                                    cjBytes : AllocationSize;
            }
            else
            {
                cjBytes = 8 * pc->cjGlyphMax;

                if (cjBytes <= CJMININCREMENT)
                {
                    pc->cjbbl = pc->cjbblInitial = CJMININCREMENT;
                }
                else
                {
                    AllocationSize = ROUND_TO_PAGE(cjBytes);
                    pc->cjbbl = pc->cjbblInitial = MIN(AllocationSize, CJMAX);
                    ASSERTGDI(pc->cjbbl >= cjGlyphMaxX2,
                            "two glyphs don't fit in the cache\n");
                }
            }
        }

    // we shall re-interpret cjMax to mean the max number of bytes in
    // glyphbits portion of the cache per 1K of glyphs in the font.
    // That is for larger fonts we shall allow more glyphbits
    // memory per realization than for ordinary US fonts. This will be
    // particularly important for FE fonts. This same code will work fine
    // in their case too:

        pc->cBlocksMax =
            (CJMAX * ((cGlyphsTotal + 1024 - 1)/1024)) /
            pc->cjbbl;


        ASSERTGDI(pc->cjbbl <= CJMAX, "bogus cache initializaiton\n");
    }

// We decide whether or not to invoke the binary search based on the
// number of runs in the font.  For large numbers of runs it makes
// sense to do a binary search.  For small numbers of runs a linear
// search will be better.  Right now I use 200 as the cutoff for
// a linear search because I am sure that a binary search will be
// faster for this number of runs.  We should do some experimentation
// to find the OPTIMAL cutoff in the future. [gerritv]\
// Arial etc has about 90 runs, Lucida Sans Unicode 65

#define BINARY_CUTOFF 200

    if(prfnt->wcgp->cRuns > BINARY_CUTOFF)
    {
        pc->iMax = prfnt->wcgp->cRuns - 1;

        if( pc->iMax & 0xF000 )
        {
            pc->cBits = acBits[(pc->iMax >> 12) & 0x00FF] + 12;
        }
        else if( pc->iMax & 0x0F00 )
        {
            pc->cBits = acBits[(pc->iMax >>  8) & 0x00FF] +  8;
        }
        else if( pc->iMax & 0x00F0 )
        {
            pc->cBits = acBits[(pc->iMax >>  4) & 0x00FF] +  4;
        }
        else
        {
            pc->cBits = acBits[pc->iMax];
        }
        pc->iFirst = aiStart[pc->cBits];
    }
    else
    {
    // setting iMax to zero signifies a linear search

        pc->iMax = 0;
    }

    return (TRUE);
}




/******************************Public*Routine******************************\
* RFONTOBJ::vDeleteCache
*
* Destroy the font cache object (CACHE).
*
* Returns FALSE if the function fails.
*
* History:
*  15-Apr-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
*
*  24-Nov-92 -by- Paul Butzi
* Rewrote it.
*  Fri 08-Sep-1995 -by- Bodin Dresevic [BodinD]
* update: Rewrote one more time
\**************************************************************************/

VOID RFONTOBJ::vDeleteCache ()
{
   CACHE *pc = &prfnt->cache;

// Free up glyph data portion of the cache:

   DATABLOCK *pdbl = pc->pdblBase;

// We are counting on the while loop to free prfnt->wcpg so
// ppv better always be non-NULL when prfnt->wcpg is.

    ASSERTGDI( ((prfnt->wcgp == NULL ) || (pdbl != (DATABLOCK*)NULL)),
               "vDeleteCache: prfnt->wcgp non-NULL but pc->pdblBase was NULL\n");

// walks the list of blocks of GLYPHDATA and frees all of them.

    while (pdbl)
    {
        DATABLOCK *pdblTmp = pdbl;

        pdbl = pdbl->pdblNext;

        if (pdbl == NULL)
        {
        // this is the first block so wcpg really points to its base.

            VFREEMEM(prfnt->wcgp);
        }
        else
        {
            VFREEMEM(pdblTmp);
        }
    }

    pc->pdblBase = NULL;
    prfnt->wcgp = NULL;
    
// Free up glyphbits portion of the cache, if it was ever allocated

    if (pc->pbblBase != NULL)
    {
        BITBLOCK * pbbl, *pbblNext;
        for (pbbl = pc->pbblBase; pbbl; pbbl = pbblNext)
        {
            pbblNext = pbbl->pbblNext;
            VFREEMEM(pbbl);
        }

        pc->pbblBase = NULL;
    }

// free aux memory if it was used

    if (prfnt->cache.pjAuxCacheMem != NULL)
    {
        VFREEMEM((PVOID) prfnt->cache.pjAuxCacheMem);
        prfnt->cache.pjAuxCacheMem = NULL;
        prfnt->cache.cjAuxCacheMem = 0;
    }

    return;
}



/******************************Public*Routine******************************\
* BOOL RFONTOBJ::bGetGlyphMetrics
*
* Translate wchars into an array of GLYPHPOS structures, filling in
* the pointer to GLYPHDATA field.  Only the metrics are assured to be
* valid; no attempt is made to ensure that the glyph data itself is
* present in the cache before the return to the caller.
*
* This routine is to be used primarily by GetTextExtent and GetCharWidths,
* which have no need for anything except metrics.
*
* A zero return means that we failed to insert the metrics due to some
* hard error, most likely a failure to commit memory in the glyph
* insertion routine.
*
* History:
*  13-Nov-92 -by- Paul Butzi
* Wrote it.
\**************************************************************************/

#pragma optimize("t", on)

BOOL RFONTOBJ::bGetGlyphMetrics (
    COUNT c,
    GLYPHPOS *pgp,
    WCHAR *pwc,
    XDCOBJ *pdco,
    ESTROBJ *pto
    )
{

    if (prfnt->wcgp == NULL)
    {
        if (!bAllocateCache())
        {
            return(FALSE);
        }
    }

    WCGP *pwcgp = prfnt->wcgp;

    WCHAR *pwcInit = pwc;

    // need to check for empty glyphset
    if (pwcgp->cRuns == 0)
    {
        WARNING("bGetGlyphMetrics - empty glyphset\n");
        for (; c != 0; --c, ++pgp)
        {
            pgp->hg = hgDefault();
            pgp->pgdf = (GLYPHDEF *) pgdDefault();
        }
        return TRUE;
    }

    GPRUN *pwcRun = pwcgp->agpRun; // initialize with guess for loop below


    GLYPHDATA *wpgd;

    for (WCHAR *pwcEnd = pwc + c; pwc < pwcEnd; pwc+=1, pgp+=1)
    {

        WCHAR wc = *pwc;

    // Find the correct run, if any.
    // Try the current run first.

        UINT swc = (UINT)wc - pwcRun->wcLow;
        if ( swc >= pwcRun->cGlyphs )
        {

        // This path should go out of line

            pwcRun = gprunFindRun(wc);
            swc = (UINT)wc - pwcRun->wcLow;

            if ( swc < pwcRun->cGlyphs )
            {
                wpgd = pwcRun->apgd[swc];
            }
            else
            {
                BOOL bAccel;
                if ((wpgd = wpgdGetLinkMetricsPlus(pdco,pto, pwc, pwcInit, c, &bAccel, FALSE)) == NULL)
                {
                    WARNING("wpgdGetLinkMetricsPlus return NULL\n");
                    return FALSE;
                }
            }
        }
        else
        {

        // Look up entry in current run
        // This path should go in line

            wpgd = pwcRun->apgd[swc];
        }

    // check to make sure in cache, insert if needed

        if ( wpgd == NULL )
        {

        // This path should go out of line

            if ( !bInsertMetrics(&pwcRun->apgd[swc], wc) )
            {

            // when insert fails trying to get just metrics, it is a hard
            // failure.  Get out of here!

                WARNING("bGetGlyphMetrics - bInsertMetrics failed\n");
                return FALSE;
            }

            wpgd = pwcRun->apgd[swc];
        }

    // set the pgp and go on to the next wc

        pgp->hg = wpgd->hg;
        pgp->pgdf = (GLYPHDEF *) wpgd;
    }

    return TRUE;

}

/******************************Public*Routine******************************\
* BOOL RFONTOBJ::bGetGlyphMetricsPlus
*
* Translate wchars into an array of GLYPHPOS structures, filling in
* the pointer to GLYPHDATA field.  Although only the metrics are assured to be
* valid, an attempt is made to ensure that the glyph data itself is
* present in the cache before the return to the caller.  Failure in this
* attempt is indicated by clearing the flag *pbAccel.  This allows the
* text code to tell the device driver that the STROBJ_bEnum callback is
* not needed.
*
* This routine is to be used primarily by TextOut and its kin.
*
* A zero return means that we failed to insert the metrics due to some
* hard error, most likely a failure to commit memory in the glyph
* insertion routine.
*
*
* History:
*  13-Nov-92 -by- Paul Butzi
* Wrote it.
\**************************************************************************/


BOOL RFONTOBJ::bGetGlyphMetricsPlus (
    COUNT c,
    GLYPHPOS *pgp,
    WCHAR *pwc,
    BOOL *pbAccel,
    XDCOBJ *pdco,
    ESTROBJ *pto
    )
{
    if (prfnt->wcgp == NULL)
    {
        if (!bAllocateCache())
        {
            return(FALSE);
        }
    }

// if this realization is intended for the device that does not need bits,
// let us make sure we do not rasterize these bits, unless the device driver
// really wants the bits (for whatever reason),
// in which case this device driver will have to call STROBJ_bEnum for the string
// that it wants rasterized:

    PDEVOBJ po(hdevConsumer());

    if
    (
        (po.flGraphicsCapsNotDynamic() & GCAPS_FONT_RASTERIZER) &&
        (prfnt->ulContent == FO_GLYPHBITS)
    )
    {
        if (pbAccel)
        {
            *pbAccel = FALSE;
        }
        return bGetGlyphMetrics(c, pgp, pwc, pdco, pto);
    }

    WCHAR *pwcInit = pwc;
    *pbAccel = TRUE;

    // need to check for empty glyphset
    if (prfnt->wcgp->cRuns == 0)
    {
        WARNING("bGetGlyphMetricsPlus - empty glyphset\n");
        for (; c != 0; --c, ++pgp)
        {
            pgp->hg = hgDefault();
            pgp->pgdf = (GLYPHDEF *) pgdDefault();
        }
        return TRUE;
    }

    GPRUN *pwcRun = prfnt->wcgp->agpRun; // initialize with guess for loop below

    for (WCHAR *pwcEnd = pwc + c; pwc < pwcEnd; pwc+=1, pgp+=1)
    {
        GLYPHDATA *wpgd;


    // Find the correct run, if any.
    // Try the current run first.

        UINT swc = (UINT)*pwc - pwcRun->wcLow;
        if ( swc >= pwcRun->cGlyphs )
        {

        // This path should go out of line

            pwcRun = gprunFindRun(*pwc);

            swc = (UINT)*pwc - pwcRun->wcLow;

            if ( swc < pwcRun->cGlyphs )
            {
                wpgd = pwcRun->apgd[swc];
            }
            else
            {
                // wpgdGetLinkMetricsPlus should never return NULL

                if ((wpgd = wpgdGetLinkMetricsPlus(pdco, pto, pwc, pwcInit,c, pbAccel, TRUE)) == NULL)
                {
                    WARNING("wpgdGetLinkMetricsPlus returns NULL\n");
                    return FALSE;
                }
            }
        }
        else
        {

        // Look up entry in current run
        // This path should go in line

            wpgd = pwcRun->apgd[swc];
        }

    // check to make sure in cache, insert if needed

        if ( wpgd == NULL )
        {

        // This path should go out of line

            if ( !bInsertMetricsPlus(&pwcRun->apgd[swc], *pwc) )
            {

            // when insert fails trying to get just metrics, it is a hard
            // failure.  Get out of here!
                WARNING("bGetGlyphMetricsPlus - bInsertMetrics failed\n");

                return FALSE;
            }

            wpgd = pwcRun->apgd[swc];
        }

    // Try to ensure that the glyph bits are there, too.
    // Don't bother if we already are going to mess with the driver

        if ( (wpgd->gdf.pgb == NULL) && *pbAccel )
        {

        // this path should go out of line

            if ( (prfnt->ulContent != FO_HGLYPHS) &&
                 !bInsertGlyphbits(wpgd, pwc == pwcInit) )
            {
                *pbAccel = 0;
            }
        }

    // set the pgp and go on to the next wc

        pgp->hg = wpgd->hg;
        pgp->pgdf = (GLYPHDEF *) wpgd;
    }

    return TRUE;

}
#pragma optimize("", on)



/******************************Public*Routine******************************\
* COUNT RFONTOBJ::cGetGlyphDataCache
*
* Run along an array of GLYPHPOS structures which have been filled in
* by a call to bGetGlyphMetricsPlus.  Fill in any missing pointers to
* the glyph data in the referenced GLYPHDATA structures, filling the
* cache as needed.  If the cache is full, and we are not trying to get
* the very first GLYPHDATA referenced by the array passed in, just return.
*
* If, on the other hand, we are still dealing with the first element of
* the array, we needn't be concerned about invalidating the pointers in
* the already worked on portion, so we can tell the glyph insertion routine
* that it can flush the cache with impunity.
*
* This routine is to be used exclusively by the STROBJ_bEnum callback.
*
* Historical Note:
*   In the olden days, we were not so clever, and font caches had the
*   metrics for glyphs and the glyphs themselves joined together.  This
*   had the unpleasant effect of invalidating the pointers in the
*   GLYPHPOS array in addition to invalidating the pointers in the
*   (discarded) GLYPHDATA structures in the font cache.
*
*   Now that that is no longer the case, the callback does not need to
*   pass the string down to this routine, and we never have to do the
*   wchar->GLYPHPOS* translation twice!  Isn't that nice?
*
* History:
*  13-Nov-92 -by- Paul Butzi
* Wrote it.
\**************************************************************************/

COUNT RFONTOBJ::cGetGlyphDataCache(
    COUNT c,
    GLYPHPOS *pgpStart
    )
{

    if ( prfnt->ulContent == FO_HGLYPHS )
        return c;

    GLYPHPOS *pgpEnd = pgpStart + c;

    for ( GLYPHPOS *pgp = pgpStart; pgp < pgpEnd; pgp += 1 )
    {
        GLYPHDEF *pgdf = pgp->pgdf;
        ASSERTGDI(pgdf != NULL, "cGetGlyphDataCache - pgdf == NULL");


    // If the pointer is already valid, just move on

        if ( pgdf->pgb != NULL )
            continue;


    // If the insertion attempt fails, we're full
    // Sundown: safe to truncate to COUNT since pgpEnd = pgpStart + c

        if ( !bInsertGlyphbits( (GLYPHDATA*)(pgp->pgdf), pgp == pgpStart) )
            return (COUNT)(pgp - pgpStart);
    }

    // Sundown: safe to truncate to COUNT since pgpEnd = pgpStart + c

    return (COUNT)(pgp - pgpStart);
}


/******************************Public*Routine******************************\
* COUNT RFONTOBJ::cGetGlyphDataLookaside
*
* For now, just handle the first entry.
*
* History:
*  13-Nov-92 -by- Paul Butzi
* Wrote it.
\**************************************************************************/

COUNT RFONTOBJ::cGetGlyphDataLookaside(
    COUNT c,
    GLYPHPOS *pgp
    )
{
    if ( c == 0 )
        return 0;


    if ( !bInsertGlyphbitsLookaside(pgp, prfnt->ulContent))
        return 0;

    return 1;
}







/******************************Public*Routine******************************\
* GPRUN * RFONTOBJ::gprunFindRun
*
* Given a wchar, run along the GPRUN structures and find the
* entry which contains the char, if any.  If not found, return pointer
* to last run examined.
*
* History:
*  13-Nov-92 -by- Paul Butzi
* Wrote it.
\**************************************************************************/

GPRUN * RFONTOBJ::gprunFindRun(
    WCHAR wc
    )
{
    ASSERTGDI(prfnt->wcgp != NULL, "xprunFindRunRFONTOBJ: wcgp is NULL\n");
    WCGP *pwcgp = prfnt->wcgp;

    // callers handle cRuns == 0 case
    ASSERTGDI(pwcgp->cRuns != 0, "pwcgp->cRuns is 0\n");

    if(!prfnt->cache.iMax)
    {
        GPRUN *pwcRunLow = pwcgp->agpRun;
        GPRUN *pwcRunHi = pwcgp->agpRun + (pwcgp->cRuns - 1);


        // The worst case case is pwcRunHi->wcLow == 0xffff and pwcRunHi->cGlyphs == 1
        UINT  swc = (UINT)(pwcRunHi->wcLow + pwcRunHi->cGlyphs - 1); 

        if (wc > swc) {
            return pwcRunLow;
        }


        for ( GPRUN *pwcRun = pwcRunLow; pwcRun <= pwcRunHi; pwcRun += 1 )
        {
            UINT nwc = wc - pwcRun->wcLow;
            if ( nwc < pwcRun->cGlyphs )
            {
                return pwcRun;
            }
        }
        return pwcRunLow;
    }
    else
    {
    // do a binary search

        int    iThis, iMax;
        GPRUN *pwcRun;
        GPRUN *pwcRunBase = pwcgp->agpRun;

        if( wc < pwcRunBase->wcLow)
        {
            return( pwcRunBase );
        }

        iThis =  prfnt->cache.iFirst;
        iMax = prfnt->cache.iMax;

        switch( prfnt->cache.cBits )
        {
          case 16:
            iThis += (wc >= pwcRunBase[iThis].wcLow) ? 32768 : 0;
            iThis -= 16384;
          case 15:
            iThis += ((iThis <= iMax) && (wc >= pwcRunBase[iThis].wcLow)) ? 16384 : 0;
            iThis -= 8192;
          case 14:
            iThis += ((iThis <= iMax) && (wc >= pwcRunBase[iThis].wcLow)) ? 8192 : 0;
            iThis -= 4096;
          case 13:
            iThis += ((iThis <= iMax) && (wc >= pwcRunBase[iThis].wcLow)) ? 4096 : 0;
            iThis -= 2048;
          case 12:
            iThis += ((iThis <= iMax) && (wc >= pwcRunBase[iThis].wcLow)) ? 2048 : 0;
            iThis -= 1024;
          case 11:
            iThis += ((iThis <= iMax) && (wc >= pwcRunBase[iThis].wcLow)) ? 1024 : 0;
            iThis -= 512;
          case 10:
            iThis += ((iThis <= iMax) && (wc >= pwcRunBase[iThis].wcLow)) ? 512 : 0;
            iThis -= 256;
          case 9:
            iThis += ((iThis <= iMax) && (wc >= pwcRunBase[iThis].wcLow)) ? 256 : 0;
            iThis -= 128;
          case 8:
            iThis += ((iThis <= iMax) && (wc >= pwcRunBase[iThis].wcLow)) ? 128 : 0;
            iThis -= 64;
          case 7:
            iThis += ((iThis <= iMax) && (wc >= pwcRunBase[iThis].wcLow)) ? 64 : 0;
            iThis -= 32;
          case 6:
            iThis += ((iThis <= iMax) && (wc >= pwcRunBase[iThis].wcLow)) ? 32 : 0;
            iThis -= 16;
          case 5:
            iThis += ((iThis <= iMax) && (wc >= pwcRunBase[iThis].wcLow)) ? 16 : 0;
            iThis -= 8;
          case 4:
            iThis += ((iThis <= iMax) && (wc >= pwcRunBase[iThis].wcLow)) ? 8 : 0;
            iThis -= 4;
          case 3:
            iThis += ((iThis <= iMax) && (wc >= pwcRunBase[iThis].wcLow)) ? 4 : 0;
            iThis -= 2;
          case 2:
            iThis += ((iThis <= iMax) && (wc >= pwcRunBase[iThis].wcLow)) ? 2 : 0;
            iThis -= 1;
          case 1:
            iThis += ((iThis <= iMax) && (wc >= pwcRunBase[iThis].wcLow)) ? 1 : 0;
            iThis -= 1;
          case 0:
            break;
        }

        pwcRun = &pwcRunBase[iThis];     // This is our candidate.

        if( wc - pwcRun->wcLow >= (INT) pwcRun->cGlyphs )
        {
            return( pwcRunBase );
        }

        return( pwcRun );
    }
}



/******************************Public*Routine******************************\
* BOOL xInsertMetricsRFONTOBJ
*
* Insert the requested glyph's metrics into the font cache.
*
* History:
*  13-Nov-92 -by- Paul Butzi
* Wrote it.
\**************************************************************************/

extern "C" BOOL xInsertMetricsRFONTOBJ
(
    PRFONTOBJ pRfont,
    GLYPHDATA **ppgd,
    WCHAR wc
)
{
    HGLYPH hg;
    WCGP  *pwcgp;

    pwcgp = pRfont->prfnt->wcgp;
    if (pRfont->prfnt->flType & RFONT_TYPE_UNICODE)
    {
        hg = pRfont->hgXlat(wc);
    }
    else
    {
        hg = (HGLYPH)wc;  // here is the tiny speed advantage
    }

// Make sure we don't insert the default glyph more than once.
// Just return the correct answer if we know it.

    if
    (
        (hg == pRfont->prfnt->hgDefault)
        && (pwcgp->pgdDefault != (GLYPHDATA *) NULL)
    )
    {
        *ppgd = pwcgp->pgdDefault;
        return(TRUE);
    }

    CACHE *pc = &pRfont->prfnt->cache;

// Verify enough room in metrics cache area, grow if needed.
// Note that failure to fit a glyphdata is a hard error, get out now.

    if (!pRfont->bCheckMetricsCache())
    {
        WARNING("xInsertMetricsRFONTOBJ - bCheckMetricsCache failed!\n");
        return FALSE;
    }

    ASSERTGDI(pc->pgdNext < pc->pgdThreshold,
                        "xInser