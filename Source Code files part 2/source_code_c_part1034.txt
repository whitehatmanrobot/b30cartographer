//
        // If we failed to set service list we delete the object and we
        // get out.
        //

        if (dwErr != ERROR_SUCCESS)     {
            pChildVol->DeleteObject();
        }

    }

    //
    // If we succeeded in creating the new object we go on to create the
    // New ExitPoint
    //

    if (dwErr == ERROR_SUCCESS)      {

        //
        // Let us switch to new EntryPath. We want to avoid mem allocations
        // here itself.
        //
        NewId = _peid;
        NewId.Prefix.Length = wcslen(pwszNewPrefix)*sizeof(WCHAR);
        NewId.Prefix.MaximumLength = NewId.Prefix.Length + sizeof(WCHAR);
        NewId.Prefix.Buffer = pwszNewPrefix;

        //
        // Now we can create the exit point at the appropriate place.
        //
        pService = pNewParentVol->_DfsSvcList.GetFirstService();
        ASSERT(pService != NULL);

        while (pService != NULL)    {
            dwErr = pService->CreateExitPoint(&NewId, _EntryType);
            if (dwErr == ERROR_SUCCESS)      {
                CreatedExitPt = TRUE;
            }
            pService = pNewParentVol->_DfsSvcList.GetNextService(pService);
        }

        if (CreatedExitPt == TRUE)  {
            //
            // This operation is committed now and we can set the
            // Recovery Properties on the new object to DONE.
            //
            //
            // Now before we set the recovery Properties to be done on the
            // new object. We have to set the appropriate recovery props
            // on the current object so that we can force this operation
            // forward.
            //
            dwErr = _Recover.SetOperationStart(DFS_RECOVERY_STATE_MOVE, NULL);

            //
            // Now we set the recovery properties  on the new object to
            // DONE since there is nothing that needs to be done over there
            // if we fail now. The only recovery (or roll forward) code will
            // be triggered off this volume object itself.
            //
            RECOVERY_TEST_POINT(L"Move", 2);

            if (dwErr == ERROR_SUCCESS) {
                pChildVol->_Recover.SetOperationDone();
	    }
        }
        else        {
            //
            // Cant go on with this operation so let us get rid of the
            // object that we created.
            //
            IDfsVolInlineDebOut((DEB_TRACE,
                            "Unable to create Exit Pt %ws for Move\n",
                            pwszNewPrefix));
            pChildVol->DeleteObject();
            dwErr = NERR_DfsCantCreateJunctionPoint;
        }

    }

    //
    // Now if we passed the last stage then there is no stopping in this
    // operation anymore.
    //
    if (dwErr == ERROR_SUCCESS)      {
        //
        // Let us get to the old parent and delete the exit point first.
        //
        dwErr = GetParent(&pOldParentVol);

        if (dwErr == ERROR_SUCCESS)  {
            pService = pOldParentVol->_DfsSvcList.GetFirstService();
            ASSERT(pService != NULL);
            //
            // We ignore all errors here.
            //
            while(pService != NULL) {
                dwErr = pService->DeleteExitPoint(&_peid, _EntryType);
                pService = pOldParentVol->_DfsSvcList.GetNextService(pService);
            }
            dwErr = ERROR_SUCCESS;
        }
        else        {
            IDfsVolInlineDebOut((DEB_ERROR,
                            "Unable to get to the parent vol for %ws\n",
                            _pwzFileName));
        }
        RECOVERY_TEST_POINT(L"Move", 3);
        //
        // Now we merely need to do a modify Prefix operation on the current
        // volume's services.
        //
        pService = _DfsSvcList.GetFirstService();
        ASSERT(pService != NULL);
        while (pService != NULL)    {
            dwErr = pService->ModifyPrefix(&NewId);
            if (dwErr != ERROR_SUCCESS) {
                IDfsVolInlineDebOut((DEB_ERROR,
                                    "Unable to Modify prefix to %ws %08lx\n",
                                    NewId.Prefix.Buffer, dwErr));
            }
            pService = _DfsSvcList.GetNextService(pService);
        }
        dwErr = ERROR_SUCCESS;

        //
        // We can now delete this object itself.
        //
        DeleteObject();
        _Deleted = FALSE;

        //
        // We now need to change the _pwzFileName of this idfsvol to match
        // the new child that we have created. Also need to change E.P.
        //
        ULONG uLen = wcslen(pChildVol->_pwzFileName);

        if ((uLen > wcslen(_pwzFileName)) && (uLen > MAX_PATH))    {
            if (_pwzFileName != _FileNameBuffer)
                delete [] _pwzFileName;
            _pwzFileName = new WCHAR[uLen + 1];
        }
        wcscpy(_pwzFileName, pChildVol->_pwzFileName);

        //
        // Now the entrypath prefix.
        //
        uLen = NewId.Prefix.Length;
        if (uLen > _peid.Prefix.Length) {
            if (_peid.Prefix.Buffer != _EntryPathBuffer)
                    delete [] _peid.Prefix.Buffer;

            if (uLen >= MAX_PATH)
                _peid.Prefix.Buffer = new WCHAR[(uLen+1)];
            else
                _peid.Prefix.Buffer = _EntryPathBuffer;
        }
        _peid.Prefix.Length = (USHORT)uLen;
        _peid.Prefix.MaximumLength = _peid.Prefix.Length + sizeof(WCHAR);
        wcscpy(_peid.Prefix.Buffer, NewId.Prefix.Buffer);

        //
        // Now we get the IStorage's etc. over to this idfsvol. We steal.
        //
        ASSERT((_pStorage == NULL) &&
               (_Recover._pPSStg == NULL) &&
               (_DfsSvcList._pPSStg == NULL));

        _pStorage = pChildVol->_pStorage;
        pChildVol->_pStorage = NULL;
        _Recover._pPSStg = pChildVol->_Recover._pPSStg;
        _DfsSvcList._pPSStg = pChildVol->_DfsSvcList._pPSStg;
        pChildVol->_Recover._pPSStg = NULL;
        pChildVol->_DfsSvcList._pPSStg = NULL;

        //
        // Copy over the child's registration id, so we can revoke that
        // as well. We need to revoke it because it has been registered
        // with the child's CDfsVol address.
        //

        _dwRotRegistration = pChildVol->_dwRotRegistration;
        pChildVol->_dwRotRegistration = NULL;

        //
        // Now we have to update the DC's PKT entry itself.
        //
        dwErr = UpdatePktEntry(NULL);
        if (dwErr != ERROR_SUCCESS)     {
            IDfsVolInlineDebOut((DEB_ERROR,
                            "Unable to updatePkt entry %08lx for %ws\n",
                            dwErr, pChildVol->_peid.Prefix.Buffer));
        }

    }

    if (pNewParentVol != NULL) {
        pNewParentVol->Release();
    }

    if (pChildVol != NULL) {
        pChildVol->Release();
    }

    if (pOldParentVol != NULL) {
        pOldParentVol->Release();
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::Move() exit\n"));

    return((dwErr));
}


//+------------------------------------------------------------------------
//
// Method:      CDfsVolume::InitializePkt, public
//
// Synopsis:    This method initilaizes the PKT with info regarding this
//              volume and also sets up the relational info for itself. It
//              also continues to recursively call all the child volume
//              objects' InitializePkt method.
//
// Arguments:   None
//
// Notes:       This is a recursive method. By calling this we can initialise
//              the PKT with info regarding this volume and all its children
//              since it is a recursive routine. This is a DEPTH-FIRST Traversal
//
// History:     09-Feb-93       SudK    Created.
//
//-------------------------------------------------------------------------
DWORD
CDfsVolume::InitializePkt(
    HANDLE PktHandle)
{

    DWORD               dwErr = ERROR_SUCCESS;
    CEnumDirectory      *pDir = NULL;
    DFSMSTATDIR          rgelt;
    ULONG               fetched = 0;
    CDfsVolume          *child = NULL;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::InitializePkt()\n"));

#if DBG
    if (DfsSvcVerbose & 0x80000000)
        DbgPrint("CDfsVolume::InitializePkt()\n");
#endif

    memset(&rgelt, 0, sizeof(DFSMSTATDIR));

    //
    // First, we get a hold of the CRegEnumDirectory interface to our own
    // volume object.
    //

    dwErr = _pStorage->GetEnumDirectory(&pDir);

    if (dwErr != ERROR_SUCCESS) {
        IDfsVolInlineDebOut((DEB_ERROR, "Failed to get IDirectory %08lx\n", dwErr));
        return(dwErr);
    }

    //
    // While there are children still to be handled we continue on.
    //
    while (TRUE)        {

        if (rgelt.pwcsName != NULL)     {
            delete [] rgelt.pwcsName;
            rgelt.pwcsName = NULL;
        }

        dwErr = pDir->Next(&rgelt, &fetched);

        if (dwErr != ERROR_SUCCESS) {
            IDfsVolInlineDebOut((DEB_ERROR, "Failed to Enumerate %08lx\n", dwErr));
            break;
        }
        //
        // If we did not get back any children we are done.
        //
        if (fetched == 0)
            break;

        IDfsVolInlineDebOut((
            DEB_TRACE, "CDfsVolume::InitializePkt Name=%ws\n", rgelt.pwcsName));

        //
        // If the child name is . or .. we ignore it
        //
        if ((!wcscmp(rgelt.pwcsName, L".")) ||
            (!wcscmp(rgelt.pwcsName, L"..")))
            continue;

        dwErr = GetDfsVolumeFromStg(&rgelt, &child);

        if (dwErr != ERROR_SUCCESS)      {
            //
            // Log an EVENT here saying that volume object is corrupt and
            // continue on. We dont want to stop just because we cant handle
            // one particular object.
            //
            LogMessage( DEB_ERROR,
                        &(_peid.Prefix.Buffer),
                        1,
                        DFS_CANT_GET_TO_CHILD_IDFSVOL_MSG);
            IDfsVolInlineDebOut((DEB_ERROR, "Bad Object: %ws\n", rgelt.pwcsName));
            //
            // We dont want to give up as yet. So let us go on to the next
            // object.
            //
            fetched = 0;                //Do I need to do this?? 
            continue;
        }

        if (DFS_GET_RECOVERY_STATE(child->_RecoveryState) != DFS_RECOVERY_STATE_NONE)   {
            //
            // Now we need to call the recovery method to handle this stuff.
            // What do I do with the error code that I get back out here.
            //
            LogMessage(DEB_ERROR,
                        &(child->_peid.Prefix.Buffer),
                        1,
                        DFS_RECOVERY_NECESSARY_MSG);
            IDfsVolInlineDebOut((DEB_ERROR, "Object To Recover From: %ws\n",
                                rgelt.pwcsName));
            dwErr = child->RecoverFromFailure();
            //
            // We failed to recover from failure. The required messages would
            // have already been logged so we dont need to bother about that
            // here at all. But a failure in this process means we really cant
            // go on here. We would get a failure from the above only if there
            // was some drastic problem.
            //
            if (dwErr != ERROR_SUCCESS)     {
                IDfsVolInlineDebOut((DEB_ERROR, "Fatal RecoveryError \n"));
            }

            if (child->_Deleted == TRUE)        {
                //
                // Due to above recovery the volume got deleted. No point
                // going on along this path. Move on to next sibling.
                //
                child->Release();
                fetched = 0;
                continue;
            }
        }

        if (dwErr == ERROR_SUCCESS)      {

            //
            //  Create the subordinate PKT entry for the child.  This way we
            //  get to setup the links as well.
            //
            dwErr = child->CreateSubordinatePktEntry(PktHandle, &_peid, TRUE);
            if (dwErr != ERROR_SUCCESS)      {
                //
                //  This is a chance to write out an EVENT and then continue
                //  to the Initialization of further children.  We need to
                //  continue on even though we could not get to finish this
                //  volume.
                //
                LogMessage(DEB_ERROR,
                        &(child->_peid.Prefix.Buffer),
                        1,
                        DFS_UNABLE_TO_CREATE_SUBORDINATE_ENTRY_MSG);
                IDfsVolInlineDebOut((DEB_ERROR, "Object For Above Error: %ws\n",
                                rgelt.pwcsName));
            }
        }

        //
        // Now that the subordinate entry has been created we can go ahead
        // and call InitialisePkt on child. This makes a DepthFirst traversal.
        // Even if we could not create the subordinate entry for some reason,
        // we need to go on and attempt to initialize the rest. But we really
        // cant do that here. Riad: 455283. We need a different approach here.
        //
        if (dwErr == ERROR_SUCCESS)      {
            dwErr = child->InitializePkt(PktHandle);
            if (dwErr != ERROR_SUCCESS)      {
            //
            // We ignore this error and also dont bother to write out an
            // event since this should have been handled by some lower method.
            // We maybe sitting many levels high up and this error came all
            // the way back up.
            //
                IDfsVolInlineDebOut((DEB_ERROR, "InitPkt failed %08lx\n", dwErr));
            }
        }

        child->Release();
        //
        // Let us now attempt to enumerate the next child.
        //
        fetched = 0;

    }   //While fetched!=0

    //
    // If this volume's state is offline, set the local DC's pkt to reflect
    // that case
    //

    if (_State == DFS_VOLUME_STATE_OFFLINE) {

        NTSTATUS Status;
        CDfsService *psvc;

        for (psvc = _DfsSvcList.GetFirstService();
                psvc != NULL;
                    psvc = _DfsSvcList.GetNextService(psvc)) {

             LPWSTR wszService;

             wszService = psvc->GetServiceName();

             Status = DfsSetServiceState(
                        &_peid,
                        wszService,
                        DFS_SERVICE_TYPE_OFFLINE);

        }

        Status = DfsDCSetVolumeState(
                        &_peid,
                        PKT_ENTRY_TYPE_OFFLINE);


    }

    if (rgelt.pwcsName != NULL)
        delete [] rgelt.pwcsName;

    if (pDir != NULL)
        pDir->Release();

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::InitializePkt() exit\n"));

#if DBG
    if (DfsSvcVerbose & 0x80000000)
        DbgPrint("CDfsVolume::InitializePkt exit %d\n", dwErr);
#endif

    return(dwErr);
}

//+----------------------------------------------------------------------------
//
//  Function:   GetNetInfo
//
//  Synopsis:   Gets information about the volume.
//
//  Arguments:  [Level] -- Level of Information desired.
//
//              [pInfo] -- Pointer to info struct to be filled. Pointer
//                      members will be allocated using MIDL_user_allocate.
//                      The type of this variable is LPDFS_INFO_3, but one
//                      can pass in pointers to lower levels, and only the
//                      fields appropriate for the level will be touched.
//
//              [pcbInfo] -- On successful return, contains the size in
//                      bytes of the returned info. The returned size does
//                      not include the size of the DFS_INFO_3 struct itself.
//
//  Returns:    ERROR_SUCCESS -- Successfully returning info
//
//              ERROR_OUTOFMEMORY -- Out of memory
//
//-----------------------------------------------------------------------------

DWORD
CDfsVolume::GetNetInfo(
    DWORD Level,
    LPDFS_INFO_3 pInfo,
    LPDWORD pcbInfo)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cbInfo = 0, cbItem;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::GetNetInfo(l=%d)\n", Level));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("  CDfsVolume::GetNetInfo(l=%d)\n", Level);
#endif

    //
    // See if this is a Level 100 or 101. If so, we handle them right away
    // and return

    if (Level == 100) {

        LPDFS_INFO_100  pInfo100 = (LPDFS_INFO_100) pInfo;

        cbItem = (wcslen(_pwszComment) + 1) * sizeof(WCHAR);

        pInfo100->Comment = (LPWSTR) MIDL_user_allocate(cbItem);

        if (pInfo100->Comment != NULL) {

            wcscpy(pInfo100->Comment, _pwszComment);

            *pcbInfo = cbItem;

            return( ERROR_SUCCESS );

        } else {

            return( ERROR_OUTOFMEMORY );

        }

    }

    if (Level == 101) {

        LPDFS_INFO_101 pInfo101 = (LPDFS_INFO_101) pInfo;

        pInfo->State = _State;

        return( ERROR_SUCCESS );

    }

    //
    // level 4 isn't just an extension of 3, so handle it seperately
    //

    if (Level == 4) {

        LPDFS_INFO_4 pInfo4 = (LPDFS_INFO_4) pInfo;

        cbItem = sizeof(UNICODE_PATH_SEP) + _peid.Prefix.Length + sizeof(WCHAR);

        pInfo4->EntryPath = (LPWSTR) MIDL_user_allocate(cbItem);

        if (pInfo4->EntryPath != NULL) {

            pInfo4->EntryPath[0] = UNICODE_PATH_SEP;

            wcscpy(&pInfo4->EntryPath[1], _peid.Prefix.Buffer);

            cbInfo += cbItem;

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

        if (dwErr == ERROR_SUCCESS) {

            cbItem = (wcslen(_pwszComment)+1) * sizeof(WCHAR);
            pInfo4->Comment = (LPWSTR) MIDL_user_allocate(cbItem);

            if (pInfo4->Comment != NULL) {

                wcscpy( pInfo4->Comment, _pwszComment );

                cbInfo += cbItem;

            } else {

                dwErr = ERROR_OUTOFMEMORY;

            }

        }

        if (dwErr == ERROR_SUCCESS) {

            pInfo4->State = _State;

            pInfo4->Timeout = _Timeout;

            pInfo4->Guid = _peid.Uid;

            pInfo4->NumberOfStorages = _DfsSvcList.GetServiceCount();

            cbItem = pInfo4->NumberOfStorages * sizeof(DFS_STORAGE_INFO);
            pInfo4->Storage = (LPDFS_STORAGE_INFO) MIDL_user_allocate(cbItem);

            if (pInfo4->Storage != NULL) {

                ULONG i;
                CDfsService *pSvc;

                RtlZeroMemory(pInfo4->Storage, cbItem);

                cbInfo += cbItem;

                pSvc = _DfsSvcList.GetFirstService();

                i = 0;

                while (pSvc != NULL && dwErr == ERROR_SUCCESS) {

                    dwErr = pSvc->GetNetStorageInfo(&pInfo4->Storage[i], &cbItem);

                    cbInfo += cbItem;

                    i++;

                    pSvc = _DfsSvcList.GetNextService( pSvc );

                }

                if (dwErr != ERROR_SUCCESS) {

                    for (; i > 0; i--) {

                        MIDL_user_free(pInfo4->Storage[i-1].ServerName);
                        MIDL_user_free(pInfo4->Storage[i-1].ShareName);

                    }

                }

            } else {

                dwErr = ERROR_OUTOFMEMORY;

            }

        }

        //
        // See if we need to clean up...
        //

        if (dwErr != ERROR_SUCCESS) {

            if (pInfo4->EntryPath != NULL) {

                MIDL_user_free(pInfo4->EntryPath);

            }

            if (pInfo4->Storage != NULL) {

                MIDL_user_free(pInfo4->Storage);

            }

        }

        *pcbInfo = cbInfo;

        return(dwErr);

    }

    //
    // Level is 1,2 or 3
    //

    //
    // Fill in the Level 1 stuff
    //

    cbItem = sizeof(UNICODE_PATH_SEP) + _peid.Prefix.Length + sizeof(WCHAR);

    pInfo->EntryPath = (LPWSTR) MIDL_user_allocate(cbItem);

    if (pInfo->EntryPath != NULL) {

        pInfo->EntryPath[0] = UNICODE_PATH_SEP;

        wcscpy(&pInfo->EntryPath[1], _peid.Prefix.Buffer);

        cbInfo += cbItem;

    } else {

        dwErr = ERROR_OUTOFMEMORY;

    }

    //
    // Fill in the Level 2 stuff if needed
    //

    if (dwErr == ERROR_SUCCESS && Level > 1) {

        cbItem = (wcslen(_pwszComment)+1) * sizeof(WCHAR);
        pInfo->Comment = (LPWSTR) MIDL_user_allocate(cbItem);

        if (pInfo->Comment != NULL) {

            wcscpy( pInfo->Comment, _pwszComment );

            cbInfo += cbItem;

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

    }

    if (dwErr == ERROR_SUCCESS && Level > 1) {

        pInfo->State = _State;

        pInfo->NumberOfStorages = _DfsSvcList.GetServiceCount();

    }

    //
    // Fill in the Level 3 stuff if needed
    //

    if (dwErr == ERROR_SUCCESS && Level > 2) {

        cbItem = pInfo->NumberOfStorages * sizeof(DFS_STORAGE_INFO);
        pInfo->Storage = (LPDFS_STORAGE_INFO) MIDL_user_allocate(cbItem);

        if (pInfo->Storage != NULL) {

            ULONG i;
            CDfsService *pSvc;

            RtlZeroMemory(pInfo->Storage, cbItem);

            cbInfo += cbItem;

            pSvc = _DfsSvcList.GetFirstService();

            i = 0;

            while (pSvc != NULL && dwErr == ERROR_SUCCESS) {

                dwErr = pSvc->GetNetStorageInfo(&pInfo->Storage[i], &cbItem);

                cbInfo += cbItem;

                i++;

                pSvc = _DfsSvcList.GetNextService( pSvc );

            }

            if (dwErr != ERROR_SUCCESS) {

                for (; i > 0; i--) {

                    MIDL_user_free(pInfo->Storage[i-1].ServerName);
                    MIDL_user_free(pInfo->Storage[i-1].ShareName);

                }

            }

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

    }

    //
    // See if we need to clean up...
    //

    if (dwErr != ERROR_SUCCESS) {

        if (Level > 1) {

            if (pInfo->EntryPath != NULL) {

                MIDL_user_free(pInfo->EntryPath);

            }

        }

        if (Level > 2) {

            if (pInfo->Storage != NULL) {

                MIDL_user_free(pInfo->Storage);

            }
        }
    }

    //
    // Finally, we are done
    //

    *pcbInfo = cbInfo;

    return(dwErr);

}



//+-----------------------------------------------------------------------
//
// Member:      CDfsVolume::SetComment, public
//
// Synopsis:    Sets a comment on the volume object.
//
// Arguments:   [pwszComment] -- The comment
//
// Returns:
//
// History:     05/10/93        SudK    Created.
//
//------------------------------------------------------------------------
DWORD
CDfsVolume::SetComment(
    PWCHAR              pwszComment
)
{
    DWORD       dwErr = ERROR_SUCCESS;
    SYSTEMTIME  st;
    FILETIME    ftOld;
    LPWSTR      pwszOldComment;
    ULONG       ulen = wcslen(pwszComment);



    IDfsVolInlineDebOut((DEB_TRACE, "SetComment: %ws\n", pwszComment));

    ftOld = _ftComment;
    pwszOldComment = _pwszComment;
    _pwszComment = new WCHAR[ulen+1];

    if (_pwszComment == NULL)
            dwErr = ERROR_OUTOFMEMORY;
    else        {
        wcscpy(_pwszComment, pwszComment);

        GetSystemTime( &st );
        SystemTimeToFileTime( &st, &_ftComment );

        dwErr = SetIdProps(     _EntryType,
                                _State,
                                _peid.Prefix.Buffer,
                                _peid.ShortPrefix.Buffer,
                                _peid.Uid,
                                pwszComment,
                                _Timeout,
                                _ftEntryPath,
                                _ftState,
                                _ftComment,
                                FALSE);
    }

    if (dwErr != ERROR_SUCCESS) {
        if (_pwszComment) {
            delete [] _pwszComment;
        }
        _ftComment = ftOld;
        _pwszComment = pwszOldComment;
    }



    return(dwErr);
}



//+-------------------------------------------------------------------------
//
// Member:      CDfsVolume::FixServiceKnowledge
//
// Synopsis:    This method is called for fixing knowledge inconsistencies.
//              It checks to make sure that the given service does support
//              this volume and then goes on to do a CreateLocalVol call on
//              that service.
//
// Arguments:   [pwszServiceName] -- The principal name of service to be
//                      fixed.
//
// History:     06-April-1993       SudK            Created
//
//--------------------------------------------------------------------------
DWORD
CDfsVolume::FixServiceKnowledge(
    PWCHAR      pwszServiceName
)
{

    DWORD             dwErr = ERROR_SUCCESS;
    CDfsService         *pService;
    PWCHAR              ErrorStrs[3];

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::FixServiceKnowledge(%s)\n",
            pwszServiceName));

    dwErr = _DfsSvcList.GetServiceFromPrincipalName(pwszServiceName, &pService);

    if (dwErr == ERROR_SUCCESS) {

        //
        // We really dont care about errors since this is all heuristic. We
        // will merely log an error that's all.
        //

        dwErr = pService->FixLocalVolume(&_peid, _EntryType);

        if (dwErr != ERROR_SUCCESS) {

            //
            // Log the error and try to take the service off-line
            //

            DWORD dwErrOffLine;

            ErrorStrs[0] = _peid.Prefix.Buffer;
            ErrorStrs[1] = pwszServiceName;

            LogMessage( DEB_ERROR,
                        ErrorStrs,
                        2,
                        DFS_CANNOT_SET_SERVICE_PROPERTY_MSG);

            dwErrOffLine = pService->SetVolumeState(
                            &_peid,
                            DFS_SERVICE_TYPE_OFFLINE,
                            FALSE);

            if (dwErrOffLine == ERROR_SUCCESS) {

                dwErrOffLine = _DfsSvcList.SerializeSvcList();
            }

            if (dwErrOffLine == ERROR_SUCCESS) {

                _DfsSvcList.SetServiceListProperty( FALSE );

            }

        }

    } else {

        IDfsVolInlineDebOut((
            DEB_ERROR,
            "Could not find Service %ws on Volume: %ws\n",
            pwszServiceName,
            _peid.Prefix.Buffer));

    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::FixServiceKnowledge() exit\n"));

    return((dwErr));

}



//+---------------------------------------------------------------------
//
// Member:      CDfsVolume::Rename,        public
//
// Synopsis:    This method should be called if an object/file/directory
//              on this volume is to be renamed, and the name falls along an
//              exit point off this volume. This method will perform the
//              rename on the filesystem and then go on to call ModifyPrefix
//              on all the child volume objects which are affected by the
//              rename operation.
//
// Arguments:   [oldPrefix] -- The oldPrefix that needs to be modified. Prefix
//              [newPrefix] -- This should be ORG relative prefix.
//
// Returns:     ERROR_SUCCESS -- If all went well.
//
// Notes:       The old and newPaths should follow all requirements of a File
//              System Rename operation. Should vary only in last component etc.
//
// History:     31 April 1993   SudK    Created.
//              26 April 1993   SudK    Fixed to work properly.
//
//----------------------------------------------------------------------
DWORD
CDfsVolume::Rename(
    PWSTR               oldPrefix,
    PWSTR               newPrefix
)
{

    DWORD               dwErr = ERROR_SUCCESS;
    CDfsVolume          *child = NULL;
    CEnumDirectory      *pdir = NULL;
    DFSMSTATDIR          rgelt;
    ULONG               fetched = 0;
    WCHAR               wszOldPath[MAX_PATH], wszNewPath[MAX_PATH];
    PWSTR               pwszOldPath = wszOldPath;
    PWSTR               pwszNewPath = wszNewPath;
    ULONG               len = MAX_PATH;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::Rename(%ws,%ws)\n", oldPrefix, newPrefix));

    //
    // Need to check if this is the right idfsvol to call rename on.
    //
    ULONG ulen = _peid.Prefix.Length/sizeof(WCHAR);

    if ((wcslen(oldPrefix) <= ulen) ||
            (wcslen(newPrefix) <= ulen)) {
        //
        // Both old and new prefixes should be longer than the prefix of
        // this volume. If they are not then we can return error right away.
        //
        dwErr = NERR_DfsBadRenamePath;
    } else if ((_wcsnicmp(_peid.Prefix.Buffer, oldPrefix, ulen) != 0) ||
                (_wcsnicmp(_peid.Prefix.Buffer, newPrefix, ulen) != 0)) {

        //
        // Now we need to check to make sure that this volume's prefix is a
        // proper prefix of path being renamed.
        //
        dwErr = NERR_DfsBadRenamePath;

    } else if (_wcsicmp(oldPrefix, newPrefix) == 0) {
        //
        // Someone has given identical rename path. Return right away.
        //
        dwErr = NERR_DfsBadRenamePath;
    }

    if (dwErr == ERROR_SUCCESS) {

        len = wcslen(oldPrefix);

        if (len > (MAX_PATH - 2)) {
            pwszOldPath = new WCHAR[ len + 2 ];
            if (pwszOldPath == NULL) {
                dwErr = ERROR_OUTOFMEMORY;
            }
        }

        if (dwErr == ERROR_SUCCESS) {
            wcscpy( pwszOldPath, UNICODE_PATH_SEP_STR );
            wcscat( pwszOldPath, oldPrefix );
        }

    }

    if (dwErr == ERROR_SUCCESS)      {

        len = wcslen(newPrefix);

        if (len > (MAX_PATH - 2)) {
            pwszNewPath = new WCHAR[ len + 2 ];
            if (pwszNewPath == NULL) {
                dwErr = ERROR_OUTOFMEMORY;
            }
        }

        if (dwErr == ERROR_SUCCESS) {
            wcscpy( pwszNewPath, UNICODE_PATH_SEP_STR );
            wcscat( pwszNewPath, newPrefix );
        }

    }


    if (dwErr == ERROR_SUCCESS)      {
        //
        // Now do the Rename operation
        //
        NTSTATUS Status;

        Status = MoveFileOrJP(pwszOldPath, pwszNewPath);

        if (!NT_SUCCESS(Status)) {
            dwErr = RtlNtStatusToDosError(Status);
        }
        if (pwszOldPath != wszOldPath) {
            delete [] pwszOldPath;
        }
        if (pwszNewPath != wszNewPath) {
            delete [] pwszNewPath;
        }
    }

    if (dwErr == ERROR_SUCCESS)  {

        dwErr = _pStorage->GetEnumDirectory(&pdir);
        if (dwErr != ERROR_SUCCESS) {
            return(dwErr);
        }

        //
        // While there are children still to be handled we continue on.
        //

        rgelt.pwcsName = NULL;

        while (TRUE)        {

            if (rgelt.pwcsName != NULL) {
                delete [] rgelt.pwcsName;
                rgelt.pwcsName = NULL;
            }

            dwErr = pdir->Next(&rgelt, &fetched);

            if (dwErr != ERROR_SUCCESS)     {
                IDfsVolInlineDebOut((DEB_ERROR, "Failed to Enumeraate\n", 0));
                break;
            }
            //
            // If we did not get back any children we are done.
            //
            if (fetched == 0)
                break;

            //
            // If the child name is . or .. we ignore it
            //
            if ((!wcscmp(rgelt.pwcsName, L".")) ||
                (!wcscmp(rgelt.pwcsName, L"..")))
                continue;

            dwErr = GetDfsVolumeFromStg(&rgelt, &child);

            if (dwErr != ERROR_SUCCESS)      {
                //
                // Log an EVENT here saying that volume object is corrupt and
                // continue on. We dont want to stop just because we cant handle
                // one particular object.
                //
                LogMessage( DEB_ERROR,
                        &(_peid.Prefix.Buffer),
                        1,
                        DFS_CANT_GET_TO_CHILD_IDFSVOL_MSG);
                //
                // We dont want to give up as yet. So let us go on to the next
                // object.
                //
                fetched = 0;
                continue;
            }

            dwErr = child->ModifyEntryPath(oldPrefix, newPrefix);
            if (dwErr != ERROR_SUCCESS)      {
                //
                // We ignore this err since it would be logged further down.
                //
            }

            child->Release();

            //
            // Let us now attempt to enumerate the next child.
            //
            fetched = 0;

        }   //While TRUE

        if (pdir != NULL)
            pdir->Release();

    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::Rename() exit\n"));

    return(dwErr);

}



//+----------------------------------------------------------------------------
//
//  Method:     CDfsVolume::ModifyLocalEntryPath,private
//
//  Synopsis:   This method modifies the entry path on the volume object,
//              and modifies the local PKT to reflect the change.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
CDfsVolume::ModifyLocalEntryPath(
    PWCHAR newEntryPath,
    FILETIME ftEntryPath,
    BOOL fUpdatePkt)
{
    DWORD             dwErr = ERROR_SUCCESS;
    CUnicodeString      oldString, newString;

    dwErr = SetIdProps(
            _EntryType,
            _State,
            newEntryPath,
            _peid.ShortPrefix.Buffer,            
            _peid.Uid,
            _pwszComment,
            _Timeout,
            ftEntryPath,
            _ftState,
            _ftComment,
            FALSE);

    if (dwErr != ERROR_SUCCESS)     {
        //
        // We want to return right away. Can we hope that the private section
        // variable will get deleted and return or should we fix the private
        // _peid since this operation never succeeded.
        //
        IDfsVolInlineDebOut((
            DEB_ERROR, "Unable To modify Prefix to [%ws]\n", newEntryPath));

        return(dwErr);             //Raid: 455283 cant return this error here.
    }

    //
    // Now that the object has changed let us modify the Private variables.
    //
    oldString.Copy(_peid.Prefix.Buffer);

    newString.Copy(newEntryPath);
    if (_peid.Prefix.Buffer != _EntryPathBuffer)
        delete [] _peid.Prefix.Buffer;
    newString.Transfer(&(_peid.Prefix));

    if (fUpdatePkt) {
        dwErr = UpdatePktEntry(NULL);
    }

    if (dwErr != ERROR_SUCCESS)     {

        DWORD dwErr2;
        delete [] _peid.Prefix.Buffer;
        oldString.Transfer(&(_peid.Prefix));
        dwErr2 = SetIdProps(_EntryType,
                        _State,
                        _peid.Prefix.Buffer,
                        _peid.ShortPrefix.Buffer,
                        _peid.Uid,
                        _pwszComment,
                        _Timeout,
                        _ftEntryPath,
                        _ftState,
                        _ftComment,
                        FALSE);

        if (dwErr2 != ERROR_SUCCESS) {
            IDfsVolInlineDebOut((
                DEB_ERROR,
                "Error restoring id props in failed rename operation %08lx\n",
                dwErr2));
        }

    } else {

        _ftEntryPath = ftEntryPath;

    }

    return(dwErr);

}



//+---------------------------------------------------------------------
//
// Method:      CDfsVolume::ModifyEntryPath,public
//
// Synopsis:    This method modifies the entry path on this volume object
//              and at the same time modifies the entry paths on all the
//              services by issuing FSCTRLs. It then turns around and calls
//              the same API on all the children since their entrypaths are
//              also affected by this change.
//
// Arguments:   [oldPrefix] -- The old Prefix on the Parent volume object.
//              [newPrefix] -- The new Prefix on the Parent volume object.
//
// Returns:     ERROR_SUCCESS -- If all went well.
//
// Notes:       This method does not bother to check for the validity of
//              the new entryPath etc. THat should have happened way before
//              we got here.
//
// History:     31 April 1993   SudK    Created.
//
//----------------------------------------------------------------------
DWORD
CDfsVolume::ModifyEntryPath(
    LPWSTR      oldPrefix,
    LPWSTR      newPrefix)
{

    DWORD               dwErr = ERROR_SUCCESS;
    CDfsService         *pService;
    PWCHAR              ErrorStrs[2];
    PWCHAR              childNewPrefix;
    CEnumDirectory      *pdir;
    DFSMSTATDIR         rgelt;
    ULONG               fetched = 0;
    CDfsVolume          *child = NULL;
    PWCHAR              newEntryPath;
    SYSTEMTIME          st;
    FILETIME            ftEntryPath;

    IDfsVolInlineDebOut((DEB_TRACE, "ModifyEntryPath(%s,%s)\n", oldPrefix, newPrefix));

    //
    // First, see if we need to modify anything at all. If the oldPrefix
    // is *not* a prefix of our name, then our name is *not* changing, and
    // we just return.
    //
    if (_wcsnicmp(_peid.Prefix.Buffer, oldPrefix, wcslen(oldPrefix)) != 0) {
        IDfsVolInlineDebOut((DEB_TRACE, "ModifyEntryPath() exit\n"));
        return( ERROR_SUCCESS );
    }

    //
    // Next, compute the new entry path
    //
    ComputeNewEntryPath( oldPrefix, newPrefix, _peid.Prefix.Buffer, &newEntryPath );

    if (newEntryPath == NULL) {
        return( ERROR_OUTOFMEMORY );
    }

    //
    // Let us first modify the prefix locally on the object. We trust the
    // arguments since they could have been passed by our own code. So we
    // will not bother with a TRY/CATCH etc. out here.
    //

    GetSystemTime( &st );
    SystemTimeToFileTime( &st, &ftEntryPath );
    dwErr = ModifyLocalEntryPath( newEntryPath, ftEntryPath, TRUE );

    if (dwErr != ERROR_SUCCESS) {

        delete [] newEntryPath;

        return(dwErr);

    }

    //
    // Now that the prefix has been modified locally we need to update all the
    // services.
    //
    pService = _DfsSvcList.GetFirstService();

    while (pService != NULL)    {

        dwErr = pService->ModifyPrefix(&_peid);

        //
        // If we fail to modify the prefix we really dont want to stop. We go
        // on and update the other services and volumes.
        //
        if (dwErr != ERROR_SUCCESS) {
            ErrorStrs[0] = _peid.Prefix.Buffer;
            ErrorStrs[1] = pService->GetServiceName();
            LogMessage(DEB_ERROR,
                        ErrorStrs,
                        2,
                        DFS_MODIFY_PREFIX_FAILED_MSG);

        }
        dwErr = ERROR_SUCCESS;
        pService = _DfsSvcList.GetNextService(pService);

    }

    //
    // Now we have updated all the services of this volume. Let us now get to
    // all our children and call this method on them again.
    //

    dwErr = _pStorage->GetEnumDirectory(&pdir);
    if (dwErr != ERROR_SUCCESS) {
        delete [] newEntryPath;
        return(dwErr);
    }

    //
    // While there are children still to be handled we continue on.
    //
    rgelt.pwcsName = NULL;

    while (TRUE)        {

        if (rgelt.pwcsName != NULL) {
            delete [] rgelt.pwcsName;
            rgelt.pwcsName = NULL;
        }

        dwErr = pdir->Next(&rgelt, &fetched);

        if (dwErr != ERROR_SUCCESS) {
            IDfsVolInlineDebOut((DEB_ERROR, "Failed to Enumeraate\n", 0));
            break;
        }

        //
        // If we did not get back any children we are done.
        //
        if (fetched == 0)
            break;

        //
        // If the child name is . or .. we ignore it
        //
        if ((!wcscmp(rgelt.pwcsName, L".")) ||
            (!wcscmp(rgelt.pwcsName, L"..")))
                continue;

        dwErr = GetDfsVolumeFromStg(&rgelt, &child);

        if (dwErr != ERROR_SUCCESS)      {
            //
            // Log an EVENT here saying that volume object is corrupt and
            // continue on. We dont want to stop just because we cant handle
            // one particular object.
            //
            LogMessage( DEB_ERROR,
                        &(_peid.Prefix.Buffer),
                        1,
                        DFS_CANT_GET_TO_CHILD_IDFSVOL_MSG);
            //
            // We dont want to give up as yet. So let us go on to the next
            // object.
            //
            fetched = 0;
            continue;
        }

        dwErr = child->ModifyEntryPath(oldPrefix, newPrefix);
        if (dwErr != ERROR_SUCCESS)      {
            //
            // We ignore this error and also dont bother to write out an
            // event since this should have been handled by some lower method.
            // We maybe sitting many levels high up and this error came all
            // the way back up.
        }

        child->Release();
        //
        // Let us now attempt to enumerate the next child.
        //
        fetched = 0;

    }   //While TRUE

    if (pdir != NULL)
        pdir->Release();

    delete [] newEntryPath;

    IDfsVolInlineDebOut((DEB_TRACE, "ModifyEntryPath() exit\n"));

    return(dwErr);
}


//+-----------------------------------------------------------------------
//
// Member:      CDfsVolume::GetReplicaSetID, public
//
// Synopsis:    This method returns the replica set ID (if any) stored with
//              this volume object.
//
// Arguments:   [pguidRsid] -- This is where the replica set ID is returned.
//
// Returns:     If there is no replica set ID then caller gets NullGuid.
//
// History:     16 Aug 1993     Alanw   Created
//              19 Oct 1993     SudK    Implemented
//
//------------------------------------------------------------------------
DWORD
CDfsVolume::GetReplicaSetID(
    GUID        *pguidRsid
)
{
    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::GetReplicaSetID()\n"));

    (*pguidRsid) = _DfsSvcList._ReplicaSetID;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::GetReplicaSetID() exit\n"));

    return(ERROR_SUCCESS);
}


//+-----------------------------------------------------------------------
//
// Member:      CDfsVolume::SetReplicaSetID, public
//
// Synopsis:    This method sets the replica set ID associated with
//              this volume object.
//
// Arguments:   [pguidRsid] -- A pointer to the replica set ID.
//
// Returns:
//
// History:     16 Aug 1993     Alanw   Created
//              19 Oct 1993     SudK    Implemented
//
//------------------------------------------------------------------------
DWORD
CDfsVolume::SetReplicaSetID(
    GUID        *pguidRsid
)
{
    DWORD             dwErr = ERROR_SUCCESS;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::SetReplicaSetID()\n"));

    _DfsSvcList._ReplicaSetID = *pguidRsid;
    //
    // I am assuming here that the service List is always setup if someone
    // called this method. For now this is correct.
    //
    dwErr = _DfsSvcList.SetServiceListProperty(FALSE);

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::SetReplicaSetID() exit\n"));

    return(dwErr);

}


//+-----------------------------------------------------------------------
//
// Method:      CDfsVolume::ChangeStorageID
//
// Synopsis:    Modify the storage ID on the replica mentioned.
//
// Arguments:   [pwszMachineName] --    The replica whose state needs to be
//                                      changed.
//              [pwszStorageId] --      The new storageId on the above replica
//
// Returns:
//
// History:     7/21/94         SudK    Created
//
//------------------------------------------------------------------------
DWORD
CDfsVolume::ChangeStorageID(
    LPWSTR      pwszMachineName,
    LPWSTR      pwszNetStorageId
)
{
    return(ERROR_SUCCESS);
}



//+-----------------------------------------------------------------------
//
// Member:      CDfsVolume::SetReplicaState, public
//
// Synopsis:    Change the state of the replica indicated.
//
// Arguments:   [pwszMachineName] -- The server whose state needs to be
//                      changed.
//              [pwszShareName] -- The share on server whose state needs to
//                      be changed.
//              [fState] -- The State to set on this.
//
// Returns:
//
// History:     7/21/94         SudK    Created
//
//------------------------------------------------------------------------
DWORD
CDfsVolume::SetReplicaState(
    LPWSTR      pwszMachineName,
    LPWSTR      pwszShareName,
    ULONG       fState
)
{
    DWORD dwErr = ERROR_SUCCESS;
    CDfsService *psvc;
    ULONG svcState;
    PWCHAR pMachineName;
    PWCHAR pShareName;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::SetReplicaState(%ws,%ws)\n",
            pwszMachineName, pwszShareName));

    switch (fState) {
    case DFS_STORAGE_STATE_OFFLINE:
        svcState = DFS_SERVICE_TYPE_OFFLINE;
        break;

    case DFS_STORAGE_STATE_ONLINE:
        svcState = 0;
        break;

    default:
        return( ERROR_INVALID_PARAMETER );
        break;

    }

    for (psvc = _DfsSvcList.GetFirstService();
            psvc != NULL;
                psvc = _DfsSvcList.GetNextService(psvc)) {

        pMachineName = psvc->GetServiceName();
        pShareName = psvc->GetShareName();

        if (pMachineName != NULL && _wcsicmp(pwszMachineName, pMachineName) == 0 &&
                pShareName != NULL && _wcsicmp(pwszShareName, pShareName) == 0) {

            dwErr = psvc->SetVolumeState( &_peid, svcState, TRUE );

            if (dwErr == ERROR_SUCCESS) {

                //
                // Store the udpated svclist to the volume object. We don't
                // revert if we fail to save to disk. Instead, we return the
                // error, and let the admin try again if she wishes.
                //

                dwErr = _DfsSvcList.SerializeSvcList();

                if (dwErr == ERROR_SUCCESS) {

                    dwErr = _DfsSvcList.SetServiceListProperty( FALSE );

                }

            }

        }

    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::SetReplicaState() exit\n"));

    return(dwErr);

}



//+-----------------------------------------------------------------------
//
// Member:      CDfsVolume::SetVolumeState,     public
//
// Synopsis:    Change the state of the volume indicated.
//
// Arguments:   [fState] -- The State to set on this.
//
// Returns:
//
// History:     7/21/94         SudK    Created
//
//------------------------------------------------------------------------
DWORD
CDfsVolume::SetVolumeState(
    ULONG       fState
)
{
    DWORD dwErr;
    NTSTATUS status;
    CDfsService *psvc;
    ULONG svcState, volState;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::SetVolumeState(0x%x)\n", fState));

    switch (fState) {
    case DFS_VOLUME_STATE_OFFLINE:
        svcState = DFS_SERVICE_TYPE_OFFLINE;
        volState = PKT_ENTRY_TYPE_OFFLINE;
        break;

    case DFS_VOLUME_STATE_ONLINE:
        svcState = 0;
        volState = 0;
        break;

    default:
        return( ERROR_INVALID_PARAMETER );
        break;

    }

    status = DfsDCSetVolumeState( &_peid, volState );

    if (NT_SUCCESS(status)) {

        SYSTEMTIME st;

        _State = fState;

        GetSystemTime( &st );
        SystemTimeToFileTime( &st, &_ftState );

        dwErr = SetIdProps(_EntryType,
                        _State,
                        _peid.Prefix.Buffer,
                        _peid.ShortPrefix.Buffer,
                        _peid.Uid,
                        _pwszComment,
                        _Timeout,
                        _ftEntryPath,
                        _ftState,
                        _ftComment,
                        FALSE);

    } else {

        dwErr = RtlNtStatusToDosError(status);

    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::SetVolumeState()\n"));

    return(dwErr);

}

//+-----------------------------------------------------------------------
//
// Member:      CDfsVolume::SetVolumeTimeout,     public
//
// Synopsis:    Change the timeout of the volume
//
// Arguments:   [Timeout] -- The new timeout to set on this.
//
// Returns:
//
//------------------------------------------------------------------------
DWORD
CDfsVolume::SetVolumeTimeout(
    ULONG       Timeout
)
{
    DWORD dwErr = 0;
    NTSTATUS status;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::SetVolumeTimeout(0x%x)\n", Timeout));

    status = DfsSetVolumeTimeout( &_peid, Timeout );

    if (NT_SUCCESS(status)) {

        _Timeout = Timeout;

        dwErr = SetIdProps(_EntryType,
                        _State,
                        _peid.Prefix.Buffer,
                        _peid.ShortPrefix.Buffer,
                        _peid.Uid,
                        _pwszComment,
                        _Timeout,
                        _ftEntryPath,
                        _ftState,
                        _ftComment,
                        FALSE);

    } else {

        dwErr = RtlNtStatusToDosError(status);

    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::SetVolumeTimeout()\n"));

    return(dwErr);
}

//+-------------------------------------------------------------------------
//
//  Function:  CDfsVolume::GetObjectID
//
//  Synopsis:  Return the volume object guid
//
//--------------------------------------------------------------------------
DWORD
CDfsVolume::GetObjectID(LPGUID guidVolume)
{
    *guidVolume = _peid.Uid;

    return(ERROR_SUCCESS);
}

//+---------------------------------------------------------------------
//
// Function:    ComputeNewEntryPath, private
//
// Synopsis:    This function is a helper function for the following functions
//              to be able to compute the entry paths for a child volume given
//              the change in their entrypath's and the child's current path.
//
// Arguments:   [oldPath] -- OldPath of currentVolume. Prefix
//              [newPath] -- NewPath of currentVOlume. Prefix
//              [childPath] -- CurrentPath of child. Prefix
//              [childNewPath] -- NewPath of child. Prefix
//
// Returns:     NOTHING.
//
// History:     05-01-93        SudK    Created.
//
//----------------------------------------------------------------------
VOID
ComputeNewEntryPath(
    PWCHAR      oldPath,
    PWCHAR      newPath,
    PWCHAR      childPath,
    PWCHAR      *childNewPath
)
{

    ULONG       newLen, oldLen;
    PWCHAR      childComponent;

    oldLen = wcslen(oldPath);
    newLen = wcslen(newPath);
    newLen += wcslen(childPath) - oldLen;

    *childNewPath = new WCHAR[newLen + sizeof(WCHAR)];

    if (*childNewPath != NULL) {

        wcscpy(*childNewPath, newPath);

        childComponent = childPath + oldLen;

        wcscat(*childNewPath, childComponent);

    }

    return;
}

//+----------------------------------------------------------------------------
//
//  Function:   MoveFileOrJP, private
//
//  Synopsis:   Similar to Win32 MoveFile, except if the named src is a JP,
//              then the JP will get renamed.
//
//  Arguments:  [pwszSrcName] -- Name of the Src object.
//              [pwszTgtName] -- New name of the object.
//
//  Returns:    [STATUS_SUCCESS] -- Rename succeeded.
//
//-----------------------------------------------------------------------------

NTSTATUS
MoveFileOrJP(
    IN PCWSTR pwszSrcName,
    IN PCWSTR pwszTgtName)
{
    UNICODE_STRING ustrSrc = {0}, ustrTgt = {0};
    NTSTATUS Status = STATUS_SUCCESS;

    if (!RtlDosPathNameToNtPathName_U( pwszSrcName, &ustrSrc, NULL, NULL)) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        DFSM_TRACE_HIGH(ERROR, MoveFileOrJP_Error1, LOGSTATUS(Status));

    } else if (!RtlDosPathNameToNtPathName_U(
                pwszTgtName, &ustrTgt, NULL, NULL)) {

        Status = STATUS_INSUFFICIENT_RESOURCES;

        DFSM_TRACE_HIGH(ERROR, MoveFileOrJP_Error2, LOGSTATUS(Status));
    }

    if (NT_SUCCESS(Status)) {
        OBJECT_ATTRIBUTES   oaSrc;
        HANDLE              hSrc;
        IO_STATUS_BLOCK     iosb;


        InitializeObjectAttributes(
            &oaSrc,
            &ustrSrc,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

        Status = NtCreateFile(
                    &hSrc,
                    FILE_WRITE_ATTRIBUTES |
                        FILE_READ_ATTRIBUTES |
                        DELETE |
                        SYNCHRONIZE,
                    &oaSrc,
                    &iosb,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ,
                    FILE_OPEN,
                    FILE_DIRECTORY_FILE |
                        FILE_SYNCHRONOUS_IO_NONALERT,
                    pOpenIfJPEa,
                    cbOpenIfJPEa);

        DFSM_TRACE_ERROR_HIGH(Status, ALL_ERROR, MoveFileOrJP_Error_NtCreateFile, LOGSTATUS(Status));

        if (Status == STATUS_DFS_EXIT_PATH_FOUND) {

            Status = NtCreateFile(
                        &hSrc,
                        FILE_READ_ATTRIBUTES |
                            FILE_WRITE_ATTRIBUTES |
                            DELETE |
                            SYNCHRONIZE,
                        &oaSrc,
                        &iosb,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ,
                        FILE_OPEN,
                        FILE_SYNCHRONOUS_IO_NONALERT,
                        pOpenIfJPEa,
                        cbOpenIfJPEa);

            DFSM_TRACE_ERROR_HIGH(Status, ALL_ERROR, MoveFileOrJP_Error_NtCreateFile2, LOGSTATUS(Status));
        }

        if (NT_SUCCESS(Status)) {

            Status = iosb.Status;

        }

        if (NT_SUCCESS(Status)) {
            PFILE_RENAME_INFORMATION pRenameInfo;
            ULONG cbRenameInfo;

            cbRenameInfo = sizeof(FILE_RENAME_INFORMATION) + ustrTgt.Length;

            pRenameInfo = (PFILE_RENAME_INFORMATION) new BYTE [cbRenameInfo];

            if (pRenameInfo != NULL) {

                pRenameInfo->ReplaceIfExists = FALSE;
                pRenameInfo->RootDirectory = NULL;
                pRenameInfo->FileNameLength = ustrTgt.Length;
                CopyMemory(
                    &pRenameInfo->FileName[0],
                    ustrTgt.Buffer,
                    ustrTgt.Length);

                Status = NtSetInformationFile(
                            hSrc,
                            &iosb,
                            pRenameInfo,
                            cbRenameInfo,
                            FileRenameInformation);

                DFSM_TRACE_ERROR_HIGH(Status, ALL_ERROR, MoveFileOrJP_Error_NtSetInformationFile, LOGSTATUS(Status));
                delete [] pRenameInfo;

                if (NT_SUCCESS(Status)) {

                    Status = iosb.Status;

                }

            } else {

                Status = STATUS_INSUFFICIENT_RESOURCES;
                DFSM_TRACE_HIGH(ERROR, MoveFileOrJP_Error3, LOGSTATUS(Status));
            }

            NtClose( hSrc );

        } // end if successfully opened src

    } // end if successfull converted dos names to nt names.

    if (ustrSrc.Buffer != NULL) {

        RtlFreeUnicodeString( &ustrSrc );

    }

    if (ustrTgt.Buffer != NULL) {

        RtlFreeUnicodeString( &ustrTgt );

    }

    return( Status );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\idfsvsup.cxx ===
//-------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (CC) Microsoft Corporation 1992, 1992
//
// File:        idfsvsup.cxx
//
// Contents:    This contains support methods for the IDfsVol interface
//              implementation.
//
//-------------------------------------------------------------
//#include <ntos.h>
//#include <ntrtl.h>
//#include <nturtl.h>
//#include <dfsfsctl.h>
//#include <windows.h>

#include <headers.hxx>
#pragma hdrstop

#include <dfserr.h>
#include "cdfsvol.hxx"
#include "dfsmwml.h"

NTSTATUS
DfspCreateExitPoint (
    IN  HANDLE                      DriverHandle,
    IN  LPGUID                      Uid,
    IN  LPWSTR                      Prefix,
    IN  ULONG                       Type,
    IN  ULONG                       ShortPrefixLen,
    OUT LPWSTR                      ShortPrefix);

NTSTATUS
DfspDeleteExitPoint (
    IN  HANDLE                      DriverHandle,
    IN  LPGUID                      Uid,
    IN  LPWSTR                      Prefix,
    IN  ULONG                       Type);


//+-------------------------------------------------------------------------
//
// Member:      CDfsVolume::CreateObject, public
//
// Synopsis:    This method merely creates a volume object. This has no
//              distributed operations associated with this operation.
//
// Arguments:   [pwzVolObjName] -- VOlume object Name
//              [EntryPath] -- The EntryPath
//              [VolType] -- VolumeType
//              [pReplicaInfo] -- ReplicaInfo. This is optional.
//
// Returns:
//
// Notes:       Raid: 455299 This function could potentially fail and leave an
//              object hanging around??
//
// History:     17-May-1993     SudK    Created.
//
//--------------------------------------------------------------------------
DWORD
CDfsVolume::CreateObject(
    PWSTR                       pwszVolObjName,
    LPWSTR                      pwszPrefix,
    ULONG                       ulVolType,
    PDFS_REPLICA_INFO           pReplicaInfo,
    PWCHAR                      pwszComment,
    GUID                        *pUid
)
{
    DWORD     dwErr = ERROR_SUCCESS;
    CDfsService *pService;
    SYSTEMTIME st;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::CreateVolObject(%ws,%ws,0x%x,%ws)\n",
            pwszVolObjName, pwszPrefix, ulVolType, pwszComment));

    //
    // First put this name in the private section.
    //
    ULONG volLen = wcslen(pwszVolObjName);
    if (volLen > MAX_PATH) {
        _pwzFileName = new WCHAR[volLen + 1];
    } else {
        _pwzFileName = _FileNameBuffer;
    }

    if (_pwzFileName == NULL)
        return( ERROR_OUTOFMEMORY );

    wcscpy(_pwzFileName, pwszVolObjName);

    IDfsVolInlineDebOut((DEB_TRACE, "Creating Object%ws\n", pwszVolObjName));

    //
    // Create the storage object.
    //
    dwErr =  DfsmCreateStorage(
            pwszVolObjName,
            &_pStorage);

    if (dwErr != ERROR_SUCCESS)     {
        IDfsVolInlineDebOut((DEB_ERROR,
            "Unable to create directory storage object %08lx %ws\n",
            dwErr, pwszVolObjName));
        return(dwErr);
    }

    //
    // First thing we do now is to setup the Class.
    //
    dwErr =  _pStorage->SetClass(CLSID_CDfsVolume);

    if (dwErr != ERROR_SUCCESS)     {
        IDfsVolInlineDebOut((DEB_ERROR,
            "Unable to set Class on this %ws\n", pwszVolObjName));
        return(dwErr);
    }

    //
    // This is where we need to init and create the dummy property sets
    // so that next time around we can set them and dont need to create them.
    //

    dwErr =  SetVersion( TRUE );

    if (dwErr != ERROR_SUCCESS)     {
        IDfsVolInlineDebOut((DEB_ERROR,
            "Unable to create version propset for %ws Error: %08lx\n",
            pwszVolObjName, dwErr));
        return(dwErr);
    }

    GUID        Uid;

    if (pUid == NULL) {
        dwErr =  UuidCreate(&Uid);
        _peid.Uid = Uid;
    } else {
        _peid.Uid = *pUid;
    }

    _EntryType = ulVolType;

    ULONG epLen = wcslen(pwszPrefix);
    if (epLen > MAX_PATH) {
        _peid.Prefix.Buffer = new WCHAR[epLen + 1];
        _peid.Prefix.MaximumLength = (USHORT) ((epLen + 1)*sizeof(WCHAR));
    } else {
        _peid.Prefix.MaximumLength = sizeof(_EntryPathBuffer);
        _peid.Prefix.Buffer = _EntryPathBuffer;
    }

    if (_peid.Prefix.Buffer == NULL)
        return( ERROR_OUTOFMEMORY );

    _peid.Prefix.Length = (USHORT) epLen*sizeof(WCHAR);
    wcscpy(_peid.Prefix.Buffer, pwszPrefix);

    //
    // We don't yet know the short name of this volume, so simply allocate
    // enough room and fill it with the full prefix. When an exit point
    // corresponding to this volume is created, the short prefix might be
    // modified.
    //
    // Note that it is tempting to think that the short prefix is <= the full
    // prefix in size. This, however, is not a valid assumption, because
    // names like A.BCDE qualify as LFNs, and their 8.3 equivalents look like
    // A12345~1.BCD!
    //

    ULONG i, sepLen;

    for (i = 0, sepLen = 0; i < epLen; i++) {
        if (pwszPrefix[i] == UNICODE_PATH_SEP)
            sepLen ++;
    }

    sepLen *= (1+8+1+3);                         // For \8.3

    if (sepLen < epLen)
        sepLen = epLen;

    if (sepLen > MAX_PATH) {
        _peid.ShortPrefix.Buffer = new WCHAR[sepLen + 1];
        _peid.ShortPrefix.MaximumLength = (USHORT) ((sepLen + 1)*sizeof(WCHAR));
    } else {
        _peid.ShortPrefix.Buffer = _ShortPathBuffer;
        _peid.ShortPrefix.MaximumLength = sizeof(_ShortPathBuffer);
    }

    if (_peid.ShortPrefix.Buffer == NULL)
        return( ERROR_OUTOFMEMORY );

    _peid.ShortPrefix.Length = (USHORT) epLen*sizeof(WCHAR);
    wcscpy(_peid.ShortPrefix.Buffer, pwszPrefix);

    //
    // We need to deal with a NULL comment as well. 
    //
    if (pwszComment != NULL) {
        _pwszComment = new WCHAR[wcslen(pwszComment) + 1];
	if (_pwszComment != NULL) {
	  wcscpy(_pwszComment, pwszComment);
	}
    } else {
        _pwszComment = new WCHAR[1];
	if (_pwszComment != NULL) {
	  *_pwszComment = UNICODE_NULL;
	}
    }
    if (_pwszComment == NULL) {
        return( ERROR_OUTOFMEMORY );
    }	

    GetSystemTime( &st );
    SystemTimeToFileTime( &st, &_ftEntryPath );
    _ftComment = _ftState = _ftEntryPath;

    dwErr =  SetIdProps(
            ulVolType,
            _State,
            pwszPrefix,
            pwszPrefix,
            _peid.Uid,
            _pwszComment,
            _Timeout,
            _ftEntryPath,
            _ftState,
            _ftComment,
            TRUE);

    if (dwErr != ERROR_SUCCESS)
        return(dwErr);

    _Recover.Initialize(_pStorage);
    _Recover.SetDefaultProps();

    //
    // Now let us set a NULL service List property. This method will create
    // the stream as well. We dont need to bother.
    //
    dwErr =  _DfsSvcList.SetNullSvcList(_pStorage);

    if (dwErr != ERROR_SUCCESS)
        return(dwErr);

    _Deleted = FALSE;

    //
    // Everything is setup now. We can set the appropriate service etc.
    //
    if (pReplicaInfo != NULL)   {
        pService = new CDfsService(pReplicaInfo, FALSE, &dwErr);
        if (pService == NULL) {
            dwErr =  ERROR_OUTOFMEMORY;
        }

        if (dwErr == ERROR_SUCCESS) {
            dwErr =  _DfsSvcList.SetNewService(pService);
            if (dwErr != ERROR_SUCCESS) {
                delete pService;
            }
        }
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::CreateVolObject() exit\n"));

    return(dwErr);

}


//+-------------------------------------------------------------------------
//
// Member:      CDfsVolume::GetDfsVolumeFromStg, private
//
// Synopsis:    This method takes a STATDIR structure and returns a CDfsVol
//              pointer to the object corresponding to that.
//
// Arguments:   [rgelt] -- Pointer to the DFSMSTATDIR structure.
//              [ppDfsVol] -- This is where the DfsVol is returned.
//
// Returns:     [ERROR_SUCCESS] -- If successfully set the parent's path.
//
//              [ERROR_OUTOFMEMORY] -- If unable to allocate memory for parent's
//                      path.
//
//              Error from loading the volume object
//
//--------------------------------------------------------------------------
DWORD
CDfsVolume::GetDfsVolumeFromStg(
    DFSMSTATDIR *rgelt,
    CDfsVolume **ppDfsVol)
{
    DWORD             dwErr =  ERROR_SUCCESS;
    PWCHAR              pwszFullName;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::GetDfsVolumeFromStg()\n"));

    //
    // Allocate a new CDfsVolume and initialize with appropriate name.
    //
    *ppDfsVol = new CDfsVolume();
    if (*ppDfsVol == NULL)
        return( ERROR_OUTOFMEMORY );

    pwszFullName = new WCHAR[wcslen(_pwzFileName) + wcslen(rgelt->pwcsName) + 2];

    if (pwszFullName != NULL) {

        wcscpy(pwszFullName, _pwzFileName);
        wcscat(pwszFullName, L"\\");
        wcscat(pwszFullName, rgelt->pwcsName);

        dwErr =  (*ppDfsVol)->LoadNoRegister(pwszFullName, 0);

        delete [] pwszFullName;

    } else {

        dwErr = ERROR_OUTOFMEMORY;

    }

    if (dwErr != ERROR_SUCCESS) {
        (*ppDfsVol)->Release();
        *ppDfsVol = NULL;
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::GetDfsVolumeFromStg() exit\n"));

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
// Member:      CDfsVolume::SetParentPath, private
//
// Synopsis:    This method figures out the name of the parent object and
//              sets it up in the private section of this instance.
//
// Arguments:   None
//
// Returns:     [ERROR_SUCCESS] -- If successfully set the parent's path.
//
//              [ERROR_OUTOFMEMORY] -- If unable to allocate memory for parent's
//                      path.
//
//--------------------------------------------------------------------------
DWORD
CDfsVolume::SetParentPath(void)
{

    PWCHAR              pwszLastComponent;
    ULONG               parentLen;

    pwszLastComponent = wcsrchr(_pwzFileName, L'\\');

    if(pwszLastComponent == NULL) {
	return ERROR_INVALID_DATA;
    }

    ASSERT(*(pwszLastComponent + 1) != UNICODE_NULL);

    //
    // Let us now figure out the length of the parent Name and copy over
    // appropriate number of characters.
    //

    if (_pwszParentName != _ParentNameBuffer)
        delete [] _pwszParentName;

    parentLen = wcslen(_pwzFileName) - wcslen(pwszLastComponent);

    if (parentLen > MAX_PATH) {

        _pwszParentName = new WCHAR[parentLen + 1];

        if (_pwszParentName == NULL)
            return( ERROR_OUTOFMEMORY );

    } else {

        _pwszParentName = _ParentNameBuffer;

    }

    wcsncpy(_pwszParentName, _pwzFileName, parentLen);

    _pwszParentName[parentLen] = UNICODE_NULL;

    return(ERROR_SUCCESS);

}


//+-------------------------------------------------------------------------
//
// Member:      CDfsVolume::GetParent, private
//
// Synopsis:    This function returns a pointer to IDfsVolume to the parent
//              of the present object. The release function on this
//              should be called by the caller of this function. We use
//              Ths IStorage interface to get to the parent.
//
// Arguments:   [pIDfsParent] -- This is where the IDfsVolume for parent is
//                      returned.
//
// Returns:     [ERROR_SUCCESS] -- If everything went well.
//
//              [ERROR_OUTOFMEMORY] -- Unable to create parent instance.
//
// History:     14-Sep-92       SudK            Created
//
//--------------------------------------------------------------------------

DWORD
CDfsVolume::GetParent(
    CDfsVolume **parent)
{
    DWORD             dwErr =  ERROR_SUCCESS;
    CDfsVolume          *pDfsVol;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::GetParent()\n"));

    //
    // First we get the parent's pathname and then we can do the appropriate.
    //

    dwErr =  SetParentPath();

    if (dwErr != ERROR_SUCCESS) {
        IDfsVolInlineDebOut((
            DEB_ERROR, "Unable to get parentPath %ws %08lx\n",
            _pwzFileName, dwErr));
        return(dwErr);
    }

    //
    // Now we instantiate a CDfsVolume structure and then initialise it.
    //

    pDfsVol = new CDfsVolume();

    if (pDfsVol == NULL)
        return( ERROR_OUTOFMEMORY );

    dwErr =  pDfsVol->LoadNoRegister(_pwszParentName, 0);

    if (dwErr != ERROR_SUCCESS) {

        pDfsVol->Release();

        *parent = NULL;

        return(dwErr);

    }

    *parent = pDfsVol;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::GetParent() exit\n"));

    return(dwErr);

}


//+-------------------------------------------------------------------------
//
//  Method:     CDfsVolume::DeleteObject, private
//
//  Synopsis:   Support method to merely delete a volume object from
//              persistent store.
//
//  Arguments:  None
//
//  Returns:    [ERROR_SUCCESS] -- If successfully deleted object.
//
//              [ERROR_OUTOFMEMORY] -- Unable to get parent instance.
//
//  History:    16-Sep-1992       SudK    Created
//
//--------------------------------------------------------------------------

DWORD
CDfsVolume::DeleteObject()
{
    DWORD               dwErr =  ERROR_SUCCESS;
    CStorage        *parentStg;
    PWCHAR              pwszLastComponent;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::DeleteObject()\n"));

    //
    // We are going to delete this object so let us release all our pointers.
    //

    ASSERT ((_pStorage != NULL));

    _pStorage->Release();

    _pStorage = NULL;

    //
    // Let us now release all the IStorage's which are with CRecover & SvcList
    //
    if (_Recover._pPSStg != NULL)       {

        _Recover._pPSStg->Release();

        _Recover._pPSStg = NULL;

    }

    if (_DfsSvcList._pPSStg != NULL)    {

        _DfsSvcList._pPSStg->Release();

        _DfsSvcList._pPSStg = NULL;

    }

    //
    // First we get the parent's pathname and then we can do the appropriate.
    //

    dwErr =  SetParentPath();

    if (dwErr != ERROR_SUCCESS)     {

        IDfsVolInlineDebOut((
            DEB_ERROR, "Failed to get parent path for %ws\n", _pwzFileName));

        return( dwErr );

    }

    dwErr =  DfsmOpenStorage( _pwszParentName, &parentStg);

    if (dwErr != ERROR_SUCCESS)     {

        IDfsVolInlineDebOut((
            DEB_ERROR, "Unable to open [%ws] %08lx\n", _pwszParentName, dwErr));

        return( dwErr );

    }

    //
    // Now we have to delete ourselves using our parent's IStorage.
    // So we extract the last component name from the file name.
    //

    pwszLastComponent = _pwzFileName + wcslen(_pwszParentName) + 1;

    dwErr =  parentStg->DestroyElement(pwszLastComponent);

    parentStg->Release();

    if (dwErr != ERROR_SUCCESS)     {

        IDfsVolInlineDebOut((
            DEB_ERROR, "Unable to delete [%ws] %08lx\n", _pwzFileName, dwErr));

        return( dwErr );

    } else {

        //
        // The storage object has really been deleted, so delete the mapping
        // of this prefix from the storage directory.
        //

        dwErr =  pDfsmStorageDirectory->_Delete( _peid.Prefix.Buffer );

        ASSERT( dwErr == ERROR_SUCCESS );

    }

    _Deleted = TRUE;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::DeleteObject() exit\n"));

    return( ERROR_SUCCESS );

}


//+----------------------------------------------------------------------------
//
//  Function:   CDfsVolume::GetVersion, private
//
//  Synopsis:   Retrieves the version of the volume object from the property
//              stamped on it.
//
//  Arguments:  [pVersion] -- The version is returned here.
//
//  Returns:    Result of reading the version property.
//
//-----------------------------------------------------------------------------

DWORD
CDfsVolume::GetVersion(
    ULONG * pVersion)
{
    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::GetVersion()\n"));

    DWORD             dwErr =  ERROR_SUCCESS;

    dwErr =  _pStorage->GetVersionProps(pVersion);

    if (dwErr != ERROR_SUCCESS)     {
        IDfsVolInlineDebOut((DEB_ERROR,
                        "Unable to read Version Properties %08lx\n",
                        dwErr));
        return(dwErr);
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::GetVersion() exit\n"));

    return( dwErr );

}


//+----------------------------------------------------------------------------
//
//  Function:   SetVersion
//
//  Synopsis:   Sets the version property on the volume object to
//              VOL_OBJ_VERSION_NUMBER
//
//  Arguments:  [bCreate] -- TRUE if the property set should be created,
//                           FALSE if the property set should be assumed to
//                           exist
//
//  Returns:    Result of setting the property
//
//-----------------------------------------------------------------------------

DWORD
CDfsVolume::SetVersion(
    BOOL bCreate)
{
    DWORD dwErr;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::SetVersion()\n"));

    dwErr =  _pStorage->SetVersionProps( VOL_OBJ_VERSION_NUMBER );
    if (dwErr != ERROR_SUCCESS)     {
        IDfsVolInlineDebOut((   DEB_ERROR,
                                "Unable to set Version Properties %08lx\n",
                                dwErr));
        return(dwErr);
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::SetVersion() exit\n"));

    return( dwErr );
}


//+-------------------------------------------------------------------------
//
//  Method:     CDfsVolume::GetIdProps, private
//
//  Synopsis:   Gets the ID Properties from a volume object.
//              Memory for the string values is allocated using new. The
//              caller is responsible for freeing it.
//
//  Arguments:  [pdwType] -- The Volume Type property is returned here.
//              [ppwszEntryPath] -- EntryPath is returned here.
//              [ppwszShortPath] -- The 8.3 form of EntryPath is returned here
//              [ppwszComment] -- Comment is returned here.
//              [pGuid] -- The Guid (VolumeID) is returned here.
//              [pdwVolumeState] -- The volume state is returned here.
//              [pftPathTime] -- Time that EntryPath was last modified.
//              [pftStateTime] -- Time that Volume State was last modified.
//              [pftCommentTime] -- Time that Comment was last modified.
//
//  Returns:
//
//  History:  16-Sep-1992       SudK    Imported from PART.CXX
//            01-Jan-1996       Milans  Ported to NT/SUR
//
//--------------------------------------------------------------------------

DWORD
CDfsVolume::GetIdProps(
    ULONG  *pdwType,
    PWCHAR *ppwszEntryPath,
    PWCHAR *ppwszShortPath,
    PWCHAR *ppwszComment,
    GUID   *pGuid,
    ULONG  *pdwVolumeState,
    ULONG  *pdwTimeout,
    FILETIME *pftPathTime,
    FILETIME *pftStateTime,
    FILETIME *pftCommentTime
)
{
    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::GetIdProps()\n"));

    DWORD             dwErr =  ERROR_SUCCESS;

    dwErr =  _pStorage->GetIdProps(
            pdwType,
            pdwVolumeState,
            ppwszEntryPath,
            ppwszShortPath,
            pGuid,
            ppwszComment,
            pdwTimeout,
            pftPathTime,
            pftStateTime,
            pftCommentTime);

    if (dwErr != ERROR_SUCCESS) {
        IDfsVolInlineDebOut((
            DEB_ERROR, "Unable to read Id Props %08lx\n", dwErr));
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::GetIdProps() exit\n"));

    return( dwErr );
}


//+-------------------------------------------------------------------------
//
//  Method:   CDfsVolume::SetIdProps, private
//
//  Synopsis: Exact opposite of GetIdProps function. A wrapper around the
//            property interface to set the appropriate properties that
//            identify a volume.
//
//  Arguments:
//
//  Returns:
//
//  History:  16-Sep-1992       SudK    Imported from PART.CXX
//
//--------------------------------------------------------------------------

DWORD
CDfsVolume::SetIdProps(
    ULONG Type,
    ULONG State,
    PWCHAR pwszPrefix,
    PWCHAR pwszShortPath,
    GUID & Guid,
    PWSTR  pwszComment,
    ULONG Timeout,
    FILETIME ftPrefix,
    FILETIME ftState,
    FILETIME ftComment,
    BOOLEAN bCreate
)
{
    DWORD             dwErr;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::SetIdProps()\n"));

    dwErr =  _pStorage->SetIdProps(
            Type,
            State,
            pwszPrefix,
            pwszShortPath,
            Guid,
            pwszComment,
            Timeout,
            ftPrefix,
            ftState,
            ftComment);

    if (dwErr != ERROR_SUCCESS)     {
        IDfsVolInlineDebOut((   DEB_ERROR,
                                "Unable to Set IDProperties %08lx\n",
                                dwErr));
        return(dwErr);
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::SetIdProps() exit\n"));

    return( dwErr );
}


//+----------------------------------------------------------------------------
//
//  Function:   CDfsVolume::SaveShortName
//
//  Synopsis:   Updates the short name for the volume entry path and saves it
//              to the registry.
//
//  Arguments:  None - the short name is picked up from the _peid private
//              member.
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
CDfsVolume::SaveShortName()
{
    DWORD     dwErr;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::SetShortName()\n"));

    dwErr =  SetIdProps(
            _EntryType,
            _State,
            _peid.Prefix.Buffer,
            _peid.ShortPrefix.Buffer,
            _peid.Uid,
            _pwszComment,
            _Timeout,
            _ftEntryPath,
            _ftState,
            _ftComment,
            FALSE);

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::SetShortName() exit\n"));

    return( dwErr );
}


//+-------------------------------------------------------------------------
//
//  Method:   CDfsVolume::DeletePktEntry, private
//
//  Synopsis:   This method deletes an entry from the PKT. Given an ID to
//              identify the entry this method deletes the entry.
//
//  Arguments:  victim - The entryID that identifies the PKT entry to go.
//
//  Returns:
//
//  History:    24-Nov-1992     SudK    Created.
//
//--------------------------------------------------------------------------

DWORD
CDfsVolume :: DeletePktEntry(
    PDFS_PKT_ENTRY_ID   victim
)
{
    DWORD     dwErr =  ERROR_SUCCESS;
    NTSTATUS    status = STATUS_SUCCESS;
    HANDLE      pktHandle = NULL;

    IDfsVolInlineDebOut((DEB_TRACE, "IDfsVol::DeletePktEntry()\n"));

    //
    // Open the local PKT...
    //

    status = PktOpen(&pktHandle, 0, 0, NULL);

    if(NT_SUCCESS(status)) {
        status = PktDestroyEntry(
            pktHandle,
            *victim
        );

        PktClose(pktHandle);

        if (status == DFS_STATUS_NO_SUCH_ENTRY) {

            dwErr =  ERROR_SUCCESS;

        } else if (!NT_SUCCESS(status)) {

            dwErr =  RtlNtStatusToDosError(status);

        }

    } else {

        dwErr = RtlNtStatusToDosError(status);

    }

    IDfsVolInlineDebOut((DEB_TRACE, "IDfsVol::DeletePktEntry() exit\n"));

    return( dwErr );
}


//+-------------------------------------------------------------------------
//
//  Method:   CDfsVolume::CreateSubordinatePktEntry, private
//
//  Synopsis: This method is basically an interface into the driver to be
//            able to manipulate the PKT. This creates an entry for the
//            current volume object and at the same time links it with its
//            superior volume object's PKT entry. This method makes one
//            assumption that no services are associated with the service.
//            It adds a NULL serviceList infact if the Boolean bWithService
//            is FALSE else it puts in the servicelist also.
//
//  Arguments:  [pSuperior] --  The Superior's EntryID info is passed here to
//                              identify the superior in the PKT.
//              [bWithService] -- Whether to include the serviceinfo in EINFO.
//
//  Returns:
//
//  History:  22-Nov-1992       SudK    Created
//
//--------------------------------------------------------------------------

DWORD
CDfsVolume::CreateSubordinatePktEntry(
    HANDLE              pktHandle,
    PDFS_PKT_ENTRY_ID   pSuperior,
    BOOLEAN             bWithService)
{
    ULONG               etype = 0;
    DFS_PKT_ENTRY_INFO  einfo;
    DWORD               dwErr =  ERROR_SUCCESS;
    NTSTATUS            status = STATUS_SUCCESS;
    CDfsService         *pDfsSvc = NULL;
    DFS_SERVICE         *pService;
    ULONG               count = 0;
    UNICODE_STRING      ustrShortName;
    WCHAR               ShortPrefix[MAX_PATH+1];
    BOOLEAN             CloseHandle = FALSE;

    IDfsVolInlineDebOut((DEB_TRACE, "IDfsVol::CreateSubordinatePktEntry()\n"));

    //
    // We setup the servicelist based on the CreateDisposition.
    //
    if (!bWithService) {
        memset(&einfo, 0, sizeof(DFS_PKT_ENTRY_INFO));
        einfo.ServiceList = NULL;
        einfo.Timeout = _Timeout;
    } else  {
        einfo.Timeout = _Timeout;
        count = _DfsSvcList.GetServiceCount();
        einfo.ServiceCount = count;
        einfo.ServiceList = new DFS_SERVICE[count];
        //447491, dont use null pointer.
        if (einfo.ServiceList == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            return dwErr;
	}
        memset(einfo.ServiceList, 0, sizeof(DFS_SERVICE)*count);

        pDfsSvc = _DfsSvcList.GetFirstService();
        pService = einfo.ServiceList;
        for (ULONG i=0; i<count; i++)   {
            *pService = *(pDfsSvc->GetDfsService());
            pService++;
            pDfsmSites->LookupSiteInfo((pDfsSvc->GetReplicaInfo())->pwszServerName);
            pDfsSvc = _DfsSvcList.GetNextService(pDfsSvc);
        }

    }

//
//  Note:  We depend upon the correspondence of certain bits between the DFS
//         volume types and PKT entry types here.
//
#if (DFS_VOL_TYPE_ALL & (PKT_ENTRY_TYPE_LOCAL|PKT_ENTRY_TYPE_PERMANENT|PKT_ENTRY_TYPE_INUSE|PKT_ENTRY_TYPE_REFERRAL_SVC|PKT_ENTRY_TYPE_LOCAL_XPOINT))
#error (DFS_VOL_TYPE_ALL & (PKT_ENTRY_TYPE_LOCAL|PKT_ENTRY_TYPE_PERMANENT|PKT_ENTRY_TYPE_INUSE|PKT_ENTRY_TYPE_REFERRAL_SVC|PKT_ENTRY_TYPE_LOCAL_XPOINT))
#endif

    etype = _EntryType | PKT_ENTRY_TYPE_PERMANENT;

    //
    // If the handle supplied is NULL, open the local pkt
    //

    if (pktHandle == NULL) {

        status = PktOpen(&pktHandle, 0, 0, NULL);

        if (NT_SUCCESS(status))
            CloseHandle = TRUE;
    }

    if(NT_SUCCESS(status))        {

#if DBG
    if (DfsSvcVerbose & 0x80000000) {
        WCHAR wszGuid[sizeof(GUID)*2+1];

        GuidToString(&_peid.Uid, wszGuid);
        DbgPrint("CDfsVolume::CreateSubordinatePktEntry:\n"
                "\tSupName=%ws\n"
                "\tPrefix=%ws\n"
                "\tShortPrefix=%ws\n"
                "\tType=0x%x\n"
                "\tCount=%d\n"
                "\tGUID=%ws\n",
                pSuperior->Prefix.Buffer,
                _peid.Prefix.Buffer,
                _peid.ShortPrefix.Buffer,
                _EntryType,
                einfo.ServiceCount,
                wszGuid);
    }
#endif

        DfspCreateExitPoint(
                pktHandle,
                &_peid.Uid,
                _peid.Prefix.Buffer,
                _EntryType,
                sizeof(ShortPrefix),
                ShortPrefix);

        status = PktCreateSubordinateEntry(
                    pktHandle,
                    pSuperior,
                    etype,
                    &_peid,
                    &einfo,
                    PKT_ENTRY_SUPERSEDE);

        //
        // If we opened the handle, close it
        //

        if (CloseHandle == TRUE) {
            PktClose(pktHandle);
            pktHandle = NULL;
        }
    }

    if (!NT_SUCCESS(status))    {
        dwErr =  RtlNtStatusToDosError(status);
    }

    //
    // Now before we leave we may have to delete the service list if we
    // allocated it.
    //
    delete [] einfo.ServiceList;

    IDfsVolInlineDebOut((DEB_TRACE, "IDfsVol::CreateSubordinatePktEntry() exit\n"));

    return( dwErr );
}

//+------------------------------------------------------------------------
//
// Method:      CDfsVolume::UpdatePktEntry, public
//
// Synopsis:    This method updates the PKT with all the info regarding this
//              volume. It however, does not bother about any kind of
//              Relational Info at all.
//
// Arguments:   None
//
// Returns:     ERROR_SUCCESS -- If all went well.
//
// Notes:
//
// History:     03-Feb-93       SudK    Created.
//
//-------------------------------------------------------------------------
DWORD
CDfsVolume::UpdatePktEntry(
    HANDLE pktHandle)
{
    DFS_PKT_ENTRY_INFO  einfo;
    PDFS_SERVICE        pService;
    CDfsService         *pDfsSvc;
    DWORD               dwErr =  ERROR_SUCCESS;
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               EntryType, count;
    UNICODE_STRING      ustrShortName;
    BOOLEAN             CloseHandle = FALSE;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::UpdatePktEntry()\n"));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CDfsVolume::UpdatePktEntry()\n");
#endif

    memset(&einfo, 0, sizeof(DFS_PKT_ENTRY_INFO));
    EntryType = _EntryType | PKT_ENTRY_TYPE_PERMANENT;

    //
    // Let us collect the service info now. Some memory allocation out here.
    //
    count = _DfsSvcList.GetServiceCount();
    einfo.Timeout = _Timeout;
    einfo.ServiceCount = count;
    einfo.ServiceList = new DFS_SERVICE[count];

    //447492, dont use null pointer.
    if (einfo.ServiceList == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        return dwErr;
    }

    memset(einfo.ServiceList, 0, sizeof(DFS_SERVICE)*count);

    pService = einfo.ServiceList;
    pDfsSvc = _DfsSvcList.GetFirstService();

    //
    // In this loop we merely do an assignment of all the services. The
    // conversion operator returns the DFS_SERVICE struct embedded in class.
    //
    for (ULONG i=0;i<count;i++)     {
        *pService = *(pDfsSvc->GetDfsService());
        pService++;
        pDfsmSites->LookupSiteInfo((pDfsSvc->GetReplicaInfo())->pwszServerName);
        pDfsSvc = _DfsSvcList.GetNextService(pDfsSvc);
    }

#if DBG
    if (DfsSvcVerbose) {
        WCHAR wszGuid[sizeof(GUID)*2+1];

        GuidToString(&_peid.Uid, wszGuid);
        DbgPrint("CDfsVolume::UpdatePktEntry\n"
                 "\tPrefix=%ws\n"
                 "\tShortPrefix=%ws\n"
                 "\tType=0x%x\n"
                 "\tCount=%d\n"
                 "\tGUID=%ws\n",
                _peid.Prefix.Buffer,
                _peid.ShortPrefix.Buffer,
                _EntryType,
                einfo.ServiceCount,
                wszGuid);
    }
#endif

    //
    // If we weren't given a handle, create one
    //

    if (pktHandle == NULL) {
        status = PktOpen(&pktHandle, 0, 0, NULL);
        if (NT_SUCCESS(status))
            CloseHandle = TRUE;
    }

    if (NT_SUCCESS(status))   {

        status = PktCreateEntry(
                        pktHandle,
                        EntryType,
                        &_peid,
                        &einfo,
                        PKT_ENTRY_SUPERSEDE);

        if (CloseHandle == TRUE) {
            PktClose(pktHandle);
            pktHandle = NULL;
        }
    }

    if (!NT_SUCCESS(status)) {
#if DBG
        if (DfsSvcVerbose)
            DbgPrint("PktCreateEntry returned 0x%x\n", status);
#endif
        dwErr =  RtlNtStatusToDosError(status);
    }

    delete [] einfo.ServiceList;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::UpdatePktEntry() exit %d\n", dwErr));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CDfsVolume::UpdatePktEntry() exit %d\n", dwErr);
#endif

    //
    // Cant blindly return this error. This needs to be processed.
    //

    return(dwErr);

}



//+----------------------------------------------------------------------------
//
//  Function:   GuidToString
//
//  Synopsis:   Converts a GUID to a 32 char wchar null terminated string.
//
//  Arguments:  [pGuid] -- Pointer to Guid structure.
//              [pwszGuid] -- wchar buffer into which to put the string
//                         representation of the GUID. Must be atleast
//                         2 * sizeof(GUID) + 1 long.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

const WCHAR rgwchHexDigits[] = L"0123456789ABCDEF";

VOID GuidToString(
    IN GUID   *pGuid,
    OUT PWSTR pwszGuid)
{
    PBYTE pbBuffer = (PBYTE) pGuid;
    USHORT i;

    for(i = 0; i < sizeof(GUID); i++) {
        pwszGuid[2 * i] = rgwchHexDigits[(pbBuffer[i] >> 4) & 0xF];
        pwszGuid[2 * i + 1] = rgwchHexDigits[pbBuffer[i] & 0xF];
    }
    pwszGuid[2 * i] = UNICODE_NULL;
}




//+-------------------------------------------------------------------------
//
//  Method:   CDfsVolume::CreateChildPartition, private
//
//  Synopsis:   This is somewhat of a wrapper around the IStorage interface.
//              It merely creates a new volume object and associates the
//              properties passed in with the Volume Object. We use the
//              IStorage interface for this purpose.
//              This method generates a GUID and uses that. It also sets
//              a NULL service list and Initial State on the volume object.
//
//  Arguments:  [Name] -- Child Volume Object's name.
//              [Type] -- Type of this volume object.
//              [EntryPath] -- Dfs prefix of child volume.
//              [pwszComment] -- Comment associated with this new volume
//              [pUid] -- Optional guid of child volume
//              [pReplInfo] -- Info regarding the server\share supporting volume
//              [NewIDfsVol] -- On successful return, pointer to new child
//                      volume object is returned here.
//
//  Returns:
//
//  Notes:      This Method creates a GUID and uses it. It also sets a default
//              state on the volume object and associates a NULL serviceList.
//
//  History:  16-Sep-1992       SudK    Imported from PART.CXX
//
//--------------------------------------------------------------------------

DWORD
CDfsVolume::CreateChildPartition(
    PWCHAR Name,
    ULONG Type,
    PWCHAR EntryPath,
    PWCHAR pwszComment,
    GUID  *pUid,
    PDFS_REPLICA_INFO   pReplInfo,
    CDfsVolume **NewIDfsVol
)
{
    DWORD     dwErr =  ERROR_SUCCESS;
    CDfsVolume  *pDfsVol;
    PWSTR       pwszChildName;
    CDfsService *pService;
    WCHAR       wszChildElement[sizeof(GUID)*2+1];
    GUID        Uid, *pVolId;
    PWCHAR      pwszChild;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::CreateChildPartition(%ws)\n", Name));

    if (Name == NULL) {
        //
        // Get a guid first.
        //
        dwErr =  UuidCreate(&Uid);

        if (dwErr != ERROR_SUCCESS) {
            IDfsVolInlineDebOut((DEB_ERROR, "UuidCreate failed %08lx\n", dwErr));
            return(dwErr);
        }

        //
        // Now figure out the last element of the child name from the GUID.
        //
        GuidToString(&Uid, wszChildElement);
        pwszChild = wszChildElement;
        pVolId = pUid == NULL ? &Uid : pUid;
    } else {
        pwszChild = Name;
        pVolId = pUid;
    }

    //
    // Now compose the full name of the child object.
    //
    pwszChildName = new WCHAR[wcslen(_pwzFileName)+wcslen(pwszChild)+2];

    if (pwszChildName == NULL) {

        *NewIDfsVol = NULL;
        dwErr = ERROR_OUTOFMEMORY;
        return dwErr;

    }

    wcscpy(pwszChildName, _pwzFileName);
    wcscat(pwszChildName, L"\\");
    wcscat(pwszChildName, pwszChild);

    //
    // Let us now instantiate a new instance of CDfsVolume and then we will
    // initialise it with the appropriate Name.
    //
    pDfsVol = new CDfsVolume();

    if (pDfsVol != NULL) {

        dwErr =  pDfsVol->CreateObject( pwszChildName,
                                    EntryPath,
                                    Type,
                                    pReplInfo,
                                    pwszComment,
                                    pVolId);

        //
        // We set up recovery properties of creation here though this is also used
        // by Move operation. This is OK however.
        //
        if (dwErr == ERROR_SUCCESS)  {
            dwErr = pDfsVol->_Recover.SetOperationStart( DFS_RECOVERY_STATE_CREATING, NULL);
            if (dwErr == ERROR_SUCCESS) {
                *NewIDfsVol = pDfsVol;
                //
                // Create object merely creates the object. We now need to call
                // initPktSvc on the service inside the serviceList.
                //
                pService = pDfsVol->_DfsSvcList.GetFirstService();
                ASSERT(((pService==NULL) && (pReplInfo==NULL)) ||
                       ((pService!=NULL) && (pReplInfo!=NULL)));
                if (pService != NULL)
                   pService->InitializePktSvc();
	    }
            else {
               pDfsVol->Release();
               *NewIDfsVol = NULL;
	    }
        } else {
            pDfsVol->Release();
            *NewIDfsVol = NULL;
        }

    } else {

        *NewIDfsVol = NULL;
        dwErr = ERROR_OUTOFMEMORY;

    }

    delete [] pwszChildName;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::CreateChildPartition() exit\n"));

    return(dwErr);
}


//+----------------------------------------------------------------------------
//
//  Function:   CDfsVolume::IsValidChildName,private
//
//  Synopsis:   Determines whether a prefix is a valid child prefix for this
//              volume (ie, is hierarchically subordinate and there is no
//              conflicting child.
//
//  Arguments:  [pwszChildPrefix] -- The prefix to test.
//              [pidChild] -- The volume id of the proposed child volume.
//
//  Returns:    TRUE if the child prefix is legal, FALSE otherwise
//
//-----------------------------------------------------------------------------

BOOL CDfsVolume::IsValidChildName(
    PWCHAR pwszChildPrefix,
    GUID   *pidChild)
{
    NTSTATUS Status;

    Status = PktIsChildnameLegal(
                _peid.Prefix.Buffer,
                pwszChildPrefix,
                pidChild);

    return( (BOOL) (Status == STATUS_SUCCESS) );

}



//+-------------------------------------------------------------------------
//
//  Method:   CDfsVolume::NotLeafVolume, private
//
//  Synopsis: Uses IStorage to find if child exists.
//
//  Arguments:None
//
//  Returns:  TRUE if NotLeafVolume else FALSE.
//
//  History:  18-May-1993       SudK    Created.
//
//--------------------------------------------------------------------------
BOOL
CDfsVolume::NotLeafVolume(void)
{
    ULONG               fetched = 0;
    CEnumDirectory      *pdir;
    DFSMSTATDIR         rgelt;
    DWORD               dwErr;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::NotLeafVolume()\n"));

    ASSERT(!(VolumeDeleted()));

    memset(&rgelt, 0, sizeof(DFSMSTATDIR));

    //
    // First, we get a hold of the IDirectory interface to our own volume
    // object.
    //

    dwErr =  _pStorage->GetEnumDirectory(&pdir);
    if (dwErr != ERROR_SUCCESS) {
        IDfsVolInlineDebOut((DEB_ERROR, "Failed to get IDirectory %08lx\n", dwErr));
        return(FALSE);
    }

    //
    // While there are children still to be handled we continue on.
    //

    while (TRUE) {

        if (rgelt.pwcsName != NULL)     {
            delete [] rgelt.pwcsName;
            rgelt.pwcsName = NULL;
        }

        dwErr =  pdir->Next(&rgelt, &fetched);

        //
        // Will we get an error if there are no more children. 
        //
        if (dwErr != ERROR_SUCCESS) {
            IDfsVolInlineDebOut((DEB_ERROR, "Failed to Enumeraate %08lx\n",dwErr));
            pdir->Release();
            return(FALSE);
        }

        //
        // If we did not get back any children we are done.
        //
        if (fetched == 0)       {
            IDfsVolInlineDebOut((DEB_TRACE, "No Children Found\n",0));
            pdir->Release();
            return(FALSE);
        }

        //
        // If the child is . or .. we look for next child.
        //
        ULONG cbLen = wcslen(rgelt.pwcsName);

        if (cbLen < sizeof(L"..")/sizeof(WCHAR))
            continue;

        //
        // If we got here it means that we came across a volume object
        // and we have to return TRUE now.
        //
        IDfsVolInlineDebOut((DEB_ERROR, "Child Found - NotLeafVolume %ws\n",
                                rgelt.pwcsName));
        pdir->Release();
        delete [] rgelt.pwcsName;
        return(TRUE);

    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::NotLeafVolume() exit\n"));

}


//+----------------------------------------------------------------------------
//
//  Function:   CDfsVolume::IsValidService
//
//  Synopsis:   Given a server name, indicates whether the server is a valid
//              server for this volume.
//
//  Arguments:  [pwszServer] -- Name of server to verify.
//
//  Returns:    TRUE if server is a valid server for this volume, FALSE
//              otherwise
//
//-----------------------------------------------------------------------------

BOOLEAN
CDfsVolume::IsValidService(
    IN LPWSTR pwszServer)
{
    DWORD dwErr;
    CDfsService *pSvc;

    dwErr =  _DfsSvcList.GetServiceFromPrincipalName( pwszServer, &pSvc );

    return( dwErr == ERROR_SUCCESS );

}


//+-------------------------------------------------------------------------
//
//  Method:     DeallocateCacheRelationInfo, private
//
//  Synopsis:   This function is used to deallocate relationInfo structures
//              that were allocated by GetPktCacheRelationInfo.
//
//  Arguments:  RelationInfo - The relationInfo struct to deallocate.
//
//  Returns:
//
//  History:    24-Nov-1992     SudK    Created.
//
//--------------------------------------------------------------------------
VOID
DeallocateCacheRelationInfo(
    DFS_PKT_RELATION_INFO & RelationInfo
)
{
    PDFS_PKT_ENTRY_ID peid = &RelationInfo.EntryId;

    IDfsVolInlineDebOut((DEB_TRACE, "Dfsm::DeallocateCacheRelationInfo()\n"));

    MarshalBufferFree(peid->Prefix.Buffer);
    peid->Prefix.Buffer = NULL;

    if (peid->ShortPrefix.Buffer) {
        MarshalBufferFree(peid->ShortPrefix.Buffer);
        peid->ShortPrefix.Buffer = NULL;
    }

    if(peid = RelationInfo.SubordinateIdList)
    {
        for(ULONG i = 0; i < RelationInfo.SubordinateIdCount; i++)
        {
            MarshalBufferFree(peid[i].Prefix.Buffer);
            peid[i].Prefix.Buffer = NULL;
            if (peid[i].ShortPrefix.Buffer != NULL) {
                MarshalBufferFree(peid[i].ShortPrefix.Buffer);
                peid[i].ShortPrefix.Buffer = NULL;
            }
        }
        MarshalBufferFree(RelationInfo.SubordinateIdList);
        RelationInfo.SubordinateIdList = NULL;
    }

    IDfsVolInlineDebOut((DEB_TRACE, "Dfsm::DeallocateCacheRelationInfo() exit\n"));

}




//+-------------------------------------------------------------------------
//
//  Method:     GetPktCacheRelationInfo, private
//
//  Synopsis:   This method retrieves the relational information regarding
//              a particular volume (identified by the ENTRY_ID props)
//              passed in to it.
//
//  Arguments:  [RelationInfo] -- The relational info is returned here.
//              [peid] --       The EntryID is passed in here.
//
//  Returns:
//
//  History:    24-Nov-1992     SudK    Created.
//
//--------------------------------------------------------------------------

DWORD
GetPktCacheRelationInfo(
    PDFS_PKT_ENTRY_ID   peid,
    PDFS_PKT_RELATION_INFO RelationInfo
)
{
    //
    // Initialize all return values to be NULL...
    //

    HANDLE      pktHandle;
    DWORD     dwErr =  ERROR_SUCCESS;
    NTSTATUS    status;
    memset(RelationInfo, 0, sizeof(DFS_PKT_RELATION_INFO));

    IDfsVolInlineDebOut((DEB_TRACE, "IDfsVol::GetPktCacheRelationInfo()\n"));

    status = PktOpen(&pktHandle, 0, 0, NULL);
    if (NT_SUCCESS(status))
    {

        //
        // Create/Update the Entry...
        //

        status = PktGetRelationInfo(
                            pktHandle,
                            peid,
                            RelationInfo
                        );

        PktClose(pktHandle);
        pktHandle = NULL;
    };

    if (!NT_SUCCESS(status))
        dwErr =  RtlNtStatusToDosError(status);
    else
        dwErr =  ERROR_SUCCESS;

    if (dwErr != ERROR_SUCCESS)     {
        IDfsVolInlineDebOut((DEB_ERROR, "Failed GetRelationInfo %08lx\n",dwErr));
    }

    IDfsVolInlineDebOut((DEB_TRACE, "IDfsVol::GetPktCacheRelationInfo() exit\n"));

    return( dwErr );
}

NTSTATUS
DfspCreateExitPoint (
    IN  HANDLE                      DriverHandle,
    IN  LPGUID                      Uid,
    IN  LPWSTR                      Prefix,
    IN  ULONG                       Type,
    IN  ULONG                       Len,
    OUT LPWSTR                      ShortPrefix)
{
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    PDFS_CREATE_EXIT_POINT_ARG CreateArg;
    ULONG   Size = sizeof(*CreateArg);
    PCHAR   pWc;

    if (Uid == NULL || Prefix == NULL) {
        NtStatus = STATUS_INVALID_PARAMETER;
        DFSM_TRACE_HIGH(ERROR, DfspCreateExitPoint_Error1, 
                        LOGSTATUS(NtStatus)
                        LOGWSTR(Prefix));
        goto ExitWithStatus;
    }

#if DBG
    if (DfsSvcVerbose & 0x80000000) {
        WCHAR wszGuid[sizeof(GUID)*2+1];

        GuidToString(Uid, wszGuid);
        DbgPrint("DfspCreateExitPoint(%ws,%ws,0x%x)\n",
            wszGuid,
            Prefix,
            Type);
    }
#endif

    //
    // Pack the args into a single buffer that can be sent to
    // the dfs driver:
    //

    //
    // First find the size...
    //

    if (Prefix != NULL) {

        Size += (wcslen(Prefix) + 1) * sizeof(WCHAR);

    }

    //
    // Now allocate the memory
    //

    CreateArg = (PDFS_CREATE_EXIT_POINT_ARG)malloc(Size);

    if (CreateArg == NULL) {

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DFSM_TRACE_HIGH(ERROR, DfspCreateExitPoint_Error2, 
                        LOGSTATUS(NtStatus)
                        LOGWSTR(Prefix));
        goto ExitWithStatus;

    }

    RtlZeroMemory(CreateArg, Size);

    //
    // Put the fixed parameters into the buffer
    //
    CreateArg->Uid = *Uid;
    CreateArg->Type = Type;

    //
    // Put the variable data in the buffer
    //
    pWc = (PCHAR)(CreateArg + 1);

    CreateArg->Prefix = (LPWSTR)pWc;
    RtlCopyMemory(CreateArg->Prefix, Prefix, wcslen(Prefix)*sizeof(WCHAR));
    LPWSTR_TO_OFFSET(CreateArg->Prefix, CreateArg);

    //
    // Tell the driver!!
    //

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_CREATE_EXIT_POINT,
                   CreateArg,
                   Size,
                   ShortPrefix,
                   Len);

    DFSM_TRACE_ERROR_HIGH(NtStatus, ALL_ERROR, DfspCreateExitPoint_Error_NtFsControlFile, 
                          LOGSTATUS(NtStatus)
                          LOGWSTR(Prefix));
    free(CreateArg);

ExitWithStatus:

#if DBG
    if (DfsSvcVerbose & 0x80000000)
        DbgPrint("DfspCreateExitPoint exit 0x%x\n", NtStatus);
#endif

    return NtStatus;
}

NTSTATUS
DfspDeleteExitPoint (
    IN  HANDLE                      DriverHandle,
    IN  LPGUID                      Uid,
    IN  LPWSTR                      Prefix,
    IN  ULONG                       Type)
{
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    PDFS_DELETE_EXIT_POINT_ARG DeleteArg;
    ULONG   Size = sizeof(*DeleteArg);
    PCHAR   pWc;

    if (Uid == NULL || Prefix == NULL) {
        NtStatus = STATUS_INVALID_PARAMETER;
        DFSM_TRACE_HIGH(ERROR, DfspDeleteExitPoint_Error1, 
                        LOGSTATUS(NtStatus)
                        LOGWSTR(Prefix));
        goto ExitWithStatus;
    }

#if DBG
    if (DfsSvcVerbose & 0x80000000) {
        WCHAR wszGuid[sizeof(GUID)*2+1];

        GuidToString(Uid, wszGuid);
        DbgPrint("DfspDeleteExitPoint(%ws,%ws,0x%x)\n",
            wszGuid,
            Prefix,
            Type);
    }
#endif

    //
    // Pack the args into a single buffer that can be sent to
    // the dfs driver:
    //

    //
    // First find the size...
    //

    if (Prefix != NULL) {

        Size += (wcslen(Prefix) + 1) * sizeof(WCHAR);

    }

    //
    // Now allocate the memory
    //

    DeleteArg = (PDFS_DELETE_EXIT_POINT_ARG)malloc(Size);

    if (DeleteArg == NULL) {

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DFSM_TRACE_HIGH(ERROR, DfspDeleteExitPoint_Error2, 
                        LOGSTATUS(NtStatus)
                        LOGWSTR(Prefix));
        goto ExitWithStatus;

    }

    RtlZeroMemory(DeleteArg, Size);

    //
    // Put the fixed parameters into the buffer
    //
    DeleteArg->Uid = *Uid;
    DeleteArg->Type = Type;

    //
    // Put the variable data in the buffer
    //
    pWc = (PCHAR)(DeleteArg + 1);

    DeleteArg->Prefix = (LPWSTR)pWc;
    RtlCopyMemory(DeleteArg->Prefix, Prefix, wcslen(Prefix)*sizeof(WCHAR));
    LPWSTR_TO_OFFSET(DeleteArg->Prefix, DeleteArg);

    //
    // Tell the driver!!
    //

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_DELETE_EXIT_POINT,
                   DeleteArg,
                   Size,
                   NULL,
                   0);

    DFSM_TRACE_ERROR_HIGH(NtStatus, ALL_ERROR, DfspDeleteExitPoint_Error_NtFsControlFile, 
                          LOGSTATUS(NtStatus)
                          LOGWSTR(Prefix));
    free(DeleteArg);

ExitWithStatus:

#if DBG
    if (DfsSvcVerbose & 0x80000000)
        DbgPrint("DfspDeleteExitPoint exit 0x%x\n", NtStatus);
#endif

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\jnpt.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1995, Microsoft Corporation
//
//  File:       jnpt.cxx
//
//  Contents:   Junction point creation/deletion/modification related
//              functions
//
//  Classes:
//
//  Functions:
//
//  History:    8-2-95          Sudk    Created
//              12-27-95        Milans  Modified for NT/SUR
//
//-----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop
extern "C" {
#include <string.h>
#include <nodetype.h>
#include <fsctrl.h>
#include <dfsmrshl.h>
#include <upkt.h>
#include <ntddnfs.h>
#include <dfsgluon.h>
#include <dfserr.h>
}
#include "service.hxx"

//+----------------------------------------------------------------------------
//
//  Function:   IsValidWin32Path
//
//  Synopsis:   Given a prefix, determines if it is a valid win32 path. This
//              routine checks for invalid names in win32, like com1 etc. It
//              also checks to see if the prefix, canonicalized for spaces,
//              ., and .. is still a valid prefix.
//
//  Arguments:  [pwszPrefix] -- The prefix to check
//
//  Returns:    TRUE if valid win32 path, FALSE otherwise
//
//-----------------------------------------------------------------------------

BOOLEAN
IsValidWin32Path(
    IN LPWSTR pwszPrefix)
{
    BOOLEAN fIsValid = FALSE;
    UNICODE_STRING ustrWin32, ustrRoot;
    ULONG cwPrefix;
    WCHAR wszWin32Path[MAX_PATH];
    LPWSTR wszRoot = L"C:\\";
    LPWSTR wszRootAndPrefix;

    cwPrefix = wcslen( pwszPrefix );

    //
    // We don't allow the last character to be a backslash
    //

    if (cwPrefix == 0 || pwszPrefix[cwPrefix-1] == UNICODE_PATH_SEP) {

        return( FALSE );
    }

    //
    // Form a dummy path that looks like "c:\<pwszPrefix>"
    //

    if (cwPrefix < (MAX_PATH - 3)) {

        wszRootAndPrefix = wszWin32Path;

    } else {

        wszRootAndPrefix = new WCHAR[ 3 + cwPrefix + 1 ];

        if (wszRootAndPrefix == NULL) {

            return( FALSE );

        }
    }

    wcscpy( wszRootAndPrefix, wszRoot );

    if (pwszPrefix[0] == UNICODE_PATH_SEP)
        wcscat( wszRootAndPrefix, &pwszPrefix[1] );
    else
        wcscat( wszRootAndPrefix, pwszPrefix );

    //
    // Convert the dummy path to an NT path and compare against the root
    //

    if (RtlDosPathNameToNtPathName_U(wszRootAndPrefix, &ustrWin32, 0, 0)) {

        if (RtlDosPathNameToNtPathName_U(wszRoot, &ustrRoot, 0, 0)) {

            fIsValid = !RtlEqualUnicodeString(&ustrRoot, &ustrWin32, TRUE);

            RtlFreeUnicodeString( &ustrRoot );
        }

        RtlFreeUnicodeString( &ustrWin32 );
    }

    if (wszRootAndPrefix != wszWin32Path)
        delete [] wszRootAndPrefix;

    return( fIsValid );

}


//+-------------------------------------------------------------------------
//
// Function:    DfsGetDSMachine
//
// Synopsis:    This function sets DS_MACHINE property on machine object
//
// Arguments:   [pwszServer] -- NetBIOS name of server for which DS_MACHINE
//                      is required.
//
//              [ppMachine] -- On successful return, contains pointer to
//                      allocated DS_MACHINE.
//
//
// History:     8-2-94          SudK    Created
//              12-27-95        Milans  Modified for NT/SUR.
//
//--------------------------------------------------------------------------

#define SIZE_OF_DS_MACHINE_WITH_1_ADDR                          \
    (sizeof(DS_MACHINE) + sizeof(LPWSTR) + sizeof(DS_TRANSPORT) + sizeof(TDI_ADDRESS_NETBIOS))

DWORD
DfsGetDSMachine(
    LPWSTR      pwszServer,
    PDS_MACHINE *ppMachine
)
{
    DWORD dwErr;
    PDS_MACHINE pdsMachine;
    PDS_TRANSPORT pdsTransport;
    PTDI_ADDRESS_NETBIOS ptdiNB;
    LPWSTR wszPrincipalName;
    LPWSTR pwszNetBIOSName;

    IDfsVolInlineDebOut((DEB_TRACE, "DfsGetDSMachine(%ws)\n", pwszServer));

    ASSERT( pwszServer != NULL );

    pwszNetBIOSName = pwszServer;


    pdsMachine = (PDS_MACHINE) MarshalBufferAllocate(
                                SIZE_OF_DS_MACHINE_WITH_1_ADDR +
                                wcslen(pwszServer) * sizeof(WCHAR) +
                                sizeof(UNICODE_NULL));

    if (pdsMachine != NULL) {

        ZeroMemory( pdsMachine, sizeof(DS_MACHINE) );

        //
        // Insert the principal name - simply domain\machine
        //

        pdsMachine->cPrincipals = 1;

        wszPrincipalName = (LPWSTR) (((PCHAR) pdsMachine) +
                                        SIZE_OF_DS_MACHINE_WITH_1_ADDR);

        wcscpy( wszPrincipalName, pwszServer );

        pdsMachine->prgpwszPrincipals = (LPWSTR *) (pdsMachine + 1);

        pdsMachine->prgpwszPrincipals[0] = wszPrincipalName;

        //
        // Build the NetBIOS DS_TRANSPORT structure
        //

        pdsMachine->cTransports = 1;

        pdsTransport = (PDS_TRANSPORT) (pdsMachine + 1);

        pdsTransport = (PDS_TRANSPORT)
                            (((PUCHAR) pdsTransport) + sizeof(LPWSTR));

        pdsMachine->rpTrans[0] = pdsTransport;

        pdsTransport->usFileProtocol = FSP_SMB;

        pdsTransport->iPrincipal = 0;

        pdsTransport->grfModifiers = 0;

        //
        // Build the TA_ADDRESS_NETBIOS
        //

        pdsTransport->taddr.AddressLength = sizeof(TDI_ADDRESS_NETBIOS);

        pdsTransport->taddr.AddressType = TDI_ADDRESS_TYPE_NETBIOS;

        ptdiNB = (PTDI_ADDRESS_NETBIOS) &pdsTransport->taddr.Address[0];

        ptdiNB->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

        FillMemory( &ptdiNB->NetbiosName[0], 16, ' ' );

        wcstombs(
            (PCHAR) &ptdiNB->NetbiosName[0],
            pwszNetBIOSName,
            wcslen(pwszNetBIOSName));

        *ppMachine = pdsMachine;

        dwErr = ERROR_SUCCESS;

    } else {

        dwErr = ERROR_OUTOFMEMORY;

    }

    IDfsVolInlineDebOut((DEB_TRACE, "DfsGetDSMachine() exit\n"));

    return( dwErr );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsMachineFree
//
//  Synopsis:   Deallocates a DS_MACHINE allocated by DfsGetDSMachine.
//
//  Arguments:  [pMachine] -- Pointer to DS_MACHINE returned by
//                      DfsGetDSMachine.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsMachineFree(
    PDS_MACHINE pMachine)
{
    ULONG i;

    MarshalBufferFree(pMachine);

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\dfsmwml.h ===
#ifndef _DFSMWML_H_
#define _DFSMWML_H_


#include "wmlmacro.h"
#include "wmlum.h"



#define _DFSM_ENABLE_0                   0x0000
#define _DFSM_ENABLE_DEFAULT             0x0001
#define _DFSM_ENABLE_UNUSED11            0x0002
#define _DFSM_ENABLE_FILEIO              0x0004
#define _DFSM_ENABLE_FILEINFO            0x0008
#define _DFSM_ENABLE_UNUSED10            0x0010
#define _DFSM_ENABLE_UNUSED9             0x0020
#define _DFSM_ENABLE_UNUSED8             0x0040
#define _DFSM_ENABLE_UNUSED7             0x0080
#define _DFSM_ENABLE_UNUSED6             0x0100
#define _DFSM_ENABLE_UNUSED5             0x0200
#define _DFSM_ENABLE_UNUSED4             0x0400
#define _DFSM_ENABLE_UNUSED3             0x0800
#define _DFSM_ENABLE_EVENT               0x1000
#define _DFSM_ENABLE_ALL_ERROR           0x2000
#define _DFSM_ENABLE_ERROR               0x4000
#define _DFSM_ENABLE_MONITOR             0x8000


#define _LEVEL_HIGH                    0x1
#define _LEVEL_NORM                    0x2
#define _LEVEL_LOW                     0x4
#define LOG_FLAGS(_flag)      _DFSM_ENABLE_ ## _flag

#define LOG_ENABLED( _level, _flags) \
            (( DfsRtlWmiReg.EnableLevel >= (_level) ) &&   \
             ( DfsRtlWmiReg.EnableFlags & _flags ))
            
            
#define DFS_WML_LOG(_level, _flags, _id, _arg) \
    do { \
        if ( LOG_ENABLED(_level, _flags) ) { \
            wml.Trace( WML_ID(_id), \
                     &DfsmRtlTraceGuid , \
                      DfsRtlWmiReg.LoggerHandle, _arg 0); \
        } \
    } while (0)            

#define DFSM_LOG(_level, _flags, _type, _args) \
        DFS_WML_LOG(_level, _flags, _type, _args)


#define DFSM_TRACE_NORM(_flags, _type, _args) \
                DFSM_LOG(_LEVEL_NORM, LOG_FLAGS(_flags), _type, _args)
#define DFSM_TRACE_LOW(_flags, _type, _args) \
                DFSM_LOG(_LEVEL_LOW, LOG_FLAGS(_flags), _type, _args)
#define DFSM_TRACE_HIGH( _flag, _type, _arg)    \
                DFSM_LOG(_LEVEL_HIGH, LOG_FLAGS(_flag), _type, _arg)

#define DFSM_TRACE_ERROR(_status, _flag, _type, _arg)    \
            DFSM_LOG(_LEVEL_NORM, (LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : LOG_FLAGS(ERROR))), _type, _arg)

#define DFSM_TRACE_ERROR_HIGH(_status, _flag, _type, _arg)    \
            DFSM_LOG(_LEVEL_HIGH, (LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : LOG_FLAGS(ERROR))), _type, _arg)

#define DFSM_TRACE_ERROR_LOW(_status, _flag, _type, _arg)    \
            DFSM_LOG(_LEVEL_LOW, (LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : LOG_FLAGS(ERROR))), _type, _arg)


#  define WPP_DEFINE_MSG_ID(_a,_b)   ( ((_a) << 16) | ( _b) )


#define LOGNOTHING      0,
            

#define WML_ID(_id)    ((MSG_ID_ ## _id) & 0xFF)

#  define MSG_ID_CDfsServiceCreateExitPoint_Error_I_NetDfsGetVersion	 WPP_DEFINE_MSG_ID(0,111)
#  define MSG_ID_CDfsServiceCreateLocalVolume_I_NetDfsCreateLocalPartition	 WPP_DEFINE_MSG_ID(0,112)
#  define MSG_ID_CDfsServiceDeleteLocalVolume_Error_I_NetDfsDeleteLocalPartition	 WPP_DEFINE_MSG_ID(0,113)
#  define MSG_ID_CDfsServiceFixLocalVolume_Error_I_NetDfsFixLocalVolume	 WPP_DEFINE_MSG_ID(0,115)
#  define MSG_ID_CDfsServiceModifyPrefix_Error_I_NetDfsModifyPrefix	 WPP_DEFINE_MSG_ID(0,116)
#  define MSG_ID_CDfsServiceSetVolumeState_Error_I_NetDfsSetLocalVolumeState	 WPP_DEFINE_MSG_ID(0,114)
#  define MSG_ID_ClusCallBackFunction_Error_ClusterRegOpenKey	 WPP_DEFINE_MSG_ID(0,26)
#  define MSG_ID_DfsGetDsBlob_Error_ldap_search_sW	 WPP_DEFINE_MSG_ID(0,91)
#  define MSG_ID_DfsGetFtServersFromDs_Error_DsGetDcName	 WPP_DEFINE_MSG_ID(0,23)
#  define MSG_ID_DfsGetFtServersFromDs_Error_ldap_search_sW	 WPP_DEFINE_MSG_ID(0,24)
#  define MSG_ID_DfsGetFtServersFromDs_Error_ldap_search_sW_2	 WPP_DEFINE_MSG_ID(0,25)
#  define MSG_ID_DfsInitializePrefixTable_Error1	 WPP_DEFINE_MSG_ID(0,10)
#  define MSG_ID_DfsInitializePrefixTable_Error2	 WPP_DEFINE_MSG_ID(0,11)
#  define MSG_ID_DfsInsertInPrefixTable_Error1	 WPP_DEFINE_MSG_ID(0,12)
#  define MSG_ID_DfsInsertInPrefixTable_Error2	 WPP_DEFINE_MSG_ID(0,13)
#  define MSG_ID_DfsInsertInPrefixTable_Error3	 WPP_DEFINE_MSG_ID(0,14)
#  define MSG_ID_DfsInsertInPrefixTable_Error4	 WPP_DEFINE_MSG_ID(0,15)
#  define MSG_ID_DfsLoadSiteTableFromDs_Error_ldap_search_sW	 WPP_DEFINE_MSG_ID(0,22)
#  define MSG_ID_DfsManagerAddService_Error_I_NetDfsManagerReportSiteInfo	 WPP_DEFINE_MSG_ID(0,90)
#  define MSG_ID_DfsManagerCreateVolumeObject_Error_I_NetDfsManagerReportSiteInfo	 WPP_DEFINE_MSG_ID(0,89)
#  define MSG_ID_DfsManagerStartDSSync_Error_NtCreateEvent	 WPP_DEFINE_MSG_ID(0,30)
#  define MSG_ID_DfsPutDsBlob_Error_ldap_modify_sW	 WPP_DEFINE_MSG_ID(0,92)
#  define MSG_ID_DfsRemoveFromPrefixTable_Error1	 WPP_DEFINE_MSG_ID(0,16)
#  define MSG_ID_DfsmFlushStalePktEntries_Error_NtCreateFile	 WPP_DEFINE_MSG_ID(0,129)
#  define MSG_ID_DfsmFlushStalePktEntries_Error_NtFsControl	 WPP_DEFINE_MSG_ID(0,130)
#  define MSG_ID_DfsmInitLocalPartitions_Error_NtCreateFile	 WPP_DEFINE_MSG_ID(0,117)
#  define MSG_ID_DfsmInitLocalPartitions_Error_NtFsCOntrolFile	 WPP_DEFINE_MSG_ID(0,118)
#  define MSG_ID_DfsmMarkStalePktEntries_Error_NtCreateFile	 WPP_DEFINE_MSG_ID(0,127)
#  define MSG_ID_DfsmMarkStalePktEntries_Error_NtFsControlFile	 WPP_DEFINE_MSG_ID(0,128)
#  define MSG_ID_DfsmPktFlushCache_Error_NtCreateFile	 WPP_DEFINE_MSG_ID(0,125)
#  define MSG_ID_DfsmPktFlushCache_Error_NtFsControlFile	 WPP_DEFINE_MSG_ID(0,126)
#  define MSG_ID_DfsmResetPkt_Error_NtCreateFile	 WPP_DEFINE_MSG_ID(0,123)
#  define MSG_ID_DfsmResetPkt_Error_NtFsControlFile	 WPP_DEFINE_MSG_ID(0,124)
#  define MSG_ID_DfsmStartDfs_Error_NtCreateFile	 WPP_DEFINE_MSG_ID(0,119)
#  define MSG_ID_DfsmStartDfs_Error_NtFsControlFile	 WPP_DEFINE_MSG_ID(0,120)
#  define MSG_ID_DfsmStopDfs_Error_NtCreateFile	 WPP_DEFINE_MSG_ID(0,121)
#  define MSG_ID_DfsmStopDfs_Error_NtFsControlFile	 WPP_DEFINE_MSG_ID(0,122)
#  define MSG_ID_DfspConnectToLdapServer_ERROR_DfspLdapOpen	 WPP_DEFINE_MSG_ID(0,17)
#  define MSG_ID_DfspCreateExitPoint_Error1	 WPP_DEFINE_MSG_ID(0,99)
#  define MSG_ID_DfspCreateExitPoint_Error2	 WPP_DEFINE_MSG_ID(0,100)
#  define MSG_ID_DfspCreateExitPoint_Error_NtFsControlFile	 WPP_DEFINE_MSG_ID(0,101)
#  define MSG_ID_DfspCreateFtDfsDsObj_Error_ldap_modify_sW_2	 WPP_DEFINE_MSG_ID(0,132)
#  define MSG_ID_DfspCreateFtDfsDsObj_Error_ldap_search_sW	 WPP_DEFINE_MSG_ID(0,131)
#  define MSG_ID_DfspCreateRootServerList_Error_ldap_search_sW	 WPP_DEFINE_MSG_ID(0,135)
#  define MSG_ID_DfspDeleteExitPoint_Error1	 WPP_DEFINE_MSG_ID(0,102)
#  define MSG_ID_DfspDeleteExitPoint_Error2	 WPP_DEFINE_MSG_ID(0,103)
#  define MSG_ID_DfspDeleteExitPoint_Error_NtFsControlFile	 WPP_DEFINE_MSG_ID(0,104)
#  define MSG_ID_DfspGetCoveredSiteInfo_Error_DsGetSiteName	 WPP_DEFINE_MSG_ID(0,109)
#  define MSG_ID_DfspGetCoveredSiteInfo_Error_RegOpenKey	 WPP_DEFINE_MSG_ID(0,105)
#  define MSG_ID_DfspGetCoveredSiteInfo_Error_RegQueryInfoKey	 WPP_DEFINE_MSG_ID(0,106)
#  define MSG_ID_DfspGetCoveredSiteInfo_Error_RegQueryValueEx	 WPP_DEFINE_MSG_ID(0,107)
#  define MSG_ID_DfspGetCoveredSiteInfo_Error_RegQueryValueEx2	 WPP_DEFINE_MSG_ID(0,108)
#  define MSG_ID_DfspGetOneEnumInfo_Error1	 WPP_DEFINE_MSG_ID(0,87)
#  define MSG_ID_DfspGetOneEnumInfo_Error2	 WPP_DEFINE_MSG_ID(0,88)
#  define MSG_ID_DfspGetPdc_Error_DsGetDcName	 WPP_DEFINE_MSG_ID(0,31)
#  define MSG_ID_DfspGetRemoteConfigInfo_Error_NetDfsManagerGetConfigInfo	 WPP_DEFINE_MSG_ID(0,110)
#  define MSG_ID_DfspLdapOpen_Error_ldap_bind_s	 WPP_DEFINE_MSG_ID(0,136)
#  define MSG_ID_DfspLdapOpen_Error_ldap_search_sW	 WPP_DEFINE_MSG_ID(0,137)
#  define MSG_ID_DfspRemoveFtDfsDsObj_Error_ldap_modify_sW	 WPP_DEFINE_MSG_ID(0,134)
#  define MSG_ID_DfspRemoveFtDfsDsObj_Error_ldap_search_sW	 WPP_DEFINE_MSG_ID(0,133)
#  define MSG_ID_GetDcName_Error_GetDcName	 WPP_DEFINE_MSG_ID(0,21)
#  define MSG_ID_InitializeNetDfsInterface_Error_RpcServerListen	 WPP_DEFINE_MSG_ID(0,29)
#  define MSG_ID_InitializeNetDfsInterface_Error_RpcServerRegisterIf	 WPP_DEFINE_MSG_ID(0,28)
#  define MSG_ID_InitializeNetDfsInterface_Error_RpcServerUseProtseqEpW	 WPP_DEFINE_MSG_ID(0,27)
#  define MSG_ID_MoveFileOrJP_Error1	 WPP_DEFINE_MSG_ID(0,93)
#  define MSG_ID_MoveFileOrJP_Error2	 WPP_DEFINE_MSG_ID(0,94)
#  define MSG_ID_MoveFileOrJP_Error3	 WPP_DEFINE_MSG_ID(0,98)
#  define MSG_ID_MoveFileOrJP_Error_NtCreateFile	 WPP_DEFINE_MSG_ID(0,95)
#  define MSG_ID_MoveFileOrJP_Error_NtCreateFile2	 WPP_DEFINE_MSG_ID(0,96)
#  define MSG_ID_MoveFileOrJP_Error_NtSetInformationFile	 WPP_DEFINE_MSG_ID(0,97)
#  define MSG_ID_NetrDfsAdd2_End	 WPP_DEFINE_MSG_ID(0,41)
#  define MSG_ID_NetrDfsAdd2_Error1	 WPP_DEFINE_MSG_ID(0,37)
#  define MSG_ID_NetrDfsAdd2_Error2	 WPP_DEFINE_MSG_ID(0,39)
#  define MSG_ID_NetrDfsAdd2_Error_I_NetDfsManagerReportSiteInfo	 WPP_DEFINE_MSG_ID(0,40)
#  define MSG_ID_NetrDfsAdd2_Error_NetShareGetInfo	 WPP_DEFINE_MSG_ID(0,38)
#  define MSG_ID_NetrDfsAdd2_Start	 WPP_DEFINE_MSG_ID(0,36)
#  define MSG_ID_NetrDfsAddFtRoot_End	 WPP_DEFINE_MSG_ID(0,43)
#  define MSG_ID_NetrDfsAddFtRoot_Start	 WPP_DEFINE_MSG_ID(0,42)
#  define MSG_ID_NetrDfsAddStdRootForced_End	 WPP_DEFINE_MSG_ID(0,53)
#  define MSG_ID_NetrDfsAddStdRootForced_Start	 WPP_DEFINE_MSG_ID(0,52)
#  define MSG_ID_NetrDfsAddStdRoot_End	 WPP_DEFINE_MSG_ID(0,51)
#  define MSG_ID_NetrDfsAddStdRoot_Start	 WPP_DEFINE_MSG_ID(0,50)
#  define MSG_ID_NetrDfsAdd_End	 WPP_DEFINE_MSG_ID(0,35)
#  define MSG_ID_NetrDfsAdd_Start	 WPP_DEFINE_MSG_ID(0,34)
#  define MSG_ID_NetrDfsEnum200_Error1	 WPP_DEFINE_MSG_ID(0,69)
#  define MSG_ID_NetrDfsEnum200_Error2	 WPP_DEFINE_MSG_ID(0,70)
#  define MSG_ID_NetrDfsEnum200_Error3	 WPP_DEFINE_MSG_ID(0,71)
#  define MSG_ID_NetrDfsEnum200_Error4	 WPP_DEFINE_MSG_ID(0,72)
#  define MSG_ID_NetrDfsEnum200_Error5	 WPP_DEFINE_MSG_ID(0,73)
#  define MSG_ID_NetrDfsEnum200_Error6	 WPP_DEFINE_MSG_ID(0,74)
#  define MSG_ID_NetrDfsEnumEx_End	 WPP_DEFINE_MSG_ID(0,76)
#  define MSG_ID_NetrDfsEnumEx_Start	 WPP_DEFINE_MSG_ID(0,75)
#  define MSG_ID_NetrDfsEnum_End	 WPP_DEFINE_MSG_ID(0,68)
#  define MSG_ID_NetrDfsEnum_Start	 WPP_DEFINE_MSG_ID(0,67)
#  define MSG_ID_NetrDfsFlushFtTable_Error_NtCreateFile	 WPP_DEFINE_MSG_ID(0,49)
#  define MSG_ID_NetrDfsFlushFtTable_Start	 WPP_DEFINE_MSG_ID(0,48)
#  define MSG_ID_NetrDfsGetDcAddress_End	 WPP_DEFINE_MSG_ID(0,45)
#  define MSG_ID_NetrDfsGetDcAddress_Start	 WPP_DEFINE_MSG_ID(0,44)
#  define MSG_ID_NetrDfsGetInfo_End	 WPP_DEFINE_MSG_ID(0,66)
#  define MSG_ID_NetrDfsGetInfo_Start	 WPP_DEFINE_MSG_ID(0,65)
#  define MSG_ID_NetrDfsManagerGetConfigInfo_End	 WPP_DEFINE_MSG_ID(0,82)
#  define MSG_ID_NetrDfsManagerGetConfigInfo_Start	 WPP_DEFINE_MSG_ID(0,81)
#  define MSG_ID_NetrDfsManagerGetVersion_End	 WPP_DEFINE_MSG_ID(0,33)
#  define MSG_ID_NetrDfsManagerGetVersion_Start	 WPP_DEFINE_MSG_ID(0,32)
#  define MSG_ID_NetrDfsManagerInitialize_End	 WPP_DEFINE_MSG_ID(0,86)
#  define MSG_ID_NetrDfsManagerInitialize_Start	 WPP_DEFINE_MSG_ID(0,85)
#  define MSG_ID_NetrDfsManagerSendSiteInfo_End	 WPP_DEFINE_MSG_ID(0,84)
#  define MSG_ID_NetrDfsManagerSendSiteInfo_Start	 WPP_DEFINE_MSG_ID(0,83)
#  define MSG_ID_NetrDfsMove_End	 WPP_DEFINE_MSG_ID(0,78)
#  define MSG_ID_NetrDfsMove_Start	 WPP_DEFINE_MSG_ID(0,77)
#  define MSG_ID_NetrDfsRemove2_End	 WPP_DEFINE_MSG_ID(0,57)
#  define MSG_ID_NetrDfsRemove2_Start	 WPP_DEFINE_MSG_ID(0,56)
#  define MSG_ID_NetrDfsRemoveFtRoot_End	 WPP_DEFINE_MSG_ID(0,59)
#  define MSG_ID_NetrDfsRemoveFtRoot_Start	 WPP_DEFINE_MSG_ID(0,58)
#  define MSG_ID_NetrDfsRemoveStdRoot_End	 WPP_DEFINE_MSG_ID(0,61)
#  define MSG_ID_NetrDfsRemoveStdRoot_Start	 WPP_DEFINE_MSG_ID(0,60)
#  define MSG_ID_NetrDfsRemove_End	 WPP_DEFINE_MSG_ID(0,55)
#  define MSG_ID_NetrDfsRemove_Start	 WPP_DEFINE_MSG_ID(0,54)
#  define MSG_ID_NetrDfsRename_End	 WPP_DEFINE_MSG_ID(0,80)
#  define MSG_ID_NetrDfsRename_Start	 WPP_DEFINE_MSG_ID(0,79)
#  define MSG_ID_NetrDfsSetDcAddress_End	 WPP_DEFINE_MSG_ID(0,47)
#  define MSG_ID_NetrDfsSetDcAddress_Start	 WPP_DEFINE_MSG_ID(0,46)
#  define MSG_ID_NetrDfsSetInfo2_End	 WPP_DEFINE_MSG_ID(0,64)
#  define MSG_ID_NetrDfsSetInfo2_Error1	 WPP_DEFINE_MSG_ID(0,63)
#  define MSG_ID_NetrDfsSetInfo2_Start	 WPP_DEFINE_MSG_ID(0,62)
#  define MSG_ID__FlushObjectTable_Error_ldap_modify_ext_sW	 WPP_DEFINE_MSG_ID(0,20)
#  define MSG_ID__IsObjectTableUpToDate_Error_ldap_search_sW	 WPP_DEFINE_MSG_ID(0,18)
#  define MSG_ID__ReadObjectTable_Error_ldap_search_sW	 WPP_DEFINE_MSG_ID(0,19)


#if defined (c_plusplus) || defined (__cplusplus)

extern "C" {
extern    WML_DATA wml;
extern    WMILIB_REG_STRUCT   DfsRtlWmiReg;
extern    GUID DfsmRtlTraceGuid;
};
#else
extern    WML_DATA wml;
extern    WMILIB_REG_STRUCT   DfsRtlWmiReg;
extern    GUID DfsmRtlTraceGuid;
#endif //C_PLUS_PLUS

#endif // _DFSMWML_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\ftsup.cxx ===
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  File:       ftsup.cxx
//
//  Contents:   This module contains the functions which deal with ftdfs removal
//
//  History:    07-Dec-1998     JHarper Created.
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "marshal.hxx"
#include "winldap.h"
#include "dsgetdc.h"
#include "setup.hxx"
#include "ftsup.hxx"
#include "dfsmwml.h"

#if DBG

void
DumpBuf(
    PCHAR cp,
    ULONG len);

#endif // DBG

extern PLDAP pLdapConnection;

//+------------------------------------------------------------------------
//
// Function:    DfsGetDsBlob
//
// Synopsis:    Reads a Dfs BLOB from the DS
//
// History:     11/19/98 JHarper Created
//
//-------------------------------------------------------------------------

DWORD
DfsGetDsBlob(
    LPWSTR wszFtDfsName,
    LPWSTR wszDcName,
    ULONG *pcbBlob,
    BYTE **ppBlob)
{
    DWORD dwErr;
    LDAP *pldap = NULL;
    PLDAPMessage pMsg = NULL;
    PLDAP_BERVAL *rgldapPktBlob = NULL;
    PLDAP_BERVAL pldapPktBlob;
    LDAPMessage *pmsgServers;
    DWORD i;
    WCHAR *wszConfigurationDN = NULL;
    WCHAR wszDfsConfigDN[MAX_PATH+1];
    LPWSTR rgAttrs[5];
    BYTE *pBlob = NULL;
    ULONG cLen = 0;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsGetDsBlob(%ws,%ws)\n", wszFtDfsName, wszDcName);
#endif

    dwErr = DfspLdapOpen(wszDcName, &pldap, &wszConfigurationDN);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Build the entry name we want to search in
    //

    cLen = wcslen(L"CN=") +
            wcslen(wszFtDfsName) +
              wcslen(L",") +
                wcslen(wszConfigurationDN) +
                  1;

    if (cLen > MAX_PATH) {
        dwErr =  ERROR_DS_NAME_TOO_LONG;
        goto Cleanup;
    }

    wcscpy(wszDfsConfigDN,L"CN=");
    wcscat(wszDfsConfigDN,wszFtDfsName);
    wcscat(wszDfsConfigDN,L",");
    wcscat(wszDfsConfigDN,wszConfigurationDN);

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("wszDfsConfigDN=[%ws]\n", wszDfsConfigDN);
#endif

    rgAttrs[0] = L"pKT";
    rgAttrs[1] = NULL;

    if (DfsSvcLdap)
        DbgPrint("DfsGetDsBlob:ldap_search_s(%ws)\n", rgAttrs[0]);

    dwErr = ldap_search_sW(
                pldap,
                wszDfsConfigDN,
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                rgAttrs,
                0,
                &pMsg);

    DFSM_TRACE_ERROR_HIGH(dwErr, ALL_ERROR,
                          DfsGetDsBlob_Error_ldap_search_sW,
                          LOGULONG(dwErr));

    if (dwErr != LDAP_SUCCESS) {
        dwErr = LdapMapErrorToWin32(dwErr);
        goto Cleanup;
    }

    pmsgServers = ldap_first_entry(pldap, pMsg);

    if (pmsgServers == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    rgldapPktBlob = ldap_get_values_lenW(
                        pldap,
                        pMsg,
                        L"pKT");

    if (rgldapPktBlob == NULL || *rgldapPktBlob == NULL) {
        dwErr = ERROR_INTERNAL_DB_CORRUPTION;
        goto Cleanup;
    }

    pldapPktBlob = rgldapPktBlob[0];

    pBlob = (BYTE *)malloc(pldapPktBlob->bv_len);

    if (pBlob == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    RtlCopyMemory(pBlob, pldapPktBlob->bv_val, pldapPktBlob->bv_len);

    *ppBlob = pBlob;
    *pcbBlob = pldapPktBlob->bv_len;

Cleanup:

    if (rgldapPktBlob != NULL)
        ldap_value_free_len(rgldapPktBlob);

    if (pMsg != NULL)
        ldap_msgfree( pMsg );

    if (pldap != NULL && pldap != pLdapConnection) {
        if (DfsSvcLdap)
            DbgPrint("DfsGetDsBlob:ldap_unbind()\n");
        ldap_unbind( pldap );
    }

    if (wszConfigurationDN != NULL)
        free(wszConfigurationDN);

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsGetDsBlob returning %d\n", dwErr);
#endif

    return (dwErr);

}

//+------------------------------------------------------------------------
//
// Function:    DfsPutDsBlob
//
// Synopsis:    Updates a Dfs BLOB in the DS
//
// History:     12/8/98 JHarper Created
//
//-------------------------------------------------------------------------

DWORD
DfsPutDsBlob(
    LPWSTR wszFtDfsName,
    LPWSTR wszDcName,
    ULONG cbBlob,
    BYTE *pBlob)
{

    DWORD dwErr;
    LDAP *pldap = NULL;
    GUID idNewPkt;
    LDAP_BERVAL ldapVal;
    PLDAP_BERVAL rgldapVals[2];
    LDAPModW ldapMod;
    LDAP_BERVAL ldapIdVal;
    PLDAP_BERVAL rgldapIdVals[2];
    LDAPModW ldapIdMod;
    PLDAPModW rgldapMods[3];
    WCHAR *wszConfigurationDN = NULL;
    WCHAR wszDfsConfigDN[MAX_PATH+1];

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsPutDsBlob(%ws,%ws)\n", wszFtDfsName, wszDcName);
#endif

    dwErr = DfspLdapOpen(wszDcName, &pldap, &wszConfigurationDN);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Build the entry name
    //

    wcscpy(wszDfsConfigDN,L"CN=");
    wcscat(wszDfsConfigDN,wszFtDfsName);
    wcscat(wszDfsConfigDN,L",");
    wcscat(wszDfsConfigDN,wszConfigurationDN);

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("wszDfsConfigDN=[%ws]\n", wszDfsConfigDN);
#endif

    UuidCreate( &idNewPkt );

    ldapIdVal.bv_len = sizeof(GUID);
    ldapIdVal.bv_val = (PCHAR) &idNewPkt;
    rgldapIdVals[0] = &ldapIdVal;
    rgldapIdVals[1] = NULL;

    ldapIdMod.mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    ldapIdMod.mod_type = L"pKTGuid";
    ldapIdMod.mod_vals.modv_bvals = rgldapIdVals;

    ldapVal.bv_len = cbBlob;
    ldapVal.bv_val = (PCHAR) pBlob;
    rgldapVals[0] = &ldapVal;
    rgldapVals[1] = NULL;

    ldapMod.mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    ldapMod.mod_type = L"pKT";
    ldapMod.mod_vals.modv_bvals = rgldapVals;

    rgldapMods[0] = &ldapMod;
    rgldapMods[1] = &ldapIdMod;
    rgldapMods[2] = NULL;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("Writing BLOB of %d bytes\n", cbBlob);
#endif

    if (DfsSvcLdap)
        DbgPrint("DfsPutDsBlob:ldap_modify(%ws)\n", L"pKTGuid and pKT");

    dwErr = ldap_modify_sW(
                    pldap,
                    wszDfsConfigDN,
                    rgldapMods);

    DFSM_TRACE_ERROR_HIGH(dwErr, ALL_ERROR, 
                          DfsPutDsBlob_Error_ldap_modify_sW,
                          LOGULONG(dwErr));

#if DBG
    if (DfsSvcVerbose) {
        DbgPrint("ldap_modify_sW returned %d\n", dwErr);
    }
#endif

    if (pldap != pLdapConnection) {
        if (DfsSvcLdap)
            DbgPrint("DfsPutDsBlob(1):ldap_unbind()\n");
        ldap_unbind(pldap);
        pldap = NULL;
    }

    if (dwErr != LDAP_SUCCESS) {
        dwErr = LdapMapErrorToWin32(dwErr);
    } else {
        dwErr = ERROR_SUCCESS;
    }

Cleanup:

    if (pldap != NULL && pldap != pLdapConnection) {
        if (DfsSvcLdap)
            DbgPrint("DfsPutDsBlob(2):ldap_unbind()\n");
        ldap_unbind( pldap );
    }

    if (wszConfigurationDN != NULL)
        free(wszConfigurationDN);

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsPutDsBlob returning %d\n", dwErr);
#endif

    return (dwErr);

}

//+------------------------------------------------------------------------
//
// Function:    DfsGetVolList
//
// Synopsis:    Unserializes an FtDfs BLOB and creates
//              a volume list representing an FtDfs.
//
// History:     11/19/98 JHarper Created
//
//-------------------------------------------------------------------------
DWORD
DfsGetVolList(
    ULONG cbBlob,
    BYTE *pBlob,
    PDFS_VOLUME_LIST pDfsVolList)
{
    DWORD dwErr;
    DWORD cObj;
    DWORD cVol;
    LDAP_PKT LdapPkt;
    MARSHAL_BUFFER marshalBuffer;
    NTSTATUS NtStatus;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsGetVolList()\n");
#endif

    RtlZeroMemory(&LdapPkt, sizeof(LDAP_PKT));

    if (cbBlob > sizeof(DWORD)) {

        _GetULong(pBlob, pDfsVolList->Version);

#if DBG
        if (DfsSvcVerbose) {
            DbgPrint("Blob Version = %d\n", pDfsVolList->Version);
            DbgPrint("BLOB is %d bytes:\n", cbBlob);
        }
#endif

        MarshalBufferInitialize(
            &marshalBuffer,
            cbBlob - sizeof(DWORD),
            pBlob + sizeof(DWORD));

        NtStatus = DfsRtlGet(&marshalBuffer, &MiLdapPkt, &LdapPkt);

        if (!NT_SUCCESS(NtStatus)) {
            dwErr =  RtlNtStatusToDosError(NtStatus);
            goto Cleanup;
        }

#if DBG
        if (DfsSvcVerbose) {

            DbgPrint("  %d objects found\n", LdapPkt.cLdapObjects);

            for (cObj = 0; cObj < LdapPkt.cLdapObjects; cObj++) {

                DbgPrint("%d:name=%ws size=%d p=0x%x\n",
                        cObj,
                        LdapPkt.rgldapObjects[cObj].wszObjectName,
                        LdapPkt.rgldapObjects[cObj].cbObjectData,
                        LdapPkt.rgldapObjects[cObj].pObjectData);

                // DumpBuf(
                //     LdapPkt.rgldapObjects[cObj].pObjectData,
                //     LdapPkt.rgldapObjects[cObj].cbObjectData);
            }

        }
#endif

        for (cObj = 0; cObj < LdapPkt.cLdapObjects; cObj++) {

            if (wcscmp(LdapPkt.rgldapObjects[cObj].wszObjectName, L"\\siteroot") != 0) {
                pDfsVolList->VolCount++;
            }

        }

        pDfsVolList->Volumes = (PDFS_VOLUME) malloc(pDfsVolList->VolCount * sizeof(DFS_VOLUME));

        if (pDfsVolList->Volumes == NULL) {

            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;

        }

        RtlZeroMemory(pDfsVolList->Volumes, pDfsVolList->VolCount * sizeof(DFS_VOLUME));

        //
        // Save the true/allocated size so to optimize deletions/additions
        //
        pDfsVolList->AllocatedVolCount = pDfsVolList->VolCount;

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("===============================\n");
#endif

        for (cVol = cObj = 0; cObj < LdapPkt.cLdapObjects; cObj++) {

            if (wcscmp(LdapPkt.rgldapObjects[cObj].wszObjectName, L"\\siteroot") == 0) {

                dwErr = DfsGetSiteTable(
                            pDfsVolList,
                            &LdapPkt.rgldapObjects[cObj]);

            } else {

                dwErr = DfsGetVolume(
                            &pDfsVolList->Volumes[cVol],
                            &LdapPkt.rgldapObjects[cObj]);

            }

            if (dwErr != ERROR_SUCCESS)
                goto Cleanup;

            cVol++;

        }

    } else if (cbBlob == sizeof(DWORD)) {

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("pKT BLOB is simply one DWORD\n");
#endif
        dwErr = ERROR_INTERNAL_DB_CORRUPTION;

    } else {

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("pKT BLOB is corrupt!\n");
#endif
        dwErr = ERROR_INTERNAL_DB_CORRUPTION;

    }

Cleanup:

    FreeLdapPkt(&LdapPkt);

    //
    // Do any recovery needed
    //

    if(pDfsVolList && pDfsVolList->Volumes) {
	DWORD dwErr2 = DfsRecoverVolList(pDfsVolList);
	if(dwErr == ERROR_SUCCESS) {
	    // this is to prevent masking the previous error.
	    dwErr = dwErr2;
	}
    }
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsGetVolList returning %d\n", dwErr);
#endif

    return( dwErr );

}

//+------------------------------------------------------------------------
//
// Function:    DfsGetVolume
//
// Synopsis:    Unserializes the data in a buffer/blob to a volume
//
// History:     11/19/98 JHarper Created
//
//-------------------------------------------------------------------------

DWORD
DfsGetVolume(
    PDFS_VOLUME pVolume,
    PLDAP_OBJECT pLdapObject)
{
    DFS_VOLUME_PROPERTIES VolProps;
    DWORD dwErr = ERROR_SUCCESS;
    MARSHAL_BUFFER marshalBuffer;
    NTSTATUS NtStatus;
    PBYTE pBuffer = NULL;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsGetVolume(%ws,%d)\n", 
                pLdapObject->wszObjectName,
                pLdapObject->cbObjectData);
#endif

    RtlZeroMemory(&VolProps, sizeof(DFS_VOLUME_PROPERTIES));

    pVolume->wszObjectName = (WCHAR *) malloc(
                    (wcslen(pLdapObject->wszObjectName)+1) * sizeof(WCHAR));

    if (pVolume->wszObjectName == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    wcscpy(
        pVolume->wszObjectName,
        pLdapObject->wszObjectName);

    MarshalBufferInitialize(
        &marshalBuffer,
        pLdapObject->cbObjectData,
        pLdapObject->pObjectData);

    NtStatus = DfsRtlGet(
                    &marshalBuffer,
                    &MiVolumeProperties,
                    &VolProps);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr =  RtlNtStatusToDosError(NtStatus);
        goto Cleanup;
    }

    VolProps.dwTimeout = 300;

    if (
        (marshalBuffer.Current < marshalBuffer.Last)
            &&
        (marshalBuffer.Last - marshalBuffer.Current) == sizeof(ULONG)
    ) {

        DfsRtlGetUlong(&marshalBuffer, &VolProps.dwTimeout);

    }

    pVolume->idVolume = VolProps.idVolume;
    pVolume->wszPrefix = VolProps.wszPrefix;
    pVolume->wszShortPrefix = VolProps.wszShortPrefix;
    pVolume->dwType = VolProps.dwType;
    pVolume->dwState = VolProps.dwState;
    pVolume->wszComment = VolProps.wszComment;
    pVolume->dwTimeout = VolProps.dwTimeout;
    pVolume->ftPrefix = VolProps.ftPrefix;
    pVolume->ftState = VolProps.ftState;
    pVolume->ftComment = VolProps.ftComment;
    pVolume->dwVersion = VolProps.dwVersion;
    pVolume->cbRecovery = VolProps.cbRecovery;
    pVolume->pRecovery = VolProps.pRecovery;

    pBuffer = VolProps.pSvc;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("VolProps.cbSvc = %d\n", VolProps.cbSvc);
#endif

    dwErr = UnSerializeReplicaList(
                &pVolume->ReplCount,
                &pVolume->AllocatedReplCount,
                &pVolume->ReplicaInfo,
                &pVolume->FtModification,
                &pBuffer);

    if (dwErr != ERROR_SUCCESS) {
        goto Cleanup;
    }

    //
    // Get deleted replicas
    //

    if (pBuffer < (pBuffer + VolProps.cbSvc)) {

        dwErr = UnSerializeReplicaList(
                    &pVolume->DelReplCount,
                    &pVolume->AllocatedDelReplCount,
                    &pVolume->DelReplicaInfo,
                    &pVolume->DelFtModification,
                    &pBuffer);

        if (dwErr != ERROR_SUCCESS) {
            goto Cleanup;
        }

    }

Cleanup:

    if (VolProps.pSvc != NULL)
        MarshalBufferFree(VolProps.pSvc);

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsGetVolume returning %d\n", dwErr);
#endif

    return dwErr;

}

//+------------------------------------------------------------------------
//
// Function:    DfsFreeVolList
//
// Synopsis:    Frees the volume list and associated substructures representing
//              an FtDfs.
//
// History:     11/19/98 JHarper Created
//
//-------------------------------------------------------------------------

VOID
DfsFreeVolList(
    PDFS_VOLUME_LIST pDfsVolList)
{
    ULONG cVol;
    ULONG cSite;
    ULONG i;
    PLIST_ENTRY pListHead;
    PDFSM_SITE_ENTRY pSiteEntry;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsFreeVolList()\n");
#endif

    if (pDfsVolList->VolCount > 0 && pDfsVolList->Volumes) {
        for (cVol = 0; cVol < pDfsVolList->VolCount; cVol++) {
            DfsFreeVol(&pDfsVolList->Volumes[cVol]);
        }
    }

    if (pDfsVolList->Volumes != NULL)
        free(pDfsVolList->Volumes);

    pListHead = &pDfsVolList->SiteList;

    if (pListHead->Flink != NULL) {

        while (pListHead->Flink != pListHead) {
            pSiteEntry = CONTAINING_RECORD(pListHead->Flink, DFSM_SITE_ENTRY, Link);
            RemoveEntryList(pListHead->Flink);
            for (i = 0; i < pSiteEntry->Info.cSites; i++) {
                if (pSiteEntry->Info.Site[i].SiteName != NULL)
                    MarshalBufferFree(pSiteEntry->Info.Site[i].SiteName);
            }
            if (pSiteEntry->ServerName != NULL)
                MarshalBufferFree(pSiteEntry->ServerName);
            free(pSiteEntry);
        }

    }

    RtlZeroMemory(pDfsVolList, sizeof(DFS_VOLUME_LIST));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsFreeVolList exit\n");
#endif

}

//+------------------------------------------------------------------------
//
// Function:    DfsFreeVol
//
// Synopsis:    Frees the volume and associated substructures representing
//              an FtDfs volume
//
// History:     12/16/98 JHarper Created
//
//-------------------------------------------------------------------------

VOID
DfsFreeVol(
    PDFS_VOLUME pVol)
{
    ULONG cRepl;

#if DBG
    if (DfsSvcVerbose & 0x80000000)
        DbgPrint("DfsFreeVol()\n");
#endif

    if (pVol->ReplCount > 0 && pVol->ReplicaInfo != NULL) {
        for (cRepl = 0; cRepl < pVol->ReplCount; cRepl++) {
            DfsFreeRepl(&pVol->ReplicaInfo[cRepl]);
        }
    }

    if (pVol->DelReplCount > 0 && pVol->DelReplicaInfo != NULL) {
        for (cRepl = 0; cRepl < pVol->DelReplCount; cRepl++) {
            DfsFreeRepl(&pVol->DelReplicaInfo[cRepl]);
        }
    }

    if (pVol->wszPrefix != NULL)
        MarshalBufferFree(pVol->wszPrefix);
    if (pVol->wszShortPrefix != NULL)
        MarshalBufferFree(pVol->wszShortPrefix);
    if (pVol->wszComment != NULL)
        MarshalBufferFree(pVol->wszComment);
    if (pVol->pRecovery != NULL)
        MarshalBufferFree(pVol->pRecovery);

    if (pVol->ReplicaInfo != NULL)
        free(pVol->ReplicaInfo);
    if (pVol->DelReplicaInfo != NULL)
        free(pVol->DelReplicaInfo);
    if (pVol->FtModification != NULL)
        free(pVol->FtModification);
    if (pVol->DelFtModification != NULL)
        free(pVol->DelFtModification);
    if (pVol->wszObjectName != NULL)
        free(pVol->wszObjectName);

    RtlZeroMemory(pVol, sizeof(DFS_VOLUME));

#if DBG
    if (DfsSvcVerbose & 0x80000000)
        DbgPrint("DfsFreeVol exit\n");
#endif
}

//+------------------------------------------------------------------------
//
// Function:    DfsFreeRepl
//
// Synopsis:    Frees the Replica and associated substructures representing
//              an FtDfs replica
//
// History:     12/16/98 JHarper Created
//
//-------------------------------------------------------------------------

VOID
DfsFreeRepl(
    PDFS_REPLICA_INFO pRepl)
{
#if DBG
    if (DfsSvcVerbose & 0x80000000)
        DbgPrint("DfsFreeRepl()\n");
#endif

    if (pRepl->pwszServerName != NULL)
        MarshalBufferFree(pRepl->pwszServerName);

    if (pRepl->pwszShareName != NULL)
        MarshalBufferFree(pRepl->pwszShareName);

    RtlZeroMemory(pRepl, sizeof(DFS_REPLICA_INFO));

#if DBG
    if (DfsSvcVerbose & 0x80000000)
        DbgPrint("DfsFreeRepl exit\n");
#endif
}


//+------------------------------------------------------------------------
//
// Function:    DfsPutVolList
//
// Synopsis:    Serializes the structs representing a Dfs volume and
//              creates a BLOB.
//
// History:     11/19/98 JHarper Created
//
//-------------------------------------------------------------------------

DWORD
DfsPutVolList(
    ULONG *pcbBlob,
    BYTE **ppBlob,
    PDFS_VOLUME_LIST pDfsVolList)
{
    ULONG cVol;
    ULONG cRepl;
    ULONG cObj;
    ULONG cBuffer;
    ULONG cSite;
    DWORD dwErr = ERROR_SUCCESS;
    PBYTE Buffer = NULL;
    MARSHAL_BUFFER marshalBuffer;
    NTSTATUS NtStatus;
    DFS_VOLUME_PROPERTIES VolProps;
    LDAP_PKT LdapPkt;
    PLIST_ENTRY pListHead;
    PLIST_ENTRY pLink;
    PDFSM_SITE_ENTRY pSiteEntry;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsPutVolList()\n");
#endif

    LdapPkt.cLdapObjects = pDfsVolList->VolCount + 1;
    LdapPkt.rgldapObjects = (PLDAP_OBJECT) malloc(LdapPkt.cLdapObjects * sizeof(LDAP_OBJECT));

    if (LdapPkt.rgldapObjects == NULL) {
        dwErr =  ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(LdapPkt.rgldapObjects, LdapPkt.cLdapObjects * sizeof(LDAP_OBJECT));

    //
    // For each volume, serialize the replicas, then the volume
    //

    for (cVol = 0; cVol < pDfsVolList->VolCount; cVol++) {

        RtlZeroMemory(&VolProps, sizeof(DFS_VOLUME_PROPERTIES));

        LdapPkt.rgldapObjects[cVol].wszObjectName = (WCHAR *) MarshalBufferAllocate(

                (wcslen(pDfsVolList->Volumes[cVol].wszObjectName)+1) * sizeof(WCHAR));

        if (LdapPkt.rgldapObjects[cVol].wszObjectName == NULL) {
            dwErr =  ERROR_OUTOFMEMORY;
            goto Cleanup;
        }

        wcscpy(LdapPkt.rgldapObjects[cVol].wszObjectName, pDfsVolList->Volumes[cVol].wszObjectName);

        //
        // Serialize the replicas
        //

        dwErr = SerializeReplicaList(
                    pDfsVolList->Volumes[cVol].ReplCount,
                    pDfsVolList->Volumes[cVol].ReplicaInfo,
                    pDfsVolList->Volumes[cVol].FtModification,
                    pDfsVolList->Volumes[cVol].DelReplCount,
                    pDfsVolList->Volumes[cVol].DelReplicaInfo,
                    pDfsVolList->Volumes[cVol].DelFtModification,
                    &VolProps.cbSvc,
                    &VolProps.pSvc);

        if (dwErr != ERROR_SUCCESS) {
            dwErr =  ERROR_OUTOFMEMORY;
            goto Cleanup;
        }

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("   cbSvc = %d\n", VolProps.cbSvc);
#endif

        VolProps.idVolume = pDfsVolList->Volumes[cVol].idVolume;
        VolProps.wszPrefix = pDfsVolList->Volumes[cVol].wszPrefix;
        VolProps.wszShortPrefix = pDfsVolList->Volumes[cVol].wszShortPrefix;
        VolProps.dwType = pDfsVolList->Volumes[cVol].dwType;
        VolProps.dwState = pDfsVolList->Volumes[cVol].dwState;
        VolProps.wszComment = pDfsVolList->Volumes[cVol].wszComment;
        VolProps.dwTimeout = pDfsVolList->Volumes[cVol].dwTimeout;
        VolProps.ftPrefix = pDfsVolList->Volumes[cVol].ftPrefix;
        VolProps.ftState = pDfsVolList->Volumes[cVol].ftState;
        VolProps.ftComment = pDfsVolList->Volumes[cVol].ftComment;
        VolProps.dwVersion = pDfsVolList->Volumes[cVol].dwVersion;
        VolProps.cbRecovery = pDfsVolList->Volumes[cVol].cbRecovery;
        VolProps.pRecovery = pDfsVolList->Volumes[cVol].pRecovery;

        //
        // Now serialize the volume

        cBuffer = 0;
        NtStatus = DfsRtlSize(&MiVolumeProperties, &VolProps, &cBuffer);

        if (!NT_SUCCESS(NtStatus)) {
            MarshalBufferFree(VolProps.pSvc);
            dwErr =  RtlNtStatusToDosError(NtStatus);
            goto Cleanup;
        }

        cBuffer += sizeof(ULONG);

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("VolProps marshaled size = %d\n", cBuffer);
#endif

        Buffer = (PBYTE) MarshalBufferAllocate(cBuffer);

        if (Buffer == NULL) {
            MarshalBufferFree(VolProps.pSvc);
            dwErr =  ERROR_OUTOFMEMORY;
            goto Cleanup;
        }

        LdapPkt.rgldapObjects[cVol].pObjectData = (PCHAR) Buffer;
        LdapPkt.rgldapObjects[cVol].cbObjectData =  cBuffer;

        MarshalBufferInitialize(
            &marshalBuffer,
            cBuffer,
            Buffer);

        NtStatus = DfsRtlPut(&marshalBuffer, &MiVolumeProperties, &VolProps);

        if (!NT_SUCCESS(NtStatus)) {
            MarshalBufferFree(VolProps.pSvc);
            dwErr =  RtlNtStatusToDosError(NtStatus);
            goto Cleanup;
        }

        NtStatus = DfsRtlPutUlong(&marshalBuffer, &VolProps.dwTimeout);

        if (!NT_SUCCESS(NtStatus)) {
            MarshalBufferFree(VolProps.pSvc);
            dwErr =  RtlNtStatusToDosError(NtStatus);
            goto Cleanup;
        }

        MarshalBufferFree(VolProps.pSvc);

    }

    //
    // Serialize the site table
    //

    cBuffer = sizeof(ULONG) + sizeof(GUID);

    //
    // Add the size of all the entries
    //

    pListHead = &pDfsVolList->SiteList;

    for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
        pSiteEntry = CONTAINING_RECORD(pLink, DFSM_SITE_ENTRY, Link);
#if DBG
        if (DfsSvcVerbose)
            DbgPrint("pSiteEntry for %ws\n", pSiteEntry->ServerName);
#endif
        NtStatus = DfsRtlSize(&MiDfsmSiteEntry, pSiteEntry, &cBuffer);
        if (!NT_SUCCESS(NtStatus)) {
            dwErr =  RtlNtStatusToDosError(NtStatus);
            goto Cleanup;
        }
    }

    //
    // Get a buffer big enough
    //

    Buffer = (BYTE *) MarshalBufferAllocate(cBuffer);

    if (Buffer == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    LdapPkt.rgldapObjects[pDfsVolList->VolCount].wszObjectName =
                    (WCHAR *)MarshalBufferAllocate(sizeof(L"\\siteroot"));
    if (LdapPkt.rgldapObjects[pDfsVolList->VolCount].wszObjectName == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    wcscpy(LdapPkt.rgldapObjects[pDfsVolList->VolCount].wszObjectName, L"\\siteroot");
    LdapPkt.rgldapObjects[pDfsVolList->VolCount].pObjectData = (PCHAR) Buffer;
    LdapPkt.rgldapObjects[pDfsVolList->VolCount].cbObjectData =  cBuffer;

    MarshalBufferInitialize(
          &marshalBuffer,
          cBuffer,
          Buffer);

    //
    // Put the guid, then the object count in the beginning of the buffer
    //

    DfsRtlPutGuid(&marshalBuffer, &pDfsVolList->SiteGuid);
    DfsRtlPutUlong(&marshalBuffer, &pDfsVolList->SiteCount);

    for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
        pSiteEntry = CONTAINING_RECORD(pLink, DFSM_SITE_ENTRY, Link);
        DfsRtlPut(&marshalBuffer,&MiDfsmSiteEntry, pSiteEntry);
        if (!NT_SUCCESS(NtStatus)) {
            dwErr =  RtlNtStatusToDosError(NtStatus);
            goto Cleanup;
        }
    }

#if DBG
    if (DfsSvcVerbose) {

        DbgPrint("After reserialization,  %d objects found\n", LdapPkt.cLdapObjects);

        for (cObj = 0; cObj < LdapPkt.cLdapObjects; cObj++) {

            DbgPrint("%d:name=%ws size=%d p=0x%x\n",
                cObj,
                LdapPkt.rgldapObjects[cObj].wszObjectName,
                LdapPkt.rgldapObjects[cObj].cbObjectData,
                LdapPkt.rgldapObjects[cObj].pObjectData);

            // DumpBuf(
            //     LdapPkt.rgldapObjects[cObj].pObjectData,
            //     LdapPkt.rgldapObjects[cObj].cbObjectData);
        }

    }
#endif

    //
    // Finally, serialize all the volumes and the site table into a blob
    //

    cBuffer = 0;
    NtStatus = DfsRtlSize(&MiLdapPkt, &LdapPkt, &cBuffer);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(dwErr);
        goto Cleanup;
    }

    cBuffer += sizeof(DWORD);

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("New ldap size = %d\n", cBuffer);
#endif

    Buffer = (PBYTE) malloc(cBuffer);

    if (Buffer == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    // 447486. Fix prefix bug. use memory after checking for null

    *((PDWORD) Buffer) = 2;             // Version #
    MarshalBufferInitialize(
        &marshalBuffer,
        cBuffer,
        Buffer + sizeof(DWORD));

    NtStatus = DfsRtlPut(&marshalBuffer, &MiLdapPkt, &LdapPkt);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(dwErr);
        goto Cleanup;
    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("Remarshal succeeded cBuffer = %d\n", cBuffer);
#endif

    *pcbBlob = cBuffer;
    *ppBlob = Buffer;
    Buffer = NULL;

Cleanup:

    FreeLdapPkt(&LdapPkt);

    if (dwErr != ERROR_SUCCESS && Buffer != NULL)
        free(Buffer);

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsPutVolList exit %d\n", dwErr);
#endif

    return dwErr;

}

//+------------------------------------------------------------------------
//
// Function:    FreeLdapPkt
//
// Synopsis:    Frees an LDAP_PKT structure and all substructures.
//
// History:     11/19/98 JHarper Created
//
//-------------------------------------------------------------------------

VOID
FreeLdapPkt(
    LDAP_PKT *pLdapPkt)
{
    ULONG cObj;

    if (pLdapPkt->rgldapObjects != NULL) {

        for (cObj = 0; cObj < pLdapPkt->cLdapObjects; cObj++) {
            if (pLdapPkt->rgldapObjects[cObj].wszObjectName != NULL) 
                MarshalBufferFree(pLdapPkt->rgldapObjects[cObj].wszObjectName);
            if (pLdapPkt->rgldapObjects[cObj].pObjectData != NULL)
                MarshalBufferFree(pLdapPkt->rgldapObjects[cObj].pObjectData);
        }
        MarshalBufferFree(pLdapPkt->rgldapObjects);
    }

}

//+------------------------------------------------------------------------
//
// Function:    SerializeReplicaList
//
// Synopsis:    This method serializes the replica info list and the
//              deleted replica info list into a buffer.
//
// Returns:     [ERROR_SUCCESS] -- If all went well.
//
//              [ERROR_OUTOFMEMORY] - If unable to allocate the target buffer.
//
// History:     11/19/98 JHarper Created
//
//-------------------------------------------------------------------------
DWORD
SerializeReplicaList(
    ULONG ReplCount,
    DFS_REPLICA_INFO *pReplicaInfo,
    FILETIME *pFtModification,
    ULONG DelReplCount,
    DFS_REPLICA_INFO *pDelReplicaInfo,
    FILETIME *pDelFtModification,
    ULONG *cBuffer,
    PBYTE *ppBuffer)
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG TotalSize;
    ULONG i;
    ULONG *pSize;
    BYTE *Buffer = NULL;
    ULONG *SizeBuffer = NULL;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("SerializeReplicaList(%d,%d)\n", ReplCount, DelReplCount);
#endif

    pSize = SizeBuffer = (PULONG) malloc(sizeof(ULONG) * (ReplCount + DelReplCount));

    if (SizeBuffer == NULL) {

        return ERROR_OUTOFMEMORY;

    }

    //
    // Need all the size values now and later for marshalling stuff.
    // So we collect them here into an array.
    //

    TotalSize = 0;
    pSize = SizeBuffer;

    for (i = 0; i < ReplCount; i++) {

        *pSize = GetReplicaMarshalSize(&pReplicaInfo[i], &pFtModification[i]);
        TotalSize += *pSize;
        pSize++;

    }

    for (i = 0; i < DelReplCount; i++) {

        *pSize = GetReplicaMarshalSize(&pDelReplicaInfo[i], &pDelFtModification[i]);
        TotalSize += *pSize;
        pSize++;

    }

    //
    // Allocate the byte Buffer we need to pass back
    //
    // TotalSize is the size required just to marshal all the replicas and
    // their last-modification-timestamps.
    //
    // In addition, we need:
    //
    //  1 ULONG for storing the count of replicas
    //  ReplCount ULONGs for storing the marshal size of each replica.
    //  1 ULONG for count of deleted replicas
    //  DelReplCount ULONGS for storing the marshal size of each deleted Repl
    //

    //
    // First calc the size of the Buffer.
    //

    TotalSize += sizeof(ULONG) * (1 + ReplCount + 1 + DelReplCount);

    *ppBuffer = Buffer = (PBYTE) malloc(TotalSize);

    if (Buffer == NULL) {
        free(SizeBuffer);
        return ERROR_OUTOFMEMORY;
    }

    //
    // Set the number of entries to follow in the Buffer at the start.
    //

    _PutULong(Buffer, ReplCount);
    Buffer += sizeof(ULONG);

    pSize = SizeBuffer;
    for (i = 0; i < ReplCount; i++) {

        //
        // Marshall each replica Entry into the Buffer.
        // Remember we first need to put the size of the marshalled
        // replica entry to follow, then the FILETIME for the replica,
        // and finally, the marshalled replica entry structure.
        //

        _PutULong(Buffer, *pSize);
        Buffer += sizeof(ULONG);
        dwErr = SerializeReplica(&pReplicaInfo[i], &pFtModification[i], Buffer, *pSize);
        if (dwErr != ERROR_SUCCESS) {
            free(*ppBuffer);
            return dwErr;
        }
        Buffer += *pSize;
        pSize++;

    }

    //
    // Now marshal the deleted Repl list.
    //

    _PutULong(Buffer, DelReplCount);
    Buffer += sizeof(ULONG);

    for (i = 0; i < DelReplCount; i++) {

        _PutULong(Buffer, *pSize);
        Buffer += sizeof(ULONG);
        dwErr = SerializeReplica(&pDelReplicaInfo[i], &pDelFtModification[i], Buffer, *pSize);
        if (dwErr != ERROR_SUCCESS) {
            free(*ppBuffer);
            return dwErr;
        }
        Buffer += *pSize;
        pSize++;
    }

    *cBuffer = TotalSize;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("SerializeReplicaList exit %d\n", dwErr);
#endif

    return( dwErr );

}

//+------------------------------------------------------------------------
//
// Member:      SerializeReplica
//
// Synopsis:    Serializes a replica info structure
//
// Notes:       The size of the buffer should have been calculated using
//              the function GetReplicaMarshalSize()
//
// History:     13-May-93       SudK    Created.
//              19-Nov-98       Jharper Modified.
//
//-------------------------------------------------------------------------
DWORD
SerializeReplica(
    DFS_REPLICA_INFO *pDfsReplicaInfo,
    FILETIME *pFtModification,
    PBYTE Buffer,
    ULONG Size)
{
    DWORD dwErr;
    MARSHAL_BUFFER MarshalBuffer;
    NTSTATUS NtStatus;

    MarshalBufferInitialize(&MarshalBuffer, Size, Buffer);
    NtStatus = DfsRtlPut(&MarshalBuffer, &MiFileTime, pFtModification);

    if (NT_SUCCESS(NtStatus))
        NtStatus = DfsRtlPut(&MarshalBuffer, &MiDfsReplicaInfo, pDfsReplicaInfo);

    dwErr =  RtlNtStatusToDosError(NtStatus);

    return dwErr;
}

//+----------------------------------------------------------------------
//
// Member:      GetReplicaMarshalSize, public
//
// Synopsis:    Returns the size of a buffer required to marshal this
//              replica.
//
// History:     12-May-93       SudK    Created.
//              19-Nov-98       Jharper Modified.
//
//-----------------------------------------------------------------------

ULONG
GetReplicaMarshalSize(
    DFS_REPLICA_INFO *pDfsReplicaInfo,
    FILETIME *pFtModification)
{
    ULONG Size = 0;
    NTSTATUS NtStatus;

    NtStatus = DfsRtlSize(&MiFileTime, pFtModification, &Size);

    if (NT_SUCCESS(NtStatus))
        NtStatus = DfsRtlSize(&MiDfsReplicaInfo, pDfsReplicaInfo, &Size);

    return(Size);

}

//+------------------------------------------------------------------------
//
// Member:      UnSerializeReplicaList
//
// Synopsis:    Unserializes a buffer into a relica list.
//
// History:     20-Nov-98       Jharper created
//
//-------------------------------------------------------------------------

DWORD
UnSerializeReplicaList(
    ULONG *pReplCount,
    ULONG *pAllocatedReplCount,
    DFS_REPLICA_INFO **ppReplicaInfo,
    FILETIME **ppFtModification,
    BYTE **ppBuffer)
{

    DFS_REPLICA_INFO *pReplicaInfo = NULL;
    FILETIME *pFtModification = NULL;
    ULONG ReplCount;
    BYTE *pBuffer = *ppBuffer;
    ULONG cRepl;
    ULONG Size;
    DWORD dwErr = ERROR_SUCCESS;
    MARSHAL_BUFFER marshalBuffer;
    NTSTATUS NtStatus;

    //
    // Get # replicas
    //

    _GetULong(pBuffer, ReplCount);
    pBuffer += sizeof(ULONG);

    pReplicaInfo = (DFS_REPLICA_INFO *) malloc(sizeof(DFS_REPLICA_INFO) * ReplCount);

    pFtModification = (FILETIME *) malloc(sizeof(FILETIME) * ReplCount);

    if(pReplicaInfo == NULL || pFtModification == NULL) {

        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;

    }

    //
    // Now get each replica
    //

    for (cRepl = 0; cRepl < ReplCount; cRepl++) {

        _GetULong(pBuffer, Size);
        pBuffer += sizeof(ULONG);

        MarshalBufferInitialize(
            &marshalBuffer,
            Size,
            pBuffer);

        NtStatus = DfsRtlGet(
                        &marshalBuffer,
                        &MiFileTime,
                        &pFtModification[cRepl]);

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = DfsRtlGet(
                        &marshalBuffer,
                        &MiDfsReplicaInfo,
                        &pReplicaInfo[cRepl]);

        }

        if (NT_SUCCESS(NtStatus)) {

            pBuffer += Size;

        }

    }

    *ppReplicaInfo = pReplicaInfo;
    *ppFtModification = pFtModification;
    *ppBuffer = pBuffer;
    *pAllocatedReplCount = *pReplCount = ReplCount;

Cleanup:

    if (dwErr != ERROR_SUCCESS) {
        if (pReplicaInfo != NULL)
            free(pReplicaInfo);
        if (pFtModification != NULL)
            free(pFtModification);
    }

    return dwErr;

}

//+------------------------------------------------------------------------
//
// Function:    DfsGetSiteTable
//
// Synopsis:    Unserializes the buffer passed in into a dfs site table.
//
// Returns:     [ERROR_SUCCESS] -- If all went well.
//
//              [ERROR_OUTOFMEMORY] - If unable to allocate the target buffer.
//
// History:     11/19/98 JHarper Created
//
//-------------------------------------------------------------------------

DWORD
DfsGetSiteTable(
    PDFS_VOLUME_LIST pDfsVolList,
    PLDAP_OBJECT pLdapObject)
{
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS NtStatus;
    ULONG cSite;
    PDFSM_SITE_ENTRY pSiteEntry;
    PDFSM_SITE_ENTRY pTmpSiteEntry;
    MARSHAL_BUFFER marshalBuffer;
    BYTE *pBuffer = NULL;
    ULONG Size;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsGetSiteTable(%d)\n", pLdapObject->cbObjectData);
#endif

    InitializeListHead(&pDfsVolList->SiteList);

    MarshalBufferInitialize(
      &marshalBuffer,
      pLdapObject->cbObjectData,
      pLdapObject->pObjectData);

    NtStatus = DfsRtlGetGuid(&marshalBuffer, &pDfsVolList->SiteGuid);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr =  RtlNtStatusToDosError(NtStatus);
        goto Cleanup;
    }

    NtStatus = DfsRtlGetUlong(&marshalBuffer, &pDfsVolList->SiteCount);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr =  RtlNtStatusToDosError(NtStatus);
        goto Cleanup;
    }

    pBuffer = (BYTE *)malloc(pLdapObject->cbObjectData);

    if (pBuffer == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    pTmpSiteEntry = (PDFSM_SITE_ENTRY)pBuffer;

    for (cSite = 0; cSite < pDfsVolList->SiteCount; cSite++) {

        RtlZeroMemory(pBuffer, pLdapObject->cbObjectData);

        NtStatus = DfsRtlGet(
                        &marshalBuffer,
                        &MiDfsmSiteEntry,
                        pBuffer);

        if (!NT_SUCCESS(NtStatus)) {
            dwErr =  RtlNtStatusToDosError(NtStatus);
            goto Cleanup;
        }

        Size = sizeof(DFSM_SITE_ENTRY) + (pTmpSiteEntry->Info.cSites * sizeof(DFS_SITENAME_INFO));

        pSiteEntry = (PDFSM_SITE_ENTRY) malloc(Size);

        if (pSiteEntry == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }

        RtlCopyMemory(pSiteEntry, pBuffer, Size);
        InsertHeadList(&pDfsVolList->SiteList, &pSiteEntry->Link);

    }

Cleanup:

    if (pBuffer != NULL)
        free(pBuffer);

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsGetSiteTable exit dwErr=%d\n", dwErr);
#endif

    return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetNetInfoEx
//
//  Synopsis:   Gets information about the volume.
//
//  Arguments:  [Level] -- Level of Information desired.
//
//              [pDfsVol] - Pointer to DFS_VOLUME to use to fill the info
//
//              [pInfo] -- Pointer to info struct to be filled. Pointer
//                      members will be allocated using MIDL_user_allocate.
//                      The type of this variable is LPDFS_INFO_3, but one
//                      can pass in pointers to lower levels, and only the
//                      fields appropriate for the level will be touched.
//
//              [pcbInfo] -- On successful return, contains the size in
//                      bytes of the returned info. The returned size does
//                      not include the size of the DFS_INFO_3 struct itself.
//
//  Returns:    ERROR_SUCCESS -- Successfully returning info
//
//              ERROR_OUTOFMEMORY -- Out of memory
//
//-----------------------------------------------------------------------------

DWORD
GetNetInfoEx(
    PDFS_VOLUME pDfsVol,
    DWORD Level,
    LPDFS_INFO_3 pInfo,
    LPDWORD pcbInfo)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cbInfo = 0;
    DWORD cbItem;
    ULONG i;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("GetNetInfoEx(%ws,%d)\n", pDfsVol->wszPrefix, Level);
#endif

    //
    // See if this is a Level 100 or 101. If so, we handle them right away
    // and return

    if (Level == 100) {

        LPDFS_INFO_100  pInfo100 = (LPDFS_INFO_100) pInfo;

        if (pDfsVol->wszComment != NULL) {
            cbItem = (wcslen(pDfsVol->wszComment) + 1) * sizeof(WCHAR);
            pInfo100->Comment = (LPWSTR) MIDL_user_allocate(cbItem);
            if (pInfo100->Comment != NULL) {
                wcscpy(pInfo100->Comment, pDfsVol->wszComment);
                cbInfo += cbItem;
                goto AllDone;
            } else {
                dwErr = ERROR_OUTOFMEMORY;
                goto AllDone;
            }
        } else {
            pInfo100->Comment = (LPWSTR) MIDL_user_allocate(sizeof(WCHAR));
            if (pInfo100->Comment != NULL) {
                pInfo100->Comment[0] = UNICODE_NULL;
                cbInfo += sizeof(WCHAR);
                goto AllDone;
            } else {
                dwErr = ERROR_OUTOFMEMORY;
                goto AllDone;
            }
        }

    }

    if (Level == 101) {

        LPDFS_INFO_101 pInfo101 = (LPDFS_INFO_101) pInfo;

        pInfo->State = pDfsVol->dwState;
        goto AllDone;

    }

    //
    // level 4 isn't just an extension of 3, so handle it seperately
    //

    if (Level == 4) {

        LPDFS_INFO_4 pInfo4 = (LPDFS_INFO_4) pInfo;

        cbItem = sizeof(UNICODE_PATH_SEP) + (wcslen(pDfsVol->wszPrefix) + 1) * sizeof(WCHAR);
        pInfo4->EntryPath = (LPWSTR) MIDL_user_allocate(cbItem);
        if (pInfo4->EntryPath != NULL) {
            pInfo4->EntryPath[0] = UNICODE_PATH_SEP;
            wcscpy(&pInfo4->EntryPath[1], pDfsVol->wszPrefix);
            cbInfo += cbItem;
        } else {
            dwErr = ERROR_OUTOFMEMORY;
            goto AllDone;
        }

        if (pDfsVol->wszComment != NULL) {
            cbItem = (wcslen(pDfsVol->wszComment)+1) * sizeof(WCHAR);
            pInfo4->Comment = (LPWSTR) MIDL_user_allocate(cbItem);
            if (pInfo4->Comment != NULL) {
                wcscpy( pInfo4->Comment, pDfsVol->wszComment );
                cbInfo += cbItem;
            } else {
                dwErr = ERROR_OUTOFMEMORY;
                goto AllDone;
            }
        } else {
            pInfo4->Comment = (LPWSTR) MIDL_user_allocate(sizeof(WCHAR));
            if (pInfo4->Comment != NULL) {
                pInfo4->Comment[0] = UNICODE_NULL;
                cbInfo += sizeof(WCHAR);
            } else {
                dwErr = ERROR_OUTOFMEMORY;
                goto AllDone;
            }
        }

        pInfo4->State = pDfsVol->dwState;
        pInfo4->Timeout = pDfsVol->dwTimeout;
        pInfo4->Guid = pDfsVol->idVolume;
        pInfo4->NumberOfStorages = pDfsVol->ReplCount;
        cbItem = pInfo4->NumberOfStorages * sizeof(DFS_STORAGE_INFO);
        pInfo4->Storage = (LPDFS_STORAGE_INFO) MIDL_user_allocate(cbItem);
        if (pInfo4->Storage != NULL) {
            RtlZeroMemory(pInfo4->Storage, cbItem);
            cbInfo += cbItem;
            for (i = 0; i < pDfsVol->ReplCount; i++) {
                dwErr = GetNetStorageInfo(&pDfsVol->ReplicaInfo[i],&pInfo4->Storage[i],&cbItem);
                cbInfo += cbItem;
            }
            if (dwErr != ERROR_SUCCESS) {
                for (; i > 0; i--) {
                    MIDL_user_free(pInfo4->Storage[i-1].ServerName);
                    MIDL_user_free(pInfo4->Storage[i-1].ShareName);
                }
            }
        } else {
            dwErr = ERROR_OUTOFMEMORY;
        }

        //
        // See if we need to clean up...
        //

        if (dwErr != ERROR_SUCCESS) {
            if (pInfo4->EntryPath != NULL) {
                MIDL_user_free(pInfo4->EntryPath);
            }
            if (pInfo4->Storage != NULL) {
                MIDL_user_free(pInfo4->Storage);
            }
            goto AllDone;
        } else {
            *pcbInfo = cbInfo;
        }
        goto AllDone;

    }

    //
    // Level is 1,2 or 3
    //

    //
    // Fill in the Level 1 stuff
    //

    cbItem = sizeof(UNICODE_PATH_SEP) + (wcslen(pDfsVol->wszPrefix)+1) * sizeof(WCHAR);
    pInfo->EntryPath = (LPWSTR) MIDL_user_allocate(cbItem);
    if (pInfo->EntryPath != NULL) {
        pInfo->EntryPath[0] = UNICODE_PATH_SEP;
        wcscpy(&pInfo->EntryPath[1], pDfsVol->wszPrefix);
        cbInfo += cbItem;
    } else {
        dwErr = ERROR_OUTOFMEMORY;
        goto AllDone;
    }

    //
    // Fill in the Level 2 stuff if needed
    //

    if (Level > 1) {
        pInfo->State = pDfsVol->dwState;
        pInfo->NumberOfStorages = pDfsVol->ReplCount;
        if (pDfsVol->wszComment != NULL) {
            cbItem = (wcslen(pDfsVol->wszComment)+1) * sizeof(WCHAR);
            pInfo->Comment = (LPWSTR) MIDL_user_allocate(cbItem);
            if (pInfo->Comment != NULL) {
                wcscpy( pInfo->Comment, pDfsVol->wszComment );
                cbInfo += cbItem;
            } else {
                dwErr = ERROR_OUTOFMEMORY;
            }
        } else {
            pInfo->Comment = (LPWSTR) MIDL_user_allocate(sizeof(WCHAR));
            if (pInfo->Comment != NULL) {
                pInfo->Comment[0] = UNICODE_NULL;
                cbInfo += sizeof(WCHAR);
            } else {
                dwErr = ERROR_OUTOFMEMORY;
            }
        }
    }

    //
    // Fill in the Level 3 stuff if needed
    //

    if (dwErr == ERROR_SUCCESS && Level > 2) {
        cbItem = pInfo->NumberOfStorages * sizeof(DFS_STORAGE_INFO);
        pInfo->Storage = (LPDFS_STORAGE_INFO) MIDL_user_allocate(cbItem);
        if (pInfo->Storage != NULL) {
            RtlZeroMemory(pInfo->Storage, cbItem);
            cbInfo += cbItem;
            for (i = 0; i < pDfsVol->ReplCount; i++) {
                dwErr = GetNetStorageInfo(&pDfsVol->ReplicaInfo[i], &pInfo->Storage[i], &cbItem);
                cbInfo += cbItem;
            }
            if (dwErr != ERROR_SUCCESS) {
                for (; i > 0; i--) {
                    MIDL_user_free(pInfo->Storage[i-1].ServerName);
                    MIDL_user_free(pInfo->Storage[i-1].ShareName);
                }
            }
        } else {
            dwErr = ERROR_OUTOFMEMORY;
        }
    }

    //
    // See if we need to clean up...
    //

    if (dwErr != ERROR_SUCCESS) {
        if (Level > 1) {
            if (pInfo->EntryPath != NULL) {
                MIDL_user_free(pInfo->EntryPath);
            }
        }
        if (Level > 2) {
            if (pInfo->Storage != NULL) {
                MIDL_user_free(pInfo->Storage);
            }
        }
    }

AllDone:

    //
    // Finally, we are done
    //

    if (dwErr == ERROR_SUCCESS)
        *pcbInfo = cbInfo;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("GetNetInfoEx returning %d\n", dwErr);
#endif

    return(dwErr);

}

//+----------------------------------------------------------------------------
//
//  Function:   GetNetStorageInfo, public
//
//  Synopsis:   Returns the replica info in a DFS_STORAGE_INFO struct.
//              Useful for NetDfsXXX APIs.
//
//  Arguments:  [pInfo] -- Pointer to DFS_STORAGE_INFO to fill. Pointer
//                      members will be allocated using MIDL_user_allocate.
//
//              [pcbInfo] -- On successful return, set to size in bytes of
//                      returned info. The size does not include the size
//                      of the DFS_STORAGE_INFO struct itself.
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
GetNetStorageInfo(
    PDFS_REPLICA_INFO pRepl,
    LPDFS_STORAGE_INFO pInfo,
    LPDWORD pcbInfo)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR wszShare;
    DWORD cbInfo = 0, cbItem;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("GetNetStorageInfo(\\\\%ws\\%ws)\n",
                    pRepl->pwszServerName,
                    pRepl->pwszShareName);
#endif

    pInfo->State = pRepl->ulReplicaState;

    cbItem = (wcslen(pRepl->pwszServerName) + 1) * sizeof(WCHAR);
    pInfo->ServerName = (LPWSTR) MIDL_user_allocate(cbItem);
    if (pInfo->ServerName != NULL) {
        wcscpy(pInfo->ServerName, pRepl->pwszServerName);
        cbInfo += cbItem;
    } else {
        dwErr = ERROR_OUTOFMEMORY;
    }

    if (dwErr == ERROR_SUCCESS) {
        cbItem = (wcslen(pRepl->pwszShareName) + 1) * sizeof(WCHAR);
        pInfo->ShareName = (LPWSTR) MIDL_user_allocate(cbItem);
        if (pInfo->ShareName != NULL) {
            wcscpy( pInfo->ShareName, pRepl->pwszShareName );
            cbInfo += cbItem;
        } else {
            MIDL_user_free( pInfo->ServerName );
            pInfo->ServerName = NULL;
            dwErr = ERROR_OUTOFMEMORY;
        }
    }

    if (dwErr == ERROR_SUCCESS)
        *pcbInfo = cbInfo;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("GetStorageInfo returning %d\n", dwErr);
#endif

    return( dwErr );

}

//+------------------------------------------------------------------------
//
// Function:    DfsRemoveRootReplica
//
// Synopsis:    Removes a Dfs root replica from the dfs root replica list
//
// History:     12/16/98 JHarper Created
//
//-------------------------------------------------------------------------

DWORD
DfsRemoveRootReplica(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR RootName)
{
    ULONG cVol;
    ULONG cRepl;
    DWORD dwErr = ERROR_SUCCESS;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsRemoveRootReplica(%ws)\n", RootName);
#endif


    for (cVol = 0; cVol < pDfsVolList->VolCount; cVol++) {

        if (wcscmp(pDfsVolList->Volumes[cVol].wszObjectName,L"\\domainroot") != 0)
            continue;

ScanReplicas:

        for (cRepl = 0; cRepl < pDfsVolList->Volumes[cVol].ReplCount; cRepl++) {

            if (
                _wcsicmp(
                    pDfsVolList->Volumes[cVol].ReplicaInfo[cRepl].pwszServerName,
                    RootName) == 0
            ) {
                DfsReplDeleteByIndex(&pDfsVolList->Volumes[cVol], cRepl);
                goto ScanReplicas;
            }

        }

        break;

    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsRemoveRootReplica exit %d\n", dwErr);
#endif

    return dwErr;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsRecoverVolList, public
//
//  Synopsis:   Walks the dfs_volume list, checking the recovery params, and
//              applying any recovery needed.  Also applies the deleted replica
//              list to the volume's replica list.
//
//  Arguments:  [pDfsVolList] -- Pointer to DFS_VOLUME_LIST work on.
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
DfsRecoverVolList(
    PDFS_VOLUME_LIST pDfsVolList)
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG iVol;
    ULONG iRepl;
    ULONG iDelRepl;
    PDFS_VOLUME pVol;
    ULONG RecoveryState;
    ULONG Operation;
    ULONG OperState;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsRecoverVolList(%d volumes)\n", pDfsVolList->VolCount);
#endif

ReStart:
    for (iVol = 0; dwErr == ERROR_SUCCESS && iVol < pDfsVolList->VolCount; iVol++) {
        pVol = &pDfsVolList->Volumes[iVol];
        if (pVol->cbRecovery >= sizeof(ULONG))  {
            _GetULong(pVol->pRecovery, RecoveryState);
#if DBG
            if (DfsSvcVerbose)
                DbgPrint("RecoveryState[%d]=0x%x\n", iVol, RecoveryState);
#endif
            if (DFS_GET_RECOVERY_STATE(RecoveryState) != DFS_RECOVERY_STATE_NONE) {
                Operation = DFS_GET_RECOVERY_STATE(RecoveryState);
                OperState = DFS_GET_OPER_STAGE(RecoveryState);
                switch (Operation)  {
                case DFS_RECOVERY_STATE_CREATING:
#if DBG
                    if (DfsSvcVerbose)
                        DbgPrint("DFS_RECOVERY_STATE_CREATING\n");
#endif
                    dwErr = DfsVolDelete(pDfsVolList, iVol);
                    goto ReStart;
                case DFS_RECOVERY_STATE_ADD_SERVICE:
#if DBG
                    if (DfsSvcVerbose)
                        DbgPrint("DFS_RECOVERY_STATE_ADD_SERVICE\n");
#endif
                    // dwErr = RecoverFromAddService(OperState);
                    ASSERT(L"DFS_RECOVERY_STATE_ADD_SERVICE - WHY?\n");
                    break;
                case DFS_RECOVERY_STATE_REMOVE_SERVICE:
#if DBG
                    if (DfsSvcVerbose)
                        DbgPrint("DFS_RECOVERY_STATE_REMOVE_SERVICE\n");
#endif
                    // dwErr = RecoverFromRemoveService(OperState);
                    ASSERT(L"DFS_RECOVERY_STATE_REMOVE_SERVICE - WHY?\n");
                    break;
                case DFS_RECOVERY_STATE_DELETE:
#if DBG
                    if (DfsSvcVerbose)
                        DbgPrint("DFS_RECOVERY_STATE_DELETE\n");
#endif
                    dwErr = DfsVolDelete(pDfsVolList, iVol);
                    goto ReStart;
                default:
#if DBG
                    if (DfsSvcVerbose)
                        DbgPrint("default\n");
#endif
                    dwErr = ERROR_INTERNAL_DB_CORRUPTION;
                }
            }
        }
        if (pVol->pRecovery != NULL)
            MarshalBufferFree(pVol->pRecovery);
        pVol->pRecovery = NULL;
        pVol->cbRecovery = 0;
    }

    if (dwErr != ERROR_SUCCESS)
        goto AllDone;

    //
    // Now apply deleted replica list to each volume
    //

    for (iVol = 0; dwErr == ERROR_SUCCESS && iVol < pDfsVolList->VolCount; iVol++) {
        pVol = &pDfsVolList->Volumes[iVol];
        for (iDelRepl = 0; dwErr == ERROR_SUCCESS && iDelRepl < pVol->DelReplCount; iDelRepl++) {
#if 0   // XXX This appears to be wrong - don't do it.
            dwErr = DfsReplDeleteByName(
                            pVol,
                            pVol->DelReplicaInfo[iDelRepl].pwszServerName,
                            pVol->DelReplicaInfo[iDelRepl].pwszShareName);
#endif
            DfsFreeRepl(&pVol->DelReplicaInfo[iDelRepl]);
        }
        if (pVol->DelReplicaInfo != NULL) {
            free(pVol->DelReplicaInfo);
            pVol->DelReplicaInfo = NULL;
        }
        if (pVol->DelFtModification != NULL) {
            free(pVol->DelFtModification);
            pVol->DelFtModification = NULL;
        }
        pVol->DelReplCount = 0;
    }

AllDone:

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsRecoverVolList returning %d\n", dwErr);
#endif
    return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsVolDelete, public
//
//  Synopsis:   Removes a  DFS_VOLUME from DFS_VOLUME_LIST
//
//  Arguments:  [pDfsVolList] -- Pointer to DFS_VOLUME_LIST work on.
//              [iVol] -- Index of volume to delete
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
DfsVolDelete(
    PDFS_VOLUME_LIST pDfsVolList,
    ULONG iVol)
{
    ULONG i;
    DWORD dwErr = ERROR_SUCCESS;

    ASSERT(iVol < pDfsVolList->VolCount);

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsVolDelete(%d)\n", iVol);
#endif

    //
    // Free any memory this Volume is using
    //

    DfsFreeVol(&pDfsVolList->Volumes[iVol]);

    //
    // Since we're shrinking the list, we simply clip out the entry we don't want
    // and adjust the count.
    //
    for (i = iVol+1; i < pDfsVolList->VolCount; i++)
        pDfsVolList->Volumes[i-1] = pDfsVolList->Volumes[i];

    pDfsVolList->VolCount--;
    RtlZeroMemory(&pDfsVolList->Volumes[pDfsVolList->VolCount], sizeof(DFS_VOLUME));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsVolDelete returning %d\n", dwErr);
#endif
    return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsReplDeleteByIndex, public
//
//  Synopsis:   Removes a  PDFS_REPLICA_INFO from a DFS_VOLUME's replica list
//
//  Arguments:  [pDfsVol] -- Pointer to DFS_VOLUME work on.
//              [iRepl] -- Index of replica to delete
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
DfsReplDeleteByIndex(
    PDFS_VOLUME pVol,
    ULONG iRepl)
{
    ULONG i;
    DWORD dwErr = ERROR_SUCCESS;

    ASSERT(iRepl < pVol->ReplCount);

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsReplDeleteByIndex(%d)\n", iRepl);
#endif

    //
    // Free any memory this replica is using
    //

    DfsFreeRepl(&pVol->ReplicaInfo[iRepl]);

    //
    // Since we're shrinking the list(s), we simply clip out the entry we don't want
    // and adjust the count.
    //
    for (i = iRepl+1; i < pVol->ReplCount; i++) {
        pVol->ReplicaInfo[i-1] = pVol->ReplicaInfo[i];
        pVol->FtModification[i-1] = pVol->FtModification[i];
    }

    pVol->ReplCount--;
    RtlZeroMemory(&pVol->ReplicaInfo[pVol->ReplCount], sizeof(DFS_REPLICA_INFO));


#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsReplDeleteByIndex returning %d\n", dwErr);
#endif
    return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsReplDeleteByName, public
//
//  Synopsis:   Removes a  PDFS_REPLICA_INFO from a DFS_VOLUME's replica list. Simply
//              looks up the replica by name and then calls DfsReplDeleteByIndex()
//
//  Arguments:  [pDfsVol] -- Pointer to DFS_VOLUME work on.
//              [pwszServername] - Server Name
//              [pwszShareName] - Share Name
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
DfsReplDeleteByName(
    PDFS_VOLUME pVol,
    LPWSTR pwszServerName,
    LPWSTR pwszShareName)
{
    ULONG iRep;
    DWORD dwErr = ERROR_SUCCESS;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsReplDeleteByName(%ws,%ws)\n", pwszServerName, pwszShareName);
#endif

    if (pwszServerName == NULL || pwszShareName == NULL) {
        dwErr =  ERROR_INVALID_PARAMETER;
        goto AllDone;
    }

ReStart:

    //
    // Scan the volume's replica list, and if there is a match on the
    // passed-in servername and sharename, remove the replica.
    //
    for (iRep = 0; iRep < pVol->ReplCount; iRep++) {
        if (_wcsicmp(pVol->ReplicaInfo[iRep].pwszServerName, pwszServerName) == 0
                &&
            _wcsicmp(pVol->ReplicaInfo[iRep].pwszShareName, pwszShareName) == 0
        ) {
            dwErr = DfsReplDeleteByIndex(pVol, iRep);
            goto ReStart;
        }
    }

AllDone:

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsReplDeleteByName returning %d\n", dwErr);
#endif
    return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsDelReplDelete, public
//
//  Synopsis:   Removes a  PDFS_REPLICA_INFO from a DFS_VOLUME's deleted replica list
//
//  Arguments:  [pDfsVol] -- Pointer to DFS_VOLUME work on.
//              [iDelRepl] -- Index of Deleted replica to delete
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
DfsDelReplDelete(
    PDFS_VOLUME pVol,
    ULONG iDelRepl)
{
    ULONG i;
    DWORD dwErr = ERROR_SUCCESS;

    ASSERT(iDelRepl < pVol->DelReplCount);

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsDelReplDelete(%d)\n", iDelRepl);
#endif

    //
    // Free any memory this replica is using
    //

    DfsFreeRepl(&pVol->DelReplicaInfo[iDelRepl]);

    //
    // Since we're shrinking the list(s), we simply clip out the entry we don't want
    // and adjust the count.
    //
    for (i = iDelRepl+1; i < pVol->DelReplCount; i++) {
        pVol->DelReplicaInfo[i-1] = pVol->DelReplicaInfo[i];
        pVol->DelFtModification[i-1] = pVol->DelFtModification[i];
    }

    pVol->DelReplCount--;
    RtlZeroMemory(&pVol->DelReplicaInfo[pVol->DelReplCount], sizeof(DFS_REPLICA_INFO));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsDelReplDelete returning %d\n", dwErr);
#endif
    return dwErr;
}

#if DBG

void
DumpBuf(PCHAR cp, ULONG len)
{
    ULONG i, j, c;

    for (i = 0; i < len; i += 16) {
        DbgPrint("%08x  ", i /* +(ULONG)cp */);
        for (j = 0; j < 16; j++) {
            if (j == 8)
                DbgPrint(" ");
            if (i+j < len) {
                c = cp[i+j] & 0xff;
                DbgPrint("%02x ", c);
            } else {
                DbgPrint("   ");
            }
        }
        DbgPrint("  ");
        for (j = 0; j < 16; j++) {
            if (j == 8)
                DbgPrint("|");
            if (i+j < len) {
                c = cp[i+j] & 0xff;
                if (c < ' ' || c > '~')
                    c = '.';
                DbgPrint("%c", c);
            } else {
                DbgPrint(" ");
            }
        }
        DbgPrint("\n");
    }
}

//+------------------------------------------------------------------------
//
// Function:    DfsDumpVolList
//
// Synopsis:    Prints the volume information represented by the volume
//              list passed in.
//
// Returns:     [ERROR_SUCCESS] -- If all went well.
//
// History:     11/19/98 JHarper Created
//
//-------------------------------------------------------------------------

VOID
DfsDumpVolList(
    PDFS_VOLUME_LIST pDfsVolList)
{
    ULONG cVol;
    ULONG cRepl;
    ULONG cSite;
    ULONG i;
    GUID guid;
    PLIST_ENTRY pListHead;
    PLIST_ENTRY pLink;
    PDFSM_SITE_ENTRY pSiteEntry;

    DbgPrint("****************************************\n");

    for (cVol = 0; cVol < pDfsVolList->VolCount; cVol++) {

        DbgPrint("Name=%ws\n", pDfsVolList->Volumes[cVol].wszObjectName);
        DbgPrint("Prefix: %ws\n", pDfsVolList->Volumes[cVol].wszPrefix);
        DbgPrint("Comment: %ws\n", pDfsVolList->Volumes[cVol].wszComment);
        DbgPrint("cbRecovery: %d\n", pDfsVolList->Volumes[cVol].cbRecovery);

        DbgPrint("ReplCount=%d\n", pDfsVolList->Volumes[cVol].ReplCount);
        DbgPrint("AllocatedReplCount=%d\n", pDfsVolList->Volumes[cVol].AllocatedReplCount);

        for (cRepl = 0; cRepl < pDfsVolList->Volumes[cVol].ReplCount; cRepl++) {

            DbgPrint("[%d]ServerName=%ws\n",
                    cRepl, pDfsVolList->Volumes[cVol].ReplicaInfo[cRepl].pwszServerName);
            DbgPrint("[%d]ShareName=%ws\n",
                    cRepl, pDfsVolList->Volumes[cVol].ReplicaInfo[cRepl].pwszShareName);

        }

        DbgPrint("DelReplCount=%d\n", pDfsVolList->Volumes[cVol].DelReplCount);
        DbgPrint("AllocatedDelReplCount=%d\n", pDfsVolList->Volumes[cVol].AllocatedDelReplCount);

        for (cRepl = 0; cRepl < pDfsVolList->Volumes[cVol].DelReplCount; cRepl++) {

            DbgPrint("[%d]ServerName=%ws\n",
                    cRepl, pDfsVolList->Volumes[cVol].DelReplicaInfo[cRepl].pwszServerName);
            DbgPrint("[%d]ShareName=%ws\n",
                    cRepl, pDfsVolList->Volumes[cVol].DelReplicaInfo[cRepl].pwszShareName);

        }

        DbgPrint("\n");

    }

    DbgPrint("---------SiteTable-------\n");

    guid = pDfsVolList->SiteGuid;
    DbgPrint("SiteTableGuid:"
        "%08lX-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X\n",
        guid.Data1, guid.Data2, guid.Data3, (int) guid.Data4[0],
        (int) guid.Data4[1], (int) guid.Data4[2], (int) guid.Data4[3],
        (int) guid.Data4[4], (int) guid.Data4[5],
        (int) guid.Data4[6], (int) guid.Data4[7]);


    pListHead = &pDfsVolList->SiteList;

    if (pListHead->Flink == pListHead)
        return;

    for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {

        pSiteEntry = CONTAINING_RECORD(pLink, DFSM_SITE_ENTRY, Link);

        DbgPrint("[%ws-%d sites]\n",
                pSiteEntry->ServerName,
                pSiteEntry->Info.cSites);

        for (i = 0; i < pSiteEntry->Info.cSites; i++) {
            DbgPrint("\t%ws\n", pSiteEntry->Info.Site[i].SiteName);
        }

    }

    DbgPrint("****************************************\n");

}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\dfsmsrv.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1995, Microsoft Corporation
//
//  File:       dfsmsrv.cxx
//
//  Contents:   The server side stubs for the Dfs Manager Admin RPC interface
//
//  Classes:
//
//  Functions:  GetDfsVolumeFromPath --
//              AddReplica --
//              RemoveReplica --
//              Delete --
//              SetComment --
//              GetInfo --
//              Move --
//              Rename --
//              CreateChild --
//              GetReplicaSetID --
//              SetReplicaSetID --
//              ChangeStorageID --
//              SetReplicaState --
//              SetVolumeState --
//
//  History:    12-27-95        Milans Created.
//
//-----------------------------------------------------------------------------

//#include <ntos.h>
//#include <ntrtl.h>
//#include <nturtl.h>
//#include <dfsfsctl.h>
//#include <windows.h>


#include <headers.hxx>
#pragma hdrstop

extern "C" {
#include "dfspriv.h"                             // For I_NetDfsXXX calls
#include <dfsmsrv.h>
#include <srvfsctl.h>
#include <icanon.h>
#include <validc.h>
#include <winldap.h>
#include <dsrole.h>
}

extern "C" {

DWORD
DfsGetFtServersFromDs(
    IN PVOID  pLDAP OPTIONAL,
    IN LPWSTR wszDomainName OPTIONAL,
    IN LPWSTR wszDfsName,
    OUT LPWSTR **List
    );
}

NET_API_STATUS
NetrDfsEnum200(
    IN DWORD Level,
    IN DWORD PrefMaxLen,
    IN OUT LPDFS_INFO_ENUM_STRUCT DfsEnum,
    IN OUT LPDWORD ResumeHandle
    );

#include "cdfsvol.hxx"
#include "jnpt.hxx"
#include "security.hxx"
#include "registry.hxx"
#include "setup.hxx"
#include "ftsup.hxx"
#include "dfsmwml.h"

NET_API_STATUS
DfspGetOneEnumInfo(
    DWORD i,
    DWORD Level,
    LPBYTE InfoArray,
    LPDWORD InfoSize,
    LPDWORD ResumeHandle);

DWORD
DfspGetOneEnumInfoEx(
    PDFS_VOLUME_LIST pDfsVolList,
    DWORD i,
    DWORD Level,
    LPBYTE InfoArray,
    LPDWORD InfoSize);

VOID
DfspFreeOneEnumInfo(
    DWORD i,
    DWORD Level,
    LPBYTE InfoArray);

DWORD
DfspAllocateRelationInfo(
    PDFS_PKT_RELATION_INFO pDfsRelationInfo,
    LPDFSM_RELATION_INFO *ppRelationInfo);

DWORD
DfsManagerRemoveServiceForced(
    LPWSTR wszServerName,
    LPWSTR wszDCName,
    LPWSTR wszFtDfsName);

DWORD
InitializeDfsManager(void);

VOID
GetDebugSwitches();

VOID
GetConfigSwitches();

extern HANDLE hSyncEvent;
extern ULONG DcLockIntervalInMs;
extern PLDAP pLdapConnection;

//+----------------------------------------------------------------------------
//
//  Function:   NormalizeEntryPath
//
//  Synopsis:   Normalizes an EntryPath argument to a prefix.
//
//  Arguments:  [pwszEntryPath] -- The entry path to normalize.
//
//  Returns:    If pwszEntryPath is a UNC path, this routine returns
//              &pwszEntryPath[1]; if pwszEntryPath starts with a backslash,
//              this routine returns pwszEntryPath. In all other cases, this
//              routine returns NULL.
//
//-----------------------------------------------------------------------------

LPWSTR
NormalizeEntryPath(
    IN LPWSTR pwszEntryPath)
{
    LPWSTR pwszEntryPathCanon;
    DWORD Type = 0;
    DWORD dwErr;
    ULONG Size = wcslen(pwszEntryPath) + 1;
    WCHAR *wCp;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NormalizeEntryPath(%ws)\n", pwszEntryPath);
#endif

    if (pwszEntryPath == NULL)
        return( NULL );

    if (wcslen(pwszEntryPath) < 2)
        return( NULL );

    if (pwszEntryPath[0] != UNICODE_PATH_SEP)
        return( NULL );

    pwszEntryPathCanon = new WCHAR [ Size ];

    if (pwszEntryPathCanon == NULL)
        return( NULL );

    dwErr = I_NetPathCanonicalize(
                NULL,
                pwszEntryPath,
                pwszEntryPathCanon,
                Size * sizeof(WCHAR),
                NULL,
                &Type,
                0);
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NormalizeEntryPath:pwszEntryPathCanon:%ws)\n", pwszEntryPathCanon);
#endif

    if (dwErr != 0 || (Type != ITYPE_UNC && Type != (ITYPE_PATH | ITYPE_ABSOLUTE))) {

        delete [] pwszEntryPathCanon;
        return( NULL );

    }

    if (ulDfsManagerType == DFS_MANAGER_SERVER) {

        if (pwszDfsRootName == NULL)
            return NULL;

        wcscpy(pwszEntryPath, UNICODE_PATH_SEP_STR);
        wcscat(pwszEntryPath, pwszDfsRootName);

        if (pwszEntryPathCanon[1] == UNICODE_PATH_SEP) {
            wCp = wcschr(&pwszEntryPathCanon[2], UNICODE_PATH_SEP);
        } else {
            wCp = wcschr(&pwszEntryPathCanon[1], UNICODE_PATH_SEP);
        }

	if(wCp == NULL) {
	    return NULL;
	}   

        wcscat(pwszEntryPath, wCp);

    } else {

        if (pwszEntryPathCanon[1] == UNICODE_PATH_SEP) {
            wcscpy(pwszEntryPath, &pwszEntryPathCanon[1]);
        } else {
            wcscpy(pwszEntryPath, pwszEntryPathCanon);
        }

    }

    delete [] pwszEntryPathCanon;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NormalizeEntryPath returning %ws\n", pwszEntryPath);
#endif

    return( pwszEntryPath );

}

//+----------------------------------------------------------------------------
//
//  Function:   FormFTDfsEntryPath
//
//  Synopsis:   When the NetDfsXXX APIs are used to administer an FTDfs, the
//              entry path passed in is of the form \servername\sharename\p
//              These first two components must be massaged to the form
//              \domainname\ftdfsname\p
//
//  Arguments:  [pwszEntryPath] -- The entry path to massage
//
//  Returns:    If successfully massaged the entry path, returns a pointer to
//              the newly allocated FTDfs entry path, else NULL
//
//-----------------------------------------------------------------------------

LPWSTR
FormFTDfsEntryPath(
    IN LPWSTR pwszEntryPath)
{
    LPWSTR pwszFTDfsPath;
    LPWSTR pwszRestOfPath;

    if (pwszDomainName == NULL || pwszDfsRootName == NULL)
        return NULL;

    if (pwszEntryPath[0] == UNICODE_PATH_SEP &&
        pwszEntryPath[1] == UNICODE_PATH_SEP) {
            pwszEntryPath++;
    }

    pwszFTDfsPath = new WCHAR [
                            wcslen(pwszEntryPath) +
                            wcslen(UNICODE_PATH_SEP_STR) +
                            wcslen(pwszDomainName) +
                            wcslen(UNICODE_PATH_SEP_STR) +
                            wcslen(pwszDfsRootName) ];

    if (pwszFTDfsPath != NULL) {

        wcscpy(pwszFTDfsPath, UNICODE_PATH_SEP_STR);
        wcscat(pwszFTDfsPath, pwszDomainName);
        wcscat(pwszFTDfsPath, UNICODE_PATH_SEP_STR);
        wcscat(pwszFTDfsPath, pwszDfsRootName);

        //
        // Skip past the first three backslashes of the input parameter
        //

        if (pwszEntryPath[0] != UNICODE_PATH_SEP)
            return NULL;

        pwszRestOfPath = wcschr( &pwszEntryPath[1], UNICODE_PATH_SEP );

        if (pwszRestOfPath == NULL)
            return NULL;

        pwszRestOfPath = wcschr( &pwszRestOfPath[1], UNICODE_PATH_SEP );

        if (pwszRestOfPath != NULL)
            wcscat(pwszFTDfsPath, pwszRestOfPath );

    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("FormFTDfsEntryPath(%ws->%ws)\n", pwszEntryPath, pwszFTDfsPath);
#endif

    return( pwszFTDfsPath );

}

//+----------------------------------------------------------------------------
//
//  Function:   FormStdDfsEntryPath
//
//  Synopsis:   When the NetDfsXXX APIs are used to administer an StdDfs, the
//              entry path passed in may be of the form \somename\dfsname.
//              The first component must be normalized if possible
//              to the computer name.
//
//  Arguments:  [pwszEntryPath] -- The entry path to normalize
//
//  Returns:    If successfully normalized the entry path, returns a pointer to
//              the newly allocated entry path, else NULL
//
//-----------------------------------------------------------------------------

LPWSTR
FormStdDfsEntryPath(
    IN LPWSTR pwszEntryPath)
{
    LPWSTR pwszStdDfsPath;
    LPWSTR pwszRestOfPath;

    if (pwszComputerName == NULL || pwszDfsRootName == NULL)
        return NULL;

    if (pwszEntryPath[0] == UNICODE_PATH_SEP &&
        pwszEntryPath[1] == UNICODE_PATH_SEP) {
            pwszEntryPath++;
    }

    pwszStdDfsPath = new WCHAR [
                            wcslen(pwszEntryPath) +
                            wcslen(UNICODE_PATH_SEP_STR) +
                            wcslen(pwszComputerName) ];

    if (pwszStdDfsPath != NULL) {

        wcscpy(pwszStdDfsPath, UNICODE_PATH_SEP_STR);
        wcscat(pwszStdDfsPath, pwszComputerName);

        //
        // Skip past the first two backslashes of the input parameter
        //

        ASSERT(pwszEntryPath[0] == UNICODE_PATH_SEP);

        pwszRestOfPath = wcschr( &pwszEntryPath[1], UNICODE_PATH_SEP );

        if (pwszRestOfPath != NULL)
            wcscat(pwszStdDfsPath, pwszRestOfPath );

    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("FormStdDfsEntryPath(%ws->%ws)\n", pwszEntryPath, pwszStdDfsPath);
#endif

    return( pwszStdDfsPath );

}


//+----------------------------------------------------------------------------
//
//  Function:   GetDfsVolumeFromPath
//
//  Synopsis:   Given a volume EntryPath, returns a CDfsVolume for that
//              volume.
//
//  Arguments:  [pwszEntryPath] -- EntryPath for which CDfsVolume is
//                      desired.
//              [fExactMatch] -- If TRUE, this call will succeed only if
//                      a volume object's EntryPath exactly matches
//                      pwszEntryPath.
//              [ppCDfsVolume] -- On successful return, contains pointer to
//                      newly allocated CDfsVolume for the EntryPath.
//
//  Returns:    [S_OK] -- Successfully returning new CDfsVolume.
//
//              [E_OUTOFMEMORY] -- Out of memory creating new object.
//
//              [DFS_E_NO_SUCH_VOLUME] -- Unable to find volume with
//                      given EntryPath.
//
//-----------------------------------------------------------------------------

DWORD
GetDfsVolumeFromPath(
    LPWSTR pwszEntryPath,
    BOOLEAN fExactMatch,
    CDfsVolume **ppCDfsVolume)
{
    DWORD dwErr;
    CDfsVolume *pCDfsVolume = NULL;
    LPWSTR  pwszVolumeObject = NULL;

    dwErr = GetVolObjForPath( pwszEntryPath, fExactMatch, &pwszVolumeObject );

    if (dwErr == ERROR_SUCCESS) {

        pCDfsVolume = new CDfsVolume();

        if (pCDfsVolume != NULL) {

            dwErr = pCDfsVolume->Load( pwszVolumeObject, 0 );

            if (dwErr != ERROR_SUCCESS) {

                pCDfsVolume->Release();

                pCDfsVolume = NULL;

            }

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

        delete [] pwszVolumeObject;

    }

    *ppCDfsVolume = pCDfsVolume;

    return( dwErr );

}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsManagerGetVersion
//
//  Synopsis:   Returns the version of this server side implementation.
//
//  Arguments:  None.
//
//  Returns:    The version number.
//
//-----------------------------------------------------------------------------

DWORD
NetrDfsManagerGetVersion()
{
    DWORD Version = 2;
    DFSM_TRACE_NORM(EVENT, NetrDfsManagerGetVersion_Start, LOGNOTHING);
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsGetVersion()\n");
#endif

    DFSM_TRACE_NORM(EVENT, NetrDfsManagerGetVersion_End, LOGULONG(Version));
    return( Version );
}

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsAdd (Obsolete)
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsAdd(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName,
    IN LPWSTR Comment,
    IN DWORD Flags)
{
    NET_API_STATUS status = ERROR_SUCCESS;

    DFSM_TRACE_NORM(EVENT, NetrDfsAdd_Start, 
                    LOGSTATUS(status)
                    LOGWSTR(DfsEntryPath)
                    LOGWSTR(ServerName)
                    LOGWSTR(ShareName));

    if (!AccessCheckRpcClient()) {
        status =  ERROR_ACCESS_DENIED;
    }
    else if (ulDfsManagerType == DFS_MANAGER_FTDFS){
        status = ERROR_NOT_SUPPORTED;
    }
    else {
        status =  NetrDfsAdd2(
            DfsEntryPath,
            NULL,
            ServerName,
            ShareName,
            Comment,
            Flags,
            NULL);
    }
    DFSM_TRACE_NORM(EVENT, NetrDfsAdd_End, 
                LOGSTATUS(status)
                LOGWSTR(DfsEntryPath)
                LOGWSTR(ServerName)
                LOGWSTR(ShareName));

    return status;

}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsAdd2
//
//  Synopsis:   Adds a volume/replica/link to this Dfs.
//
//  Arguments:  [DfsEntryPath] -- Entry Path of volume/link to be created, or
//                      to which a replica should be added.
//              [DcName] -- Name of Dc to use
//              [ServerName] -- Name of server backing the volume.
//              [ShareName] -- Name of share on ServerName backing the volume.
//              [Comment] -- Comment associated with this volume, only used
//                      when DFS_ADD_VOLUME is specified.
//              [Flags] -- If DFS_ADD_VOLUME, a new volume will be created.
//                      If DFS_ADD_LINK, a new link to another Dfs will be
//                      create. If 0, a replica will be added.
//              [ppRootList] -- On success, returns a list of roots that need to be
//                              informed of the change in the DS object
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//              [NERR_DfsNoSuchVolume] -- DfsEntryPath does not correspond to a
//                      existing Dfs volume.
//
//              [NERR_DfsVolumeAlreadyExists] -- DFS_ADD_VOLUME was specified
//                      and a volume with DfsEntryPath already exists.
//
//              [NERR_DfsInternalCorruption] -- An internal database
//                      corruption was encountered while executing this
//                      operation.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory condition.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsAdd2(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR DcName,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName,
    IN LPWSTR Comment,
    IN DWORD Flags,
    IN PDFSM_ROOT_LIST *ppRootList)
{
    NET_API_STATUS status = NERR_Success;
    CDfsVolume *pDfsVol = NULL;
    DFS_REPLICA_INFO replInfo;
    DWORD dwVersion;
    DWORD dwVolType;
    DWORD shareType = 0;
    DWORD dwErr;
    LPWSTR realShareName;
    BOOLEAN modifiedShareName = FALSE;
    LPDFS_SITELIST_INFO pSiteInfo;
    LPWSTR OrgDfsEntryPath = DfsEntryPath;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsAdd2(%ws,%ws,%ws,%ws,%ws,%d,0x%x)\n",
                DfsEntryPath,
                DcName,
                ServerName,
                ShareName,
                Comment,
                Flags,
                ppRootList);
#endif

    DFSM_TRACE_NORM(EVENT, NetrDfsAdd2_Start,
                     LOGSTATUS(status)
                     LOGWSTR(OrgDfsEntryPath)
                     LOGWSTR(DcName)
                     LOGWSTR(ServerName)
                     LOGWSTR(ShareName));

    if (!AccessCheckRpcClient()) {
        status = ERROR_ACCESS_DENIED;
        goto cleanup;
    }

    //
    // Validate the input arguments...
    //

    if ( (Flags & ~(DFS_ADD_VOLUME | DFS_RESTORE_VOLUME)) != 0) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (DfsEntryPath == NULL || DfsEntryPath[0] != UNICODE_PATH_SEP){
        status =  ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

#if 0 // Broken for DNS names
    DfsEntryPath = NormalizeEntryPath( DfsEntryPath );
#endif

#if DBG
    if (DfsSvcVerbose) {
        DbgPrint(" 0:DfsEntryPath=[%ws]\n", DfsEntryPath);
        DbgPrint(" 0:ServerName=[%ws]\n", ServerName);
        DbgPrint(" 0:ShareName=[%ws]\n", ShareName);
    }
#endif

    if (DfsEntryPath != NULL) {
    
        if (ulDfsManagerType == DFS_MANAGER_FTDFS)
            DfsEntryPath = FormFTDfsEntryPath(DfsEntryPath);
        else if (ulDfsManagerType == DFS_MANAGER_SERVER)
            DfsEntryPath = FormStdDfsEntryPath(DfsEntryPath);

        if (DfsEntryPath == NULL) {
            status = ERROR_OUTOFMEMORY;
            goto cleanup;
        }

    }

#if DBG
    if (DfsSvcVerbose) {
        DbgPrint(" 1:ServerName=[%ws]\n", ServerName);
        DbgPrint(" 1:ShareName=[%ws]\n", ShareName);
    }
#endif

    if (DfsEntryPath == NULL ||
            ServerName == NULL ||
                ShareName == NULL) {

        if (DfsEntryPath != NULL && DfsEntryPath != OrgDfsEntryPath) {
            delete [] DfsEntryPath;
        }

        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (ServerName[0] == UNICODE_NULL ||
            ShareName[0] == UNICODE_NULL) {

        if (DfsEntryPath != OrgDfsEntryPath) {
            delete [] DfsEntryPath;
        }

        status =  ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    ENTER_DFSM_OPERATION;

    if (ulDfsManagerType == DFS_MANAGER_FTDFS) {
        if (DcName != NULL)
            DfsManagerSetDcName(DcName);
        LdapIncrementBlob();
    }

    //
    // We next determine whether this is going to be an interdomain link or
    // not. While doing so, we'll also check for certain cases of cyclical
    // references.
    //

    if (I_NetDfsIsThisADomainName(ServerName) == ERROR_SUCCESS) {

        if (ulDfsManagerType == DFS_MANAGER_FTDFS &&
                pwszDfsRootName != NULL &&
                (_wcsicmp( ServerName, pwszDfsRootName) == 0)){
            status = NERR_DfsCyclicalName;
            DFSM_TRACE_HIGH(ERROR, NetrDfsAdd2_Error1, 
                            LOGSTATUS(status)
                            LOGWSTR(ServerName)
                            LOGWSTR(ShareName));
        }
        else
            dwVolType = DFS_VOL_TYPE_REFERRAL_SVC | DFS_VOL_TYPE_INTER_DFS;

    } else if (Flags & DFS_RESTORE_VOLUME) {

        dwVolType = DFS_VOL_TYPE_DFS;

        shareType = 0;

    } else {

        //
        // Server name passed in is a real server. See if what kind of share
        // we are talking about.
        //

        PSHARE_INFO_1005 shi1005;

        realShareName = wcschr(ShareName, UNICODE_PATH_SEP);

        if (realShareName != NULL) {
            *realShareName = UNICODE_NULL;
            modifiedShareName = TRUE;
        }

        status = NetShareGetInfo(
                        ServerName,
                        ShareName,
                        1005,
                        (PBYTE *) &shi1005);

        DFSM_TRACE_ERROR_HIGH(status, ALL_ERROR, NetrDfsAdd2_Error_NetShareGetInfo,
                              LOGSTATUS(status)
                              LOGWSTR(ServerName)
                              LOGWSTR(ShareName));

        if (modifiedShareName)
            *realShareName = UNICODE_PATH_SEP;

        if (status == NERR_Success) {

            shareType = shi1005->shi1005_flags;

            NetApiBufferFree( shi1005 );
        }

        if (status != NERR_NetNameNotFound)
            status = NERR_Success;

        if (status == NERR_Success) {

            if (shareType & SHI1005_FLAGS_DFS_ROOT) {

                //
                // If this is a server based Dfs, make sure we are not creating
                // a cyclical link to our root share. Since there is only one
                // share per server that can be a Dfs Root, it is sufficient to
                // see if the machine names match.
                //

                if (ulDfsManagerType == DFS_MANAGER_SERVER &&
                        pwszDfsRootName != NULL &&
                        (_wcsicmp( ServerName, pwszDfsRootName) == 0)) {
                    status = NERR_DfsCyclicalName;
                    DFSM_TRACE_HIGH(ERROR, NetrDfsAdd2_Error2, 
                                    LOGSTATUS(status)
                                    LOGWSTR(ServerName)
                                    LOGWSTR(ShareName));
                }
                else
                    dwVolType = DFS_VOL_TYPE_REFERRAL_SVC |
                                    DFS_VOL_TYPE_INTER_DFS;

            } else {

                dwVolType = DFS_VOL_TYPE_DFS;

            }

        }

    }

    //
    // Great, the parameters look semi-reasonable, lets do the work.
    //

    if (status == NERR_Success) {

        if ((Flags & DFS_ADD_VOLUME) == 0) {

            status = GetDfsVolumeFromPath( DfsEntryPath, TRUE, &pDfsVol );

        } else {

            //
            // Add volume or link case, so we don't want an exact match.
            // Note that if the Dfs Volume returned does indeed match exactly,
            // its ok, because the subsequent CreateChild operation will fail.
            //

            status = GetDfsVolumeFromPath( DfsEntryPath, FALSE, &pDfsVol );

        }

    }

    if (status != ERROR_SUCCESS) {

        pDfsVol = NULL;

    }

    if (status == ERROR_SUCCESS) {

        //
        // Create a DFS_REPLICA_INFO struct for this server-share...
        //

        ZeroMemory( &replInfo, sizeof(replInfo) );

#if DBG
        if (DfsSvcVerbose) {
            DbgPrint(" 2:ServerName=[%ws]\n", ServerName);
            DbgPrint(" 2:ShareName=[%ws]\n", ShareName);
        }
#endif

        replInfo.ulReplicaType = DFS_STORAGE_TYPE_NONDFS;
        replInfo.ulReplicaState = DFS_STORAGE_STATE_ONLINE;
        replInfo.pwszServerName = ServerName;
        replInfo.pwszShareName = ShareName;

        //
        // and carry out the Add operation.
        //

        if ((Flags & DFS_ADD_VOLUME) != 0) {

            status = pDfsVol->CreateChild(
                    DfsEntryPath,
                    dwVolType,
                    &replInfo,
                    Comment,
                    DFS_NORMAL_FORCE);

        } else {

            status = pDfsVol->AddReplica( &replInfo, 0 );

        }

        if (status == NERR_Success) {

            //
            // Find out the list of covered sites
            // Note we use dwErr as the return code,
            // because we don't care if this fails - a downlevel
            // server won't respond.
            //

            pSiteInfo = NULL;

            dwErr = I_NetDfsManagerReportSiteInfo(
                        ServerName,
                        &pSiteInfo);

            DFSM_TRACE_ERROR_HIGH(dwErr, ALL_ERROR, NetrDfsAdd2_Error_I_NetDfsManagerReportSiteInfo,
                                  LOGSTATUS(dwErr)
                                  LOGWSTR(ServerName)
                                  LOGWSTR(ShareName));
            //
            // Create a SiteTable object with those sites
            //

            if (dwErr == ERROR_SUCCESS) {

                if (pSiteInfo->cSites > 0) {

                    //
                    // AddRef the site table, then put the site info in, then
                    // Release it.  This will cause it to be written to the
                    // appropriate store (ldap or registry).
                    //

                    pDfsmSites->AddRef();

                    pDfsmSites->AddOrUpdateSiteInfo(
                                    ServerName,
                                    pSiteInfo->cSites,
                                    &pSiteInfo->Site[0]);
                    pDfsmSites->Release();
                }

                NetApiBufferFree(pSiteInfo);

            }

        }

    }

    //
    // This writes the dfs-link info back
    // to
    // (1) the registry if stddfs
    //     or
    // (2) the in-memory unmarshalled pkt blob which
    // will still need to go to the DS.
    //

    if (pDfsVol != NULL) {
        pDfsVol->Release();
    }

    if (ulDfsManagerType == DFS_MANAGER_FTDFS) {
        // if we can't write to the DS we get an error
        // but don't mask any previous errors...
        NET_API_STATUS NewStatus;
        NewStatus = LdapDecrementBlob();
        if(status == NERR_Success){
            status = NewStatus;
        }
    }

    EXIT_DFSM_OPERATION;

    //
    // Create list of roots to redirect to this DC
    //

    if (status == NERR_Success &&
        DcName != NULL &&
        ulDfsManagerType == DFS_MANAGER_FTDFS
    ) {
        DfspCreateRootList(
                DfsEntryPath,
                DcName,
                ppRootList);
    }

    if (DfsEntryPath != OrgDfsEntryPath) {
        delete [] DfsEntryPath;
    }
cleanup:
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsAdd2 returning %d\n", status);
#endif
    DFSM_TRACE_NORM(EVENT, NetrDfsAdd2_End,
                      LOGSTATUS(status)
                      LOGWSTR(OrgDfsEntryPath)
                      LOGWSTR(DcName)
                      LOGWSTR(ServerName)
                      LOGWSTR(ShareName));
    
    return( status );
}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsAddFtRoot
//
//  Synopsis:   Creates a new FtDfs, or joins a Server into an FtDfs at the root
//
//  Arguments:  [ServerName] -- Name of server backing the volume.
//              [DcName] -- DC to use
//              [RootShare] -- Name of share on ServerName backing the volume.
//              [FtDfsName] -- The Name of the FtDfs to create/join
//              [Comment] -- Comment associated with this root.
//              [Flags] -- Flags for the operation
//              [ppRootList] -- On success, returns a list of roots that need to be
//                              informed of the change in the DS object
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//              [NERR_DfsInternalCorruption] -- An internal database
//                      corruption was encountered while executing this
//                      operation.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory condition.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsAddFtRoot(
    IN LPWSTR ServerName,
    IN LPWSTR DcName,
    IN LPWSTR RootShare,
    IN LPWSTR FtDfsName,
    IN LPWSTR Comment,
    IN LPWSTR ConfigDN,
    IN BOOLEAN NewFtDfs,
    IN DWORD  Flags,
    IN PDFSM_ROOT_LIST *ppRootList)
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG i;
    WCHAR wszFullObjectName[MAX_PATH];
    WCHAR wszComputerName[MAX_PATH];
    WCHAR wszDomainName[MAX_PATH];
    HKEY hkey;
    DFS_NAME_CONVENTION NameType;
    PDFSM_ROOT_LIST pRootList = NULL;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsAddFtRoot(%ws,%ws,%ws,%ws,%ws,%ws,0x%x,0x%x)\n",
                ServerName,
                DcName,
                RootShare,
                FtDfsName,
                Comment,
                ConfigDN,
                NewFtDfs,
                Flags);
#endif

    DFSM_TRACE_NORM(EVENT, NetrDfsAddFtRoot_Start,
                    LOGSTATUS(dwErr)
                    LOGWSTR(ServerName)
                    LOGWSTR(DcName)
                    LOGWSTR(RootShare)
                    LOGWSTR(FtDfsName)
                    LOGWSTR(ConfigDN));

    if (!AccessCheckRpcClient()) {

        dwErr =  ERROR_ACCESS_DENIED;
        goto cleanup;
    }

    //
    // Validate the input arguments...
    //

    if (
        ServerName == NULL ||
        DcName == NULL ||
        RootShare == NULL ||
        FtDfsName == NULL ||
        Comment == NULL ||
        ConfigDN == NULL
    ) {

        dwErr =  ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (
        ServerName[0] == UNICODE_NULL ||
        DcName[0] == UNICODE_NULL ||
        RootShare[0] == UNICODE_NULL ||
        FtDfsName[0] == UNICODE_NULL ||
        ConfigDN[0] == UNICODE_NULL
    ) {

        dwErr =  ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Get our computer and domain names
    //
    NameType = DFS_NAMETYPE_DNS;
    dwErr = GetDomAndComputerName( wszDomainName, wszComputerName, &NameType);

    if (dwErr != ERROR_SUCCESS){
        goto cleanup;
        //return dwErr;

    }

    //
    // Ensure the syntax of FtDfsName is reasonable
    //

    if( wcslen( FtDfsName ) > NNLEN ||
        wcscspn( FtDfsName, ILLEGAL_NAME_CHARS_STR ) != wcslen( FtDfsName ) ) {

        dwErr =  ERROR_INVALID_NAME;
        goto cleanup;
    }

    ENTER_DFSM_OPERATION;

    //
    // Already a root?
    //

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, VOLUMES_DIR, &hkey );

    if (dwErr != ERROR_SUCCESS) {

        DfsManagerSetDcName(DcName);
        LdapIncrementBlob();

        //
        // Update pKT (blob) attribute
        //

        dwErr = SetupFtDfs(
                    wszComputerName,
                    wszDomainName,
                    RootShare,
                    FtDfsName,
                    Comment,
                    ConfigDN,
                    NewFtDfs,
                    Flags);

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("SetupFtDfs() returned %d\n", dwErr);
#endif


        if (dwErr == ERROR_SUCCESS) {

            //
            // Reset dfs
            //
            DfsmStopDfs();
            DfsmResetPkt();
            DfsmInitLocalPartitions();
            InitializeDfsManager();
            DfsmStartDfs();
            DfsmPktFlushCache();

        } else {

            //
            // Something went wrong - remove all the stuff we set up
            //

            if (*ppRootList != NULL) {
                pRootList = *ppRootList;
                for (i = 0; i< pRootList->cEntries; i++)
                    if (pRootList->Entry[i].ServerShare != NULL)
                        MIDL_user_free(pRootList->Entry[i].ServerShare);
                MIDL_user_free(pRootList);
                *ppRootList = NULL;
            }

            wcscpy(wszFullObjectName, LDAP_VOLUMES_DIR);
            wcscat(wszFullObjectName, DOMAIN_ROOT_VOL);

            DfsManagerRemoveService(
                wszFullObjectName,
                wszComputerName);


            if (*ppRootList != NULL) {
                pRootList = *ppRootList;
                for (i = 0; i < pRootList->cEntries; i++)
                    if (pRootList->Entry[i].ServerShare != NULL)
                        MIDL_user_free(pRootList->Entry[i].ServerShare);
                MIDL_user_free(pRootList);
                *ppRootList = NULL;
            }

            DfsRemoveRoot();
            DfsReInitGlobals(wszComputerName, DFS_MANAGER_SERVER);

            //
            // Tell dfs.sys to discard all state
            //
            DfsmStopDfs();
            DfsmResetPkt();
            DfsmStartDfs();
            DfsmPktFlushCache();

        }

        {
            // don't mask the previous errors!!!!
            DWORD dwErr2;
            dwErr2 = LdapDecrementBlob();
            if (dwErr == ERROR_SUCCESS) {
                dwErr = dwErr2;
            }
        }

	if (dwErr == ERROR_SUCCESS) {

	    //
	    // Everything went okay.
	    // Update remoteServerName attribute
	    //

	    dwErr = DfspCreateFtDfsDsObj(
		wszComputerName,
		DcName,
		RootShare,
		FtDfsName,
		ppRootList);
#if DBG
	    if (DfsSvcVerbose)
		DbgPrint("DfspCreateFtDfsDsObj() returned %d\n", dwErr);
#endif

	}


    } else {

        RegCloseKey(hkey);
        dwErr = ERROR_ALREADY_EXISTS;

    }


    EXIT_DFSM_OPERATION;
cleanup:
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsAddFtRoot returning %d\n", dwErr);
#endif

    DFSM_TRACE_NORM(EVENT, NetrDfsAddFtRoot_End,
                    LOGSTATUS(dwErr)
                    LOGWSTR(ServerName)
                    LOGWSTR(DcName)
                    LOGWSTR(RootShare)
                    LOGWSTR(FtDfsName)
                    LOGWSTR(ConfigDN));

    return dwErr;

}

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsGetDcAddress
//
//  Synopsis:   Gets the DC to go to so that we can create an FtDfs object for
//              this server.
//
//  Arguments:  [ServerName] -- Name of server backing the volume.
//              [DcName] -- Dc to use
//              [IsRoot] -- TRUE if this server is a Dfs root, FALSE otherwise
//              [Timeout] -- Timeout, in sec, that the server will stay with this DC
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//              [NERR_DfsInternalCorruption] -- An internal database
//                      corruption was encountered while executing this
//                      operation.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory condition.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsGetDcAddress(
    IN LPWSTR ServerName,
    IN OUT LPWSTR *DcName,
    IN OUT BOOLEAN *IsRoot,
    IN OUT ULONG *Timeout)
{
    DWORD dwErr = ERROR_SUCCESS;
    HKEY hkey;
    WCHAR *wszDCName;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsGetDcAddress(%ws)\n", ServerName);
#endif

    DFSM_TRACE_NORM(EVENT, NetrDfsGetDcAddress_Start,
                    LOGSTATUS(dwErr)
                    LOGWSTR(ServerName));

    if (!AccessCheckRpcClient()) {

        dwErr = ERROR_ACCESS_DENIED;
        goto cleanup;
    }

    //
    // Validate the input arguments...
    //

    if (
        ServerName == NULL ||
        DcName == NULL ||
        IsRoot == NULL ||
        Timeout == NULL
    ) {

        dwErr =  ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (ServerName[0] == UNICODE_NULL) {

        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    ENTER_DFSM_OPERATION;

    //
    // Fill in root flag
    //

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, VOLUMES_DIR, &hkey );

    if (dwErr == ERROR_SUCCESS) {

        RegCloseKey(hkey);
        *IsRoot = TRUE;

    } else {

        *IsRoot = FALSE;

    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("IsRoot=%ws\n", *IsRoot == TRUE ? L"TRUE" : L"FALSE");
#endif

    dwErr = ERROR_SUCCESS;

    if (pwszDSMachineName == NULL) {

        dwErr = GetDcName( NULL, 1, &wszDCName );

        if (dwErr == ERROR_SUCCESS) {

            DfsManagerSetDcName(&wszDCName[2]);

        }

    }

    if (dwErr == ERROR_SUCCESS) {

        *DcName = (LPWSTR) MIDL_user_allocate((wcslen(pwszDSMachineName)+1) * sizeof(WCHAR));
        if (*DcName != NULL) {
            wcscpy(*DcName,pwszDSMachineName);
        } else {
            dwErr = ERROR_OUTOFMEMORY;
        }

    }

    *Timeout = DcLockIntervalInMs / 1000;

    EXIT_DFSM_OPERATION;
cleanup:
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsGetDcAddress returning %d\n", dwErr);
#endif
    DFSM_TRACE_NORM(EVENT, NetrDfsGetDcAddress_End,
                    LOGSTATUS(dwErr)
                    LOGWSTR(ServerName)
		    LOGWSTR(*DcName)
		    LOGBOOLEAN(*IsRoot)
		    LOGULONG(*Timeout)
		    );

    return dwErr;

}

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsSetDcAddress
//
//  Synopsis:   Sets the DC to go to for the dfs blob
//
//  Arguments:  [ServerName] -- Name of server backing the volume.
//              [DcName] -- Dc to use
//              [Timeout] -- Time, in sec, to stay with that DC
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory condition.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsSetDcAddress(
    IN LPWSTR ServerName,
    IN LPWSTR DcName,
    IN ULONG Timeout,
    IN DWORD Flags)
{
    NET_API_STATUS status = ERROR_SUCCESS;
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsSetDcAddress(%ws,%ws,%d,0x%x)\n",
                            ServerName,
                            DcName,
                            Timeout,
                            Flags);
#endif

    DFSM_TRACE_NORM(EVENT, NetrDfsSetDcAddress_Start,
                    LOGSTATUS(status)
                    LOGWSTR(ServerName)
                    LOGWSTR(DcName));

    if (!AccessCheckRpcClient()) {

        status = ERROR_ACCESS_DENIED;
        goto cleanup;
    }

    //
    // Validate the input arguments...
    //

    if (ServerName == NULL || DcName == NULL) {

        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (ServerName[0] == UNICODE_NULL || DcName[0] == UNICODE_NULL) {

        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (ulDfsManagerType == DFS_MANAGER_FTDFS) {

        ENTER_DFSM_OPERATION;

        DfsManagerSetDcName(DcName);

        if ((Flags & NET_DFS_SETDC_TIMEOUT) != 0) {
            DcLockIntervalInMs = Timeout * 1000;
        }

        EXIT_DFSM_OPERATION;

        if (Flags & NET_DFS_SETDC_INITPKT) {
            SetEvent(hSyncEvent);
        }

    }
cleanup:
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsSetDcAddress returning SUCCESS\n");
#endif

    DFSM_TRACE_NORM(EVENT, NetrDfsSetDcAddress_End,
                LOGSTATUS(status)
                LOGWSTR(ServerName)
                LOGWSTR(DcName));

    return ERROR_SUCCESS;

}

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsFlushFtTable
//
//  Synopsis:   Flushes an FtDfs entry from the FtDfs cache
//
//  Arguments:  [DcName] -- Dc to use
//              [FtDfsName] -- Name of FtDfs
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory condition.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsFlushFtTable(
    IN LPWSTR DcName,
    IN LPWSTR FtDfsName)
{
    ULONG Size;
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS Status;
    PDFS_DELETE_SPECIAL_INFO_ARG pSpcDelArg;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK IoStatus;
    HANDLE dfsHandle = NULL;
    UNICODE_STRING SrvName;

    DFSM_TRACE_NORM(EVENT, NetrDfsFlushFtTable_Start,
                    LOGSTATUS(Status)
                    LOGWSTR(DcName)
                    LOGWSTR(FtDfsName));

    if (!AccessCheckRpcClient()) {

        Status = ERROR_ACCESS_DENIED;
        goto cleanup;
    }

    //
    // Validate the input arguments...
    //

    if (DcName == NULL || FtDfsName == NULL) {

        Status =  ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (DcName[0] == UNICODE_NULL || FtDfsName[0] == UNICODE_NULL) {

        Status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    Size = sizeof(DFS_DELETE_SPECIAL_INFO_ARG) +
                wcslen(FtDfsName) * sizeof(WCHAR);

    pSpcDelArg = (PDFS_DELETE_SPECIAL_INFO_ARG) malloc(Size);

    if (pSpcDelArg != NULL) {

        WCHAR *wCp;

        RtlZeroMemory(pSpcDelArg, Size);

        wCp = (WCHAR *)((PCHAR)pSpcDelArg + sizeof(DFS_DELETE_SPECIAL_INFO_ARG));
        pSpcDelArg->SpecialName.Buffer = (PWCHAR)sizeof(DFS_DELETE_SPECIAL_INFO_ARG);
        pSpcDelArg->SpecialName.Length = wcslen(FtDfsName) * sizeof(WCHAR);
        pSpcDelArg->SpecialName.MaximumLength = pSpcDelArg->SpecialName.Length;
        RtlCopyMemory(wCp, FtDfsName, pSpcDelArg->SpecialName.Length);

        ENTER_DFSM_OPERATION;

        RtlInitUnicodeString(&SrvName, DFS_SERVER_NAME);

        InitializeObjectAttributes(
            &objectAttributes,
            &SrvName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
        );

        Status = NtCreateFile(
                    &dfsHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatus,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0
                );

        DFSM_TRACE_ERROR_HIGH(Status, ALL_ERROR, NetrDfsFlushFtTable_Error_NtCreateFile,
                              LOGSTATUS(Status)
                              LOGWSTR(DcName)
                              LOGWSTR(FtDfsName));

        if (NT_SUCCESS(Status)) {

            NtFsControlFile(
                    dfsHandle,
                    NULL,       // Event,
                    NULL,       // ApcRoutine,
                    NULL,       // ApcContext,
                    &IoStatus,
                    FSCTL_DFS_DELETE_FTDFS_INFO,
                    pSpcDelArg,
                    Size,
                    NULL,
                    0);

            NtClose(dfsHandle);

        }

        free(pSpcDelArg);

        if (!NT_SUCCESS(Status)) {

            dwErr = ERROR_NOT_FOUND;

        }

        EXIT_DFSM_OPERATION;

    } else {

        dwErr = ERROR_OUTOFMEMORY;

    }
cleanup:
    DFSM_TRACE_NORM(EVENT, NetrDfsFlushFtTable_Start,
                    LOGSTATUS(Status)
                    LOGWSTR(DcName)
                    LOGWSTR(FtDfsName));

    return dwErr;

}

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsAddStdRoot
//
//  Synopsis:   Creates a new Std Dfs
//
//  Arguments:  [ServerName] -- Name of server backing the volume.
//              [RootShare] -- Name of share on ServerName backing the volume.
//              [Comment] -- Comment associated with this root.
//              [Flags] -- Flags for the operation
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//              [NERR_DfsInternalCorruption] -- An internal database
//                      corruption was encountered while executing this
//                      operation.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory condition.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsAddStdRoot(
    IN LPWSTR ServerName,
    IN LPWSTR RootShare,
    IN LPWSTR Comment,
    IN DWORD  Flags)
{
    WCHAR wszComputerName[MAX_PATH+1];
    DWORD dwErr = ERROR_SUCCESS;
    HKEY hkey;
    DFS_NAME_CONVENTION NameType;

    DFSM_TRACE_NORM(EVENT, NetrDfsAddStdRoot_Start, 
                    LOGSTATUS(dwErr)
                    LOGWSTR(ServerName)
                    LOGWSTR(RootShare));

    if (!AccessCheckRpcClient()) {

        dwErr = ERROR_ACCESS_DENIED;
        goto cleanup;
    }

    //
    // Validate the input arguments...
    //

    if (ServerName == NULL || RootShare == NULL) {

        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (ServerName[0] == UNICODE_NULL || RootShare[0] == UNICODE_NULL) {

        dwErr =  ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Get our computer name
    //
    NameType = DFS_NAMETYPE_EITHER;
    // NameType = DFS_NAMETYPE_NETBIOS;
    dwErr = GetDomAndComputerName( NULL, wszComputerName, &NameType);

    if (dwErr != ERROR_SUCCESS){
        goto cleanup;
        //return dwErr;

    }

    ENTER_DFSM_OPERATION;

    //
    // Already a root?
    //

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, VOLUMES_DIR, &hkey );

    if (dwErr != ERROR_SUCCESS) {

        dwErr = SetupStdDfs(
                    wszComputerName,
                    RootShare,
                    Comment,
                    Flags,
                    NULL);

        if (dwErr == ERROR_SUCCESS) {

            //
            // Reset dfs
            //
            DfsmStopDfs();
            DfsmResetPkt();
            DfsmInitLocalPartitions();
            InitializeDfsManager();
            DfsmStartDfs();
            DfsmPktFlushCache();

        }

    } else {

        RegCloseKey(hkey);
        dwErr = ERROR_ALREADY_EXISTS;

    }

    EXIT_DFSM_OPERATION;
cleanup:
    DFSM_TRACE_NORM(EVENT, NetrDfsAddStdRoot_End, 
                    LOGSTATUS(dwErr)
                    LOGWSTR(ServerName)
                    LOGWSTR(RootShare));

    return dwErr;

}

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsAddStdRootForced
//
//  Synopsis:   Creates a new Std Dfs
//
//  Arguments:  [ServerName] -- Name of server backing the volume.
//              [RootShare] -- Name of share on ServerName backing the volume.
//              [Comment] -- Comment associated with this root.
//              [Share] -- drive:\dir behind the share
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//              [NERR_DfsInternalCorruption] -- An internal database
//                      corruption was encountered while executing this
//                      operation.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory condition.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsAddStdRootForced(
    IN LPWSTR ServerName,
    IN LPWSTR RootShare,
    IN LPWSTR Comment,
    IN LPWSTR Share)
{
    WCHAR wszComputerName[MAX_PATH+1];
    DWORD dwErr = ERROR_SUCCESS;
    HKEY hkey;
    DFS_NAME_CONVENTION NameType;

    DFSM_TRACE_NORM(EVENT, NetrDfsAddStdRootForced_Start,
                    LOGSTATUS(dwErr)
                    LOGWSTR(ServerName)
                    LOGWSTR(RootShare)
                    LOGWSTR(Share));

    if (!AccessCheckRpcClient()) {

        dwErr = ERROR_ACCESS_DENIED;
        goto cleanup;
    }

    //
    // Validate the input arguments...
    //

    if (ServerName == NULL || RootShare == NULL || Share == NULL) {

        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (ServerName[0] == UNICODE_NULL || RootShare[0] == UNICODE_NULL || Share[0] == UNICODE_NULL) {

        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Get our computer name
    //
    NameType = DFS_NAMETYPE_EITHER;
    dwErr = GetDomAndComputerName( NULL, wszComputerName, &NameType);

    if (dwErr != ERROR_SUCCESS){
        goto cleanup;
        //return dwErr;

    }

    ENTER_DFSM_OPERATION;

    //
    // Already a root?
    //

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, VOLUMES_DIR, &hkey );

    if (dwErr != ERROR_SUCCESS) {

        dwErr = SetupStdDfs(
                    wszComputerName,
                    RootShare,
                    Comment,
                    1,
                    Share);

        if (dwErr == ERROR_SUCCESS) {

            //
            // Reset dfs
            //
            DfsmStopDfs();
            DfsmResetPkt();
            DfsmInitLocalPartitions();
            InitializeDfsManager();
            DfsmStartDfs();
            DfsmPktFlushCache();

        }

    } else {

        RegCloseKey(hkey);
        dwErr = ERROR_ALREADY_EXISTS;

    }

    EXIT_DFSM_OPERATION;
cleanup:
    DFSM_TRACE_NORM(EVENT, NetrDfsAddStdRootForced_End,
                    LOGSTATUS(dwErr)
                    LOGWSTR(ServerName)
                    LOGWSTR(RootShare)
                    LOGWSTR(Share));

    return dwErr;

}



//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsRemove (Obsolete)
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsRemove(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName)
{
    NET_API_STATUS status = ERROR_SUCCESS;
    DFSM_TRACE_NORM(EVENT, NetrDfsRemove_Start,
                    LOGSTATUS(status)
                    LOGWSTR(DfsEntryPath)
                    LOGWSTR(ServerName)
                    LOGWSTR(ShareName));

    if (!AccessCheckRpcClient()) {
        status = ERROR_ACCESS_DENIED;
        goto cleanup;
    }

    if (ulDfsManagerType == DFS_MANAGER_FTDFS){
        status = ERROR_NOT_SUPPORTED;
        goto cleanup;
    }

    status = NetrDfsRemove2(
                DfsEntryPath,
                NULL,
                ServerName,
                ShareName,
                NULL);
    goto cleanup;
 cleanup:
     DFSM_TRACE_NORM(EVENT, NetrDfsRemove_End,
                     LOGSTATUS(status)
                     LOGWSTR(DfsEntryPath)
                     LOGWSTR(ServerName)
                     LOGWSTR(ShareName));

 return status;
}

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsRemove2
//
//  Synopsis:   Deletes a volume/replica/link from the Dfs.
//
//  Arguments:  [DfsEntryPath] -- Entry path of the volume to operate on.
//              [DcName] -- Name of Dc to use
//              [ServerName] -- If specified, indicates the replica of the
//                      volume to operate on.
//              [ShareName] -- If specified, indicates the share on the
//                      server to operate on.
//              [Flags] -- Flags for the operation
//              [ppRootList] -- On success, returns a list of roots that need to be
//                              informed of the change in the DS object
//
//  Returns:    [NERR_Success] -- Operation successful.
//
//              [NERR_DfsNoSuchVolume] -- DfsEntryPath does not correspond to
//                      a valid entry path.
//
//              [NERR_DfsNotALeafVolume] -- Unable to delete the volume
//                      because it is not a leaf volume.
//
//              [NERR_DfsInternalCorruption] -- Internal database corruption
//                      encountered while executing operation.
//
//              [ERROR_INVALID_PARAMETER] -- One of the input parameters is
//                      incorrect.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsRemove2(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR DcName,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName,
    IN PDFSM_ROOT_LIST *ppRootList)
{
    NET_API_STATUS status = ERROR_SUCCESS;
    CDfsVolume *pDfsVol = NULL;
    DFS_REPLICA_INFO replInfo;
    BOOLEAN fRemoveReplica = FALSE;
    LPWSTR OrgDfsEntryPath = DfsEntryPath;
    DWORD dwErr;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsRemove2(%ws,%ws,%ws,%ws,0x%x)\n",
                DfsEntryPath,
                DcName,
                ServerName,
                ShareName,
                ppRootList);
#endif
    DFSM_TRACE_NORM(EVENT, NetrDfsRemove2_Start,
                    LOGSTATUS(status)
                    LOGWSTR(OrgDfsEntryPath)
                    LOGWSTR(DcName)
                    LOGWSTR(ServerName)
                    LOGWSTR(ShareName));

    if (!AccessCheckRpcClient()){
        status = ERROR_ACCESS_DENIED;
        goto cleanup;
    }

    //
    // Validate the input arguments...
    //

#if 0 // Broken for DNS names
    DfsEntryPath = NormalizeEntryPath( DfsEntryPath );
#endif

    if (DfsEntryPath != NULL) {
    
        if (ulDfsManagerType == DFS_MANAGER_FTDFS)
            DfsEntryPath = FormFTDfsEntryPath(DfsEntryPath);
        else if (ulDfsManagerType == DFS_MANAGER_SERVER)
            DfsEntryPath = FormStdDfsEntryPath(DfsEntryPath);

        if (DfsEntryPath == NULL){
            status = ERROR_OUTOFMEMORY;
            goto cleanup;
        }

    }

    if (DfsEntryPath == NULL) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // If ServerName is present, it must be valid.
    //

    if (ServerName != NULL && ServerName[0] == UNICODE_NULL) {

        if (DfsEntryPath != OrgDfsEntryPath) {
            delete [] DfsEntryPath;
        }

        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // If ShareName is present, it must be valid.
    //

    if (ShareName != NULL && ShareName[0] == UNICODE_NULL) {

        if (DfsEntryPath != OrgDfsEntryPath) {
            delete [] DfsEntryPath;
        }

        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // If ShareName is present, ServerName must be present.
    //

    if (ShareName != NULL && ServerName == NULL) {

        if (DfsEntryPath != OrgDfsEntryPath) {
            delete [] DfsEntryPath;
        }

        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    ENTER_DFSM_OPERATION;

    //
    // Great, the parameters look semi-reasonable, lets do the work.
    //

    if (ulDfsManagerType == DFS_MANAGER_FTDFS) {
        if (DcName != NULL)
            DfsManagerSetDcName(DcName);
        LdapIncrementBlob();
    }

    ZeroMemory( &replInfo, sizeof(replInfo) );

    status = GetDfsVolumeFromPath( DfsEntryPath, TRUE, &pDfsVol );

    if (status != ERROR_SUCCESS) {

        pDfsVol = NULL;

    }

    if (status == ERROR_SUCCESS && ServerName != NULL && ShareName != NULL) {

        LPWSTR pwszShare;

        replInfo.ulReplicaState = 0;
        replInfo.ulReplicaType = 0;
        replInfo.pwszServerName = ServerName;
        replInfo.pwszShareName = ShareName;

        fRemoveReplica = TRUE;

    }

    if (status == ERROR_SUCCESS) {

        //
        // See whether we should delete a replica or the volume
        //

        if (fRemoveReplica) {

            status = pDfsVol->RemoveReplica( &replInfo, DFS_OVERRIDE_FORCE );

            if (status == NERR_DfsCantRemoveLastServerShare) {

                status = pDfsVol->Delete( DFS_OVERRIDE_FORCE );

            }

        } else {

            status = pDfsVol->Delete( DFS_OVERRIDE_FORCE );

        }

    }

    if (pDfsVol != NULL) {
        pDfsVol->Release();
    }

    if (ulDfsManagerType == DFS_MANAGER_FTDFS)
        status = LdapDecrementBlob();

    EXIT_DFSM_OPERATION;


    //
    // Create list of roots to redirect to this DC
    //

    if (status == NERR_Success &&
        DcName != NULL &&
        ulDfsManagerType == DFS_MANAGER_FTDFS
    ) {
        DfspCreateRootList(
                DfsEntryPath,
                DcName,
                ppRootList);
    }

    if (DfsEntryPath != OrgDfsEntryPath) {
        delete [] DfsEntryPath;
    }
cleanup:
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsRemove2 returning %d\n", status);
#endif


    DFSM_TRACE_NORM(EVENT, NetrDfsRemove2_End,
                    LOGSTATUS(status)
                    LOGWSTR(OrgDfsEntryPath)
                    LOGWSTR(DcName)
                    LOGWSTR(ServerName)
                    LOGWSTR(ShareName));
    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsRemoveFtRoot
//
//  Synopsis:   Deletes a root from an FtDfs.
//
//  Arguments:  [ServerName] -- The server to remove.
//              [DcName] -- DC to use
//              [RootShare] -- The Root share hosting the Dfs/FtDfs
//              [FtDfsName] -- The FtDfs to remove the root from.
//              [Flags] -- Flags for the operation
//              [ppRootList] -- On success, returns a list of roots that need to be
//                              informed of the change in the DS object
//
//  Returns:    [NERR_Success] -- Operation successful.
//
//              [NERR_DfsInternalCorruption] -- Internal database corruption
//                      encountered while executing operation.
//
//              [ERROR_INVALID_PARAMETER] -- One of the input parameters is
//                      incorrect.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsRemoveFtRoot(
    IN LPWSTR ServerName,
    IN LPWSTR DcName,
    IN LPWSTR RootShare,
    IN LPWSTR FtDfsName,
    IN DWORD  Flags,
    IN PDFSM_ROOT_LIST *ppRootList)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwErr2 = ERROR_SUCCESS;
    DWORD cbData;
    DWORD dwType;
    HKEY hkey;
    WCHAR wszRootShare[MAX_PATH];
    WCHAR wszFTDfs[MAX_PATH];
    WCHAR wszFullObjectName[MAX_PATH];
    WCHAR wszComputerName[MAX_PATH];
    DFS_NAME_CONVENTION NameType;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsRemoveFtRoot(%ws,%ws,%ws,%ws,0x%x)\n",
                ServerName,
                DcName,
                RootShare,
                FtDfsName,
                Flags);
#endif
    DFSM_TRACE_NORM(EVENT, NetrDfsRemoveFtRoot_Start,
                    LOGSTATUS(dwErr)
                    LOGWSTR(ServerName)
                    LOGWSTR(DcName)
                    LOGWSTR(RootShare)
                    LOGWSTR(FtDfsName));

    if (!AccessCheckRpcClient()) {

        dwErr = ERROR_ACCESS_DENIED;
        goto cleanup;

    }

    //
    // Validate the input arguments...
    //

    if (
        ServerName == NULL ||
        DcName == NULL ||
        RootShare == NULL ||
        FtDfsName == NULL
    ) {

        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (
        ServerName[0] == UNICODE_NULL ||
        DcName[0] == UNICODE_NULL ||
        RootShare[0] == UNICODE_NULL ||
        FtDfsName[0] == UNICODE_NULL
    ) {

        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Get our computer name
    //
    NameType = DFS_NAMETYPE_DNS;
    dwErr = GetDomAndComputerName( NULL, wszComputerName, &NameType);

    if (dwErr != ERROR_SUCCESS){
        goto cleanup;
        //return dwErr;

    }

    if ((Flags & DFS_FORCE_REMOVE) == 0) {

        ENTER_DFSM_OPERATION;
	        
	//
        // Update remoteServerName attribute
        //


	dwErr = DfspRemoveFtDfsDsObj(
	    wszComputerName,
	    DcName,
	    RootShare,
	    FtDfsName,
	    ppRootList);


        if (dwErr == ERROR_SUCCESS) {
	    LdapIncrementBlob();
	    DfsManagerSetDcName(DcName);

	    //
	    // We need to be a root to remove a root...
	    //

	    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, VOLUMES_DIR, &hkey );
	}


        //
        // Check RootName and FtDfsName
        //

        if (dwErr == ERROR_SUCCESS) {

            cbData = sizeof(wszRootShare);

            dwErr = RegQueryValueEx(
                        hkey,
                        ROOT_SHARE_VALUE_NAME,
                        NULL,
                        &dwType,
                        (PBYTE) wszRootShare,
                        &cbData);

            if (dwErr != ERROR_SUCCESS ||
                dwType != REG_SZ ||
                _wcsicmp(wszRootShare, RootShare) != 0
            ) {

                dwErr = ERROR_INVALID_PARAMETER;

            }

        } else {

            hkey = NULL;

        }

        if (dwErr == ERROR_SUCCESS) {

            cbData = sizeof(wszFTDfs);

            dwErr = RegQueryValueEx(
                        hkey,
                        FTDFS_VALUE_NAME,
                        NULL,
                        &dwType,
                        (PBYTE) wszFTDfs,
                        &cbData);

            if (dwErr != ERROR_SUCCESS ||
                dwType != REG_SZ ||
                _wcsicmp(wszFTDfs, FtDfsName) != 0
            ) {

                dwErr = ERROR_INVALID_PARAMETER;

            }

        }

        //
        // Update pKT (blob) attribute
        //

        if (dwErr == ERROR_SUCCESS) {

            wcscpy(wszFullObjectName, LDAP_VOLUMES_DIR);
            wcscat(wszFullObjectName, DOMAIN_ROOT_VOL);

            dwErr = DfsManagerRemoveService(
                        wszFullObjectName,
                        wszComputerName);

            if (dwErr == NERR_DfsCantRemoveLastServerShare) {
                dwErr = ERROR_SUCCESS;
            }

        }


        if (dwErr == ERROR_SUCCESS) {

            dwErr = DfsRemoveRoot();

            if (dwErr == ERROR_SUCCESS) {

                //
                // Reinit the service, back to non-ldap
                //

                DfsReInitGlobals(wszComputerName, DFS_MANAGER_SERVER);

                //
                // Tell dfs.sys to discard all state
                //

                RegCloseKey(hkey);
                hkey = NULL;

                DfsmStopDfs();
                DfsmResetPkt();
                DfsmStartDfs();
                DfsmPktFlushCache();

            }

        }

        if (hkey != NULL) {

            RegCloseKey(hkey);

        }

        dwErr2 = LdapDecrementBlob();
	// don't mask more important errors.
	if(dwErr == ERROR_SUCCESS) {
	    dwErr = dwErr2;
	}

        EXIT_DFSM_OPERATION;

    } else {

        ENTER_DFSM_OPERATION;

        //
        // We're forcefully removing a root.  We'd better be a DC!!
        //

	//
        // Update remoteServerName attribute
        //

            dwErr = DfspRemoveFtDfsDsObj(
                        ServerName,
                        DcName,
                        RootShare,
                        FtDfsName,
                        ppRootList);

        //
        // Update pKT (blob) attribute
        //

	    if (dwErr == ERROR_SUCCESS) {

		dwErr = DfsManagerRemoveServiceForced(
		    ServerName,
		    DcName,
		    FtDfsName);
	    }



        EXIT_DFSM_OPERATION;

    }
cleanup:
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsRemoveFtRoot returning %d\n", dwErr);
#endif
    DFSM_TRACE_NORM(EVENT, NetrDfsRemoveFtRoot_End,
                     LOGSTATUS(dwErr)
                     LOGWSTR(ServerName)
                     LOGWSTR(DcName)
                     LOGWSTR(RootShare)
                     LOGWSTR(FtDfsName));

    return dwErr;

}

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsRemoveStdRoot
//
//  Synopsis:   Deletes a Dfs root
//
//  Arguments:  [ServerName] -- The server to remove.
//              [RootShare] -- The Root share hosting the Dfs/FtDfs
//              [Flags] -- Flags for the operation
//
//  Returns:    [NERR_Success] -- Operation successful.
//
//              [NERR_DfsInternalCorruption] -- Internal database corruption
//                      encountered while executing operation.
//
//              [ERROR_INVALID_PARAMETER] -- One of the input parameters is
//                      incorrect.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsRemoveStdRoot(
    IN LPWSTR ServerName,
    IN LPWSTR RootShare,
    IN DWORD  Flags)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cbData;
    DWORD dwType;
    HKEY hkey;
    WCHAR wszRootShare[MAX_PATH];

    DFSM_TRACE_NORM(EVENT, NetrDfsRemoveStdRoot_Start,
                    LOGSTATUS(dwErr)
                    LOGWSTR(ServerName)
                    LOGWSTR(RootShare));

    if (!AccessCheckRpcClient()) {

        dwErr = ERROR_ACCESS_DENIED;
        goto cleanup;
    }

    //
    // Validate the input arguments...
    //

    if (ServerName == NULL) {

        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (ServerName[0] == UNICODE_NULL) {

        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (RootShare == NULL) {

        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (RootShare[0] == UNICODE_NULL) {

        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    ENTER_DFSM_OPERATION;

    //
    // We need to be a root to remove a root...
    //

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, VOLUMES_DIR, &hkey );

    //
    // Check RootName
    //

    if (dwErr == ERROR_SUCCESS) {

        cbData = sizeof(wszRootShare);

        dwErr = RegQueryValueEx(
                    hkey,
                    ROOT_SHARE_VALUE_NAME,
                    NULL,
                    &dwType,
                    (PBYTE) wszRootShare,
                    &cbData);

        if (dwErr != ERROR_SUCCESS ||
            dwType != REG_SZ ||
            _wcsicmp(wszRootShare, RootShare) != 0
        ) {

            dwErr = ERROR_INVALID_PARAMETER;

        }

    } else {

        hkey = NULL;

    }

    if (dwErr == ERROR_SUCCESS) {

        //
        // Remove registry stuff (DfsHost and volumes)
        //

        dwErr = DfsRemoveRoot();

        if (dwErr == ERROR_SUCCESS) {

            //
            // Reinit the service
            //

            DfsReInitGlobals(pwszComputerName, DFS_MANAGER_SERVER);

            //
            // Tell dfs.sys to discard all state
            //

            RegCloseKey(hkey);
            hkey = NULL;

            DfsmStopDfs();
            DfsmResetPkt();
            DfsmStartDfs();
            DfsmPktFlushCache();

        }

    }

    if (hkey != NULL) {

        RegCloseKey(hkey);

    }

    EXIT_DFSM_OPERATION;
cleanup:
   DFSM_TRACE_NORM(EVENT, NetrDfsRemoveStdRoot_End,
                    LOGSTATUS(dwErr)
                    LOGWSTR(ServerName)
                    LOGWSTR(RootShare));

    return dwErr;

}

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsSetInfo (Obsolete)
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsSetInfo(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName,
    IN DWORD Level,
    IN LPDFS_INFO_STRUCT DfsInfo)
{
    if (!AccessCheckRpcClient())
        return( ERROR_ACCESS_DENIED );

    if (ulDfsManagerType == DFS_MANAGER_FTDFS)
        return( ERROR_NOT_SUPPORTED );

    return NetrDfsSetInfo2(
            DfsEntryPath,
            NULL,
            ServerName,
            ShareName,
            Level,
            DfsInfo,
            NULL);
}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsSetInfo2
//
//  Synopsis:   Sets the comment, volume state, or replica state.
//
//  Arguments:  [DfsEntryPath] -- Entry Path of the volume for which info is
//                      to be set.
//              [ServerName] -- If specified, the name of the server whose
//                      state is to be set.
//              [ShareName] -- If specified, the name of the share on
//                      ServerName whose state is to be set.
//              [Level] -- Level of DfsInfo
//              [DfsInfo] -- The actual Dfs info.
//
//  Returns:    [NERR_Success] -- Operation completed successfully.
//
//              [ERROR_INVALID_LEVEL] -- Level != 100 , 101, or 102
//
//              [ERROR_INVALID_PARAMETER] -- DfsEntryPath invalid, or
//                      ShareName specified without ServerName.
//
//              [NERR_DfsNoSuchVolume] -- DfsEntryPath does not correspond to
//                      a valid Dfs volume.
//
//              [NERR_DfsNoSuchShare] -- The indicated ServerName/ShareName do
//                      not support this Dfs volume.
//
//              [NERR_DfsInternalCorruption] -- Internal database corruption
//                      encountered while executing operation.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsSetInfo2(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR DcName,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName,
    IN DWORD Level,
    IN LPDFS_INFO_STRUCT DfsInfo,
    IN PDFSM_ROOT_LIST *ppRootList)
{
    NET_API_STATUS status = ERROR_SUCCESS;
    NET_API_STATUS netStatus;
    CDfsVolume *pDfsVol = NULL;
    LPWSTR pwszShare = NULL;
    BOOLEAN fSetReplicaState;
    LPWSTR OrgDfsEntryPath = DfsEntryPath;

    DFSM_TRACE_NORM(EVENT, NetrDfsSetInfo2_Start,
                    LOGSTATUS(status)
                    LOGWSTR(OrgDfsEntryPath)
                    LOGWSTR(DcName)
                    LOGWSTR(ServerName)
                    LOGWSTR(ShareName));
#if DBG
    if (DfsSvcVerbose) {
        DbgPrint("NetrDfsSetInfo2(%ws,%ws,%ws,%ws,%d,0x%x\n",
                        DfsEntryPath,
                        DcName,
                        ServerName,
                        ShareName,
                        Level,
                        ppRootList);
        if (Level == 100) {
            DbgPrint(",Comment=%ws)\n", DfsInfo->DfsInfo100->Comment);
        } else if (Level == 101) {
            DbgPrint(",State=0x%x)\n", DfsInfo->DfsInfo101->State);
        } else if (Level == 102) {
            DbgPrint(",Timeout=0x%x)\n", DfsInfo->DfsInfo102->Timeout);
        } else {
            DbgPrint(")\n");
        }
    }
#endif

    if (!AccessCheckRpcClient()) {
        status = ERROR_ACCESS_DENIED;
        goto cleanup;
    }

    //
    // Validate the input parameters...
    //

#if 0 // Broken for DNS names
    DfsEntryPath = NormalizeEntryPath( DfsEntryPath );
#endif

    if (DfsEntryPath != NULL) {
    
        if (ulDfsManagerType == DFS_MANAGER_FTDFS)
            DfsEntryPath = FormFTDfsEntryPath(DfsEntryPath);
        else if (ulDfsManagerType == DFS_MANAGER_SERVER)
            DfsEntryPath = FormStdDfsEntryPath(DfsEntryPath);

        if (DfsEntryPath == NULL){
            status = ERROR_OUTOFMEMORY;
            goto cleanup;
        }

    }

    if (DfsEntryPath == NULL) {

        status = ERROR_INVALID_PARAMETER;
        goto cleanup;

    }

    if (DfsInfo == NULL || DfsInfo->DfsInfo100 == NULL) {

        if (DfsEntryPath != OrgDfsEntryPath) {
            delete [] DfsEntryPath;
        }

        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (!(Level >= 100 && Level <= 102)) {

        if (DfsEntryPath != OrgDfsEntryPath) {
            delete [] DfsEntryPath;
        }

        status = ERROR_INVALID_LEVEL;
        goto cleanup;
    }

    ENTER_DFSM_OPERATION;

    if (ulDfsManagerType == DFS_MANAGER_FTDFS) {
        if (DcName != NULL)
            DfsManagerSetDcName(DcName);
        LdapIncrementBlob();
    }

    //
    // Try to get the Dfs Volume for DfsEntryPath
    //

    status = GetDfsVolumeFromPath( DfsEntryPath, TRUE, &pDfsVol );

    if (status == ERROR_SUCCESS) {

        //
        // Do the right thing based on Level...
        //

        if (Level == 100) {

            //
            // Set the volume Comment
            //

            if (DfsInfo->DfsInfo100->Comment != NULL)
                status = pDfsVol->SetComment(DfsInfo->DfsInfo100->Comment);
            else
                status = pDfsVol->SetComment(L"");

        } else if (Level == 101) {

            //
            // Set the volume state
            //

            if (ServerName == NULL && ShareName == NULL) {

                fSetReplicaState = FALSE;

            } else if (ServerName != NULL && ServerName[0] != UNICODE_NULL &&
                        ShareName != NULL && ShareName[0] != UNICODE_NULL) {

                fSetReplicaState = TRUE;

            } else {

                status = ERROR_INVALID_PARAMETER;
                DFSM_TRACE_HIGH(ERROR, NetrDfsSetInfo2_Error1, 
                                LOGSTATUS(status)
                                LOGWSTR(DcName)
                                LOGWSTR(ServerName)
                                LOGWSTR(ShareName));
            }

            if (status == ERROR_SUCCESS) {

                if (fSetReplicaState) {

                    status = pDfsVol->SetReplicaState(
                                        ServerName,
                                        ShareName,
                                        DfsInfo->DfsInfo101->State);

                } else {

                    status = pDfsVol->SetVolumeState(DfsInfo->DfsInfo101->State);

                }

            }

            if (pwszShare != NULL) {

                delete [] pwszShare;

            }

        } else if (Level == 102) {

            //
            // Set the volume timeout
            //

            status = pDfsVol->SetVolumeTimeout(DfsInfo->DfsInfo102->Timeout);

        }

    }


    if (pDfsVol != NULL) {
        pDfsVol->Release();
    }

    if (ulDfsManagerType == DFS_MANAGER_FTDFS)
        status = LdapDecrementBlob();

    EXIT_DFSM_OPERATION;

    //
    // Create list of roots to redirect to this DC
    //

    if (status == NERR_Success &&
        DcName != NULL &&
        ulDfsManagerType == DFS_MANAGER_FTDFS
    ) {
        DfspCreateRootList(
                DfsEntryPath,
                DcName,
                ppRootList);
    }

    if (DfsEntryPath != OrgDfsEntryPath) {
        delete [] DfsEntryPath;
    }
cleanup:
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsSetInfo2 returning %d\n", status);
#endif

    DFSM_TRACE_NORM(EVENT, NetrDfsSetInfo2_End,
                    LOGSTATUS(status)
                    LOGWSTR(OrgDfsEntryPath)
                    LOGWSTR(DcName)
                    LOGWSTR(ServerName)
                    LOGWSTR(ShareName));
    return( status );

}



//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsGetInfo
//
//  Synopsis:   Server side implementation of the NetDfsGetInfo.
//
//  Arguments:  [DfsEntryPath] -- Entry Path of volume for which info is
//                      requested.
//
//              [ServerName] -- Name of server which supports this volume
//                      and for which info is requested.
//
//              [ShareName] -- Name of share on ServerName which supports this
//                      volume.
//
//              [Level] -- Level of Info requested.
//
//              [DfsInfo] -- On successful return, contains a pointer to the
//                      requested DFS_INFO_x struct.
//
//  Returns:    [NERR_Success] -- If successfully returned requested info.
//
//              [NERR_DfsNoSuchVolume] -- If DfsEntryPath does not
//                      corresponds to a valid volume.
//
//              [NERR_DfsInternalCorruption] -- Corruption encountered in
//                      internal database.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Unable to allocate memory for
//                      info.
//
//              [ERROR_INVALID_PARAMETER] -- DfsInfo was NULL on entry, or
//                      ShareName specified without ServerName, or
//                      DfsEntryPath was NULL on entry.
//
//              [ERROR_INVALID_LEVEL] -- Level != 1,2,3,4, or 100
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsGetInfo(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName,
    IN DWORD Level,
    OUT LPDFS_INFO_STRUCT DfsInfo)
{
    NET_API_STATUS status = ERROR_SUCCESS;
    LPDFS_INFO_3 pInfo;
    CDfsVolume *pDfsVol;
    DWORD cbInfo;
    LPWSTR OrgDfsEntryPath = DfsEntryPath;

    DFSM_TRACE_NORM(EVENT, NetrDfsGetInfo_Start,
                    LOGSTATUS(status)
                    LOGWSTR(DfsEntryPath)
                    LOGWSTR(ServerName)
                    LOGWSTR(ShareName));
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsGetInfo(%ws,%ws,%ws,%d)\n",
            DfsEntryPath,
            ServerName,
            ShareName,
            Level);
#endif

    IDfsVolInlineDebOut((DEB_TRACE, "NetrDfsGetInfo(L=%d)\n", Level));

    //
    // Validate the input parameters...
    //

#if 0 // Broken for DNS names
    DfsEntryPath = NormalizeEntryPath( DfsEntryPath );
#endif

    if (DfsEntryPath != NULL) {
    
        if (ulDfsManagerType == DFS_MANAGER_FTDFS)
            DfsEntryPath = FormFTDfsEntryPath(DfsEntryPath);
        else if (ulDfsManagerType == DFS_MANAGER_SERVER)
            DfsEntryPath = FormStdDfsEntryPath(DfsEntryPath);

        if (DfsEntryPath == NULL) {
            status = ERROR_OUTOFMEMORY;
            goto cleanup;
        }

    }

    if (DfsEntryPath == NULL) {

        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (DfsInfo == NULL) {

        if (DfsEntryPath != OrgDfsEntryPath) {
            delete [] DfsEntryPath;
        }

        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (!(Level >= 1 && Level <= 4) && Level != 100) {

        if (DfsEntryPath != OrgDfsEntryPath) {
            delete [] DfsEntryPath;
        }

        status = ERROR_INVALID_LEVEL;
        goto cleanup;
    }

    if (ServerName == NULL && ShareName != NULL) {

        if (DfsEntryPath != OrgDfsEntryPath) {
            delete [] DfsEntryPath;
        }

        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Now, get the info...
    //

    if (Level <= 3) {

        pInfo = (LPDFS_INFO_3) MIDL_user_allocate(sizeof(DFS_INFO_3));

    } else {

        pInfo = (LPDFS_INFO_3) MIDL_user_allocate(sizeof(DFS_INFO_4));

    }

    if (pInfo == NULL) {

        if (DfsEntryPath != OrgDfsEntryPath) {
            delete [] DfsEntryPath;
        }

        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;

    }

    ENTER_DFSM_OPERATION;

    if (ulDfsManagerType == DFS_MANAGER_FTDFS)
        LdapIncrementBlob();

    status = GetDfsVolumeFromPath( DfsEntryPath, TRUE, &pDfsVol );

    if (status == ERROR_SUCCESS) {

        status = pDfsVol->GetNetInfo(Level, pInfo, &cbInfo );

        pDfsVol->Release();

    }

    if (status == ERROR_SUCCESS) {

        DfsInfo->DfsInfo3 = pInfo;

    } else if (status != NERR_DfsNoSuchVolume) {

        status = NERR_DfsInternalCorruption;

    }

    if (ulDfsManagerType == DFS_MANAGER_FTDFS) {
        NET_API_STATUS TempStatus;
        TempStatus = LdapDecrementBlob();
        // only mask the status if we haven't already seen an error.
        if(status == ERROR_SUCCESS) {
            status = TempStatus;
        }
    }

    EXIT_DFSM_OPERATION;

    if (DfsEntryPath != OrgDfsEntryPath) {
        delete [] DfsEntryPath;
    }
cleanup:
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsGetInfo returning %d\n", status);
#endif
    DFSM_TRACE_NORM(EVENT, NetrDfsGetInfo_End,
                    LOGSTATUS(status)
                    LOGWSTR(DfsEntryPath)
                    LOGWSTR(ServerName)
                    LOGWSTR(ShareName));

    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsEnum
//
//  Synopsis:   The server side implementation of the NetDfsEnum public API
//
//  Arguments:  [Level] -- The level of info struct desired.
//              [PrefMaxLen] -- Preferred maximum length of output buffer.
//                      0xffffffff means no limit.
//              [DfsEnum] -- DFS_INFO_ENUM_STRUCT pointer where the info
//                      structs will be returned.
//              [ResumeHandle] -- If 0, the enumeration will begin from the
//                      start. On return, the resume handle will be an opaque
//                      cookie that can be passed in on subsequent calls to
//                      resume the enumeration.
//
//  Returns:    [NERR_Success] -- Successfully retrieved info.
//
//              [NERR_DfsInternalCorruption] -- Internal Dfs database is
//                      corrupt.
//
//              [ERROR_INVALID_PARAMETER] -- DfsEnum or ResumeHandle were
//                      NULL on entry.
//
//              [ERROR_INVALID_LEVEL] -- If Level != 1,2, 4 or 200
//
//              [ERROR_NO_MORE_ITEMS] -- If nothing more to enumerate based
//                      on *ResumeHandle value.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- If we hit an out of memory
//                      condition while constructing info.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsEnum(
    IN DWORD Level,
    IN DWORD PrefMaxLen,
    IN OUT LPDFS_INFO_ENUM_STRUCT DfsEnum,
    IN OUT LPDWORD ResumeHandle)
{
    NET_API_STATUS status = ERROR_SUCCESS;
    DWORD i, cEntriesToRead, cbInfoSize, cbOneInfoSize, cbTotalSize;
    LPBYTE pBuffer;

    DFSM_TRACE_NORM(EVENT, NetrDfsEnum_Start,
                    LOGSTATUS(status));

    IDfsVolInlineDebOut((DEB_TRACE, "NetrDfsEnum(L=%d)\n", Level));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsEnum(%d,0x%x)\n",
            Level,
            PrefMaxLen);
#endif

    //
    // Validate the Out parameters before we die...
    //

    if (DfsEnum == NULL ||
            DfsEnum->DfsInfoContainer.DfsInfo1Container == NULL ||
                ResumeHandle == NULL) {
#if DBG
        if (DfsSvcVerbose)
            DbgPrint("NetrDfsEnum returning ERROR_INVALID_PARAMETER\n");
#endif

        if (DfsEventLog > 1) {
            LogWriteMessage(
                NET_DFS_ENUM,
                ERROR_INVALID_PARAMETER,
                0,
                NULL);
        }

        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Validate the Info Level...
    //
    if (!(Level >= 1 && Level <= 4) && Level != 200) {
#if DBG
        if (DfsSvcVerbose)
            DbgPrint("NetrDfsEnum returning ERROR_INVALID_LEVEL\n");
#endif
        if (DfsEventLog > 1) {
            LogWriteMessage(
                NET_DFS_ENUM,
                ERROR_INVALID_LEVEL,
                0,
                NULL);
        }
        status = ERROR_INVALID_LEVEL;
        goto cleanup;
    }

    ENTER_DFSM_OPERATION;

    if (ulDfsManagerType == DFS_MANAGER_FTDFS)
        LdapIncrementBlob();

    //
    // Handle level 200 as a special case
    //

    if (Level == 200) {

        status = NetrDfsEnum200(
                        Level,
                        PrefMaxLen,
                        DfsEnum,
                        ResumeHandle);

        if (ulDfsManagerType == DFS_MANAGER_FTDFS)
            status = LdapDecrementBlob();

        EXIT_DFSM_OPERATION;

#if DBG
        if (DfsSvcVerbose) {
            DbgPrint("NetrDfsEnum200 returned %d\n", status);
            DbgPrint("NetrDfsEnum returning %d\n", status);
        }
#endif
        if (DfsEventLog > 1) {
            LogWriteMessage(
                NET_DFS_ENUM,
                status,
                0,
                NULL);
        }
        //return( status );
        goto cleanup;
    }

    //
    // Sanity check the ResumeHandle...
    //

    if (pDfsmStorageDirectory == NULL ||
            (*ResumeHandle) >= pDfsmStorageDirectory->GetNumEntries()) {

        if (ulDfsManagerType == DFS_MANAGER_FTDFS)
            status = LdapDecrementBlob();

        EXIT_DFSM_OPERATION;

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("NetrDfsEnum returning ERROR_NO_MORE_ITEMS\n");
#endif
        if (DfsEventLog > 1) {
            LogWriteMessage(
                NET_DFS_ENUM,
                ERROR_NO_MORE_ITEMS,
                0,
                NULL);
        }
        status = ERROR_NO_MORE_ITEMS;
        goto cleanup;

    }

    switch (Level) {
    case 1:
        cbInfoSize = sizeof(DFS_INFO_1);
        break;

    case 2:
        cbInfoSize = sizeof(DFS_INFO_2);
        break;

    case 3:
        cbInfoSize = sizeof(DFS_INFO_3);
        break;

    case 4:
        cbInfoSize = sizeof(DFS_INFO_4);
        break;

    default:
        EXIT_DFSM_OPERATION;
        status = ERROR_INVALID_LEVEL;
        goto cleanup;
    }

    if (PrefMaxLen == ~0) {

        cEntriesToRead = pDfsmStorageDirectory->GetNumEntries();

    } else {

        cEntriesToRead = min( pDfsmStorageDirectory->GetNumEntries(),
                              PrefMaxLen / cbInfoSize );

    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsEnum: cEntriesToRead = %d\n", cEntriesToRead);
#endif

    pBuffer = (LPBYTE) MIDL_user_allocate( cEntriesToRead * cbInfoSize );

    if (pBuffer == NULL) {

        if (ulDfsManagerType == DFS_MANAGER_FTDFS)
            status = LdapDecrementBlob();

        EXIT_DFSM_OPERATION;
#if DBG
        if (DfsSvcVerbose)
            DbgPrint("NetrDfsEnum returning ERROR_NOT_ENOUGH_MEMORY\n");
#endif
        if (DfsEventLog > 1) {
            LogWriteMessage(
                NET_DFS_ENUM,
                ERROR_NOT_ENOUGH_MEMORY,
                0,
                NULL);
        }
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;

    }

    //
    // Now, we sit in a loop and get the info
    //

    for (i = 0, cbTotalSize = 0, status = NERR_Success;
            (i < cEntriesToRead) &&
                (cbTotalSize < PrefMaxLen);
                        i++) {

         status = DfspGetOneEnumInfo(
                        i,
                        Level,
                        pBuffer,
                        &cbOneInfoSize,
                        ResumeHandle);
#if DBG
        if (DfsSvcVerbose)
            DbgPrint("DfspGetOneEnumInfo returned %d\n", status);
#endif

         if (status == ERROR_NO_MORE_ITEMS || status != NERR_Success)
             break;

         cbTotalSize += (cbInfoSize + cbOneInfoSize);

         cbOneInfoSize = 0;

    }

    if (status == NERR_Success || status == ERROR_NO_MORE_ITEMS) {

        DfsEnum->Level = Level;

        DfsEnum->DfsInfoContainer.DfsInfo1Container->EntriesRead = i;

        if (i > 0) {

            DfsEnum->DfsInfoContainer.DfsInfo1Container->Buffer =
                (LPDFS_INFO_1) pBuffer;

            status = ERROR_SUCCESS;

        } else {

            DfsEnum->DfsInfoContainer.DfsInfo1Container->Buffer = NULL;

            MIDL_user_free( pBuffer );

        }

    } else {

        for (; i > 0; i--) {

            DfspFreeOneEnumInfo(i-1, Level, pBuffer);

            //
            // 333596.  Fix memory leak.
            //
            MIDL_user_free( pBuffer );

        }

    }

    if (ulDfsManagerType == DFS_MANAGER_FTDFS)
        status = LdapDecrementBlob();

    EXIT_DFSM_OPERATION;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsEnum returning %d\n", status);
#endif

    if (DfsEventLog > 1) {
        LogWriteMessage(
            NET_DFS_ENUM,
            status,
            0,
            NULL);
    }
cleanup:

    DFSM_TRACE_NORM(EVENT, NetrDfsEnum_End,
                    LOGSTATUS(status));

    return( status );
}

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsEnum200
//
//  Synopsis:   Handles level 200 for NetrDfsEnum, server-side implementation
//
//  Arguments:  [Level] -- The level of info struct desired.
//              [PrefMaxLen] -- Preferred maximum length of output buffer.
//                      0xffffffff means no limit.
//              [DfsEnum] -- DFS_INFO_ENUM_STRUCT pointer where the info
//                      structs will be returned.
//              [ResumeHandle] -- If 0, the enumeration will begin from the
//                      start. On return, the resume handle will be an opaque
//                      cookie that can be passed in on subsequent calls to
//                      resume the enumeration.
//
//  Returns:    [NERR_Success] -- Successfully retrieved info.
//
//              [NERR_DfsInternalCorruption] -- Internal Dfs database is
//                      corrupt.
//
//              [ERROR_INVALID_PARAMETER] -- DfsEnum or ResumeHandle were
//                      NULL on entry.
//
//              [ERROR_INVALID_LEVEL] -- If Level != 200
//
//              [ERROR_NO_MORE_ITEMS] -- If nothing more to enumerate based
//                      on *ResumeHandle value.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- If we hit an out of memory
//                      condition while constructing info.
//
//-----------------------------------------------------------------------------
NET_API_STATUS
NetrDfsEnum200(
    IN DWORD Level,
    IN DWORD PrefMaxLen,
    IN OUT LPDFS_INFO_ENUM_STRUCT DfsEnum,
    IN OUT LPDWORD ResumeHandle)
{
    NET_API_STATUS status = ERROR_SUCCESS;
    ULONG i;
    ULONG cEntriesToRead;
    ULONG cEntriesRead;
    ULONG cbInfoSize;
    ULONG cbThisInfoSize;
    ULONG cbTotalSize;
    ULONG cList;
    LPWSTR *List = NULL;
    PDFS_INFO_200 pDfsInfo200;
    PBYTE pBuffer;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsEnum200(%d,%d)\n", Level, PrefMaxLen);
#endif

    if (Level != 200) {
        status = ERROR_INVALID_LEVEL;
        DFSM_TRACE_HIGH(ERROR, NetrDfsEnum200_Error1, LOGSTATUS(status));
        goto AllDone;
    }

    if (pwszDomainName == NULL) {
        status = ERROR_DOMAIN_CONTROLLER_NOT_FOUND;
        DFSM_TRACE_HIGH(ERROR, NetrDfsEnum200_Error2, LOGSTATUS(status));
        goto AllDone;
    }

    cbInfoSize = sizeof(DFS_INFO_200);

    //
    // Get the list of FtDfs roots in the domain
    //
    status = DfsGetFtServersFromDs(
                    NULL,
                    pwszDomainName,
                    NULL,
                    &List);

    IDfsVolInlineDebOut((DEB_TRACE, "DfsGetFtServersFromDs returned %d\n", status));

    if (status != ERROR_SUCCESS)
        goto AllDone;

    if (List == NULL) {
        status =  ERROR_NO_MORE_ITEMS;
        DFSM_TRACE_HIGH(ERROR, NetrDfsEnum200_Error3, LOGSTATUS(status));
        goto AllDone;
    }

    //
    // Build the results array
    //
    if (status == NOERROR) {

        status = NERR_Success;

        //
        // Count # entries returned
        //
        for (cList = 0; List[cList]; cList++) {
            NOTHING;
        }

#if DBG
        if (DfsSvcVerbose) {
            DbgPrint("List has %d items\n", cList);
            for (i = 0; i < cList; i++)
                DbgPrint("%d: %ws\n", i, List[i]);
         }
#endif

        if (*ResumeHandle >= cList) {
            status =  ERROR_NO_MORE_ITEMS;
            DFSM_TRACE_HIGH(ERROR, NetrDfsEnum200_Error4, LOGSTATUS(status));
            goto AllDone;

        }

        //
        // Size & allocate the results array
        //
        if (PrefMaxLen == ~0) {

            cEntriesToRead = cList;

        } else {

            cEntriesToRead = min(cList, PrefMaxLen / cbInfoSize);

        }

        pBuffer = (LPBYTE) MIDL_user_allocate(cEntriesToRead * cbInfoSize);

        if (pBuffer == NULL) {

            status = ERROR_NOT_ENOUGH_MEMORY;
            DFSM_TRACE_HIGH(ERROR, NetrDfsEnum200_Error5, LOGSTATUS(status));

        }

    }

    //
    // Load the results array, starting at the resume handle
    //
    if (status == NERR_Success) {

        pDfsInfo200 = (LPDFS_INFO_200)pBuffer;
        cbTotalSize = cEntriesRead = 0;

        for (i = *ResumeHandle; (i < cEntriesToRead) && (status == NERR_Success); i++) {

            cbThisInfoSize = (wcslen(List[i]) + 1) * sizeof(WCHAR);

            //
            // Quit if this element would cause us to exceed PrefmaxLen
            //
            if (cbTotalSize + cbInfoSize + cbThisInfoSize > PrefMaxLen) {

                break;

            }

            pDfsInfo200->FtDfsName = (LPWSTR) MIDL_user_allocate(cbThisInfoSize);

            if (pDfsInfo200 != NULL) {

                wcscpy(pDfsInfo200->FtDfsName, List[i]);
                cbTotalSize += cbInfoSize + cbThisInfoSize;

            } else {

                status = ERROR_NOT_ENOUGH_MEMORY;
                DFSM_TRACE_HIGH(ERROR, NetrDfsEnum200_Error6, LOGSTATUS(status));

            }

            pDfsInfo200++;
            cEntriesRead++;

        }

        *ResumeHandle = i;

    }

    if (status == NERR_Success) {

        //
        // Everything worked
        //

        DfsEnum->Level = Level;
        DfsEnum->DfsInfoContainer.DfsInfo1Container->EntriesRead = cEntriesRead;

        if (cEntriesRead > 0) {

            DfsEnum->DfsInfoContainer.DfsInfo1Container->Buffer = (LPDFS_INFO_1) pBuffer;
            status = ERROR_SUCCESS;

        } else {

            DfsEnum->DfsInfoContainer.DfsInfo1Container->Buffer = NULL;

            MIDL_user_free( pBuffer );

        }

    } else {

        //
        // We're going to return an error, so free all the MIDL_user_allocate's
        // we made to hold FtDfsName's
        //
        for (i = cEntriesRead; i > 0; i--) {

            pDfsInfo200 = (LPDFS_INFO_200) (pBuffer + (i-1) * sizeof(DFS_INFO_200));

            if (pDfsInfo200->FtDfsName != NULL) {

                MIDL_user_free(pDfsInfo200->FtDfsName);

            }

        }

        MIDL_user_free( pBuffer );

    }

    NetApiBufferFree( List );

AllDone:

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsEnum200 returning %d\n", status);
#endif

    return status;

}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsEnumEx
//
//  Synopsis:   The DC implementation of the NetDfsEnum public API
//
//  Arguments:  [DfsName] -- The Dfs to enumerate (\\domainname\ftdfsname)
//              [Level] -- The level of info struct desired.
//              [PrefMaxLen] -- Preferred maximum length of output buffer.
//                      0xffffffff means no limit.
//              [DfsEnum] -- DFS_INFO_ENUM_STRUCT pointer where the info
//                      structs will be returned.
//              [ResumeHandle] -- If 0, the enumeration will begin from the
//                      start. On return, the resume handle will be an opaque
//                      cookie that can be passed in on subsequent calls to
//                      resume the enumeration.
//
//  Returns:    [NERR_Success] -- Successfully retrieved info.
//
//              [NERR_DfsInternalCorruption] -- Internal Dfs database is
//                      corrupt.
//
//              [ERROR_INVALID_PARAMETER] -- DfsEnum or ResumeHandle were
//                      NULL on entry.
//
//              [ERROR_INVALID_LEVEL] -- If Level != 1,2, 4 or 200
//
//              [ERROR_NO_MORE_ITEMS] -- If nothing more to enumerate based
//                      on *ResumeHandle value.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- If we hit an out of memory
//                      condition while constructing info.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsEnumEx(
    IN LPWSTR DfsName,
    IN DWORD Level,
    IN DWORD PrefMaxLen,
    IN OUT LPDFS_INFO_ENUM_STRUCT DfsEnum,
    IN OUT LPDWORD ResumeHandle)
{
    DWORD dwErr = ERROR_SUCCESS;
    DFS_VOLUME_LIST DfsVolList;
    ULONG cbBlob = 0;
    BYTE *pBlob = NULL;
    LPWSTR wszFtDfsName;

    DWORD i;
    DWORD cEntriesToRead;
    DWORD cbInfoSize;
    DWORD cbOneInfoSize;
    DWORD cbTotalSize;
    LPBYTE pBuffer;

    DFSM_TRACE_NORM(EVENT, NetrDfsEnumEx_Start,
                    LOGSTATUS(dwErr)
                    LOGWSTR(DfsName));

    IDfsVolInlineDebOut((DEB_TRACE, "NetrDfsEnumEx(%ws,%d)\n", DfsName, Level));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsEnumEx(%ws,%d,0x%x)\n",
            DfsName,
            Level,
            PrefMaxLen);
#endif

    RtlZeroMemory(&DfsVolList, sizeof(DFS_VOLUME_LIST));

    //
    // Validate the Out parameters
    //

    if (DfsEnum == NULL
            ||
        DfsEnum->DfsInfoContainer.DfsInfo1Container == NULL
            ||
        ResumeHandle == NULL
    ) {
#if DBG
        if (DfsSvcVerbose)
            DbgPrint("NetrDfsEnumEx returning ERROR_INVALID_PARAMETER\n");
#endif
        if (DfsEventLog > 1) {
            LogWriteMessage(
                NET_DFS_ENUMEX,
                ERROR_INVALID_PARAMETER,
                0,
                NULL);
        }
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Validate the Info Level...
    //
    if (!(Level >= 1 && Level <= 4) && Level != 200) {
#if DBG
        if (DfsSvcVerbose)
            DbgPrint("NetrDfsEnumEx returning ERROR_INVALID_LEVEL\n");
#endif
        if (DfsEventLog > 1) {
            LogWriteMessage(
                NET_DFS_ENUMEX,
                ERROR_INVALID_LEVEL,
                0,
                NULL);
        }
        dwErr = ERROR_INVALID_LEVEL;
        goto cleanup;
    }

    ENTER_DFSM_OPERATION;

    //
    // Handle level 200 as a special case
    //

    if (Level == 200) {

        dwErr = NetrDfsEnum200(
                        Level,
                        PrefMaxLen,
                        DfsEnum,
                        ResumeHandle);

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("NetrDfsEnum200 returned %d\n", dwErr);
#endif
        goto Cleanup;

    }

    for (wszFtDfsName = DfsName;
            *wszFtDfsName != UNICODE_PATH_SEP && *wszFtDfsName != UNICODE_NULL;
                wszFtDfsName++) {
        NOTHING;
    }

    if (*wszFtDfsName != UNICODE_PATH_SEP) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    wszFtDfsName++;

    if (*wszFtDfsName == UNICODE_NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Get blob from Ds
    //
    dwErr = DfsGetDsBlob(
                wszFtDfsName,
                pwszComputerName,
                &cbBlob,
                &pBlob);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Unserialize it
    //
    dwErr =  DfsGetVolList(
                cbBlob,
                pBlob,
                &DfsVolList);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

#if DBG
    if (DfsSvcVerbose)
        DfsDumpVolList(&DfsVolList);
#endif


    //
    // Sanity check the ResumeHandle...
    //

    if ((*ResumeHandle) >= DfsVolList.VolCount) {

        dwErr = ERROR_NO_MORE_ITEMS;
        goto Cleanup;

    }

    switch (Level) {
    case 1:
        cbInfoSize = sizeof(DFS_INFO_1);
        break;

    case 2:
        cbInfoSize = sizeof(DFS_INFO_2);
        break;

    case 3:
        cbInfoSize = sizeof(DFS_INFO_3);
        break;

    case 4:
        cbInfoSize = sizeof(DFS_INFO_4);
        break;

    default:
        ASSERT(FALSE && "Invalid Info Level");
        break;
    }

    if (PrefMaxLen == ~0) {

        cEntriesToRead = DfsVolList.VolCount;

    } else {

        cEntriesToRead = min(DfsVolList.VolCount, PrefMaxLen/cbInfoSize);

    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsEnumEx: cEntriesToRead = %d\n", cEntriesToRead);
#endif


    pBuffer = (LPBYTE) MIDL_user_allocate( cEntriesToRead * cbInfoSize );

    if (pBuffer == NULL) {

        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;

    }

    //
    // Now, we sit in a loop and get the info
    //

    for (i = 0, cbTotalSize = 0, dwErr = ERROR_SUCCESS;
            (i < cEntriesToRead) && (cbTotalSize < PrefMaxLen);
                        i++
    ) {

         dwErr = DfspGetOneEnumInfoEx(
                        &DfsVolList,
                        i,
                        Level,
                        pBuffer,
                        &cbOneInfoSize);

         if (dwErr == ERROR_NO_MORE_ITEMS || dwErr != ERROR_SUCCESS)
             break;

         cbTotalSize += cbInfoSize + cbOneInfoSize;
         cbOneInfoSize = 0;

    }

    if (dwErr == ERROR_SUCCESS || dwErr == ERROR_NO_MORE_ITEMS) {

        DfsEnum->Level = Level;
        DfsEnum->DfsInfoContainer.DfsInfo1Container->EntriesRead = cEntriesToRead;

        if (i > 0) {

            DfsEnum->DfsInfoContainer.DfsInfo1Container->Buffer = (LPDFS_INFO_1) pBuffer;
            dwErr = ERROR_SUCCESS;

        } else {

            DfsEnum->DfsInfoContainer.DfsInfo1Container->Buffer = NULL;
            MIDL_user_free( pBuffer );

        }

    } else {

        for (; i > 0; i--) {

            DfspFreeOneEnumInfo(i-1, Level, pBuffer);

        }

    }

Cleanup:

    EXIT_DFSM_OPERATION;

    if (pBlob != NULL)
        free(pBlob);

    if (DfsVolList.VolCount > 0 && DfsVolList.Volumes != NULL)
        DfsFreeVolList(&DfsVolList);

#if DBG
    if (DfsSvcVerbose & 0x80000000) {
        DbgPrint("===============\n");
        DbgPrint("Level: %d\n", DfsEnum->Level);
        DbgPrint("EntriesRead=%d\n", DfsEnum->DfsInfoContainer.DfsInfo1Container->EntriesRead);
        for (i = 0; i < DfsEnum->DfsInfoContainer.DfsInfo1Container->EntriesRead; i++) {
            if (Level == 1) {
                DbgPrint("Entry %d: %ws\n", 
                    i+1,
                    DfsEnum->DfsInfoContainer.DfsInfo1Container->Buffer[i].EntryPath);
            } else if (Level == 3) {
                DbgPrint("Entry %d: %ws\n", 
                    i+1,
                    DfsEnum->DfsInfoContainer.DfsInfo3Container->Buffer[i].EntryPath);
            }
            if (Level == 3) {
                ULONG j;
                DbgPrint("\tComment: [%ws]\n",
                    DfsEnum->DfsInfoContainer.DfsInfo3Container->Buffer[i].Comment,
                    DfsEnum->DfsInfoContainer.DfsInfo3Container->Buffer[i].State,
                    DfsEnum->DfsInfoContainer.DfsInfo3Container->Buffer[i].NumberOfStorages);
                for (j = 0;
                    j < DfsEnum->DfsInfoContainer.DfsInfo3Container->Buffer[i].NumberOfStorages;
                        j++
                ) {
                    DbgPrint("\t\t[0x%x][\\\\%ws\\%ws]\n",
                       DfsEnum->DfsInfoContainer.DfsInfo3Container->Buffer[i].Storage[j].State,
                       DfsEnum->DfsInfoContainer.DfsInfo3Container->Buffer[i].Storage[j].ServerName,
                       DfsEnum->DfsInfoContainer.DfsInfo3Container->Buffer[i].Storage[j].ShareName);
                }
            }
        }
        DbgPrint("===============\n");
    }

    if (DfsSvcVerbose)
        DbgPrint("NetrDfsEnumEx returning %d\n", dwErr);
#endif

    if (DfsEventLog > 1) {
        LogWriteMessage(
            NET_DFS_ENUMEX,
            dwErr,
            0,
            NULL);
    }
cleanup:
    DFSM_TRACE_NORM(EVENT, NetrDfsEnumEx_End,
                    LOGSTATUS(dwErr)
                    LOGWSTR(DfsName));

    return( dwErr );
}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsMove
//
//  Synopsis:   Moves a leaf volume to a different parent.
//
//  Arguments:  [DfsEntryPath] -- Current entry path of Dfs volume.
//
//              [NewEntryPath] -- New entry path of Dfs volume.
//
//  Returns:
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsMove(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR NewDfsEntryPath)
{
    NET_API_STATUS status = ERROR_NOT_SUPPORTED;
    CDfsVolume *pDfsVol = NULL;
    LPWSTR OrgDfsEntryPath = DfsEntryPath;
    LPWSTR OrgNewDfsEntryPath = NewDfsEntryPath;

    DFSM_TRACE_NORM(EVENT, NetrDfsMove_Start,
                    LOGSTATUS(status)
                    LOGWSTR(DfsEntryPath)
                    LOGWSTR(NewDfsEntryPath));

    if (!AccessCheckRpcClient())
        status = ERROR_ACCESS_DENIED;

    DFSM_TRACE_NORM(EVENT, NetrDfsMove_End,
                    LOGSTATUS(status)
                    LOGWSTR(DfsEntryPath)
                    LOGWSTR(NewDfsEntryPath));

    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsRename
//
//  Synopsis:   Moves a leaf volume to a different parent.
//
//  Arguments:  [Path] -- Current path along the entry path of a Dfs volume.
//
//              [NewPath] -- New path for current path.
//
//  Returns:
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsRename(
    IN LPWSTR Path,
    IN LPWSTR NewPath)
{
    NET_API_STATUS status = ERROR_NOT_SUPPORTED;
    CDfsVolume *pDfsVol;
    LPWSTR OrgPath = Path;
    LPWSTR OrgNewPath = NewPath;

    DFSM_TRACE_NORM(EVENT, NetrDfsRename_Start,
                    LOGSTATUS(status)
                    LOGWSTR(Path)
                    LOGWSTR(NewPath));

    if (!AccessCheckRpcClient())
        status = ERROR_ACCESS_DENIED;

    DFSM_TRACE_NORM(EVENT, NetrDfsRename_End,
                    LOGSTATUS(status)
                    LOGWSTR(Path)
                    LOGWSTR(NewPath));

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsManagerGetConfigInfo
//
//  Synopsis:   RPC Interface method that returns the config info for a
//              Dfs volume for a given server
//
//  Arguments:  [wszServer] -- Name of server requesting the info. This
//                      server is assumed to be requesting the info for
//                      verification of its local volume knowledge.
//              [wszLocalVolumeEntryPath] -- Entry path of local volume.
//              [idLocalVolume] -- The guid of the local volume.
//              [ppRelationInfo] -- The relation info is allocated and
//                      returned here.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully returning relation info
//
//              [NERR_DfsNoSuchVolume] -- Did not find LocalVolumeEntryPath
//
//              [NERR_DfsNoSuchShare] -- The server name passed in does not
//                      support this local volume.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Unable to allocate memory for info.
//
//-----------------------------------------------------------------------------

extern "C" DWORD
NetrDfsManagerGetConfigInfo(
    IN LPWSTR wszServer,
    IN LPWSTR wszLocalVolumeEntryPath,
    IN GUID idLocalVolume,
    OUT LPDFSM_RELATION_INFO *ppRelationInfo)
{
    DWORD dwErr = ERROR_SUCCESS;
    DFS_PKT_ENTRY_ID EntryId;
    DFS_PKT_RELATION_INFO DfsRelationInfo;
    CDfsVolume *pDfsVol;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsManagerGetConfigInfo(%ws,%ws)\n",
            wszServer,
            wszLocalVolumeEntryPath);
#endif

    DFSM_TRACE_NORM(EVENT, NetrDfsManagerGetConfigInfo_Start,
                    LOGSTATUS(dwErr)
                    LOGWSTR(wszServer)
                    LOGWSTR(wszLocalVolumeEntryPath));

    if (ppRelationInfo == NULL) {

        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;

    }

    ENTER_DFSM_OPERATION;

    EntryId.Uid = idLocalVolume;

    RtlInitUnicodeString( &EntryId.Prefix, wszLocalVolumeEntryPath );

    EntryId.ShortPrefix.Length = EntryId.ShortPrefix.MaximumLength = 0;
    EntryId.ShortPrefix.Buffer = NULL;

    dwErr = GetPktCacheRelationInfo( &EntryId, &DfsRelationInfo );

    if (dwErr == ERROR_SUCCESS) {

        //
        // Well, we have the relation info, see if this server is a valid
        // server for this volume.
        //

        dwErr = GetDfsVolumeFromPath( wszLocalVolumeEntryPath, TRUE, &pDfsVol );

        if (dwErr == ERROR_SUCCESS) {

            if ( pDfsVol->IsValidService(wszServer) ) {

                dwErr = DfspAllocateRelationInfo(
                            &DfsRelationInfo,
                            ppRelationInfo );

            } else {

                dwErr = NERR_DfsNoSuchShare;

            }

            pDfsVol->Release();

        } else {

            dwErr = NERR_DfsNoSuchVolume;

        }

        DeallocateCacheRelationInfo( DfsRelationInfo );

    } else {

        dwErr = NERR_DfsInternalError;

    }

    EXIT_DFSM_OPERATION;
cleanup:
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsManagerGetConfigInfo returning %d\n", dwErr);
#endif
    DFSM_TRACE_NORM(EVENT, NetrDfsManagerGetConfigInfo_End,
                    LOGSTATUS(dwErr)
                    LOGWSTR(wszServer)
                    LOGWSTR(wszLocalVolumeEntryPath));

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsManagerSendSiteInfo
//
//  Synopsis:   RPC Interface method that reports the site information for a
//              Dfs storage server.
//
//  Arguments:  [wszServer] -- Name of server sending the info.
//              [pSiteInfo] -- The site info is here.
//
//  Returns:    [ERROR_SUCCESS] -- Successfull
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Unable to allocate memory for info.
//
//-----------------------------------------------------------------------------

extern "C" DWORD
NetrDfsManagerSendSiteInfo(
    IN LPWSTR wszServer,
    IN LPDFS_SITELIST_INFO pSiteInfo)
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG i;

    DFSM_TRACE_NORM(EVENT, NetrDfsManagerSendSiteInfo_Start,
                    LOGSTATUS(dwErr)
                    LOGWSTR(wszServer));

    if (!AccessCheckRpcClient()) {
        dwErr = ERROR_ACCESS_DENIED;
        goto cleanup;
    }

    ENTER_DFSM_OPERATION;

    //
    // Update the Site table
    //

    IDfsVolInlineDebOut((DEB_TRACE, "NetrDfsGetInfo()\n", 0));

    pDfsmSites->AddRef();
    dwErr = pDfsmSites->AddOrUpdateSiteInfo(
                    wszServer,
                    pSiteInfo->cSites,
                    &pSiteInfo->Site[0]);
    pDfsmSites->Release();

    EXIT_DFSM_OPERATION;
cleanup:
    DFSM_TRACE_NORM(EVENT, NetrDfsManagerSendSiteInfo_End,
                    LOGSTATUS(dwErr)
                    LOGWSTR(wszServer));

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsManagerInitialize
//
//  Synopsis:   Reinitializes the service
//
//  Arguments:  [ServerName] -- Name of server
//              [Flags] -- Flags for the operation
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory condition.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsManagerInitialize(
    IN LPWSTR ServerName,
    IN DWORD  Flags)
{
    DWORD dwErr = ERROR_SUCCESS;

    DFSM_TRACE_NORM(EVENT, NetrDfsManagerInitialize_Start,
                    LOGSTATUS(dwErr)
                    LOGWSTR(ServerName));
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsManagerInitialize(%ws,%d)\n",
            ServerName,
            Flags);
#endif

    if (!AccessCheckRpcClient()) {
        dwErr = ERROR_ACCESS_DENIED;
        goto cleanup;
    }

    ENTER_DFSM_OPERATION;

#if DBG
    GetDebugSwitches();
#endif
    GetConfigSwitches();

    //
    // If we are a DomDfs, simply doing the LdapIncrementBlob will
    // be enough.  If the DS blob has changed, then we will note that
    // and fully reinitialize everything.
    //

    if (ulDfsManagerType == DFS_MANAGER_FTDFS)  {
        LdapIncrementBlob();
        dwErr = LdapDecrementBlob();
    } else {
        if (pDfsmStorageDirectory != NULL)
            delete pDfsmStorageDirectory;
        if (pDfsmSites != NULL)
            delete pDfsmSites;
        pDfsmSites = new CSites(LDAP_VOLUMES_DIR SITE_ROOT, &dwErr);
        pDfsmStorageDirectory = new CStorageDirectory( &dwErr );
        DfsmMarkStalePktEntries();
        InitializeDfsManager();
        DfsmFlushStalePktEntries();
    }

    DfsmPktFlushCache();

    EXIT_DFSM_OPERATION;

    dwErr = NERR_Success;
cleanup:
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NetrDfsManagerInitialize returning %d\n", dwErr);
#endif
    DFSM_TRACE_NORM(EVENT, NetrDfsManagerInitialize_End,
                    LOGSTATUS(dwErr)
                    LOGWSTR(ServerName));

    return dwErr;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspGetOneEnumInfo
//
//  Synopsis:   Helper routine to read one info dfs info into an enum array.
//
//  Arguments:  [i] -- Index of the array element to fill.
//              [Level] -- Info Level to fill with.
//              [InfoArray] -- The array to use; only the ith member will be
//                      filled.
//              [InfoSize] -- On successful return, size in bytes of info.
//              [ResumeHandle] -- Handle to indicate the information to fill.
//
//  Returns:
//
//-----------------------------------------------------------------------------

NET_API_STATUS
DfspGetOneEnumInfo(
    DWORD i,
    DWORD Level,
    LPBYTE InfoArray,
    LPDWORD InfoSize,
    LPDWORD ResumeHandle)
{
    NET_API_STATUS status;
    LPWSTR wszObject;
    CDfsVolume *pDfsVolume;
    LPDFS_INFO_3  pDfsInfo;

    //
    // Get the object name for the object indicated in ResumeHandle. i == 0
    // means that this is the first time this function is being called for
    // this enum, so we are forced to get object name by index. If i > 0, then
    // we can get the object name by using the "get next" capability of
    // CStorageDirectory::GetObjectByIndex.
    //

    if (pDfsmStorageDirectory == NULL) {

        return(ERROR_NO_MORE_ITEMS);

    }

    if (i == 0) {

        status = pDfsmStorageDirectory->GetObjectByIndex(*ResumeHandle, &wszObject);

    } else {

        status = pDfsmStorageDirectory->GetObjectByIndex((DWORD)~0, &wszObject);

    }

    if (status != ERROR_SUCCESS)
        return( status );

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfspGetOneEnumInfo(%d,%d)\n", i, Level);
#endif

    pDfsVolume = new CDfsVolume();

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("  pDfsVolume = 0x%x\n", pDfsVolume);
#endif

    if (pDfsVolume != NULL) {

        status = pDfsVolume->Load(wszObject, 0);

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("  pDfsVolume->Load returned %d\n", status);
#endif

        if (status == ERROR_SUCCESS) {

            switch (Level) {
            case 1:
                pDfsInfo = (LPDFS_INFO_3) (InfoArray + i * sizeof(DFS_INFO_1));
                break;

            case 2:
                pDfsInfo = (LPDFS_INFO_3) (InfoArray + i * sizeof(DFS_INFO_2));
                break;

            case 3:
                pDfsInfo = (LPDFS_INFO_3) (InfoArray + i * sizeof(DFS_INFO_3));
                break;

            case 4:
                pDfsInfo = (LPDFS_INFO_3) (InfoArray + i * sizeof(DFS_INFO_4));
                break;

            default:
                ASSERT( FALSE && "Invalid Info Level" );
                break;

            }

            status = pDfsVolume->GetNetInfo(Level, pDfsInfo, InfoSize);

#if DBG
            if (DfsSvcVerbose)
                DbgPrint("  pDfsVolume->GetNetInfo returned %d\n", status);
#endif

        }

        pDfsVolume->Release();

        if (status == ERROR_SUCCESS) {

            (*ResumeHandle)++;

        } else {

            status = NERR_DfsInternalCorruption;

            DFSM_TRACE_HIGH(ERROR, DfspGetOneEnumInfo_Error1, LOGSTATUS(status));
        }

    } else {

        status = ERROR_NOT_ENOUGH_MEMORY;
        DFSM_TRACE_HIGH(ERROR, DfspGetOneEnumInfo_Error2, LOGSTATUS(status));

    }

    delete [] wszObject;

    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfspGetOneEnumInfoEx
//
//  Synopsis:   Helper routine to read one info dfs info into an enum array.
//
//  Arguments:  [pDfsVolList] pointer to DFS_VOLUME_LIST to use
//              [i] -- Index of the array element to fill.
//              [Level] -- Info Level to fill with.
//              [InfoArray] -- The array to use; only the ith member will be
//                      filled.
//              [InfoSize] -- On successful return, size in bytes of info.
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
DfspGetOneEnumInfoEx(
    PDFS_VOLUME_LIST pDfsVolList,
    DWORD i,
    DWORD Level,
    LPBYTE InfoArray,
    LPDWORD InfoSize)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR wszObject;
    LPDFS_INFO_3  pDfsInfo;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfspGetOneEnumInfoEx(%d,%d)\n", i, Level);
#endif

    if (pDfsVolList == NULL || i >= pDfsVolList->VolCount) {

        dwErr = ERROR_NO_MORE_ITEMS;
        goto AllDone;

    }

    switch (Level) {
    case 1:
        pDfsInfo = (LPDFS_INFO_3) (InfoArray + i * sizeof(DFS_INFO_1));
        break;

    case 2:
        pDfsInfo = (LPDFS_INFO_3) (InfoArray + i * sizeof(DFS_INFO_2));
        break;

    case 3:
        pDfsInfo = (LPDFS_INFO_3) (InfoArray + i * sizeof(DFS_INFO_3));
        break;

    case 4:
        pDfsInfo = (LPDFS_INFO_3) (InfoArray + i * sizeof(DFS_INFO_4));
        break;

    default:
        // 447489. fix prefix bug.
        return ERROR_INVALID_LEVEL;

    }

    dwErr = GetNetInfoEx(&pDfsVolList->Volumes[i], Level, pDfsInfo, InfoSize);

AllDone:

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfspGetOneEnumInfoEx returning %d\n", dwErr);
#endif

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspFreeOneEnumInfo
//
//  Synopsis:   Worker routine to free one DFS_INFO_x struct as allocated
//              by DfspGetOneEnumInfo. Useful for cleanup in case of error.
//
//  Arguments:  [Idx] -- Index of the array element to free.
//              [Level] -- Level of info to free.
//              [InfoArray] -- The array to use; only the members of the ith
//                      element will be freed.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfspFreeOneEnumInfo(
    DWORD Idx,
    DWORD Level,
    LPBYTE InfoArray)
{
    LPDFS_INFO_3 pDfsInfo;
    LPDFS_INFO_4 pDfsInfo4;
    ULONG i;

    switch (Level) {
    case 1:
        pDfsInfo = (LPDFS_INFO_3) (InfoArray + Idx * sizeof(DFS_INFO_1));
        break;

    case 2:
        pDfsInfo = (LPDFS_INFO_3) (InfoArray + Idx * sizeof(DFS_INFO_2));
        break;

    case 3:
        pDfsInfo = (LPDFS_INFO_3) (InfoArray + Idx * sizeof(DFS_INFO_3));
        break;

    case 4:
        pDfsInfo4 = (LPDFS_INFO_4) (InfoArray + Idx * sizeof(DFS_INFO_4));
        break;

    default:
        //
        // 447480. prefix bug. return if unknown level.
        return;

    }

    if (Level == 4) {

        if (pDfsInfo4->EntryPath != NULL) {
            MIDL_user_free(pDfsInfo4->EntryPath);
        }

        if (pDfsInfo4->Comment != NULL) {
            MIDL_user_free(pDfsInfo4->Comment);
        }

        if (pDfsInfo4->Storage != NULL) {

            for (i = 0; i < pDfsInfo4->NumberOfStorages; i++) {

                if (pDfsInfo4->Storage[i].ServerName != NULL)
                    MIDL_user_free(pDfsInfo4->Storage[i].ServerName);

                if (pDfsInfo4->Storage[i].ShareName != NULL)
                    MIDL_user_free(pDfsInfo4->Storage[i].ShareName);

            }

            MIDL_user_free(pDfsInfo4->Storage);

        }

        return;

    }

    //
    // Cleanup the Level 1 stuff.
    //

    if (pDfsInfo->EntryPath != NULL)
        MIDL_user_free(pDfsInfo->EntryPath);

    //
    // Cleanup the Level 2 stuff if needed.
    //

    if (Level > 1 && pDfsInfo->Comment != NULL)
        MIDL_user_free(pDfsInfo->Comment);

    //
    // Cleanup the Level 3 stuff if needed.
    //

    if (Level > 2 && pDfsInfo->Storage != NULL) {

        for (i = 0; i < pDfsInfo->NumberOfStorages; i++) {

            if (pDfsInfo->Storage[i].ServerName != NULL)
                MIDL_user_free(pDfsInfo->Storage[i].ServerName);

            if (pDfsInfo->Storage[i].ShareName != NULL)
                MIDL_user_free(pDfsInfo->Storage[i].ShareName);

        }

        MIDL_user_free(pDfsInfo->Storage);

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsManagerCreateVolumeObject
//
//  Synopsis:   Bootstrap routine to create a volume object directly (ie,
//              without having to call DfsCreateChildVolume on a parent
//              volume)
//
//  Arguments:  [pwszObjectName] -- Name of the volume object.
//              [pwszPrefix] -- Entry Path of dfs volume.
//              [pwszServer] -- Name of server supporting dfs volume.
//              [pwszShare] -- Name of share on server supporting dfs volume.
//              [pwszComment] -- Comment for dfs volume.
//              [guidVolume] -- Id of dfs volume.
//
//  Returns:
//
//-----------------------------------------------------------------------------

extern "C" DWORD
DfsManagerCreateVolumeObject(
    IN LPWSTR   pwszObjectName,
    IN LPWSTR   pwszPrefix,
    IN LPWSTR   pwszServer,
    IN LPWSTR   pwszShare,
    IN LPWSTR   pwszComment,
    IN GUID     *guidVolume)
{
    DWORD dwErr;
    DWORD dwStatus;
    CDfsVolume *pCDfsVolume;
    DFS_REPLICA_INFO replicaInfo;
    LPDFS_SITELIST_INFO pSiteInfo;

    pCDfsVolume = new CDfsVolume();

    if (pCDfsVolume != NULL) {

        replicaInfo.ulReplicaType = DFS_STORAGE_TYPE_DFS;
        replicaInfo.ulReplicaState = DFS_STORAGE_STATE_ONLINE;
        replicaInfo.pwszServerName = pwszServer;
        replicaInfo.pwszShareName = pwszShare;

        dwErr = pCDfsVolume->CreateObject(
                    pwszObjectName,
                    pwszPrefix,
                    DFS_VOL_TYPE_DFS | DFS_VOL_TYPE_REFERRAL_SVC,
                    &replicaInfo,
                    pwszComment,
                    guidVolume);

        //
        // Create the site table object in the DS or registry
        //
        if (ulDfsManagerType == DFS_MANAGER_FTDFS) {

            dwErr = LdapCreateObject(
                        LDAP_VOLUMES_DIR SITE_ROOT);

        } else {

            // registry stuff instead

            dwErr = RegCreateObject(
                        VOLUMES_DIR SITE_ROOT);
        }

        if (dwErr == ERROR_SUCCESS) {

            //
            // Find out the list of covered sites
            // We continue even if this fails (standalone, no TCP/IP)
            //
            pSiteInfo = NULL;

            dwStatus = I_NetDfsManagerReportSiteInfo(
                        pwszServer,
                        &pSiteInfo);

            DFSM_TRACE_ERROR_HIGH(dwStatus, ALL_ERROR, DfsManagerCreateVolumeObject_Error_I_NetDfsManagerReportSiteInfo,
                                  LOGSTATUS(dwStatus)
                                  LOGWSTR(pwszObjectName)
                                  LOGWSTR(pwszPrefix)
                                  LOGWSTR(pwszServer)
                                  LOGWSTR(pwszShare));
            //
            // Create a SiteTable object with those sites
            //

            if (dwStatus == ERROR_SUCCESS) {

                if (pSiteInfo->cSites > 0) {

                    //
                    // AddRef the site table, then put the site info in, then
                    // Release it.  This will cause it to be written to the
                    // appropriate store (ldap or registry).
                    //

                    pDfsmSites->AddRef();

                    pDfsmSites->AddOrUpdateSiteInfo(
                                    pwszServer,
                                    pSiteInfo->cSites,
                                    &pSiteInfo->Site[0]);

                    pDfsmSites->Release();

                }

                NetApiBufferFree(pSiteInfo);

            }

        }

        pCDfsVolume->Release();

    } else {

        dwErr = ERROR_OUTOFMEMORY;

    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsManagerSetDcName
//
//  Synopsis:   Sets the DC we should first attempt to connect to.
//
//  Arguments:  [pwszDCName] -- Name of the DC
//
//  Returns:    ERROR_SUCCESS
//
//-----------------------------------------------------------------------------

extern "C" DWORD
DfsManagerSetDcName(
    IN LPWSTR pwszDCName)
{
    if (pwszDSMachineName != NULL) {
        if (wcscmp(pwszDSMachineName, pwszDCName) != 0) {
            wcscpy(wszDSMachineName, pwszDCName);
            pwszDSMachineName = wszDSMachineName;
            if (pLdapConnection != NULL) {
                if (DfsSvcLdap)
                    DbgPrint("DfsManagerSetDcName:ldap_unbind()\n");
                ldap_unbind(pLdapConnection);
                pLdapConnection = NULL;
            }
        }
    } else {
        wcscpy(wszDSMachineName, pwszDCName);
        pwszDSMachineName = wszDSMachineName;
    }

    return ERROR_SUCCESS;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsManagerAddService
//
//  Synopsis:   Bootstrap routine for adding a service to an existing volume
//              object. Used to set up additional root servers in an FTDfs
//              setup.
//
//  Arguments:  [pwszFullObjectName] -- Name of the volume object.
//              [pwszServer] -- Name of server to add.
//              [pwszShare] -- Name of share.
//
//  Returns:
//
//-----------------------------------------------------------------------------

extern "C" DWORD
DfsManagerAddService(
    IN LPWSTR pwszFullObjectName,
    IN LPWSTR pwszServer,
    IN LPWSTR pwszShare,
    OUT GUID *guidVolume)
{
    DWORD dwErr;
    DWORD dwStatus;
    CDfsVolume *pCDfsVolume;
    DFS_REPLICA_INFO replicaInfo;
    LPDFS_SITELIST_INFO pSiteInfo;

    pCDfsVolume = new CDfsVolume();

    if (pCDfsVolume != NULL) {

        dwErr = pCDfsVolume->Load( pwszFullObjectName, 0 );

        if (dwErr == ERROR_SUCCESS) {

            replicaInfo.ulReplicaType = DFS_STORAGE_TYPE_DFS;
            replicaInfo.ulReplicaState = DFS_STORAGE_STATE_ONLINE;
            replicaInfo.pwszServerName = pwszServer;
            replicaInfo.pwszShareName = pwszShare;

            dwErr = pCDfsVolume->AddReplicaToObj( &replicaInfo );

            if (dwErr == ERROR_SUCCESS) {

                pCDfsVolume->GetObjectID( guidVolume );

            }
        }

        if (dwErr == ERROR_SUCCESS) {

            //
            // Find out the list of covered sites
            // We continue even if this fails (standalone, no TCP/IP)
            //
            pSiteInfo = NULL;

            dwStatus = I_NetDfsManagerReportSiteInfo(
                        pwszServer,
                        &pSiteInfo);

            DFSM_TRACE_ERROR_HIGH(dwStatus, ALL_ERROR, DfsManagerAddService_Error_I_NetDfsManagerReportSiteInfo,
                                  LOGSTATUS(dwStatus)
                                  LOGWSTR(pwszFullObjectName)
                                  LOGWSTR(pwszServer)
                                  LOGWSTR(pwszShare));
            //
            // Create a SiteTable object with those sites
            //

            if (dwStatus == ERROR_SUCCESS) {

                if (pSiteInfo->cSites > 0) {

                    //
                    // AddRef the site table, then put the site info in, then
                    // Release it.  This will cause it to be written to the
                    // appropriate store (ldap or registry).
                    //

                    pDfsmSites->AddRef();

                    pDfsmSites->AddOrUpdateSiteInfo(
                                    pwszServer,
                                    pSiteInfo->cSites,
                                    &pSiteInfo->Site[0]);

                    pDfsmSites->Release();

                }

                NetApiBufferFree(pSiteInfo);

            }

        }

        pCDfsVolume->Release();

    } else {

        dwErr = ERROR_OUTOFMEMORY;

    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsManagerRemoveService
//
//  Synopsis:   Bootstrap routine for removing a service from an existing
//              volume object. Used to remove root servers in an FTDfs
//              setup.
//
//  Arguments:  [pwszFullObjectName] -- Name of the volume object.
//              [pwszServer] -- Name of server to remove.
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
DfsManagerRemoveService(
    IN LPWSTR pwszFullObjectName,
    IN LPWSTR pwszServer)
{
    DWORD dwErr;
    CDfsVolume *pCDfsVolume;

    pCDfsVolume = new CDfsVolume();

    if (pCDfsVolume != NULL) {

        dwErr = pCDfsVolume->Load( pwszFullObjectName, 0 );

        if (dwErr == ERROR_SUCCESS) {

            dwErr = pCDfsVolume->RemoveReplicaFromObj( pwszServer );

        }

        pCDfsVolume->Release();

    } else {

        dwErr = ERROR_OUTOFMEMORY;

    }

    return( dwErr );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsManagerRemoveServiceForced
//
//  Synopsis:   Routine for removing a service from an existing
//              volume object in the DS. Used to remove root servers in an FTDfs
//              setup, even if the server is not up.
//
//  Arguments:  [wszServerName] -- Name of server to remove
//              [wszDCName] -- Name of DC to use
//              [wszFtDfsName] -- Name of the FtDfs
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
DfsManagerRemoveServiceForced(
    LPWSTR wszServerName,
    LPWSTR wszDCName,
    LPWSTR wszFtDfsName)
{
    DWORD dwErr = ERROR_SUCCESS;
    DFS_VOLUME_LIST DfsVolList;
    ULONG cbBlob = 0;
    BYTE *pBlob = NULL;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsManagerRemoveServiceForced(%ws,%ws,%ws)\n",
                        wszServerName,
                        wszDCName,
                        wszFtDfsName);
#endif

    RtlZeroMemory(&DfsVolList, sizeof(DFS_VOLUME_LIST));

    //
    // Get blob from Ds
    //
    dwErr = DfsGetDsBlob(
                wszFtDfsName,
                wszDCName,
                &cbBlob,
                &pBlob);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Unserialize it
    //
    dwErr =  DfsGetVolList(
                cbBlob,
                pBlob,
                &DfsVolList);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Free the blob
    //
    free(pBlob);
    pBlob = NULL;

#if DBG
    if (DfsSvcVerbose)
        DfsDumpVolList(&DfsVolList);
#endif

    //
    // Remove the root/server/machine
    //
    dwErr = DfsRemoveRootReplica(&DfsVolList, wszServerName);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

#if DBG
    if (DfsSvcVerbose)
        DfsDumpVolList(&DfsVolList);
#endif

    //
    // Serialize it
    //
    dwErr = DfsPutVolList(
                &cbBlob,
                &pBlob,
                &DfsVolList);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Update the DS
    //
    dwErr = DfsPutDsBlob(
                wszFtDfsName,
                wszDCName,
                cbBlob,
                pBlob);

    //
    // Free the volume list we created
    //
    DfsFreeVolList(&DfsVolList);

Cleanup:
    if (pBlob != NULL)
        free(pBlob);

    if (DfsVolList.VolCount > 0 && DfsVolList.Volumes != NULL)
        DfsFreeVolList(&DfsVolList);

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsManagerRemoveServiceForced returning %d\n", dwErr);
#endif

    return( dwErr );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfspAllocateRelationInfo
//
//  Synopsis:   Allocates and fills a RPC compliant DFSM_RELATION_INFO struct
//
//  Arguments:  [pDfsRelationInfo] -- The DFS_PKT_RELATION_INFO to use as a
//                      the source.
//              [ppRelationInfo] -- On successful return, pointer to allocated
//                      DFSM_RELATION_INFO.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully returning RelationInfo
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Unable to allocate RelationInfo
//
//-----------------------------------------------------------------------------

DWORD
DfspAllocateRelationInfo(
    IN PDFS_PKT_RELATION_INFO pDfsRelationInfo,
    OUT LPDFSM_RELATION_INFO *ppRelationInfo)
{
    LPDFSM_RELATION_INFO pRelationInfo;
    DWORD i, cbSize, dwErr;
    LPDFSM_ENTRY_ID pEntryId;
    LPWSTR pwszEntryPath;

    cbSize = sizeof(DFSM_RELATION_INFO);

    for (i = 0; i < pDfsRelationInfo->SubordinateIdCount; i++) {

        cbSize += sizeof(DFSM_ENTRY_ID) +
                    pDfsRelationInfo->SubordinateIdList[i].Prefix.Length +
                        sizeof(UNICODE_NULL);

    }

    pRelationInfo = (LPDFSM_RELATION_INFO) MIDL_user_allocate( cbSize );

    if (pRelationInfo != NULL) {

        pRelationInfo->cSubordinates = pDfsRelationInfo->SubordinateIdCount;

        pEntryId = &pRelationInfo->eid[0];

        pwszEntryPath = (LPWSTR)
            (((PBYTE) pRelationInfo) +
                sizeof(DFSM_RELATION_INFO) +
                    (pDfsRelationInfo->SubordinateIdCount
                        * sizeof(DFSM_ENTRY_ID)));

        for (i = 0;
                i < pDfsRelationInfo->SubordinateIdCount;
                    i++, pEntryId++) {

            pEntryId->idSubordinate =
                pDfsRelationInfo->SubordinateIdList[i].Uid;

            pEntryId->wszSubordinate = pwszEntryPath;

            CopyMemory(
                pwszEntryPath,
                pDfsRelationInfo->SubordinateIdList[i].Prefix.Buffer,
                pDfsRelationInfo->SubordinateIdList[i].Prefix.Length);

            pwszEntryPath +=
                pDfsRelationInfo->SubordinateIdList[i].Prefix.Length /
                    sizeof(WCHAR);

            *pwszEntryPath = UNICODE_NULL;

            pwszEntryPath++;

        }

        *ppRelationInfo = pRelationInfo;

        dwErr = ERROR_SUCCESS;

    } else {

        dwErr = ERROR_OUTOFMEMORY;

    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   GetDomAndComputerName
//
//  Synopsis:   Retrieves the domain and computer name of the local machine
//
//  Arguments:  [wszDomain] -- On successful return, contains name of domain.
//                      If this parameter is NULL on entry, the domain name is
//                      not returned.
//
//              [wszComputer] -- On successful return, contains name of
//                      computer. If this parameter is NULL on entry, the
//                      computer name is not returned.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully returning names.
//
//              Win32 Error from calling NetWkstaGetInfo
//
//-----------------------------------------------------------------------------

DWORD
GetDomAndComputerName(
    LPWSTR wszDomain OPTIONAL,
    LPWSTR wszComputer OPTIONAL,
    PDFS_NAME_CONVENTION pNameType) 
{
    DWORD dwErrNetBios = ERROR_SUCCESS;
    DWORD dwErrDns = ERROR_SUCCESS;
    PWKSTA_INFO_100 wkstaInfo = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pPrimaryDomainInfo = NULL;
    DWORD Idx = 0;
    DFS_NAME_CONVENTION NameType = *pNameType;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("GetDomAndComputerName(0x%x,0x%x,%ws)\n",
            wszDomain,
            wszComputer,
            NameType == DFS_NAMETYPE_NETBIOS ? L"DFS_NAMETYPE_NETBIOS" :
                NameType == DFS_NAMETYPE_DNS ? L"DFS_NAMETYPE_DNS" :
                    L"DFS_NAMETYPE_EITHER");
#endif

    //
    // Force Netbios only unless DfsDnsConfig != 0
    //
    if (DfsDnsConfig == 0) {
        NameType = DFS_NAMETYPE_NETBIOS;
    }

    if (NameType == DFS_NAMETYPE_NETBIOS || NameType == DFS_NAMETYPE_EITHER) {

        dwErrNetBios = NetWkstaGetInfo( NULL, 100, (LPBYTE *) &wkstaInfo );

        if (dwErrNetBios == ERROR_SUCCESS) {

            if (wszDomain)
                wcscpy(wszDomain, wkstaInfo->wki100_langroup);

            if (wszComputer)
                wcscpy(wszComputer, wkstaInfo->wki100_computername);

            NetApiBufferFree( wkstaInfo );

        }

        if (dwErrNetBios == ERROR_SUCCESS)
            *pNameType = DFS_NAMETYPE_NETBIOS;

        if (NameType == DFS_NAMETYPE_NETBIOS) {
#if DBG
            if (DfsSvcVerbose)
                DbgPrint("GetDomAndComputerName:NETBIOS:%ws,%ws\n", wszDomain, wszComputer);
#endif
            return dwErrNetBios;
        }

    }

    if (NameType == DFS_NAMETYPE_DNS || NameType == DFS_NAMETYPE_EITHER) {

        if (wszDomain) {
            //
            // Get our machine name and type/role.
            //
            dwErrDns = DsRoleGetPrimaryDomainInformation(
                        NULL,
                        DsRolePrimaryDomainInfoBasic,
                        (PBYTE *)&pPrimaryDomainInfo);

            if (dwErrDns == ERROR_SUCCESS) {
                if (pPrimaryDomainInfo->DomainNameDns != NULL) {
                    if (wcslen(pPrimaryDomainInfo->DomainNameDns) < MAX_PATH) {
                        wcscpy(wszDomain, pPrimaryDomainInfo->DomainNameDns);
                    } else {
                        dwErrDns = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
            if (pPrimaryDomainInfo != NULL) {
                DsRoleFreeMemory(pPrimaryDomainInfo);
                pPrimaryDomainInfo = NULL;
            }
       }

       if (wszComputer && dwErrDns == ERROR_SUCCESS) {
            Idx = MAX_PATH;
            if (!GetComputerNameEx(
                        ComputerNameDnsFullyQualified,
                        wszComputer,
                        &Idx))
                dwErrDns = GetLastError();
        }

        if (dwErrDns == ERROR_SUCCESS)
            *pNameType = DFS_NAMETYPE_DNS;

        if (NameType == DFS_NAMETYPE_DNS) {
#if DBG
            if (DfsSvcVerbose)
                DbgPrint("GetDomAndComputerName:DNS:%ws,%ws\n", wszDomain, wszComputer);
#endif
            return dwErrDns;
        }
    }

    //
    // NameType must be DFS_NAMETYPE_EITHER
    //

    if (*pNameType == DFS_NAMETYPE_DNS) {
#if DBG
        if (DfsSvcVerbose)
            DbgPrint("GetDomAndComputerName:EITHER(DNS)%ws,%ws\n", wszDomain, wszComputer);
#endif
        return  dwErrDns;
    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("GetDomAndComputerName:EITHER(NETBIOS)%ws,%ws\n", wszDomain, wszComputer);
#endif

    return dwErrNetBios;

}


// ====================================================================
//                MIDL allocate and free
// ====================================================================

PVOID
MIDL_user_allocate(size_t len)
{
    return malloc(len);
}

VOID
MIDL_user_free(void * ptr)
{
    free(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\netdfs_s_stub.c ===
#include <netdfs_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\log.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1999, Microsoft Corporation
//
//  File:       log.cxx
//
//  Contents:   Event logging for Dfs service
//
//  Functions:  
//
//  History:    2-1-99  Jharper created
//
//-----------------------------------------------------------------------------

#include <headers.hxx>
#pragma hdrstop

extern "C" {
#include <stdio.h>
#include <windows.h>
#include <lm.h>
#include <lmwksta.h>
#include <malloc.h>
}

extern "C" VOID
LogWriteMessage(
    ULONG UniqueErrorCode,
    DWORD dwErr,
    ULONG nStrings,
    LPCWSTR *pwStr)
{
    HANDLE h;

    h = RegisterEventSource(NULL, L"DfsSvc");

    if (h != NULL) {

        ReportEvent(
            h,
            // EVENTLOG_ERROR_TYPE,  // vs EVENTLOG_WARNING_TYPE, EVENTLOG_INFORMATION_TYPE
            EVENTLOG_INFORMATION_TYPE,
            0,
            UniqueErrorCode,
            NULL,
            (USHORT)nStrings,
            sizeof(dwErr),
            pwStr,
            &dwErr);

        DeregisterEventSource(h);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\query.cxx ===
//+-------------------------------------------------------------------------
//
//  File:       query.cxx
//
//  Contents:   This module contains the functions which deal with queries
//              basically, those which help us in getting from an entry path
//              to a volume object Name.
//
//  History:    24-May-1993     SudK    Created.
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "cdfsvol.hxx"

//+-------------------------------------------------------------------------
//
// Function:    GetVolObjForPath,
//
// Synopsis:    Given an entrypath it returns the volume object which has
//              the exact same entry path on it.
//
// Arguments:   [pwszEntryPath] -- The Entry Path is given here.
//              [fExactMatch] -- If TRUE, then the volume object's entry path
//                      must match pwszEntryPath exactly.
//              [ppwszVolFound] -- The appropriate vol obj name.
//
// Returns:
//
//--------------------------------------------------------------------------
DWORD
GetVolObjForPath(
    IN PWSTR    pwszEntryPath,
    IN BOOLEAN  fExactMatch,
    OUT PWSTR   *ppwszVolFound
)
{
    PWCHAR              pPrivatePrefix;
    ULONG               ulen = wcslen(pwszEntryPath);
    DWORD               dwErr;

    if (pDfsmStorageDirectory == NULL) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Get rid of a trailing backslash if there is one.
    //

    pPrivatePrefix = new WCHAR[ulen+1];
    if (pPrivatePrefix != NULL) {
        wcscpy(pPrivatePrefix, pwszEntryPath);
        if (ulen >= 1 && pPrivatePrefix[ulen-1] == L'\\')
            pPrivatePrefix[ulen-1] = L'\0';

        dwErr = pDfsmStorageDirectory->GetObjectForPrefix(
                    pPrivatePrefix,
                    fExactMatch,
                    ppwszVolFound,
                    &ulen);

        delete [] pPrivatePrefix;
    } else {
        dwErr = ERROR_OUTOFMEMORY;
    }

    return(dwErr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\security.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       security.cxx
//
//  Contents:   Worker routines to check whether the calling thread has
//              admin access on this machine.
//
//  Classes:
//
//  Functions:  InitializeSecurity
//              AccessCheckRpcClient
//
//  History:    Aug 14, 1996    Milans created
//
//-----------------------------------------------------------------------------

#include <headers.hxx>
#pragma hdrstop

static SECURITY_DESCRIPTOR AdminSecurityDesc;

static GENERIC_MAPPING AdminGenericMapping = {

        STANDARD_RIGHTS_READ,                    // Generic read

        STANDARD_RIGHTS_WRITE,                   // Generic write

        STANDARD_RIGHTS_EXECUTE,                 // Generic execute

        STANDARD_RIGHTS_READ |                   // Generic all
            STANDARD_RIGHTS_WRITE |
            STANDARD_RIGHTS_EXECUTE
};

//+----------------------------------------------------------------------------
//
//  Function:   InitializeSecurity
//
//  Synopsis:   Initializes data needed to check the access rights of callers
//              of the NetDfs APIs
//
//  Arguments:  None
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//-----------------------------------------------------------------------------

BOOL DfsInitializeSecurity()
{
    static PSID AdminSid;
    static PACL AdminAcl;
    NTSTATUS status;
    ULONG cbAcl;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;

    status = RtlAllocateAndInitializeSid(
                &ntAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,0,0,0,0,0,
                &AdminSid);

    if (!NT_SUCCESS(status))
        return( FALSE );

    cbAcl = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(AdminSid);

    AdminAcl = (PACL) new BYTE[ cbAcl ];

    if (AdminAcl == NULL)
        return(FALSE);

    if (!InitializeAcl(AdminAcl, cbAcl, ACL_REVISION))
        return( FALSE );

    if (!AddAccessAllowedAce(AdminAcl, ACL_REVISION, STANDARD_RIGHTS_WRITE, AdminSid))
        return( FALSE );

    if (!InitializeSecurityDescriptor(&AdminSecurityDesc, SECURITY_DESCRIPTOR_REVISION))
        return( FALSE );

    if (!SetSecurityDescriptorOwner(&AdminSecurityDesc, AdminSid, FALSE))
        return( FALSE );

    if (!SetSecurityDescriptorGroup(&AdminSecurityDesc, AdminSid, FALSE))
        return( FALSE );

    if (!SetSecurityDescriptorDacl(&AdminSecurityDesc, TRUE, AdminAcl, FALSE))
        return( FALSE );

    return( TRUE );

}

//+----------------------------------------------------------------------------
//
//  Function:   AccessCheckRpcClient
//
//  Synopsis:   Called by an RPC server thread. This routine will check if
//              the client making the RPC call has rights to do so.
//
//  Arguments:  None, but the callers thread context needs to be that of an
//              RPC server thread
//
//  Returns:    TRUE if client has rights to make Dfs admin calls.
//
//-----------------------------------------------------------------------------

BOOL AccessCheckRpcClient()
{
    BOOL accessGranted = FALSE;
    DWORD grantedAccess;
    HANDLE clientToken = NULL;
    BYTE privilegeSet[500];                      // Large buffer
    DWORD privilegeSetSize = sizeof(privilegeSet);
    DWORD dwErr;

    if (RpcImpersonateClient(NULL) != ERROR_SUCCESS)
        return( FALSE );

    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &clientToken)) {

        (void) AccessCheck(
                    &AdminSecurityDesc,
                    clientToken,
                    STANDARD_RIGHTS_WRITE,
                    &AdminGenericMapping,
                    (PPRIVILEGE_SET) privilegeSet,
                    &privilegeSetSize,
                    &grantedAccess,
                    &accessGranted);

        dwErr = GetLastError();

    }

    RpcRevertToSelf();

    if (clientToken != NULL)
        CloseHandle( clientToken );

    return( accessGranted );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\recovery.cxx ===
//-----------------------------------------------------------------------
//
// File:        recovery.cxx
//
// Contents:    This file contains the part of the CDFSVOL interface which
//              deals with recovery stuff. All functions in here handle
//              recovering from a failed DFSM operation. These functions will
//              return error codes only if something seriously wrong happened
//              while performing recovery will they return an error. Most of
//              the errors that they may encountered are not passed back. Look
//              at individual functions for further details about all of this.
//
// History:     09-Feb-93       SudK    Created.
//              15-April-93     SudK    Cleanup/CodeReview.
//
//-----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <cdfsvol.hxx>


//+------------------------------------------------------------------------
//
// Method:      CDfsVolume::RecoverFromFailure
//
// Synopsis:    This method assumes that the RecoveryState has already been
//              read and is in the private section of the klass. It uses the
//              recovery state to figure out the operation that we were in and
//              then calls the appropriate recovery method to do the recovery
//              stuff for each operation individually.
//
// Arguments:   NONE
//
// Returns:
//
// Notes:
//
// History:     09-Feb-1993     SudK    Created.
//
//-------------------------------------------------------------------------
DWORD
CDfsVolume::RecoverFromFailure(void)
{
    DWORD       dwErr = ERROR_SUCCESS;
    ULONG       operation, operState;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::RecoveryFromFailure()\n"));

    operation = DFS_GET_RECOVERY_STATE(_RecoveryState);
    operState = DFS_GET_OPER_STAGE(_RecoveryState);

    switch (operation)  {

    case        DFS_RECOVERY_STATE_CREATING:

        dwErr = RecoverFromCreation(operState);
        break;

    case        DFS_RECOVERY_STATE_ADD_SERVICE:

        dwErr = RecoverFromAddService(operState);
        break;

    case        DFS_RECOVERY_STATE_REMOVE_SERVICE:

        dwErr = RecoverFromRemoveService(operState);
        break;

    case        DFS_RECOVERY_STATE_DELETE:

        dwErr = RecoverFromDelete(operState);
        break;

    case        DFS_RECOVERY_STATE_MOVE:

        dwErr = RecoverFromMove(operState);
        break;

    default:
        //
        // This is yet another place where we would like to raise an EVENT
        // since the volume object is corrupt. This could never have happened.
        //
        dwErr = NERR_DfsVolumeDataCorrupt;
        IDfsVolInlineDebOut((DEB_ERROR, "Unrecognised RecoveryCode: %08lx\n", operation));
        LogMessage(DEB_ERROR,
                &(_peid.Prefix.Buffer),
                1,
                DFS_UNRECOGNISED_RECOVERY_CODE_MSG);

    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::RecoveryFromFailure() exit\n"));

    return(dwErr);

}

//+------------------------------------------------------------------------
//
// Method:      CDfsVolume::RecoverFromCreation
//
// Synopsis:    This method handles the recovery stuff if an operation failed
//              during creation. This should be called only if that has been
//              determined. This method merely backs out the entire operation.
//              It attempts to contact each service of the parent and requests
//              it to delete the ExitPoint that MIGHT have been created there
//              during the actual operation. All errors while going through
//              such ExitPt deletion operations are ignored. If this method
//              is unable to delete an ExitPoint information it assumes that
//              at worst it would have created a Knowledge inconsistency which
//              would get resolved by knowledge sync.
//
// Arguments:   [OperStage] -- The stage in which the operation crashed.
//
// Returns:
//
// Notes:
//
// History:     09-Feb-1993     SudK    Created.
//
//-------------------------------------------------------------------------
DWORD
CDfsVolume::RecoverFromCreation(ULONG OperStage)
{
    DWORD               dwErr = ERROR_SUCCESS;
    CDfsService         *pDfsService = NULL;
    CDfsVolume          *parent = NULL;
    CDfsServiceList     *svcList = NULL;

    IDfsVolInlineDebOut((DEB_TRACE, "IDfsVol::RecoveryFromCreation()\n"));

    //
    // Ofcourse we log an event now since we have determined the precise
    // recovery that we are going to do. The admin should know that such
    // a recovery did occur.
    //

    LogMessage(DEB_ERROR,
                &(_peid.Prefix.Buffer),
                1,
                DFS_RECOVERED_FROM_CREATION_MSG);

    //
    // First we go ahead and request parent machine to delete the ExitPoints
    // and then we will delete the object itself. We are basically backing
    // off the entire operation.
    //

    dwErr = GetParent(&parent);

    if (dwErr != ERROR_SUCCESS)     {
            LogMessage(DEB_TRACE, nullPtr, 0, DFS_CANT_GET_PARENT_MSG);
            dwErr = NERR_DfsVolumeDataCorrupt;
    }

    if (dwErr == ERROR_SUCCESS)  {
        svcList = &(parent->_DfsSvcList);

        pDfsService = svcList->GetFirstService();

        while (pDfsService!=NULL)       {
            dwErr = pDfsService->DeleteExitPoint(&_peid, _EntryType);
            //
            // Well we failed to delete one of the exit points. Now what do
            // we do.  We really are not going to let this stop our progress
            // from recovering. Remember that all we are interested in is not
            // to have TOO FEW exit points at a server. If a server has too
            // many exit points due to this action of ours it is OK. So lets
            // go forth and explore where no DFSM has explored before.
            //
            if (dwErr != ERROR_SUCCESS)     {
                IDfsVolInlineDebOut((
                    DEB_ERROR, "Unable to delete exitPoint %ws at %ws\n",
                    _peid.Prefix.Buffer, pDfsService->GetServiceName()));

            }
            pDfsService = svcList->GetNextService(pDfsService);
        }

        if (parent!=NULL)
            parent->Release();

        //
        // Once the recovery is done we delete the object itself.
        //
        DeleteObject();
        dwErr = ERROR_SUCCESS;
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::RecoveryFromCreation() exit\n"));

    return(dwErr);
}

//+------------------------------------------------------------------------
//
// Method:      CDfsVolume::RecoverFromAddService
//
// Synopsis:    This method handles the recovery stuff if an operation failed
//              during an AddService operation. This should be called if only
//              that has already been determined. This method backs out the
//              entire operation irrespective of where we were during the
//              operation. If necessary it will attempt to do a DeleteLocalVol
//              on the service (if it is in SVCLIST_UPDATED state). It goes
//              on to delete the Service from the ServiceList if it exists.
//              At best we would have left a knowledge inconsistency if we are
//              unable to delete the Service at remote server. But that is easy
//              to fix and knowledge inconsistency checks will take care of
//              that.
//
// Arguments:   [OperStage] -- The stage in which the operation crashed.
//
// Returns:
//
// Notes:
//
// History:     09-Feb-1993     SudK    Created.
//
//-------------------------------------------------------------------------
DWORD
CDfsVolume::RecoverFromAddService(ULONG OperStage)
{
    DWORD     dwErr = ERROR_SUCCESS;
    CDfsService *pService;


    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::RecoveryFromAddService()\n"));

    //
    // Ofcourse we log an event now since we have determined the precise
    // recovery that we are going to do. The admin should know that such
    // a recovery did occur.
    //

    LogMessage(DEB_ERROR,
                &(_peid.Prefix.Buffer),
                1,
                DFS_RECOVERED_FROM_ADDSERVICE_MSG);

    //
    // If there is no recovery Service we are out of luck basically.
    // So we just return.
    //

    ASSERT(_pRecoverySvc != NULL);

    if (_pRecoverySvc == NULL)  {
        LogMessage(DEB_ERROR,
                &(_peid.Prefix.Buffer),
                1,
                DFS_INCONSISTENT_RECOVERY_ARGS_MSG);

        dwErr = ERROR_SUCCESS;
        _Recover.SetOperationDone();
        return(dwErr);
    }

    //
    // Now if we have a recoverySvc available we still need to get a handle to
    // the service actually in the SvcList. So let us do that. That is the
    // one in which we are really interested at this point.
    //
    dwErr = _DfsSvcList.GetService(_pRecoverySvc->GetReplicaInfo(), &pService);

    if (dwErr == ERROR_SUCCESS)  {

        switch(OperStage)       {

        case DFS_OPER_STAGE_SVCLIST_UPDATED:
            //
            // We may have gotten to informing the service or maybe not but who
            // cares lets go ahead and try to delete the service anyway.
            //
            dwErr = pService->DeleteLocalVolume(&_peid);
            dwErr = ERROR_SUCCESS;

            //
            // Fall Through here.
            //
        case DFS_OPER_STAGE_START:

            //
            // Once again here we ignore the error code because if the service
            // does not exist at all in the list who cares.
            //
            dwErr = _DfsSvcList.DeleteService(pService);
            ASSERT(dwErr == ERROR_SUCCESS);
            dwErr = ERROR_SUCCESS;

            break;

        default:
            //
            // Unexpected State. LogEvent.
            //
            LogMessage( DEB_ERROR,
                        &(_peid.Prefix.Buffer),
                        1,
                        DFS_UNKNOWN_RECOVERY_STATE_MSG);

            break;

        }
    }
    else        {
        //
        // This means that we could not find the service in the SvcList. There
        // is nothing much that we can do now so we put a message and return
        //
        IDfsVolInlineDebOut((DEB_ERROR, "Could not find the service in SvcList\n of %ws in RecoverFromAddService",_peid.Prefix.Buffer));
        dwErr = ERROR_SUCCESS;
    }

    _Recover.SetOperationDone();

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::RecoveryFromAddService() exit\n"));

    return(dwErr);

}

//+------------------------------------------------------------------------
//
// Method:      CDfsVolume::RecoverFromRemoveService
//
// Synopsis:    This method handles the recovery stuff if an operation failed
//              during a RemoveService operation. It should be called only
//              if this has already been determined. This method also tries
//              to roll forward the entire operation. If the ServiceList does
//              not even have the relevant service in it that means we did
//              manage to finish the operation but however, did not get to
//              changing the recovery properties. Well that is OK.
//
// Arguments:   [OperStage] -- The stage in which the operation crashed.
//
// History:     09-Feb-1993     SudK    Created.
//
//-------------------------------------------------------------------------
DWORD
CDfsVolume::RecoverFromRemoveService(ULONG OperStage)
{
    DWORD             dwErr = ERROR_SUCCESS;
    PWCHAR              ErrorStrs[3];
    CDfsService         *pService;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::RecoveryFromRemoveService()\n"));
    //
    // Ofcourse we log an event now since we have determined the precise
    // recovery that we are going to do. The admin should know that such
    // a recovery did occur.
    //

    ASSERT(_pRecoverySvc != NULL);

    if (_pRecoverySvc == NULL)  {
        LogMessage(DEB_ERROR,
                &(_peid.Prefix.Buffer),
                1,
                DFS_INCONSISTENT_RECOVERY_ARGS_MSG);
        //
        // We will return SUCCESS here.
        //
        dwErr = ERROR_SUCCESS;
        _Recover.SetOperationDone();
        return(dwErr);
    }

    LogMessage(DEB_ERROR,
                &(_peid.Prefix.Buffer),
                1,
                DFS_RECOVERED_FROM_REMOVESERVICE_MSG);

    //
    // Now if we have a recoverySvc available we still need to get a handle to
    // the service actually in the SvcList. So let us do that. That is the
    // one in which we are really interested at this point.
    //
    dwErr = _DfsSvcList.GetService(_pRecoverySvc->GetReplicaInfo(), &pService);

    //
    // If we go in here it means that we never deleted the service from the
    // volume object at all. The best that we could have done is to inform
    // the remote service to delete the localvolume information.
    // We will roll the operation forward anyways.
    //
    if (dwErr == ERROR_SUCCESS)  {

        switch (OperStage)      {

        case DFS_OPER_STAGE_START:
            //
            // We dont know if we informed the service or not. So we do that
            // now in order to roll the operation forward.
            //
            dwErr = pService->DeleteLocalVolume(&_peid);

            if (dwErr != ERROR_SUCCESS)     {
                ErrorStrs[0] = _peid.Prefix.Buffer;
                ErrorStrs[1] = pService->GetServiceName();

                LogMessage( DEB_ERROR,
                        ErrorStrs,
                        2,
                        DFS_CANT_CREATE_LOCAL_VOLUME_MSG);
            }
            dwErr = ERROR_SUCCESS;
            //
            // Fall through here and roll the rest of operation forward.
            //
        case DFS_OPER_STAGE_INFORMED_SERVICE:
            //
            // We may not have gotten to deleting the service from disk itself
            // so we roll this operation forward by doing that.
            //
            dwErr = _DfsSvcList.DeleteService(pService);
            ASSERT(dwErr == ERROR_SUCCESS);
            dwErr = ERROR_SUCCESS;
            break;

        default:
        {
            //
            // Unexpected State. LogEvent.
            //
            LogMessage( DEB_ERROR,
                        &(_peid.Prefix.Buffer),
                        1,
                        DFS_UNKNOWN_RECOVERY_STATE_MSG);
        }
        break;
        }
    }
    else        {
        //
        // We never found this service so that means we are actually done with
        // the operation. So let us go ahead and return SUCCESS and set
        // recovery properties appropriately.
        //
        IDfsVolInlineDebOut((DEB_ERROR, "Could not find the service in SvcList\n of %ws in RecoverFromRemoveSvc",_peid.Prefix.Buffer));

        dwErr = ERROR_SUCCESS;

    }
    _Recover.SetOperationDone();

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::RecoveryFromRemoveService() exit\n"));

    return(dwErr);

}

//+------------------------------------------------------------------------
//
// Method:      CDfsVolume::RecoverFromDelete
//
// Synopsis:    This handles recover from failure during a delete operation.
//              If we are in the OPER_START stage of the operation then we
//              we will roll back the operation by attempting to inform the
//              relevant service (ONLY ONE EXISTS) to CreateLocalVol info.
//              If we are in any other state we will roll-forward the entire
//              operation. We will attempt to delete ExitPoints at each of
//              the services of the parent and then delete the object itself.
//
// Arguments:   [OperStage] -- The stage in which the operation crashed.
//
// Returns:
//
// Notes:
//
// History:     09-Feb-1993     SudK    Created.
//
//-------------------------------------------------------------------------
DWORD
CDfsVolume::RecoverFromDelete(ULONG OperStage)
{
    DWORD     dwErr = ERROR_SUCCESS;
    CDfsService         *pDfsService = NULL;
    CDfsVolume          *parent = NULL;
    CDfsServiceList     *svcList = NULL;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::RecoveryFromDelete()\n"));

    //
    // Ofcourse we log an event now since we have determined the precise
    // recovery that we are going to do. The admin should know that such
    // a recovery did occur.
    //

    LogMessage(DEB_ERROR,
                &(_peid.Prefix.Buffer),
                1,
                DFS_RECOVERED_FROM_DELETE_MSG);

    //
    // I think recovery from this operation is a big problem. We may not be
    // able to avoid going over the net to fix any problems with this operation.
    //
    switch (OperStage)  {

    case DFS_OPER_STAGE_INFORMED_SERVICE:
        //
        // we might have informed some parent as well. Anyway, we can either
        // ignore this or attempt to delete exit point info at the parents.
        // If we want to delete the exit point we do it here. IGNORE ALL ERRORS.
        //
        dwErr = GetParent(&parent);

        if (dwErr != ERROR_SUCCESS) {
            LogMessage(DEB_TRACE, nullPtr, 0, DFS_CANT_GET_PARENT_MSG);
            dwErr = NERR_DfsVolumeDataCorrupt;   //Is this error code OK?
            return(dwErr);
        }
        svcList = &(parent->_DfsSvcList);

        pDfsService = svcList->GetFirstService();

        while (pDfsService!=NULL)       {
            dwErr = pDfsService->DeleteExitPoint(&_peid, _EntryType);
            pDfsService = svcList->GetNextService(pDfsService);
        }
        dwErr = ERROR_SUCCESS;      // Ignore all errors here: Raid 455283

        if (parent!=NULL)
            parent->Release();

        //
        // Fall Through Here.
        //

    case DFS_OPER_STAGE_INFORMED_PARENT:
        //
        // We already have informed the services to delete local volume info
        // and have also informed ATLEAST one parent to delete the exit point.
        // Well as far as all remote operations are concerned we are done. So
        // we only need to delete the local object and then we are done. At
        // the same time we invalidate this instance by setting _Deleted = TRUE.
        //
        DeleteObject();

        _Deleted = TRUE;
        break;

    case DFS_OPER_STAGE_START:
        //
        // In this case we will just remove the recovery state and assume
        // that nothing ever happened. Even if we did get to some service and
        // inform it to delete local volume it is not a problem - we will
        // detect such a service since it will refuse to accept serivce requests
        // However, we will attempt to Create back any local volume information
        // at the service that is involved.
        //

        pDfsService = _DfsSvcList.GetFirstService();

        //
        // Remember that there should only be one service otherwise we would
        // have never got this far in this operation.
        //
        if (pDfsService != NULL)        {
            dwErr = pDfsService->CreateLocalVolume(&_peid, _EntryType);
            dwErr = ERROR_SUCCESS;
        }

        _Recover.SetOperationDone();
        break;

    default:
        //
        // Unexpected State. LogEvent.
        //
        LogMessage(     DEB_ERROR,
                        &(_peid.Prefix.Buffer),
                        1,
                        DFS_UNKNOWN_RECOVERY_STATE_MSG);
        _Recover.SetOperationDone();
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::RecoveryFromDelete() exit\n"));

    return(dwErr);

}

//+------------------------------------------------------------------------
//
// Method:      CDfsVolume::RecoverFromMove
//
// Synopsis:    Handles recovery from failure during a MOVE operation.
//
// Arguments:   [OperStage] -- The stage in which the operation crashed.
//
// Returns:
//
// Notes:
//
// History:     09-Feb-1993     SudK    Created.
//
//-------------------------------------------------------------------------
DWORD
CDfsVolume::RecoverFromMove(ULONG OperStage)
{
    DWORD     dwErr = ERROR_SUCCESS;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::RecoveryFromMove()\n"));

    //
    // Ofcourse we log an event now since we have determined the precise
    // recovery that we are going to do. The admin should know that such
    // a recovery did occur.
    //

    LogMessage(DEB_ERROR,
                &(_peid.Prefix.Buffer),
                1,
                DFS_RECOVERED_FROM_MOVE_MSG);

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::RecoveryFromMove() exit\n"));

    return(dwErr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\localvol.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       localvol.cxx
//
//  Contents:   Code to validate local volume knowledge with the root server
//              of the Dfs
//
//  Classes:
//
//  Functions:  DfsManagerValidateLocalVolumes
//
//              DfspGetRemoteConfigInfo
//              DfspValidateLocalPartition
//              DfspPruneLocalPartition
//              StringToGuid
//
//  History:    April 29, 1996  Milans Created
//
//-----------------------------------------------------------------------------

//#include <ntos.h>
//#include <ntrtl.h>
//#include <nturtl.h>
//#include <dfsfsctl.h>
//#include <windows.h>

#include <headers.hxx>
#pragma hdrstop

#include <dsgetdc.h>
#include "dfsmwml.h"

extern "C" NET_API_STATUS
NetDfsManagerGetConfigInfo(
    LPWSTR wszServer,
    LPWSTR wszLocalVolumeEntryPath,
    GUID guidLocalVolume,
    LPDFSM_RELATION_INFO *ppDfsmRelationInfo);

extern "C" NET_API_STATUS
NetDfsManagerSendSiteInfo(
    LPWSTR wszServer,
    LPWSTR wszLocalVolumeEntryPath,
    LPDFS_SITELIST_INFO pSiteInfo);

DWORD
DfspGetRemoteConfigInfo(
    LPWSTR wszLocalVolumeEntryPath,
    LPWSTR wszLocalVolumeGuid,
    LPDFSM_RELATION_INFO *ppDfsmRelationInfo);

VOID
DfspValidateLocalPartition(
    LPWSTR wszLocalVolumeEntryPath,
    LPWSTR wszLocalVolumeGuid,
    LPDFSM_RELATION_INFO pDfsmRelationInfo);

VOID
DfspPruneLocalPartition(
    LPWSTR wszLocalVolumeEntryPath,
    LPWSTR wszLocalVolumeGuid);

VOID StringToGuid(
    IN PWSTR pwszGuid,
    OUT GUID *pGuid);

BOOLEAN
DfspGetCoveredSiteInfo(
    LPWSTR ServerName,
    LPDFS_SITELIST_INFO *ppSiteInfo);

//+----------------------------------------------------------------------------
//
//  Function:   DfsManagerValidateLocalVolumes
//
//  Synopsis:   Validates the relation info of all local volumes with the
//              Dfs Root server
//
//  Arguments:  None
//
//  Returns:    TRUE if validation attempt succeeded, FALSE if could not
//              validate all local volumes
//
//-----------------------------------------------------------------------------

extern "C" BOOLEAN
DfsManagerValidateLocalVolumes()
{
    DWORD dwErr, i;
    HKEY hkeyLv, hkeyThisLv;
    WCHAR wszLocalVolGuid[ 2 * sizeof(GUID) + 1 ];
    BOOLEAN fValidateNextVolume;
    BOOLEAN fHaveCoveredSiteInfo;
    LPDFS_SITELIST_INFO pSiteInfo = NULL;

    if (pwszComputerName == NULL)
        return FALSE;

    //
    // Get covered site info
    //
    fHaveCoveredSiteInfo = DfspGetCoveredSiteInfo(
                                pwszComputerName,
                                &pSiteInfo);

    //
    // For each local volume, ask the root for its relation info and then
    // fsctl it down to the driver so it can validate its relation info.
    //

    IDfsVolInlineDebOut((DEB_TRACE, "DfsManagerValidateLocalVolumes()\n"));

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, REG_KEY_LOCAL_VOLUMES, &hkeyLv);

    if (dwErr != ERROR_SUCCESS) {

        if (fHaveCoveredSiteInfo == TRUE) {

            MIDL_user_free(pSiteInfo);

        }

        return( FALSE );

    }

    i = 0;

    do {

        WCHAR wszEntryPath[MAX_PATH + 1];
        LPDFSM_RELATION_INFO pDfsmRelationInfo;

        fValidateNextVolume = TRUE;

        //
        // Local volumes are stored with their stringized guids as key names
        //

        dwErr = RegEnumKey(
                    hkeyLv,
                    i,
                    wszLocalVolGuid,
                    sizeof(wszLocalVolGuid) );

        if (dwErr == ERROR_SUCCESS) {

            dwErr = RegOpenKey(hkeyLv, wszLocalVolGuid, &hkeyThisLv);

            if (dwErr == ERROR_SUCCESS) {

                DWORD cbBuffer = sizeof(wszEntryPath);
                DWORD dwType;

                dwErr = RegQueryValueEx(
                            hkeyThisLv,
                            REG_VALUE_ENTRY_PATH,
                            NULL,
                            &dwType,
                            (LPBYTE) wszEntryPath,
                            &cbBuffer);

                RegCloseKey( hkeyThisLv );

            }

        } else if (dwErr == ERROR_NO_MORE_ITEMS) {

            fValidateNextVolume = FALSE;

        }

        if (dwErr == ERROR_SUCCESS) {

            dwErr = DfspGetRemoteConfigInfo(
                        wszEntryPath,
                        wszLocalVolGuid,
                        &pDfsmRelationInfo);

            switch (dwErr) {

            case ERROR_SUCCESS:

                DfspValidateLocalPartition(
                    wszEntryPath,
                    wszLocalVolGuid,
                    pDfsmRelationInfo);

                NetApiBufferFree(pDfsmRelationInfo);

                break;


            case NERR_DfsNoSuchVolume:
            case NERR_DfsNoSuchShare:

                DfspPruneLocalPartition(
                    wszEntryPath,
                    wszLocalVolGuid);

                break;


            case ERROR_NOT_ENOUGH_MEMORY:

                break;


            default:

                fValidateNextVolume = FALSE;

                break;


            }
            
            //
            // Tell the root what sites we cover
            //

            if (fHaveCoveredSiteInfo == TRUE && pwszComputerName != NULL) {

                NetDfsManagerSendSiteInfo(
                    pwszComputerName,   // Who's sending this
                    wszEntryPath,       // The dfs root to send to
                    pSiteInfo);         // the site info itself

            }

        }

        i++;

    } while ( fValidateNextVolume );

    RegCloseKey( hkeyLv );

    if (fHaveCoveredSiteInfo == TRUE) {

        MIDL_user_free(pSiteInfo);

    }

    IDfsVolInlineDebOut((DEB_TRACE, "DfsManagerValidateLocalVolumes: i=%d on exit\n", i));

    return( TRUE );

}

BOOLEAN
DfspGetCoveredSiteInfo(
    LPWSTR ServerName,
    LPDFS_SITELIST_INFO *ppSiteInfo)
{
    DWORD status;
    LPWSTR ThisSite;
    LPWSTR CoveredSites = NULL;
    LPDFS_SITELIST_INFO pSiteInfo = NULL;
    ULONG Size;
    ULONG cSites;
    LPWSTR pSiteName;
    LPWSTR pNames;
    ULONG iSite;
    ULONG j;
    DWORD dwType;
    DWORD dwUnused;
    ULONG cbBuffer;
    HKEY hkey;
    BOOLEAN fUsingDefault = TRUE;

    status = RegOpenKey(
                HKEY_LOCAL_MACHINE,
                REG_KEY_COVERED_SITES,
                &hkey);

    DFSM_TRACE_ERROR_HIGH(status, ALL_ERROR, DfspGetCoveredSiteInfo_Error_RegOpenKey,
                          LOGSTATUS(status)
                          LOGWSTR(ServerName));

    if (status == ERROR_SUCCESS) {

        status = RegQueryInfoKey(
                    hkey,                            // Key
                    NULL,                            // Class string
                    NULL,                            // Size of class string
                    NULL,                            // Reserved
                    &dwUnused,                       // # of subkeys
                    &dwUnused,                       // max size of subkey name
                    &dwUnused,                       // max size of class name
                    &dwUnused,                       // # of values
                    &dwUnused,                       // max size of value name
                    &cbBuffer,                       // max size of value data,
                    NULL,                            // security descriptor
                    NULL);                           // Last write time

        DFSM_TRACE_ERROR_HIGH(status, ALL_ERROR, DfspGetCoveredSiteInfo_Error_RegQueryInfoKey,
                              LOGSTATUS(status)
                              LOGWSTR(ServerName));

        //
        // Check if there's a value the same name as the servername passed in,
        // if so, use it.  Else default to value REG_VALUE_COVERED_SITES.
        //

        if (status == ERROR_SUCCESS) {

            CoveredSites = (LPWSTR)MIDL_user_allocate(cbBuffer);

            if (CoveredSites != NULL) {

                status = RegQueryValueEx(
                                hkey,
                                ServerName,
                                NULL,
                                &dwType,
                                (PUCHAR)CoveredSites,
                                &cbBuffer);
                DFSM_TRACE_ERROR_HIGH(status, ALL_ERROR, DfspGetCoveredSiteInfo_Error_RegQueryValueEx,
                                      LOGSTATUS(status)
                                      LOGWSTR(ServerName));

                if (status == ERROR_SUCCESS && dwType == REG_MULTI_SZ) {

                    fUsingDefault = FALSE;

                } else {

                    status = RegQueryValueEx(
                                    hkey,
                                    REG_VALUE_COVERED_SITES,
                                    NULL,
                                    &dwType,
                                    (PUCHAR)CoveredSites,
                                    &cbBuffer);
                    DFSM_TRACE_ERROR_HIGH(status, ALL_ERROR, DfspGetCoveredSiteInfo_Error_RegQueryValueEx2,
                                          LOGSTATUS(status)
                                          LOGWSTR(ServerName));

                    if ( status != ERROR_SUCCESS || dwType != REG_MULTI_SZ) {

                        MIDL_user_free(CoveredSites);

                        CoveredSites = NULL;

                    }

                }

            }

        }

        RegCloseKey( hkey );
    }

    //
    // Size the return buffer
    //

    Size = 0;

    for (cSites = 0, pNames = CoveredSites; pNames && *pNames; cSites++) {

        Size += (wcslen(pNames) + 1) * sizeof(WCHAR);

        pNames += wcslen(pNames) + 1;

    }

    //
    // Get site we belong to, if we're using the defaults
    //

    ThisSite = NULL;

    if (fUsingDefault == TRUE) {

        status = DsGetSiteName(NULL, &ThisSite);
        DFSM_TRACE_ERROR_HIGH(status, ALL_ERROR, DfspGetCoveredSiteInfo_Error_DsGetSiteName,
                              LOGSTATUS(status)
                              LOGWSTR(ServerName));


        if (status == NO_ERROR && ThisSite != NULL) {

            Size += (wcslen(ThisSite) + 1) * sizeof(WCHAR);

            cSites++;

        }

    }

    //
    // If no sites are configured, and we couldn't determine our site,
    // then we fail.
    //

    if (cSites == 0) {

        goto ErrorReturn;

    }

    Size += FIELD_OFFSET(DFS_SITELIST_INFO,Site[cSites]);

    pSiteInfo = (LPDFS_SITELIST_INFO)MIDL_user_allocate(Size);

    if (pSiteInfo == NULL) {

        goto ErrorReturn;

    }

    RtlZeroMemory(pSiteInfo, Size);

    pSiteInfo->cSites = cSites;

    pSiteName = (LPWSTR) ((PCHAR)pSiteInfo +
                            sizeof(DFS_SITELIST_INFO) +
                                sizeof(DFS_SITENAME_INFO) * (cSites - 1));

    //
    // Marshall the site strings into the buffer
    //

    iSite = 0;

    if (ThisSite != NULL) {

        wcscpy(pSiteName, ThisSite);

        pSiteInfo->Site[iSite].SiteFlags = DFS_SITE_PRIMARY;

        pSiteInfo->Site[iSite++].SiteName = pSiteName;

        pSiteName += wcslen(ThisSite) + 1;

    }

    for (pNames = CoveredSites; pNames && *pNames; pNames += wcslen(pNames) + 1) {

        wcscpy(pSiteName, pNames);

        pSiteInfo->Site[iSite++].SiteName = pSiteName;

        pSiteName += wcslen(pSiteName) + 1;

    }

    *ppSiteInfo = pSiteInfo;

    if (CoveredSites != NULL) {

        MIDL_user_free(CoveredSites);

    }

    return TRUE;

ErrorReturn:

    //
    // Free anything we allocated
    //

    if (pSiteInfo != NULL) {

        MIDL_user_free(pSiteInfo);

    }

    if (CoveredSites != NULL) {

        MIDL_user_free(CoveredSites);

    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfspGetRemoteConfigInfo
//
//  Synopsis:   Gets the config info for a local volume from the Dfs root
//              server.
//
//  Arguments:  [wszLocalVolumeEntryPath] -- Entry path of local volume.
//
//              [wszLocalVolumeGuid] -- Stringized guid of local volume.
//
//              [ppDfsmRelationInfo] -- On successful return, contains pointer
//                      to allocated DFSM_RELATION_INFO structure.
//
//  Returns:    Error code from NetDfsManagerGetConfigInfo or
//
//-----------------------------------------------------------------------------

DWORD
DfspGetRemoteConfigInfo(
    LPWSTR wszLocalVolumeEntryPath,
    LPWSTR wszLocalVolumeGuid,
    LPDFSM_RELATION_INFO *ppDfsmRelationInfo)
{
    DWORD dwErr;
    GUID guidLocalVolume;

    if (pwszComputerName == NULL)
        return ERROR_INVALID_PARAMETER;

    StringToGuid( wszLocalVolumeGuid, &guidLocalVolume );

    dwErr = NetDfsManagerGetConfigInfo(
                pwszComputerName,
                wszLocalVolumeEntryPath,
                guidLocalVolume,
                ppDfsmRelationInfo);

    DFSM_TRACE_ERROR_HIGH(dwErr, ALL_ERROR,  DfspGetRemoteConfigInfo_Error_NetDfsManagerGetConfigInfo,
                          LOGSTATUS(dwErr)
                          LOGWSTR(wszLocalVolumeEntryPath));

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspValidateLocalPartition
//
//  Synopsis:   Given a remote config info, this API will fsctl to the local
//              dfs driver to take actions and match up its local volume info
//              with the remote one.
//
//  Arguments:  [wszLocalVolumeEntryPath] -- local volume entry path to
//                      validate
//              [wszLocalVolumeGuid] -- Guid of local volume to validate
//              [pDfsmRelationInfo] -- The DFSM_RELATION_INFO that this local
//                      volume should have.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfspValidateLocalPartition(
    LPWSTR wszLocalVolumeEntryPath,
    LPWSTR wszLocalVolumeGuid,
    LPDFSM_RELATION_INFO pDfsmRelationInfo)
{
    DFS_PKT_RELATION_INFO DfsRelationInfo;
    DWORD i;

    //
    // Massage the DFSM_RELATION_INFO into a DFS_PKT_RELATION_INFO
    //

    StringToGuid( wszLocalVolumeGuid, &DfsRelationInfo.EntryId.Uid );

    RtlInitUnicodeString(
        &DfsRelationInfo.EntryId.Prefix,
        wszLocalVolumeEntryPath);

    RtlInitUnicodeString( &DfsRelationInfo.EntryId.ShortPrefix, NULL );

    DfsRelationInfo.SubordinateIdList =
        new DFS_PKT_ENTRY_ID[ pDfsmRelationInfo->cSubordinates ];

    if (DfsRelationInfo.SubordinateIdList == NULL)
        return;


    DfsRelationInfo.SubordinateIdCount = pDfsmRelationInfo->cSubordinates;

    for (i = 0; i < pDfsmRelationInfo->cSubordinates; i++) {

        DfsRelationInfo.SubordinateIdList[i].Uid =
            pDfsmRelationInfo->eid[i].idSubordinate;

        RtlInitUnicodeString(
            &DfsRelationInfo.SubordinateIdList[i].Prefix,
            pDfsmRelationInfo->eid[i].wszSubordinate);

        RtlInitUnicodeString(
            &DfsRelationInfo.SubordinateIdList[i].ShortPrefix,
            NULL);

    }

    PktValidateLocalVolumeInfo( &DfsRelationInfo );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspPruneLocalPartition
//
//  Synopsis:   Deletes a local volume that the root server says is an extra
//              volume.
//
//  Arguments:  [wszLocalVolumeEntryPath] -- local volume entry path to
//                      delete
//              [wszLocalVolumeGuid] -- Guid of local volume to delete
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfspPruneLocalPartition(
    LPWSTR wszLocalVolumeEntryPath,
    LPWSTR wszLocalVolumeGuid)
{
    DFS_PKT_ENTRY_ID EntryId;

    RtlZeroMemory(&EntryId, sizeof(EntryId));

    StringToGuid( wszLocalVolumeGuid, &EntryId.Uid );

    RtlInitUnicodeString( &EntryId.Prefix, wszLocalVolumeEntryPath );

    PktPruneLocalPartition( &EntryId );

}

//+----------------------------------------------------------------------------
//
//  Function:   StringToGuid
//
//  Synopsis:   Converts a 32 wchar null terminated string to a GUID.
//
//  Arguments:  [pwszGuid] -- the string to convert
//              [pGuid] -- Pointer to destination GUID.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

#define HEX_DIGIT_TO_INT(d, i)                          \
    ASSERT(((d) >= L'0' && (d) <= L'9') ||              \
           ((d) >= L'A' && (d) <= L'F'));               \
    if ((d) <= L'9') {                                  \
        i = (d) - L'0';                                 \
    } else {                                            \
        i = (d) - L'A' + 10;                            \
    }

VOID StringToGuid(
    IN PWSTR pwszGuid,
    OUT GUID *pGuid)
{
    PBYTE pbBuffer = (PBYTE) pGuid;
    USHORT i, n;

    for (i = 0; i < sizeof(GUID); i++) {
        HEX_DIGIT_TO_INT(pwszGuid[2 * i], n);
        pbBuffer[i] = n << 4;
        HEX_DIGIT_TO_INT(pwszGuid[2 * i + 1], n);
        pbBuffer[i] |= n;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\registry.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       registry.cxx
//
//  Contents:   implementations for CRegKey member Members
//
//  Members:    CRegKey::CRegKey - constructor for registry key object
//              CRegKey::CRegKey - constructor for registry key object
//              CRegKey::CreateKey - real worker for constructors
//              CRegKey::~CRegKey - destructor for registry key object
//              CRegKey::Delete - delete a registry key
//              CRegKey::EnumValues - enumerate values of a registry key
//              CRegKey::EnumKeys - enumerate subkeys of a registry key
//              CRegKey::NotifyChange - setup change notification for a key
//
//              CRegValue::GetValue - sets a registry value
//              CRegValue::SetValue - retrieves a registry value
//              CRegValue::Delete - deletes a registry value
//              CRegValue::GetTypeCode - returns the type code of the value
//
//              CRegMSZ::SetStrings - sets a multi-string registry value
//              CRegMSZ::GetStrings - retrieves a multi-string registry value
//
//  History:    09/30/92    Rickhi  Created
//              09/22/93    AlokS   Took out exception throwing code
//                                  and added proper return code for
//                                  each method.
//
//              07/26/94    AlokS   Made it real light weight for simple
//                                  registry set/get operations
//
//  Notes:      see notes in registry.hxx
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include    <stdlib.h>
#include    <windows.h>
#include    <registry.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using HKEY for parent
//
//  Arguments:  [hkParent] - handle to parent key
//              [pwszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pwszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//              [fThrowExceptionOnError] - Constructor throw exception on error
//
//  Signals:    Internal error state is set if construction fails.
//
//  Returns:    -none-
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All except the hkParent and pwszPath are optional parameters.
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        HKEY hkParent,
        const LPWSTR pwszPath,
        REGSAM samDesiredAccess,
        const LPWSTR pwszClass,
        DWORD dwOptions,
        DWORD *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
    :_hkParent(hkParent),
     _hkThis(NULL),
     _dwErr (ERROR_SUCCESS)
{
    _dwErr = CreateKey( _hkParent,
                     pwszPath,
                     samDesiredAccess,
                     pwszClass,
                     dwOptions,
                     pdwDisposition,
                     pSecurityAttributes );
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using CRegKey for parent
//
//  Arguments:  [prkParent] - ptr to Parent CRegKey
//              [pwszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pwszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//              [fThrowExceptionOnError] - Constructor throw exception on error
//
//  Signals:    Internal Error state is set if error occures during construction.
//
//  Returns:    nothing
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All except the prkParent and pwszPath are optional parameters.
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        const CRegKey &crkParent,
        const LPWSTR pwszPath,
        REGSAM samDesiredAccess,
        const LPWSTR pwszClass,
        DWORD dwOptions,
        DWORD *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
    :_hkParent(crkParent.GetHandle()),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
    _dwErr = CreateKey ( _hkParent,
                      pwszPath,
                      samDesiredAccess,
                      pwszClass,
                      dwOptions,
                      pdwDisposition,
                      pSecurityAttributes );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using HKEY for parent
//                              Merely opens the key, if exist
//
//  Arguments:  [hkParent] - HKEY to Parent
//                              [dwErr]      - Error code returned here
//                      [pwszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    Internal Error state is set if error occures during construction
//
//  Returns:    nothing
//
//  History:    09/22/93    AlokS  Created
//
//  Notes:      Check error status to determine if constructor succeeded
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        HKEY hkParent,
        DWORD *pdwErr,
        const LPWSTR pwszPath,
        REGSAM samDesiredAccess )
    :_hkParent(hkParent),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
     *pdwErr = _dwErr = OpenKey  ( _hkParent, pwszPath, samDesiredAccess );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using CRegKey for parent
//                              Merely opens the key, if exist
//
//  Arguments:  [prkParent] - ptr to Parent CRegKey
//              [dwErr]           -  Error code returned here.
//                      [pwszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    Internal Error state is set if error occures during construction
//
//  Returns:    nothing
//
//  History:    09/22/93    AlokS  Created
//
//  Notes:      Check error status to determine if constructor succeeded
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        const CRegKey  &crkParent,
        DWORD *pdwErr,
        const LPWSTR pwszPath,
        REGSAM   samDesiredAccess )
    :_hkParent(crkParent.GetHandle()),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
    IDfsVolInlineDebOut((
        DEB_TRACE, "CRegKey::+CRegKey(0x%x)\n",
        this));

     *pdwErr = _dwErr = OpenKey ( _hkParent, pwszPath, samDesiredAccess );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::~CRegKey, public
//
//  Synopsis:   Destructor for registry key object
//
//  Arguments:  none
//
//  Signals:    nothing
//
//  Returns:    nothing
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

CRegKey::~CRegKey()
{
    IDfsVolInlineDebOut((
        DEB_TRACE, "CRegKey::~CRegKey(0x%x)\n",
        this));

    if (_hkThis != NULL) {

        RegCloseKey(_hkThis);

    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CreateKey, private
//
//  Synopsis:   This method does the real work of the constructors.
//
//  Arguments:  [hkParent] - handle to parent key
//              [pwszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pwszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All parameters are required.
//
//--------------------------------------------------------------------------

DWORD CRegKey::CreateKey (
        HKEY hkParent,
        const LPWSTR  pwszPath,
        REGSAM  samDesiredAccess,
        const LPWSTR  pwszClass,
        DWORD   dwOptions,
        DWORD   *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
{
    DWORD   dwDisposition;
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;
    LPSECURITY_ATTRIBUTES lpsec = pSecurityAttributes;

    //  create/open the key
    if ((dwRc = RegCreateKeyEx(hkParent,
                           pwszPath,           //  path to key
                           0,                  //  title index
                           pwszClass,          //  class of key
                           dwOptions,          //  key options
                           samDesiredAccess,   //  desired access
                           lpsec,              //  if created
                           &_hkThis,           //  handle
                           &dwDisposition)     //  opened/created
                          )==ERROR_SUCCESS)
    {
        //  save away the name
        _cwszName.Set(pwszPath);

        //  setup the return parameters
        if (pdwDisposition != NULL)
            *pdwDisposition = dwDisposition;

    }
    else
        dwErr = Creg_ERROR(dwRc);

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::OpenKey, private
//
//  Synopsis:   This method does the real work of the constructors.
//
//  Arguments:  [hkParent] - handle to parent key
//                      [pwszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/22/93        AlokS  Created
//
//  Notes:      All parameters are required.
//
//--------------------------------------------------------------------------

DWORD CRegKey::OpenKey (
        HKEY    hkParent,
        const  LPWSTR  pwszPath,
        REGSAM  samDesiredAccess )
{
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;

    //  open the key
    if ((dwRc = RegOpenKeyEx(hkParent,
                         pwszPath,           //  path to key
                         0,                  //  reserved
                         samDesiredAccess,   //  desired access
                         &_hkThis            //  handle
                        ))==ERROR_SUCCESS)
    {
        //  save away the name
        _cwszName.Set(pwszPath);

    }
    else
        dwErr = Creg_ERROR(dwRc);

    return(dwErr);
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::Delete, public
//
//  Synopsis:   Deletes an existing key from the registry.  Note that
//              the key object still exists, the destructor must be
//              called seperately.
//
//  Arguments:  none
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CRegKey::Delete(void)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD   dwRc;
    SRegKeySet *pChildren;

    dwErr = this->EnumKeys(&pChildren);

    if (dwErr == ERROR_SUCCESS) {

        ULONG i;
        DWORD dwErrDelete = ERROR_SUCCESS;

        for(i = 0; i < pChildren->cKeys; i++) {

            dwErr = pChildren->aprkKey[i]->Delete();

            if (dwErr != ERROR_SUCCESS) {

                dwErrDelete = dwErr;

            }

            delete pChildren->aprkKey[i];

        }

        if (dwErrDelete == ERROR_SUCCESS) {

            if (( dwRc= RegDeleteKey(_hkThis, NULL))!=ERROR_SUCCESS) {

                dwErr = Creg_ERROR(dwRc);

            }

        } else {

            dwErr = dwErrDelete;

        }

        delete pChildren;

    }

    return(dwErr);
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::EnumValues, public
//
//  Synopsis:   Enumerates the values stored in an open registry key.
//
//  Arguments:  [pprvs] - SRegValueSet allocated and returned by this
//                                    method.  The caller is responsible for releasing
//                                    the allocated CRegValue objects via delete and the
//                                    SRegValueSet structure via CRegKey::MemFree.
//
//  Signals:  none
//
//  Returns:  ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      The data associated with each Value is not returned. The
//              caller may invoke the GetValue method of each CRegValue
//              returned to get it's associated data.
//
//--------------------------------------------------------------------------

DWORD CRegKey::EnumValues(SRegValueSet **pprvs)
{
    DWORD dwErr = ERROR_SUCCESS;

    //  figure out how many values are currently stored in this key
    //  and allocate a buffer to hold the return results.

    WCHAR   wszClass[MAX_PATH];
    ULONG   cbClass = sizeof(wszClass);
    ULONG   cSubKeys, cbMaxSubKeyLen, cbMaxClassLen;
    ULONG   cValues, cbMaxValueIDLen, cbMaxValueLen;
    SECURITY_DESCRIPTOR SecDescriptor;
    FILETIME ft;

    DWORD dwRc = RegQueryInfoKey(_hkThis,
                               wszClass,
                               &cbClass,
                               NULL,
                               &cSubKeys,
                               &cbMaxSubKeyLen,
                               &cbMaxClassLen,
                               &cValues,
                               &cbMaxValueIDLen,
                               &cbMaxValueLen,
                               (DWORD *)&SecDescriptor,
                               &ft );

    if ( dwRc == ERROR_SUCCESS )
    {
        *pprvs = (SRegValueSet *) new BYTE [ sizeof(SRegValueSet)+
                                             cValues*sizeof(CRegValue *) ];
        if ( *pprvs == NULL )
        {
            dwErr = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        //   QueryInfo failed.
        dwErr = Creg_ERROR(dwRc);
    }
    if (dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    //  loop enumerating and creating a RegValue object for each value
    DWORD   dwIndex=0;

    do
    {
        WCHAR   wszValueID[MAX_PATH];
        ULONG   cbValueID = MAX_PATH;
        DWORD   dwTypeCode;
        CRegValue *pRegVal;

        if ((dwRc = RegEnumValue(_hkThis,         //  handle
                        dwIndex,        //  index
                        wszValueID,     //  value id
                        &cbValueID,     //  length of value name
                        NULL,           //  title index
                        &dwTypeCode,    //  data type
                        NULL,           //  data buffer
                        NULL            //  size of data buffer
                      ))==ERROR_SUCCESS)
        {
            //  create the appropriate class of value object
            switch (dwTypeCode)
            {
            case REG_SZ:
                pRegVal = (CRegValue *) new CRegSZ((const CRegKey &)*this, wszValueID);
                break;

            case REG_DWORD:
                pRegVal = (CRegValue *) new CRegDWORD((const CRegKey &)*this, wszValueID);
                break;

            case REG_BINARY:
                pRegVal = (CRegValue *) new CRegBINARY((const CRegKey &)*this, wszValueID);
                break;

            default:
                pRegVal = (CRegValue *) new CRegBINARY((const CRegKey &)*this, wszValueID);
                break;
            }

            //  save ptr to value object and count another entry
            (*pprvs)->aprvValue[dwIndex++] = pRegVal;
        }
        else
        {
            //  error, we're done with the enumeration
            break;
        }

    } while (dwIndex < cValues);


    //  finished the enumeration, check the results
    if (dwRc == ERROR_NO_MORE_ITEMS || dwRc == ERROR_SUCCESS)
    {
        //  set the return count
        (*pprvs)->cValues = dwIndex;
    }
    else
    {
        //  Cleanup and return an error
        while (dwIndex)
        {
            delete (*pprvs)->aprvValue[--dwIndex];
        }

        delete [] *pprvs;

        dwErr = Creg_ERROR(dwRc);
    }

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::EnumKeys, public
//
//  Synopsis:   Enumerates the subkeys of an open registry key.
//
//  Arguments:  [pprks] - SRegKeySet allocated and returned by this method.
//                        The caller is responsible for releasing all the
//                        allocated CRegKey objects and the SRegKeySet
//                        structure.
//
//  Signals:    none
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CRegKey::EnumKeys(SRegKeySet **pprks)
{
    //  figure out how many keys are currently stored in this key
    //  and allocate a buffer to hold the return results.

    WCHAR   wszClass[MAX_PATH];
    ULONG   cbClass = sizeof(wszClass);
    ULONG   cSubKeys, cbMaxSubKeyLen, cbMaxClassLen;
    ULONG   cValues, cbMaxValueIDLen, cbMaxValueLen;
    SECURITY_DESCRIPTOR SecDescriptor;
    FILETIME ft;
    DWORD  dwErr = ERROR_SUCCESS;

    DWORD dwRc = RegQueryInfoKey(_hkThis,
                     wszClass,
                     &cbClass,
                     NULL,
                     &cSubKeys,
                     &cbMaxSubKeyLen,
                     &cbMaxClassLen,
                     &cValues,
                     &cbMaxValueIDLen,
                     &cbMaxValueLen,
                     (DWORD *)&SecDescriptor,
                     &ft);

    if ( dwRc == ERROR_SUCCESS )
    {
        *pprks = (SRegKeySet*) new BYTE [sizeof(SRegKeySet)+cSubKeys*sizeof(CRegKey *)];
        if ( *pprks == NULL )
        {
            dwErr = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        //  QueryInfo failed..
        dwErr = Creg_ERROR(dwRc);
    }

    if (dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }
    //  loop enumerating and creating a RegKey object for each subkey
    DWORD   dwIndex=0;

    do
    {
        WCHAR   wszKeyName[MAX_PATH];
        ULONG   cbKeyName = MAX_PATH;
        WCHAR   wszClass[MAX_PATH];
        ULONG   cbClass = MAX_PATH;
        FILETIME ft;

        if ((dwRc = RegEnumKeyEx(_hkThis,         //  handle
                                dwIndex,        //  index
                                wszKeyName,     //  key name
                                &cbKeyName,     //  length of key name
                                NULL,           //  title index
                                wszClass,       //  class
                                &cbClass,       //  length of class
                                &ft             //  last write time
                              ))==ERROR_SUCCESS)
        {
            //  Create a CRegKey object for the subkey
            CRegKey *pRegKey = (CRegKey *) new CRegKey((const CRegKey &)*this, wszKeyName);
            // bug 447481: check for null return from above.
            if (pRegKey == NULL) 
            {
                dwErr = ERROR_OUTOFMEMORY;
                break;
            }
            if (ERROR_SUCCESS != (dwErr = pRegKey->QueryErrorStatus()))
            {
                break;
            }
            (*pprks)->aprkKey[dwIndex++] = pRegKey;
        }
        else
        {
            //  error, we're done with the enumeration
            break;
        }

    } while (dwIndex < cSubKeys);


    //  finished the enumeration, check the results
    if ((dwErr == ERROR_SUCCESS) &&
        ((dwRc == ERROR_NO_MORE_ITEMS || dwRc == ERROR_SUCCESS)))
    {
        //  set the return count
        (*pprks)->cKeys = dwIndex;
    }
    else
    {
        //  Cleanup and return an error
        while (dwIndex)
        {
            delete (*pprks)->aprkKey[--dwIndex];
        }

        delete [] *pprks;

        dwErr = Creg_ERROR(dwRc);
    }

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegValue::GetValue, public
//
//  Purpose:    Returns the data associated with a registry value.
//
//  Arguements: [pbData] - ptr to buffer supplied by caller.
//              [cbData] - size of data buffer supplied.
//              [pdwTypeCode] - type of data returned.
//
//  Signals:
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//
//
//--------------------------------------------------------------------------

DWORD CRegValue::GetValue(LPBYTE pbData, ULONG* pcbData, DWORD *pdwTypeCode)
{
    DWORD dwRc = RegQueryValueEx(GetParentHandle(),
                                    (LPWSTR)_cwszValueID,    //  value id
                                    NULL,        //  title index
                                    pdwTypeCode, //  type of data returned
                                    pbData,       //  data
                                    pcbData);       // size of data
    return(dwRc);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegValue::SetValue
//
//  Purpose:    Writes the data associated with a registry value.
//
//  Arguements: [pbData] - ptr to data to write.
//                      [cbData] - size of data to write.
//                      [dwTypeCode] - type of data to write.
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CRegValue::SetValue(const LPBYTE pbData, ULONG cbData, DWORD dwTypeCode)
{
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;
    if ((dwRc = RegSetValueEx(GetParentHandle(),        //  key handle
                             (LPWSTR)_cwszValueID,  //  value id
                              NULL,      //  title index
                              dwTypeCode,    //  type of info in buffer
                              pbData,        //  data
                              cbData)        //  size of data
                             )!= ERROR_SUCCESS)
    {
        dwErr = Creg_ERROR(dwRc);
    }
    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   DelRegKeyTree
//
//  Purpose:    Deletes a key and any of it's children. This is like
//              delnode for registry
//
//  Arguements: [hParent]      - Handle to Parent Key
//              [lpwszKeyPath] - Path (relative to Parent) of the key
//
//  Signals:
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/93    AlokS  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD DelRegKeyTree ( HKEY hParent, LPWSTR lpwszKeyPath)
{
    DWORD dwErr = ERROR_SUCCESS;
    CRegKey cregKey ( hParent,
                      lpwszKeyPath
                    );
    if (ERROR_SUCCESS != (dwErr = cregKey.QueryErrorStatus()))
    {
        return(dwErr);
    }

    // Enumerate the children of the key. We will
    // not propogate to the caller errors from enumeration
    SRegKeySet *pRegKeySet = NULL;
    if (ERROR_SUCCESS == (dwErr = cregKey.EnumKeys ( & pRegKeySet)))
    {
        // Now we have set of Keys which need to be deleted in depth
        // first manner
        for (ULONG i = 0; i < pRegKeySet->cKeys; i++ )
        {
            dwErr = DelRegKeyTree ( cregKey.GetHandle(),
                                 pRegKeySet->aprkKey[i]->GetName()
                               );

            // Delete the key itself
            delete pRegKeySet->aprkKey[i];
        }

        // Delete the enumerator structure
        delete pRegKeySet;
    }

    // Finally delete this key
    dwErr = cregKey.Delete();

    return(dwErr);
}

DWORD CRegKey::DeleteChildren()
{
    //  figure out how many keys are currently stored in this key

    ULONG   cSubKeys, cbMaxSubKeyLen;
    DWORD  dwErr = ERROR_SUCCESS;

    DWORD dwRc = RegQueryInfoKey(_hkThis,
                     NULL,
                     NULL,
                     NULL,
                     &cSubKeys,
                     &cbMaxSubKeyLen,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     NULL);

    if ( dwRc != ERROR_SUCCESS )
    {
         //  QueryInfo failed..
        dwErr = Creg_ERROR(dwRc);
    }

    if (dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }
    //  loop enumerating and creating a RegKey object for each subkey
    DWORD   dwIndex=0;

    do
    {
        WCHAR   wszKeyName[MAX_PATH];
        ULONG   cbKeyName = sizeof(wszKeyName);
        FILETIME ft;

        if ((dwRc = RegEnumKeyEx(_hkThis,         //  handle
                                dwIndex,        //  index
                                wszKeyName,     //  key name
                                &cbKeyName,     //  length of key name
                                NULL,           //  title index
                                NULL,       //  class
                                NULL,       //  length of class
                                &ft             //  last write time
                              ))==ERROR_SUCCESS)
        {
            //  Create a CRegKey object for the subkey
            CRegKey *pRegKey = (CRegKey *) new CRegKey((const CRegKey &)*this, wszKeyName);
            if (ERROR_SUCCESS != (dwErr = pRegKey->QueryErrorStatus()))
            {
                break;
            }
            pRegKey->DeleteChildren();
            delete pRegKey;
            dwRc = RegDeleteKey(_hkThis, wszKeyName);
        }
        else
        {
            //  error, we're done with the enumeration
            break;
        }

    } while (dwIndex < cSubKeys);


    //  finished the enumeration, check the results
    if ((dwErr == ERROR_SUCCESS) && 
        (dwRc != ERROR_NO_MORE_ITEMS && dwRc != ERROR_SUCCESS))
    {
        dwErr = Creg_ERROR(dwRc);
    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\setup.cxx ===
//+-------------------------------------------------------------------------
//
//  File:       setup.cxx
//
//  Contents:   This module contains the functions which remote setup
//
//  History:    11-Feb-1998     JHarper Created
//
//--------------------------------------------------------------------------


//#include <ntos.h>
//#include <ntrtl.h>
//#include <nturtl.h>
//#include <dfsfsctl.h>
//#include <windows.h>

#include "headers.hxx"
#pragma hdrstop

extern "C" {
#include <srvfsctl.h>
#include <winldap.h>
#include <dsgetdc.h>
#include "dfsmsrv.h"
}

#include "registry.hxx"

#include "setup.hxx"

#include "dfsmwml.h"
#include <winioctl.h>
//
// Until we get the schema right in the DS, we have to set our own SD on
// certain objects
//

#include <aclapi.h>
#include <permit.h>


DECLARE_DEBUG(Setup)
DECLARE_INFOLEVEL(Setup)

#if DBG == 1
#define dprintf(x)      SetupInlineDebugOut x
# else
#define dprintf(x)
#endif

DWORD
InitStdVolumeObjectStorage(VOID);

DWORD
GetShareAndPath(
    IN LPWSTR wszShare,
    OUT LPWSTR wszPath);

DWORD
CreateFtRootVolRegInfo(
    LPWSTR wszObjectName,
    LPWSTR wszFTDfsConfigDN,
    LPWSTR wszDomainName,
    LPWSTR wszDfsName,
    LPWSTR wszServerName,
    LPWSTR wszShareName,
    LPWSTR wszSharePath,
    BOOLEAN fNewFTDfs);

DWORD
CreateStdVolumeObject(
    LPWSTR wszObjectName,
    LPWSTR pwszEntryPath,
    LPWSTR pwszServer,
    LPWSTR pwszShare,
    LPWSTR pwszComment,
    GUID *guidVolume);

DWORD
CreateFtVolumeObject(
    LPWSTR wszObjectName,
    LPWSTR wszFTDfsConfigDN,
    LPWSTR wszDomainName,
    LPWSTR wszDfsName,
    LPWSTR wszServerName,
    LPWSTR wszShareName,
    LPWSTR wszSharePath,
    LPWSTR wszComment,
    BOOLEAN fNewFTDfs);

DWORD
StoreLocalVolInfo(
    IN GUID  *pVolumeID,
    IN PWSTR pwszStorageID,
    IN PWSTR pwszShareName,
    IN PWSTR pwszEntryPath,
    IN ULONG ulVolumeType);

DWORD
LdapFlushTable(
    void);

DWORD
DfspCreateRootServerList(
    IN LDAP *pldap,
    IN LPWSTR wszServerShare,
    IN LPWSTR wszDfsConfigDN,
    IN PDFSM_ROOT_LIST *ppRootList);

VOID GuidToString(
    IN GUID   *pGuid,
    OUT PWSTR pwszGuid);

extern PLDAP pLdapConnection;

//+-------------------------------------------------------------------------
//
// Function:    DfsmInitLocalPartitions
//
// Synopsis:    Tell dfs.sys to read the local volume part of the registry
//              Sends FSCTL_DFS_INIT_LOCAL_PARTITIONS to dfs.sys
//
//--------------------------------------------------------------------------

NTSTATUS
DfsmInitLocalPartitions(
    VOID)
{
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsServerName;

    RtlInitUnicodeString(&DfsServerName, DFS_SERVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsServerName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    DFSM_TRACE_ERROR_HIGH(NtStatus, ALL_ERROR, DfsmInitLocalPartitions_Error_NtCreateFile,
                            LOGSTATUS(NtStatus));

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = NtFsControlFile(
                       DriverHandle,
                       NULL,       // Event,
                       NULL,       // ApcRoutine,
                       NULL,       // ApcContext,
                       &IoStatusBlock,
                       FSCTL_DFS_INIT_LOCAL_PARTITIONS,
                       NULL,
                       0,
                       NULL,
                       0);
        DFSM_TRACE_ERROR_HIGH(NtStatus, ALL_ERROR, DfsmInitLocalPartitions_Error_NtFsCOntrolFile,
                                LOGSTATUS(NtStatus));

        NtClose(DriverHandle);

    }

    return NtStatus;
}

//+-------------------------------------------------------------------------
//
// Function:    DfsmStartDfs
//
// Synopsis:    Tell dfs.sys to turn itself on
//              Sends FSCTL_DFS_START_DFS to dfs.sys
//
//--------------------------------------------------------------------------

NTSTATUS
DfsmStartDfs(
    VOID)
{
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsServerName;

    RtlInitUnicodeString(&DfsServerName, DFS_SERVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsServerName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    DFSM_TRACE_ERROR_HIGH(NtStatus, ALL_ERROR, DfsmStartDfs_Error_NtCreateFile,
                            LOGSTATUS(NtStatus));

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = NtFsControlFile(
                       DriverHandle,
                       NULL,       // Event,
                       NULL,       // ApcRoutine,
                       NULL,       // ApcContext,
                       &IoStatusBlock,
                       FSCTL_DFS_START_DFS,
                       NULL,
                       0,
                       NULL,
                       0);
        DFSM_TRACE_ERROR_HIGH(NtStatus, ALL_ERROR, DfsmStartDfs_Error_NtFsControlFile,
                                LOGSTATUS(NtStatus));

        NtClose(DriverHandle);

    }

    return NtStatus;
}

//+-------------------------------------------------------------------------
//
// Function:    DfsmStopDfs
//
// Synopsis:    Tell dfs.sys to turn itself off
//              Sends FSCTL_DFS_STOP_DFS to dfs.sys
//
//--------------------------------------------------------------------------

NTSTATUS
DfsmStopDfs(
    VOID)
{
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsServerName;

    RtlInitUnicodeString(&DfsServerName, DFS_SERVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsServerName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    DFSM_TRACE_ERROR_HIGH(NtStatus, ALL_ERROR, DfsmStopDfs_Error_NtCreateFile,
                            LOGSTATUS(NtStatus));

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = NtFsControlFile(
                       DriverHandle,
                       NULL,       // Event,
                       NULL,       // ApcRoutine,
                       NULL,       // ApcContext,
                       &IoStatusBlock,
                       FSCTL_DFS_STOP_DFS,
                       NULL,
                       0,
                       NULL,
                       0);
        DFSM_TRACE_ERROR_HIGH(NtStatus, ALL_ERROR, DfsmStopDfs_Error_NtFsControlFile,
                                LOGSTATUS(NtStatus));

        NtClose(DriverHandle);

    }

    return NtStatus;
}

//+-------------------------------------------------------------------------
//
// Function:    DfsmResetPkt
//
// Synopsis:    Tell dfs.sys to throw away all state and turn off
//              Sends FSCTL_DFS_RESET_PKT to dfs.sys
//
//--------------------------------------------------------------------------

NTSTATUS
DfsmResetPkt(
    VOID)
{
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsServerName;

    RtlInitUnicodeString(&DfsServerName, DFS_SERVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsServerName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);
    DFSM_TRACE_ERROR_HIGH(NtStatus, ALL_ERROR, DfsmResetPkt_Error_NtCreateFile,
                            LOGSTATUS(NtStatus));
    //
    // Toss the Pkt
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = NtFsControlFile(
                       DriverHandle,
                       NULL,       // Event,
                       NULL,       // ApcRoutine,
                       NULL,       // ApcContext,
                       &IoStatusBlock,
                       FSCTL_DFS_RESET_PKT,
                       NULL,
                       0,
                       NULL,
                       0);
        DFSM_TRACE_ERROR_HIGH(NtStatus, ALL_ERROR, DfsmResetPkt_Error_NtFsControlFile,
                                LOGSTATUS(NtStatus));
        NtClose(DriverHandle);
    }

    return NtStatus;

}

//+-------------------------------------------------------------------------
//
// Function:    DfsmPktFlushCache
//
// Synopsis:    Tell dfs.sys to turn itself off
//              Sends FSCTL_DFS_PKT_FLUSH_CACHE to mup.sys
//
//--------------------------------------------------------------------------

NTSTATUS
DfsmPktFlushCache(
    VOID)
{
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    WCHAR EntryPath[5];

    //
    // Flush the local/client side pkt, too
    //

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    DFSM_TRACE_ERROR_HIGH(NtStatus, ALL_ERROR, DfsmPktFlushCache_Error_NtCreateFile,
                            LOGSTATUS(NtStatus));


    if (NT_SUCCESS(NtStatus)) {

        wcscpy(EntryPath, L"*");

        NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_PKT_FLUSH_CACHE,
                   EntryPath,
                   wcslen(EntryPath) * sizeof(WCHAR),
                   NULL,
                   0);
        DFSM_TRACE_ERROR_HIGH(NtStatus, ALL_ERROR, DfsmPktFlushCache_Error_NtFsControlFile,
                                LOGSTATUS(NtStatus));

        NtClose(DriverHandle);

    }

    return NtStatus;

}

//+-------------------------------------------------------------------------
//
// Function:    DfsmMarkStalePktEntries
//
// Synopsis:    Tell dfs.sys to throw away all state and turn off
//              Sends FSCTL_DFS_MARK_STALE_PKT_ENTRIES to dfs.sys
//
//--------------------------------------------------------------------------

NTSTATUS
DfsmMarkStalePktEntries(
    VOID)
{
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsServerName;

    RtlInitUnicodeString(&DfsServerName, DFS_SERVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsServerName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);
    DFSM_TRACE_ERROR_HIGH(NtStatus, ALL_ERROR, DfsmMarkStalePktEntries_Error_NtCreateFile,
                            LOGSTATUS(NtStatus));

    //
    // Toss the Pkt
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = NtFsControlFile(
                       DriverHandle,
                       NULL,       // Event,
                       NULL,       // ApcRoutine,
                       NULL,       // ApcContext,
                       &IoStatusBlock,
                       FSCTL_DFS_MARK_STALE_PKT_ENTRIES,
                       NULL,
                       0,
                       NULL,
                       0);
        DFSM_TRACE_ERROR_HIGH(NtStatus, ALL_ERROR, DfsmMarkStalePktEntries_Error_NtFsControlFile,
                                LOGSTATUS(NtStatus));
        NtClose(DriverHandle);
    }

    return NtStatus;

}

//+-------------------------------------------------------------------------
//
// Function:    DfsmFlushStalePktEntries
//
// Synopsis:    Tell dfs.sys to throw away all state and turn off
//              Sends FSCTL_DFS_FLUSH_STALE_PKT_ENTRIES to dfs.sys
//
//--------------------------------------------------------------------------

NTSTATUS
DfsmFlushStalePktEntries(
    VOID)
{
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsServerName;

    RtlInitUnicodeString(&DfsServerName, DFS_SERVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsServerName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);
    DFSM_TRACE_ERROR_HIGH(NtStatus, ALL_ERROR, DfsmFlushStalePktEntries_Error_NtCreateFile,
                            LOGSTATUS(NtStatus));

    //
    // Toss the Pkt
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = NtFsControlFile(
                       DriverHandle,
                       NULL,       // Event,
                       NULL,       // ApcRoutine,
                       NULL,       // ApcContext,
                       &IoStatusBlock,
                       FSCTL_DFS_FLUSH_STALE_PKT_ENTRIES,
                       NULL,
                       0,
                       NULL,
                       0);
        DFSM_TRACE_ERROR_HIGH(NtStatus, ALL_ERROR, DfsmFlushStalePktEntries_Error_NtFsControl,
                                LOGSTATUS(NtStatus));
        NtClose(DriverHandle);
    }

    return NtStatus;

}

//+----------------------------------------------------------------------------
//
//  Function:   SetupStdDfs
//
//  Synopsis:   Does necessary setup to make this Dfs a root of the Dfs.
//
//  Arguments:  [wszComputerName] -- The name of the computer
//              [wszDfsRootShare] -- The share to use as the Dfs root.
//              [wszComment] -- Comment for root share
//              [dwFlags] -- Flags for operation
//
//  Returns:    Win32 error from configuring the root storages etc.
//
//-----------------------------------------------------------------------------

DWORD
SetupStdDfs(
    LPWSTR wszComputerName,
    LPWSTR wszDfsRootShare,
    LPWSTR wszComment,
    DWORD  dwFlags,
    LPWSTR wszDfsRoot)
{
    DWORD dwErr = ERROR_SUCCESS;
    GUID guid;
    WCHAR wszDfsRootPath[MAX_PATH+1];
    PWCHAR wszDfsRootPrefix = NULL;
    TCHAR szPath[] = TEXT("A:\\");
  
    //
    // Figure out the share path for the Root Dfs share
    //

    if (dwErr == ERROR_SUCCESS) {
    
        if (wszDfsRoot == NULL) {

            dwErr = GetShareAndPath( wszDfsRootShare, wszDfsRootPath );

        } else {

            wcscpy(wszDfsRootPath, wszDfsRoot);

        }

    }

    // Check if we are trying to create a root on removable media.
    // Return an error if we are.
    // We can't allow this because, for example, if the root is a floppy
    // that is not present at boot time, the system hangs and doesn't
    // even boot up. It isn't possible to detect this at boot time and ignore
    // the drive, so we must prevent such roots from existing at all.
    if(dwErr == ERROR_SUCCESS) {
        szPath[0] = (TCHAR)wszDfsRootPath[0];
        if (GetDriveType(szPath) != DRIVE_FIXED) {
            dwErr = ERROR_INVALID_MEDIA;
        }
    }
    //
    // We have all the info we need now. Lets get to work....
    //
    //  1. Initialize the volume object section in the registry.
    //
    //  2. Initialize (ie, create if necessary) the storage used for the
    //     Dfs root.
    //
    //  3. Create the root volume object.
    //
    //  4. Configure the root volume as a local volume by updating the
    //     LocalVolumes section in the registry.
    //

    //
    // Initialize the Dfs Manager Volume Object Store
    //

    if (dwErr == ERROR_SUCCESS) {

        dwErr = InitStdVolumeObjectStorage();

    }


    if (dwErr == ERROR_SUCCESS) {

        dprintf((DEB_TRACE,
            "Setting [%ws] as Dfs storage root...\n", wszDfsRootPath));

        dwErr = DfsReInitGlobals(wszComputerName, DFS_MANAGER_SERVER );

        if (pwszDfsRootName != NULL)
            wcscpy(wszComputerName, pwszDfsRootName);

        if (dwErr == ERROR_SUCCESS) {

            wszDfsRootPrefix = new WCHAR[1 +
                                      wcslen(wszComputerName) +
                                      1 +
                                      wcslen(wszDfsRootShare) +
                                      1];

            if (wszDfsRootPrefix == NULL) {

                dwErr = ERROR_OUTOFMEMORY;

            }

        }

        if (dwErr == ERROR_SUCCESS) {

            wszDfsRootPrefix[0] = UNICODE_PATH_SEP;
            wcscpy( &wszDfsRootPrefix[1], wszComputerName );
            wcscat( wszDfsRootPrefix, UNICODE_PATH_SEP_STR );
            wcscat( wszDfsRootPrefix, wszDfsRootShare );

            dwErr = CreateStdVolumeObject(
                    DOMAIN_ROOT_VOL,             // Name of volume object
                    wszDfsRootPrefix,            // EntryPath of volume
                    wszComputerName,             // Server name
                    wszDfsRootShare,             // Share name
                    wszComment,                  // Comment
                    &guid);                      // Id of created volume

        }

        if (dwErr == ERROR_SUCCESS) {

            dwErr = StoreLocalVolInfo(
                    &guid,
                    wszDfsRootPath,
                    wszDfsRootShare,
                    wszDfsRootPrefix,
                    DFS_VOL_TYPE_DFS | DFS_VOL_TYPE_REFERRAL_SVC);

        }

        if (wszDfsRootPrefix != NULL)
            delete [] wszDfsRootPrefix;

        if (dwErr != ERROR_SUCCESS)
            dwErr = ERROR_INVALID_FUNCTION;

        if (dwErr == ERROR_SUCCESS) {

            DWORD dwErr;
            CRegKey cregVolumesDir( HKEY_LOCAL_MACHINE, &dwErr, VOLUMES_DIR );

            if (dwErr == ERROR_SUCCESS) {

                CRegSZ cregRootShare(
                            cregVolumesDir,
                            ROOT_SHARE_VALUE_NAME,
                            wszDfsRootShare );

                dwErr = cregRootShare.QueryErrorStatus();

            }

        }

    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   SetupFtDfs
//
//  Synopsis:   Completes necessary setup to make this Dfs an FtDfs root
//
//  Arguments:  [wszServerName] -- The name of the machine
//              [wszDomainName] -- Domain the machine is in
//              [wszDfsRootShare] -- The share to use as the FtDfs root.
//              [wszFtDfsName] -- The name for the FtDfs
//              [wszComment] -- Comment for root share
//              [wszConfigDN] -- The obj name to create
//              [NewFtDfs] -- TRUE to create new, FALSE to join existing
//              [dwFlags] -- Flags
//
//  Returns:    Win32 error from configuring the root storages etc.
//
//-----------------------------------------------------------------------------

DWORD
SetupFtDfs(
    LPWSTR wszServerName,
    LPWSTR wszDomainName,
    LPWSTR wszRootShare,
    LPWSTR wszFtDfsName,
    LPWSTR wszComment,
    LPWSTR wszConfigDN,
    BOOLEAN NewFtDfs,
    DWORD  dwFlags)
{
    DWORD dwErr = ERROR_SUCCESS;

    WCHAR wszRootSharePath[MAX_PATH+1];
    WCHAR wszServerShare[MAX_PATH+1];
    TCHAR szPath[] = TEXT("A:\\");

    dwErr = GetShareAndPath( wszRootShare, wszRootSharePath );

    if (dwErr != ERROR_SUCCESS) {

        dprintf((
            DEB_ERROR,
            "Win32 Error %d getting share path for %ws\n",
            dwErr, wszRootShare));

        goto Cleanup;
    }


    // Check if we are trying to create a root on removable media.
    // Return an error if we are.
    // We can't allow this because, for example, if the root is a floppy
    // that is not present at boot time, the system hangs and doesn't
    // even boot up. It isn't possible to detect this at boot time and ignore
    // the drive, so we must prevent such roots from existing at all.
    if(dwErr == ERROR_SUCCESS) {
        szPath[0] = (TCHAR)wszRootSharePath[0];
        if (GetDriveType(szPath) != DRIVE_FIXED) {
            dwErr = ERROR_INVALID_MEDIA;
            goto Cleanup;
        }
    }

    wsprintf(
        wszServerShare,
        L"\\\\%ws\\%ws",
        wszServerName,
        wszRootShare);

    //
    // Create the DfsHost root entry in the registry
    //

    dwErr = CreateFtRootVolRegInfo(
                DOMAIN_ROOT_VOL,
                wszConfigDN,
                wszDomainName,
                wszFtDfsName,
                wszServerName,
                wszRootShare,
                wszRootSharePath,
                NewFtDfs);

    //
    // Reinitialize global stuff
    //

    if (dwErr == ERROR_SUCCESS) {

        dwErr = DfsReInitGlobals(
                    wszFtDfsName,
                    DFS_MANAGER_FTDFS);

    }

    //
    // Finally, create the root volume object
    //

    if (dwErr == ERROR_SUCCESS) {

        dwErr = CreateFtVolumeObject(
                    DOMAIN_ROOT_VOL,
                    wszConfigDN,
                    wszDomainName,
                    wszFtDfsName,
                    wszServerName,
                    wszRootShare,
                    wszRootSharePath,
                    wszComment,
                    NewFtDfs);

    }

    if (dwErr == ERROR_SUCCESS) {

        dprintf((
            DEB_TRACE, "Successfully created FT-Dfs Configuration!\n"));

        goto Cleanup;

    }

    dprintf((
        DEB_ERROR, "CreateFtVolumeObject failed with error %d\n", dwErr));


Cleanup:

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   GetShareAndPath
//
//  Synopsis:   Returns the share path for a share on the local machine
//
//  Arguments:  [wszShare] -- Name of share
//
//              [wszPath] -- On return, share path of wszShare
//
//  Returns:    [ERROR_SUCCESS] -- Successfully returning share path
//
//              Win32 error from NetShareGetInfo
//
//-----------------------------------------------------------------------------

DWORD
GetShareAndPath(
    IN LPWSTR wszShare,
    OUT LPWSTR wszPath)
{
    DWORD dwErr;
    PSHARE_INFO_2 pshi2;

    dwErr = NetShareGetInfo(
                NULL,                        // Server (local machine)
                wszShare,                    // Share Name
                2,                           // Level,
                (LPBYTE *) &pshi2);          // Buffer

    if (dwErr == ERROR_SUCCESS) {

        wcscpy( wszPath, pshi2->shi2_path );

        NetApiBufferFree( pshi2 );
    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CreateFtRootVolRegInfo
//
//  Synopsis:   Creates root vol info in the registry
//
//  Arguments:  [wszObjectName] -- Name of volume object
//              [wszFTDfsConfigDN] -- The DN of the FTDfs config object in DS
//              [wszDomainName] -- Name of FTDfs domain
//              [wszDfsName] -- Name of Dfs
//              [wszServerName] -- Name of root server
//              [wszShareName] -- Name of root share
//              [fNewFTDfs] -- If true, this is a new FTDfs
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
CreateFtRootVolRegInfo(
    LPWSTR wszObjectName,
    LPWSTR wszFTDfsConfigDN,
    LPWSTR wszDomainName,
    LPWSTR wszDfsName,
    LPWSTR wszServerName,
    LPWSTR wszShareName,
    LPWSTR wszSharePath,
    BOOLEAN fNewFTDfs)
{
    DWORD dwErr;
    WCHAR wszFullObjectName[ MAX_PATH ];
    WCHAR wszDfsPrefix[ MAX_PATH ];
    GUID idVolume;

    wcscpy( wszDfsPrefix, UNICODE_PATH_SEP_STR );
    wcscat( wszDfsPrefix, wszDomainName );
    wcscat( wszDfsPrefix, UNICODE_PATH_SEP_STR );
    wcscat( wszDfsPrefix, wszDfsName );

    wcscpy( wszFullObjectName, LDAP_VOLUMES_DIR );
    wcscat( wszFullObjectName, wszObjectName );

    //
    // Create the volumes dir key that indicates that this machine is to
    // be a root of an FTDfs
    //

    CRegKey cregVolumesDir( HKEY_LOCAL_MACHINE, VOLUMES_DIR );

    dwErr = cregVolumesDir.QueryErrorStatus();

    if (dwErr == ERROR_SUCCESS) {

        CRegSZ cregRootShare(
                    cregVolumesDir,
                    ROOT_SHARE_VALUE_NAME,
                    wszShareName );

        dwErr = cregRootShare.QueryErrorStatus();

        if (dwErr == ERROR_SUCCESS) {

            CRegSZ cregFTDfs(
                    cregVolumesDir,
                    FTDFS_VALUE_NAME,
                    wszDfsName);

            CRegSZ cregFTDfsConfigDN(
                    cregVolumesDir,
                    FTDFS_DN_VALUE_NAME,
                    wszFTDfsConfigDN);

            dwErr = cregFTDfs.QueryErrorStatus();

            if (dwErr == ERROR_SUCCESS) {

                dwErr = cregFTDfsConfigDN.QueryErrorStatus();

                if (dwErr != ERROR_SUCCESS)
                    cregFTDfs.Delete();

            }

        }

    }

    return( dwErr );
}


//+----------------------------------------------------------------------------
//
//  Function:   CreateFtVolumeObject
//
//  Synopsis:   Creates root vol object
//
//  Arguments:  [wszObjectName] -- Name of volume object
//              [wszFTDfsConfigDN] -- The DN of the FTDfs config object in DS
//              [wszDomainName] -- Name of FTDfs domain
//              [wszDfsName] -- Name of Dfs
//              [wszServerName] -- Name of root server
//              [wszShareName] -- Name of root share
//              [wszComment] -- Comment for root
//              [fNewFTDfs] -- If true, this is a new FTDfs
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
CreateFtVolumeObject(
    LPWSTR wszObjectName,
    LPWSTR wszFTDfsConfigDN,
    LPWSTR wszDomainName,
    LPWSTR wszDfsName,
    LPWSTR wszServerName,
    LPWSTR wszShareName,
    LPWSTR wszSharePath,
    LPWSTR wszComment,
    BOOLEAN fNewFTDfs)
{
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR wszFullObjectName[ MAX_PATH ];
    WCHAR wszDfsPrefix[ MAX_PATH ];
    GUID idVolume;

    wcscpy( wszDfsPrefix, UNICODE_PATH_SEP_STR );
    wcscat( wszDfsPrefix, wszDomainName );
    wcscat( wszDfsPrefix, UNICODE_PATH_SEP_STR );
    wcscat( wszDfsPrefix, wszDfsName );

    wcscpy( wszFullObjectName, LDAP_VOLUMES_DIR );
    wcscat( wszFullObjectName, wszObjectName );

    if (fNewFTDfs) {

        //
        // Generate a Guid for the new Volume
        //

        UuidCreate( &idVolume );

        dwErr = DfsManagerCreateVolumeObject(
                    wszFullObjectName,
                    wszDfsPrefix,
                    wszServerName,
                    wszShareName,
                    wszComment,
                    &idVolume);

    } else {

        dwErr = DfsManagerAddService(
                    wszFullObjectName,
                    wszServerName,
                    wszShareName,
                    &idVolume);

    }

    //
    // Write the root local vol info into the registry
    //

    if (dwErr == ERROR_SUCCESS) {


        dwErr = StoreLocalVolInfo(
                    &idVolume,
                    wszSharePath,
                    wszShareName,
                    wszDfsPrefix,
                    DFS_VOL_TYPE_DFS | DFS_VOL_TYPE_REFERRAL_SVC);

        if (dwErr == ERROR_SUCCESS) {
        
            dwErr = LdapFlushTable();

        }

    }

    return( dwErr );
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateStdVolumeObject
//
//  Synopsis:   Creates a volume object to bootstrap the Dfs namespace.
//
//  Arguments:  [pwszObjectName] -- The name of the volume object, relative
//                      to VOLUMES_DIR
//              [pwszEntryPath] -- EntryPath of the volume.
//              [pwszServer] -- Name of server used to access this Dfs volume
//              [pwszShare] -- Name of share used to access this Dfs volume
//              [pwszComment] -- Comment to stamp on the volume object.
//              [guidVolume] -- ID of newly create dfs volume
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
CreateStdVolumeObject(
    LPWSTR wszObjectName,
    LPWSTR pwszEntryPath,
    LPWSTR pwszServer,
    LPWSTR pwszShare,
    LPWSTR pwszComment,
    GUID *guidVolume)
{
    DWORD dwErr;
    WCHAR wszFullObject[ MAX_PATH ];

    //
    // First, compute the full object name, storage ids, and machine name.
    //

    wcscpy( wszFullObject, VOLUMES_DIR );
    wcscat( wszFullObject, wszObjectName );

    //
    // Next, get a guid for this volume
    //

    UuidCreate( guidVolume );

    //
    // Lastly, create this volume object
    //

    dwErr = DfsManagerCreateVolumeObject(
                wszFullObject,
                pwszEntryPath,
                pwszServer,
                pwszShare,
                pwszComment,
                guidVolume);

    if (dwErr == ERROR_SUCCESS) {

        dprintf((DEB_TRACE,"Successfully inited Dfs Manager Volume [%ws]...\n", pwszEntryPath));

    }

    return(dwErr);

}

//+----------------------------------------------------------------------------
//
//  Function:   InitStdVolumeObjectStorage
//
//  Synopsis:   Initializes the Dfs Manager Volume Object store.
//
//  Arguments:  None
//
//  Returns:    DWORD from registry operations.
//
//-----------------------------------------------------------------------------

DWORD
InitStdVolumeObjectStorage()
{
    DWORD dwErr;
    CRegKey *pcregVolumeObjectStore;

    pcregVolumeObjectStore = new CRegKey(HKEY_LOCAL_MACHINE, VOLUMES_DIR );

    if (pcregVolumeObjectStore != NULL) {

        dwErr = pcregVolumeObjectStore->QueryErrorStatus();

        delete pcregVolumeObjectStore;
    } else {

        dwErr = ERROR_OUTOFMEMORY;

    }

    if (dwErr == ERROR_SUCCESS) {

        dprintf((DEB_TRACE,"Successfully inited Dfs Manager Volume Storage...\n"));

    }

    return(dwErr);

}

//+----------------------------------------------------------------------------
//
//  Function:   StoreLocalVolInfo
//
//  Synopsis:   Stores information about a local volume in the registry.
//
//  Arguments:  [pVolumeID] -- Id of dfs volume
//              [pwszStorageId] -- Storage used by dfs volume
//              [pwszShareName] -- LM Share used to access dfs volume
//              [pwszEntryPath] -- EntryPath of dfs volume
//              [ulVolumeType] -- Type of dfs volume. See DFS_VOL_TYPE_xxx
//
//  Returns:    DWORD from registry operations.
//
//-----------------------------------------------------------------------------

extern VOID
GuidToString(
    IN GUID *pID,
    OUT PWSTR pwszID);

DWORD
StoreLocalVolInfo(
    IN GUID  *pVolumeID,
    IN PWSTR pwszStorageID,
    IN PWSTR pwszShareName,
    IN PWSTR pwszEntryPath,
    IN ULONG ulVolumeType)
{
    DWORD dwErr;
    WCHAR wszLvolKey[_MAX_PATH];
    UNICODE_STRING ustrNtStorageId;
    PWCHAR pwcGuid;

    wcscpy(wszLvolKey, REG_KEY_LOCAL_VOLUMES);
    wcscat(wszLvolKey, UNICODE_PATH_SEP_STR);
    pwcGuid = wszLvolKey + wcslen(wszLvolKey);
    ASSERT( *pwcGuid == UNICODE_NULL );

    GuidToString( pVolumeID, pwcGuid );

    if (!RtlDosPathNameToNtPathName_U(
            pwszStorageID,
            &ustrNtStorageId,
            NULL,
            NULL)) {

        return(ERROR_OUTOFMEMORY);

    } else {

        ustrNtStorageId.Buffer[ustrNtStorageId.Length/sizeof(WCHAR)] = UNICODE_NULL;

    }

    CRegKey rkeyLvol(HKEY_LOCAL_MACHINE, wszLvolKey, KEY_WRITE, NULL, REG_OPTION_NON_VOLATILE);

    dwErr = rkeyLvol.QueryErrorStatus();

    if (dwErr != ERROR_SUCCESS) {
        RtlFreeUnicodeString(&ustrNtStorageId);
        return(dwErr);
    }

    CRegSZ rvEntryPath((const CRegKey &) rkeyLvol, REG_VALUE_ENTRY_PATH, pwszEntryPath);

    CRegSZ rvShortEntryPath((const CRegKey &) rkeyLvol, REG_VALUE_SHORT_PATH, pwszEntryPath);

    CRegDWORD rvEntryType((const CRegKey &) rkeyLvol, REG_VALUE_ENTRY_TYPE, ulVolumeType);

    CRegSZ rvStorageId((const CRegKey &) rkeyLvol, REG_VALUE_STORAGE_ID, ustrNtStorageId.Buffer);

    CRegSZ rvShareName((const CRegKey &) rkeyLvol, REG_VALUE_SHARE_NAME, pwszShareName);

    RtlFreeUnicodeString(&ustrNtStorageId);

    if (ERROR_SUCCESS != (dwErr = rvEntryPath.QueryErrorStatus()) ||
            ERROR_SUCCESS != (dwErr = rvShortEntryPath.QueryErrorStatus()) ||
                ERROR_SUCCESS != (dwErr = rvEntryType.QueryErrorStatus()) ||
                    ERROR_SUCCESS != (dwErr = rvStorageId.QueryErrorStatus()) ||
                        ERROR_SUCCESS != (dwErr = rvShareName.QueryErrorStatus())) {

        rkeyLvol.Delete();
    } else {

        dprintf((DEB_TRACE,"Successfully stored local volume info for [%ws]\n", pwszEntryPath));
    }

    return(dwErr);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsRemoveRoot
//
//  Synopsis:   Removes the registry info that makes a machine a root
//
//  Arguments:  None
//
//  Returns:    Win32 error from registry actions
//
//-----------------------------------------------------------------------------

DWORD
DfsRemoveRoot()
{
    DWORD dwErr;
    CRegKey *pcregLV;


    //
    // Now the volumes section

    pcregLV = new CRegKey(                       // Open local volumes section
                    HKEY_LOCAL_MACHINE,
                    REG_KEY_LOCAL_VOLUMES);

    if (pcregLV != NULL) {

        dwErr = pcregLV->QueryErrorStatus();

    } else {

        dwErr = ERROR_OUTOFMEMORY;

    }

    if (dwErr == ERROR_SUCCESS) {

        dwErr = pcregLV->DeleteChildren();                  // Delete local volumes

        delete pcregLV;
	pcregLV = NULL;

        if(dwErr == ERROR_SUCCESS) {
            // now delete the key
            dwErr = RegDeleteKey( HKEY_LOCAL_MACHINE,
                                  REG_KEY_LOCAL_VOLUMES);
        }

        if (dwErr == ERROR_SUCCESS) {

            //
            // Recreate an empty local volumes key
            //

            pcregLV = new CRegKey( HKEY_LOCAL_MACHINE, REG_KEY_LOCAL_VOLUMES);

            if (pcregLV != NULL) {
                delete pcregLV;
		pcregLV = NULL;
            }

        }

    }

    if(dwErr == ERROR_SUCCESS) {
        //
        // The DfsHost stuff 
        //

        CRegKey cregVolumesDir( HKEY_LOCAL_MACHINE, &dwErr, VOLUMES_DIR );

        if (dwErr != ERROR_SUCCESS) {                            // Unable to open volumes dir
            return(dwErr);
        }

        dwErr = cregVolumesDir.DeleteChildren();             // Delete volumes dir
    }

    if(dwErr == ERROR_SUCCESS) {
        dwErr = RegDeleteKey( HKEY_LOCAL_MACHINE, VOLUMES_DIR );
    }

    if(pcregLV) {
	delete pcregLV;
    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspCreateFtDfsDsObj
//
//  Synopsis:   Updates (by adding to) the Ds objects representing the FtDfs
//
//  Arguments:  wszServerName - Name of server we'll be adding
//              wszDcName - Dc to use
//              wszRootShare - Share to become the root share
//              wszFtDfsName - Name of FtDfs we are creating
//              ppRootList - List of FtDfs roots that need to be informed of
//                              the changed Ds object
//
//  Returns:    NTSTATUS of the call (STATUS_SUCCESS or error)
//
//-----------------------------------------------------------------------------

DWORD
DfspCreateFtDfsDsObj(
    LPWSTR wszServerName,
    LPWSTR wszDcName,
    LPWSTR wszRootShare,
    LPWSTR wszFtDfsName,
    PDFSM_ROOT_LIST *ppRootList)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD i, j;

    WCHAR wszDfsConfigDN[MAX_PATH+1];
    WCHAR wszServerShare[MAX_PATH+1];
    LPWSTR wszConfigurationDN = NULL;

    LDAP *pldap = NULL;
    PLDAPMessage pMsg = NULL;

    LDAPModW ldapModServer;
    LPWSTR rgAttrs[5];
    PLDAPModW rgldapMods[6];

    LDAPMessage *pmsgServers;
    PWCHAR *rgServers;
    PWCHAR *rgNewServers;
    DWORD cServers;

    dwErr = DfspLdapOpen(wszDcName, &pldap, &wszConfigurationDN);

    if (dwErr != ERROR_SUCCESS) {

        pldap = NULL;
        goto Cleanup;

    }

    wcscpy(wszDfsConfigDN,L"CN=");
    wcscat(wszDfsConfigDN,wszFtDfsName);
    wcscat(wszDfsConfigDN,L",");
    wcscat(wszDfsConfigDN,wszConfigurationDN);

    wcscpy(wszServerShare,L"\\\\");
    wcscat(wszServerShare,wszServerName);
    wcscat(wszServerShare,L"\\");
    wcscat(wszServerShare,wszRootShare);

    rgAttrs[0] = L"remoteServerName";
    rgAttrs[1] = NULL;

    if (DfsSvcLdap)
        DbgPrint("DfspCreateFtDfsDsObj:ldap_search_s(%ws)\n", rgAttrs[0]);

    dwErr = ldap_search_sW(
                pldap,
                wszDfsConfigDN,
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                rgAttrs,
                0,
                &pMsg);

    DFSM_TRACE_ERROR_HIGH(dwErr, ALL_ERROR,
                          DfspCreateFtDfsDsObj_Error_ldap_search_sW,
                          LOGULONG(dwErr));

    if (dwErr == LDAP_SUCCESS) {

        //
        // We are joining an existing FT Dfs. Append our server\share to it
        //

        pmsgServers = ldap_first_entry(pldap, pMsg);

        if (pmsgServers != NULL) {

            rgServers = ldap_get_valuesW(
                            pldap,
                            pmsgServers,
                            L"remoteServerName");

            if (rgServers != NULL) {

                cServers = ldap_count_valuesW( rgServers );

                //
                // Check that we're not adding the same server in again somehow
                //

                for (i = 0; i < cServers; i++) {

                    if (_wcsicmp(wszServerShare,rgServers[i]) == 0) {

                        dwErr = ERROR_DUP_NAME;
                        ldap_value_freeW( rgServers );
                        ldap_msgfree( pMsg );
                        pMsg = NULL;
                        goto Cleanup;

                    }

                }

                rgNewServers = (PWCHAR *) malloc(sizeof(LPWSTR) * (cServers+2));

                if (rgNewServers != NULL) {

                    CopyMemory( rgNewServers, rgServers, cServers * sizeof(rgServers[0]) );

                    rgNewServers[cServers] = wszServerShare;
                    rgNewServers[cServers+1] = NULL;

                    ldapModServer.mod_op = LDAP_MOD_REPLACE;
                    ldapModServer.mod_type = L"remoteServerName";
                    ldapModServer.mod_vals.modv_strvals = rgNewServers;

                    rgldapMods[0] = &ldapModServer;
                    rgldapMods[1] = NULL;

                    if (DfsSvcLdap)
                        DbgPrint("DfspCreateFtDfsDsObj:ldap_modify(%ws)\n", L"remoteServerName");

                    dwErr = ldap_modify_sW(pldap, wszDfsConfigDN, rgldapMods);

                    DFSM_TRACE_ERROR_HIGH(dwErr, ALL_ERROR,
                                          DfspCreateFtDfsDsObj_Error_ldap_modify_sW_2,
                                          LOGULONG(dwErr));
                    if (dwErr == LDAP_ATTRIBUTE_OR_VALUE_EXISTS)
                        dwErr = LDAP_SUCCESS;

                    if (dwErr != LDAP_SUCCESS) {
                        dwErr = LdapMapErrorToWin32(dwErr);
                    } else {
                        dwErr = ERROR_SUCCESS;
                    }

                    free(rgNewServers);

                } else {

                    dwErr = ERROR_OUTOFMEMORY;
                }

                ldap_value_freeW( rgServers );

            } else {

                dwErr = ERROR_OUTOFMEMORY;

            }

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

        ldap_msgfree( pMsg );
        pMsg = NULL;

    } else {

        dwErr = LdapMapErrorToWin32(dwErr);

    }

    if (dwErr != ERROR_SUCCESS) {

        goto Cleanup;

    }

    //
    // Create list of other roots
    //

    DfspCreateRootServerList(
        pldap,
        wszServerName,
        wszDfsConfigDN,
        ppRootList);

Cleanup:

    if (pMsg != NULL)
        ldap_msgfree(pMsg);

    if (pldap != NULL && pldap != pLdapConnection) {
        if (DfsSvcLdap)
            DbgPrint("DfspCreateFtDfsDsObj:ldap_unbind()\n");
        ldap_unbind( pldap );
    }

    if (wszConfigurationDN == NULL)
        free(wszConfigurationDN);

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspRemoveFtDfsDsObj
//
//  Synopsis:   Updates (by removing from) the Ds objects representing the FtDfs
//
//  Arguments:  wszServerName - Name of server we'll be adding
//              wszDcName - Dc to use
//              wszRootShare - Share to become the root share
//              wszFtDfsName - Name of FtDfs we are creating
//              ppRootList - List of FtDfs roots that need to be informed of
//                              the changed Ds object
//
//  Returns:    NTSTATUS of the call (STATUS_SUCCESS or error)
//
//-----------------------------------------------------------------------------

DWORD
DfspRemoveFtDfsDsObj(
    LPWSTR wszServerName,
    LPWSTR wszDcName,
    LPWSTR wszRootShare,
    LPWSTR wszFtDfsName,
    PDFSM_ROOT_LIST *ppRootList)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOLEAN fFoundIt = FALSE;

    DWORD i, j;
    WCHAR wszDfsConfigDN[MAX_PATH+1];
    WCHAR wszServerShare[MAX_PATH+1];
    LPWSTR wszConfigurationDN = NULL;

    LDAP *pldap = NULL;
    PLDAPMessage pMsg = NULL;

    LDAPModW ldapModServer;
    LPWSTR rgAttrs[5];
    PLDAPModW rgldapMods[6];

    LDAPMessage *pmsgServers;
    PWCHAR *rgServers;
    PWCHAR *rgNewServers;
    DWORD cServers;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfspRemoveFtDfsDsObj(%ws,%ws,%ws,%ws)\n", 
                wszServerName,
                wszDcName,
                wszRootShare,
                wszFtDfsName);
#endif

    dwErr = DfspLdapOpen(wszDcName, &pldap, &wszConfigurationDN);

    if (dwErr != ERROR_SUCCESS) {

        goto Cleanup;

    }

    //
    // Search for the FtDfs object
    //

    wcscpy(wszDfsConfigDN,L"CN=");
    wcscat(wszDfsConfigDN,wszFtDfsName);
    wcscat(wszDfsConfigDN,L",");
    wcscat(wszDfsConfigDN,wszConfigurationDN);

    wcscpy(wszServerShare,L"\\\\");
    wcscat(wszServerShare,wszServerName);
    wcscat(wszServerShare,L"\\");
    wcscat(wszServerShare,wszRootShare);

    rgAttrs[0] = L"remoteServerName";
    rgAttrs[1] = NULL;

    if (DfsSvcLdap)
        DbgPrint("DfspRemoveFtDfsDsObj:ldap_search_s(%ws)\n", rgAttrs[0]);

    dwErr = ldap_search_sW(
                pldap,
                wszDfsConfigDN,
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                rgAttrs,
                0,
                &pMsg);

    DFSM_TRACE_ERROR_HIGH(dwErr, ALL_ERROR,
                          DfspRemoveFtDfsDsObj_Error_ldap_search_sW,
                          LOGULONG(dwErr));

    if (dwErr != LDAP_SUCCESS) {

        dwErr = LdapMapErrorToWin32(dwErr);
        goto Cleanup;

    }

    dwErr = ERROR_SUCCESS;

    //
    // We found a Dfs object to update
    //

    pmsgServers = ldap_first_entry(pldap, pMsg);

    if (pmsgServers != NULL) {

        rgServers = ldap_get_valuesW(
                        pldap,
                        pmsgServers,
                        L"remoteServerName");

        if (rgServers != NULL) {

            cServers = ldap_count_valuesW( rgServers );

            rgNewServers = (PWCHAR *)malloc(sizeof(LPWSTR) * (cServers+1));

            if (rgNewServers != NULL) {
                for (i = j = 0; i < cServers; i += 1) {
                    if (_wcsicmp(wszServerShare, rgServers[i]) == 0) {
                        fFoundIt = TRUE;
                        continue;
                    }
                    rgNewServers[j++] = rgServers[i];
                }
                rgNewServers[j] = NULL;
                if (j > 0 && fFoundIt == TRUE) {
                    ldapModServer.mod_op = LDAP_MOD_REPLACE;
                    ldapModServer.mod_type = L"remoteServerName";
                    ldapModServer.mod_vals.modv_strvals = rgNewServers;

                    rgldapMods[0] = &ldapModServer;
                    rgldapMods[1] = NULL;

                    if (DfsSvcLdap)
                        DbgPrint("DfspRemoveFtDfsDsObj:ldap_modify(%ws)\n", L"remoteServerName");

                    dwErr = ldap_modify_sW(pldap, wszDfsConfigDN, rgldapMods);

                    DFSM_TRACE_ERROR_HIGH(dwErr, ALL_ERROR,
                                          DfspRemoveFtDfsDsObj_Error_ldap_modify_sW,
                                          LOGULONG(dwErr));

                    if (dwErr != LDAP_SUCCESS) {
                        dwErr = LdapMapErrorToWin32(dwErr);
                    } else {
                        dwErr = ERROR_SUCCESS;
                    }
                }

                free(rgNewServers);

            } else {

                dwErr = ERROR_OUTOFMEMORY;
            }

            ldap_value_freeW( rgServers );

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

    } else {

        dwErr = ERROR_OUTOFMEMORY;

    }

    if (pMsg != NULL) {
        ldap_msgfree( pMsg );
        pMsg = NULL;
    }

    if (fFoundIt == FALSE) {

        dwErr = ERROR_OBJECT_NOT_FOUND;
        goto Cleanup;

    }

    if (dwErr != ERROR_SUCCESS) {

        goto Cleanup;

    }

    //
    // Create list of other roots
    //

    DfspCreateRootServerList(
        pldap,
        wszServerName,
        wszDfsConfigDN,
        ppRootList);

Cleanup:

    if (pMsg != NULL)
        ldap_msgfree( pMsg );

    if (pldap != NULL && pldap != pLdapConnection) {
        if (DfsSvcLdap)
            DbgPrint("DfspRemoveFtDfsDsObj:ldap_unbind()\n");
        ldap_unbind( pldap );
    }

    if (wszConfigurationDN != NULL)
        free(wszConfigurationDN);

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfspRemoveFtDfsDsObj returning %d\n", dwErr);
#endif

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspCreateRootServerList
//
//  Synopsis:   Creates a list of root which have to be informed of the change
//                  to the Ds object
//              tells them which DC to go to for the latest blob.
//
//  Arguments:  pldap -- Ldap handle to use
//              wszServerName - Name of server to skip
//              wszDfsConfigDN - The DN to use
//              ppRootList - List of FtDfs roots that need to be informed of
//                              the changed Ds object
//
//  Returns:    NTSTATUS of the call (STATUS_SUCCESS or error)
//
//-----------------------------------------------------------------------------

DWORD
DfspCreateRootServerList(
    IN LDAP *pldap,
    IN LPWSTR wszServerName,
    IN LPWSTR wszDfsConfigDN,
    IN PDFSM_ROOT_LIST *ppRootList)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cServers;
    DWORD cRoots;
    DWORD i;
    PDFSM_ROOT_LIST pRootList = NULL;
    ULONG Size = 0;
    WCHAR *pWc;

    PLDAPMessage pMsg = NULL;
    LDAPMessage *pmsgServers;

    LPWSTR rgAttrs[5];
    PWCHAR *rgServers = NULL;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfspCreateRootServerList(%ws,%ws)\n",
                    wszServerName,
                    wszDfsConfigDN);
#endif

    //
    // Search for the FtDfs object
    //

    rgAttrs[0] = L"remoteServerName";
    rgAttrs[1] = NULL;

    if (DfsSvcLdap)
        DbgPrint("DfspCreateRootServerList:ldap_search_s(%ws)\n", rgAttrs[0]);

    dwErr = ldap_search_sW(
                pldap,
                wszDfsConfigDN,
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                rgAttrs,
                0,
                &pMsg);

    DFSM_TRACE_ERROR_HIGH(dwErr, ALL_ERROR,
                          DfspCreateRootServerList_Error_ldap_search_sW,
                          LOGULONG(dwErr));

    if (dwErr != ERROR_SUCCESS) {

        dwErr = LdapMapErrorToWin32(dwErr);
        goto Cleanup;

    }

    dwErr = ERROR_SUCCESS;

    pmsgServers = ldap_first_entry(pldap, pMsg);

    if (pmsgServers != NULL) {

        rgServers = ldap_get_valuesW(
                        pldap,
                        pmsgServers,
                        L"remoteServerName");

        if (rgServers != NULL) {

            cServers = ldap_count_valuesW( rgServers );

            for (cRoots = i = 0; i < cServers; i++) {
                if (wcslen(rgServers[i]) < 3 ||
                    rgServers[i][0] != UNICODE_PATH_SEP ||
                    _wcsnicmp(wszServerName, &rgServers[i][2], wcslen(wszServerName)) == 0
                ) {
                    continue;
                }
                Size += (wcslen(rgServers[i]) + 1) * sizeof(WCHAR);
                cRoots++;
            }

            Size += FIELD_OFFSET(DFSM_ROOT_LIST,Entry[cRoots+1]);

            pRootList = (PDFSM_ROOT_LIST)MIDL_user_allocate(Size);

            if (pRootList != NULL) {

                RtlZeroMemory(pRootList, Size);

                pRootList->cEntries = cRoots;
                pWc = (WCHAR *)&pRootList->Entry[cRoots+1];

                for (cRoots = i = 0; i < cServers; i++) {
                    if (wcslen(rgServers[i]) < 3 ||
                        rgServers[i][0] != UNICODE_PATH_SEP ||
                        _wcsnicmp(wszServerName, &rgServers[i][2], wcslen(wszServerName)) == 0
                    ) {
                        continue;
                    }
                    pWc = (WCHAR *)MIDL_user_allocate((wcslen(rgServers[i]) + 1) * sizeof(WCHAR));
                    pRootList->Entry[cRoots].ServerShare = pWc;
                    wcscpy(pRootList->Entry[cRoots++].ServerShare, rgServers[i]);
                }

                *ppRootList = pRootList;

            } else {

                dwErr = ERROR_OUTOFMEMORY;

            }

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

    } else {

        dwErr = ERROR_OUTOFMEMORY;

    }

Cleanup:

    if (rgServers != NULL)
        ldap_value_freeW(rgServers);

    if (pMsg != NULL)
        ldap_msgfree( pMsg );

#if DBG
    if (DfsSvcVerbose) {
        DbgPrint("DfspCreateRootServerList dwErr=%d\n", dwErr);
        if (dwErr == NO_ERROR) {
            for (i = 0; i < pRootList->cEntries; i++)
                    DbgPrint("[%d][%ws]\n", i, pRootList->Entry[i].ServerShare);
        }
     }
#endif

    return( dwErr );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfspCreateRootList
//
//  Synopsis:   Helper for adding/removing jp's, really a wrapper for
//                  DfspCreateRootServerList
//
//  Arguments:  DfsEntryPath - Path (of form \\domainname\ftdfsname)
//              DcName - Dc name to be used
//              ppRootList - Pointer to arg for results
//
//  Returns:    [ERROR_SUCCESS] -- Successfully returning list
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Unable to allocate list
//
//              [??] - From ldap open/bind, etc.
//
//-----------------------------------------------------------------------------
DWORD
DfspCreateRootList(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR DcName,
    IN PDFSM_ROOT_LIST *ppRootList)
{
    ULONG start, end;
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR wszDfsConfigDN[MAX_PATH+1];
    WCHAR wszFtDfsName[MAX_PATH+1];
    WCHAR wszComputerName[MAX_PATH+1];
    LPWSTR wszConfigurationDN = NULL;

    LDAP *pldap = NULL;
    LPWSTR rgAttrs[5];

    DFS_NAME_CONVENTION NameType;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfspCreateRootList(%ws,%ws)\n",
            DfsEntryPath,
            DcName);
#endif

    if (DfsEntryPath == NULL || DcName == NULL) {

        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;

    }

    NameType = (ulDfsManagerType == DFS_MANAGER_FTDFS) ? DFS_NAMETYPE_DNS : DFS_NAMETYPE_EITHER;
    dwErr = GetDomAndComputerName( NULL, wszComputerName, &NameType);

    if (dwErr != ERROR_SUCCESS) {

        dprintf((
            DEB_ERROR,
            "Win32 Error %d getting Domain/Computer name\n", dwErr));

        goto Cleanup;

    }
    //
    // Extract the ftdfs name from the DfsEntryPath
    //

    for (start = 1;
        DfsEntryPath[start] != UNICODE_PATH_SEP && DfsEntryPath[start] != UNICODE_NULL;
            start++) {

        NOTHING;

    }

    if (DfsEntryPath[start] == UNICODE_PATH_SEP)
        start++;

    for (end = start;
        DfsEntryPath[end] != UNICODE_PATH_SEP && DfsEntryPath[end] != UNICODE_NULL;
            end++) {

         NOTHING;
         
    }

    if (DfsEntryPath[start] == UNICODE_PATH_SEP)
        end--;

    if (start >= end) {

        ERROR_INVALID_PARAMETER;

    }

    RtlZeroMemory(wszFtDfsName, sizeof(wszFtDfsName));
    RtlCopyMemory(wszFtDfsName, &DfsEntryPath[start], (end - start) * sizeof(WCHAR));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("wszFtDfsName=[%ws]\n", wszFtDfsName);
#endif

    //
    // Open & bind to the ds
    //

    dwErr = DfspLdapOpen(DcName, &pldap, &wszConfigurationDN);

    if (dwErr != ERROR_SUCCESS) {

        goto Cleanup;

    }

    //
    // Search for the FtDfs object
    //

    wcscpy(wszDfsConfigDN,L"CN=");
    wcscat(wszDfsConfigDN,wszFtDfsName);
    wcscat(wszDfsConfigDN,L",");
    wcscat(wszDfsConfigDN,wszConfigurationDN);

    //
    // Create the list of roots
    //

    dwErr = DfspCreateRootServerList(
                    pldap,
                    wszComputerName,
                    wszDfsConfigDN,
                    ppRootList);

Cleanup:

    if (pldap != NULL && pldap != pLdapConnection) {
        if (DfsSvcLdap)
            DbgPrint("DfspCreateRootList:ldap_unbind()\n");
        ldap_unbind( pldap );
    }

    if (wszConfigurationDN != NULL)
        free(wszConfigurationDN);

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfspCreateRootList returning %d\n", dwErr);
#endif

    return dwErr;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspLdapOpen
//
//  Synopsis:   Open ldap storage and returns the object name of the
//                  Dfs-Configuration object.
//
//  Arguments:  DfsEntryPath - wszDcName - Dc name to be used
//              ppldap -- pointer to pointer to ldap obj, filled in on success
//              pwszObjectName -- pointer to LPWSTR for name of dfs-config object
//
//  Returns:    [ERROR_SUCCESS] -- Successfully returning list
//
//              [??] - From ldap open/bind, etc.
//
//-----------------------------------------------------------------------------
DWORD
DfspLdapOpen(
    LPWSTR wszDcName,
    LDAP **ppldap,
    LPWSTR *pwszObjectName)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD i;
    ULONG Size;

    PLDAPMessage pMsg = NULL;
    LDAP *pldap = NULL;
    LPWSTR rgAttrs[5];

    if ( ppldap == NULL || pwszObjectName == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfspLdapOpen(%ws,0x%x)\n", wszDcName,*ppldap);
#endif

    //
    // We must be given either a DC name or an ldap connection.  If neither, then
    // return an error.
    //
    if (*ppldap == NULL && wszDcName == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // If we were given an ldap connection, but no DC name, then we just want
    // the name of the dfs config object.
    //
    if (wszDcName == NULL) {
        pldap = *ppldap;
        goto GetConfigObject;
    }

    //
    // We were given a DC name and possibly an ldap connection.
    //

    if (*ppldap == NULL || pLdapConnection == NULL || pwszDSMachineName == NULL) {

        if (pLdapConnection != NULL &&
            pwszDSMachineName != NULL &&
            wszDcName != NULL &&
            wcscmp(pwszDSMachineName, wszDcName) == 0) {
            pldap = pLdapConnection;
            dwErr = ERROR_SUCCESS;
        } else {
            if (DfsSvcLdap)
                DbgPrint("DfspLdapOpen:ldap_init(%ws)\n", wszDcName);

            pldap = ldap_initW(wszDcName, LDAP_PORT);
            if (pldap == NULL) {
#if DBG
                if (DfsSvcVerbose)
                    DbgPrint("DfspLdapOpen:ldap_init failed\n");
#endif
                LdapGetLastError();
                dwErr = ERROR_INVALID_NAME;
                goto Cleanup; // added to prevent error masking!!
            }

	    dwErr = ldap_set_option(pldap, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);
	    if (dwErr != LDAP_SUCCESS) {

		dprintf((
			 DEB_ERROR,
			 "ldap_set_option failed with ldap error %d\n", dwErr));

		pldap = NULL;

		goto Cleanup;

	    }

            if (DfsSvcLdap)
                DbgPrint("DfspLdapOpen:ldap_bind()\n");
            dwErr = ldap_bind_s(pldap, NULL, NULL, LDAP_AUTH_SSPI);

            DFSM_TRACE_ERROR_HIGH(dwErr, ALL_ERROR,
                                  DfspLdapOpen_Error_ldap_bind_s,
                                  LOGULONG(dwErr));

            if (dwErr != LDAP_SUCCESS) {
#if DBG
                if (DfsSvcVerbose)
                    DbgPrint("ldap_bind_s failed with ldap error %d\n", dwErr);
#endif
                pldap = NULL;
                dwErr = LdapMapErrorToWin32(dwErr);
                goto Cleanup;
            }
            if (DfsSvcLdap)
                DbgPrint("DfspLdapOpen:pLdapConnection set to %ws\n", wszDcName);
            if (pLdapConnection != NULL)
                ldap_unbind(pLdapConnection);
            pLdapConnection = pldap;
            pwszDSMachineName = wszDSMachineName;
            wcscpy(pwszDSMachineName, wszDcName);
            if (DfsSvcLdap)
                DbgPrint("DfspLdapOpen:pLdapConnection:0x%x\n", pLdapConnection);
        }

    } else {
        pldap = *ppldap;
    }

    //
    // Get attribute "defaultNameContext" containing name of entry we'll be
    // using for our DN
    //
GetConfigObject:

    if (gConfigurationDN == NULL) {

        rgAttrs[0] = L"defaultnamingContext";
        rgAttrs[1] = NULL;

        if (DfsSvcLdap)
            DbgPrint("DfspLdapOpen:ldap_search_s(%ws)\n", rgAttrs[0]);

        dwErr = ldap_search_sW(
                    pldap,
                    L"",
                    LDAP_SCOPE_BASE,
                    L"(objectClass=*)",
                    rgAttrs,
                    0,
                    &pMsg);

        DFSM_TRACE_ERROR_HIGH(dwErr, ALL_ERROR,
                              DfspLdapOpen_Error_ldap_search_sW,
                              LOGULONG(dwErr));

        if (dwErr == LDAP_SUCCESS) {

            PLDAPMessage pEntry = NULL;
            PWCHAR *rgszNamingContexts = NULL;
            DWORD i, cNamingContexts;

            dwErr = ERROR_SUCCESS;

            if ((pEntry = ldap_first_entry(pldap, pMsg)) != NULL &&
                    (rgszNamingContexts = ldap_get_valuesW(pldap, pEntry, rgAttrs[0])) != NULL &&
                        (cNamingContexts = ldap_count_valuesW(rgszNamingContexts)) > 0) {

                gConfigurationDN = (LPWSTR)malloc((wcslen(*rgszNamingContexts)+1) * sizeof(WCHAR));
                if (gConfigurationDN == NULL)
                    dwErr = ERROR_OUTOFMEMORY;
                else
                    wcscpy( gConfigurationDN, *rgszNamingContexts );
            } else {
                dwErr = ERROR_UNEXP_NET_ERR;
            }

            if (rgszNamingContexts != NULL)
                ldap_value_freeW( rgszNamingContexts );

        } else {

            dwErr = LdapMapErrorToWin32(dwErr);

        }

        if (dwErr != ERROR_SUCCESS) {
#if DBG
            if (DfsSvcVerbose)
                DbgPrint("Unable to find Configuration naming context\n");
#endif
            goto Cleanup;
        }

    }

    //
    // Create string with full object name
    //

    Size = wcslen(DfsConfigContainer) * sizeof(WCHAR) +
                sizeof(WCHAR) +
                    wcslen(gConfigurationDN) * sizeof(WCHAR) +
                        sizeof(WCHAR);

    *pwszObjectName = (LPWSTR)malloc(Size);

    if (*pwszObjectName == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
     }

    wcscpy(*pwszObjectName,DfsConfigContainer);
    wcscat(*pwszObjectName,L",");
    wcscat(*pwszObjectName,gConfigurationDN);

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfspLdapOpen:object name=[%ws]\n", *pwszObjectName);
#endif

Cleanup:

    //
    // If we had an error and we check if the ldap connection was passed in.
    // If not, and it is not pLdapConnection, close it.
    //
    if (dwErr != ERROR_SUCCESS &&
            pldap != NULL &&
                pldap != pLdapConnection &&
                    *ppldap == NULL) {
        if (DfsSvcLdap)
            DbgPrint("DfspLdapOpen:ldap_unbind()\n");
        ldap_unbind( pldap );
        pldap = NULL;
    }

    if (pMsg != NULL)
        ldap_msgfree(pMsg);

    if (*ppldap == NULL) {
        *ppldap = pldap;
    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfspLdapOpen:returning %d\n", dwErr);
#endif
    return( dwErr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\svclist.cxx ===
//+-------------------------------------------------------------------------
//
//  File:       svclist.cxx
//
//  Contents:   A Class for the serviceList on volume objects. This is the
//              implementation for this class.
//
//
//  History:    28-Jan-93       SudK            Created
//              11-May-93       SudK            Ported to Cairole with changes.
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

extern "C" {
#include "dfsmrshl.h"
}
#include "marshal.hxx"
#include "recon.hxx"
#include "svclist.hxx"


//+------------------------------------------------------------------------
//
// Member:      CDfsServiceList::CDfsServiceList, public
//
// Synopsis:    This is the constructor and it does nothing.
//
// Arguments:   None
//
// Returns:     Nothing.
//
// History:     28-Jan-1993     Sudk    Created.
//
//-------------------------------------------------------------------------

CDfsServiceList::CDfsServiceList(void)
{
    IDfsVolInlineDebOut((
        DEB_TRACE, "CDfsServiceList::+CDfsServiceList(0x%x)\n",
        this));

    //
    // Actually we do nothing at this point but to set the private variables
    // to NULL etc. We need an IProp reference to do anything.
    //
    _fInitialised = FALSE;
    _pDfsSvcList = NULL;
    _cSvc = 0;
    _pDeletedSvcList = NULL;
    _cDeletedSvc = 0;
    _SvcListBuffer = NULL;
    _pPSStg = NULL;
    memset(&_ReplicaSetID, 0, sizeof(GUID));

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::CDfsServiceList() exit\n"));

}


//+------------------------------------------------------------------------
//
// Member:      CDfsServiceList::InitializeServiceList, public
//
// Synopsis:    This is the routine that initialises the serviceList
//              by reading off the property. This is the function which will
//              read off the ServiceList property and setup the list in the
//              private section.
//
// Arguments:   [pPSStg] --     The IPropertySetStg interface is passed here.
//
// Returns:     ERROR_SUCCESS -- If all went well.
//              NERR_DfsVolumeDataCorrupt - If service list not found etc.
//
// Notes:       Will throw an exception if memory failure occurs.
//
// History:     28-Jan-1993     Sudk    Created.
//
//-------------------------------------------------------------------------

DWORD
CDfsServiceList::InitializeServiceList(
    CStorage *pPSStg)
{
    DWORD     dwErr;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::InitServiceList()\n"));

    ASSERT( _pPSStg == NULL );

    _pPSStg = pPSStg;
    _pPSStg->AddRef();

    dwErr = ReadServiceListProperty();

    if (dwErr != ERROR_SUCCESS)
        return( dwErr );

    //
    // Now we get the SvcList and put it into the private section of
    // our class. Notice that the following function directly manipulates
    // the private list that we have. This is a private member of this class.
    //

    dwErr = DeSerializeSvcList();

    if (dwErr != ERROR_SUCCESS)
        return( dwErr );

    //
    // Now we have initialised the ServiceList class and can take all requests.
    //
    _fInitialised = TRUE;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::InitServiceList() exit\n"));

    return( dwErr );

}


//+------------------------------------------------------------------------
//
// Member:      CDfsServiceList::~CDfsServiceList, public
//
// Synopsis:    The Destructor. Gets rid of all the memory.
//
// Arguments:   None
//
// Returns:     Nothing.
//
// Notes:       This assumes that the constructor used "new" to allocate
//              memory for the strings in the private structure.
//
// History:     26-Jan-93       SudK    Created.
//
//-------------------------------------------------------------------------
CDfsServiceList::~CDfsServiceList(void)
{
    CDfsService *tempSvc, *nextSvc;
    ULONG i;

    IDfsVolInlineDebOut((
        DEB_TRACE, "CDfsServiceList::~CDfsServiceList(0x%x)\n",
        this));

#if DBG
    if (DfsSvcVerbose & 0x80000000)
        DbgPrint("CDfsServiceList::~CDfsServiceList @0x%x\n", this);
#endif

    //
    // Deallocate some memory that might still be hanging around here.
    //
    if (_SvcListBuffer != NULL)
        delete [] _SvcListBuffer;

    //
    // We walk through the list that we have and destroy each of the
    // elements in the list that we maintain. This should take care of
    // cases of zero elements etc. cleanly. This is So Simple!
    //
    tempSvc = _pDfsSvcList;

    for (i = 0; i < _cSvc; i++)      {
        nextSvc = GetNextService(tempSvc);
        delete tempSvc;
        tempSvc = nextSvc;
    }

    tempSvc = _pDeletedSvcList;

    for (i = 0; i < _cDeletedSvc; i++)      {
        nextSvc = GetNextDeletedService(tempSvc);
        delete tempSvc;
        tempSvc = nextSvc;
    }

    if (_pPSStg != NULL)
        _pPSStg->Release();

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::~CDfsServiceList() exit\n"));

}


//+------------------------------------------------------------------------
//
// Member:      SetNullSvcList, public
//
// Synopsis:    This method sets a Null SvcList in the ReplicaList Property
//
// Arguments:   [pPSStg] -- The CStorage pointer where props are to be
//                      saved
//
// History:     May-17-1993     SudK    Created.
//
//-------------------------------------------------------------------------
DWORD
CDfsServiceList::SetNullSvcList(
    CStorage  *pPSStg)
{
    DWORD     dwErr = ERROR_SUCCESS;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::SetNullSvcList()\n"));

    ASSERT( _pPSStg == NULL );

    _pPSStg = pPSStg;
    _pPSStg->AddRef();

    //
    // pBuffer gets allocated here. Use Smart Pointers to avoid memory leaks.
    //
    dwErr = SerializeSvcList();

    if (dwErr != ERROR_SUCCESS) {
        return( dwErr );
    }

    //
    // Now we get the SvcList and put it into the private section of
    // our class. Notice that the following function directly manipulates
    // the private list that we have. This is a private member of this class.
    //
    dwErr = SetServiceListProperty(TRUE);

    if (dwErr != ERROR_SUCCESS)     {
        return( dwErr );
    }

    //
    // Now we have initialised the ServiceList class and can take all requests.
    //
    _fInitialised = TRUE;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::SetNullSvcList() exit\n"));

    return( dwErr );

}


//+------------------------------------------------------------------------
//
// Member:      CDfsServiceList::GetServiceFromPrincipalName(), public
//
// Synopsis:    Returns the Service structure in the form of the class for
//              the requested service.
//
// Arguments:   [pwszSvcName] --        The Service for which PktService
//                                      is requested.
//              [ppService] --          The pointer to CDfsService is returned here.
//
// Returns:     ERROR_SUCCESS - If everything was OK.
//              NERR_DfsNoSuchShare - If service requested not found.
//
// Notes:       Note that this method returns a pointer to the structures in
//              the private section of its class. This memory should not be
//              modified or released.
//
// History:     28-Jan-93       SudK    Created.
//
//-------------------------------------------------------------------------
DWORD
CDfsServiceList::GetServiceFromPrincipalName(
    WCHAR CONST *pwszServiceName,
    CDfsService **ppDfsSvc
)
{
    IDfsVolInlineDebOut((DEB_TRACE,
                "CDfsServiceList::GetServiceFromPrincipalName(%ws)\n",
                pwszServiceName));

    CDfsService *tempSvcPtr;
    PWCHAR      pwch;

    if (pwszServiceName == NULL)
        return(NERR_DfsNoSuchShare);

    tempSvcPtr = GetFirstService();

    while (tempSvcPtr != NULL)  {
        pwch = tempSvcPtr->GetServiceName();

        if ((pwch == NULL) || (_wcsicmp(pwszServiceName, pwch))) {
            tempSvcPtr = GetNextService(tempSvcPtr);
        } else {
            *ppDfsSvc = tempSvcPtr;
            IDfsVolInlineDebOut(
                    (DEB_TRACE,
                    "CDfsServiceList::GetServiceFromPrincipalName() exit\n"));
            return(ERROR_SUCCESS);
        }
    }

    //
    // Could not find anything with the ServiceName passed in.
    //

    *ppDfsSvc = NULL;

    IDfsVolInlineDebOut(
            (DEB_TRACE,"CDfsServiceList::GetServiceFromPrincipalName() exit\n"));

    return(NERR_DfsNoSuchShare);
}


//+----------------------------------------------------------------------------
//
//  Function:   CDfsServiceList::GetDeletedServiceFromPrincipalName, private
//
//  Synopsis:   Searches the deleted svc list for a service with the given
//              principal name.
//
// Arguments:   [pwszSvcName] --        The Service for which PktService
//                                      is requested.
//              [ppService] --          The pointer to CDfsService is returned here.
//
// Returns:     ERROR_SUCCESS - If everything was OK.
//              NERR_DfsNoSuchShare - If service requested not found.
//
// Notes:       Note that this method returns a pointer to the structures in
//              the private section of its class. This memory should not be
//              modified or released.
//
// History:     20-April-95     Milans    Created.
//
//-------------------------------------------------------------------------
DWORD
CDfsServiceList::GetDeletedServiceFromPrincipalName(
    WCHAR CONST *pwszServiceName,
    CDfsService **ppDfsSvc
)
{
    CDfsService *tempSvcPtr;
    PWCHAR      pwch;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::GetDeletedServiceFromPrincipalName(%ws)\n",
            pwszServiceName));

    if (pwszServiceName == NULL)
        return(NERR_DfsNoSuchShare);

    tempSvcPtr = GetFirstDeletedService();

    //
    // This routine is really a little flaky since not all services have
    // PrincipalNames associated with them.
    //

    while (tempSvcPtr != NULL)  {
        pwch = tempSvcPtr->GetServiceName();

        if ((pwch == NULL) || (_wcsicmp(pwszServiceName, pwch))) {
                tempSvcPtr = GetNextDeletedService(tempSvcPtr);
        }
        else    {
                *ppDfsSvc = tempSvcPtr;
                IDfsVolInlineDebOut(
                    (DEB_TRACE,
                    "CDfsServiceList::GetDeletedServiceFromPrincipalName() exit\n"));
                return(ERROR_SUCCESS);
        }
    }
    //
    // Could not find anything with the PrincipalName passed in.
    //
    *ppDfsSvc = NULL;

    IDfsVolInlineDebOut(
        (DEB_TRACE, "CDfsServiceList::GetDeletedServiceFromPrincipalName() exit\n"));

    return(NERR_DfsNoSuchShare);
}



//+------------------------------------------------------------------------
//
// Member:      CDfsServiceList::GetService(), public
//
// Synopsis:    Returns the Service structure in the form of the class for
//              the requested service.
//
// Arguments:   [pReplicaInfo] --       The ReplicaInfo for which CDfsService
//                                      is requested.
//              [ppService] --          The pointer to CDfsService is returned here.
//
// Returns:     ERROR_SUCCESS - If everything was OK.
//              NERR_DfsNoSuchShare - If service requested not found.
//
// Notes:       Note that this method returns a pointer to the structures in
//              the private section of its class. This memory should not be
//              modified or released.
//
// History:     28-Jan-93       SudK    Created.
//
//-------------------------------------------------------------------------
DWORD
CDfsServiceList::GetService(
    PDFS_REPLICA_INFO   pReplicaInfo,
    CDfsService         **ppDfsSvc)
{
    CDfsService *tempSvcPtr;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::GetService()\n"));

    tempSvcPtr = GetFirstService();

    while (tempSvcPtr != NULL)  {

        //
        // Check whether this ReplicaInfo struct represents the same service
        //

        if (tempSvcPtr->IsEqual(pReplicaInfo))  {
                *ppDfsSvc = tempSvcPtr;
                IDfsVolInlineDebOut(
                    (DEB_TRACE,
                    "CDfsServiceList::GetService() exit\n"));
                return(ERROR_SUCCESS);
        }

        tempSvcPtr = GetNextService(tempSvcPtr);

    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::GetService() exit\n"));

    return(NERR_DfsNoSuchShare);
}


//+------------------------------------------------------------------------
//
// Member:      CDfsServiceList::GetDeletedService(), public
//
// Synopsis:    Returns the Service structure in the form of the class for
//              the requested service.
//
// Arguments:   [pReplicaInfo] --       The ReplicaInfo for which CDfsService
//                                      is requested.
//              [ppService] --          The pointer to CDfsService is returned here.
//
// Returns:     ERROR_SUCCESS - If everything was OK.
//              NERR_DfsNoSuchShare - If service requested not found.
//
// Notes:       Note that this method returns a pointer to the structures in
//              the private section of its class. This memory should not be
//              modified or released.
//
// History:     28-Jan-93       SudK    Created.
//
//-------------------------------------------------------------------------
DWORD
CDfsServiceList::GetDeletedService(
    PDFS_REPLICA_INFO   pReplicaInfo,
    CDfsService         **ppDfsSvc)
{
    CDfsService *tempSvcPtr;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::GetDeletedService()\n"));

    tempSvcPtr = GetFirstDeletedService();

    while (tempSvcPtr != NULL)  {

        //
        // Check whether this ReplicaInfo struct represents the same service
        //

        if (tempSvcPtr->IsEqual(pReplicaInfo))  {
                *ppDfsSvc = tempSvcPtr;
                IDfsVolInlineDebOut(
                    (DEB_TRACE, "CDfsServiceList::GetDeletedService() exit\n"));
                return(ERROR_SUCCESS);
        }

        tempSvcPtr = GetNextDeletedService(tempSvcPtr);

    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::GetDeletedService() exit\n"));

    return(NERR_DfsNoSuchShare);
}


//+------------------------------------------------------------------------
//
// Member:      CDfsServiceList::SetNewService(), public
//
// Synopsis:    This method takes a new service description and associates
//              this with the volume object. It also makes sure that the
//              service being associated does not already exist in the list.
//
// Arguments:   [pSvcEntry] --  The Svc that needs to be added to service List.
//
// Returns:     ERROR_SUCCESS - If it succeeded.
//              NERR_DfsVolumeDataCorrupt - If it cannot set properties.
//              NERR_DfsDuplicateService - If service already exists.
//
// Notes:       The ptr to the CDfsService class passed in here should not be
//              deallocated by the caller. The instance is gobbled up by
//              this method.
//
// History:     28-Jan-93       SudK    Created.
//
//-------------------------------------------------------------------------

DWORD
CDfsServiceList::SetNewService(CDfsService      *pService)
{
    CDfsService         *tempSvcPtr = NULL;
    DWORD             dwErr = ERROR_SUCCESS;
    PWCHAR              pwszName;
    SYSTEMTIME          st;
    FILETIME            ftService;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::SetNewService()\n"));

    //
    // First we need to make sure that this service is not there in the list
    // already. If so we return an error code.
    //

    dwErr = GetService(pService->GetReplicaInfo(), &tempSvcPtr);
    if (dwErr == ERROR_SUCCESS)  {

        pwszName = pService->GetServiceName();

        LogMessage(DEB_TRACE,
                   &pwszName,
                   1,
                   DFS_SERVICE_ALREADY_EXISTS_MSG);

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("CDfsServiceList::SetNewService: returning NERR_DfsDuplicateService\n");
#endif
        return(NERR_DfsDuplicateService);
    }

    //
    // We just take the Service instance that we got and goble it up.
    //
    GetSystemTime( &st );
    SystemTimeToFileTime( &st, &ftService );
    pService->SetModificationTime( ftService );
    InsertNewService(pService);

    //
    // Now we have to update the Service list on the disk as well.
    // Serialize the list and then call SetServiceProperty to set the property
    // on the volume object. However, if we fail to do that then we should
    // remove the service that we just added into the list. That will be a
    // simple INLINE operation. Ofcourse we also need to delete it.
    //

    dwErr = SerializeSvcList();

    if (dwErr == ERROR_SUCCESS)
        dwErr = SetServiceListProperty(FALSE);

    if (dwErr != ERROR_SUCCESS)     {

        RemoveService(pService);

        IDfsVolInlineDebOut((
                        DEB_TRACE,
                        "Failed to SetNewService %ws and got Error: %x\n",
                        pService->GetServiceName(),
                        dwErr));

        delete pService;
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::SetNewService() exit\n"));

    return( dwErr );
}


//+------------------------------------------------------------------------
//
// Function:    CDfsServiceList::DeleteService(), public
//
// Synopsis:    This method deletes a service from the service list on the
//              volume object. This only deals with the ServiceList property.
//
// Arguments:   [pService] --   The Service to be deleted.
//              [fAddToDeletedList] -- If true, the deleted service will be
//                      added to the deleted list for reconciliation.
//
// Returns:     ERROR_SUCCESS - If all went well.
//              DFS_E_NOSUCH_SERVICE - If service does not exist at all.
//              NERR_DfsVolumeDataCorrupt - If volume object seems to be bad.
//
// Notes:       If this operation succeeds, the service instance passed in
//              will be deleted and should not be touched after this call.
//
//              However, if this operation fails, the service instance passed
//              in will NOT be freed and the caller is responsible for
//              freeing it.
//
// History:     28-Jan-93       SudK    Created
//
//-------------------------------------------------------------------------
DWORD
CDfsServiceList::DeleteService(
    CDfsService      *pService,
    CONST BOOLEAN    fAddToDeletedList)
{
    DWORD     dwErr = ERROR_SUCCESS;
    SYSTEMTIME  st;
    FILETIME    ftDelete;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::DeleteService()\n"));

    //
    // We remove this service from the private Service List that we have.
    //
    RemoveService(pService);
    GetSystemTime( &st );
    SystemTimeToFileTime( &st, &ftDelete );
    pService->SetModificationTime( ftDelete );
    if (fAddToDeletedList) {
        InsertDeletedService(pService);
    }

    //
    // Now we go and set the serviceList on the volume object itself.
    // If we fail to do so we must bring back our service list to the
    // original state itself.
    //

    dwErr = SerializeSvcList();
    CHECK_RESULT(dwErr)

    if (dwErr != ERROR_SUCCESS)     {
        IDfsVolInlineDebOut((DEB_ERROR, "Serialization failed for some unknown reason %08lx\n", dwErr));
        dwErr = SetNewService(pService);
        CHECK_RESULT(dwErr)
        return( dwErr );
    }

    dwErr = SetServiceListProperty(FALSE);
    CHECK_RESULT(dwErr)

    if (dwErr != ERROR_SUCCESS)     {
        dwErr = SetNewService(pService);
        CHECK_RESULT(dwErr)
        return( dwErr );
    } else {
        if (!fAddToDeletedList) {
            delete pService;
        }
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::DeleteService() exit\n"));

    return( dwErr );
}


//+----------------------------------------------------------------------------
//
//  Function:   CDfsServiceList::ReconcileSvcList
//
//  Synopsis:   Reconciles this service list with that from a remote object.
//
//  Arguments:  [cSvc] -- The number of services in the remote svc list.
//              [pSvcList] -- The remote svc list.
//              [cDeletedSvc] -- The number of services in the deleted list.
//              [pDeletedSvcList] -- The list of deleted services.
//
//  Returns:    [ERROR_SUCCESS] -- If changes were successfully made, and if the
//                      resulting service list is not identical to the remote
//              [RES_S_OBJECTSIDENTICAL] -- If changes were successfully
//                      made and the resulting service list is identical to
//                      the remote.
//
//-----------------------------------------------------------------------------

DWORD
CDfsServiceList::ReconcileSvcList(
    ULONG cSvc,
    CDfsService *pSvcList,
    ULONG cDeletedSvc,
    CDfsService *pDeletedSvcList)
{
    DWORD dwErrReturn = ERROR_SUCCESS, dwErr;
    CDfsService *pSrcSvc, *pTgtSvc;
    FILETIME ftSrc, ftTgt;
    ULONG i;

    //
    // We first handle the remote deleted service list.
    //  For each service in deleted list:
    //      if (Found(OurSvcList))
    //          if (OurSvcModTime < DeleteTime))
    //              DeleteFrom(OurSvcList);
    //          else
    //              InsertInto(OurDeletedSvcList);
    //      else
    //          if (Found(OurDeletedSvcList))
    //              UpdateDeletionTime();
    //          else
    //              InsertInto(OurDeletedSvcList);
    //  End For
    //

    for (i = 0, pSrcSvc = pDeletedSvcList;
            i < cDeletedSvc;
                i++, pSrcSvc = pSrcSvc->Next) {

        BOOL fAddToDeletedList;

        fAddToDeletedList = FALSE;

        dwErr = GetService(
                pSrcSvc->GetReplicaInfo(),
                &pTgtSvc);

        if (dwErr == ERROR_SUCCESS) {

            //
            // Found a service with the same principal name in our Svc List
            //

            ftSrc = pSrcSvc->GetModificationTime();

            ftTgt = pTgtSvc->GetModificationTime();

            if (IsFTOlder(ftTgt, ftSrc)) {

                RemoveService( pTgtSvc );
                pTgtSvc->SetModificationTime( ftSrc );
                InsertDeletedService( pTgtSvc );

            } else {

                fAddToDeletedList = TRUE;

            }

        } else { // Unable to find the service in our active list...

            dwErr = GetDeletedService(
                    pSrcSvc->GetReplicaInfo(),
                    &pTgtSvc);

            if (dwErr == ERROR_SUCCESS) {

                ftSrc = pSrcSvc->GetModificationTime();

                ftTgt = pTgtSvc->GetModificationTime();

                if (IsFTOlder( ftTgt, ftSrc )) {

                    pTgtSvc->SetModificationTime( ftSrc );

                }

            } else {

                fAddToDeletedList = TRUE;

            }

        }

        if (fAddToDeletedList) {

            CDfsService *pNewDeletedSvc;

            pNewDeletedSvc = new CDfsService(
                                    pSrcSvc->GetReplicaInfo(),
                                    FALSE,
                                    &dwErr);

            if (pNewDeletedSvc != NULL) {

                if (dwErr == ERROR_SUCCESS) {

                    pNewDeletedSvc->SetModificationTime( ftSrc );

                    InsertDeletedService( pNewDeletedSvc );

                } else {

                    delete pNewDeletedSvc;

                    dwErrReturn = dwErr;
                }

            } else {

                IDfsVolInlineDebOut((
                    DEB_ERROR,
                    "Dfs Manager: Out of memory reconciling deleted svc\n"
                    ));

                dwErrReturn = ERROR_OUTOFMEMORY;

            }

        }

    }

    //
    // Next, we reconcile the active list. This is simple - for each service
    // in the remote active list, if we find it in our active list, we
    // reconcile the two services. If we don't find it in our active list,
    // we add it in.
    //

    for (i = 0, pSrcSvc = pSvcList;
            i < cSvc;
                i++, pSrcSvc = pSrcSvc->Next) {

        dwErr = GetService(
                pSrcSvc->GetReplicaInfo(),
                &pTgtSvc);

        ftSrc = pSrcSvc->GetModificationTime();

        if (dwErr == ERROR_SUCCESS) {

            ftTgt = pTgtSvc->GetModificationTime();

            if (IsFTOlder( ftTgt, ftSrc )) {

                pTgtSvc->SetModificationTime( ftSrc );

            }

        } else { // Newly added service, add it to our list

            CDfsService *pNewSvc;

            pNewSvc = new CDfsService(
                            pSrcSvc->GetReplicaInfo(),
                            TRUE,
                            &dwErr );

            if (pNewSvc != NULL) {

                if (dwErr == ERROR_SUCCESS) {

                    pNewSvc->SetModificationTime( ftSrc );

                    InsertNewService( pNewSvc );

                } else {

                    delete pNewSvc;

                    dwErrReturn = dwErr;

                }

            } else {

                IDfsVolInlineDebOut((
                    DEB_ERROR,
                    "Dfs Manager: Out of memory reconciling new svc\n"
                    ));

                dwErrReturn = ERROR_OUTOFMEMORY;

            }

        }

    }

    //
    // Save the reconciled list on the volume object.
    //

    if (dwErrReturn == ERROR_SUCCESS) {

        dwErrReturn = SerializeSvcList();

        if (dwErrReturn == ERROR_SUCCESS) {

            dwErrReturn = SetServiceListProperty( FALSE );

            if (FAILED(dwErrReturn)) {

                IDfsVolInlineDebOut((
                    DEB_ERROR, "Error %08lx setting service list property\n",
                    dwErrReturn));

            }

        } else {

            IDfsVolInlineDebOut((
                DEB_ERROR, "Error %08lx serializing service list\n",
                dwErrReturn));

        }

    }

    //
    // Finally, see if the two lists are identical, so that we can return
    // REC_S_OBJECTSIDENTICAL when appropriate
    //

    if (dwErrReturn == ERROR_SUCCESS) {

        if (_cSvc == cSvc && _cDeletedSvc == cDeletedSvc) {

            dwErrReturn = NERR_DfsDataIsIdentical;

            //
            // It is sufficient for _cSvc == cSvc and
            // _cDeletedSvc == cDeletedSvc to prove that the svc lists are
            // identical.
            //

        }

    }

    return( dwErrReturn );

}


//+------------------------------------------------------------------------
//
// Function:    CDfsServiceList::ReadServiceListProperty(), private
//
// Synopsis:    This method reads the service list property and puts the
//              buffer in the private section of this instance.
//
// Arguments:   None
//
// Returns:     ERROR_SUCCESS - If all went well.
//              NERR_DfsVolumeDataCorrupt - Volume object is corrupt.
//
// Notes:
//
// History:     28-Jan-93       SudK    Created
//
//-------------------------------------------------------------------------
DWORD
CDfsServiceList::ReadServiceListProperty(void)
{
    DWORD             dwErr = ERROR_SUCCESS;
    BYTE                *pBuffer;
    ULONG               size;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::ReadServiceListProperty()\n"));

    dwErr = _pPSStg->GetSvcProps( &pBuffer, &size );

    if (dwErr != ERROR_SUCCESS)     {
        IDfsVolInlineDebOut(
            (DEB_ERROR, "Unable to read serviceList Props %08lx\n", dwErr));
        return( dwErr );
    }

    if (_SvcListBuffer != NULL)
        delete [] _SvcListBuffer;

    _SvcListBuffer = new BYTE[size + sizeof(ULONG)];
    if (_SvcListBuffer == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    *(PULONG) _SvcListBuffer = size;
    memcpy(_SvcListBuffer + sizeof(ULONG), pBuffer, size);

Cleanup:
    //
    // We need to dismiss the results now.
    //
    delete [] pBuffer;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::ReadServiceListProperty() exit\n"));

    return( dwErr );

}


//+----------------------------------------------------------------------------
//
//  Function:   CDfsServiceList::DeSerializeBuffer
//
//  Synopsis:   Helper function that deserializes a marshalled service list
//
//  Arguments:  [pBuffer] -- The buffer to deserialize
//              [pcSvc] -- The count of services in *ppSvcList is returned
//                      here
//              [ppSvcList] -- The service list is returned here.
//              [pcDeletedSvc] -- The count of deleted services in
//                      *ppDeletedSvcList.
//              [ppDeletedSvcList] -- The list of deleted services is
//                      returned here.
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
CDfsServiceList::DeSerializeBuffer(
    PBYTE pBuffer,
    ULONG *pcSvc,
    CDfsService **ppSvcList,
    ULONG *pcDeletedSvc,
    CDfsService **ppDeletedSvcList)
{
    PBYTE               pBufferEnd;
    DWORD             dwErr = ERROR_SUCCESS;
    CDfsService         *pSvcPtr = NULL;
    ULONG               count, i, size, bufsize;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::DeSerializeBuffer()\n"));

    *pcSvc = 0;
    *ppSvcList = NULL;
    *pcDeletedSvc = 0;
    *ppDeletedSvcList = NULL;

    __try
    {
        _GetULong(pBuffer, bufsize);
        pBufferEnd = pBuffer + bufsize;
        pBuffer = pBuffer + sizeof(ULONG);

        //
        // Get the number of elements that exist in the buffer.
        //

        _GetULong(pBuffer, count);
        pBuffer = pBuffer + sizeof(ULONG);

        for (i=0; i<count; i++) {

            //
            // Unmarshall each entry. Remember the size of the entry
            // comes first in the buffer, then the marshalled entry
            // itself.
            //

            _GetULong(pBuffer, size);
            pBuffer = pBuffer + sizeof(ULONG);

            //
            // This will not throw an exception even if the buffer is
            // corrupt. So we are safe here. If this fails we will still
            // go on to the next service and try to unmarshall and
            // initialise ourselves with it.
            //
            dwErr = CDfsService::DeSerialize(pBuffer, size, &pSvcPtr);

            if (dwErr == ERROR_SUCCESS)      {

                InsertServiceInList(*ppSvcList, pSvcPtr);
                (*pcSvc)++;
            }

            pBuffer = pBuffer + size;
        }

        //
        // Get the number of deleted svcs.
        //

        if (pBuffer < pBufferEnd) {

            _GetULong(pBuffer, count);
            pBuffer = pBuffer + sizeof(ULONG);

            for (i=0; i<count; i++) {

                _GetULong(pBuffer, size);
                pBuffer = pBuffer + sizeof(ULONG);

                dwErr = CDfsService::DeSerialize(pBuffer, size, &pSvcPtr);

                if (dwErr == ERROR_SUCCESS)      {

                    InsertServiceInList(*ppDeletedSvcList, pSvcPtr);
                    (*pcDeletedSvc)++;
                }

                pBuffer = pBuffer + size;
            }

        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // The only reason that we could get this is if the buffer above
        // were corrupt which means that the serviceList property is corrupt.
        //
        dwErr = NERR_DfsVolumeDataCorrupt;
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::DeSerializeBuffer() exit\n"));

    return( dwErr );

}


//+------------------------------------------------------------------------
//
// Function:    CDfsServiceList::DeSerializeSvcList(), private
//
// Synopsis:    This method takes in a binary buffer and unmarshalls the
//              serviceEntries and plugs them into the ServiceList in the
//              private section of this class instance.
//
// Arguments:   This method picks up requried args from Private section.
//
// Returns:     ERROR_SUCCESS -- If all went well.
//
// Notes:       We have a TRY/CATCH block just in case the buffer is corrupt.
//
// History:     28-Jan-93       SudK    Created
//
//-------------------------------------------------------------------------
DWORD
CDfsServiceList::DeSerializeSvcList(void)
{
    DWORD             dwErr = ERROR_SUCCESS;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::DeSerializeSvcList()\n"));

    ASSERT( _SvcListBuffer != NULL );

    dwErr = DeSerializeBuffer(
            (PBYTE) _SvcListBuffer,
            &_cSvc,
            &_pDfsSvcList,
            &_cDeletedSvc,
            &_pDeletedSvcList);

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::DeSerializeSvcList() exit\n"));

    return( dwErr );

}


//+----------------------------------------------------------------------------
//
//  Function:   CDfsServiceList::DeSerializeReconcileList
//
//  Synopsis:   Deserializes a service list retrieved from a remote volume.
//
//  Arguments:  [pMarshalBuffer] -- The marshal buffer from which to
//                      deserialize the svc list.
//              [pcSvc] -- The count of services in *ppSvcList is returned
//                      here
//              [ppSvcList] -- The service list is returned here.
//              [pcDeletedSvc] -- The count of deleted services in
//                      *ppDeletedSvcList.
//              [ppDeletedSvcList] -- The list of deleted services is
//                      returned here.
//
//  Returns:
//
//-----------------------------------------------------------------------------
DWORD
CDfsServiceList::DeSerializeReconcileList(
    MARSHAL_BUFFER      *pMarshalBuffer,
    ULONG               *pcSvc,
    CDfsService         **ppSvcList,
    ULONG               *pcDeletedSvc,
    CDfsService         **ppDeletedSvcList)
{
    DWORD dwErr;
    PBYTE   pBuffer;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::DeSerializeReconcileList()\n"));

    pBuffer = (PBYTE) pMarshalBuffer->Current;

    dwErr = DeSerializeBuffer(
            pBuffer,
            pcSvc,
            ppSvcList,
            pcDeletedSvc,
            ppDeletedSvcList);

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::DeSerializeReconcileList() exit\n"));

    return( dwErr );
}


//+------------------------------------------------------------------------
//
// Function:    CDfsServiceList::SerializeSvcList(), private
//
// Synopsis:    This method serializes a given service list into a binary
//              buffer. The service list in the private section of this class
//              is used as the source. The serialised target buffer is also
//              kept in the private section.
//
// Arguments:   None
//
// Returns:     [ERROR_SUCCESS] -- If all went well.
//
//              [ERROR_OUTOFMEMORY] - If unable to allocate the target buffer.
//
// History:     28-Jan-93       SudK    Created
//
//-------------------------------------------------------------------------
DWORD
CDfsServiceList::SerializeSvcList(void)
{

    DWORD             dwErr = ERROR_SUCCESS;
    ULONG               totalSize, i, *psize;
    BYTE                *buffer;
    CDfsService         *pSvcPtr = NULL;
    ULONG               *sizeBuffer = NULL;
    FILETIME            ftService;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::SerializeSvcList()\n"));

    totalSize = 0;

    sizeBuffer = new ULONG[_cSvc + _cDeletedSvc];

    if (sizeBuffer == NULL) {

        return ERROR_OUTOFMEMORY;

    }

    //
    // Need all the size values now and later for marshalling stuff.
    // So we collect them here into an array.
    //

    psize = sizeBuffer;
    pSvcPtr = GetFirstService();

    for (i=0;i<_cSvc;i++)      {
        *psize = pSvcPtr->GetMarshalSize();
        totalSize = totalSize + *psize;
        pSvcPtr = GetNextService(pSvcPtr);
        psize++;
    }

    pSvcPtr = GetFirstDeletedService();
    for (i=0;i<_cDeletedSvc;i++)      {
        *psize = pSvcPtr->GetMarshalSize();
        totalSize = totalSize + *psize;
        pSvcPtr = GetNextDeletedService(pSvcPtr);
        psize++;
    }

    //
    // Allocate the byte buffer that we need to pass to IProp interface.
    //
    // totalsize is the size required just to marshal all the services and
    // their last-modification-timestamps.
    //
    // In addition, we need:
    //
    //  1 ULONG for store the buffersize, since we are storing this as a
    //          VT_BLOB property.
    //
    //  1 ULONG for storing the count of services
    //
    //  _cSvc ULONGs for storing the marshal size of each service.
    //
    //  1 ULONG for count of deleted services
    //
    //  _cDeletedSvc ULONGS for storing the marshal size of each deleted svc
    //

    if (_SvcListBuffer != NULL)
        delete [] _SvcListBuffer;

    _cbSvcListBuffer = totalSize +
                       sizeof(ULONG) * (2 + _cSvc + 1 + _cDeletedSvc);

    _SvcListBuffer = new BYTE[_cbSvcListBuffer];

    if (_SvcListBuffer != NULL) {

        buffer = _SvcListBuffer;

        //
        // First set the size of the buffer. Since this will be used
        // as a BLOB property. The size does NOT include the size field
        // itself, hence the (1 + _cSvc + 1 + _cDeletedSvc).
        //

        totalSize = totalSize + sizeof(ULONG)*(1 + _cSvc + 1 + _cDeletedSvc);
        _PutULong(buffer, totalSize);
        buffer = buffer + sizeof(ULONG);

        //
        // Set the number of entries to follow in the buffer at the start.
        //

        _PutULong(buffer, _cSvc);
        buffer = buffer + sizeof(ULONG);

        psize = sizeBuffer;
        pSvcPtr = GetFirstService();

        for (i=0;i<_cSvc;i++)      {

            //
            // Marshall each service Entry into the buffer.
            // Remember we first need to put the size of the marshalled
            // service entry to follow, then the FILETIME for the service,
            // and finally, the marshalled service entry structure.
            //

            _PutULong( buffer, (*psize));
            buffer = buffer + sizeof(ULONG);

            pSvcPtr->Serialize(buffer, *psize);

            buffer = buffer + *psize;

            psize = psize + 1;

            pSvcPtr = GetNextService(pSvcPtr);

        }

        //
        // Now marshal the delete svc list.
        //

        pSvcPtr = GetFirstDeletedService();

        _PutULong(buffer, _cDeletedSvc);
        buffer += sizeof(ULONG);

        for (i=0; i<_cDeletedSvc; i++) {

            _PutULong(buffer, *psize);
            buffer = buffer + sizeof(ULONG);

            pSvcPtr->Serialize(buffer, *psize);

            buffer = buffer + *psize;

            psize = psize + 1;

            pSvcPtr = GetNextDeletedService(pSvcPtr);
        }


    } else {

        dwErr = ERROR_OUTOFMEMORY;

    }

    if (sizeBuffer != NULL)     {
        delete [] sizeBuffer;
    }


    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::SerializeSvcList() exit\n"));

    return( dwErr );

}


//+------------------------------------------------------------------------
//
// Function:    CDfsServiceList::SetServiceListProperty(), private
//
// Synopsis:    This method sets the service list property on the vol object.
//              Picks up the property from the Private section.
//
// Arguments:   None
//
// Returns:     ERROR_SUCCESS -- If all went well.
//              NERR_DfsVolumeDataCorrupt - If volume object is corrupt.
//
// Notes:
//
// History:     28-Jan-93       SudK    Created
//
//-------------------------------------------------------------------------
DWORD
CDfsServiceList::SetServiceListProperty(BOOLEAN bCreate)
{
    DWORD             dwErr = ERROR_SUCCESS;
    BYTE                *pBuffer;
    ULONG               cbSize;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::SetSvcListProp()\n"));

    //
    // Set the ReplicaList property first.
    //

    cbSize = *((ULONG *) _SvcListBuffer);
    pBuffer = _SvcListBuffer + sizeof(ULONG);

    //
    // Now set the Property itself
    //
    dwErr = _pPSStg->SetSvcProps(pBuffer, cbSize);

    if (dwErr != ERROR_SUCCESS)     {
        IDfsVolInlineDebOut((   DEB_ERROR,
                                "Unable to Set RecoveryProperties %08lx\n",
                                dwErr));
        return( dwErr );
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsServiceList::SetSvcListProp() exit\n"));

    return( dwErr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\service.cxx ===
//+----------------------------------------------------------------------------//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992-1995, Microsoft Corporation
//
//  File:       service.cxx
//
//  Contents:   A Class for abstracting the concept of a Service/Replica on
//              each volume in the namespace.
//
//  Classes:
//
//  Functions:
//
//  History:    26-Jan-93       SudK            Created
//              12-May-93       SudK            Modified
//              28-Mar-95       Milans          Updated to handle server
//                                              knowledge inconsistencies
//              27-Dec-95       Milans          Updated for NT/SUR
//
//--------------------------------------------------------------------------
//#include <ntos.h>
//#include <ntrtl.h>
//#include <nturtl.h>
//#include <dfsfsctl.h>
//#include <windows.h>


#include "headers.hxx"
#pragma hdrstop


extern "C"      {
#include <dfserr.h>
#include <dfspriv.h>                             // For I_NetDfsXXX calls
#include "dfsmsrv.h"
}

#include "service.hxx"
#include "cdfsvol.hxx"
#include "jnpt.hxx"
#include "dfsmwml.h"

INIT_DFS_REPLICA_INFO_MARSHAL_INFO()

DWORD
RelationInfoToNetInfo(
    PDFS_PKT_RELATION_INFO RelationInfo,
    LPNET_DFS_ENTRY_ID_CONTAINER pNetInfo);

NTSTATUS
DfspCreateExitPoint (
    IN  HANDLE                      DriverHandle,
    IN  LPGUID                      Uid,
    IN  LPWSTR                      Prefix,
    IN  ULONG                       Type,
    IN  ULONG                       ShortPrefixLen,
    OUT LPWSTR                      ShortPrefix);

NTSTATUS
DfspDeleteExitPoint (
    IN  HANDLE                      DriverHandle,
    IN  LPGUID                      Uid,
    IN  LPWSTR                      Prefix,
    IN  ULONG                       Type);


//+------------------------------------------------------------------------
//
// Member:      CDfsService::CDfsService, private
//
// Synopsis:    This is  private constructor with no arguments.
//
// Arguments:   None.
//
// Returns:     Nothing.
//
// Notes:       This constructor should be followed up by some kind of
//              deserialization to setup the instance appropriately.
//
//-------------------------------------------------------------------------
CDfsService::CDfsService( void )
{

    IDfsVolInlineDebOut((
        DEB_TRACE, "CDfsService::+CDfsService(1)(0x%x)\n",
        this));

    //
    // Initialise all the private section appropriately.
    //
    memset(&_DfsReplicaInfo, 0, sizeof(DFS_REPLICA_INFO));
    memset(&_DfsPktService, 0, sizeof(DFS_SERVICE));
    memset(&_ftModification, 0, sizeof(FILETIME));

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsService::CDfsService(1)() exit\n"));
}


//+------------------------------------------------------------------------
//
// Member:      CDfsService::CDfsService
//
// Synopsis:    This is the primary way of constructing a CDfsService instance
//              using a DFS_REPLICA_INFO structure. The DFS_REPLICA_INFO struct
//              passed in has to be freed by the caller. This constructor does
//              not eat up that memory.
//
// Arguments:   [pReplicaInfo] -- The ReplicaInfo struct that defines this Svc.
//              [bCreatePktSvc] -- Whether to create PKT Service struct in
//                                 private section.
//              [pdwErr] -- On return, indicates result of construction.
//
// Returns:     *pdwErr will be set to ERROR_OUTOFMEMORY if memory allocation fails.
//
// Notes:       This constructor allocates required memory and then copies.
//
//-------------------------------------------------------------------------
CDfsService::CDfsService(
    PDFS_REPLICA_INFO   pReplicaInfo,
    BOOLEAN             bCreatePktSvc,
    DWORD               *pdwErr
)
{
    DWORD       dwErr = ERROR_SUCCESS;
    ULONG       size;
    LPBYTE      buffer;

    IDfsVolInlineDebOut((
        DEB_TRACE, "CDfsService::+CDfsService(2)(0x%x)\n",
        this));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CDfsService::CDfsService(%ws,%ws,%ws)\n",
            pReplicaInfo->pwszServerName,
            pReplicaInfo->pwszShareName,
            bCreatePktSvc == TRUE ? L"TRUE" : L"FALSE");
#endif

    //
    // First initialise the ServiceEntry structure.
    //

    ZeroMemory(&_DfsReplicaInfo, sizeof(DFS_REPLICA_INFO));
    ZeroMemory(&_DfsPktService, sizeof(DFS_SERVICE));
    ZeroMemory(&_ftModification, sizeof(FILETIME));

    //
    // We first need to initialise the ReplicaInfo structure in the private
    // section. The simplest way to do this is to serialize what we got and
    // then Deserialize the same thing.
    //

    _DfsReplicaInfo = *pReplicaInfo;    // Temporarily

    size = GetMarshalSize();

    buffer = new BYTE[size];

    if (buffer != NULL) {

        Serialize(buffer, size);

        //
        // Now we unmarshall this buffer again to get a new ReplicaInfo
        // structure.
        //

        DeSerialize(buffer, size);

        delete [] buffer;

    } else {

        ZeroMemory( &_DfsReplicaInfo, sizeof(DFS_REPLICA_INFO));

        dwErr = ERROR_OUTOFMEMORY;

    }

    //
    // Now that we have initialised the DfsReplicaInfo structure in the
    // private section, we need to initialize the DFS_SERVICE structure
    //  as well.
    //

    if (dwErr == ERROR_SUCCESS && bCreatePktSvc)
        dwErr = InitializePktSvc();

    *pdwErr = dwErr;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsService::CDfsService(2)() exit\n"));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CDfsService::CDfsService exit %d\n", dwErr);
#endif

}


//+------------------------------------------------------------------------
//
// Member:      CDfsService::~CDfsService
//
// Synopsis:    The Destructor. Gets rid of all the memory.
//
// Arguments:   None
//
// Returns:     Nothing.
//
// Notes:       This assumes that the constructor used "new" to allocate
//              memory for the strings in the private structure.
//
//-------------------------------------------------------------------------
CDfsService::~CDfsService(void)
{
    ULONG       i;
    PDS_MACHINE pMachine;

    IDfsVolInlineDebOut((
        DEB_TRACE, "CDfsService::~CDfsService(0x%x)\n",
        this));

    //
    // Need to get rid of memory in DFS_SERVICE and DfsReplicaInfo structs.
    //

    if (_DfsReplicaInfo.pwszServerName != pwszComputerName) {
        MarshalBufferFree( _DfsReplicaInfo.pwszServerName );
    }

    MarshalBufferFree( _DfsReplicaInfo.pwszShareName );

    if (_DfsPktService.pMachEntry != NULL) {
        pMachine = _DfsPktService.pMachEntry->pMachine;

        if (pMachine != NULL)
            DfsMachineFree(pMachine); // Free using appropriate mechanism

        delete _DfsPktService.pMachEntry;

    }

    if (_DfsPktService.Name.Buffer != NULL) {
        delete [] _DfsPktService.Name.Buffer;
    }

    if (_DfsPktService.Address.Buffer != NULL) {
        delete [] _DfsPktService.Address.Buffer;
    }

    if (_DfsPktService.StgId.Buffer != NULL) {
        delete [] _DfsPktService.StgId.Buffer;
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsService::~CDfsService() exit\n"));

}


//+------------------------------------------------------------------------
//
// Member:      CDfsService::InitializePktSvc
//
// Synopsis:    This is the method that initialises the DFS_SERVICE structure
//              in the private section of Class. The DFS_REPLICA_INFO
//              structure should have been setup by the time this routine is
//              called.
//
// Arguments:   None
//
// Returns:     [ERROR_SUCCESS] -- If everything went ok.
//
//              [ERROR_OUTOFMEMORY] -- If unable to allocate requisite memory.
//
// History:     26-Jan-1993     Sudk    Created.
//              13-May-93       Sudk    Modified for new interface.
//
//-------------------------------------------------------------------------
DWORD
CDfsService::InitializePktSvc()
{
    DWORD               dwErr = ERROR_SUCCESS;
    UNICODE_STRING      ustr;

    //
    // We just put in a switch for Each ReplicaType that we will handle.
    //

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsService::InitializePktSvc()\n"));

    switch(_DfsReplicaInfo.ulReplicaType) {

    case DFS_STORAGE_TYPE_DFS:

        _DfsPktService.ProviderId = PROV_ID_DFS_RDR;
        _DfsPktService.Capability = PROV_DFS_RDR;
        _DfsPktService.Type = DFS_SERVICE_TYPE_MASTER;
        _DfsPktService.Cost = (ULONG) ~0L;
        break;

    case DFS_STORAGE_TYPE_NONDFS:
        _DfsPktService.ProviderId = PROV_ID_LM_RDR;
        _DfsPktService.Capability = PROV_STRIP_PREFIX;
        _DfsPktService.Type = DFS_SERVICE_TYPE_DOWN_LEVEL | DFS_SERVICE_TYPE_MASTER;
        _DfsPktService.Cost = (ULONG) ~0L;
        break;

    default:
        ASSERT( FALSE && "Invalid Replica Type");
        break;

    }

   if (_DfsReplicaInfo.ulReplicaState & DFS_STORAGE_STATE_OFFLINE) 
        _DfsPktService.Type |= DFS_SERVICE_TYPE_OFFLINE;

    //
    // Now, we construct the DS_MACHINE
    //

    _DfsPktService.pMachEntry = (PDFS_MACHINE_ENTRY) new DFS_MACHINE_ENTRY;
    if (_DfsPktService.pMachEntry == NULL) {
        return( ERROR_OUTOFMEMORY );
    } else {
        ZeroMemory(
            (PVOID) _DfsPktService.pMachEntry,
            sizeof( DFS_MACHINE_ENTRY ) );
    }

    dwErr = DfsGetDSMachine(
            _DfsReplicaInfo.pwszServerName,
            &_DfsPktService.pMachEntry->pMachine);

    if (dwErr != ERROR_SUCCESS) {

        delete _DfsPktService.pMachEntry;
        _DfsPktService.pMachEntry = NULL;

        IDfsVolInlineDebOut((DEB_ERROR, "Unable to get to %ws machine \n",
                    _DfsReplicaInfo.pwszServerName));

        return( ERROR_OUTOFMEMORY );

    }

    ustr.Length = (USHORT)wcslen(_DfsReplicaInfo.pwszServerName);
    ustr.Buffer = new WCHAR [ustr.Length + 1];
    ustr.Length *= sizeof(WCHAR);
    ustr.MaximumLength = ustr.Length + sizeof(WCHAR);

    if (ustr.Buffer != NULL) {
        wcscpy(ustr.Buffer, _DfsReplicaInfo.pwszServerName);
        _DfsPktService.Name = ustr;
    } else {
        delete _DfsPktService.pMachEntry;
        _DfsPktService.pMachEntry = NULL;
        return( ERROR_OUTOFMEMORY );
    }

    ustr.Length = (1 + wcslen(_DfsReplicaInfo.pwszServerName) +
                    1 + wcslen(_DfsReplicaInfo.pwszShareName));
    ustr.Buffer = new WCHAR [ustr.Length + 1];
    ustr.Length *= sizeof(WCHAR);
    ustr.MaximumLength = ustr.Length + sizeof(WCHAR);

    if (ustr.Buffer != NULL) {
        wcscpy(ustr.Buffer, UNICODE_PATH_SEP_STR);
        wcscat(ustr.Buffer, _DfsReplicaInfo.pwszServerName);
        wcscat(ustr.Buffer, UNICODE_PATH_SEP_STR);
        wcscat(ustr.Buffer, _DfsReplicaInfo.pwszShareName);
        _DfsPktService.Address = ustr;
    } else {
        delete [] _DfsPktService.Name.Buffer;
        _DfsPktService.Name.Buffer = NULL;
        _DfsPktService.Name.Length = _DfsPktService.Name.MaximumLength = 0;
        delete _DfsPktService.pMachEntry;
        _DfsPktService.pMachEntry = NULL;
        return( ERROR_OUTOFMEMORY );
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsService::InitializePktSvc() exit\n"));

    return( ERROR_SUCCESS );

}


//+------------------------------------------------------------------------
//
// Member:      CDfsService::DeSerialize, private
//
// Synopsis:    This function takes a buffer as an argument and deserializes
//              its contents into the private DfsReplicaInfo structure.
//
// Arguments:   [buffer] -- The buffer which has to be deserialized.
//              [size] -- The size of the buffer.
//
// Returns:     Nothing.
//
//
//
// History:     13-May-93       SudK    Created.
//
//-------------------------------------------------------------------------
DWORD
CDfsService::DeSerialize(BYTE *buffer, ULONG size)
{

    ULONG               ulReplicaType;
    MARSHAL_BUFFER      marshalBuffer;
    NTSTATUS            status;

    MarshalBufferInitialize(&marshalBuffer, size, buffer);

    status = DfsRtlGet(&marshalBuffer, &MiFileTime, &_ftModification);

    if (!NT_SUCCESS(status))
        return( ERROR_INVALID_PARAMETER );

    //
    // Now that we know which Minfo Struct to use and we also have the
    // buffer at hand. We can just do a simple Unmarshall to get the stuff
    // out of the buffer.
    //

    status = DfsRtlGet(&marshalBuffer, &MiDfsReplicaInfo, &_DfsReplicaInfo);

    if (ulDfsManagerType == DFS_MANAGER_SERVER) {

        //
        // To handle machine renames, we store the local computer name as a
        // L"." Replace this with the current computer name, if necessary.
        //
        if (NT_SUCCESS(status) && pwszComputerName != NULL) {

            if (wcscmp(_DfsReplicaInfo.pwszServerName, L".") == 0) {

                MarshalBufferFree(_DfsReplicaInfo.pwszServerName);

                _DfsReplicaInfo.pwszServerName = pwszComputerName;

            }
        }

    }

    if (status == STATUS_INSUFFICIENT_RESOURCES) {
        return( ERROR_OUTOFMEMORY );
    } else if (!NT_SUCCESS(status)) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Now that we have deserialized we are done.
    //

    return ERROR_SUCCESS;

}


//+------------------------------------------------------------------------
//
// Member:      CDfsService::DeSerialize, public
//
// Synopsis:    This function takes a buffer as an argument and deserializes
//              its contents and creates an instance of this class and
//              returns a pointer to it.
//
// Arguments:   [buffer] -- The buffer which has to be deserialized.
//              [size] -- The size of the buffer.
//              [ppService] - The new instance is returned here.
//
// Returns:     ERROR_SUCCESS -- If all went well.
//
// Notes:       This method will not throw any exceptions.
//
// History:     13-May-93       SudK    Created.
//
//-------------------------------------------------------------------------
DWORD
CDfsService::DeSerialize(
    PBYTE buffer,
    ULONG size,
    CDfsService **ppService)
{

    DWORD     dwErr = ERROR_SUCCESS;

    *ppService = NULL;

    //
    // Construct a NULL CDfsService first and then unmarshall the stuff.
    //
    *ppService = new CDfsService;

    if (*ppService == NULL) {
        return(ERROR_OUTOFMEMORY);
    }

    dwErr = (*ppService)->DeSerialize(buffer, size);

    //
    // Now the ReplicaInfo struct in the private section has been setup
    // appropriately. What is left is to setup the DFS_SERVICE struct
    // as well and then we have a properly constructed CDfsService.
    //
    if (dwErr == ERROR_SUCCESS) {
        dwErr = (*ppService)->InitializePktSvc();
    }


    if (dwErr != ERROR_SUCCESS) {
        delete *ppService;
        *ppService = NULL;
    }

    return( dwErr );

}


//+------------------------------------------------------------------------
//
// Member:      CDfsService::Serialize, public
//
// Synopsis:    This function takes a buffer as an argument and serializes
//              the private DfsReplicaInfo structure into that buffer.
//
// Arguments:   [buffer] -- ReplInfo struct to be serialised into this.
//              [size] -- The size of the buffer.
//
// Returns:     Nothing.
//
// Notes:       Will ASSERT if the buffer is not big enough. The
//              size of the buffer should have been calculated using
//              the function GetMarshalSize() in this class.
//
//              The ServiceInfo MUST BE MARSHALLED FIRST!. This is because
//              the Deserialize routine does a _GetUlong to figure out what
//              kind of ServiceInfo was marshalled.
//
// History:     13-May-93       SudK    Created.
//
//-------------------------------------------------------------------------
VOID
CDfsService::Serialize(PBYTE buffer, ULONG size)
{

    MARSHAL_BUFFER      marshalBuffer;
    NTSTATUS            status;
    DFS_REPLICA_INFO    dfsReplicaInfo;


    ASSERT( size >= GetMarshalSize() );

    //
    // Now that we have a proper buffer lets go marshall the stuff in.
    //

    MarshalBufferInitialize(&marshalBuffer, size, buffer);
    status = DfsRtlPut(&marshalBuffer, &MiFileTime, &_ftModification);
    ASSERT(NT_SUCCESS(status));

    dfsReplicaInfo = _DfsReplicaInfo;

    if (ulDfsManagerType == DFS_MANAGER_SERVER && pwszComputerName != NULL) {

        if (_wcsicmp(dfsReplicaInfo.pwszServerName, pwszComputerName) == 0)
            dfsReplicaInfo.pwszServerName = L".";

    }

    status = DfsRtlPut(&marshalBuffer, &MiDfsReplicaInfo, &dfsReplicaInfo);
    ASSERT(NT_SUCCESS(status));

}


//+----------------------------------------------------------------------------
//
//  Function:   CDfsService::GetNetStorageInfo, public
//
//  Synopsis:   Returns the service info in a DFS_STORAGE_INFO struct.
//              Useful for NetDfsXXX APIs.
//
//  Arguments:  [pInfo] -- Pointer to DFS_STORAGE_INFO to fill. Pointer
//                      members will be allocated using MIDL_user_allocate.
//
//              [pcbInfo] -- On successful return, set to size in bytes of
//                      returned info. The size does not include the size
//                      of the DFS_STORAGE_INFO struct itself.
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
CDfsService::GetNetStorageInfo(
    LPDFS_STORAGE_INFO pInfo,
    LPDWORD pcbInfo)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR wszShare;
    DWORD cbInfo = 0, cbItem;

    pInfo->State = _DfsReplicaInfo.ulReplicaState;

    cbItem = (wcslen(_DfsReplicaInfo.pwszServerName) + 1) * sizeof(WCHAR);
    pInfo->ServerName = (LPWSTR) MIDL_user_allocate(cbItem);
    if (pInfo->ServerName != NULL) {
        wcscpy(pInfo->ServerName, _DfsReplicaInfo.pwszServerName);
        cbInfo += cbItem;
    } else {
        dwErr = ERROR_OUTOFMEMORY;
    }

    if (dwErr == ERROR_SUCCESS) {
        cbItem = (wcslen(_DfsReplicaInfo.pwszShareName) + 1) * sizeof(WCHAR);
        pInfo->ShareName = (LPWSTR) MIDL_user_allocate(cbItem);
        if (pInfo->ShareName != NULL) {
            wcscpy( pInfo->ShareName, _DfsReplicaInfo.pwszShareName );
            cbInfo += cbItem;
        } else {
            MIDL_user_free( pInfo->ServerName );
            pInfo->ServerName = NULL;
            dwErr = ERROR_OUTOFMEMORY;
        }
    }

    *pcbInfo = cbInfo;

    return( dwErr );

}


//+------------------------------------------------------------------------
//
// Member:      CDfsService::IsEqual, public
//
// Synopsis:    This function takes a replicaInfo structure and compares it
//              for equality with itself. After all a ReplicaInfo structure
//              uniquely identifies a service.
//
// Arguments:   [pReplicaInfo] -- A replicaInfo struct.
//
// Returns:     TRUE if it is equal else FALSE.
//
// Notes:       Can throw an exception due to bad structures etc.
//
// History:     13-May-93       SudK    Created.
//
//-------------------------------------------------------------------------
BOOLEAN
CDfsService::IsEqual(PDFS_REPLICA_INFO pReplicaInfo)
{

    if (_wcsicmp(pReplicaInfo->pwszServerName, _DfsReplicaInfo.pwszServerName)) {
        return(FALSE);
    }

    if (_wcsicmp(pReplicaInfo->pwszShareName, _DfsReplicaInfo.pwszShareName)) {
        return(FALSE);
    }

    return(TRUE);

}


//+------------------------------------------------------------------------
//
// Method:      CDfsService::CreateExitPoint, public
//
// Synopsis:    This method creates an exit point at the remote machine.
//
// Arguments:   [peid] -- The Pkt Entry ID of the exit point.
//
//              [Type] -- The type of volume where we are.
//
// Returns:     [ERROR_SUCCESS] -- If all went well.
//
//              [NERR_DfsServerUpgraded] -- A non-dfs replica has since been
//                      made Dfs aware.
//
//              [NERR_DfsServerNotDfsAware] -- Server is non-dfs or
//                      replica is unavailable at this time.
//
// History:     01 Feb 93       SudK    Created.
//
//-------------------------------------------------------------------------

DWORD
CDfsService::CreateExitPoint(
    PDFS_PKT_ENTRY_ID peid,
    ULONG Type)
{
    DWORD                       dwErr = ERROR_SUCCESS;
    NET_API_STATUS              netStatus;
    ULONG                       dwVersion;
    BOOL                        fRetry;
    HANDLE                      pktHandle = NULL;
    NTSTATUS                    status = STATUS_SUCCESS;

    //
    // If this is marked as a non-dfs aware replica, try and see if the
    // replica has been made Dfs aware. If so, we return a distinguished
    // error code so the caller can turn around, do a create local partition
    // and retry the CreateExitPoint.
    //

    if (_DfsReplicaInfo.ulReplicaType == DFS_STORAGE_TYPE_NONDFS) {

        //
        // At the time this server was added as a replica for this volume,
        // this server was was either unavailable or not dfs aware. So,
        // try and see if the server is now Dfs Aware or not.
        //

        netStatus = I_NetDfsGetVersion(
                        _DfsReplicaInfo.pwszServerName,
                        &dwVersion);

        DFSM_TRACE_ERROR_HIGH(netStatus, ALL_ERROR, CDfsServiceCreateExitPoint_Error_I_NetDfsGetVersion,
                                LOGSTATUS(netStatus));
        if (netStatus == NERR_Success) {

            return( NERR_DfsServerUpgraded );

        } else {

            return( NERR_DfsServerNotDfsAware );

        }

    }

    ASSERT (_DfsReplicaInfo.ulReplicaType != DFS_STORAGE_TYPE_NONDFS);

    status = PktOpen(&pktHandle, 0, 0, NULL);

    if (!NT_SUCCESS(status)) {
        dwErr = RtlNtStatusToDosError(status);
        return dwErr;
    }

    fRetry = FALSE;

    do {

        netStatus = (NET_API_STATUS)DfspCreateExitPoint(
                                        pktHandle,
                                        &peid->Uid,
                                        peid->Prefix.Buffer,
                                        Type,
                                        peid->ShortPrefix.MaximumLength/sizeof(WCHAR),
                                        peid->ShortPrefix.Buffer);

        if (netStatus == STATUS_SUCCESS)
            peid->ShortPrefix.Length =
                wcslen(peid->ShortPrefix.Buffer) * sizeof(WCHAR);

        if (fRetry) {

            //
            // We have already tried once to sync up the server. Time to quit
            //

            fRetry = FALSE;

        } else if (netStatus == DFS_STATUS_NOSUCH_LOCAL_VOLUME ||
                   netStatus == DFS_STATUS_LOCAL_ENTRY ||
                   netStatus == DFS_STATUS_BAD_EXIT_POINT) {

            fRetry = SyncKnowledge();

        }

    } while ( fRetry );

    if (pktHandle != NULL) 
        PktClose(pktHandle);

    if (netStatus != NERR_Success)
        dwErr = RtlNtStatusToDosError(netStatus);

    if (dwErr != ERROR_SUCCESS)     {
        IDfsVolInlineDebOut((
            DEB_TRACE, "Failed to do CreateExitPt %ws at %ws. Error: %x\n",
            peid->Prefix.Buffer, _DfsReplicaInfo.pwszServerName, dwErr));
    }

    return( dwErr );

}



//+------------------------------------------------------------------------
//
// Method:      CDfsService::DeleteExitPoint()
//
// Synopsis:    This method deletes an exit point at the remote machine.
//
// Arguments:   [peid] -- ExitPath to be deleted along with GUID in the
//                      EntryId struct.
//              [Type] -- The type of volume where we are.
//
// Returns:     [ERROR_SUCCESS] -- If successfully deleted exit point, or exit point
//                      did not exist to begin with.
//
//              Rpc error from I_NetDfsDeleteExitPoint
//
// Notes:
//
// History:     01 Feb 93       SudK    Created.
//
//-------------------------------------------------------------------------
DWORD
CDfsService::DeleteExitPoint(
    PDFS_PKT_ENTRY_ID peid,
    ULONG Type)
{
    DWORD                       dwErr = ERROR_SUCCESS;
    NTSTATUS                    status = STATUS_SUCCESS;
    BOOL                        fRetry;
    HANDLE                      pktHandle = NULL;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsService:DeleteExitPoint()\n"));

    // ASSERT (_DfsReplicaInfo.ulReplicaType != DFS_STORAGE_TYPE_NONDFS);

    status = PktOpen(&pktHandle, 0, 0, NULL);

    fRetry = FALSE;

    do {

        status = DfspDeleteExitPoint(
                    pktHandle,
                    &peid->Uid,
                    peid->Prefix.Buffer,
                    Type);

        if (fRetry) {

            //
            // We have already tried once to sync up the server. Time to quit
            //

            fRetry = FALSE;

        } else if (status == DFS_STATUS_BAD_EXIT_POINT ||
                   status == DFS_STATUS_NOSUCH_LOCAL_VOLUME) {

            //
            // The server is out of sync with the DC. Lets try to force it
            // into a valid state
            //

            fRetry = SyncKnowledge();

        }

    } while ( fRetry );

    if (pktHandle != NULL) 
        PktClose(pktHandle);

    if (!NT_SUCCESS(status))
        dwErr = RtlNtStatusToDosError(status);

    if (dwErr != ERROR_SUCCESS)     {
        IDfsVolInlineDebOut((
            DEB_TRACE, "Failed to do DeleteExitPt %ws at %ws. Error: %x\n",
            peid->Prefix.Buffer, _DfsReplicaInfo.pwszServerName, status ));
    }

    if (status == DFS_E_BAD_EXIT_POINT)
        dwErr = ERROR_SUCCESS;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsService:DeleteExitPoint() exit\n"));

    return( dwErr );

}


//+------------------------------------------------------------------------
//
// Method:      CDfsService::CreateLocalVolume()
//
// Synopsis:    This method creates knowledge regarding a new volume at the
//              remote server.
//
// Arguments:   [peid] -- The EntryId. This class does not know this.
//              [EntryType] -- Type of Entry. This class doesn't know this.
//
// Returns:     [ERROR_SUCCESS] -- Successfully created local volume knowledge on
//                      server.
//
// History:     01 Feb 93       SudK    Created.
//
//-------------------------------------------------------------------------
DWORD
CDfsService::CreateLocalVolume(
    PDFS_PKT_ENTRY_ID   peid,
    ULONG               EntryType)
{
    DFS_PKT_RELATION_INFO       RelationInfo;
    NET_DFS_ENTRY_ID_CONTAINER  NetRelationInfo;
    DWORD                     dwErr = ERROR_SUCCESS;
    NTSTATUS                    status;

    //
    // First to check whether this is necessary since this could be a down
    // level scenario.
    //

    if (_DfsReplicaInfo.ulReplicaType == DFS_STORAGE_TYPE_NONDFS) {

        return(ERROR_SUCCESS);

    }

    //
    // Now we need to create a config info structure. We will have to go to
    // the PKT for this since this is not available in the Private section
    // above.
    //

    dwErr = GetPktCacheRelationInfo(peid, &RelationInfo);

    if (dwErr != ERROR_SUCCESS)     {

        IDfsVolInlineDebOut((
            DEB_ERROR,"Failed to do GetPktCacheRelationInfo on %ws %08lx\n",
           peid->Prefix.Buffer, dwErr));

        return( dwErr );

    }

    //
    // Convert the ConfigInfo into an LPNET_DFS_ENTRY_ID_CONTAINER suitable
    // for calling I_NetDfsCreateLocalPartition.
    //

    dwErr = RelationInfoToNetInfo( &RelationInfo, &NetRelationInfo );

    if (dwErr != ERROR_SUCCESS) {

        IDfsVolInlineDebOut((
            DEB_ERROR,
            "Failed to allocate memory for NET_ENTRY_ID_CONTAINER"));

        return( dwErr );

    }

    BOOL fRetry;

    fRetry = FALSE;

    //
    // Note that I_NetDfsCreateLocalPartition returns an NT_STATUS cast to a
    // NET_API_STATUS
    //

    do {

        status = I_NetDfsCreateLocalPartition(
                    _DfsReplicaInfo.pwszServerName,
                    _DfsReplicaInfo.pwszShareName,
                    &peid->Uid,
                    peid->Prefix.Buffer,
                    peid->ShortPrefix.Buffer,
                    &NetRelationInfo,
                    FALSE);

        DFSM_TRACE_ERROR_HIGH(status, ALL_ERROR, CDfsServiceCreateLocalVolume_I_NetDfsCreateLocalPartition,
                                LOGSTATUS(status));
        //
        // If this operation fails, it could reflect a knowledge inconsistency at
        // the server. So, handle it now.
        //

        IDfsVolInlineDebOut((
            DEB_TRACE, "I_NetDfsCreateLocalPartition returned %08lx\n",
            status));

        if (fRetry) {

            //
            // We have already tried once to sync up the server. Time to quit
            //

            fRetry = FALSE;

        } else if (status == DFS_STATUS_LOCAL_ENTRY) {

            //
            // The server thinks that the volume we are trying to create
            // already exists. This is bogus, so lets try to bring the server
            // up to sync with us.
            //

            fRetry = SyncKnowledge();

        }

    } while ( fRetry );

    if (!NT_SUCCESS(status)) {
        dwErr = RtlNtStatusToDosError(status);
    }

    DeallocateCacheRelationInfo(RelationInfo);

    delete [] NetRelationInfo.Buffer;

    if (dwErr != ERROR_SUCCESS) {
        IDfsVolInlineDebOut((
            DEB_TRACE,
            "Failed to CreateLocalVol at %ws for %ws. Error: %x\n",
             _DfsReplicaInfo.pwszServerName, peid->Prefix.Buffer, dwErr));
    }

    return( dwErr );

}



//+------------------------------------------------------------------------
//
// Method:      CDfsService::DeleteLocalVolume()
//
// Synopsis:    This method deletes knowledge regarding a volume at remote
//              machine.
//
// Arguments:   [peid] --       EntryId information.
//
// Returns:     [ERROR_SUCCESS] -- If successfully deleted the knowledge at the remote
//                      server, or the server didn't know about the volume
//                      to begin with.
//
// History:     01 Feb 93       SudK    Created.
//
//-------------------------------------------------------------------------
DWORD
CDfsService::DeleteLocalVolume(
    PDFS_PKT_ENTRY_ID peid)
{
    NTSTATUS            status;
    DWORD             dwErr = ERROR_SUCCESS;
    BOOL                fRetry;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsService::DeleteLocalVolume()\n"));

    //
    // First to check whether this is necessary since this could be a down
    // level scenario.
    //

    if (_DfsReplicaInfo.ulReplicaType == DFS_STORAGE_TYPE_NONDFS)     {
        return(ERROR_SUCCESS);
    }

    fRetry = FALSE;

    //
    // Note that I_NetDfsCreateLocalPartition returns an NT_STATUS cast to a
    // NET_API_STATUS
    //

    do {

        status = I_NetDfsDeleteLocalPartition(
                    _DfsReplicaInfo.pwszServerName,
                    &peid->Uid,
                    peid->Prefix.Buffer);

        DFSM_TRACE_ERROR_HIGH(status, ALL_ERROR, CDfsServiceDeleteLocalVolume_Error_I_NetDfsDeleteLocalPartition,
                                LOGSTATUS(status));
        IDfsVolInlineDebOut((
            DEB_TRACE, "NT Status %08lx from DfsDeleteLocalPartition\n",
            status));

        if (fRetry) {

            //
            // We have already tried once to sync up the server. Time to quit
            //

            fRetry = FALSE;

        } else if (status == DFS_STATUS_NOSUCH_LOCAL_VOLUME) {

            //
            // This could happen because the server's knowledge is
            // inconsistent with that of this DC. Try to bring it in sync.
            //

            fRetry = SyncKnowledge();

        }

    } while ( fRetry );


    if (!NT_SUCCESS(status))    {
        IDfsVolInlineDebOut((
            DEB_TRACE,
            "Failed to Delete Local Volume at %ws for %ws Error: %x\n",
            _DfsReplicaInfo.pwszServerName, peid->Prefix.Buffer, status));
    }

    if (status == DFS_STATUS_NOSUCH_LOCAL_VOLUME)
        dwErr = ERROR_SUCCESS;
    else if (!NT_SUCCESS(status))
        dwErr = RtlNtStatusToDosError(status);
    else
        dwErr = ERROR_SUCCESS;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsService::DeleteLocalVolume() exit\n"));

    return( dwErr );

}


//+----------------------------------------------------------------------------
//
//  Function:   CDfsService::SetVolumeState
//
//  Synopsis:   This method sets the Online/Offline state of the volume at
//              the remote machine.
//
//  Arguments:  [peid] -- The entry id of the volume.
//
//              [fState] -- The state to set it at.
//
//              [fRemoteOpMustSucceed] -- If TRUE, then the whole operation
//                      fails if the remote server cannot be forced offline.
//                      If FALSE, then the operation succeeds as long as the
//                      local DC's PKT is updated.
//
//  Returns:    ERROR_SUCCESS -- The state of the volume was set as specified.
//
//              Converted NTSTATUS from call to remote dfs.
//
//-----------------------------------------------------------------------------

DWORD
CDfsService::SetVolumeState(
    const PDFS_PKT_ENTRY_ID peid,
    const ULONG fState,
    const BOOL fRemoteOpMustSucceed)
{
    NTSTATUS Status;
    DWORD dwErr = ERROR_SUCCESS;
    SYSTEMTIME st;

    //
    // We first inform the DC's Dfs driver to set the replica state.
    //

    Status = DfsSetServiceState( peid, GetServiceName(), fState );

    //
    // Save the changed state
    //

    if (NT_SUCCESS(Status)) {

        GetSystemTime( &st );
        SystemTimeToFileTime( &st, &_ftModification );

        if (fState == DFS_SERVICE_TYPE_OFFLINE) {

            _DfsReplicaInfo.ulReplicaState = DFS_STORAGE_STATE_OFFLINE;

        } else {

            _DfsReplicaInfo.ulReplicaState = DFS_STORAGE_STATE_ONLINE;

        }

    }

    //
    // Only in the case that this succeeded and the service in question is
    // a dfs aware replica do we tell the server to take the volume offline
    //

    if (NT_SUCCESS(Status)) {

        if (_DfsReplicaInfo.ulReplicaType == DFS_STORAGE_TYPE_DFS) {

            Status = I_NetDfsSetLocalVolumeState(
                            _DfsReplicaInfo.pwszServerName,
                            &peid->Uid,
                            peid->Prefix.Buffer,
                            fState);

            DFSM_TRACE_ERROR_HIGH(Status, ALL_ERROR, CDfsServiceSetVolumeState_Error_I_NetDfsSetLocalVolumeState,
                                    LOGSTATUS(Status));

            if (!fRemoteOpMustSucceed) {

                Status = STATUS_SUCCESS;

            }

            if (!NT_SUCCESS(Status)) {

                //
                // Try to undo the DC's PKT change
                //

                NTSTATUS statusRecover;

                statusRecover = DfsSetServiceState(
                                    peid,
                                    GetServiceName(),
                                    (_DfsReplicaInfo.ulReplicaState ==
                                        DFS_STORAGE_STATE_OFFLINE) ?
                                        DFS_STORAGE_STATE_ONLINE : 0);


                dwErr = RtlNtStatusToDosError(Status);

            }

        } else {

            //
            // Replica is not dfs-aware
            //

            NOTHING;

        }

    } else {

        dwErr = RtlNtStatusToDosError(Status);

    }

    return( dwErr );
}


//+------------------------------------------------------------------------
//
// Method:      CDfsService::FixLocalVolume()
//
// Synopsis:    This method creates knowledge regarding a new volume at remote
//              machine. This method merely packages the info from private
//              section of the class into a buffer and makes an FSCTRL to the
//              remote service. The rest happens at the remote service. This
//              method does not affect the local PKT at all. It updates the
//              remote service's PKT and the DFS.CFG file on disk and updates
//              the registry at the other end.This is a kind of FORCE operation.
//              At the remote server every attempt will be made to create this
//              local volume knowledge.
//
// Arguments:   [peid]  --      The EntryId. This class does not know this.
//              [EntryType] --  Type of Entry. This class doesn't know this.
//
// Returns:     [ERROR_SUCCESS] -- If operation successfully completed.
//
// History:     18-June-93      SudK    Created.
//
//-------------------------------------------------------------------------

DWORD
CDfsService::FixLocalVolume(
    PDFS_PKT_ENTRY_ID peid,
    ULONG EntryType)
{
    DFS_PKT_RELATION_INFO RelationInfo;
    NET_DFS_ENTRY_ID_CONTAINER NetRelationInfo;
    DWORD             dwErr = ERROR_SUCCESS;
    NTSTATUS            status;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsService::FixLocalVolume()\n"));

    //
    // First to check whether this is necessary since this could be a down
    // level scenario.
    //

    if (_DfsReplicaInfo.ulReplicaType == DFS_STORAGE_TYPE_NONDFS)     {
        return(ERROR_SUCCESS);
    }

    //
    // Now we need to create a relation info structure. We will have to go to
    // the PKT for this since this is not available in the private section
    //

    dwErr = GetPktCacheRelationInfo(peid, &RelationInfo);

    if (dwErr != ERROR_SUCCESS) {

        IDfsVolInlineDebOut((
            DEB_ERROR, "Failed to do GetPktCacheRelationInfo on %ws %08lx\n",
            peid->Prefix.Buffer, dwErr));

        return( dwErr );
    }

    //
    // Now that we have the relationInfo. We know how to construct ConfigInfo.
    //

    RelationInfoToNetInfo( &RelationInfo, &NetRelationInfo );

    if (dwErr != ERROR_SUCCESS) {

        IDfsVolInlineDebOut((
            DEB_ERROR,
            "Failed to allocate memory for NET_ENTRY_ID_CONTAINER"));

        return( dwErr );

    }

    //
    // Now we are all setup to make the FSCTRL.
    //

    status = I_NetDfsFixLocalVolume(
                _DfsReplicaInfo.pwszServerName,
                _DfsReplicaInfo.pwszShareName,
                EntryType,
                _DfsPktService.Type,
                NULL,
                &peid->Uid,
                peid->Prefix.Buffer,
                &NetRelationInfo,
                PKT_ENTRY_SUPERSEDE);

    DFSM_TRACE_ERROR_HIGH(status, ALL_ERROR, CDfsServiceFixLocalVolume_Error_I_NetDfsFixLocalVolume,
                            LOGSTATUS(status));

    if (!NT_SUCCESS(status))
        dwErr = RtlNtStatusToDosError(status);

    DeallocateCacheRelationInfo(RelationInfo);

    delete [] NetRelationInfo.Buffer;

    if (dwErr != ERROR_SUCCESS)     {
        IDfsVolInlineDebOut((
            DEB_TRACE, "Failed to FixLocalVolume at %ws for %ws. Error: %x\n",
            _DfsReplicaInfo.pwszServerName, peid->Prefix.Buffer, dwErr));
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsService::FixLocalVolume() exit\n"));

    return( dwErr );

}



//+------------------------------------------------------------------------
//
// Method:      CDfsService::ModifyPrefix()
//
// Synopsis:    This method takes the PKT_ENTRY_ID that it gets and advises
//              the remote server of the new prefix for the volume ID.
//
// Arguments:   [peid] --       NewEntry ID for this service.
//
// Returns:     [ERROR_SUCCESS] -- If operation completed successfully.
//
// History:     31 April 93     SudK    Created.
//
//-------------------------------------------------------------------------
DWORD
CDfsService::ModifyPrefix(
    PDFS_PKT_ENTRY_ID peid)
{
    DWORD                     dwErr = ERROR_SUCCESS;
    NTSTATUS                    status;
    BOOL                        fRetry;

    //
    // First to check whether this is necessary since this could be a down
    // level scenario.
    //

    if (_DfsReplicaInfo.ulReplicaType == DFS_STORAGE_TYPE_NONDFS)     {
        return(ERROR_SUCCESS);
    }

    fRetry = FALSE;

    do {

        status = I_NetDfsModifyPrefix(
                    _DfsReplicaInfo.pwszServerName,
                    &peid->Uid,
                    peid->Prefix.Buffer);

        DFSM_TRACE_ERROR_HIGH(status, ALL_ERROR, CDfsServiceModifyPrefix_Error_I_NetDfsModifyPrefix,
                                LOGSTATUS(status));

        if (fRetry) {

            //
            // We have already tried once to sync up the server. Time to quit
            //

            fRetry = FALSE;

        } else if (status == DFS_STATUS_NOSUCH_LOCAL_VOLUME ||
                    status == DFS_STATUS_BAD_EXIT_POINT) {

                //
                // The server seems to be out of sync with this DC. Try to
                // force it to sync up
                //

                fRetry = SyncKnowledge();

        }

    } while ( fRetry );

    if (!NT_SUCCESS(status))
        dwErr = RtlNtStatusToDosError(status);


    if (dwErr != ERROR_SUCCESS)     {
        IDfsVolInlineDebOut((
            DEB_TRACE,
            "Failed to do ModifyPrefix at [%ws] to [%ws]. Error: %x\n",
            _DfsReplicaInfo.pwszServerName, peid->Prefix.Buffer, dwErr));
    }

    return( dwErr );

}


//+----------------------------------------------------------------------------
//
//  Function:  CDfsService::SyncKnowledge()
//
//  Synopsis:  Tries to force the server's knowledge to correspond with that
//             on this DC.
//
//  Arguments: None.
//
//  Returns:   TRUE if the server had to change any knowledge and was able
//             to do so. FALSE if either nothing changed or the server was
//             unable to comply.
//
//-----------------------------------------------------------------------------

BOOL CDfsService::SyncKnowledge()
{
    NTSTATUS Status = STATUS_SUCCESS;
    DFS_PKT_ENTRY_ID EntryId;

    EntryId.Uid = _DfsPktService.pMachEntry->pMachine->guidMachine;

    RtlInitUnicodeString(
        &EntryId.Prefix,
        _DfsReplicaInfo.pwszServerName );

    // Status = DfsSetServerInfo( &EntryId, NULL );

    if (!NT_SUCCESS(Status)) {

        LogMessage(
            DEB_ERROR, &EntryId.Prefix.Buffer, 1, DFS_CANT_SYNC_SERVER_MSG );

    }
    return( (BOOL) (Status == STATUS_REGISTRY_RECOVERED) );

}

//+----------------------------------------------------------------------------
//
//  Function:  CDfsService::VerifyStgIdInUse
//
//  Synopsis:  Given a storage id, verifies using knowledge on the DC whether
//             that storage id or some parent/child thereof is already shared.
//             This routine simply fsctls to the driver, which does the
//             verification.
//
//  Arguments: [pustrStgId] -- The storage id to check.
//
//  Returns:   TRUE if this storage id or some parent/child thereof is already
//             shared, FALSE otherwise.
//
//-----------------------------------------------------------------------------

BOOL CDfsService::VerifyStgIdInUse(
    PUNICODE_STRING pustrStgId)
{

    NTSTATUS            Status = STATUS_SUCCESS;
    DFS_PKT_ENTRY_ID    EntryId;
    BOOL                fStgIdInUse;

    //
    // Marshal the machine's Guid and the storage id into a DFS_PKT_ENTRY_ID
    // structure, and fsctl to the driver to verify the storage id.
    //

    memcpy(
        (PVOID) &EntryId.Uid,
        (PVOID) &_DfsPktService.pMachEntry->pMachine->guidMachine,
        sizeof(GUID) );

    EntryId.Prefix = *pustrStgId;

    // Status = DfsCheckStgIdInUse( &EntryId );

    fStgIdInUse = (Status == STATUS_DEVICE_BUSY);

    if (Status != STATUS_DEVICE_BUSY && Status != STATUS_SUCCESS) {

        LogMessage( DEB_TRACE,
                    &pustrStgId->Buffer,
                    1,
                    DFS_CANT_VERIFY_SERVER_KNOWLEDGE_MSG );

    }

    return( fStgIdInUse );

}

//+----------------------------------------------------------------------------
//
//  Function:   CDfsService::SetCreateTime, public
//
//  Synopsis:   Initializes the Modification Time of this service to the
//              current time.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID CDfsService::SetCreateTime()
{
    SYSTEMTIME st;
    FILETIME ft;

    GetSystemTime( &st );
    SystemTimeToFileTime( &st, &_ftModification );

}

//+----------------------------------------------------------------------------
//
//  Function:   RelationInfoToNetInfo, private
//
//  Synopsis:   Converts a DFS_PKT_RELATION_INFO struct into a
//              NET_DFS_ENTRY_ID_CONTAINER struct for use with I_NetDfs calls.
//
//  Arguments:  [RelationInfo] -- Reference to source DFS_PKT_RELATION_INFO
//
//              [pNetInfo] -- On successful return, contains a valid
//                      NET_DFS_ENTRY_ID_CONTAINER. pNetInfo->Buffer is
//                      allocated using new - caller responsible for freeing
//                      it using delete.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully created *ppNetInfo.
//
//              [ERROR_OUTOFMEMORY] -- Unable to allocate room for the info.
//
//-----------------------------------------------------------------------------

DWORD
RelationInfoToNetInfo(
    PDFS_PKT_RELATION_INFO RelationInfo,
    LPNET_DFS_ENTRY_ID_CONTAINER pNetInfo)
{
    DWORD dwErr;
    ULONG i;

    //
    // The +1 is so we don't try to do a 0 length allocation. This simplifies
    // cleanup in the caller's code.
    //

    pNetInfo->Buffer = new NET_DFS_ENTRY_ID
                            [RelationInfo->SubordinateIdCount + 1];

    if (pNetInfo->Buffer != NULL) {

        pNetInfo->Count = RelationInfo->SubordinateIdCount;

        for (i = 0; i < pNetInfo->Count; i++) {

            pNetInfo->Buffer[i].Uid = RelationInfo->SubordinateIdList[i].Uid;
            pNetInfo->Buffer[i].Prefix =
                RelationInfo->SubordinateIdList[i].Prefix.Buffer;

        }

        dwErr = ERROR_SUCCESS;

    } else {

        pNetInfo->Count = 0;

        dwErr = ERROR_OUTOFMEMORY;

    }

    return( dwErr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\upgrade.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1995, Microsoft Corporation
//
//  File:       upgrade.cxx
//
//  Contents:   Code to handle version upgrades of Dfs Volume Objects
//
//  Classes:    None
//
//  Functions:  CDfsVolume::UpgradeObject
//
//  History:    May 15, 1995    Milans created
//
//-----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <dfsmrshl.h>
#include "cdfsvol.hxx"
#include "marshal.hxx"
#include "recon.hxx"
#include "svclist.hxx"

//+----------------------------------------------------------------------------
//
//  Function:   CDfsVolume::UpgradeObject
//
//  Synopsis:   This routine is called everytime a volume object is loaded
//              and takes care of any version upgrades that need to be done.
//
//  Arguments:  None
//
//  Returns:    ERROR_SUCCESS if successfully upgraded object.
//
//              Error code from property operation if unable to upgrade object
//
//-----------------------------------------------------------------------------

DWORD
CDfsVolume::UpgradeObject()
{
    DWORD dwErr;
    DWORD dwCurrentVersion;
    BOOLEAN fUpgraded = FALSE;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::UpgradeObject()\n"));

    dwErr = GetVersion(&dwCurrentVersion);

    if (dwErr == ERROR_SUCCESS) {

        //
        // Version 1 had the name of the current machine included in the
        // ServiceList. This prevented Dfs from working when the machine got
        // renamed. We upgrade by simply reading in the old service list,
        // and saving it out again. The save process will replace the local
        // machine name with a ".". See CDfsServiceList::Serialize().
        //

        if (dwCurrentVersion == 1) {

            CDfsServiceList dfsSvcList;

            dwErr = dfsSvcList.InitializeServiceList(_pStorage);

            if (dwErr == ERROR_SUCCESS) {

                dwErr = dfsSvcList.SerializeSvcList();

                if (dwErr == ERROR_SUCCESS) {

                    dwErr = dfsSvcList.SetServiceListProperty( FALSE );

                }

            }

            fUpgraded = (dwErr == ERROR_SUCCESS);

        }



    }

    //
    // If an upgrade was needed and it succeeded, then update the version
    // number.
    //

    if ((dwErr == ERROR_SUCCESS) && fUpgraded) {

        (VOID) SetVersion( FALSE );
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::UpgradeObject() exit\n"));

    return( dwErr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\uprefixp.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1995, Microsoft Corporation
//
//  File:       uprefixp.c
//
//  Contents:   Code to implement a Unicode Prefix Table.
//
//  Classes:
//
//  Functions:
//
//  History:    12-28-95        Milans  Created
//
//-----------------------------------------------------------------------------

#include <ntifs.h>
#include <ntext.h>
#include <libsup.h>
#include <stdlib.h>

#include "prefixp.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\uprefix.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1995, Microsoft Corporation
//
//  File:       uprefix.c
//
//  Contents:   Code to implement a Unicode Prefix Table.
//
//  Classes:
//
//  Functions:
//
//  History:    12-28-95        Milans Created
//
//-----------------------------------------------------------------------------

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <dfsfsctl.h>
#include <windows.h>


//#include <ntifs.h>
//#include <ntext.h>
#include <stdlib.h>
#include <libsup.h>

#ifdef KERNEL_MODE
#include <dfsprocs.h>

#define Dbg     DEBUG_TRACE_RTL

#else

#define DebugTrace(x,y,z,a)

#endif

#include <prefix.h>
#include <prefixp.h>

#include "dfsmwml.h"

extern ULONG DfsSvcVerbose;

PDFS_PREFIX_TABLE_ENTRY
DfspNextUnicodeTableEntry(
    IN PDFS_PREFIX_TABLE_ENTRY pEntry);

//+---------------------------------------------------------------------------
//
//  Function:   DfsInitializePrefixTable
//
//  Synopsis:   API for initializing the prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS DfsInitializePrefixTable(PDFS_PREFIX_TABLE pTable, BOOLEAN fCaseSensitive)
{
    NTSTATUS status = STATUS_SUCCESS;

    DebugTrace(+1, Dbg,"DfsInitializePrefixTable -- Entry\n", 0);

    if (pTable != NULL)
    {
        ULONG i;

        // Initialize flags
        pTable->CaseSensitive = fCaseSensitive;

        // Initialize the root entry
        INITIALIZE_PREFIX_TABLE_ENTRY(&pTable->RootEntry);

        // Initialize the various buckets.
        for (i = 0;i < NO_OF_HASH_BUCKETS;i++)
        {
            INITIALIZE_BUCKET(pTable->Buckets[i]);
        }

        // Initialize the name page list.
        pTable->NamePageList.pFirstPage = ALLOCATE_NAME_PAGE();
        if (pTable->NamePageList.pFirstPage != NULL)
        {
            INITIALIZE_NAME_PAGE(pTable->NamePageList.pFirstPage);

            // Initialize the prefix table entry allocation mechanism.
            status = _InitializePrefixTableEntryAllocation(pTable);
        }
        else
        {
            status = STATUS_NO_MEMORY;
            DFSM_TRACE_HIGH(ERROR, DfsInitializePrefixTable_Error1, LOGSTATUS(status));
            DebugTrace(0, Dbg,"DfsInitializePrefixTable Error -- %lx\n",status);
        }
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
        DFSM_TRACE_HIGH(ERROR, DfsInitializePrefixTable_Error2, LOGSTATUS(status));
        DebugTrace(0, Dbg,"DfsInitializePrefixTable Error -- %lx\n",status);
    }

    DebugTrace(-1, Dbg, "DfsInitializePrefixTable -- Exit\n", 0);
    return  status;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsInsertInPrefixTable
//
//  Synopsis:   API for inserting a path in the prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pData] -- BLOB associated with the path
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS DfsInsertInPrefixTable(PDFS_PREFIX_TABLE pTable,
                                 PUNICODE_STRING   pPath,
                                 PVOID             pData)
{
    NTSTATUS                status = STATUS_SUCCESS;
    WCHAR                   Buffer[MAX_PATH_SEGMENT_SIZE];
    PWCHAR                  NameBuffer = Buffer;
    USHORT                  cbNameBuffer = sizeof(Buffer);
    UNICODE_STRING          Path,Name;
    ULONG                   BucketNo;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    PDFS_PREFIX_TABLE_ENTRY pParentEntry = NULL;
    BOOLEAN                 fNameFound = FALSE;

    DebugTrace(+1, Dbg, "DfsInsertInPrefixTable -- Entry\n", 0);

    // There is one special case, i.e., in which the prefix is '\'.
    // Since this is the PATH_DELIMITER which is treated in a special
    // way, we do the processing upfront.

    if (pPath->Length == 0)
    {
        return STATUS_SUCCESS;
    }
    else if ((pPath->Length == sizeof(WCHAR)) &&
        (pPath->Buffer[0] == PATH_DELIMITER))
    {
       pTable->RootEntry.pData = pData;
       return STATUS_SUCCESS;
    }
    else
    {
        Path.Length = pPath->Length - sizeof(WCHAR);
        Path.MaximumLength = pPath->MaximumLength;
        Path.Buffer = &pPath->Buffer[1];
        pParentEntry = &pTable->RootEntry;
    }

    if (Path.Length > MAX_PATH_SEGMENT_SIZE * sizeof(WCHAR) ) {
        NameBuffer = ExAllocatePool( NonPagedPool, Path.Length + sizeof(WCHAR) );
        if (NameBuffer == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            DFSM_TRACE_HIGH(ERROR, DfsInsertInPrefixTable_Error1, 
                            LOGSTATUS(status)
                            LOGUSTR(*pPath));
            DebugTrace(0, Dbg, "Unable to allocate %d non-paged bytes\n", (Path.Length + sizeof(WCHAR)) );
            return( STATUS_INSUFFICIENT_RESOURCES );
        } else {
            cbNameBuffer = Path.Length + sizeof(WCHAR);
        }
    }

    while (Path.Length > 0)
    {
        Name.Length = 0;
        Name.Buffer = NameBuffer;
        Name.MaximumLength = cbNameBuffer;

        // Process the name segment
        if (pTable->CaseSensitive)
        {
            SPLIT_CASE_SENSITIVE_PATH(&Path,&Name,BucketNo);
        }
        else
        {
            SPLIT_CASE_INSENSITIVE_PATH(&Path,&Name,BucketNo);
        }

        if (Name.Length > 0)
        {
            // Lookup the table to see if the name segment already exists.
            DebugTrace(0, Dbg, "LOOKUP_BUCKET: Bucket(%ld)", BucketNo);
            DebugTrace(0, Dbg, " for Name(%wZ)\n", &Name);

            LOOKUP_BUCKET(pTable->Buckets[BucketNo],Name,pParentEntry,pEntry,fNameFound);

            DebugTrace(0, Dbg, "returned pEntry(%lx)", pEntry);
            DebugTrace(0, Dbg, " fNameFound(%s)\n", fNameFound ? "TRUE" : "FALSE");

            if (pEntry == NULL)
            {
                // Initialize the new entry and initialize the name segment.
                pEntry = ALLOCATE_DFS_PREFIX_TABLE_ENTRY(pTable);
                if (pEntry != NULL)
                {
                    INITIALIZE_PREFIX_TABLE_ENTRY(pEntry);

                    // Allocate the name space entry if there is no entry in the
                    // name page.
                    if (!fNameFound || fNameFound)
                    {
                        PWSTR pBuffer;

                        // Allocate the entry in the name page.
                        pBuffer = ALLOCATE_NAME_PAGE_ENTRY((pTable->NamePageList),(Name.Length/sizeof(WCHAR)));

                        if (pBuffer != NULL)
                        {
                            RtlZeroMemory(pBuffer, Name.Length);
                            RtlCopyMemory(pBuffer,Name.Buffer,Name.Length);
                            pEntry->PathSegment = Name;
                            pEntry->PathSegment.Buffer = pBuffer;
                        }
                        else
                        {
                            status = STATUS_NO_MEMORY;
                            DFSM_TRACE_HIGH(ERROR, DfsInsertInPrefixTable_Error2,
                                             LOGSTATUS(status)
                                            LOGUSTR(*pPath));
                            break;
                        }
                    }
                    else
                        pEntry->PathSegment = Name;

                    // thread the entry to point to the parent.
                    pEntry->pParentEntry = pParentEntry;

                    // Insert the entry in the bucket.
                    INSERT_IN_BUCKET(pTable->Buckets[BucketNo],pEntry);

                    // Insert the entry in the parent's children list.
                    INSERT_IN_CHILD_LIST(pEntry, pParentEntry);
                }
                else
                {
                    status = STATUS_NO_MEMORY;
                    DebugTrace(0, Dbg, "DfsInsertInPrefixTable Error -- %lx\n",status);
                    DFSM_TRACE_HIGH(ERROR, DfsInsertInPrefixTable_Error3, 
                                    LOGSTATUS(status)
                                    LOGUSTR(*pPath));
                    break;
                }
            }
            else
            {
                // Increment the no. of children associated with  this entry

                pEntry->NoOfChildren++;
            }

            pParentEntry = pEntry;
        }
        else
        {
            status = STATUS_INVALID_PARAMETER;
            DFSM_TRACE_HIGH(ERROR, DfsInsertInPrefixTable_Error4, 
                            LOGSTATUS(status)
                            LOGUSTR(*pPath));
            DebugTrace(0, Dbg, "DfsInsertInPrefixTable Error -- %lx\n",status);
            break;
        }
    }

    // If a new entry was not successfully inserted we need to walk up the chain
    // of parent entries to undo the increment to the reference count and
    // remove the entries from their parent links.
    if (NT_SUCCESS(status))
    {
        // The entry was successfully inserted in the prefix table. Update
        // the data (BLOB) associated with it.
        // We do it outside the loop to prevent redundant comparisons within
        // the loop.

        if (pEntry != NULL) {
            pEntry->pData = pData;
        }
    }
    else
    {
        while (pParentEntry != NULL)
        {
            PDFS_PREFIX_TABLE_ENTRY pMaybeTempEntry;

            pMaybeTempEntry = pParentEntry;
            pParentEntry = pParentEntry->pParentEntry;

            if (--pMaybeTempEntry->NoOfChildren == 0) {
                //
                // If pParentEntry == NULL, pMaybeTempEntry is
                // pTable->RootEntry. Do not try to remove it.
                //
                if (pParentEntry != NULL) {
                    REMOVE_FROM_CHILD_LIST(pMaybeTempEntry);
                    REMOVE_FROM_BUCKET(pMaybeTempEntry);
		    if ((pMaybeTempEntry)->PathSegment.Buffer != NULL)
		      free ((pMaybeTempEntry)->PathSegment.Buffer);
		    free (pMaybeTempEntry);
                }
            }
        }
    }

    if (NameBuffer != Buffer) {
        ExFreePool( NameBuffer );
    }

    DebugTrace(-1, Dbg, "DfsInsertInPrefixTable -- Exit\n", 0);
    return status;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsLookupPrefixTable
//
//  Synopsis:   private fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pSuffix] -- the suffix that could not be found.
//
//              [ppData] -- placeholder for the BLOB for the prefix.
//
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//                  STATUS_OBJECT_PATH_NOT_FOUND -- no entry for the path
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS DfsLookupPrefixTable(PDFS_PREFIX_TABLE   pTable,
                               PUNICODE_STRING     pPath,
                               PUNICODE_STRING     pSuffix,
                               PVOID               *ppData)
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;

    DebugTrace(+1, Dbg, "DfsLookupInPrefixTable -- Entry\n", 0);

    if (pPath->Length == 0)
    {
        DebugTrace(-1, Dbg, "DfsLookupInPrefixTable Exited - Null Path!\n", 0);
        return STATUS_SUCCESS;
    }
    else
    {
        status = _LookupPrefixTable(pTable,pPath,pSuffix,&pEntry);

        // Update the BLOB placeholder with the results of the lookup.
        if (NT_SUCCESS(status))
        {
             *ppData = pEntry->pData;
        }

        DebugTrace(-1, Dbg, "DfsLookupInPrefixTable -- Exit\n", 0);
        return status;
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   DfsFindUnicodePrefix
//
//  Synopsis:   fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pSuffix] -- the suffix that could not be found.
//
//  Returns:    a valid ptr if successfull, NULL otherwise
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PVOID DfsFindUnicodePrefix(PDFS_PREFIX_TABLE   pTable,
                           PUNICODE_STRING     pPath,
                           PUNICODE_STRING     pSuffix)
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    PVOID                   pData  = NULL;

    DebugTrace(+1, Dbg, "DfsFindUnicodePrefix -- Entry\n", 0);

    if (pPath->Length == 0)
    {
        DebugTrace(-1, Dbg, "DfsFindUnicodePrefix Exited - Null Path!\n", 0);
        return NULL;
    }
    else
    {
        status = _LookupPrefixTable(pTable,pPath,pSuffix,&pEntry);

        // Update the BLOB placeholder with the results of the lookup.
        if (NT_SUCCESS(status))
        {
             pData = pEntry->pData;
        }

        DebugTrace(-1, Dbg, "DfsFindUnicodePrefix -- Exit\n", 0);
        return pData;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsRemoveFromPrefixTable
//
//  Synopsis:   private fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//                  STATUS_OBJECT_PATH_NOT_FOUND -- no entry for the path
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS DfsRemoveFromPrefixTable(PDFS_PREFIX_TABLE pTable,
                                   PUNICODE_STRING pPath)
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING Path,Suffix;
    ULONG    BucketNo;

    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;

    DebugTrace(+1, Dbg, "DfsRemoveFromPrefixTable -- Entry\n", 0);

    Suffix.Length = 0;
    Suffix.Buffer = NULL;

    if (pPath->Length == 0)
    {
        DebugTrace(-1, Dbg, "DfsRemoveFromPrefixTable Exited -- Null Path!\n", 0);
        return STATUS_SUCCESS;
    }

    else if ((pPath->Length == sizeof(WCHAR)) &&
        (pPath->Buffer[0] == PATH_DELIMITER))
    {
        if (pTable->RootEntry.pData == NULL)
        {
            status = STATUS_OBJECT_PATH_NOT_FOUND;
            DFSM_TRACE_HIGH(ERROR, DfsRemoveFromPrefixTable_Error1, 
                            LOGSTATUS(status)
                            LOGUSTR(*pPath));
        }
        else
        {
            pTable->RootEntry.pData = NULL;
            DebugTrace(-1, Dbg, "DfsRemoveFromPrefixTable Exited.\n", 0);
            return  STATUS_SUCCESS;
        }
    }
    else
    {
        Path.Length = pPath->Length - sizeof(WCHAR);
        Path.MaximumLength = pPath->MaximumLength;
        Path.Buffer = &pPath->Buffer[1];

        status = _LookupPrefixTable(pTable,&Path,&Suffix,&pEntry);

        if (NT_SUCCESS(status) && (Suffix.Length == 0))
        {
            // Destroy the association between the data associated with
            // this prefix.
            pEntry->pData = NULL;

            // found an exact match for the given path name in the table.
            // traverse the list of parent pointers and delete them if
            // required.

            while (pEntry != NULL)
            {
                if ((--pEntry->NoOfChildren) == 0)
                {
                    PDFS_PREFIX_TABLE_ENTRY pTempEntry = pEntry;
                    pEntry = pEntry->pParentEntry;

                    //
                    // pEntry == NULL means pTempEntry is pTable->RootEntry.
                    // Do not try to remove it.
                    //
                    if (pEntry != NULL) {
                        REMOVE_FROM_CHILD_LIST(pTempEntry);
                        REMOVE_FROM_BUCKET(pTempEntry);
			if ((pTempEntry)->PathSegment.Buffer != NULL)
			  free ((pTempEntry)->PathSegment.Buffer);
			free (pTempEntry);
                    }
                }
                else
                   break;
            }
        }
    }

    DebugTrace(-1, Dbg, "DfsRemoveFromPrefixTable -- Exit\n", 0);
    return status;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsNextUnicodePrefix
//
//  Synopsis:   Enumerates the entries in the table in ordered fashion.
//              Note that state is maintained between calls to
//              DfsNextUnicodePrefix - the caller must ensure that the table
//              is not modified between calls to DfsNextUnicodePrefix.
//
//  Arguments:  [pTable] -- The table to enumerate over.
//              [fRestart] -- If TRUE, starts the enumeration. If FALSE,
//                      continues from where the enumeration left off.
//
//  Returns:    Valid pointer to data associated with the next Prefix Table
//              entry, or NULL if at the end of the enumeration.
//
//
//-----------------------------------------------------------------------------

PVOID DfsNextUnicodePrefix(
    IN PDFS_PREFIX_TABLE pTable,
    IN BOOLEAN fRestart)
{
    PDFS_PREFIX_TABLE_ENTRY pEntry, pNextEntry;

    if (fRestart) {
        pNextEntry = &pTable->RootEntry;
        while (pNextEntry != NULL && pNextEntry->pData == NULL) {
            pNextEntry = DfspNextUnicodeTableEntry( pNextEntry );
        }
    } else {
        pNextEntry = pTable->NextEntry;
    }

    pEntry = pNextEntry;

    if (pNextEntry != NULL) {
        do {
            pNextEntry = DfspNextUnicodeTableEntry( pNextEntry );
        } while ( pNextEntry != NULL && pNextEntry->pData == NULL );
        pTable->NextEntry = pNextEntry;
    }

    if (pEntry != NULL) {
        return( pEntry->pData );
    } else {
        return( NULL );
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   DfspNextUnicodeTableEntry
//
//  Synopsis:   Given a pointer to a Prefix Table Entry, this function will
//              return a pointer to the "next" prefix table entry.
//
//              The "next" entry is chosen as follows:
//                  If the start entry has a valid child, the child is
//                      is returned.
//                  else if the start entry has a valid sibling, the sibling
//                      is returned
//                  else the first valid sibling of the closest ancestor is
//                      returned.
//
//  Arguments:  [pEntry] -- The entry to start from.
//
//  Returns:    Pointer to the next DFS_PREFIX_TABLE_ENTRY that has a valid
//              pData, or NULL if there are no more entries.
//
//-----------------------------------------------------------------------------

PDFS_PREFIX_TABLE_ENTRY
DfspNextUnicodeTableEntry(
    IN PDFS_PREFIX_TABLE_ENTRY pEntry)
{
    PDFS_PREFIX_TABLE_ENTRY pNextEntry;

    if (pEntry->pFirstChildEntry != NULL) {
        pNextEntry = pEntry->pFirstChildEntry;
    } else if (pEntry->pSiblingEntry != NULL) {
        pNextEntry = pEntry->pSiblingEntry;
    } else {
        for (pNextEntry = pEntry->pParentEntry;
                pNextEntry != NULL && pNextEntry->pSiblingEntry == NULL;
                    pNextEntry = pNextEntry->pParentEntry) {
             NOTHING;
        }
        if (pNextEntry != NULL) {
            pNextEntry = pNextEntry->pSiblingEntry;
        }
    }

    return( pNextEntry );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsNextUnicodePrefixChild
//
//  Synopsis:   Enumerates the immediate children of a given prefix.
//
//  Arguments:  [pTable] -- The DFS prefix table to use.
//              [pPath] -- The prefix whose children are to be enumerated.
//              [pCookie] -- On first call, this point to a NULL. On return,
//                      it will be set to a cookie that should be returned
//                      on subsequent calls to continue the enumeration.
//
//  Returns:    On successful return, a pointer to the child prefix that has a
//              valid pData, or NULL if at the end of the enumeration, or if
//              pPath is not a valid prefix in the table to begin with.
//
//-----------------------------------------------------------------------------

PVOID
DfsNextUnicodePrefixChild(
    IN PDFS_PREFIX_TABLE pTable,
    IN PUNICODE_STRING pPath,
    OUT PVOID *ppCookie)
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    UNICODE_STRING          suffix;
    PVOID                   pData;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsNextUnicodePrefixChild(%wZ,0x%x)\n",
                    pPath,
                    *ppCookie);
#endif

    //
    // If at end, simply return NULL
    //

    if ((*ppCookie) == (PVOID) -1)
        return NULL;

    pEntry = (PDFS_PREFIX_TABLE_ENTRY) (*ppCookie);

    //
    // If starting, get the first child entry
    //

    if (pEntry == NULL) {

        if (pPath->Length > 0) {

            status = _LookupPrefixTable(pTable,pPath,&suffix,&pEntry);

            if (NT_SUCCESS(status)) {

                pEntry = pEntry->pFirstChildEntry;

            }

        }

    }

    //
    // pEntry is now set - if NULL we're at the end
    //

    (*ppCookie) = (PVOID) -1;
    pData = NULL;

    if (pEntry != NULL) {

        pData = pEntry->pData;

        if (pEntry->pSiblingEntry != NULL) {

            (*ppCookie) = (PVOID) pEntry->pSiblingEntry;

        }

    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsNextUnicodePrefixChild returning 0x%x, Cookie=0x%x)\n",
                    pData,
                    *ppCookie);
#endif

    return( pData );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfssvc\dfsipc.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       dfsipc.h
//
//  Contents:   Code to communicate with the Dfs driver. The Dfs driver
//              sends messages to the user level to resolve a name to either a domain or
//              computer based Dfs name.
//
//  Classes:    None
//
//  History:    Feb 1, 1996     Milans  Created
//
//-----------------------------------------------------------------------------

#ifndef _DFS_IPC_
#define _DFS_IPC_

typedef struct {
    HANDLE hThreadStarted;
    DWORD  dwThreadStatus;
} PROCESS_DRIVER_MESSAGE_STARTUP, *LPPROCESS_DRIVER_MESSAGE_STARTUP;

NTSTATUS
DfsInitOurDomainDCs(
    VOID);

NTSTATUS
DfsInitRemainingDomainDCs(
    VOID);

NTSTATUS
DfsGetTrustedDomainDCs(
    LPWSTR wszDomainName,
    ULONG  Flags);

NTSTATUS
DfsDomainReferral(
    LPWSTR wszDomain,
    LPWSTR wszShare);

#endif // _DFS_IPC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfssvc\dfsipc.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       dfsipc.c
//
//  Contents:   Code to communicate with the Dfs driver. The Dfs driver
//              sends messages to the user level to resolve a name to either a domain or
//              computer based Dfs name.
//
//  Classes:    None
//
//  History:    Feb 1, 1996     Milans  Created
//
//-----------------------------------------------------------------------------

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <dfsfsctl.h>
#include <windows.h>

#include <dfsstr.h>
#include <nodetype.h>
#include <libsup.h>
#include <dfsmrshl.h>
#include <upkt.h>
#include <ntlsa.h>

#include <dfsmsrv.h>
#include <lm.h>
#include <dsrole.h>

#include <crypt.h>
#include <samrpc.h>
#include <logonmsv.h>
#include <dsgetdc.h>
#include <ntdsapi.h>
#include <winldap.h>

#include "dominfo.h"
#include "dfsipc.h"
#include "svcwml.h"

DWORD
DfsLoadSiteTableFromDs(
    PLDAP pLDAP,
    LPWSTR wszFtDfsName,
    ULONG Count,
    PUNICODE_STRING pustr);

DWORD
DfsCreateSpcArg(
    LPWSTR DomainName,
    ULONG Timeout,
    ULONG Flags,
    ULONG TrustDirection,
    ULONG TrustType,
    LONG NameCount,
    PUNICODE_STRING pustrDCNames,
    PDFS_CREATE_SPECIAL_INFO_ARG *ppSpcArg,
    PULONG pSize);

DWORD
DfsCreateSiteArg(
    LPWSTR ServerName,
    ULONG SiteCount,
    PUNICODE_STRING pustrSiteNames,
    PDFS_CREATE_SITE_INFO_ARG *ppSiteArg,
    PULONG pSize);

DWORD
DfsGetFtServersFromDs(
    PLDAP  pLdap,
    LPWSTR wszDomainName,
    LPWSTR wszDfsName,
    LPWSTR **List);

//
// Event logging and debugging globals
//
extern ULONG DfsSvcVerbose;
extern ULONG DfsEventLog;

extern DFS_DOMAIN_INFO         DfsDomainInfo;
extern DSROLE_MACHINE_ROLE     DfsMachineRole;

extern WCHAR MachineName[MAX_PATH];
extern WCHAR DomainName[MAX_PATH];
extern WCHAR DomainNameDns[MAX_PATH];
extern WCHAR LastMachineName[MAX_PATH];
extern WCHAR LastDomainName[MAX_PATH];
extern WCHAR SiteName[MAX_PATH];

extern PLDAP pLdap;

extern CRITICAL_SECTION DomListCritSection;

BOOLEAN
DfsGetNextDomainName(
    LPWSTR DomName,
    ULONG Size);

NTSTATUS
DfsInitOurDomainDCs(VOID)
{

    DWORD dwErr;
    LPWSTR OurSite;
    NTSTATUS status;
    HANDLE dfsHandle = NULL;
    IO_STATUS_BLOCK ioStatus;
    ULONG cDom;
    PDFS_CREATE_SPECIAL_INFO_ARG pSpcArg;
    ULONG Size;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsInitOurDomainDCs()\n");
#endif

    dwErr = DsGetSiteName(
                NULL,
                &OurSite);

    RtlZeroMemory(SiteName, MAX_PATH * sizeof(WCHAR));

    if (dwErr == NO_ERROR) {

        wcscpy(SiteName, OurSite);

        NetApiBufferFree(OurSite);

    }

    status = DfsOpen(&dfsHandle, NULL);

    if (NT_SUCCESS(status)) {

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("Domain %ws/%ws\n",
                DomainName,
                DomainNameDns);
#endif

        status = DfsCreateSpcArg(
                        DomainName,
                        0,
                        DFS_SPECIAL_INFO_NETBIOS,
                        TRUST_DIRECTION_BIDIRECTIONAL,
                        TRUST_TYPE_UPLEVEL,
                        -1,
                        NULL,
                        &pSpcArg,
                        &Size);

        if (status == ERROR_SUCCESS) {

            status = NtFsControlFile(
                        dfsHandle,
                        NULL,       // Event,
                        NULL,       // ApcRoutine,
                        NULL,       // ApcContext,
                        &ioStatus,
                        FSCTL_DFS_CREATE_SPECIAL_INFO,
                        pSpcArg,
                        Size,
                        NULL,
                        0);

            free(pSpcArg);

        }

        status = DfsCreateSpcArg(
                        DomainNameDns,
                        0,
                        0,
                        TRUST_DIRECTION_BIDIRECTIONAL,
                        TRUST_TYPE_UPLEVEL,
                        -1,
                        NULL,
                        &pSpcArg,
                        &Size);

        if (status == ERROR_SUCCESS) {

            status = NtFsControlFile(
                        dfsHandle,
                        NULL,       // Event,
                        NULL,       // ApcRoutine,
                        NULL,       // ApcContext,
                        &ioStatus,
                        FSCTL_DFS_CREATE_SPECIAL_INFO,
                        pSpcArg,
                        Size,
                        NULL,
                        0);

#if DBG
            if (DfsSvcVerbose)
                DbgPrint("NtFsControlFile(FSCTL_DFS_CREATE_SPECIAL_INFO) returned 0x%x\n",
                                status);
#endif


            free(pSpcArg);

        }

    }

    if (dfsHandle != NULL) {
        NtClose( dfsHandle);
    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsInitOurDomainDCs returning 0x%x\n", status);
#endif

    DFSSVC_TRACE_LOW(DEFAULT, DfsInitOurDomainDCs_Exit, LOGSTATUS(status));
    return( status );

}

NTSTATUS
DfsInitRemainingDomainDCs(VOID)
{
    NTSTATUS status;
    HANDLE dfsHandle = NULL;
    IO_STATUS_BLOCK ioStatus;
    ULONG cDom;
    PDFS_CREATE_SPECIAL_INFO_ARG pSpcArg;
    ULONG Size;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsInitRemainingDomainDCs()\n");
#endif

    if (DfsDomainInfo.cDomains == 0) {

        return STATUS_SUCCESS;

    }

    status = DfsOpen(&dfsHandle, NULL);

    if (NT_SUCCESS(status)) {

        for (cDom = 0; cDom < DfsDomainInfo.cDomains; cDom++) {

#if DBG
            if (DfsSvcVerbose)
                DbgPrint("Trusted domain %ws/%ws\n",
                    DfsDomainInfo.rgustrDomains[cDom].DnsName.Buffer,
                    DfsDomainInfo.rgustrDomains[cDom].FlatName.Buffer);
#endif

            status = DfsCreateSpcArg(
                            DfsDomainInfo.rgustrDomains[cDom].FlatName.Buffer,
                            0,
                            DFS_SPECIAL_INFO_NETBIOS,
                            DfsDomainInfo.rgustrDomains[cDom].TrustDirection,
                            DfsDomainInfo.rgustrDomains[cDom].TrustType,
                            -1,
                            NULL,
                            &pSpcArg,
                            &Size);

            if (status == ERROR_SUCCESS) {

                status = NtFsControlFile(
                            dfsHandle,
                            NULL,       // Event,
                            NULL,       // ApcRoutine,
                            NULL,       // ApcContext,
                            &ioStatus,
                            FSCTL_DFS_CREATE_SPECIAL_INFO,
                            pSpcArg,
                            Size,
                            NULL,
                            0);

                DFSSVC_TRACE_ERROR_HIGH(status, ALL_ERROR, DfsInitRemainingDomainDCs_Error_NtFsControlFile,
                                        LOGSTATUS(status));
                free(pSpcArg);

            }

            status = DfsCreateSpcArg(
                            DfsDomainInfo.rgustrDomains[cDom].DnsName.Buffer,
                            0,
                            0,
                            DfsDomainInfo.rgustrDomains[cDom].TrustDirection,
                            DfsDomainInfo.rgustrDomains[cDom].TrustType,
                            -1,
                            NULL,
                            &pSpcArg,
                            &Size);

            if (status == ERROR_SUCCESS) {

                status = NtFsControlFile(
                            dfsHandle,
                            NULL,       // Event,
                            NULL,       // ApcRoutine,
                            NULL,       // ApcContext,
                            &ioStatus,
                            FSCTL_DFS_CREATE_SPECIAL_INFO,
                            pSpcArg,
                            Size,
                            NULL,
                            0);

                DFSSVC_TRACE_ERROR_HIGH(status, ALL_ERROR, 
                                        DfsInitRemainingDomainDCs_Error_NtFsControlFile2,
                                        LOGSTATUS(status));

                free(pSpcArg);

            }

        }

    }

    if (dfsHandle != NULL) {
        NtClose( dfsHandle);
    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsInitRemainingDomainDCs returning 0x%x\n", status);
#endif

    return( status );

}

NTSTATUS
_DfsGetTrustedDomainDCs(
    LPWSTR LpcDomainName,
    ULONG Flags)
{
    NTSTATUS status;
    DWORD dwErr;
    HANDLE dfsHandle = NULL;
    HANDLE hDs = NULL;
    IO_STATUS_BLOCK ioStatus;
    ULONG i, j;
    PDFS_CREATE_SPECIAL_INFO_ARG pSpcArg;
    ULONG NameCount = 0;
    ULONG NT5Count = 0;
    ULONG Size;
    ULONG Timeout = 10 * 60;
    ULONG TrustDirection;
    ULONG TrustType;
    ULONG cDom;
    PDS_DOMAIN_CONTROLLER_INFO_1 pDsDomainControllerInfo1 = NULL;
    PUNICODE_STRING pustrDCNames = NULL;
    UNICODE_STRING ustrSiteName;
    PDFS_CREATE_SITE_INFO_ARG pSiteArg;
    LPWSTR Name = NULL;
    WCHAR DnsDomName[MAX_PATH];
    UNICODE_STRING uDomainName;
    UNICODE_STRING uDomainNameDns;
    UNICODE_STRING uLpcDomainName;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsGetTrustedDomainDCs(%ws)\n", LpcDomainName);
#endif

    EnterCriticalSection(&DomListCritSection);

    RtlInitUnicodeString(&uDomainName, DomainName);
    RtlInitUnicodeString(&uDomainNameDns, DomainNameDns);
    RtlInitUnicodeString(&uLpcDomainName, LpcDomainName);

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("Comparing [%wZ/%wZ] to [%wZ]\n",
                &uDomainName,
                &uDomainNameDns,
                &uLpcDomainName);
#endif

    if (RtlCompareUnicodeString(&uDomainName, &uLpcDomainName, TRUE) == 0
            ||
        RtlCompareUnicodeString(&uDomainNameDns, &uLpcDomainName, TRUE) == 0
    ) {

        if (wcslen(DomainNameDns) <= MAX_PATH) {

            wcscpy(DnsDomName, DomainNameDns);
            TrustDirection = TRUST_DIRECTION_BIDIRECTIONAL;
            TrustType = TRUST_TYPE_UPLEVEL;

        } else {

            status = ERROR_NOT_ENOUGH_MEMORY;
            LeaveCriticalSection(&DomListCritSection);
            goto exit_with_status;

        }


    } else {

        for (cDom = 0; cDom < DfsDomainInfo.cDomains; cDom++) {

            RtlInitUnicodeString(&uLpcDomainName, LpcDomainName);

#if DBG
            if (DfsSvcVerbose)
                DbgPrint("Comparing [%wZ/%wZ] to [%wZ]\n",
                    &DfsDomainInfo.rgustrDomains[cDom].FlatName,
                    &DfsDomainInfo.rgustrDomains[cDom].DnsName,
                    &uLpcDomainName);
#endif

            if (RtlCompareUnicodeString(
                        &DfsDomainInfo.rgustrDomains[cDom].FlatName,
                        &uLpcDomainName,
                        TRUE) == 0
                   ||
                RtlCompareUnicodeString(
                        &DfsDomainInfo.rgustrDomains[cDom].DnsName,
                        &uLpcDomainName,
                        TRUE) == 0
            ) {

                break;

            }

        }

        if (cDom >= DfsDomainInfo.cDomains) {

            status = STATUS_OBJECT_NAME_NOT_FOUND;
            LeaveCriticalSection(&DomListCritSection);
            goto exit_with_status;

        }

        if (DfsDomainInfo.rgustrDomains[cDom].DnsName.Length/sizeof(WCHAR) <= MAX_PATH) {

            wcscpy(DnsDomName, DfsDomainInfo.rgustrDomains[cDom].DnsName.Buffer);
            TrustDirection = DfsDomainInfo.rgustrDomains[cDom].TrustDirection;
            TrustType = DfsDomainInfo.rgustrDomains[cDom].TrustType;

        } else {

            status = ERROR_NOT_ENOUGH_MEMORY;
            LeaveCriticalSection(&DomListCritSection);
            goto exit_with_status;

        }

    }

    LeaveCriticalSection(&DomListCritSection);

    status = DfsOpen(&dfsHandle, NULL);

    if (NT_SUCCESS(status)) {

        dwErr = DsBind(NULL, DnsDomName, &hDs);

        if (dwErr == NO_ERROR) {

            //
            // get DC list for that domain
            //

            dwErr = DsGetDomainControllerInfo(
                        hDs,
                        DnsDomName,
                        1,
                        &NameCount,
                        &pDsDomainControllerInfo1);

#if DBG
            if (DfsSvcVerbose)
                DbgPrint("DsGetDomainControllerInfo(%ws) returned %d\n",
                        DnsDomName,
                        dwErr);
#endif

            if (dwErr == NO_ERROR && pDsDomainControllerInfo1 != NULL) {

                //
                // Load Site info
                //

#if DBG
                if (DfsSvcVerbose)
                    DbgPrint("NameCount=%d\n", NameCount);
#endif

                for (i = 0; i < NameCount; i++) {

                    Name = (Flags & DFS_SPECIAL_INFO_NETBIOS) != 0 ? 
                                    pDsDomainControllerInfo1[i].NetbiosName :
                                    pDsDomainControllerInfo1[i].DnsHostName;

                    if (pDsDomainControllerInfo1[i].fDsEnabled == TRUE &&
                        Name != NULL &&
                        pDsDomainControllerInfo1[i].SiteName != NULL) {

                        RtlInitUnicodeString(
                                &ustrSiteName,
                                pDsDomainControllerInfo1[i].SiteName);
#if DBG
                        if (DfsSvcVerbose)
                            DbgPrint("%ws is in site %ws\n",
                                Name,
                                pDsDomainControllerInfo1[i].SiteName);
#endif

                        dwErr = DfsCreateSiteArg(
                                        Name,
                                        1,
                                        &ustrSiteName,
                                        &pSiteArg,
                                        &Size);

                        if ( dwErr != NO_ERROR) {

                            status = ERROR_NOT_ENOUGH_MEMORY;
                            goto exit_with_status;

                        }

                        NtFsControlFile(
                           dfsHandle,
                           NULL,
                           NULL,
                           NULL,
                           &ioStatus,
                           FSCTL_DFS_CREATE_SITE_INFO,
                           pSiteArg,
                           Size,
                           NULL,
                           0);

                        free(pSiteArg);

                   }

                }

                //
                // Convert to an array of UNICODE_STRINGS, taking only the NT5 DC's
                //

                for (i = NT5Count = 0; i < NameCount; i++) {

                    if (pDsDomainControllerInfo1[i].fDsEnabled == TRUE) {

                        NT5Count++;

                    }

                }

                if (NT5Count > 0) {

                    pustrDCNames = malloc(sizeof(UNICODE_STRING) * NT5Count);

                    if (pustrDCNames == NULL) {

                        status = ERROR_NOT_ENOUGH_MEMORY;
                        goto exit_with_status;

                    }

                    for (i = j = 0; i < NameCount; i++) {

                        Name = (Flags & DFS_SPECIAL_INFO_NETBIOS) != 0 ? 
                                    pDsDomainControllerInfo1[i].NetbiosName :
                                    pDsDomainControllerInfo1[i].DnsHostName;

                        if (pDsDomainControllerInfo1[i].fDsEnabled == TRUE && Name != NULL) {
                            RtlInitUnicodeString(
                                &pustrDCNames[j],
                                Name);
                            j++;

                        }

                    }

                }

#if DBG
                if (DfsSvcVerbose) {
                    DbgPrint("DFSINIT:%ws=", LpcDomainName);

                    for (i = 0; i < j; i++) {

                        DbgPrint("%wZ ", &pustrDCNames[i]);

                    }

                    DbgPrint("\n");
                    DbgPrint("Our domain has %d DC's\n", j);

                }
#endif


                status = DfsCreateSpcArg(
                                LpcDomainName,
                                Timeout,
                                Flags,
                                TrustDirection,
                                TrustType,
                                j,
                                pustrDCNames,
                                &pSpcArg,
                                &Size);

                if (status == ERROR_SUCCESS) {

                    status = NtFsControlFile(
                                dfsHandle,
                                NULL,       // Event,
                                NULL,       // ApcRoutine,
                                NULL,       // ApcContext,
                                &ioStatus,
                                FSCTL_DFS_CREATE_SPECIAL_INFO,
                                pSpcArg,
                                Size,
                                NULL,
                                0);

                    free(pSpcArg);

                }

                if (pustrDCNames != NULL) {

                    free(pustrDCNames);
                    pustrDCNames = NULL;

                }

            }

        } else {

            status = STATUS_DS_UNAVAILABLE;

        }

    }

exit_with_status:

    if (dfsHandle != NULL) {
        NtClose( dfsHandle);
    }

    if (pDsDomainControllerInfo1 != NULL) {
        DsFreeDomainControllerInfo(
            1,
            NameCount,
            pDsDomainControllerInfo1);
    }

    if (pustrDCNames != NULL) {
        free(pustrDCNames);
    }

    if (hDs != NULL) {
        DsUnBind(&hDs);
    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsGetTrustedDomainDCs returning 0x%x\n", status);
#endif

    return( status );

}

#define MAX_SPC_LONG_NAME_SIZE 2048

NTSTATUS
DfsGetTrustedDomainDCs(
    LPWSTR LpcDomainName,
    ULONG Flags)
{
   LPWSTR NewDomainName = NULL;
   NTSTATUS Status = STATUS_SUCCESS;

   if ((LpcDomainName != NULL) &&
       (*LpcDomainName != 0)) {
     return _DfsGetTrustedDomainDCs(LpcDomainName, Flags);
   }

   NewDomainName = malloc(MAX_SPC_LONG_NAME_SIZE);
   if (NewDomainName == NULL) {
     return STATUS_INSUFFICIENT_RESOURCES;
   }

   while (DfsGetNextDomainName(NewDomainName, MAX_SPC_LONG_NAME_SIZE) == TRUE) {
     Status = _DfsGetTrustedDomainDCs(NewDomainName, Flags);
   }

   free(NewDomainName);

   return Status;
}


DWORD
DfsCreateSpcArg(
    LPWSTR SpecialName,
    ULONG Timeout,
    ULONG Flags,
    ULONG TrustDirection,
    ULONG TrustType,
    LONG NameCount,
    PUNICODE_STRING pustrDCNames,
    PDFS_CREATE_SPECIAL_INFO_ARG *ppSpcArg,
    PULONG pSize)
{
    ULONG Size;
    PDFS_CREATE_SPECIAL_INFO_ARG pSpcArg;
    PUNICODE_STRING ustrp;
    WCHAR *wCp;
    LONG i;
    LONG j;
    DWORD status = STATUS_SUCCESS;
    UNICODE_STRING ComputerNetbiosName;
    UNICODE_STRING ComputerDnsName;
    ULONG ComputerNameSize;
    BOOL bStatus;
    WCHAR NetBIOSBuffer[MAX_COMPUTERNAME_LENGTH + 1];

    RtlInitUnicodeString(&ComputerNetbiosName, NULL);
    RtlInitUnicodeString(&ComputerDnsName, NULL);

    ComputerNetbiosName.Buffer = NetBIOSBuffer;
    ComputerNetbiosName.MaximumLength = (MAX_COMPUTERNAME_LENGTH + 1) * sizeof(WCHAR);

    ComputerNameSize = MAX_COMPUTERNAME_LENGTH + 1;
    if (GetComputerNameEx(ComputerNameNetBIOS,
                          ComputerNetbiosName.Buffer,
                          &ComputerNameSize)) {
        ComputerNetbiosName.Length = (USHORT)(ComputerNameSize - 1) * sizeof(WCHAR);
    }

    ComputerNameSize = 0;

    while( TRUE ) {

        bStatus = GetComputerNameEx( ComputerNameDnsFullyQualified,
                                     ComputerDnsName.Buffer,
                                     &ComputerNameSize );

        if( bStatus == TRUE ) {

            ComputerDnsName.Length = (USHORT)(ComputerNameSize - 1) * sizeof(WCHAR);
            break;
        }

        if( GetLastError() == ERROR_MORE_DATA ) {

            if( ComputerDnsName.Buffer != NULL ) {

                free( ComputerDnsName.Buffer );
            }

            ComputerDnsName.Buffer = malloc( ComputerNameSize * sizeof(WCHAR) );

            if( ComputerDnsName.Buffer == NULL ) {

                ComputerDnsName.MaximumLength = 0;
                break;
            }

            ComputerDnsName.MaximumLength = (USHORT)ComputerNameSize * sizeof(WCHAR);

        } else {

            break;
        }
    }

#if DBG
    if (DfsSvcVerbose) {
        DbgPrint("DfsCreateSpcArg(SpecialName=%ws,Timeout=%d,Flags=0x%x,NameCount=%d)\n",
            SpecialName,
            Timeout,
            Flags,
            NameCount);

        for (i = 0;  i < NameCount; i++) {
            DbgPrint("     Name[%d]:%wZ\n", i, &pustrDCNames[i]);
        }

    }
#endif

    //
    // Size the buffer
    //

    if (NameCount > 0) {

        Size = FIELD_OFFSET(DFS_CREATE_SPECIAL_INFO_ARG,Name[NameCount]) +
                    wcslen(SpecialName) * sizeof(WCHAR);

        for (i = 0; i < NameCount; i++) {

            Size += pustrDCNames[i].Length;

        }

    } else {

        Size = sizeof(DFS_CREATE_SPECIAL_INFO_ARG) +
                    wcslen(SpecialName) * sizeof(WCHAR);

    }

    pSpcArg = malloc(Size);

    if (pSpcArg != NULL) {

        ZeroMemory(pSpcArg, Size);

        // Marshall the info in

        pSpcArg->NameCount = NameCount;
        pSpcArg->Flags = Flags;
        pSpcArg->TrustDirection = TrustDirection;
        pSpcArg->TrustType = TrustType;
        pSpcArg->Timeout = Timeout;

        wCp = (WCHAR *) &pSpcArg->Name[NameCount < 0 ? 0 : NameCount];

        ustrp = &pSpcArg->SpecialName;
        ustrp->Buffer = wCp;
        ustrp->Length = ustrp->MaximumLength = wcslen(SpecialName) * sizeof(WCHAR);
        RtlCopyMemory(ustrp->Buffer, SpecialName, ustrp->Length);
        wCp += ustrp->Length / sizeof(WCHAR);

        for (i = 0; i < NameCount; i++) {
            BOOLEAN foundDc = FALSE;

            ustrp = &pSpcArg->Name[i];
            ustrp->Buffer = wCp;
            ustrp->Length = ustrp->MaximumLength = pustrDCNames[i].Length;
            RtlCopyMemory(ustrp->Buffer, pustrDCNames[i].Buffer, ustrp->Length);
            wCp += ustrp->Length / sizeof(WCHAR);
            if (!foundDc) {
                if ((ComputerNetbiosName.Length != 0) &&
                    (RtlCompareUnicodeString(&ComputerNetbiosName,
                                             &pustrDCNames[i],
                                             TRUE) == 0)) {
                    foundDc = TRUE;
                }
                else if ((ComputerDnsName.Length != 0) &&
                         (RtlCompareUnicodeString(&ComputerDnsName,
                                                  &pustrDCNames[i],
                                                  TRUE) == 0)) {
                    foundDc = TRUE;
                }
                if ((foundDc == TRUE) && (i != 0)) {
                    UNICODE_STRING Tmp;

                    Tmp = *ustrp;
                    *ustrp = pSpcArg->Name[0];
                    pSpcArg->Name[0] = Tmp;
                }
            }
        }

        POINTER_TO_OFFSET(pSpcArg->SpecialName.Buffer, pSpcArg);
        for (i = 0; i < NameCount; i++) {
            POINTER_TO_OFFSET(pSpcArg->Name[i].Buffer, pSpcArg);
        }

        *ppSpcArg = pSpcArg;
        *pSize = Size;

    } else {

        status = ERROR_NOT_ENOUGH_MEMORY;

    }

    if( ComputerDnsName.Buffer != NULL ) {

        free( ComputerDnsName.Buffer );
    }

    return status;

}

DWORD
DfsCreateSiteArg(
    LPWSTR ServerName,
    ULONG SiteCount,
    PUNICODE_STRING pustrSiteNames,
    PDFS_CREATE_SITE_INFO_ARG *ppSiteArg,
    PULONG pSize)
{
    ULONG i;
    ULONG Size;
    WCHAR *wCp;
    PUNICODE_STRING ustrp;
    PDFS_CREATE_SITE_INFO_ARG pSiteArg;
    DWORD status = STATUS_SUCCESS;


    DFSSVC_TRACE_NORM(DEFAULT, DfsCreateSiteArg_Entry,
                      LOGWSTR_CHK(ServerName)
                      LOGULONG(SiteCount)
                      LOGUSTR(*pustrSiteNames));
    // Size the buffer

    Size = FIELD_OFFSET(DFS_CREATE_SITE_INFO_ARG,SiteName[SiteCount]) +
                wcslen(ServerName) * sizeof(WCHAR);

    for (i = 0; i < SiteCount; i++)
        Size += pustrSiteNames[i].Length;

    pSiteArg = malloc(Size);

    if (pSiteArg != NULL) {

        // Marshall the info in

        pSiteArg->SiteCount = SiteCount;

        wCp = (WCHAR *) &pSiteArg->SiteName[SiteCount];

        ustrp = &pSiteArg->ServerName;
        ustrp->Buffer = wCp;
        ustrp->Length = ustrp->MaximumLength = wcslen(ServerName) * sizeof(WCHAR);
        RtlCopyMemory(ustrp->Buffer,ServerName,ustrp->Length);
        wCp += ustrp->Length / sizeof(WCHAR);

        for (i = 0; i < SiteCount; i++) {

            ustrp = &pSiteArg->SiteName[i];
            ustrp->Buffer = wCp;
            ustrp->Length = ustrp->MaximumLength = pustrSiteNames[i].Length;
            RtlCopyMemory(ustrp->Buffer,pustrSiteNames[i].Buffer,ustrp->Length);
            wCp += ustrp->Length / sizeof(WCHAR);

        }

        POINTER_TO_OFFSET(pSiteArg->ServerName.Buffer, pSiteArg);
        for (i = 0; i < SiteCount; i++) {
            POINTER_TO_OFFSET(pSiteArg->SiteName[i].Buffer, pSiteArg);
        }

        *ppSiteArg = pSiteArg;
        *pSize =  Size;

    } else {

        status = ERROR_NOT_ENOUGH_MEMORY;

    }

    DFSSVC_TRACE_NORM(DEFAULT, DfsCreateSiteArg_Exit, 
                      LOGSTATUS(status)
                      LOGWSTR_CHK(ServerName)
                      LOGULONG(SiteCount)
                      LOGUSTR(*pustrSiteNames));

    return status;

}

NTSTATUS
DfsDomainReferral(
    LPWSTR wszDomain,
    LPWSTR wszShare)
{
    NTSTATUS Status;
    DWORD dwErr;
    LPWSTR *List = NULL;
    PUNICODE_STRING pustr;
    HANDLE dfsHandle;
    IO_STATUS_BLOCK ioStatus;
    ULONG Count;
    ULONG Size;
    PDFS_CREATE_SPECIAL_INFO_ARG pSpcArg;
    ULONG i;

    DFSSVC_TRACE_HIGH(DEFAULT,DfsDomainReferral_Entry, 
                      LOGWSTR_CHK(wszDomain)
                      LOGWSTR_CHK(wszShare));
#if DBG
    if (DfsSvcVerbose) {
        DbgPrint("DfsDomainReferral()\n", 0);
        DbgPrint("\twszDomain:%ws\n", wszDomain);
        DbgPrint("\twszShare:%ws\n", wszShare);
    }
#endif

    dwErr = DfsGetFtServersFromDs(pLdap, wszDomain, wszShare, &List);

    if (dwErr != NO_ERROR || List == NULL) {

        Status = STATUS_OBJECT_NAME_NOT_FOUND;

    } else {

        for (Count = 0; List[Count]; Count++)
            /* NOTHING */;

        pustr = malloc(sizeof(UNICODE_STRING) * Count);

        if (pustr != NULL) {

            for (i = 0; i < Count; i++) {

                RtlInitUnicodeString(&pustr[i], List[i]);

                if (pustr[i].Buffer[0] == L'\\') {

                    pustr[i].Buffer++;
                    pustr[i].Length -= sizeof(WCHAR);
                    pustr[i].MaximumLength -= sizeof(WCHAR);

                }

            }

            Status = DfsCreateSpcArg(
                        wszShare,
                        60 * 15,                    // 15 min
                        DFS_SPECIAL_INFO_PRIMARY,
                        0,
                        0,
                        Count,
                        pustr,
                        &pSpcArg,
                        &Size);

            if (Status == ERROR_SUCCESS) {

                Status = DfsOpen(&dfsHandle, NULL);

                if (NT_SUCCESS(Status)) {

                    NtFsControlFile(
                            dfsHandle,
                            NULL,       // Event,
                            NULL,       // ApcRoutine,
                            NULL,       // ApcContext,
                            &ioStatus,
                            FSCTL_DFS_CREATE_FTDFS_INFO,
                            pSpcArg,
                            Size,
                            NULL,
                            0);

                    NtClose( dfsHandle);

                }

                //
                // Rummage through the DS, loading the site info for the
                // machines we found.
                //

                if (NT_SUCCESS(Status)) {

                    DfsLoadSiteTableFromDs(
                        pLdap,
                        wszShare,
                        Count,
                        pustr);

                }

                free(pSpcArg);

            }

            free(pustr);

        }

        NetApiBufferFree(List);

    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsDomainReferral exit 0x%x\n", Status);
#endif

    return Status;

}


BOOLEAN
DfsGetNextDomainName(
    LPWSTR DomName,
    ULONG Size)
{
    HANDLE dfsHandle;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS Status;

    Status = DfsOpen(&dfsHandle, NULL);

    if (NT_SUCCESS(Status)) {

        Status = NtFsControlFile(
				 dfsHandle,
				 NULL,       // Event,
				 NULL,       // ApcRoutine,
				 NULL,       // ApcContext,
				 &ioStatus,
				 FSCTL_DFS_GET_NEXT_LONG_DOMAIN_NAME,
				 NULL,
				 0,
				 DomName,
				 Size);

	NtClose( dfsHandle);
    }

    return (Status == STATUS_SUCCESS) ? TRUE : FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfssvc\dominfo.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       dominfo.h
//
//  Contents:   Code to figure out domain dfs addresses
//
//  Classes:    None
//
//  History:    Feb 7, 1996     Milans created
//
//-----------------------------------------------------------------------------

#ifndef _DOMINFO_
#define _DOMINFO_

typedef struct _DFS_TRUSTED_DOMAIN_INFO {
    UNICODE_STRING FlatName;
    UNICODE_STRING DnsName;
    ULONG TrustDirection;
    ULONG TrustType;
    ULONG TrustAttributes;
} DFS_TRUSTED_DOMAIN_INFO, *PDFS_TRUSTED_DOMAIN_INFO;

typedef struct _DFS_DOMAIN_INFO {
    ULONG cDomains;
    UNICODE_STRING ustrThisDomain;
    UNICODE_STRING ustrThisDomainFlat;
    PDFS_TRUSTED_DOMAIN_INFO rgustrDomains;
    ULONG cbNameBuffer;
    PWSTR wszNameBuffer;
} DFS_DOMAIN_INFO, *PDFS_DOMAIN_INFO;

VOID
DfsInitDomainList();

DWORD
DfspIsThisADomainName(
    LPWSTR wszName);

#endif // _DOMINFO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfssvc\dfslpc.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  File:       dfslpc.c
//
//  Contents:   Code implement lpc server for dfs.sys
//
//  Classes:
//
//  Functions:
//
//  History:    18 Dec 97       Jharper created (from XACT stuff)
//
//-----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <dfsfsctl.h>
#include <windows.h>
#include <stdlib.h>
#include <lm.h>
#include <winsock2.h>
#include <dsgetdc.h>

#include <dfssrv.h>
#include <dsrole.h>
#include "dfsipc.h"

extern WCHAR DomainName[MAX_PATH];
extern DSROLE_MACHINE_ROLE DfsMachineRole;

//
// Event logging and debugging globals
//
extern ULONG DfsSvcVerbose;
extern ULONG DfsEventLog;

//
// Number of worker threads.
//

LONG DfsThreads = 0;

//
// Event signalled when the last worker thread terminates.
//

HANDLE DfsAllThreadsTerminatedEvent = NULL;

//
// Boolean indicating whether server is active or terminating.
//

BOOL DfsTerminating = FALSE;

//
// Handle for the LPC port used for communication between the dfs driver
// and server
//

HANDLE DfsConnectionPortHandle = NULL;
HANDLE DfsCommunicationPortHandle = NULL;

//
// Handle for communicating with the dfs driver
//
HANDLE serverHandle = NULL;

//
//  This is the number of threads blocked waiting for an LPC request.
//  When it drops to zero, all threads are active and another thread is
//  created.
//

LONG DfsWaitingApiThreads = 0;

VOID
DfsProcessApisWrapper (
    DWORD ThreadNum
    );

VOID
DfsProcessApis (
    DWORD ThreadNum
    );

VOID
DfsLoadIpCache(
    PDFS_IPADDRESS pIpAddress,
    LPWSTR SiteName
    );

NTSTATUS
AddrToSite(
    PDFS_IPADDRESS IpAddress,
    LPWSTR **pppSiteName
    );

//
// Flags used in DsGetDcName()
//

DWORD dwFlags[] = {
        DS_DIRECTORY_SERVICE_REQUIRED |
            DS_IP_REQUIRED,

        DS_DIRECTORY_SERVICE_REQUIRED |
            DS_IP_REQUIRED |
            DS_FORCE_REDISCOVERY
     };

DWORD
DfsStartDfssrv (
    VOID)
{
    NTSTATUS status;
    DWORD error;
    DWORD i;
    HANDLE threadHandle;
    DWORD threadId;
    HANDLE eventHandle;
    UNICODE_STRING unicodeName;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    PORT_MESSAGE connectionRequest;
    BOOL waitForEvent;
    PCHAR bp;
    ULONG size;
    PUNICODE_STRING pustr;
    UNICODE_STRING DfsDriverName;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsStartDfssrv()\n", 0);
#endif

    // Sleep(60*1000);

    // lpc_debug_trace("DfsStartDfssrv done sleeping...\n", 0);

    //
    // Set up variables so that we'll know how to shut down in case of
    // an error.
    //

    serverHandle = NULL;
    eventHandle = NULL;
    DfsAllThreadsTerminatedEvent = NULL;
    waitForEvent = FALSE;

    //
    // Create a event that will be set by the last thread to exit.
    //

    status = NtCreateEvent(
                 &DfsAllThreadsTerminatedEvent,
                 EVENT_ALL_ACCESS,
                 NULL,
                 NotificationEvent,
                 FALSE
                 );

    if ( !NT_SUCCESS(status) ) {
        DfsAllThreadsTerminatedEvent = NULL;
        goto exit;
    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("created event\n", 0);
#endif

    //
    // Open the server device.  Note that we need this handle because
    // the handle used by the main server service is synchronous.  We
    // need to to do the DFS_CONNECT FSCTL asynchronously.
    //

    RtlInitUnicodeString( &unicodeName, DFS_SERVER_NAME );

    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenFile(
                 &serverHandle,
                 FILE_READ_DATA | FILE_WRITE_DATA,            // DesiredAccess
                 &objectAttributes,
                 &ioStatusBlock,
                 0L,                        // ShareAccess
                 0L                         // OpenOptions
                 );

    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }
    if ( !NT_SUCCESS(status) ) {
        goto exit;
    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("opened device\n", 0);
#endif

    //
    // Create the LPC port.
    //
    //     Right now this only tries a single port name.  If, for some
    //     bizarre reason, somebody already has a port by this name,
    //     then this will fail.  It might make sense to try different
    //     names if this fails.
    //

    RtlInitUnicodeString( &unicodeName, DFS_PORT_NAME_W );

    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeName,
        0,
        NULL,
        NULL
        );

    status = NtCreatePort(
                 &DfsConnectionPortHandle,
                 &objectAttributes,
                 0,
                 DFS_PORT_MAX_MESSAGE_LENGTH,
                 DFS_PORT_MAX_MESSAGE_LENGTH * 32
                 );

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NtCreatePort status=0x%x\n", status);
#endif

    if ( ! NT_SUCCESS(status) ) {
        DfsConnectionPortHandle = NULL;
        goto exit;
    }

    //
    // Set up an event so that we'll know when IO completes, then send
    // the FSCTL to the server indicating that it should now connect to
    // us.  We'll set up the port while the IO is outstanding, then wait
    // on the event when the port setup is complete.
    //

    status = NtCreateEvent(
                 &eventHandle,
                 EVENT_ALL_ACCESS,
                 NULL,                           // ObjectAttributes
                 NotificationEvent,
                 FALSE
                 );

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NtCreateEvent status=0x%x\n", status);
#endif

    if ( !NT_SUCCESS(status) ) {
        goto exit;
    }

    size = sizeof(UNICODE_STRING) + unicodeName.Length + sizeof(WCHAR);

    pustr = (UNICODE_STRING *)(bp = malloc(size));

    if (pustr == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    RtlZeroMemory(bp, size);

    pustr->Length = unicodeName.Length;
    pustr->MaximumLength = unicodeName.Length + sizeof(WCHAR);
    pustr->Buffer = (WCHAR *)(bp + sizeof(UNICODE_STRING));
    RtlCopyMemory(pustr->Buffer, unicodeName.Buffer, unicodeName.Length);
    pustr->Buffer = (WCHAR *)sizeof(UNICODE_STRING);

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("Calling NtFsControlFile(FSCTL_SRV_DFSSRV_CONNECT)\n", status);
#endif

    status = NtFsControlFile(
                 serverHandle,
                 eventHandle,
                 NULL,                           // ApcRoutine
                 NULL,                           // ApcContext
                 &ioStatusBlock,
                 FSCTL_SRV_DFSSRV_CONNECT,
                 bp,
                 size,
                 NULL,                           // OutputBuffer
                 0L                              // OutputBufferLength
                 );

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NtFsControlFile status=0x%x\n", status);
#endif

    free(pustr);

    if ( !NT_SUCCESS(status) ) {
        goto exit;
    }

    waitForEvent = TRUE;

    //
    // Start listening for the server's connection to the port.  Note
    // that it is OK if the server happens to call NtConnectPort
    // first--it will simply block until this call to NtListenPort
    // occurs.
    //

    connectionRequest.u1.s1.TotalLength = sizeof(connectionRequest);
    connectionRequest.u1.s1.DataLength = (CSHORT)0;
    status = NtListenPort(
                 DfsConnectionPortHandle,
                 &connectionRequest
                 );

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NtListenPort status=0x%x\n", status);
#endif

    if ( !NT_SUCCESS(status) ) {
        goto exit;
    }

    //
    // The server has initiated the connection.  Accept the connection.
    //

    status = NtAcceptConnectPort(
                 &DfsCommunicationPortHandle,
                 NULL,                           // PortContext
                 &connectionRequest,
                 TRUE,                           // AcceptConnection
                 NULL,                           // ServerView
                 NULL                            // ClientView
                 );

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NtAcceptConnectPort status=0x%x\n", status);
#endif

    if ( !NT_SUCCESS(status) ) {
       DfsCommunicationPortHandle = NULL;
       goto exit;
    }

    //
    // Complete the connection to the port, thereby releasing the server
    // thread waiting in NtConnectPort.
    //

    status = NtCompleteConnectPort( DfsCommunicationPortHandle );

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("NtCompleteConnectPort status=0x%x\n", status);
#endif

    if ( !NT_SUCCESS(status) ) {
       goto exit;
    }

    status = STATUS_SUCCESS;

exit:

    //
    // Wait for the IO to complete, then close the event handle.
    //

    if ( waitForEvent ) {

        NTSTATUS waitStatus;

        waitStatus = NtWaitForSingleObject( eventHandle, FALSE, NULL );

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("NtWaitForSingleObject status=0x%x\n", waitStatus);
#endif

        if ( !NT_SUCCESS(waitStatus) ) {

            //
            // If another error has already occurred, don't report this
            // one.
            //

            if ( NT_SUCCESS(status) ) {
                status = waitStatus;
            }
        }

        //
        // Check the status in the IO status block.  If it is bad, then
        // there was some problem on the server side of the port setup.
        //

        if ( !NT_SUCCESS(ioStatusBlock.Status) ) {
            //
            // If another error has already occurred, don't report this
            // one.
            //

            if ( NT_SUCCESS(status) ) {
                status = ioStatusBlock.Status;
            }

        }

    }


    if (eventHandle != NULL) {

        CloseHandle( eventHandle );

    }

    //
    // If the above failed, return to caller now.
    //

    if ( !NT_SUCCESS(status) ) {
#if DBG
        if (DfsSvcVerbose)
            DbgPrint("DfsStartDfsSrv exit 0x%x\n", status);
#endif
        return RtlNtStatusToDosError( status );
    }

    //
    // Start one API processing thread.  It will spawn others if needed
    //

    DfsThreads = 1;

    DfsProcessApisWrapper(DfsThreads);

    //
    // Initialization succeeded.
    //

    return NO_ERROR;

}

VOID
DfsProcessApisWrapper (
    DWORD ThreadNum)
{
    DFSSRV_REQUEST_MESSAGE requestMessage;

    //
    //  Increase the priority of this thread to just above foreground
    //

    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL );

    //
    // Do the APIs
    //

    DfsProcessApis( ThreadNum );

    //
    // Decrement the count of threads.  If the count goes to
    // zero, set the All Threads Terminated event.
    //

    if (InterlockedDecrement(&DfsThreads ) == 0 ) {

        SetEvent( DfsAllThreadsTerminatedEvent );

    } else if (DfsTerminating ) {

        //
        // There are still threads left, and we are trying to terminate.  Queue
        //  another message to the queue so the next thread will get it and
        //  notice that we're trying to quit.
        //
        RtlZeroMemory( &requestMessage, sizeof( requestMessage ));
        requestMessage.PortMessage.u1.s1.DataLength =
            (USHORT)( sizeof(requestMessage) - sizeof(PORT_MESSAGE) );
        requestMessage.PortMessage.u1.s1.TotalLength = sizeof(requestMessage);
        requestMessage.MessageType = DFSSRV_MESSAGE_WAKEUP;

        NtRequestPort(
            DfsConnectionPortHandle,
            (PPORT_MESSAGE)&requestMessage
            );
    }

    ExitThread( NO_ERROR );

}

/*
 * This routine is called to stop the transaction processor once the
 * server driver has terminated.
 */
VOID
DfsStopDfssrv (
    VOID)
{
    NTSTATUS status;
    static DFSSRV_REQUEST_MESSAGE requestMessage;
    LONG i;

    //
    // Stop all the worker threads, and release resources
    //

    if ( DfsConnectionPortHandle != NULL ) {

        //
        // Indicate that server is terminating.
        //
        DfsTerminating = TRUE;

        //
        // Queue a message to kill off the worker thereads
        //
        RtlZeroMemory( &requestMessage, sizeof( requestMessage ));
        requestMessage.PortMessage.u1.s1.DataLength =
            (USHORT)( sizeof(requestMessage) - sizeof(PORT_MESSAGE) );
        requestMessage.PortMessage.u1.s1.TotalLength = sizeof(requestMessage);
        requestMessage.MessageType = DFSSRV_MESSAGE_WAKEUP;
        
        status = NtRequestPort(
                    DfsConnectionPortHandle,
                    (PPORT_MESSAGE)&requestMessage
                    );

        //
        // The above will cause all worker threads to wake up then die.
        //

        if ( DfsThreads != 0 ) {
            BOOL ok;
            ok = WaitForSingleObject( DfsAllThreadsTerminatedEvent, (DWORD)-1 );
        }

        CloseHandle( DfsConnectionPortHandle );
    }

    if( DfsCommunicationPortHandle != NULL ) {
        CloseHandle( DfsCommunicationPortHandle );
        DfsCommunicationPortHandle = NULL;
    }

    //
    // Close the termination event.
    //

    if ( DfsAllThreadsTerminatedEvent != NULL ) {
        CloseHandle( DfsAllThreadsTerminatedEvent );
        DfsAllThreadsTerminatedEvent = NULL;
    }

    //
    // Close handle to driver
    //

    if ( serverHandle != NULL ) {
       CloseHandle( serverHandle );
    }

    return;

}

NTSTATUS ReplyFailedStatus;
#define MAX_RETRY_REPLY 10

VOID
DfsProcessApis (
    DWORD ThreadNum)
{
    NTSTATUS status;
    DFSSRV_REQUEST_MESSAGE request;
    DFSSRV_REPLY_MESSAGE reply;
    BOOL sendReply = FALSE;
    WORD apiNumber;
    LPWSTR *SiteNames;
    ULONG RetryReplyCount = 0;

    RtlZeroMemory(&request, sizeof(DFSSRV_REQUEST_MESSAGE));

    //
    // Loop dispatching API requests.
    //
    while ( DfsTerminating == FALSE ) {

        //
        // We're waiting to handle another API...
        //
        InterlockedIncrement( &DfsWaitingApiThreads );

        //
        // Send the reply to the last message and wait for the next
        // message.  The first time through the loop, there will be
        // no last message -- reply will be NULL.
        //

        status = NtReplyWaitReceivePort(
                     DfsCommunicationPortHandle,
                     NULL,                       // PortContext
                     sendReply ? (PPORT_MESSAGE)&reply : NULL,
                     (PPORT_MESSAGE)&request
                     );


	if ( status == STATUS_INVALID_PORT_HANDLE
                 || status == STATUS_PORT_DISCONNECTED
                 || status == STATUS_INVALID_HANDLE
                 || DfsTerminating
                 || request.PortMessage.u2.s2.Type == LPC_PORT_CLOSED ) {

            //
            // The port is no longer valid, or DFSSRV is terminating.
            //

            InterlockedDecrement( &DfsWaitingApiThreads );
            return;

        } else if (request.PortMessage.u2.s2.Type == LPC_CONNECTION_REQUEST) {

            sendReply = FALSE;
            continue;

        } else if ( !NT_SUCCESS(status) ) {
	    //
	    // Attempt to handle error returns from reply wait receive.
	    //
	    if ((status == STATUS_UNSUCCESSFUL) || 
		(status == STATUS_USER_APC)) {
		sendReply = FALSE;
	    } else if ((status == STATUS_INVALID_PARAMETER) ||
		       (status == STATUS_PORT_MESSAGE_TOO_LONG) ||
		       (status == STATUS_REPLY_MESSAGE_MISMATCH)) {
		sendReply = FALSE;

	    } else if (RetryReplyCount++ > MAX_RETRY_REPLY) {
		sendReply = FALSE;
		ReplyFailedStatus = status;
	    }

	    continue;
        }

	RetryReplyCount = 0;
        sendReply = TRUE;

        //
        // Set up the response message to be sent on the next call to
        // NtReplyWaitReceivePort.
        //
        reply.PortMessage.u1.s1.DataLength =
            sizeof(reply) - sizeof(PORT_MESSAGE);
        reply.PortMessage.u1.s1.TotalLength = sizeof(reply);
        reply.PortMessage.u2.ZeroInit = 0;
        reply.PortMessage.ClientId = request.PortMessage.ClientId;
        reply.PortMessage.MessageId = request.PortMessage.MessageId;


        if( InterlockedDecrement( &DfsWaitingApiThreads ) == 0 ) {

            HANDLE threadHandle;
            DWORD  threadId;

            //
            // Are there other threads ready to handle new requests?  If not, then
            // we should spawn a new thread.
            //

            InterlockedIncrement( &DfsThreads );

            threadHandle = CreateThread(
                                NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)DfsProcessApisWrapper,
                                (LPVOID)ULongToPtr( DfsThreads ),
                                0,
                                &threadId
                                );

            if ( threadHandle != 0 ) {

                CloseHandle( threadHandle );

            } else {

                InterlockedDecrement( &DfsThreads );
            }
        }

        switch ( request.MessageType ) {

        case DFSSRV_MESSAGE_GET_SITE_NAME:
        {
            ULONG IpAddress = *((ULONG *) &request.Message.GetSiteName.IpAddress.IpData);

#if DBG
            if (DfsSvcVerbose)
                DbgPrint("Asking for SiteName for %d.%d.%d.%d\n",
                                    IpAddress & 0xff,
                                    (IpAddress >> 8) & 0xff,
                                    (IpAddress >> 16) & 0xff,
                                    (IpAddress >> 24) & 0xff);
#endif

            SiteNames = NULL;

#define _Dfs_LocalAddress 0x0100007f

            if ((request.Message.GetSiteName.IpAddress.IpLen == 4) &&
                (IpAddress == _Dfs_LocalAddress)) {
                LPWSTR SiteName;

                status = DsGetSiteName( NULL,
                                     &SiteName );
                if (status == NO_ERROR) {
                    DfsLoadIpCache(&request.Message.GetSiteName.IpAddress, SiteName);
                    NetApiBufferFree(SiteName);
                }
            }
            else {
                status = AddrToSite(
                    &request.Message.GetSiteName.IpAddress,
                    &SiteNames);

                if (status == NO_ERROR) {

                    if (SiteNames != NULL && SiteNames[0] != NULL) {

                        DfsLoadIpCache(&request.Message.GetSiteName.IpAddress, SiteNames[0]);

                    }

                    if (SiteNames != NULL) {

                        NetApiBufferFree(SiteNames);
                    }
                }
            }

            reply.Message.Result.Status = status;

            break;
        }

        case DFSSRV_MESSAGE_GET_DOMAIN_REFERRAL:
        {
            LPWSTR FtName = request.Message.GetFtDfs.FtName;

#if DBG
            if (DfsSvcVerbose)
                DbgPrint("Asking for DOMAIN REFERRAL for %ws\n", FtName);
#endif

            status = DfsDomainReferral(
                            DomainName,
                            FtName);

            reply.Message.Result.Status = status;

            break;
        }

        case DFSSRV_MESSAGE_GET_SPC_ENTRY:
        {
            LPWSTR SpcName = request.Message.GetSpcName.SpcName;
            ULONG Flags = request.Message.GetSpcName.Flags;

#if DBG
            if (DfsSvcVerbose)
                DbgPrint("Asking for SPC EXPANSION for %ws\n", SpcName);
#endif

            status = DfsGetTrustedDomainDCs(
                            SpcName,
                            Flags);

            reply.Message.Result.Status = status;

            break;
        }

        default:
            /* NOTHING */;

        }

   }

}

VOID
DfsLoadIpCache(
    PDFS_IPADDRESS pIpAddress,
    LPWSTR SiteName)
{
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    PDFS_CREATE_IP_INFO_ARG pInfoArg;
    ULONG size;

    size  = sizeof(DFS_CREATE_IP_INFO_ARG) + wcslen(SiteName) * sizeof(WCHAR);
    pInfoArg = malloc(size);

    if (pInfoArg != NULL) {

        RtlZeroMemory(pInfoArg, size);

        pInfoArg->SiteName.Buffer = (LPWSTR)&pInfoArg[1];
        pInfoArg->SiteName.Length = wcslen(SiteName) * sizeof(WCHAR);
        pInfoArg->SiteName.MaximumLength = pInfoArg->SiteName.Length;
        RtlCopyMemory(pInfoArg->SiteName.Buffer,SiteName,pInfoArg->SiteName.Length);

        pInfoArg->SiteName.Buffer = (LPWSTR)sizeof(DFS_CREATE_IP_INFO_ARG);

        pInfoArg->IpAddress = *pIpAddress;

        NtStatus = NtFsControlFile(
                       serverHandle,
                       NULL,       // Event,
                       NULL,       // ApcRoutine,
                       NULL,       // ApcContext,
                       &IoStatusBlock,
                       FSCTL_DFS_CREATE_IP_INFO,
                       pInfoArg,
                       size,
                       NULL,
                       0
                   );

        free(pInfoArg);

    }

}


NTSTATUS
AddrToSite(
    PDFS_IPADDRESS IpAddress,
    LPWSTR **pppSiteName)
{
    DWORD dwErr;
    PSOCKET_ADDRESS pSockAddr;
    SOCKET_ADDRESS SockAddr;
    PSOCKADDR_IN pSockAddrIn;
    SOCKADDR_IN SockAddrIn;
    WCHAR **SiteNames;
    DWORD cRetry;
    PDOMAIN_CONTROLLER_INFO pDCInfo;


    pSockAddr = &SockAddr;
    pSockAddr->iSockaddrLength = sizeof(SOCKADDR_IN);
    pSockAddr->lpSockaddr = (LPSOCKADDR)&SockAddrIn;
    pSockAddrIn = &SockAddrIn;
    pSockAddrIn->sin_family = IpAddress->IpFamily;
    pSockAddrIn->sin_port = 0;
    RtlCopyMemory(
                    &pSockAddrIn->sin_addr,
                    IpAddress->IpData,
                    (IpAddress->IpLen & 0xff));

    if (DfsMachineRole == DsRole_RoleBackupDomainController
            ||
        DfsMachineRole == DsRole_RolePrimaryDomainController) {

        dwErr = DsAddressToSiteNames(
                NULL,
                1,
                pSockAddr,
                pppSiteName);

        goto exit;

    }

    //
    // Call DsGetDcName() with ever-increasing urgency, until either
    // we get a good DC or we just give up.
    //

    for (cRetry = 0; cRetry < (sizeof(dwFlags) / sizeof(dwFlags[1])); cRetry++) {

        dwErr = DsGetDcName(
                    NULL,                            // Computer to remote to
                    NULL,                            // Domain - use local domain
                    NULL,                            // Domain Guid
                    NULL,                            // Site Guid
                    dwFlags[cRetry],                 // Flags
                    &pDCInfo);

        if (dwErr == ERROR_SUCCESS) {

            dwErr = DsAddressToSiteNames(
                    pDCInfo->DomainControllerAddress,
                    1,
                    pSockAddr,
                    pppSiteName);

            NetApiBufferFree( pDCInfo );

            if (dwErr == ERROR_SUCCESS) {

                goto exit;

            }

        }

    }

exit:

    return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfssvc\dominfo.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       dominfo.h
//
//  Contents:   Code to figure out domain dfs addresses
//
//  Classes:    None
//
//  Functions:  DfsInitDomainList
//
//              DfspInitDomainListFromLSA
//              DfspInsertLsaDomainList
//
//  History:    Feb 7, 1996     Milans created
//
//-----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>                               // LsaEnumerateTrustedDomains
#include <dfsfsctl.h>
#include <tdi.h>
#include <gluon.h>
#include <windows.h>

#include <lm.h>                                  // NetGetAnyDC, NetUseAdd
#include <netlogon.h>                            // Needed by logonp.h
#include <logonp.h>                              // I_NetGetDCList

#include <dfsstr.h>
#include <nodetype.h>
#include <libsup.h>
#include <dfsmrshl.h>
#include <dfsgluon.h>

#include "dominfo.h"
#include "svcwml.h"

extern DWORD
DfsCreateSpcArg(
    LPWSTR DomainName,
    ULONG Timeout,
    ULONG Flags,
    ULONG TrustDirection,
    ULONG TrustType,
    LONG NameCount,
    PUNICODE_STRING pustrDCNames,
    PDFS_CREATE_SPECIAL_INFO_ARG *ppSpcArg,
    PULONG pSize);

//
// Global structure describing list of trusted domains
//

DFS_DOMAIN_INFO DfsDomainInfo;
BOOLEAN DfsDomainInfoInit = FALSE;

extern WCHAR DomainName[MAX_PATH];
extern WCHAR DomainNameDns[MAX_PATH];
extern CRITICAL_SECTION DomListCritSection;

//
// Event logging and debugging globals
//
extern ULONG DfsSvcVerbose;
extern ULONG DfsEventLog;

//
// Private functions
//

DWORD
DfspInitDomainListFromLSA();

NTSTATUS
DfspInsertLsaDomainList(
    PTRUSTED_DOMAIN_INFORMATION_EX rglsaDomainList,
    ULONG cDomains);

NTSTATUS
DfspInsertDsDomainList(
    PDS_DOMAIN_TRUSTS pDsDomainTrusts,
    ULONG cDomains);

BOOLEAN
IsDupDomainInfo(
    PDS_DOMAIN_TRUSTS pDsDomainTrusts);


//+----------------------------------------------------------------------------
//
//  Function:   DfsInitDomainList
//
//  Synopsis:   Initializes the list of trusted domains so that their Dfs's
//              may be accessed.
//
//  Arguments:  None
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

VOID
DfsInitDomainList()
{
    PDS_DOMAIN_TRUSTS pDsDomainTrusts = NULL;
    ULONG DsDomainCount = 0;
    DWORD dwErr;
    DFS_DOMAIN_INFO OldDfsDomainInfo;
    ULONG i, j;
    HANDLE dfsHandle;
    NTSTATUS status;
    PDFS_CREATE_SPECIAL_INFO_ARG pSpcArg;
    ULONG Size;
    IO_STATUS_BLOCK ioStatus;

    EnterCriticalSection(&DomListCritSection);

    if (DfsDomainInfoInit == FALSE) {

        ZeroMemory( &DfsDomainInfo, sizeof(DfsDomainInfo) );
        ZeroMemory( &OldDfsDomainInfo, sizeof(DfsDomainInfo) );

    } else {

        OldDfsDomainInfo = DfsDomainInfo;
        ZeroMemory( &DfsDomainInfo, sizeof(DfsDomainInfo) );

    }

    //
    // Handle our domain name
    //

    RtlInitUnicodeString(&DfsDomainInfo.ustrThisDomainFlat, DomainName);
    RtlInitUnicodeString(&DfsDomainInfo.ustrThisDomain, DomainNameDns);

    //
    // And the trusted domains
    //

    DfspInitDomainListFromLSA();

    //
    // Use Ds for another list
    //
    dwErr = DsEnumerateDomainTrusts(
                NULL,
                DS_DOMAIN_VALID_FLAGS,
                &pDsDomainTrusts,
                &DsDomainCount);

    if (dwErr == ERROR_SUCCESS) {

        //
        // Merge that list in
        //
        DfspInsertDsDomainList(
            pDsDomainTrusts,
            DsDomainCount);

        NetApiBufferFree(pDsDomainTrusts);

    }


#if DBG
    if (DfsSvcVerbose) {
        ULONG i;

        for (i = 0; i < DfsDomainInfo.cDomains; i++) {
            DbgPrint("%d:[%wZ:%wZ]\n", 
                    i,
                    &DfsDomainInfo.rgustrDomains[i].FlatName,
                    &DfsDomainInfo.rgustrDomains[i].DnsName);
        }
    }
#endif

    if (dwErr == ERROR_SUCCESS) {    
       for (i = 0; i < OldDfsDomainInfo.cDomains; i++) {
           for (j = 0; j < DfsDomainInfo.cDomains; j++) {
               if ((RtlCompareUnicodeString(
                           &OldDfsDomainInfo.rgustrDomains[i].FlatName,
                           &DfsDomainInfo.rgustrDomains[j].FlatName,
                           TRUE) == 0) ||
                   (RtlCompareUnicodeString(
                           &OldDfsDomainInfo.rgustrDomains[i].DnsName,
                           &DfsDomainInfo.rgustrDomains[j].DnsName,
                           TRUE) == 0)) {
                   break;
               }
           }
           if (j == DfsDomainInfo.cDomains) {
   
               status = DfsOpen(&dfsHandle, NULL);
               if (NT_SUCCESS(status)) {

                   status = DfsCreateSpcArg(
                                OldDfsDomainInfo.rgustrDomains[i].FlatName.Buffer,
                                0,
                                DFS_SPECIAL_INFO_NETBIOS,
                                TRUST_DIRECTION_BIDIRECTIONAL,
                                TRUST_TYPE_UPLEVEL,
                                0,
                                NULL,
                                &pSpcArg,
                                &Size);

                   if (status == ERROR_SUCCESS) {
                       status = NtFsControlFile(
                                   dfsHandle,
                                   NULL,       // Event,
                                   NULL,       // ApcRoutine,
                                   NULL,       // ApcContext,
                                   &ioStatus,
                                   FSCTL_DFS_DELETE_SPECIAL_INFO,
                                   pSpcArg,
                                   Size,
                                   NULL,
                                   0);
   
                        free(pSpcArg);
                   }

                   status = DfsCreateSpcArg(
                                OldDfsDomainInfo.rgustrDomains[i].DnsName.Buffer,
                                0,
                                0,
                                TRUST_DIRECTION_BIDIRECTIONAL,
                                TRUST_TYPE_UPLEVEL,
                                0,
                                NULL,
                                &pSpcArg,
                                &Size);

                   if (status == ERROR_SUCCESS) {
                       status = NtFsControlFile(
                                   dfsHandle,
                                   NULL,       // Event,
                                   NULL,       // ApcRoutine,
                                   NULL,       // ApcContext,
                                   &ioStatus,
                                   FSCTL_DFS_DELETE_SPECIAL_INFO,
                                   pSpcArg,
                                   Size,
                                   NULL,
                                   0);
                       free(pSpcArg);
                   }
                   NtClose(dfsHandle);
	       }
	   }
       }
       if (OldDfsDomainInfo.rgustrDomains)
           free(OldDfsDomainInfo.rgustrDomains);
       if (OldDfsDomainInfo.wszNameBuffer)
           free(OldDfsDomainInfo.wszNameBuffer);
    }

    DfsDomainInfoInit = TRUE;

    LeaveCriticalSection(&DomListCritSection);
}


//+----------------------------------------------------------------------------
//
//  Function:   DfspInitDomainListFromLSA
//
//  Synopsis:   Retrieves the list of trusted domains from the LSA.
//
//  Arguments:  None
//
//  Returns:    [ERROR_SUCCESS] -- Successfully inited list.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Out of memory condition
//
//-----------------------------------------------------------------------------

DWORD
DfspInitDomainListFromLSA()
{
    DWORD dwErr;
    NTSTATUS status;
    ULONG cEnum;
    OBJECT_ATTRIBUTES oa;
    LSA_HANDLE hlsa = NULL;
    LSA_ENUMERATION_HANDLE hEnum = (LSA_ENUMERATION_HANDLE)0;
    PTRUSTED_DOMAIN_INFORMATION_EX rglsaDomainInfo = NULL;

    ZeroMemory( &oa, sizeof(OBJECT_ATTRIBUTES) );

    status = LsaOpenPolicy(
                NULL,                            // SystemName
                &oa,                             // LSA Object Attributes
                POLICY_VIEW_LOCAL_INFORMATION,   // Desired Access
                &hlsa);

    if (NT_SUCCESS(status)) {

        do {

            cEnum = 0;
            status = LsaEnumerateTrustedDomainsEx(
                        hlsa,
                        &hEnum,
                        (PVOID) &rglsaDomainInfo,
                        LSA_MAXIMUM_ENUMERATION_LENGTH,
                        &cEnum);

            if (
                NT_SUCCESS(status)
                    ||
                (status == STATUS_NO_MORE_ENTRIES && cEnum > 0 && rglsaDomainInfo != NULL)
            ) {

                status = DfspInsertLsaDomainList(
                            rglsaDomainInfo,
                            cEnum);

            }
            if (rglsaDomainInfo != NULL) {
                LsaFreeMemory(rglsaDomainInfo);
                rglsaDomainInfo = NULL;
            }

        } while (status == STATUS_SUCCESS);

    }

    switch (status) {
    case STATUS_SUCCESS:
    case STATUS_NO_MORE_ENTRIES:
        dwErr = ERROR_SUCCESS;
        break;

    case STATUS_INSUFFICIENT_RESOURCES:
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        break;

    default:
        dwErr = ERROR_UNEXP_NET_ERR;
        break;

    }

    if (hlsa != NULL) {
        LsaClose(hlsa);
    }

    return( dwErr );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfspInsertLsaDomainList
//
//  Synopsis:   Helper function to insert a part of the trusted domain list
//              into the DfsDomainInfo.
//
//  Arguments:  [rglsaDomainList] -- Array of LSA_TRUST_INFORMATIONs.
//              [cDomains] -- Number of elements in rglsaDomainList
//
//  Returns:    [STATUS_SUCCESS] -- Successfully appended domain list to
//                      DfsDomainInfo.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Unable to allocate memory
//                      for new list.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspInsertLsaDomainList(
    PTRUSTED_DOMAIN_INFORMATION_EX rglsaDomainList,
    ULONG cDomains)
{
    PDFS_TRUSTED_DOMAIN_INFO rgustrDomains = NULL;
    PWSTR wszNameBuffer = NULL, pwch;
    ULONG cTotalDomains, cbNameBuffer, i, j;

    DFSSVC_TRACE_NORM(DEFAULT, DfspInsertLsaDomainList_Entry,
                      LOGPTR(rglsaDomainList)
                      LOGULONG(cDomains));
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfspInsertLsaDomainList(%d)\n", cDomains);
#endif

    cTotalDomains = DfsDomainInfo.cDomains + cDomains;

    cbNameBuffer = DfsDomainInfo.cbNameBuffer;

    for (i = 0; i < cDomains; i++) {

        cbNameBuffer += rglsaDomainList[i].Name.Length
                            + sizeof(UNICODE_NULL) +
                                rglsaDomainList[i].FlatName.Length +
                                    sizeof(UNICODE_NULL);

    }

    wszNameBuffer = (PWSTR) malloc( cbNameBuffer );

    if (wszNameBuffer == NULL) {

        return( STATUS_INSUFFICIENT_RESOURCES );

    }

    rgustrDomains = (PDFS_TRUSTED_DOMAIN_INFO) malloc(
                        cTotalDomains * sizeof(DFS_TRUSTED_DOMAIN_INFO));

    if (rgustrDomains == NULL) {

        free( wszNameBuffer );

        return( STATUS_INSUFFICIENT_RESOURCES );

    }

    //
    // Copy over the existing DfsDomainInfo
    //

    if (DfsDomainInfo.cDomains != 0) {

        CopyMemory(
            wszNameBuffer,
            DfsDomainInfo.wszNameBuffer,
            DfsDomainInfo.cbNameBuffer);

        CopyMemory(
            rgustrDomains,
            DfsDomainInfo.rgustrDomains,
            DfsDomainInfo.cDomains * sizeof(DFS_TRUSTED_DOMAIN_INFO));

    }

    for (i = 0; i < DfsDomainInfo.cDomains; i++) {

        rgustrDomains[i].FlatName.Buffer = (WCHAR *)((PCHAR)wszNameBuffer +
            ((PCHAR)DfsDomainInfo.rgustrDomains[i].FlatName.Buffer - (PCHAR)DfsDomainInfo.wszNameBuffer));

        rgustrDomains[i].DnsName.Buffer = (WCHAR *)((PCHAR)wszNameBuffer +
            ((PCHAR)DfsDomainInfo.rgustrDomains[i].DnsName.Buffer - (PCHAR)DfsDomainInfo.wszNameBuffer));

    }

    //
    // Now copy in the new
    //

    pwch = (PWSTR) (((PCHAR) wszNameBuffer) + DfsDomainInfo.cbNameBuffer);

    for (j = 0, i = DfsDomainInfo.cDomains; j < cDomains; j++, i++) {

        //
        // Dns name
        //

        CopyMemory(
            pwch,
            rglsaDomainList[j].Name.Buffer,
            rglsaDomainList[j].Name.Length);

        pwch[ rglsaDomainList[j].Name.Length / sizeof(WCHAR) ] = UNICODE_NULL;

        RtlInitUnicodeString( &rgustrDomains[i].DnsName, pwch);

        pwch += (rglsaDomainList[j].Name.Length / sizeof(WCHAR) + 1);

        //
        // FlatName (Netbios)
        //

        CopyMemory(
            pwch,
            rglsaDomainList[j].FlatName.Buffer,
            rglsaDomainList[j].FlatName.Length);

        pwch[ rglsaDomainList[j].FlatName.Length / sizeof(WCHAR) ] = UNICODE_NULL;

        RtlInitUnicodeString( &rgustrDomains[i].FlatName, pwch);

        pwch += (rglsaDomainList[j].FlatName.Length / sizeof(WCHAR) + 1);

        rgustrDomains[i].TrustDirection = rglsaDomainList[j].TrustDirection;
        rgustrDomains[i].TrustType = rglsaDomainList[j].TrustType;
        rgustrDomains[i].TrustAttributes = rglsaDomainList[j].TrustAttributes;


    }

    if (DfsDomainInfo.wszNameBuffer != NULL)
        free(DfsDomainInfo.wszNameBuffer);
    if (DfsDomainInfo.rgustrDomains != NULL)
        free( DfsDomainInfo.rgustrDomains );

    DfsDomainInfo.cDomains = cTotalDomains;
    DfsDomainInfo.rgustrDomains = rgustrDomains;
    DfsDomainInfo.wszNameBuffer = wszNameBuffer;
    DfsDomainInfo.cbNameBuffer = cbNameBuffer;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfspInsertLsaDomainList exit\n");
#endif

    return( STATUS_SUCCESS );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspInsertDsDomainList
//
//  Synopsis:   Helper function to insert a part of the trusted domain list
//              into the DfsDomainInfo.
//
//  Arguments:  [pDsDomainTrusts] -- Array of DS_DOMAIN_TRUSTS
//              [cDomains] -- Number of elements in pDsDomainTrusts
//
//  Returns:    [STATUS_SUCCESS] -- Successfully appended domain list to
//                      DfsDomainInfo.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Unable to allocate memory
//                      for new list.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspInsertDsDomainList(
    PDS_DOMAIN_TRUSTS pDsDomainTrusts,
    ULONG cDomains)
{
    PDFS_TRUSTED_DOMAIN_INFO rgustrDomains = NULL;
    PWSTR wszNameBuffer = NULL, pwch;
    ULONG cTotalDomains, cbNameBuffer, i, j;
    ULONG Len;
    ULONG Count;

    DFSSVC_TRACE_NORM(DEFAULT, DfspInsertDsDomainList_Entry, 
                      LOGPTR(pDsDomainTrusts)
                      LOGULONG(cDomains));
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfspInsertDsDomainList(%d)\n", cDomains);
#endif

    cTotalDomains = DfsDomainInfo.cDomains + cDomains;

    cbNameBuffer = DfsDomainInfo.cbNameBuffer;

    for (i = 0; i < cDomains; i++) {

        if (pDsDomainTrusts[i].NetbiosDomainName != NULL
                &&
            pDsDomainTrusts[i].DnsDomainName != NULL
        ) {

            cbNameBuffer += wcslen(pDsDomainTrusts[i].NetbiosDomainName) * sizeof(WCHAR) +
                                sizeof(UNICODE_NULL) +
                                    wcslen(pDsDomainTrusts[i].DnsDomainName) * sizeof(WCHAR) +
                                        sizeof(UNICODE_NULL);

        }

    }

    wszNameBuffer = (PWSTR) malloc( cbNameBuffer );

    if (wszNameBuffer == NULL) {

        return( STATUS_INSUFFICIENT_RESOURCES );

    }

    rgustrDomains = (PDFS_TRUSTED_DOMAIN_INFO) malloc(
                        cTotalDomains * sizeof(DFS_TRUSTED_DOMAIN_INFO));

    if (rgustrDomains == NULL) {

        free( wszNameBuffer );

        return( STATUS_INSUFFICIENT_RESOURCES );

    }

    //
    // Copy over the existing DfsDomainInfo
    //

    if (DfsDomainInfo.cDomains != 0) {

        CopyMemory(
            wszNameBuffer,
            DfsDomainInfo.wszNameBuffer,
            DfsDomainInfo.cbNameBuffer);

        CopyMemory(
            rgustrDomains,
            DfsDomainInfo.rgustrDomains,
            DfsDomainInfo.cDomains * sizeof(DFS_TRUSTED_DOMAIN_INFO));

    }

    for (i = 0; i < DfsDomainInfo.cDomains; i++) {

        rgustrDomains[i].FlatName.Buffer = (WCHAR *)((PCHAR)wszNameBuffer +
            ((PCHAR)DfsDomainInfo.rgustrDomains[i].FlatName.Buffer - (PCHAR)DfsDomainInfo.wszNameBuffer));

        rgustrDomains[i].DnsName.Buffer = (WCHAR *)((PCHAR)wszNameBuffer +
            ((PCHAR)DfsDomainInfo.rgustrDomains[i].DnsName.Buffer - (PCHAR)DfsDomainInfo.wszNameBuffer));

    }

    //
    // Now copy in the new
    //

    pwch = (PWSTR) (((PCHAR) wszNameBuffer) + DfsDomainInfo.cbNameBuffer);

    for (Count = j = 0, i = DfsDomainInfo.cDomains; j < cDomains; j++) {

        if (IsDupDomainInfo(&pDsDomainTrusts[j]) == TRUE) {
            continue;
        }

        //
        // Dns name
        //

        Len = wcslen(pDsDomainTrusts[j].DnsDomainName) * sizeof(WCHAR);

        CopyMemory(
            pwch,
            pDsDomainTrusts[j].DnsDomainName,
            Len);

        pwch[ Len / sizeof(WCHAR) ] = UNICODE_NULL;

        RtlInitUnicodeString( &rgustrDomains[i].DnsName, pwch);

        pwch += (Len / sizeof(WCHAR) + 1);

        //
        // FlatName (Netbios)
        //

        Len = wcslen(pDsDomainTrusts[j].NetbiosDomainName) * sizeof(WCHAR);

        CopyMemory(
            pwch,
            pDsDomainTrusts[j].NetbiosDomainName,
            Len);

        pwch[ Len / sizeof(WCHAR) ] = UNICODE_NULL;

        RtlInitUnicodeString( &rgustrDomains[i].FlatName, pwch);

        pwch += (Len / sizeof(WCHAR) + 1);

        rgustrDomains[i].TrustDirection = pDsDomainTrusts[j].Flags;
        rgustrDomains[i].TrustType = pDsDomainTrusts[j].TrustType;
        rgustrDomains[i].TrustAttributes = pDsDomainTrusts[j].TrustAttributes;
        Count++;
        i++;


    }

    if (DfsDomainInfo.wszNameBuffer != NULL)
        free(DfsDomainInfo.wszNameBuffer);
    if (DfsDomainInfo.rgustrDomains != NULL)
        free( DfsDomainInfo.rgustrDomains );

    DfsDomainInfo.cDomains += Count;
    DfsDomainInfo.rgustrDomains = rgustrDomains;
    DfsDomainInfo.wszNameBuffer = wszNameBuffer;
    DfsDomainInfo.cbNameBuffer = cbNameBuffer;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfspInsertDsDomainList (%d inserted)\n", Count);
#endif

    return( STATUS_SUCCESS );

}

BOOLEAN
IsDupDomainInfo(
    PDS_DOMAIN_TRUSTS pDsDomainTrusts)
{
    ULONG i;

    if ( pDsDomainTrusts->NetbiosDomainName == NULL ||
        pDsDomainTrusts->DnsDomainName == NULL
    ) {
        return TRUE;
    }

    if (_wcsicmp(pDsDomainTrusts->NetbiosDomainName, DomainName) == 0
            ||
        _wcsicmp(pDsDomainTrusts->DnsDomainName, DomainNameDns) == 0
    ){
        return TRUE;
    }

    for (i = 0; i < DfsDomainInfo.cDomains; i++) {
        if (_wcsicmp(pDsDomainTrusts->NetbiosDomainName,
                     DfsDomainInfo.rgustrDomains[i].FlatName.Buffer) == 0
                ||
            _wcsicmp(pDsDomainTrusts->DnsDomainName,
                     DfsDomainInfo.rgustrDomains[i].DnsName.Buffer) == 0
        ) {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfssvc\svcwml.h ===
#ifndef _SVCWML_H_
#define _SVCWML_H_

#include "wmlmacro.h"
#include "wmlum.h"

#define _DFSSVC_ENABLE_DEFAULT             0x0001
#define _DFSSVC_ENABLE_UNUSED11            0x0002
#define _DFSSVC_ENABLE_FILEIO              0x0004
#define _DFSSVC_ENABLE_FILEINFO            0x0008
#define _DFSSVC_ENABLE_UNUSED10            0x0010
#define _DFSSVC_ENABLE_UNUSED9             0x0020
#define _DFSSVC_ENABLE_UNUSED8             0x0040
#define _DFSSVC_ENABLE_UNUSED7             0x0080
#define _DFSSVC_ENABLE_UNUSED6             0x0100
#define _DFSSVC_ENABLE_UNUSED5             0x0200
#define _DFSSVC_ENABLE_UNUSED4             0x0400
#define _DFSSVC_ENABLE_UNUSED3             0x0800
#define _DFSSVC_ENABLE_UNUSED2             0x1000
#define _DFSSVC_ENABLE_ALL_ERROR           0x2000
#define _DFSSVC_ENABLE_ERROR               0x4000
#define _DFSSVC_ENABLE_MONITOR             0x8000


#define _LEVEL_HIGH                    0x1
#define _LEVEL_NORM                    0x2
#define _LEVEL_LOW                     0x4
#define LOG_FLAGS(_flag)      _DFSSVC_ENABLE_ ## _flag

#define LOG_ENABLED( _level, _flags) \
            (( DfsRtlWmiReg.EnableLevel >= (_level) ) &&   \
             ( DfsRtlWmiReg.EnableFlags & _flags ))
            
            
#define DFS_WML_LOG(_level, _flags, _id, _arg) \
    do { \
        if ( LOG_ENABLED(_level, _flags) ) { \
            wml.Trace( WML_ID(_id), \
                     &DfsRtlTraceGuid , \
                      DfsRtlWmiReg.LoggerHandle, _arg 0); \
        } \
    } while (0)            

#define DFSSVC_LOG(_level, _flags, _type, _args) \
        DFS_WML_LOG(_level, _flags, _type, _args)


#define DFSSVC_TRACE_HIGH(_flags, _type, _args) \
                DFSSVC_LOG(_LEVEL_HIGH, LOG_FLAGS(_flags), _type, _args)
#define DFSSVC_TRACE_NORM(_flags, _type, _args) \
                DFSSVC_LOG(_LEVEL_NORM, LOG_FLAGS(_flags), _type, _args)
#define DFSSVC_TRACE_LOW(_flags, _type, _args) \
                DFSSVC_LOG(_LEVEL_LOW, LOG_FLAGS(_flags), _type, _args)

#define DFSSVC_TRACE_ERROR(_status, _flag, _type, _arg)    \
            DFSSVC_LOG(_LEVEL_NORM, (LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : LOG_FLAGS(ERROR))), _type, _arg)

#define DFSSVC_TRACE_ERROR_HIGH(_status, _flag, _type, _arg)    \
            DFSSVC_LOG(_LEVEL_HIGH, (LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : LOG_FLAGS(ERROR))), _type, _arg)

#define DFSSVC_TRACE_ERROR_LOW(_status, _flag, _type, _arg)    \
            DFSSVC_LOG(_LEVEL_LOW, (LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : LOG_FLAGS(ERROR))), _type, _arg)


#  define WPP_DEFINE_MSG_ID(_a,_b)   ( ((_a) << 16) | ( _b) )



#define WML_ID(_id)    ((MSG_ID_ ## _id) & 0xFF)

#  define MSG_ID_DfsCreateSiteArg_Entry	 WPP_DEFINE_MSG_ID(0,13)
#  define MSG_ID_DfsCreateSiteArg_Exit	 WPP_DEFINE_MSG_ID(0,14)
#  define MSG_ID_DfsDomainReferral_Entry	 WPP_DEFINE_MSG_ID(0,15)
#  define MSG_ID_DfsInitOurDomainDCs_Exit	 WPP_DEFINE_MSG_ID(0,10)
#  define MSG_ID_DfsInitRemainingDomainDCs_Error_NtFsControlFile	 WPP_DEFINE_MSG_ID(0,11)
#  define MSG_ID_DfsInitRemainingDomainDCs_Error_NtFsControlFile2	 WPP_DEFINE_MSG_ID(0,12)
#  define MSG_ID_DfspInsertDsDomainList_Entry	 WPP_DEFINE_MSG_ID(0,17)
#  define MSG_ID_DfspInsertLsaDomainList_Entry	 WPP_DEFINE_MSG_ID(0,16)


extern WML_DATA wml;
extern WMILIB_REG_STRUCT   DfsRtlWmiReg;
extern GUID DfsRtlTraceGuid;
void print(UINT level, PCHAR str);

#endif // _SVCWML_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\attach.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       attach.h
//
//  Contents:   This module defines the data structures used in attaching
//              to an existing file system volume.
//
//  Functions:
//
//-----------------------------------------------------------------------------

#ifndef _ATTACH_
#define _ATTACH_


//
//      For each local file system volume on which there exists a local
//      DFS volume, a DFS volume device object is created, and attached
//      to the local file system volume device object via
//      IoAttachDeviceByPointer.  This permits the DFS driver to
//      pre-screen any I/O which takes place on the local volume
//      and adjust it for DFS file I/O semantics.
//
//      In many cases, the I/O can simply be passed through to the local
//      file system for handling.  In some cases, parameters of the I/O
//      request must be examined and possibly modified before passing it
//      along to the underlying file system.  In some cases, e.g., an attempt
//      to rename a directory along an exit path, the I/O request may be
//      returned with an error status.
//

//
//  The Volume device object is associated with every volume to which this
//  file system has been attached.
//
typedef struct _DFS_VOLUME_OBJECT {

    DEVICE_OBJECT       DeviceObject;           // simple device object.
    ULONG               AttachCount;            // count of attachments
    LIST_ENTRY          VdoLinks;               // links for DfsData.AVdoQueue
    PROVIDER_DEF        Provider;               // provider definition for passthrough
    PDEVICE_OBJECT      RealDevice;             // The bottommost device in
                                                // the chain of attached
                                                // devices.
    BOOLEAN             DfsEnable;              // Dfs Enabled or disable
} DFS_VOLUME_OBJECT, *PDFS_VOLUME_OBJECT;

//
//  The File System Attach device object is associated with every File
//  System Device Object that is available in the system
//

typedef struct _DFS_ATTACH_FILE_SYSTEM_OBJECT {

    DEVICE_OBJECT       DeviceObject;           // simple device object.
    LIST_ENTRY          FsoLinks;               // links for DfsData.AFsoQueue
    PDEVICE_OBJECT      TargetDevice;           // The one we are attached to

} DFS_ATTACH_FILE_SYSTEM_OBJECT, *PDFS_ATTACH_FILE_SYSTEM_OBJECT;

//
//  Public function prototypes in attach.c
//

NTSTATUS
DfsGetAttachName(
    IN  PUNICODE_STRING LocalVolumeStorageId,
    OUT PUNICODE_STRING LocalVolumeRelativeName
);

NTSTATUS
DfsSetupVdo(
    IN  PUNICODE_STRING RootName,
    IN  PDEVICE_OBJECT ptargetVdo,
    IN  PDEVICE_OBJECT realDevice,
    IN  ULONG pVolNameLen,
    OUT PDFS_VOLUME_OBJECT *pdfsVdo);

NTSTATUS
DfsAttachVolume(
    IN  PUNICODE_STRING RootName,
    OUT PPROVIDER_DEF *ppProvider
);

NTSTATUS
DfsDetachVolume(
    IN  PUNICODE_STRING TargetName
);

NTSTATUS
DfsDetachVolumeForDelete(
    IN  PDEVICE_OBJECT DfsVdo
);

VOID
DfsReattachToMountedVolume(
    IN PDEVICE_OBJECT TargetDevice,
    IN PVPB Vpb
);

VOID
DfsFsNotification(
    IN PDEVICE_OBJECT FileSystemObject,
    IN BOOLEAN fLoading
);

VOID
DfsDetachAllFileSystems(
    VOID
);

NTSTATUS
DfsVolumePassThrough(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PIRP Irp
);

NTSTATUS
DfsCompleteVolumePassThrough(
    IN  PDEVICE_OBJECT pDevice,
    IN  PIRP Irp,
    IN  PVOID Context
);

#endif  // _ATTACH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\attach.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       attach.c
//
//  Contents:   This module contains routines for managing attached file
//              systems.
//
//  Functions:
//
//-----------------------------------------------------------------------------


#include "dfsprocs.h"
#include "attach.h"
#include "dfswml.h"

#define Dbg              (DEBUG_TRACE_ATTACH)

NTSTATUS
DfsReferenceVdoByFileName(
    IN  PUNICODE_STRING TargetName,
    OUT PDEVICE_OBJECT *DeviceObject,
    OUT PDEVICE_OBJECT *RealDeviceObject,
    OUT PULONG DevObjNameLen OPTIONAL
);

VOID
DfsAttachToFileSystem(
    IN PDEVICE_OBJECT FileSystemObject);

VOID
DfsDetachFromFileSystem(
    IN PDEVICE_OBJECT FileSystemObject);

PDEVICE_OBJECT
DfsGetDfsFilterDeviceObject(
    IN PFILE_OBJECT targetFile);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsReferenceVdoByFileName )
#pragma alloc_text( PAGE, DfsGetAttachName )
#pragma alloc_text( PAGE, DfsSetupVdo)
#pragma alloc_text( PAGE, DfsAttachVolume )
#pragma alloc_text( PAGE, DfsDetachVolume )
#pragma alloc_text( PAGE, DfsGetDfsFilterDeviceObject)

//
// The following are not pageable since they can be called at DPC level
//
// DfsVolumePassThrough
//

#endif // ALLOC_PRAGMA

//
// Generator value for local provider IDs.
//

static  USHORT  LocalProviderID = 0xF000;

//+-------------------------------------------------------------------------
//
//  Function:   DfsReferenceVdoByFileName, private
//
//  Synopsis:   Given a file path name, this function will return a pointer
//              to its corresponding volume device object.
//
//  Arguments:  [TargetName] -- File path name of the root directory of the
//                      local volume.
//              [DeviceObject] -- Upon successful return, contains a
//                      referenced pointer to the first attached device
//                      object for the file.
//              [RealDeviceObject] -- Upon successful return, contains a
//                      non-referenced pointer to the real device object
//                      for the file.
//              [DevObjNameLen] -- An optional argument, which if present,
//                      gives the length (in bytes) of the path to the
//                      returned device object.
//
//  Returns:    NTSTATUS -- STATUS_SUCCESS if successful.  Otherwise, the
//                          status returned by the file open attempt.
//
//  Notes:      This could return a pointer to a DFS volume object if one
//              has already been attached.
//
//              ObDereferenceObject must be called on the returned
//              DeviceObject
//
//--------------------------------------------------------------------------


NTSTATUS
DfsReferenceVdoByFileName(
    IN  PUNICODE_STRING TargetName,
    OUT PDEVICE_OBJECT *DeviceObject,
    OUT PDEVICE_OBJECT *RealDeviceObject,
    OUT PULONG DevObjNameLen OPTIONAL
)
{
    NTSTATUS Status;
    UNICODE_STRING fileName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE targetFileHandle = NULL;
    OBJECT_HANDLE_INFORMATION handleInformation;
    PFILE_OBJECT targetFileObject;

    DebugTrace(+1, Dbg, "DfsReferenceVdoByFileName: Entered\n", 0);

    //
    // Make sure what we have is indeed a file name, and not a device name!
    //

    if (TargetName->Buffer[ TargetName->Length/sizeof(WCHAR) - 1 ] ==
            UNICODE_DRIVE_SEP) {

        fileName.Length = 0;
        fileName.MaximumLength = TargetName->Length + 2 * sizeof(WCHAR);
        fileName.Buffer = ExAllocatePoolWithTag(PagedPool, fileName.MaximumLength, ' sfD');

        if (fileName.Buffer == NULL) {

            DebugTrace(0, Dbg,
                "Unable to allocate %d bytes\n", fileName.MaximumLength);

            Status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            RtlCopyUnicodeString(&fileName, TargetName);

            RtlAppendUnicodeToString(
                &fileName,
                (LPWSTR) UNICODE_PATH_SEP_STR);

            Status = STATUS_SUCCESS;

        }

    } else {

        fileName = *TargetName;

        Status = STATUS_SUCCESS;

    }

    if (NT_SUCCESS(Status)) {

        //
        // create the object attribtues argument
        //

        InitializeObjectAttributes(
                &objectAttributes,
                &fileName,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

        DebugTrace(0,Dbg, "DfsReferenceVdoByFileName: Attempting to open file [%wZ]\n", &fileName );

        //
        // Open the root of the volume
        //

        Status = ZwOpenFile(&targetFileHandle,
                            FILE_READ_ATTRIBUTES | FILE_LIST_DIRECTORY,
                            &objectAttributes,
                            &ioStatusBlock,
                            FILE_SHARE_READ,
                            FILE_DIRECTORY_FILE);

    }

    //
    // if we have successfully opened the file then we begin the
    // task of getting a reference to the file object itself.
    //

    if (NT_SUCCESS(Status)) {

        DebugTrace(0,Dbg,
            "DfsReferenceVdoByFileName: Attempting get file object \n", 0);

        Status = ObReferenceObjectByHandle(
                    targetFileHandle,
                    0,
                    NULL,
                    KernelMode,
                    (PVOID *)&targetFileObject,
                    &handleInformation);

        //
        // if we have successfully obtained a reference to the file object
        // we can now begin the task of getting the related device object.
        //
        if (NT_SUCCESS(Status)) {

            *DeviceObject = DfsGetDfsFilterDeviceObject(targetFileObject);

            if (*DeviceObject == NULL) {
                *DeviceObject = IoGetRelatedDeviceObject(targetFileObject);
            }

            *RealDeviceObject = targetFileObject->Vpb->RealDevice;

            Status = ObReferenceObjectByPointer(
                        *DeviceObject,
                        0,
                        NULL,
                        KernelMode);

            if (NT_SUCCESS(Status) && ARGUMENT_PRESENT(DevObjNameLen)) {

                ASSERT(
                    fileName.Length > targetFileObject->FileName.Length);

                *DevObjNameLen = fileName.Length -
                                    targetFileObject->FileName.Length;
            }

            ObDereferenceObject(targetFileObject);

            DebugTrace( 0, Dbg, "Referenced Vdo [%08lx]\n", *DeviceObject);

            DebugTrace( 0, Dbg, "Real Device Object [%08lx]\n",
                *RealDeviceObject);

        }

        ZwClose(targetFileHandle);

    }

    if (fileName.Buffer != NULL && fileName.Buffer != TargetName->Buffer) {

        ExFreePool( fileName.Buffer );

    }

    DebugTrace(-1,Dbg, "DfsReferenceVdoByFileName: Exit -> %08lx\n", ULongToPtr( Status ) );

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsGetAttachName, public
//
//  Synopsis:   A DFS local volume storage ID is parsed into the portion
//              which refers to a volume device object, and the portion
//              which refers to the volume-relative path to the root of
//              the local volume storageID.
//
//  Arguments:  [LocalVolumeStorageId] -- file path name of the root of
//                              the local DFS volume.
//              [LocalVolumeRelativeName] -- the name of LocalVolumeStorageId
//                              relative to the volume object name.  This
//                              includes a leading \.
//
//  Returns:    Status from DfsReferenceVdoByFileName()
//
//  Notes:      The returned string is a pointer into the input string.
//              The string storage should be duplicated as needed.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsGetAttachName(
    IN  PUNICODE_STRING LocalVolumeStorageId,
    OUT PUNICODE_STRING LocalVolumeRelativeName
)
{
    NTSTATUS Status;
    PDEVICE_OBJECT targetVdo, realDevice;
    ULONG volNameLen;

    DebugTrace(+1, Dbg, "DfsGetAttachName: Entered\n", 0);

    //
    // Get our hands on the volume object
    //
    DebugTrace(0, Dbg,
        "DfsGetAttachName: Attempting to reference volume\n", 0);

    Status = DfsReferenceVdoByFileName(
                LocalVolumeStorageId,
                &targetVdo,
                &realDevice,
                &volNameLen);

    if (NT_SUCCESS(Status)) {

        *LocalVolumeRelativeName = *LocalVolumeStorageId;

        if (LocalVolumeRelativeName->Length -= (USHORT)volNameLen) {

            LocalVolumeRelativeName->Buffer =
                (PWCHAR)((PCHAR)LocalVolumeRelativeName->Buffer + volNameLen);

            ASSERT (LocalVolumeRelativeName->Buffer[0] == UNICODE_PATH_SEP);

            LocalVolumeRelativeName->MaximumLength -=
                LocalVolumeStorageId->Length - LocalVolumeRelativeName->Length;

        } else {

            LocalVolumeRelativeName->Buffer = NULL;

            LocalVolumeRelativeName->MaximumLength = 0;

        }

        ObDereferenceObject(targetVdo);
    }

    DebugTrace(-1,Dbg, "DfsGetAttachName: Exit -> %08lx\n", ULongToPtr( Status ) );

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsAttachVolume, public
//
//  Synopsis:   A DFS volume device object is attached to the volume
//              device object for some local file system, and a provider
//              definition is built for the local volume.
//
//  Arguments:  [RootName] -- file path name of the root of the local
//                            volume.
//              [ppProvider] -- On successful return, contains a pointer
//                              to a PROVIDER_DEF record that descibes the
//                              attached device.
//
//  Returns:    [STATUS_INSUFFICIENT_RESOURCES] -- If unable to allocate
//                      pool for provider name.
//
//              Status from DfsSetupVdo()
//
//--------------------------------------------------------------------------

NTSTATUS
DfsAttachVolume(
    IN PUNICODE_STRING RootName,
    OUT PPROVIDER_DEF *ppProvider
)
{
    NTSTATUS Status;
    PDEVICE_OBJECT targetVdo, realDevice;
    PDFS_VOLUME_OBJECT dfsVdo = NULL;
    ULONG volNameLen;
    BOOLEAN fReferenced = FALSE;

    DebugTrace(+1, Dbg, "DfsAttachVolume: Entered\n", 0);

    Status = DfsReferenceVdoByFileName(
                RootName,
                &targetVdo,
                &realDevice,
                &volNameLen);

    if (NT_SUCCESS(Status)) {
        fReferenced = TRUE;

        if (targetVdo->DeviceType != FILE_DEVICE_DFS_VOLUME) {
             Status = DfsSetupVdo(RootName, targetVdo, realDevice, volNameLen, &dfsVdo);
	     if (NT_SUCCESS(Status)) {
	       InsertTailList(&DfsData.AVdoQueue, &dfsVdo->VdoLinks);
	       dfsVdo->DfsEnable = TRUE;
	       dfsVdo->DeviceObject.Flags &= ~DO_DEVICE_INITIALIZING;
	     }
       } else {

            //
            //  Upon dereferencing the volume device object, we found one
            //  of our own Vdos.  Just bump the reference count on it.
            //

            DebugTrace(0, Dbg,
                "DfsAttachVolume: Attaching multiple times to device %x\n",
                targetVdo);

            dfsVdo = (PDFS_VOLUME_OBJECT) targetVdo;
            dfsVdo->DfsEnable = TRUE;
            dfsVdo->AttachCount++;
       }
    }

    if (NT_SUCCESS(Status)) {
        *ppProvider = &dfsVdo->Provider;
    }

    if (fReferenced) {
        ObDereferenceObject(targetVdo);
    }

    DfspGetMaxReferrals();

    DebugTrace(-1,Dbg, "DfsAttachVolume: Exit -> %08lx\n", ULongToPtr( Status ) );

    return Status;

}

//+-------------------------------------------------------------------------
//
//  Function:   DfsDetachVolume, public
//
//  Synopsis:   The DFS volume device object referred to by the file
//              RootName is dereferenced.  If it is the last reference,
//              the Vdo is detached from the device chain.
//
//  Arguments:  [RootName] -- file path name of the root of the local
//                            volume.
//
//  Returns:    Status from DfsReferenceVdoByFileName
//
//--------------------------------------------------------------------------

NTSTATUS
DfsDetachVolume(
    IN PUNICODE_STRING RootName
)
{
    NTSTATUS Status;
    PDFS_VOLUME_OBJECT dfsVdo;
    PDEVICE_OBJECT realDevice;

    DebugTrace(+1, Dbg, "DfsDetachVolume: Entered\n", 0);

    //
    // Get our hands on the volume object
    //

    DebugTrace(0, Dbg, "DfsDetachVolume: Attempting to reference volume\n", 0);

    Status = DfsReferenceVdoByFileName(
                RootName,
                (PDEVICE_OBJECT *)&dfsVdo,
                &realDevice,
                NULL);

    if (NT_SUCCESS(Status)) {

        //
        // We should have our hands on one of our device objects
        //


        if ((dfsVdo->DeviceObject.DeviceType == FILE_DEVICE_DFS_VOLUME) &&
            (--dfsVdo->AttachCount == 0)) {

            //
            // Go ahead and detach the device
            //

	    dfsVdo->DfsEnable = FALSE;
	}
        ObDereferenceObject(dfsVdo);
    }

    DebugTrace(-1,Dbg, "DfsDetachVolume: Exit -> %08lx\n", ULongToPtr( Status ) );

    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsDetachVolumeForDelete, public
//
//  Synopsis:   This routine does the work of detaching from a target
//              device object so that the target device object may be
//              deleted.
//
//
//  Arguments:  [DfsVdo] -- The dfs attached device object.
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsDetachVolumeForDelete(
    IN PDEVICE_OBJECT DeviceObject)
{

    //
    // Acquire the Pkt exclusively so no one will access this Vdo while we
    // are detaching it.
    //
    if (DeviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM) {
        DfsDetachFromFileSystem( ((PDFS_ATTACH_FILE_SYSTEM_OBJECT) DeviceObject)->TargetDevice );
    } else {
        PDFS_PKT pkt;
        PDFS_VOLUME_OBJECT DfsVdo = (PDFS_VOLUME_OBJECT) DeviceObject;

        pkt = _GetPkt();

        PktAcquireExclusive( pkt, TRUE );

        //
        // Detach from the underlying FS...
        //

        IoDetachDevice(DfsVdo->Provider.DeviceObject);

        //
        // Flag our provider to be unavailable...
        //

        DfsVdo->Provider.fProvCapability |= PROV_UNAVAILABLE;

        PktRelease( pkt );
    }

    return( STATUS_SUCCESS );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsReattachToMountedVolume, public
//
//  Synopsis:   If one runs chkdsk, format etc on a volume that has been
//              attached to, the underlying file system will need to
//              unmount the volume. This will be handled by the
//              DfsDetachVolumeForDelete routine above. Ater the operation is
//              done, the volume will need to be remounted again. This
//              routine will reattach on the remount.
//
//  Arguments:  [TargetDevice] -- The Volume Device Object for the volume
//                      that was just mounted.
//
//              [Vpb] -- The Volume Parameter Block of the volume that was
//                      just mounted.
//
//  Returns:
//
//-----------------------------------------------------------------------------

VOID
DfsReattachToMountedVolume(
    IN PDEVICE_OBJECT TargetDevice,
    IN PVPB Vpb)
{
    NTSTATUS Status;
    PDFS_PKT pkt;
    PUNICODE_PREFIX_TABLE_ENTRY lvPrefix;
    PDFS_LOCAL_VOL_ENTRY localVol;

    //
    // If the local volumes are being initialized as we speak, we won't
    // check to see if there are any unmounted volumes that need to be
    // reattached. This is because we need to acquire the pkt to do the
    // check. However, the local volume init itself might be causing this
    // volume to be mounted, in which case they already have the Pkt locked.
    //

    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    if (DfsData.LvState == LV_INITINPROGRESS ||
            DfsData.LvState == LV_UNINITIALIZED) {

        DebugTrace(0, Dbg, "Local volumes being initialized - no action taken\n", 0);

        ExReleaseResourceLite( &DfsData.Resource );

        return;

    }

    ExReleaseResourceLite( &DfsData.Resource );

    //
    // We will go through all our local volumes to see if any of them have
    // a provider that has been detached (marked as PROV_UNAVAILABLE). If
    // we find any, we will see if the volume being mounted is one which
    // was dismounted before. If so, we reattach.
    //

    pkt = _GetPkt();

    PktAcquireExclusive( pkt, TRUE );

    lvPrefix = DfsNextUnicodePrefix(&pkt->LocalVolTable, TRUE);

    DebugTrace(0, Dbg, "Looking for Real Device %08lx\n", Vpb->RealDevice);

    while (lvPrefix != NULL) {

        PPROVIDER_DEF  provider;
        PDFS_VOLUME_OBJECT candidateObject;

        localVol = (PDFS_LOCAL_VOL_ENTRY) CONTAINING_RECORD(
                        lvPrefix,
                        DFS_LOCAL_VOL_ENTRY,
                        PrefixTableEntry);

        ASSERT(localVol->PktEntry->LocalService != NULL);

        provider = localVol->PktEntry->LocalService->pProvider;

        if (provider != NULL) {

            candidateObject = CONTAINING_RECORD(
                                    provider,
                                    DFS_VOLUME_OBJECT,
                                    Provider);

            if (provider->fProvCapability & PROV_UNAVAILABLE) {


                DebugTrace(0, Dbg, "Examining dismounted volume [%wZ]\n",
                    &localVol->PktEntry->Id.Prefix);

                if (Vpb->RealDevice == candidateObject->RealDevice) {

                    DebugTrace(0, Dbg, "Found detached device %08lx\n",
                        candidateObject);

                    provider->DeviceObject = TargetDevice;

                    Status = IoAttachDeviceByPointer(
                                &candidateObject->DeviceObject,
                                TargetDevice);

                    if (NT_SUCCESS(Status)) {

                        provider->fProvCapability &= ~PROV_UNAVAILABLE;

                    }

                } else {

                    DebugTrace(0, Dbg, "Real Device %08lx did not match\n",
                        candidateObject->RealDevice);

                }

            }

        }

        lvPrefix = DfsNextUnicodePrefix( &pkt->LocalVolTable, FALSE );

        localVol = (PDFS_LOCAL_VOL_ENTRY) CONTAINING_RECORD(
                        lvPrefix,
                        DFS_LOCAL_VOL_ENTRY,
                        PrefixTableEntry);

    }

    PktRelease( pkt );

}


//+-------------------------------------------------------------------
//
//  Function:   DfsVolumePassThrough, public
//
//  Synopsis:   This is the main FSD routine that passes a request
//              on to an attached-to device, or to a redirected
//              file.
//
//  Arguments:  [DeviceObject] -- Supplies a pointer to the Dfs device
//                      object this request was aimed at.
//              [Irp] -- Supplies a pointer to the I/O request packet.
//
//  Returns:    [STATUS_INVALID_DEVICE_REQUEST] -- If the DeviceObject
//                      argument is of unknown type, or the type of file
//                      is invalid for the request being performed.
//
//              NT Status from calling the underlying file system that
//                      opened the file.
//
//--------------------------------------------------------------------

NTSTATUS
DfsVolumePassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;
    PFILE_OBJECT FileObject;


    DebugTrace(+1, Dbg, "DfsVolumePassThrough: Entered\n", 0);

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;

    DebugTrace(0, Dbg, "DeviceObject    = %x\n", DeviceObject);
    DebugTrace(0, Dbg, "Irp             = %x\n", Irp        );
    DebugTrace(0, Dbg, "  MajorFunction = %x\n", IrpSp->MajorFunction );
    DebugTrace(0, Dbg, "  MinorFunction = %x\n", IrpSp->MinorFunction );

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS_VOLUME) {

        PDEVICE_OBJECT Vdo;

        //
        // Copy the stack from one to the next...
        //

        NextIrpSp = IoGetNextIrpStackLocation(Irp);

        (*NextIrpSp) = (*IrpSp);

        IoSetCompletionRoutine(Irp, NULL, NULL, FALSE, FALSE, FALSE);

        //
        // Find out what device to call...and call it
        //

        Vdo = ((PDFS_VOLUME_OBJECT) DeviceObject)->Provider.DeviceObject;

        Status = IoCallDriver( Vdo, Irp );

        DFS_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsVolumePassThrough_Error_Vol_IoCallDriver,
                             LOGSTATUS(Status)
                             LOGPTR(Irp)
                             LOGPTR(FileObject));

    } else if (DeviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM) {

        PDEVICE_OBJECT Fso;

        //
        // Copy the stack from one to the next...
        //

        NextIrpSp = IoGetNextIrpStackLocation(Irp);

        (*NextIrpSp) = (*IrpSp);

        IoSetCompletionRoutine(Irp, NULL, NULL, FALSE, FALSE, FALSE);

        //
        // Find out what device to call...and call it
        //

        Fso = ((PDFS_ATTACH_FILE_SYSTEM_OBJECT) DeviceObject)->TargetDevice;

        Status = IoCallDriver( Fso, Irp );
        DFS_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsVolumePassThrough_Error_FS_IoCallDriver,
                             LOGPTR(Irp)
                             LOGSTATUS(Status)
                             LOGPTR(FileObject));


    } else {

        DebugTrace(0, Dbg, "DfsVolumePassThrough: Unexpected Dev = %x\n",
                                DeviceObject);

        Status = STATUS_INVALID_DEVICE_REQUEST;
        DFS_TRACE_HIGH(ERROR, DfsVolumePassThrough_Error1,
                       LOGSTATUS(Status)
                       LOGPTR(FileObject)
                       LOGPTR(Irp));

        Irp->IoStatus.Status = Status;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DebugTrace(-1, Dbg, "DfsVolumePassThrough: Exit -> %08lx\n", ULongToPtr( Status ) );
    

    return Status;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFsNotification, public
//
//  Synopsis:   Routine to be registered as a callback with the IO subsystem.
//              It gets called every time a file system is loaded or
//              unloaded. Here, we attach to the file system so that we can
//              trap MOUNT fsctrls. We need to trap MOUNT fsctrls so that
//              we can attach to the Volume Device Objects of volumes that
//              are mounted in the Dfs namespace.
//
//  Arguments:  [FileSystemObject] -- The File System Device Object of the
//                      File System that is being loaded/unloaded.
//
//              [fLoading] -- TRUE if the File System is being loaded. FALSE
//                      if it is being unloaded.
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

VOID
DfsFsNotification(
    IN PDEVICE_OBJECT FileSystemObject,
    IN BOOLEAN fLoading)
{
    ASSERT( FileSystemObject->DriverObject != NULL );

    DebugTrace(+1, Dbg, "DfsFsNotification - Entered\n", 0);
    DebugTrace(0, Dbg, "File System [%wZ]\n", &FileSystemObject->DriverObject->DriverName);
    DebugTrace(0, Dbg, "%s\n", fLoading ? "Loading" : "Unloading" );

    //
    // Check if this is a DISK based file system. If not, we don't care about
    // it.
    //

    if (FileSystemObject->DeviceType != FILE_DEVICE_DISK_FILE_SYSTEM) {
        DebugTrace(-1, Dbg, "DfsFsNotification - Not Disk File System\n",0);
        return;
    }

    //
    // A disk file system is being loaded or unloaded. If it is being loaded,
    // we want to attach to the File System Device Object being passed in. If
    // it is being unloaded, we try to find our attached device and detach
    // ourselves.
    //

    if (fLoading) {

        DfsAttachToFileSystem( FileSystemObject );

    } else {

        DfsDetachFromFileSystem( FileSystemObject );

    }

    DebugTrace(-1, Dbg, "DfsFsNotification - Exited\n", 0);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsAttachToFileSystem
//
//  Synopsis:   Attaches to a File System Device Object so we can trap
//              MOUNT calls.
//
//  Arguments:  [FileSystemObject] -- The File System Object to attach to.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsAttachToFileSystem(
    IN PDEVICE_OBJECT FileSystemObject)
{
    NTSTATUS Status;
    PDFS_ATTACH_FILE_SYSTEM_OBJECT ourDevice;
    PDEVICE_OBJECT TargetFileSystemObject;

    //
    // Create our own device object.
    //

    Status = IoCreateDevice(
                DfsData.DriverObject,            // Our own Driver Object
                sizeof(DFS_ATTACH_FILE_SYSTEM_OBJECT) -
                sizeof(DEVICE_OBJECT),           // size of extension
                NULL,                            // Name - we don't need one
                FILE_DEVICE_DISK_FILE_SYSTEM,    // Type of device
                0,                               // Device Characteristics
                FALSE,                           // Exclusive
                (PDEVICE_OBJECT *) &ourDevice);  // On return, new device

    DFS_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsAttachToFileSystem_Error_IoCreateDevice,
                         LOGSTATUS(Status)
                         LOGPTR(FileSystemObject));

    if (NT_SUCCESS(Status)) {

        DebugTrace(0, Dbg, "Created File System Attach Device %08lx\n",
            ourDevice);

        TargetFileSystemObject = IoAttachDeviceToDeviceStack(
                                    &ourDevice->DeviceObject,
                                    FileSystemObject );

        if (TargetFileSystemObject != NULL) {

            ourDevice->TargetDevice = TargetFileSystemObject;

            ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

            InsertTailList( &DfsData.AFsoQueue, &ourDevice->FsoLinks );

            ExReleaseResourceLite( &DfsData.Resource );


            ourDevice->DeviceObject.Flags &= ~DO_DEVICE_INITIALIZING;

        } else {

            DebugTrace(0, Dbg, "Unable to attach %08lx\n", ULongToPtr( Status ));

            IoDeleteDevice( (PDEVICE_OBJECT) ourDevice );

        }

    } else {

        DebugTrace(0, Dbg, "Unable to create Device Object %08lx\n", ULongToPtr( Status ));

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsDetachFromFileSystem
//
//  Synopsis:   Finds and detaches a DFS_ATTACHED_FILE_SYSTEM_OBJECT from
//              its target File System Device Object.
//
//  Arguments:  [FileSystemObject] -- The one that purpotedly has one of our
//                      device objects attached to it.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsDetachFromFileSystem(
    IN PDEVICE_OBJECT FileSystemObject)
{
    PDFS_ATTACH_FILE_SYSTEM_OBJECT attachedDevice, candidateDevice;
    PLIST_ENTRY nextAFsoLink;

    //
    // First, we need to find our own device. For each device that is
    // attached to the FileSystemObject, we check our AFsoQueue to see if
    // the attached device belongs to us.
    //
    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    for (attachedDevice = (PDFS_ATTACH_FILE_SYSTEM_OBJECT)
            FileSystemObject->AttachedDevice;
                attachedDevice != NULL;
                    attachedDevice = (PDFS_ATTACH_FILE_SYSTEM_OBJECT)
                        attachedDevice->DeviceObject.AttachedDevice) {

        for (nextAFsoLink = DfsData.AFsoQueue.Flink;
                nextAFsoLink != &DfsData.AFsoQueue;
                    nextAFsoLink = nextAFsoLink->Flink) {

            candidateDevice = CONTAINING_RECORD(
                                    nextAFsoLink,
                                    DFS_ATTACH_FILE_SYSTEM_OBJECT,
                                    FsoLinks);

            if (attachedDevice == candidateDevice) {

                DebugTrace(0, Dbg, "Found Attached Device %08lx\n",
                    candidateDevice);

                RemoveEntryList( &attachedDevice->FsoLinks );

                ExReleaseResourceLite( &DfsData.Resource );

                IoDetachDevice( FileSystemObject );

                IoDeleteDevice( (PDEVICE_OBJECT) attachedDevice );

                return;

            }

        }

    }

    ExReleaseResourceLite( &DfsData.Resource );

    DebugTrace(0, Dbg, "Did not find a device attached to %08lx\n",
        FileSystemObject);

}

//+-------------------------------------------------------------------------
//
//  Function:   DfsDetachAllFileSystems
//
//  Synopsis:   Detaches from all file systems at unload time
//              
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//
//--------------------------------------------------------------------------

VOID
DfsDetachAllFileSystems(
    VOID
)
{
    PDFS_ATTACH_FILE_SYSTEM_OBJECT Device;
    PLIST_ENTRY ListEntry;

    FsRtlEnterFileSystem ();
    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    while (!IsListEmpty (&DfsData.AFsoQueue)) {
        ListEntry = RemoveHeadList (&DfsData.AFsoQueue);
        Device = CONTAINING_RECORD(ListEntry,
                                   DFS_ATTACH_FILE_SYSTEM_OBJECT,
                                   FsoLinks);

        ExReleaseResourceLite( &DfsData.Resource );
        FsRtlExitFileSystem ();

        IoDetachDevice( Device->TargetDevice );

        IoDeleteDevice( &Device->DeviceObject );

        FsRtlEnterFileSystem ();
        ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );
    }

    ExReleaseResourceLite( &DfsData.Resource );
    FsRtlExitFileSystem ();
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsSetupVdo, private
//
//  Synopsis:   A DFS volume device object is created and initialized. It is then
//              attached to the device object that is passed in.
//
//  Arguments:  [RootName] -- file path name of the root of the local
//                            volume.
//               targetVdo -- The target device object we are attaching to.
//               realDevice --  the real device for this volume.
//               volNameLen -- Volume name length.
//               CreatedVdo -- The is the return value, from IoCreateDevice.
//
//  Returns:    [STATUS_INSUFFICIENT_RESOURCES] -- If unable to allocate
//                      pool for provider name.
//              return status from IoCreateDevice or IoAttachDevice.
//
//
//--------------------------------------------------------------------------


NTSTATUS
DfsSetupVdo (
    IN PUNICODE_STRING RootName,
    IN PDEVICE_OBJECT targetVdo,
    IN PDEVICE_OBJECT realDevice,
    IN ULONG volNameLen,
    OUT PDFS_VOLUME_OBJECT *CreatedVdo
)
{

    NTSTATUS Status;
    PDFS_VOLUME_OBJECT dfsVdo;

    DebugTrace(1, Dbg, "DfsSetupVdo: Attempting to create device\n",0);
    Status = IoCreateDevice(
                DfsData.DriverObject,
                sizeof(DFS_VOLUME_OBJECT) - sizeof(DEVICE_OBJECT),
                NULL,
                FILE_DEVICE_DFS_VOLUME,
                targetVdo->Characteristics,
                FALSE,
                (PDEVICE_OBJECT *) &dfsVdo);

    if (NT_SUCCESS(Status)) {
        dfsVdo->DeviceObject.StackSize = targetVdo->StackSize+1;
        dfsVdo->AttachCount = 1;
        dfsVdo->RealDevice = realDevice;

        dfsVdo->Provider.NodeTypeCode = DFS_NTC_PROVIDER;
        dfsVdo->Provider.NodeByteSize = sizeof ( PROVIDER_DEF );
        dfsVdo->Provider.eProviderId = ++LocalProviderID;
        dfsVdo->Provider.fProvCapability = 0;
        dfsVdo->Provider.DeviceObject = targetVdo;
        dfsVdo->Provider.FileObject = NULL;
        dfsVdo->Provider.DeviceName.Buffer = (PWCHAR) ExAllocatePoolWithTag(
                                                        PagedPool,
                                                        volNameLen,
                                                        ' sfD');

        if (dfsVdo->Provider.DeviceName.Buffer == NULL) {
               IoDeleteDevice(&dfsVdo->DeviceObject);
	       DebugTrace(-1, Dbg, "DfsSetupVdo: Cannot allocate memory\n", 0);
               return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlMoveMemory(dfsVdo->Provider.DeviceName.Buffer,  RootName->Buffer, volNameLen);

        dfsVdo->Provider.DeviceName.MaximumLength =
                 dfsVdo->Provider.DeviceName.Length =
                          (USHORT)volNameLen;

        //
        // If we successfully created the device object we can
        // begin the task of attaching.
        //

        DebugTrace(0, Dbg, "DfsSetupVdo: Attempting to attach device\n",0);
        Status = IoAttachDeviceByPointer(
                       &dfsVdo->DeviceObject,
                       targetVdo);
        if (!NT_SUCCESS(Status)) {
           ExFreePool(dfsVdo->Provider.DeviceName.Buffer);
           IoDeleteDevice(&dfsVdo->DeviceObject);
        }
    }
    
    if (NT_SUCCESS(Status)) {
      *CreatedVdo = dfsVdo;
    }
    DebugTrace(-1, Dbg, "DfsSetupVdo: Returning status %p\n", ULongToPtr( Status ));
    return Status;
}


PDEVICE_OBJECT
DfsGetDfsFilterDeviceObject(
    PFILE_OBJECT fileObject)
{
    PDEVICE_OBJECT DevObj;
    PDEVICE_OBJECT NextAttached;

    DevObj = fileObject->Vpb->DeviceObject;
    NextAttached = DevObj->AttachedDevice;

    while (NextAttached != NULL) {
        if (NextAttached->DeviceType == FILE_DEVICE_DFS_VOLUME) {
            return NextAttached;
        }
        NextAttached = NextAttached->AttachedDevice;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfssvc\dfssvc.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       dfssvc.c
//
//  Contents:   Code to interact with service manager.
//
//  Classes:
//
//  Functions:
//
//  History:    12 Nov 92       Milans created.
//
//-----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <dfsfsctl.h>
#include <windows.h>
#include <stdlib.h>
#include <lm.h>
#include <dsrole.h>

#include <dfsstr.h>
#include <libsup.h>
#include <dfsmsrv.h>

#include <winldap.h>

#include "dfsipc.h"
#include "dominfo.h"
#include "wmlum.h"
#include "wmlmacro.h"
#include "svcwml.h"

#include <debug.h>
DECLARE_DEBUG(DfsSvc)
DECLARE_INFOLEVEL(DfsSvc)

#if DBG == 1

#define svc_debug_error(x,y)    DfsSvcInlineDebugOut(DEB_ERROR, x, y)
#define svc_debug_trace(x,y)    DfsSvcInlineDebugOut(DEB_TRACE, x, y)

#else // DBG == 1

#define svc_debug_error(x,y)
#define svc_debug_trace(x,y)

#endif // DBG == 1

#define MAX_HINT_PERIODS        1000

BOOLEAN                 fStartAsService;
const PWSTR             wszDfsServiceName = L"DfsService";
SERVICE_STATUS          DfsStatus;
SERVICE_STATUS_HANDLE   hDfsService;

VOID DfsSvcMsgProc(
    DWORD dwControl);

VOID StartDfsService(
    DWORD dwNumServiceArgs,
    LPWSTR *lpServiceArgs);

DWORD
DfsStartDfssrv(VOID);

VOID
DfsStopDfssrv( VOID);

BOOL
DfsIsThisADfsRoot();

DWORD
DfsInitializationLoop(
    LPVOID lpThreadParams);

DWORD DfsManagerProc();

DWORD DfsRegDeleteKeyAndChildren(HKEY hkey, LPWSTR s);

DWORD DfsCleanLocalVols(void);
DWORD DfsDeleteChildKeys(HKEY hkey, LPWSTR s);

void UpdateStatus(
    SERVICE_STATUS_HANDLE hService,
    SERVICE_STATUS *pSStatus,
    DWORD Status);

//
// Event logging and debugging globals
//
extern ULONG DfsSvcVerbose;
extern ULONG DfsEventLog;

typedef void (FAR WINAPI *DLL_ENTRY_PROC)(PWSTR);

//
// Our domain name and machine name
//
WCHAR MachineName[MAX_PATH];
WCHAR DomainName[MAX_PATH];
WCHAR DomainNameDns[MAX_PATH];
WCHAR LastMachineName[MAX_PATH];
WCHAR LastDomainName[MAX_PATH];
WCHAR SiteName[MAX_PATH];
CRITICAL_SECTION DomListCritSection;

//
// Our role in life (see dsrole.h)
//
DSROLE_MACHINE_ROLE     DfsMachineRole;

//
// Type of dfs (FtDfs==DFS_MANAGER_FTDFS/Machine-based==DFS_MANAGER_SERVER)
//
ULONG DfsServerType = 0;

//
// Long-lived ldap handle to the ds on this machine, if it is a DC
//
PLDAP pLdap = NULL;

GUID DfsRtlTraceGuid = { // 79d1da1f-7268-441b-b835-7c7bed5ab39e
    0x79d1da1f, 0x7268, 0x441b, 
    {0xb8, 0x35, 0x7c, 0x7b, 0xed, 0x5a, 0xb3, 0x9e}};


extern void DfsInitWml();


//+----------------------------------------------------------------------------
//
//  Function:  WinMain
//
//  Synopsis:  This guy will set up link to service manager and install
//             ServiceMain as the service's entry point. Hopefully, the service
//             control dispatcher will call ServiceMain soon thereafter.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

int PASCAL WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance,
                   LPSTR lpszCmdLine,
                   int nCmdShow)
{
    SERVICE_TABLE_ENTRYW        aServiceEntry[2];
    DWORD status;


    if (_stricmp( lpszCmdLine, "-noservice" ) == 0) {

        fStartAsService = FALSE;

        StartDfsService( 0, NULL );

        //
        // Since we were not started as a service, we wait for ever...
        //

        Sleep( INFINITE );

    } else {

        fStartAsService = TRUE;

        aServiceEntry[0].lpServiceName = wszDfsServiceName;
        aServiceEntry[0].lpServiceProc = StartDfsService;
        aServiceEntry[1].lpServiceName = NULL;
        aServiceEntry[1].lpServiceProc = NULL;

        svc_debug_trace("Starting Dfs Services...\n", 0);

        if (!StartServiceCtrlDispatcherW(aServiceEntry)) {
            svc_debug_error("Error %d starting as service!\n", GetLastError());
            return(GetLastError());
        }

    }

    //
    // If the StartServiceCtrlDispatcher call succeeded, we will never get to
    // this point until someone stops this service.
    //

    return(0);

}


//+----------------------------------------------------------------------------
//
//  Function:   StartDfsService
//
//  Synopsis:   Call back for DfsService service. This is called *once* by the
//              Service controller when the DfsService service is to be inited
//              This function is responsible for registering a message
//              handler function for the DfsService service.
//
//  Arguments:  Unused
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
StartDfsService(DWORD dwNumServiceArgs, LPWSTR *lpServiceArgs)
{
    HANDLE hInit;
    DWORD dwErr;
    DWORD idThread;
    HKEY hkey;
    PSECURITY_ATTRIBUTES    pSecAttribs = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pPrimaryDomainInfo;
    ULONG CheckPoint = 0;

#if (DBG == 1) || (_CT_TEST_HOOK == 1)
    SECURITY_DESCRIPTOR SD;
    SECURITY_ATTRIBUTES SA;
    BOOL    fRC = InitializeSecurityDescriptor(
                        &SD,
                        SECURITY_DESCRIPTOR_REVISION);

    if( fRC == TRUE ) {

        fRC = SetSecurityDescriptorDacl(
                    &SD,
                    TRUE,
                    NULL,
                    FALSE);

    }

    SA.nLength              = sizeof(SECURITY_ATTRIBUTES);
    SA.lpSecurityDescriptor = &SD;
    SA.bInheritHandle       = FALSE;
    pSecAttribs             = &SA;

#endif

    svc_debug_trace("StartDfsService: fStartAsService = %d\n", fStartAsService);

    if (fStartAsService) {

        hDfsService = RegisterServiceCtrlHandlerW(
                            wszDfsServiceName,
                            DfsSvcMsgProc);
        if (!hDfsService) {
            svc_debug_error("Error %d installing Dfs msg handler\n", GetLastError());
            return;
        }

        DfsStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
        DfsStatus.dwCurrentState = SERVICE_STOPPED;
        DfsStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
        DfsStatus.dwWin32ExitCode = 0;
        DfsStatus.dwServiceSpecificExitCode = 0;
        DfsStatus.dwCheckPoint = CheckPoint++;
        DfsStatus.dwWaitHint = 1000 * 30;

        svc_debug_trace("Updating Status to Start Pending...\n", 0);
        UpdateStatus(hDfsService, &DfsStatus, SERVICE_START_PENDING);

    }

    //
    // Remove any old exit pt info from the registry
    //

    DfsCleanLocalVols();

    InitializeCriticalSection(&DomListCritSection);

    //
    // Get our machine name and type/role.
    //


    dwErr = DsRoleGetPrimaryDomainInformation(
                NULL,
                DsRolePrimaryDomainInfoBasic,
                (PBYTE *)&pPrimaryDomainInfo);

    if (dwErr == ERROR_SUCCESS) {

        DfsMachineRole = pPrimaryDomainInfo->MachineRole;

        DomainName[0] = LastDomainName[0] = L'\0';

        DomainNameDns[0] = L'\0';

        if (pPrimaryDomainInfo->DomainNameFlat != NULL) {

            if (wcslen(pPrimaryDomainInfo->DomainNameFlat) < MAX_PATH) {

                wcscpy(DomainName,pPrimaryDomainInfo->DomainNameFlat);
                wcscpy(LastDomainName, DomainName);

            } else {

                dwErr = ERROR_NOT_ENOUGH_MEMORY;

            }

        }

        if (pPrimaryDomainInfo->DomainNameDns != NULL) {

            if (wcslen(pPrimaryDomainInfo->DomainNameDns) < MAX_PATH) {

                wcscpy(DomainNameDns,pPrimaryDomainInfo->DomainNameDns);

            } else {

                dwErr = ERROR_NOT_ENOUGH_MEMORY;

            }

        }

        DsRoleFreeMemory(pPrimaryDomainInfo);

    }

    if (dwErr != ERROR_SUCCESS) {
        svc_debug_error("StartDfsService:DsRoleGetPrimaryDomainInformation %08lx!\n", dwErr);
        DfsStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
        DfsStatus.dwServiceSpecificExitCode = dwErr;
        DfsStatus.dwCheckPoint = 0;
        UpdateStatus(hDfsService, &DfsStatus, SERVICE_STOPPED);
        return;
    }

    //
    // Create a thread to finish initialization
    //

    hInit = CreateThread(
                NULL,                            // Security attributes
                0,                               // Use default stack size
                DfsInitializationLoop,           // Thread entry procedure
                0,                               // Thread context parameter
                0,                               // Start immediately
                &idThread);                      // Thread ID

    if (hInit == NULL) {
        svc_debug_error(
            "Unable to create Driver Init thread %08lx\n", GetLastError());
        DfsStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
        DfsStatus.dwServiceSpecificExitCode = GetLastError();
        DfsStatus.dwCheckPoint = 0;
        UpdateStatus(hDfsService, &DfsStatus, SERVICE_STOPPED);
        return;
    }
    else {  
        // 428812: no need to keep the handle around. prevent thread leak.
        CloseHandle( hInit );
    }

    DfsStatus.dwCheckPoint = CheckPoint++;
    UpdateStatus(hDfsService, &DfsStatus, SERVICE_RUNNING);
    return;

}

DWORD
DfsInitializationLoop(
    LPVOID lpThreadParams)
{
    HANDLE hLPC;
    DWORD idLpcThread;
    HANDLE hDfs;
    ULONG Retry;
    DWORD dwErr;
    NTSTATUS Status;

    Retry = 0;


    DfsInitWml();
    do {

        dwErr = DfsManagerProc();

    } while (dwErr != ERROR_SUCCESS && ++Retry < 10);

    if (dwErr != ERROR_SUCCESS) {
        svc_debug_error("Dfs Manager failed %08lx!\n", dwErr);
    }

    switch (DfsMachineRole) {

    case DsRole_RoleBackupDomainController:
    case DsRole_RolePrimaryDomainController:


        //
        // Init the special name table
        //

        Retry = 0;
        DfsInitDomainList();

        do {

            Status = DfsInitOurDomainDCs();

            if (Status != ERROR_SUCCESS) {

                Sleep(10*1000);

            }

        } while (Status != ERROR_SUCCESS && ++Retry < 10);

        DfsInitRemainingDomainDCs();

        pLdap = ldap_init(L"LocalHost", LDAP_PORT);

        if (pLdap != NULL) {
	    
	    dwErr = ldap_set_option(pLdap, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);
	    
	    if (dwErr != LDAP_SUCCESS) {
		pLdap = NULL;
	    } else {

		dwErr = ldap_bind_s(pLdap, NULL, NULL, LDAP_AUTH_SSPI);

		if (dwErr != ERROR_SUCCESS) {

		    svc_debug_error("Could not bind to LocalHost\n", 0);
		    pLdap = NULL;
		}
	    }
        } else {

            svc_debug_error("Could not open LocalHost\n", 0);

        }

        /* Fall THRU */

    case DsRole_RoleMemberServer:

        //
        // Start the dfs lpc server
        //

        hLPC = CreateThread(
                    NULL,                                    // Security attributes
                    0,                                       // Use default stack size
                    (LPTHREAD_START_ROUTINE)DfsStartDfssrv,  // Thread entry procedure
                    0,                                       // Thread context parameter
                    0,                                       // Start immediately
                    &idLpcThread);                           // Thread ID

        if (hLPC == NULL) {
            svc_debug_error(
                "Unable to create Driver LPC thread %08lx\n", GetLastError());
        }
        else {
            CloseHandle(hLPC);
        }


    }

    Status = DfsOpen( &hDfs, NULL );

    if (NT_SUCCESS(Status)) {

        switch (DfsMachineRole) {

        case DsRole_RoleBackupDomainController:
        case DsRole_RolePrimaryDomainController:

            Status = DfsFsctl(
                        hDfs,
                        FSCTL_DFS_ISDC,
                        NULL,
                        0L,
                        NULL,
                        0L);

        }

        NtClose( hDfs );

    } else {

        svc_debug_error("Unable to open dfs driver %08lx\n", Status);
        svc_debug_error("UNC names will not work!\n", 0);

    }
 
    switch (DfsMachineRole) {

    case DsRole_RoleBackupDomainController:
    case DsRole_RolePrimaryDomainController:

        do {

            Status = DfsInitRemainingDomainDCs();

            if (Status != ERROR_SUCCESS) {

                Sleep(1000 * 60 * 10);  // 10 min

            }

        } while (Status != ERROR_SUCCESS && ++Retry < 100);
        
        
        do {

            Sleep(1000 * 60 * 15);  // 15 min
            DfsInitDomainList();
            DfsInitOurDomainDCs();
            DfsInitRemainingDomainDCs();

        } while (TRUE);

    }

    return 0;

}


//+----------------------------------------------------------------------------
//
//  Function:  DfsSvcMsgProc
//
//  Synopsis:  Service-Message handler for DFSInit.
//
//  Arguments: [dwControl] - the message
//
//  Returns:   nothing
//
//-----------------------------------------------------------------------------

VOID
DfsSvcMsgProc(DWORD dwControl)
{
    NTSTATUS Status;
    HANDLE hDfs;

    switch(dwControl) {

    case SERVICE_CONTROL_STOP:

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("DfsSvcMsgProc(SERVICE_CONTROL_STOP)\n");
#endif
        //
        // Stop the driver
        //

        Status = DfsOpen( &hDfs, NULL );

        if (NT_SUCCESS(Status)) {

            Status = DfsFsctl(
                        hDfs,
                        FSCTL_DFS_STOP_DFS,
                        NULL,
                        0L,
                        NULL,
                        0L);

            svc_debug_trace("Fsctl STOP_DFS returned %08lx\n", Status);

            Status = DfsFsctl(
                        hDfs,
                        FSCTL_DFS_RESET_PKT,
                        NULL,
                        0L,
                        NULL,
                        0L);

            svc_debug_trace("Fsctl FSCTL_DFS_RESET_PKT returned %08lx\n", Status);

            NtClose( hDfs );

        }

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("DfsSvcMsgProc: calling DfsStopDfssvc\n");
#endif

        DfsStopDfssrv();

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("DfsSvcMsgProc: DfsStopDfssvc returned\n");
#endif

        UpdateStatus(hDfsService, &DfsStatus, SERVICE_STOPPED);
        break;

    case SERVICE_INTERROGATE:

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("DfsSvcMsgProc(SERVICE_INTERROGATE)\n");
#endif
        //
        // We don't seem to be called with SERVICE_INTERROGATE ever!
        //
        if (DfsStatus.dwCurrentState == SERVICE_START_PENDING &&
            DfsStatus.dwCheckPoint < MAX_HINT_PERIODS) {

            DfsStatus.dwCheckPoint++;
            svc_debug_trace("DFSInit Checkpoint == %d\n", DfsStatus.dwCheckPoint);

            UpdateStatus(hDfsService, &DfsStatus, SERVICE_START_PENDING);

        } else {

            DfsStatus.dwCheckPoint = 0;
            UpdateStatus(hDfsService, &DfsStatus, DfsStatus.dwCurrentState);

        }
        break;

    default:
        break;
    }

}


//+----------------------------------------------------------------------------
//
//  Function:  UpdateStatus
//
//  Synopsis:  Pushes a ServiceStatus to the service manager.
//
//  Arguments: [hService] - handle returned from RegisterServiceCtrlHandler
//             [pSStatus] - pointer to service-status block
//             [Status] -   The status to set.
//
//  Returns:   Nothing.
//
//-----------------------------------------------------------------------------

static void
UpdateStatus(SERVICE_STATUS_HANDLE hService, SERVICE_STATUS *pSStatus, DWORD Status)
{
    if (fStartAsService) {

        pSStatus->dwCurrentState = Status;

        if (Status == SERVICE_START_PENDING) {
            pSStatus->dwCheckPoint++;
            pSStatus->dwWaitHint = 1000;
        } else {
            pSStatus->dwCheckPoint = 0;
            pSStatus->dwWaitHint = 0;
        }

        SetServiceStatus(hService, pSStatus);

    }
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsManagerIsDomainDfsEnabled
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOL
DfsManagerIsDomainDfsEnabled()
{
    DWORD dwErr;
    HKEY hkey;

    dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, REG_KEY_ENABLE_DOMAIN_DFS, &hkey);

    if (dwErr == ERROR_SUCCESS) {

        RegCloseKey( hkey );

        return( TRUE );

    } else {

        return( FALSE );

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsIsThisADfsRoot
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOL
DfsIsThisADfsRoot()
{
    DWORD dwErr;
    HKEY hkey;

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, VOLUMES_DIR, &hkey );

    if (dwErr == ERROR_SUCCESS) {

        RegCloseKey( hkey );

        return( TRUE );

    }

    return( FALSE );

}


//+----------------------------------------------------------------------------
//
//  Function:  DfsManagerProc
//
//  Synopsis:  The Dfs Manager side implementation of Dfs Service.
//
//  Arguments: None
//
//  Returns:   TRUE if everything went ok, FALSE otherwise
//
//-----------------------------------------------------------------------------

DWORD
DfsManagerProc()
{
    DWORD dwErr;
    PWKSTA_INFO_100 wkstaInfo = NULL;
    HKEY hkey;
    WCHAR wszFTDfsName[ MAX_PATH ];
    DWORD cbName, dwType;
    BOOLEAN fIsFTDfs = FALSE;

    //
    // Get our Machine name
    //

    dwErr = NetWkstaGetInfo( NULL, 100, (LPBYTE *) &wkstaInfo );

    if (dwErr == ERROR_SUCCESS) {

        if (wcslen(wkstaInfo->wki100_computername) < MAX_PATH) {

            wcscpy(MachineName,wkstaInfo->wki100_computername);
            wcscpy(LastMachineName, MachineName);

        } else {

            dwErr = ERROR_NOT_ENOUGH_MEMORY;

        }

        NetApiBufferFree( wkstaInfo );

    }

    if (dwErr != ERROR_SUCCESS) {
        svc_debug_error("DfsManagerProc:NetWkstaGetInfo %08lx!\n", dwErr);
    }

    //
    // Check VOLUMES_DIR, if it exists, get machine and domain name, and determine
    // if this is an FtDfs participant
    //

    if (dwErr == ERROR_SUCCESS) {

        dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, VOLUMES_DIR, &hkey );

        if (dwErr == ERROR_SUCCESS) {

            cbName = sizeof(LastMachineName);

            dwErr = RegQueryValueEx(
                        hkey,
                        MACHINE_VALUE_NAME,
                        NULL,
                        &dwType,
                        (PBYTE) LastMachineName,
                        &cbName);

            if (dwErr != ERROR_SUCCESS) {

                dwErr = RegSetValueEx(
                            hkey,
                            MACHINE_VALUE_NAME,
                            0,
                            REG_SZ,
                            (PCHAR)MachineName,
                            wcslen(MachineName) * sizeof(WCHAR));

            } else if (dwType != REG_SZ) {

                LastMachineName[0] = L'\0';

            }

            cbName = sizeof(LastDomainName);

            dwErr = RegQueryValueEx(
                        hkey,
                        DOMAIN_VALUE_NAME,
                        NULL,
                        &dwType,
                        (PBYTE) LastDomainName,
                        &cbName);

            if (dwErr != ERROR_SUCCESS) {

                dwErr = RegSetValueEx(
                            hkey,
                            DOMAIN_VALUE_NAME,
                            0,
                            REG_SZ,
                            (PCHAR)DomainName,
                            wcslen(DomainName) * sizeof(WCHAR));

            } else if (dwType != REG_SZ) {

                LastDomainName[0] = L'\0';

            }

            //
            // See if this is a Fault-Tolerant Dfs vs Server-Based Dfs
            //

            cbName = sizeof(wszFTDfsName);

            dwErr = RegQueryValueEx(
                        hkey,
                        FTDFS_VALUE_NAME,
                        NULL,
                        &dwType,
                        (PBYTE) wszFTDfsName,
                        &cbName);

            if ((dwErr == ERROR_SUCCESS) && (dwType == REG_SZ)) {

                fIsFTDfs = TRUE;

            }

            RegCloseKey( hkey );

        }

        dwErr = ERROR_SUCCESS;

    }


    //
    // Now we check if the machine role is appropriate
    //

    if (dwErr == ERROR_SUCCESS) {

        switch(DfsMachineRole) {

        //
        // Somehow we were started on a workstation
        //
        case DsRole_RoleStandaloneWorkstation:
        case DsRole_RoleMemberWorkstation:
            dwErr = ERROR_NOT_SUPPORTED;
            break;

        //
        // We can run, but not in FtDFS mode,
        //
        // If the domain name has changed, clean up the registry.
        //
        case DsRole_RoleStandaloneServer:
            if (fIsFTDfs == TRUE || _wcsicmp(DomainName, LastDomainName) != 0) {
                fIsFTDfs = FALSE;
            }
            break;

        //
        // Fully supported modes
        //
        case DsRole_RoleMemberServer:
        case DsRole_RoleBackupDomainController:
        case DsRole_RolePrimaryDomainController:
            break;

        }

    }


    if (dwErr == ERROR_SUCCESS) {

        if (fIsFTDfs) {

            dwErr =  DfsManager(
                        wszFTDfsName,
                        DFS_MANAGER_FTDFS );

        } else {

            dwErr = DfsManager(
                        MachineName,
                        DFS_MANAGER_SERVER );

        }

    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:  DfsCleanLocalVols
//
//  Synopsis:  Cleans out the LocalVolumes part of the registry, if there are
//              dfs-link keys left over from older versions.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
DfsCleanLocalVols(void)
{
    HKEY hLvolKey = NULL;
    HKEY hRootKey = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    PWCHAR wCp;

    wCp = malloc(4096);
    if (wCp == NULL) {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, REG_KEY_LOCAL_VOLUMES, &hLvolKey);
    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Find the key representing the root
    //
    dwErr = RegEnumKey(hLvolKey, 0, wCp, 100);
    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    dwErr = RegOpenKey(hLvolKey, wCp, &hRootKey);
    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    while (dwErr == ERROR_SUCCESS && RegEnumKey(hRootKey, 0, wCp, 100) == ERROR_SUCCESS)
        dwErr = DfsDeleteChildKeys(hRootKey, wCp);

Cleanup:

    if (hLvolKey != NULL)
        RegCloseKey(hLvolKey);

    if (hRootKey != NULL)
        RegCloseKey(hRootKey);

    if (wCp != NULL)
        free(wCp);

    return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:  DfsRegDeleteChildKeys
//
//  Synopsis:  Helper for DfsRegDeleteKeyAndChildren
//
//  Arguments:
//
//  Returns:   ERROR_SUCCESS or failure code
//
//-----------------------------------------------------------------------------

DWORD
DfsDeleteChildKeys(HKEY hKey, LPWSTR s)
{
    WCHAR *wCp;
    HKEY nKey = NULL;
    DWORD dwErr;
    DWORD i = 0;

    dwErr = RegOpenKey(hKey, s, &nKey);
    if (dwErr != ERROR_SUCCESS)
        return dwErr;

    for (wCp = s; *wCp; wCp++)
            ;
    while (dwErr == ERROR_SUCCESS && RegEnumKey(nKey, 0, wCp, 100) == ERROR_SUCCESS)
        dwErr = DfsDeleteChildKeys(nKey, wCp);

    *wCp = L'\0';
    if (nKey != NULL)
        RegCloseKey(nKey);

    dwErr = RegDeleteKey(hKey, s);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\dcfsctl.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1995, Microsoft Corporation
//
//  File:       dcfsctl.c
//
//  Contents:   This file has all the fsctrl routines that typically execute
//              on a DC.
//
//  Classes:
//
//  Functions:  DfsFsctrlDCSetVolumeState -
//              DfsFsctrlDCSetVolumeState -
//              DfsFsctrlSetServiceState -
//              DfsFsctrlGetServerInfo -
//              DfsFsctrlCheckStgIdInUse -
//
//              DfspGetServerConfigInfo -
//              IsPathAPrefixOf -
//
//
//  History:    April 5, 1995           Milans created
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include <dfserr.h>
#include <netevent.h>
#include "fsctrl.h"
#include "log.h"

NTSTATUS
DfspGetServerConfigInfo(
    IN GUID *pMachine,
    IN PDFS_PKT pPkt,
    IN PDFS_PKT_ENTRY pPktEntry,
    OUT PDFS_LOCAL_VOLUME_CONFIG pConfigInfo);

BOOLEAN
IsPathAPrefixOf(
    IN PUNICODE_STRING pustrPath1,
    IN PUNICODE_STRING pustrPath2);

#pragma alloc_text( PAGE, DfsFsctrlDCSetVolumeState )
#pragma alloc_text( PAGE, DfsFsctrlSetVolumeTimeout )
#pragma alloc_text( PAGE, DfsFsctrlSetServiceState )
#pragma alloc_text( PAGE, DfsFsctrlGetServerInfo )
#pragma alloc_text( PAGE, DfsFsctrlCheckStgIdInUse )

#pragma alloc_text( PAGE, DfspGetServerConfigInfo )
#pragma alloc_text( PAGE, IsPathAPrefixOf )

#define Dbg             (DEBUG_TRACE_LOCALVOL)


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlDCSetVolumeState, public
//
//  Synopsis:   Marks the specified replica offline for the particular volume
//
//  Arguments:  [Irp]
//
//              [InputBuffer] -- Marshalled DFS_SETSTATE_ARG structure
//                      that specifies the volume and the state to set it to.
//
//              [InputBufferLength] -- Length in bytes of InputBuffer
//
//  Returns:    [STATUS_SUCCESS] -- The specified replica was set
//                      online/offline as speficied.
//
//              [DFS_STATUS_NO_SUCH_ENTRY] -- The specified volume was not
//                      found.
//
//              [STATUS_DATA_ERROR] -- The InputBuffer could not be
//                      correctly unmarshalled.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory situation.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlDCSetVolumeState(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength)
{
    NTSTATUS                    status;
    MARSHAL_BUFFER              marshalBuffer;
    DFS_SETSTATE_ARG            setStateArg;
    PDFS_PKT                    pkt;
    PDFS_PKT_ENTRY              pktEntry;

    STD_FSCTRL_PROLOGUE(DfsFsctrlDCSetVolumeState, TRUE, FALSE);

    MarshalBufferInitialize( &marshalBuffer, InputBufferLength, InputBuffer );

    status = DfsRtlGet(
                &marshalBuffer,
                &MiSetStateArg,
                &setStateArg);

    if (NT_SUCCESS(status)) {

        DebugTrace(
            0, Dbg, "Setting volume state for %[wZ]\n",
            &setStateArg.Id.Prefix);

        pkt = _GetPkt();

        PktAcquireShared( pkt, TRUE );

        pktEntry = PktLookupEntryById( pkt, &setStateArg.Id );

        if (pktEntry != NULL) {

            if (setStateArg.Type == PKT_ENTRY_TYPE_OFFLINE) {

                pktEntry->Type |= PKT_ENTRY_TYPE_OFFLINE;

            } else {

                pktEntry->Type &= ~PKT_ENTRY_TYPE_OFFLINE;

            }

            status = STATUS_SUCCESS;

        } else {

            DebugTrace(0, Dbg, "Unable to find PKT Entry!\n", 0);

            status = DFS_STATUS_NO_SUCH_ENTRY;

        }

        PktRelease( pkt );

        PktEntryIdDestroy(&setStateArg.Id, FALSE);

    }

    DebugTrace(-1, Dbg, "DfsFsctrlDCSetVolumeState: Exit %08lx\n", ULongToPtr( status ));

    DfsCompleteRequest( Irp, status );

    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlSetServiceState, public
//
//  Synopsis:   Marks the specified replica offline for the particular volume
//
//  Arguments:  [Irp]
//
//              [InputBuffer] -- Marshalled DFS_DC_SET_REPLICA_STATE structure
//                      that specifies the volume and the replica to be set
//                      offline/online.
//
//              [InputBufferLength] -- Length in bytes of InputBuffer
//
//  Returns:    [STATUS_SUCCESS] -- The specified replica was set
//                      online/offline as speficied.
//
//              [DFS_STATUS_NO_SUCH_ENTRY] -- The specified volume was not
//                      found, or the specified replica is not a server for
//                      the volume.
//
//              [STATUS_DATA_ERROR] -- The InputBuffer could not be
//                      correctly unmarshalled.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory situation.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlSetServiceState(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength)
{
    NTSTATUS                    status;
    MARSHAL_BUFFER              marshalBuffer;
    DFS_DC_SET_SERVICE_STATE    setSvcState;
    PDFS_PKT                    pkt;
    PDFS_PKT_ENTRY              pktEntry;

    STD_FSCTRL_PROLOGUE(DfsFsctrlSetServiceState, TRUE, FALSE);

    MarshalBufferInitialize( &marshalBuffer, InputBufferLength, InputBuffer );

    status = DfsRtlGet(
                &marshalBuffer,
                &MiDCSetServiceState,
                &setSvcState);

    if (NT_SUCCESS(status)) {

        DebugTrace(
            0, Dbg, "Setting service state for [%wZ]\n",
            &setSvcState.Id.Prefix);

        DebugTrace(
            0, Dbg, "For Service [%wZ]\n", &setSvcState.ServiceName);

        pkt = _GetPkt();

        PktAcquireShared( pkt, TRUE );

        pktEntry = PktLookupEntryById( pkt, &setSvcState.Id );

        if (pktEntry != NULL) {

            PDFS_SERVICE pSvc;
            ULONG i, cSvc;

            status = DFS_STATUS_NO_SUCH_ENTRY;

            for (i = 0, cSvc = pktEntry->Info.ServiceCount;
                    i < cSvc && status != STATUS_SUCCESS;
                        i++) {

                 pSvc = &pktEntry->Info.ServiceList[i];

                 if (RtlEqualUnicodeString(
                        &setSvcState.ServiceName, &pSvc->Name, TRUE)) {

                     DebugTrace(0, Dbg, "Found Svc @ %08lx\n", pSvc );

                     if (setSvcState.State == DFS_SERVICE_TYPE_OFFLINE) {

                         pSvc->Type |= DFS_SERVICE_TYPE_OFFLINE;

                     } else {

                         pSvc->Type &= ~DFS_SERVICE_TYPE_OFFLINE;

                     }

                     status = STATUS_SUCCESS;

                 }

            } // For each service

        } else {

            DebugTrace(0, Dbg, "Unable to find PKT Entry!\n", 0);

            status = DFS_STATUS_NO_SUCH_ENTRY;

        }

        PktRelease( pkt );

        //
        // Free up the unmarshalled arguments
        //

        PktEntryIdDestroy(&setSvcState.Id, FALSE);
        MarshalBufferFree( setSvcState.ServiceName.Buffer );

    }

    DebugTrace(-1, Dbg, "DfsFsctrlSetServiceState: Exit %08lx\n", ULongToPtr( status ));

    DfsCompleteRequest( Irp, status );

    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlSetVolumeTimeout, public
//
//  Synopsis:   Sets the specified volume's referral timeout
//
//  Arguments:  [Irp]
//
//              [InputBuffer] -- Marshalled DFS_SET_VOLUME_TIMEOUT_ARG structure
//                      that specifies the volume and the timeout to associate
//                      with the volume.
//
//              [InputBufferLength] -- Length in bytes of InputBuffer
//
//  Returns:    [STATUS_SUCCESS] -- The specified timeout was set.
//
//              [DFS_STATUS_NO_SUCH_ENTRY] -- The specified volume was not
//                      found.
//
//              [STATUS_DATA_ERROR] -- The InputBuffer could not be
//                      correctly unmarshalled.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory situation.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlSetVolumeTimeout(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength)
{
    NTSTATUS                    status;
    MARSHAL_BUFFER              marshalBuffer;
    DFS_SET_VOLUME_TIMEOUT_ARG  setVolTimeoutArg;
    PDFS_PKT                    pkt;
    PDFS_PKT_ENTRY              pktEntry;

    STD_FSCTRL_PROLOGUE(DfsFsctrlSetVolumeTimeout, TRUE, FALSE);

    MarshalBufferInitialize( &marshalBuffer, InputBufferLength, InputBuffer );

    status = DfsRtlGet(
                &marshalBuffer,
                &MiSetVolTimeoutArg,
                &setVolTimeoutArg);

    if (NT_SUCCESS(status)) {

        DebugTrace(
            0, Dbg, "Setting volume timeout for %[wZ]\n",
            &setVolTimeoutArg.Id.Prefix);

        pkt = _GetPkt();

        PktAcquireShared( pkt, TRUE );

        pktEntry = PktLookupEntryById( pkt, &setVolTimeoutArg.Id );

        if (pktEntry != NULL) {

            pktEntry->Info.Timeout = setVolTimeoutArg.Timeout;

            status = STATUS_SUCCESS;

        } else {

            DebugTrace(0, Dbg, "Unable to find PKT Entry!\n", 0);

            status = DFS_STATUS_NO_SUCH_ENTRY;

        }

        PktRelease( pkt );

        //
        // Free the unmarshalled input arguments
        //

        PktEntryIdDestroy(&setVolTimeoutArg.Id, FALSE);

    }

    DebugTrace(-1, Dbg, "DfsFsctrlSetVolumeTimeout: Exit %08lx\n", ULongToPtr( status ));

    DfsCompleteRequest( Irp, status );

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlGetServerInfo
//
//  Synopsis:   Given the machine guid of a server, this routine will return
//              the entire local volume knowledge that a dfs server should
//              have. This routine is intended to be called on the DC only.
//
//  Arguments:
//
//  Returns:    [STATUS_SUCCESS] -- The info is successfully returned.
//
//              [STATUS_BUFFER_OVERFLOW] -- The output buffer is too small.
//                      The needed size is returned in the first 4 bytes of
//                      this buffer.
//
//              [STATUS_DATA_ERROR] -- The input buffer could not be
//                      unmarshalled
//
//              [STATUS_BUFFER_TOO_SMALL] -- The output buffer is < 4 bytes.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory condition
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlGetServerInfo(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength)
{
    NTSTATUS Status, MarshalStatus;
    PDFS_PKT pPkt;
    PDFS_PKT_ENTRY pPktEntry;
    MARSHAL_BUFFER marshalBuffer;
    DFS_PKT_ENTRY_ID EntryId;
    DFS_LOCAL_VOLUME_CONFIG ConfigInfo;
    ULONG i, cInfo, cbBuffer;

    STD_FSCTRL_PROLOGUE(DfsFsctrlGetServerInfo, TRUE, FALSE);

    pPkt = _GetPkt();

    //
    // Get the input arguments
    //

    MarshalBufferInitialize( &marshalBuffer, InputBufferLength, InputBuffer );

    Status = DfsRtlGet( &marshalBuffer, &MiPktEntryId, &EntryId );

    if (NT_SUCCESS(Status)) {

        DebugTrace(0, Dbg,
            "Getting Server Info for server [%wZ]\n", &EntryId.Prefix);

        MarshalBufferInitialize(
            &marshalBuffer,
            OutputBufferLength,
            OutputBuffer );

        //
        // We'll marshal in a count of 0 at the beginning of the output
        // buffer. Later, we'll revisit this and put in the actual count of
        // relation info's.
        //

        cInfo = 0;

        MarshalStatus = DfsRtlPutUlong( &marshalBuffer, &cInfo );

        cbBuffer = sizeof(ULONG);

        //
        // For each Pkt entry, create and marshal a relation info if the
        // Dfs volume is a local volume for the server.
        //

        PktAcquireShared( pPkt, TRUE );

        pPktEntry =
            CONTAINING_RECORD(pPkt->EntryList.Flink, DFS_PKT_ENTRY, Link);

        for (i = 0; i < pPkt->EntryCount && NT_SUCCESS(Status); i++) {

            Status = DfspGetServerConfigInfo(
                        &EntryId.Uid,
                        pPkt,
                        pPktEntry,
                        &ConfigInfo);

            if (NT_SUCCESS(Status)) {

                DebugTrace(0, Dbg, "Found [%wZ]\n", &pPktEntry->Id.Prefix);

                Status = DfsRtlSize( &MiLocalVolumeConfig, &ConfigInfo, &cbBuffer);

                if (NT_SUCCESS(Status) && NT_SUCCESS(MarshalStatus)) {

                    MarshalStatus = DfsRtlPut(
                                        &marshalBuffer,
                                        &MiLocalVolumeConfig,
                                        &ConfigInfo);

                    cInfo++;

                }

                LocalVolumeConfigInfoDestroy( &ConfigInfo, FALSE );

            } else if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

                //
                // Means volume is not local to server - go on to the next
                // Pkt Entry
                //

                Status = STATUS_SUCCESS;

            } else if (Status == STATUS_OBJECT_TYPE_MISMATCH) {

                //
                // Means volume is a Machine, Domain, or Orgroot volume -
                // we ignore it.
                //

                Status = STATUS_SUCCESS;

            } else {

                DebugTrace(0, Dbg,
                    "Error %08lx constructing relation info!\n", ULongToPtr( Status ));

            }

            pPktEntry =
                CONTAINING_RECORD(pPktEntry->Link.Flink, DFS_PKT_ENTRY, Link);

        } // End for each Pkt Entry

        PktRelease( pPkt );

        //
        // Free the unmarshalled input arguments
        //

        PktEntryIdDestroy(&EntryId, FALSE);

    } else {

        DebugTrace( 0, Dbg, "Error %08lx unmarshalling input\n", ULongToPtr( Status ));

    }

    if (NT_SUCCESS(Status)) {

        if (NT_SUCCESS(MarshalStatus)) {

            //
            // Everything went successfully - Marshal in the number of
            // relation info's we are returning at the beginning of the
            // output buffer
            //

            MarshalBufferInitialize(
                &marshalBuffer,
                OutputBufferLength,
                OutputBuffer);

            Status = DfsRtlPutUlong( &marshalBuffer, &cInfo );

            ASSERT( NT_SUCCESS(Status) );

            ASSERT( cbBuffer <= OutputBufferLength );

            Irp->IoStatus.Information = cbBuffer;

        } else {

            //
            // If we hit a marshalling error along the way, we'll try and
            // tell the caller how much buffer we need
            //

            RETURN_BUFFER_SIZE( cbBuffer, Status );

        }

    }

    DfsCompleteRequest( Irp, Status );

    DebugTrace(-1, Dbg, "DfsFsctrlGetServerInfo: returning %08lx\n", ULongToPtr( Status ));

    return Status;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlCheckStgIdInUse
//
//  Synopsis:   Given a storage id and the machine guid of a server, this
//              routine will say whether the storage id can be legally shared
//              by the server. This routine is intended to be called on the
//              DC only.
//
//  Arguments:
//
//  Returns:    [STATUS_SUCCESS] -- It is legal for the server to share the
//                      storage id.
//
//              [STATUS_DEVICE_BUSY] -- Some parent or child of the
//                      storage id is already shared in Dfs. The shared
//                      volume is returned in OutputBuffer.
//
//              [STATUS_BUFFER_OVERFLOW] -- OutputBuffer too small to return
//                      prefix of shared volume - the required size is
//                      returned in the first 4 bytes of OutputBuffer
//
//              [STATUS_BUFFER_TOO_SMALL] -- OutputBuffer is < 4 bytes.
//
//              [STATUS_DATA_ERROR] -- Unable to unmarshall the arguments.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Unable to unmarshall the
//                      arguments.
//
//  Notes:      The Input buffer is a marshalled PKT_ENTRY_ID, where the
//              GUID is the server's machine id, and the Prefix is the
//              storage id to be verified.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlCheckStgIdInUse(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength)
{
    NTSTATUS Status = STATUS_SUCCESS;            // Innocent till proven...
    PDFS_PKT pPkt;
    PDFS_PKT_ENTRY pPktEntry;
    MARSHAL_BUFFER marshalBuffer;
    DFS_PKT_ENTRY_ID EntryId;
    ULONG i;

    STD_FSCTRL_PROLOGUE(DfsFsctrlIsStgIdLegalOnServer, TRUE, FALSE);

    MarshalBufferInitialize( &marshalBuffer, InputBufferLength, InputBuffer );

    Status = DfsRtlGet( &marshalBuffer, &MiPktEntryId, &EntryId );

    if (NT_SUCCESS(Status)) {

        DebugTrace(0, Dbg, "Verifying Storage Id [%wZ]\n", &EntryId.Prefix );

        pPkt = _GetPkt();

        pPktEntry =
            CONTAINING_RECORD(pPkt->EntryList.Flink, DFS_PKT_ENTRY, Link);

        for (i = 0; i < pPkt->EntryCount && NT_SUCCESS(Status); i++) {

            //
            // For every pkt entry, we iterate through all the services. If a
            // service matches the input service, then we see if the storage
            // id is a prefix or child of the service's storage id. If so,
            // the storage id is not legal.
            //

            ULONG j;

            for (j = 0;
                    j < pPktEntry->Info.ServiceCount && NT_SUCCESS(Status);
                        j++) {

                PDFS_SERVICE pService = &pPktEntry->Info.ServiceList[j];

                if ( GuidEqual( &pService->pMachEntry->pMachine->guidMachine,
                                &EntryId.Uid ) ) {


                    if (IsPathAPrefixOf(
                            &EntryId.Prefix,
                            &pService->StgId ) ||
                        IsPathAPrefixOf(
                            &pService->StgId,
                            &EntryId.Prefix )) {

                        DebugTrace(0, Dbg,
                            "Stg Id Not legal - Conflicts with [%wZ]\n",
                            &pPktEntry->Id.Prefix);

                        DebugTrace(0, Dbg,
                            "Storage Id for share is [%wZ]\n",
                            &pService->StgId);

                        Status = STATUS_DEVICE_BUSY;

                    }

                    //
                    // We found a matching service, no need to look at the
                    // rest of the services
                    //

                    break;

                }

            }

            pPktEntry =
                CONTAINING_RECORD(pPktEntry->Link.Flink, DFS_PKT_ENTRY, Link);

        }

        //
        // Free the unmarshalled input arguments
        //

        PktEntryIdDestroy(&EntryId, FALSE);

    } else {

        DebugTrace( 0, Dbg, "Unmarshalling Error - %08lx\n", ULongToPtr( Status ));

    }

    DfsCompleteRequest( Irp, Status );

    DebugTrace(-1, Dbg,
        "DfsFsctrlIsStgIdLegalOnServer - returning %08lx\n", ULongToPtr( Status ));

    return Status;

}


//+----------------------------------------------------------------------------
//
//  Function:   DfspGetServerConfigInfo
//
//  Synopsis:   Given a machine guid and a pkt entry, this routine will
//              return the relation info for the entry if the machine is a
//              server for the entry.
//
//  Arguments:  [pMachine] -- Pointer to machine guid
//              [pPkt] -- The pkt to examine
//              [pPktEntry] -- The pkt entry to examine
//              [pConfigInfo] -- If the machine is a server for this entry, a
//                            relation info is returned here.
//
//  Returns:    [STATUS_SUCCESS] -- Machine is a server, and relation info
//                      constructed successfully
//
//              [STATUS_OBJECT_NAME_NOT_FOUND] -- Machine is not a server for
//                      the given pkt entry
//
//              [STATUS_OBJECT_TYPE_MISMATCH] -- pPktEntry is for a machine,
//                      domain, or orgroot volume. Can't get config info for
//                      these volumes.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Machine is a server, but
//                      out of memory constructing relation info
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspGetServerConfigInfo(
    IN GUID *pMachine,
    IN PDFS_PKT pPkt,
    IN PDFS_PKT_ENTRY pPktEntry,
    OUT PDFS_LOCAL_VOLUME_CONFIG pConfigInfo)
{
    ULONG j;
    NTSTATUS Status = STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // We can't get a config info for a machine volume.
    //

    if ( ((pPktEntry->Type & PKT_ENTRY_TYPE_MACHINE) != 0) ||
            (pPktEntry == pPkt->DomainPktEntry) ||
                (pPktEntry->Id.Prefix.Length == sizeof(WCHAR))) {

        return( STATUS_OBJECT_TYPE_MISMATCH );

    }

    for (j = 0; j < pPktEntry->Info.ServiceCount; j++) {

        PDFS_SERVICE pService = &pPktEntry->Info.ServiceList[j];

        if ( GuidEqual(
                &pService->pMachEntry->pMachine->guidMachine,
                pMachine ) ) {

             Status = PktRelationInfoConstruct(
                        &pConfigInfo->RelationInfo,
                        pPkt,
                        &pPktEntry->Id);

             ASSERT( Status != DFS_STATUS_NO_SUCH_ENTRY );

             if (NT_SUCCESS(Status)) {

                 ASSERT( pService->StgId.Length != 0 );

                 pConfigInfo->StgId.Length = 0;
                 pConfigInfo->StgId.MaximumLength =
                    pService->StgId.MaximumLength;
                 pConfigInfo->StgId.Buffer = ExAllocatePoolWithTag(
                                                    PagedPool,
                                                    pService->StgId.Length,
                                                    ' sfD');

                 if (pConfigInfo->StgId.Buffer != NULL) {

                     RtlCopyUnicodeString(
                        &pConfigInfo->StgId,
                        &pService->StgId);

                 } else {

                     Status = STATUS_INSUFFICIENT_RESOURCES;

                 }

             }

             if (NT_SUCCESS(Status)) {

                 ASSERT( pPktEntry->Type & PKT_ENTRY_TYPE_CAIRO );

                 //
                 // Send only the PKT_ENTRY_TYPE_CAIRO bit.
                 //

                 pConfigInfo->EntryType = PKT_ENTRY_TYPE_CAIRO;

                 //
                 // Send only the service online/offline bit
                 //

                 pConfigInfo->ServiceType = pService->Type &
                                                DFS_SERVICE_TYPE_OFFLINE;

             }

             break;

        }

    }

    return( Status );

}


//+----------------------------------------------------------------------------
//
//  Function:   IsPathAPrefixOf
//
//  Synopsis:   Given two paths, this will return TRUE if the first path is
//              a prefix of the second.
//
//  Arguments:  [pustrPath1] -- The two paths
//              [pustrPath2]
//
//  Returns:    TRUE if pustrPath1 is a prefix of pustrPath2, FALSE otherwise
//
//-----------------------------------------------------------------------------

BOOLEAN
IsPathAPrefixOf(
    IN PUNICODE_STRING pustrPath1,
    IN PUNICODE_STRING pustrPath2)
{
    BOOLEAN fResult;

    fResult = RtlPrefixUnicodeString( pustrPath1, pustrPath2, FALSE );

    if (fResult) {

        //
        // Path1 is a prefix of Path2. However, this is not a sufficient test.
        // We have to catch cases like d:\test1 being a prefix of d:\test10
        //

        fResult =
            (pustrPath2->Length == pustrPath1->Length)
                        ||
            (pustrPath2->Buffer[ pustrPath1->Length / sizeof(WCHAR) ] ==
                UNICODE_PATH_SEP);

    }

    return( fResult );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\create.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       create.c
//
//  Contents:   Implements the Create code for the Dfs server. The Dfs server
//              only allows opening the File System Device object for the
//              express purpose of FsControlling to the Dfs server.
//
//  Classes:
//
//  Functions:  DfsFsdCreate
//              DfsOpenDevice
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "attach.h"
#include "dfswml.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

//
//  Local procedure prototypes
//

NTSTATUS
DfsOpenFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

NTSTATUS
DfsCompleteOpenFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context);

NTSTATUS
DfsOpenDevice (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG CreateOptions);

VOID
DfspDoesPathCrossJunctionPoint(
    IN PUNICODE_STRING Path,
    OUT BOOLEAN *IsExitPoint,
    OUT BOOLEAN *CrossesExitPoint);

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, DfsFsdCreate )
#pragma alloc_text( PAGE, DfsOpenFile )
#pragma alloc_text( PAGE, DfsOpenDevice )

#endif // ALLOC_PRAGMA



//+-------------------------------------------------------------------
//
//  Function:   DfsFsdCreate, public
//
//  Synopsis:   This routine implements the FSD part of the NtCreateFile
//              and NtOpenFile API calls.
//
//  Arguments:  [DeviceObject] -- Supplies the device object relative to which
//                      the open is to be processed.
//              [Irp] - Supplies the Irp being processed.
//
//  Returns:    NTSTATUS - The Fsd status for the Irp
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILE_OBJECT FileObject = irpSp->FileObject;
    PFILE_OBJECT        fileObject; 
    ULONG               createOptions;

    DebugTrace(+1, Dbg, "DfsFsdCreate: Entered\n", 0);
    DFS_TRACE_HIGH(TRACE_IRP, DfsFsdCreate_Entry, 
                   LOGPTR(DeviceObject)
                   LOGPTR(FileObject)
                   LOGUSTR(FileObject->FileName)
                   LOGPTR(Irp));

    ASSERT(IoIsOperationSynchronous(Irp) == TRUE);

    //
    // If someone is coming in via a device object attached to a file system
    // device object, pass it through.
    //

    if (DeviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM) {

        status = DfsVolumePassThrough(DeviceObject, Irp);

        DebugTrace(-1, Dbg, "DfsFsdCreate: FS Device Pass Through Exit %08lx\n", ULongToPtr( status ));

        return status;

    }

    //
    // If someone is coming in via a device object attached to a file system
    // volume, we need to see if they are opening an exit point via its local
    // file system name.
    //

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS_VOLUME) {

        if (((PDFS_VOLUME_OBJECT)DeviceObject)->DfsEnable == TRUE)    {
              status = DfsOpenFile(DeviceObject, Irp);

              DebugTrace(-1, Dbg, "DfsFsdCreate: Local File Open Exit %08lx\n", ULongToPtr( status ));
	}
	else {
              status = DfsVolumePassThrough(DeviceObject, Irp);

              DebugTrace(-1, Dbg, "DfsFsdCreate: (DfsDisable) FS Device Pass Through Exit %08lx\n", ULongToPtr( status ));

	}
        return status;
    }

    //
    // The only other create we handle is someone trying to open our own
    // file system device object.
    //

    ASSERT(DeviceObject->DeviceType == FILE_DEVICE_DFS_FILE_SYSTEM);

    FsRtlEnterFileSystem();

    fileObject = irpSp->FileObject;
    createOptions     = irpSp->Parameters.Create.Options;

    if (fileObject->FileName.Length == 0 &&
            fileObject->RelatedFileObject == NULL) {

        //
        // This is the only case we handle
        //

        status = DfsOpenDevice(
                    fileObject,
                    DeviceObject,
                    createOptions);

    } else {

        status = STATUS_INVALID_DEVICE_REQUEST;

    }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "DfsFsdCreate: Exit -> %08lx\n", ULongToPtr( status ));

    DfsCompleteRequest( Irp, status );

    DFS_TRACE_HIGH(TRACE_IRP, DfsFsdCreate_Exit, 
                   LOGSTATUS(status)
                   LOGPTR(fileObject)
                   LOGPTR(Irp));

    return status;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsOpenFile, local
//
//  Synopsis:   This routine handles file opens that come in via attached
//              volumes. The semantics of this open are:
//
//              If the named file is a child of a DfsExitPath, fail it
//              with access denied.
//
//              If the named file is a DfsExitPath, and CreateOptions specify
//              DELETE_ON_CLOSE, fail it with access denied.
//
//              In all other cases, allocate an FCB, and pass the open through
//              to the underlying FS. If the open succeeds, then insert the
//              FCB in our FCB table. If the open fails, destroy the FCB.
//
//  Arguments:  [DeviceObject] -- The attached device object through which
//                      the Create Irp came in.
//
//              [Irp] -- The Create Irp.
//
//  Returns:    [STATUS_INSUFFICIENT_RESOURCES] -- Unable to allocate an FCB.
//
//              [STATUS_ACCESS_DENIED] -- The file is a child of a Dfs exit
//                      path or the file is a Dfs exit path and
//                      DELETE_ON_CLOSE was specified.
//
//              Status from the underlying FS.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsOpenFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp)
{
    NTSTATUS            status;

    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION  nextIrpSp;
    PFILE_OBJECT        fileObject = irpSp->FileObject;
    ULONG               createOptions = irpSp->Parameters.Create.Options;
    PDFS_FCB            fcb = NULL;

    DebugTrace(+1, Dbg, "DfsOpenFile - Entered\n", 0);
    DFS_TRACE_LOW(TRACE_IRP, DfsOpenFile_Entry,
                   LOGPTR(fileObject)
                   LOGPTR(Irp));

    //
    // Optimistically, we allocate an FCB for this open.
    //

    status = DfsAllocateFcb(DeviceObject, fileObject, &fcb);

    if (NT_SUCCESS(status)) {

        BOOLEAN isExitPoint, crossesExitPoint;

        DfspDoesPathCrossJunctionPoint(
            &fcb->FullFileName,
            &isExitPoint,
            &crossesExitPoint);

        if (isExitPoint && (createOptions & FILE_DELETE_ON_CLOSE))
            status = STATUS_ACCESS_DENIED;

        if (crossesExitPoint)
            status = STATUS_ACCESS_DENIED;
    }

    //
    // If we haven't failed yet, we need to pass this open down to the
    // underlying file system. If we failed, then we need to complete the
    // Create Irp.
    //

    if (NT_SUCCESS(status)) {

        PDEVICE_OBJECT vdo;

        //
        // Copy the stack from one to the next...
        //

        nextIrpSp = IoGetNextIrpStackLocation(Irp);

        (*nextIrpSp) = (*irpSp);

        IoSetCompletionRoutine(
            Irp,
            DfsCompleteOpenFile,
            (PVOID) fcb,
            TRUE,
            TRUE,
            TRUE);

        //
        // Find out what device to call...and call it
        //

        vdo = ((PDFS_VOLUME_OBJECT) DeviceObject)->Provider.DeviceObject;

        status = IoCallDriver( vdo, Irp );
        DFS_TRACE_ERROR_HIGH(status, ALL_ERROR, DfsOpenFile_Error_IoCallDriver,
                             LOGSTATUS(status)
                             LOGPTR(fileObject)
                             LOGPTR(Irp));


    } else {

        if (fcb != NULL) {

            DfsDestroyFcb(fcb);

        }

        DfsCompleteRequest( Irp, status );

    }

    DebugTrace(-1, Dbg, "DfsOpenFile - Exited %08lx\n", ULongToPtr( status ));
    DFS_TRACE_LOW(TRACE_IRP, DfsOpenFile_Exit, 
                  LOGSTATUS(status)
                  LOGPTR(fileObject)
                  LOGPTR(Irp));

    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsCompleteOpenFile, local
//
//  Synopsis:   Completion routine for DfsOpenFile. If the underlying FS
//              successfully opened the file, we insert the FCB into our
//              FCB table, else we destroy the preallocated FCB.
//
//  Arguments:  [DeviceObject] -- Our device object, unused.
//
//              [Irp] -- The Create Irp that is being completed, unused.
//
//              [Context] -- Actually, a pointer to our pre-allocated FCB
//
//  Returns:    [STATUS_SUCCESS] -- This function always succeeds.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsCompleteOpenFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)
{
    PDFS_FCB fcb = (PDFS_FCB) Context;

    if (Irp->PendingReturned) {

        //
        // We need to call IpMarkIrpPending so the IoSubsystem will realize
        // that our FSD routine returned STATUS_PENDING. We can't call this
        // from the FSD routine itself because the FSD routine doesn't have
        // access to the stack location when the underlying guy returns
        // STATUS_PENDING
        //

        IoMarkIrpPending( Irp );

    }

    if (Irp->IoStatus.Status == STATUS_SUCCESS) {

        DfsAttachFcb( fcb->FileObject, fcb );

    } else {

        DfsDestroyFcb( fcb );
    }

    return( STATUS_SUCCESS );
}


//+-------------------------------------------------------------------
//
//  Function:   DfsOpenDevice, local
//
//  Synopsis:   This routine opens the specified device for direct
//              access.
//
//  Arguments:  [FileObject] - Supplies the File object
//              [DeviceObject] - Supplies the object denoting the device
//                      being opened
//              [CreateOptions] - Supplies the create options for
//                      this operation
//
//  Returns:    [IO_STATUS_BLOCK] - Returns the completion status for
//                      the operation
//
//--------------------------------------------------------------------

NTSTATUS
DfsOpenDevice (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG CreateOptions
) {
    NTSTATUS status;
    //
    //  Check to see which type of device is being opened.
    //  We don't permit all open modes on the file system
    //  device object.
    //

    ULONG CreateDisposition = (CreateOptions >> 24) & 0x000000ff;
    DFS_TRACE_LOW(TRACE_IRP, DfsOpenDevice_Entry, 
                   LOGPTR(FileObject)
                   LOGPTR(DeviceObject)
                   LOGULONG(CreateOptions));

    //
    //  Check for proper desired access and rights
    //

    if (CreateDisposition != FILE_OPEN
        && CreateDisposition != FILE_OPEN_IF ) {
        status = STATUS_ACCESS_DENIED;
        DebugTrace(0, Dbg,
            "DfsOpenDevice: Invalid CreateDisposition\n", 0);

        DFS_TRACE_HIGH(ERROR, DfsOpenDevice_Error1, 
                       LOGSTATUS(status)
                       LOGPTR(FileObject)
                       LOGPTR(DeviceObject));
        return( status );
    }

    //
    //  Check if we were to open a directory
    //

    if (CreateOptions & FILE_DIRECTORY_FILE) {
        status = STATUS_NOT_A_DIRECTORY;
        DebugTrace(0, Dbg,
            "DfsOpenDevice: Cannot open device as a directory\n", 0);

        DFS_TRACE_HIGH(ERROR, DfsOpenDevice_Error3, 
                       LOGSTATUS(status)
                       LOGPTR(FileObject)
                       LOGPTR(DeviceObject));
        return( status );

    }

    FileObject->FsContext = UIntToPtr( DFS_OPEN_CONTEXT );
    status = STATUS_SUCCESS;
    DFS_TRACE_LOW(TRACE_IRP, DfsOpenDevice_Exit, 
                  LOGSTATUS(status)
                  LOGPTR(FileObject)
                  LOGPTR(DeviceObject)); 
    return( status );
}


//+----------------------------------------------------------------------------
//
//  Function:   DfspDoesPathCrossJunctionPoint
//
//  Synopsis:   Given a fully formed local FS path
//              (looks like "\DosDevices\C:\foo\bar") this routine figures out
//              if the path matches an exit point exactly, or crosses an
//              exit point.
//
//  Arguments:  [Path] -- The path to check.
//              [IsExitPoint] -- The path refers to an exit point.
//              [CrossesExitPoint] -- The path crosses an exit point.
//
//  Returns:    NOTHING. The results are returned in the two out parameters.
//
//-----------------------------------------------------------------------------

VOID
DfspDoesPathCrossJunctionPoint(
    IN PUNICODE_STRING Path,
    OUT BOOLEAN *IsExitPoint,
    OUT BOOLEAN *CrossesExitPoint)
{
    PDFS_PKT                        pkt;
    PDFS_LOCAL_VOL_ENTRY            lv;
    UNICODE_STRING                  remPath;

    *IsExitPoint = FALSE;
    *CrossesExitPoint = FALSE;

    pkt = _GetPkt();

    PktAcquireShared(pkt, TRUE);

    lv = PktEntryLookupLocalService(pkt, Path, &remPath);

    if (lv != NULL && remPath.Length != 0) {

        PDFS_PKT_ENTRY  pktEntry, pktExitEntry;
        USHORT          prefixLength;
        UNICODE_STRING  remExitPt;
        PUNICODE_STRING exitPrefix;

        pktEntry = lv->PktEntry;
        prefixLength = pktEntry->Id.Prefix.Length;
        pktExitEntry = PktEntryFirstSubordinate(pktEntry);

        //
        // As long as there are more exit points see if the path crosses
        // the exit point.
        //

        while (pktExitEntry != NULL &&
                !(*IsExitPoint) &&
                    !(*CrossesExitPoint))    {

            exitPrefix = &pktExitEntry->Id.Prefix;

            if (exitPrefix->Buffer[prefixLength/sizeof(WCHAR)] == UNICODE_PATH_SEP)
                prefixLength += sizeof(WCHAR);

            remExitPt.Length = pktExitEntry->Id.Prefix.Length - prefixLength;
            remExitPt.MaximumLength = remExitPt.Length + 1;
            remExitPt.Buffer = &exitPrefix->Buffer[prefixLength/sizeof(WCHAR)];

            //
            // If the Path has the potential of crossing past the junction
            // point, we have something to return!
            //

            if (DfsRtlPrefixPath(&remExitPt, &remPath, TRUE)) {

                if (remExitPt.Length == remPath.Length) {

                    *IsExitPoint = TRUE;

                } else {

                    *CrossesExitPoint = TRUE;

                }
            }

            pktExitEntry = PktEntryNextSubordinate(pktEntry, pktExitEntry);

        } //while exit pt exists

    } // lv != NULL && remPath.Length != 0

    PktRelease(pkt);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\dfsdata.h ===
//+----------------------------------------------------------------------------
//
//  File:       dfsdata.h
//
//  Contents:   This module declares the global data used by the
//              Dfs file system.
//
//  Functions:
//
//-----------------------------------------------------------------------------

#ifndef _DFSDATA_
#define _DFSDATA_

//
//  The global FSD data record.
//

extern DFS_DATA DfsData;


//
// The global event logging level
//
extern ULONG DfsEventLog;

//
//  The security descriptor used to check access for renames along exit paths
//

extern PSECURITY_DESCRIPTOR SeRenameSd;

#if DBG

#define DEBUG_TRACE_ERROR               (0x00000001)
#define DEBUG_TRACE_DEBUG_HOOKS         (0x00000002)
#define DEBUG_TRACE_CATCH_EXCEPTIONS    (0x00000004)
#define DEBUG_TRACE_UNWIND              (0x00000008)
#define DEBUG_TRACE_REGISTRY            (0x00000010)
#define DEBUG_TRACE_CLOSE               (0x00000020)
#define DEBUG_TRACE_CREATE              (0x00000040)
#define DEBUG_TRACE_INIT                (0x00000080)
#define DEBUG_TRACE_INSTRUM             (0x00000100)
#define DEBUG_TRACE_FILEINFO            (0x00000200)
#define DEBUG_TRACE_FSCTRL              (0x00000400)
#define DEBUG_TRACE_RTL                 (0x00000800)
#define DEBUG_TRACE_RESET               (0x00001000)
#define DEBUG_TRACE_VOLINFO             (0x00002000)  // Unused
#define DEBUG_TRACE_WRITE               (0x00004000)  // Unused
#define DEBUG_TRACE_DEVCTRL             (0x00008000)  // Unused
#define DEBUG_TRACE_PKT                 (0x00010000)
#define DEBUG_TRACE_DOTDFS              (0x00020000)  // Unused
#define DEBUG_TRACE_LOCALVOL            (0x00040000)
#define DEBUG_TRACE_DNR                 (0x00080000)  // Unused
#define DEBUG_TRACE_ATTACH              (0x00100000)
#define DEBUG_TRACE_FASTIO              (0x00200000)
#define DEBUG_TRACE_DIRSUP              (0x00400000)  // Unused
#define DEBUG_TRACE_FILOBSUP            (0x00800000)  // Unused
#define DEBUG_TRACE_EVENTLOG            (0x01000000)
#define DEBUG_TRACE_LOGROOT             (0x02000000)  // Unused
#define DEBUG_TRACE_CACHESUP            (0x04000000)  // Unused
#define DEBUG_TRACE_PREFXSUP            (0x08000000)
#define DEBUG_TRACE_DEVIOSUP            (0x10000000)  // Unused
#define DEBUG_TRACE_STRUCSUP            (0x20000000)  // Unused
#define DEBUG_TRACE_ROOT_EXPANSION      (0x40000000)
#define DEBUG_TRACE_REFERRALS           (0x80000000)

extern LONG DfsDebugTraceLevel;
extern LONG DfsDebugTraceIndent;


//+---------------------------------------------------------------------------
// Macro:       DebugTrace, public
//
// Synopsis:    Conditionally print a debug trace message
//
// Arguments:   [Indent] -- Indent to appluy: +1, 0 or -1
//              [Level] -- debug trace level
//              [Msg] -- Message to be printed, can include one prinf-style
//                      format effector.
//              [Y] -- Value to be printed
//
// Returns:     None
//
//----------------------------------------------------------------------------

VOID DfsDebugTracePrint(PCHAR x, PVOID y);

#define DebugTrace(INDENT,LEVEL,X,Y) {                      \
    if (((LEVEL) == 0) || (DfsDebugTraceLevel & (LEVEL))) { \
        if ((INDENT) < 0) {                                 \
            DfsDebugTraceIndent += (INDENT);                \
        }                                                   \
        DfsDebugTracePrint(X, (PVOID)Y);                    \
        if ((INDENT) > 0) {                                 \
            DfsDebugTraceIndent += (INDENT);                \
        }                                                   \
    }                                                       \
}

#else

#define DebugTrace(INDENT,LEVEL,X,Y)     {NOTHING;}

#endif // DBG


//+---------------------------------------------------------------------------
// Macro:       BugCheck, public
//
// Synopsis:    Call DfsBugCheck with invoker's file and line numbers
//
// Arguments:   [Msg] -- Optional Message to be printed for debug
//                      builds
//
// Returns:     None
//
//----------------------------------------------------------------------------

#if DBG
VOID DfsBugCheck(CHAR *pszmsg, CHAR *pszfile, ULONG line);
#define BugCheck(sz)    DfsBugCheck(sz, __FILE__, __LINE__)
#else
VOID DfsBugCheck(VOID);
#define BugCheck(sz)    DfsBugCheck()
#endif

#endif // _DFSDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\dfsdata.c ===
//+----------------------------------------------------------------------------
//
//  File:       DSDATA.C
//
//  Contents:
//      This module declares the global data used by the Dsfs file system.
//
//  Functions:
//
//  History:    12 Nov 1991     AlanW   Created from CDFS souce.
//-----------------------------------------------------------------------------


#include "dfsprocs.h"

//
//  The debug trace level
//

#define Dbg             (DEBUG_TRACE_CATCH_EXCEPTIONS)


//  DfsBugCheck
//  DfsExceptionFilter
//  DfsProcessException

#ifdef ALLOC_PRAGMA
#pragma alloc_text ( PAGE, DfsBugCheck )
#pragma alloc_text ( PAGE, DfsExceptionFilter )
#pragma alloc_text ( PAGE, DfsProcessException )

//
//  The following rountine cannot be paged because it raises the IRQL to
//  complete IRPs.
//
//
//  DfsCompleteRequest_Real
//

#endif // ALLOC_PRAGMA

//
//  The global FSD data record
//

DFS_DATA DfsData;

//
// The global event logging level
//
ULONG DfsEventLog = 0;

#if DBG

//+---------------------------------------------------------------------------
// Function:    DfsDebugTracePrint, public
//
// Synopsis:    Produce a DFS debug trace printout
//
// Arguments:   [x] -- DbgPrint format string
//              [y] -- optional argument to DbgPrint
//
// Returns:     None
//
//----------------------------------------------------------------------------

LONG DfsDebugTraceLevel = 0x00000001;
LONG DfsDebugTraceIndent = 0;

VOID
DfsDebugTracePrint(PCHAR x, PVOID y)
{
        int i;

        DbgPrint("%08X:",PsGetCurrentThread());
        if (DfsDebugTraceIndent < 0)
            DfsDebugTraceIndent = 0;
        for (i = 0; i+5 < DfsDebugTraceIndent; i += 5) {
            DbgPrint("      ");
        }
        for ( ; i < DfsDebugTraceIndent; i += 1) {
            DbgPrint(" ");
        }
        DbgPrint(x,y);
}

#endif // DBG



//+---------------------------------------------------------------------------
// Function:    DfsBugCheck, public
//
// Synopsis:    Call KeBugCheck with DFS' constant
//
// Arguments:   [pszmsg]  -- message            (DBG=1 only)
//              [pszfile] -- filename           (DBG=1 only)
//              [line]    -- line number        (DBG=1 only)
//
// Returns:     None
//
//----------------------------------------------------------------------------

#if DBG
VOID DfsBugCheck(CHAR *pszmsg, CHAR *pszfile, ULONG line)
{
    PVOID CallersAddress, CallersCaller;

    RtlGetCallersAddress(&CallersAddress, &CallersCaller);

    DbgPrint("\nDFS: BugCheck in %s, line %u (%s)\n", pszfile, line, pszmsg);
    KeBugCheckEx(DFS_FILE_SYSTEM, (ULONG_PTR)CallersAddress, (ULONG_PTR)pszmsg, (ULONG_PTR)pszfile, line);
}
#else   // DBG
VOID DfsBugCheck(VOID)
{
    PVOID CallersAddress, CallersCaller;

    RtlGetCallersAddress(&CallersAddress, &CallersCaller);
    KeBugCheckEx(DFS_FILE_SYSTEM, (ULONG_PTR)CallersAddress, (ULONG_PTR)CallersCaller, 0, 0);
}
#endif  // DBG

//+----------------------------------------------------------------------------
//
//  Function:   FillDebugException
//
//  Synopsis:   Captures the exception record into variables that we can
//              look at.
//
//  Arguments:  [pep] -- Pointer to exception record.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

#define CEXCEPTION_STACK        8

PEXCEPTION_RECORD   DfsExceptionRecord;
PCONTEXT            DfsExceptionContext;
ULONG               DfsExceptionStack[CEXCEPTION_STACK];

VOID
FillDebugException(
    PEXCEPTION_POINTERS pep)
{
    if(pep != NULL) {

        DfsExceptionRecord = pep->ExceptionRecord;

        DfsExceptionContext = pep->ContextRecord;

    }

}


//+-------------------------------------------------------------------
//
//  Function:   DfsExceptionFilter
//
//  Synopsis:   Decide if we should or should not handle an exception status
//              that is being raised.
//
//  Arguments:  [ExceptionCode] -- Supplies the exception code to being checked.
//              [ExceptionPointers] -- Supplies the struct to fill with exception pointers
//
//  Returns:    ULONG - returns EXCEPTION_EXECUTE_HANDLER or BugChecks
//
//--------------------------------------------------------------------

LONG
DfsExceptionFilter (
    IN NTSTATUS ExceptionCode,
    IN PEXCEPTION_POINTERS ExceptionPointers OPTIONAL
) {
    DebugTrace(
        0, DEBUG_TRACE_UNWIND, "DfsExceptionFilter %lx\n", ULongToPtr( ExceptionCode ));

    FillDebugException( ExceptionPointers );

    ASSERT(ExceptionCode != STATUS_ACCESS_VIOLATION);

    ASSERTMSG(
        "DfsExceptionFilter entered\n",
        !(DfsDebugTraceLevel & DEBUG_TRACE_UNWIND));

    if (!FsRtlIsNtstatusExpected( ExceptionCode )) {
        BugCheck( "DfsExceptionFilter: Unexpected exception" );
    }

    return EXCEPTION_EXECUTE_HANDLER;
}

//+-------------------------------------------------------------------
//
//  Function:   DfsProcessException, public
//
//  Synopsis:   This routine processes an exception.  It either completes
//              the request with the saved exception status or it sends
//              the request off to the Fsp.
//
//  Arguments:  [Irp] -- Supplies the IRP being processed
//              [ExceptionCode] -- normalized exception status being handled
//
//  Returns:    NTSTATUS - Returns the results of either posting the Irp or the
//              saved completion status.
//
//--------------------------------------------------------------------

NTSTATUS
DfsProcessException (
    IN PIRP Irp,
    IN NTSTATUS ExceptionCode
    )
{
    NTSTATUS Status;

    DebugTrace(0, Dbg, "DfsProcessException\n", 0);

    //
    //  We got an error, so zero out the information field before
    //  completing the request if this was an input operation.
    //  Otherwise IopCompleteRequest will try to copy to the user's buffer.
    //

    if (FlagOn(Irp->Flags, IRP_INPUT_OPERATION)) {

        Irp->IoStatus.Information = 0;
    }

    Status = ExceptionCode;

    DfsCompleteRequest( Irp, Status );

    return Status;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsCompleteRequest, public
//
//  Synopsis:   This routine completes a Irp
//
//  Arguments:  [Irp] - Supplies the Irp being processed
//              [Status] - Supplies the status to complete the Irp with
//
//  Returns:    None.
//
//--------------------------------------------------------------------

VOID
DfsCompleteRequest_Real (
    IN PIRP Irp OPTIONAL,
    IN NTSTATUS Status
) {
    KIRQL PreviousIrql;

    //
    //  If we have an Irp then complete the irp.
    //

    if (Irp != NULL) {

        Irp->IoStatus.Status = Status;

        IoCompleteRequest( Irp, IO_DISK_INCREMENT );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\close.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       close.c
//
//  Contents:   This module implements the File Close and Cleanup routines for
//              the Dfs server.
//
//  Functions:  DfsFsdClose - FSD entry point for Close IRP
//              DfsFsdCleanup - FSD entry point for Cleanup IRP
//
//-----------------------------------------------------------------------------


#include "dfsprocs.h"
#include "attach.h"
#include "dfswml.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLOSE)

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, DfsFsdClose )
#pragma alloc_text( PAGE, DfsFsdCleanup )

#endif // ALLOC_PRAGMA

//+-------------------------------------------------------------------
//
//  Function:   DfsFsdClose, public
//
//  Synopsis:   This routine implements the FSD part of closing down the
//              last reference to a file object.
//
//  Arguments:  [DeviceObject] -- Supplies the device object where the
//                      file being closed exists
//              [Irp] - Supplies the Irp being processed
//
//  Returns:    NTSTATUS - The FSD status for the IRP
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
) {
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    NTSTATUS Status;

    DebugTrace(+1, Dbg, "DfsFsdClose:  Entered\n", 0);
    DFS_TRACE_HIGH(TRACE_IRP, DfsFsdClose_Entry,
                   LOGPTR(FileObject)
                   LOGPTR(Irp));

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS_VOLUME) {
        PDFS_FCB fcb;

        fcb = DfsLookupFcb( IrpSp->FileObject );

        if (fcb != NULL) {

            DfsDetachFcb( IrpSp->FileObject, fcb );

            DfsDestroyFcb( fcb );
        }

    }

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS_VOLUME ||
            DeviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM) {

        Status = DfsVolumePassThrough(DeviceObject, Irp);

        DebugTrace(-1, Dbg, "DfsFsdClose: Pass Through Exit %08lx\n", ULongToPtr( Status ));

        return Status;

    }

    ASSERT(DeviceObject->DeviceType == FILE_DEVICE_DFS_FILE_SYSTEM);

    ASSERT(IrpSp->FileObject->FsContext == UIntToPtr( DFS_OPEN_CONTEXT ));

    Status = STATUS_SUCCESS;

    DebugTrace(-1, Dbg, "DfsFsdClose:  Exit -> %08lx\n", ULongToPtr( Status ));

    DfsCompleteRequest( Irp, Status );

    DFS_TRACE_HIGH(TRACE_IRP, DfsFsdClose_Exit, 
                   LOGSTATUS(Status)
                   LOGPTR(FileObject)
                   LOGPTR(Irp));
    return Status;

}

//+-------------------------------------------------------------------
//
//  Function:   DfsFsdCleanup, public
//
//  Synopsis:   This routine implements the FSD part of closing down the
//              last user handle to a file object.
//
//  Arguments:  [DeviceObject] -- Supplies the device object where the
//                                file being closed exists
//              [Irp] - Supplies the Irp being processed
//
//  Returns:    NTSTATUS - The FSD status for the IRP
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdCleanup (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
) {

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    NTSTATUS Status;

    DebugTrace(+1, Dbg, "DfsFsdCleanup:  Entered\n", 0);
    DFS_TRACE_HIGH(TRACE_IRP, DfsFsdCleanup_Entry,
                   LOGPTR(FileObject)
                   LOGPTR(Irp));

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS_VOLUME ||
            DeviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM) {

        Status = DfsVolumePassThrough(DeviceObject, Irp);

        DebugTrace(-1, Dbg, "DfsFsdCleanup: Pass Through Exit %08lx\n", ULongToPtr( Status ));

        return Status;

    }

    ASSERT(DeviceObject->DeviceType == FILE_DEVICE_DFS_FILE_SYSTEM);

    ASSERT(IrpSp->FileObject->FsContext == UIntToPtr( DFS_OPEN_CONTEXT ));

    Status = STATUS_SUCCESS;

    DebugTrace(-1, Dbg, "DfsFsdCleanup:  Exit -> %08lx\n", ULongToPtr( Status ));

    DfsCompleteRequest( Irp, Status );

    DFS_TRACE_HIGH(TRACE_IRP, DfsFsdCleanup_Exit, 
                   LOGSTATUS(Status)
                   LOGPTR(FileObject)
                   LOGPTR(Irp));

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\dfsinit.c ===
//+----------------------------------------------------------------------------//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       dfsinit.c
//
//  Contents:   Driver initialization routine for the Dfs server.
//
//  Classes:    None
//
//  Functions:  DriverEntry -- Entry point for driver
//              DfsCreateMachineName -- Routine to query this computers name
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "attach.h"
#include "fastio.h"
#include "registry.h"
#include "regkeys.h"

//
// The following are includes for init modules, which will get discarded when
// the driver has finished loading.
//

#include "provider.h"
#include "localvol.h"
#include "lvolinit.h"
#include "sitesup.h"
#include "ipsup.h"
#include "spcsup.h"
#include "dfswml.h"

//
//  The debug trace level
//

#define Dbg              (DEBUG_TRACE_INIT)

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
);

VOID
DfsUnload(
    IN PDRIVER_OBJECT DriverObject);

NTSTATUS
DfsCreateMachineName(void);

VOID
DfsDeleteMachineName (
    VOID);

#if DBG
VOID
DfsGetDebugFlags(void);
#endif

VOID
DfsGetEventLogValue(VOID);

#ifdef  ALLOC_PRAGMA
#pragma alloc_text( INIT, DfsCreateMachineName)
#pragma alloc_text( INIT, DriverEntry)
#pragma alloc_text( PAGE, DfsDeleteMachineName)
#pragma alloc_text( PAGE, DfsGetEventLogValue )
#pragma alloc_text( PAGE, DfsUnload)
#if DBG
#pragma alloc_text( PAGE, DfsGetDebugFlags )
#endif
#endif // ALLOC_PRAGMA

//
//  This macro takes a pointer (or ulong) and returns its rounded up quadword
//  value
//

#define QuadAlign(Ptr) (        \
    ((((ULONG)(Ptr)) + 7) & 0xfffffff8) \
    )


NTSTATUS DfsDrvWmiDispatch(PDEVICE_OBJECT p, PIRP i);

//+-------------------------------------------------------------------
//
//  Function:   DriverEntry, main entry point
//
//  Synopsis:   This is the initialization routine for the DFS file system
//      device driver.  This routine creates the device object for
//      the FileSystem device and performs all other driver
//      initialization.
//
//  Arguments:  [DriverObject] -- Pointer to driver object created by the
//          system.
//
//  Returns:    [NTSTATUS] - The function value is the final status from
//          the initialization operation.
//
//--------------------------------------------------------------------

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
) {
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    PDEVICE_OBJECT DeviceObject;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PWSTR p;
    int i;
    HANDLE hTemp;
    HANDLE DirHandle;
    PBYTE pData;

    DebugTrace(0, Dbg, "***********Dfs DriverEntry()\n", 0);

    DfsData.OperationalState = DFS_STATE_UNINITIALIZED;
    DfsData.LvState = LV_UNINITIALIZED;
    //
    // Create the filesystem device object.
    //

    RtlInitUnicodeString( &UnicodeString, DFS_SERVER_NAME );
    Status = IoCreateDevice( DriverObject,
             0,
             &UnicodeString,
             FILE_DEVICE_DFS_FILE_SYSTEM,
             FILE_REMOTE_DEVICE | FILE_DEVICE_SECURE_OPEN,
             FALSE,
             &DeviceObject );
    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }
    DriverObject->DriverUnload = DfsUnload;
    //
    // Initialize the driver object with this driver's entry points.
    // Most are simply passed through to some other device driver.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = DfsVolumePassThrough;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE]      = (PDRIVER_DISPATCH)DfsFsdCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]       = (PDRIVER_DISPATCH)DfsFsdClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]     = (PDRIVER_DISPATCH)DfsFsdCleanup;
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION] = (PDRIVER_DISPATCH)DfsFsdSetInformation;
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = (PDRIVER_DISPATCH)DfsFsdFileSystemControl;

    DriverObject->FastIoDispatch = &FastIoDispatch;

    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = 
                                      (PDRIVER_DISPATCH) DfsDrvWmiDispatch;



    Status = IoWMIRegistrationControl (DeviceObject, WMIREG_ACTION_REGISTER);

    //
    //  Initialize the global data structures
    //

    RtlZeroMemory(&DfsData, sizeof (DFS_DATA));

    DfsData.NodeTypeCode = DFS_NTC_DATA_HEADER;
    DfsData.NodeByteSize = sizeof( DFS_DATA );

    InitializeListHead( &DfsData.AVdoQueue );
    InitializeListHead( &DfsData.AFsoQueue );

    //
    // Init assorted hash tables
    //

    Status = DfsInitFcbs( 0 );
    if (!NT_SUCCESS(Status)) {
        IoDeleteDevice (DeviceObject);
        return Status;
    }

    Status = DfsInitSites( 0 );
    if (!NT_SUCCESS(Status)) {
        DfsUninitFcbs ();
        IoDeleteDevice (DeviceObject);
        return Status;
    }

    Status = DfsInitSpcHashTable( &DfsData.SpcHashTable, 0 );
    if (!NT_SUCCESS(Status)) {
        DfsUninitSites ();
        DfsUninitFcbs ();
        IoDeleteDevice (DeviceObject);
        return Status;
    }

    Status = DfsInitSpcHashTable( &DfsData.FtDfsHashTable, 0 );
    if (!NT_SUCCESS(Status)) {
        DfsUninitSpcHashTable (DfsData.SpcHashTable);
        DfsUninitSites ();
        DfsUninitFcbs ();
        IoDeleteDevice (DeviceObject);
        return Status;
    }

    Status = DfsInitIp( 0, 0 );
    if (!NT_SUCCESS(Status)) {
        DfsUninitSpcHashTable (DfsData.FtDfsHashTable);
        DfsUninitSpcHashTable (DfsData.SpcHashTable);
        DfsUninitSites ();
        DfsUninitFcbs ();
        IoDeleteDevice (DeviceObject);
        return Status;
    }

    DfsData.DriverObject = DriverObject;
    DfsData.FileSysDeviceObject = DeviceObject;

    ExInitializeResourceLite( &DfsData.Resource );

    DfsData.MachineState = DFS_UNKNOWN;

    DfsData.IsDC = FALSE;

    DfsCreateMachineName();

    DfsData.Pkt.DefaultTimeToLive = DEFAULT_PKT_ENTRY_TIMEOUT;

    //
    // Override special name table timeout with registry entry
    //

    Status = KRegSetRoot(wszRegDfsDriver);

    if (NT_SUCCESS(Status)) {

        Status = KRegGetValue(
                    L"",
                    wszDefaultTimeToLive,
                    (PVOID ) &pData);

        KRegCloseRoot();

        if (NT_SUCCESS(Status)) {

            DfsData.Pkt.DefaultTimeToLive = *((ULONG*)pData);

            ExFreePool(pData);

        }

    }

    //
    // Initialize Lpc struct
    //

    RtlInitUnicodeString(&DfsData.DfsLpcInfo.LpcPortName, NULL);
    DfsData.DfsLpcInfo.LpcPortState = LPC_STATE_UNINITIALIZED;
    ExInitializeFastMutex(&DfsData.DfsLpcInfo.LpcPortMutex);
    DfsData.DfsLpcInfo.LpcPortHandle = NULL;
    ExInitializeResourceLite(&DfsData.DfsLpcInfo.LpcPortResource );

    //
    //  Initialize the system wide PKT
    //

    Status = PktInitialize(&DfsData.Pkt);
    if (!NT_SUCCESS(Status)) {
        ExDeleteResourceLite(&DfsData.DfsLpcInfo.LpcPortResource );
        DfsDeleteMachineName();
        ExDeleteResourceLite( &DfsData.Resource );
        DfsUninitIp ();
        DfsUninitSpcHashTable (DfsData.FtDfsHashTable);
        DfsUninitSpcHashTable (DfsData.SpcHashTable);
        DfsUninitSites ();
        DfsUninitFcbs ();
        IoDeleteDevice (DfsData.FileSysDeviceObject);
        return Status;
    }

    //
    //  Set up global pointer to the system process.
    //

    DfsData.OurProcess = PsGetCurrentProcess();

    //
    //  Register for callbacks when other file systems are loaded
    //

    Status = IoRegisterFsRegistrationChange( DriverObject, DfsFsNotification );
    if (!NT_SUCCESS (Status)) {
        PktUninitialize(&DfsData.Pkt);
        ExDeleteResourceLite(&DfsData.DfsLpcInfo.LpcPortResource );
        DfsDeleteMachineName();
        ExDeleteResourceLite( &DfsData.Resource );
        DfsUninitIp ();
        DfsUninitSpcHashTable (DfsData.FtDfsHashTable);
        DfsUninitSpcHashTable (DfsData.SpcHashTable);
        DfsUninitSites ();
        DfsUninitFcbs ();
        IoDeleteDevice (DfsData.FileSysDeviceObject);
        return Status;
    }

    //
    //  Finally, mark our state to being INITIALIZED
    //

    DfsData.OperationalState = DFS_STATE_INITIALIZED;

    return STATUS_SUCCESS;
}

//+---------------------------------------------------------------------
//
// Function:    DfsUnload()
//
// Synopsis:    Driver unload routine
//
// Arguments:   [DriverObject] -- The driver object created by the system
//
// Returns: Nothing
//
//----------------------------------------------------------------------
VOID
DfsUnload(
    IN PDRIVER_OBJECT DriverObject)
{

    IoUnregisterFsRegistrationChange(DriverObject, DfsFsNotification);

    DfsDetachAllFileSystems ();

    PktUninitialize(&DfsData.Pkt);
    ExDeleteResourceLite(&DfsData.DfsLpcInfo.LpcPortResource );
    DfsDeleteMachineName();
    ExDeleteResourceLite( &DfsData.Resource );
    DfsUninitIp ();
    DfsUninitSpcHashTable (DfsData.FtDfsHashTable);
    DfsUninitSpcHashTable (DfsData.SpcHashTable);
    DfsUninitSites ();
    DfsUninitFcbs ();
    IoDeleteDevice (DfsData.FileSysDeviceObject);
}


//+---------------------------------------------------------------------
//
// Function:    DfsCreateMachineName()
//
// Synopsis:    Gets the principal name of this machine by looking at
//              Registry.
//
// Arguments:   [pustrName] -- The Service Name is to be filled in here.
//
// Returns: STATUS_SUCCESS -- If all went well.
//
//
// History: 30 Mar 1993 SudK    Created.
//
//----------------------------------------------------------------------

NTSTATUS
DfsCreateMachineName(void)
{

    NTSTATUS    status;
    UNICODE_STRING  PName;
    PWCHAR      pwszNetBIOSName;
    PWCHAR      pwszComputerName;
    PWCHAR      pwszDomainRoot;
    PWCHAR      pwszOU;
    ULONG       lOUNameLength;

    //
    // Now we have to go and get the computer name from the registry.
    //

    status = KRegSetRoot(wszRegComputerNameRt);

    if (NT_SUCCESS(status)) {

        status = KRegGetValue(
                    wszRegComputerNameSubKey,
                    wszRegComputerNameValue,
                    (PVOID ) &pwszComputerName);

        KRegCloseRoot();

        if (NT_SUCCESS(status)) {

            RtlInitUnicodeString(
                &DfsData.NetBIOSName,
                pwszComputerName);

            RtlInitUnicodeString(
                &DfsData.PrincipalName,
                pwszComputerName);

        }

    }

    return(status);

}

VOID
DfsDeleteMachineName (
    VOID)
{
    ExFreePool (DfsData.NetBIOSName.Buffer);
}

VOID
DfsGetEventLogValue(VOID)

/*++

Routine Description:

    This routine checks registry keys to set the event logging level

Arguments:

    None

Return Value:

    None
    

--*/

{
    NTSTATUS status;
    HANDLE DfsRegHandle;
    OBJECT_ATTRIBUTES ObjAttr;
    ULONG ValueSize;

    UNICODE_STRING DfsRegKey;
    UNICODE_STRING DfsValueName;

    struct {
        KEY_VALUE_PARTIAL_INFORMATION Info;
        ULONG Buffer;
    } DfsValue;

    PAGED_CODE();

    DebugTrace(0, Dbg, "DfsGetEventLogValue()\n", 0);

    RtlInitUnicodeString(
        &DfsRegKey,
        L"\\Registry\\Machine\\SOFTWARE\\MicroSoft\\Windows NT\\CurrentVersion\\Diagnostics");

    InitializeObjectAttributes(
        &ObjAttr,
        &DfsRegKey,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL);

    status = ZwOpenKey(
                &DfsRegHandle,
                KEY_QUERY_VALUE,
                &ObjAttr);

    if (!NT_SUCCESS(status))
        return;

    RtlInitUnicodeString(&DfsValueName, L"RunDiagnosticLoggingGlobal");

    status = ZwQueryValueKey(
                DfsRegHandle,
                &DfsValueName,
                KeyValuePartialInformation,
                (PVOID) &DfsValue,
                sizeof(DfsValue),
                &ValueSize);

    if (NT_SUCCESS(status) && DfsValue.Info.Type == REG_DWORD) {

        DfsEventLog = *((PULONG) DfsValue.Info.Data);
        goto Cleanup;

    }

    RtlInitUnicodeString(&DfsValueName, L"RunDiagnosticLoggingDfs");

    status = ZwQueryValueKey(
                DfsRegHandle,
                &DfsValueName,
                KeyValuePartialInformation,
                (PVOID) &DfsValue,
                sizeof(DfsValue),
                &ValueSize);

    if (NT_SUCCESS(status) && DfsValue.Info.Type == REG_DWORD)
        DfsEventLog = *((PULONG) DfsValue.Info.Data);

Cleanup:

    ZwClose( DfsRegHandle );

    DebugTrace( 0, Dbg, "DfsGetEventLog exit DfsEventLog = 0x%x\n", ULongToPtr( DfsEventLog ));

}

//
// DfspGetMaxReferrals: read from registry the maximum number of referrals
// that we pass back to the client, and store this in the dfsdata.pkt
//

VOID
DfspGetMaxReferrals(
   VOID)
{
    NTSTATUS status;
    HANDLE DfsRegHandle;
    OBJECT_ATTRIBUTES ObjAttr;
    ULONG ValueSize;

    UNICODE_STRING DfsRegKey;
    UNICODE_STRING DfsValueName;

    struct {
        KEY_VALUE_PARTIAL_INFORMATION Info;
        ULONG Buffer;
    } DfsValue;

    RtlInitUnicodeString(
        &DfsRegKey,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\DfsDriver");

    InitializeObjectAttributes(
        &ObjAttr,
        &DfsRegKey,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL);

    status = ZwOpenKey(
                &DfsRegHandle,
                KEY_QUERY_VALUE,
                &ObjAttr);

    if (!NT_SUCCESS(status))
        return;

    RtlInitUnicodeString(&DfsValueName, wszMaxReferrals);

    status = ZwQueryValueKey(
                DfsRegHandle,
                &DfsValueName,
                KeyValuePartialInformation,
                (PVOID) &DfsValue,
                sizeof(DfsValue),
                &ValueSize);

    if (NT_SUCCESS(status) && DfsValue.Info.Type == REG_DWORD) {
       DfsData.Pkt.MaxReferrals = *((PULONG) DfsValue.Info.Data);
        // DbgPrint("Set MaxReferrals to %d\n", DfsData.Pkt.MaxReferrals);
    }

    ZwClose( DfsRegHandle );

}

#if DBG


VOID
DfsGetDebugFlags(
    VOID
    )

/*++

Routine Description:

    This routine reads Dfs debug flag settings from the registry

Arguments:

    None.

Return Value:

    None.

--*/

{
    HANDLE handle;
    NTSTATUS status;
    UNICODE_STRING valueName;
    UNICODE_STRING keyName;
    OBJECT_ATTRIBUTES objectAttributes;
    PWCH providerName;
    ULONG lengthRequired;
    ULONG Flags = 0;

     union {
        KEY_VALUE_FULL_INFORMATION;
        UCHAR   buffer[ sizeof( KEY_VALUE_FULL_INFORMATION ) + 100 ];
    } keyValueInformation;

    PAGED_CODE();

    RtlInitUnicodeString(
        &keyName,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Dfs");

    InitializeObjectAttributes(
        &objectAttributes,
        &keyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL);

    status = ZwOpenKey(
                 &handle,
                 KEY_QUERY_VALUE,
                 &objectAttributes);

    if (!NT_SUCCESS(status))
        return;

    RtlInitUnicodeString( &valueName, L"DfsDebugTraceLevelServer" );

    status = ZwQueryValueKey(
                 handle,
                 &valueName,
                 KeyValueFullInformation,
                 &keyValueInformation,
                 sizeof(keyValueInformation),
                 &lengthRequired
                 );

    if (
        NT_SUCCESS(status) &&
        keyValueInformation.Type == REG_DWORD &&
        keyValueInformation.DataLength != 0
    ) {

        Flags = *(PULONG)(((PUCHAR)(&keyValueInformation)) + keyValueInformation.DataOffset);
        DfsDebugTraceLevel = Flags;

    }

    ZwClose( handle );

    return;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\dfslpc.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.
//
//  File:       DFSLPC.H
//
//  Contents:   This module provides the prototypes and structures for
//              the routines associated with lpc calls
//
//  Functions:
//
//-----------------------------------------------------------------------------


#ifndef _DFSLPC_H_
#define _DFSLPC_H_

NTSTATUS
DfsLpcIpRequest (
    PDFS_IPADDRESS pIpAddress
);

NTSTATUS
DfsLpcDomRequest (
    PUNICODE_STRING pFtDfsName
);

NTSTATUS
DfsLpcSpcRequest (
    PUNICODE_STRING pSpcName,
    ULONG TypeFlags
);

VOID
DfsLpcDisconnect(
);

NTSTATUS
PktFsctrlDfsSrvConnect(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
);

NTSTATUS
PktFsctrlDfsSrvIpAddr(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
);

//
// Lpc port states
//

typedef enum {
    LPC_STATE_UNINITIALIZED = 0,
    LPC_STATE_INITIALIZING = 1,
    LPC_STATE_INITIALIZED = 2,
} LPC_PORT_STATE;

//
// Struct containing the LPC state and name of the port to connect to
//

typedef struct _DFS_LPC_INFO {

    //
    // the name of the lpc port to connect to
    //

    UNICODE_STRING LpcPortName;

    //
    // state of the connect
    //

    LPC_PORT_STATE LpcPortState;

    //
    //  A mutex to handle open port races
    //

    FAST_MUTEX LpcPortMutex;

    //
    // Lpc port handle
    //
    
    HANDLE LpcPortHandle;

    //
    // Resource for close
    //

    ERESOURCE LpcPortResource;

} DFS_LPC_INFO, *PDFS_LPC_INFO;


#endif // _DFSLPC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\dfslpc.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    lpc.c

Abstract:

    This module contains the code necessary to support sites using
    lpc upcalls from the dfs driver.

Author:

    Jim Harper (JHarper) 11-Dec-97

Revision History:

--*/

#include "dfsprocs.h"
#include "dfslpc.h"
#include <dfssrv.h>
#pragma hdrstop

#include "fsctrl.h"
#include "ipsup.h"

typedef struct {
    WORK_QUEUE_ITEM WorkQueueItem;
} DFS_CONNECT_ARG, *PDFS_CONNECT_ARG;

typedef struct {
    WORK_QUEUE_ITEM WorkQueueItem;
    DFS_IPADDRESS IpAddress;
} DFS_REQUEST_ARG, *PDFS_REQUEST_ARG;

VOID
DfsLpcConnect (
    IN PDFS_CONNECT_ARG DfsConnectArg
);

#define Dbg     0x2000

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsLpcConnect )
#pragma alloc_text( PAGE, DfsLpcIpRequest )
#pragma alloc_text( PAGE, DfsLpcDomRequest )
#pragma alloc_text( PAGE, DfsLpcDisconnect )
#endif

VOID
DfsLpcConnect (
    IN PDFS_CONNECT_ARG DfsConnectArg)
{
    NTSTATUS status = STATUS_SUCCESS;
    SECURITY_QUALITY_OF_SERVICE dynamicQos;
    PDFS_LPC_INFO pLpcInfo = &DfsData.DfsLpcInfo;

    DebugTrace(+1, Dbg, "DfsLpcConnect(Name=%wZ)\n",
                        &pLpcInfo->LpcPortName);
    DebugTrace( 0, Dbg, "DfsLpcConnect(Handle=0x%x)\n",
                        &pLpcInfo->LpcPortHandle);

    PAGED_CODE();

    dynamicQos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    dynamicQos.ImpersonationLevel = SecurityAnonymous;
    dynamicQos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    dynamicQos.EffectiveOnly = TRUE;

    ExAcquireResourceExclusiveLite( &pLpcInfo->LpcPortResource, TRUE );

    ASSERT(pLpcInfo->LpcPortName.Buffer != NULL);

    pLpcInfo->LpcPortState = LPC_STATE_INITIALIZED;

    status = NtConnectPort(
                 &pLpcInfo->LpcPortHandle,
                 &pLpcInfo->LpcPortName,
                 &dynamicQos,
                 NULL,                           // ClientView
                 NULL,                           // ServerView
                 NULL,                           // MaxMessageLength
                 NULL,                           // ConnectionInformation
                 NULL                            // ConnectionInformationLength
                 );

    DebugTrace(-1, Dbg, "DfsLpcConnect: NtConnectPort returned 0x%x\n", ULongToPtr( status ));

    if (!NT_SUCCESS(status)) {
        pLpcInfo->LpcPortState = LPC_STATE_UNINITIALIZED;
        if ( pLpcInfo->LpcPortHandle != NULL ) {
           NtClose( pLpcInfo->LpcPortHandle);
           pLpcInfo->LpcPortHandle = NULL;
        }
        if (pLpcInfo->LpcPortName.Buffer != NULL) {
            ExFreePool(pLpcInfo->LpcPortName.Buffer);
            RtlInitUnicodeString(&pLpcInfo->LpcPortName, NULL);
        }
    }

    ExReleaseResourceLite( &pLpcInfo->LpcPortResource );
    ExFreePool(DfsConnectArg);

    return;

}


NTSTATUS
DfsLpcIpRequest (
    PDFS_IPADDRESS pIpAddress)
{
    NTSTATUS status;
    DFSSRV_REQUEST_MESSAGE requestMessage;
    DFSSRV_REPLY_MESSAGE replyMessage;
    PDFS_LPC_INFO pLpcInfo = &DfsData.DfsLpcInfo;

    PAGED_CODE();

    requestMessage.Message.GetSiteName.IpAddress = *pIpAddress;

    //
    // Set up the message to send over the port.
    //

    requestMessage.PortMessage.u1.s1.DataLength =
            (USHORT)( sizeof(requestMessage) - sizeof(PORT_MESSAGE) );
    requestMessage.PortMessage.u1.s1.TotalLength = sizeof(requestMessage);
    requestMessage.PortMessage.u2.ZeroInit = 0;
    requestMessage.MessageType = DFSSRV_MESSAGE_GET_SITE_NAME;
    
    //
    // Send the message and wait for a response message.
    //

    status = NtRequestWaitReplyPort(
                 pLpcInfo->LpcPortHandle,
                 (PPORT_MESSAGE)&requestMessage,
                 (PPORT_MESSAGE)&replyMessage
                 );

    if ( !NT_SUCCESS(status) ) {
        goto exit;
    }

    //
    // Check the status returned in the reply.
    //

    status = replyMessage.Message.Result.Status;

exit:

    return status;

}


NTSTATUS
DfsLpcDomRequest (
    PUNICODE_STRING pFtName)
{
    NTSTATUS status;
    DFSSRV_REQUEST_MESSAGE requestMessage;
    DFSSRV_REPLY_MESSAGE replyMessage;
    PDFS_LPC_INFO pLpcInfo = &DfsData.DfsLpcInfo;

    PAGED_CODE();

    if ( pFtName->Length > ((MAX_FTNAME_LEN - 1) * sizeof(WCHAR))) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    RtlZeroMemory(requestMessage.Message.GetFtDfs.FtName, MAX_FTNAME_LEN * sizeof(WCHAR));
    RtlCopyMemory(requestMessage.Message.GetFtDfs.FtName, pFtName->Buffer, pFtName->Length);

    //
    // Set up the message to send over the port.
    //

    requestMessage.PortMessage.u1.s1.DataLength =
            (USHORT)( sizeof(requestMessage) - sizeof(PORT_MESSAGE) );
    requestMessage.PortMessage.u1.s1.TotalLength = sizeof(requestMessage);
    requestMessage.PortMessage.u2.ZeroInit = 0;
    requestMessage.MessageType = DFSSRV_MESSAGE_GET_DOMAIN_REFERRAL;
    
    //
    // Send the message and wait for a response message.
    //

    status = NtRequestWaitReplyPort(
                 pLpcInfo->LpcPortHandle,
                 (PPORT_MESSAGE)&requestMessage,
                 (PPORT_MESSAGE)&replyMessage
                 );

    if ( !NT_SUCCESS(status) ) {
        goto exit;
    }

    //
    // Check the status returned in the reply.
    //

    status = replyMessage.Message.Result.Status;

exit:

    return status;

}

NTSTATUS
DfsLpcSpcRequest(
    PUNICODE_STRING pSpcName,
    ULONG TypeFlags)
{
    NTSTATUS status;
    DFSSRV_REQUEST_MESSAGE requestMessage;
    DFSSRV_REPLY_MESSAGE replyMessage;
    PDFS_LPC_INFO pLpcInfo = &DfsData.DfsLpcInfo;

    PAGED_CODE();

    if ( pSpcName->Length > ((MAX_SPCNAME_LEN - 1) * sizeof(WCHAR))) {
        pSpcName = NULL;
    }

    RtlZeroMemory(requestMessage.Message.GetSpcName.SpcName, MAX_SPCNAME_LEN * sizeof(WCHAR));

    if (pSpcName != NULL) {
       RtlCopyMemory(requestMessage.Message.GetSpcName.SpcName, pSpcName->Buffer, pSpcName->Length);
    }
    requestMessage.Message.GetSpcName.Flags = TypeFlags;

    //
    // Set up the message to send over the port.
    //

    requestMessage.PortMessage.u1.s1.DataLength =
            (USHORT)( sizeof(requestMessage) - sizeof(PORT_MESSAGE) );
    requestMessage.PortMessage.u1.s1.TotalLength = sizeof(requestMessage);
    requestMessage.PortMessage.u2.ZeroInit = 0;
    requestMessage.MessageType = DFSSRV_MESSAGE_GET_SPC_ENTRY;
    
    //
    // Send the message and wait for a response message.
    //

    status = NtRequestWaitReplyPort(
                 pLpcInfo->LpcPortHandle,
                 (PPORT_MESSAGE)&requestMessage,
                 (PPORT_MESSAGE)&replyMessage
                 );

    if ( !NT_SUCCESS(status) ) {
        goto exit;
    }

    //
    // Check the status returned in the reply.
    //

    status = replyMessage.Message.Result.Status;

exit:

    return status;

}


VOID
DfsLpcDisconnect ( )
{
    NTSTATUS status;
    PDFS_LPC_INFO pLpcInfo = &DfsData.DfsLpcInfo;

    PAGED_CODE();

    //
    // Acquire exclusive access to the port resource, to prevent new
    // requests from being started.
    //

    ExAcquireResourceExclusiveLite( &pLpcInfo->LpcPortResource, TRUE );

    pLpcInfo->LpcPortState = LPC_STATE_UNINITIALIZED;

    if (pLpcInfo->LpcPortHandle != NULL) {
        NtClose( pLpcInfo->LpcPortHandle);
        pLpcInfo->LpcPortHandle = NULL;
    }

    if (pLpcInfo->LpcPortName.Buffer != NULL) {
        ExFreePool(pLpcInfo->LpcPortName.Buffer);
        RtlInitUnicodeString(&pLpcInfo->LpcPortName, NULL);
    }

    ExReleaseResourceLite( &pLpcInfo->LpcPortResource );

    return;

}

NTSTATUS
PktFsctrlDfsSrvConnect(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_SRV_DFSSRV_CONNECT_ARG arg;
    PDFS_CONNECT_ARG DfsConnectArg = NULL;
    PDFS_LPC_INFO pLpcInfo = &DfsData.DfsLpcInfo;

    STD_FSCTRL_PROLOGUE(DfsFsctrlDfsSrvConnect, TRUE, FALSE);

    if (InputBufferLength < sizeof(DFS_SRV_DFSSRV_CONNECT_ARG)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    //
    // unmarshal the arguments...
    //

    arg = (PDFS_SRV_DFSSRV_CONNECT_ARG) InputBuffer;

    OFFSET_TO_POINTER(arg->PortName.Buffer, arg);

    if (!UNICODESTRING_IS_VALID(arg->PortName, InputBuffer, InputBufferLength)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    DfsConnectArg = ExAllocatePoolWithTag(
                        NonPagedPool,
                        sizeof(DFS_CONNECT_ARG),
                        ' sfD');
                        

    if (DfsConnectArg == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit_with_status;
    }

    ExAcquireResourceExclusiveLite( &pLpcInfo->LpcPortResource, TRUE );

#if 0
    if (pLpcInfo->LpcPortName.Buffer != NULL) {
        ExFreePool(pLpcInfo->LpcPortName.Buffer);
        RtlInitUnicodeString(&pLpcInfo->LpcPortName, NULL);
    }
    if ( pLpcInfo->LpcPortHandle != NULL ) {
       NtClose( pLpcInfo->LpcPortHandle);
       pLpcInfo->LpcPortHandle = NULL;
    }
#endif

    pLpcInfo->LpcPortName.Buffer = ExAllocatePoolWithTag(
                                        PagedPool,
                                        arg->PortName.Length,
                                        ' sfD');

    if (pLpcInfo->LpcPortName.Buffer == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        ExFreePool(DfsConnectArg);
        ExReleaseResourceLite( &pLpcInfo->LpcPortResource );
        goto exit_with_status;
    }

    pLpcInfo->LpcPortName.Length = arg->PortName.Length;
    pLpcInfo->LpcPortName.MaximumLength = arg->PortName.Length;

    RtlCopyMemory(
        pLpcInfo->LpcPortName.Buffer,
        arg->PortName.Buffer,
        arg->PortName.Length);

    ExInitializeWorkItem(
            &DfsConnectArg->WorkQueueItem,
            DfsLpcConnect,
            DfsConnectArg);

    ExQueueWorkItem( &DfsConnectArg->WorkQueueItem, CriticalWorkQueue );

    pLpcInfo->LpcPortState = LPC_STATE_INITIALIZING;

    ExReleaseResourceLite( &pLpcInfo->LpcPortResource );

exit_with_status:

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg, "DfsFsctrlDfsSrvConnect: Exit -> %08lx\n", ULongToPtr( status ) );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\dfsprocs.h ===
//+----------------------------------------------------------------------------
//
//  File:       dfsprocs.h
//
//  Contents:
//
//  This module defines all of the globally used procedures in the Dfs server
//  driver
//
//  Functions:
//
//-----------------------------------------------------------------------------


#ifndef _DFSPROCS_
#define _DFSPROCS_

#include <ntos.h>
#include <string.h>
#include <fsrtl.h>
#include <zwapi.h>
#include <tdi.h>
#include <ntddnfs.h>                             // For communicating with
                                                 // the SMB Rdr

#include <ntddmup.h>                             // For UNC registration

#include <winnetwk.h>                            // For NETRESOURCE def'n

#include <dfsfsctl.h>                            // Dfs FsControl Codes.

#include "dfserr.h"
#include "dfsstr.h"
#include "nodetype.h"
#include "dfsmrshl.h"
#include "dfsrtl.h"
#include "pkt.h"
#include "dfslpc.h"
#include "dfsstruc.h"
#include "dfsdata.h"
#include "localvol.h"
#include "log.h"
#include "lvolinfo.h"
#include "fcbsup.h"
#include "reset.h"

#ifndef i386

#define DFS_UNALIGNED   UNALIGNED

#else

#define DFS_UNALIGNED

#endif // i386


//
//  The FSD Level dispatch routines.   These routines are called by the
//  I/O system via the dispatch table in the Driver Object.
//

NTSTATUS
DfsFsdCleanup (                         //  implemented in Close.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdClose (                           //  implemented in Close.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdCreate (                          //  implemented in Create.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdFileSystemControl (               //  implemented in Fsctrl.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdSetInformation (                  //  implemented in Fileinfo.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


//
//  Miscellaneous support routines
//

NTSTATUS
DfspInitSecDesc(
    PDFS_PKT    pkt);


NTSTATUS
DfsInitializeLogicalRoot (
    IN LPCWSTR Name,
    IN PUNICODE_STRING Prefix OPTIONAL,
    IN USHORT VcbFlags OPTIONAL
);

NTSTATUS
DfsInsertProvider(
    IN PUNICODE_STRING pustrProviderName,
    IN ULONG           fProvCapability,
    IN ULONG           eProviderId);

NTSTATUS
DfsDeleteLogicalRoot (
    IN PWSTR Name,
    IN BOOLEAN fForce
);

NTSTATUS
DfspLogRootNameToPath(
    LPCWSTR         Name,
    PUNICODE_STRING RootName
);


BOOLEAN
DfsLogicalRootExists(
    PWSTR       pwszName
);

PDFS_LOCAL_VOLUME_CONFIG
DfsNetInfoToConfigInfo(
    ULONG EntryType,
    ULONG ServiceType,
    LPWSTR pwszStgId,
    LPWSTR pwszShareName,
    GUID  *pUid,
    LPWSTR pwszEntryPrefix,
    LPWSTR pwszShortPrefix,
    LPNET_DFS_ENTRY_ID_CONTAINER NetInfo);

NTSTATUS
DfsCreateConnection(
    IN PDFS_SERVICE pService,
    IN PPROVIDER_DEF pProvider,
    OUT PHANDLE     handle
);

NTSTATUS
DfsCloseConnection(
        IN PDFS_SERVICE pService
);

BOOLEAN
DfsConcatenateFilePath (
    IN PUNICODE_STRING Dest,
    IN PWSTR RemainingPath,
    IN USHORT Length
);

VOID
DfspGetMaxReferrals (
   VOID		
);

//


//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#ifdef FlagOn
#undef FlagOn
#endif

#define FlagOn(Flags,SingleFlag) (              \
    (BOOLEAN)(((Flags) & (SingleFlag)) != 0 ? TRUE : FALSE) \
    )

#define SetFlag(Flags,SingleFlag) { \
    (Flags) |= (SingleFlag);        \
}


#define ClearFlag(Flags,SingleFlag) { \
    (Flags) &= ~(SingleFlag);         \
}

VOID GuidToString(
    IN GUID   *pGuid,
    OUT PWSTR pwszGuid);

VOID StringToGuid(
    IN PWSTR pwszGuid,
    OUT GUID *pGuid);

//
//  The following macro is used to determine if an FSD thread can block
//  for I/O or wait for a resource.  It returns TRUE if the thread can
//  block and FALSE otherwise.  This attribute can then be used to call
//  the FSD & FSP common work routine with the proper wait value.
//

#define CanFsdWait(IRP) ((BOOLEAN)(          \
    IoIsOperationSynchronous(IRP) ||             \
    DfsData.OurProcess == PsGetCurrentProcess())         \
)


//
//  The following macro is used by the FSP and FSD routines to complete
//  an IRP.
//

VOID
DfsCompleteRequest_Real (
    IN PIRP Irp,
    IN NTSTATUS Status
    );

#define DfsCompleteRequest(IRP,STATUS) { \
    DfsCompleteRequest_Real(IRP,STATUS); \
}



//
//  The following two macros are used by the Fsd/Fsp exception handlers to
//  process an exception.  The first macro is the exception filter used in
//  the Fsd/Fsp to decide if an exception should be handled at this level.
//  The second macro decides if the exception is to be finished off by
//  completing the IRP, and cleaning up the Irp Context, or if we should
//  bugcheck.  Exception values such as STATUS_FILE_INVALID (raised by
//  VerfySup.c) cause us to complete the Irp and cleanup, while exceptions
//  such as accvio cause us to bugcheck.
//
//  The basic structure for fsd/fsp exception handling is as follows:
//
//  DfsFsdXxx(...)
//  {
//  try {
//
//      ...
//
//  } except(DfsExceptionFilter("Xxx\n")) {
//
//      DfsProcessException( Irp, &Status );
//  }
//
//  Return Status;
//  }
//
//  LONG
//  DfsExceptionFilter (
//  IN PSZ String
//  );
//
//  VOID
//  DfsProcessException (
//  IN PIRP Irp,
//  IN PNTSTATUS ExceptionCode
//  );
//

LONG
DfsExceptionFilter (
    IN NTSTATUS ExceptionCode,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

NTSTATUS
DfsProcessException (
    IN PIRP Irp,
    IN NTSTATUS ExceptionCode
    );

//
//  VOID
//  DfsRaiseStatus (
//  IN NT_STATUS Status
//  );
//
//

#define DfsRaiseStatus(STATUS) {                \
    ExRaiseStatus( (STATUS) );                  \
    BugCheck( "DfsRaiseStatus "  #STATUS );     \
}


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//  try {
//      :
//      :
//
//  try_exit: NOTHING;
//  } finally {
//
//      :
//      :
//  }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//  #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//  #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }

#endif // _DFSPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\dfswml.c ===
#include "dfswml.h"


WML_CONTROL_GUID_REG _DfsDrv_ControlGuids[] = {
    { //d920eeb7-08b4-4ceb-bdc8-2d56660e8187 Debug control guid
        0xd920eeb7, 0x08b4, 0x4ceb, 
            { 0xbd, 0xc8, 0x2d, 0x56, 0x66, 0x0e, 0x81, 0x87 },
            // 3 trace guids per control guid.
            { 
               {// e3f1c64a-1a24-494b-8d47-ac37ad623342
                   0xe3f1c64a, 0x1a24, 0x494b,
                       { 0x8d, 0x47, 0xac, 0x37, 0xad, 0x62, 0x33, 0x42 },
               },
               { // c093f7a7-c2ff-47aa-ba7e-42b9ed3f621e
                   0xc093f7a7, 0xc2ff, 0x47aa,
                       { 0xba, 0x7e, 0x42, 0xb9, 0xed, 0x3f, 0x62, 0x1e },
               },
               { // 4ed36891-4175-48d2-a209-aad889fa225a
                   0x4ed36891, 0x4175, 0x48d2,
                       { 0xa2, 0x09, 0xaa, 0xd8, 0x89, 0xfa, 0x22, 0x5a },
               }
            },
    }
};



ULONG called = 0;

NTSTATUS
DfsDrvWmiDispatch(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    )
{
    WML_TINY_INFO Info;
    NTSTATUS Status;
    UNICODE_STRING RegPath;

    called = 1;
    RtlInitUnicodeString (&RegPath, L"Dfs");

    RtlZeroMemory (&Info, sizeof(Info));

    Info.ControlGuids = _DfsDrv_ControlGuids;
    Info.GuidCount = sizeof(_DfsDrv_ControlGuids) / sizeof(WML_CONTROL_GUID_REG);
    Info.DriverRegPath = &RegPath;
    
    Status = WmlTinySystemControl (&Info, pDeviceObject, pIrp);

    return Status;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\dfsmrshl.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       DfsMrshl.c
//
//  Contents:   Routines to handle marshalling of data structures. This file
//              has been specifically created so that user level code can
//              avail of the marshalling code simply by including this file.
//
//  Classes:
//
//  Functions:
//
//  History:    March 29, 1994          Milans created from PeterCo's routines
//
//-----------------------------------------------------------------------------

#ifdef KERNEL_MODE

#include "dfsprocs.h"
#include "dfsmrshl.h"
#include "dfsrtl.h"

#define Dbg              (DEBUG_TRACE_RTL)

#else // !KERNEL_MODE

#include "dfsmrshl.h"

#ifndef ExRaiseStatus
#define ExRaiseStatus(x)        RtlRaiseStatus(x)
#endif // ExRaiseStatus

#ifndef try_return
#define try_return(s)           {s; goto try_exit;}
#endif // try_return

#ifndef DebugTrace
#define DebugTrace(i,l,f,s)
#endif // DebugTrace

#endif // KERNEL_MODE



NTSTATUS
DfsRtlGetpwString(
    IN OUT PMARSHAL_BUFFER      MarshalBuffer,
    OUT    PWSTR                *ppwszString
);

NTSTATUS
DfsRtlPutpwString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PWSTR       *ppwszString
);

NTSTATUS
DfsRtlGetString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PSTRING String
);

NTSTATUS
DfsRtlPutString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PSTRING String
);


#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, DfsRtlGetpwString )
#pragma alloc_text( PAGE, DfsRtlPutpwString )
#pragma alloc_text( PAGE, DfsRtlGetString )
#pragma alloc_text( PAGE, DfsRtlPutString )
#pragma alloc_text( PAGE, DfsRtlGet )
#pragma alloc_text( PAGE, DfsRtlPut )
#pragma alloc_text( PAGE, DfsRtlSize )
#pragma alloc_text( PAGE, DfsRtlUnwindGet )

#endif //ALLOC_PRAGMA

#define UNREFERENCED_LABEL(label)\
    if(0) goto label;

#define DfsRtlGetUchar(MarshalBuffer, pValue) (                         \
    ((MarshalBuffer)->Current + 1 <= (MarshalBuffer)->Last) ?           \
        *(pValue) = (UCHAR)((MarshalBuffer)->Current[0]     ),          \
        (MarshalBuffer)->Current += 1,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_DATA_ERROR                                               \
    )

#define DfsRtlPutUchar(MarshalBuffer, pValue) (                         \
    ((MarshalBuffer)->Current + 1 <= (MarshalBuffer)->Last) ?           \
        (MarshalBuffer)->Current[0] = BYTE_0(*pValue),                  \
        (MarshalBuffer)->Current += 1,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_BUFFER_TOO_SMALL                                         \
    )


#define DfsRtlUnwindStringGet(s) {                                      \
    if((s)->Length != 0 && (s)->Buffer != NULL) {                       \
        MarshalBufferFree((s)->Buffer);                                 \
        (s)->Buffer = NULL;                                             \
        (s)->Length = 0;                                                \
    }                                                                   \
}

#define DfsRtlUnwindUnicodeStringGet(s)                                 \
    DfsRtlUnwindStringGet(s)


NTSTATUS
DfsRtlGetArrayUchar(
    IN OUT PMARSHAL_BUFFER      MarshalBuffer,
    IN ULONG                    cbArray,
    OUT PUCHAR                  pArray)
{
    NTSTATUS    status = STATUS_SUCCESS;

    DebugTrace(+1, Dbg, "DfsRtlGetArrayUchar: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    // ASSERT(ARGUMENT_PRESENT(pArray));

    try {
        UNREFERENCED_LABEL(try_exit);
        if (MarshalBuffer->Current + cbArray <= MarshalBuffer->Last) {
            memcpy(pArray, MarshalBuffer->Current, cbArray);
            MarshalBuffer->Current += cbArray;
        } else {
            status = STATUS_DATA_ERROR;
        }
    try_exit: NOTHING;
    } finally {
        if (AbnormalTermination()) {
            DebugTrace(0, Dbg,
                "DfsRtlGetArrayUchar - Abnormal termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }

    }

    DebugTrace(-1, Dbg, "DfsRtlGetArrayUchar: Exited %08lx\n", ULongToPtr( status ));
    return(status);
}

NTSTATUS
DfsRtlPutArrayUchar(
    IN OUT PMARSHAL_BUFFER      MarshalBuffer,
    IN ULONG                    cbArray,
    OUT PUCHAR                  pArray)
{
    NTSTATUS    status = STATUS_SUCCESS;

    DebugTrace(+1, Dbg, "DfsRtlGetArrayUchar: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    // ASSERT(ARGUMENT_PRESENT(pArray));

    try {
        UNREFERENCED_LABEL(try_exit);
        if (MarshalBuffer->Current + cbArray <= MarshalBuffer->Last) {
            if (cbArray) {
                memcpy(MarshalBuffer->Current, pArray, cbArray);
                MarshalBuffer->Current += cbArray;
            }
        } else {
            status = STATUS_BUFFER_TOO_SMALL;
        }
    try_exit: NOTHING;
    } finally {
        if (AbnormalTermination()) {
            DebugTrace(0, Dbg,
                "DfsRtlPutArrayUchar - Abnormal termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }

    }

    DebugTrace(-1, Dbg, "DfsRtlPutArrayUchar: Exited %08lx\n", ULongToPtr( status ));
    return(status);
}


NTSTATUS
DfsRtlGetpwString(
    IN OUT PMARSHAL_BUFFER      MarshalBuffer,
    OUT    PWSTR                *ppwszString
)
{
    USHORT size;
    PCHAR cp = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    DebugTrace(+1, Dbg, "DfsRtlGetpwString:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(ppwszString));

    try {
        UNREFERENCED_LABEL(try_exit);
        *ppwszString = NULL;
        if(NT_SUCCESS(status = DfsRtlGetUshort(MarshalBuffer, &size))) {
            if(size > 0) {
                if(
                    MarshalBuffer->Current + size <= MarshalBuffer->Last &&
                    ((ULONG)size + sizeof(WCHAR)) <= MAXUSHORT &&
                    (size & 0x1) == 0
                ) {
                    if((cp = ExAllocatePoolWithTag(
                                    PagedPool,
                                    size+sizeof(WCHAR),
                                    ' sfD')) != NULL) {
                        memcpy(cp, MarshalBuffer->Current, size);
                        *((WCHAR *) (cp + size)) = UNICODE_NULL;
                        *ppwszString = (PWCHAR) cp;
                        MarshalBuffer->Current += size;
                    } else
                        status = STATUS_INSUFFICIENT_RESOURCES;
                } else
                    status = STATUS_DATA_ERROR;
            }
        }
    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DebugTrace(0, Dbg,
                "DfsRtlGetpwString:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }

        if(!NT_SUCCESS(status) && cp)
                MarshalBufferFree(cp);
    }
    DebugTrace(-1, Dbg, "DfsRtlGetpwString:  Exit -> %08lx\n", ULongToPtr( status ));
    return status;
}


NTSTATUS
DfsRtlPutpwString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PWSTR       *ppwszString
)
{
    USHORT size;
    NTSTATUS status = STATUS_SUCCESS;

    DebugTrace(+1, Dbg, "DfsRtlPutpwString:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(ppwszString));


    try {
        UNREFERENCED_LABEL(try_exit);
        if (*ppwszString != NULL)
            size = wcslen(*ppwszString)*sizeof(WCHAR);
        else
            size = 0;
        if(NT_SUCCESS(status = DfsRtlPutUshort(MarshalBuffer, &size))) {
            if(size > 0) {
                if(MarshalBuffer->Current + size <= MarshalBuffer->Last) {
                    memcpy(MarshalBuffer->Current, *ppwszString, size);
                    MarshalBuffer->Current += size;
                } else
                    status = STATUS_BUFFER_TOO_SMALL;
            }
        }
    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DebugTrace(0, Dbg,
                "DfsRtlPutString:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }
    }
    DebugTrace(-1, Dbg, "DfsRtlPutString:  Exit -> %08lx\n", ULongToPtr( status ));
    return status;
}



NTSTATUS
DfsRtlGetString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PSTRING String
)
{
    USHORT size;
    PCHAR cp = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    DebugTrace(+1, Dbg, "DfsRtlGetString:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(String));

    try {
        UNREFERENCED_LABEL(try_exit);
        String->Length = String->MaximumLength = 0;
        String->Buffer = NULL;
        if(NT_SUCCESS(status = DfsRtlGetUshort(MarshalBuffer, &size))) {
            if(size > 0) {
                if(
                    MarshalBuffer->Current + size <= MarshalBuffer->Last &&
                    ((ULONG)size + sizeof(WCHAR)) <= MAXUSHORT &&
                    (size & 0x1) == 0
                ) {
                    if((cp = ExAllocatePoolWithTag(
                                PagedPool,
                                size+sizeof(WCHAR),
                                ' sfD')) != NULL) {
                        RtlZeroMemory(cp, size+sizeof(WCHAR));
                        memcpy(cp, MarshalBuffer->Current, size);
                        String->Length = (USHORT)size;
                        String->MaximumLength = size + sizeof(WCHAR);
                        String->Buffer = cp;
                        MarshalBuffer->Current += size;
                    } else
                        status = STATUS_INSUFFICIENT_RESOURCES;
                } else
                    status = STATUS_DATA_ERROR;
            }
        }
    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DebugTrace(0, Dbg,
                "DfsRtlGetString:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }

        if(!NT_SUCCESS(status) && cp)
                MarshalBufferFree(cp);
    }
    DebugTrace(-1, Dbg, "DfsRtlGetString:  Exit -> %08lx\n", ULongToPtr( status ));
    return status;
}



NTSTATUS
DfsRtlPutString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PSTRING String
)
{
    USHORT size;
    NTSTATUS status = STATUS_SUCCESS;

    DebugTrace(+1, Dbg, "DfsRtlPutString:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(String));


    try {
        UNREFERENCED_LABEL(try_exit);
        size = String->Length;
        if(NT_SUCCESS(status = DfsRtlPutUshort(MarshalBuffer, &size))) {
            if(size > 0) {
                if(MarshalBuffer->Current + size <= MarshalBuffer->Last) {
                    if(String->Buffer != NULL) {
                        memcpy(MarshalBuffer->Current, String->Buffer, size);
                        MarshalBuffer->Current += size;
                    } else
                        status = STATUS_DATA_ERROR;
                } else
                    status = STATUS_BUFFER_TOO_SMALL;
            }
        }
    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DebugTrace(0, Dbg,
                "DfsRtlPutString:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }
    }
    DebugTrace(-1, Dbg, "DfsRtlPutString:  Exit -> %08lx\n", ULongToPtr( status ));
    return status;
}



#ifdef  NOT_NEEDED

NTSTATUS
DfsRtlGetUnicodeString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PUNICODE_STRING UnicodeString
)
{
    USHORT size;
    PWCHAR wcp = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    DebugTrace(+1, Dbg, "DfsRtlGetUnicodeString:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(UnicodeString));

    try {
        UnicodeString->Length = UnicodeString->MaximumLength = 0;
        UnicodeString->Buffer = NULL;
        if(NT_SUCCESS(status = DfsRtlGetUshort(MarshalBuffer, &size))) {
            if(size > 0) {
                if(
                    MarshalBuffer->Current + size <= MarshalBuffer->Last &&
                    ((ULONG)size + sizeof(WCHAR)) <= MAXUSHORT &&
                    (size & 0x1) == 0
                ) {
                    if((wcp = (ExAllocatePoolWithTag)(
                                    PagedPool,
                                    size+sizeof(WCHAR)
                                    ' sfD')) != NULL) {
                        memcpy(wcp, MarshalBuffer->Current, size);
                        wcp[size/sizeof(WCHAR)] = UNICODE_NULL;
                        UnicodeString->Length = size;
                        UnicodeString->MaximumLength = size + sizeof(WCHAR);
                        UnicodeString->Buffer = wcp;
                        MarshalBuffer->Current += size;
                    } else
                        status = STATUS_INSUFFICIENT_RESOURCES;
                } else
                    status = STATUS_DATA_ERROR;
            }
        }
    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DebugTrace(0, Dbg,
                "DfsRtlGetUnicodeString:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }

        if(!NT_SUCCESS(status) && wcp)
                MarshalBufferFree(wcp);
    }
    DebugTrace(-1, Dbg, "DfsRtlGetUnicodeString:  Exit -> %08lx\n",
                status);
    return status;
}



NTSTATUS
DfsRtlPutUnicodeString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PUNICODE_STRING UnicodeString
)
{
    USHORT size;
    NTSTATUS status = STATUS_SUCCESS;

    DebugTrace(+1, Dbg, "DfsRtlPutUnicodeString:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(UnicodeString));

    try {
        size = UnicodeString->Length;
        if(NT_SUCCESS(status = DfsRtlPutUshort(MarshalBuffer, &size))) {
            if(size > 0) {
                if(MarshalBuffer->Current + size <= MarshalBuffer->Last) {
                    if(UnicodeString->Buffer != NULL) {
                        memcpy(
                            MarshalBuffer->Current,
                            UnicodeString->Buffer,
                            size
                        );
                        MarshalBuffer->Current += size;
                    } else
                        status = STATUS_DATA_ERROR;
                } else
                    status = STATUS_BUFFER_TOO_SMALL;
            }
        }
    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DebugTrace(0, Dbg,
                "DfsRtlPutUnicodeString:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }
    }
    DebugTrace(-1, Dbg, "DfsRtlPutUnicodeString:  Exit -> %08lx\n",
                status);
    return status;
}

#else   // NOT_NEEDED

#define DfsRtlGetUnicodeString(b, s)\
    DfsRtlGetString(b, (PSTRING)(s))

#define DfsRtlPutUnicodeString(b, s)\
    DfsRtlPutString(b, (PSTRING)(s))

#endif  // NOT_NEEDED





NTSTATUS
DfsRtlGet(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    IN  PMARSHAL_INFO MarshalInfo,
    OUT PVOID Item
)
{
    PMARSHAL_TYPE_INFO typeInfo;
    PVOID subItem;
    PVOID subItemElem;
    ULONG cnt;
    ULONG unwindcnt;
    PUCHAR cntptr;
    ULONG itemSize;
    PMARSHAL_INFO subInfo;
    NTSTATUS status = STATUS_SUCCESS;

    DebugTrace(+1, Dbg, "DfsRtlGet:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(MarshalInfo));
    ASSERT(ARGUMENT_PRESENT(Item));

    try {

        RtlZeroMemory(Item, MarshalInfo->_size);

        for(typeInfo = &MarshalInfo->_typeInfo[0];
            typeInfo < &MarshalInfo->_typeInfo[MarshalInfo->_typecnt];
            typeInfo++) {

            switch(typeInfo->_type & MTYPE_BASE_TYPE) {
            case MTYPE_COMPOUND:
                subInfo = typeInfo->_subinfo;
                itemSize = subInfo->_size;
                //
                // If this compound type is a conformant structure, then
                // we need to adjust the size field here.
                //
                if (subInfo->_typecnt > 0 &&
                      subInfo->_typeInfo[0]._type == MTYPE_CONFORMANT_CNT) {
                   MARSHAL_BUFFER tempMarshalBuffer = *MarshalBuffer;
                   ULONG extraSize = 0;

                   status = DfsRtlGetUlong(&tempMarshalBuffer, &extraSize);
                   if (!NT_SUCCESS(status) || (itemSize + extraSize) < itemSize) {
                       try_return(status = STATUS_DATA_ERROR);
                   }
                   itemSize += extraSize;
                }
                break;
            case MTYPE_CONFORMANT_CNT:
                itemSize = 0;
                break;
            case MTYPE_GUID:
                itemSize = sizeof(GUID);
                break;
            case MTYPE_STRING:
                itemSize = sizeof(STRING);
                break;
            case MTYPE_UNICODE_STRING:
                itemSize = sizeof(UNICODE_STRING);
                break;
            case MTYPE_PWSTR:
                itemSize = sizeof(PWSTR);
                break;
            case MTYPE_ULONG:
                itemSize = sizeof(ULONG);
                break;
            case MTYPE_USHORT:
                itemSize = sizeof(USHORT);
                break;
            case MTYPE_UCHAR:
                itemSize = sizeof(UCHAR);
                break;
            default:
                try_return(status = STATUS_DATA_ERROR);
            }

            if(typeInfo->_type & MTYPE_COUNTED_ARRAY) {
                cntptr = ((PUCHAR)Item + typeInfo->_cntoff);
                switch(typeInfo->_cntsize) {
                case sizeof(UCHAR):
                    cnt = *(PUCHAR)cntptr;
                    break;
                case sizeof(USHORT):
                    cnt = *(PUSHORT)cntptr;
                    break;
                case sizeof(ULONG):
                    cnt = *(PULONG)cntptr;
                    break;
                default:
                    try_return(status = STATUS_DATA_ERROR);
                }
            } else if (typeInfo->_type & MTYPE_STATIC_ARRAY) {
                cnt = typeInfo->_cntoff;
            } else {
                cnt = 1;
            }

            if(typeInfo->_type & MTYPE_INDIRECT) {
                if((typeInfo->_type & MTYPE_COUNTED_ARRAY) && cnt == 0)
                    subItem = NULL;
                else {
                    subItem = NULL;
                    if ((cnt != 0) && ((itemSize * cnt) / cnt) == itemSize)
                        subItem = ExAllocatePoolWithTag(
                                    PagedPool,
                                    itemSize * cnt,
                                    ' sfD');
                    if(subItem == NULL)
                        try_return(status = STATUS_INSUFFICIENT_RESOURCES);
                }
                *(PVOID *)((PUCHAR)Item + typeInfo->_off) = subItem;
            }
            else
                subItem = ((PUCHAR)Item + typeInfo->_off);

            switch(typeInfo->_type & ~MTYPE_INDIRECT) {

            case MTYPE_COMPOUND:
                    status = DfsRtlGet(
                        MarshalBuffer,
                        subInfo,
                        subItem
                    );
                    break;
            case MTYPE_CONFORMANT_CNT:
                    //
                    // this field is used only when sizing a conformant
                    // structure. As such, there is no place to unmarshal
                    // it into. So, simply eat the ulong.
                    //
                    status = DfsRtlGetUlong(MarshalBuffer, &itemSize);
                    break;
            case (MTYPE_COMPOUND|MTYPE_COUNTED_ARRAY):
            case (MTYPE_COMPOUND|MTYPE_STATIC_ARRAY):
                    subItemElem = (PUCHAR)subItem;
                    unwindcnt = cnt;
                    while(cnt--) {
                        status = DfsRtlGet(
                            MarshalBuffer,
                            subInfo,
                            subItemElem
                        );
                        if(!NT_SUCCESS(status)) {
                            while((++cnt) < unwindcnt) {
                                ((PUCHAR)subItemElem) -= itemSize;
                                DfsRtlUnwindGet(
                                    subInfo,
                                    &subInfo->_typeInfo[subInfo->_typecnt],
                                    subItemElem
                                );
                            }
                            if(typeInfo->_type & MTYPE_INDIRECT)
                                MarshalBufferFree(subItem);
                            break;
                        }
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case MTYPE_GUID:
                    status = DfsRtlGetGuid(
                        MarshalBuffer,
                        (GUID *)subItem
                    );
                    break;
            case MTYPE_STRING:
                    status = DfsRtlGetString(
                        MarshalBuffer,
                        (PSTRING)subItem
                    );
                    break;
            case MTYPE_UNICODE_STRING:
                    status = DfsRtlGetUnicodeString(
                        MarshalBuffer,
                        (PUNICODE_STRING)subItem
                    );
                    break;

            case MTYPE_PWSTR:
                    status = DfsRtlGetpwString(
                        MarshalBuffer,
                        (PWSTR *)subItem
                    );
                    break;

            case (MTYPE_PWSTR|MTYPE_COUNTED_ARRAY):
            case (MTYPE_PWSTR|MTYPE_STATIC_ARRAY):
                    subItemElem = (PUCHAR)subItem;
                    unwindcnt = cnt;
                    while (cnt--) {
                        status = DfsRtlGetpwString(
                            MarshalBuffer,
                            (PWSTR *)subItemElem);
                        if (!NT_SUCCESS(status)) {
                            while ((++cnt) < unwindcnt) {
                                ((PUCHAR)subItemElem) -= itemSize;
                                MarshalBufferFree((PVOID)*(PWSTR *)subItemElem);
                            }
                            if (typeInfo->_type & MTYPE_INDIRECT) {
                                MarshalBufferFree(subItem);
                            }
                            break;
                        }
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case (MTYPE_UNICODE_STRING|MTYPE_COUNTED_ARRAY):
            case (MTYPE_UNICODE_STRING|MTYPE_STATIC_ARRAY):
                    subItemElem = (PUCHAR)subItem;
                    unwindcnt = cnt;
                    while(cnt--) {
                        status = DfsRtlGetUnicodeString(
                            MarshalBuffer,
                            (PUNICODE_STRING)subItemElem
                        );
                        if(!NT_SUCCESS(status)) {
                            while((++cnt) < unwindcnt) {
                                ((PUCHAR)subItemElem) -= itemSize;
                                DfsRtlUnwindUnicodeStringGet(
                                    (PUNICODE_STRING)subItemElem
                                );
                            }
                            if(typeInfo->_type & MTYPE_INDIRECT)
                                MarshalBufferFree(subItem);
                            break;
                        }
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case MTYPE_ULONG:
                    status = DfsRtlGetUlong(
                        MarshalBuffer,
                        (PULONG)subItem
                    );
                    break;
            case MTYPE_USHORT:
                    status = DfsRtlGetUshort(
                        MarshalBuffer,
                        (PUSHORT)subItem);
                    break;
            case MTYPE_UCHAR:
                    status = DfsRtlGetUchar(
                        MarshalBuffer,
                        (PUCHAR)subItem);
                    break;
            case MTYPE_UCHAR|MTYPE_COUNTED_ARRAY:
            case MTYPE_UCHAR|MTYPE_STATIC_ARRAY:
                    status = DfsRtlGetArrayUchar(
                        MarshalBuffer,
                        cnt,
                        (PUCHAR)subItem);
                    break;
            default:
                    status = STATUS_DATA_ERROR;
                    break;
            };
            if(!NT_SUCCESS(status))
                break;
        }

    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DebugTrace(0, Dbg, "DfsRtlGet:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }

        if(!NT_SUCCESS(status))
            DfsRtlUnwindGet(MarshalInfo, typeInfo, Item);
    }

    DebugTrace(-1, Dbg, "DfsRtlGet:  Exit -> %08lx\n", ULongToPtr( status ));
    return status;
}



NTSTATUS
DfsRtlPut(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    IN  PMARSHAL_INFO MarshalInfo,
    OUT PVOID Item
)
{
    PMARSHAL_TYPE_INFO typeInfo;
    PVOID subItem;
    PVOID subItemElem;
    ULONG cnt;
    PUCHAR cntptr;
    ULONG itemSize;
    PMARSHAL_INFO subInfo;
    NTSTATUS status = STATUS_SUCCESS;

    DebugTrace(+1, Dbg, "DfsRtlPut:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(MarshalInfo));
    ASSERT(ARGUMENT_PRESENT(Item));

    try {
        for(typeInfo = &MarshalInfo->_typeInfo[0];
            typeInfo < &MarshalInfo->_typeInfo[MarshalInfo->_typecnt];
            typeInfo++) {

            switch(typeInfo->_type & MTYPE_BASE_TYPE) {
            case MTYPE_COMPOUND:
                subInfo = typeInfo->_subinfo;
                itemSize = subInfo->_size;
                break;
            case MTYPE_CONFORMANT_CNT:
                itemSize = typeInfo->_off;
                break;
            case MTYPE_GUID:
                itemSize = sizeof(GUID);
                break;
            case MTYPE_STRING:
                itemSize = sizeof(STRING);
                break;
            case MTYPE_UNICODE_STRING:
                itemSize = sizeof(UNICODE_STRING);
                break;
            case MTYPE_PWSTR:
                itemSize = sizeof(PWSTR);
                break;
            case MTYPE_ULONG:
                itemSize = sizeof(ULONG);
                break;
            case MTYPE_USHORT:
                itemSize = sizeof(USHORT);
                break;
            case MTYPE_UCHAR:
                itemSize = sizeof(UCHAR);
                break;
            default:
                try_return(status = STATUS_DATA_ERROR);
            }

            if(typeInfo->_type & MTYPE_COUNTED_ARRAY ||
               typeInfo->_type == MTYPE_CONFORMANT_CNT) {
                cntptr = ((PUCHAR)Item + typeInfo->_cntoff);
                switch(typeInfo->_cntsize) {
                case sizeof(UCHAR):
                    cnt = *(PUCHAR)cntptr;
                    break;
                case sizeof(USHORT):
                    cnt = *(PUSHORT)cntptr;
                    break;
                case sizeof(ULONG):
                    cnt = *(PULONG)cntptr;
                    break;
                default:
                    try_return(status = STATUS_DATA_ERROR);
                }
            } else
                cnt = typeInfo->_cntoff;

            if(typeInfo->_type & MTYPE_INDIRECT) {
                subItem = *(PUCHAR *)((PUCHAR)Item + typeInfo->_off);
                if(subItem == NULL &&
                   !((typeInfo->_type & MTYPE_COUNTED_ARRAY) && cnt == 0))
                    try_return(status = STATUS_DATA_ERROR);
            } else
                subItem = ((PUCHAR)Item + typeInfo->_off);

            switch(typeInfo->_type & ~MTYPE_INDIRECT) {

            case MTYPE_COMPOUND:
                    status = DfsRtlPut(
                        MarshalBuffer,
                        subInfo,
                        subItem
                    );
                    break;
            case MTYPE_CONFORMANT_CNT:
                    cnt *= itemSize;
                    status = DfsRtlPutUlong(
                                MarshalBuffer,
                                &cnt);
                    break;
            case (MTYPE_COMPOUND|MTYPE_COUNTED_ARRAY):
            case (MTYPE_COMPOUND|MTYPE_STATIC_ARRAY):
                    //
                    // No sense in having an array of conformant structures
                    // ASSERT this fact
                    //

                    ASSERT(subInfo->_typecnt == 0
                                    ||
                           subInfo->_typeInfo[0]._type != MTYPE_CONFORMANT_CNT
                          );

                    subItemElem = (PUCHAR)subItem;
                    while(cnt--) {
                        status = DfsRtlPut(
                            MarshalBuffer,
                            subInfo,
                            subItemElem
                        );
                        if(!NT_SUCCESS(status))
                            break;
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case MTYPE_GUID:
                    status = DfsRtlPutGuid(
                        MarshalBuffer,
                        (GUID *)subItem
                    );
                    break;
            case MTYPE_STRING:
                    status = DfsRtlPutString(
                        MarshalBuffer,
                        (PSTRING)subItem
                    );
                    break;
            case MTYPE_UNICODE_STRING:
                    status = DfsRtlPutUnicodeString(
                        MarshalBuffer,
                        (PUNICODE_STRING)subItem
                    );
                    break;
            case MTYPE_PWSTR:
                    status = DfsRtlPutpwString(
                        MarshalBuffer,
                        (PWSTR *)subItem
                    );
                    break;

            case (MTYPE_PWSTR|MTYPE_COUNTED_ARRAY):
            case (MTYPE_PWSTR|MTYPE_STATIC_ARRAY):
                    subItemElem = (PWSTR *)subItem;
                    while(cnt--) {
                        status = DfsRtlPutpwString(
                            MarshalBuffer,
                            (PWSTR *)subItemElem);
                        if (!NT_SUCCESS(status))
                            break;
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case (MTYPE_UNICODE_STRING|MTYPE_COUNTED_ARRAY):
            case (MTYPE_UNICODE_STRING|MTYPE_STATIC_ARRAY):
                    subItemElem = (PUCHAR)subItem;
                    while(cnt--) {
                        status = DfsRtlPutUnicodeString(
                            MarshalBuffer,
                            (PUNICODE_STRING)subItemElem
                        );
                        if(!NT_SUCCESS(status))
                            break;
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case MTYPE_ULONG:
                    status = DfsRtlPutUlong(
                        MarshalBuffer,
                        (PULONG)subItem
                    );
                    break;
            case MTYPE_USHORT:
                    status = DfsRtlPutUshort(
                        MarshalBuffer,
                        (PUSHORT)subItem);
                    break;
            case MTYPE_UCHAR:
                    status = DfsRtlPutUchar(
                        MarshalBuffer,
                        (PUCHAR)subItem);
                    break;
            case (MTYPE_UCHAR|MTYPE_COUNTED_ARRAY):
            case (MTYPE_UCHAR|MTYPE_STATIC_ARRAY):
                    status = DfsRtlPutArrayUchar(
                                    MarshalBuffer,
                                    cnt,
                                    (PUCHAR)subItem);
                    break;
            default:
                    status = STATUS_DATA_ERROR;
                break;
            }

            if(!NT_SUCCESS(status))
                break;
        }

    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DebugTrace(0, Dbg, "DfsRtlPut:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }
    }

    DebugTrace(-1, Dbg, "DfsRtlPut:  Exit -> %08lx\n", ULongToPtr( status ));
    return status;
}




NTSTATUS
DfsRtlSize(
    IN  PMARSHAL_INFO MarshalInfo,
    IN  PVOID Item,
    OUT PULONG Size
)
{
    PMARSHAL_TYPE_INFO typeInfo;
    PVOID subItem;
    PVOID subItemElem;
    ULONG cnt;
    PUCHAR cntptr;
    ULONG itemSize;
    PMARSHAL_INFO subInfo;
    NTSTATUS status = STATUS_SUCCESS;

    DebugTrace(+1, Dbg, "DfsRtlSize:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalInfo));
    ASSERT(ARGUMENT_PRESENT(Item));
    ASSERT(ARGUMENT_PRESENT(Size));

    try {
        for(typeInfo = &MarshalInfo->_typeInfo[0];
            typeInfo < &MarshalInfo->_typeInfo[MarshalInfo->_typecnt];
            typeInfo++) {

            switch(typeInfo->_type & MTYPE_BASE_TYPE) {
            case MTYPE_COMPOUND:
                subInfo = typeInfo->_subinfo;
                itemSize = subInfo->_size;
                break;
            case MTYPE_CONFORMANT_CNT:
                //
                // For conformant structures, _offset is sizeof each
                // element, _cntsize is sizeof cnt field, and _cntoff is
                // offset of cnt field.
                //
                itemSize = typeInfo->_off;
                break;
            case MTYPE_GUID:
                itemSize = sizeof(GUID);
                break;
            case MTYPE_STRING:
                itemSize = sizeof(STRING);
                break;
            case MTYPE_UNICODE_STRING:
                itemSize = sizeof(UNICODE_STRING);
                break;
            case MTYPE_PWSTR:
                itemSize = sizeof(PWCHAR);
                break;
            case MTYPE_ULONG:
                itemSize = sizeof(ULONG);
                break;
            case MTYPE_USHORT:
                itemSize = sizeof(USHORT);
                break;
            case MTYPE_UCHAR:
                itemSize = sizeof(UCHAR);
                break;
            default:
                try_return(status = STATUS_DATA_ERROR);
            }

            if(typeInfo->_type & MTYPE_COUNTED_ARRAY ||
               typeInfo->_type == MTYPE_CONFORMANT_CNT) {
                cntptr = ((PUCHAR)Item + typeInfo->_cntoff);
                switch(typeInfo->_cntsize) {
                case sizeof(UCHAR):
                    cnt = *(PUCHAR)cntptr;
                    break;
                case sizeof(USHORT):
                    cnt = *(PUSHORT)cntptr;
                    break;
                case sizeof(ULONG):
                    cnt = *(PULONG)cntptr;
                    break;
                default:
                    try_return(status = STATUS_DATA_ERROR);
                }
            } else
                cnt = typeInfo->_cntoff;

            if(typeInfo->_type & MTYPE_INDIRECT) {
                subItem = *(PUCHAR *)((PUCHAR)Item + typeInfo->_off);
                if(subItem == NULL &&
                   !((typeInfo->_type & MTYPE_COUNTED_ARRAY) && cnt == 0))
                    try_return(status = STATUS_DATA_ERROR);
            } else
                subItem = ((PUCHAR)Item + typeInfo->_off);

            switch(typeInfo->_type & ~MTYPE_INDIRECT) {

            case MTYPE_COMPOUND:
                    status = DfsRtlSize(
                        subInfo,
                        subItem,
                        Size
                    );
                    break;
            case MTYPE_CONFORMANT_CNT:
                    (*Size) += sizeof(ULONG);
                    break;
            case (MTYPE_COMPOUND|MTYPE_COUNTED_ARRAY):
            case (MTYPE_COMPOUND|MTYPE_STATIC_ARRAY):
                    //
                    // No sense in having an array of conformant structures
                    // ASSERT this fact
                    //

                    ASSERT(subInfo->_typecnt == 0
                                    ||
                           subInfo->_typeInfo[0]._type != MTYPE_CONFORMANT_CNT
                          );

                    subItemElem = (PUCHAR)subItem;
                    while(cnt--) {
                        status = DfsRtlSize(
                            subInfo,
                            subItemElem,
                            Size
                        );
                        if(!NT_SUCCESS(status))
                            break;
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case MTYPE_GUID:
                    (*Size) += 16;
                    break;
            case MTYPE_STRING:
                    status = DfsRtlSizeString(
                        (PSTRING)subItem,
                        Size
                    );
                    break;
            case MTYPE_UNICODE_STRING:
                    status = DfsRtlSizeUnicodeString(
                        (PUNICODE_STRING)subItem,
                        Size
                    );
                    break;

            case MTYPE_PWSTR:
                    status = DfsRtlSizepwString(
                        (PWSTR *)subItem,
                        Size
                    );
                    break;
            case (MTYPE_PWSTR|MTYPE_COUNTED_ARRAY):
            case (MTYPE_PWSTR|MTYPE_STATIC_ARRAY):
                    subItemElem = (PUCHAR)subItem;
                    while (cnt--) {
                        status = DfsRtlSizepwString(
                            (PWSTR *)subItemElem,
                            Size);
                        if (!NT_SUCCESS(status)) {
                            break;
                        }
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case (MTYPE_UNICODE_STRING|MTYPE_COUNTED_ARRAY):
            case (MTYPE_UNICODE_STRING|MTYPE_STATIC_ARRAY):
                    subItemElem = (PUCHAR)subItem;
                    while(cnt--) {
                        status = DfsRtlSizeUnicodeString(
                            (PUNICODE_STRING)subItemElem,
                            Size
                        );
                        if(!NT_SUCCESS(status))
                            break;
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case MTYPE_ULONG:
                    (*Size) += 4;
                    break;
            case MTYPE_USHORT:
                    (*Size) += 2;
                    break;
            case MTYPE_UCHAR:
                    (*Size) += 1;
                    break;
            case MTYPE_UCHAR|MTYPE_COUNTED_ARRAY:
            case MTYPE_UCHAR|MTYPE_STATIC_ARRAY:
                    (*Size) += (cnt * sizeof(UCHAR));
                    break;
            default:
                    status = STATUS_DATA_ERROR;
                    break;
            };
            if(!NT_SUCCESS(status))
                break;
        }

    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DebugTrace(0, Dbg, "DfsRtlSize:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }
    }

    DebugTrace(0, Dbg, "DfsRtlSize:  (*Size) = %ld\n", ULongToPtr( (*Size) ));
    DebugTrace(-1, Dbg, "DfsRtlSize:  Exit -> %08lx\n", ULongToPtr( status ));
    return status;
}




VOID
DfsRtlUnwindGet(
    IN  PMARSHAL_INFO MarshalInfo,
    IN  PMARSHAL_TYPE_INFO LastTypeInfo,
    IN  PVOID Item
)
{
    PMARSHAL_TYPE_INFO typeInfo;
    PVOID subItem;
    PVOID subItemElem;
    ULONG cnt;
    PUCHAR cntptr;
    ULONG itemSize;
    PMARSHAL_INFO subInfo;
    NTSTATUS status = STATUS_SUCCESS;

    DebugTrace(+1, Dbg, "DfsRtlUnwindGet:  Entered\n", 0);

    for(typeInfo = &MarshalInfo->_typeInfo[0];
        typeInfo < LastTypeInfo;
        typeInfo++) {

        switch(typeInfo->_type & MTYPE_BASE_TYPE) {
        case MTYPE_COMPOUND:
            subInfo = typeInfo->_subinfo;
            itemSize = subInfo->_size;
            break;
        case MTYPE_GUID:
            itemSize = sizeof(GUID);
            break;
        case MTYPE_STRING:
            itemSize = sizeof(STRING);
            break;
        case MTYPE_UNICODE_STRING:
            itemSize = sizeof(UNICODE_STRING);
            break;
        case MTYPE_ULONG:
            itemSize = sizeof(ULONG);
            break;
        case MTYPE_USHORT:
            itemSize = sizeof(USHORT);
            break;
        case MTYPE_UCHAR:
            itemSize = sizeof(UCHAR);
            break;
        default:
            ExRaiseStatus(STATUS_DATA_ERROR);
        }

        if(typeInfo->_type & MTYPE_COUNTED_ARRAY) {
            cntptr = ((PUCHAR)Item + typeInfo->_cntoff);
            switch(typeInfo->_cntsize) {
            case sizeof(UCHAR):
                cnt = *(PUCHAR)cntptr;
                break;
            case sizeof(USHORT):
                cnt = *(PUSHORT)cntptr;
                break;
            case sizeof(ULONG):
                cnt = *(PULONG)cntptr;
                break;
            default:
                ExRaiseStatus(STATUS_DATA_ERROR);
            }
        } else
            cnt = typeInfo->_cntoff;

        if(typeInfo->_type & MTYPE_INDIRECT) {
            subItem = *(PUCHAR *)((PUCHAR)Item + typeInfo->_off);
            if(subItem == NULL &&
               !((typeInfo->_type & MTYPE_COUNTED_ARRAY) && cnt == 0))
                ExRaiseStatus(STATUS_DATA_ERROR);
        } else
            subItem = ((PUCHAR)Item + typeInfo->_off);

        switch(typeInfo->_type & ~MTYPE_INDIRECT) {

        case MTYPE_COMPOUND:
                DfsRtlUnwindGet(
                    subInfo,
                    &subInfo->_typeInfo[subInfo->_typecnt],
                    subItem
                );
                break;
        case (MTYPE_COMPOUND|MTYPE_COUNTED_ARRAY):
        case (MTYPE_COMPOUND|MTYPE_STATIC_ARRAY):
                subItemElem = (PUCHAR)subItem;
                while(cnt--) {
                    DfsRtlUnwindGet(
                        subInfo,
                        &subInfo->_typeInfo[subInfo->_typecnt],
                        subItemElem
                    );
                    ((PUCHAR)subItemElem) += itemSize;
                }
                break;
        case MTYPE_STRING:
                DfsRtlUnwindStringGet((PSTRING)subItem);
                break;
        case MTYPE_UNICODE_STRING:
                DfsRtlUnwindUnicodeStringGet((PUNICODE_STRING)subItem);
                break;
        case (MTYPE_UNICODE_STRING|MTYPE_COUNTED_ARRAY):
        case (MTYPE_UNICODE_STRING|MTYPE_STATIC_ARRAY):
                subItemElem = (PUCHAR)subItem;
                while(cnt--) {
                    DfsRtlUnwindUnicodeStringGet((PUNICODE_STRING)subItemElem);
                    ((PUCHAR)subItemElem) += itemSize;
                }
                break;
        case MTYPE_GUID:
        case MTYPE_ULONG:
        case MTYPE_USHORT:
        case MTYPE_UCHAR:
                break;
        default:
                ExRaiseStatus(STATUS_DATA_ERROR);
        };

        if(typeInfo->_type & MTYPE_INDIRECT) {
            MarshalBufferFree(subItem);
            *(PUCHAR *)((PUCHAR)Item + typeInfo->_off) = NULL;
        }
    }
    DebugTrace(-1, Dbg, "DfsRtlUnwindGet:  Exit -> VOID\n", 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\dfsstruc.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       dfsstruc.h
//
//  Contents:
//      This module defines the data structures that make up the major internal
//      part of the DFS file system.
//
//  Functions:
//
//-----------------------------------------------------------------------------


#ifndef _DFSSTRUC_
#define _DFSSTRUC_

typedef enum {
    DFS_STATE_UNINITIALIZED = 0,
    DFS_STATE_INITIALIZED = 1,
    DFS_STATE_STARTED = 2,
    DFS_STATE_STOPPING = 3,
    DFS_STATE_STOPPED = 4
} DFS_OPERATIONAL_STATE;

typedef enum {
    DFS_UNKNOWN = 0,
    DFS_CLIENT = 1,
    DFS_SERVER = 2,
    DFS_ROOT_SERVER = 3,
} DFS_MACHINE_STATE;

typedef enum {
    LV_UNINITIALIZED = 0,
    LV_INITSCHEDULED,
    LV_INITINPROGRESS,
    LV_INITIALIZED,
    LV_VALIDATED
} DFS_LV_STATE;

//
//  The DFS_DATA record is the top record in the DFS file system in-memory
//  data structure.  This structure must be allocated from non-paged pool.
//

typedef struct _DFS_DATA {

    //
    //  The type and size of this record (must be DFS_NTC_DATA_HEADER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A queue of all attached volume device objects
    //

    LIST_ENTRY AVdoQueue;

    //
    //  A queue of all attached file system device objects
    //

    LIST_ENTRY AFsoQueue;

    //
    //  A pointer to the Driver object we were initialized with
    //

    PDRIVER_OBJECT DriverObject;

    //
    //  A pointer to the \Dfs device object
    //

    PDEVICE_OBJECT FileSysDeviceObject;

    //
    //  A pointer to an array of provider records
    //

    struct _PROVIDER_DEF *pProvider;
    int cProvider, maxProvider;

    //
    //  A resource variable to control access to the global data record
    //

    ERESOURCE Resource;

    //
    //  A pointer to our EPROCESS struct, which is a required input to the
    //  Cache Management subsystem.  This field is simply set each time an
    //  FSP thread is started, since it is easiest to do while running in the
    //  Fsp.
    //

    PEPROCESS OurProcess;

    //
    //  Principal Name of this machine.
    //

    UNICODE_STRING PrincipalName;

    //
    //  The NetBIOS name of this machine. Needed for public Dfs APIs.
    //

    UNICODE_STRING NetBIOSName;

    //
    //  The operational state of the machine - Started, Stopped, etc.
    //

    DFS_OPERATIONAL_STATE OperationalState;

    //
    //  The state of the machine - DC, Server, Client etc.
    //

    DFS_MACHINE_STATE MachineState;

    //
    // Is this a DC?
    //

    BOOLEAN IsDC;

    //
    // The state of the local volumes - initialize or validated

    DFS_LV_STATE LvState;

    //
    // The system wide Partition Knowledge Table (PKT)
    //

    DFS_PKT Pkt;

    //
    //  A hash table for associating DFS_FCBs with file objects
    //

    struct _FCB_HASH_TABLE *FcbHashTable;

    //
    //  A hash table for associating Sites with machines
    //

    struct _SITE_HASH_TABLE *SiteHashTable;

    //
    // Another hash table for associating IP addresses with sites
    //

    struct _IP_HASH_TABLE *IpHashTable;

    //
    // Hash table for special names
    //

    struct _SPECIAL_HASH_TABLE *SpcHashTable;

    //
    // Hash table for FtDfs's
    //

    struct _SPECIAL_HASH_TABLE *FtDfsHashTable;

    //
    // Lpc Port info
    //

    struct _DFS_LPC_INFO DfsLpcInfo;

} DFS_DATA, *PDFS_DATA;




#define MAX_PROVIDERS   5       // number of pre-allocated provider records

//
//  A PROVIDER_DEF is a provider definition record, which maps a provider
//  ID in a referral record to an installed provider.
//

typedef struct _PROVIDER_DEF {

    //
    //  The type and size of this record (must be DFS_NTC_PROVIDER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Provider ID and Capabilities, same as in the DS_REFERRAL structure.
    //

    USHORT      eProviderId;
    USHORT      fProvCapability;

    //
    //  The following field gives the name of the device for the provider.
    //

    UNICODE_STRING      DeviceName;

    //
    //  Referenced pointers to the associated file and device objects
    //

    PDEVICE_OBJECT      DeviceObject;
    PFILE_OBJECT        FileObject;

} PROVIDER_DEF, *PPROVIDER_DEF;

//
// For every open file on a volume object to which we are attached, we
// maintain an FCB.
//

typedef struct _DFS_FCB {

    //
    //  Type and size of this record (must be DFS_NTC_FCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A list entry for the hash table chain.
    //

    LIST_ENTRY HashChain;

    //
    //  The following field is the fully qualified file name for this DFS_FCB/DCB
    //  starting from the logical root.
    //

    UNICODE_STRING FullFileName;

    //
    //  The following fields give the file on which this DFS_FCB
    //  have been opened.
    //

    PFILE_OBJECT FileObject;

} DFS_FCB, *PDFS_FCB;

//
// We need to order our referrals by site; we normalize the referral list of names and
// types into the following structure.
//

typedef struct _DFS_REFERRAL_LIST {

    UNICODE_STRING pName;          // ex: JHARPERDC1
                        
    UNICODE_STRING pAddress;       // ex: \\JHARPERDC1\MYFTDFS

    ULONG Type;

} DFS_REFERRAL_LIST, *PDFS_REFERRAL_LIST;

#endif // _DFSSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\dfsrtl.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:   DfsRtl.c
//
//  Contents:
//
//  Functions:  DfsRtlDeleteFile - Deletes a file given its name.
//              DfsRtlPrefixPath - Is one path a prefix of another?
//
//  History:     27 May 1992 PeterCo Created.
//
//-----------------------------------------------------------------------------

#ifdef KERNEL_MODE

#include "dfsprocs.h"
#include "dfsrtl.h"

#define Dbg              (DEBUG_TRACE_RTL)

#endif

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, DfsRtlPrefixPath )

#endif // ALLOC_PRAGMA


//+-------------------------------------------------------------------
//
//  Function:   DfsRtlPrefixPath, local
//
//  Synopsis:   This routine will return TRUE if the first string argument
//              is a path name prefix of the second string argument.
//
//  Arguments:  [Prefix] -- Pointer to target device object for
//                      the request.
//              [Test] -- Pointer to I/O request packet
//              [IgnoreCase] -- TRUE if the comparison should be done
//                      case-insignificant.
//
//  Returns:    BOOLEAN - TRUE if Prefix is a prefix of Test and the
//                      comparison ends at a path separator character.
//
//--------------------------------------------------------------------


BOOLEAN
DfsRtlPrefixPath (
    IN PUNICODE_STRING Prefix,
    IN PUNICODE_STRING Test,
    IN BOOLEAN IgnoreCase
) {
    int cchPrefix;

    if (Prefix->Length > Test->Length) {

        return FALSE;

    }

    cchPrefix = Prefix->Length / sizeof (WCHAR);

    if (Prefix->Length < Test->Length &&
            Test->Buffer[cchPrefix] != L'\\') {

        return FALSE;

    }

    return( RtlPrefixUnicodeString( Prefix, Test, IgnoreCase ) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\dumpsup.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       DUMPSUP.C
//
//  Contents:
//              This module implements a collection of data structure dump
//              routines for debugging the Dfs file system
//
//  Functions:  DfsDump - Print the contents of a dfs data structure
//
//  History:    12 Nov 1991     AlanW   Created from CDFS souce.
//               8 May 1992     PeterCo Modifications for PKT support
//              14 July 1992    SudK    Modifications to dump PKT structures.
//              30 April 1993   SudK    Modified to work with KD Extensions.
//
//  Notes:      This module is included by the user-mode program
//              DfsDump.c.  When this occurs, the structures will
//              be in user addressible memory, but pointers will
//              be inaccessible.  The sysmbol USERMODE will be
//              defined when included by DfsDump.c.
//
//-----------------------------------------------------------------------------


#ifdef  USERMODE
#undef DBG
#define DBG     1
#endif //USERMODE

#ifdef KDEXTMODE

#undef DBG
#define DBG     1

#endif  //KDEXTMODE

#include "dsprocs.h"
#include "attach.h"
#include "fcbsup.h"


#ifdef KDEXTMODE

typedef void (*PNTKD_OUTPUT_ROUTINE)(char *, ...);

extern PNTKD_OUTPUT_ROUTINE     lpOutputRoutine;

void
DfsKdextReadAndPrintString(PUNICODE_STRING pustr);

#define DbgPrint        (lpOutputRoutine)

#endif  //KDEXTMODE


#if DBG

VOID DfsDump( IN PVOID Ptr );

VOID DfsDumpDataHeader( IN PDS_DATA Ptr);
VOID DfsDumpVcb( IN PVCB Ptr );
VOID DfsDumpPkt( IN PDFS_PKT Ptr );
VOID DfsDumpPktEntry( IN PDFS_PKT_ENTRY Ptr);
VOID DfsDumpPktEntryId( IN PDFS_PKT_ENTRY_ID Ptr);
VOID DfsDumpPktEntryInfo(IN PDFS_PKT_ENTRY_INFO Ptr);
VOID DfsDumpDfsService( IN PDFS_SERVICE Ptr);
VOID DfsDumpProvider(IN PPROVIDER_DEF Ptr);
VOID DfsDumpFcbHash( IN PFCB_HASH_TABLE Ptr );
VOID DfsDumpFcb( IN PFCB Ptr );
VOID DfsDumpIrpContext( IN PIRP_CONTEXT Ptr );
VOID DfsDumpVolumeDevice( IN PDFS_VOLUME_OBJECT Ptr );
VOID DfsDumpLogicalRootDevice( IN PLOGICAL_ROOT_DEVICE_OBJECT Ptr );
VOID DfsDumpFilesysDevice( IN PDEVICE_OBJECT Ptr );
VOID DfsDumpDevice( IN PDEVICE_OBJECT Ptr );

VOID PrintGuid( IN GUID *Ptr);

#ifdef ALLOC_PRAGMA
#pragma alloc_text ( PAGE, DfsDumpDataHeader )
#pragma alloc_text ( PAGE, DfsDumpVcb )
#pragma alloc_text ( PAGE, DfsDumpPkt )
#pragma alloc_text ( PAGE, DfsDumpPktEntry )
#pragma alloc_text ( PAGE, DfsDumpPktEntryId )
#pragma alloc_text ( PAGE, DfsDumpPktEntryInfo )
#pragma alloc_text ( PAGE, DfsDumpDfsService )
#pragma alloc_text ( PAGE, DfsDumpProvider )
#pragma alloc_text ( PAGE, DfsDumpFcbHash )
#pragma alloc_text ( PAGE, DfsDumpFcb )
#pragma alloc_text ( PAGE, DfsDumpIrpContext )
#pragma alloc_text ( PAGE, DfsDumpVolumeDevice )
#pragma alloc_text ( PAGE, DfsDumpLogicalRootDevice )
#pragma alloc_text ( PAGE, DfsDumpFilesysDevice )
#pragma alloc_text ( PAGE, DfsDumpDevice )
#pragma alloc_text ( PAGE, PrintGuid )
#endif // ALLOC_PRAGMA

#ifdef  KDEXTMODE
#define PrintString(pStr)       DfsKdextReadAndPrintString(pStr)
#else
    #ifdef      USERMODE
    #define     PrintString(pStr)       DfsReadAndPrintString(pStr)
    #else
    #define     PrintString(pStr)       DbgPrint("%wZ", (pStr))
    #endif //USERMODE
#endif //KDEXTMODE

ULONG DfsDumpCurrentColumn = 0;
ULONG DfsDumpCurrentIndent = 0;

#define DumpNewLine() {       \
    DbgPrint("\n");           \
    DfsDumpCurrentColumn = 0; \
}

#define DumpLabel(Label,Width) {                                            \
    ULONG i, LastPeriod=0;                                                  \
    CHAR _Str[19];                                                          \
    for(i=0;i<strlen(#Label);i++) {if (#Label[i] == '.') LastPeriod = i;}   \
    RtlCopyMemory(&_Str[0],&#Label[LastPeriod],Width);                      \
    for(i=strlen(_Str);i<Width;i++) {_Str[i] = ' '; }                       \
    _Str[Width] = '\0';                                                     \
    if (DfsDumpCurrentColumn==0)                                            \
      for(i=0;i<DfsDumpCurrentIndent;i++) {DbgPrint(" ");}                  \
    DbgPrint("  %s", _Str);                                                 \
}

#define DumpField(Field) {                                          \
    if ((DfsDumpCurrentColumn + 18 + 9 + 9) > 80) {DumpNewLine();}   \
    DumpLabel(Field,18);                                            \
    DbgPrint(":%8lx", Ptr->Field);                                  \
    DbgPrint("         ");                                          \
    DfsDumpCurrentColumn += 18 + 9 + 9;                             \
}

#define DumpLargeInt(Field) {                                       \
    if ((DfsDumpCurrentColumn + 18 + 17) > 80) {DumpNewLine();}     \
    DumpLabel(Field,18);                                            \
    DbgPrint(":%8lx", Ptr->Field.HighPart);                         \
    DbgPrint("%8lx", Ptr->Field.LowPart);                           \
    DbgPrint(" ");                                                  \
    DfsDumpCurrentColumn += 18 + 17;                                \
}

#define DumpListEntry(Links) {                                      \
    if ((DfsDumpCurrentColumn + 18 + 9 + 9) > 80) {DumpNewLine();}  \
    DumpLabel(Links,18);                                            \
    DbgPrint(" %8lx", Ptr->Links.Flink);                            \
    DbgPrint(":%8lx", Ptr->Links.Blink);                            \
    DfsDumpCurrentColumn += 18 + 9 + 9;                             \
}

#define DumpString(Field) {                                         \
    ULONG Width = Ptr->Field.Length/sizeof (WCHAR);                 \
    if (Ptr->Field.Buffer == NULL) { Width = 6; }                   \
    if ((DfsDumpCurrentColumn + 18 + Width) > 80) {DumpNewLine();}  \
    DumpLabel(Field,18);                                            \
    if (Ptr->Field.Buffer == NULL) { DbgPrint("*NULL*"); } else {   \
        PrintString(&Ptr->Field);                                   \
    }                                                               \
    DfsDumpCurrentColumn += 18 + Width;                             \
}

#define DumpGuid(Field) {                                           \
    if ((DfsDumpCurrentColumn + 8 + 35) > 80) {DumpNewLine();}      \
    DumpLabel(Field,8);                                             \
    PrintGuid(&Ptr->Field);                                         \
    DfsDumpCurrentColumn += 8 + 35;                                 \
}

#define DumpBuffer(Field, len)  {                               \
    ULONG i;                                                    \
    if ((DfsDumpCurrentColumn+18+2*Ptr->len+8)>80) {DumpNewLine();} \
    DumpLabel(Field,18);                                        \
    for (i=0; i<(ULONG)(Ptr->len-1); i++)                       \
        DbgPrint("%c", Ptr->Field[i]);                          \
    for (i=0; i<(ULONG)(Ptr->len-1); i++)                       \
        DbgPrint("%02x", Ptr->Field[i]);                        \
    DfsDumpCurrentColumn += 18 + Ptr->len + 8;                  \
}

#define TestForNull(Name) {                                     \
    if (Ptr == NULL) {                                          \
        DbgPrint("%s - Cannot dump a NULL pointer\n", Name);    \
        return;                                                 \
    }                                                           \
}


VOID
DfsDump (
    IN PVOID Ptr
    )

/*++

Routine Description:

    This routine determines the type of internal record reference by ptr and
    calls the appropriate dump routine.

Arguments:

    Ptr - Supplies the pointer to the record to be dumped

Return Value:

    None

--*/

{
    TestForNull("DfsDump");


    switch (NodeType(Ptr)) {

    case DSFS_NTC_DATA_HEADER:

        DfsDumpDataHeader( Ptr );
        break;

    case DSFS_NTC_VCB:

        DfsDumpVcb( Ptr );
        break;

    case DSFS_NTC_PKT:

        DfsDumpPkt( Ptr );
        break;

    case DSFS_NTC_PKT_ENTRY:

        DfsDumpPktEntry( Ptr );
        break;

    case DSFS_NTC_PROVIDER:

        DfsDumpProvider( Ptr );
        break;

    case DSFS_NTC_FCB_HASH:

        DfsDumpFcbHash( Ptr );
        break;

    case DSFS_NTC_FCB:

        DfsDumpFcb( Ptr );
        break;

    case DSFS_NTC_IRP_CONTEXT:

        DfsDumpIrpContext( Ptr );
        break;

    case IO_TYPE_DEVICE:

        if (((PDEVICE_OBJECT)Ptr)->DeviceType == FILE_DEVICE_DFS_VOLUME)
            DfsDumpVolumeDevice( Ptr );
        else if (((PDEVICE_OBJECT)Ptr)->DeviceType == FILE_DEVICE_DFS)
            DfsDumpLogicalRootDevice( Ptr );
        else if (((PDEVICE_OBJECT)Ptr)->DeviceType == FILE_DEVICE_DFS_FILE_SYSTEM)
            DfsDumpFilesysDevice( Ptr );
        else
            DbgPrint("DfsDump - Unknown device type code %4x\n",
                        ((PDEVICE_OBJECT)Ptr)->DeviceType);
        break;

    default:

        DbgPrint("DfsDump - Unknown Node type code %4x\n",
                        *((PNODE_TYPE_CODE)(Ptr)));
        break;
    }

    return;
}


static VOID
DfsDumpPtrAndNtc (
    char *Str,
    PVOID Ptr
) {
#ifndef KDEXTMODE
#ifndef USERMODE
    DumpNewLine();
    DbgPrint("%s @ %lx\t", Str, (Ptr));
#endif  //USERMODE
#endif  //KDEXTMODE

    DumpLabel(Node, sizeof("Node "));
    DbgPrint("Type:  %04x",   ((PDS_DATA)Ptr)->NodeTypeCode);
    DbgPrint("\tNode Size:  %04x", ((PDS_DATA)Ptr)->NodeByteSize);
    DumpNewLine();

    return;
}


static VOID
DfsDumpDataHeader (
    IN PDS_DATA Ptr
    )

/*++

Routine Description:

    Dump the top data structure

Arguments:

    Ptr - a pointer to the anchor block

Return Value:

    None

--*/

{

//    ASSERT(Ptr == &DfsData);

    DfsDumpPtrAndNtc("DfsData", (Ptr));

    DumpListEntry       (VcbQueue);
    DumpListEntry       (AVdoQueue);

    DumpField           (DriverObject);
    DumpField           (FileSysDeviceObject);
    DumpField           (cProvider);
    DumpField           (pProvider);
    DumpField           (OurProcess);
    DumpField           (FcbHashTable);
    DumpNewLine();

    return;
}



static VOID
DfsDumpVcb (
    IN PVCB Ptr
    )

/*++

Routine Description:

    Dump a Vcb structure.

Arguments:

    Ptr - Supplies the Vcb to be dumped.

Return Value:

    None

--*/

{
//    TestForNull("DfsDumpVcb");

    DfsDumpPtrAndNtc("Vcb", (Ptr));

    DumpListEntry       (VcbLinks);
    DumpString          (LogicalRoot);
    DumpString          (LogRootPrefix);

    DumpNewLine();
    return;
}


//----------------------------------------------------------------------
//
// Function:    DfsDumpPktEntry()
//
// Arguments:   Ptr - Pointer to the DFS_PKT_ENTRY Structure to be dumped.
//
// Returns:     Nothing.
//
// Description: This function dumps the various fields of the PKT Entry.
//
// History:     14 July 1992    Sudk    Created.
//
//----------------------------------------------------------------------
static VOID
DfsDumpPktEntry( IN PDFS_PKT_ENTRY Ptr)
{

        DfsDumpPtrAndNtc("PktEntry", (Ptr));

        DumpListEntry(Link);
        DumpField(Type);
        DumpField(FileOpenCount);

        DumpField(ExpireTime);
        DumpField(ActiveService);
        DumpField(LocalService);

        DumpField(Superior);
        DumpField(SubordinateCount);
        DumpListEntry(SubordinateList);
        DumpListEntry(SiblingLink);
        DumpNewLine();

        DumpField(ClosestDC);
        DumpListEntry(ChildList);
        DumpListEntry(NextLink);
        DumpNewLine();

        DfsDumpPktEntryId(&(Ptr->Id));
        DfsDumpPktEntryInfo(&(Ptr->Info));

        DumpNewLine();
}


//----------------------------------------------------------------------
//
// Function:    DfsDumpPktEntryId()
//
// Arguments:   Ptr - Pointer to EntryId structure.
//
// Returns:     Nothing.
//
// Description: Dumps the EntryId structure passed to it.
//
// History:     14 July 1992    Sudk    Created.
//
//----------------------------------------------------------------------

static  VOID
DfsDumpPktEntryId(IN PDFS_PKT_ENTRY_ID Ptr)
{

        DumpNewLine();

        DumpLabel(PKT_ENTRY_ID, sizeof "PKT_ENTRY_ID");
        DfsDumpCurrentIndent += 2;
        DumpNewLine();

        DumpGuid(Uid);
        DumpString(Prefix);
        DumpNewLine();

        DfsDumpCurrentIndent -= 2;
}


//----------------------------------------------------------------------
//
// Function:    PrintGuid
//
// Synopsis:    Prints a GUID value in a 35 byte field
//
// Arguments:   Ptr - Pointer to a GUID.
//
// Returns:     Nothing.
//
// History:     14 July 1992    Sudk    Created.
//
//----------------------------------------------------------------------

static  VOID
PrintGuid( IN GUID      *Ptr)
{
        int     i;

        DbgPrint("%08x-%04x-%04x-", Ptr->Data1, Ptr->Data2, Ptr->Data3);

        for (i=0; i<8; i++)     {
                DbgPrint("%02x", Ptr->Data4[i]);
        }
}



//----------------------------------------------------------------------
//
// Function:    DfsDumpPktEntryInfo()
//
// Arguments:   Ptr - Pointer to EntryInfo structure.
//
// Returns:     Nothing.
//
// Description: Dumps the EntryInfo structure passed to it.
//
// History:     14 July 1992    Sudk    Created.
//
//----------------------------------------------------------------------

static  VOID
DfsDumpPktEntryInfo(IN PDFS_PKT_ENTRY_INFO Ptr)
{
        DumpLabel(PKT_ENTRY_INFO, sizeof("PKT_ENTRY_INFO"));
        DfsDumpCurrentIndent += 2;
        DumpNewLine();

        DumpField(Timeout);
        DumpField(ServiceCount);
        DumpField(ServiceList);

        DfsDumpCurrentIndent -= 2;
        DumpNewLine();
}



//----------------------------------------------------------------------
//
// Function:    DfsDumpDfsService()
//
// Arguments:   Ptr - Pointer to the DFS_SERVICE struct to be dumped.
//
// Returns:     Nothing.
//
// Description: A simple dump of the above structure.
//
// History:     14 June 1992    Sudk Created.
//
//----------------------------------------------------------------------

VOID
DfsDumpDfsService( IN PDFS_SERVICE Ptr)
{
        DumpLabel(DFS_SERVICE, sizeof("DFS_SERVICE"));
        DfsDumpCurrentIndent += 2;
        DumpNewLine();

        DumpField(Type);
        DumpField(Capability);
        DumpField(Status);
        DumpField(ProviderId);
        DumpField(pProvider);
        DumpField(ConnFile);
        DumpField(pMachEntry);
        DumpNewLine();

        DumpString(Name);
        DumpNewLine();
        DumpString(Address);
        DumpNewLine();
        DumpString(StgId);

        DfsDumpCurrentIndent -= 2;
        DumpNewLine();
}



//----------------------------------------------------------------------
//
// Function:    DfsDumpDSMachine()
//
// Arguments:   Ptr - Pointer to the DS_MACHINE struct to be dumped.
//
// Returns:     Nothing.
//
// Description: A simple dump of the above structure.
//
// History:     12 April 1994   Sudk Created.
//
//----------------------------------------------------------------------
VOID
DfsDumpDSMachine( IN PDS_MACHINE Ptr)
{
        ULONG   i;
        DumpLabel(DS_MACHINE, sizeof("DS_MACHINE"));
        DfsDumpCurrentIndent += 2;
        DumpNewLine();

        DumpGuid(guidSite);
        DumpGuid(guidMachine);
        DumpField(grfFlags);
        DumpField(pwszShareName);
        DumpField(cPrincipals);
        DumpField(prgpwszPrincipals);
        DumpField(cTransports);

        for (i=0; i<Ptr->cTransports; i++)      {
            DumpField(rpTrans[i]);
        }

        DfsDumpCurrentIndent -= 2;
        DumpNewLine();
}




//----------------------------------------------------------------------
//
// Function:    DfsDumpDSTransport()
//
// Arguments:   Ptr - Pointer to the DS_TRANSPORT struct to be dumped.
//
// Returns:     Nothing.
//
// Description: A simple dump of the above structure.
//
// History:     12 April 1994   Sudk Created.
//
//----------------------------------------------------------------------

VOID
DfsDumpDSTransport( IN PDS_TRANSPORT Ptr)
{

        DumpLabel(DS_TRANSPORT, sizeof("DS_TRANSPORT"));
        DfsDumpCurrentIndent += 2;
        DumpNewLine();

        DumpField(usFileProtocol);
        DumpField(iPrincipal);
        DumpField(grfModifiers);
        DumpField(taddr.AddressLength);
        DumpNewLine();

        switch (Ptr->taddr.AddressType) {
        case TDI_ADDRESS_TYPE_IP: {
            PTDI_ADDRESS_IP pipAddr;
            pipAddr = (PTDI_ADDRESS_IP) Ptr->taddr.Address;
            DbgPrint("    TCP/IP Address: %d.%d.%d.%d",
                BYTE_0(pipAddr->in_addr),
                BYTE_1(pipAddr->in_addr),
                BYTE_2(pipAddr->in_addr),
                BYTE_3(pipAddr->in_addr));
            } break;

        case TDI_ADDRESS_TYPE_NETBIOS: {
            PTDI_ADDRESS_NETBIOS pnbAddr;
            pnbAddr = (PTDI_ADDRESS_NETBIOS) Ptr->taddr.Address;
            DbgPrint("    NetBIOS Address: %s", pnbAddr->NetbiosName);
            } break;

        case TDI_ADDRESS_TYPE_IPX: {
            PTDI_ADDRESS_IPX pipxAddr;
            pipxAddr = (PTDI_ADDRESS_IPX) Ptr->taddr.Address;
            DbgPrint("    IPX Address: Net = %08 Node = %02x%02x%02x%02x%02x%02x",
                pipxAddr->NetworkAddress,
                pipxAddr->NodeAddress[6],
                pipxAddr->NodeAddress[5],
                pipxAddr->NodeAddress[4],
                pipxAddr->NodeAddress[3],
                pipxAddr->NodeAddress[2],
                pipxAddr->NodeAddress[1],
                pipxAddr->NodeAddress[0]);
            } break;

        default:
            break;

        }

        DfsDumpCurrentIndent -= 2;
        DumpNewLine();
}



//----------------------------------------------------------------------
//
// Function:    DfsDumpPkt
//
// Arguments:   Ptr - A pointer to a DFS_PKT structure to be dumped.
//
// Returns:     Nothing.
//
// Description: This function dumps the various fields of the PKT.
//
// History:     14 July 1992    Sudk    Created.
//
//----------------------------------------------------------------------

static VOID
DfsDumpPkt( IN PDFS_PKT Ptr)
{

        //
        // First Dump the name of the structure, the nodetype and the
        // node size of this structure.
        //

        DfsDumpPtrAndNtc("Pkt", (Ptr));

        DumpField(EntryCount);
        DumpListEntry(EntryList);
        DumpField(DomainPktEntry);

        DumpNewLine();
}



//+--------------------------------------------------------------
//
// Function: DfsDumpProvider()
//
// Arguments:   Ptr - a pointer to the provider structure to dump.
//
// Description: This function merely dumps the information in a provider struct.
//
// Returns:     Nothing.
//
// History:     Sudk Created July 16th 1992.
//
//---------------------------------------------------------------
static VOID
DfsDumpProvider( IN PPROVIDER_DEF Ptr)
{

        DfsDumpPtrAndNtc("Provider", (Ptr));

        DumpField(eProviderId);
        DumpField(fProvCapability);
        DumpString(DeviceName);

        DumpNewLine();

}




static VOID
DfsDumpFcbHash (
    IN PFCB_HASH_TABLE Ptr
    )

/*++

Routine Description:

    Dump an FcbHashTable structure.

Arguments:

    Ptr - Supplies the FcbHashTable to be dumped.

Return Value:

    None

--*/

{
    DfsDumpPtrAndNtc("FcbHash", (Ptr));

    DumpField           (HashMask);
    DumpNewLine();

    return;
}


static VOID
DfsDumpFcb (
    IN PFCB Ptr
    )

/*++

Routine Description:

    Dump an Fcb structure.

Arguments:

    Ptr - Supplies the Fcb to be dumped.

Return Value:

    None

--*/

{
    DfsDumpPtrAndNtc("Fcb", (Ptr));

    DumpField           (Vcb);
    DumpString          (FullFileName);
    DumpField           (TargetDevice);
    DumpField           (FileObject);
    DumpNewLine();

    return;
}



static VOID
DfsDumpIrpContext (
    IN PIRP_CONTEXT Ptr
    )

/*++

Routine Description:

    Dump an IrpContext structure.

Arguments:

    Ptr - Supplies the Irp Context to be dumped.

Return Value:

    None

--*/

{
//    TestForNull("DfsDumpIrpContext");

    DfsDumpPtrAndNtc("IrpContext", (Ptr));

//    DumpListEntry     (WorkQueueLinks);
    DumpField           (OriginatingIrp);
    DumpField           (MajorFunction);
    DumpField           (MinorFunction);
    DumpField           (Flags);
    DumpField           (ExceptionStatus);
    DumpNewLine();

    return;
}


static VOID
DfsDumpDevice (
    IN PDEVICE_OBJECT Ptr
    )

/*++

Routine Description:

    Dump a device object structure.

Arguments:

    Ptr - Supplies the  device object to be dumped.

Return Value:

    None

--*/

{
//    TestForNull("DfsDumpDevice");

    DfsDumpPtrAndNtc("Device", (Ptr));

    DumpField           (ReferenceCount);
    DumpField           (DriverObject);
    DumpField           (AttachedDevice);
    DumpField           (Flags);
    DumpField           (Characteristics);
    DumpField           (DeviceExtension);
    DumpField           (DeviceType);
    DumpField           (StackSize);
    DumpNewLine();

    return;
}


static VOID
DfsDumpVolumeDevice (
    IN PDFS_VOLUME_OBJECT Ptr
    )

/*++

Routine Description:

    Dump a dfs volume device object structure.

Arguments:

    Ptr - Supplies the  device object to be dumped.

Return Value:

    None

--*/

{
//    TestForNull("DfsDumpDevice");

    DfsDumpPtrAndNtc("DfsVolumeDevice", (Ptr));

    DumpLabel(DEVICE_OBJECT, sizeof("DEVICE_OBJECT"));
    DfsDumpCurrentIndent += 2;
    DumpNewLine();

    DfsDumpDevice(&Ptr->DeviceObject);
    DfsDumpCurrentIndent -= 2;

    DumpLabel(PROVIDER_DEF, sizeof("PROVIDER_DEF"));
    DfsDumpCurrentIndent += 2;
    DumpNewLine();

    DfsDumpProvider(&Ptr->Provider);
    DfsDumpCurrentIndent -= 2;

    DumpField           (AttachCount);
    DumpListEntry       (VdoLinks);

    DumpNewLine();

    return;
}

static VOID
DfsDumpLogicalRootDevice (
    IN PLOGICAL_ROOT_DEVICE_OBJECT Ptr
    )

/*++

Routine Description:

    Dump a dfs logical root device object structure.

Arguments:

    Ptr - Supplies the device object to be dumped.

Return Value:

    None

--*/

{
//    TestForNull("DfsDumpLogicalRootDevice");

    DfsDumpPtrAndNtc("DfsLogicalRootDevice", (Ptr));

    DumpLabel(DEVICE_OBJECT, sizeof("DEVICE_OBJECT"));
    DfsDumpCurrentIndent += 2;
    DumpNewLine();

    DfsDumpDevice(&Ptr->DeviceObject);
    DfsDumpCurrentIndent -= 2;

    DumpLabel(VCB, sizeof("VCB"));
    DfsDumpCurrentIndent += 2;
    DumpNewLine();

    DfsDumpVcb(&Ptr->Vcb);
    DfsDumpCurrentIndent -= 2;

//    DumpField         (AttachCount);
//    DumpList          (VdoLinks);

    DumpNewLine();

    return;
}


static VOID
DfsDumpFilesysDevice(
    IN PDEVICE_OBJECT Ptr
)

/*++

Routine Description:

    Dump the dfs file system device object structure.

Arguments:

    Ptr - Supplies the device object to be dumped.

Return Value:

    None

--*/

{
//    TestForNull("DfsDumpFilesysDevice");

    DfsDumpPtrAndNtc("DfsFileSystemDevice", (Ptr));

    DumpLabel(DEVICE_OBJECT, sizeof("DEVICE_OBJECT"));
    DfsDumpCurrentIndent += 2;
    DumpNewLine();

    DfsDumpDevice(Ptr);
    DfsDumpCurrentIndent -= 2;

    DumpNewLine();

    return;
}




#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\fastio.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       fastio.c
//
//  Contents:   Routines to implement Fast IO
//
//  Classes:
//
//  Functions:
//
//  History:    8/11/93         Milans created
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "fsctrl.h"
#include "fastio.h"
#include "attach.h"
#include "srv.h"

#define Dbg              (DEBUG_TRACE_FASTIO)

BOOLEAN
DfsFastIoCheckIfPossible (
    FILE_OBJECT *pFileObject,
    LARGE_INTEGER *pOffset,
    ULONG Length,
    BOOLEAN fWait,
    ULONG LockKey,
    BOOLEAN fCheckForRead,
    IO_STATUS_BLOCK *pIoStatusBlock,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoRead(
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoWrite(
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoQueryBasicInfo(
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoQueryStandardInfo(
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoLock(
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoUnlockSingle(
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );


BOOLEAN
DfsFastIoUnlockAll(
    IN struct _FILE_OBJECT *FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoUnlockAllByKey(
    IN struct _FILE_OBJECT *FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoDeviceControl(
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject);

VOID
DfsFastIoAcquireFile(
    IN PFILE_OBJECT FileObject);

VOID
DfsFastIoReleaseFile(
    IN PFILE_OBJECT FileObject);

VOID
DfsFastIoDetachDevice(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice);

BOOLEAN
DfsFastIoQueryNetworkOpenInfo(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoMdlRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoMdlReadComplete(
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
DfsFastIoPrepareMdlWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
DfsFastIoMdlWriteComplete(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

//
//  If this routine is present, it will be called by FsRtl
//  to acquire the file for the mapped page writer.
//

NTSTATUS
DfsFastIoAcquireForModWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER EndingOffset,
    OUT PERESOURCE *ResourceToRelease,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoReadCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
DfsFastIoWriteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoMdlReadCompleteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoMdlWriteCompleteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject);

PFAST_IO_DISPATCH
DfsFastIoLookup(
    IN FILE_OBJECT *pFileObject,
    IN DEVICE_OBJECT *DeviceObject,
    IN PDEVICE_OBJECT *targetVdo);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsFastIoCheckIfPossible )
#pragma alloc_text( PAGE, DfsFastIoRead )
#pragma alloc_text( PAGE, DfsFastIoWrite )
#pragma alloc_text( PAGE, DfsFastIoQueryBasicInfo )
#pragma alloc_text( PAGE, DfsFastIoQueryStandardInfo )
#pragma alloc_text( PAGE, DfsFastIoLock )
#pragma alloc_text( PAGE, DfsFastIoUnlockSingle )
#pragma alloc_text( PAGE, DfsFastIoUnlockAll )
#pragma alloc_text( PAGE, DfsFastIoUnlockAllByKey )
#pragma alloc_text( PAGE, DfsFastIoDeviceControl )
#pragma alloc_text( PAGE, DfsFastIoDetachDevice )
#endif // ALLOC_PRAGMA

FAST_IO_DISPATCH FastIoDispatch =
{
    sizeof(FAST_IO_DISPATCH),
    DfsFastIoCheckIfPossible,           //  CheckForFastIo
    DfsFastIoRead,                      //  FastIoRead
    DfsFastIoWrite,                     //  FastIoWrite
    DfsFastIoQueryBasicInfo,            //  FastIoQueryBasicInfo
    DfsFastIoQueryStandardInfo,         //  FastIoQueryStandardInfo
    DfsFastIoLock,                      //  FastIoLock
    DfsFastIoUnlockSingle,              //  FastIoUnlockSingle
    DfsFastIoUnlockAll,                 //  FastIoUnlockAll
    DfsFastIoUnlockAllByKey,            //  FastIoUnlockAllByKey
    DfsFastIoDeviceControl,             //  FastIoDeviceControl
    DfsFastIoAcquireFile,               //  AcquireFileForNtCreateSection
    DfsFastIoReleaseFile,               //  ReleaseFileForNtCreateSection
    DfsFastIoDetachDevice,              //  FastIoDetachDevice
    DfsFastIoQueryNetworkOpenInfo,      //  FastIoQueryNetworkOpenInfo
    DfsFastIoAcquireForModWrite,        //  AcquireForModWrite
    DfsFastIoMdlRead,                   //  MdlRead
    DfsFastIoMdlReadComplete,           //  MdlReadComplete
    DfsFastIoPrepareMdlWrite,           //  PrepareMdlWrite
    DfsFastIoMdlWriteComplete,          //  MdlWriteComplete
    DfsFastIoReadCompressed,            //  FastIoReadCompressed
    DfsFastIoWriteCompressed,           //  FastIoWriteCompressed
    DfsFastIoMdlReadCompleteCompressed, //  MdlReadCompleteCompressed
    DfsFastIoMdlWriteCompleteCompressed //  MdlWriteCompleteCompressed
};

//
// Macro to see if a PFAST_IO_DISPATCH has a particular field
//

#define IS_VALID_INDEX(pfio, e)                                 \
    ((pfio != NULL)                                       &&    \
     (pfio->SizeOfFastIoDispatch >=                             \
        (offsetof(FAST_IO_DISPATCH, e) + sizeof(PVOID)))  &&    \
     (pfio->e != NULL)                                          \
    )


//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoLookup
//
//  Synopsis:   Given a file object, this routine will locate the fast IO
//              dispatch table for the underlying provider
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

PFAST_IO_DISPATCH
DfsFastIoLookup(
    IN FILE_OBJECT *pFileObject,
    IN DEVICE_OBJECT *DeviceObject,
    OUT PDEVICE_OBJECT *targetVdo)
{
    PFAST_IO_DISPATCH   pFastIoTable;

    *targetVdo = NULL;

    DebugTrace(+1, Dbg, "DfsFastIoLookup: Entered\n", 0);

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS_VOLUME) {

        //
        // In this case we have a direct pointer to the next device to which
        // we need to pass on (This is attached device case).
        //

        *targetVdo = ((PDFS_VOLUME_OBJECT) DeviceObject)->Provider.DeviceObject;

        pFastIoTable = (*targetVdo)->DriverObject->FastIoDispatch;

        DebugTrace(0,Dbg, "DfsFastIoLookup: DevObj: %08lx\n", DeviceObject);
        DebugTrace(0, Dbg, "DfsFastIoLookup: TargetVdo %08lx\n", *targetVdo);
        DebugTrace(-1,Dbg, "DfsFastIoLookup: Exit -> %08lx\n", pFastIoTable );

        return(pFastIoTable);

    } else if (DeviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM ) {

        //
        // An operation intended for a disk file system we are attached to.
        //

        *targetVdo = ((PDFS_ATTACH_FILE_SYSTEM_OBJECT) DeviceObject)->TargetDevice;

        pFastIoTable = (*targetVdo)->DriverObject->FastIoDispatch;

        DebugTrace(0,Dbg, "DfsFastIoLookup: DevObj: %08lx  ", DeviceObject);
        DebugTrace(0, Dbg, "TargetVdo %08lx\n", *targetVdo);
        DebugTrace(-1,Dbg, "DfsFastIoLookup: Exit -> %08lx\n", pFastIoTable );

        return( pFastIoTable );

    } else {

        //
        // This is an unknown device object type and we dont know what to do
        //

        DebugTrace(0, 0,
            "DfsFastIoLookup: Unexpected DeviceObject Type %08x\n",
            DeviceObject);

        ASSERT(FALSE && "Unknown DeviceObject");

        DebugTrace(-1,Dbg, "DfsFastIoLookup: Exit -> %08lx\n", NULL );

        return(NULL);

    }

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoCheckIfPossible
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoCheckIfPossible (
    FILE_OBJECT *pFileObject,
    LARGE_INTEGER *pOffset,
    ULONG Length,
    BOOLEAN fWait,
    ULONG LockKey,
    BOOLEAN fCheckForRead,
    IO_STATUS_BLOCK *pIoStatusBlock,
    PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH   pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DebugTrace(+1, Dbg, "DfsFastIoCheckIfPossible Enter \n", 0);
    pFastIoTable = DfsFastIoLookup(pFileObject, DeviceObject, &targetVdo);



    if ( IS_VALID_INDEX(pFastIoTable, FastIoCheckIfPossible) ) {

        fPossible = pFastIoTable->FastIoCheckIfPossible(
                        pFileObject,
                        pOffset,
                        Length,
                        fWait,
                        LockKey,
                        fCheckForRead,
                        pIoStatusBlock,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DebugTrace(-1, Dbg, "DfsFastIoCheckIfPossible Exit \n", 0);

    return(fPossible);
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoRead
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DebugTrace(+1, Dbg, "DfsFastIoRead Enter \n", 0);
    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);


    if ( IS_VALID_INDEX(pFastIoTable, FastIoRead) ) {

        fPossible =  pFastIoTable->FastIoRead(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        Buffer,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DebugTrace(-1, Dbg, "DfsFastIoRead Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoWrite
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DebugTrace(+1, Dbg, "DfsFastIoWrite Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);


    if ( IS_VALID_INDEX(pFastIoTable, FastIoWrite) ) {

        fPossible = pFastIoTable->FastIoWrite(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        Buffer,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DebugTrace(-1, Dbg, "DfsFastIoWrite Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoQueryBasicInfo
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoQueryBasicInfo(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DebugTrace(+1, Dbg, "DfsFastIoQueryBasicInfo Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);


    if ( IS_VALID_INDEX(pFastIoTable, FastIoQueryBasicInfo) ) {

        fPossible = pFastIoTable->FastIoQueryBasicInfo(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DebugTrace(-1, Dbg, "DfsFastIoQueryBasicInfo Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoQueryStandardInfo
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoQueryStandardInfo(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DebugTrace(+1, Dbg, "DfsFastIoQueryStandardInfo Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);


    if ( IS_VALID_INDEX(pFastIoTable, FastIoQueryStandardInfo) ) {

        fPossible = pFastIoTable->FastIoQueryStandardInfo(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DebugTrace(-1, Dbg, "DfsFastIoQueryStandardInfo Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoLock
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoLock(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DebugTrace(+1, Dbg, "DfsFastIoLock Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);


    if ( IS_VALID_INDEX(pFastIoTable, FastIoLock) ) {

        fPossible = pFastIoTable->FastIoLock(
                        FileObject,
                        FileOffset,
                        Length,
                        ProcessId,
                        Key,
                        FailImmediately,
                        ExclusiveLock,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DebugTrace(-1, Dbg, "DfsFastIoLock Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoUnlockSingle
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoUnlockSingle(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DebugTrace(+1, Dbg, "DfsFastIoUnlockSingle Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

 
    if ( IS_VALID_INDEX(pFastIoTable, FastIoUnlockSingle) ) {

        fPossible = pFastIoTable->FastIoUnlockSingle(
                        FileObject,
                        FileOffset,
                        Length,
                        ProcessId,
                        Key,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DebugTrace(-1, Dbg, "DfsFastIoUnlockSingle Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoUnlockAll
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoUnlockAll(
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DebugTrace(+1, Dbg, "DfsFastIoUnlockAll Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

 
    if ( IS_VALID_INDEX(pFastIoTable, FastIoUnlockAll) ) {

        fPossible = pFastIoTable->FastIoUnlockAll(
                        FileObject,
                        ProcessId,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DebugTrace(-1, Dbg, "DfsFastIoUnlockAll Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   FastIoUnlockAllByKey
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoUnlockAllByKey(
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DebugTrace(+1, Dbg, "DfsFastIoUnlockAllByKey Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

 
    if ( IS_VALID_INDEX(pFastIoTable, FastIoUnlockAllByKey) ) {

        fPossible = pFastIoTable->FastIoUnlockAllByKey(
                        FileObject,
                        ProcessId,
                        Key,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DebugTrace(-1, Dbg, "DfsFastIoUnlockAllByKey Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoDeviceControl
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoDeviceControl(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DebugTrace(+1, Dbg, "DfsFastIoDeviceControl Enter \n", 0);

    //
    // See if this is the server making fsctl calls to us...
    //

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS_FILE_SYSTEM) {

        if (FileObject->FsContext == UIntToPtr( DFS_OPEN_CONTEXT )) {

            DfsSrvFsctrl(
                IoControlCode,
                InputBuffer,
                InputBufferLength,
                OutputBuffer,
                OutputBufferLength,
                IoStatus);

            fPossible = TRUE;

        } else {

            //
            // This should never happen, since its unlikely that there is
            // someone else registering a FILE_DEVICE_DFS_FILE_SYSTEM, and
            // even if they did, we wouldn't be attaching to it.
            //

            DebugTrace(0, 0,
                "DfsFastIoDeviceControl: Unknown device %08lx\n",
                DeviceObject);

            ASSERT( FALSE && "FastIO fsctrl on illegal device!\n" );

            DebugTrace(-1,Dbg, "DfsFastIoDeviceControl: Exit\n", 0);

            fPossible = FALSE;

        }

    } else if (IS_DFS_CTL_CODE(IoControlCode)) {

        //
        // One of our control codes, can't handle it via fast IO
        //

        DebugTrace(0, Dbg, "Dfs fsctrl code %08lx - returning FALSE\n",
            ULongToPtr( IoControlCode ));

        fPossible = FALSE;

    } else {

        pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

       
        if ( IS_VALID_INDEX(pFastIoTable, FastIoDeviceControl) ) {

            fPossible = pFastIoTable->FastIoDeviceControl(
                            FileObject,
                            Wait,
                            InputBuffer,
                            InputBufferLength,
                            OutputBuffer,
                            OutputBufferLength,
                            IoControlCode,
                            IoStatus,
                            targetVdo);

        } else {

            fPossible = FALSE;

        }

    }

    DebugTrace(-1, Dbg, "DfsFastIoDeviceControl Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoAcquireFile
//
//  Synopsis:   Acquire file for NtCreateSection. Due to a long chain of
//              events, this routine must either call the underlying FS's
//              AcquireFileForNtCreateSection routine or, if there isn't one,
//              we must acquire the FileObject resource ourselves, since
//              there is no possibility of returning a BOOLEAN.
//
//  Arguments:  [FileObject] -- The file to be acquired.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsFastIoAcquireFile(
    IN PFILE_OBJECT FileObject)
{

    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT deviceObject, targetVdo;
    PFSRTL_COMMON_FCB_HEADER header;

    //
    // Due to an error, this routine was defined without a device object
    // argument. We will have to locate our device object
    //

    if (FileObject->Vpb == NULL) {

        deviceObject = FileObject->DeviceObject;

    } else {

        //
        // Pick up the bottommost device object
        //

        ASSERT( FileObject->Vpb->DeviceObject != NULL );

        deviceObject = FileObject->Vpb->DeviceObject;

        ASSERT( deviceObject->DeviceType != FILE_DEVICE_DFS_VOLUME );

        //
        // Now, walk up the attached chain and find our own device object
        //

        while (deviceObject &&
                (deviceObject->DeviceType != FILE_DEVICE_DFS_VOLUME)) {

            deviceObject = deviceObject->AttachedDevice;

        }

    }

    ASSERT( deviceObject != NULL );

    pFastIoTable = DfsFastIoLookup( FileObject, deviceObject, &targetVdo );


    if (IS_VALID_INDEX( pFastIoTable, AcquireFileForNtCreateSection) ) {

        IoSetTopLevelIrp( (PIRP) FSRTL_FSP_TOP_LEVEL_IRP );

        pFastIoTable->AcquireFileForNtCreateSection( FileObject );

    } else if ((header = FileObject->FsContext) && header->Resource) {

        IoSetTopLevelIrp( (PIRP) FSRTL_FSP_TOP_LEVEL_IRP );

        ExAcquireResourceExclusiveLite( header->Resource, TRUE );

    } else {

        NOTHING;

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoReleaseFile
//
//  Synopsis:   Release file for NtCreateSection. Due to a long chain of
//              events, this routine must either call the underlying FS's
//              ReleaseFileForNtCreateSection routine or, if there isn't one,
//              we must Release the FileObject resource ourselves, since
//              there is no possibility of returning a BOOLEAN.
//
//  Arguments:  [FileObject] -- The file to be Released.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsFastIoReleaseFile(
    IN PFILE_OBJECT FileObject)
{

    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT deviceObject, targetVdo;
    PFSRTL_COMMON_FCB_HEADER header;

    //
    // Due to an error, this routine was defined without a device object
    // argument. We will have to locate our device object
    //

    if (FileObject->Vpb == NULL) {

        deviceObject = FileObject->DeviceObject;

    } else {

        //
        // Pick up the bottommost device object
        //

        ASSERT( FileObject->Vpb->DeviceObject != NULL );

        deviceObject = FileObject->Vpb->DeviceObject;

        ASSERT( deviceObject->DeviceType != FILE_DEVICE_DFS_VOLUME );

        //
        // Now, walk up the attached chain and find our own device object
        //

        while (deviceObject &&
                (deviceObject->DeviceType != FILE_DEVICE_DFS_VOLUME)) {

            deviceObject = deviceObject->AttachedDevice;

        }

    }

    ASSERT( deviceObject != NULL );

    pFastIoTable = DfsFastIoLookup( FileObject, deviceObject, &targetVdo );


    if (IS_VALID_INDEX( pFastIoTable, ReleaseFileForNtCreateSection) ) {

        IoSetTopLevelIrp( (PIRP) NULL );

        pFastIoTable->ReleaseFileForNtCreateSection( FileObject );

    } else if ((header = FileObject->FsContext) && header->Resource) {

        IoSetTopLevelIrp( (PIRP) NULL );

        ExReleaseResourceLite( header->Resource );

    } else {

        NOTHING;

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoDetachDevice, public
//
//  Synopsis:   This routine is a different from the rest of the fast io
//              routines. It is called when a device object is being deleted,
//              and that device object has an attached device. The semantics
//              of this routine are "You attached to a device object that now
//              needs to be deleted; please detach from the said device
//              object."
//
//  Arguments:  [SourceDevice] -- Our device, the one that we created to
//                      attach ourselves to the target device.
//              [TargetDevice] -- Their device, the one that we are attached
//                      to.
//
//  Returns:    Nothing - we must succeed.
//
//-----------------------------------------------------------------------------

VOID
DfsFastIoDetachDevice(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice)
{
    DfsDetachVolumeForDelete( SourceDevice );
}

BOOLEAN
DfsFastIoQueryNetworkOpenInfo(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DebugTrace(+1, Dbg, "DfsFastIoQueryNetworkOpenInfo Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);


    if ( IS_VALID_INDEX(pFastIoTable, FastIoQueryNetworkOpenInfo) ) {

        fPossible = pFastIoTable->FastIoQueryNetworkOpenInfo(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

        IoStatus->Status = STATUS_NOT_SUPPORTED;

    }

    DebugTrace(-1, Dbg, "DfsFastIoQueryNetworkOpenInfo Exit \n", 0);

    return( fPossible );

}

BOOLEAN
DfsFastIoMdlRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DebugTrace(+1, Dbg, "DfsFastIoMdlRead Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

 
    if ( IS_VALID_INDEX(pFastIoTable, MdlRead) ) {

        fPossible = pFastIoTable->MdlRead(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FsRtlMdlReadDev(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        targetVdo);

    }

    DebugTrace(-1, Dbg, "DfsFastIoMdlRead Exit \n", 0);

    return( fPossible );
}

BOOLEAN
DfsFastIoMdlReadComplete(
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT    targetVdo;
    BOOLEAN           fSuccess;

    DebugTrace(+1, Dbg, "DfsFastIoMdlReadComplete Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

 
    if ( IS_VALID_INDEX(pFastIoTable, MdlReadComplete) ) {

        fSuccess = pFastIoTable->MdlReadComplete(
                        FileObject,
                        MdlChain,
                        targetVdo);

    } else {

        fSuccess = FsRtlMdlReadCompleteDev(
                    FileObject,
                    MdlChain,
                    targetVdo);

    }

    DebugTrace(-1, Dbg, "DfsFastIoMdlReadComplete Exit \n", 0);

    return( fSuccess );

}

BOOLEAN
DfsFastIoPrepareMdlWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DebugTrace(+1, Dbg, "DfsFastIoPrepareMdlWrite Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

 
    if ( IS_VALID_INDEX(pFastIoTable, PrepareMdlWrite) ) {

        fPossible = pFastIoTable->PrepareMdlWrite(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FsRtlPrepareMdlWriteDev(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        targetVdo);

    }

    DebugTrace(-1, Dbg, "DfsFastIoPrepareMdlWrite Exit \n", 0);

    return( fPossible );
}

BOOLEAN
DfsFastIoMdlWriteComplete(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fSuccess;

    DebugTrace(+1, Dbg, "DfsFastIoMdlWriteComplete Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

 
    if ( IS_VALID_INDEX(pFastIoTable, MdlWriteComplete) ) {

        fSuccess = pFastIoTable->MdlWriteComplete(
                        FileObject,
                        FileOffset,
                        MdlChain,
                        targetVdo);

    } else {

        fSuccess = FsRtlMdlWriteCompleteDev(
                        FileObject,
                        FileOffset,
                        MdlChain,
                        targetVdo);

    }

    DebugTrace(-1, Dbg, "DfsFastIoMdlWriteComplete Exit \n", 0);

    return( fSuccess );
}

//
//  If this routine is present, it will be called by FsRtl
//  to acquire the file for the mapped page writer.
//

NTSTATUS
DfsFastIoAcquireForModWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER EndingOffset,
    OUT PERESOURCE *ResourceToRelease,
    IN PDEVICE_OBJECT DeviceObject)
{
    NTSTATUS            Status;
    PFAST_IO_DISPATCH   pFastIoTable;
    PDEVICE_OBJECT      targetVdo;

    DebugTrace(+1, Dbg, "DfsFastIoAcquireForModWrite Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

 
    if ( IS_VALID_INDEX(pFastIoTable, AcquireForModWrite) ) {

        Status = pFastIoTable->AcquireForModWrite(
                        FileObject,
                        EndingOffset,
                        ResourceToRelease,
                        targetVdo);

    } else {

        Status = STATUS_INVALID_DEVICE_REQUEST;

    }

    DebugTrace(-1, Dbg, "DfsFastIoAcquireForModWrite Exit \n", 0);

    return( Status );
}

BOOLEAN
DfsFastIoReadCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DebugTrace(+1, Dbg, "DfsFastIoReadCompressed Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

 
    if ( IS_VALID_INDEX(pFastIoTable, FastIoReadCompressed) ) {

        fPossible = pFastIoTable->FastIoReadCompressed(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        Buffer,
                        MdlChain,
                        IoStatus,
                        CompressedDataInfo,
                        CompressedDataInfoLength,
                        targetVdo);

    } else {

        fPossible = FALSE;

        IoStatus->Status = STATUS_NOT_SUPPORTED;

    }

    DebugTrace(-1, Dbg, "DfsFastIoReadCompressed Exit \n", 0);

    return( fPossible );

}


BOOLEAN
DfsFastIoWriteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DebugTrace(+1, Dbg, "DfsFastIoWriteCompressed Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

 
    if ( IS_VALID_INDEX(pFastIoTable, FastIoWriteCompressed) ) {

        fPossible = pFastIoTable->FastIoWriteCompressed(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        Buffer,
                        MdlChain,
                        IoStatus,
                        CompressedDataInfo,
                        CompressedDataInfoLength,
                        targetVdo);

    } else {

        fPossible = FALSE;

        IoStatus->Status = STATUS_NOT_SUPPORTED;

    }

    DebugTrace(-1, Dbg, "DfsFastIoWriteCompressed Exit \n", 0);

    return( fPossible );

}

BOOLEAN
DfsFastIoMdlReadCompleteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT    targetVdo;
    BOOLEAN           fSuccess;

    DebugTrace(+1, Dbg, "DfsFastIoMdlReadCompleteCompressed Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

 
    if ( IS_VALID_INDEX(pFastIoTable, MdlReadCompleteCompressed) ) {

        fSuccess = pFastIoTable->MdlReadCompleteCompressed(
                        FileObject,
                        MdlChain,
                        targetVdo);

    } else {

        fSuccess = FALSE;

    }

    DebugTrace(-1, Dbg, "DfsFastIoMdlReadCompleteCompressed Exit \n", 0);

    return( fSuccess );

}

BOOLEAN
DfsFastIoMdlWriteCompleteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT    targetVdo;
    BOOLEAN           fSuccess;

    DebugTrace(+1, Dbg, "DfsFastIoMdlWriteCompleteCompressed Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

  
    if ( IS_VALID_INDEX(pFastIoTable, MdlWriteCompleteCompressed) ) {

        fSuccess = pFastIoTable->MdlWriteCompleteCompressed(
                        FileObject,
                        FileOffset,
                        MdlChain,
                        targetVdo);

    } else {

        fSuccess = FALSE;

    }

    DebugTrace(-1, Dbg, "DfsFastIoMdlWriteCompleteCompressed Exit \n", 0);

    return( fSuccess );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\dfswml.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    dfswml.h

Abstract:

    This file defines macro for use by the mup driver

Author:

    drewsam

Revision History:

--*/

#ifndef __DFSWML_H__
#define __DFSWML_H__
#include <ntos.h>
#include "wmlkm.h"
#include "wmlmacro.h"
// Streams 

#define _DFS_TRACE_STREAM               0x00
#define _DFS_PERF_STREAM                0x01
#define _DFS_INSTR_STREAM               0x02

#define _DFS_ENABLE_DEFAULT             0x0001
#define _DFS_ENABLE_PROVIDER            0x0002
#define _DFS_ENABLE_TRACE_IRP           0x0004
#define _DFS_ENABLE_FILEINFO            0x0008
#define _DFS_ENABLE_SURROGATE           0x0010
#define _DFS_ENABLE_UNUSED9             0x0020
#define _DFS_ENABLE_UNUSED8             0x0040
#define _DFS_ENABLE_UNUSED7             0x0080
#define _DFS_ENABLE_UNUSED6             0x0100
#define _DFS_ENABLE_UNUSED5             0x0200
#define _DFS_ENABLE_UNUSED4             0x0400
#define _DFS_ENABLE_UNUSED3             0x0800
#define _DFS_ENABLE_EVENT               0x1000
#define _DFS_ENABLE_ALL_ERROR           0x2000
#define _DFS_ENABLE_ERROR               0x4000
#define _DFS_ENABLE_MONITOR             0x8000


#define _DFS_LEVEL_HIGH                    0x1
#define _DFS_LEVEL_NORM                    0x2
#define _DFS_LEVEL_LOW                     0x4



#define DFS_LOG_STREAM(_stream)   _DFS_ ## _stream ## _STREAM
#define DFS_LOG_FLAGS(_flag)      _DFS_ENABLE_ ## _flag
#define DFS_LOG_LEVEL(_level)     _DFS_LEVEL_ ## _level

#define DFS_LOG(_why, _level, _flag, _type, _arg) \
            WML_LOG(_DfsDrv, DFS_LOG_STREAM(_why), DFS_LOG_LEVEL(_level), _flag, _type, _arg 0)

#define LOGARG(_val)    (_val),
#define LOGNOTHING      0,
#define DFS_TRACE_HIGH(_flag, _type, _arg)              \
            DFS_LOG(TRACE, HIGH, DFS_LOG_FLAGS(_flag), _type, _arg)
#define DFS_TRACE_NORM(_flag, _type, _arg)              \
            DFS_LOG(TRACE, NORM, DFS_LOG_FLAGS(_flag), _type, _arg)
#define DFS_TRACE_LOW(_flag, _type, _arg)               \
            DFS_LOG(TRACE, LOW, DFS_LOG_FLAGS(_flag), _type, _arg)

#define DFS_TRACE_ERROR(_status, _flag, _type, _arg)    \
            DFS_LOG(TRACE, NORM, (DFS_LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : DFS_LOG_FLAGS(ERROR))), _type, _arg)

#define DFS_TRACE_ERROR_HIGH(_status, _flag, _type, _arg)    \
            DFS_LOG(TRACE, HIGH, (DFS_LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : DFS_LOG_FLAGS(ERROR))), _type, _arg)

#define DFS_TRACE_ERROR_LOW(_status, _flag, _type, _arg)    \
            DFS_LOG(TRACE, LOW, (DFS_LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : DFS_LOG_FLAGS(ERROR))), _type, _arg)


#define DFS_PERF(_flag, _type, _arg)                    \
            DFS_LOG (PERF, HIGH, DFS_LOG_FLAGS(_flag), _type, _arg)
#define DFS_INSTR(_flag, _type, _arg)                   \
            DFS_LOG (INSTR, HIGH, DFS_LOG_FLAGS(_flag), _type, _arg)

#if 0
#define DFS_PRINTF(_why, _flag, _type, _fmtstr, _arg)   \
            WML_PRINTF(_DfsDrv, DFS_LOG_STREAM(_why), DFS_LOG_FLAGS(_flag), _type, _fmtstr, _arg 0)

#define DFS_DBG_PRINT(_flag, _fmtstr, _arg)             \
            DFS_PRINTF(DBGLOG, _flag, DFSDefault, _fmtstr, _arg)
            
#define DFS_ERR_PRINT (_status, _fmtstr, _arg) \
            if (NT_SUCCESS(_status)) {                \
                DFS_PRINTF (DBGLOG, LOG_ERROR, DFSDefault, _fmtstr, _arg) \
            }

#endif

// from the WPP generated .h file
// We use different macros, so need to do some cut and paste
// Hopefully this will get automated in the future.

#  define WPP_DEFINE_MSG_ID(_a,_b)   ( ((_a) << 16) | ( _b) )

#  define MSG_ID_DfsAttachToFileSystem_Error_IoCreateDevice	 WPP_DEFINE_MSG_ID(0,13)
#  define MSG_ID_DfsCommonDetInformation_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,30)
#  define MSG_ID_DfsCommonFileSystemControl_Entry	 WPP_DEFINE_MSG_ID(0,34)
#  define MSG_ID_DfsCommonFileSystemControl_Error_FS_IoCallDriver	 WPP_DEFINE_MSG_ID(0,37)
#  define MSG_ID_DfsCommonFileSystemControl_Error_FsctrlFromInvalidDeviceObj	 WPP_DEFINE_MSG_ID(0,35)
#  define MSG_ID_DfsCommonFileSystemControl_Error_Vol_IoCallDriver	 WPP_DEFINE_MSG_ID(0,36)
#  define MSG_ID_DfsCommonFileSystemControl_Exit	 WPP_DEFINE_MSG_ID(0,38)
#  define MSG_ID_DfsCommonSetInformation_Entry	 WPP_DEFINE_MSG_ID(0,29)
#  define MSG_ID_DfsCommonSetInformation_Exit	 WPP_DEFINE_MSG_ID(0,31)
#  define MSG_ID_DfsCreateExitPath_Error_ZwCreateFile	 WPP_DEFINE_MSG_ID(0,42)
#  define MSG_ID_DfsCreateExitPath_Error_ZwCreateFile2	 WPP_DEFINE_MSG_ID(0,43)
#  define MSG_ID_DfsCreateExitPath_Error_ZwCreateFile3	 WPP_DEFINE_MSG_ID(0,44)
#  define MSG_ID_DfsCreateRemoteExitPt_Entry	 WPP_DEFINE_MSG_ID(0,39)
#  define MSG_ID_DfsCreateRemoteExitPt_Error_ZwFsControlFile	 WPP_DEFINE_MSG_ID(0,40)
#  define MSG_ID_DfsCreateRemoteExitPt_Exit	 WPP_DEFINE_MSG_ID(0,41)
#  define MSG_ID_DfsDeleteExitPath_Error_ZwOpenFile	 WPP_DEFINE_MSG_ID(0,45)
#  define MSG_ID_DfsDeleteExitPath_Error_ZwSetInformationFile	 WPP_DEFINE_MSG_ID(0,46)
#  define MSG_ID_DfsFsctrlFindShare_End	 WPP_DEFINE_MSG_ID(0,79)
#  define MSG_ID_DfsFsctrlFindShare_Error1	 WPP_DEFINE_MSG_ID(0,77)
#  define MSG_ID_DfsFsctrlFindShare_Error2	 WPP_DEFINE_MSG_ID(0,78)
#  define MSG_ID_DfsFsctrlFindShare_Start	 WPP_DEFINE_MSG_ID(0,76)
#  define MSG_ID_DfsFsctrlGetReferals_Error1	 WPP_DEFINE_MSG_ID(0,57)
#  define MSG_ID_DfsFsctrlGetReferals_Error2	 WPP_DEFINE_MSG_ID(0,58)
#  define MSG_ID_DfsFsctrlGetReferrals_End	 WPP_DEFINE_MSG_ID(0,59)
#  define MSG_ID_DfsFsctrlGetReferrals_Error1	 WPP_DEFINE_MSG_ID(0,56)
#  define MSG_ID_DfsFsctrlGetReferrals_Start	 WPP_DEFINE_MSG_ID(0,55)
#  define MSG_ID_DfsFsctrlIsShareInDfs_Error1	 WPP_DEFINE_MSG_ID(0,74)
#  define MSG_ID_DfsFsctrlIsShareInDfs_Error2	 WPP_DEFINE_MSG_ID(0,75)
#  define MSG_ID_DfsFsctrlTranslatePath_End	 WPP_DEFINE_MSG_ID(0,52)
#  define MSG_ID_DfsFsctrlTranslatePath_Error1	 WPP_DEFINE_MSG_ID(0,51)
#  define MSG_ID_DfsFsctrlTranslatePath_Start	 WPP_DEFINE_MSG_ID(0,50)
#  define MSG_ID_DfsFsdCleanup_Entry	 WPP_DEFINE_MSG_ID(0,16)
#  define MSG_ID_DfsFsdCleanup_Exit	 WPP_DEFINE_MSG_ID(0,17)
#  define MSG_ID_DfsFsdClose_Entry	 WPP_DEFINE_MSG_ID(0,14)
#  define MSG_ID_DfsFsdClose_Exit	 WPP_DEFINE_MSG_ID(0,15)
#  define MSG_ID_DfsFsdCreate_Entry	 WPP_DEFINE_MSG_ID(0,18)
#  define MSG_ID_DfsFsdCreate_Exit	 WPP_DEFINE_MSG_ID(0,19)
#  define MSG_ID_DfsFsdFileSystemControl_Entry	 WPP_DEFINE_MSG_ID(0,32)
#  define MSG_ID_DfsFsdFileSystemControl_Exit	 WPP_DEFINE_MSG_ID(0,33)
#  define MSG_ID_DfsFsdSetInformation_Entry	 WPP_DEFINE_MSG_ID(0,27)
#  define MSG_ID_DfsFsdSetInformation_Exit	 WPP_DEFINE_MSG_ID(0,28)
#  define MSG_ID_DfsOpenDevice_Entry	 WPP_DEFINE_MSG_ID(0,23)
#  define MSG_ID_DfsOpenDevice_Error1	 WPP_DEFINE_MSG_ID(0,24)
#  define MSG_ID_DfsOpenDevice_Error3	 WPP_DEFINE_MSG_ID(0,25)
#  define MSG_ID_DfsOpenDevice_Exit	 WPP_DEFINE_MSG_ID(0,26)
#  define MSG_ID_DfsOpenFile_Entry	 WPP_DEFINE_MSG_ID(0,20)
#  define MSG_ID_DfsOpenFile_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,21)
#  define MSG_ID_DfsOpenFile_Exit	 WPP_DEFINE_MSG_ID(0,22)
#  define MSG_ID_DfsSrvFsctrl_Error1	 WPP_DEFINE_MSG_ID(0,47)
#  define MSG_ID_DfsSrvFsctrl_Error2	 WPP_DEFINE_MSG_ID(0,48)
#  define MSG_ID_DfsSrvFsctrl_Error3	 WPP_DEFINE_MSG_ID(0,49)
#  define MSG_ID_DfsVolumePassThrough_Error1	 WPP_DEFINE_MSG_ID(0,12)
#  define MSG_ID_DfsVolumePassThrough_Error_FS_IoCallDriver	 WPP_DEFINE_MSG_ID(0,11)
#  define MSG_ID_DfsVolumePassThrough_Error_Vol_IoCallDriver	 WPP_DEFINE_MSG_ID(0,10)
#  define MSG_ID_DfspFormPrefix_Error1	 WPP_DEFINE_MSG_ID(0,53)
#  define MSG_ID_DfspFormPrefix_Error2	 WPP_DEFINE_MSG_ID(0,54)
#  define MSG_ID_DfspGetAllV3SpecialReferral_Error1	 WPP_DEFINE_MSG_ID(0,67)
#  define MSG_ID_DfspGetAllV3SpecialReferral_Error2	 WPP_DEFINE_MSG_ID(0,68)
#  define MSG_ID_DfspGetAllV3SpecialReferral_Error3	 WPP_DEFINE_MSG_ID(0,69)
#  define MSG_ID_DfspGetOneV3SpecialReferral_Error1	 WPP_DEFINE_MSG_ID(0,64)
#  define MSG_ID_DfspGetOneV3SpecialRefferal_Error1	 WPP_DEFINE_MSG_ID(0,65)
#  define MSG_ID_DfspGetOneV3SpecialRefferal_Error2	 WPP_DEFINE_MSG_ID(0,66)
#  define MSG_ID_DfspGetV2Referral_Error1	 WPP_DEFINE_MSG_ID(0,60)
#  define MSG_ID_DfspGetV2Referral_Error2	 WPP_DEFINE_MSG_ID(0,61)
#  define MSG_ID_DfspGetV3FtDfsReferral_Error1	 WPP_DEFINE_MSG_ID(0,70)
#  define MSG_ID_DfspGetV3FtDfsReferral_Error2	 WPP_DEFINE_MSG_ID(0,71)
#  define MSG_ID_DfspGetV3FtDfsReferral_Error3	 WPP_DEFINE_MSG_ID(0,72)
#  define MSG_ID_DfspGetV3FtDfsReferral_Error4	 WPP_DEFINE_MSG_ID(0,73)
#  define MSG_ID_DfspGetV3Referral_Error1	 WPP_DEFINE_MSG_ID(0,62)
#  define MSG_ID_DfspGetV3Referral_Error2	 WPP_DEFINE_MSG_ID(0,63)



            
#define WML_ID(_id)    ((MSG_ID_ ## _id) & 0xFF)
#define WML_GUID(_id)  ((MSG_ID_ ## _id) >> 8)
            

extern WML_CONTROL_GUID_REG _DfsDrv_ControlGuids[];



#endif /* __DFSWML_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\fastio.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       fastio.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8/11/93		Milans created
//
//-----------------------------------------------------------------------------

#ifndef _FASTIO_
#define _FASTIO_

extern FAST_IO_DISPATCH FastIoDispatch;

#endif // _FASTIO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\fcbsup.c ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       fcbsup.c
//
//  Contents:   Support routines for associating DFS_FCB records with
//              file objects, and looking them up again.
//
//  Functions:  DfsInitFcbs - Initialize the hash table for DFS_FCB lookup
//              DfsLookupFcb - Lookup an DFS_FCB associated with a file object
//              DfsAttachFcb - Associate an DFS_FCB with a file object
//              DfsDetachFcb - Remove the Association between an DFS_FCB and
//                              a file object
//              DfsAllocateFcb - Allocate an FCB
//              DfsDestroyFcb - Deallocate an FCB
//
//--------------------------------------------------------------------------


#include "dfsprocs.h"
#include "attach.h"
#include "fcbsup.h"

#define Dbg     0x1000

#define HASH(k,m)       (((ULONG_PTR)(k)>>12^(ULONG_PTR)(k)>>2) & m)

#define DEFAULT_HASH_SIZE       16      // default size of hash table

NTSTATUS
DfsInitFcbHashTable(
    IN  ULONG cHash,
    OUT PFCB_HASH_TABLE *ppHashTable);

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DfsInitFcbs)
#pragma alloc_text(PAGE, DfsUninitFcbs)
#pragma alloc_text(PAGE, DfsInitFcbHashTable)

//
// The following routines are not pageable because they acquire spinlocks.
//
// DfsLookupFcb
// DfsAttachFcb
// DfsDetachFcb
//

#endif

//+-------------------------------------------------------------------------
//
//  Function:   DfsInitFcbs - Initialize the DFS_FCB lookup hash table
//
//  Synopsis:   This function initializes data structures which are
//              used for looking up an DFS_FCB associated with some open
//              file object.
//
//  Arguments:  [cHash] -- Size of the hash table to be allocated.  Must be
//                         a power of two.  If zero, a default size is used.
//
//  Returns:    NTSTATUS -- STATUS_SUCCESS, unless memory allocation
//                          fails.
//
//  Note:       The hash buckets are initialized to zero, then later
//              initialized to a list head when used.  This is a debugging
//              aid to determine if some hash buckets are never used.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsInitFcbHashTable(
    IN  ULONG cHash,
    OUT PFCB_HASH_TABLE *ppHashTable)
{
    PFCB_HASH_TABLE pHashTable;
    ULONG cbHashTable;

    if (cHash == 0) {
        cHash = DEFAULT_HASH_SIZE;
    }
    ASSERT ((cHash & (cHash-1)) == 0);  // Assure cHash is a power of two

    cbHashTable = sizeof (FCB_HASH_TABLE) + (cHash-1)*sizeof (LIST_ENTRY);
    pHashTable = ExAllocatePoolWithTag(NonPagedPool, cbHashTable, ' sfD');
    if (pHashTable == NULL) {
        return STATUS_NO_MEMORY;
    }
    pHashTable->NodeTypeCode = DFS_NTC_FCB_HASH;
    pHashTable->NodeByteSize = (NODE_BYTE_SIZE) cbHashTable;

    pHashTable->HashMask = (cHash-1);
    KeInitializeSpinLock( &pHashTable->HashListSpinLock );
    RtlZeroMemory(&pHashTable->HashBuckets[0], cHash * sizeof (LIST_ENTRY));

    *ppHashTable = pHashTable;

    return(STATUS_SUCCESS);
}

NTSTATUS
DfsInitFcbs(
  IN    ULONG cHash
) {
    NTSTATUS status;

    status = DfsInitFcbHashTable( cHash, &DfsData.FcbHashTable );

    return status;
}

VOID
DfsUninitFcbs(
    VOID
) {
    ExFreePool (DfsData.FcbHashTable);
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsLookupFcb - Lookup an DFS_FCB in the hash table
//
//  Synopsis:   This function will lookup the DFS_FCB associated with
//              a particular file object.
//
//  Arguments:  [pFile] -- Pointer to file object for which the DFS_FCB is
//                         being looked up.
//
//  Returns:    PVOID -- pointer to the DFS_FCB found, or NULL if none
//
//  Algorithm:  Knuth would call it hashing with conflict resoulution
//              by chaining.
//
//  History:    20 Feb 1993     Alanw   Created
//
//--------------------------------------------------------------------------


PDFS_FCB
DfsLookupFcb(
  IN    PFILE_OBJECT pFile
) {
    PLIST_ENTRY pListHead, pLink;
    PDFS_FCB pFCB;
    KIRQL SavedIrql;
    PFCB_HASH_TABLE pHashTable = DfsData.FcbHashTable;

    KeAcquireSpinLock( &pHashTable->HashListSpinLock, &SavedIrql );
    pListHead = &pHashTable->HashBuckets[ HASH(pFile, pHashTable->HashMask) ];

    if ((pListHead->Flink == NULL) ||           // list not initialized
        (pListHead->Flink == pListHead)) {      // list empty
        KeReleaseSpinLock( &pHashTable->HashListSpinLock, SavedIrql );
        return NULL;
    }

    for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
        pFCB = CONTAINING_RECORD(pLink, DFS_FCB, HashChain);
        if (pFCB->FileObject == pFile) {
            KeReleaseSpinLock( &pHashTable->HashListSpinLock, SavedIrql );
            return pFCB;
        }
    }
    KeReleaseSpinLock( &pHashTable->HashListSpinLock, SavedIrql );
    return NULL;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsAttachFcb - Inserts an DFS_FCB into the hash table
//
//  Synopsis:   This function associates an DFS_FCB to a file object.  This
//              involves inserting it into the hash table.
//
//  Arguments:  [pFCB] -- Pointer to the DFS_FCB to be inserted.
//              [pFileObj] -- Pointer to the corresponding file object, used
//                            as the hash key.
//
//  Returns:    -nothing-
//
//--------------------------------------------------------------------------

VOID
DfsAttachFcb(
  IN    PFILE_OBJECT pFileObj,
  IN    PDFS_FCB pFCB
) {
    PFCB_HASH_TABLE pHashTable = (PFCB_HASH_TABLE) DfsData.FcbHashTable;
    PLIST_ENTRY pListHead;
    KIRQL SavedIrql;

    KeAcquireSpinLock( &pHashTable->HashListSpinLock, &SavedIrql );

    pListHead = &pHashTable->HashBuckets[ HASH(pFileObj, pHashTable->HashMask) ];

    if (pListHead->Flink == NULL) {
        InitializeListHead(pListHead);
    }
    InsertHeadList(pListHead, &pFCB->HashChain);
    KeReleaseSpinLock( &pHashTable->HashListSpinLock, SavedIrql );

    DebugTrace(0, Dbg, "Attached Fcb %08lx ", pFCB);
    DebugTrace(0, Dbg, "For Fileobject %08lx ", pFileObj);

}



//+-------------------------------------------------------------------------
//
//  Function:   DfsDetachFcb - Detach an DFS_FCB from the lookup hash table
//
//  Synopsis:   This function detaches an DFS_FCB from the hash table.  This
//              involves just deleting it from the hash bucket chain.
//
//  Arguments:  [pFCB] -- Pointer to the DFS_FCB to be detached.
//              [pFileObj] -- Pointer to the corresponding file object, used
//                            for debugging only.
//
//  Returns:    -nothing-
//
//--------------------------------------------------------------------------


VOID
DfsDetachFcb(
  IN    PFILE_OBJECT pFileObj,
  IN    PDFS_FCB pFCB
) {
    PFCB_HASH_TABLE pHashTable = (PFCB_HASH_TABLE) DfsData.FcbHashTable;
    KIRQL SavedIrql;

    ASSERT(pFCB->FileObject == pFileObj);
    ASSERT(DfsLookupFcb(pFCB->FileObject) == pFCB);

    KeAcquireSpinLock( &pHashTable->HashListSpinLock, &SavedIrql );
    RemoveEntryList(&pFCB->HashChain);
    pFCB->FileObject = NULL;
    KeReleaseSpinLock( &pHashTable->HashListSpinLock, SavedIrql );

    DebugTrace(0, Dbg, "Detached Fcb %08lx ", pFCB);
    DebugTrace(0, Dbg, "For Fileobject %08lx ", pFileObj);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsAllocateFcb - Allocate an FCB
//
//  Synopsis:   This function allocates an FCB for a fileObject that is the
//              argument of a Create IRP. The most important thing this
//              Fcb contains is the full file name of the fileObject,
//              normalized for relative opens etc.
//
//  Arguments:  [DeviceObject] -- The Device on which the file is being
//                      opened.
//              [FileObject] -- The file object for which the FCB is to be
//                      allocated.
//              [Fcb] -- On successful return, has pointer to newly allocated
//                      Fcb.
//
//  Returns:    [STATUS_SUCCESS] -- Successfully allocated FCB
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory condition
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsAllocateFcb(
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    OUT PDFS_FCB *Fcb)
{
    NTSTATUS status;
    PDFS_VOLUME_OBJECT deviceObject = (PDFS_VOLUME_OBJECT) DeviceObject;
    PDFS_FCB relatedFcb = NULL;
    PDFS_FCB fcb;
    PUNICODE_STRING relatedName;
    ULONG length;

    length = sizeof(DFS_FCB) +
                deviceObject->Provider.DeviceName.Length +
                    sizeof(UNICODE_PATH_SEP) +
                        FileObject->FileName.Length +
                            sizeof(UNICODE_NULL);

    if (FileObject->RelatedFileObject != NULL) {

        relatedFcb = DfsLookupFcb( FileObject->RelatedFileObject );

        if (relatedFcb != NULL) {

            length += relatedFcb->FullFileName.Length +
                        sizeof(UNICODE_PATH_SEP);

            relatedName = &relatedFcb->FullFileName;

        } else {

            length += FileObject->RelatedFileObject->FileName.Length;

            relatedName = &FileObject->RelatedFileObject->FileName;
        }

    } else {

        relatedName = NULL;
    }

    if (length <= MAXUSHORT) {

        fcb = (PDFS_FCB) ExAllocatePoolWithTag( NonPagedPool, length, ' sfD' );

        if (fcb != NULL) {

            RtlZeroMemory( fcb, length );

            fcb->NodeTypeCode = DFS_NTC_FCB;
            fcb->NodeByteSize = (USHORT)length;

            fcb->FullFileName.Length = 0;
            fcb->FullFileName.MaximumLength = (USHORT) (length - sizeof(DFS_FCB));
            fcb->FullFileName.Buffer = (PWCHAR) (fcb + 1);

            if (relatedName == NULL) {

                RtlCopyUnicodeString(
                    &fcb->FullFileName,
                    &deviceObject->Provider.DeviceName);

            } else {

                RtlCopyUnicodeString(
                    &fcb->FullFileName,
                    relatedName);

            }

            DfsConcatenateFilePath(
                &fcb->FullFileName,
                FileObject->FileName.Buffer,
                FileObject->FileName.Length);

            fcb->FileObject = FileObject;

            *Fcb = fcb;

            status = STATUS_SUCCESS;

        } else {

            status = STATUS_INSUFFICIENT_RESOURCES;

        }

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;

    }

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsDestroyFcb
//
//  Synopsis:   Destroys an FCB allocated by DfsAllocateFcb
//
//  Arguments:  [Fcb] -- The Fcb to destroy.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsDestroyFcb(
    IN PDFS_FCB Fcb)
{

    //
    // Make sure its gone from our Fcb tables
    //

    ASSERT( DfsLookupFcb( Fcb->FileObject ) != Fcb );

    //
    // Now, free it up.
    //

    ExFreePool( Fcb );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\fcbsup.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       fcbsup.h
//
//  Contents:   Declarations for DFS_FCB lookup support functions.
//
//  History:    20 Feb 1993     Alanw   Created
//
//--------------------------------------------------------------------------

#ifndef __FCBSUP_H__
#define __FCBSUP_H__

//
//      In order to avoid modifying file objects which are passed
//      through the DFS and used by other file systems, DFS_FCB records
//      used by DFS are not directly attached to the file object
//      through one of the fscontext fields, they are instead
//      associated with the file object, and looked up as needed.
//
//      A hashing mechanism is used for the lookup.  Since the
//      file object being looked up is just a pointer, the hash
//      function is just a simple combination of a few of the low-
//      order bits of the pointer's address.
//

//
//  Declaration of the hash table.  The hash table can be variably
//  sized, with the hash table size being a parameter of the hash
//  function.
//

typedef struct _FCB_HASH_TABLE {

    //
    //  The type and size of this record (must be DSFS_NTC_FCB_HASH)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Mask value for the hash function.  The hash table size is
    //  assumed to be a power of two; the mask is the size - 1.
    //

    ULONG HashMask;

    //
    //  A spinlock to protect access to the hash bucket lists.
    //

    KSPIN_LOCK HashListSpinLock;

    //
    //  An array of list heads for the hash table chains.  There
    //  are actually N of these where N is the hash table size.
    //

    LIST_ENTRY  HashBuckets[1];
} FCB_HASH_TABLE, *PFCB_HASH_TABLE;



NTSTATUS
DfsInitFcbs(
  IN    ULONG n
);

VOID
DfsUninitFcbs(
    VOID
);

PDFS_FCB
DfsLookupFcb(
  IN    PFILE_OBJECT pFile
);

VOID
DfsAttachFcb(
  IN    PFILE_OBJECT pFileObj,
  IN    PDFS_FCB pFCB
);

VOID
DfsDetachFcb(
  IN    PFILE_OBJECT pFileObj,
  IN    PDFS_FCB pFCB
);

NTSTATUS
DfsAllocateFcb(
  IN    PDEVICE_OBJECT DeviceObject,
  IN    PFILE_OBJECT FileObject,
  OUT   PDFS_FCB *Fcb
);

VOID
DfsDestroyFcb(
  IN    PDFS_FCB Fcb);

#endif  // __FCBSUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\fileinfo.c ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       FILEINFO.C
//
//  Contents:   This module implements the File Information routines for
//              Dfs called by the dispatch driver.
//
//  Functions:  DfsFsdSetInformation - FSD entry point for NtSetInformationFile
//              DfsCommonSetInformation - Implement SetInformationFile for DFS
//              DfsSetRenameInfo - Takes care of rename restrictions.
//              DfsSetDispositionInfo - Enforces Deletion of StgId restrictions.
//
//  Notes:      No query information routines are presently used.
//              These requests are passed directly through to a redirected
//              file (if one exists).
//
//  History:    30 Jun 1992     AlanW   Created from FastFAT source.
//              09 Feb 1994     SudK    Added Rename/Delete restrictions.
//
//--------------------------------------------------------------------------


#include "dfsprocs.h"
#include "attach.h"
#include "localvol.h"
#include "dfswml.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILEINFO)

//
//  Local procedure prototypes
//

NTSTATUS
DfsCommonSetInformation (
    IN PIRP Irp,
    BOOLEAN DfsEnable
    );

NTSTATUS
DfsSetDispositionInfo (
    IN PIRP Irp
    );

NTSTATUS
DfsSetRenameInfo (
    IN PIRP Irp);

#ifdef ALLOC_PRAGMA
#pragma alloc_text ( PAGE, DfsFsdSetInformation )
#pragma alloc_text ( PAGE, DfsCommonSetInformation )
#pragma alloc_text ( PAGE, DfsSetDispositionInfo )
#pragma alloc_text ( PAGE, DfsSetRenameInfo )
#endif // ALLOC_PRAGMA


//+-------------------------------------------------------------------
//
//  Function:   DfsFsdSetInformation, public
//
//  Synopsis:   This routine implements the FSD part of the
//              NtSetInformationFile API call.
//
//  Arguments:  [DeviceObject] -- Supplies the volume device object where
//                      the file being set exists.
//              [Irp] -- Supplies the Irp being processed.
//
//  Returns:    NTSTATUS - The FSD status for the Irp.
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdSetInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
) {
    NTSTATUS Status;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILE_OBJECT FileObject = irpSp->FileObject;
    ASSERT(ARGUMENT_PRESENT(DeviceObject));
    ASSERT(ARGUMENT_PRESENT(Irp));

    DebugTrace(+1, Dbg, "DfsFsdSetInformation\n", 0);
    DFS_TRACE_LOW(TRACE_IRP, DfsFsdSetInformation_Entry,
                   LOGPTR(FileObject)
                   LOGPTR(Irp));


    if (DeviceObject->DeviceType == FILE_DEVICE_DFS_VOLUME) {
        //
        //  For local paths, we need to protect exit points and
        //  local storage IDs against rename and delete.  Otherwise,
        //  pass the request along to the local file system driver.
        //

        Status = DfsCommonSetInformation(
                             Irp,
                             ((PDFS_VOLUME_OBJECT)DeviceObject)->DfsEnable);

    } else {

	Status = DfsVolumePassThrough( DeviceObject, Irp );

    }

    DebugTrace(-1, Dbg, "DfsFsdSetInformation: Exit -> %08lx\n", ULongToPtr( Status ));

    DFS_TRACE_LOW(TRACE_IRP, DfsFsdSetInformation_Exit, 
                  LOGSTATUS(Status)
                  LOGPTR(FileObject)
                  LOGPTR(Irp));

    return( Status );

}


//+-------------------------------------------------------------------
//
//  Function:   DfsCommonSetInformation, private
//
//  Synopsis:   This is the common routine for setting file information called
//              by both the FSD and FSP threads.
//
//  Arguments:  [Irp] -- Supplies the Irp being processed
//
//  Returns:    NTSTATUS - The return status for the operation
//
//--------------------------------------------------------------------
//

NTSTATUS
DfsCommonSetInformation (
    IN PIRP Irp,
    IN BOOLEAN DfsEnabled
) {
    NTSTATUS            Status = STATUS_SUCCESS;

    PIO_STACK_LOCATION  IrpSp;
    PIO_STACK_LOCATION  NextIrpSp;

    PFILE_OBJECT        FileObject;
    FILE_INFORMATION_CLASS FileInformationClass;
    PDEVICE_OBJECT      Vdo, DeviceObject;


    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    DFS_TRACE_LOW(TRACE_IRP, DfsCommonSetInformation_Entry,
                  LOGPTR(Irp)
                  LOGPTR(IrpSp->FileObject)
                  LOGBOOLEAN(DfsEnabled));

    DebugTrace(+1, Dbg, "DfsCommonSetInformation...\n", 0);
    DebugTrace( 0, Dbg, "Irp                    = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "->Length               = %08lx\n", ULongToPtr( IrpSp->Parameters.SetFile.Length ));
    DebugTrace( 0, Dbg, "->FileInformationClass = %08lx\n", IrpSp->Parameters.SetFile.FileInformationClass);
    DebugTrace( 0, Dbg, "->ReplaceFileObject    = %08lx\n", IrpSp->Parameters.SetFile.FileObject);
    DebugTrace( 0, Dbg, "->ReplaceIfExists      = %08lx\n", IrpSp->Parameters.SetFile.ReplaceIfExists);
    DebugTrace( 0, Dbg, "->Buffer               = %08lx\n", Irp->AssociatedIrp.SystemBuffer);

    //
    //  Reference our input parameters to make things easier
    //

    FileInformationClass = IrpSp->Parameters.SetFile.FileInformationClass;
    FileObject = IrpSp->FileObject;
    DeviceObject = IrpSp->DeviceObject;

    try {

        //
        //  Based on the information class we'll do different
        //  actions.  Each of the procedures that we're calling will either
        //  complete the request of send the request off to the fsp
        //  to do the work.
        //

        switch (FileInformationClass) {

        case FileRenameInformation:
        case FileDispositionInformation:

            if (DfsEnabled) {
                 if (FileInformationClass == FileRenameInformation) {
                       Status = DfsSetRenameInfo( Irp );
                  }
                 else {
                       Status = DfsSetDispositionInfo( Irp );
                 }

                 if (Status != STATUS_MORE_PROCESSING_REQUIRED)
                       break;
	    }
            // NOTE: Fall through

        default:

            //
            // Copy the stack from one to the next...
            //

            NextIrpSp = IoGetNextIrpStackLocation(Irp);
            (*NextIrpSp) = (*IrpSp);

            IoSetCompletionRoutine( Irp,
                                    NULL,
                                    NULL,
                                    FALSE,
                                    FALSE,
                                    FALSE);

            Vdo = ((PDFS_VOLUME_OBJECT)DeviceObject)->Provider.DeviceObject;

            Status = IoCallDriver( Vdo, Irp);
            DFS_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsCommonDetInformation_Error_IoCallDriver,
                                 LOGPTR(Irp)
                                 LOGPTR(FileObject)
                                 LOGSTATUS(Status));

            //
            //  The IRP will be completed by the called driver.
            //

            Irp = NULL;

            break;
        }

    } finally {

        if (!AbnormalTermination()) {

            DfsCompleteRequest( Irp, Status );
        }

        DebugTrace(-1, Dbg, "DfsCommonSetInformation -> %08lx\n", ULongToPtr( Status ));
    }

    
    DFS_TRACE_LOW(TRACE_IRP, DfsCommonSetInformation_Exit, 
                  LOGSTATUS(Status)
                  LOGPTR(FileObject)
                  LOGPTR(Irp));
    return Status;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsSetDispositionInfo, private
//
//  Synopsis:   This routine performs the set name information for DFS.  In
//              many cases, this is simply done by sending it along to the
//              redirected or attached file object.  If, however, this is a
//              local volume and the storageId is about to be deleted the
//              the operation will be refused.
//
//  Arguments:  [Irp] -- Supplies the IRP being processed
//
//  Returns:    NTSTATUS - The result of this operation if it completes
//                      without an exception. STATUS_MORE_PROCESSING_REQUIRED
//                      is returned if the request should just be passed on
//                      to the attached-to device.
//
//--------------------------------------------------------------------
NTSTATUS
DfsSetDispositionInfo (
    IN PIRP Irp
)
{
    NTSTATUS                    Status = STATUS_MORE_PROCESSING_REQUIRED;

    PIO_STACK_LOCATION          IrpSp;
    PFILE_OBJECT                FileObject;
    PDEVICE_OBJECT              DeviceObject;
    PDFS_PKT                    Pkt;
    PDFS_LOCAL_VOL_ENTRY        lv;

    //
    //  The following variables are for abnormal termination
    //

    BOOLEAN LockedPkt = FALSE;

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    DeviceObject = IrpSp->DeviceObject;
    FileObject = IrpSp->FileObject;

    DebugTrace(+1, Dbg, "DfsSetDispositionInfo...\n", 0);

    try {

        PDFS_FCB fcb;

        fcb = DfsLookupFcb( FileObject );

        if (fcb != NULL) {

            DebugTrace(0, Dbg, "File Delete on %wZ attempted\n",
                        &fcb->FullFileName);

            //
            // Now we have the full file name of file we are trying to delete
            //

            Pkt = _GetPkt();

            PktAcquireShared(Pkt, TRUE);

            LockedPkt = TRUE;

            if (DfsFileOnExitPath( Pkt, &fcb->FullFileName )) {
                try_return( Status = STATUS_ACCESS_DENIED );
            }

        }

        Status = STATUS_MORE_PROCESSING_REQUIRED;

    try_exit: NOTHING;

    } finally {

        //
        //  Release the PKT if locked. FreeMemory if allocated.
        //

        if (LockedPkt)
            PktRelease(&DfsData.Pkt);

        DebugTrace(-1, Dbg, "DfsSetDispositionInfo -> %08lx\n", ULongToPtr( Status ));
    }

    return(Status);

}

NTSTATUS
DfspRenameAllowed()
{
    return( STATUS_SUCCESS );
}


//+--------------------------------------------------------------------------
//
//  Function:   DfsSetRenameInfo, private
//
//  Synopsis:   This routine performs the set name information for DFS.  In
//              many cases, this is simply done by sending it along to the
//              redirected or attached file object.  If, however, this is a
//              local volume and there are volume exit points below a
//              directory being renamed, DFS knowledge is being changed, and
//              the operation will be refused unless this is being done as
//              part of the rename DFS path administrative operation.
//
//  Arguments:  [Irp] -- Supplies the IRP being processed
//
//  Returns:    [STATUS_MORE_PROCESSING_REQUIRED] -- Caller should continue
//                      processing of the Irp by forwarding it to the
//                      underlying file system driver.
//
//              [STATUS_NOT_SAME_DEVICE] -- Indicates the source file object
//                      and the target file object are not on the same device.
//
//              [STATUS_INVALID_PARAMETER] -- Operation is invalid for the
//                      type of file object or target file object.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Unable to allocate memory
//                      for the operation.
//
//---------------------------------------------------------------------------

NTSTATUS
DfsSetRenameInfo (
    IN PIRP Irp)
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;

    PIO_STACK_LOCATION          IrpSp;
    PDEVICE_OBJECT              DeviceObject;
    PDFS_VOLUME_OBJECT          dfsVdo;
    PFILE_OBJECT                FileObject;
    PFILE_OBJECT                TargetFileObject;
    PDFS_PKT                    Pkt;
    PUNICODE_PREFIX_TABLE_ENTRY lvpfx;
    PDFS_LOCAL_VOL_ENTRY        lv;
    PDFS_FCB                    fcb;


    //
    //  The following variables are for abnormal termination
    //

    BOOLEAN LockedPkt = FALSE;

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    DeviceObject = IrpSp->DeviceObject;
    dfsVdo = (PDFS_VOLUME_OBJECT) DeviceObject;
    TargetFileObject = IrpSp->Parameters.SetFile.FileObject;
    FileObject = IrpSp->FileObject;

    DebugTrace(+1, Dbg, "DfsSetRenameInfo...\n", 0);

    try {

        if (DeviceObject->DeviceType == FILE_DEVICE_DFS_VOLUME) {

            //
            // This is the hard case. We have to do a lookup of the local
            // name and look for conflicts.
            //

            fcb = DfsLookupFcb(FileObject);

            if (fcb != NULL) {

                DebugTrace(0, Dbg,
                    "File Rename on %wZ attempted\n", &fcb->FullFileName);

                //
                // Now we have the full file name of file we are trying to rename.
                //

                Pkt = _GetPkt();

                PktAcquireShared(Pkt, TRUE);

                LockedPkt = TRUE;

                //
                // First we make sure that we are not renaming any storageId.
                //
                lvpfx = DfsNextUnicodePrefix(&Pkt->LocalVolTable, TRUE);

                while (lvpfx != NULL) {

                    lv = CONTAINING_RECORD(
                            lvpfx,
                            DFS_LOCAL_VOL_ENTRY,
                            PrefixTableEntry);

                    if (DfsRtlPrefixPath(&fcb->FullFileName, &lv->LocalPath, TRUE)) {

                        try_return(Status = STATUS_ACCESS_DENIED);

                    }

                    lvpfx = DfsNextUnicodePrefix(&Pkt->LocalVolTable, FALSE);
                }

                //
                // Now we only need to make sure that we are not renaming an
                // exit path.
                //

                if (DfsFileOnExitPath(Pkt, &fcb->FullFileName))  {

                    //
                    // If this is a namespace reorg then if caller is DfsManager
                    // allow the access else fail the call.
                    //

                    if (DfspRenameAllowed()) {

                        try_return(Status = STATUS_MORE_PROCESSING_REQUIRED);

                    } else {

                        try_return(Status = STATUS_ACCESS_DENIED);

                    }

                }

            }

        } else {

            try_return(Status = STATUS_INVALID_DEVICE_REQUEST);

        }


    try_exit: NOTHING;

    } finally {

        //
        //  Release the PKT if locked. FreeMemory if allocated.
        //

        if (LockedPkt)
            PktRelease(&DfsData.Pkt);

    }

    DebugTrace(-1, Dbg, "DfsSetRenameInfo -> %08lx\n", ULongToPtr( Status ));

    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\fsctrl.c ===
//-----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       fsctrl.c
//
//  Contents:
//      This module implements the File System Control routines for Dsfs called
//      by the dispatch driver.
//
//  Functions:
//              DfsFsdFileSystemControl
//              DfsFspFileSystemControl
//              DfsCommonFileSystemControl, local
//              DfsUserFsctl, local
//              DfsInsertProvider - Helper routine for DfsFsctrlDefineProvider
//              DfsFsctrlReadCtrs - Read the Dfs driver perfmon counters
//              DfsFsctrlGetServerName - Get name of server given prefix
//              DfsFsctrlReadStruct - return an internal data struct (debug build only)
//              DfsFsctrlReadMem - return internal memory (debug build only)
//              DfsCompleteMountRequest - Completion routine for mount IRP
//              DfsCompleteLoadFsRequest - Completion routine for Load FS IRP
//
//-----------------------------------------------------------------------------


#include "dfsprocs.h"
#include "attach.h"
#include "registry.h"
#include "regkeys.h"
#include "know.h"
#include "localvol.h"
#include "lvolinit.h"
#include "fsctrl.h"
#include "sitesup.h"
#include "ipsup.h"
#include "spcsup.h"
#include "dfslpc.h"
#include "dfswml.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSCTRL)

//
//  Local procedure prototypes
//

NTSTATUS
DfsCommonFileSystemControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsUserFsctl (
    IN PIRP Irp
    );


NTSTATUS
DfsFsctrlStartDfs(
    IN PIRP Irp);

VOID DfsSetMachineState();

NTSTATUS
DfsFsctrlGetServerName(
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG   InputBufferLength,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength);

#if DBG
NTSTATUS
DfsFsctrlReadStruct (
    IN PIRP Irp,
    IN PFILE_DFS_READ_STRUCT_PARAM pRsParam,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DfsFsctrlReadMem (
    IN PIRP Irp,
    IN PFILE_DFS_READ_MEM Request,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength
    );
#endif

NTSTATUS
DfsCompleteMountRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
);

NTSTATUS
DfsCompleteLoadFsRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
);

NTSTATUS
DfsFsctrlGetPkt(
    IN PIRP Irp,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength);

NTSTATUS
DfsGetPktSize(
    OUT PULONG pSize);

NTSTATUS
DfsGetPktMarshall(
    IN PBYTE Buffer,
    IN ULONG Size);

#if DBG
VOID
DfsGetDebugFlags(void);
#endif

VOID
DfsGetEventLogValue(VOID);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsFsdFileSystemControl )
#pragma alloc_text( PAGE, DfsCommonFileSystemControl )
#pragma alloc_text( PAGE, DfsUserFsctl )
#pragma alloc_text( PAGE, DfsSetMachineState)
#pragma alloc_text( PAGE, DfsInsertProvider )
#pragma alloc_text( PAGE, DfsFsctrlGetServerName )
#pragma alloc_text( PAGE, DfspStringInBuffer)
#pragma alloc_text( PAGE, DfsFsctrlGetPkt)
#pragma alloc_text( PAGE, DfsGetPktSize)
#pragma alloc_text( PAGE, DfsGetPktMarshall)

#if DBG
#pragma alloc_text( PAGE, DfsFsctrlReadStruct )
#pragma alloc_text( PAGE, DfsFsctrlReadMem )
#endif // DBG

//
// The following routines cannot be paged because they are completion
// routines which can be called at raised IRQL
//
// DfsCompleteMountRequest
// DfsCompleteLoadFsRequest
//

#endif // ALLOC_PRAGMA


//+-------------------------------------------------------------------
//
//  Function:   DfsFsdFileSystemControl, public
//
//  Synopsis:   This routine implements the FSD part of FileSystem
//              control operations
//
//  Arguments:  [DeviceObject] -- Supplies the volume device object
//                      where the file exists
//              [Irp] -- Supplies the Irp being processed
//
//  Returns:    [NTSTATUS] -- The FSD status for the IRP
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdFileSystemControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
) {
    BOOLEAN Wait;
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    DebugTrace(+1, Dbg, "DfsFsdFileSystemControl\n", 0);
    DFS_TRACE_HIGH(TRACE_IRP, DfsFsdFileSystemControl_Entry,
                   LOGPTR(FileObject)
                   LOGPTR(Irp));

    //
    //  Call the common FileSystem Control routine, with blocking allowed
    //  if synchronous.  This opeation needs to special case the mount
    //  and verify suboperations because we know they are allowed to block.
    //  We identify these suboperations by looking at the file object field
    //  and seeing if it's null.
    //

    if (IoGetCurrentIrpStackLocation(Irp)->FileObject == NULL) {

        Wait = TRUE;

    } else {

        Wait = CanFsdWait( Irp );

    }

    FsRtlEnterFileSystem();

    try {


        Status = DfsCommonFileSystemControl( DeviceObject, Irp );

    } except( DfsExceptionFilter( GetExceptionCode(), GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = DfsProcessException( Irp, GetExceptionCode() );

    }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "DfsFsdFileSystemControl -> %08lx\n", ULongToPtr( Status ));
    DFS_TRACE_HIGH(TRACE_IRP, DfsFsdFileSystemControl_Exit, 
                   LOGSTATUS(Status)
                   LOGPTR(FileObject)
                   LOGPTR(Irp));
    
    return Status;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsCommonFileSystemControl, local
//
//  Synopsis:   This is the common routine for doing FileSystem control
//              operations called by both the FSD and FSP threads
//
//  Arguments:  [DeviceObject] -- The one used to enter our FSD Routine
//              [Irp] -- Supplies the Irp to process
//
//  Returns:    NTSTATUS - The return status for the operation
//--------------------------------------------------------------------

NTSTATUS
DfsCommonFileSystemControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
) {
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp, NextIrpSp;
    PFILE_OBJECT FileObject;
    ULONG FsControlCode;


    
    //      
    //  Get a pointer to the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FileObject = IrpSp->FileObject;
    DFS_TRACE_LOW(TRACE_IRP, DfsCommonFileSystemControl_Entry,
               LOGPTR(FileObject)
               LOGPTR(Irp));

    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace(+1, Dbg, "DfsCommonFileSystemControl\n", 0);
    DebugTrace( 0, Dbg, "Irp                = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "MinorFunction      = %08lx\n", IrpSp->MinorFunction);

    //
    //  We know this is a file system control so we'll case on the
    //  minor function, and call a internal worker routine to complete
    //  the irp.
    //
    switch (IrpSp->MinorFunction) {

    case IRP_MN_USER_FS_REQUEST:

        //
        // If the FSCTL is issued via a device that is not 
        // the DFS file system device object, then reject the request.
        //
        if (IS_DFS_CTL_CODE( FsControlCode )) {
            if (DeviceObject == DfsData.FileSysDeviceObject) {
                 Status = DfsUserFsctl( Irp );
            }
            else {
                 DebugTrace(0, Dbg,"Dfs Fsctrl from invalid device object!\n", 0);
                 Status = STATUS_INVALID_DEVICE_REQUEST;
                 DFS_TRACE_HIGH(ERROR, DfsCommonFileSystemControl_Error_FsctrlFromInvalidDeviceObj,
                                LOGPTR(Irp)
                                LOGPTR(FileObject)
                                LOGSTATUS(Status));
                 DfsCompleteRequest( Irp, Status );
            }
        } else if (DeviceObject->DeviceType == FILE_DEVICE_DFS_VOLUME ||
                    DeviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM) {

            Status = DfsVolumePassThrough(DeviceObject, Irp);

            DebugTrace(0, Dbg, "Pass through user fsctrl -> %08lx\n", ULongToPtr( Status ) );

        } else {

            DebugTrace(0, Dbg, "Non Dfs Fsctrl code to Dfs File System Object!\n", 0);

            Status = STATUS_INVALID_DEVICE_REQUEST;

            DfsCompleteRequest( Irp, Status );

        }
        break;

    case IRP_MN_MOUNT_VOLUME:
    case IRP_MN_VERIFY_VOLUME:

        ASSERT( DeviceObject != NULL );

        if (DeviceObject->DeviceType == FILE_DEVICE_DFS_VOLUME) {

            Status = DfsVolumePassThrough(DeviceObject, Irp);

            DebugTrace(0, Dbg, "Pass through user fsctrl -> %08lx\n", ULongToPtr( Status ) );

        } else if (DeviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM) {

            //
            // We are processing a MOUNT/VERIFY request being directed to
            // another File System to which we have attached our own
            // Attach File System Object. We setup a completion routine
            // and forward the request.
            //

            NextIrpSp = IoGetNextIrpStackLocation(Irp);
            (*NextIrpSp) = (*IrpSp);

            IoSetCompletionRoutine(
                Irp,
                DfsCompleteMountRequest,
                NULL,
                TRUE,
                TRUE,
                TRUE);

            //
            // We want to pass the real device to the underlying file system
            // so it can do its mount. See the comment in
            // DfsCompleteMountRequest.
            //

            IrpSp->Parameters.MountVolume.DeviceObject =
                IrpSp->Parameters.MountVolume.Vpb->RealDevice;


            //
            //  Call the underlying file system via its file system device
            //

            Status = IoCallDriver(
                        ((PDFS_ATTACH_FILE_SYSTEM_OBJECT)
                            DeviceObject)->TargetDevice,
                        Irp );

            DFS_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsCommonFileSystemControl_Error_Vol_IoCallDriver,
                                 LOGSTATUS(Status)
                                 LOGPTR(FileObject)
                                 LOGPTR(Irp));

        } else {

            //
            // We are processing a MOUNT/VERIFY request being directed to our
            // our File System Device Object. We don't directly support
            // disk volumes, so we simply reject.
            //

            ASSERT(DeviceObject->DeviceType == FILE_DEVICE_DFS_FILE_SYSTEM);

            Status = STATUS_NOT_SUPPORTED;

            DfsCompleteRequest( Irp, Status );

        }

        break;

    case IRP_MN_LOAD_FILE_SYSTEM:

        //
        // This is a "load file system" fsctrl being sent to a file system
        // recognizer to which we are attached. We first detach from the
        // recognizer (so it can delete itself), then setup a completion
        // routine and forward the request.
        //

        ASSERT( DeviceObject != NULL );

        IoDetachDevice(
            ((PDFS_ATTACH_FILE_SYSTEM_OBJECT) DeviceObject)->TargetDevice);

        NextIrpSp = IoGetNextIrpStackLocation(Irp);
        (*NextIrpSp) = (*IrpSp);

        IoSetCompletionRoutine(
            Irp,
            DfsCompleteLoadFsRequest,
            NULL,
            TRUE,
            TRUE,
            TRUE);

        Status = IoCallDriver(
                    ((PDFS_ATTACH_FILE_SYSTEM_OBJECT)
                        DeviceObject)->TargetDevice,
                    Irp );

        DFS_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsCommonFileSystemControl_Error_FS_IoCallDriver,
                             LOGSTATUS(Status)
                             LOGPTR(FileObject)
                             LOGPTR(Irp));

        break;


    default:

        //
        // Pass through all the rest we dont care about.
        //
        DebugTrace(0, Dbg, "Unknown FS Control Minor Function %08lx\n",
            IrpSp->MinorFunction);

        Status = DfsVolumePassThrough(DeviceObject, Irp);
 
        break;

    }

    DebugTrace(-1, Dbg, "DfsCommonFileSystemControl -> %08lx\n", ULongToPtr( Status ));

    DFS_TRACE_LOW(TRACE_IRP, DfsCommonFileSystemControl_Exit, 
                  LOGSTATUS(Status)
                  LOGPTR(FileObject)
                  LOGPTR(Irp));

    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsCompleteMountRequest, local
//
//  Synopsis:   Completion routine for a MOUNT fsctrl that was passed through
//              to the underlying File System Device Object.
//
//              This routine will simply see if the MOUNT succeeded. If it
//              did, this routine will call DfsReattachToMountedVolume so
//              any local volumes which were disabled by the unmount will be
//              enabled again.
//
//  Arguments:  [DeviceObject] -- Our Attached File System Object.
//              [Irp] -- The MOUNT fsctrl IRP.
//              [Context] -- Unused
//
//  Returns:    [STATUS_SUCCESS] -- Always.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsCompleteMountRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
    PDEVICE_OBJECT targetDevice;
    PVPB vpb;

    //
    // Determine whether or not the request was successful and act accordingly.
    //

    DebugTrace(+1, Dbg,
        "DfsCompleteMountRequest: Entered %08lx\n", ULongToPtr( Irp->IoStatus.Status ));

    if (NT_SUCCESS( Irp->IoStatus.Status )) {

        //
        // Note that the VPB must be picked up from the target device object
        // in case the file system did a remount of a previous volume, in
        // which case it has replaced the VPB passed in as the target with
        // a previously mounted VPB.  Note also that in the mount dispatch
        // routine, this driver *replaced* the DeviceObject pointer with a
        // pointer to the real device, not the device that the file system
        // was supposed to talk to, since this driver does not care.
        //

        vpb = irpSp->Parameters.MountVolume.DeviceObject->Vpb;

        targetDevice = IoGetAttachedDevice( vpb->DeviceObject );

        DebugTrace(0, Dbg, "Target Device %08lx\n", targetDevice);

        DfsReattachToMountedVolume( targetDevice, vpb );

    }

    //
    // If pending was returned, then propogate it to the caller.
    //

    if (Irp->PendingReturned) {
            IoMarkIrpPending( Irp );
    }

    DebugTrace(-1, Dbg, "DfsCompleteMountRequest: Exited\n", 0);

    return( STATUS_SUCCESS );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsCompleteLoadFsRequest, local
//
//  Synopsis:   Completion routine for a LOAD_FILE_SYSTEM fsctrl Irp. If
//              the load did not succeed, this routine simply reattaches our
//              Attached File System Object to the recognizer. If the load
//              succeeds, this routine arranges to delete the Attached File
//              System Object that was originally attached to the recognizer.
//
//  Arguments:  [DeviceObject] -- Attached File System Object.
//              [Irp] -- The LOAD_FILE_SYSTEM Fsctrl Irp.
//              [Context] -- Unused.
//
//  Returns:    [STATUS_SUCCESS] -- Always.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsCompleteLoadFsRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)
{

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        RemoveEntryList(
            &((PDFS_ATTACH_FILE_SYSTEM_OBJECT) DeviceObject)->FsoLinks);

        //
        // Due to refcounting done by the IO Subsystem, there's no way to
        // delete the DeviceObject.
        //

    } else {

        IoAttachDeviceByPointer(
            DeviceObject,
            ((PDFS_ATTACH_FILE_SYSTEM_OBJECT) DeviceObject)->TargetDevice);


    }

    //
    // If pending was returned, then propogate it to the caller
    //

    if (Irp->PendingReturned) {
            IoMarkIrpPending( Irp );
    }

    return( STATUS_SUCCESS );

}


//+-------------------------------------------------------------------
//
//  Function:   DfsUserFsctl, local
//
//  Synopsis:   This is the common routine for implementing the user's
//              requests made through NtFsControlFile.
//
//  Arguments:  [Irp] -- Supplies the Irp being processed
//
//  Returns:    NTSTATUS - The return status for the operation
//
//--------------------------------------------------------------------

NTSTATUS
DfsUserFsctl (
    IN PIRP Irp
) {
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PIO_STACK_LOCATION NextIrpSp;
    NTSTATUS Status;
    ULONG FsControlCode;

    ULONG cbOutput;
    ULONG cbInput;

    PUCHAR InputBuffer;
    PUCHAR OutputBuffer;

    //
    // Just in case some-one (cough) forgets about it...
    // ...zero information status now!
    //

    Irp->IoStatus.Information = 0L;

    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    cbInput = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    cbOutput = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    DebugTrace(+1, Dbg, "DfsUserFsctl:  Entered\n", 0);
    DebugTrace( 0, Dbg, "DfsUserFsctl:  Cntrl Code  -> %08lx\n", ULongToPtr( FsControlCode ));
    DebugTrace( 0, Dbg, "DfsUserFsctl:  cbInput   -> %08lx\n", ULongToPtr( cbInput ));
    DebugTrace( 0, Dbg, "DfsUserFsctl:  cbOutput   -> %08lx\n", ULongToPtr( cbOutput ));

    //
    //  All DFS FsControlCodes use METHOD_BUFFERED, so the SystemBuffer
    //  is used for both the input and output.
    //

    InputBuffer = OutputBuffer = Irp->AssociatedIrp.SystemBuffer;

    DebugTrace( 0, Dbg, "DfsUserFsctl:  InputBuffer -> %08lx\n", InputBuffer);
    DebugTrace( 0, Dbg, "DfsUserFsctl:  UserBuffer  -> %08lx\n", Irp->UserBuffer);

    //
    //  Case on the control code.
    //

    switch ( FsControlCode ) {

    case FSCTL_REQUEST_OPLOCK_LEVEL_1:
    case FSCTL_REQUEST_OPLOCK_LEVEL_2:
    case FSCTL_REQUEST_BATCH_OPLOCK:
    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
    case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
    case FSCTL_OPLOCK_BREAK_NOTIFY:
    case  FSCTL_DFS_READ_METERS:
    case  FSCTL_SRV_DFSSRV_IPADDR:
        Status = STATUS_INVALID_DEVICE_REQUEST;
        DfsCompleteRequest( Irp, Status );
        break;

    case FSCTL_DISMOUNT_VOLUME:
        Status = STATUS_NOT_SUPPORTED;
        DfsCompleteRequest( Irp, Status );
        break;

    case  FSCTL_DFS_GET_VERSION:
        if (OutputBuffer != NULL &&
                cbOutput >= sizeof(DFS_GET_VERSION_ARG)) {
            PDFS_GET_VERSION_ARG parg =
                (PDFS_GET_VERSION_ARG) OutputBuffer;
            parg->Version = 1;
            Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(DFS_GET_VERSION_ARG);
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
        DfsCompleteRequest(Irp, Status);
        break;

    case  FSCTL_DFS_IS_ROOT:
        if (DfsData.MachineState == DFS_UNKNOWN) {
            DfsSetMachineState();
        }

        if (DfsData.MachineState == DFS_ROOT_SERVER) {
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_INVALID_DOMAIN_ROLE;
        }
        DfsCompleteRequest(Irp, Status);
        break;

    case  FSCTL_DFS_ISDC:

        DfsData.IsDC = TRUE;
        Status = STATUS_SUCCESS;
        DfsCompleteRequest(Irp, Status);
        break;

    case  FSCTL_DFS_ISNOTDC:

        DfsData.IsDC = FALSE;
        Status = STATUS_SUCCESS;
        DfsCompleteRequest(Irp, Status);
        break;

    case  FSCTL_DFS_GET_ENTRY_TYPE:
        Status = DfsFsctrlGetEntryType(
                    Irp,
                    InputBuffer,
                    cbInput,
                    OutputBuffer,
                    cbOutput);
        break;

    case  FSCTL_DFS_MODIFY_PREFIX:
        Status = DfsFsctrlModifyLocalVolPrefix(
                Irp,
                InputBuffer,
                cbInput
        );
        break;

    case  FSCTL_DFS_CREATE_EXIT_POINT:
        Status = DfsFsctrlCreateExitPoint(
                Irp,
                InputBuffer,
                cbInput,
                OutputBuffer,
                cbOutput
        );
        break;

    case  FSCTL_DFS_DELETE_EXIT_POINT:
        Status = DfsFsctrlDeleteExitPoint(
                Irp,
                InputBuffer,
                cbInput
        );
        break;

    case  FSCTL_DFS_START_DFS:

        DfsGetEventLogValue();
#if DBG
        DfsGetDebugFlags();
#endif  // DBG

        Status = DfsFsctrlStartDfs(
                    Irp);

        if (DfsData.MachineState == DFS_UNKNOWN) {
            DfsSetMachineState();
        }

        //
        // Try to validate our local partitions with a DC
        //

        break;

    case  FSCTL_DFS_STOP_DFS:

        DfsGetEventLogValue();
#if DBG
        DfsGetDebugFlags();
#endif  // DBG

        Status = DfsFsctrlStopDfs(
                    Irp
        );

        break;

    case FSCTL_DFS_RESET_PKT:

        Status = DfsFsctrlResetPkt(
                    Irp
        );
        break;

    case FSCTL_DFS_MARK_STALE_PKT_ENTRIES:

        Status = DfsFsctrlMarkStalePktEntries(
                    Irp
        );
        break;

    case FSCTL_DFS_FLUSH_STALE_PKT_ENTRIES:

        Status = DfsFsctrlFlushStalePktEntries(
                    Irp
        );
        break;

    case  FSCTL_DFS_INIT_LOCAL_PARTITIONS:
        DfsInitLocalPartitions();
        Status = STATUS_SUCCESS;
        DfsCompleteRequest( Irp, Status);
        break;

    case  FSCTL_DFS_CREATE_LOCAL_PARTITION:
        Status = DfsFsctrlCreateLocalPartition(
                Irp,
                InputBuffer,
                cbInput
        );
        break;

    case  FSCTL_DFS_CREATE_SITE_INFO:
        Status = DfsFsctrlCreateSiteInfo(
                Irp,
                InputBuffer,
                cbInput
        );
        break;

    case  FSCTL_DFS_DELETE_SITE_INFO:
        Status = DfsFsctrlDeleteSiteInfo(
                Irp,
                InputBuffer,
                cbInput
        );
        break;

    case  FSCTL_DFS_CREATE_IP_INFO:
        Status = DfsFsctrlCreateIpInfo(
                Irp,
                InputBuffer,
                cbInput
        );
        break;

    case  FSCTL_DFS_DELETE_IP_INFO:
        Status = DfsFsctrlDeleteIpInfo(
                Irp,
                InputBuffer,
                cbInput
        );
        break;

    case  FSCTL_DFS_CREATE_SPECIAL_INFO:
        Status = DfsFsctrlCreateSpcInfo(
                    DfsData.SpcHashTable,
                    Irp,
                    InputBuffer,
                    cbInput
        );
        break;

    case  FSCTL_DFS_DELETE_SPECIAL_INFO:
        Status = DfsFsctrlDeleteSpcInfo(
                    DfsData.SpcHashTable,
                    Irp,
                    InputBuffer,
                    cbInput
        );
        break;

    case  FSCTL_DFS_CREATE_FTDFS_INFO:
        Status = DfsFsctrlCreateSpcInfo(
                    DfsData.FtDfsHashTable,
                    Irp,
                    InputBuffer,
                    cbInput
        );
        break;

    case  FSCTL_DFS_DELETE_FTDFS_INFO:
        Status = DfsFsctrlDeleteSpcInfo(
                    DfsData.FtDfsHashTable,
                    Irp,
                    InputBuffer,
                    cbInput
        );
        break;

    case  FSCTL_DFS_DELETE_LOCAL_PARTITION:
        Status = DfsFsctrlDeleteLocalPartition(
                Irp,
                InputBuffer,
                cbInput
        );
        break;

    case  FSCTL_DFS_SET_LOCAL_VOLUME_STATE:
        Status = DfsFsctrlSetVolumeState(
                Irp,
                InputBuffer,
                cbInput);
        break;

    case  FSCTL_DFS_SET_SERVICE_STATE:
        Status = DfsFsctrlSetServiceState(
                Irp,
                InputBuffer,
                cbInput);
        break;

    case  FSCTL_DFS_DC_SET_VOLUME_STATE:
        Status = DfsFsctrlDCSetVolumeState(
                Irp,
                InputBuffer,
                cbInput);
        break;

    case  FSCTL_DFS_SET_VOLUME_TIMEOUT:
        Status = DfsFsctrlSetVolumeTimeout(
                Irp,
                InputBuffer,
                cbInput);
        break;

    case  FSCTL_DFS_IS_CHILDNAME_LEGAL:
        Status = PktFsctrlIsChildnameLegal(
                Irp,
                InputBuffer,
                cbInput);
        break;

    case  FSCTL_DFS_PKT_CREATE_ENTRY:
        Status = PktFsctrlCreateEntry(
                Irp,
                InputBuffer,
                cbInput
        );
        break;

    case  FSCTL_DFS_PKT_CREATE_SUBORDINATE_ENTRY:
        Status = PktFsctrlCreateSubordinateEntry(
                Irp,
                InputBuffer,
                cbInput
        );
        break;

    case  FSCTL_DFS_PKT_DESTROY_ENTRY:
        Status = PktFsctrlDestroyEntry(
                Irp,
                InputBuffer,
                cbInput
        );
        break;

    case  FSCTL_DFS_PKT_SET_RELATION_INFO:
        Status = PktFsctrlSetRelationInfo(
                Irp,
                InputBuffer,
                cbInput
        );
        break;

    case  FSCTL_DFS_PKT_GET_RELATION_INFO:
        Status = PktFsctrlGetRelationInfo(
                Irp,
                InputBuffer,
                cbInput,
                OutputBuffer,
                cbOutput
        );
        break;

    case  FSCTL_DFS_GET_SERVER_INFO:
        Status = DfsFsctrlGetServerInfo(
                Irp,
                InputBuffer,
                cbInput,
                OutputBuffer,
                cbOutput);
        break;

    case  FSCTL_DFS_SET_SERVER_INFO:
        Status = PktFsctrlSetServerInfo(
                Irp,
                InputBuffer,
                cbInput);
        break;

    case  FSCTL_DFS_CHECK_STGID_IN_USE:
        Status = DfsFsctrlCheckStgIdInUse(
                Irp,
                InputBuffer,
                cbInput,
                OutputBuffer,
                cbOutput);
        break;

    case  FSCTL_DFS_VERIFY_LOCAL_VOLUME_KNOWLEDGE:
        Status = PktFsctrlVerifyLocalVolumeKnowledge(
                Irp,
                InputBuffer,
                cbInput
        );
        break;

    case  FSCTL_DFS_PRUNE_LOCAL_PARTITION:
        Status = PktFsctrlPruneLocalVolume(
                Irp,
                InputBuffer,
                cbInput);
        break;

    case  FSCTL_DFS_FIX_LOCAL_VOLUME:
        Status = DfsFsctrlFixLocalVolumeKnowledge(Irp,
                                                  InputBuffer,
                                                  cbInput);
        break;


    case  FSCTL_DFS_GET_SERVER_NAME:
        Status = DfsFsctrlGetServerName(Irp,
                                        InputBuffer,
                                        cbInput,
                                        OutputBuffer,
                                        cbOutput);
        break;

    case  FSCTL_SRV_DFSSRV_CONNECT:
        Status = PktFsctrlDfsSrvConnect(Irp,
                                         InputBuffer,
                                         cbInput);
        break;

    case FSCTL_DFS_GET_PKT:
        Status = DfsFsctrlGetPkt(Irp,
                                OutputBuffer,
                                cbOutput);

         break;


    case FSCTL_DFS_GET_NEXT_LONG_DOMAIN_NAME:
        Status = DfsFsctrlGetDomainToRefresh(Irp,
					     OutputBuffer,
					     cbOutput);
	break;
        

    case FSCTL_DFS_REREAD_REGISTRY:
        DfsGetEventLogValue();
#if DBG
        DfsGetDebugFlags();
        DbgPrint("DfsDebugTraceLevel=0x%x\n", DfsDebugTraceLevel);
        DbgPrint("DfsEventLog=0x%x\n", DfsEventLog);
#endif  // DBG
        DfspGetMaxReferrals();	
        Status = STATUS_SUCCESS;
        DfsCompleteRequest(Irp, Status);
        break;

#if DBG
    case  FSCTL_DFS_PKT_FLUSH_CACHE:
        Status = PktFsctrlFlushCache(Irp, InputBuffer, cbInput);
        break;

    case  FSCTL_DFS_DBG_BREAK:
        DbgBreakPoint();
        Status = STATUS_SUCCESS;
        DfsCompleteRequest(Irp, Status);
        break;

    case  FSCTL_DFS_DBG_FLAGS:
        DfsDebugTraceLevel = * ((PULONG) InputBuffer);
        Status = STATUS_SUCCESS;
        DfsCompleteRequest(Irp, Status);
        break;

    case  FSCTL_DFS_SHUFFLE_ENTRY:
        Status = PktFsctrlShufflePktEntry(
                    Irp,
                    InputBuffer,
                    cbInput);
        break;


    case  FSCTL_DFS_INTERNAL_READ_MEM:
        Status = DfsFsctrlReadMem(
                    Irp,
                    (PFILE_DFS_READ_MEM)InputBuffer,
                    cbInput,
                    OutputBuffer,
                    cbOutput );
        break;

    case  FSCTL_DFS_INTERNAL_READSTRUCT:
        Status = DfsFsctrlReadStruct(
                    Irp,
                    (PFILE_DFS_READ_STRUCT_PARAM)InputBuffer,
                    cbInput,
                    OutputBuffer,
                    cbOutput );
        break;

#endif  // DBG

    default:

        //
        //  This is not a recognized DFS fsctrl.
        //

        Status = STATUS_INVALID_PARAMETER;

        DfsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );

        break;

    }

    DebugTrace(-1, Dbg, "DfsUserFsctl:  Exit -> %08lx\n", ULongToPtr( Status ) );
    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlStartDfs
//
//  Synopsis:   Sets the state of the Dfs driver so that it will start
//              receiving open requests.
//
//  Arguments:  [Irp] --
//
//  Returns:    [STATUS_SUCCESS] -- Successfully set the state to started.
//
//              [STATUS_UNSUCCESSFUL] -- An error occured trying to set the
//                      state of Dfs to started. This is most likely because
//                      of a failure to register with the MUP.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlStartDfs(
    IN PIRP Irp)
{
    NTSTATUS status;
    UNICODE_STRING dfsRootDeviceName;

    STD_FSCTRL_PROLOGUE("DfsFsctrlStartDfs", FALSE, FALSE);

    RtlInitUnicodeString(&dfsRootDeviceName, DFS_DEVICE_ROOT);

    DfsSetMachineState();

    DfsData.OperationalState = DFS_STATE_STARTED;

    status = STATUS_SUCCESS;

    DebugTrace(-1, Dbg, "DfsFsctrlStartDfs - returning %08lx\n", ULongToPtr( status ));

    DfsCompleteRequest(Irp, status);

    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsSetMachineState
//
//  Synopsis:   Gets the machine state from the registry and sets it in
//              DfsData structure.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID DfsSetMachineState()
{

    NTSTATUS    Status;

    DebugTrace(+1, Dbg, "DfsSetMachineState - Entered\n", 0);

    Status = KRegSetRoot( wszRegRootVolumes );

    if (NT_SUCCESS(Status)) {

        DebugTrace(0, Dbg, "Found volumes dir %ws\n", wszRegRootVolumes );

        DfsData.MachineState = DFS_ROOT_SERVER;

        KRegCloseRoot();

    } else if (Status == STATUS_OBJECT_PATH_NOT_FOUND ||
            Status == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // We default to DFS_CLIENT. When we later try to initialize local
        // volumes, if we do have any, we'll upgrade ourselves to
        // DFS_SERVER
        //

        DfsData.MachineState = DFS_CLIENT;

        Status = STATUS_SUCCESS;

    } else {

        DebugTrace(0, Dbg, "Error %08lx opening volumes dir!\n", ULongToPtr( Status ) );

        DfsData.MachineState = DFS_UNKNOWN;
    }

    DebugTrace(-1, Dbg, "DfsSetMachineState - Exited!\n", 0);

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsInsertProvider
//
//  Synopsis:   Given a provider name, id, and capability, will add a new or
//              overwrite an existing provider definition.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS DfsInsertProvider(
    IN PUNICODE_STRING  ProviderName,
    IN ULONG            fProvCapability,
    IN ULONG            eProviderId)
{
    PPROVIDER_DEF pProv = DfsData.pProvider;
    int iProv;

    //
    //  Find a free provider structure, or overwrite an existing one.
    //

    for (iProv = 0; iProv < DfsData.cProvider; iProv++, pProv++) {
        if (pProv->eProviderId == eProviderId)
            break;
    }

    if (iProv >= DfsData.maxProvider) {
        ASSERT(iProv >= DfsData.maxProvider && "Out of provider structs");
        return(STATUS_INSUFFICIENT_RESOURCES);

    }

    if (iProv < DfsData.cProvider) {

        //
        // Decrement reference counts on saved objects
        //
        if (pProv->FileObject)
            ObDereferenceObject(pProv->FileObject);
        if (pProv->DeviceObject)
            ObDereferenceObject(pProv->DeviceObject);
        if (pProv->DeviceName.Buffer)
            ExFreePool(pProv->DeviceName.Buffer);
    }

    pProv->FileObject = NULL;
    pProv->DeviceObject = NULL;


    pProv->eProviderId = (USHORT) eProviderId;
    pProv->fProvCapability = (USHORT) fProvCapability;
    pProv->DeviceName = *ProviderName;

    if (iProv == DfsData.cProvider) {
        DfsData.cProvider++;
    }

    return(STATUS_SUCCESS);
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlGetServerName
//
//  Synopsis:   Given a Prefix in Dfs namespace it gets a server name for
//              it.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
NTSTATUS
DfsFsctrlGetServerName(
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG   InputBufferLength,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength)
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDFS_PKT            pkt;
    PWCHAR              pwchServer = (PWCHAR) OutputBuffer;
    ULONG               cChServer = 0;
    ULONG               MaxAllowed;
    PDFS_PKT_ENTRY      pEntry;
    PWCHAR              pwszPrefix = (PWCHAR) InputBuffer;
    UNICODE_STRING      ustrPrefix, RemainingPath;
    PDFS_SERVICE        pService;
    PWCHAR              pwch;
    ULONG               i;

    STD_FSCTRL_PROLOGUE(DfsFsctrlGetServerName, TRUE, TRUE);

    DebugTrace(+1,Dbg,"DfsFsctrlGetServerName()\n", 0);

    //
    // InputBuffer is a WCHAR.  Check that the buffer is of even size, and 
    // has at least one character in it.
    //

    if (InputBufferLength < sizeof(WCHAR) || (InputBufferLength & 0x1) != 0) {

        DfsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;
        return status;

    }

    //
    // Confirm there's a UNICODE NULL in there somewhere.
    //

    for (i = 0; i < InputBufferLength / sizeof(WCHAR); i++) {

        if (pwszPrefix[i] == UNICODE_NULL) {

            break;

        }

    }

    if (i >= InputBufferLength / sizeof(WCHAR)) {

        DfsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;
        return status;

    }

    //
    // Need to be able to put at least a UNICODE_NULL in the output buffer
    //

    if (OutputBufferLength >= sizeof(WCHAR)) {
    
        MaxAllowed = OutputBufferLength/sizeof(WCHAR) - 1;

    } else {

        DfsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
        status = STATUS_INVALID_PARAMETER;
        return status;

    }

    //
    // Found a UNICODE_NULL in the buffer, so off we go...
    //

    RtlInitUnicodeString(&ustrPrefix, pwszPrefix);

    pkt = _GetPkt();

    PktAcquireExclusive(pkt, TRUE);
    pEntry = PktLookupEntryByPrefix(pkt,
                                    &ustrPrefix,
                                    &RemainingPath);

    if (pEntry == NULL) {
        status = STATUS_OBJECT_NAME_NOT_FOUND;
    } else {
        //
        // If there is a local service then return a NULL string.
        //
        if (pEntry->LocalService != NULL)       {
            *pwchServer = UNICODE_NULL;
            cChServer = 1;
        } else {
            if (pEntry->ActiveService != NULL)  {
                pService = pEntry->ActiveService;
            } else if (pEntry->Info.ServiceCount == 0) {
                pService = NULL;
            } else {

                //
                // Take first service.
                //

                pService = pEntry->Info.ServiceList;
            }

            if (pService != NULL)       {

                pwch = pService->Address.Buffer;
                ASSERT(*pwch == L'\\');
                pwch++;
                while (*pwch != L'\\')  {
                    *pwchServer++ = *pwch++;
                    if (++cChServer >= MaxAllowed) {
                        break;
                    }
                }
                *pwchServer = UNICODE_NULL;
                DebugTrace(0, Dbg, "SERVERName Created %ws\n", pwchServer);
            } else {
                DebugTrace(0, Dbg, "No Service Exists for %ws\n", pwszPrefix);
                status = DFS_STATUS_NO_SUCH_ENTRY;
            }
        }
    }

    PktRelease(pkt);

    Irp->IoStatus.Information = cChServer * sizeof(WCHAR);
    DfsCompleteRequest( Irp, status );

    DebugTrace(-1,Dbg,"DfsFsctrlGetServerName: Exit->%08lx\n", ULongToPtr( status ));
    return status;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfspValidateString, private
//
//  Synopsis:   Check that a LPWSTR lies within a buffer.
//
//  Arguments:  [pwszString] -- pointer to string
//
//  Returns:    TRUE - string lies within buffer
//              FALSE - bad alignment or string doesn't lie within buffer
//
//-----------------------------------------------------------------------------

BOOLEAN
DfspStringInBuffer(LPWSTR pwszString, PVOID Buffer, ULONG BufferLen)
{
    PCHAR BufferEnd = (PCHAR)Buffer + BufferLen;
    PWCHAR wcp;

    //
    // Buffer has to be large enough to at least contain a UNICODE_NULL
    // The buffer has to be aligned correctly
    // The start of the string has to lie within the buffer
    //

    if (BufferLen < sizeof(WCHAR) ||
        !ALIGNMENT_IS_VALID(Buffer, PWCHAR) ||
        !POINTER_IS_VALID(pwszString, Buffer, BufferLen)
    ) {

            return FALSE;

    }

    //
    // Scan the string and be sure we find a UNICODE_NULL within the buffer
    //
    for (wcp = pwszString; (PCHAR)wcp < BufferEnd; wcp++) {


        if (*wcp == UNICODE_NULL) {
            break;
        }

    }

    if ((PCHAR)wcp >= BufferEnd) {

        return FALSE;

    }

    //
    // Looks good!!
    //

    return TRUE;

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlGetPkt
//
//  Synopsis:   Returns the current (cached Pkt)
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlGetPkt(
    IN PIRP Irp,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDFS_PKT pkt;
    BOOLEAN pktLocked = FALSE;
    ULONG cbOutBuffer;


    DebugTrace(+1, Dbg, "DfsFsctrlGetPkt\n", 0);

    STD_FSCTRL_PROLOGUE("DfsFsctrlGetPkt", FALSE, TRUE);

    pkt = _GetPkt();

    PktAcquireShared( pkt, TRUE );

    //
    // Calculate the needed output buffer size
    //
    NtStatus = DfsGetPktSize(&cbOutBuffer);

    //
    // Let user know if it's too small
    //
    if (OutputBufferLength < cbOutBuffer) {

        RETURN_BUFFER_SIZE(cbOutBuffer, NtStatus);

    }

    if (NT_SUCCESS(NtStatus)) {

        //
        // Args are ok, and it fits - marshall the data
        //
        NtStatus = DfsGetPktMarshall(OutputBuffer, cbOutBuffer);

        Irp->IoStatus.Information = cbOutBuffer;

    }

    PktRelease(pkt);

    DfsCompleteRequest( Irp, NtStatus );

    DebugTrace(-1, Dbg, "DfsFsctrlGetPkt -> %08lx\n", ULongToPtr( NtStatus ) );

    return( NtStatus );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetPktSize, private
//
//  Synopsis:   Calculates the size needed to return the Pkt.  Helper for
//              DfsFsctrlGetPkt().
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetPktSize(
    PULONG pSize)
{
    ULONG EntryCount = 0;
    ULONG i;
    ULONG Size = 0;
    PDFS_PKT_ENTRY pPktEntry;
    PDFS_PKT pkt = _GetPkt();

    //
    // Walk the linked list of Pkt entries
    //

    for ( pPktEntry = PktFirstEntry(pkt);
            pPktEntry != NULL;
                pPktEntry = PktNextEntry(pkt, pPktEntry)) {

        //
        // Space for the Prefix and ShortPrefix, including a UNICODE_NULL
        //
        Size += pPktEntry->Id.Prefix.Length + sizeof(WCHAR);
        Size += pPktEntry->Id.ShortPrefix.Length + sizeof(WCHAR);

        //
        // Space for an array of pointers to DFS_PKT_ADDRESS_OBJECTS
        //
        Size += sizeof(PDFS_PKT_ADDRESS_OBJECT) * pPktEntry->Info.ServiceCount;

        //
        // Space for the ServerShare address, plus a UNICODE_NULL, plus the state
        //
        for (i = 0; i < pPktEntry->Info.ServiceCount; i++) {

            Size += sizeof(USHORT) + pPktEntry->Info.ServiceList[i].Address.Length + sizeof(WCHAR);

        }

        EntryCount++;

    }

    //
    // Space for the DFS_PKT_ARG, which will have EntryCount objects on the end
    //
    Size += FIELD_OFFSET(DFS_GET_PKT_ARG, EntryObject[EntryCount]);

    //
    // Make sure the size is a multiple of the size of a PDFS_PKT_ADDRESS_OBJECT, as that is what
    // will be at the end of the buffer
    //

    while ((Size & (sizeof(PDFS_PKT_ADDRESS_OBJECT)-1)) != 0) {
        Size++;
    }

    *pSize = Size;

    return STATUS_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetPktMarshall, private
//
//  Synopsis:   Marshalls the Pkt.  Helper for DfsFsctrlGetPkt().
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetPktMarshall(
    PBYTE Buffer,
    ULONG Size)
{
    ULONG EntryCount = 0;
    ULONG i;
    ULONG j;
    ULONG Type;
    PCHAR pCh;
    PDFS_PKT_ENTRY pPktEntry;
    PDFS_GET_PKT_ARG pPktArg;
    PDFS_PKT pkt = _GetPkt();

    //
    // This will be a two-pass operation, the first pass will calculate how
    // much room for the LPWSTR arrays at the end of the buffer, then the
    // second pass will put the strings into place, too.
    //

    RtlZeroMemory(Buffer,Size);

    //
    // Point to the end of the buffer
    //
    pCh = (PCHAR)(Buffer + Size);

    pPktArg = (PDFS_GET_PKT_ARG)Buffer;

    for ( pPktEntry = PktFirstEntry(pkt);
            pPktEntry != NULL;
                pPktEntry = PktNextEntry(pkt, pPktEntry)) {

        //
        // Space for an array of pointers to DFS_PKT_ADDRESS_OBJECTS
        //
        pCh -= sizeof(PDFS_PKT_ADDRESS_OBJECT) * pPktEntry->Info.ServiceCount;
        pPktArg->EntryObject[EntryCount].Address = (PDFS_PKT_ADDRESS_OBJECT *)pCh;

        EntryCount++;

    }

    //
    // Now marshall
    //

    EntryCount = 0;
    for ( pPktEntry = PktFirstEntry(pkt);
            pPktEntry != NULL;
                pPktEntry = PktNextEntry(pkt, pPktEntry)) {

        pCh -= pPktEntry->Id.Prefix.Length + sizeof(WCHAR);
        pPktArg->EntryObject[EntryCount].Prefix = (LPWSTR)pCh;
        RtlCopyMemory(
            pPktArg->EntryObject[EntryCount].Prefix,
            pPktEntry->Id.Prefix.Buffer,
            pPktEntry->Id.Prefix.Length);

        pCh -= pPktEntry->Id.ShortPrefix.Length + sizeof(WCHAR);
        pPktArg->EntryObject[EntryCount].ShortPrefix = (LPWSTR)pCh;
        RtlCopyMemory(
            pPktArg->EntryObject[EntryCount].ShortPrefix,
            pPktEntry->Id.ShortPrefix.Buffer,
            pPktEntry->Id.ShortPrefix.Length);

        pPktArg->EntryObject[EntryCount].Type = pPktEntry->Type;
        pPktArg->EntryObject[EntryCount].USN = pPktEntry->USN;
        pPktArg->EntryObject[EntryCount].ExpireTime = pPktEntry->ExpireTime;
        pPktArg->EntryObject[EntryCount].UseCount = pPktEntry->UseCount;
        pPktArg->EntryObject[EntryCount].Uid = pPktEntry->Id.Uid;
        pPktArg->EntryObject[EntryCount].ServiceCount = pPktEntry->Info.ServiceCount;

        for (i = 0; i < pPktEntry->Info.ServiceCount; i++) {

            Type = pPktEntry->Info.ServiceList[i].Type;
            pCh -= sizeof(USHORT) + pPktEntry->Info.ServiceList[i].Address.Length + sizeof(WCHAR);
            pPktArg->EntryObject[EntryCount].Address[i] = (PDFS_PKT_ADDRESS_OBJECT)pCh;
            pPktArg->EntryObject[EntryCount].Address[i]->State = (USHORT)Type;

            RtlCopyMemory(
                &pPktArg->EntryObject[EntryCount].Address[i]->ServerShare[0],
                pPktEntry->Info.ServiceList[i].Address.Buffer,
                pPktEntry->Info.ServiceList[i].Address.Length);

        }

        EntryCount++;

    }

    pPktArg->EntryCount = EntryCount;

    //
    // Convert all the pointers to relative offsets
    //

    for (i = 0; i < pPktArg->EntryCount; i++) {

        for (j = 0; j < pPktArg->EntryObject[i].ServiceCount; j++) {

            POINTER_TO_OFFSET(pPktArg->EntryObject[i].Address[j], Buffer);

        }

        POINTER_TO_OFFSET(pPktArg->EntryObject[i].Prefix, Buffer);
        POINTER_TO_OFFSET(pPktArg->EntryObject[i].ShortPrefix, Buffer);
        POINTER_TO_OFFSET(pPktArg->EntryObject[i].Address, Buffer);

    }

    return STATUS_SUCCESS;
}

#if DBG

//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctrlReadMem, local
//
//  Synopsis:   DfsFsctrlReadMem is a debugging function which will return
//              the contents of a chunk of kernel space memory
//
//  Arguments:  [IrpContext] -
//              [Irp] -
//              [Request] -- Pointer to a FILE_DFS_READ_MEM struct,
//                      giving the description of the data to be returned.
//              [InputBufferLength] -- Size of InputBuffer
//              [OutputBuffer] -- User's output buffer, in which the
//                      data structure will be returned.
//              [OutputBufferLength] -- Size of OutputBuffer
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if no error.
//
//  Notes:      Available in DBG builds only.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsFsctrlReadMem (
    IN PIRP Irp,
    IN PFILE_DFS_READ_MEM Request,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength
) {
    NTSTATUS Status;
    PUCHAR ReadBuffer;
    ULONG ReadLength;

    DfsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
    return STATUS_INVALID_PARAMETER;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctrlReadStruct, local
//
//  Synopsis:   DfsFsctrlReadStruct is a debugging function which will return
//              structures associated with the Dfs Server.
//
//  Arguments:  [Irp] -
//              [InputBuffer] -- Pointer to a FILE_DFS_READ_STRUCT_PARAM,
//                      giving the description of the data structure to be
//                      returned.
//              [InputBufferLength] -- Size of InputBuffer
//              [OutputBuffer] -- User's output buffer, in which the
//                      data structure will be returned.
//              [OutputBufferLength] -- Size of OutputBuffer
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if no error.
//
//  Notes:      Available in DBG builds only.
//
//--------------------------------------------------------------------------


NTSTATUS
DfsFsctrlReadStruct (
    IN PIRP Irp,
    IN PFILE_DFS_READ_STRUCT_PARAM pRsParam,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength
) {
    NTSTATUS Status;

    NODE_TYPE_CODE NodeTypeCode;
    PUCHAR ReadBuffer;
    ULONG ReadLength;

    DfsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
    
    return STATUS_INVALID_PARAMETER;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\ipsup.c ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.
//
//  File:       ipsup.c
//
//  Contents:   Support routines for managing DFS_IP_INFO entries and
//               DFS_IP_PENDING_INFO entries
//
//  Functions:  DfsInitIp - Initialize the hash table for DFS_IP_INFO lookup
//              DfsLookupIpInfo - Lookup a DFS_IP_INFO
//              DfsAllocateIpInfo - Allocate a DFS_IP_INFO
//              DfsInsertIpInfo - Put a DFS_IP_INFO into the table
//              DfsDeleteIpInfo - Remove a DFS_IP_INFO from the table
//              DfsReleaseIpInfo - Stop using a DFS_IP_INFO
//
//              DfsFsctrlCreateIpInfo - Load an IpInfo table entry
//              DfsFsctrlDeleteIpInfo - Remove an IpInfo table entry
//
//  History:    16 Dec 1997     Jharper Created
//
//--------------------------------------------------------------------------

#include "dfsprocs.h"
#include "attach.h"
#include "ipsup.h"
#include "fsctrl.h"

#include "dfslpc.h"
#include "registry.h"
#include "regkeys.h"

#define Dbg     0x1000

//
// Manifest constants
//

#define IP_DEFAULT_HASH_SIZE       16        // default size of hash table
#define IP_DEFAULT_NUMBER_ENTRIES  250       // default max # of entries
#define IP_DEFAULT_TIMEOUT         (60 * 60 * 24) // default time entry can live (in sec)


NTSTATUS
DfsInitIpInfoHashTable(
    IN  ULONG cHash,
    OUT PIP_HASH_TABLE *ppHashTable
);

NTSTATUS
DfsAllocateIpInfo(
  IN    PDFS_IPADDRESS pDfsIpAddress,
  IN    PUNICODE_STRING pSiteName,
  OUT   PDFS_IP_INFO *ppIpInfo
);

VOID
DfsInsertIpInfo(
  IN    PDFS_IPADDRESS pDfsIpAddress,
  IN    PDFS_IP_INFO pIpInfo
);

VOID
DfsDeleteIpInfo(
    PDFS_IP_INFO pIpInfo
);

ULONG
DfsHashIpAddress(
    IN PDFS_IPADDRESS pDfsIpAddress,
    IN DWORD HashMask
);

PDFS_IP_INFO
DfsLookupIpInfo(
  IN    PIP_HASH_TABLE pHashTable,
  IN    PDFS_IPADDRESS pDfsIpAddress
);


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DfsInitIp)
#pragma alloc_text(PAGE, DfsUninitIp)
#pragma alloc_text(PAGE, DfsInitIpInfoHashTable)
#pragma alloc_text(PAGE, DfsAllocateIpInfo)
#pragma alloc_text(PAGE, DfsLookupIpInfo)
#pragma alloc_text(PAGE, DfsInsertIpInfo)
#pragma alloc_text(PAGE, DfsDeleteIpInfo)
#pragma alloc_text(PAGE, DfsReleaseIpInfo)
#pragma alloc_text(PAGE, DfsHashIpAddress)
#pragma alloc_text(PAGE, DfsFsctrlCreateIpInfo)
#pragma alloc_text(PAGE, DfsFsctrlDeleteIpInfo)
#endif

#ifdef DBG
VOID
DfsDumpIpTable(void);
#endif

//+-------------------------------------------------------------------------
//
//  Function:   DfsInitIpHashTable - Initialize the DFS_IP_INFO lookup hash table
//
//  Synopsis:   This function initializes data structures which are
//              used for looking up a DFS_IP_INFO associated with some IP address
//
//  Arguments:  [cHash] -- Size of the hash table to be allocated.  Must be
//                         a power of two.  If zero, a default size is used.
//
//  Returns:    NTSTATUS -- STATUS_SUCCESS, unless memory allocation
//                          fails.
//
//  Note:       The hash buckets are initialized to zero, then later
//              initialized to a list head when used.  This is a debugging
//              aid to determine if some hash buckets are never used.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsInitIpHashTable(
    ULONG cHash,
    ULONG cEntries,
    PIP_HASH_TABLE *ppHashTable)
{
    PIP_HASH_TABLE pHashTable;
    ULONG cbHashTable;
    ULONG Timeout;
    NTSTATUS status;
    PBYTE pData;

    if (cHash == 0) {
        cHash = IP_DEFAULT_HASH_SIZE;
    }

    ASSERT ((cHash & (cHash-1)) == 0);  // Assure cHash is a power of two

    if (cEntries == 0) {
        cEntries = IP_DEFAULT_NUMBER_ENTRIES;
    }

    cbHashTable = sizeof(IP_HASH_TABLE) + (cHash-1) * sizeof(LIST_ENTRY);
    pHashTable = ExAllocatePoolWithTag(NonPagedPool, cbHashTable, ' sfD');
    if (pHashTable == NULL) {
        return STATUS_NO_MEMORY;
    }
    pHashTable->NodeTypeCode = DFS_NTC_IP_HASH;
    pHashTable->NodeByteSize = (NODE_BYTE_SIZE) cbHashTable;

    pHashTable->MaxEntries = cEntries;
    pHashTable->EntryCount = 0;
    InitializeListHead(&pHashTable->LRUChain);

    pHashTable->HashMask = (cHash-1);
    ExInitializeFastMutex( &pHashTable->HashListMutex );
    RtlZeroMemory(&pHashTable->HashBuckets[0], cHash * sizeof(LIST_ENTRY));

    //
    // If there is a timeout override in the registry, get it
    //

    Timeout = IP_DEFAULT_TIMEOUT;

    status = KRegSetRoot(wszRegDfsDriver);

    if (NT_SUCCESS(status)) {

        status = KRegGetValue(
                    L"",
                    wszIpCacheTimeout,
                    (PVOID ) &pData);

        KRegCloseRoot();

        if (NT_SUCCESS(status)) {

            Timeout = *((ULONG*)pData);

            ExFreePool(pData);

        }

    }

    pHashTable->Timeout.QuadPart = UInt32x32To64(
                                       Timeout,
                                       10 * 1000 * 1000
                                       );


    *ppHashTable = pHashTable;

    return(STATUS_SUCCESS);
}

NTSTATUS
DfsInitIp(
    ULONG cHash,
    ULONG cEntries)
{
    NTSTATUS status;

    status = DfsInitIpHashTable( cHash, cEntries, &DfsData.IpHashTable );

    return status;
}

VOID
DfsUninitIp(
    VOID
    )
{
    ExFreePool (DfsData.IpHashTable);
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsLookupIpInfo - Lookup a DFS_IP_INFO in the hash table
//
//  Synopsis:   This function will lookup a DFS_IP_INFO.
//              It will increment the UseCount on the DFS_IP_INFO.
//
//  Arguments:  [pDfsIpAddress] -- Ip address being looked up.
//
//  Returns:    PVOID -- pointer to the DFS_IP_INFO found, or NULL if none
//
//--------------------------------------------------------------------------

PDFS_IP_INFO
DfsLookupIpInfo(
    PIP_HASH_TABLE pHashTable,
    PDFS_IPADDRESS pDfsIpAddress)
{
    PLIST_ENTRY pListHead, pLink;
    PDFS_IP_INFO pIpInfo;

    ExAcquireFastMutex( &pHashTable->HashListMutex);
    pListHead = &pHashTable->HashBuckets[DfsHashIpAddress(pDfsIpAddress,pHashTable->HashMask)];

    if ((pListHead->Flink == NULL) ||           // list not initialized
        (pListHead->Flink == pListHead)) {      // list empty
        ExReleaseFastMutex( &pHashTable->HashListMutex );
        return NULL;
    }

    for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
        pIpInfo = CONTAINING_RECORD(pLink, DFS_IP_INFO, HashChain);
        if (pDfsIpAddress->IpFamily == pIpInfo->IpAddress.IpFamily
                &&
            pDfsIpAddress->IpLen == pIpInfo->IpAddress.IpLen
                &&
            RtlCompareMemory(
                pDfsIpAddress->IpData,
                pIpInfo->IpAddress.IpData,
                pDfsIpAddress->IpLen) == pDfsIpAddress->IpLen
        ) {
            RemoveEntryList(&pIpInfo->LRUChain);
            InsertHeadList(&pHashTable->LRUChain, &pIpInfo->LRUChain);
            pIpInfo->UseCount++;
            ExReleaseFastMutex( &pHashTable->HashListMutex );
            return pIpInfo;
        }
    }
    ExReleaseFastMutex( &pHashTable->HashListMutex);
    return NULL;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsInsertIpInfo - Inserts a DFS_IP_INFO into the hash table
//
//  Synopsis:   This function associates a DFS_IP_INFO with an Ip address.  This
//              involves removing any existing entry, and adding the new.
//
//  Arguments:  [pDfsIpAddress] -- Pointer to the corresponding IpAddress, used
//                                 as the hash key.
//              [pIpInfo] -- Pointer to the DFS_IP_INFO to be inserted.
//
//  Returns:    -nothing-
//
//--------------------------------------------------------------------------

VOID
DfsInsertIpInfo(
    PDFS_IPADDRESS pDfsIpAddress,
    PDFS_IP_INFO pIpInfo)
{
    PIP_HASH_TABLE pHashTable = (PIP_HASH_TABLE) DfsData.IpHashTable;
    PLIST_ENTRY pListHead;
    PDFS_IP_INFO pExistingIpInfo;
    PDFS_IP_INFO pTailIpInfo;
    LARGE_INTEGER now;

    pExistingIpInfo = DfsLookupIpInfo(pHashTable, &pIpInfo->IpAddress);

    //
    // Put the new one in
    //

    ExAcquireFastMutex( &pHashTable->HashListMutex);

    pListHead = &pHashTable->HashBuckets[DfsHashIpAddress(pDfsIpAddress,pHashTable->HashMask)];

    if (pListHead->Flink == NULL) {
        InitializeListHead(pListHead);
    }
    KeQuerySystemTime(&now);
    pIpInfo->Timeout.QuadPart = now.QuadPart + pHashTable->Timeout.QuadPart;
    InsertHeadList(pListHead, &pIpInfo->HashChain);
    InsertHeadList(&pHashTable->LRUChain, &pIpInfo->LRUChain);
    pHashTable->EntryCount++;

    //
    // If adding this entry causes the number of entries to exceed the maximum,
    // then remove entries from the tail of the LRU list.
    //
    pListHead = &pHashTable->LRUChain;
    if (pHashTable->EntryCount > pHashTable->MaxEntries && pListHead->Blink != pListHead) {
        pTailIpInfo = CONTAINING_RECORD(pListHead->Blink, DFS_IP_INFO, LRUChain);
        if (pTailIpInfo != pIpInfo) {
            pTailIpInfo->Flags |= IP_INFO_DELETE_PENDING;
            RemoveEntryList(&pTailIpInfo->HashChain);
            RemoveEntryList(&pTailIpInfo->LRUChain);
            if (pTailIpInfo->UseCount == 0) {
                ExFreePool(pTailIpInfo);
            }
            pHashTable->EntryCount--;
        }
    }

    ExReleaseFastMutex( &pHashTable->HashListMutex );

    if (pExistingIpInfo != NULL) {

        DfsDeleteIpInfo(
            pExistingIpInfo);

        DfsReleaseIpInfo(
            pExistingIpInfo);

    }

    DebugTrace(0, Dbg, "Added pIpInfo %08lx ", pIpInfo);
    DebugTrace(0, Dbg, "For Site %wZ ", &pIpInfo->SiteName);

}

//+-------------------------------------------------------------------------
//
//  Function:   DfsDeleteIpInfo - Delete a DFS_IP_INFO from the lookup hash table
//
//  Synopsis:   This function Deletes a DFS_IP_INFO from the hash table.
//
//  Arguments:  [pIpInfo] -- Pointer to the DFS_IP_INFO to delete
//
//  Returns:    -nothing-
//
//--------------------------------------------------------------------------

VOID
DfsDeleteIpInfo(
    PDFS_IP_INFO pIpInfo)
{
    PIP_HASH_TABLE pHashTable = (PIP_HASH_TABLE) DfsData.IpHashTable;

    ExAcquireFastMutex( &pHashTable->HashListMutex);
    pIpInfo->Flags |= IP_INFO_DELETE_PENDING;
    RemoveEntryList(&pIpInfo->HashChain);
    RemoveEntryList(&pIpInfo->LRUChain);
    pHashTable->EntryCount--;
    ExReleaseFastMutex( &pHashTable->HashListMutex);

    DebugTrace(0, Dbg, "deleted pIpInfo %08lx ", pIpInfo);
    DebugTrace(0, Dbg, "For site %wZ ", &pIpInfo->SiteName);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsAllocateIpInfo - Allocate a DFS_IP_INFO
//
//  Synopsis:   This function allocates a contiguous DFS_IP_INFO struct.  The
//              strings are stored in the allocated buffer after the DFS_IP_INFO
//              structure.
//
//  Arguments:  [pSiteName] -- The site name
//              [pDfsIpAddress -- The Ip address of the client
//              [ppIpInfo] -- On successful return, has pointer to newly allocated
//                                  DFS_IP_INFO.
//
//  Returns:    [STATUS_SUCCESS] -- Successfully allocated DFS_IP_INFO
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory condition
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsAllocateIpInfo(
    PDFS_IPADDRESS pDfsIpAddress,
    PUNICODE_STRING pSiteName,
    PDFS_IP_INFO *ppIpInfo)
{
    NTSTATUS status;
    PDFS_IP_INFO pIpInfo;
    ULONG Size;
    ULONG i;
    LPWSTR pwCh;
    PUNICODE_STRING pustr;

    DebugTrace(0, Dbg, "DfsAllocateIpInfo(%wZ)\n", pSiteName);

    //
    // Size the buffer - include storage for the unicode string after the
    // DFS_IP_INFO structure.
    //

    Size = sizeof(DFS_IP_INFO) + pSiteName->Length;

    pIpInfo = (PDFS_IP_INFO) ExAllocatePoolWithTag( PagedPool, Size, ' sfD' );

    if (pIpInfo != NULL) {

        RtlZeroMemory( pIpInfo, Size );

        pIpInfo->NodeTypeCode = DFS_NTC_IP_INFO;
        pIpInfo->NodeByteSize = (USHORT)Size;

        pIpInfo->IpAddress = *pDfsIpAddress;

        pwCh = (LPWSTR) &pIpInfo[1];

        pustr = &pIpInfo->SiteName;
        pustr->Length = pustr->MaximumLength = pSiteName->Length;
        pustr->Buffer = pwCh;
        RtlCopyMemory(pwCh, pSiteName->Buffer, pSiteName->Length);
        pwCh += pustr->Length / sizeof(WCHAR);


        *ppIpInfo = pIpInfo;

        status = STATUS_SUCCESS;

        DebugTrace(0, Dbg, "DfsAllocateIpInfo pIpInfo = %d\n", pIpInfo);

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;

    }

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsReleaseIpInfo
//
//  Synopsis:   Decrements UseCount of and possibly frees a DFS_IP_INFO
//
//  Arguments:  [pIpInfo] -- The DFS_IP_INFO to release
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsReleaseIpInfo(
    PDFS_IP_INFO pIpInfo)
{
    PIP_HASH_TABLE pHashTable = (PIP_HASH_TABLE) DfsData.IpHashTable;

    if (pIpInfo == NULL) {

        return;

    }

    //
    // There's a potential race with DfsDeleteIpInfo/DfsInsertIpInfo w.r.t.
    // DELETE_PENDING and the test below of DELETE_PENDING, so we still have
    // to acquire the Mutex to safely test the DELETE_PENDING bit.
    //

    ExAcquireFastMutex( &pHashTable->HashListMutex);

    pIpInfo->UseCount--;

    if ((pIpInfo->Flags & IP_INFO_DELETE_PENDING) != 0 && pIpInfo->UseCount == 0) {

        ExFreePool(pIpInfo);

    }

    ExReleaseFastMutex( &pHashTable->HashListMutex);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsHashIpAddress
//
//  Synopsis:   Generates a hash 0-N
//
//  Arguments:  [pDfsIpAddress] -- Ip address to hash
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

ULONG
DfsHashIpAddress(
    PDFS_IPADDRESS pDfsAddress,
    DWORD HashMask)
{
    ULONG BucketNo = 0;
    CHAR *pBuffer = pDfsAddress->IpData;
    CHAR *pBufferEnd = &pBuffer[pDfsAddress->IpLen];
    ULONG Ch;

    BucketNo = 0;

    while (pBuffer != pBufferEnd) {
    
        Ch = *pBuffer & 0xff;
        BucketNo *= 131;
        BucketNo += Ch;
        pBuffer++;

    }

    BucketNo = BucketNo & HashMask;
    return BucketNo;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctrlCreateIpInfo, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

NTSTATUS
DfsFsctrlCreateIpInfo(
    PIRP Irp,
    PVOID InputBuffer,
    ULONG InputBufferLength)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_CREATE_IP_INFO_ARG arg;
    PDFS_IP_INFO pIpInfo;
    ULONG i;

    DebugTrace(+1, Dbg, "DfsFsctrlCreateIpInfo()\n", 0);

    STD_FSCTRL_PROLOGUE(DfsFsctrlCreateIpInfo, TRUE, FALSE);

    if (InputBufferLength < sizeof(DFS_CREATE_IP_INFO_ARG)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    //
    // unmarshal the arguments...
    //

    arg = (PDFS_CREATE_IP_INFO_ARG) InputBuffer;

    OFFSET_TO_POINTER(arg->SiteName.Buffer, arg);

    if (!UNICODESTRING_IS_VALID(arg->SiteName, InputBuffer, InputBufferLength)
            ||
        arg->IpAddress.IpLen > sizeof(arg->IpAddress.IpData)
    ) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    status = DfsAllocateIpInfo(
                &arg->IpAddress,
                &arg->SiteName,
                &pIpInfo);

    if (NT_SUCCESS(status)) {

        DfsInsertIpInfo(
            &arg->IpAddress,
            pIpInfo);

    }

exit_with_status:

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg,
        "DfsFsctrlCreateIpInfo: Exit -> %08lx\n", ULongToPtr( status ) );

    return status;

}

//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctrlDeleteIpInfo, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

NTSTATUS
DfsFsctrlDeleteIpInfo(
    PIRP Irp,
    PVOID InputBuffer,
    ULONG InputBufferLength)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_DELETE_IP_INFO_ARG arg;
    PDFS_IP_INFO pIpInfo;
    PIP_HASH_TABLE pHashTable = DfsData.IpHashTable;

    DebugTrace(+1, Dbg, "DfsFsctrlDeleteIpInfo()\n", 0);

    STD_FSCTRL_PROLOGUE(DfsFsctrlDeleteIpInfo, TRUE, FALSE);

    if (InputBufferLength < sizeof(DFS_DELETE_IP_INFO_ARG)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    //
    // unmarshal the arguments...
    //

    arg = (PDFS_DELETE_IP_INFO_ARG) InputBuffer;

    if ( arg->IpAddress.IpLen > sizeof(arg->IpAddress.IpData)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    pIpInfo = DfsLookupIpInfo(
                    pHashTable,
                    &arg->IpAddress);

    //
    // The DfsLookupIpInfo() call bumped the usecount, so we're sure pIpInfo
    // won't become invalid as we're using it.
    //

    if (pIpInfo != NULL) {

        //
        // Removes from the table, but doesn't free the memory
        //
        DfsDeleteIpInfo(
            pIpInfo);

        //
        // This will decrement the usecount, and if it goes to zero, frees the memory
        //
        DfsReleaseIpInfo(
            pIpInfo);

    }

exit_with_status:

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg,
        "DfsFsctrlDeleteIpInfo: Exit -> %08lx\n", ULongToPtr( status ) );

    return status;

}

PDFS_IP_INFO
DfsLookupSiteByIpaddress(
    PDFS_IPADDRESS pDfsIpAddress,
    BOOLEAN UseForce)
{
    PDFS_IP_INFO pIpInfo;
    LARGE_INTEGER now;
    NTSTATUS status;
    PIP_HASH_TABLE pHashTable = DfsData.IpHashTable;

    if (pDfsIpAddress == NULL) {

        return NULL;

    }

    KeQuerySystemTime(&now);

    pIpInfo = DfsLookupIpInfo(pHashTable, pDfsIpAddress);

    if (pIpInfo == NULL || now.QuadPart > pIpInfo->Timeout.QuadPart) {

        //
        // Entry is not in cache, or is old
        //

        if (pIpInfo != NULL) {

            // Old entry - try for a new one

            if (UseForce == TRUE) {

                ExAcquireFastMutex( &pHashTable->HashListMutex);
                pIpInfo->Timeout.QuadPart = now.QuadPart + UInt32x32To64(
                                                                   10 * 60,
                                                                   10 * 1000 * 1000);
                ExReleaseFastMutex( &pHashTable->HashListMutex);
                DfsLpcIpRequest(pDfsIpAddress);
                pIpInfo = DfsLookupIpInfo(pHashTable, pDfsIpAddress);

            }

        } else {

            if (UseForce == TRUE) {

                DfsLpcIpRequest(pDfsIpAddress);
                pIpInfo = DfsLookupIpInfo(pHashTable, pDfsIpAddress);

            }

        }

    }

    return pIpInfo;

}

#ifdef DBG

VOID
DfsDumpIpTable(void)
{
    PLIST_ENTRY pListHead, pLink;
    PDFS_IP_INFO pIpInfo;
    PIP_HASH_TABLE pHashTable = DfsData.IpHashTable;
    ULONG i, j;

    DbgPrint("%d entries total\n", pHashTable->EntryCount);

    for (i = 0; i <= pHashTable->HashMask; i++) {

        pListHead = &pHashTable->HashBuckets[i];

        if ((pListHead->Flink == NULL) ||           // list not initialized
            (pListHead->Flink == pListHead)) {      // list empty
            continue;
        }
        for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
            pIpInfo = CONTAINING_RECORD(pLink, DFS_IP_INFO, HashChain);
            DbgPrint("B:%02d Ip:0x%x N:%wZ C=%d\n",
                        i,
                        *((ULONG *)&pIpInfo->IpAddress.IpData),
                        &pIpInfo->SiteName,
                        pIpInfo->UseCount);
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\fsctrl.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       dsfsctl.h
//
//  Contents:   This module contains the definitions of internally used file
//              system controls for the Dfs file system.  It also contains
//              definitions of macros used in the implementation of Fsctrls.
//
//              Public control code and structure declarations are in the
//              private header file dfsfsctl.h.
//
//  Classes:
//
//  Functions:
//
//--------------------------------------------------------------------------



#ifndef _DFS_FSCTRL_
#define _DFS_FSCTRL_


#ifndef IOCTL_DFS_BASE
# include <dfsfsctl.h>
#endif  //IOCTL_DFS_BASE

//+----------------------------------------------------------------------------
//
//  Macro:      IS_DFS_CTL_CODE
//
//  Synopsis:   Determines whether a fsctrl code is a Dfs fsctrl code.
//
//  Arguments:  [c] -- The control code to test
//
//  Returns:    TRUE if c is a Dfs fsctrl code, FALSE if its not.
//
//-----------------------------------------------------------------------------

#define IS_DFS_CTL_CODE(c)                                              \
    (((c) & CTL_CODE(0xFF, 0,0,0)) == CTL_CODE(FSCTL_DFS_BASE, 0,0,0))

//+----------------------------------------------------------------------------
//
//  Macro:      UNICODESTRING_IS_VALID
//
//  Synopsis:   Determines whether a passed-in UNICODE_STRING is good
//
//  Returns:    TRUE if is good, FALSE if not
//
//-----------------------------------------------------------------------------

#define UNICODESTRING_IS_VALID(ustr,start,len)                              \
    (                                                                       \
    ((ustr).Length <= (len)) &&                                             \
    ((PCHAR)(ustr).Buffer >= (PCHAR)(start)) &&                             \
    ((PCHAR)(ustr).Buffer <= (PCHAR)(start) + ((len) - (ustr).Length))      \
    )

//+----------------------------------------------------------------------------
//
//  Macro:      POINTER_IN_BUFFER
//
//  Synopsis:   Determines whether a pointer lies within a buffer
//
//  Returns:    TRUE if is good, FALSE if not
//
//-----------------------------------------------------------------------------

#define POINTER_IN_BUFFER(ptr,size,buf,len)                           \
  (((PCHAR)(ptr) >= (PCHAR)(buf)) && (((PCHAR)(ptr) + (size)) <= ((PCHAR)(buf) + len)))

//+----------------------------------------------------------------------------
//
//  Macro:      OFFSET_TO_POINTER
//
//  Synopsis:   Certain fsctls (mainly those issued by the srvsvc) communicate
//              via buffers that contain "pointers" which are really offsets
//              from the beginning of the buffer. This macro fixes up the
//              offsets to real pointers
//
//  Arguments:  [field] -- The field to fix up.
//              [buffer] -- The beginning of the buffer.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

#define OFFSET_TO_POINTER(field, buffer)  \
    ( ((PCHAR)field) += ((ULONG_PTR)buffer) )

//+----------------------------------------------------------------------------
//
//  Macro:      POINTER_IS_VALID
//
//  Synopsis:   Determine whether a pointer is within a certain range.
//
//  Arguments:  [val] -- The pointer to check
//              [start] -- The start of the buffer
//              [len] -- The length of the buffer
//
//  Returns:    TRUE if is good, FALSE if not
//
//-----------------------------------------------------------------------------

#define POINTER_IS_VALID(val,start,len)                      \
      ( (PCHAR)(val) > (PCHAR)(start) &&                     \
          (PCHAR)(val) < ((PCHAR)(start) + (len)) )

//+----------------------------------------------------------------------------
//
//  Macro:      ALIGNMENT_IS_VALID
//
//  Synopsis:   Determine whether a pointer is aligned correctly
//
//  Arguments:  [val] -- The pointer to check
//              [type] -- The type of object to pointer can point to
//
//  Returns:    TRUE if is good, FALSE if not
//
//-----------------------------------------------------------------------------

#define ALIGNMENT_IS_VALID(val, type)                        \
    ( ((ULONG_PTR)(val) & (sizeof(type)-1)) == 0 )


//+----------------------------------------------------------------------------
//
//  Function:   DFS_DUPLICATE_STRING
//
//  Synopsis:   Macro to create a UNICODE_STRING from an LPWSTR. The buffer
//              for the UNICODE_STRING is allocated using ExAllocatePoolWithTag.
//
//              Useful for duplicating strings received in fsctls from the
//              server.
//
//  Arguments:  [ustr] -- Destination UNICODE_STRING
//              [pwsz] -- Source LPWSTR
//              [status] -- If pool allocation fails, or the string would be too
//                      large, this will be set to STATUS_INSUFFICIENT_RESOURCES
//
//  Returns:    Nothing. Check the status parameter to see if the operation
//              succeeded.
//
//-----------------------------------------------------------------------------

#define DFS_DUPLICATE_STRING(ustr,pwsz,status)                           \
{                                                                        \
    ULONG Len = wcslen(pwsz) * sizeof(WCHAR);                            \
                                                                         \
    if ((Len + sizeof(WCHAR)) <= MAXUSHORT) {                            \
        ustr.Length = (USHORT)Len;                                       \
        ustr.MaximumLength = ustr.Length + sizeof(WCHAR);                \
        ustr.Buffer = ExAllocatePoolWithTag(PagedPool, ustr.MaximumLength,' sfD');    \
        if (ustr.Buffer != NULL) {                                       \
            RtlCopyMemory( ustr.Buffer, pwsz, ustr.MaximumLength );      \
            status = STATUS_SUCCESS;                                     \
        } else {                                                         \
            status = STATUS_INSUFFICIENT_RESOURCES;                      \
        }                                                                \
    } else {                                                             \
        status = STATUS_INSUFFICIENT_RESOURCES;                          \
    }                                                                    \
}

//+---------------------------------------------------------------------------
//
// Macro:       STD_FSCTRL_PROLOGUE, public
//
// Synopsis:    Do the standard stuff associated with any fsctrl implementation
//              which needs to run in the FSP.  This assumes a standard set
//              of parameters for the calling function, as below:
//
//                      DfsMyownFsctrl(
//                              IN PIRP Irp,
//                      [maybe] IN PVOID InputBuffer,
//                              IN ULONG InputBufferLength,
//                      [maybe] IN PVOID OutputBuffer,
//                              IN ULONG OutputBufferLength
//                      );
//
// Arguments:   [szName] -- Name of the function for debug trace messages
//              [fExpInp] -- TRUE if it takes an input buffer
//              [fExpOutp] -- TRUE if it takes an output buffer
//
// Returns:     None
//
//  Notes:      The macros CHECK_BUFFER_TRUE and CHECK_BUFFER_FALSE are
//              necessary for the generation of STD_FSCTRL_PROLOGUE and
//              are not intended to be used directly.
//
//
//----------------------------------------------------------------------------

#define CHK_BUFFER_FALSE(szName, inout) ;
#define CHK_BUFFER_TRUE(szName, inout)                          \
    if (!ARGUMENT_PRESENT(inout##Buffer) || (inout##BufferLength == 0)) {\
        DebugTrace(0, Dbg, #szName ": Bad buffer\n", 0);                \
        DfsCompleteRequest( Irp, STATUS_INVALID_PARAMETER );            \
        return STATUS_INVALID_PARAMETER;                                \
    }

#define STD_FSCTRL_PROLOGUE(szName, fExpInp, fExpOutp) {                \
    ASSERT((ARGUMENT_PRESENT(Irp)));                                    \
    CHK_BUFFER_##fExpInp(szName, Input)                                 \
    CHK_BUFFER_##fExpOutp(szName, Output)                               \
    DebugTrace(+1, Dbg, #szName ": Entered\n", 0);                      \
}


//+---------------------------------------------------------------------------
//
//  Macro:      RETURN_BUFFER_SIZE, public
//
//  Synopsis:   Return conventional errors when the output of an fsctrl
//              function is larger than the user buffer. This assumes a
//              standard set of parameters for the calling function, as
//              below:
//
//                      DfsMyownFsctrl(
//                              IN PIRP Irp,
//                      [maybe] IN PVOID InputBuffer,
//                      [maybe] IN ULONG InputBufferLength,
//                              IN PVOID OutputBuffer,
//                              IN ULONG OutputBufferLength
//                      );
//
//  Arguments:  [x] -- The required size of the output buffer
//              [Status] -- The status to be returned from the fsctrl.
//
//  Returns:    Sets Status to STATUS_BUFFER_TOO_SMALL or
//              STATUS_BUFFER_OVERFLOW.  The convention we use is that if
//              the OutputBuffer is at least sizeof(ULONG) big, then we stuff
//              the needed size in OutputBuffer and return
//              STATUS_BUFFER_OVERFLOW, which is a warning code.  If the
//              OutputBuffer isn't big enough for that, we return
//              STATUS_BUFFER_TOO_SMALL.
//
//  Notes:      Requires that the function declare "OutputBufferLength",
//              "OutputBuffer", and "Irp". Irp->IoStatus.Information will
//              be set to the return size.
//
//----------------------------------------------------------------------------

#define RETURN_BUFFER_SIZE(x, Status)                                   \
    if ((OutputBufferLength) < sizeof(ULONG)) {                         \
        Status = STATUS_BUFFER_TOO_SMALL;                               \
    } else {                                                            \
        Status = STATUS_BUFFER_OVERFLOW;                                \
        *((PULONG) OutputBuffer) = x;                                   \
        Irp->IoStatus.Information = sizeof(ULONG);                      \
    }


//
//  Internal Distributed file system control operations.
//

#define FSCTL_DFS_DBG_BREAK             CTL_CODE(FSCTL_DFS_BASE, 2045, METHOD_BUFFERED, FILE_WRITE_DATA)

#define FSCTL_DFS_DBG_FLAGS             CTL_CODE(FSCTL_DFS_BASE, 2046, METHOD_BUFFERED, FILE_WRITE_DATA)

#define FSCTL_DFS_INTERNAL_READ_MEM     CTL_CODE(FSCTL_DFS_BASE, 2047, METHOD_BUFFERED, FILE_READ_DATA)

#define FSCTL_DFS_SET_PKT_ENTRY_TIMEOUT CTL_CODE(FSCTL_DFS_BASE, 2048, METHOD_BUFFERED, FILE_READ_DATA)

#define FSCTL_DFS_INTERNAL_READSTRUCT   CTL_CODE(FSCTL_DFS_BASE, 2049, METHOD_BUFFERED, FILE_READ_DATA)

//
//  Control structure for FSCTL_DFS_INTERNAL_READSTRUCT (input)
//

typedef struct _FILE_DFS_READ_STRUCT_PARAM {
    ULONG_PTR   StructKey;      // key (ptr) to desired structure
    CSHORT      TypeCode;       // expected type code (or 0)
    CSHORT      ByteCount;      // expected size
} FILE_DFS_READ_STRUCT_PARAM, *PFILE_DFS_READ_STRUCT_PARAM;

//
//  Control structure for FSCTL_DFS_INTERNAL_READ_MEM (input)
//

typedef struct _FILE_DFS_READ_MEM {
    ULONG_PTR Address;
    ULONG Length;
} FILE_DFS_READ_MEM, *PFILE_DFS_READ_MEM;

BOOLEAN
DfspStringInBuffer(LPWSTR pwszString, PVOID Buffer, ULONG BufferLen);

#endif // _DFS_FSCTRL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\know.c ===
//+------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       Know.C
//
//  Contents:   This file has all the code that involves with knowledge
//              synchronisation on the DC.
//
//  Synoposis:  This code handles the fixing of knowledge inconsistencies.
//              All this code runs only on the DC in response to FSCTRLs from
//              a client etc.
//
//  Functions:  DfsModifyRemotePrefix -
//              DfsCreateRemoteExitPoint -
//              DfsDeleteRemoteExitPoint -
//              DfsTriggerKnowledgeVerification -
//              DfsFsctrlVerifyLocalVolumeKnowledge -
//              DfsFsctrlGetKnowledgeSyncParameters -
//              DfsFsctrlFixLocalVolumeKnowledge -
//
//  History:    22-March-1993   SudK    Created
//              18-June-1992    SudK    Added FixLocalVolumeKnowledge
//
//-------------------------------------------------------------------

#include "dfsprocs.h"
#include <netevent.h>
#include "fsctrl.h"
#include "registry.h"
#include "know.h"
#include "log.h"
#include "localvol.h"
#include "dfswml.h"

#define Dbg     (DEBUG_TRACE_LOCALVOL)


//
//  local function prototypes
//

BOOLEAN
DfsFileExists(
    UNICODE_STRING      DirPath
);

BOOLEAN
DfsFileCreate(
    UNICODE_STRING      DirPath
);

BOOLEAN
DfsFixExitPath(
    PWSTR       ExitPath
);

DfspFixExitPoints(
    PDFS_FIX_LOCAL_VOLUME_ARG   arg
);


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsModifyRemotePrefix )
#pragma alloc_text( PAGE, DfsCreateRemoteExitPoint )
#pragma alloc_text( PAGE, DfsDeleteRemoteExitPoint )
#pragma alloc_text( PAGE, DfsFileExists )
#pragma alloc_text( PAGE, DfsFileCreate )
#pragma alloc_text( PAGE, DfsStorageIdExists )
#pragma alloc_text( PAGE, DfsFixExitPath )
#pragma alloc_text( PAGE, DfspFixExitPoints )
#pragma alloc_text( PAGE, DfsFsctrlFixLocalVolumeKnowledge )
#endif // ALLOC_PRAGMA


//+------------------------------------------------------------------
//
//  Function:   DfsModifyRemotePrefix
//
//  Synopsis:   This function creates an ExitPoint knowledge at a remote client.
//              Serves as a wrapper and merely makes an FSCTRL to the remote
//              Client.
//
//  Arguments:  [ExitPtId] -- The exit Point ID that needs to be sent across.
//              [remoteHandle] -- The Handle to be used for FSCTRLs.
//
//  Returns:
//
//  History:    22-March-1992   SudK    Created
//
//  Notes:
//
//-------------------------------------------------------------------
NTSTATUS
DfsModifyRemotePrefix(DFS_PKT_ENTRY_ID ExitPtId, HANDLE remoteHandle)
{

    ULONG               size;
    PVOID               buffer = NULL;
    IO_STATUS_BLOCK     ioStatusBlock;
    MARSHAL_BUFFER      marshalBuffer;
    NTSTATUS            status;

    DebugTrace(0, Dbg, "DfsModifyRemotePrefix: %ws\n", ExitPtId.Prefix.Buffer);

    size = 0L;
    status = DfsRtlSize(&MiPktEntryId, &ExitPtId, &size);
    if (NT_SUCCESS(status)) {

        buffer = ExAllocatePoolWithTag(PagedPool, size, ' sfD');
        if (buffer != NULL)     {
            MarshalBufferInitialize(&marshalBuffer, size, buffer);

            status = DfsRtlPut(
                        &marshalBuffer,
                        &MiPktEntryId,
                        &ExitPtId
                        );
        } else {
            status = STATUS_NO_MEMORY;
        }
    }

    if (NT_SUCCESS(status))     {
        status = ZwFsControlFile(
                    remoteHandle,
                    NULL,
                    NULL,
                    NULL,
                    &ioStatusBlock,
                    FSCTL_DFS_MODIFY_PREFIX,
                    buffer,
                    size,
                    NULL,
                    0
                );

    }

    if (NT_SUCCESS(status))
        status = ioStatusBlock.Status;

    if (buffer != NULL)
        ExFreePool(buffer);

    return(status);

}



//+------------------------------------------------------------------
//
//  Function:   DfsCreateRemoteExitPoint
//
//  Synopsis:   This function creates an ExitPoint knowledge at a remote client.
//              Serves as a wrapper and merely makes an FSCTRL to the remote
//              Client.
//
//  Arguments:  [ExitPtId] -- The exit Point ID that needs to be sent across.
//              [remoteHandle] -- The Handle to be used for FSCTRLs.
//
//  Returns:
//
//  History:    22-March-1992   SudK    Created
//
//  Notes:
//
//-------------------------------------------------------------------
NTSTATUS
DfsCreateRemoteExitPoint(DFS_PKT_ENTRY_ID ExitPtId, HANDLE remoteHandle)
{

    ULONG               size;
    PVOID               buffer = NULL;
    IO_STATUS_BLOCK     ioStatusBlock;
    MARSHAL_BUFFER      marshalBuffer;
    NTSTATUS            status;

    DebugTrace(0, Dbg, "DfsCreateRemoteExitPt: %ws\n", ExitPtId.Prefix.Buffer);

    DFS_TRACE_LOW(PROVIDER, DfsCreateRemoteExitPt_Entry, 
                  LOGGUID(ExitPtId.Uid)
                  LOGUSTR(ExitPtId.Prefix)
                  LOGUSTR(ExitPtId.ShortPrefix)
                  LOGHANDLE(remoteHandle));

    size = 0L;
    status = DfsRtlSize(&MiPktEntryId, &ExitPtId, &size);
    if (NT_SUCCESS(status)) {

        buffer = ExAllocatePoolWithTag(PagedPool, size, ' sfD');
        if (buffer != NULL)     {
            MarshalBufferInitialize(&marshalBuffer, size, buffer);

            status = DfsRtlPut(
                        &marshalBuffer,
                        &MiPktEntryId,
                        &ExitPtId
                        );
        } else {
            status = STATUS_NO_MEMORY;
        }
    }

    if (NT_SUCCESS(status))     {
        status = ZwFsControlFile(
                    remoteHandle,
                    NULL,
                    NULL,
                    NULL,
                    &ioStatusBlock,
                    FSCTL_DFS_CREATE_EXIT_POINT,
                    buffer,
                    size,
                    NULL,
                    0
                );
        DFS_TRACE_ERROR_HIGH(status, ALL_ERROR, DfsCreateRemoteExitPt_Error_ZwFsControlFile,
                             LOGSTATUS(status)
                             LOGGUID(ExitPtId.Uid)
                             LOGUSTR(ExitPtId.Prefix)
                             LOGUSTR(ExitPtId.ShortPrefix)); 
    }

    if (NT_SUCCESS(status))
        status = ioStatusBlock.Status;

    if (buffer != NULL)
        ExFreePool(buffer);

    DFS_TRACE_LOW(PROVIDER, DfsCreateRemoteExitPt_Exit, LOGSTATUS(status)
                  LOGGUID(ExitPtId.Uid)
                  LOGUSTR(ExitPtId.Prefix)
                  LOGUSTR(ExitPtId.ShortPrefix));

    return(status);

}



//+------------------------------------------------------------------
//
//  Function:   DfsDeleteRemoteExitPoint
//
//  Synopsis:   This function deletes a remote exitpoint knowledeg by making
//              an FSCTRL to the remote client.
//
//  Arguments:  [ExitPtId] -- The exit Point ID that needs to be sent across.
//              [remoteHandle] -- The Handle to be used for FSCTRLs.
//
//  Returns:
//
//  History:    22-March-1992   SudK    Created
//
//  Notes:
//
//-------------------------------------------------------------------
NTSTATUS
DfsDeleteRemoteExitPoint(
    IN  DFS_PKT_ENTRY_ID ExitPtId,
    IN  HANDLE remoteHandle
) {
    ULONG               size;
    PVOID               buffer = NULL;
    IO_STATUS_BLOCK     ioStatusBlock;
    MARSHAL_BUFFER      marshalBuffer;
    NTSTATUS            status;

    DebugTrace(0, Dbg, "DeleteRemoteExitPt: %ws\n", ExitPtId.Prefix.Buffer);

    size = 0L;
    status = DfsRtlSize(&MiPktEntryId, &ExitPtId, &size);

    if (NT_SUCCESS(status)) {
        buffer = ExAllocatePoolWithTag(PagedPool, size, ' sfD');
        if (buffer != NULL)     {
            MarshalBufferInitialize(&marshalBuffer, size, buffer);

            status = DfsRtlPut(&marshalBuffer, &MiPktEntryId, &ExitPtId);
        } else {
            status = STATUS_NO_MEMORY;
        }
    }

    if (NT_SUCCESS(status))     {
        status = ZwFsControlFile(remoteHandle,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &ioStatusBlock,
                                 FSCTL_DFS_DELETE_EXIT_POINT,
                                 buffer,
                                 size,
                                 NULL,
                                 0);

    }

    if (NT_SUCCESS(status))
        status = ioStatusBlock.Status;

    if (buffer != NULL)
        ExFreePool(buffer);

    return(status);

}


//+-------------------------------------------------------------------------
//
// Function:    DfsFileExists
//
// Synopsis:    This function verifies the existence of a given directory.
//              It does not create it if it does not exist.
//
// Arguments:   [DirPath] -- The StorageId in the form of UnicodeString.
//
// Returns:     TRUE - If directory exists else FALSE.
//
// History:     15 Jun 1993     SudK    Created
//
//--------------------------------------------------------------------------
BOOLEAN
DfsFileExists(
    UNICODE_STRING      DirPath
)
{
    HANDLE              DirHandle;
    OBJECT_ATTRIBUTES   objectAttributes;
    IO_STATUS_BLOCK     ioStatus;
    NTSTATUS            status;
    BOOLEAN             fPreviousErrorMode;

    InitializeObjectAttributes(
                                &objectAttributes,
                                &DirPath,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    status = ZwCreateFile(
                        &DirHandle,
                        FILE_LIST_DIRECTORY | FILE_READ_ATTRIBUTES,
                        &objectAttributes,
                        &ioStatus,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_OPEN,
                        FILE_DIRECTORY_FILE,
                        NULL,
                        0
             );

    if (NT_SUCCESS(status))     {
        status = ioStatus.Status;
        ZwClose(DirHandle);
    }

    if (NT_SUCCESS(status))
        return(TRUE);
    else if (status == STATUS_NO_MEDIA_IN_DEVICE)
        return(TRUE);
    else
        return(FALSE);

}


//+-------------------------------------------------------------------------
//
// Function:    DfsFileCreate
//
// Synopsis:    This function verifies the existence of a given directory.
//              If it does not exist then it creates it.
//
// Arguments:   [DirPath] -- The StorageId in the form of UnicodeString.
//
// Returns:     TRUE - If it created and all is fine else FALSE.
//
// History:     15 Jun 1993     SudK    Created
//
//--------------------------------------------------------------------------
BOOLEAN
DfsFileCreate(
    UNICODE_STRING      DirPath
)
{
    HANDLE              DirHandle;
    OBJECT_ATTRIBUTES   objectAttributes;
    IO_STATUS_BLOCK     ioStatus;
    NTSTATUS            status;

    InitializeObjectAttributes(
                                &objectAttributes,
                                &DirPath,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    status = ZwCreateFile(
                        &DirHandle,
                        FILE_LIST_DIRECTORY | FILE_READ_ATTRIBUTES,
                        &objectAttributes,
                        &ioStatus,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_OPEN_IF,
                        FILE_DIRECTORY_FILE,
                        NULL,
                        0
             );

    if (NT_SUCCESS(status))     {
        status = ioStatus.Status;
        ZwClose(DirHandle);
    }

    if (!NT_SUCCESS(status))
        return(FALSE);
    else
        return(TRUE);


}



//+-------------------------------------------------------------------------
//
// Function:    DfsStorageIdExists
//
// Synopsis:    This function makes sure that a given storageId exists and if
//              it does not then it attempts to create the storageId if req.
//
// Arguments:   [StorageId] --  The storage id to test in the form of an
//                      NT Path name (eg, \??\C:\foo )
//              [bCreate] --    If this is TRUE, then the function will attempt
//                      to create the stg else it will check for existence.
//
// Returns:     TRUE - If it created and all is fine else FALSE.
//
// History:     15 Jun 1993     SudK    Created
//
//--------------------------------------------------------------------------
BOOLEAN
DfsStorageIdExists(
    UNICODE_STRING      StgPath,
    BOOLEAN             bCreate
)
{
    PWCHAR              pwch = NULL;
    UNICODE_STRING      StorageId;
    BOOLEAN             StgIdCreated = FALSE;

    StorageId = StgPath;
    StorageId.Buffer = ExAllocatePoolWithTag(
                            PagedPool,
                            StorageId.MaximumLength + sizeof(WCHAR),
                            ' sfD');
    
    if (StorageId.Buffer == NULL) {
        return FALSE;
    }

    wcsncpy(StorageId.Buffer, StgPath.Buffer, StgPath.Length/sizeof(WCHAR));
    StorageId.Buffer[StgPath.Length/sizeof(WCHAR)] = UNICODE_NULL;

    ASSERT(StorageId.Length >= wcslen(L"\\??\\C:")*sizeof(WCHAR));
    //
    // If the storage Id refers only to a root drive the trailing backslash
    // may not exist and we need to put it in there to open the right thing.
    //
    if (StorageId.Length < wcslen(L"\\??\\C:\\")*sizeof(WCHAR)) {
        StorageId.Buffer[StorageId.Length/sizeof(WCHAR)] = L'\\';
        StorageId.Buffer[StorageId.Length/sizeof(WCHAR) + 1] = UNICODE_NULL;
    }
    //
    // First verify that the Drive does exist and then we will go into the
    // next stage.
    //
    StorageId.Length = sizeof(L"\\??\\c:\\") - sizeof(UNICODE_NULL);

    if (!DfsFileExists(StorageId))      {
        ExFreePool(StorageId.Buffer);
        return(FALSE);
    }

    //
    // If all that we have is a drive letter then we are done with this step.
    //
    if (wcslen(StorageId.Buffer) <= wcslen(L"\\??\\C:\\"))      {
        ExFreePool(StorageId.Buffer);
        return(TRUE);
    }

    //
    // Now that the drive does exist we can check for each of the directories
    // and create them as we go along.
    //
    pwch = StorageId.Buffer + StorageId.Length/sizeof(WCHAR);

    while (pwch != NULL)        {
        ASSERT(pwch < StorageId.Buffer + StorageId.MaximumLength/sizeof(WCHAR));
        pwch = wcschr(pwch, L'\\');
        if (pwch != NULL)       {
            StorageId.Length = (wcslen(StorageId.Buffer) - wcslen(pwch))*
                                                        sizeof(WCHAR);
            if (bCreate)        {
                if (!DfsFileCreate(StorageId))
                        break;
            }
            else        {
                if (!DfsFileExists(StorageId))
                        break;
            }
            pwch++;     //Skip the last L'\'
        }
        else    {
            StorageId.Length = wcslen(StorageId.Buffer)*sizeof(WCHAR);
            if (bCreate)        {
                if (DfsFileCreate(StorageId))
                        StgIdCreated = TRUE;
            }
            else        {
                if (DfsFileExists(StorageId))
                        StgIdCreated = TRUE;
            }
        }
    }

    //
    // If we came out without the pwch != NULL then it means we were unable
    // to create one of the directories along the way due to some wierd
    // reason. We return a FALSE from this function else a SUCCESS.
    //
    ExFreePool(StorageId.Buffer);
    if (StgIdCreated)
        return(TRUE);
    else
        return(FALSE);

    return(TRUE);
}



//+-------------------------------------------------------------------------
//
// Function:    DfsFixExitPath
//
// Synopsis:    This function makes sure
//
//
//
//--------------------------------------------------------------------------
BOOLEAN
DfsFixExitPath(
    PWSTR       ExitPath
)
{

    UNICODE_STRING      ustrExitPath;
    PWCHAR              pwcLastComponent;
    OBJECT_ATTRIBUTES   objectAttributes;
    HANDLE              exitPtHandle;
    IO_STATUS_BLOCK     ioStatus;
    NTSTATUS            status;

    pwcLastComponent = wcsrchr(ExitPath, L'\\');
    if (pwcLastComponent == NULL)       {
        //
        // This should not happen.
        //
        DebugTrace(0, 1, "DfsFixExitPath: Bad Exitpath %ws given here\n",
                        ExitPath);
        return(FALSE);

    }
    //
    // Now let us verify that everything except for exit pt exists.
    //
    ustrExitPath.Length = (USHORT)(pwcLastComponent - ExitPath);
    ustrExitPath.MaximumLength = ustrExitPath.Length + sizeof(WCHAR);
    ustrExitPath.Buffer = ExitPath;

    if (!DfsStorageIdExists(ustrExitPath, TRUE))      {
        DebugTrace(0, Dbg, "DfsFixExitPath:Fail createstg %wZ\n",&ustrExitPath);
        return(FALSE);
    }

    //
    // Now let us just create the exit pt.
    //
    ustrExitPath.Length = wcslen(ExitPath) * sizeof(WCHAR);
    ustrExitPath.MaximumLength = ustrExitPath.Length + sizeof(WCHAR);

    InitializeObjectAttributes(
                                &objectAttributes,
                                &ustrExitPath,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    status = ZwCreateFile(
                        &exitPtHandle,
                        DELETE | FILE_READ_ATTRIBUTES,
                        &objectAttributes,
                        &ioStatus,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_OPEN_IF,
                        FILE_DIRECTORY_FILE |
                        FILE_SYNCHRONOUS_IO_NONALERT,
                        NULL,
                        0
             );

    if (NT_SUCCESS(status)) {
        ZwClose( exitPtHandle );
        status = ioStatus.Status;
    }

    if (status == STATUS_FILE_IS_A_DIRECTORY) {
        status = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(status))
        status = DFS_STATUS_BAD_EXIT_POINT;

    if (NT_SUCCESS(status))     {
        return(TRUE);
    }
    else        {
        DebugTrace(0, Dbg, "DfsFixExtPath: Fail create extpath %08lx\n", ULongToPtr( status ));
        DebugTrace(0, Dbg, "DfsFixExtPath: %wZ\n", &ustrExitPath);
        return(FALSE);
    }
}




//+-------------------------------------------------------------------------
//
// Function:    DfspFixExitPoints
//
// Synopsis:    This function ensures that the exit points for a volume are
//              all in place and if not it attempts to create them.
//
// Arguments:   [arg] -- Pointer to DFS_FIX_LOCAL_VOLUME_ARG.
//
// Returns:     STATUS_SUCCESS -- If all went well.
//
// History:     15 Jun 1993     SudK    Created
//
//--------------------------------------------------------------------------
DfspFixExitPoints(
    PDFS_FIX_LOCAL_VOLUME_ARG      arg
)
{
    NTSTATUS                    status = STATUS_SUCCESS;
    LPNET_DFS_ENTRY_ID_CONTAINER pRelInfo;
    ULONG                       i, len, volLen, exitPointLen;
    WCHAR                       wszExitPath[MAX_PATH];
    PWSTR                       pwszExitPath;
    PWCHAR                      pwch;

    pRelInfo = arg->RelationInfo;

    len = wcslen(arg->EntryPrefix);

    volLen = wcslen(arg->VolumeName);

    for (i=0; i < pRelInfo->Count && NT_SUCCESS(status); i++)    {

        exitPointLen = wcslen( pRelInfo->Buffer[i].Prefix );

        if (volLen + exitPointLen < MAX_PATH) {
            pwszExitPath = wszExitPath;
        } else {
            pwszExitPath = ExAllocatePoolWithTag(
                                PagedPool,
                                (volLen + exitPointLen + 1) * sizeof(WCHAR),
                                ' sfD');
        }

        if (pwszExitPath != NULL) {

            wcscpy(pwszExitPath, arg->VolumeName);

            //
            // Now we need to get the last part of the exit path so that
            // we can concatenate to above to get local path to create.
            //

            pwch = pRelInfo->Buffer[i].Prefix + len;

            wcscat(pwszExitPath, pwch);

            //
            // Now we have the local path to create. Call off to appropriate func
            //

            if (!DfsFixExitPath(pwszExitPath))   {
                DebugTrace(0, Dbg, "Unable to forcibly Create %ws exitpath",
                            pwszExitPath);
            }

            if (pwszExitPath != wszExitPath) {
                ExFreePool(pwszExitPath);
            }

        } else {

            status = STATUS_INSUFFICIENT_RESOURCES;

        }

    }

    return(status);

}




//+-------------------------------------------------------------------------
//
// Function:    DfsFsctrlFixLocalVolumeKnowledge
//
// Synopsis:    This function gets called on a server by the DC when the
//              DC discovers a knowledge inconsistency where the server is
//              entirely unaware of a particular volume.
//
// Arguments:
//
// Returns:
//
// History:     15 Jun 1993     SudK    Created.
//
//--------------------------------------------------------------------------
NTSTATUS
DfsFsctrlFixLocalVolumeKnowledge(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{

    NTSTATUS                            status = STATUS_SUCCESS;
    MARSHAL_BUFFER                      marshalBuffer;
    PDFS_FIX_LOCAL_VOLUME_ARG           arg;
    PDFS_LOCAL_VOLUME_CONFIG            configInfo;
    ULONG                               i;
    PDFS_PKT                            pkt = _GetPkt();
    UNICODE_STRING                      volume, path, remainingPath;
    PDFS_PKT_ENTRY                      Entry;

    STD_FSCTRL_PROLOGUE(DfsFsctrlFixLocalVolumeKnowledge, TRUE, FALSE);

    if (InputBufferLength < sizeof(*arg)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    //
    // unmarshal the arguments...
    //

    arg = (PDFS_FIX_LOCAL_VOLUME_ARG) InputBuffer;

    OFFSET_TO_POINTER( arg->VolumeName, arg );
    OFFSET_TO_POINTER( arg->StgId, arg );
    OFFSET_TO_POINTER( arg->EntryPrefix, arg );
    OFFSET_TO_POINTER( arg->ShortPrefix, arg );
    OFFSET_TO_POINTER( arg->RelationInfo, arg );

    if (
        !DfspStringInBuffer(arg->VolumeName, InputBuffer, InputBufferLength) ||
        !DfspStringInBuffer(arg->StgId, InputBuffer, InputBufferLength) ||
        !DfspStringInBuffer(arg->EntryPrefix, InputBuffer, InputBufferLength) ||
        !DfspStringInBuffer(arg->ShortPrefix, InputBuffer, InputBufferLength) ||
        !POINTER_IS_VALID(arg->RelationInfo, InputBuffer, InputBufferLength)
    ) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    if (!POINTER_IN_BUFFER(
            &arg->RelationInfo->Buffer,
            sizeof(arg->RelationInfo->Buffer),
            InputBuffer,
            InputBufferLength)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    OFFSET_TO_POINTER( arg->RelationInfo->Buffer, arg );

    if (!POINTER_IS_VALID(arg->RelationInfo->Buffer, InputBuffer, InputBufferLength)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    for (i = 0; i < arg->RelationInfo->Count; i++) {

        if (!POINTER_IN_BUFFER(
                &arg->RelationInfo->Buffer[i].Prefix,
                sizeof(arg->RelationInfo->Buffer[i].Prefix),
                InputBuffer,
                InputBufferLength)) {
            status = STATUS_INVALID_PARAMETER;
            goto exit_with_status;
        }

        OFFSET_TO_POINTER( arg->RelationInfo->Buffer[i].Prefix, arg );

        if (!DfspStringInBuffer(
                arg->RelationInfo->Buffer[i].Prefix,
                InputBuffer,
                InputBufferLength)) {
            status = STATUS_INVALID_PARAMETER;
            goto exit_with_status;
        }

    }

    RtlInitUnicodeString( &volume, arg->VolumeName );

    configInfo = DfsNetInfoToConfigInfo(
                    arg->EntryType,
                    arg->ServiceType,
                    arg->StgId,
                    arg->VolumeName,
                    &arg->EntryUid,
                    arg->EntryPrefix,
                    arg->ShortPrefix,
                    arg->RelationInfo);
    if (configInfo == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Make sure that the storage id is legal
    //

    if (NT_SUCCESS(status)) {
        if (!DfsStorageIdLegal(&volume))      {
            status = DFS_STATUS_STORAGEID_ALREADY_INUSE;
        }
    }

    if (NT_SUCCESS(status)) {

        //
        // Next we need to make sure that we dont already have a local volume
        // with the same prefix. So we acquire resources in the right order.
        //

        ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

        //
        // Now we need to acquire the PKT and try to update PKT with new
        // partition's information.
        //

        PktAcquireExclusive(pkt, TRUE);

        //
        // Let us lookup in the PKT first.
        //

        RtlInitUnicodeString( &path, arg->EntryPrefix );

        Entry = PktLookupEntryByPrefix(
                    pkt,
                    &path,
                    &remainingPath);

        //
        // If we already have a local volume with exactly this prefix then we
        // fail this call.
        //

        if ((Entry != NULL) &&
                (Entry->LocalService != NULL) &&
                    (remainingPath.Length == 0))    {

            status = DFS_STATUS_LOCAL_ENTRY;
            goto Cleanup;

        }

        //
        // Now that we are here we have determined that we can go ahead and
        // attempt to perform this operation. First we need to make sure that
        // the required storageId does exist on disk.
        //

        if (!DfsStorageIdExists(volume, TRUE))        {
            status = DFS_STATUS_BAD_STORAGEID;
            goto Cleanup;
        }

        //
        // Next, store the local volume info persistently in the registry.
        //

        status = DfsStoreLvolInfo(
                        configInfo,
                        &volume );

        if (!NT_SUCCESS(status)) {
            DebugTrace(0, Dbg,
                "DfsFsctrlFixLocalVolumeKnowledge: Error storing local volume info %08lx\n", ULongToPtr( status ));
            status = DFS_STATUS_BAD_STORAGEID;
            goto Cleanup;
        }

        //
        // Now we are done with the storing the local volume info in the
        // registry. We still need to make sure that each of the exit Points
        // exist on disk appropriately.
        //

        if (NT_SUCCESS(status)) {
            status = DfspFixExitPoints(arg);
        }

        //
        // Now we need to initialize the PKT with this new partition info.
        //
        if (NT_SUCCESS(status)) {
            status = PktInitializeLocalPartition(
                        pkt,
                        &volume,
                        configInfo);

            if (!NT_SUCCESS(status))    {
                DebugTrace(0, Dbg,
                "DfsFixLocalVolumeKnowledge: Failed PktInitialize %08lx\n",
                ULongToPtr( status ));
            }
        }


Cleanup:

        if (pkt != NULL)
            PktRelease(pkt);

        ExReleaseResourceLite(&DfsData.Resource);

        if (configInfo != NULL)
            ExFreePool( configInfo );

    } else {

        DebugTrace(0,Dbg, "DfsFsctrlFixLocalVolumeKnowledge:Error %08lx\n", ULongToPtr( status ));

    }

exit_with_status:

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg,"DfsFsctrlFixLocalVolumeKnowledge:Exit-> %08lx\n", ULongToPtr( status ));

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\ftdfs.h ===
//+------------------------------------------------------------------
//
// File:        ftdfs.h
//
// Contents:    Header file for FtDfs related functions
//
// Functions:
//
//-------------------------------------------------------------------

VOID
DfspParsePath(
    PUNICODE_STRING Path,
    PUNICODE_STRING DomainName,
    PUNICODE_STRING ShareName,
    PUNICODE_STRING Remainder
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\ftdfs.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       ftdfs.c
//
//  Contents:   Support for ftdfs resolution
//
//  Classes:    None
//
//  Functions:  
//
//-----------------------------------------------------------------------------

#define Dbg DEBUG_TRACE_ROOT_EXPANSION

#include "dfsprocs.h"
#include "ftdfs.h"

#include "know.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfspParsePath )

#endif // ALLOC_PRAGMA

//+----------------------------------------------------------------------------
//
//  Function:   DfspParsePrefix
//
//  Synopsis:   Helper routine to break a path into domain, share, remainder
//
//  Arguments:  [Path] -- PUNICODE string of path to parse
//
//  Returns:    [DomainName] -- UNICODE_STRING containing DomainName, if present
//              [ShareName] -- UNICODE_STRING containing ShareName, if present
//              [Remainder] -- UNICODE_STRING containing remainder of Path
//
//-----------------------------------------------------------------------------

VOID
DfspParsePath(
    PUNICODE_STRING PathName,
    PUNICODE_STRING DomainName,
    PUNICODE_STRING ShareName,
    PUNICODE_STRING Remainder)
{
    LPWSTR ustrp, ustart, uend;

    DebugTrace(+1, Dbg, "DfspParsePath(%wZ)\n", PathName);

    RtlInitUnicodeString(DomainName, NULL);
    RtlInitUnicodeString(ShareName, NULL);
    RtlInitUnicodeString(Remainder, NULL);

    // Be sure there's something to do

    if (PathName->Length == 0) {
        DebugTrace(-1, Dbg, "PathName is empty\n",0 );
        return;
    }

    // Skip leading '\'s

    ustart = ustrp = PathName->Buffer;
    uend = &PathName->Buffer[PathName->Length / sizeof(WCHAR)] - 1;

    // strip trailing nulls
    while (uend >= ustart && *uend == UNICODE_NULL)
        uend--;

    while (ustrp <= uend && *ustrp == UNICODE_PATH_SEP)
        ustrp++;

    // DomainName

    ustart = ustrp;

    while (ustrp <= uend && *ustrp != UNICODE_PATH_SEP)
        ustrp++;

    if (ustrp != ustart) {

        DomainName->Buffer = ustart;
        DomainName->Length = (USHORT)((ustrp - ustart)) * sizeof(WCHAR);
        DomainName->MaximumLength = DomainName->Length;

        // ShareName

        ustart = ++ustrp;

        while (ustrp <= uend && *ustrp != UNICODE_PATH_SEP)
            ustrp++;

        if (ustrp != ustart) {
            ShareName->Buffer = ustart;
            ShareName->Length = (USHORT)((ustrp - ustart)) * sizeof(WCHAR);
            ShareName->MaximumLength = ShareName->Length;

            // Remainder is whatever's left

            ustart = ++ustrp;

            while (ustrp <= uend)
                ustrp++;

            if (ustrp != ustart) {
                Remainder->Buffer = ustart;
                Remainder->Length = (USHORT)((ustrp - ustart)) * sizeof(WCHAR);
                Remainder->MaximumLength = Remainder->Length;
            }
        }
    }
    DebugTrace( 0, Dbg, "DfspParsePath: DomainName -> %wZ\n", DomainName);
    DebugTrace( 0, Dbg, "               ShareName  -> %wZ\n", ShareName);
    DebugTrace(-1, Dbg, "               Remainder  -> %wZ\n", Remainder);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\ipsup.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.
//
//  File:       ipsup.h
//
//  Contents:   Declarations for DFS_IP_INFO entries
//
//  History:    15 Dec 1997     Jharper Created
//
//--------------------------------------------------------------------------

#ifndef __IPSUP_H_
#define __IPSUP_H_

//
// For machine names we associate a list of sites
//

typedef struct _DFS_IP_INFO {

    //
    //  Type and size of this record (must be DFS_NTC_IP_INFO)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A list entry for the hash table chain.
    //

    LIST_ENTRY HashChain;

    //
    //  A list entry for the LRU chain
    //

    LIST_ENTRY LRUChain;

    //
    // Count (for multi-threading)
    // Uses InterlockedIncrement()/InterlockedDecrement
    //

    ULONG UseCount;

    //
    // Flags
    //

    ULONG Flags;

    //
    // The time this entry becomes invalid
    //

    LARGE_INTEGER Timeout;

    //
    // Ip address
    //

    DFS_IPADDRESS IpAddress;

    //
    //  The site associated with this IP address
    //

    UNICODE_STRING SiteName;

} DFS_IP_INFO, *PDFS_IP_INFO;

#define IP_INFO_DELETE_PENDING    0x00000001  // DFS_IP_INFO should be freed

//
//
//  Declaration of the hash table.  The hash table can be variably
//  sized, with the hash table size being a parameter of the hash
//  function.
//

typedef struct _IP_HASH_TABLE {

    //
    //  The type and size of this record (must be DFS_NTC_IP_HASH)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Mask value for the hash function.  The hash table size is
    //  assumed to be a power of two; the mask is the size - 1.
    //

    ULONG HashMask;

    //
    //  A mutex to protect access to the hash bucket lists and LRU list
    //

    FAST_MUTEX HashListMutex;

    //
    // The LRU list
    //

    LIST_ENTRY LRUChain;

    //
    // Max number of DFS_IP_INFO entries allowed
    //

    ULONG MaxEntries;

    //
    // Number of DFS_IP_INFO entries
    //

    ULONG EntryCount;

    //
    // Timeout
    //

    LARGE_INTEGER Timeout;

    //
    //  An array of list heads for the hash table chains.  There
    //  are actually N of these where N is the hash table size.
    //

    LIST_ENTRY  HashBuckets[1];

} IP_HASH_TABLE, *PIP_HASH_TABLE;

NTSTATUS
DfsInitIp(
    ULONG cHash,
    ULONG cEntries
);

VOID
DfsUninitIp(
    VOID
    );

VOID
DfsReleaseIpInfo(
    PDFS_IP_INFO pIpInfo
);

NTSTATUS
DfsFsctrlCreateIpInfo(
    PIRP Irp,
    PVOID InputBuffer,
    ULONG InputBufferLength
);

NTSTATUS
DfsFsctrlDeleteIpInfo(
    PIRP Irp,
    PVOID InputBuffer,
    ULONG InputBufferLength
);

PDFS_IP_INFO
DfsLookupSiteByIpaddress(
  IN    PDFS_IPADDRESS pDfsIpAddress,
  IN    BOOLEAN UseForce
);

VOID
DfsReleaseIpInfo(
  IN    PDFS_IP_INFO pIpInfo
);

#endif  // __IPSUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\localvol.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       LOCALVOL.C
//
//  Contents:   This module implements the routines associated with
//              managing local volumes.  These are generally external
//              interfaces which are called via NtFsControlFile.
//
//  Functions:  DfsFsctrlGetLocalVolumeEntry -
//              DfsFsctrlCreateLocalPartition -
//              DfsFsctrlDeleteLocalPartition -
//              DfsFsctrlCreateExitPoint -
//              DfsFsctrlDeleteExitPoint -
//              BuildLocalVolPath - build the path to a file on a local volume
//              DfsCreateExitPath -
//              DfsDeleteExitPath -
//              DfsGetPrincipalName -
//              DfsFileOnExitPath -
//              DfsStorageIdLegal -
//
//  History:    28 May 1992     Peterco Created.
//              22 Jul 1992     Alanw   Extended DfsFsctrlInitLocalPartitions
//                              SudK    Creating/DeletingLocal Knowledge
//                              SudK    Adding Aging PKT entries.
//              12 Jul 1993     Alanw   Removed fsctrls for manipulating PKT.
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include <align.h>
#include <stdlib.h>                              
#include <dfserr.h>
#include <netevent.h>
#include "fsctrl.h"
#include "registry.h"
#include "regkeys.h"
#include "log.h"
#include "know.h"
#include "lvolinit.h"
#include "attach.h"
#include "dfswml.h"

//
//  The local debug trace level
//

#define Dbg             (DEBUG_TRACE_LOCALVOL)

BOOLEAN
DfsDeleteDirectoryCheck(
   UCHAR *Buffer);

ULONG
DfsGetDirectoriesToDelete(
    PUNICODE_STRING pExitPtName, 
    PUNICODE_STRING pShareName);

NTSTATUS
DfsCreateExitPath(
    IN PDFS_SERVICE  pService,
    IN PUNICODE_STRING pRemPath,
    IN ULONG Disposition);

NTSTATUS
BuildShortPrefix(
    IN PUNICODE_STRING pRemPath,
    IN PDFS_SERVICE pService,
    IN PDFS_PKT_ENTRY_ID PeidParent,
    IN OUT PDFS_PKT_ENTRY_ID Peid);
VOID
StripLastComponent(PUNICODE_STRING pustr);

VOID
AddLastComponent(PUNICODE_STRING pustr);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsFsctrlGetLocalVolumeEntry )
#pragma alloc_text( PAGE, DfsFsctrlGetEntryType )
#pragma alloc_text( PAGE, DfsFsctrlGetChildVolumes )
#pragma alloc_text( PAGE, BuildLocalVolPath )
#pragma alloc_text( PAGE, DfsRegModifyLocalVolume )
#pragma alloc_text( PAGE, DfsFsctrlCreateLocalPartition )
#pragma alloc_text( PAGE, DfsInternalDeleteLocalVolume )
#pragma alloc_text( PAGE, DfsFsctrlDeleteLocalPartition )
#pragma alloc_text( PAGE, DfsCreateExitPath )
#pragma alloc_text( PAGE, DfsDeleteExitPath )
#pragma alloc_text( PAGE, DfsInternalModifyPrefix )
#pragma alloc_text( PAGE, DfsFsctrlModifyLocalVolPrefix )
#pragma alloc_text( PAGE, DfsInternalCreateExitPoint )
#pragma alloc_text( PAGE, DfsFsctrlCreateExitPoint )
#pragma alloc_text( PAGE, DfsInternalDeleteExitPoint )
#pragma alloc_text( PAGE, DfsFsctrlDeleteExitPoint )
#pragma alloc_text( PAGE, DfsGetPrincipalName )
#pragma alloc_text( PAGE, DfsFileOnExitPath )
#pragma alloc_text( PAGE, DfsStorageIdLegal )
#pragma alloc_text( PAGE, DfsExitPtLegal )
#pragma alloc_text( PAGE, BuildShortPrefix)
#pragma alloc_text( PAGE, StripLastComponent)
#pragma alloc_text( PAGE, AddLastComponent)
#pragma alloc_text( PAGE, DfsDeleteDirectoryCheck)
#pragma alloc_text( PAGE, DfsGetDirectoriesToDelete)
#endif // ALLOC_PRAGMA



//+----------------------------------------------------------------------------
//
//  Function:   DfspBringVolumeOnline
//
//  Synopsis:   Brings an offline volume online
//
//  Arguments:  [pkt] -- The pkt and pktEntry identify the local volume to
//              [pktEntry] -- bring online
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspBringVolumeOnline(
    IN PDFS_PKT pkt,
    IN PDFS_PKT_ENTRY pktEntry)
{
    NTSTATUS status;
    UNICODE_STRING shareName, localVolAddress;
    PDEVICE_OBJECT targetVdo;
    PDFS_VOLUME_OBJECT dfsVdo;
    ULONG volNameLen;
    BOOLEAN fCreated;

    //
    // Construct the full share name.
    //

    ASSERT(pktEntry->LocalService != NULL );

    shareName = pktEntry->LocalService->Address;

    status = DfsGetAttachName( &shareName, &localVolAddress );

    if (NT_SUCCESS(status)) {

        status = DfsAttachVolume(
                    &shareName,
                    &pktEntry->LocalService->pProvider);

        if (NT_SUCCESS(status)) {

            pktEntry->LocalService->Type &= ~DFS_SERVICE_TYPE_OFFLINE;

            RtlMoveMemory(
                (PVOID) pktEntry->LocalService->Address.Buffer,
                (PVOID) localVolAddress.Buffer,
                localVolAddress.Length);

            pktEntry->LocalService->Address.Length = localVolAddress.Length;

        }

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;

    }

    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfspTakeVolumeOffline
//
//  Synopsis:   Takes an online volume offline
//
//  Arguments:  [pkt] -- The pkt and pktEntry identify the local volume to be
//              [pktEntry] -- taken off line.
//
//  Returns:    [STATUS_SUCCESS] -- The volume was sucessfully taken offline.
//
//              [STATUS_FILES_OPEN] -- The volume could not be taken offline
//                      because it has open files.
//
//  Notes:      Assumes that the pkt has been acquired exclusive.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspTakeVolumeOffline(
    IN PDFS_PKT pkt,
    IN PDFS_PKT_ENTRY pktEntry)
{
    NTSTATUS status;

    if (pktEntry->FileOpenCount > 0) {

        DebugTrace(0, Dbg, "Volume has %d open files\n", ULongToPtr( pktEntry->FileOpenCount ));

        status = STATUS_FILES_OPEN;

    } else {

        UNICODE_STRING shareName, remPath;

        DebugTrace(0, Dbg, "Volume has no files open!\n", 0);

        //
        // Detach the device object from the volume
        //

        remPath.Length = 0;
        remPath.MaximumLength = 0;
        remPath.Buffer = NULL;

        status = BuildLocalVolPath(&shareName, pktEntry->LocalService, &remPath);

        if (NT_SUCCESS(status)) {

            DebugTrace(0, Dbg, "Detaching device object %wZ\n", &shareName);

            if (!(pktEntry->Type & PKT_ENTRY_TYPE_LEAFONLY) &&
                    !(pktEntry->LocalService->pProvider->fProvCapability & PROV_UNAVAILABLE)) {
                DfsDetachVolume( &shareName );
            }

            ASSERT( pktEntry->LocalService != NULL );

            pktEntry->LocalService->Type |= DFS_SERVICE_TYPE_OFFLINE;

            //
            // At this point, the LocalService->Address field has the name
            // relative to the device name. If we later try to bring this
            // volume online, we'll need the full name, including the device.
            // So, we'll junk the LocalService->Address field and copy the
            // full name there, just in case we need to bring it online again.
            //

            ExFreePool( pktEntry->LocalService->Address.Buffer );

            pktEntry->LocalService->Address = shareName;

        } else {

            DebugTrace(0, Dbg, "Unable to allocate share name %08lx\n", ULongToPtr( status ));

        }

    }

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlSetVolumeState
//
//  Synopsis:   Sets the volume on or off line.
//
//  Arguments:
//
//  Returns:    [STATUS_SUCCESS] -- The volume state was successfully set
//                      to the requested mode.
//
//              [STATUS_FILES_OPEN] -- The volume has open files.
//
//              [DFS_STATUS_NOSUCH_LOCAL_VOLUME] -- The volume is not local
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Unable to unmarshal
//                      arguments or allocate memory to complete operations
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlSetVolumeState(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength)
{
    NTSTATUS status;
    PDFS_SET_LOCAL_VOLUME_STATE_ARG setArg;
    PDFS_PKT pkt;
    DFS_PKT_ENTRY_ID EntryId;
    PDFS_PKT_ENTRY pktEntry;

    STD_FSCTRL_PROLOGUE(DfsFsctrlSetVolumeState, TRUE, FALSE);

    if (InputBufferLength < sizeof(*setArg)+sizeof(UNICODE_NULL)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    //
    // Unmarshal the name of the volume and the requested state.
    //

    setArg = (PDFS_SET_LOCAL_VOLUME_STATE_ARG) InputBuffer;

    OFFSET_TO_POINTER( setArg->Prefix, setArg );

    if (!DfspStringInBuffer(setArg->Prefix, InputBuffer, InputBufferLength)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    EntryId.Uid = setArg->Uid;

    RtlInitUnicodeString( &EntryId.Prefix, setArg->Prefix );

    pkt = _GetPkt();

    PktAcquireExclusive( pkt, TRUE );


    DebugTrace(0, Dbg, "Setting state for [%wZ]\n", &EntryId.Prefix );
    DebugTrace(0, Dbg, "Requested state is %d\n", ULongToPtr( setArg->State ));

    pktEntry = PktLookupEntryById( pkt, &EntryId );

    if (pktEntry == NULL ) {

        DebugTrace(0, Dbg, "Unable to locate Pkt Entry!\n", 0);

        status = DFS_STATUS_NOSUCH_LOCAL_VOLUME;

    } else {

        if (!(pktEntry->Type & PKT_ENTRY_TYPE_LOCAL)) {

            DebugTrace(0, Dbg, "Entry %wZ is not a local volume!\n",
                                                            &EntryId.Prefix);

            status = DFS_STATUS_BAD_EXIT_POINT;

        } else {

            status = STATUS_SUCCESS;

        }

    }


    if (NT_SUCCESS(status)) {

        ASSERT( pktEntry != NULL );

        //
        // See if the state bit is already as desired; if not, then do
        // the needful.
        //

        if (((pktEntry->LocalService->Type & DFS_SERVICE_TYPE_OFFLINE)
                ^ setArg->State) != 0) {

            //
            // Volume is not in requested state - try to switch it.
            //

            if (setArg->State == DFS_SERVICE_TYPE_OFFLINE) {

                status = DfspTakeVolumeOffline( pkt, pktEntry );

            } else {

                status = DfspBringVolumeOnline( pkt, pktEntry );
            }

            //
            // If successful, update our persistent knowledge in the registry
            //

            if (NT_SUCCESS(status)) {

                status = DfsChangeLvolInfoServiceType(
                            &pktEntry->Id.Uid,
                            pktEntry->LocalService->Type);

                if (!NT_SUCCESS(status)) {

                    NTSTATUS statusRecover;

                    DebugTrace(
                        0,
                        Dbg,
                        "DfsFsctrlSetVolumeState: Unable to update "
                        "registry %08lx!\n",
                        ULongToPtr( status ));

                    if (setArg->State == DFS_SERVICE_TYPE_OFFLINE) {

                        statusRecover = DfspBringVolumeOnline(pkt, pktEntry);

                    } else {

                        statusRecover = DfspTakeVolumeOffline(pkt, pktEntry);

                    }

                    if (!NT_SUCCESS(statusRecover)) {

                        DebugTrace(
                            0,
                            Dbg,
                            "DfsFsctrlSetVolumeState: Unable to recover "
                            "%08lx!\n",
                            ULongToPtr( statusRecover ));

                    }

                }

            }

        } else {

            //
            // Volume is already in the requested state - return!
            //

            NOTHING;

        }

    }

    PktRelease( pkt );

exit_with_status:

    DebugTrace(-1, Dbg, "DfsFsctrlSetVolumeState: Returning %08lx\n", ULongToPtr( status ));

    DfsCompleteRequest( Irp, status );

    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlGetEntryType
//
//  Synopsis:   Looks-up and retrieves the type of the Pkt Entry for the input
//              prefix. If there is no exact match for the input prefix,
//              this function fails with STATUS_OBJECT_NAME_NOT_FOUND
//
//  Arguments:
//
//  Returns:    [STATUS_SUCCESS] -- Entry is in output buffer.
//
//              [STATUS_BUFFER_TOO_SMALL] -- The OutputBuffer was less than
//                      4 bytes, so can't return the type.
//
//              [STATUS_OBJECT_NAME_NOT_FOUND] -- The input prefix is not
//                      in the local pkt.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlGetEntryType(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength)
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING prefix, remPath;
    MARSHAL_BUFFER marshalBuffer;
    PDFS_PKT pkt;
    PDFS_PKT_ENTRY pktEntry;

    STD_FSCTRL_PROLOGUE(DfsFsctrlGetEntryType, TRUE, TRUE);

    //
    // must be multiple of two
    //

    if ((InputBufferLength % sizeof(WCHAR)) != 0) {

        Status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;

    }

    pkt = _GetPkt();

    PktAcquireShared(pkt, (BOOLEAN)TRUE);

    prefix.MaximumLength = prefix.Length = (USHORT) InputBufferLength;
    prefix.Buffer = (PWCHAR) InputBuffer;


    DebugTrace(0, Dbg, "Getting Entry for [%wZ]\n", &prefix);

    pktEntry = PktLookupEntryByPrefix( pkt, &prefix, &remPath );

    if (pktEntry == NULL) {

        Status = STATUS_OBJECT_NAME_NOT_FOUND;

    }

    if (NT_SUCCESS(Status) && remPath.Length != 0) {

        Status = STATUS_OBJECT_NAME_NOT_FOUND;

    }

    if (NT_SUCCESS(Status)) {

        DebugTrace(0, Dbg, "Found Pkt Entry @%08lx\n", pktEntry );

        if (sizeof(ULONG) > OutputBufferLength) {

            Status = STATUS_BUFFER_TOO_SMALL;

        }

    }

    if (NT_SUCCESS(Status)) {

        _PutULong( ((PUCHAR) OutputBuffer), pktEntry->Type );

        Irp->IoStatus.Information = sizeof(ULONG);

    }

    PktRelease( pkt );

exit_with_status:

    DebugTrace(-1, Dbg, "DfsFsctrlGetPktEntry returning %08lx\n", ULongToPtr( Status ));

    DfsCompleteRequest( Irp, Status );

    return( Status );
}


//+-------------------------------------------------------------------------
//
//  Function:   BuildLocalVolPath, local
//
//  Synopsis:   This function creates the path to a file on a local volume.
//
//  Arguments:  [pFullName] --  On return, the full path name to the file
//              [pService] --   The Local Service which has storageId in it.
//              [RemPath] --    The remaining path relative to storageId.
//
//  Returns:    [STATUS_SUCCESS] --
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory
//
//  History:    05-Apr-93       Alanw   Created.
//
//--------------------------------------------------------------------------

NTSTATUS
BuildLocalVolPath(
    OUT PUNICODE_STRING pFullName,
    IN  PDFS_SERVICE pService,
    IN  PUNICODE_STRING pRemPath
) {

    //
    //  We figure out the FullName from the StorageId in the Service
    //  structure passed in and the remaining path passed in.
    //  The devicename and address are preceeded by path separators,
    //  so we don't need to add those in.
    //

    if (pService->pProvider != NULL) {
        pFullName->MaximumLength = pService->pProvider->DeviceName.Length;
    } else {
        pFullName->MaximumLength = 0;
    }

    pFullName->MaximumLength += pService->Address.Length +
                               sizeof(WCHAR) +          //For PATHSEP
                               pRemPath->Length +
                               sizeof(WCHAR);           //For UNICODE_NULL.

    pFullName->Buffer = ExAllocatePoolWithTag(PagedPool, pFullName->MaximumLength, ' sfD');

    if (pFullName->Buffer==NULL)        {
        pFullName->Length = pFullName->MaximumLength = 0;
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    if (pService->pProvider != NULL) {
        pFullName->Length = pService->pProvider->DeviceName.Length;
        RtlMoveMemory(      pFullName->Buffer,
                            pService->pProvider->DeviceName.Buffer,
                            pService->pProvider->DeviceName.Length
                     );
    } else {
        pFullName->Length = 0;
    }

    DfsConcatenateFilePath(pFullName,
                   (PWCHAR)pService->Address.Buffer,
                           pService->Address.Length
                    );

    if (pRemPath->Length > 0)
        DfsConcatenateFilePath(pFullName,
                           pRemPath->Buffer,
                           pRemPath->Length
                    );

    pFullName->Buffer[pFullName->Length/sizeof(WCHAR)] = UNICODE_NULL;

    return STATUS_SUCCESS;
}




//+----------------------------------------------------------------------
//
// Function:    DfsStorageIdLocal
//
// Synopsis:    This function determines if a given storage Id is local or not.
//
// Arguments:   [StorageId] -- UnicodeString which represents the StorageId.
//              [RemovableableMedia] -- On return, if the storage Id represents
//                      removable media.
//
// Returns:     TRUE if it is Local else FALSE.
//
// Note:        This function can also return FALSE if it cannot find the
//              drive at all as well.
//
// History:     10-10-1994  SudK    Created.
//
//-----------------------------------------------------------------------
BOOLEAN
DfsStorageIdLocal(
    IN PUNICODE_STRING     StorageId,
    OUT BOOLEAN            *RemovableMedia
)
{
    UNICODE_STRING      DriveStgId;
    OBJECT_ATTRIBUTES   objectAttributes;
    HANDLE              handle;
    IO_STATUS_BLOCK     ioStatus;
    NTSTATUS            status;
    FILE_FS_DEVICE_INFORMATION  DeviceInfo;

    if (StorageId->Length == 0)
        return(FALSE);

    //
    // Should we verify that the storage id is of \?? form.
    //
    DriveStgId.Buffer = L"\\??\\C:\\";
    DriveStgId.Length = wcslen(L"\\??\\C:\\")*sizeof(WCHAR);
    DriveStgId.MaximumLength = DriveStgId.Length + sizeof(WCHAR);
    DriveStgId.Buffer[DriveStgId.Length/sizeof(WCHAR)-3] =
        StorageId->Buffer[DriveStgId.Length/sizeof(WCHAR)-3];

    InitializeObjectAttributes(
        &objectAttributes,
        &DriveStgId,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    status = ZwCreateFile(
                &handle,
                FILE_READ_ATTRIBUTES,
                &objectAttributes,
                &ioStatus,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0);

    if (!NT_SUCCESS(status)) {

        if (status == STATUS_NO_MEDIA_IN_DEVICE) {
            *RemovableMedia = TRUE;
            return( TRUE );
        } else {
            return( FALSE );
        }
    }


    //
    // So we now have a open handle to the file
    //

    status = ZwQueryVolumeInformationFile(
                        handle,
                        &ioStatus,
                        &DeviceInfo,
                        sizeof(FILE_FS_DEVICE_INFORMATION),
                        FileFsDeviceInformation
                );

    ZwClose(handle);

    if (!NT_SUCCESS(status))    {
        DebugTrace(0, Dbg, "ZwQueryStdInformation failed %08lx\n", ULongToPtr( status ));
        return(FALSE);
    }

    if (DeviceInfo.Characteristics & FILE_REMOTE_DEVICE)        {
        DebugTrace(0, Dbg, "Remote StgId passed in %wZ\n", StorageId);
        return(FALSE);
    }

    switch (DeviceInfo.DeviceType)      {

    case FILE_DEVICE_NETWORK:
    case FILE_DEVICE_NETWORK_FILE_SYSTEM:
    case FILE_DEVICE_VIRTUAL_DISK:
        DebugTrace(0, Dbg, "Remote StgId passed in %wZ\n", StorageId);
        return(FALSE);
        break;

    case FILE_DEVICE_CD_ROM:
    case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
        *RemovableMedia = TRUE;
        return(TRUE);
        break;

    case FILE_DEVICE_DISK:
    case FILE_DEVICE_DISK_FILE_SYSTEM:
        if (DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA) {
            *RemovableMedia = TRUE;
        } else {
            *RemovableMedia = FALSE;
        }
        return(TRUE);
        break;

    default:
        DebugTrace(0, Dbg, "Unknown type StgId passed in %wZ\n", StorageId);
        return(FALSE);
        break;
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsInternalCreateLocalPartition, public
//
//  Synopsis:   This routine does all the server-side work required to share
//              some local storage under Dfs. This includes:
//
//                      Verifying the storage id is legal
//                      Updating the registry
//                      Creating the local partition info in the Pkt.
//
//  Arguments:  [StgId] -- The storage id to be shared under Dfs.
//
//              [CreateStorage] -- TRUE if you want Dfs to create the storage
//                      if it does not exist.
//
//              [pInfo] -- The DFS_LOCAL_VOLUME_CONFIG structure describing the
//                      local volume.
//
//
//
//  Returns:    [STATUS_SUCCESS] -- Local volume was successfully creaeted.
//
//              [DFS_STATUS_BAD_STORAGEID] -- The storage id is not a local
//                      storage, or does not exist and CreateStorage flag
//                      was not TRUE in the, or is a badly formatted string
//
//              [DFS_STATUS_STORAGEID_ALREADY_INUSE] -- Some parent or child
//                      of this storage id is already in the dfs namespace.
//
//              [DFS_STATUS_LOCAL_ENTRY] -- There is already a local volume
//                      with the same prefix as the input.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsInternalCreateLocalPartition(
    IN PUNICODE_STRING StgId,
    IN BOOLEAN CreateStorage,
    IN OUT PDFS_LOCAL_VOLUME_CONFIG pConfigInfo)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_PKT pkt;
    BOOLEAN  fPreviousErrorMode, removableMedia = FALSE;
    NTSTATUS DeleteStatus;

    //
    // Set this in case we are going to create a volume on removable
    // media which has no media in it
    //

    fPreviousErrorMode = IoSetThreadHardErrorMode( FALSE );

    if (!DfsStorageIdLocal(StgId, &removableMedia)) {

        status = DFS_STATUS_BAD_STORAGEID;

    }

    if (NT_SUCCESS(status) && !DfsStorageIdLegal(StgId)) {

        DebugTrace(0, Dbg,
            "DfsFsctlCreateLPartition illegal stgid %wZ\n", StgId);

        status = DFS_STATUS_STORAGEID_ALREADY_INUSE;

    }

    if (removableMedia) {
        pConfigInfo->EntryType |= PKT_ENTRY_TYPE_LEAFONLY;
    }

    if (NT_SUCCESS(status)) {

        pkt = _GetPkt();

        PktAcquireExclusive(pkt, TRUE);

        if (!DfsStorageIdExists(*StgId, CreateStorage) ) {

            status = DFS_STATUS_BAD_STORAGEID;

        } else {

            status = DfsStoreLvolInfo(pConfigInfo, StgId);

            //
            // Now we need to initialize the PKT with this new partition info.
            //

            if (NT_SUCCESS(status)) {

                //
                // We'll initialize the local partition with no exit points.
                // Then, if the local partition is initialized successfully,
                // we'll try to create all the exit points with individual
                // calls to DfsInternalCreateExitPoint
                //

                DFS_LOCAL_VOLUME_CONFIG configInfo;
                UNICODE_STRING unusedShortPrefix;
                ULONG i;

                configInfo = *pConfigInfo;

                configInfo.RelationInfo.SubordinateIdCount = 0;

                status = PktInitializeLocalPartition( pkt, StgId, &configInfo);

                if (NT_SUCCESS(status)) {

                    for (i = 0;
                            (i < pConfigInfo->RelationInfo.SubordinateIdCount)
                                && NT_SUCCESS(status);
                                    i++ ) {

                         RtlInitUnicodeString(&unusedShortPrefix,NULL);

                         status = DfsInternalCreateExitPoint(
                                    &pConfigInfo->RelationInfo.SubordinateIdList[i],
                                    PKT_ENTRY_TYPE_LOCAL_XPOINT,
                                    FILE_OPEN,
                                    &unusedShortPrefix);

                        if (NT_SUCCESS(status) && unusedShortPrefix.Buffer != NULL) {
                            ExFreePool(unusedShortPrefix.Buffer);
                        }

                    }

                    //
                    // If creating one of the junction points failed, we need
                    // to cleanup the the ones we created
                    //

                    if (!NT_SUCCESS(status)) {

                        for (i--; i > 0; i--) {

                            (void) DfsInternalDeleteExitPoint(
                                        &pConfigInfo->RelationInfo.SubordinateIdList[i],
                                        PKT_ENTRY_TYPE_LOCAL_XPOINT);
                        }

                        //
                        // We also need to "uninitialize" the local partition
                        // we just initialized
                        //

                        (void) DfsInternalDeleteLocalVolume(
                                    &pConfigInfo->RelationInfo.EntryId);


                        DeleteStatus = DfsDeleteLvolInfo(
                                        &pConfigInfo->RelationInfo.EntryId.Uid);

                        if (!NT_SUCCESS(DeleteStatus)) {

                            DebugTrace(
                                0, Dbg,
                                "Error %08lx deleting registry info after "
                                "failed create partition!\n",
                                ULongToPtr( DeleteStatus ));

                        }

                    }

                } else {

                    DeleteStatus = DfsDeleteLvolInfo(
                                        &pConfigInfo->RelationInfo.EntryId.Uid);

                    if (!NT_SUCCESS(DeleteStatus)) {

                        DebugTrace(
                            0, Dbg,
                            "Error %08lx deleting registry info after "
                            "failed create partition!\n",
                            ULongToPtr( DeleteStatus ));

                    }

                }

            } else {

                DebugTrace(0, Dbg, "Error %08lx storing info in registry\n", ULongToPtr( status ));

            }

        }

        //
        // Release the PKT.
        //

        PktRelease(pkt);

    }


    IoSetThreadHardErrorMode( fPreviousErrorMode );

    return( status );

}

//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctrlCreateLocalPartition, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Notes:      We only process this FSCTRL from the file system process,
//              never from the driver.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsFsctrlCreateLocalPartition(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{
    NTSTATUS status = STATUS_SUCCESS;
    MARSHAL_BUFFER marshalBuffer;
    PDFS_CREATE_LOCAL_PARTITION_ARG arg;
    PDFS_LOCAL_VOLUME_CONFIG configInfo;
    UNICODE_STRING sharePath;
    ULONG i;

    STD_FSCTRL_PROLOGUE(DfsFsctrlCreateLocalPartition, TRUE, FALSE);

    if (InputBufferLength < sizeof(*arg)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    //
    // unmarshal the arguments...
    //

    arg = (PDFS_CREATE_LOCAL_PARTITION_ARG) InputBuffer;

    OFFSET_TO_POINTER(arg->ShareName, arg);
    OFFSET_TO_POINTER(arg->SharePath, arg);
    OFFSET_TO_POINTER(arg->EntryPrefix, arg);
    OFFSET_TO_POINTER(arg->ShortName, arg);
    OFFSET_TO_POINTER(arg->RelationInfo, arg);

    if (
        !DfspStringInBuffer(arg->ShareName, InputBuffer, InputBufferLength) ||
        !DfspStringInBuffer(arg->SharePath, InputBuffer, InputBufferLength) ||
        !DfspStringInBuffer(arg->EntryPrefix, InputBuffer, InputBufferLength) ||
        !DfspStringInBuffer(arg->ShortName, InputBuffer, InputBufferLength) ||
        !POINTER_IS_VALID(arg->RelationInfo, InputBuffer, InputBufferLength)
    ) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    if (!POINTER_IN_BUFFER(
            &arg->RelationInfo->Buffer,
            sizeof(arg->RelationInfo->Buffer),
            InputBuffer,
            InputBufferLength)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    OFFSET_TO_POINTER( arg->RelationInfo->Buffer, arg );

    if (!POINTER_IS_VALID(arg->RelationInfo->Buffer, InputBuffer, InputBufferLength)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }


    for (i = 0; i < arg->RelationInfo->Count; i++) {

        if (!POINTER_IN_BUFFER(
                &arg->RelationInfo->Buffer[i].Prefix,
                sizeof(arg->RelationInfo->Buffer[i].Prefix),
                InputBuffer,
                InputBufferLength)) {
            status = STATUS_INVALID_PARAMETER;
            goto exit_with_status;
        }

        OFFSET_TO_POINTER( arg->RelationInfo->Buffer[i].Prefix, arg );

        if (!DfspStringInBuffer(
                arg->RelationInfo->Buffer[i].Prefix,
                InputBuffer,
                InputBufferLength)) {
            status = STATUS_INVALID_PARAMETER;
            goto exit_with_status;
        }

    }

    RtlInitUnicodeString( &sharePath, arg->SharePath );

    configInfo = DfsNetInfoToConfigInfo(
                    PKT_ENTRY_TYPE_CAIRO,
                    DFS_SERVICE_TYPE_MASTER,
                    arg->SharePath,
                    arg->ShareName,
                    &arg->EntryUid,
                    arg->EntryPrefix,
                    arg->ShortName,
                    arg->RelationInfo );

    if (configInfo == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;

    }

    if (NT_SUCCESS(status)) {

        status = DfsInternalCreateLocalPartition(
                        &sharePath,
                        FALSE,
                        configInfo);

        //
        // need to deallocate the config info...
        //

        LocalVolumeConfigInfoDestroy( configInfo, TRUE );

    } else {

        DebugTrace(0, Dbg, "DfsFsctrlCreateLPart Unmarshal Err %08lx\n", ULongToPtr( status ));

    }

exit_with_status:

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg,
        "DfsFsctrlCreateLocalPartition: Exit -> %08lx\n", ULongToPtr( status ));

    return status;

}



//+-------------------------------------------------------------------------
//
//  function:   DfsInternalDeleteLocalVolume, public
//
//  Synopsis:   This function deletes a local volume knowledge given the
//              EntryId describing the local volume.
//
//  Arguments:  [localEntryId] -- The entryId describing the local volume.
//
//  Returns:    [SUCCESS_SUCCESS] -- If all went well.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory.
//
//              [DFS_STATUS_NOSUCH_LOCAL_VOLUME] -- Couldn't find pkt entry
//                      in Pkt.
//
//              This routine can also return error codes returned by
//              NT Registry calls.
//
//  Notes:      This function will attempt to acquire Exclusive Locks on PKT.
//
//  History:    31 March 1993   Created SudK from
//                              DfsFsctrlDeleteLocalPartition.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsInternalDeleteLocalVolume(
    IN  PDFS_PKT_ENTRY_ID       localEntryId)
{
    NTSTATUS status = STATUS_SUCCESS;

    DebugTrace(+1, Dbg, "DfsInternalDeleteLocalVolume: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(localEntryId));

    if (NT_SUCCESS(status)) {

        PDFS_PKT pkt;
        PDFS_PKT_ENTRY localEntry;

        //
        // Find the local entry...and make sure that its local...
        //

        pkt = _GetPkt();

        PktAcquireExclusive(pkt, TRUE);

        localEntry = PktLookupEntryById(pkt, localEntryId);

        if ((localEntry != NULL) &&
            (localEntry->Type & PKT_ENTRY_TYPE_LOCAL)) {

            PDFS_SERVICE service;

            status = DfsDeleteLvolInfo(&localEntryId->Uid);

            //
            // We don't want to invalidate this entry unless everything
            // else (deletion of the registry info) went well.
            //

            if (NT_SUCCESS(status))     {

                UNICODE_STRING      ShareName = {0, 0, NULL};
                UNICODE_STRING      RemPath = {0, 0, NULL};

                //
                // First, we delete the local DFS_SERVICE associated with
                // the Pkt Entry
                //

                if (! (localEntry->LocalService->Type &
                            DFS_SERVICE_TYPE_OFFLINE)) {

                    status = BuildLocalVolPath(&ShareName, localEntry->LocalService, &RemPath);

                    if (NT_SUCCESS(status)) {

                        DebugTrace(0, Dbg, "Trying to remove local service %wZ\n", &ShareName);

                        PktEntryRemoveLocalService(pkt, localEntry, &ShareName);

                    }

                } else {

                    PktServiceDestroy(localEntry->LocalService, (BOOLEAN)TRUE);

                    localEntry->LocalService = NULL;

                }

                //
                //  Next, we delete the Pkt Entry if it is only a local
                //  volume.  If it is also an exit point, then we want to
                //  keep the entry.
                //

                if (NT_SUCCESS(status)) {

                    localEntry->Type &= ~PKT_ENTRY_TYPE_LOCAL;

                    if (! (localEntry->Type & PKT_ENTRY_TYPE_LOCAL_XPOINT)) {

                        status = PktInvalidateEntry(pkt, localEntry);

                        ASSERT( status == STATUS_SUCCESS );

                    }

                    if (ShareName.Buffer) {

                        ExFreePool(ShareName.Buffer);

                    }

                } else {

                    DebugTrace(0, Dbg, "Unable to allocate share name %08lx\n", ULongToPtr( status ));

                }

            } else {

                DebugTrace(0, Dbg, "Error %08lx deleting registry info\n", ULongToPtr( status ));
            }

        } else {

            //
            // We did not find a local entry that matches the Prefix that
            // has been requested to be deleted. We have to return an
            // error code here.
            //

            status = DFS_STATUS_NOSUCH_LOCAL_VOLUME;

        }

        //
        // We can release the Pkt now...
        //

        PktRelease(pkt);
    }

    DebugTrace(-1, Dbg, "DfsInternalDeleteLocalVolume: Exit -> %08lx\n", ULongToPtr( status ));
    return status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctrlDeleteLocalPartition, public
//
//  Synopsis:   This function services an FSCTRL which the DC can make to
//              delete knowledge of a local partition in the PKT.
//
//  Arguments:
//
//  Returns:
//
//  History:    March 31 1993   Modified to use DfsInternalDelete by SudK
//
//--------------------------------------------------------------------------
NTSTATUS
DfsFsctrlDeleteLocalPartition(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{
    NTSTATUS status = STATUS_SUCCESS;
    DFS_PKT_ENTRY_ID localEntryId;
    PDFS_DELETE_LOCAL_PARTITION_ARG arg;

    STD_FSCTRL_PROLOGUE(DfsFsctrlDeleteLocalPartition, TRUE, FALSE);

    if (InputBufferLength < sizeof(*arg)+sizeof(UNICODE_NULL)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    //
    // Unmarshal the argument...
    //

    arg = (PDFS_DELETE_LOCAL_PARTITION_ARG) InputBuffer;
    OFFSET_TO_POINTER( arg->Prefix, arg );

    if (!DfspStringInBuffer(arg->Prefix, InputBuffer, InputBufferLength)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    localEntryId.Uid = arg->Uid;
    RtlInitUnicodeString( &localEntryId.Prefix, arg->Prefix );

    DebugTrace(0, Dbg, "Deleting [%wZ]", &localEntryId.Prefix );

    status = DfsInternalDeleteLocalVolume(&localEntryId);

exit_with_status:

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg, "DfsFsctrlDeleteLocalPartition: Exit -> %08lx\n", ULongToPtr( status ));
    return status;
}




//+-------------------------------------------------------------------------
//
//  Function:   DfsCreateExitPath, local
//
//  Synopsis:   This function creates the exit point on the disk.
//
//  Arguments:  [pService] --   The Local Service which has storageId in it.
//              [pRemPath] --   The remaining path relative to storageId.
//              [Disposition] -- If this is set to FILE_OPEN_IF, success
//                      is returned if the exit path already exists on disk.
//                      If it is set to FILE_CREATE, then an error is
//                      returned if the exit path exists.
//              [pExitPointHandle] -- On successful return, handle to the
//                      newly create exit point is returned here.
//
//  Returns:    [STATUS_SUCCESS] -- If everything succeeds.
//
//              [DFS_STATUS_BAD_EXIT_POINT] -- If any error was encountered
//                              during the creation of the exit path.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- If unable to allocate
//                              memory for the Device Path form of the exit
//                              path.
//
//  History:    02-Feb-93       SudK    Created.
//
//--------------------------------------------------------------------------
NTSTATUS
DfsCreateExitPath(
    PDFS_SERVICE  pService,
    PUNICODE_STRING pRemPath,
    ULONG Disposition)
{
    HANDLE              exitPtHandle;
    UNICODE_STRING      exitPtName;
    UNICODE_STRING      exitPtPath;
    OBJECT_ATTRIBUTES   objectAttributes;
    IO_STATUS_BLOCK     ioStatus;
    NTSTATUS            status;
    BOOLEAN             fDoingParents = TRUE;

    DebugTrace(+1, Dbg, "DfsCreateExitPath()\n", 0 );

    //
    // Get the full name of the exit point.
    //

    status = BuildLocalVolPath(&exitPtName, pService, pRemPath);

    if (! NT_SUCCESS(status)) {
        return status;
    }

    //
    // Now we have the Full Path of the ExitPoint. Let's go create it.
    //

    InitializeObjectAttributes(
        &objectAttributes,
        &exitPtName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);


    //
    // Bug fix: 431227. Attempt to create the dir if it doesn't already
    // exist. Instead of always deleting the directory and then recreating 
    // it, since that causes FRS headaches.

    status = ZwCreateFile(
                &exitPtHandle,
                DELETE | FILE_READ_ATTRIBUTES,
                &objectAttributes,
                &ioStatus,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN_IF,
                FILE_DIRECTORY_FILE |
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0);

    DFS_TRACE_ERROR_HIGH(status,ALL_ERROR, DfsCreateExitPath_Error_ZwCreateFile,
                         LOGSTATUS(status)
                         LOGUSTR(*pRemPath));

    if (!NT_SUCCESS(status)) {
        (void) ZwDeleteFile(&objectAttributes);
    } else {
        ZwClose( exitPtHandle );
        goto done;
    }

    exitPtPath = exitPtName;

    exitPtPath.MaximumLength = exitPtPath.Length;

    do {

        DebugTrace( 0, Dbg, "exitPtPath=%wZ\n", &exitPtPath);

        status = ZwCreateFile(
                    &exitPtHandle,
                    DELETE | FILE_READ_ATTRIBUTES,
                    &objectAttributes,
                    &ioStatus,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    Disposition,
                    FILE_DIRECTORY_FILE |
                    FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

        DFS_TRACE_ERROR_HIGH(status,ALL_ERROR, DfsCreateExitPath_Error_ZwCreateFile2,
                             LOGSTATUS(status)
                             LOGUSTR(*pRemPath));
        if (!NT_SUCCESS(status)) {

            StripLastComponent(&exitPtPath);

            InitializeObjectAttributes(
                &objectAttributes,
                &exitPtPath,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

        } else {

            ZwClose( exitPtHandle );

        }

    } while (!NT_SUCCESS(status) && exitPtPath.Length > (7 * sizeof(WCHAR)));

    if (NT_SUCCESS(status)) {

        while (exitPtPath.Length < exitPtPath.MaximumLength) {

            AddLastComponent(&exitPtPath);

            InitializeObjectAttributes(
                &objectAttributes,
                &exitPtPath,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

            DebugTrace( 0, Dbg, "exitPtPath=%wZ\n", &exitPtPath);

            status = ZwCreateFile(
                        &exitPtHandle,
                        DELETE | FILE_READ_ATTRIBUTES,
                        &objectAttributes,
                        &ioStatus,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        Disposition,
                        FILE_DIRECTORY_FILE |
                        FILE_SYNCHRONOUS_IO_NONALERT,
                        NULL,
                        0);

            DFS_TRACE_ERROR_HIGH(status,ALL_ERROR, DfsCreateExitPath_Error_ZwCreateFile3,
                                 LOGSTATUS(status)
                                 LOGUSTR(*pRemPath));
            if (!NT_SUCCESS(status)) {

                break;

            }

            ZwClose( exitPtHandle );

        }

    }

done:
    if (!NT_SUCCESS(status)) {
        status = DFS_STATUS_BAD_EXIT_POINT;
    }

    if (exitPtName.Buffer != NULL)      {
        ExFreePool(exitPtName.Buffer);
    }

    DebugTrace(-1, Dbg, "DfsCreateExitPath: Exit -> %08lx\n", ULongToPtr( status ));

    return(status);
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsDeleteExitPath, local
//
//  Synopsis:   This function deletes the exit point on the disk.
//
//  Arguments:  [pService] --   The Local Service which has storageId in it.
//              [pRemPath] --   The remaining path relative to storageId.
//
//  Returns:    [STATUS_INSUFFICIENT_RESOURCES] -- If unable to build a
//                      local path.
//
//              [STATUS_DEVICE_OFF_LINE] -- If the local volume on which the
//                      exit path resides is offline.
//
//              NTSTATUS from the ZwCreateFile call to delete the exit path.
//
//  History:    02-Feb-93       SudK    Created.
//
//--------------------------------------------------------------------------
NTSTATUS
DfsDeleteExitPath(PDFS_SERVICE  pService, PUNICODE_STRING pRemPath)
{
    UNICODE_STRING      ExitPtName, ExitPtPath;
    OBJECT_ATTRIBUTES   objectAttributes;
    HANDLE              exitPtHandle;
    IO_STATUS_BLOCK     ioStatus;
    NTSTATUS            status;
    FILE_DISPOSITION_INFORMATION        FileDispInfo;
    UNICODE_STRING      ShareRemPath = {0, 0, NULL};
    UNICODE_STRING      ShareName = {0, 0, NULL};
    ULONG Deletes;
    ULONG i;

    //
    // See if the local volume from which the exit point has to be deleted
    // is offline.
    //

    if (pService->Type & DFS_SERVICE_TYPE_OFFLINE) {

        return( STATUS_DEVICE_OFF_LINE );
    }

    //
    // Get the name of the Share (this is NOT the full name of exit point).
    // The sharename is that specified in the pservice.
    //

    status = BuildLocalVolPath(&ShareName, pService, &ShareRemPath);
    if (! NT_SUCCESS(status)) {
        return status;
    }

    //
    // Get the full name of the exit point.
    //

    status = BuildLocalVolPath(&ExitPtName, pService, pRemPath);
    if (! NT_SUCCESS(status)) {
        return status;
    }


    Deletes = DfsGetDirectoriesToDelete(&ExitPtName, &ShareName);

    ExitPtPath = ExitPtName;
    //
    //  Now we have the Full Path of the ExitPoint. Let's go delete it.
    //

    for (i = 0; (i < Deletes) && (NT_SUCCESS(status)); i++) {
        InitializeObjectAttributes(
             &objectAttributes,
             &ExitPtPath,
             OBJ_CASE_INSENSITIVE,
             NULL,
             NULL);

         status = ZwOpenFile(
                      &exitPtHandle,
                      DELETE,
                      &objectAttributes,
                      &ioStatus,
                      FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                      FILE_DIRECTORY_FILE);


         DFS_TRACE_ERROR_HIGH(status,ALL_ERROR, DfsDeleteExitPath_Error_ZwOpenFile,
                              LOGSTATUS(status)
                              LOGUSTR(*pRemPath));
         if (NT_SUCCESS(status)) {

             FILE_DISPOSITION_INFORMATION disposition;

             disposition.DeleteFile = TRUE;
             status = ZwSetInformationFile(
                            exitPtHandle,
                            &ioStatus,
                            &disposition,
                            sizeof(disposition),
                            FileDispositionInformation);
             DFS_TRACE_ERROR_HIGH(status,ALL_ERROR, DfsDeleteExitPath_Error_ZwSetInformationFile,
                                  LOGSTATUS(status)
                                  LOGUSTR(*pRemPath));

             ZwClose(exitPtHandle);
             StripLastComponent(&ExitPtPath);
	 }
    }

    if (ExitPtName.Buffer != NULL) {
        ExFreePool(ExitPtName.Buffer);
    }

    return(status);
}



//+------------------------------------------------------------------------
//
// Function:    DfsInternalModifyPrefix, private
//
// Synopsis:    This function fixes the entrypath of the volume whose EntryId
//              is passed to it.
//
// Arguments:   [peid] -- The PktEntryId of vol to be fixed. The GUID is
//                        used to look up the volume.
//
// Returns:     [DFS_STATUS_NOSUCH_LOCAL_VOLUME] -- If no pkt entry with the
//                        GUID in peid is found.
//
//              [DFS_STATUS_BAD_EXIT_POINT] -- If the new prefix could not
//                        be inserted in the Prefix Table (because
//                        of a conflicting entry already in the Pkt)
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- If room for the new
//                        prefix could not be allocated.
//
//              [STATUS_SUCCESS] -- If everything succeeds
//
// History:     24 Oct 1993     SudK    Created.
//
//-------------------------------------------------------------------------
NTSTATUS
DfsInternalModifyPrefix(
    IN PDFS_PKT_ENTRY_ID        peid
)
{
    PDFS_PKT        pkt;
    PDFS_PKT_ENTRY  localEntry;
    NTSTATUS        status = STATUS_SUCCESS;
    UNICODE_STRING  oldPrefix;

    DebugTrace(+1, Dbg, "DfsInternalModifyPrefix: Entered\n", 0);
    memset(&oldPrefix, 0, sizeof(UNICODE_STRING));

    pkt = _GetPkt();
    PktAcquireExclusive(pkt, TRUE);
    localEntry = PktLookupEntryByUid(pkt, &peid->Uid);

    if ((localEntry != NULL) &&
        (localEntry->Type & PKT_ENTRY_TYPE_LOCAL)) {

        ASSERT(localEntry->LocalService != NULL);

        //
        // We now need to save the old prefix first.
        //

        oldPrefix = localEntry->Id.Prefix;

        oldPrefix.Buffer = ExAllocatePoolWithTag(PagedPool, oldPrefix.MaximumLength, ' sfD');

        if (oldPrefix.Buffer != NULL)       {
            RtlMoveMemory(  oldPrefix.Buffer,
                            localEntry->Id.Prefix.Buffer,
                            oldPrefix.MaximumLength);

            status = PktEntryModifyPrefix(pkt, &peid->Prefix, localEntry);
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        //
        // The best match with the ExitPath was not a local volume.
        // Hence we cannot create this exit point. There might be some
        // knowledge discrepancy here.
        //

        DebugTrace(0, Dbg, "Did Not Find Entry to ModifyPrefix %ws\n",
                    peid->Prefix.Buffer);

        status = DFS_STATUS_NOSUCH_LOCAL_VOLUME;

    }

    //
    // OK we took care of the PKT. We still need to take care of the
    // info in the registry.
    //

    if (NT_SUCCESS(status)) {

        status = DfsChangeLvolInfoEntryPath(&localEntry->Id.Uid,
                                            &peid->Prefix);

        if (!NT_SUCCESS(status)) {
            status = PktEntryModifyPrefix(pkt, &oldPrefix, localEntry);
        }
    }


    //
    // We can release the Pkt now...
    //
    if (oldPrefix.Buffer != NULL)
        ExFreePool(oldPrefix.Buffer);

    PktRelease(pkt);
    DebugTrace(-1, Dbg, "DfsInternalModifyPrefix: Exit -> %08lx\n", ULongToPtr( status ));
    return(status);

}



//+----------------------------------------------------------------------
//
// Function:    DfsFsctrlModifyLocalVolPrefix
//
// Synopsis:    This function is called on a client/server by the DC during
//              knowledge synchronisation to fix a bad prefix match.
//
// Arguments:   The PktEntryID.
//
// Returns:     [STATUS_DATA_ERROR] -- If the input buffer is not formatted
//                        correctly.
//
//              [DFS_STATUS_NOSUCH_LOCAL_VOLUME] -- If no pkt entry with the
//                        GUID in peid is found.
//
//              [DFS_STATUS_BAD_EXIT_POINT] -- If the new prefix could not
//                        be inserted in the Prefix Table (because
//                        of a conflicting entry already in the Pkt)
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- If memory could not be
//                        allocated.
//
//              [STATUS_SUCCESS] -- If everything succeeds
//
//-----------------------------------------------------------------------
NTSTATUS
DfsFsctrlModifyLocalVolPrefix(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{

    NTSTATUS status = STATUS_SUCCESS;
    DFS_PKT_ENTRY_ID ExitPtId;
    MARSHAL_BUFFER marshalBuffer;

    STD_FSCTRL_PROLOGUE(DfsFsctrlModifyLocalVolPrefix, TRUE, FALSE);

    //
    // Unmarshal the argument...
    //

    MarshalBufferInitialize(&marshalBuffer, InputBufferLength, InputBuffer);
    status = DfsRtlGet(&marshalBuffer, &MiPktEntryId, &ExitPtId);

    if (NT_SUCCESS(status)) {

        status = DfsInternalModifyPrefix(&ExitPtId);

        //
        // Need to deallocate the entry Id...
        //

        PktEntryIdDestroy(&ExitPtId, FALSE);

    } else
        DebugTrace(0, Dbg,
                "DfsFsctrlModifyLocalVolPrefix: Unmarshalling Error!\n", 0);

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg, "DfsFsctrlModifyLocalVolPrefix: Exit -> %08lx\n", ULongToPtr( status ));
    return status;
}


//+-------------------------------------------------------------------------
//
// Function:    DfsInternalCreateExitPoint, private
//
// Synopsis:    This is the same as the function DfsFsctrlCreateExitPoint
//              except that it expects to be called after args are unmarshaled.
//
// Arguments:   [peid] -- ExitPt to create.
//              [Type] -- The type of exit point. For now only
//                      PKT_ENTRY_TYPE_MACHINE is relevant - if the type is
//                      PKT_ENTRY_TYPE_MACHINE, no attempt is made to create
//                      the on-disk exit point.
//              [Disposition] -- What to do if the on-disk exit point already
//                      exists. If Disposition == FILE_OPEN, a success is
//                      returned if the exit point already exits on disk.
//              [ShortPrefix] -- On successful return, the short prefix
//                      of the exit point that was created. Caller must free
//                      the buffer of this variable.
//
// Returns:     [STATUS_INVALID_DEVICE_REQUEST] -- If the local volume is
//                      leafonly (removable media)
//
//              [DFS_STATUS_NOSUCH_LOCAL_VOLUME] -- If there is no appropriate
//                      local volume to create the exit pt under.
//
//              [DFS_STATUS_LOCAL_ENTRY] - creation of the subordinate entry
//                      would have required that a local entry or exit point
//                      be invalidated.
//
//              [DFS_STATUS_INCONSISTENT] - an inconsistency in the PKT
//                      has been discovered.
//
//              [STATUS_DEVICE_OFF_LINE] -- The local volume on which the
//                      exit point has to be created is currently offline.
//
//              [STATUS_INVALID_PARAMETER] - the Id specified for the
//                      subordinate is invalid.
//
//              [STATUS_INSUFFICIENT_RESOURCES] - not enough memory was
//                  available to complete the operation.
//
// History:     24 Oct 1993     SudK    Created.
//
//--------------------------------------------------------------------------
NTSTATUS
DfsInternalCreateExitPoint(
    PDFS_PKT_ENTRY_ID   peid,
    ULONG               Type,
    ULONG               Disposition,
    PUNICODE_STRING     ShortPrefix
)
{
    PDFS_PKT    pkt;
    PDFS_PKT_ENTRY      localEntry;
    UNICODE_STRING      RemainingPath;
    NTSTATUS            status = STATUS_SUCCESS;
    BOOLEAN             ExitPtCreated = FALSE;
    BOOLEAN             PktEntryCreated = FALSE;
    PDFS_SERVICE        service;
    PDFS_PKT_ENTRY      pSubEntry;
    UNICODE_STRING      ustrPrefix;

    DebugTrace(+1, Dbg, "DfsInternalCreateExitPoint: Entered\n",0 );
    //
    // Find the local entry in which the exit point needs to be created
    // and make sure that its local...
    //

    pkt = _GetPkt();

    PktAcquireExclusive(pkt, TRUE);

    RtlInitUnicodeString(&ustrPrefix, NULL);

    localEntry = PktLookupEntryByPrefix(
                    pkt,
                    &peid->Prefix,
                    &RemainingPath);

    if ((localEntry != NULL) &&
            (localEntry->Type & PKT_ENTRY_TYPE_LEAFONLY)) {

        status = STATUS_INVALID_DEVICE_REQUEST;

    }

    if (NT_SUCCESS(status) &&
            (localEntry != NULL) &&
                (localEntry->Type & PKT_ENTRY_TYPE_LOCAL)) {

        ASSERT(localEntry->LocalService != NULL);

        if (localEntry->LocalService->Type & DFS_SERVICE_TYPE_OFFLINE) {

            //
            // This volume is offline, can't create exit point.
            //

            status = STATUS_DEVICE_OFF_LINE;

        } else if (DfsExitPtLegal(pkt, localEntry, &RemainingPath)) {

            //
            // Now we first want to create the exit point since we now
            // know that there is an appropriate place to create it.
            //

            service = localEntry->LocalService;

            status = STATUS_SUCCESS;
            //
            // Only if this is not an exit point leading to a machine volume
            // will we create the physical exit path on disk.
            //
            if (!(Type & PKT_ENTRY_TYPE_MACHINE))       {
                status = DfsCreateExitPath(
                            service,
                            &RemainingPath,
                            Disposition);

                if (NT_SUCCESS(status)) {

                    ExitPtCreated = TRUE;

                    status = BuildShortPrefix(
                                &RemainingPath,
                                service,
                                &localEntry->Id,
                                peid);
                }

            } else {
                status = DFS_STATUS_BAD_EXIT_POINT;
            }

            //
            // Only if we succeeded in Creating ExitPoint will we get here.
            //
            if (NT_SUCCESS(status))     {

                //
                // We now merely need to update the PKT.
                // This should create no problems in general.
                //

                status = PktCreateSubordinateEntry(
                                            pkt,
                                            localEntry,
                                            PKT_ENTRY_TYPE_LOCAL_XPOINT |
                                              PKT_ENTRY_TYPE_PERMANENT,
                                            peid,
                                            NULL,
                                            PKT_ENTRY_SUPERSEDE,
                                            &pSubEntry
                                    );
            }


            if (NT_SUCCESS(status))     {

                //
                // Now that we have created the exit pt on disk, let us
                // update our knowledge in the registry.
                //

                PktEntryCreated = TRUE;

                ustrPrefix = pSubEntry->Id.ShortPrefix;

                ustrPrefix.Buffer = ExAllocatePoolWithTag(
                                            PagedPool,
                                            pSubEntry->Id.ShortPrefix.Length,
                                            ' fsD');

                if (ustrPrefix.Buffer != NULL) {

                    RtlCopyMemory(ustrPrefix.Buffer,
                        pSubEntry->Id.ShortPrefix.Buffer,
                        pSubEntry->Id.ShortPrefix.Length);

                    status = DfsCreateExitPointInfo(
                                &localEntry->Id.Uid,
                                &pSubEntry->Id);

                } else {

                    ustrPrefix.Length = ustrPrefix.MaximumLength = 0;
                    status = STATUS_INSUFFICIENT_RESOURCES;

                }

            }

            //
            // Now we check for an error. If we do have an error then we
            // need to back out all the operations that we did so far.
            //
            if (!NT_SUCCESS(status))    {

                if (PktEntryCreated == TRUE)    {
                    //
                    // What do we do with an error in this case.
                    //
                    pSubEntry->Type &= ~(PKT_ENTRY_TYPE_LOCAL_XPOINT);
                    PktEntryDestroy(pSubEntry, pkt, TRUE);
                }

                if ((ExitPtCreated == TRUE)&&!( Type & PKT_ENTRY_TYPE_MACHINE)) {
                    //
                    // What do we do with an error in this case.
                    //
                    status = DfsDeleteExitPath(service, &RemainingPath);
                }

            }

        } else {
            DebugTrace(0, Dbg, "Illegal exit pt passed in %wZ\n",
                        &peid->Prefix);
            status = DFS_STATUS_NOSUCH_LOCAL_VOLUME;
        }
    } else {
        //
        // The best match with the ExitPath was not a local volume.
        // Hence we cannot create this exit point. There might be some
        // knowledge discrepancy here.
        //
        status = DFS_STATUS_NOSUCH_LOCAL_VOLUME;

    }

    //
    // We can release the Pkt now...
    //

    PktRelease(pkt);

    //
    // Either return the ShortPrefix with the allocated buffer or destroy it, depending on the
    // status returned.
    //

    if (NT_SUCCESS(status)) {
        *ShortPrefix = ustrPrefix;
    } else if (ustrPrefix.Buffer != NULL) {
        ExFreePool(ustrPrefix.Buffer);
    }

    DebugTrace(-1, Dbg, "DfsInternalCreateExitPoint: Exit -> %08lx\n", ULongToPtr( status ));
    return(status);

}



//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctrlCreateExitPoint, public
//
//  Synopsis:   This method creates an exit point on disk, creates a DFS.CFG
//              file and updates the PKT with the new exit point information.
//              This method of course checks to make sure that it makes sense
//              to create such an exit point. i.e. there is a local volume
//              under which this exit point can be created. Also if any of the
//              operations above fail then it backs out the entire operation.
//              If no system failures occur during this function, then it will
//              behave in an atomic fashion.
//
//  Arguments:
//
//  Returns:    [SUCCESS_SUCCESS] -- If all went well.
//
//              [STATUS_DATA_ERROR] -- If unable to unmarshal the input
//                      buffer.
//
//              [DFS_STATUS_BAD_EXIT_POINT] -- If cannot create exit point.
//
//  History:    02-Feb-93       SudK    Created.
//
//--------------------------------------------------------------------------
NTSTATUS
DfsFsctrlCreateExitPoint(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength
)
{
    NTSTATUS            status = STATUS_SUCCESS;
    DFS_PKT_ENTRY_ID    ExitPtId;
    PDFS_CREATE_EXIT_POINT_ARG arg;
    ULONG               Type;
    UNICODE_STRING      ShortPrefix;
    WCHAR               *wcp;
    PCHAR               BufferEnd;

    STD_FSCTRL_PROLOGUE(DfsFsctrlCreateExitPoint, TRUE, FALSE);

    if (InputBufferLength < sizeof(*arg)+sizeof(UNICODE_NULL) ||
        OutputBufferLength < sizeof(UNICODE_NULL)) {
        status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest( Irp, status );

        DebugTrace(-1, Dbg, "DfsFsctrlCreateExitPoint: Exit -> %08lx\n", ULongToPtr( status ));
        return( status );
    }

    //
    // Unmarshal the argument...
    //

    arg = (PDFS_CREATE_EXIT_POINT_ARG) InputBuffer;
    OFFSET_TO_POINTER( arg->Prefix, arg );

    if (!DfspStringInBuffer(arg->Prefix, InputBuffer, InputBufferLength)) {
        status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest( Irp, status );

        DebugTrace(-1, Dbg, "DfsFsctrlCreateExitPoint: Exit -> %08lx\n", ULongToPtr( status ));
        return( status );
    }

    RtlInitUnicodeString(&ShortPrefix,NULL);

    DFS_DUPLICATE_STRING(ExitPtId.Prefix, arg->Prefix, status);
    if (!NT_SUCCESS(status)) {
        DfsCompleteRequest( Irp, status );

        DebugTrace(-1, Dbg, "DfsFsctrlCreateExitPoint: Exit -> %08lx\n", ULongToPtr( status ));
        return( status );
    }
    ExitPtId.ShortPrefix.Length = ExitPtId.ShortPrefix.MaximumLength = 0;
    ExitPtId.ShortPrefix.Buffer = NULL;
    ExitPtId.Uid = arg->Uid;
    Type = arg->Type;

    if (NT_SUCCESS(status)) {

        DebugTrace(0, Dbg, "Creating Exit Point [%wZ]\n", &ExitPtId.Prefix );
        DebugTrace(0, Dbg, "Type == %d\n", ULongToPtr( Type ) );

        status = DfsInternalCreateExitPoint(&ExitPtId, Type, FILE_CREATE, &ShortPrefix);

        PktEntryIdDestroy(&ExitPtId, FALSE);

        if (NT_SUCCESS(status)) {

            if (OutputBufferLength >= (ShortPrefix.Length + sizeof(WCHAR))) {

                RtlCopyMemory(
                    OutputBuffer,
                    ShortPrefix.Buffer,
                    ShortPrefix.Length);

                ((PWCHAR) OutputBuffer)[ShortPrefix.Length/sizeof(WCHAR)] = UNICODE_NULL;

                OutputBufferLength = ShortPrefix.Length + sizeof(WCHAR);


            } else {

                RtlZeroMemory(OutputBuffer, OutputBufferLength);

            }

            Irp->IoStatus.Information = OutputBufferLength;

        }

    }

    if (ShortPrefix.Buffer != NULL) {
        ExFreePool(ShortPrefix.Buffer);
    }

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg, "DfsFsctrlCreateExitPoint: Exit -> %08lx\n", ULongToPtr( status ) );
    return status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsInternalDeleteExitPoint, public
//
//  Synopsis:   This method deletes an exit point on disk, updates the local
//              volume info in the registry and updates the PKT wrt
//              exit point information.
//
//  Arguments:  [ExitPtId] --   THis is the exitPath and GUID.
//              [Type] --       The kind of ExitPt (Machine/Cairo/NonCairo)
//
//  Returns:    [SUCCESS_SUCCESS] -- If all went well.
//
//              [DFS_STATUS_BAD_EXIT_POINT] -- If cannot find exit point.
//
//              [DFS_STATUS_NOSUCH_LOCAL_VOLUME] -- Unable to find a local
//                      service for the volume on which the exit pt is.
//
//              This routine can return errors from the NT Registry API.
//
//  Note:
//
//  History:    March 31 1993   SudK    Created from DfsFstrlDeleteExitPoint.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsInternalDeleteExitPoint(
    IN  PDFS_PKT_ENTRY_ID       ExitPtId,
    IN  ULONG                   Type)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_PKT pkt = _GetPkt();
    PWCHAR      pwch;

    PDFS_PKT_ENTRY      localEntry;
    UNICODE_STRING      RemainingPath;
    PDFS_SERVICE        service;
    DFS_LOCAL_VOLUME_CONFIG ConfigInfo;
    BOOLEAN             PktUpdated = FALSE;
    BOOLEAN             ExitPtDeleted = FALSE;
    UNICODE_STRING      ParentPrefix;

    DebugTrace(+1, Dbg, "DfsInternalDeleteExitPoint: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(ExitPtId));

    memset(&ConfigInfo, 0, sizeof(DFS_LOCAL_VOLUME_CONFIG));

    //
    // Find the local entry in which the exit point needs to be created
    // and make sure that it's local...
    //

    PktAcquireExclusive(pkt, TRUE);

    localEntry = PktLookupEntryByPrefix(
                    pkt,
                    &ExitPtId->Prefix,
                    &RemainingPath);

    if ((localEntry == NULL) ||
        (RemainingPath.Length != 0) ||
        !(localEntry->Type & PKT_ENTRY_TYPE_LOCAL_XPOINT)) {

        //
        // We don't have a perfect match or if we do, it is not
        // a local exit point.
        //

        status = DFS_STATUS_BAD_EXIT_POINT;

    }

    //
    // We go in here only if we found the exit pt in the PKT.
    //

    if ((RemainingPath.Length == 0) && (NT_SUCCESS(status)))    {

        //
        // We first delete the exit Point info from the PKT.  Else we
        // will not be able to delete the exit point??
        //

        if (localEntry->LocalService != NULL)   {

            //
            // In this case we should only turn off the exit point
            // bit and leave the entry intact.
            //

            PktEntryUnlinkSubordinate((localEntry->Superior), localEntry);

            localEntry->Type &= ~PKT_ENTRY_TYPE_LOCAL_XPOINT;

        } else  {

            PktEntryDestroy(localEntry, pkt, TRUE);

        }

        PktUpdated = TRUE;
    }

    //
    // We will attempt to delete the exit point on disk irrespective of
    // whether we found it in the PKT.
    //
    // We will remove the last component of the exit path in order to find
    // the PKT entry for the local volume on which the exit point exists.
    //

    ASSERT(ExitPtId->Prefix.Length >=  2*sizeof(WCHAR));

    pwch = ExitPtId->Prefix.Buffer;
    pwch = pwch + ExitPtId->Prefix.Length/sizeof(WCHAR) - 1;
    while ((pwch >= ExitPtId->Prefix.Buffer) && (*pwch != L'\\')) {

        pwch--;

    }

    ASSERT((pwch > ExitPtId->Prefix.Buffer) ||
           ((pwch == ExitPtId->Prefix.Buffer) && (*pwch == L'\\')));

    if (pwch > ExitPtId->Prefix.Buffer) {

        //
        // Save original length before we update.
        //

        ParentPrefix = ExitPtId->Prefix;

        ParentPrefix.Length = (USHORT)((pwch-ExitPtId->Prefix.Buffer))*sizeof(WCHAR);

    } else if (pwch == ExitPtId->Prefix.Buffer) {

        //
        // This means that we have an exit point off of O:
        //

        ParentPrefix = ExitPtId->Prefix;

        ParentPrefix.Length = sizeof(WCHAR);

    } else {

        //
        // This should never happen because of above asserts
        //

        DebugTrace(0, 1,
            "DFS: Got a Bad ExitPt for deletion: %wZ\n", &ExitPtId->Prefix);

        return(DFS_STATUS_BAD_EXIT_POINT);

    }

    localEntry = PktLookupEntryByPrefix(
                    pkt,
                    &ParentPrefix,
                    &RemainingPath);

    if (localEntry && localEntry->LocalService) {

        service = localEntry->LocalService;

        //
        // Adjust the remaining path to take account of the path name
        // component we removed above.
        //

        if (RemainingPath.Buffer == NULL)       {
            RemainingPath.Buffer = pwch + 1;
            RemainingPath.Length =
                ExitPtId->Prefix.Length - ParentPrefix.Length;
            if (pwch != ExitPtId->Prefix.Buffer)        {
                RemainingPath.Length -= sizeof(WCHAR);
            }

            RemainingPath.MaximumLength = RemainingPath.Length + sizeof(WCHAR);
        } else {
            //
            // Here we include the leading Path separator before last component
            // in length field whereas in the Previous case we do not
            //
            RemainingPath.Length += ExitPtId->Prefix.Length-ParentPrefix.Length;
            RemainingPath.MaximumLength = RemainingPath.Length + sizeof(WCHAR);
        }

        //
        // We attempt to delete the exit path. But we ignore all
        // errors here and continue on. We delete exit path only if we
        // are not dealing with an exit point leading to a machine volume.
        //

        if (!(Type & PKT_ENTRY_TYPE_MACHINE))   {

            status = DfsDeleteExitPath(service, &RemainingPath);

            if (NT_SUCCESS(status))     {

                ExitPtDeleted = TRUE;

            }

        }

        //
        // Now that we have deleted the exit pt on disk, let us
        // update our knowledge in the registry.
        //

        if (NT_SUCCESS(status)) {

            status = DfsDeleteExitPointInfo(
                            &localEntry->Id.Uid,
                            &ExitPtId->Uid);
        }

    } else {

        DebugTrace(0, 1,
            "DFS: Could not find a LocalEntry To Delete ExitPt %ws\n",
            ExitPtId->Prefix.Buffer);

        status = DFS_STATUS_NOSUCH_LOCAL_VOLUME;

    }

    //
    // We go in here only if we managed to Update the PKT and at the
    // same time also managed to delete the ExitPt from the Disk, but
    // failed to update the DFS.CFG file.
    //

    if (!NT_SUCCESS(status))    {
        //
        // If we got here. We definitely did not update the registry config
        // info with changes. We might have updated the PKT and
        // also deleted the exit point.
        //

        if (ExitPtDeleted == TRUE)      {

            //  RAID 455283: What do we do here?  Should we attempt to
            //  recreate the exitPt?

        }

        if (PktUpdated == TRUE)         {

            //  RAID 455283: What do we do here?  Should we update
            //  the Pkt with the exit pt info again?

        }

    }

    //
    // We can release the Pkt now...
    //

    PktRelease(pkt);

    DebugTrace(-1, Dbg, "DfsInternalDeleteExitPoint: Exit -> %08lx\n", ULongToPtr( status ));
    return status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctrlDeleteExitPoint, public
//
//  Synopsis:   This method deletes an exit point on disk, updates a DFS.CFG
//              file and updates the PKT without the  exit point information.
//              What should this method do if there are errors along the way
//              during any of its 3 steps described above. RAID 455283
//
//  Arguments:
//
//  Returns:    STATUS_SUCCESS -- If all went well.
//
//              DFS_STATUS_BAD_EXIT_POINT --    If cannot find exit point.
//
//  Note:
//
//  History:    02-Feb-93       SudK    Created.
//
//--------------------------------------------------------------------------
NTSTATUS
DfsFsctrlDeleteExitPoint(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDFS_DELETE_EXIT_POINT_ARG arg;
    DFS_PKT_ENTRY_ID    ExitPtId;
    ULONG               Type;

    STD_FSCTRL_PROLOGUE(DfsFsctrlDeleteExitPoint, TRUE, FALSE);

    if (InputBufferLength < sizeof(*arg)+sizeof(UNICODE_NULL)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    //
    // Unmarshal the argument...
    //

    arg = (PDFS_DELETE_EXIT_POINT_ARG) InputBuffer;
    OFFSET_TO_POINTER( arg->Prefix, arg );

    if (!DfspStringInBuffer(arg->Prefix, InputBuffer, InputBufferLength)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    ExitPtId.Uid = arg->Uid;
    RtlInitUnicodeString( &ExitPtId.Prefix, arg->Prefix );

    Type = arg->Type;

    DebugTrace(0, Dbg, "Deleting Exit Point [%wZ]\n", &ExitPtId.Prefix );
    DebugTrace(0, Dbg, "Type == %d\n", ULongToPtr( Type ));

    status = DfsInternalDeleteExitPoint(&ExitPtId, Type);

exit_with_status:

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg, "DfsFsctrlDeleteExitPoint: Exit -> %08lx\n", ULongToPtr( status ) );
    return status;
}



//+---------------------------------------------------------------------
//
//  Function:   DfsGetPrincipalName, public
//
//  Synopsis:   Gets the principal name of this machine either from the
//              DfsData structure or creates a new one by looking at Registry
//              and domain service.
//
//  Arguments:  [pustrName] -- The Service Name is to be filled in here.
//
//  Returns:    STATUS_SUCCESS -- If all went well.
//
//  History:    30 May 1993     SudK    Created.
//
//----------------------------------------------------------------------

NTSTATUS
DfsGetPrincipalName(PUNICODE_STRING pustrName)
{
    NTSTATUS    status;

    ASSERT(ARGUMENT_PRESENT(pustrName));

    //
    // We first need to acquire DfsData resource.
    //

    ExAcquireResourceSharedLite(&DfsData.Resource, TRUE);

    ASSERT(DfsData.PrincipalName.Length != 0);

    if (DfsData.PrincipalName.Length != 0)      {
        *pustrName = DfsData.PrincipalName;

        status = STATUS_SUCCESS;
    } else {
        status = STATUS_OBJECT_NAME_NOT_FOUND;
    }

    ExReleaseResourceLite(&DfsData.Resource);

    return(status);
}



//+----------------------------------------------------------------------
//
// Function:    DfsFileOnExitPath,
//
// Synopsis:    This function figures out if the given path lies along an
//              exit path on the local machine.
//
// Arguments:   [Pkt] -- Shared access is sufficient.
//              [StorageId] -- The FilePath which we need to test for.
//
// Returns:     TRUE if FilePath is a prefix of some exit path.
//              Also if FilePath matches a StorageId then we return TRUE.
//              ELSE we return FALSE.
//-----------------------------------------------------------------------
BOOLEAN
DfsFileOnExitPath(
    PDFS_PKT            Pkt,
    PUNICODE_STRING     StorageId
)
{
    PDFS_LOCAL_VOL_ENTRY        lv;
    UNICODE_STRING              RemStgId;

    lv = PktEntryLookupLocalService(Pkt, StorageId, &RemStgId);

    if ((lv != NULL) && (RemStgId.Length == 0)) {
        //
        // If we did find a perfect match, return TRUE
        // from this perfect match.
        //
        return(TRUE);
    } else if (lv != NULL) {
        //
        // We did not have a perfect match. We now need to look for exit pts
        // crossing into this StorageId from the match that we found.
        //
        PDFS_PKT_ENTRY  pktEntry, pktExitEntry;
        USHORT          prefixLength;
        UNICODE_STRING  RemExitPt;

        pktEntry = lv->PktEntry;
        pktExitEntry = PktEntryFirstSubordinate(pktEntry);

        //
        // As long as there are more exit points see if that exit point crosses
        // into the new storage Id.
        //
        while (pktExitEntry != NULL)    {

            PUNICODE_STRING     ExitPrefix;
            ExitPrefix = &pktExitEntry->Id.Prefix;

            prefixLength = pktEntry->Id.Prefix.Length;

            if (ExitPrefix->Buffer[prefixLength/sizeof(WCHAR)] == UNICODE_PATH_SEP)
                prefixLength += sizeof(WCHAR);

            RemExitPt.Length = pktExitEntry->Id.Prefix.Length - prefixLength;
            RemExitPt.MaximumLength = RemExitPt.Length + 1;
            RemExitPt.Buffer = &ExitPrefix->Buffer[prefixLength/sizeof(WCHAR)];

            //
            // Only if the ExitPt has the potential of crossing over into the
            // storageId do we do this.
            //
            if (DfsRtlPrefixPath(&RemStgId, &RemExitPt, TRUE))     {
                return(TRUE);
            }

            pktExitEntry = PktEntryNextSubordinate(pktEntry, pktExitEntry);

        } //while exit pt exists
    } // lv != NULL

    return(FALSE);

}



//+----------------------------------------------------------------------
//
// Function:    DfsStorageIdLegal
//
// Synopsis:    This function determines if a given storage Id can be used
//              to support a new part of the namespace without violating any
//              of the DFS rules as specified below.
//
// Arguments:   [StorageId] -- UnicodeString which represents the StorageId.
//
// Returns:     TRUE if it is Legal else FALSE.
//
// History:     8th Dec. 1993   SudK    Created.
//
//-----------------------------------------------------------------------
BOOLEAN
DfsStorageIdLegal(
    PUNICODE_STRING     StorageId
)
{

    PDFS_PKT                    Pkt;
    PDFS_LOCAL_VOL_ENTRY        lv;
    PUNICODE_PREFIX_TABLE_ENTRY lvpfx;
    BOOLEAN                     conflictFound = FALSE;

    if (StorageId->Length == 0)
        return(FALSE);

    //
    // We need Read access to the Pkt.
    //
    Pkt = _GetPkt();
    PktAcquireShared(Pkt, TRUE);

    lvpfx = DfsNextUnicodePrefix(&Pkt->LocalVolTable, TRUE);

    while (lvpfx != NULL && !conflictFound) {

        lv = CONTAINING_RECORD(lvpfx, DFS_LOCAL_VOL_ENTRY, PrefixTableEntry);

        if (lv->LocalPath.Length > StorageId->Length) {

            if (RtlPrefixUnicodeString(StorageId, &lv->LocalPath, TRUE)) {

                //
                // StorageId scopes over a directory which is in Dfs - this is
                // not allowed.
                //

                conflictFound = TRUE;

            }

        }

        if (lv->LocalPath.Length <= StorageId->Length) {

            if (RtlPrefixUnicodeString(&lv->LocalPath, StorageId, TRUE)) {

                //
                // StorageId is a child of a Dfs volume - this is not allowed
                // either.
                //

                conflictFound = TRUE;

            }

        }

        lvpfx = DfsNextUnicodePrefix(&Pkt->LocalVolTable, FALSE);
    }

    //
    // If we got here the StorageId was perfectly legal.
    //

    PktRelease(Pkt);

    return( !conflictFound );
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsExitPtLegal
//
//  Synopsis:   This function checks to see whether a given exit point is legal
//
//  Arguments:  [localEntry] -- The Local Entry where exit pt is to be created.
//              [Remaining]  -- Remaining Path on local Stg Id to be created.
//
//  History:    8th Dec. 1993   SudK    Created.
//
//--------------------------------------------------------------------------
BOOLEAN
DfsExitPtLegal(
    IN  PDFS_PKT                Pkt,
    IN  PDFS_PKT_ENTRY          localEntry,
    IN  PUNICODE_STRING         Remaining
)
{
    NTSTATUS                    status;
    UNICODE_STRING              LocalExitPt;
    PDFS_LOCAL_VOL_ENTRY        lv;
    UNICODE_STRING              RemExitPt;
    PWCHAR                      pwsz;
    BOOLEAN                     retCode;
    USHORT                      index;

    DebugTrace(+1, Dbg, "DfsExitPtLegal Entered : %wZ\n", Remaining);

    ASSERT(localEntry != NULL);

    //
    // We first compose the local path to the exit pt.
    //
    status = BuildLocalVolPath(&LocalExitPt,
                                localEntry->LocalService,
                                Remaining);

    //
    // If for some reason (Mem Failure) we fail above, then we will just make
    // the exit pt to be illegal. That should be an OK restrictions since the
    // only reason the above would fail is due to memory failure.
    //
    if (!NT_SUCCESS(status))    {
        DebugTrace(-1, Dbg, "DfsExitPtLegal Exited %08lx\n", ULongToPtr( status ));
        return(FALSE);
    }

    lv = PktEntryLookupLocalService(Pkt, &LocalExitPt, &RemExitPt);

    //
    // There is atleast the stg id in the local entry so we better getback a
    // Non Null value here.
    //
    ASSERT(lv != NULL);

    if (lv != NULL)     {

        ASSERT(RemExitPt.Length <= Remaining->Length);
        //
        // If we the remaining path is less than original remaining exit path
        // the we definitely hit a different and longer storage Id. So the
        // exit pt is illegal since it would cross over into a new storageId.
        //
        if (RemExitPt.Length < Remaining->Length)       {
            DebugTrace(-1, Dbg, "Illegal exit pt creation attempted %wZ\n",
                        &LocalExitPt);
            ExFreePool(LocalExitPt.Buffer);
            return(FALSE);
        }

    }
    else        {
        DebugTrace(-1, Dbg, "InternalData structures seem to be corrupt\n",0);
        ExFreePool(LocalExitPt.Buffer);
        return(FALSE);  // We should never get here.
    }

    //
    // Now we need to see if there is an encompassing and shorter StorageId.
    // If so we wont allow this exit pt to be created.
    //
    LocalExitPt.Length = LocalExitPt.Length - Remaining->Length - sizeof(WCHAR);
    index = LocalExitPt.Length/sizeof(WCHAR) - 1;
    pwsz = &LocalExitPt.Buffer[index];
    while ((*pwsz != UNICODE_PATH_SEP) && (index > 0))  {
        pwsz--;
        index--;
    }

    if (index == 0)     {
        ExFreePool(LocalExitPt.Buffer);
        return(TRUE);   // When would this happen at all.
    }
    else        {

        *pwsz = UNICODE_NULL;
        LocalExitPt.Length = index*sizeof(WCHAR);

        //
        // Now we have the StorageId with the last component of StorageId in
        // the current local service removed. Lets do a lookup for a shorter
        // StgId now.
        //
        lv = PktEntryLookupLocalService(Pkt, &LocalExitPt, &RemExitPt);
        if (lv == NULL) {
            retCode = TRUE;
        }
        else    {
            DebugTrace(0, Dbg,
                        "Found shorter StgId %wZ which makes ExitPt illegal\n",
                        &lv->LocalPath);
            retCode = FALSE;
        }
    }

    ExFreePool(LocalExitPt.Buffer);
    DebugTrace(-1, Dbg, "DfsExitPtLegal Exited\n", 0);
    return(retCode);
}

//+----------------------------------------------------------------------------
//
//  Function:   BuildShortPrefix
//
//  Synopsis:   Given the name of an exit path relative to some local volume,
//              and the Dfs prefix of the local volume, this routine computes
//              the short prefix of the exit path.
//
//  Arguments:  [pRemPath] -- Exit path relative to local volume
//              [pService] -- DFS_SERVICE describing local volume
//              [PeidParent] -- Entry path of the local volume
//              [Peid] -- EntryID of the volume for which this exit point
//                      was created.
//
//  Returns:    [STATUS_SUCCESS] -- Successfully return short prefix in
//                      Peid->ShortPrefix.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory
//
//-----------------------------------------------------------------------------

NTSTATUS
BuildShortPrefix(
    PUNICODE_STRING pRemPath,
    PDFS_SERVICE pService,
    PDFS_PKT_ENTRY_ID PeidParent,
    PDFS_PKT_ENTRY_ID Peid)
{
    NTSTATUS status;
    UNICODE_STRING exitPath, exitPathComponent, shortPrefix;

    DebugTrace(+1, Dbg, "BuildShortPrefix - Entered\n", 0);

    status = BuildLocalVolPath( &exitPath, pService, pRemPath);

    if (!NT_SUCCESS(status)) {

        ASSERT(status == STATUS_INSUFFICIENT_RESOURCES );

        return( status );

    }

    DebugTrace(0, Dbg, "Exit Path = [%wZ]\n", &exitPath);

    //
    // We now have the exit path name, which looks like
    // \Device\Harddisk0\Partition1\a\b\c\rem-path
    // The short prefix we are after looks like
    // \PeidParent.ShortPrefix\8.3-form-of-pRemPath
    //

    //
    // First, allocate room for the short prefix
    //

    shortPrefix.MaximumLength = PeidParent->ShortPrefix.Length +
                                    exitPath.Length +
                                        sizeof(FILE_NAME_INFORMATION);

    shortPrefix.MaximumLength = (USHORT) ROUND_UP_COUNT(
                                            shortPrefix.MaximumLength,
                                            4);

    shortPrefix.Buffer = ExAllocatePoolWithTag(PagedPool, shortPrefix.MaximumLength, ' sfD');

    if (shortPrefix.Buffer == NULL) {

        ExFreePool( exitPath.Buffer );

        return( STATUS_INSUFFICIENT_RESOURCES );

    }

    //
    // Copy the parent's short prefix first
    //

    shortPrefix.Length = PeidParent->ShortPrefix.Length;

    RtlCopyMemory(
        shortPrefix.Buffer,
        PeidParent->ShortPrefix.Buffer,
        PeidParent->ShortPrefix.Length);

    //
    // Now, for each component of pRemPath, figure out its 8.3 form, and
    // append it to the short prefix we are constructing.
    //

    exitPathComponent = exitPath;

    exitPathComponent.Length -= pRemPath->Length;

    do {

        ULONG n, lastIndex;
        HANDLE componentHandle;
        OBJECT_ATTRIBUTES objectAttributes;
        IO_STATUS_BLOCK ioStatus;
        PFILE_NAME_INFORMATION shortNameInfo;

        if (exitPathComponent.Buffer[
                exitPathComponent.Length/sizeof(WCHAR)] ==
                    UNICODE_PATH_SEP) {

            exitPathComponent.Length += sizeof(WCHAR);

        }

        for (n = exitPathComponent.Length / sizeof(WCHAR),
                lastIndex = exitPath.Length / sizeof(WCHAR);
                    n < lastIndex &&
                        exitPathComponent.Buffer[n] != UNICODE_PATH_SEP;
                            n++,
                                exitPathComponent.Length += sizeof(WCHAR)) {
            NOTHING;
        }

        DebugTrace(0, Dbg, "ExitPathComponent: [%wZ]\n", &exitPathComponent);

        InitializeObjectAttributes(
            &objectAttributes,
            &exitPathComponent,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

        status = ZwOpenFile(
                    &componentHandle,
                    FILE_READ_ATTRIBUTES,
                    &objectAttributes,
                    &ioStatus,
                    FILE_SHARE_VALID_FLAGS,
                    FILE_DIRECTORY_FILE);

        if (NT_SUCCESS(status)) {

            shortNameInfo = (PFILE_NAME_INFORMATION)
                                &shortPrefix.Buffer[
                                    shortPrefix.Length/sizeof(WCHAR)];

            shortNameInfo = ROUND_UP_POINTER(shortNameInfo, 4);

            status = ZwQueryInformationFile(
                        componentHandle,
                        &ioStatus,
                        shortNameInfo,
                        shortPrefix.MaximumLength - shortPrefix.Length,
                        FileAlternateNameInformation);

            ZwClose( componentHandle );

        }

        if (NT_SUCCESS(status)) {

            ULONG componentLength;

            componentLength = shortNameInfo->FileNameLength;

            shortPrefix.Buffer[ shortPrefix.Length/sizeof(WCHAR) ] =
                UNICODE_PATH_SEP;

            shortPrefix.Length += sizeof(WCHAR);

            RtlMoveMemory(
                &shortPrefix.Buffer[ shortPrefix.Length/sizeof(WCHAR) ],
                shortNameInfo->FileName,
                componentLength);

            shortPrefix.Length += (USHORT) componentLength;

        }

        DebugTrace(0, Dbg, "ShortPrefix: [%wZ]\n", &shortPrefix);

    } while ( NT_SUCCESS(status) &&
                exitPathComponent.Length < exitPath.Length );

    if (!NT_SUCCESS(status)) {

        //
        // We failed to compute the short prefix. So, we'll just use the
        // prefix as our short prefix.
        //

        shortPrefix.Length = PeidParent->Prefix.Length;

        RtlCopyMemory(
            &shortPrefix.Buffer[ shortPrefix.Length/sizeof(WCHAR) ],
            &Peid->Prefix.Buffer[ PeidParent->Prefix.Length/sizeof(WCHAR) ],
            Peid->Prefix.Length - PeidParent->Prefix.Length);

    }

    Peid->ShortPrefix = shortPrefix;

    ExFreePool( exitPath.Buffer );

    DebugTrace(-1, Dbg, "BuildShortPrefix: Exiting [%wZ]\n", &shortPrefix);

    return( STATUS_SUCCESS );

}

//+----------------------------------------------------------------------------
//
//  Function:   StripLastComponent, private
//
//  Synopsis:   Strip the trailing backslash and path from a name.  Adjusts
//              the Length field, leaves the MaximumLength field alone.
//
//  Arguments:  [pustr] -- pointer to unicode string
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------

VOID
StripLastComponent(PUNICODE_STRING pustr)
{
    PWCHAR      pwch;
    USHORT      i = 0;

    pwch = pustr->Buffer;
    pwch += (pustr->Length/sizeof(WCHAR)) - 1;

    while ((*pwch != UNICODE_PATH_SEP) && (pwch != pustr->Buffer))  {
        i += sizeof(WCHAR);
        pwch--;
    }
    if ((*pwch == UNICODE_PATH_SEP) && (pwch != pustr->Buffer))  {
        i += sizeof(WCHAR);
        pwch--;
    }

    pustr->Length -= i;
}

//+----------------------------------------------------------------------------
//
//  Function:   AddLastComponent, private
//
//  Synopsis:   Restore the trailing backslash and path from a name.  Adjusts
//              the Length field, leaves the MaximumLength field alone.  Assumes
//              that MaximumLength is the 'real' length of the string.
//
//  Arguments:  [pustr] -- pointer to unicode string
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------

VOID
AddLastComponent(PUNICODE_STRING pustr)
{
    PWCHAR      pwch;
    PWCHAR      pend;
    USHORT      i = 0;

    pwch = pustr->Buffer;
    pwch += (pustr->Length/sizeof(WCHAR)) - 1;
    pend = &pustr->Buffer[pustr->MaximumLength/sizeof(WCHAR) - 1];

    if (pwch != pend)  {
        i += sizeof(WCHAR);
        pwch++;
    }
    if ((*pwch == UNICODE_PATH_SEP) && (pwch != pend))  {
        i += sizeof(WCHAR);
        pwch++;
    }
    while ((*pwch != UNICODE_PATH_SEP) && (pwch != pend))  {
        i += sizeof(WCHAR);
        pwch++;
    }
    if ((*pwch == UNICODE_PATH_SEP) && (pwch != pend))  {
        i -= sizeof(WCHAR);
        pwch--;
    }
    pustr->Length += i;
}


#define DFS_DIRECTORY_INFO_BUFFER_SIZE 1024
#define DFS_MAX_DELETE_FILES_IN_DIRECTORY 3

//+----------------------------------------------------------------------------
//
//  Function:   DfsDeleteDirectoryCheck, private
//
//  Synopsis:   Given a buffer of FILE_NAMES_INFORMATION, this will indicate
//              if the given directory can be deleted.
//
//  Arguments:  [buffer] -- buffer containing info
//
//  Returns:    TRUE if directory can be deleted.
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsDeleteDirectoryCheck(
   UCHAR *Buffer)
{
    FILE_NAMES_INFORMATION *buf;
    ULONG numFiles = 1;
    BOOLEAN DeleteOk = TRUE;

    buf =  (FILE_NAMES_INFORMATION *)Buffer;

    while (buf->NextEntryOffset) {
      numFiles++;
      if (numFiles > DFS_MAX_DELETE_FILES_IN_DIRECTORY) {
	DeleteOk = FALSE;
         break;
      }
      buf = (FILE_NAMES_INFORMATION *)((UCHAR *)(buf) + buf->NextEntryOffset);
    }

    return DeleteOk;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetDirectoriesToDelete, private
//
//  Synopsis:   Walk the pathnames all the way up to the sharename, and
//              and return a count of number of levels that can be deleted.
//              NOTE: This is not atomic! (If someone creates a directory or
//              file AFTER this check, they are hosed since we will mark the
//              directory for delete)
//
//  Arguments:  pExitPtName : name of exit point
//              pShareName  : name of the share.
//
//  Returns:    count of number of levels that can be deleted.
//
//-----------------------------------------------------------------------------

ULONG
DfsGetDirectoriesToDelete(
    PUNICODE_STRING pExitPtName, 
    PUNICODE_STRING pShareName)
{
    PUCHAR Buffer;
    ULONG Deletes = 0;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE              exitPtHandle;
    IO_STATUS_BLOCK     ioStatus;
    NTSTATUS status, CloseStatus;
    UNICODE_STRING ExitPtName;

    ExitPtName = *pExitPtName;

    Buffer = ExAllocatePoolWithTag(PagedPool, 
                                   DFS_DIRECTORY_INFO_BUFFER_SIZE,
                                   ' sfD');
    if (Buffer == NULL)
      return ++Deletes;

    do {
        InitializeObjectAttributes(
               &objectAttributes,
	       &ExitPtName,
	       OBJ_CASE_INSENSITIVE,
	       NULL,
	       NULL);


        status = ZwOpenFile(
                    &exitPtHandle,
		    FILE_LIST_DIRECTORY | SYNCHRONIZE,
                    &objectAttributes,
                    &ioStatus,
		    FILE_SHARE_READ | FILE_SHARE_WRITE,
		    FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT );


        if (NT_SUCCESS(status)) {
            status = ZwQueryDirectoryFile(
                    exitPtHandle,
                    NULL, NULL, NULL,
                    &ioStatus,
		    Buffer,
                    DFS_DIRECTORY_INFO_BUFFER_SIZE,
                    FileNamesInformation,
                    FALSE,
		    NULL,
                    TRUE);
	    CloseStatus = ZwClose( exitPtHandle );
	}

        if (!NT_SUCCESS(status) || 
            (DfsDeleteDirectoryCheck(Buffer) == FALSE)) {
             break;
	}

        Deletes++;

        StripLastComponent(&ExitPtName);
    } while (!RtlEqualUnicodeString(&ExitPtName, pShareName, TRUE));

    if (Buffer)
      ExFreePool(Buffer);

    return Deletes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\know.h ===
//+------------------------------------------------------------------
//
// File:        know.h
//
// Contents:    Header file for knowledge related functions.
//
// Functions:
//
//-------------------------------------------------------------------


NTSTATUS
DfsModifyRemotePrefix(
    IN  DFS_PKT_ENTRY_ID ExitPtId,
    IN  HANDLE remoteHandle
    );

NTSTATUS
DfsCreateRemoteExitPoint(
    IN  DFS_PKT_ENTRY_ID ExitPtId,
    IN  HANDLE remoteHandle
    );

NTSTATUS
DfsDeleteRemoteExitPoint(
    IN  DFS_PKT_ENTRY_ID ExitPtId,
    IN  HANDLE remoteHandle
    );

NTSTATUS
DfsFsctrlFixLocalVolumeKnowledge(
    IN PIRP             Irp,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength
    );

BOOLEAN
DfsStorageIdExists(
    IN UNICODE_STRING   StgPath,
    IN BOOLEAN          bCreate
);

BOOLEAN
DfsFixExitPath(
    PWSTR       ExitPath
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\localvol.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       LOCALVOL.H
//
//  Contents:   This module provides the prototypes and structures for
//              the routines associated with managing local volumes.
//
//  Functions:
//
//-----------------------------------------------------------------------------


#ifndef _LOCALVOL_
#define _LOCALVOL_

NTSTATUS
DfsFsctrlInitLocalPartitions(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );

NTSTATUS
BuildLocalVolPath(
    OUT PUNICODE_STRING pFullName,
    IN  PDFS_SERVICE pService,
    IN  PUNICODE_STRING pRemPath
);


NTSTATUS
DfsFsctrlGetLocalVolumeEntry(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DfsFsctrlGetEntryType(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DfsFsctrlGetAllPktEntries(
    IN PIRP Irp,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength);

NTSTATUS
DfsFsctrlGetChildVolumes(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DfsFsctrlSetServiceState(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
DfsFsctrlCreateLocalPartition(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
DfsFsctrlDeleteLocalPartition(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
DfsFsctrlSetVolumeState(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
DfsFsctrlDCSetVolumeState(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
DfsFsctrlSetVolumeTimeout(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
DfsFsctrlCreateExitPoint(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DfsFsctrlDeleteExitPoint(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
DfsFsctrlModifyLocalVolPrefix(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
DfsFsctrlGetServerInfo(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DfsFsctrlCheckStgIdInUse(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );

NTSTATUS
PktFsctrlVerifyLocalVolumeKnowledge(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
PktFsctrlPruneLocalVolume(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
PktFsctrlIsChildnameLegal(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
PktFsctrlCreateEntry(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
PktFsctrlCreateSubordinateEntry(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
PktFsctrlDestroyEntry(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
PktFsctrlSetServerInfo(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
DfsRegModifyLocalVolume(
    IN PDFS_PKT_ENTRY   Entry,
    IN PUNICODE_STRING  oldPrefix
    );

NTSTATUS
DfsInternalCreateLocalPartition(
    IN PUNICODE_STRING StgId,
    IN BOOLEAN CreateStorage,
    IN OUT PDFS_LOCAL_VOLUME_CONFIG pInfo
    );

NTSTATUS
DfsInternalDeleteLocalVolume(
    IN PDFS_PKT_ENTRY_ID entryId
    );

NTSTATUS
DfsInternalDeleteExitPoint(
    IN PDFS_PKT_ENTRY_ID entryId,
    IN ULONG Type
    );

NTSTATUS
DfsDeleteExitPath(
    PDFS_SERVICE  pService,
    PUNICODE_STRING pRemPath
    );

VOID
DfsAgePktEntries(
//    IN PDFS_TIMER_CONTEXT DfsTimerContext
    IN PVOID DfsTimerContext
    );

NTSTATUS
PktFsctrlSetRelationInfo(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );


NTSTATUS
PktFsctrlGetRelationInfo(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DfsGetPrincipalName(
    OUT PUNICODE_STRING PrincipalName
    );

NTSTATUS
DfsInternalCreateExitPoint(
    IN PDFS_PKT_ENTRY_ID peid,
    IN ULONG Type,
    IN ULONG Disposition,
    OUT PUNICODE_STRING ShortPrefix
    );

NTSTATUS
DfsInternalDeleteExitPoint(
    IN  PDFS_PKT_ENTRY_ID       ExitPtId,
    IN  ULONG                   Type
    );

NTSTATUS
DfsInternalModifyPrefix(
    IN PDFS_PKT_ENTRY_ID        peid
    );

BOOLEAN
DfsStorageIdLegal(
    PUNICODE_STRING     StorageId
    );

BOOLEAN
DfsExitPtLegal(
    IN  PDFS_PKT                Pkt,
    IN  PDFS_PKT_ENTRY          localEntry,
    IN  PUNICODE_STRING         Remaining
    );

BOOLEAN
DfsFileOnExitPath(
    PDFS_PKT            Pkt,
    PUNICODE_STRING     StorageId
    );

NTSTATUS
DfspTakeVolumeOffline(
    IN PDFS_PKT pkt,
    IN PDFS_PKT_ENTRY pktEntry
    );

NTSTATUS
PktpFixupRelationInfo(
    IN PDFS_PKT_RELATION_INFO Local,
    IN PDFS_PKT_RELATION_INFO Remote);

#if DBG

NTSTATUS
PktFsctrlFlushCache(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
PktFsctrlShufflePktEntry(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength);

NTSTATUS
PktFsctrlGetFirstSvc(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    OUT ULONG OutputBufferLength);

NTSTATUS
PktFsctrlGetNextSvc(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    OUT ULONG OutputBufferLength);

#endif // DBG

#endif // _LOCALVOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\log.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       log.h
//
//  Contents:   Module to log messages from the driver to the NT event logging
//		system.
//
//  Classes:
//
//  Functions:  LogWriteMessage()
//	
//  History:    3/30/93		Milans created
//		04/18/93	SudK	Changed this function entirely.
//
//-----------------------------------------------------------------------------

#ifndef _LOG_H_
#define _LOG_H_

#define EVENT_SUCCESSFUL_INIT	0
#define EVENT_RANDOM_ERROR	1

VOID LogWriteMessage(
	IN ULONG	UniqueErrorCode,
	IN NTSTATUS	NtStatusCode,
	IN ULONG	nStrings,
	IN PUNICODE_STRING pustrArg OPTIONAL);

#endif // _LOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\lvolinfo.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       lvolinfo.c
//
//  Contents:   Functions to store and retrieve local volume info in the
//              registry.
//
//  Classes:    None
//
//  Functions:  DfsStoreLvolInfo
//              DfsGetLvolInfo
//              DfsDeleteLvolInfo
//              DfsChangeLvolInfoServiceType
//              DfsChangeLvolInfoEntryPath
//              DfsCreateExitPointInfo
//              DfsDeleteExitPointInfo
//
//              DfspAddSubordinateId
//              GuidToString
//              StringToGuid
//
//
//  History:    August 16, 1994         Milans created
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "regkeys.h"
#include "registry.h"

#define Dbg     DEBUG_TRACE_LOCALVOL

NTSTATUS
DfspAddSubordinateId(
    IN PWSTR wszLvolKey,
    IN PDFS_PKT_ENTRY_ID pId);

NTSTATUS
DfspReadPrefix(
    IN PWSTR wszKey,
    IN PWSTR wszValue,
    OUT PUNICODE_STRING pustrPrefix);

NTSTATUS
DfspSavePrefix(
    IN PWSTR wszKey,
    IN PWSTR wszValue,
    IN PUNICODE_STRING pustrPrefix);

NTSTATUS
DfspUpgradePrefix(
    IN PWSTR wszKey,
    IN PWSTR wszValue,
    IN USHORT cbComputerName,
    IN PULONG pcbPrefix,
    IN OUT PWSTR *pwszPrefix);

//+----------------------------------------------------------------------------
//
//  Function:   DfsStoreLvolInfo
//
//  Synopsis:   Stores the local volume info in the registry.
//
//  Arguments:  [pRelationInfo] -- Contains the entry id and exit point info
//                                 for the local volume.
//
//  Returns:    STATUS_SUCCESS
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsStoreLvolInfo(
    IN PDFS_LOCAL_VOLUME_CONFIG pConfigInfo,
    IN PUNICODE_STRING pustrStorageId)
{
    NTSTATUS Status;
    WCHAR wszLvolKey[ 2 * sizeof(GUID) + 1 ];
    ULONG i;

    DebugTrace(+1, Dbg, "DfsStoreLvolInfo: Entered\n", 0);

    //
    // Open the local volume section
    //

    Status = KRegSetRoot(wszLocalVolumesSection);

    if (!NT_SUCCESS(Status)) {

        DebugTrace(-1, Dbg, "Unable to open Local volumes section!\n", 0);

        return( Status );

    }

    //
    // Now, create a key for the local volume. We use the ascii form of the
    // volume guid as the key.
    //

    GuidToString( &pConfigInfo->RelationInfo.EntryId.Uid, wszLvolKey );

    DebugTrace(0, Dbg, "Volume Guid (Key) is [%ws]\n", wszLvolKey);

    Status = KRegCreateKey( NULL, wszLvolKey );

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;

    }

    //
    // Now, put the rest of the stuff in the registry for this local volume.
    //    Entry Path
    //    8.3 Entry Path
    //    Entry Type
    //    Storage ID
    //    Share Name
    //    A separate key for each exit point.
    //

    DebugTrace(0, Dbg, "Entry path is %wZ\n", &pConfigInfo->RelationInfo.EntryId.Prefix);

    Status = DfspSavePrefix(
                wszLvolKey,
                wszEntryPath,
                &pConfigInfo->RelationInfo.EntryId.Prefix);

    if (!NT_SUCCESS(Status)) {

        DebugTrace(0, Dbg, "Error setting entry path in registry %08lx!\n", ULongToPtr( Status ));

        goto Cleanup;

    }

    DebugTrace(
        0, Dbg, "Short Entry path is %wZ\n",
        &pConfigInfo->RelationInfo.EntryId.ShortPrefix);

    Status = DfspSavePrefix(
                wszLvolKey,
                wszShortEntryPath,
                &pConfigInfo->RelationInfo.EntryId.ShortPrefix);

    if (!NT_SUCCESS(Status)) {

        DebugTrace(0, Dbg, "Error setting short entry path in registry %08lx!\n", ULongToPtr( Status ));

        goto Cleanup;

    }

    DebugTrace(0, Dbg, "Entry type is %08lx\n", ULongToPtr( pConfigInfo->EntryType ));

    Status = KRegSetValue(
                wszLvolKey,
                wszEntryType,
                REG_DWORD,
                sizeof(ULONG),
                (PBYTE) &pConfigInfo->EntryType);

    if (!NT_SUCCESS(Status)) {

        DebugTrace(0, Dbg, "Error setting entry type in registry %08lx\n", ULongToPtr( Status ));

        goto Cleanup;
    }

    Status = KRegSetValue(
                wszLvolKey,
                wszServiceType,
                REG_DWORD,
                sizeof(ULONG),
                (PBYTE) &pConfigInfo->ServiceType);

    if (!NT_SUCCESS(Status)) {

        DebugTrace(0, Dbg, "Error setting service type in registry %08lx\n", ULongToPtr( Status ));

        goto Cleanup;
    }

    DebugTrace(0, Dbg, "Storage ID is %wZ\n", pustrStorageId);

    Status = KRegSetValue(
                wszLvolKey,
                wszStorageId,
                REG_SZ,
                pustrStorageId->Length,
                (PBYTE) pustrStorageId->Buffer);

    if (!NT_SUCCESS(Status)) {

        DebugTrace(0, Dbg, "Error setting storage id in registry %08lx\n", ULongToPtr( Status ));

        goto Cleanup;
    }

    DebugTrace(0, Dbg, "Share name is %wZ\n", &pConfigInfo->Share);

    Status = KRegSetValue(
                wszLvolKey,
                wszShareName,
                REG_SZ,
                pConfigInfo->Share.Length,
                (PVOID) pConfigInfo->Share.Buffer);

    if (!NT_SUCCESS(Status)) {

        DebugTrace(0, Dbg, "Error setting share name in registry %08lx\n", ULongToPtr( Status ));

        goto Cleanup;
    }

    for (i = pConfigInfo->RelationInfo.SubordinateIdCount;
            i != 0;
            i--) {


        Status = DfspAddSubordinateId(
                    wszLvolKey,
                    &pConfigInfo->RelationInfo.SubordinateIdList[i-1]);

        if (!NT_SUCCESS(Status)) {

            DebugTrace(0, Dbg, "Error %08lx adding subordinate info!\n", ULongToPtr( Status ));

            goto Cleanup;
        }

        DebugTrace(0, Dbg, "Successfully added subordinate info\n", 0);

    }

Cleanup:

    if (!NT_SUCCESS(Status)) {

        //
        // We have to cleanup all the stuff we did if we failed somewhere.
        // This is easy - just delete the key we added for the local volume
        //

        NTSTATUS CleanupStatus;

        DebugTrace(0, Dbg, "Error occured, cleaning up...\n", 0);

        CleanupStatus = KRegDeleteKey( wszLvolKey );

        if (!NT_SUCCESS(CleanupStatus)) {

            //
            // We are hosed!
            //

            DebugTrace(0, Dbg, "Unable to cleanup %08lx!\n", ULongToPtr( CleanupStatus ));

        }

    }

    KRegCloseRoot();

    DebugTrace(-1, Dbg, "DfsStoreLvolInfo exited %08lx\n", ULongToPtr( Status ));

    return( Status );
}

//+----------------------------------------------------------------------------
//
//  Function:  DfsGetLvolInfo
//
//  Synopsis:  Retrieves local volume info from the registry given the key
//             identifying the local volume.
//
//  Arguments: [pwszGuid] -- the string representation of the guid of the
//                           volume.
//             [pRelationInfo] -- Pointer to relation info which will be
//                           filled in. Note that the SubordinateIdList will
//                           be allocated here, and must be freed by the
//                           caller. Additionally, the buffers in the
//                           individual prefixes are also allocated and must
//                           be freed.
//
//  Returns:   NTSTATUS from reading the registry.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetLvolInfo(
    IN PWSTR pwszGuid,
    OUT PDFS_LOCAL_VOLUME_CONFIG pConfigInfo,
    OUT PUNICODE_STRING pustrStorageId)
{
    NTSTATUS Status;
    PDFS_PKT_ENTRY_ID pid;
    PULONG pulEntryType = NULL;
    PULONG pulServiceType = NULL;
    ULONG i, cbSize;
    APWSTR awstrSubs = NULL;

    DebugTrace(+1, Dbg, "DfsGetLvolInfo: Entered for %ws\n", pwszGuid);

    //
    // First, initialize the pConfigInfo and pustrStorageId to NULL to
    // facilitate cleanup.
    //

    RtlZeroMemory((PVOID) pConfigInfo, sizeof(DFS_LOCAL_VOLUME_CONFIG));

    RtlZeroMemory((PVOID) pustrStorageId, sizeof(UNICODE_STRING));

    Status = KRegSetRoot(wszLocalVolumesSection);

    if (!NT_SUCCESS(Status)) {

        DebugTrace(-1, Dbg, "DfsGetLvolInfo: Error setting registry root %08lx!\n", ULongToPtr( Status ));

        return( Status );

    }

    //
    // Get the Entry ID - convert the wchar GUID to an actual GUID, and get
    // the entry path from the registry.
    //

    pid = &pConfigInfo->RelationInfo.EntryId;

    Status = DfspReadPrefix( pwszGuid, wszEntryPath, &pid->Prefix );

    DebugTrace(0, Dbg, "EntryPath is %wZ\n", &pid->Prefix);

    Status = DfspReadPrefix( pwszGuid, wszShortEntryPath, &pid->ShortPrefix );

    if (!NT_SUCCESS(Status)) {

        DebugTrace(-1, Dbg, "DfsGetLvolInfo: Error reading entry path %08lx\n", ULongToPtr( Status ));

        KRegCloseRoot();

        return( Status );

    }

    DebugTrace(0, Dbg, "8.3 EntryPath is %wZ\n", &pid->Prefix);

    StringToGuid( pwszGuid, &pid->Uid );

    //
    // Now get the Entry and Service Type
    //

    Status = KRegGetValue( pwszGuid, wszEntryType, (PBYTE *) &pulEntryType );

    if (!NT_SUCCESS(Status)) {

        DebugTrace(0, Dbg, "Error %08lx getting entry type\n", ULongToPtr( Status ));

        goto Cleanup;

    }

    pConfigInfo->EntryType = *pulEntryType;

    Status = KRegGetValue( pwszGuid, wszServiceType, (PBYTE *) &pulServiceType );

    if (!NT_SUCCESS(Status)) {

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

            pConfigInfo->ServiceType = 0;

        } else {

            DebugTrace(0, Dbg, "Error %08lx getting service type\n", ULongToPtr( Status ));

            goto Cleanup;

        }

    } else {

        pConfigInfo->ServiceType = *pulServiceType;

    }

    //
    // Next, get the Storage ID
    //

    Status = KRegGetValue( pwszGuid, wszStorageId, (PBYTE *) &pustrStorageId->Buffer);

    if (!NT_SUCCESS(Status)) {

        DebugTrace(0, Dbg, "Error %08lx getting storage id from registry\n", ULongToPtr( Status ));

        goto Cleanup;

    }

    pustrStorageId->Length = wcslen(pustrStorageId->Buffer) * sizeof(WCHAR);

    pustrStorageId->MaximumLength = pustrStorageId->Length + sizeof(WCHAR);

    DebugTrace(0, Dbg, "Storage id is %wZ\n", pustrStorageId);

    //
    // Next, get the share name
    //

    Status = KRegGetValue( pwszGuid, wszShareName, (PBYTE *) &pConfigInfo->Share.Buffer);

    if (!NT_SUCCESS(Status)) {

        DebugTrace(0, Dbg, "Error %08lx getting share name from registry\n", ULongToPtr( Status ));

        goto Cleanup;

    }

    pConfigInfo->Share.Length = wcslen(pConfigInfo->Share.Buffer) * sizeof(WCHAR);

    pustrStorageId->MaximumLength = pConfigInfo->Share.Length + sizeof(WCHAR);

    DebugTrace(0, Dbg, "Share Nameis %wZ\n", &pConfigInfo->Share);

    //
    // We have the volumes PKT_ENTRY_ID. Now, figure out how many
    // subordinates there are, and get them.
    //

    Status = KRegEnumSubKeySet(
                pwszGuid,
                &pConfigInfo->RelationInfo.SubordinateIdCount,
                &awstrSubs);

    if (!NT_SUCCESS(Status)) {

        DebugTrace(0, Dbg, "DfsGetLvolInfo: Error getting subkeys %08lx\n", ULongToPtr( Status ));

        goto Cleanup;

    }

    DebugTrace(0, Dbg, "Volume has %d subordinates\n", ULongToPtr( pConfigInfo->RelationInfo.SubordinateIdCount ));

    if (pConfigInfo->RelationInfo.SubordinateIdCount == 0) {

        DebugTrace(-1, Dbg, "DfsGetLvolInfo: No subordinates! Returning success\n", 0);

        Status = STATUS_SUCCESS;

        goto Cleanup;

    }

    cbSize = pConfigInfo->RelationInfo.SubordinateIdCount * sizeof(DFS_PKT_ENTRY_ID);

    pConfigInfo->RelationInfo.SubordinateIdList = ExAllocatePoolWithTag(
                                                            PagedPool,
                                                            cbSize,
                                                            ' sfD' );

    if (pConfigInfo->RelationInfo.SubordinateIdList == NULL) {

        DebugTrace(0, Dbg, "DfsGetLvolInfo: Unable to allocate %d bytes!\n", ULongToPtr( cbSize ));

        Status = STATUS_INSUFFICIENT_RESOURCES;

        goto Cleanup;

    }

    RtlZeroMemory(pConfigInfo->RelationInfo.SubordinateIdList, cbSize);

    //
    // Get all the Subordinate information
    //

    for (i = pConfigInfo->RelationInfo.SubordinateIdCount; i != 0; i--) {

        PWSTR pwszSubordinateGuid;

        pid = &pConfigInfo->RelationInfo.SubordinateIdList[i-1];

        //
        // awstrSubs[?] is of the form lvolguid\subordinateguid.
        //

        pwszSubordinateGuid = &awstrSubs[i-1][2 * sizeof(GUID) + 1];

        DebugTrace(0, Dbg, "Subordinate Guid is %ws\n", pwszSubordinateGuid);

        StringToGuid( pwszSubordinateGuid, &pid->Uid );

        DebugTrace(0, Dbg, "Subkey is %ws\n", awstrSubs[i-1]);

        Status = DfspReadPrefix(
                    awstrSubs[i-1],
                    wszEntryPath,
                    &pid->Prefix);

        if (!NT_SUCCESS(Status)) {

            DebugTrace(0, Dbg, "Error %08lx reading subordinate prefix\n", ULongToPtr( Status ));

            goto Cleanup;

        }

        DebugTrace(0, Dbg, "Retrieved Subordinate Entry %ws\n", awstrSubs[i-1]);

        DebugTrace(0, Dbg, "Prefix is %wZ\n", &pid->Prefix);

    }

Cleanup:

    KRegCloseRoot();

    if (pulEntryType) {

        ExFreePool( pulEntryType );

    }

    if (pulServiceType) {

        ExFreePool( pulServiceType );

    }

    if (!NT_SUCCESS(Status)) {

        //
        // Cleanup whatever relation info we might have built up so far.
        //

        KRegFreeArray(
            pConfigInfo->RelationInfo.SubordinateIdCount,
            (APBYTE) awstrSubs);

        if (pConfigInfo->RelationInfo.EntryId.Prefix.Buffer != NULL) {

            ExFreePool(pConfigInfo->RelationInfo.EntryId.Prefix.Buffer);

        }

        if (pustrStorageId->Buffer != NULL) {

            ExFreePool(pustrStorageId->Buffer);

        }

        for (i = pConfigInfo->RelationInfo.SubordinateIdCount; i != 0; i--) {

            pid = &pConfigInfo->RelationInfo.SubordinateIdList[i-1];

            if (pid->Prefix.Buffer != NULL) {

                ExFreePool( pid->Prefix.Buffer );

            }

        }

        if (pConfigInfo->RelationInfo.SubordinateIdList != NULL) {

            ExFreePool(pConfigInfo->RelationInfo.SubordinateIdList);

        }

    } else {

        KRegFreeArray(
            pConfigInfo->RelationInfo.SubordinateIdCount,
            (APBYTE) awstrSubs);

    }

    DebugTrace(-1, Dbg, "DfsGetLvolInfo: Exited - %08lx\n", ULongToPtr( Status ) );

    return( Status );

}

//+----------------------------------------------------------------------------
//
//  Function:  DfsDeleteLvolInfo
//
//  Synopsis:  Deletes local volume information from the registry.
//
//  Arguments: [pguidLvol] -- pointer to guid of local volume to delete.
//
//  Returns:   NTSTATUS from registry API
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsDeleteLvolInfo(
    IN GUID *pguidLvol)
{
    NTSTATUS Status;
    WCHAR wszLvolKey[ 2 * sizeof(GUID) + 1 ];

    DebugTrace(+1, Dbg, "DfsDeleteLvolInfo - Entered\n", 0);

    GuidToString(pguidLvol, wszLvolKey);

    Status = KRegSetRoot( wszLocalVolumesSection );

    if (!NT_SUCCESS(Status)) {

        DebugTrace(-1, Dbg, "DfsDeleteLvolInfo - Error %08lx opening local volumes section\n", ULongToPtr( Status ));

        return(Status);
    }

    Status = KRegDeleteKey( wszLvolKey );

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

        Status = STATUS_SUCCESS;

    }

    KRegCloseRoot();

    DebugTrace(-1, Dbg, "DfsDeleteLvolInfo - Exiting %08lx\n", ULongToPtr( Status ));

    return( Status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsChangeLvolInfoServiceType
//
//  Synopsis:   Changes the service type associated with the local volume in
//              the registry.
//
//  Arguments:  [pguidLvol] -- pointer to guid of local volume.
//              [ulServiceType] -- new service type.
//
//  Returns:    NTSTATUS from registry api.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsChangeLvolInfoServiceType(
    IN GUID *pguidLvol,
    IN ULONG ulServiceType)
{
    NTSTATUS Status;
    WCHAR wszLvolKey[ 2 * sizeof(GUID) + 1 ];

    Status = KRegSetRoot( wszLocalVolumesSection );

    if (!NT_SUCCESS(Status)) {

        return( Status );

    }

    GuidToString(pguidLvol, wszLvolKey);

    Status = KRegSetValue(
                wszLvolKey,
                wszServiceType,
                REG_DWORD,
                sizeof(ULONG),
                (PBYTE) &ulServiceType);

    KRegCloseRoot();

    return( Status );

}


//+----------------------------------------------------------------------------
//
//  Function:  DfsChangeLvolInfoEntryPath
//
//  Synopsis:  Changes the entry path associated with the local volume in the
//             registry.
//
//  Arguments: [pguidLvol] -- pointer to guid of local volume.
//             [pustrEntryPath] -- new entry path.
//
//  Returns:   NTSTATUS from registry api.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsChangeLvolInfoEntryPath(
    IN GUID *pguidLvol,
    IN PUNICODE_STRING pustrEntryPath)
{
    NTSTATUS Status;
    WCHAR wszLvolKey[ 2 * sizeof(GUID) + 1 ];

    Status = KRegSetRoot( wszLocalVolumesSection );

    if (!NT_SUCCESS(Status)) {

        return( Status );

    }

    GuidToString(pguidLvol, wszLvolKey);

    Status = DfspSavePrefix(
                wszLvolKey,
                wszEntryPath,
                pustrEntryPath);

    KRegCloseRoot();

    return( Status );

}

//+----------------------------------------------------------------------------
//
//  Function:  DfsCreateExitPointInfo
//
//  Synopsis:  Adds a single exit point to the local volume information in
//             the registry.
//
//  Arguments: [pguidLvol] -- pointer to guid of local volume.
//             [pidExitPoint] -- pointer to PKT_ENTRY_ID of exit point.
//
//  Returns:   NTSTATUS from registry manipulation.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsCreateExitPointInfo(
    IN GUID *pguidLvol,
    IN PDFS_PKT_ENTRY_ID pidExitPoint)
{
    NTSTATUS Status = STATUS_SUCCESS;
    WCHAR wszLvolKey[ 2 * sizeof(GUID) + 1 ];

    DebugTrace(+1, Dbg, "DfsCreateExitPointInfo - Entered\n", 0);

    //
    // Stop storing exit point information in the SYSTEM part of
    // the registry. (380845).
    //

#if 0
    Status = KRegSetRoot( wszLocalVolumesSection );

    if (!NT_SUCCESS(Status)) {

        DebugTrace(-1, Dbg, "DfsCreateExitPointInfo - exiting %08lx\n", Status);

        return(Status);

    }

    GuidToString( pguidLvol, wszLvolKey );

    Status = DfspAddSubordinateId( wszLvolKey, pidExitPoint );

    KRegCloseRoot();
#endif

    DebugTrace(-1, Dbg, "DfsCreateExitPointInfo - Exited %08lx\n", ULongToPtr( Status ));

    return( Status );

}

//+----------------------------------------------------------------------------
//
//  Function:  DfsDeleteExitPointInfo
//
//  Synopsis:  Deletes an exit point info from the registry.
//
//  Arguments: [pguidLvol] -- pointer to guid of local volume.
//             [pguidExitPoint] -- pointer to guid of exit point.
//
//  Returns:   NTSTATUS from registry api.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsDeleteExitPointInfo(
    IN GUID *pguidLvol,
    IN GUID *pguidExitPoint)
{
    NTSTATUS Status = STATUS_SUCCESS;
    WCHAR wszExitPointKey[ 2 * sizeof(GUID) +    // for Local volume guid
                           1 +                   // for UNICODE_PATH_SEP
                           2 * sizeof(GUID) +    // for exit point guid
                           1 ];                  // for UNICODE_NULL

    DebugTrace(+1, Dbg, "DfsDeleteExitPointInfo: Entered\n", 0);

    //
    // Stop storing exit point information in the SYSTEM part of
    // the registry. (380845).
    //

#if 0

    Status = KRegSetRoot( wszLocalVolumesSection );

    if (!NT_SUCCESS(Status)) {

        DebugTrace(-1, Dbg, "DfsDeleteExitPointInfo: Exiting %08lx\n", Status);

        return( Status );

    }

    GuidToString( pguidLvol, wszExitPointKey );

    wszExitPointKey[ 2 * sizeof(GUID) ] = UNICODE_PATH_SEP;

    GuidToString( pguidExitPoint, &wszExitPointKey[2*sizeof(GUID) + 1]  );

    DebugTrace(0, Dbg, "Attempting to delete subkey %ws\n", wszExitPointKey);

    Status = KRegDeleteKey( wszExitPointKey );

    KRegCloseRoot();

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        Status = STATUS_SUCCESS;
    }

#endif

    DebugTrace(-1, Dbg, "DfsDeleteExitPointInfo: Exiting %08lx\n", ULongToPtr( Status ));

    return( Status );
}

//+----------------------------------------------------------------------------
//
//  Function:  DfspAddSubordinateId
//
//  Synopsis:  Adds a single exit point info to a local volume entry in the
//             registry.
//
//  Arguments: [wszLvolKey] -- The local volume key under which to add info.
//             [pId] -- The info to add.
//
//  Returns:   NT Status from adding the info.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspAddSubordinateId(
    IN PWSTR wszLvolKey,
    IN PDFS_PKT_ENTRY_ID pId)
{
    NTSTATUS Status;
    WCHAR wszExitPoint[ 2 * sizeof(GUID) + 1 ];
    WCHAR wszExitPointKey[ 2 * sizeof(GUID) +
                           sizeof(UNICODE_PATH_SEP_STR) +
                           2 * sizeof(GUID) +
                           sizeof(UNICODE_NULL) ];

    GuidToString( &pId->Uid, wszExitPoint );

    DebugTrace(0, Dbg, "Adding exit point key %ws\n", wszExitPoint);

    Status = KRegCreateKey(wszLvolKey, wszExitPoint);

    if (!NT_SUCCESS(Status)) {

        DebugTrace(0, Dbg, "Error adding exit pt key %08lx\n", ULongToPtr( Status ));

        return(Status);

    }

    //
    // Now, add the entry path for the exit point as a value to the
    // new key.
    //

    wcscpy(wszExitPointKey, wszLvolKey);
    wcscat(wszExitPointKey, UNICODE_PATH_SEP_STR);
    wcscat(wszExitPointKey, wszExitPoint);

    DebugTrace(0, Dbg, "Subkey name is %ws\n", wszExitPointKey);

    DebugTrace(0, Dbg, "Prefix is %wZ\n", &pId->Prefix);

    Status = DfspSavePrefix(
                wszExitPointKey,
                wszEntryPath,
                &pId->Prefix);

    if (!NT_SUCCESS(Status)) {

        KRegDeleteKey(wszExitPointKey);

    }

    return(Status);
}

//+----------------------------------------------------------------------------
//
//  Function:   DfspReadPrefix
//
//  Synopsis:   Reads a prefix from the registry, given the registry key and
//              value name. To handle machine renames, the first component
//              of the prefix is matched against the current computer name.
//              If the two are different, indicating a computer name change,
//              the prefix is updated.
//
//  Arguments:  [wszKey] -- Name of key (relative to current root)
//              [wszValue] -- Name of value to read prefix from
//              [pustrPrefix] -- On successful return, the prefix is returned
//                      here.
//
//  Returns:    [STATUS_SUCCESS] -- If successfully retrieved prefix.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Unable to allocate memory
//
//              [STATUS_INTERNAL_DB_CORRUPTION] -- The retrieved value did
//                      not look like a prefix.
//
//              Status from reading the registry value
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspReadPrefix(
    IN PWSTR wszKey,
    IN PWSTR wszValue,
    OUT PUNICODE_STRING pustrPrefix)
{
    NTSTATUS Status;
    PWSTR wszCurrentPrefix = NULL;
    ULONG cbPrefix, cwCurrentPrefix, i;
    UNICODE_STRING ustrComputerName;

    Status = KRegGetValue(
                wszKey,
                wszValue,
                (LPBYTE *)&wszCurrentPrefix );

    //
    // If successfully read in the prefix, do some elementary syntax checking
    //

    if (NT_SUCCESS(Status)) {

        cwCurrentPrefix = wcslen(wszCurrentPrefix);

        cbPrefix = cwCurrentPrefix * sizeof(WCHAR);

        //
        // Must be atleast \a\b
        //

        if ((cwCurrentPrefix < 4) ||
                (wszCurrentPrefix[0] != UNICODE_PATH_SEP)) {

            Status = STATUS_INTERNAL_DB_CORRUPTION;

        }

    }

    //
    // Compute the first component of the prefix
    //

    if (NT_SUCCESS(Status)) {

        ustrComputerName.Buffer = &wszCurrentPrefix[1];

        for (i = 1;
                (i < cwCurrentPrefix) &&
                    (wszCurrentPrefix[i] != UNICODE_PATH_SEP);
                        i++) {

            NOTHING;

        }

        if (i != cwCurrentPrefix) {

            ustrComputerName.Length = (USHORT) ((i-1) * sizeof(WCHAR));

            ustrComputerName.MaximumLength = ustrComputerName.Length;

        } else {

            Status = STATUS_INTERNAL_DB_CORRUPTION;

        }

    }

    if (NT_SUCCESS(Status)) {

        pustrPrefix->Buffer = wszCurrentPrefix;
        pustrPrefix->Length = (USHORT) cbPrefix;
        pustrPrefix->MaximumLength = (USHORT)cbPrefix + sizeof(UNICODE_NULL);

    } else {

        if (wszCurrentPrefix != NULL)
            kreg_free( wszCurrentPrefix );

    }

    return( Status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspSavePrefix
//
//  Synopsis:   Saves a prefix to the registry.
//
//  Arguments:  [wszKey] -- Name of key (relative to current root)
//              [wszValue] -- Name of value to save prefix to.
//              [pustrPrefix] -- The prefix to store.
//
//  Returns:    Status from registry operation
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspSavePrefix(
    IN PWSTR wszKey,
    IN PWSTR wszValue,
    IN PUNICODE_STRING pustrPrefix)
{
    NTSTATUS Status;

    Status = KRegSetValue(
                wszKey,
                wszValue,
                REG_SZ,
                pustrPrefix->Length,
                (LPBYTE) pustrPrefix->Buffer);

    return( Status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspUpgradePrefix
//
//  Synopsis:   If a machine rename has occured since the last time a prefix
//              was updated, this routine will upgrade the first component
//              of the prefix to match the computer name.
//
//  Arguments:  [wszKey] -- Name of key (relative to current root)
//              [wszValue] -- Name of value to save updated prefix to.
//              [cbComputerName] -- size, in bytes, of the first component of
//                      the input prefix.
//              [pcbPrefix] -- On entry, size in bytes of the input prefix.
//                      On return, size in bytes of the new prefix. Neither
//                      sizes includes the terminating NULL.
//              [pwszPrefix] -- On entry, the prefix as it currently exists in
//                      the registry. On return, points to a new block of
//                      memory that has the new prefix.
//
//  Returns:    [STATUS_SUCCESS] -- Successfully updated prefix.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory condition
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspUpgradePrefix(
    IN PWSTR wszKey,
    IN PWSTR wszValue,
    IN USHORT cbComputerName,
    IN PULONG pcbPrefix,
    IN OUT PWSTR *pwszPrefix)
{
    NTSTATUS Status;
    ULONG cbPrefix;
    PWSTR wszCurrentPrefix, wszNewPrefix;

    wszCurrentPrefix = *pwszPrefix;

    cbPrefix = (*pcbPrefix) -
                cbComputerName +
                DfsData.NetBIOSName.Length;

    wszNewPrefix = (PWSTR) kreg_alloc( cbPrefix + sizeof(UNICODE_NULL) );

    if (wszNewPrefix != NULL) {

        wszNewPrefix[0] = UNICODE_PATH_SEP;

        RtlCopyMemory(
            &wszNewPrefix[1],
            DfsData.NetBIOSName.Buffer,
            DfsData.NetBIOSName.Length);

        RtlCopyMemory(
            &wszNewPrefix[ DfsData.NetBIOSName.Length/sizeof(WCHAR) + 1],
            &wszCurrentPrefix[ cbComputerName/sizeof(WCHAR) + 1 ],
            (*pcbPrefix) - cbComputerName);

        *pcbPrefix = cbPrefix;

        *pwszPrefix = wszNewPrefix;

        kreg_free( wszCurrentPrefix );

        //
        // We try to update the prefix in the registry. Failure to do so is
        // ok, we'll just try again next time we try to read it.
        //

        (VOID) KRegSetValue(
                    wszKey,
                    wszValue,
                    REG_SZ,
                    cbPrefix,
                    (LPBYTE) wszNewPrefix);

        Status = STATUS_SUCCESS;

    } else {

        Status = STATUS_INSUFFICIENT_RESOURCES;

    }

    return( Status );

}

//+----------------------------------------------------------------------------
//
//  Function:   GuidToString
//
//  Synopsis:   Converts a GUID to a 32 char wchar null terminated string.
//
//  Arguments:  [pGuid] -- Pointer to Guid structure.
//              [pwszGuid] -- wchar buffer into which to put the string
//                         representation of the GUID. Must be atleast
//                         2 * sizeof(GUID) + 1 long.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

const WCHAR rgwchHexDigits[] = L"0123456789ABCDEF";

VOID GuidToString(
    IN GUID   *pGuid,
    OUT PWSTR pwszGuid)
{
    PBYTE pbBuffer = (PBYTE) pGuid;
    USHORT i;

    for(i = 0; i < sizeof(GUID); i++) {
        pwszGuid[2 * i] = rgwchHexDigits[(pbBuffer[i] >> 4) & 0xF];
        pwszGuid[2 * i + 1] = rgwchHexDigits[pbBuffer[i] & 0xF];
    }
    pwszGuid[2 * i] = UNICODE_NULL;
}

//+----------------------------------------------------------------------------
//
//  Function:   StringToGuid
//
//  Synopsis:   Converts a 32 wchar null terminated string to a GUID.
//
//  Arguments:  [pwszGuid] -- the string to convert
//              [pGuid] -- Pointer to destination GUID.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

#define HEX_DIGIT_TO_INT(d, i)                          \
    ASSERT(((d) >= L'0' && (d) <= L'9') ||              \
           ((d) >= L'A' && (d) <= L'F'));               \
    if ((d) <= L'9') {                                  \
        i = (d) - L'0';                                 \
    } else {                                            \
        i = (d) - L'A' + 10;                            \
    }

VOID StringToGuid(
    IN PWSTR pwszGuid,
    OUT GUID *pGuid)
{
    PBYTE pbBuffer = (PBYTE) pGuid;
    USHORT i, n;

    for (i = 0; i < sizeof(GUID); i++) {
        HEX_DIGIT_TO_INT(pwszGuid[2 * i], n);
        pbBuffer[i] = n << 4;
        HEX_DIGIT_TO_INT(pwszGuid[2 * i + 1], n);
        pbBuffer[i] |= n;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\log.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       log.c
//
//  Contents:   Module to log messages from the driver to the NT event logging
//              system.
//
//  Classes:
//
//  Functions:  LogWriteMessage()
//
//  History:    3/30/93         Milans created
//              04/18/93        SudK    modified to use a MessageFile. and some
//                                      cleanup to the function below.
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"

#define Dbg             DEBUG_TRACE_EVENTLOG


VOID LogpPutString(
    IN PUNICODE_STRING pustrString,
    IN OUT PCHAR *ppStringBuffer,
    IN OUT UCHAR *pcbBuffer);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, LogWriteMessage )
#pragma alloc_text( PAGE, LogpPutString )
#endif // ALLOC_PRAGMA



//+----------------------------------------------------------------------------
//
//  Function:   LogWriteMessage
//
//  Synopsis:   Logs a message to the NT event logging system.
//
//  Arguments:  [UniqueErrCode] -- The code that identifes the message.
//              [NtStatusCode] --  Status code from some error.
//              [nStrings]      -- Number of strings being passed in.
//              [pustrArg]      -- The Array of insertion strings.
//
//  Returns:    Nothing at all.
//
//  History:    04/18/93        SudK    Created.
//
//-----------------------------------------------------------------------------
VOID LogWriteMessage(
        IN ULONG        UniqueErrorCode,
        IN NTSTATUS     NtStatusCode,
        IN ULONG        nStrings,
        IN PUNICODE_STRING pustrArg OPTIONAL)
{
    PIO_ERROR_LOG_PACKET pErrorLog;
    UCHAR                cbSize;
    UCHAR                *pStringBuffer;
    ULONG                i;

    //
    // Compute the size of the Error Log Packet that we need to start with.
    //
    cbSize = sizeof(IO_ERROR_LOG_PACKET);

    for (i = 0; i < nStrings; i++)  {
        cbSize = (UCHAR)(cbSize + pustrArg[i].Length + sizeof(WCHAR));
    }

    if (cbSize > ERROR_LOG_MAXIMUM_SIZE) {
        cbSize = ERROR_LOG_MAXIMUM_SIZE;
    }

    pErrorLog = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(
                                            DfsData.DriverObject,
                                            cbSize);
    if (!pErrorLog) {

        //
        // Well, I guess we won't be logging this one.
        //

        return;
    }

    //
    // Zero out all fields, then set the ones we want.
    //

    RtlZeroMemory((PVOID) pErrorLog, sizeof(IO_ERROR_LOG_PACKET));
    pErrorLog->FinalStatus = NtStatusCode;
    pErrorLog->ErrorCode = UniqueErrorCode;
    pErrorLog->NumberOfStrings = (USHORT) nStrings;

    pErrorLog->StringOffset = sizeof(IO_ERROR_LOG_PACKET);
    pStringBuffer = ((PCHAR) pErrorLog) + sizeof(IO_ERROR_LOG_PACKET);

    //
    // Copy the strings into the buffer, making sure we truncate if and when
    // we need to.
    //

    cbSize -= sizeof(IO_ERROR_LOG_PACKET);

    for (i = 0; i < nStrings; i++)  {
        LogpPutString(&pustrArg[i], &pStringBuffer, &cbSize);
    }

    //
    // And finally, write out the log
    //

    IoWriteErrorLogEntry(pErrorLog);

}


//+----------------------------------------------------------------------------
//
//  Function:   LogpPutString
//
//  Synopsis:   Copies a string into the buffer part of an IO_ERROR_LOG_PACKET.
//              Takes care of truncating if the whole string won't fit.
//
//  Arguments:  [pustrString] -- Pointer to unicode string to copy.
//              [ppStringBuffer] -- On input, pointer to beginning of buffer
//                               to copy to. On exit, will point one past the
//                               end of the copied string.
//              [pcbBuffer] -- On input, max size of buffer. On output,
//                               remaining size after string has been copied.
//
//  Returns:    Nothing
//
//  History:    04/18/93        SudK    Created.
//
//-----------------------------------------------------------------------------

VOID LogpPutString(
    IN PUNICODE_STRING pustrString,
    IN OUT PCHAR *ppStringBuffer,
    IN OUT UCHAR *pcbBuffer)
{
    ULONG       len;
    PWCHAR      pwch;

    if ((*pcbBuffer == 0) || (pustrString->Length == 0))        {
        return;
    }

    if ( *pcbBuffer >= (pustrString->Length + sizeof(WCHAR)) ) {
        RtlMoveMemory(*ppStringBuffer, pustrString->Buffer, pustrString->Length);
        (*pcbBuffer) -= pustrString->Length;
        (*ppStringBuffer) += pustrString->Length;

    } else {
        RtlMoveMemory(*ppStringBuffer, pustrString->Buffer, (*pcbBuffer)-sizeof(WCHAR));
        *pcbBuffer = sizeof(WCHAR);
        (*ppStringBuffer) += (*pcbBuffer - sizeof(WCHAR));
    }

    //
    // Null Terminate the String Now if necessary.
    //
    if (*((PWCHAR) *ppStringBuffer - 1) != L'\0')       {
        *((PWCHAR) *ppStringBuffer) = L'\0';
        *ppStringBuffer += sizeof(WCHAR);
        (*pcbBuffer) -= sizeof(WCHAR);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\lvolinit.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       lvolinit.c
//
//  Contents:   Routines to initialize Local volumes
//
//  Classes:
//
//  Functions:
//
//  History:    April 27, 1994          Milans Created
//
//-----------------------------------------------------------------------------


#include "dfsprocs.h"
#include "regkeys.h"
#include "registry.h"
#include "lvolinit.h"


#define Dbg             DEBUG_TRACE_INIT

NTSTATUS
GetRegVolumes(
   OUT PULONG pcLocalVols,
   OUT APWSTR *pawstr
   );


//+----------------------------------------------------------------------------
//
//  Function:   DfsInitLocalPartitions
//
//  Synopsis:   Initializes the local volumes that are shared in the Dfs
//              name space by reading the list of shared folders from the
//              registry and creating the appropriate Pkt Entries for them.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsInitLocalPartitions()
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG    cLocalVols;
    APWSTR   awstrLocalVols = NULL;
    PDFS_PKT pkt;
    ULONG i;
    BOOLEAN  fErrorsFound = FALSE;

    DebugTrace(+1, Dbg, "DfsInitLocalPartitions: Entered\n", 0);

    //
    // Initializing the local volumes might cause some of the underlying
    // storage volumes to get mounted. We need to set the LvState to
    // prevent a deadlock in DfsReattachToMountedVolume. It is important
    // that we set the LvState before we acquire the Pkt and after we
    // release it.
    //

    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    DfsData.LvState = LV_INITINPROGRESS;

    ExReleaseResourceLite( &DfsData.Resource );

    pkt = _GetPkt();

    status = GetRegVolumes(&cLocalVols, &awstrLocalVols);

    if (!NT_SUCCESS(status)) {
        DebugTrace(-1, Dbg, "DfsInitLocalPartitions: Unable to get volume list %08lx\n", ULongToPtr( status ));
        return;
    }

    DebugTrace(0, Dbg, "Retrieved %d local volumes\n", ULongToPtr( cLocalVols ));

    if (cLocalVols == 0) {
        DebugTrace(-1, Dbg, "DfsInitLocalPartitions: No local volumes!\n", 0);
        DfsData.LvState = LV_INITIALIZED;
        if (awstrLocalVols != NULL) {
            KRegFreeArray(cLocalVols, (APBYTE) awstrLocalVols);
        }
        return;
    }


    //
    // Now we acquire the Pkt and for every volume attempt to initialize
    // any partitions we may find.
    //

    PktAcquireExclusive(pkt, TRUE);

    for (i = 0; i < cLocalVols; i++) {

        DFS_LOCAL_VOLUME_CONFIG ConfigInfo;
        UNICODE_STRING ustrStorageId;

        DebugTrace(0, Dbg, "Reading info for [%ws]\n", awstrLocalVols[i]);
        RtlZeroMemory(&ConfigInfo, sizeof(DFS_LOCAL_VOLUME_CONFIG));
        RtlZeroMemory(&ustrStorageId, sizeof(UNICODE_STRING));

        //
        // Retrieve the local volume config info from the registry.
        //

        status = DfsGetLvolInfo(awstrLocalVols[i], &ConfigInfo, &ustrStorageId);

        if (!NT_SUCCESS(status)) {
            DebugTrace(0, Dbg, "Error %08lx getting info from registry!\n", ULongToPtr( status ));
            continue;
        }

        //
        // Ok, we have a valid local volume config structure so we need to go
        // and ask the Pkt to initialize the local partition.
        //

        status = PktInitializeLocalPartition(pkt, &ustrStorageId, &ConfigInfo);

        fErrorsFound = (BOOLEAN) (!NT_SUCCESS(status)) || fErrorsFound;

        DebugTrace(0, Dbg, "PktInitializeLocalPartition status %08lx\n", ULongToPtr( status ));

        //
        // Get rid of the memory used by the ConfigInfo structures.
        //

        if (ustrStorageId.Buffer != NULL)
            ExFreePool(ustrStorageId.Buffer);
        if (ConfigInfo.StgId.Buffer != NULL)
            ExFreePool(ConfigInfo.StgId.Buffer);
        if (ConfigInfo.Share.Buffer != NULL)
            ExFreePool(ConfigInfo.Share.Buffer);
        PktRelationInfoDestroy(&ConfigInfo.RelationInfo, FALSE );

    }

    //
    // Done. Release locks, cleanup, and vamoose.
    //

    if (awstrLocalVols != NULL) {
        KRegFreeArray(cLocalVols, (APBYTE) awstrLocalVols);
    }

    PktRelease(pkt);

    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    DfsData.LvState = (fErrorsFound ? LV_UNINITIALIZED : LV_INITIALIZED);

    ExReleaseResourceLite( &DfsData.Resource );

    DebugTrace(-1, Dbg, "DfsInitLocalPartitions: Exited %08lx\n", ULongToPtr( status ));
}


//+----------------------------------------------------------------------------
//
//  Function:  GetRegVolumes
//
//  Synopsis:  Read the local volume list from the
//             Registry\Machine\System\CurrentControlSet\Dfs\Localvolumes
//             section of the registry.
//
//  Arguments:
//
//  Returns:   STATUS_SUCCESS or reason for failure.
//
//-----------------------------------------------------------------------------

NTSTATUS
GetRegVolumes(
    OUT PULONG pcLocalVols,
    OUT APWSTR *pawstr
   )
{
    NTSTATUS    Status;
    PWSTR       wszMachineRoot = NULL;

    Status = KRegSetRoot( wszLocalVolumesSection );
    if (!NT_SUCCESS(Status)) {
        DebugTrace(0, Dbg, "GetRegVolumes: Error opening registry %08lx\n", ULongToPtr( Status ));
        return(Status);
    }

    Status = KRegEnumSubKeySet(
               L"",
               pcLocalVols,
               pawstr);


    KRegCloseRoot();

    DebugTrace(0, Dbg, "GetRegVolumes: Returning %08lx\n", ULongToPtr( Status ));

    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\lvolinit.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       lvolinit.h
//
//  Contents:   Local volumes initialization - Function headers
//
//  Classes:
//
//  Functions:  DfsInitLocalPartitions
//              DfsValidateLocalPartitions
//
//  History:    April 27, 1994          Milans created
//
//-----------------------------------------------------------------------------

#ifndef _LVOLINIT_
#define _LVOLINIT_

VOID
DfsInitLocalPartitions();

VOID
DfsValidateLocalPartitions(
    IN PVOID Context);

#endif // _LVOLINIT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\makefile.inc ===
..\h\dfsevent.h msg00001.bin: dfsevent.mc
    mc -v -r . -h ..\h\ dfsevent.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\lvolinfo.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       lvolinfo.h
//
//  Contents:   Functions to store and retrieve local volume info in the
//              registry.
//
//  Classes:    None
//
//  Functions:  DfsStoreLvolInfo
//              DfsGetLvolInfo
//
//  History:    August 16, 1994         Milans created
//
//-----------------------------------------------------------------------------

#ifndef _LVOLINFO_
#define _LVOLINFO_

NTSTATUS
DfsStoreLvolInfo(
    IN PDFS_LOCAL_VOLUME_CONFIG pConfigInfo,
    IN PUNICODE_STRING pustrStorageId);

NTSTATUS
DfsGetLvolInfo(
    IN PWSTR pwszGuid,
    OUT PDFS_LOCAL_VOLUME_CONFIG pConfigInfo,
    OUT PUNICODE_STRING pustrStorageId);

NTSTATUS
DfsDeleteLvolInfo(
    IN GUID *pguidLvol);

NTSTATUS
DfsChangeLvolInfoServiceType(
    IN GUID *pguidLvol,
    IN ULONG ulServiceType);

NTSTATUS
DfsChangeLvolInfoEntryPath(
    IN GUID *pguidLvol,
    IN PUNICODE_STRING pustrEntryPath);

NTSTATUS
DfsCreateExitPointInfo(
    IN GUID *pguidLvol,
    IN PDFS_PKT_ENTRY_ID pidExitPoint);

NTSTATUS
DfsDeleteExitPointInfo(
    IN GUID *pguidLvol,
    IN GUID *pguidExitPoint);

#endif // _LVOLINFO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\minfo.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:   MInfo.C
//
//  Contents:
//
//  Functions:
//
//  History:
//
//-----------------------------------------------------------------------------

#ifdef KERNEL_MODE
#include "dfsprocs.h"
#endif

INIT_TADDRESS_MARSHAL_INFO()
INIT_DS_TRANSPORT_P_MARSHAL_INFO()
INIT_DS_TRANSPORT_MARSHAL_INFO()
INIT_DS_MACHINE_P_MARSHAL_INFO()
INIT_DS_MACHINE_MARSHAL_INFO()
INIT_DS_GLUON_MARSHAL_INFO()
INIT_DS_GLUON_P_MARSHAL_INFO()

INIT_DFS_MACHINE_ENTRY_MARSHAL_INFO()
INIT_DFS_SERVICE_MARSHAL_INFO()
INIT_DFS_PKT_ENTRY_ID_MARSHAL_INFO()
INIT_DFS_PKT_ENTRY_INFO_MARSHAL_INFO()
INIT_DFS_PKT_ENTRY_MARSHAL_INFO()
INIT_LOCAL_VOLUME_CONFIG_MARSHAL_INFO()
INIT_DFS_PKT_RELATION_INFO_MARSHAL_INFO()
INIT_DFS_PKT_CREATE_ENTRY_ARG_MARSHAL_INFO()
INIT_DFS_PKT_CREATE_SUBORDINATE_ENTRY_ARG_MARSHAL_INFO()
INIT_DFS_CHECK_VOLUME_ARG_MARSHAL_INFO()
INIT_DFS_DC_SET_SERVICE_STATE_MARSHAL_INFO()
INIT_DFS_VOLUME_VERIFY_ARG_MARSHAL_INFO()
INIT_DFS_EXIT_POINT_ARG_MARSHAL_INFO()
INIT_DFS_SET_VOLUME_TIMEOUT_ARG_MARSHAL_INFO()
INIT_DFS_HANDLE_SERVER_INFO_MARSHAL_INFO()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\pkt.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       PKT.C
//
//  Contents:   This module implements the Partition Knowledge Table routines
//              for the Dfs driver.
//
//  Functions:  PktInitialize -
//              PktInitializeLocalPartition -
//              RemoveLastComponent -
//              PktCreateEntry -
//              PktCreateSubordinateEntry -
//              PktLookupEntryById -
//              PktEntryModifyPrefix -
//              PktLookupEntryByPrefix -
//              PktLookupEntryByUid -
//              PktLookupReferralEntry -
//              PktSetRelationInfo -
//              PktTrimSubordinates -
//              PktpAddEntry -
//
//  History:     5 May 1992 PeterCo Created.
//
//-----------------------------------------------------------------------------


#include "dfsprocs.h"

#include <netevent.h>
#include <smbtypes.h>
#include <smbtrans.h>

#include "attach.h"
#include "log.h"
#include "know.h"

#define Dbg              (DEBUG_TRACE_PKT)

//
//  Local procedure prototypes
//

NTSTATUS
PktInitializeLocalPartition(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING LocalVolumeName,
    IN  PDFS_LOCAL_VOLUME_CONFIG ConfigInfo);

NTSTATUS
PktpAddEntry (
    IN PDFS_PKT Pkt,
    IN PUNICODE_STRING Prefix,
    IN PRESP_GET_DFS_REFERRAL ReferralBuffer,
    IN ULONG CreateDisposition,
    OUT PDFS_PKT_ENTRY  *ppPktEntry);

VOID
PktShuffleServiceList(
    PDFS_PKT_ENTRY_INFO pInfo);

VOID
PktShuffleGroup(
    PDFS_PKT_ENTRY_INFO pInfo,
    ULONG       nStart,
    ULONG       nEnd);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, PktInitialize )

#pragma alloc_text( PAGE, PktUninitialize )
#pragma alloc_text( PAGE, PktInitializeLocalPartition )
#pragma alloc_text( PAGE, RemoveLastComponent )
#pragma alloc_text( PAGE, PktCreateEntry )
#pragma alloc_text( PAGE, PktCreateSubordinateEntry )
#pragma alloc_text( PAGE, PktLookupEntryById )
#pragma alloc_text( PAGE, PktEntryModifyPrefix )
#pragma alloc_text( PAGE, PktLookupEntryByPrefix )
#pragma alloc_text( PAGE, PktLookupEntryByUid )
#pragma alloc_text( PAGE, PktSetRelationInfo )
#pragma alloc_text( PAGE, PktTrimSubordinates )
#pragma alloc_text( PAGE, PktpAddEntry )
#endif // ALLOC_PRAGMA

//
// declare the global null guid
//
GUID _TheNullGuid;



//+-------------------------------------------------------------------------
//
//  Function:   PktInitialize, public
//
//  Synopsis:   PktInitialize initializes the partition knowledge table.
//
//  Arguments:  [Pkt] - pointer to an uninitialized PKT
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if no error.
//
//  Notes:      This routine is called only at driver init time.
//
//--------------------------------------------------------------------------

NTSTATUS
PktInitialize(
    IN  PDFS_PKT Pkt
) {
    DebugTrace(+1, Dbg, "PktInitialize: Entered\n", 0);

    //
    // initialize the NULL GUID.
    //
    RtlZeroMemory(&_TheNullGuid, sizeof(GUID));

    //
    // Always zero the pkt first
    //
    RtlZeroMemory(Pkt, sizeof(DFS_PKT));

    //
    // do basic initialization
    //
    Pkt->NodeTypeCode = DFS_NTC_PKT;
    Pkt->NodeByteSize = sizeof(DFS_PKT);
    ExInitializeResourceLite(&Pkt->Resource);
    InitializeListHead(&Pkt->EntryList);
    DfsInitializeUnicodePrefix(&Pkt->LocalVolTable);
    DfsInitializeUnicodePrefix(&Pkt->PrefixTable);
    DfsInitializeUnicodePrefix(&Pkt->ShortPrefixTable);
    RtlInitializeUnicodePrefix(&Pkt->DSMachineTable);

    //
    //  We don't know anything about our domain yet, so we leave
    //  it NULL.  This will get initialized later to the right value!
    //

    Pkt->DomainPktEntry = NULL;

    DebugTrace(-1, Dbg, "PktInitialize: Exit -> VOID\n", 0 );
    return STATUS_SUCCESS;
}

VOID
PktUninitialize(
    IN  PDFS_PKT Pkt)
{
    DfsFreePrefixTable(&Pkt->LocalVolTable);
    DfsFreePrefixTable(&Pkt->PrefixTable);
    DfsFreePrefixTable(&Pkt->ShortPrefixTable);
    ExDeleteResourceLite(&Pkt->Resource);
}



//+-------------------------------------------------------------------------
//
//  Function:   PktInitializeLocalPartition, public
//
//  Synopsis:   PktInitializeLocalPartition initializes the Pkt entry
//              and its subordinates specified by the ConfigInfo structure
//              passed in.
//
//  Arguments:  [Pkt] - a pointer to an (exclusively) acquired Pkt.
//              [LocalVolumeName] - the name of the local volume.
//              [ConfigInfo] - the parameters specifying the local
//                  entry and all its exit points.
//
//  Returns:    [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory conditions
//
//              [DFS_STATUS_LOCAL_ENTRY] - creation of the entry would
//                  require the invalidation of a local entry or exit point.
//
//              [STATUS_INVALID_PARAMETER] - the Id specified for the
//                  new entry is invalid.
//
//  Note:       The ConfigInfo argument is stripped of all its Ids as a
//              by-product of this operation.
//
//              The Pkt needs to be acquired exclusively before calling this.
//
//--------------------------------------------------------------------------
NTSTATUS
PktInitializeLocalPartition(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING LocalVolumeName,
    IN  PDFS_LOCAL_VOLUME_CONFIG ConfigInfo
)
{
    NTSTATUS status;
    PDFS_PKT_ENTRY entry;
    DFS_PKT_ENTRY_ID entryId;
    PDFS_SERVICE localService;
    PDFS_PKT_RELATION_INFO relationInfo;
    PDFS_LOCAL_VOL_ENTRY localVolEntry;
    UNICODE_STRING LocalVolumeRelativeName;

    DebugTrace(+1, Dbg, "PktInitializeLocalPartition: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(Pkt) &&
           ARGUMENT_PRESENT(LocalVolumeName) &&
           ARGUMENT_PRESENT(ConfigInfo));

    //
    // Now we attempt to create a local service
    // structure for this Entry...so allocate some memory.
    //

    localService = (PDFS_SERVICE) ExAllocatePoolWithTag(PagedPool, sizeof(DFS_SERVICE), ' sfD');
    if (localService == NULL) {

        DebugTrace(0, Dbg,
            "PktInitializeLocalPartition: Cannot allocate local service!\n",0);
        DebugTrace(-1, Dbg, "PktInitializeLocalPartition: Exit -> %08lx\n",
            ULongToPtr( STATUS_INSUFFICIENT_RESOURCES ) );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    localVolEntry = (PDFS_LOCAL_VOL_ENTRY) ExAllocatePoolWithTag(
                                                PagedPool,
                                                sizeof(DFS_LOCAL_VOL_ENTRY),
                                                ' sfD');

    if (localVolEntry == NULL) {
        DebugTrace(0, Dbg,
            "PktInitializeLocalPartition: Cannot allocate local vol entry!\n",0);
        DebugTrace(-1, Dbg, "PktInitializeLocalPartition: Exit -> %08lx\n",
            ULongToPtr( STATUS_INSUFFICIENT_RESOURCES ) );

        ExFreePool(localService);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Construct the local service.  We need to first compute the
    //  break point between the volume device object name, and the
    //  local entry point within the volume, which will become the
    //  service's "address".
    //

    if (!(ConfigInfo->EntryType & PKT_ENTRY_TYPE_LEAFONLY)) {
        status = DfsGetAttachName(
                        LocalVolumeName,
                        &LocalVolumeRelativeName);
    } else {

        LocalVolumeRelativeName = *LocalVolumeName;

        status = STATUS_SUCCESS;

    }

    if (NT_SUCCESS(status)) {
        status = PktServiceConstruct(
                            localService,
                            ConfigInfo->ServiceType | DFS_SERVICE_TYPE_LOCAL,
                            PROV_STRIP_PREFIX,          
                            DFS_SERVICE_STATUS_VERIFIED,
                            PROV_ID_LOCAL_FS,
                            NULL,
                            &LocalVolumeRelativeName
                        );
    }

    if (!NT_SUCCESS(status)) {

        DebugTrace(0, Dbg,
            "PktInitializeLocalPartition: Cannot construct local service!\n",0);
        DebugTrace(-1, Dbg, "PktInitializeLocalPartition: Exit -> %08lx\n",
            ULongToPtr( status ) );

        ExFreePool(localService);
        ExFreePool(localVolEntry);

        return status;
    }

    //
    // Now we attempt to create/update the entry point entry.
    //

    //
    // Remember! the create strips the entry Id off! so we need to
    // duplicate the entry id info off the relation info structure
    // so that we can pass it into PktCreateEntry...
    //

    relationInfo = &ConfigInfo->RelationInfo;
    status = PktEntryIdConstruct(&entryId,
                        &relationInfo->EntryId.Uid,
                        &relationInfo->EntryId.Prefix,
                        &relationInfo->EntryId.ShortPrefix);

    DebugTrace(0, Dbg, "PktEntryIdConstruct returned 0x%x\n", ULongToPtr( status ));

    if (NT_SUCCESS(status)) {

        status = PktCreateEntry(
                    Pkt,
                    ConfigInfo->EntryType | PKT_ENTRY_TYPE_LOCAL | PKT_ENTRY_TYPE_PERMANENT,
                    &entryId,
                    NULL,
                    PKT_ENTRY_SUPERSEDE,
                    &entry);

        DebugTrace(0, Dbg, "PktCreateEntry returned 0x%x\n", ULongToPtr( status ));

    }

    if (NT_SUCCESS(status)) {

        PDFS_PKT_ENTRY subEntry;
        PDFS_PKT_ENTRY_ID subId;
        PDFS_PKT_ENTRY_ID lastSubId;

        //
        // We trim the subordinates off the entry that are not
        // included in the relation info.
        //

        PktTrimSubordinates(Pkt, entry, relationInfo);

        //
        // Go through and create/update all the subordinates.
        //

        subId = relationInfo->SubordinateIdList;
        lastSubId = &subId[ relationInfo->SubordinateIdCount ];

        for (subId = relationInfo->SubordinateIdList; subId < lastSubId; subId++) {

            PktCreateSubordinateEntry(
                    Pkt,
                    entry,
                    PKT_ENTRY_TYPE_LOCAL_XPOINT | PKT_ENTRY_TYPE_PERMANENT,
                    subId,
                    NULL,
                    PKT_ENTRY_SUPERSEDE,
                    &subEntry);

            DebugTrace(0, Dbg, "PktCreateSubordinateEntry returned 0x%x\n", ULongToPtr( status ));
        }

        if (NT_SUCCESS(status)) {

            //
            // We set the local service of this entry...
            //

            status = PktEntrySetLocalService(
                    Pkt,
                    entry,
                    localService,
                    localVolEntry,
                    LocalVolumeName,
                    &ConfigInfo->Share);

            DebugTrace(0, Dbg, "PktEntrySetLocalService returned 0x%x\n", ULongToPtr( status ));
        }

        if (NT_SUCCESS(status) &&
            !(entry->Type & PKT_ENTRY_TYPE_LEAFONLY)) {

            status = DfsAttachVolume(
                        LocalVolumeName,
                        &localService->pProvider);

            if (!NT_SUCCESS(status)) {

                PktEntryUnsetLocalService( Pkt, entry, LocalVolumeName );

                ExFreePool(localVolEntry);

            }

        }

        if (!NT_SUCCESS(status)) {

            //
            // We take somewhat draconian measures here.  We could
            // not complete the initialization so we basically
            // invalidate everything to do with this entry.
            //

            while ((subEntry = PktEntryFirstSubordinate(entry)) != NULL) {
                PktEntryDestroy(subEntry, Pkt, (BOOLEAN)TRUE);
            }

            PktEntryDestroy(entry, Pkt, (BOOLEAN)TRUE);
            //
            // We need to destroy this as well since it will not get destroyed
            // as part of above.
            //
            PktServiceDestroy(localService, (BOOLEAN)TRUE);

            DebugTrace(0, Dbg,
                "PktInitializeLocalPartition: Error creating subordinate!\n",0);
        }

    } else {

        //
        // we could not create the entry so we need to deallocate the
        // service we allocated.
        //

        PktEntryIdDestroy(&entryId, FALSE);
        PktServiceDestroy(localService, (BOOLEAN)TRUE);
        ExFreePool(localVolEntry);

        DebugTrace(0, Dbg,
            "PktInitializeLocalPartition: Cannot create entry!\n", 0);
    }

    if (NT_SUCCESS(status)) {

        if (localService->Type & DFS_SERVICE_TYPE_OFFLINE) {

            localService->ProviderId = localService->pProvider->eProviderId;

            status = DfspTakeVolumeOffline( Pkt, entry );

        }

    }

    DebugTrace(-1, Dbg, "PktInitializeLocalPartition: Exit -> %08lx\n",
        ULongToPtr( status ) );

    return status;

}


//+-------------------------------------------------------------------------
//
//  Function:   RemoveLastComponent, public
//
//  Synopsis:   Removes the last component of the string passed.
//
//  Arguments:  [Prefix] -- The prefix whose last component is to be returned.
//              [newPrefix] -- The new Prefix with the last component removed.
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if no error.
//
//  Notes:      On return, the newPrefix points to the same memory buffer
//              as Prefix.
//
//--------------------------------------------------------------------------

void
RemoveLastComponent(
    PUNICODE_STRING     Prefix,
    PUNICODE_STRING     newPrefix
)
{
    PWCHAR      pwch;
    USHORT      i=0;

    *newPrefix = *Prefix;

    pwch = newPrefix->Buffer;
    pwch += (Prefix->Length/sizeof(WCHAR)) - 1;

    while ((*pwch != UNICODE_PATH_SEP) && (pwch != newPrefix->Buffer))  {
        i += sizeof(WCHAR);
        pwch--;
    }

    newPrefix->Length = newPrefix->Length - i;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktCreateEntry, public
//
//  Synopsis:   PktCreateEntry creates a new partition table entry or
//              updates an existing one.  The PKT must be acquired
//              exclusively for this operation.
//
//  Arguments:  [Pkt] - pointer to an initialized (and exclusively acquired) PKT
//              [PktEntryType] - the type of entry to create/update.
//              [PktEntryId] - pointer to the Id of the entry to create
//              [PktEntryInfo] - pointer to the guts of the entry
//              [CreateDisposition] - specifies whether to overwrite if
//                  an entry already exists, etc.
//              [ppPktEntry] - the new entry is placed here.
//
//  Returns:    [STATUS_SUCCESS] - if all is well.
//
//              [DFS_STATUS_NO_SUCH_ENTRY] -  the create disposition was
//                  set to PKT_REPLACE_ENTRY and no entry of the specified
//                  Id exists to replace.
//
//              [DFS_STATUS_ENTRY_EXISTS] - a create disposition of
//                  PKT_CREATE_ENTRY was specified and an entry of the
//                  specified Id already exists.
//
//              [DFS_STATUS_LOCAL_ENTRY] - creation of the entry would
//                  required the invalidation of a local entry or exit point.
//
//              [STATUS_INVALID_PARAMETER] - the Id specified for the
//                  new entry is invalid.
//
//              [STATUS_INSUFFICIENT_RESOURCES] - not enough memory was
//                  available to complete the operation.
//
//  Notes:      The PktEntryId and PktEntryInfo structures are MOVED (not
//              COPIED) to the new entry.  The memory used for UNICODE_STRINGS
//              and DFS_SERVICE arrays is used by the new entry.  The
//              associated fields in the PktEntryId and PktEntryInfo
//              structures passed as arguments are Zero'd to indicate that
//              the memory has been "deallocated" from these strutures and
//              reallocated to the newly created PktEntry.  Note that this
//              routine does not deallocate the PktEntryId structure or
//              the PktEntryInfo structure itself. On successful return from
//              this function, the PktEntryId structure will be modified
//              to have a NULL Prefix entry, and the PktEntryInfo structure
//              will be modified to have zero services and a null ServiceList
//              entry.
//
//--------------------------------------------------------------------------
NTSTATUS
PktCreateEntry(
    IN  PDFS_PKT Pkt,
    IN  ULONG PktEntryType,
    IN  PDFS_PKT_ENTRY_ID PktEntryId,
    IN  PDFS_PKT_ENTRY_INFO PktEntryInfo OPTIONAL,
    IN  ULONG CreateDisposition,
    OUT PDFS_PKT_ENTRY *ppPktEntry
)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_PKT_ENTRY pfxMatchEntry = NULL;
    PDFS_PKT_ENTRY uidMatchEntry = NULL;
    PDFS_PKT_ENTRY entryToUpdate = NULL;
    PDFS_PKT_ENTRY entryToInvalidate = NULL;
    PDFS_PKT_ENTRY SupEntry = NULL;
    UNICODE_STRING remainingPath = {0, 0, NULL};
    UNICODE_STRING newRemainingPath;

    ASSERT(ARGUMENT_PRESENT(Pkt) &&
           ARGUMENT_PRESENT(PktEntryId) &&
           ARGUMENT_PRESENT(ppPktEntry));

    DebugTrace(+1, Dbg, "PktCreateEntry: Entered\n", 0);

    //
    // We're pessimistic at first...
    //

    *ppPktEntry = NULL;

    //
    // See if there exists an entry with this prefix.  The prefix
    // must match exactly (i.e. No remaining path).
    //

    pfxMatchEntry = PktLookupEntryByPrefix(Pkt,
                                           &PktEntryId->Prefix,
                                           &remainingPath);

    if ((remainingPath.Length > 0) || 
	(PktEntryId->Prefix.Length == 0)) {
        SupEntry = pfxMatchEntry;
        pfxMatchEntry = NULL;
    } else {
        UNICODE_STRING newPrefix;

        RemoveLastComponent(&PktEntryId->Prefix, &newPrefix);
        SupEntry = PktLookupEntryByPrefix(Pkt,
                                          &newPrefix,
                                          &newRemainingPath);
    }


    //
    // Now search for an entry that has the same Uid.
    //

    uidMatchEntry = PktLookupEntryByUid(Pkt, &PktEntryId->Uid);

    //
    // Now we must determine if during this create, we are going to be
    // updating or invalidating any existing entries.  If an existing
    // entry is found that has the same Uid as the one we are trying to
    // create, the entry becomes a target for "updating".  If the Uid
    // passed in is NULL, then we check to see if an entry exists that
    // has a NULL Uid AND a Prefix that matches.  If this is the case,
    // that entry becomes the target for "updating".
    //
    // To determine if there is an entry to invalidate, we look for an
    // entry with the same Prefix as the one we are trying to create, BUT,
    // which has a different Uid.  If we detect such a situation, we
    // we make the entry with the same Prefix the target for invalidation
    // (we do not allow two entries with the same Prefix, and we assume
    // that the new entry takes precedence).
    //

    if (uidMatchEntry != NULL) {

        entryToUpdate = uidMatchEntry;

        if (pfxMatchEntry != uidMatchEntry)
            entryToInvalidate = pfxMatchEntry;

    } else if ((pfxMatchEntry != NULL) &&
              NullGuid(&pfxMatchEntry->Id.Uid)) {

        entryToUpdate = pfxMatchEntry;

    } else {

        entryToInvalidate = pfxMatchEntry;

    }

    //
    // Now we check to make sure that our create disposition is
    // consistent with what we are about to do.
    //

    if ((CreateDisposition & PKT_ENTRY_CREATE) && entryToUpdate != NULL) {

        *ppPktEntry = entryToUpdate;

        status = DFS_STATUS_ENTRY_EXISTS;

    } else if ((CreateDisposition & PKT_ENTRY_REPLACE) && entryToUpdate==NULL) {

        status = DFS_STATUS_NO_SUCH_ENTRY;
    }

    //
    //  if we have an error here we can get out now!
    //

    if (!NT_SUCCESS(status)) {

        DebugTrace(-1, Dbg, "PktCreateEntry: Exit -> %08lx\n", ULongToPtr( status ) );
        return status;
    }

    //
    //  At this point, we have two possible entries - entryToUpdate and
    //  entryToInvalidate. We make an additional check to see if there is
    //  a conflict with an 8.3 prefix. This logic works according to the
    //  following table:
    //
    //  entryToUpdate | entryToInvalidate | 8.3 match ||   Action
    //                |                   |           ||
    //        0       |        0          |     0     || Create
    //                |                   |           ||
    //        1       |        0          |     0     || Update
    //                |                   |           ||
    //        0       |        1          |     0     || Invalidate/Create
    //                |                   |           ||
    //        1       |        1          |     0     || Invalidate/Update
    //                |                   |           ||
    //        0       |        0          |     1     || 8.3 name conflict
    //                |                   |           ||
    //        1       |        0          |     1     || In entryToUpdate is
    //                |                   |           ||   the 8.3 match, ok
    //        0       |        1          |     1     || If entryToInvalidate
    //                |                   |           ||   is the 8.3 match,
    //        1       |        1          |     1     ||   then invalidate,
    //                |                   |           || else 8.3 name conflict
    //

    if (PktEntryId->ShortPrefix.Length != 0) {

        PDFS_PKT_ENTRY shortpfxMatch;

        shortpfxMatch = PktLookupEntryByShortPrefix(
                            Pkt,
                            &PktEntryId->ShortPrefix,
                            &remainingPath);

        if (remainingPath.Length > 0)
            shortpfxMatch = NULL;

        if (shortpfxMatch != NULL) {

            if (entryToUpdate == NULL && entryToInvalidate == NULL) {

                status = STATUS_DUPLICATE_NAME;

            } else if (entryToUpdate != NULL && entryToInvalidate == NULL) {

                if (shortpfxMatch != entryToUpdate) {

                    status = STATUS_DUPLICATE_NAME;

                }

            } else if (entryToInvalidate != NULL) {

                if (shortpfxMatch != entryToInvalidate) {

                    status = STATUS_DUPLICATE_NAME;

                }

            }

        }

    }

    if (!NT_SUCCESS(status)) {

        DebugTrace(-1, Dbg,
            "PktCreateEntry: (Short name conflict) Exit -> %08lx\n", ULongToPtr( status ));
        return status;
    }

    //
    // At this point we must insure that we are not going to
    // be invalidating any local partition entries.
    //

    if ((entryToInvalidate != NULL) &&
        (!(entryToInvalidate->Type &  PKT_ENTRY_TYPE_OUTSIDE_MY_DOM) ) &&
        (entryToInvalidate->Type &
         (PKT_ENTRY_TYPE_LOCAL |
          PKT_ENTRY_TYPE_LOCAL_XPOINT |
          PKT_ENTRY_TYPE_PERMANENT))) {
        DebugTrace(-1, Dbg, "PktCreateEntry(1): Exit -> %08lx\n",
                    ULongToPtr( DFS_STATUS_LOCAL_ENTRY ) );
        return DFS_STATUS_LOCAL_ENTRY;
    }

    //
    // We go up the links till we reach a REFERRAL entry type. Actually
    // we may never go up since we always link to a REFERRAL entry. Anyway
    // no harm done!
    //

    while ((SupEntry != NULL) &&
           !(SupEntry->Type & PKT_ENTRY_TYPE_REFERRAL_SVC))  {
        SupEntry = SupEntry->ClosestDC;
    }

    //
    // If we had success then we need to see if we have to
    // invalidate an entry.
    //

    if (NT_SUCCESS(status) && entryToInvalidate != NULL)
        PktEntryDestroy(entryToInvalidate, Pkt, (BOOLEAN)TRUE);

    //
    // If we are not updating an entry we must construct a new one
    // from scratch.  Otherwise we need to update.
    //

    if (entryToUpdate != NULL) {

        status = PktEntryReassemble(entryToUpdate,
                                    Pkt,
                                    PktEntryType,
                                    PktEntryId,
                                    PktEntryInfo);

        if (NT_SUCCESS(status))  {
            (*ppPktEntry) = entryToUpdate;
            PktEntryLinkChild(SupEntry, entryToUpdate);
        }
    } else {

        //
        // Now we are going to create a new entry. So we have to set
        // the ClosestDC Entry pointer while creating this entry. The
        // ClosestDC entry value is already in SupEntry.
        //

        PDFS_PKT_ENTRY newEntry;

        newEntry = (PDFS_PKT_ENTRY) ExAllocatePoolWithTag(
                                           PagedPool,
                                           sizeof(DFS_PKT_ENTRY),
                                           ' sfD');
        if (newEntry == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            status = PktEntryAssemble(newEntry,
                                      Pkt,
                                      PktEntryType,
                                      PktEntryId,
                                      PktEntryInfo);
            if (!NT_SUCCESS(status)) {
                ExFreePool(newEntry);
            } else {
                (*ppPktEntry) = newEntry;
                PktEntryLinkChild(SupEntry, newEntry);
            }
        }
    }

    DebugTrace(-1, Dbg, "PktCreateEntry(2): Exit -> %08lx\n", ULongToPtr( status ));
    return status;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktCreateSubordinateEntry, public
//
//  Synopsis:   PktCreateSubordinateEntry creates/updates an entry to be
//              subordinate to an existing entry.
//
//  Arguments:  [Pkt] - pointer to a initialized (and acquired) PKT
//              [Superior] - a pointer to the superior entry.
//              [SubordinateType] - the type of subordinate entry to
//                  create/update.
//              [SubordinateId] - the Id of the entry to create/update
//                  to be subordinate.
//              [SubordinateInfo] - the Info of the entry to create/update.
//              [CreateDisposition] - identifies whether or not to supersede,
//                  create, or update.
//              [Subordinate] - the (potentially new) subordinate entry.
//
//  Returns:    [STATUS_SUCCESS] - if all is well.
//              [DFS_STATUS_NO_SUCH_ENTRY] -  the create disposition was
//                  set to PKT_REPLACE_ENTRY and the Subordinate entry does
//                  not exist.
//              [DFS_STATUS_ENTRY_EXISTS] - a create disposition of
//                  PKT_CREATE_ENTRY was specified and the subordinate entry
//                  already exists.
//              [DFS_STATUS_LOCAL_ENTRY] - creation of the subordinate entry
//                  would have required that a local entry or exit point
//                  be invalidated.
//              [DFS_STATUS_INCONSISTENT] - an inconsistency in the PKT
//                  has been discovered.
//              [STATUS_INVALID_PARAMETER] - the Id specified for the
//                  subordinate is invalid.
//              [STATUS_INSUFFICIENT_RESOURCES] - not enough memory was
//                  available to complete the operation.
//
//
//  Notes:      If the subordinate exists and is currently a subordinate
//              of some other entry (then the Superior specified), it is
//              first removed from the old superior before making it
//              a subordinate of the Superior specified.
//
//              The SubordinateId and SubordinateInfo structures are MOVED (not
//              COPIED) to the new entry.  The memory used for UNICODE_STRINGS
//              and DFS_SERVICE arrays is used by the new entry.  The
//              associated fields in the SubordinateId and SubordinateInfo
//              structures passed as arguments are Zero'd to indicate that
//              the memory has been "deallocated" from these strutures and
//              reallocated to the newly created Subordinate.  Note that this
//              routine does not deallocate the SubordinateId structure or
//              the SubordinateInfo structure itself. On successful return from
//              this function, the SubordinateId structure will be modified
//              to have a NULL Prefix entry, and the SubordinateInfo structure
//              will be modified to have zero services and a null ServiceList
//              entry.
//--------------------------------------------------------------------------
NTSTATUS
PktCreateSubordinateEntry(
    IN      PDFS_PKT Pkt,
    IN      PDFS_PKT_ENTRY Superior,
    IN      ULONG SubordinateType,
    IN      PDFS_PKT_ENTRY_ID SubordinateId,
    IN      PDFS_PKT_ENTRY_INFO SubordinateInfo OPTIONAL,
    IN      ULONG CreateDisposition,
    IN  OUT PDFS_PKT_ENTRY *Subordinate
)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_PKT_ENTRY subEntry;

    DebugTrace(+1, Dbg, "PktCreateSubordinateEntry: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(Pkt));
    ASSERT(ARGUMENT_PRESENT(Superior));
    ASSERT(ARGUMENT_PRESENT(SubordinateId));
    ASSERT(ARGUMENT_PRESENT(Subordinate));

    //
    // Now we go ahead and create the new sub entry...
    //

    status = PktCreateEntry(
        Pkt,
        SubordinateType,
        SubordinateId,
        SubordinateInfo,
        CreateDisposition,
        &subEntry
    );

    if (NT_SUCCESS(status)) {

        PktSetTypeInheritance(Superior, subEntry)

        //
        // Link the child to the parent...note that this removes the
        // child from any other parent.
        //

        PktEntryLinkSubordinate(Superior, subEntry);

        //
        // Don't forget to set the return value...
        //

        (*Subordinate) = subEntry;
    }

    DebugTrace(-1, Dbg, "PktCreateSubordinateEntry: Exit -> %08lx\n", ULongToPtr( status ));
    return status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PktEntryModifyPrefix, public
//
//  Synopsis:   PktEntryModifyPrefix finds an entry that has a
//              specified prefix.  The PKT must be acquired for
//              this operation.
//
//  Arguments:  [Pkt] - pointer to a initialized (and acquired) PKT
//              [Prefix] - the volume's new entry path
//              [Entry] - pointer to the PKT entry that needs to be modified.
//
//  Returns:    [DFS_STATUS_BAD_EXIT_POINT] -- If the new prefix could
//                      not be inserted into the prefix table.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- If room for the new
//                      prefix could not be allocated.
//
//              [STATUS_SUCCESS] -- If everything succeeds.
//
//  Notes:      If everything succeeds, the old Entry->Id.Prefix.Buffer is
//              freed up. If this function fails, then everything, including
//              the prefix table, is left intact.
//
//--------------------------------------------------------------------------

NTSTATUS
PktEntryModifyPrefix(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING Prefix,
    IN  PDFS_PKT_ENTRY  Entry)
{
    NTSTATUS            status;
    UNICODE_STRING      oldPrefix = Entry->Id.Prefix;

    DebugTrace(+1, Dbg, "PktEntryModifyPrefix: Entered\n", 0);

    //
    // First, try to allocate space for the new prefix. The old one has
    // already been saved in oldPrefix
    //

    Entry->Id.Prefix.Buffer = ExAllocatePoolWithTag(PagedPool, Prefix->MaximumLength, ' sfD');

    if (Entry->Id.Prefix.Buffer != NULL) {

        //
        // Next, get rid of the existing prefix from the PrefixTable.
        //

        DfsRemoveUnicodePrefix(&(Pkt->PrefixTable), &oldPrefix);

        //
        // Now we will plug in the actual prefix.
        //


        wcscpy(Entry->Id.Prefix.Buffer, Prefix->Buffer);

        Entry->Id.Prefix.Length = Prefix->Length;

        Entry->Id.Prefix.MaximumLength = Prefix->MaximumLength;

        if (DfsInsertUnicodePrefix(&Pkt->PrefixTable,
                                   &(Entry->Id.Prefix),
                                   &(Entry->PrefixTableEntry))) {

            ExFreePool(oldPrefix.Buffer);

            status = STATUS_SUCCESS;

        } else {

            ExFreePool( Entry->Id.Prefix.Buffer );

            Entry->Id.Prefix = oldPrefix;

            DfsInsertUnicodePrefix(&Pkt->PrefixTable,
                                   &(Entry->Id.Prefix),
                                   &(Entry->PrefixTableEntry));

            status = DFS_STATUS_BAD_EXIT_POINT;

        }

    } else {

        DebugTrace(0, Dbg,
            "PktEntryModifyPrefix: Unable to allocate %d bytes\n",
            Prefix->MaximumLength);

        Entry->Id.Prefix = oldPrefix;

        status = STATUS_INSUFFICIENT_RESOURCES;

    }


    DebugTrace(-1, Dbg, "PktEntryModifyPrefix: Exit -> %08lx\n", ULongToPtr( status ));

    return(status);
}



//+-------------------------------------------------------------------------
//
//  Function:   PktLookupEntryById, public
//
//  Synopsis:   PktLookupEntryById finds an entry that has a
//              specified Entry Id.  The PKT must be acquired for
//              this operation.
//
//  Arguments:  [Pkt] - pointer to a initialized (and acquired) PKT
//              [Id] - the partitions Id to lookup.
//
//  Returns:    The PKT_ENTRY that has the exact same Id, or NULL,
//              if none exists.
//
//  Notes:
//
//--------------------------------------------------------------------------

PDFS_PKT_ENTRY
PktLookupEntryById(
    IN      PDFS_PKT Pkt,
    IN      PDFS_PKT_ENTRY_ID Id
)
{
    PDFS_PKT_ENTRY ep;
    UNICODE_STRING remaining;

    DebugTrace(+1, Dbg, "PktLookupEntryById: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(Pkt) &&
           ARGUMENT_PRESENT(Id));

    ep = PktLookupEntryByPrefix(Pkt, &Id->Prefix, &remaining);

    if (ep != NULL) {
        if (remaining.Length != 0 || !GuidEqual(&Id->Uid, &ep->Id.Uid))
            ep = NULL;
    }

    DebugTrace(-1, Dbg, "PktLookupEntryById: Exit -> %08lx\n", ep );
    return ep;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktLookupEntryByPrefix, public
//
//  Synopsis:   PktLookupEntryByPrefix finds an entry that has a
//              specified prefix.  The PKT must be acquired for
//              this operation.
//
//  Arguments:  [Pkt] - pointer to a initialized (and acquired) PKT
//              [Prefix] - the partitions prefix to lookup.
//              [Remaining] - any remaining path.  Points within
//                  the Prefix to where any trailing (nonmatched)
//                  characters are.
//
//  Returns:    The PKT_ENTRY that has the exact same prefix, or NULL,
//              if none exists.
//
//  Notes:
//
//--------------------------------------------------------------------------
PDFS_PKT_ENTRY
PktLookupEntryByPrefix(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING Prefix,
    OUT PUNICODE_STRING Remaining
)
{
    PUNICODE_PREFIX_TABLE_ENTRY pfxEntry;
    PDFS_PKT_ENTRY              pktEntry;
    UNICODE_STRING              PrefixTail;
    UNICODE_STRING              EntryTail;

    DebugTrace(+1, Dbg, "PktLookupEntryByPrefix: Entered\n", 0);

    //
    // If there really is a prefix to lookup, use the prefix table
    //  to initially find an entry
    //

    if ((Prefix->Length != 0) &&
       (pfxEntry = DfsFindUnicodePrefix(&Pkt->PrefixTable,Prefix,Remaining))) {
        USHORT pfxLength;

        //
        // reset a pointer to the corresponding entry
        //

        pktEntry = CONTAINING_RECORD(pfxEntry,
                                     DFS_PKT_ENTRY,
                                     PrefixTableEntry
                                );

        RemoveFirstComponent(Prefix,&PrefixTail);
        RemoveFirstComponent(&pktEntry->Id.Prefix,&EntryTail);

        pfxLength = EntryTail.Length;

        //
        //  Now calculate the remaining path and return
        //  the entry we found.  Note that we bump the length
        //  up by one char so that we skip any path separater.
        //

        if ((pfxLength < PrefixTail.Length) &&
                (PrefixTail.Buffer[pfxLength/sizeof(WCHAR)] == UNICODE_PATH_SEP))
            pfxLength += sizeof(WCHAR);

        if (pfxLength <= PrefixTail.Length) {
            Remaining->Length = (USHORT)(PrefixTail.Length - pfxLength);
            Remaining->Buffer = &PrefixTail.Buffer[pfxLength/sizeof(WCHAR)];
            Remaining->MaximumLength = (USHORT)(PrefixTail.MaximumLength - pfxLength);
            DebugTrace( 0, Dbg, "PktLookupEntryByPrefix: Remaining = %wZ\n",
                        Remaining);
        } else {
            Remaining->Length = Remaining->MaximumLength = 0;
            Remaining->Buffer = NULL;
            DebugTrace( 0, Dbg, "PktLookupEntryByPrefix: No Remaining\n", 0);
        }

        DebugTrace(-1, Dbg, "PktLookupEntryByPrefix: Exit -> %08lx\n",
                    pktEntry);
        return pktEntry;
    }

    DebugTrace(-1, Dbg, "PktLookupEntryByPrefix: Exit -> %08lx\n", NULL);
    return NULL;
}


//+-------------------------------------------------------------------------
//
//  Function:   PktLookupEntryByShortPrefix, public
//
//  Synopsis:   PktLookupEntryByShortPrefix finds an entry that has a
//              specified short (8.3) prefix.  The PKT must be acquired for
//              this operation.
//
//  Arguments:  [Pkt] - pointer to a initialized (and acquired) PKT
//              [Prefix] - the partitions prefix to lookup.
//              [Remaining] - any remaining path.  Points within
//                  the Prefix to where any trailing (nonmatched)
//                  characters are.
//
//  Returns:    The PKT_ENTRY that has the exact same prefix, or NULL,
//              if none exists.
//
//  Notes:
//
//--------------------------------------------------------------------------
PDFS_PKT_ENTRY
PktLookupEntryByShortPrefix(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING Prefix,
    OUT PUNICODE_STRING Remaining
)
{
    PUNICODE_PREFIX_TABLE_ENTRY pfxEntry;
    PDFS_PKT_ENTRY              pktEntry;

    DebugTrace(+1, Dbg, "PktLookupEntryByShortPrefix: Entered\n", 0);

    //
    // If there really is a prefix to lookup, use the prefix table
    //  to initially find an entry
    //

    if ((Prefix->Length != 0) &&
       (pfxEntry = DfsFindUnicodePrefix(&Pkt->ShortPrefixTable,Prefix,Remaining))) {
        USHORT pfxLength;

        //
        // reset a pointer to the corresponding entry
        //

        pktEntry = CONTAINING_RECORD(pfxEntry,
                                     DFS_PKT_ENTRY,
                                     PrefixTableEntry
                                );
        pfxLength = pktEntry->Id.ShortPrefix.Length;

        //
        //  Now calculate the remaining path and return
        //  the entry we found.  Note that we bump the length
        //  up by one char so that we skip any path separater.
        //

        if ((pfxLength < Prefix->Length) &&
                (Prefix->Buffer[pfxLength/sizeof(WCHAR)] == UNICODE_PATH_SEP))
            pfxLength += sizeof(WCHAR);

        if (pfxLength <= Prefix->Length) {
            Remaining->Length = (USHORT)(Prefix->Length - pfxLength);
            Remaining->Buffer = &Prefix->Buffer[pfxLength/sizeof(WCHAR)];
            Remaining->MaximumLength = (USHORT)(Prefix->MaximumLength - pfxLength);
            DebugTrace( 0, Dbg, "PktLookupEntryByShortPrefix: Remaining = %wZ\n",
                        Remaining);
        } else {
            Remaining->Length = Remaining->MaximumLength = 0;
            Remaining->Buffer = NULL;
            DebugTrace( 0, Dbg, "PktLookupEntryByShortPrefix: No Remaining\n", 0);
        }

        DebugTrace(-1, Dbg, "PktLookupEntryByShortPrefix: Exit -> %08lx\n",
                    pktEntry);
        return pktEntry;
    }

    DebugTrace(-1, Dbg, "PktLookupEntryByShortPrefix: Exit -> %08lx\n", NULL);
    return NULL;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktLookupEntryByUid, public
//
//  Synopsis:   PktLookupEntryByUid finds an entry that has a
//              specified Uid.  The PKT must be acquired for this operation.
//
//  Arguments:  [Pkt] - pointer to a initialized (and acquired) PKT
//              [Uid] - a pointer to the partitions Uid to lookup.
//
//  Returns:    A pointer to the PKT_ENTRY that has the exact same
//              Uid, or NULL, if none exists.
//
//  Notes:      The input Uid cannot be the Null GUID.
//
//              On a DC where there may be *lots* of entries in the PKT,
//              we may want to consider using some other algorithm for
//              looking up by ID.
//
//--------------------------------------------------------------------------

PDFS_PKT_ENTRY
PktLookupEntryByUid(
    IN  PDFS_PKT Pkt,
    IN  GUID *Uid
) {
    PDFS_PKT_ENTRY entry;

    DebugTrace(+1, Dbg, "PktLookupEntryByUid: Entered\n", 0);

    //
    // We don't lookup NULL Uids
    //

    if (NullGuid(Uid)) {
        DebugTrace(0, Dbg, "PktLookupEntryByUid: NULL Guid\n", NULL);

        entry = NULL;
    } else {
        entry = PktFirstEntry(Pkt);
    }

    while (entry != NULL) {
        if (GuidEqual(&entry->Id.Uid, Uid))
            break;
        entry = PktNextEntry(Pkt, entry);
    }

    DebugTrace(-1, Dbg, "PktLookupEntryByUid: Exit -> %08lx\n", entry);
    return entry;
}


//+-------------------------------------------------------------------------
//
//  Function:   PktSetRelationInfo, public
//
//  Synopsis:   PktSetRelationInfo takes the information specified in a
//              relation info structure and sets the Pkt entries accordingly.
//
//  Arguments:  [Pkt] - a pointer to an exclusively acquired Pkt.
//              [RelationInfo] - a pointer to a relation info structure
//                  specifying the relationship that is to be set.
//
//  Returns:    [STATUS_SUCCESS] - if all is well.
//              [DFS_STATUS_NO_SUCH_ENTRY] - the EntryId specified in the
//                  Relation Info structure does not exist.
//              [DFS_STATUS_LOCAL_ENTRY] - creation of the subordinate entry
//                  would have required that a local entry or exit point
//                  be invalidated.
//              [DFS_STATUS_INCONSISTENT] - an inconsistency in the PKT
//                  has been discovered.
//              [STATUS_INVALID_PARAMETER] - the Id specified for a
//                  subordinate is invalid.
//              [STATUS_INSUFFICIENT_RESOURCES] - not enough memory was
//                  available to complete the operation.
//
//
//  Notes:      If this operation fails, all subordinates of the entry
//              are cleared.
//
//--------------------------------------------------------------------------
NTSTATUS
PktSetRelationInfo(
    IN      PDFS_PKT Pkt,
    IN      PDFS_PKT_RELATION_INFO RelationInfo
)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_PKT_ENTRY entry;
    ULONG i;

    DebugTrace(+1, Dbg, "PktSetRelationalInfo: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(Pkt));
    ASSERT(ARGUMENT_PRESENT(RelationInfo));

    //
    // We need to lookup the entry for which we are setting relation
    // information on.
    //

    if ((entry = PktLookupEntryById(Pkt, &RelationInfo->EntryId)) == NULL) {

        DebugTrace(-1, Dbg, "PktSetRelationalInfo: Exit -> %08lx\n",
            ULongToPtr( DFS_STATUS_NO_SUCH_ENTRY ));
        return DFS_STATUS_NO_SUCH_ENTRY;
    }

    //
    // Now we go and trim off any subordinates that aren't
    // currently identified in the Relation Info structure.
    //

    PktTrimSubordinates(Pkt, entry, RelationInfo);

    //
    // Go through the relation info structure creating subordinates
    //

    for (i = 0; i < RelationInfo->SubordinateIdCount; i++) {

        PDFS_PKT_ENTRY subEntry;

        status = PktCreateSubordinateEntry(
            Pkt,
            entry,
            0L,
            &RelationInfo->SubordinateIdList[i],
            NULL,
            PKT_ENTRY_SUPERSEDE,
            &subEntry
        );

        if (!NT_SUCCESS(status)) {

            //
            // If there was an error, we clear away all subordinates.
            // ...It's an all or nothing proposition...
            //

            PktEntryClearSubordinates(entry);
            break;
        }
    }

    DebugTrace(-1, Dbg, "PktSetRelationalInfo: Exit -> %08lx\n", ULongToPtr( status ));
    return status;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktTrimSubordinates, public
//
//  Synopsis:   PktTrimSubordinates invalidates all subordinate entries
//              that are not specified in the relation info structure
//              supplied.
//
//  Arguments:  [Pkt] - a pointer to an exclusively acquired Pkt.
//              [PktEntry] - a pointer to an entry that is to have all its
//                  subordinates unlinked.
//              [RelationInfo] - a pointer to a relation info structure
//                  specifying the relationship that the Pkt is to
//                  be trimmed to.
//
//  Returns:    VOID
//
//  Notes:      This operation does not insure that all the subordinates
//              exist, it only insures that no subordinates that are
//              NOT specified in the relation info structure exist.
//
//--------------------------------------------------------------------------
VOID
PktTrimSubordinates(
    IN      PDFS_PKT Pkt,
    IN      PDFS_PKT_ENTRY Entry,
    IN      PDFS_PKT_RELATION_INFO RInfo
)
{
    PDFS_PKT_ENTRY subEntry;

    DebugTrace(+1, Dbg, "PktTrimSubordinates: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(Entry));
    ASSERT(ARGUMENT_PRESENT(RInfo));

    ASSERT(PktEntryIdEqual(&Entry->Id, &RInfo->EntryId));

    //
    // go through the list of subordinate entries
    //

    subEntry = PktEntryFirstSubordinate(Entry);
    while (subEntry != NULL) {

        PDFS_PKT_ENTRY_ID id;
        PDFS_PKT_ENTRY nextSubEntry;
        BOOLEAN onTheList;

        //
        // Search the list of subordinate ids to insure that this
        // subordinate is on it.
        //

        for (onTheList = FALSE, id = RInfo->SubordinateIdList;
            id < &RInfo->SubordinateIdList[RInfo->SubordinateIdCount];
            id++) {

            if (PktEntryIdEqual(&subEntry->Id, id)) {
                onTheList = TRUE;
                break;
            }
        }

        //
        // If we didn't find the subordinate on the list, we destroy...
        // Note that we have to get the next subordinate prior to this
        // just in case the current one gets nuked!
        //

        nextSubEntry = PktEntryNextSubordinate(Entry, subEntry);
        if (!onTheList)
            PktEntryDestroy(subEntry, Pkt, (BOOLEAN)TRUE);

        //
        // go to the next subordinate entry...
        //

        subEntry = nextSubEntry;
    }

    DebugTrace(-1, Dbg, "PktTrimSubordinates: Exit -> VOID\n", 0);

}


//+----------------------------------------------------------------------------
//
//  Function:   PktpPruneExtraVolume
//
//  Synopsis:   Sometimes a DC thinks this server has an extra volume, so
//              that volume's knowledge needs to be pruned from the pkt and
//              registry, and the volume's exit points need to be deleted
//              from the disk. This routine is a helper routine to do that.
//
//  Arguments:  [RelationInfo] -- The Relation Info for the local volume
//                      that needs to be pruned.
//
//  Returns:    [STATUS_SUCCESS] -- Local volume and its exit pts were deleted
//
//              [STATUS_UNSUCCESSFUL] -- Some errors were encountered in
//                      deleting the local volume; for each error, a message
//                      was logged.
//
//  Notes:      Assumes Pkt has been acquired exclusive
//
//  History:    05-April-95     Milans created
//
//-----------------------------------------------------------------------------

NTSTATUS
PktpPruneExtraVolume(
    IN PDFS_PKT_RELATION_INFO RelationInfo)
{

    NTSTATUS status, returnStatus;
    PDFS_PKT_ENTRY_ID peid;
    UNICODE_STRING puStr[2];
    ULONG i;

    puStr[1].MaximumLength = sizeof(L"LocalMachine");
    puStr[1].Length = puStr[1].MaximumLength - sizeof(WCHAR);
    puStr[1].Buffer = L"LocalMachine";

    //
    // First we delete all the exit Points.
    //

    returnStatus = STATUS_SUCCESS;

    peid = RelationInfo->SubordinateIdList;

    for (i = 0; i < RelationInfo->SubordinateIdCount; i++)  {

        status = DfsInternalDeleteExitPoint(peid, PKT_ENTRY_TYPE_CAIRO);

        if (!NT_SUCCESS(status))    {

            DebugTrace(0, 1, "Dfs - PktpPruneExtraVolume: DeletingExitPt "
                "failed: %08lx\n", ULongToPtr( status ));

            puStr[0] = peid->Prefix;

            LogWriteMessage(EXTRA_EXIT_POINT_NOT_DELETED, status, 2, puStr);

            returnStatus = STATUS_UNSUCCESSFUL;

        }

        peid++;

    }

    status = DfsInternalDeleteLocalVolume(&RelationInfo->EntryId);

    if (!NT_SUCCESS(status))        {

        puStr[0] = RelationInfo->EntryId.Prefix;

        DebugTrace(0, 1, "Dfs - PktpPruneExtraVolume: Deleting "
            "Extra Local Volume failed: %08lx\n", ULongToPtr( status ));

        LogWriteMessage(EXTRA_VOLUME_NOT_DELETED, status, 2, puStr);

        returnStatus = STATUS_UNSUCCESSFUL;

    }

    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   PktpFixupRelationInfo
//
//  Synopsis:   Sometimes a DC will discover that this server has the wrong
//              information about a local volume. This routine will fix up
//              the local knowledge to that of the DC.
//
//  Arguments:
//
//  Returns:    [STATUS_SUCCESS] -- We managed to completely sync up with
//                      the DC's relation info.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory.
//
//              [STATUS_UNSUCCESSFUL] -- We were unable to fully sync up -
//                      a message was logged for the errors encountered.
//
//  Notes:      Assumes Pkt has been acquired exclusive
//
//  History:    05-April-95     Milans created
//
//-----------------------------------------------------------------------------

NTSTATUS
PktpFixupRelationInfo(
    IN PDFS_PKT_RELATION_INFO Local,
    IN PDFS_PKT_RELATION_INFO Remote)
{
    NTSTATUS                status, returnStatus;
    PUNICODE_STRING         lpfx, rpfx;
    ULONG                   i, j=0;
    ULONG                   *pulExitPtUsed = NULL;
    UNICODE_STRING          LocalMachStr;
    UNICODE_STRING          puStr[3];
    UNICODE_STRING          unusedShortPrefix;

    LocalMachStr.MaximumLength = sizeof(L"LocalMachine");
    LocalMachStr.Length = LocalMachStr.MaximumLength - sizeof(WCHAR);
    LocalMachStr.Buffer = L"LocalMachine";

    returnStatus = status = STATUS_SUCCESS;

    //
    // The GUIDs of this volume have already been matched otherwise we
    // would not be here.  So we don't even look at that.  We still
    // need to match the prefixes. If the prefixes are different then we
    // need to fix that.
    //

    lpfx = &Local->EntryId.Prefix;

    rpfx = &Remote->EntryId.Prefix;

    if (RtlCompareUnicodeString(lpfx, rpfx, TRUE))      {

        //
        // The Prefixes are different we need to fix this now.
        // But first let us log this event.
        //

        DebugTrace(0, Dbg, "Fixed Prefix [%wZ]\n", rpfx);
        DebugTrace(0, Dbg, "To be [%wZ]\n", lpfx);

        puStr[0] = Local->EntryId.Prefix;

        puStr[1] = Remote->EntryId.Prefix;

        puStr[2] = LocalMachStr;

        LogWriteMessage(PREFIX_MISMATCH, status, 3, puStr);

        status = DfsInternalModifyPrefix(&Remote->EntryId);

        if (NT_SUCCESS(status)) {

            LogWriteMessage(PREFIX_MISMATCH_FIXED, status, 3, puStr);

        } else  {

            DebugTrace(0, 1, "Dfs - PktRelationInfoValidate: "
                    "Status from DfsModifyePrefix = %08lx\n", ULongToPtr( status ));

            LogWriteMessage(PREFIX_MISMATCH_NOT_FIXED, status, 3,puStr);

        }

    }

    if (Remote->SubordinateIdCount != 0) {

        ULONG size = sizeof(ULONG) * Remote->SubordinateIdCount;

        pulExitPtUsed = ExAllocatePoolWithTag( PagedPool, size, ' sfD' );

        if (pulExitPtUsed == NULL) {

            return ( STATUS_INSUFFICIENT_RESOURCES );

        } else {

            RtlZeroMemory( pulExitPtUsed, size );

        }

    }

    //
    // We step through each exit point in the local knowledge and
    // make sure that is right. If not we attempt to delete the exit
    // point from this machine. So this takes care of EXTRA
    // ExitPoints at this machine. We will still need to deal with
    // ExitPoints which the DC knows of whereas the this machine does
    // not. So we keep track of all the remote exit points which have
    // been acounted for by the local Relational info and then we
    // take the rest and create those exit points at this machine.
    // This takes care of TOO FEW ExitPoints at this machine.
    //

    for (i = 0; i < Local->SubordinateIdCount; i++) {

        ULONG j;
        GUID *lguid, *rguid;

        rpfx = &Local->SubordinateIdList[i].Prefix;

        rguid = &Local->SubordinateIdList[i].Uid;

        status = DFS_STATUS_BAD_EXIT_POINT;

        for (j = 0; j < Remote->SubordinateIdCount; j++) {

            lpfx = &Remote->SubordinateIdList[j].Prefix;

            lguid = &Remote->SubordinateIdList[j].Uid;

            if (!RtlCompareUnicodeString(lpfx, rpfx, TRUE) &&
                    GuidEqual(lguid, rguid)) {

                status = STATUS_SUCCESS;

                ASSERT(pulExitPtUsed[j] == FALSE);

                pulExitPtUsed[j] = TRUE;

                break;

            }

        }

        if (!NT_SUCCESS(status)) {

            //
            // In this case we have an exit point which the DC does not
            // recognise. We need to delete this.
            //

            puStr[0] = Local->SubordinateIdList[i].Prefix;

            puStr[1] = LocalMachStr;

            LogWriteMessage(EXTRA_EXIT_POINT, status, 2, puStr);

            status =
                DfsInternalDeleteExitPoint(&Local->SubordinateIdList[i],
                                           PKT_ENTRY_TYPE_CAIRO);

            if (!NT_SUCCESS(status)) {

                //
                // We want to Log an event here actually.
                //

                DebugTrace(0, 1,
                    "Dfs - PktpFixupRelationInfo: Failed to delete [%wZ]\n",
                    &Local->SubordinateIdList[i].Prefix  );

                LogWriteMessage(EXTRA_EXIT_POINT_NOT_DELETED, status, 2, puStr);

                returnStatus = STATUS_UNSUCCESSFUL;

            } else {

                LogWriteMessage(EXTRA_EXIT_POINT_DELETED, status, 2, puStr);

            }

        }

    }

    //
    // Now that we are done with getting rid of extra exit points
    // we only need to deal with any exit point that we dont have
    // and create any such that might exist.
    //

    for (i = 0; i < Remote->SubordinateIdCount; i++)       {

        if (pulExitPtUsed[i] == FALSE)  {

            puStr[0] = Remote->SubordinateIdList[i].Prefix;

            puStr[1] = LocalMachStr;

            LogWriteMessage(MISSING_EXIT_POINT, status, 2, puStr);

            RtlInitUnicodeString(&unusedShortPrefix, NULL);

            status = DfsInternalCreateExitPoint(
                        &Remote->SubordinateIdList[i],
                        PKT_ENTRY_TYPE_CAIRO,
                        FILE_OPEN_IF,
                        &unusedShortPrefix);

            if (NT_SUCCESS(status) && unusedShortPrefix.Buffer != NULL) {
                ExFreePool(unusedShortPrefix.Buffer);
            }

            if (!NT_SUCCESS(status)) {

                //
                // We want to Log an event here actually. 
                //

                DebugTrace(0, 1, "DFS - PktpFixupRelationInfo: "
                         "Failed to Create ExitPt [%wZ]\n",
                         &Remote->SubordinateIdList[i].Prefix);

                LogWriteMessage(MISSING_EXIT_POINT_NOT_CREATED,
                                status,
                                2,
                                puStr);

                returnStatus = STATUS_UNSUCCESSFUL;

            } else {

                LogWriteMessage(MISSING_EXIT_POINT_CREATED,
                                status,
                                2,
                                puStr);

            }

        }

    } // end for each subordinate in remote relation info

    if (pulExitPtUsed != NULL) {

        ExFreePool(pulExitPtUsed);

    }

    return( returnStatus );

}


//+----------------------------------------------------------------------------
//
//  Function:  PktShuffleServiceList
//
//  Synopsis:  Randomizes a service list for proper load balancing. This
//             routine assumes that the service list is ordered based on
//             site costs. For each equivalent cost group, this routine
//             shuffles the service list.
//
//  Arguments: [pInfo] -- Pointer to PktEntryInfo whose service list needs to
//                        be shuffled.
//
//  Returns:   Nothing, unless rand() fails!
//
//-----------------------------------------------------------------------------

VOID
PktShuffleServiceList(
    PDFS_PKT_ENTRY_INFO pInfo)
{
    PktShuffleGroup(pInfo, 0, pInfo->ServiceCount);
}

//+----------------------------------------------------------------------------
//
//  Function:   PktShuffleGroup
//
//  Synopsis:   Shuffles a cost equivalent group of services around for load
//              balancing. Uses the classic card shuffling algorithm - for
//              each card in the deck, exchange it with a random card in the
//              deck.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

VOID
PktShuffleGroup(
    PDFS_PKT_ENTRY_INFO pInfo,
    ULONG       nStart,
    ULONG       nEnd)
{
    ULONG i;
    LARGE_INTEGER seed;

    ASSERT( nStart < pInfo->ServiceCount );
    ASSERT( nEnd <= pInfo->ServiceCount );

    KeQuerySystemTime( &seed );

    for (i = nStart; i < nEnd; i++) {

        DFS_SERVICE TempService;
        ULONG j;

        ASSERT (nEnd - nStart != 0);

        j = (RtlRandom( &seed.LowPart ) % (nEnd - nStart)) + nStart;

        ASSERT( j >= nStart && j <= nEnd );

        TempService = pInfo->ServiceList[i];

        pInfo->ServiceList[i] = pInfo->ServiceList[j];

        pInfo->ServiceList[j] = TempService;

    }
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsBuildConnectionRequest
//
//  Synopsis:   Builds the EA and file names necessary to setup an
//              authenticated connection to a server.
//
//  Arguments:  [pService] -- Pointer to DFS_SERVICE describing server
//              [pProvider] -- Pointer to PROVIDER_DEF describing the
//                            provider to use to establish the connection.
//              [pShareName] -- Share name to open.
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//-----------------------------------------------------------------------------

NTSTATUS DfsBuildConnectionRequest(
    IN PDFS_SERVICE pService,
    IN PPROVIDER_DEF pProvider,
    OUT PUNICODE_STRING pShareName)
{
    ASSERT(pService != NULL);
    ASSERT(pProvider != NULL);

    RtlInitUnicodeString(pShareName, NULL);

    pShareName->Length = 0;

    pShareName->MaximumLength = pProvider->DeviceName.Length +
                                    sizeof(UNICODE_PATH_SEP_STR) +
                                        pService->Name.Length +
                                            sizeof(ROOT_SHARE_NAME);

    pShareName->Buffer = ExAllocatePoolWithTag(PagedPool, pShareName->MaximumLength, ' sfD');

    if (pShareName->Buffer == NULL) {

        DebugTrace(0, Dbg, "Unable to allocate pool for share name!\n", 0);

        pShareName->Length = pShareName->MaximumLength = 0;

        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    RtlAppendUnicodeStringToString( pShareName, &pProvider->DeviceName );

    RtlAppendUnicodeToString( pShareName, UNICODE_PATH_SEP_STR );

    RtlAppendUnicodeStringToString( pShareName, &pService->Name );

    RtlAppendUnicodeToString( pShareName, ROOT_SHARE_NAME );

    return( STATUS_SUCCESS );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFreeConnectionRequest
//
//  Synopsis:   Frees up the stuff allocated on a successful call to
//              DfsBuildConnectionRequest
//
//  Arguments:  [pShareName] -- Unicode string holding share name.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsFreeConnectionRequest(
    IN OUT PUNICODE_STRING pShareName)
{

    if (pShareName->Buffer != NULL) {
        ExFreePool ( pShareName->Buffer );
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsCreateConnection -- Create a connection to a server
//
//  Synopsis:   DfsCreateConnection will attempt to create a connection
//              to some server's IPC$ share.
//
//  Arguments:  [pService] -- the Service entry, giving the server principal
//                              name
//              [remoteHandle] -- This is where the handle is returned.
//
//  Returns:    NTSTATUS - the status of the operation
//
//  Notes:      The Pkt must be acquired shared before calling this! It will
//              be released and reacquired in this routine.
//
//  History:    31 Mar 1993     SudK    Created
//
//--------------------------------------------------------------------------

NTSTATUS
DfsCreateConnection(
    IN PDFS_SERVICE     pService,
    IN PPROVIDER_DEF    pProvider,
    OUT PHANDLE         remoteHandle
) {
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING ShareName;
    NTSTATUS Status;

    ASSERT(pService != NULL);
    ASSERT(pProvider != NULL);
    ASSERT(ExIsResourceAcquiredSharedLite( &DfsData.Pkt.Resource ));

    Status = DfsBuildConnectionRequest(
                pService,
                pProvider,
                &ShareName);

    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    InitializeObjectAttributes(
        &ObjectAttributes,
        &ShareName,                             // File Name
        0,                                      // Attributes
        NULL,                                   // Root Directory
        NULL                                    // Security
        );

    //
    // Create or open a tree connection
    //

    PktRelease( &DfsData.Pkt );

    Status = ZwCreateFile(
                    remoteHandle,
                    SYNCHRONIZE,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    PktAcquireShared( &DfsData.Pkt, TRUE );

    if ( NT_SUCCESS( Status ) ) {
        DebugTrace(0, Dbg, "Created Connection Successfully\n", 0);
        Status = IoStatusBlock.Status;
    }

    DfsFreeConnectionRequest( &ShareName );

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsCloseConnection -- Close a connection to a server
//
//  Synopsis:   DfsCloseConnection will attempt to Close a connection
//              to some server.
//
//  Effects:    The file object referring to the the connection will be
//              closed.
//
//  Arguments:  pService - the Service entry, giving the server connection
//                      handle
//
//  Returns:    NTSTATUS - the status of the operation
//
//  History:    28 May 1992     Alanw   Created
//
//--------------------------------------------------------------------------


NTSTATUS
DfsCloseConnection(
    IN PDFS_SERVICE pService
)
{
    ASSERT( pService->ConnFile != NULL );

    ObDereferenceObject(pService->ConnFile);
    pService->ConnFile = NULL;
    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsConcatenateFilePath, public
//
//  Synopsis:   DfsConcatenateFilePath will concatenate two strings
//              representing file path names, assuring that they are
//              separated by a single '\' character.
//
//  Arguments:  [Dest] - a pointer to the destination string
//              [RemainingPath] - the final part of the path name
//              [Length] - the length (in bytes) of RemainingPath
//
//  Returns:    BOOLEAN - TRUE unless Dest is too small to
//                      hold the result (assert).
//
//--------------------------------------------------------------------------

BOOLEAN
DfsConcatenateFilePath (
    IN PUNICODE_STRING Dest,
    IN PWSTR RemainingPath,
    IN USHORT Length
) {
    PWSTR  OutBuf = (PWSTR)&(((PCHAR)Dest->Buffer)[Dest->Length]);

    if (Dest->Length > 0) {
        ASSERT(OutBuf[-1] != UNICODE_NULL);
    }

    if (Dest->Length > 0 && OutBuf[-1] != UNICODE_PATH_SEP) {
        *OutBuf++ = UNICODE_PATH_SEP;
        Dest->Length += sizeof (WCHAR);
    }

    if (Length > 0 && *RemainingPath == UNICODE_PATH_SEP) {
        RemainingPath++;
        Length -= sizeof (WCHAR);
    }

    ASSERT(Dest->MaximumLength >= (USHORT)(Dest->Length + Length));

    if (Length > 0) {
        RtlMoveMemory(OutBuf, RemainingPath, Length);
        Dest->Length += Length;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\pktsup.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       PktSup.C
//
//  Contents:   This module implements routines specific to the partition
//              knowledge table entry.
//
//  Functions:  PktEntrySetLocalService -
//              PktEntryLookupLocalService -
//              PktEntryRemoveLocalService -
//              PktDSTransportDestroy -
//              PktDSMachineDestroy -
//              PktServiceConstruct -
//              PktServiceDestroy -
//              PktEntryIdConstruct -
//              PktEntryIdDestroy -
//              PktEntryInfoConstruct -
//              PktEntryInfoDestroy -
//              PktEntryAssemble -
//              PktEntryReassemble -
//              PktEntryDestroy -
//              PktEntryClearSubordinates -
//              PktEntryClearChildren -
//              PktRelationInfoConstruct -
//              PktRelationInfoValidate -
//              PktRelationInfoDestroy -
//              PktGetService -
//              DfsFixDSMachineStructs -
//              DfspFixService -
//              DfsDecrementMachEntryCount -
//
//  History:    27 May 1992 PeterCo Created.
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"

#include <netevent.h>

#include "fsctrl.h"
#include "attach.h"
#include "know.h"
#include "log.h"
#include "localvol.h"

#define Dbg              (DEBUG_TRACE_PKT)

NTSTATUS
DfsFixDSMachineStructs(
    PDFS_PKT_ENTRY      pEntry
);

NTSTATUS
DfspFixService(
    PDFS_SERVICE        pService
);

VOID
DfsDecrementMachEntryCount(
    PDFS_MACHINE_ENTRY  pMachEntry,
    BOOLEAN     DeallocateMachine
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, PktEntrySetLocalService )
#pragma alloc_text( PAGE, PktEntryLookupLocalService )
#pragma alloc_text( PAGE, PktEntryRemoveLocalService )
#pragma alloc_text( PAGE, PktServiceConstruct )
#pragma alloc_text( PAGE, PktServiceDestroy )
#pragma alloc_text( PAGE, PktEntryIdConstruct )
#pragma alloc_text( PAGE, PktEntryIdDestroy )
#pragma alloc_text( PAGE, PktEntryInfoDestroy )
#pragma alloc_text( PAGE, PktEntryAssemble )
#pragma alloc_text( PAGE, PktEntryReassemble )
#pragma alloc_text( PAGE, PktEntryDestroy )
#pragma alloc_text( PAGE, PktEntryClearSubordinates )
#pragma alloc_text( PAGE, PktEntryClearChildren )
#pragma alloc_text( PAGE, PktRelationInfoConstruct )
#pragma alloc_text( PAGE, PktRelationInfoValidate )
#pragma alloc_text( PAGE, PktRelationInfoDestroy )
#pragma alloc_text( PAGE, PktGetService )
#pragma alloc_text( PAGE, DfsFixDSMachineStructs )
#pragma alloc_text( PAGE, DfspFixService )
#pragma alloc_text( PAGE, DfsDecrementMachEntryCount )
#endif // ALLOC_PRAGMA
//
// NOTE - we designed for only one system-wide PKT; there is no provision
//        for multiple PKTs.
//

#define _GetPkt() (&DfsData.Pkt)


//+-------------------------------------------------------------------------
//
//  Function:   PktEntrySetLocalService, public
//
//  Synopsis:   PktEntrySetLocalService sets the local service field of
//              the entry (deallocating any previous local service field
//              that may exist).
//
//  Arguments:  [Pkt] -- pointer to the Pkt
//              [Entry] -- pointer to the PKT entry to set the local service on.
//              [LocalService] -- pointer to the local service to be set.
//              [LocalVolEntry] -- pointer to a local volume table entry
//              [LocalPath] -- the storage ID for the local service
//              [ShareName] -- The LM share through which LocalPath is to be
//                      accessed.
//
//  Returns:    STATUS_SUCCESS  if all's well that ends well
//              STATUS_DEVICE_ALREADY_ATTACHED if the entry has a local service,
//                              and the new service to be set is different.
//              STATUS_INSUFFICIENT_RESOURCES if memory alloc fails.
//
//--------------------------------------------------------------------------

NTSTATUS
PktEntrySetLocalService(
    IN  PDFS_PKT        Pkt,
    IN  PDFS_PKT_ENTRY  Entry,
    IN  PDFS_SERVICE    LocalService,
    IN  PDFS_LOCAL_VOL_ENTRY LocalVolEntry,
    IN  PUNICODE_STRING LocalPath,
    IN  PUNICODE_STRING ShareName
) {
    //
    //  When setting a local service, we don't expect there
    //  to be one already.
    //
    ASSERT(LocalService != NULL);
    ASSERT(LocalVolEntry != NULL);

    DebugTrace(+1, Dbg, "PktEntrySetLocalService(%wZ)\n", LocalPath);
    DebugTrace(+1, Dbg, "                       (%wZ)\n", ShareName);

    if (Entry->LocalService != NULL)    {

        UNICODE_STRING ustrLocalVolName;

        //
        //  The entry has an existing local service. Make sure its the "same"
        //  as the new one we are setting. By same we mean that the new
        //  service has the same provider def and address.
        //
        //

        //  The problem is, we are given LocalPath of the form
        //  \??\X:\path. The existing Entry->LocalService has a pointer
        //  to a provider def that has the the \??\X: part, while the
        //  \path part is stored in Entry->LocalService.Address. So, here, we
        //  first make sure that the \??\X: matches with the existing
        //  provider def, and then we make sure that the \path matches with the
        //  Address part.
        //

        ustrLocalVolName = *LocalPath;
        ustrLocalVolName.Length = Entry->LocalService->pProvider->DeviceName.Length;
        if (!RtlEqualUnicodeString(&ustrLocalVolName,
                                   &Entry->LocalService->pProvider->DeviceName,
                                   TRUE)) {

            DebugTrace(-1, Dbg, "PktEntrySetLocalService->STATUS_DEVICE_ALREADY_ATTACHED(1)\n", 0);
            return (STATUS_DEVICE_ALREADY_ATTACHED);

        }
        ustrLocalVolName.Buffer += (ustrLocalVolName.Length / sizeof(WCHAR));
        ustrLocalVolName.Length = LocalPath->Length - ustrLocalVolName.Length;
        if (!RtlEqualUnicodeString(&ustrLocalVolName,
                                   (PUNICODE_STRING) &Entry->LocalService->Address,
                                   TRUE)) {

            DebugTrace(-1, Dbg, "PktEntrySetLocalService->STATUS_DEVICE_ALREADY_ATTACHED(2)\n", 0);
            return(STATUS_DEVICE_ALREADY_ATTACHED);

        }

        //
        //  Attaching the same local service - all is ok.
        //

        PktEntryRemoveLocalService(Pkt, Entry, LocalPath);
    }

    Entry->LocalService = LocalService;

    //
    // We now have to setup the LocalVolEntry.
    //

    LocalVolEntry->PktEntry = Entry;

    LocalVolEntry->ShareName.Buffer = ExAllocatePoolWithTag(
                                            PagedPool,
                                            ShareName->Length+sizeof(WCHAR),
                                            ' sfD');
    if (LocalVolEntry->ShareName.Buffer != NULL) {

        LocalVolEntry->ShareName.Length = ShareName->Length;
        LocalVolEntry->ShareName.MaximumLength = ShareName->Length + sizeof(WCHAR);

        RtlMoveMemory(  LocalVolEntry->ShareName.Buffer,
                        ShareName->Buffer,
                        ShareName->Length);

    } else {
        DebugTrace(-1, Dbg, "PktEntrySetLocalService exit STATUS_INSUFFICIENT_RESOURCES(1)\n", 0);
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    LocalVolEntry->LocalPath.Buffer = ExAllocatePoolWithTag(
                                            PagedPool,
                                            LocalPath->Length+sizeof(WCHAR),
                                            ' sfD');

    if (LocalVolEntry->LocalPath.Buffer != NULL)        {

        LocalVolEntry->LocalPath.Length = LocalPath->Length;
        LocalVolEntry->LocalPath.MaximumLength = LocalPath->Length + sizeof(WCHAR);

        RtlMoveMemory(  LocalVolEntry->LocalPath.Buffer,
                        LocalPath->Buffer,
                        LocalPath->Length);

        DfsInsertUnicodePrefix(&Pkt->LocalVolTable,
                           &(LocalVolEntry->LocalPath),
                           &(LocalVolEntry->PrefixTableEntry));

    } else {
        ExFreePool( LocalVolEntry->ShareName.Buffer );
        LocalVolEntry->ShareName.Buffer = NULL;
        DebugTrace(-1, Dbg, "PktEntrySetLocalService exit STATUS_INSUFFICIENT_RESOURCES(2)\n", 0);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Entry->Type |= (PKT_ENTRY_TYPE_LOCAL | PKT_ENTRY_TYPE_PERMANENT);
    DebugTrace(-1, Dbg, "PktEntrySetLocalService exit STATUS_SUCCESS)\n", 0);
    return(STATUS_SUCCESS);
}


//+----------------------------------------------------------------------------
//
//  Function:   PktEntryUnsetLocalService, public
//
//  Synopsis:   The exact inverse of PktEntrySetLocalService. It is different
//              from PktEntryRemoveLocalService in that it does not try to
//              call DfsDetachVolume.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

VOID
PktEntryUnsetLocalService(
    IN  PDFS_PKT        Pkt,
    IN  PDFS_PKT_ENTRY  Entry,
    IN  PUNICODE_STRING LocalPath)
{

    ASSERT( Entry != NULL );

    if (Entry->LocalService != NULL) {

        PUNICODE_PREFIX_TABLE_ENTRY lvpfx;
        PDFS_LOCAL_VOL_ENTRY        lv;
        UNICODE_STRING              lvRemPath;

        lvpfx = DfsFindUnicodePrefix(
                    &Pkt->LocalVolTable,
                    LocalPath,
                    &lvRemPath);

        ASSERT(lvpfx != NULL);

        lv = CONTAINING_RECORD(lvpfx, DFS_LOCAL_VOL_ENTRY, PrefixTableEntry);

        ASSERT(lv->PktEntry == Entry);

        //
        //  Get rid of the local volume table entry
        //

        DfsRemoveUnicodePrefix( &Pkt->LocalVolTable, &lv->LocalPath);

        if (lv->ShareName.Buffer != NULL)
            ExFreePool(lv->ShareName.Buffer);
        if (lv->LocalPath.Buffer != NULL)
            ExFreePool(lv->LocalPath.Buffer);

        Entry->LocalService = NULL;

    }

}


//+-------------------------------------------------------------------------
//
//  Function:   PktEntryLookupLocalService, public
//
//  Synopsis:   PktEntryLookupLocalService finds the best match for a given
//              LocalPath and returns the rest of the path and the best match.
//
//  Arguments:  [LocalPath] -- pointer to the local service to be set.
//              [Remaining] -- The Remaining part of LocalPath.
//
//  Returns:    The LOCAL_VOL_ENTRY if a match was found in the PrefixTable.
//
//--------------------------------------------------------------------------
PDFS_LOCAL_VOL_ENTRY
PktEntryLookupLocalService(
    IN  PDFS_PKT        Pkt,
    IN  PUNICODE_STRING LocalPath,
    OUT PUNICODE_STRING Remaining

)
{
    PUNICODE_PREFIX_TABLE_ENTRY lvpfx;
    PDFS_LOCAL_VOL_ENTRY        lv = NULL;

    DebugTrace(+1, Dbg, "PktLookupLocalService: LocalPath: %wZ\n", LocalPath);
    if (LocalPath->Length != 0) {

        lvpfx = DfsFindUnicodePrefix(&Pkt->LocalVolTable,
                                     LocalPath,
                                     Remaining);

        if (lvpfx != NULL)      {
            USHORT      LPathLen;

            lv = CONTAINING_RECORD(lvpfx, DFS_LOCAL_VOL_ENTRY, PrefixTableEntry);
            LPathLen = lv->LocalPath.Length;
            if (LocalPath->Buffer[LPathLen/sizeof(WCHAR)]==UNICODE_PATH_SEP)
                    LPathLen += sizeof(WCHAR);

            if (LPathLen < LocalPath->Length)   {
                Remaining->Length = LocalPath->Length - LPathLen;
                Remaining->Buffer = &LocalPath->Buffer[LPathLen/sizeof(WCHAR)];
                DebugTrace(0,Dbg,"PktEntryLookupLocalService: Remaining: %wZ\n",
                                 Remaining);
            }
            else        {
                Remaining->Length = Remaining->MaximumLength = 0;
                Remaining->Buffer = NULL;
                DebugTrace(0,Dbg,"PktEntryLookupLocalService:No Remaining\n",0);
            }

        }

    }
    DebugTrace(-1, Dbg, "PktLookupLocalService: Exit: %08lx\n", lv);
    return(lv);

}


//+-------------------------------------------------------------------------
//
//  Function:   PktEntryRemoveLocalService, public
//
//  Synopsis:   PktEntryRemoveLocalService clears the local service field of
//              the entry (deallocating any previous local service field
//              that may exist).
//
//  Arguments:  [Pkt] - pointer to the Pkt, must be acquired exclusive
//              [Entry] - pointer to the PKT entry to set the local service on.
//              [LocalPath] - pointer to the local service to be set.
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------

VOID
PktEntryRemoveLocalService(
    IN  PDFS_PKT        Pkt,
    IN  PDFS_PKT_ENTRY  Entry,
    IN  PUNICODE_STRING LocalPath
) {
    ASSERT (Entry->LocalService != NULL);

    if (Entry->LocalService != NULL) {
        PUNICODE_PREFIX_TABLE_ENTRY lvpfx;
        PDFS_LOCAL_VOL_ENTRY        lv;
        UNICODE_STRING              remPath;

        lvpfx = DfsFindUnicodePrefix(&Pkt->LocalVolTable,
                                     LocalPath,
                                     &remPath);

	if (lvpfx != NULL) {
           lv = CONTAINING_RECORD(lvpfx, DFS_LOCAL_VOL_ENTRY, PrefixTableEntry);
           ASSERT(lv->PktEntry == Entry);

            //
            //  Get rid of the local volume table entry
            //
            DfsRemoveUnicodePrefix(&(Pkt->LocalVolTable), &(lv->LocalPath));
            if (lv->ShareName.Buffer != NULL)
                ExFreePool(lv->ShareName.Buffer);
            if (lv->LocalPath.Buffer != NULL)
                ExFreePool(lv->LocalPath.Buffer);
            ExFreePool(lv);

           //
           // Detach if needed
           //
           if ((Entry->LocalService->pProvider) &&
                   !(Entry->LocalService->pProvider->fProvCapability & PROV_UNAVAILABLE)) {
               DfsDetachVolume(LocalPath);
           }

           PktServiceDestroy(Entry->LocalService, (BOOLEAN)TRUE);
       }
       Entry->LocalService = NULL;
    }
    Entry->Type &= ~PKT_ENTRY_TYPE_LOCAL;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktServiceConstruct, public
//
//  Synopsis:   PktServiceConstruct creates a new service structure.
//
//  Arguments:  [Service] - a pointer to a service structure to fill.
//              [ServiceType] - the type of the new service.
//              [ServiceCapability] - the capabilities of the new service.
//              [ServiceStatus] - the initial status of the new service.
//              [ServiceProviderId] - the provider Id of the new service.
//              [ServiceName] - the name of the principal for the service
//              [ServiceAddress] - a string which gives the address
//                                 of the service.
//
//  Returns:    [STATUS_SUCCESS] - all is well.
//              [STATUS_INSUFFICIENT_RESOURCES] - memory could not be
//                  allocated for this new service.
//
//  Notes:      All data is copied (Not MOVED).
//
//--------------------------------------------------------------------------

NTSTATUS
PktServiceConstruct(
    OUT PDFS_SERVICE Service,
    IN  ULONG ServiceType,
    IN  ULONG ServiceCapability,
    IN  ULONG ServiceStatus,
    IN  ULONG ServiceProviderId,
    IN  PUNICODE_STRING ServiceName OPTIONAL,
    IN  PUNICODE_STRING ServiceAddress OPTIONAL
) {
    DebugTrace(+1, Dbg, "PktServiceConstruct: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(Service));

    RtlZeroMemory(Service, sizeof(DFS_SERVICE));

    if (ARGUMENT_PRESENT(ServiceName)) {

        Service->Name.Buffer = ExAllocatePoolWithTag(
                                    PagedPool,
                                    ServiceName->Length,
                                    ' sfD');
        if (Service->Name.Buffer == NULL) {
            DebugTrace(-1, Dbg, "PktServiceConstruct: Exit -> %08lx\n",
                                    ULongToPtr( STATUS_INSUFFICIENT_RESOURCES ) );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        Service->Name.Length = ServiceName->Length;
        Service->Name.MaximumLength = ServiceName->Length;
        RtlCopyUnicodeString(&Service->Name, ServiceName);
    }

    if (ARGUMENT_PRESENT(ServiceAddress) && ServiceAddress->Length != 0) {
        Service->Address.Buffer = ExAllocatePoolWithTag(
                                    PagedPool,
                                    ServiceAddress->Length,
                                    ' sfD');
        if (Service->Address.Buffer == NULL) {

            if (Service->Name.Buffer != NULL)
                DfsFree(Service->Name.Buffer);

            DebugTrace(-1, Dbg, "PktServiceConstruct: Exit -> %08lx\n",
                                    ULongToPtr( STATUS_INSUFFICIENT_RESOURCES ) );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlMoveMemory(Service->Address.Buffer, ServiceAddress->Buffer,
                                               ServiceAddress->Length);
        Service->Address.Length =
        Service->Address.MaximumLength = ServiceAddress->Length;
    } else {
        Service->Address.Buffer = NULL;
        Service->Address.Length = Service->Address.MaximumLength = 0;
    }

    Service->Type = ServiceType;
    Service->Capability = ServiceCapability;
    Service->Status = ServiceStatus;
    Service->ProviderId = ServiceProviderId;
    Service->pProvider = NULL;

    DebugTrace(-1, Dbg, "PktServiceConstruct: Exit -> %08lx\n",
        STATUS_SUCCESS );
    return STATUS_SUCCESS;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktDSTransportDestroy, public
//
//  Synopsis:   PktDSTransportDestroy destroys a DS_TRANSPORT structure, and
//              optionally deallocates the structure itself.
//
//  Arguments:  [Victim] - the DS_TRANSPORT structure to destroy
//              [DeallocateAll] - if True, indicates that the structure
//                  it self is to be deallocated, otherwise, only the
//                  strings within the structure are deallocated.
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------
VOID
PktDSTransportDestroy(
    IN  PDS_TRANSPORT Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
)
{

    DebugTrace(+1, Dbg, "PktDSTransportDestroy: Entered\n", 0);

    if (ARGUMENT_PRESENT(Victim))       {

        //
        // Nothing to free in this structure??
        //

        if (DeallocateAll)
            ExFreePool(Victim);
    } else
        DebugTrace(0, Dbg, "PktDSTransportDestroy: No Victim\n", 0 );

    DebugTrace(-1, Dbg, "PktDSTransportDestroy: Exit -> VOID\n", 0 );
}



//+-------------------------------------------------------------------------
//
//  Function:   PktDSMachineDestroy, public
//
//  Synopsis:   PktDSMachineDestroy destroys a DS_MACHINE structure, and
//              optionally deallocates the structure itself.
//
//  Arguments:  [Victim] - the DS_MACHINE structure to destroy
//              [DeallocateAll] - if True, indicates that the structure
//                  it self is to be deallocated, otherwise, only the
//                  strings within the structure are deallocated.
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------
VOID
PktDSMachineDestroy(
    IN  PDS_MACHINE Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
)
{
    ULONG       i;
    DebugTrace(+1, Dbg, "PktDSMachineDestroy: Entered\n", 0);

    if (ARGUMENT_PRESENT(Victim))       {

        if (Victim->pwszShareName != NULL)      {
            DfsFree(Victim->pwszShareName);
        }

        if (Victim->prgpwszPrincipals != NULL && Victim->cPrincipals > 0) {
            for (i = 0; i < Victim->cPrincipals; i++)   {
                if (Victim->prgpwszPrincipals[i] != NULL)
                    DfsFree(Victim->prgpwszPrincipals[i]);
            }
        }

        if (Victim->prgpwszPrincipals) {
            ExFreePool(Victim->prgpwszPrincipals);
        }

        for (i = 0; i < Victim->cTransports; i++)   {
            PktDSTransportDestroy(Victim->rpTrans[i], TRUE);
        }

        if (DeallocateAll)
            ExFreePool(Victim);
    } else
        DebugTrace(0, Dbg, "PktDSMachineDestroy: No Victim\n", 0 );

    DebugTrace(-1, Dbg, "PktDSMachineDestroy: Exit -> VOID\n", 0 );
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsDecrementMachEntryCount
//
//  Synopsis:   This function decrements the count for the pMachine passed
//              in and if necessary will also free up the DS_MACHINE struct
//
//--------------------------------------------------------------------------
VOID
DfsDecrementMachEntryCount(
    PDFS_MACHINE_ENTRY  pMachEntry,
    BOOLEAN     DeallocateMachine
)
{

    NTSTATUS            status = STATUS_SUCCESS;
    UNICODE_STRING      ustrMachineName;
    PUNICODE_PREFIX_TABLE_ENTRY pfxEntry;
    PDS_MACHINE         pMachine;
    PDFS_PKT            Pkt;

    ASSERT(pMachEntry != NULL);
    if (pMachEntry == NULL)
        return;

    pMachine = pMachEntry->pMachine;
    ASSERT(pMachine != NULL);
    if (pMachine == NULL)
        return;

    //
    // We already have appropriate locks
    //
    Pkt = _GetPkt();

    //
    // For now we only expect one principal.
    //
    ASSERT(pMachine->cPrincipals == 1);

    pMachEntry->UseCount--;

    if (pMachEntry->UseCount == 0)      {
        //
        // This means we can now actually delete this DS_MACHINE structure
        //
        RtlRemoveUnicodePrefix(&Pkt->DSMachineTable,
                                   &pMachEntry->PrefixTableEntry);

        if (DeallocateMachine)
            PktDSMachineDestroy(pMachine, TRUE);

        //
        // Free the entry itself. Note that the UNICODE_STRING in the
        // entry gets freed up as part of above pMachine deletion.
        //
        DfsFree(pMachEntry);
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   PktServiceDestroy, public
//
//  Synopsis:   PktServiceDestroy destroys a service structure, and
//              optionally deallocates the structure itself.
//
//  Arguments:  [Victim] - the service structure to destroy
//              [DeallocateAll] - if True, indicates that the structure
//                  it self is to be deallocated, otherwise, only the
//                  strings within the structure are deallocated.
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID
PktServiceDestroy(
    IN  PDFS_SERVICE Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
)
{
    DebugTrace(+1, Dbg, "PktServiceDestroy: Entered\n", 0);

    if (ARGUMENT_PRESENT(Victim)) {

        if (Victim->ConnFile != NULL) {
            DfsCloseConnection(Victim);
            Victim->ConnFile = NULL;
        }
        if (Victim->Name.Buffer != NULL)
            DfsFree(Victim->Name.Buffer);
            Victim->Name.Buffer = NULL;

        if (Victim->Address.Buffer != NULL)
            DfsFree(Victim->Address.Buffer);
            Victim->Address.Buffer = NULL;

        //
        // Decrement the usage count. If it is to be deleted it will happen
        // automatically.
        //
        if (Victim->pMachEntry != NULL) {
            DfsDecrementMachEntryCount(Victim->pMachEntry, TRUE);
        }

        if (DeallocateAll)
            ExFreePool(Victim);
    } else
        DebugTrace(0, Dbg, "PktServiceDestroy: No Victim\n", 0 );

    DebugTrace(-1, Dbg, "PktServiceDestroy: Exit -> VOID\n", 0 );
}



//+-------------------------------------------------------------------------
//
//  Function:   PktEntryIdConstruct, public
//
//  Synopsis:   PktEntryIdConstruct creates a PKT Entry Id
//
//  Arguments:  [PktEntryId] - Where the new entry is placed
//              [Uid] - The UID of the new Pkt Entry
//              [Prefix] - The prefix of the new Pkt Entry
//              [ShortPrefix] - The 8.3 form of Prefix
//
//  Returns:    [STATUS_SUCCESS] - all is well.
//              [STATUS_INSUFFICIENT_RESOURCES] - could not allocate
//                  memory for the Prefix part of the Id.
//
//  Notes:      The UNICODE_STRING used in the Prefix of the Id is COPIED,
//              not MOVED!
//
//--------------------------------------------------------------------------
NTSTATUS
PktEntryIdConstruct(
    OUT PDFS_PKT_ENTRY_ID PktEntryId,
    IN  GUID *Uid,
    IN  UNICODE_STRING *Prefix,
    IN  UNICODE_STRING *ShortPrefix
)
{
    PUNICODE_STRING pus;

    DebugTrace(+1, Dbg, "PktEntryIdConstruct: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(PktEntryId));
    ASSERT(ARGUMENT_PRESENT(Prefix));

    //
    // Zero the memory
    //
    RtlZeroMemory(PktEntryId, sizeof(DFS_PKT_ENTRY_ID));

    //
    // deal with the prefix.
    //

    pus = &PktEntryId->Prefix;

    if (Prefix->Length != 0) {
        pus->Length = pus->MaximumLength = Prefix->Length;
        pus->Buffer = ExAllocatePoolWithTag(
                        PagedPool,
                        pus->Length,
                        ' sfD');
        if (pus->Buffer != NULL) {
            RtlCopyUnicodeString(pus, Prefix);
        } else {
            DebugTrace(-1,Dbg,"PktEntryIdConstruct: Exit -> %08lx\n",
                ULongToPtr( STATUS_INSUFFICIENT_RESOURCES ));
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    pus = &PktEntryId->ShortPrefix;

    if (ShortPrefix->Length != 0) {
        pus->Length = pus->MaximumLength = ShortPrefix->Length;
        pus->Buffer = ExAllocatePoolWithTag(
                        PagedPool,
                        pus->Length,
                        ' sfD');
        if (pus->Buffer != NULL) {
            RtlCopyUnicodeString(pus, ShortPrefix);
        } else {
            ExFreePool(PktEntryId->Prefix.Buffer);
            PktEntryId->Prefix.Buffer = NULL;
            DebugTrace(-1,Dbg,"PktEntryIdConstruct: Exit -> %08lx\n",
                ULongToPtr( STATUS_INSUFFICIENT_RESOURCES ));
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // deal with the GUID.
    //
    if (ARGUMENT_PRESENT(Uid)) {
        PktEntryId->Uid = (*Uid);
    }

    DebugTrace(-1,Dbg,"PktEntryIdConstruct: Exit -> %08lx\n",STATUS_SUCCESS);
    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   PktEntryIdDestroy, public
//
//  Synopsis:   PktEntryIdDestroy destroys a PKT Entry Id
//
//  Arguments:  [Victim] - Id to destroy
//              [DeallocateAll] - if true, indicates that the memory
//                  for the Id itself is to be release, otherwise,
//                  this memory is not released (only the memory for
//                  the UNICODE_STRING in the Prefix is released).
//
//  Returns:    VOID
//
//  Notes:      Memory for the UNICODE_STRING in the Prefix is released.
//
//--------------------------------------------------------------------------

VOID
PktEntryIdDestroy(
    IN  PDFS_PKT_ENTRY_ID Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
)
{
    DebugTrace(+1, Dbg, "PktEntryIdDestroy: Entered\n", 0);
    if (ARGUMENT_PRESENT(Victim)) {
        if (Victim->Prefix.Buffer != NULL)
            DfsFree(Victim->Prefix.Buffer);
        if (Victim->ShortPrefix.Buffer != NULL)
            DfsFree(Victim->ShortPrefix.Buffer);
        if (DeallocateAll)
            ExFreePool(Victim);
    } else
        DebugTrace(0, Dbg, "PktEntryIdDestroy: No Victim\n", 0 );
    DebugTrace(-1, Dbg, "PktEntryIdDestroy: Exit -> VOID\n", 0 );
}



//+-------------------------------------------------------------------------
//
//  Function:   PktEntryInfoDestroy, public
//
//  Synopsis:   PktEntryInfoDestroy destroys an info structure, and
//              optionally deallocates the structure itself.
//
//  Arguments:  [Victim] - the info structure to destroy
//              [DeallocateAll] - if True, indicates that the structure
//                  itself is to be deallocated, otherwise, only the
//                  service list within the structure is deallocated.
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------
VOID
PktEntryInfoDestroy(
    IN  PDFS_PKT_ENTRY_INFO Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
)
{
    DebugTrace(+1, Dbg, "PktEntryInfoDestroy: Entered\n", 0);

    if (ARGUMENT_PRESENT(Victim)) {

        ULONG i;

        for (i = 0; i < Victim->ServiceCount; i++)
            PktServiceDestroy(&Victim->ServiceList[i], FALSE);

        if (Victim->ServiceCount)
            ExFreePool(Victim->ServiceList);

        if (DeallocateAll)
            ExFreePool(Victim);
    } else
        DebugTrace(0, Dbg, "PktEntryInfoDestroy: No Victim\n", 0 );

    DebugTrace(-1, Dbg, "PktEntryInfoDestroy: Exit -> VOID\n", 0 );
}



//+-------------------------------------------------------------------------
//
//  Function:   DfspFixService
//
//  Synopsis:   This function should be called when a new service's DS_MACHINE
//              struct has to be adjusted to make sure there is a unique one
//              for each machine in the PKT.
//
//  Arguments:  [pService] -- The Service struct to fix up.
//
//  History:    23 August 1994          SudK    Created.
//
//--------------------------------------------------------------------------
NTSTATUS
DfspFixService(
    PDFS_SERVICE        pService
)
{

    NTSTATUS            status = STATUS_SUCCESS;
    UNICODE_STRING      ustrMachineName;
    PDS_MACHINE         pMachine;
    PUNICODE_PREFIX_TABLE_ENTRY pfxEntry;
    PDFS_MACHINE_ENTRY  machEntry;
    PDFS_PKT            Pkt;

    ASSERT(pService != NULL);
    ASSERT(pService->pMachEntry != NULL);
    pMachine = pService->pMachEntry->pMachine;
    if (pMachine->cPrincipals == 0)     {
        ASSERT(pService->Type && DFS_SERVICE_TYPE_DOWN_LEVEL);
        pService->pMachEntry->UseCount = 1;
        return(status);
    }
    //
    // We are called during PktCreateEntry. We already have appropriate locks
    //
    Pkt = _GetPkt();

    //
    // For now we only expect one principal.
    //
    ASSERT(pMachine->cPrincipals == 1);

    RtlInitUnicodeString(&ustrMachineName,
                        pMachine->prgpwszPrincipals[0]);


    ASSERT(ustrMachineName.Buffer != NULL);

    pfxEntry = RtlFindUnicodePrefix(&Pkt->DSMachineTable,&ustrMachineName,TRUE);
    if (pfxEntry != NULL) {
        //
        // In this case the DS_Machine structure already exists. Just use the
        // existing DS_Machine struct and bump the UseCount
        //
        machEntry = CONTAINING_RECORD(pfxEntry,
                                     DFS_MACHINE_ENTRY,
                                     PrefixTableEntry);

        machEntry->UseCount++;
        //
        // Even though we are "reusing" the Machine Entry, we might have a
        // better DS_MACHINE (ie, one with more transports) in the incoming
        // one. If so, lets use the new one.
        //

        if (pMachine->cTransports > machEntry->pMachine->cTransports) {
            PDS_MACHINE pTempMachine;

            DebugTrace(0, 0, "DfspFixService: Using new DS_MACHINE for [%wZ]\n", &ustrMachineName);

            pTempMachine = machEntry->pMachine;
            machEntry->pMachine = pMachine;
            pService->pMachEntry->pMachine = pTempMachine;

            RtlRemoveUnicodePrefix(
                &Pkt->DSMachineTable,
                &machEntry->PrefixTableEntry);

            machEntry->MachineName = ustrMachineName;

            RtlInsertUnicodePrefix(
                &Pkt->DSMachineTable,
                &machEntry->MachineName,
                &machEntry->PrefixTableEntry);

        }
        pService->pMachEntry = machEntry;

    } else {
        //
        // In this case the DS_Machine is not there in the table. Need to add
        // current one to the table.
        //
        machEntry = pService->pMachEntry;
        machEntry->UseCount = 1;
        machEntry->MachineName = ustrMachineName; // Use same mem in DS_MACHINE.

        //
        // Now insert the machEntry and then we are done. This better not fail.
        //
        if (!RtlInsertUnicodePrefix(&Pkt->DSMachineTable,
                               &machEntry->MachineName,
                               &machEntry->PrefixTableEntry))   {
            BugCheck("DFS Pkt inconsistent DfspFixService");
        }

    }
    return(status);
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsFixDSMachineStructs
//
//  Synopsis:   For the entry given this function makes sure that there is
//              only one DS_MACHINE structure in the PKT. If there isn't one
//              then one is registered. If there is one then the same one is
//              used and the current one in the DFS_SERVICE struct is freed up.
//
//  Arguments:  [pEntry] -- The PKT entry that has to be fixed.
//
//  Notes:      If this function fails then it will reset the pEntry to the
//              same format it was when it was called.
//
//  History:    22 Aug 1994     SudK    Created.
//
//--------------------------------------------------------------------------
NTSTATUS
DfsFixDSMachineStructs(
    PDFS_PKT_ENTRY      pEntry
)
{
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               i;
    PDFS_MACHINE_ENTRY  *apMachineEntry;
    PDFS_SERVICE        pService;

    if (pEntry->Info.ServiceCount == 0)
        return(status);

    //
    // In case of downlevel we do nothing
    //
    if (pEntry->Type & PKT_ENTRY_TYPE_NONCAIRO)
        return(status);

    apMachineEntry = ExAllocatePoolWithTag(
                                PagedPool,
                                sizeof(PDFS_MACHINE_ENTRY) * pEntry->Info.ServiceCount,
                                ' sfD');

    if (apMachineEntry == NULL)      {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    for (i=0; i < pEntry->Info.ServiceCount; i++) {
        //
        // First Save the current DS_Machine and then fix up
        //
        apMachineEntry[i] = pEntry->Info.ServiceList[i].pMachEntry;
        status = DfspFixService(&pEntry->Info.ServiceList[i]);
        if (!NT_SUCCESS(status))        {
            //
            // In this case we break and let the cleanup part below take care
            // of cleaning up everything.
            //
            break;
        }
    }

    if (!NT_SUCCESS(status))    {
        //
        // We need to cleanup in this case. I.E. reset all the PDS_MACHINEs
        // back to old values and decrement any usage counts on DS_MACHINE
        // structures.
        //
        ULONG j;
        for (j=0; j < i; j++)     {
            pService = &pEntry->Info.ServiceList[j];
            //
            // These have already been fixed up so decrement the count on the
            // pMachine structs. Dont want to deallocate the pMachine structs
            // if we were the last one to use it.
            //
            DfsDecrementMachEntryCount(pService->pMachEntry, FALSE);

            if (apMachineEntry[j] != pService->pMachEntry)
                pService->pMachEntry = apMachineEntry[j];
        }
    }
    else        {
        //
        // In this case everything went fine. So we need to free up the
        // DS_MACHINE structures that were superfluously allocated for now.
        //
        for (i=0; i<pEntry->Info.ServiceCount; i++)     {
            if (apMachineEntry[i] != pEntry->Info.ServiceList[i].pMachEntry) {
                //
                // This means that the pMachine in the service list got replaced
                // by a different one so let us free this one now.
                //
                PktDSMachineDestroy(apMachineEntry[i]->pMachine, TRUE);
                ExFreePool( apMachineEntry[i] );
            }
        }
    }

    ExFreePool(apMachineEntry);
    return(status);
}



//+-------------------------------------------------------------------------
//
//  Function:   PktEntryAssemble, private
//
//  Synopsis:   PktpEntryAssemble blindly constructs a new partition
//              table entry and places it in the PKT.  The caller must
//              have previously determined that no other entry with this
//              UID or Prefix existed.  The PKT must be acquired exclusively
//              for this operation.
//
//  Arguments:  [Entry] - a pointer to an entry to be filled.
//              [Pkt] - pointer to a initialized (and acquired
//                      exclusively) PKT
//              [EntryType] - the type of entry to assemble.
//              [EntryId] - pointer to the new entry's Id.
//              [EntryInfo] - pointer to the guts of the entry.
//
//  Returns:    [STATUS_SUCCESS] if no error.
//              [STATUS_INVALID_PARAMETER] - if the EntryId does not have a
//                  UID or a Prefix (no such thing as an anonymous entry).
//              [PKT_ENTRY_EXISTS] - a new prefix table entry could not
//                  be made.
//
//  Notes:      The EntryId and EntryInfo structures are MOVED (not
//              COPIED) to the new entry.  The memory used for UNICODE_STRINGS
//              and DFS_SERVICE arrays is used by the new entry.  The
//              associated fields in the EntryId and EntryInfo
//              structures passed as arguments are Zero'd to indicate that
//              the memory has been "deallocated" from these strutures and
//              reallocated to the newly create Entry.  Note that this
//              routine does not deallocate the EntryId structure or
//              the EntryInfo structure itself. On successful return from
//              this function, the EntryId structure will be modified
//              to have a NULL Prefix entry, and the EntryInfo structure
//              will be modified to have zero services and a null ServiceList
//              entry.
//
//--------------------------------------------------------------------------
NTSTATUS
PktEntryAssemble(
    IN  OUT PDFS_PKT_ENTRY Entry,
    IN      PDFS_PKT Pkt,
    IN      ULONG EntryType,
    IN      PDFS_PKT_ENTRY_ID EntryId,
    IN      PDFS_PKT_ENTRY_INFO EntryInfo OPTIONAL
)
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG               i;
    PDFS_SERVICE        pService;

    DebugTrace(+1, Dbg, "PktEntryAssemble: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(Entry) &&
           ARGUMENT_PRESENT(EntryId));

    //
    // We do not allow the creation of entries
    // without any Uid or Prefix.
    //

    if (NullGuid(&EntryId->Uid) && EntryId->Prefix.Length == 0) {
        DebugTrace(-1, Dbg, "PktEntryAssemble: Exit -> %08lx\n",
                    ULongToPtr( STATUS_INVALID_PARAMETER ) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Zero out the entry.
    //
    RtlZeroMemory(Entry, sizeof(DFS_PKT_ENTRY));

    //
    // Mundane initialization
    //
    Entry->NodeTypeCode =  DFS_NTC_PKT_ENTRY;
    Entry->NodeByteSize = sizeof(DFS_PKT_ENTRY);

    //
    // Initialize the USN to 1
    //
    Entry->USN = 1;

    //
    // Move the Type, Id, and Info into this entry.
    //
    Entry->Type = EntryType;
    PktpEntryIdMove(&Entry->Id, EntryId);
    if (ARGUMENT_PRESENT(EntryInfo))  {
        PktpEntryInfoMove(&Entry->Info, EntryInfo);

        for (i = 0; i < Entry->Info.ServiceCount; i++) {
            Entry->Info.ServiceList[i].pMachEntry->UseCount = 1;
        }

        //
        // If we are setting up a PKT_ENTRY_TYPE_REFERRAL_SVC entry then we want
        // to mark ALL of its services to be REFERRAL_SERVICES as well.
        //
        if (EntryType & PKT_ENTRY_TYPE_REFERRAL_SVC)    {
            pService = Entry->Info.ServiceList;
            for (i=0; i<Entry->Info.ServiceCount; i++)  {
                pService->Type = pService->Type | DFS_SERVICE_TYPE_REFERRAL;
                pService++;
            }
        }
        //
        // Now we need to make sure that there is only one copy of the
        // DS_MACHINE structures for each of the above services that we added.
        //
        if (!(EntryType & PKT_ENTRY_TYPE_NONCAIRO))    {
            status = DfsFixDSMachineStructs(Entry);
            if (!NT_SUCCESS(status))    {
                //
                // We messed up. This means that something is really messed up.
                //
                DebugTrace(0, 1,
                        "DFS: DfsFixDSMachineStructs failed for %wZ\n",
                        &Entry->Id.Prefix);

                PktpEntryIdMove(EntryId, &Entry->Id);

                if (ARGUMENT_PRESENT(EntryInfo))
                    PktpEntryInfoMove(EntryInfo, &Entry->Info);

                return(status);
            }
        }
    }
    //
    // Initialize the head of the subordinate list.
    //
    InitializeListHead(&Entry->SubordinateList);

    //
    // Initialize the head of the childList.
    //
    InitializeListHead(&Entry->ChildList);

    //
    // Try to get us into the prefix table.
    //

    if (DfsInsertUnicodePrefix(&Pkt->PrefixTable,
                               &Entry->Id.Prefix,
                               &Entry->PrefixTableEntry)) {

        //
        // We successfully created the prefix entry, so now we link
        // this entry into the PKT.
        //

        PktLinkEntry(Pkt, Entry);

        //
        // And insert into the short prefix table. We don't do error
        // recovery if this fails.
        //

        DfsInsertUnicodePrefix(&Pkt->ShortPrefixTable,
                               &Entry->Id.ShortPrefix,
                               &Entry->PrefixTableEntry);

    } else {

        //
        // We failed to get the entry into the prefix table.  This
        // can only happen if a prefix already exists, and a prefix
        // can only exist if we've really gotten messed up...
        // We disassemble the entry and return an error.
        //

        DebugTrace(0, 1,
                "DFS: PktEntryAssemble failed prefix table insert of %wZ\n",
                &Entry->Id.Prefix);

        PktpEntryIdMove(EntryId, &Entry->Id);
        if (ARGUMENT_PRESENT(EntryInfo))
            PktpEntryInfoMove(EntryInfo, &Entry->Info);

        status = DFS_STATUS_ENTRY_EXISTS;
    }

    DebugTrace(-1, Dbg, "PktEntryAssemble: Exit -> %08lX\n", ULongToPtr( status ) );
    return STATUS_SUCCESS;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktEntryReassemble, private
//
//  Synopsis:   PktpEntryReassemble blindly reconstructs a partition
//              table entry.  It provides a mechanism by which an existing
//              entry can be modified.  The caller must have previously
//              determined that no other entry with this UID or Prefix
//              existed. The PKT must be acquired exclusively for this
//              operation.
//
//  Arguments:  [Entry] - a pointer to an entry to be reassembled.
//              [Pkt] - pointer to a initialized (and acquired
//                      exclusively) PKT - must be provided if EntryId
//                      is provided.
//              [EntryType] - the type of entry to reassemble.
//              [EntryId] - pointer to the entry's new Id.
//              [EntryInfo] - pointer to the new guts of the entry.
//
//  Returns:    [STATUS_SUCCESS] if no error.
//              [STATUS_INVALID_PARAMETER] - if the EntryId does not have a
//                  UID or a Prefix (no such thing as an anonymous entry), or
//                  and EntryId was provided but a PKT argument was not.
//              [DFS_STATUS_ENTRY_EXISTS] - a new prefix table entry could not
//                  be made.
//              [DFS_STATUS_INCONSISTENT] - a new prefix table entry could
//                  not be made, and we could not back out of the operation.
//                  This status return indicates that the entry is no longer
//                  in the prefix table associated with the PKT and that
//                  it is likely that the PKT is inconsistent as a result.
//
//  Notes:      The EntryId and EntryInfo structures are MOVED (not
//              COPIED) to the entry, the old Id and Info are destroyed.
//              The memory used for UNICODE_STRINGS and DFS_SERVICE arrays
//              is used by the entry.  The associated fields in the EntryId
//              and EntryInfo structures passed as arguments are Zero'd to
//              indicate that the memory has been "deallocated" from these
//              structures and reallocated to the newly created Entry.  Note
//              that this routine does not deallocate the EntryId structure
//              or the EntryInfo structure itself.  On successful return from
//              this function, the EntryId structure will be modified
//              to have a NULL Prefix entry, and the EntryInfo structure
//              will be modified to have zero services and a null ServiceList
//              entry.
//
//--------------------------------------------------------------------------
NTSTATUS
PktEntryReassemble(
    IN  OUT PDFS_PKT_ENTRY Entry,
    IN      PDFS_PKT Pkt,
    IN      ULONG EntryType,
    IN      PDFS_PKT_ENTRY_ID EntryId OPTIONAL,
    IN      PDFS_PKT_ENTRY_INFO EntryInfo OPTIONAL
)
{
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               i;
    PDFS_SERVICE        pService;

    DebugTrace(+1, Dbg, "PktEntryReassemble: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(Entry) &&
           ARGUMENT_PRESENT(Pkt));

    if (ARGUMENT_PRESENT(EntryId)) {

        DFS_PKT_ENTRY_ID oldId;

        //
        // We do not allow the creation of entries
        // without any Prefix.
        //

        if (EntryId->Prefix.Length == 0) {
            DebugTrace(-1, Dbg, "PktEntryReassemble: Exit -> %08lx\n",
                                    ULongToPtr( STATUS_INVALID_PARAMETER ));
            return STATUS_INVALID_PARAMETER;
        }

        //
        // need to get rid of our current prefix info.  We save the
        // old Id in case we fail to reassemble the new entry.
        //

        DfsRemoveUnicodePrefix(&Pkt->PrefixTable, &Entry->Id.Prefix);
        DfsRemoveUnicodePrefix(&Pkt->ShortPrefixTable, &Entry->Id.ShortPrefix);
        PktpEntryIdMove(&oldId, &Entry->Id);

        //
        // Now we assemble the new Id and attempt to make a new entry
        // in the Pkt prefix table.
        //

        PktpEntryIdMove(&Entry->Id, EntryId);
        if (DfsInsertUnicodePrefix(&Pkt->PrefixTable,
                                   &Entry->Id.Prefix,
                                   &Entry->PrefixTableEntry))
        {
            USHORT len = oldId.Prefix.Length/sizeof(WCHAR);

            //
            // We get ourselves into the short prefix table
            //

            DfsInsertUnicodePrefix(&Pkt->ShortPrefixTable,
                                   &Entry->Id.ShortPrefix,
                                   &Entry->PrefixTableEntry);

            //
            // If we just dealt with a LocalVolEntry then we need to fix the
            // registry as well if the prefixes actually changed.
            //

            if ((Entry->LocalService != NULL) &&
                ((Entry->Id.Prefix.Length != oldId.Prefix.Length) ||
                (_wcsnicmp(oldId.Prefix.Buffer,Entry->Id.Prefix.Buffer,len)))) {

                if (!NT_SUCCESS(DfsChangeLvolInfoEntryPath(&Entry->Id.Uid,&Entry->Id.Prefix))) {
                    DebugTrace(0, Dbg,
                                "Failed to modify registry info for %wZ\n",
                                &oldId.Prefix);
                }
            }

            //
            // Everything looks good so its safe to unload the old Id.
            //

            PktEntryIdDestroy(&oldId, FALSE);

        } else {

            //
            // We were unable to make the new prefix entry, so we
            // attempt to back out and put things back the way
            // they were.
            //

            status = DFS_STATUS_ENTRY_EXISTS;

            PktpEntryIdMove(EntryId, &Entry->Id);
            PktpEntryIdMove(&Entry->Id, &oldId);

            status = DfsInsertInPrefixTable(&Pkt->PrefixTable,
                                        &Entry->Id.Prefix,
                                        &Entry->PrefixTableEntry);

            if( !NT_SUCCESS( status ) ) {

                //
                // We can't get things back to where they were. Return
                // the error that DfsInsertInPrefixTable returned to us
                // (probably STATUS_INSUFFICIENT_RESOURCES)
                //
                // Destory the entry since it can't be found.
                //
                PktEntryDestroy(Entry, Pkt, TRUE);
                DebugTrace(-1, Dbg, "PktEntryReassemble: Exit -> %08lx\n", ULongToPtr( status ));
                return status;

            } else {

                DfsInsertUnicodePrefix(&Pkt->ShortPrefixTable,
                                       &Entry->Id.ShortPrefix,
                                       &Entry->PrefixTableEntry);

            }

        }

    }

    //
    // Now we work on the entry info
    //

    if (NT_SUCCESS(status) && EntryInfo != 0) {

        //
        // Destroy the existing info structure and move the new
        // one into its place.  Note that the active service is
        // Nulled.
        //

        PktEntryInfoDestroy(&Entry->Info, FALSE);
        PktpEntryInfoMove(&Entry->Info, EntryInfo);

        for (i = 0; i < Entry->Info.ServiceCount; i++) {
            Entry->Info.ServiceList[i].pMachEntry->UseCount = 1;
        }

        if (EntryType & PKT_ENTRY_TYPE_REFERRAL_SVC)    {
            pService = Entry->Info.ServiceList;
            for (i=0; i<Entry->Info.ServiceCount; i++)  {
                pService->Type = pService->Type | DFS_SERVICE_TYPE_REFERRAL;
                pService++;
            }
        }

        Entry->ActiveService = NULL;

        //
        // Now we need to make sure that there is only one copy of the
        // DS_MACHINE structures for each of the above services that we added.
        //
        if (!(EntryType & PKT_ENTRY_TYPE_NONCAIRO))    {
            status = DfsFixDSMachineStructs(Entry);
            if (!NT_SUCCESS(status))    {
                //
                // We messed up. This means that something is really messed up.
                //
                DebugTrace(0, 1,
                        "DFS: DfsFixDSMachineStructs failed for %wZ\n",
                        &Entry->Id.Prefix);

                PktpEntryIdMove(EntryId, &Entry->Id);

                if (ARGUMENT_PRESENT(EntryInfo))
                    PktpEntryInfoMove(EntryInfo, &Entry->Info);

                return(status);
            }
        }
    }

    if (NT_SUCCESS(status)) {

        Entry->Type |= EntryType;

        //
        // If the new entry type is "local" we adjust all the
        // subordinates to indicate that they are all now
        // local exit points.
        //
        if (Entry->Type & PKT_ENTRY_TYPE_LOCAL) {

            PDFS_PKT_ENTRY subEntry;

            for (subEntry = PktEntryFirstSubordinate(Entry);
                subEntry != NULL;
                subEntry = PktEntryNextSubordinate(Entry, subEntry)) {

                    subEntry->Type |= PKT_ENTRY_TYPE_LOCAL_XPOINT;
            }
        }

        //
        // Finally, we update the USN
        //

        Entry->USN++;

        //
        // And turn off the STALE bit
        //

        Entry->Type &= ~PKT_ENTRY_TYPE_STALE;

        DebugTrace(0, Dbg, "Updated USN for %wz", &Entry->Id.Prefix);
        DebugTrace(0, Dbg, " to %d\n", ULongToPtr( Entry->USN ));
    }

    DebugTrace(-1, Dbg, "PktEntryReassemble: Exit -> %08lx\n", ULongToPtr( status ));
    return status;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktEntryDestroy, public
//
//  Synopsis:   PktEntryDestroy destroys an pkt entry structure, and
//              optionally deallocates the structure itself.
//
//  Arguments:  [Victim] - the entry structure to destroy
//              [Pkt] - pointer to the PKT this entry is in.
//              [DeallocateAll] - if True, indicates that the structure
//                  itself is to be deallocated, otherwise, only the
//                  service list within the structure is deallocated.
//
//  Returns:    VOID
//
//  Notes:      This should not be called on an entry that has a
//              local service attached, or which is a local exit point.
//
//--------------------------------------------------------------------------
VOID
PktEntryDestroy(
    IN  PDFS_PKT_ENTRY Victim OPTIONAL,
    IN  PDFS_PKT Pkt,
    IN  BOOLEAN DeallocateAll
)
{
    NTSTATUS Status;

    DebugTrace(+1, Dbg, "PktEntryDestroy: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(Pkt));

    //
    // Make sure we have a victim...
    //
    if (!ARGUMENT_PRESENT(Victim)) {
        DebugTrace(-1, Dbg, "PktEntryDestroy: Exit -> No Victim\n", 0);
        return;
    }

    //
    // We really don't expect to have a LocalService but then even if we
    // do have one due to running DFSINIT again etc. let us try to handle it.
    //

    if (Victim->LocalService != NULL)   {

        UNICODE_STRING a, b;

        RtlInitUnicodeString(&b, L"\\");
        Status = BuildLocalVolPath(&a, Victim->LocalService, &b);
        if (NT_SUCCESS(Status)) {
            PktEntryRemoveLocalService(Pkt, Victim, &a);
            ExFreePool(a.Buffer);
        }

    }
    //
    // Remove the entry from the prefix table and from the PKT.
    //

    DfsRemoveUnicodePrefix(&Pkt->PrefixTable, &(Victim->Id.Prefix));
    DfsRemoveUnicodePrefix(&Pkt->ShortPrefixTable, &(Victim->Id.ShortPrefix));
    PktUnlinkEntry(Pkt, Victim);

    //
    // We clear away all subordinates and parents.
    //
    PktEntryClearSubordinates(Victim);
    if (Victim->Superior)
        PktEntryUnlinkSubordinate(Victim->Superior, Victim);

    //
    // We clear all the children and parent pointers from here.
    //
    PktEntryClearChildren(Victim);
    if (Victim->ClosestDC)      {
        PktEntryUnlinkChild(Victim->ClosestDC, Victim);
    };

    //
    // Now destroy the body of the entry (id, and info).
    //

    Victim->ActiveService = NULL;
    PktEntryIdDestroy(&Victim->Id, FALSE);
    PktEntryInfoDestroy(&Victim->Info, FALSE);

    //
    // Deallocate everything if they want us to.
    //
    if (DeallocateAll)
        ExFreePool(Victim);

    DebugTrace(-1, Dbg, "PktEntryDestroy: Exit -> VOID\n", 0);
}


//+-------------------------------------------------------------------------
//
//  Function:   PktEntryClearSubordinates, public
//
//  Synopsis:   PktEntryClearSubordinates unlinks all subordinates from
//              this entry.
//
//  Arguments:  [PktEntry] - a pointer to an entry that is to have all its
//                  subordinates unlinked.
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------
VOID
PktEntryClearSubordinates(
    IN      PDFS_PKT_ENTRY PktEntry
)
{
    PDFS_PKT_ENTRY subEntry;

    DebugTrace(+1, Dbg, "PktEntryClearSubordinates: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(PktEntry));

    subEntry = PktEntryFirstSubordinate(PktEntry);
    while (subEntry) {
        PktEntryUnlinkSubordinate(PktEntry, subEntry);
        subEntry = PktEntryFirstSubordinate(PktEntry);
    }

    DebugTrace(-1, Dbg, "PktEntryClearSubordinates: Exit -> VOID\n", 0)
}



//+-------------------------------------------------------------------------
//
//  Function:   PktEntryClearChildren, public
//
//  Synopsis:   PktEntryClearChildren unlinks all children from
//              this entry.
//
//  Arguments:  [PktEntry] - a pointer to an entry that is to have all its
//                           children unlinked.
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID
PktEntryClearChildren(
    IN      PDFS_PKT_ENTRY PktEntry
)
{
    PDFS_PKT_ENTRY subEntry;

    DebugTrace(+1, Dbg, "PktEntryClearChildren: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(PktEntry));

    subEntry = PktEntryFirstChild(PktEntry);
    while (subEntry) {
        PktEntryUnlinkAndRelinkChild(PktEntry, subEntry);
        subEntry = PktEntryFirstChild(PktEntry);
    }

    DebugTrace(-1, Dbg, "PktEntryClearChildren: Exit -> VOID\n", 0)
}


//+-------------------------------------------------------------------------
//
//  Function:   PktRelationInfoConstruct, public
//
//  Synopsis:   PktRelationInfoConstruct creates a pkt relation info
//              structure for the entry id passed in.
//
//  Arguments:  [RelationInfo] -- a pointer to a relation info structure
//                      to be filled.
//              [Pkt] -- pointer to a initialized (and acquired) PKT
//              [PktEntryId] -- pointer to the Id of the entry whose
//                      subordinates we will find.
//
//  Returns:    [STATUS_SUCCESS] - all is well.
//              [STATUS_INSUFFICIENT_RESOURCES] - the operation could not
//                      get enough memory.
//              [DFS_STATUS_NO_SUCH_ENTRY] - no entry exists with an Id
//                  specified by PktEntryId.
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
PktRelationInfoConstruct(
    IN OUT  PDFS_PKT_RELATION_INFO RelationInfo,
    IN      PDFS_PKT Pkt,
    IN      PDFS_PKT_ENTRY_ID PktEntryId
)
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG subCnt = 0;
    PDFS_PKT_ENTRY entry;
    PDFS_PKT_ENTRY_ID subId = NULL;

    DebugTrace(+1, Dbg, "PktRelationalInfoConstruct: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(RelationInfo));
    ASSERT(ARGUMENT_PRESENT(Pkt));
    ASSERT(ARGUMENT_PRESENT(PktEntryId));

    //
    // We need to lookup the entry for which we are getting relation
    // information about.
    //

    entry = PktLookupEntryById(Pkt, PktEntryId);
    if (entry == NULL) {
        DebugTrace(-1, Dbg, "PktRelationalInfoConstruct: Exit -> %08lx\n",
                                ULongToPtr( DFS_STATUS_NO_SUCH_ENTRY ));
        return DFS_STATUS_NO_SUCH_ENTRY;
    }

    //
    // Construct the entry part of the Relational information
    //

    status = PktEntryIdConstruct(&RelationInfo->EntryId,
                                 &entry->Id.Uid,
                                 &entry->Id.Prefix,
                                 &entry->Id.ShortPrefix);

    //
    // Now go through and construct all the subordinate stuff.
    //

    if (NT_SUCCESS(status) && entry->SubordinateCount > 0) {

        //
        // Calculate how many subordinates and allocate enough room
        // to hold an array of Ids.
        //

        subCnt = entry->SubordinateCount;
        subId = ExAllocatePoolWithTag(PagedPool, sizeof(DFS_PKT_ENTRY_ID) * subCnt, ' sfD');

        if (subId != NULL) {

            ULONG i;
            PDFS_PKT_ENTRY subEntry;

            //
            // Go through all the subordinates and create copies of their
            // Ids in the Relation Info structure.
            //

            for ((i = 0, subEntry = PktEntryFirstSubordinate(entry));
                 (subEntry != NULL) && (i < subCnt);
                 (subEntry = PktEntryNextSubordinate(entry, subEntry), i++)) {

                status = PktEntryIdConstruct(&subId[i],
                                             &subEntry->Id.Uid,
                                             &subEntry->Id.Prefix,
                                             &subEntry->Id.ShortPrefix);

                if (!NT_SUCCESS(status)) {

                    ULONG j;

                    //
                    // If we get an error around here we back out all
                    // the Ids we've so far created...
                    //

                    for (j = 0; j < i; j++)
                        PktEntryIdDestroy(&subId[j], FALSE);

                    break;
                }
            }

            //
            // If sucessful, we assert that the subEntry is null (we've
            // go through the entire list of subordinates), and that the
            // count is the same as we expect.  If we weren't successful
            // we need to deallocate the array.
            //

            if (NT_SUCCESS(status)) {

                //
                // If sucess, we need to jump out now.
                // We assert that the subEntry is null (we've gone through
                // the entire list of subordinates), and that the
                // count is the same as we expect.
                //

                ASSERT((subEntry == NULL) && (i == subCnt));

                RelationInfo->SubordinateIdCount = subCnt;
                RelationInfo->SubordinateIdList = subId;

                DebugTrace(-1, Dbg,
                        "PktRelationalInfoConstruct: Exit -> %08lx\n", ULongToPtr( status ));
                return status;
            }

            //
            // At this point, we have hit an error.  We need to deallocate
            // the array.
            //

            ExFreePool(subId);
            subId = NULL;

            DebugTrace(0, Dbg,
                "PktRelationalInfoConstruct: Error filling in sublist!\n", 0);
        } else {

            status = STATUS_INSUFFICIENT_RESOURCES;

            DebugTrace(0, Dbg,
                "PktRelationalInfoConstruct: Error allocating sublist!\n", 0);
        }

        //
        // If we get here, we failed at allocating the array, or we
        // hit an error filling in the array.  In any case we need
        // to destroy the entry Id we made at the top.
        //

        PktEntryIdDestroy(&RelationInfo->EntryId, FALSE);
        subCnt = 0;
    }

    //
    // Fill in the relational info and exit.
    //

    RelationInfo->SubordinateIdCount = subCnt;
    RelationInfo->SubordinateIdList = subId;

    DebugTrace(-1, Dbg, "PktRelationalInfoConstruct: Exit -> %08lx\n", ULongToPtr( status ));
    return status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PktRelationInfoDestroy, public
//
//  Synopsis:   PktRelationInfoDestroy destroys a pkt relation info
//              structure.
//
//  Arguments:  [RelationInfo] - a pointer to a relation info structure
//                  to be destroyed.
//              [DeallocateAll] - if true, indicates that the info structure
//                  itself is to be deallocated, otherwise, the base
//                  structure is not deallocated.
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------
VOID
PktRelationInfoDestroy(
    IN      PDFS_PKT_RELATION_INFO RelationInfo,
    IN      BOOLEAN DeallocateAll
)
{
    DebugTrace(+1, Dbg, "PktRelationalInfoDestroy: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(RelationInfo));

    PktEntryIdDestroy(&RelationInfo->EntryId, FALSE);

    if (RelationInfo->SubordinateIdCount > 0) {

        ULONG i;

        for (i = 0; i < RelationInfo->SubordinateIdCount; i++)
            PktEntryIdDestroy(&RelationInfo->SubordinateIdList[i], FALSE);
        ExFreePool(RelationInfo->SubordinateIdList);
    }

    if (DeallocateAll)
        ExFreePool(RelationInfo);

    DebugTrace(-1, Dbg, "PktRelationalInfoDestroy: Exit -> VOID\n", 0);
}


//+-------------------------------------------------------------------------
//
//  Function:   PktRelationInfoValidate, public
//
//  Synopsis:   PktRelationInfoValidate compares a local version of the
//              relation info to a remote version.
//
//  Arguments:  [Local] - a pointer to a local version of relation info.
//              [Remote] - a pointer to a remote version of relation info.
//              [ServiceName] -- used exclusively for logging messages.
//
//  Returns:    [STATUS_SUCCESS] - both version are identical.
//
//              [DFS_STATUS_RESYNC_INFO] -- If relation info's did not match.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory conditions
//
//  Notes:      Note that the priority of error returns is such that no
//              checking is done if the entry point is inconsistent; no
//              exit point checking is done if the remote version has too
//              few exit points; checking for "too-many-xpoints" is not
//              done if a "bad-xpoint" is discovered.  "Too-many-xpoints"
//              is returned only if all the xpoints in the local version
//              are verified, and there are additional exit points in the
//              remote version left.
//
//--------------------------------------------------------------------------

NTSTATUS
PktRelationInfoValidate(
    IN      PDFS_PKT_RELATION_INFO      Local,
    IN      PDFS_PKT_RELATION_INFO      Remote,
    IN      UNICODE_STRING              ServiceName
)
{
    NTSTATUS            status = STATUS_SUCCESS;
    PUNICODE_STRING     lpfx;
    PUNICODE_STRING     rpfx;
    ULONG               i;
    ULONG               *pulExitPtUsed = NULL;
    UNICODE_STRING      puStr[3];

    DebugTrace(+1, Dbg, "PktRelationInfoValidate: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(Local));
    ASSERT(ARGUMENT_PRESENT(Remote));

    //
    // The GUIDs of this volume have already been matched otherwise we
    // would not be here.  So we don't even look at that.  We still
    // need to match the prefixes.  If the prefixes are different then we
    // need to fix that at this machine.
    //
    lpfx = &Local->EntryId.Prefix;
    rpfx = &Remote->EntryId.Prefix;

    if (RtlCompareUnicodeString(lpfx, rpfx, TRUE))      {
        //
        // The Prefixes are different we need to fix this now.  But first, let
        // us log this event.
        //
        DebugTrace(0, Dbg, "PktRelationInfoValidate: Prefixes did not match\n",
                                0);
        DebugTrace(0, Dbg, "Fixed Prefix %ws\n", rpfx->Buffer);
        DebugTrace(0, Dbg, "To be %ws\n", lpfx->Buffer);

        puStr[0] = Local->EntryId.Prefix;
        puStr[1] = Remote->EntryId.Prefix;
        puStr[2] = ServiceName;
        LogWriteMessage(PREFIX_MISMATCH, status, 3, puStr);

        status = DFS_STATUS_RESYNC_INFO;

    }

    if (Local->SubordinateIdCount != 0) {

        pulExitPtUsed = ExAllocatePoolWithTag(
                                    PagedPool,
                                    sizeof(ULONG)*(Local->SubordinateIdCount),
                                    ' sfD');

        if (pulExitPtUsed == NULL) {
            status = STATUS_NO_MEMORY;
            goto exit_with_status;
        }

        RtlZeroMemory(pulExitPtUsed, sizeof(ULONG)*(Local->SubordinateIdCount));
    }

    //
    // We step through each exit point in the remote knowledge and make sure
    // that is right.
    //

    puStr[1] = ServiceName;   // We set this once and for all.

    for (i = 0; i < Remote->SubordinateIdCount; i++) {

        ULONG   j;
        GUID    *lguid, *rguid;
        BOOLEAN bExitPtFound = FALSE;

        rpfx = &Remote->SubordinateIdList[i].Prefix;
        rguid = &Remote->SubordinateIdList[i].Uid;

        for (j = 0; j < Local->SubordinateIdCount; j++) {

            lpfx = &Local->SubordinateIdList[j].Prefix;
            lguid = &Local->SubordinateIdList[j].Uid;

            if (!RtlCompareUnicodeString(lpfx, rpfx, TRUE) &&
                GuidEqual(lguid, rguid)) {

                ASSERT(pulExitPtUsed[j] == FALSE);
                if (pulExitPtUsed[j] == TRUE)   {
                    status = DFS_STATUS_RESYNC_INFO;
                    DebugTrace(0, Dbg, "Found Duplicate ExitPts %ws\n",
                                rpfx->Buffer);
                }
                else
                    bExitPtFound = TRUE;

                pulExitPtUsed[j] = TRUE;
                break;
            }
        }

        if (bExitPtFound == FALSE) {
            //
            // In this case we have an exit point which the DC does not
            // recognise. We need to log this fact here.
            //
            puStr[0] = Remote->SubordinateIdList[i].Prefix;

            LogWriteMessage(EXTRA_EXIT_POINT, status, 2, puStr);

            status = DFS_STATUS_RESYNC_INFO;

        }

    }

    //
    // Now that we are done stepping through the list of Remote ExitPts and
    // either validating them or deleting them from the remote server we now
    // need to step through the local Info and see if we have any extra exit
    // points which the remote server needs to be informed about. This is
    // where the pulExitPtUsed array comes in.
    //
    for (i=0; i < Local->SubordinateIdCount; i++)       {

        if (pulExitPtUsed[i] == FALSE)  {

            status = DFS_STATUS_RESYNC_INFO;

            puStr[1] = Local->SubordinateIdList[i].Prefix;

            LogWriteMessage(MISSING_EXIT_POINT, status, 2, puStr);

        }

    }

    if (pulExitPtUsed != NULL) {

        ExFreePool(pulExitPtUsed);

    }

exit_with_status:

    DebugTrace(-1, Dbg, "PktRelationInfoValidate: Exit -> %08lx\n", ULongToPtr( status ) );

    return status;
}


//+---------------------------------------------------------------
//
// Function:    PktGetService
//
// Synopsis:    This function retrieves a specific service entry given a
//              PKT entry and the service name required.
//
// Arguments:   [Entry] -- The Pkt Entry that has to be scanned for the
//                      requested service.
//              [ServiceName] -- Look for this service entry.
//
// Returns:     NULL - If not found else a valid pointer to Service struct.
//
//----------------------------------------------------------------
PDFS_SERVICE
PktGetService(PDFS_PKT_ENTRY entry, PUNICODE_STRING pustrServiceName)
{
    PDFS_SERVICE        pService = NULL;
    ULONG               i;

    ASSERT(ARGUMENT_PRESENT(entry));
    ASSERT(ARGUMENT_PRESENT(pustrServiceName));

    pService = entry->Info.ServiceList;

    for (i=0; i < entry->Info.ServiceCount; i++)        {

        if (!RtlCompareUnicodeString(pustrServiceName, &pService->Name, TRUE)) {
            //
            // We found the required service entry. We can return this right
            // away.
            //
            return(pService);
        }
        pService = pService + 1;
    }

    //
    // We did not find any match. So we return back a NULL.
    //
    return(NULL);
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsNetInfoToConfigInfo
//
//  Synopsis:   Converts a LPNET_DFS_ENTRY_ID_CONTAINER to a
//              LPDFS_LOCAL_VOLUME_CONFIG
//
//  Arguments:  [EntryType] -- Type of local volume (see PKT_ENTRY_TYPE_XXX)
//              [ServiceType] -- Type of local service (DFS_SERVICE_TYPE_XXX)
//              [pwszStgId] -- Storage Id for local volume.
//              [pwszShareName] -- Lanman share name of local volume.
//              [pUid] -- Id of local volume.
//              [pwszEntryPrefix] -- Entry path of local volume.
//              [NetInfo] -- Pointer to LPNET_DFS_ENTRY_ID_CONTAINTER
//
//  Notes:      The returned pointer to DFS_LOCAL_VOLUME_CONFIG should be
//              freed using LocalVolumeConfigInfoDestroy( x, TRUE ).
//
//              If you change this routine, carefully update the cleanup
//              code in case of failure!
//
//  Returns:    Pointer to LPDFS_LOCAL_VOLUME_CONFIG if successful, NULL
//              otherwise.
//
//-----------------------------------------------------------------------------

PDFS_LOCAL_VOLUME_CONFIG
DfsNetInfoToConfigInfo(
    ULONG EntryType,
    ULONG ServiceType,
    LPWSTR pwszStgId,
    LPWSTR pwszShareName,
    GUID  *pUid,
    LPWSTR pwszEntryPrefix,
    LPWSTR pwszShortPrefix,
    LPNET_DFS_ENTRY_ID_CONTAINER NetInfo)
{
    PDFS_LOCAL_VOLUME_CONFIG configInfo;
    ULONG i = 0;
    NTSTATUS status;

    configInfo = (PDFS_LOCAL_VOLUME_CONFIG) ExAllocatePoolWithTag(
                                                PagedPool,
                                                sizeof(DFS_LOCAL_VOLUME_CONFIG) +
                                                    NetInfo->Count * sizeof(DFS_PKT_ENTRY_ID),
                                                ' sfD' );

    if (configInfo != NULL) {

        RtlZeroMemory( configInfo, sizeof(configInfo) );

        configInfo->EntryType = EntryType;
        configInfo->ServiceType = ServiceType;

        DFS_DUPLICATE_STRING( configInfo->StgId, pwszStgId, status );

        configInfo->RelationInfo.EntryId.Uid = *pUid;

        if (NT_SUCCESS(status)) {

            DFS_DUPLICATE_STRING( configInfo->Share, pwszShareName, status );

        }

        if (NT_SUCCESS(status)) {

            DFS_DUPLICATE_STRING(
                configInfo->RelationInfo.EntryId.Prefix,
                pwszEntryPrefix,
                status );

        }

        if (NT_SUCCESS(status) && pwszShortPrefix != NULL) {

            DFS_DUPLICATE_STRING(
                configInfo->RelationInfo.EntryId.ShortPrefix,
                pwszShortPrefix,
                status );

        }

        if (NT_SUCCESS(status)) {

            configInfo->RelationInfo.SubordinateIdCount = NetInfo->Count;

            configInfo->RelationInfo.SubordinateIdList =
                (PDFS_PKT_ENTRY_ID) (configInfo + 1);

            for (i = 0; (i < NetInfo->Count) && NT_SUCCESS(status); i++) {

                configInfo->RelationInfo.SubordinateIdList[i].Uid =
                    NetInfo->Buffer[i].Uid;

                DFS_DUPLICATE_STRING(
                        configInfo->RelationInfo.SubordinateIdList[i].Prefix,
                        NetInfo->Buffer[i].Prefix,
                        status);

            }

        }

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;

    }

    if (!NT_SUCCESS(status)) {

        //
        // Cleanup whatever we allocated. The cleanup routine works as
        // follows:
        //
        //      1. allocation of configInfo failed - Nothing to do
        //
        //      2. allocation of configInfo->StgId failed or
        //         allocation of configInfo->RelationInfo.EntryId failed - Set
        //              SubordinateIdCount to i (initialized to 0!) and call
        //              LocalVolumeConfigInfoDestroy.
        //
        //      3. allocation of a configInfo->RelationInfo Id failed - Set
        //              SubordinateIdCount to i and call
        //              LocalVolumeConfigInfoDestroy. Note that the i'th Id
        //              will have its Prefix.Buffer set to NULL!
        //

        if (configInfo != NULL) {

            configInfo->RelationInfo.SubordinateIdCount = i;

            LocalVolumeConfigInfoDestroy( configInfo, TRUE );

            configInfo = NULL;

        }

    }

    return( configInfo );

}


//+-------------------------------------------------------------------------
//
//  Function:   LocalVolumeConfigInfoDestroy, public
//
//  Synopsis:   LocalVolumeConfigInfoDestroy deallocates a
//              DFS_LOCAL_VOLUME_CONFIG structure.
//
//  Arguments:  [Victim] -- a pointer the DFS_LOCAL_VOLUME_CONFIG structure to
//                      free.
//              [DeallocateAll] -- if true, the memory for the base structure
//                  is freed as well.
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------

VOID
LocalVolumeConfigInfoDestroy(
    IN  PDFS_LOCAL_VOLUME_CONFIG Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
)
{

    DebugTrace(+1, Dbg, "LocalVolumeConfigInfoDestroy: Entered\n", 0);

    if (!ARGUMENT_PRESENT(Victim)) {

        DebugTrace(-1, Dbg, "LocalVolumeConfigInfoDestroy: Exit -> No Victim\n",0);
        return;
    }

    //
    // Get a hold of the relation info part and deallocate it.
    //

    PktRelationInfoDestroy(&Victim->RelationInfo, FALSE);

    //
    // If a StgId is specified, free it.
    //

    if (Victim->StgId.Buffer != NULL) {

        ExFreePool(Victim->StgId.Buffer);

    }

    //
    // If a ShareName is specified, free it.
    //

    if (Victim->Share.Buffer != NULL) {

        ExFreePool(Victim->Share.Buffer);

    }

    //
    // If specified, free the base structure as well.
    //

    if (DeallocateAll)
        ExFreePool(Victim);

    DebugTrace(-1, Dbg, "LocalVolumeConfigInfoDestroy: Exit -> VOID\n",0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\prefixp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       prefix.hxx
//
//  Contents:   PREFIX table definition
//
//  History:    SethuR -- Implemented
//
//  Notes:      The DFS prefix table data structure consists of three
//              entities and methods to manipulate them. They are the
//              DFS_PREFIX_TABLE_ENTRY,DFS_PREFIX_TABLE_BUCKET and the
//              DFS_PREFIX_TABLE.
//
//              The DFS_PREFIX_TABLE is a hash table of DFS_PREFIX_TABLE_ENTRY's
//              wherein collisions are resolved through linear chaining. The
//              hash table is organized as an array of collision lists
//              (DFS_PREFIX_TABLE_BUCKET). A brief description with each of
//              these entities is attached to the declaration.
//
//              There are certain characterstics that distinguish this
//              hash table from other hash tables. These are the extensions
//              provided to accomodate the special operations.
//
//--------------------------------------------------------------------------

#ifndef __PREFIXP_H__
#define __PREFIXP_H__

#include <prefix.h>


//--------------------------------------------------------------------------
//
// PREFIX TABLE UTILITIES
//
// A Path is a sequence of one or more name segments alternated with a
// distinguished concatenation character ( typically \ in FAT,NTFS,HPFS and
// / in UNIX file systems). These utilities are used to split a given path
// into the first path segment followed by the remainder of the path.
//
// SPLIT_PATH("foo\bar\bar1",Name,RemainingPath) binds Name to foo and
// RemainingPath to bar\bar1
//
// Similarly PROCESS_CASE_SENSITIVE_NAME and PROCESS_CASE_INSENSITIVE_NAME
// compute the hash signatures ( bucket no. ) for a given string.
//
//--------------------------------------------------------------------------


//
// MAX_PATH_SEGMENT_SIZE is simply used as a good size buffer to do prefix
// lookups and insertions. This should save us from having to allocate for
// most cases.
//

#define MAX_PATH_SEGMENT_SIZE  256
#define PATH_DELIMITER L'\\'

//+---------------------------------------------------------------------------
//
//  Function:   SPLIT_CASE_INSENSITIVE_PATH
//
//  Synopsis:   Split the path name around deleimiters.
//
//  Arguments:  [pPath] -- path to be split(PUNICODE_STRING)
//
//              [pName] -- the leftmost component of the path(PUNICODE_STRING)
//
//              [BucketNo] -- Hash Bucket no. corresponding to the name(ULONG)
//
//  SideEffects: the UNICODE_STRING pointed to by pName and BucketNo are
//               modified.
//
//  PreRequisite: pName be associated with a valid buffer.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define SPLIT_CASE_INSENSITIVE_PATH(pPath,pName,BucketNo)                    \
{                                                                            \
    WCHAR *pPathBuffer   = (pPath)->Buffer;                                  \
    WCHAR *pNameBuffer   = (pName)->Buffer;                                  \
    WCHAR *pPathBufferEnd = &pPathBuffer[(pPath)->Length / sizeof(WCHAR)];   \
                                                                             \
    BucketNo = 0;                                                            \
    while ((pPathBufferEnd != pPathBuffer) &&                                \
           ((*pNameBuffer = *pPathBuffer++) != PATH_DELIMITER))              \
    {                                                                        \
        *pNameBuffer = (*pNameBuffer < L'a')                                 \
                       ? *pNameBuffer                                        \
                       : ((*pNameBuffer < L'z')                              \
                          ? (*pNameBuffer - L'a' + L'A')                     \
                          : RtlUpcaseUnicodeChar(*pNameBuffer));             \
        BucketNo *= 131;                                                     \
        BucketNo += *pNameBuffer;                                            \
        pNameBuffer++;                                                       \
    }                                                                        \
                                                                             \
    BucketNo = BucketNo % NO_OF_HASH_BUCKETS;                                \
    *pNameBuffer = L'\0';                                                    \
    (pName)->Length = (USHORT)((CHAR *)pNameBuffer - (CHAR *)(pName)->Buffer);\
                                                                             \
    (pPath)->Length = (USHORT)((CHAR *)pPathBufferEnd - (CHAR *)pPathBuffer);\
    (pPath)->Buffer = pPathBuffer;                                           \
    DebugTrace(0, Dbg, "SPLIT_PATH:Path (%wZ)",pPath);                       \
    DebugTrace(0, Dbg, " Name (%wZ)\n",pName);                               \
}                                                                            \

//+---------------------------------------------------------------------------
//
//  Function:   SPLIT_CASE_SENSITIVE_PATH
//
//  Synopsis:   Split the patah name around deleimiters.
//
//  Arguments:  [pPath] -- path to be split(PUNICODE_STRING)
//
//              [pName] -- the leftmost component of the path(PUNICODE_STRING)
//
//              [BucketNo] -- Hash Bucket no. corresponding to the name(ULONG)
//
//  SideEffects: the UNICODE_STRING pointed to by pName and BucketNo are modified.
//
//  PreRequisite: pName be associated with a valid buffer.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define SPLIT_CASE_SENSITIVE_PATH(pPath,pName,BucketNo)                      \
{                                                                            \
    WCHAR *pPathBuffer   = (pPath)->Buffer;                                  \
    WCHAR *pNameBuffer   = (pName)->Buffer;                                  \
    WCHAR *pPathBufferEnd = &pPathBuffer[(pPath)->Length / sizeof(WCHAR)];   \
                                                                             \
    BucketNo = 0;                                                            \
    while ((pPathBufferEnd != pPathBuffer) &&                                \
           ((*pNameBuffer = *pPathBuffer++) != PATH_DELIMITER))              \
    {                                                                        \
        BucketNo *= 131;                                                     \
        BucketNo += *pNameBuffer;                                            \
        pNameBuffer++;                                                       \
    }                                                                        \
                                                                             \
    BucketNo = BucketNo % NO_OF_HASH_BUCKETS;                                \
    *pNameBuffer = L'\0';                                                    \
    (pName)->Length = (USHORT)((CHAR *)pNameBuffer - (CHAR *)(pName)->Buffer);\
                                                                             \
    (pPath)->Length = (USHORT)((CHAR *)pPathBufferEnd - (CHAR *)pPathBuffer);  \
    (pPath)->Buffer = pPathBuffer;                                           \
    DebugTrace(0, Dbg, "SPLIT_PATH:Path (%wZ)",pPath);                       \
    DebugTrace(0, Dbg, " Name (%wZ)\n",pName);                               \
}                                                                            \


//+---------------------------------------------------------------------------
//
//  Function:   INITIALIZE_BUCKET
//
//  Synopsis:   Initializes a hash bucket.
//
//  Arguments:  [Bucket] -- the bucket to be initialized(DFS_PREFIX_TABLE_BUCKET)
//
//  SideEffects: the bucket is intialized ( the collision list and count are
//               initialized
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INITIALIZE_BUCKET(Bucket)                                           \
{                                                                           \
   (Bucket).SentinelEntry.pNextEntry = &(Bucket).SentinelEntry;             \
   (Bucket).SentinelEntry.pPrevEntry = &(Bucket).SentinelEntry;             \
   (Bucket).NoOfEntries = 0;                                                \
}                                                                           \

//+---------------------------------------------------------------------------
//
//  Function:   LOOKUP_BUCKET
//
//  Synopsis:   lookups the bucket for an entry.
//
//  Arguments:  [Bucket] -- the bucket to be used (DFS_PREFIX_TABLE_BUCKET)
//
//              [Name]   -- the name to be looked up (UNICODE_STRING)
//
//              [pParentEntry] -- the parent entry of the entry we are
//                                searching for.
//
//              [pEntry] -- placeholder for the desired entry.
//
//              [fNameFound] -- indicates if the name was found.
//
//  SideEffects: Name,fNameFound and pEntry are modified
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//              We only store one copy of a string irrespective of the no. of
//              places it appears in, e.g. foo\bar and foo1\bar will result
//              in only one copy of bar being stored. This implies that the
//              lookup routine will have to return sufficient info. to prevent
//              the allocation of memory space for a string. If on exit
//              fNameFound is set to TRUE then this indicates that a similar
//              string was located in the table and the Name.Buffer field is
//              modified to point to the first instance of the string in
//              the table.
//
//----------------------------------------------------------------------------

#define LOOKUP_BUCKET(Bucket,Name,pParentEntry,pEntry,fNameFound)           \
{                                                                           \
    PDFS_PREFIX_TABLE_ENTRY pCurEntry = Bucket.SentinelEntry.pNextEntry;    \
                                                                            \
    DebugTrace(0, Dbg, "LOOKUP_BUCKET: Looking for (%wZ)\n", &Name);        \
    fNameFound = FALSE;                                                     \
    pEntry = NULL;                                                          \
                                                                            \
    while (pCurEntry != &Bucket.SentinelEntry)                              \
    {                                                                       \
        if (pCurEntry->PathSegment.Length == Name.Length)                   \
        {                                                                   \
            DebugTrace(0, Dbg, "LOOKUP_BUCKET: Looking at Entry with Name (%wZ)\n",&pCurEntry->PathSegment); \
            if (fNameFound &&                                               \
               (pCurEntry->PathSegment.Buffer == Name.Buffer))              \
            {                                                               \
                if (pCurEntry->pParentEntry == pParentEntry)                \
                {                                                           \
                    pEntry = pCurEntry;                                     \
                    break;                                                  \
                }                                                           \
            }                                                               \
            else if (!COMPARE_MEMORY(pCurEntry->PathSegment.Buffer,                 \
                             Name.Buffer,                                   \
                             Name.Length))                                  \
            {                                                               \
                fNameFound = TRUE;                                          \
                Name.Buffer = pCurEntry->PathSegment.Buffer;                \
                if (pCurEntry->pParentEntry == pParentEntry)                \
                {                                                           \
                    pEntry = pCurEntry;                                     \
                    break;                                                  \
                }                                                           \
            }                                                               \
        }                                                                   \
                                                                            \
        pCurEntry = pCurEntry->pNextEntry;                                  \
    }                                                                       \
}                                                                           \

//+---------------------------------------------------------------------------
//
//  Function:   INSERT_IN_BUCKET
//
//  Synopsis:   inserts the entry in the bucket
//
//  Arguments:  [Bucket] -- the bucket to be initialized(DFS_PREFIX_TABLE_BUCKET)
//
//              [pEntry] -- the entry to be inserted
//
//  SideEffects: Bucket is modified to include the entry
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INSERT_IN_BUCKET(Bucket,pEntry)                                     \
{                                                                           \
    (Bucket).NoOfEntries++;                                                 \
    (pEntry)->pPrevEntry = (Bucket).SentinelEntry.pPrevEntry;               \
    (pEntry)->pNextEntry = &((Bucket).SentinelEntry);                       \
    ((Bucket).SentinelEntry.pPrevEntry)->pNextEntry = (pEntry);             \
    (Bucket).SentinelEntry.pPrevEntry = (pEntry);                           \
}                                                                           \

//+---------------------------------------------------------------------------
//
//  Function:   REMOVE_FROM_BUCKET
//
//  Synopsis:   removes the entry from the bucket
//
//  Arguments:  [pEntry] -- the entry to be inserted
//
//  SideEffects: Bucket is modified to exclude the entry
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define REMOVE_FROM_BUCKET(pEntry)                                          \
{                                                                           \
    PDFS_PREFIX_TABLE_ENTRY pPrevEntry = (pEntry)->pPrevEntry;              \
    PDFS_PREFIX_TABLE_ENTRY pNextEntry = (pEntry)->pNextEntry;              \
                                                                            \
    pPrevEntry->pNextEntry = pNextEntry;                                    \
    pNextEntry->pPrevEntry = pPrevEntry;                                    \
}                                                                           \

//+---------------------------------------------------------------------------
//
//  Function:   INSERT_IN_CHILD_LIST
//
//  Synopsis:   Inserts this entry in the parent's list of children
//
//  Arguments:  [pEntry] -- the entry to be inserted
//
//              [pParentEntry] -- the entry into whose list of children
//                      pEntry has to be inserted.
//
//  SideEffects: Parent's list of children is modified.
//
//  History:    01-09-96  MilanS Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INSERT_IN_CHILD_LIST(pEntry, pParentEntry)                           \
{                                                                            \
    PDFS_PREFIX_TABLE_ENTRY pLastChild;                                      \
                                                                             \
    if (pParentEntry->pFirstChildEntry == NULL) {                            \
        pParentEntry->pFirstChildEntry = pEntry;                             \
    } else {                                                                 \
        for (pLastChild = pParentEntry->pFirstChildEntry;                    \
                pLastChild->pSiblingEntry != NULL;                           \
                    pLastChild = pLastChild->pSiblingEntry) {                \
             NOTHING;                                                        \
        }                                                                    \
        pLastChild->pSiblingEntry = pEntry;                                  \
    }                                                                        \
}

//+----------------------------------------------------------------------------
//
//  Function:   REMOVE_FROM_CHILD_LIST
//
//  Synopsis:   Removes an entry from its parent's list of children
//
//  Arguments:  [pEntry] -- the Entry to remove from children list.
//
//  SideEffects: The children list of pParentEntry is modified.
//
//  History:    01-09-96  MilanS Created
//
//  Notes:      Defined as a macro for inlining.
//
//              This routine will ASSERT if pEntry is not in the parent's
//              list of children.
//
//-----------------------------------------------------------------------------

#define REMOVE_FROM_CHILD_LIST(pEntry)                                       \
{                                                                            \
    PDFS_PREFIX_TABLE_ENTRY pParentEntry = pEntry->pParentEntry;             \
    PDFS_PREFIX_TABLE_ENTRY pPrevSibling;                                    \
                                                                             \
    if (pParentEntry->pFirstChildEntry == pEntry) {                          \
        pParentEntry->pFirstChildEntry = pEntry->pSiblingEntry;              \
    } else {                                                                 \
        for (pPrevSibling = pParentEntry->pFirstChildEntry;                  \
                pPrevSibling->pSiblingEntry != pEntry;                       \
                    pPrevSibling = pPrevSibling->pSiblingEntry) {            \
             ASSERT(pPrevSibling->pSiblingEntry != NULL);                    \
        }                                                                    \
        pPrevSibling->pSiblingEntry = pEntry->pSiblingEntry;                 \
    }                                                                        \
}

//+---------------------------------------------------------------------------
//
//  Function:   INITIALIZE_NAME_PAGE
//
//  Synopsis:   initializes the name page
//
//  Arguments:  [pNamePage] -- the NAME_PAGE to be initialized
//
//  SideEffects: the name page is initialized
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INITIALIZE_NAME_PAGE(pNamePage)                                      \
{                                                                            \
    pNamePage->pNextPage = NULL;                                             \
    pNamePage->cFreeSpace = FREESPACE_IN_NAME_PAGE - 1;                      \
    pNamePage->Names[FREESPACE_IN_NAME_PAGE - 1] = L'\0';                    \
}                                                                            \

//+---------------------------------------------------------------------------
//
//  Function:   INITIALIZE_PREFIX_TABLE_ENTRY
//
//  Synopsis:   initializes the prefix table entry
//
//  Arguments:  [pEntry] -- the entry to be initialized
//
//  SideEffects: the prefix table entry is modified
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INITIALIZE_PREFIX_TABLE_ENTRY(pEntry)                                \
{                                                                            \
    RtlZeroMemory( pEntry, sizeof( DFS_PREFIX_TABLE_ENTRY ) );               \
    (pEntry)->NoOfChildren = 1;                                              \
}                                                                            \

//+---------------------------------------------------------------------------
//
//  Function:   private fns. extern declarations
//
//----------------------------------------------------------------------------

extern
NTSTATUS _LookupPrefixTable(PDFS_PREFIX_TABLE        pTable,
                            UNICODE_STRING           *pPath,
                            UNICODE_STRING           *pSuffix,
                            PDFS_PREFIX_TABLE_ENTRY  *ppEntry);

//+---------------------------------------------------------------------------
//
//  Function:   ALLOCATION ROUTINES
//
//  Synopsis:   all the allocation routines are defined to be used in the KERNEL as
//              well as user mode. The KERNEL mode is turned on by defining KERNEL
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

extern
NTSTATUS
_InitializePrefixTableEntryAllocation(PDFS_PREFIX_TABLE pTable);

extern
PWSTR _AllocateNamePageEntry(PNAME_PAGE_LIST pPageList,ULONG cLength);

#ifdef KERNEL_MODE

#define ALLOCATE_NAME_PAGE() (PNAME_PAGE)ExAllocatePoolWithTag(PagedPool,sizeof(NAME_PAGE), ' sfD')

#define FREE_NAME_PAGE(pPage) ExFreePool(pPage)

#define ALLOCATE_NAME_PAGE_ENTRY(PageList,cLength)                           \
    ExAllocatePoolWithTag(PagedPool, cLength * sizeof(WCHAR), ' sfD');       \

#define FREE_NAME_PAGE_ENTRY(PageList,pName)

#define ALLOCATE_DFS_PREFIX_TABLE_ENTRY(pTable)                             \
 (PDFS_PREFIX_TABLE_ENTRY) ExAllocatePoolWithTag(PagedPool,sizeof(DFS_PREFIX_TABLE_ENTRY), ' sfD')

#define FREE_DFS_PREFIX_TABLE_ENTRY(pTable,pEntry)                           \
    if ((pEntry)->PathSegment.Buffer != NULL) {                              \
        ExFreePool((pEntry)->PathSegment.Buffer);                            \
    }                                                                        \
    ExFreePool((pEntry));

#define COMPARE_MEMORY(s,d,l)   (!RtlEqualMemory(s,d,l))

#else

#define ALLOCATE_NAME_PAGE() (PNAME_PAGE)malloc(sizeof(NAME_PAGE))

#define FREE_NAME_PAGE(pPage) free(pPage)

#define ALLOCATE_NAME_PAGE_ENTRY(PageList,cLength) malloc(cLength * sizeof(WCHAR))

#define FREE_NAME_PAGE_ENTRY(PageList,pName)

#define ALLOCATE_DFS_PREFIX_TABLE_ENTRY(pTable)                              \
    (PDFS_PREFIX_TABLE_ENTRY)malloc(sizeof(DFS_PREFIX_TABLE_ENTRY))

#define FREE_DFS_PREFIX_TABLE_ENTRY(pTable,pEntry) free((pEntry))

#define COMPARE_MEMORY(s,d,l)   memcmp(s,d,l)

#endif

#endif // __PREFIXP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\provider.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       provider.h
//
//  Contents:   Interface to the provider defining module
//
//  Classes:
//
//  Functions:  ProviderInit
//
//  History:    12 Sep 1992 	Milans created.
//
//-----------------------------------------------------------------------------

#ifndef _DFS_PROVIDERS_
#define _DFS_PROVIDERS_

NTSTATUS ProviderInit(void);

#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\prefixp.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       prefixp.c
//
//  Contents:   PREFIX table implementation
//
//  History:    SethuR -- Implemented
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef KERNEL_MODE

#include <dfsprocs.h>

#define Dbg DEBUG_TRACE_RTL

#else

#define DebugTrace(x,y,z,a)

#endif


#include <prefix.h>
#include <prefixp.h>

//
//  This macro takes a pointer (or ulong) and returns its rounded up quadword
//  value
//

#define QuadAlign(Ptr) (        \
    ((((ULONG)(Ptr)) + 7) & 0xfffffff8) \
    )

//+---------------------------------------------------------------------------
//
//  Function:   _InitializePrefixTableEntryAllocation
//
//  Synopsis:   private fn. for initializing prefix table entry allocation
//
//  Arguments:  [pTable] -- table to be initialized
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//                  STATUS_NO_MEMORY -- no resource available
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS _InitializePrefixTableEntryAllocation(PDFS_PREFIX_TABLE pTable)
{
    NTSTATUS status = STATUS_SUCCESS;

    return  status;
}


//+---------------------------------------------------------------------------
//
//  Function:   _AllocateNamePageEntry
//
//  Synopsis:   private fn. for allocating a name page entry
//
//  Arguments:  [pNamePageList] -- name page list to allocate from
//
//              [cLength]  -- length of the buffer in WCHAR's
//
//  Returns:    NULL if unsuccessfull otherwise valid pointer
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PWSTR _AllocateNamePageEntry(PNAME_PAGE_LIST pNamePageList,
                             ULONG           cLength)
{
   PNAME_PAGE pTempPage = pNamePageList->pFirstPage;
   PWSTR pBuffer = NULL;

   //
   // We alloc in chunks of FREESPACE_IN_NAME_PAGE, so if cLength is
   // greater than that, we can't alloc anything.
   //

   if (cLength > FREESPACE_IN_NAME_PAGE) {

        return NULL;

   }

   while (pTempPage != NULL)
   {
       if (pTempPage->cFreeSpace >= (LONG)cLength)
          break;
       else
          pTempPage = pTempPage->pNextPage;
   }

   if (pTempPage == NULL)
   {
       pTempPage = ALLOCATE_NAME_PAGE();

       if (pTempPage != NULL)
       {
           INITIALIZE_NAME_PAGE(pTempPage);
           pTempPage->pNextPage = pNamePageList->pFirstPage;
           pNamePageList->pFirstPage = pTempPage;
           pTempPage->cFreeSpace = FREESPACE_IN_NAME_PAGE;
       }
   }

   if ((pTempPage != NULL) && (pTempPage->cFreeSpace >= (LONG)cLength))
   {
       pTempPage->cFreeSpace -= cLength;
       pBuffer = &pTempPage->Names[pTempPage->cFreeSpace];
   }

   return pBuffer;
}

//+---------------------------------------------------------------------------
//
//  Function:   _LookupPrefixTable
//
//  Synopsis:   private fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pSuffix] -- the suffix that could not be found.
//
//              [ppEntry] -- placeholder for the matching entry for the prefix.
//
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//                  STATUS_OBJECT_PATH_NOT_FOUND -- no entry for the path
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS _LookupPrefixTable(PDFS_PREFIX_TABLE        pTable,
                            UNICODE_STRING           *pPath,
                            UNICODE_STRING           *pSuffix,
                            PDFS_PREFIX_TABLE_ENTRY  *ppEntry)
{
    NTSTATUS                status = STATUS_SUCCESS;
    UNICODE_STRING          Path = *pPath;
    WCHAR                   Buffer[MAX_PATH_SEGMENT_SIZE];
    PWCHAR                  NameBuffer = Buffer;
    USHORT                  cbNameBuffer = sizeof(Buffer);
    UNICODE_STRING          Name;
    ULONG                   BucketNo;
    BOOLEAN                 fPrefixFound = FALSE;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    PDFS_PREFIX_TABLE_ENTRY pParentEntry = &pTable->RootEntry;
    BOOLEAN                 fNameFound = FALSE;

    DebugTrace(0, Dbg, "_LookupPrefixTable -- Entry\n", 0);


    // The \ is treated as a special case. The test for all names starting with
    // a delimiter is done before we initiate the complete search process.

    if (Path.Buffer[0] == PATH_DELIMITER)
    {
        Path.Length = Path.Length - sizeof(WCHAR);
        Path.Buffer += 1; // Skip the path delimiter at the beginning.

        if (pTable->RootEntry.pData != NULL)
        {
            fPrefixFound = TRUE;
            *pSuffix     = Path;
            *ppEntry     = &pTable->RootEntry;
        }
    }

    if (Path.Length > MAX_PATH_SEGMENT_SIZE) {
        NameBuffer = ExAllocatePoolWithTag( NonPagedPool, Path.Length + sizeof(WCHAR), ' sfD' );
        if (NameBuffer == NULL) {
            DebugTrace(0, Dbg, "Unable to allocate %d non-paged bytes\n", (Path.Length + sizeof(WCHAR)) );
            return( STATUS_INSUFFICIENT_RESOURCES );
        } else {
            cbNameBuffer = Path.Length + sizeof(WCHAR);
        }
    }

    while (Path.Length > 0)
    {
        Name.Length = 0;
        Name.Buffer = NameBuffer;
        Name.MaximumLength = cbNameBuffer;

        if (pTable->CaseSensitive)
        {
            SPLIT_CASE_SENSITIVE_PATH(&Path,&Name,BucketNo);
        }
        else
        {
            SPLIT_CASE_INSENSITIVE_PATH(&Path,&Name,BucketNo);
        }

        if (Name.Length > 0)
        {
            // Process the name segment
            // Lookup the bucket to see if the entry exists.
            DebugTrace(0, Dbg, "LOOKUP_BUCKET: Bucket(%ld)", ULongToPtr( BucketNo ));
            DebugTrace(0, Dbg, "for Name(%wZ)\n", &Name);

            LOOKUP_BUCKET(pTable->Buckets[BucketNo],Name,pParentEntry,pEntry,fNameFound);

            DebugTrace(0, Dbg, "Returned pEntry(%lx)", pEntry);
            DebugTrace(0, Dbg, " and fNameFound(%s)\n",fNameFound ? "TRUE" : "FALSE" );

            if (pEntry != NULL)
            {
                // Cache the data available for this prefix if any.
                if (pEntry->pData != NULL)
                {
                    *pSuffix      = Path;
                    *ppEntry      = pEntry;
                    fPrefixFound  = TRUE;
                }
            }
            else
            {
                break;
            }

            // set the stage for processing the next name segment.
            pParentEntry = pEntry;
        }
    }

    if (!fPrefixFound)
    {
        status = STATUS_OBJECT_PATH_NOT_FOUND;
        DebugTrace(0, Dbg, "_LookupPrefixTable Error -- %lx\n", ULongToPtr( status ));
    }

    if (NameBuffer != Buffer) {
        ExFreePool( NameBuffer );
    }

    DebugTrace(-1, Dbg, "_LookupPrefixTable -- Exit\n", 0);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\pktfsctl.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       PKTFSCTL.C
//
//  Contents:   This module contains the implementation for FS controls
//              which manipulate the PKT.
//
//  Functions:  PktFsctrlGetRelationInfo -
//              PktFsctrlSetRelationInfo -
//              PktFsctrlIsChildnameLegal -
//              PktFsctrlCreateEntry -
//              PktFsctrlCreateSubordinateEntry -
//              PktFsctrlDestroyEntry -
//              PktFsctrlUpdateSiteCosts -
//              DfsAgePktEntries - Flush PKT entries periodically
//
//              Private Functions
//
//              DfspCreateExitPathOnRoot
//              PktpHashSiteCostList
//              PktpLookupSiteCost
//              PktpUpdateSiteCosts
//
//              Debug Only Functions
//
//              PktFsctrlFlushCache - Flush PKT entries on command
//
//  History:    12 Jul 1993     Alanw   Created from localvol.c.
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include <dfserr.h>
#include <netevent.h>
#include "fsctrl.h"
#include "log.h"
#include "know.h"

//
//  The local debug trace level
//

#define Dbg             (DEBUG_TRACE_LOCALVOL)

NTSTATUS
DfspCreateExitPathOnRoot(
    PDFS_SERVICE        service,
    PUNICODE_STRING     RemPath
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, PktFsctrlGetRelationInfo )
#pragma alloc_text( PAGE, PktFsctrlVerifyLocalVolumeKnowledge )
#pragma alloc_text( PAGE, PktFsctrlPruneLocalVolume )
#pragma alloc_text( PAGE, PktFsctrlCreateEntry )
#pragma alloc_text( PAGE, PktFsctrlCreateSubordinateEntry )
#pragma alloc_text( PAGE, PktFsctrlDestroyEntry )
#pragma alloc_text( PAGE, DfsAgePktEntries )
#pragma alloc_text( PAGE, DfspCreateExitPathOnRoot )


#if DBG
#pragma alloc_text( PAGE, PktFsctrlFlushCache )
#endif // DBG

#endif // ALLOC_PRAGMA


//+-------------------------------------------------------------------------
//
//  Function:   DfspCreateExitPathOnRoot
//
//  Synopsis:   This function creates an on disk exit path on the ORGROOT vol
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------
NTSTATUS
DfspCreateExitPathOnRoot(
    PDFS_SERVICE        service,
    PUNICODE_STRING     RemPath
)
{
    NTSTATUS            status = STATUS_SUCCESS;
    UNICODE_STRING      ExitPath;

    status = BuildLocalVolPath(&ExitPath, service, RemPath);
    if (NT_SUCCESS(status))     {
        //
        // For now make sure that StorageId Exists. Dont worry about the
        // actual exit pt bit on it. Fix when EXIT_PTs come along.
        //
        if (DfsFixExitPath(ExitPath.Buffer))    {
            DebugTrace(0, Dbg, "Succeeded to Create ExitPth on Orgroot %wZ\n",
                        &ExitPath);
            status = STATUS_SUCCESS;
        }
        else    {
            DebugTrace(0, Dbg, "Failed to Create ExitPath on Orgroot %wZ\n",
                        &ExitPath);
            status = DFS_STATUS_BAD_EXIT_POINT;
        }
        ExFreePool(ExitPath.Buffer);
    }
    else        {
        DebugTrace(0, Dbg, "Failed to create localvol path for %wZ \n",
                        RemPath);
    }

    return(status);
}


//+-------------------------------------------------------------------------
//
//  Function:   PktFsctrlGetRelationInfo, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Notes:      We only process this FSCTRL from the file system process,
//              never from the driver.
//
//--------------------------------------------------------------------------
NTSTATUS
PktFsctrlGetRelationInfo(
    IN PIRP  Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
)
{
    NTSTATUS status = STATUS_SUCCESS;
    DFS_PKT_ENTRY_ID      EntryId;
    DFS_PKT_RELATION_INFO relationInfo;
    ULONG       size = 0;
    MARSHAL_BUFFER marshalBuffer;

    STD_FSCTRL_PROLOGUE(PktFsctrlGetRelationInfo, TRUE, TRUE );

    //
    // Unmarshal the argument...
    //

    MarshalBufferInitialize(&marshalBuffer, InputBufferLength, InputBuffer);
    status = DfsRtlGet(&marshalBuffer, &MiPktEntryId, &EntryId);

    if (NT_SUCCESS(status))     {

        PDFS_PKT pkt = _GetPkt();
        status = PktRelationInfoConstruct(&relationInfo, pkt, &EntryId);

        if (NT_SUCCESS(status)) {
            DfsRtlSize(&MiPktRelationInfo, &relationInfo, &size);
            if (size>OutputBufferLength)        {

                    status = STATUS_INSUFFICIENT_RESOURCES;

            } else {
                    MarshalBufferInitialize(&marshalBuffer,
                                            size,
                                            OutputBuffer);
                    DfsRtlPut(&marshalBuffer,
                            &MiPktRelationInfo,
                            &relationInfo);
            }
            //
            // Now we have to free up the relation info struct that we
            // created above.
            //
            PktRelationInfoDestroy(&relationInfo, FALSE);
        }

        PktEntryIdDestroy(&EntryId, FALSE);

    } else
        DebugTrace(0, Dbg,
                        "PktFsctrlGetRelationInfo: Unmarshalling Error!\n", 0);

    Irp->IoStatus.Information = marshalBuffer.Current - marshalBuffer.First;
    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg, "PktFsctrlGetRelationInfo: Exit -> %08lx\n", ULongToPtr( status ));

    return(status);

}




//+-------------------------------------------------------------------------
//
//  Function:   PktFsctrlSetRelationInfo, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Notes:      We only process this FSCTRL from the file system process,
//              never from the driver.
//
//--------------------------------------------------------------------------
NTSTATUS
PktFsctrlSetRelationInfo(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{
    NTSTATUS status = STATUS_SUCCESS;
    DFS_PKT_RELATION_INFO relationInfo;
    MARSHAL_BUFFER marshalBuffer;

    STD_FSCTRL_PROLOGUE(PktFsctrlSetRelationInfo, TRUE, FALSE);

    //
    // Unmarshal the argument...
    //

    MarshalBufferInitialize(&marshalBuffer, InputBufferLength, InputBuffer);
    status = DfsRtlGet(&marshalBuffer, &MiPktRelationInfo, &relationInfo);

    if (NT_SUCCESS(status)) {

        PDFS_PKT pkt = _GetPkt();

        status = PktSetRelationInfo(
            pkt,
            &relationInfo
        );

        //
        // Need to deallocate the relationInfo...
        //

        PktRelationInfoDestroy(&relationInfo, FALSE);
    } else
        DebugTrace(0, Dbg,
                        "PktFsctrlSetRelationInfo: Unmarshalling Error!\n", 0);

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg, "PktFsctrlSetRelationInfo: Exit -> %08lx\n", ULongToPtr( status ));
    return status;
}


//+----------------------------------------------------------------------------
//
//  Function:   PktFsctrlIsChildnameLegal, public
//
//  Synopsis:   Determines whether the given childname is a valid one for
//              the given parent prefix.
//
//  Arguments:
//
//  Returns:    [STATUS_SUCCESS] -- The childname is legal
//
//              [STATUS_OBJECT_NAME_COLLISION] -- The childname conflicts with
//                      another child of the parent prefix.
//
//              [STATUS_OBJECT_PATH_NOT_FOUND] -- The childname is not a
//                      hierarchically related to the parent
//
//              [STATUS_INVALID_PARAMETER] -- The childname is bogus and
//                      doesn't start with a backslash
//
//              [STATUS_DATA_ERROR] -- If the input buffer could not be
//                      unmarshalled.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory unmarshalling
//                      input buffer.
//
//-----------------------------------------------------------------------------

NTSTATUS
PktFsctrlIsChildnameLegal(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength)
{
    NTSTATUS status;
    MARSHAL_BUFFER marshalBuffer;
    DFS_PKT_ENTRY_ID idParent;
    DFS_PKT_ENTRY_ID idChild;
    UNICODE_STRING ustrRem;

    STD_FSCTRL_PROLOGUE(PktFsctrlIsChildnameLegal, TRUE, FALSE);

    MarshalBufferInitialize( &marshalBuffer, InputBufferLength, InputBuffer );

    status = DfsRtlGet( &marshalBuffer, &MiPktEntryId, &idParent );

    if (NT_SUCCESS(status)) {

        status = DfsRtlGet( &marshalBuffer, &MiPktEntryId, &idChild );

        if (NT_SUCCESS(status)) {

            PDFS_PKT pPkt = _GetPkt();
            PDFS_PKT_ENTRY pPktEntry, pSuperiorEntry;

            ustrRem.Length = ustrRem.MaximumLength = 0;
            ustrRem.Buffer = NULL;

            PktAcquireShared( pPkt, TRUE );

            pPktEntry = PktLookupEntryByPrefix(
                            pPkt,
                            &idChild.Prefix,
                            &ustrRem);

            if (pPktEntry != NULL) {

                if (ustrRem.Length != 0) {

                    //
                    // There is no exact match for the child, so
                    // lets check to see if the match occured with the
                    // parent prefix.
                    //

                    if (RtlCompareUnicodeString(
                            &idParent.Prefix,
                                &pPktEntry->Id.Prefix,
                                    FALSE) == 0) {

                        status = STATUS_SUCCESS;

                    } else {

                        status = STATUS_OBJECT_NAME_COLLISION;

                    }

                } else {

                    //
                    // This might be a legal child name. Check to see if the
                    // passed-in child guid matches the one in the pkt entry
                    // we found; if so, then this is a valid child name.
                    //

                    if (GuidEqual(&idChild.Uid, &pPktEntry->Id.Uid)) {

                        status = STATUS_SUCCESS;

                    } else {

                        status = STATUS_OBJECT_NAME_COLLISION;

                    }

                }

            } else {

                status = STATUS_INVALID_PARAMETER;
            }

            PktRelease( pPkt );

            PktEntryIdDestroy(&idChild, FALSE);

        }

        PktEntryIdDestroy(&idParent, FALSE);
    }

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg, "PktFsctrlIsChildnameLegal: Exit -> %08lx\n", ULongToPtr( status ));

    return status;

}


//+-------------------------------------------------------------------------
//
//  Function:   PktFsctrlCreateEntry, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Notes:      We only process this FSCTRL from the file system process,
//              never from the driver.
//
//--------------------------------------------------------------------------
NTSTATUS
PktFsctrlCreateEntry(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{
    NTSTATUS status = STATUS_SUCCESS;
    DFS_PKT_CREATE_ENTRY_ARG arg;
    MARSHAL_BUFFER marshalBuffer;

    STD_FSCTRL_PROLOGUE(PktFsctrlCreateEntry, TRUE, FALSE);

    //
    // Unmarshal the argument...
    //

    MarshalBufferInitialize(&marshalBuffer, InputBufferLength, InputBuffer);
    status = DfsRtlGet(&marshalBuffer, &MiPktCreateEntryArg, &arg);

    if (NT_SUCCESS(status)) {

        PDFS_PKT pkt = _GetPkt();
        PDFS_PKT_ENTRY entry;
        ULONG i;

        PktAcquireExclusive(pkt, TRUE);
        try {
            status = PktCreateEntry(pkt,
                        arg.EntryType,
                        &arg.EntryId,
                        &arg.EntryInfo,
                        arg.CreateDisposition,
                        &entry);
        } finally {
            PktRelease(pkt);
        }

        //
        // Need to deallocate the entry Id...
        //
        PktEntryIdDestroy(&arg.EntryId, FALSE);
        PktEntryInfoDestroy(&arg.EntryInfo, FALSE);
    } else
        DebugTrace(0, Dbg, "PktFsctrlCreateEntry: Unmarshalling Error!\n", 0);

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg, "PktFsctrlCreateEntry: Exit -> %08lx\n", ULongToPtr( status ));
    return status;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktFsctrlCreateSubordinateEntry, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Notes:      We only process this FSCTRL from the file system process,
//              never from the driver.
//
//--------------------------------------------------------------------------
NTSTATUS
PktFsctrlCreateSubordinateEntry(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{
    NTSTATUS status = STATUS_SUCCESS;
    DFS_PKT_CREATE_SUBORDINATE_ENTRY_ARG arg;
    MARSHAL_BUFFER marshalBuffer;

    STD_FSCTRL_PROLOGUE(PktFsctrlCreateSubordinateEntry, TRUE, FALSE);

    //
    // Unmarshal the argument...
    //

    MarshalBufferInitialize(&marshalBuffer, InputBufferLength, InputBuffer);
    status = DfsRtlGet(&marshalBuffer, &MiPktCreateSubordinateEntryArg, &arg);

    if (NT_SUCCESS(status)) {

        PDFS_PKT pkt = _GetPkt();
        PDFS_PKT_ENTRY superior;
        PDFS_PKT_ENTRY subEntry;

        PktAcquireExclusive(pkt, TRUE);
        try {
            superior = PktLookupEntryById(pkt, &arg.EntryId);
            if (superior != NULL) {
                status = PktCreateSubordinateEntry(
                                pkt,
                                superior,
                                arg.SubEntryType,
                                &arg.SubEntryId,
                                &arg.SubEntryInfo,
                                arg.CreateDisposition,
                                &subEntry);
            } else {
                DebugTrace(0, Dbg,
                        "PktFsctrlCreateSubordinateEntry: No Superior!\n", 0);
                status = DFS_STATUS_NO_SUCH_ENTRY;
            }
        } finally {
            PktRelease(pkt);
        }

        //
        // Need to deallocate the entry Id...
        //
        PktEntryIdDestroy(&arg.EntryId, FALSE);
        PktEntryIdDestroy(&arg.SubEntryId, FALSE);
        PktEntryInfoDestroy(&arg.SubEntryInfo, FALSE);
    } else {
        DebugTrace(0, Dbg,
            "PktFsctrlCreateSubordinateEntry: Unmarshalling Error!\n", 0);
    }

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg,
        "PktFsctrlCreateSubordinateEntry: Exit -> %08lx\n", ULongToPtr( status ));
    return status;
}

//+-------------------------------------------------------------------------
//
//  Function:   PktFsctrlDestroyEntry, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Notes:      We only process this FSCTRL from the file system process,
//              never from the driver.
//
//--------------------------------------------------------------------------
NTSTATUS
PktFsctrlDestroyEntry(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{
    NTSTATUS status = STATUS_SUCCESS;
    DFS_PKT_ENTRY_ID    Id;
    MARSHAL_BUFFER marshalBuffer;
    PDFS_PKT_ENTRY      victim;

    STD_FSCTRL_PROLOGUE(PktFsctrlDestroyEntry, TRUE, FALSE);

    //
    // Unmarshal the argument...
    //

    MarshalBufferInitialize(&marshalBuffer, InputBufferLength, InputBuffer);
    status = DfsRtlGet(&marshalBuffer, &MiPktEntryId, &Id);

    if (NT_SUCCESS(status)) {

        PDFS_PKT pkt = _GetPkt();

        PktAcquireExclusive(pkt, TRUE);

        victim = PktLookupEntryById(pkt, &Id);

        if (victim != NULL) {
            //
            // If there is a local service we first need to delete this
            // explicitly before we call PktEntryDestroy.
            //
            if (victim->LocalService) {

                UNICODE_STRING a, b;

                RtlInitUnicodeString(&b, L"\\");
                BuildLocalVolPath(&a, victim->LocalService, &b);
                PktEntryRemoveLocalService(pkt, victim, &a);

            }
            PktEntryDestroy( victim, pkt, (BOOLEAN) TRUE);
        } else {
            DebugTrace(0, Dbg, "PktFsctrlDestroyEntry: No Superior!\n", 0);
            status = DFS_STATUS_NO_SUCH_ENTRY;
        }

        PktRelease(pkt);

        //
        // Need to deallocate the entry Id...
        //

        PktEntryIdDestroy(&Id, FALSE);
    } else
        DebugTrace(0, Dbg,
                "PktFsctrlDestroyEntry: Unmarshalling Error!\n", 0);

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg,
        "PktFsctrlDestroyEntry: Exit -> %08lx\n", ULongToPtr(status) );
    return status;
}


//+----------------------------------------------------------------------------
//
//  Function:   PktpPruneAllExtraVolumes
//
//  Synopsis:   Given a set of relation infos, this helper routine will
//              prune all local volume entries in the pkt that are not present
//              in the input set of relation infos.
//
//  Arguments:  [pPkt] -- The pkt to operate upon. Should be acquired
//                      exclusive
//              [cInfo] -- The number of config infos in the set
//              [pInfo] -- The set of config infos
//
//  Returns:    [STATUS_SUCCESS] -- No extra volumes were found.
//
//              [STATUS_REGISTRY_RECOVERED] -- Extra volumes were found and
//                      were successfully recovered.
//
//              [STATUS_UNSUCCESSFUL] -- Extra volumes were found but could
//                      not be deleted. A detailed error was logged.
//
//  Notes:      Assumes Pkt has been acquired exclusive
//
//-----------------------------------------------------------------------------

NTSTATUS
PktpPruneAllExtraVolumes(
    PDFS_PKT pPkt,
    ULONG cInfo,
    PDFS_LOCAL_VOLUME_CONFIG pInfo)
{
    //
    // 447479: init return status.
    NTSTATUS status, returnStatus = STATUS_UNSUCCESSFUL;
    PDFS_PKT_ENTRY pPktEntry;
    ULONG i, j;
    BOOLEAN fExtra;

    //
    // This is a pretty brute-force algorithm - for each Pkt entry that is
    // local, we scan the entire set of infos looking for a match. If a
    // match is not found, we delete the local volume.
    //

    pPktEntry = CONTAINING_RECORD(pPkt->EntryList.Flink, DFS_PKT_ENTRY, Link);

    for (i = 0, status = STATUS_SUCCESS;
            i < pPkt->EntryCount && NT_SUCCESS(status);
                i++) {

        for (j = 0, fExtra = TRUE; j < cInfo && fExtra; j++) {

            if (GuidEqual( &pInfo[j].RelationInfo.EntryId.Uid, &pPktEntry->Id.Uid)) {

                fExtra = FALSE;

            }

        }

        if (fExtra && !(pPktEntry->Type & PKT_ENTRY_TYPE_MACHINE)) {

            DebugTrace(0, Dbg,
                "Pruning Extra volume [%wZ]\n", &pPktEntry->Id.Prefix);

            status = DfsInternalDeleteLocalVolume( &pPktEntry->Id );

            if (!NT_SUCCESS(status)) {

                UNICODE_STRING puStr[2];

                puStr[0] = pPktEntry->Id.Prefix;

                puStr[1].MaximumLength = sizeof(L"LocalMachine");
                puStr[1].Length = puStr[1].MaximumLength - sizeof(WCHAR);
                puStr[1].Buffer = L"LocalMachine";

                LogWriteMessage(
                    EXTRA_VOLUME_NOT_DELETED,
                    status,
                    2,
                    puStr);

                returnStatus = STATUS_UNSUCCESSFUL;

            } else {

                returnStatus = STATUS_REGISTRY_RECOVERED;
            }

        }

        pPktEntry =
            CONTAINING_RECORD(pPktEntry->Link.Flink, DFS_PKT_ENTRY, Link);

    }

    return( returnStatus );

}

//+----------------------------------------------------------------------------
//
//  Function:   PktpResetOneLocalVolume
//
//  Synopsis:   Given a relation info (as sent over by the DC), this routine
//              will locate a pkt entry for the given volume. If such an
//              entry is found, this routine will try to sync up the relation
//              info to that of the passed in info.
//
//  Arguments:  [pPkt] -- The pkt to operate upon. Should be acquired
//                      exclusive
//              [pRemoteInfo] -- The DFS_LOCAL_VOLUME_CONFIG_INFO sent by the
//                      DC.
//
//  Returns:    [STATUS_SUCCESS] -- Either there is no such local volume in
//                      the Pkt, or the local volume's relation info is in
//                      exact sync.
//
//              [STATUS_REGISTRY_RECOVERED] -- Found a local volume, and
//                      steps were taken to bring it in sync with the
//                      passed in relation info.
//
//              [STATUS_UNSUCCESSFUL] -- Found a local volume, and in
//                      taking steps to bring it in sync, an error was
//                      encountered. A detailed message has been logged.
//
//  History:    April 6, 1995           Milans created
//
//-----------------------------------------------------------------------------

NTSTATUS
PktpResetOneLocalVolume(
    PDFS_PKT pPkt,
    PDFS_LOCAL_VOLUME_CONFIG pRemoteInfo)
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDFS_PKT_ENTRY      pPktEntry;
    UNICODE_STRING      LocalMachStr;

    LocalMachStr.MaximumLength = sizeof(L"LocalMachine");
    LocalMachStr.Length = LocalMachStr.MaximumLength - sizeof(WCHAR);
    LocalMachStr.Buffer = L"LocalMachine";

    pPktEntry = PktLookupEntryByUid( pPkt, &pRemoteInfo->RelationInfo.EntryId.Uid );

    if (pPktEntry != NULL) {

        DFS_PKT_RELATION_INFO       LocalInfo;

        //
        // We found a matching pkt entry in the local pkt. Lets see
        // if it is in sync with the input relation info.
        //

        status = PktRelationInfoConstruct(
                    &LocalInfo,
                    pPkt,
                    &pPktEntry->Id);

        if (NT_SUCCESS(status)) {

            status = PktRelationInfoValidate(
                        &LocalInfo,
                        &pRemoteInfo->RelationInfo,
                        LocalMachStr);

            if (status == DFS_STATUS_RESYNC_INFO) {

                status = PktpFixupRelationInfo(
                                &LocalInfo,
                                &pRemoteInfo->RelationInfo);

                if (NT_SUCCESS(status)) {

                    status = STATUS_REGISTRY_RECOVERED;

                }

            }

        }

    } else {

        status = DFS_STATUS_NOSUCH_LOCAL_VOLUME;

    }

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   PktpCreateIfMissing
//
//  Synopsis:   Given a relation info for a local volume, this routine
//              will create a local volume matching the relation info if
//              a volume with the given guid does not already exist.
//
//  Arguments:  [pPkt] -- The pkt to operate upon. Should be acquired
//                      exclusive
//              [pInfo] -- The local volume config info required to recreate
//                      the local volume.
//
//  Returns:    [STATUS_SUCCESS] -- The local volume already exists. Doesn't
//                      guarantee that the relation info matches, just that
//                      there is already a pkt entry for the given guid.
//
//              [STATUS_REGISTRY_RECOVERED] -- The local volume was missing
//                      and was successfully recreated.
//
//              [STATUS_UNSUCCESSFUL] -- The local volume is missing, and
//                      an error was encountered while recreating it; a
//                      more detailed error message has been logged.
//
//  History:    April 6, 1995           Milans created
//
//-----------------------------------------------------------------------------

NTSTATUS
PktpCreateIfMissing(
    PDFS_PKT pPkt,
    PDFS_LOCAL_VOLUME_CONFIG pInfo)
{

    NTSTATUS            status = STATUS_SUCCESS;
    PDFS_PKT_ENTRY      pPktEntry;

    pPktEntry = PktLookupEntryByUid( pPkt, &pInfo->RelationInfo.EntryId.Uid );

    if (pPktEntry == NULL) {

        //
        // There is no local volume matching pInfo. We try to recreate it.
        //

        pInfo->EntryType = PKT_ENTRY_TYPE_CAIRO;
        pInfo->ServiceType |= DFS_SERVICE_TYPE_MASTER;

        status = DfsInternalCreateLocalPartition(
                    &pInfo->StgId,
                    TRUE,
                    pInfo);

        if (!NT_SUCCESS(status)) {

            UNICODE_STRING puStr[2];

            puStr[0] = pInfo->RelationInfo.EntryId.Prefix;

            puStr[1].MaximumLength = sizeof(L"LocalMachine");
            puStr[1].Length = puStr[1].MaximumLength - sizeof(WCHAR);
            puStr[1].Buffer = L"LocalMachine";

            LogWriteMessage(
                MISSING_VOLUME_NOT_CREATED,
                status,
                2,
                puStr);

            status = STATUS_UNSUCCESSFUL;

        } else {

            status = STATUS_REGISTRY_RECOVERED;
        }

    }

    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   PktpResetLocalVolumes
//
//  Synopsis:   Given an array of relation infos for local volumes, this
//              routine will set the pkt to match the entire set of infos.
//              Local volumes in the pkt but not in the set of infos will
//              be deleted. Local volumes in the pkt and in the set will
//              be modified if needed to match the info in the set. Lastly,
//              infos in the set but not in the pkt will result in a new
//              local volume being created.
//
//  Arguments:  [cInfo] -- The number of config infos passed in.
//              [pInfo] -- The array of DFS_LOCAL_VOLUME_CONFIG structs.
//
//  Returns:    [STATUS_SUCCESS] -- The pkt is already in sync with the
//                      passed in set of relation infos.
//
//              [STATUS_REGISTRY_RECOVERED] -- The pkt was successfully
//                      brought in sync with the passed in infos; some
//                      needed changes were made and messages were logged.
//                      THIS IS AN NT INFORMATION STATUS CODE!
//
//              [STATUS_UNSUCCESSFUL] -- Unable to bring the pkt in sync;
//                      The problem was logged.
//
//-----------------------------------------------------------------------------

NTSTATUS
PktpResetLocalVolumes(
    ULONG cInfo,
    PDFS_LOCAL_VOLUME_CONFIG pInfo)
{

    PDFS_PKT pPkt;
    NTSTATUS status, returnStatus;
    ULONG i;

    pPkt = _GetPkt();

    PktAcquireExclusive( pPkt, TRUE );

    //
    // First, we need to see if we have any extra volumes, and if so, we
    // need to prune them
    //

    status = PktpPruneAllExtraVolumes( pPkt, cInfo, pInfo );

    if (NT_SUCCESS(status)) {

        returnStatus = status;

        //
        // Next, we need to sync up all the local volumes which are
        // out of sync
        //

        for (i = 0; i < cInfo && NT_SUCCESS(status); i++) {

            status = PktpResetOneLocalVolume( pPkt, &pInfo[i] );

            if (status == STATUS_REGISTRY_RECOVERED) {

                returnStatus = status;

            }

        }

        //
        // Lastly, we need to create any missing volumes
        //

        for (i = 0; i < cInfo && NT_SUCCESS(status); i++) {

            status = PktpCreateIfMissing( pPkt, &pInfo[i] );

            if (status == STATUS_REGISTRY_RECOVERED) {

                returnStatus = status;

            }

        }

    }

    PktRelease( pPkt );

    if (!NT_SUCCESS(status)) {

        returnStatus = STATUS_UNSUCCESSFUL;

    }

    return( returnStatus );

}

//+----------------------------------------------------------------------------
//
//  Function:   PktFsctrlSetServerInfo
//
//  Synopsis:   During the course of Dfs admin operations, the DC might
//              discover that a particular server's knowledge does not agree
//              with its own. If that is the case, the DC will try to force
//              the server to sync up to its knowledge.
//
//  Arguments:
//
//  Returns:    [STATUS_SUCCESS] -- The pkt is already in sync with the
//                      passed in set of relation infos.
//
//              [STATUS_REGISTRY_RECOVERED] -- The pkt was successfully
//                      brought in sync with the passed in infos; some
//                      needed changes were made and messages were logged.
//                      THIS IS AN NT INFORMATION STATUS CODE!
//
//              [STATUS_UNSUCCESSFUL] -- Unable to bring the pkt in sync;
//                      The problem was logged.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Unable to unmarshal
//                      arguments or otherwise out of memory
//
//              [STATUS_INVALID_DOMAIN_ROLE] -- Can't set server info because
//                      this machine is a DC.
//
//-----------------------------------------------------------------------------

NTSTATUS
PktFsctrlSetServerInfo(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength)
{
    NTSTATUS status = STATUS_SUCCESS;
    MARSHAL_BUFFER marshalBuffer;
    ULONG    i, cInfo;
    PDFS_LOCAL_VOLUME_CONFIG pInfos = NULL;

    STD_FSCTRL_PROLOGUE(PktFsctrlSetServerInfo, TRUE, FALSE);

    //
    // First, check to see if this machine is a DC. If so, we should not
    // muck with our Pkt!
    //

    if (DfsData.MachineState == DFS_ROOT_SERVER) {

        DebugTrace(0, Dbg, "Ignoring SetServerInfo call on DC!\n", 0);

        status = STATUS_INVALID_DOMAIN_ROLE;

    } else {

        MarshalBufferInitialize( &marshalBuffer, InputBufferLength, InputBuffer );

        status = DfsRtlGetUlong( &marshalBuffer, &cInfo );

    }

    if (NT_SUCCESS(status) && cInfo > 0) {

        //
        // We want to get all the config infos first, and then fix up each
        // instead of unmarshalling and fixing them one by one. This way,
        // we won't get messeded up if we hit an unmarshalling error after
        // having fixed up some of our local volumes.
        //

        ULONG cbSize;

        cbSize = sizeof(DFS_LOCAL_VOLUME_CONFIG) * cInfo;

        if ((cbSize / cInfo) == sizeof(DFS_LOCAL_VOLUME_CONFIG)) {

            pInfos = ExAllocatePoolWithTag(PagedPool,cbSize, ' sfD');

            if (pInfos != NULL) {

                DebugTrace(0, Dbg, "Unmarshalling %d Config Infos\n", ULongToPtr( cInfo ));

                for (i = 0; i < cInfo && NT_SUCCESS(status); i++) {

                    status = DfsRtlGet(
                                &marshalBuffer,
                                &MiLocalVolumeConfig,
                                &pInfos[i]);

                }

                if (!NT_SUCCESS(status)) {

                    //
                    // Unmarshalling error - cleanup
                    //

                    DebugTrace(0, Dbg, "Error %08lx unmarshalling ", ULongToPtr( status ));
                    DebugTrace(0, Dbg, "the %d th relation info", ULongToPtr( i ));

                    for ( ; i > 0; i--) {

                        LocalVolumeConfigInfoDestroy( &pInfos[i-1], FALSE );

                    }

                }

            } else {

                DebugTrace(0, Dbg, "Unable to allocate %d bytes\n", ULongToPtr( cbSize ));

                status = STATUS_INSUFFICIENT_RESOURCES;

            }

        } else {

            DebugTrace(0, Dbg, "Interger overflow in %s\n", __FILE__);

            status = STATUS_INVALID_PARAMETER;

        }

        if (NT_SUCCESS(status)) {

            DebugTrace(0, Dbg, "Successfully unmarshalled %d Infos\n", ULongToPtr( cInfo ));

            status = PktpResetLocalVolumes( cInfo, pInfos );

            for (i = 0; i < cInfo; i++) {

                LocalVolumeConfigInfoDestroy( &pInfos[i], FALSE );

            }

        }

    } else {

        DebugTrace(0, Dbg, "Error %08lx getting count\n", ULongToPtr( status ));

    }
    
    if (pInfos != NULL) {

        ExFreePool( pInfos );

    }


    DfsCompleteRequest( Irp, status );

    DebugTrace(-1,Dbg, "PktFsctrlSetServerInfo: Exit -> %08lx\n", ULongToPtr( status ));

    return(status);

}


//+------------------------------------------------------------------
//
//  Function:   PktFsctrlVerifyLocalVolumeKnowledge
//
//  Synopsis:   This method runs on a Dfs Server and validates the local
//              volume knowledge with the one passed in.
//
//  Arguments:  [InputBuffer] -- Marshalled DFS_PKT_RELATION_INFO to compare
//                      with.
//
//              [InputBufferLength] -- the length in bytes of InputBuffer
//
//  Returns:    [STATUS_SUCCESS] -- Verified that local volume knowledge was
//                      already in sync with passed in argument.
//
//              [STATUS_REGISTRY_RECOVERED] -- Synced up local volume
//                      knowledge with passed in argument
//
//              [STATUS_UNSUCCESSFUL] -- Unable to fully sync up - a message
//                      was logged to the local event log.
//
//              [STATUS_DATA_ERROR] -- Passed in argument could not be
//                      unmarshalled.
//
//              [DFS_STATUS_NOSUCH_LOCAL_VOLUME] -- Local volume not found.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory.
//
//-------------------------------------------------------------------

NTSTATUS
PktFsctrlVerifyLocalVolumeKnowledge(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{

    NTSTATUS            status = STATUS_SUCCESS;
    MARSHAL_BUFFER      marshalBuffer;
    DFS_LOCAL_VOLUME_CONFIG remoteInfo;
    PDFS_PKT            pkt = _GetPkt();

    STD_FSCTRL_PROLOGUE(PktFsctrlVerifyLocalVolumeKnowledge, TRUE, FALSE);

    //
    // unmarshal the arguments...
    //

    MarshalBufferInitialize(&marshalBuffer, InputBufferLength, InputBuffer);

    RtlZeroMemory(&remoteInfo, sizeof(remoteInfo));

    status = DfsRtlGet(
                &marshalBuffer,
                &MiPktRelationInfo,
                &remoteInfo.RelationInfo);

    if (NT_SUCCESS(status)) {

        PktAcquireExclusive(pkt, TRUE);

        status = PktpResetOneLocalVolume(pkt, &remoteInfo);

        PktRelease(pkt);

        PktRelationInfoDestroy(&remoteInfo.RelationInfo, FALSE);

    } else
        DebugTrace(0, Dbg,
                "PktFsctrlVerifyLocalVolumeKnowledge: Unmarshalling Error\n",0);

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg, "DfsFsctrlVerifyLocalVolumeKnowledge: Exit -> %08lx\n",
                ULongToPtr( status ));
    return status;
}


//+----------------------------------------------------------------------------
//
//  Function:   PktFsctrlPruneLocalVolume, public
//
//  Synopsis:   Prunes information about an extra local volume.
//
//  Arguments:  [InputBuffer] -- Marshalled EntryId of the local volume.
//
//              [InputBufferLength] -- length of InputBuffer
//
//  Returns:    [STATUS_REGISTRY_RECOVERED] -- Volume pruned successfully.
//
//              [STATUS_UNSUCCESSFUL] -- Unable to delete volume - proper
//                      event has been logged to eventlog
//
//              [STATUS_DATA_ERROR] -- Unable to unmarshal input arguments
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory
//
//-----------------------------------------------------------------------------

NTSTATUS
PktFsctrlPruneLocalVolume(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{

    NTSTATUS            status = STATUS_SUCCESS;
    MARSHAL_BUFFER      marshalBuffer;
    DFS_PKT_ENTRY_ID   EntryId;
    PDFS_PKT            pkt = _GetPkt();

    STD_FSCTRL_PROLOGUE(PktFsctrlPruneLocalVolume, TRUE, FALSE);

    //
    // unmarshal the arguments...
    //

    MarshalBufferInitialize(&marshalBuffer, InputBufferLength, InputBuffer);

    status = DfsRtlGet(
                &marshalBuffer,
                &MiPktEntryId,
                &EntryId);

    if (NT_SUCCESS(status)) {

        status = DfsInternalDeleteLocalVolume(&EntryId);

        if (!NT_SUCCESS(status)) {

            UNICODE_STRING puStr[2];

            puStr[0] = EntryId.Prefix;

            puStr[1].MaximumLength = sizeof(L"LocalMachine");
            puStr[1].Length = puStr[1].MaximumLength - sizeof(WCHAR);
            puStr[1].Buffer = L"LocalMachine";

            LogWriteMessage(
                EXTRA_VOLUME_NOT_DELETED,
                status,
                2,
                puStr);

            status = STATUS_UNSUCCESSFUL;

        } else {

            status = STATUS_REGISTRY_RECOVERED;

        }

        PktEntryIdDestroy(&EntryId, FALSE);

    } else
        DebugTrace(0, Dbg,
                "PktFsctrlPruneLocalVolume: Unmarshalling Error\n",0);

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg, "DfsFsctrlPruneLocalVolume: Exit -> %08lx\n",
                ULongToPtr( status ) );

    return status;
}


#if DBG
//+-------------------------------------------------------------------------
//
//  Function:   PktFsctrlFlushCache, public
//
//  Synopsis:   This function will flush all entries which have all the
//              bits specified in the TYPE vairable set in their own Type field.
//              However, this function will refuse to delete and Permanent
//              entries of the PKT.
//
//  Arguments:  Type - Specifies which entries to delete.
//
//  Returns:
//
//  Notes:      We only process this FSCTRL from the file system process,
//              never from the driver.
//
//--------------------------------------------------------------------------
NTSTATUS
PktFsctrlFlushCache(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG       Type;
    PDFS_PKT    Pkt;
    PDFS_PKT_ENTRY  curEntry, nextEntry;


    STD_FSCTRL_PROLOGUE(PktFsctrlFlushCache, TRUE, FALSE);

    //
    // Unmarshalling is very simple here. We only expect a ULONG.
    //

    Type = (*((ULONG *)InputBuffer));

    Pkt = _GetPkt();
    PktAcquireExclusive(Pkt, TRUE);
    curEntry = PktFirstEntry(Pkt);

    while (curEntry!=NULL)  {
        nextEntry = PktNextEntry(Pkt, curEntry);

        if (((curEntry->Type & Type) == Type) &&
                !(curEntry->Type & PKT_ENTRY_TYPE_LOCAL) &&
                    !(curEntry->Type & PKT_ENTRY_TYPE_LOCAL_XPOINT)) {

            //
            // Entry has all the Type bits specified in variable
            // "Type" set and hence we can destroy this entry.
            //

            PktEntryDestroy(curEntry, Pkt, (BOOLEAN) TRUE);

        }
        curEntry = nextEntry;
    }
    PktRelease(Pkt);

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1,Dbg, "PktFsctrlFlushCache: Exit -> %08lx\n", ULongToPtr( status ));

    return(status);
}


//+----------------------------------------------------------------------------
//
//  Function:   PktFsctrlShufflePktEntry
//
//  Synopsis:   Shuffles a pkt entry. Useful for testing.
//
//  Arguments:  [Irp]
//              [InputBuffer] -- Marshalled Pkt entry to shuffle.
//              [InputBufferLength] -- size of InputBuffer.
//
//  Returns:
//
//-----------------------------------------------------------------------------

VOID
PktShuffleServiceList(
    PDFS_PKT_ENTRY_INFO pInfo);

NTSTATUS
PktFsctrlShufflePktEntry(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength)
{
    NTSTATUS Status;
    MARSHAL_BUFFER marshalBuffer;
    DFS_PKT_ENTRY_ID PktEntryId;
    PDFS_PKT_ENTRY pPktEntry;
    UNICODE_STRING ustrRemaining;

    MarshalBufferInitialize( &marshalBuffer, InputBufferLength, InputBuffer );

    Status = DfsRtlGet( &marshalBuffer, &MiPktEntryId, &PktEntryId );

    if (NT_SUCCESS(Status)) {

        pPktEntry = PktLookupEntryByPrefix(
                        &DfsData.Pkt,
                        &PktEntryId.Prefix,
                        &ustrRemaining);

        if (pPktEntry == NULL || ustrRemaining.Length != 0) {

            DebugTrace(0, Dbg, "PktFsctrlShufflePktEntry : [%wZ] is not an entry\n", &PktEntryId.Prefix);

            Status = STATUS_NOT_FOUND;

        } else {

            PktShuffleServiceList( &pPktEntry->Info );

        }

        PktEntryIdDestroy(&PktEntryId, FALSE);

    } else {

        DebugTrace(0, Dbg, "PktFsctrlShufflePktEntry : DfsRtlGet returned %08lx\n", ULongToPtr( Status ) );

    }

    DebugTrace(0, Dbg, "PktFsctrlShufflePktEntry - returning %08lx\n", ULongToPtr( Status ));

    DfsCompleteRequest( Irp, Status );

    return( Status );

}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\prefix.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       prefix.c
//
//  Contents:   PREFIX table implementation
//
//  History:    SethuR -- Implemented
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef KERNEL_MODE
#include <dfsprocs.h>

#define Dbg     DEBUG_TRACE_RTL

#else

#define DebugTrace(x,y,z,a)

#endif

#include <prefix.h>
#include <prefixp.h>

PDFS_PREFIX_TABLE_ENTRY
DfspNextUnicodeTableEntry(
    IN PDFS_PREFIX_TABLE_ENTRY pEntry);

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, DfsInitializePrefixTable )
#pragma alloc_text( PAGE, DfsFreePrefixTable )
#pragma alloc_text( PAGE, DfsInsertInPrefixTable )
#pragma alloc_text( PAGE, DfsLookupPrefixTable )
#pragma alloc_text( PAGE, DfsFindUnicodePrefix )
#pragma alloc_text( PAGE, DfsRemoveFromPrefixTable )
#pragma alloc_text( PAGE, RemoveFirstComponent )

#endif  // ALLOC_PRAGMA

//+---------------------------------------------------------------------------
//
//  Function:   DfsInitializePrefixTable
//
//  Synopsis:   API for initializing the prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
DfsInitializePrefixTable(
    PDFS_PREFIX_TABLE pTable,
    BOOLEAN fCaseSensitive)
{
    NTSTATUS status = STATUS_SUCCESS;

    DebugTrace(+1, Dbg,"DfsInitializePrefixTable -- Entry\n", 0);

    if (pTable != NULL)
    {
        ULONG i;

        // Initialize flags
        pTable->CaseSensitive = fCaseSensitive;

        // Initialize the root entry
        INITIALIZE_PREFIX_TABLE_ENTRY(&pTable->RootEntry);

        // Initialize the various buckets.
        for (i = 0;i < NO_OF_HASH_BUCKETS;i++)
        {
            INITIALIZE_BUCKET(pTable->Buckets[i]);
        }

        // Initialize the name page list.
        pTable->NamePageList.pFirstPage = ALLOCATE_NAME_PAGE();
        if (pTable->NamePageList.pFirstPage != NULL)
        {
            INITIALIZE_NAME_PAGE(pTable->NamePageList.pFirstPage);

            // Initialize the prefix table entry allocation mechanism.
            status = _InitializePrefixTableEntryAllocation(pTable);
        }
        else
        {
            status = STATUS_NO_MEMORY;
            DebugTrace(0, Dbg,"DfsInitializePrefixTable Error -- %lx\n", ULongToPtr( status ));
        }
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
        DebugTrace(0, Dbg,"DfsInitializePrefixTable Error -- %lx\n", ULongToPtr( status ));
    }

    DebugTrace(-1, Dbg, "DfsInitializePrefixTable -- Exit\n", 0);
    return  status;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsFreePrefixTable
//
//  Synopsis:   API for freeing a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//
//  History:    08-01-99 JHarper Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
DfsFreePrefixTable(
    PDFS_PREFIX_TABLE pTable)
{
    NTSTATUS status = STATUS_SUCCESS;
    PNAME_PAGE pNamePage = NULL;
    PNAME_PAGE pNextPage = NULL;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    PDFS_PREFIX_TABLE_ENTRY pSentinelEntry = NULL;
    ULONG i;

    DebugTrace(+1, Dbg,"DfsFreePrefixTable -- Entry\n", 0);

    if (pTable != NULL) {
       for (i = 0; i < NO_OF_HASH_BUCKETS; i++) {
            pSentinelEntry = &pTable->Buckets[i].SentinelEntry;
            while (pSentinelEntry->pNextEntry != pSentinelEntry) {
                pEntry = pSentinelEntry->pNextEntry;
                REMOVE_FROM_BUCKET(pEntry);
                if (pEntry->PathSegment.Buffer != NULL)
                    ExFreePool(pEntry->PathSegment.Buffer);
                ExFreePool(pEntry);
            }
            pTable->Buckets[i].NoOfEntries = 0;
        }
        if (pTable->RootEntry.PathSegment.Buffer != NULL)
            ExFreePool(pTable->RootEntry.PathSegment.Buffer);

        for (pNamePage = pTable->NamePageList.pFirstPage;
                pNamePage;
                    pNamePage = pNextPage
        ) {
            pNextPage = pNamePage->pNextPage;
            ExFreePool(pNamePage);
        }

    } else {
        status = STATUS_INVALID_PARAMETER;
        DebugTrace(0, Dbg,"DfsFreePrefixTable Error -- %lx\n", ULongToPtr( status ));
    }

    DebugTrace(-1, Dbg, "DfsFreePrefixTable -- Exit\n", 0);
    return  status;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsInsertInPrefixTable
//
//  Synopsis:   API for inserting a path in the prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pData] -- BLOB associated with the path
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
DfsInsertInPrefixTable(
    PDFS_PREFIX_TABLE pTable,
    PUNICODE_STRING   pPath,
    PVOID             pData)
{
    NTSTATUS                status = STATUS_SUCCESS;
    WCHAR                   Buffer[MAX_PATH_SEGMENT_SIZE];
    PWCHAR                  NameBuffer = Buffer;
    USHORT                  cbNameBuffer = sizeof(Buffer);
    UNICODE_STRING          Path,Name;
    ULONG                   BucketNo;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    PDFS_PREFIX_TABLE_ENTRY pParentEntry = NULL;
    BOOLEAN                 fNameFound = FALSE;
    BOOLEAN                 pEntryAllocated = FALSE;

    DebugTrace(+1, Dbg, "DfsInsertInPrefixTable -- Entry\n", 0);

    RemoveFirstComponent(pPath, &Path);

    // There is one special case, i.e., in which the prefix is '\'.
    // Since this is the PATH_DELIMITER which is treated in a special
    // way, we do the processing upfront.

    if (Path.Length == 0)
    {
        return STATUS_SUCCESS;
    }
    else if ((Path.Length == sizeof(WCHAR)) &&
        (Path.Buffer[0] == PATH_DELIMITER))
    {
       pTable->RootEntry.pData = pData;
       return STATUS_SUCCESS;
    }
    else
    {
        Path.Length -= sizeof(WCHAR);
        Path.MaximumLength = Path.MaximumLength;
        Path.Buffer++;
        pParentEntry = &pTable->RootEntry;
    }

    if (Path.Length > MAX_PATH_SEGMENT_SIZE * sizeof(WCHAR) ) {
        NameBuffer = ExAllocatePoolWithTag( NonPagedPool, Path.Length + sizeof(WCHAR), ' sfD' );
        if (NameBuffer == NULL) {
            DebugTrace(0, Dbg, "Unable to allocate %d non-paged bytes\n", (Path.Length + sizeof(WCHAR)) );
            return( STATUS_INSUFFICIENT_RESOURCES );
        } else {
            cbNameBuffer = Path.Length + sizeof(WCHAR);
        }
    }

    while (Path.Length > 0)
    {
        Name.Length = 0;
        Name.Buffer = NameBuffer;
        Name.MaximumLength = cbNameBuffer;

        // Process the name segment
        if (pTable->CaseSensitive)
        {
            SPLIT_CASE_SENSITIVE_PATH(&Path,&Name,BucketNo);
        }
        else
        {
            SPLIT_CASE_INSENSITIVE_PATH(&Path,&Name,BucketNo);
        }

        if (Name.Length > 0)
        {
            // Lookup the table to see if the name segment already exists.
            DebugTrace(0, Dbg, "LOOKUP_BUCKET: Bucket(%ld)\n", ULongToPtr( BucketNo ));
            DebugTrace(0, Dbg, " for Name(%wZ)\n", &Name);

            LOOKUP_BUCKET(pTable->Buckets[BucketNo],Name,pParentEntry,pEntry,fNameFound);

            DebugTrace(0, Dbg, "returned pEntry(%lx)", pEntry);
            DebugTrace(0, Dbg, " fNameFound(%s)\n", fNameFound ? "TRUE" : "FALSE");

            if (pEntry == NULL)
            {
                // Initialize the new entry and initialize the name segment.
                pEntry = ALLOCATE_DFS_PREFIX_TABLE_ENTRY(pTable);
                if (pEntry != NULL)
                {
                    pEntryAllocated = TRUE;
                    INITIALIZE_PREFIX_TABLE_ENTRY(pEntry);

                    // Allocate the name space entry if there is no entry in the
                    // name page.
                    if (!fNameFound || fNameFound)
                    {
                        PWSTR pBuffer;

                        // Allocate the entry in the name page.
                        pBuffer = ALLOCATE_NAME_PAGE_ENTRY((pTable->NamePageList),(Name.Length/sizeof(WCHAR)));

                        if (pBuffer != NULL)
                        {
                            RtlCopyMemory(pBuffer,Name.Buffer,Name.Length);
                            pEntry->PathSegment = Name;
                            pEntry->PathSegment.Buffer = pBuffer;
                        }
                        else
                        {
                            status = STATUS_NO_MEMORY;
                            break;
                        }
                    }
                    else
                        pEntry->PathSegment = Name;

                    // thread the entry to point to the parent.
                    pEntry->pParentEntry = pParentEntry;

                    // Insert the entry in the bucket.
                    INSERT_IN_BUCKET(pTable->Buckets[BucketNo],pEntry);

                    // Insert the entry in the parent's children list.
                    INSERT_IN_CHILD_LIST(pEntry, pParentEntry);
                }
                else
                {
                    status = STATUS_NO_MEMORY;
                    DebugTrace(0, Dbg, "DfsInsertInPrefixTable Error -- %lx\n", ULongToPtr( status ));
                    break;
                }
            }
            else
            {
                // Increment the no. of children associated with  this entry

                pEntry->NoOfChildren++;
            }

            pParentEntry = pEntry;
            pEntryAllocated = FALSE;
        }
        else
        {
            status = STATUS_INVALID_PARAMETER;
            DebugTrace(0, Dbg, "DfsInsertInPrefixTable Error -- %lx\n", ULongToPtr( status ));
            break;
        }
    }

    // If a new entry was not successfully inserted we need to walk up the chain
    // of parent entries to undo the increment to the reference count and
    // remove the entries from their parent links.
    if (NT_SUCCESS(status))
    {
        // The entry was successfully inserted in the prefix table. Update
        // the data (BLOB) associated with it.
        // We do it outside the loop to prevent redundant comparisons within
        // the loop.

        if (pEntry != NULL) {
            pEntry->pData = pData;
        }
    }
    else
    {
        while (pParentEntry != NULL)
        {
            PDFS_PREFIX_TABLE_ENTRY pMaybeTempEntry;

            pMaybeTempEntry = pParentEntry;
            pParentEntry = pParentEntry->pParentEntry;

            if (--pMaybeTempEntry->NoOfChildren == 0) {
                //
                // If pParentEntry == NULL, pMaybeTempEntry is
                // pTable->RootEntry. Do not try to remove it.
                //
                if (pParentEntry != NULL) {
                    REMOVE_FROM_CHILD_LIST(pMaybeTempEntry);
                    REMOVE_FROM_BUCKET(pMaybeTempEntry);
                    FREE_DFS_PREFIX_TABLE_ENTRY(pTable, pMaybeTempEntry);
                }
            }
        }
        if (pEntryAllocated) {
            FREE_DFS_PREFIX_TABLE_ENTRY(pTable, pEntry);
        }
    }

    if (NameBuffer != Buffer) {
        ExFreePool( NameBuffer );
    }

    DebugTrace(-1, Dbg, "DfsInsertInPrefixTable -- Exit\n", 0);
    return status;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsLookupPrefixTable
//
//  Synopsis:   private fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pSuffix] -- the suffix that could not be found.
//
//              [ppData] -- placeholder for the BLOB for the prefix.
//
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//                  STATUS_OBJECT_PATH_NOT_FOUND -- no entry for the path
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
DfsLookupPrefixTable(
    PDFS_PREFIX_TABLE   pTable,
    PUNICODE_STRING     pPath,
    PUNICODE_STRING     pSuffix,
    PVOID               *ppData)
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    UNICODE_STRING          Path;

    DebugTrace(+1, Dbg, "DfsLookupInPrefixTable -- Entry\n", 0);

    RemoveFirstComponent(pPath, &Path);

    if (Path.Length == 0)
    {
        DebugTrace(-1, Dbg, "DfsLookupInPrefixTable Exited - Null Path!\n", 0);
        return STATUS_SUCCESS;
    }


    status = _LookupPrefixTable(pTable,&Path,pSuffix,&pEntry);

    // Update the BLOB placeholder with the results of the lookup.
    if (NT_SUCCESS(status))
    {
         *ppData = pEntry->pData;
    }

    DebugTrace(-1, Dbg, "DfsLookupInPrefixTable -- Exit\n", 0);
    return status;

}

//+---------------------------------------------------------------------------
//
//  Function:   DfsFindUnicodePrefix
//
//  Synopsis:   fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pSuffix] -- the suffix that could not be found.
//
//  Returns:    a valid ptr if successfull, NULL otherwise
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PVOID
DfsFindUnicodePrefix(
    PDFS_PREFIX_TABLE   pTable,
    PUNICODE_STRING     pPath,
    PUNICODE_STRING     pSuffix)
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    PVOID                   pData  = NULL;
    UNICODE_STRING          Path;

    DebugTrace(+1, Dbg, "DfsFindUnicodePrefix -- Entry\n", 0);

    RemoveFirstComponent(pPath, &Path);

    if (Path.Length == 0)
    {
        DebugTrace(-1, Dbg, "DfsFindUnicodePrefix Exited - Null Path!\n", 0);
        return NULL;
    }
    else
    {
        status = _LookupPrefixTable(pTable,&Path,pSuffix,&pEntry);

        // Update the BLOB placeholder with the results of the lookup.
        if (NT_SUCCESS(status))
        {
             pData = pEntry->pData;
        }

        DebugTrace(-1, Dbg, "DfsFindUnicodePrefix -- Exit\n", 0);
        return pData;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsRemoveFromPrefixTable
//
//  Synopsis:   private fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//                  STATUS_OBJECT_PATH_NOT_FOUND -- no entry for the path
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
DfsRemoveFromPrefixTable(
    PDFS_PREFIX_TABLE pTable,
    PUNICODE_STRING pPath)
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING Path,Suffix;
    ULONG    BucketNo;

    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;

    DebugTrace(+1, Dbg, "DfsRemoveFromPrefixTable -- Entry\n", 0);

    Suffix.Length = 0;
    Suffix.Buffer = NULL;

    RemoveFirstComponent(pPath, &Path);

    if (Path.Length == 0)
    {
        DebugTrace(-1, Dbg, "DfsRemoveFromPrefixTable Exited -- Null Path!\n", 0);
        return STATUS_SUCCESS;
    }

    else if ((Path.Length == sizeof(WCHAR)) &&
        (Path.Buffer[0] == PATH_DELIMITER))
    {
        if (pTable->RootEntry.pData == NULL)
        {
            status = STATUS_OBJECT_PATH_NOT_FOUND;
        }
        else
        {
            pTable->RootEntry.pData = NULL;
            DebugTrace(-1, Dbg, "DfsRemoveFromPrefixTable Exited.\n", 0);
            return  STATUS_SUCCESS;
        }
    }
    else
    {
        Path.Length -= sizeof(WCHAR);
        Path.MaximumLength = Path.Length;
        Path.Buffer++;

        status = _LookupPrefixTable(pTable,&Path,&Suffix,&pEntry);

        if (NT_SUCCESS(status) && (Suffix.Length == 0))
        {
            // Destroy the association between the data associated with
            // this prefix.
            pEntry->pData = NULL;

            // found an exact match for the given path name in the table.
            // traverse the list of parent pointers and delete them if
            // required.

            while (pEntry != NULL)
            {
                if ((--pEntry->NoOfChildren) == 0)
                {
                    PDFS_PREFIX_TABLE_ENTRY pTempEntry = pEntry;
                    pEntry = pEntry->pParentEntry;

                    //
                    // pEntry == NULL means pTempEntry is pTable->RootEntry.
                    // Do not try to remove it.
                    //
                    if (pEntry != NULL) {
                        REMOVE_FROM_CHILD_LIST(pTempEntry);
                        REMOVE_FROM_BUCKET(pTempEntry);
                        FREE_DFS_PREFIX_TABLE_ENTRY(pTable,pTempEntry);
                    }
                }
                else
                   break;
            }
        }
    }

    DebugTrace(-1, Dbg, "DfsRemoveFromPrefixTable -- Exit\n", 0);
    return status;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsNextUnicodePrefix
//
//  Synopsis:   Enumerates the entries in the table in ordered fashion.
//              Note that state is maintained between calls to
//              DfsNextUnicodePrefix - the caller must ensure that the table
//              is not modified between calls to DfsNextUnicodePrefix.
//
//  Arguments:  [pTable] -- The table to enumerate over.
//              [fRestart] -- If TRUE, starts the enumeration. If FALSE,
//                      continues from where the enumeration left off.
//
//  Returns:    Valid pointer to data associated with the next Prefix Table
//              entry, or NULL if at the end of the enumeration.
//
//
//-----------------------------------------------------------------------------

PVOID DfsNextUnicodePrefix(
    IN PDFS_PREFIX_TABLE pTable,
    IN BOOLEAN fRestart)
{
    PDFS_PREFIX_TABLE_ENTRY pEntry, pNextEntry;

    if (fRestart) {
        pNextEntry = &pTable->RootEntry;
        while (pNextEntry != NULL && pNextEntry->pData == NULL) {
            pNextEntry = DfspNextUnicodeTableEntry( pNextEntry );
        }
    } else {
        pNextEntry = pTable->NextEntry;
    }

    pEntry = pNextEntry;

    if (pNextEntry != NULL) {
        do {
            pNextEntry = DfspNextUnicodeTableEntry( pNextEntry );
        } while ( pNextEntry != NULL && pNextEntry->pData == NULL );
        pTable->NextEntry = pNextEntry;
    }

    if (pEntry != NULL) {
        return( pEntry->pData );
    } else {
        return( NULL );
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   DfspNextUnicodeTableEntry
//
//  Synopsis:   Given a pointer to a Prefix Table Entry, this function will
//              return a pointer to the "next" prefix table entry.
//
//              The "next" entry is chosen as follows:
//                  If the start entry has a valid child, the child is
//                      is returned.
//                  else if the start entry has a valid sibling, the sibling
//                      is returned
//                  else the first valid sibling of the closest ancestor is
//                      returned.
//
//  Arguments:  [pEntry] -- The entry to start from.
//
//  Returns:    Pointer to the next DFS_PREFIX_TABLE_ENTRY that has a valid
//              pData, or NULL if there are no more entries.
//
//-----------------------------------------------------------------------------

PDFS_PREFIX_TABLE_ENTRY
DfspNextUnicodeTableEntry(
    IN PDFS_PREFIX_TABLE_ENTRY pEntry)
{
    PDFS_PREFIX_TABLE_ENTRY pNextEntry;

    if (pEntry->pFirstChildEntry != NULL) {
        pNextEntry = pEntry->pFirstChildEntry;
    } else if (pEntry->pSiblingEntry != NULL) {
        pNextEntry = pEntry->pSiblingEntry;
    } else {
        for (pNextEntry = pEntry->pParentEntry;
                pNextEntry != NULL && pNextEntry->pSiblingEntry == NULL;
                    pNextEntry = pNextEntry->pParentEntry) {
             NOTHING;
        }
        if (pNextEntry != NULL) {
            pNextEntry = pNextEntry->pSiblingEntry;
        }
    }

    return( pNextEntry );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsNextUnicodePrefixChild
//
//  Synopsis:   Enumerates the immediate children of a given prefix.
//
//  Arguments:  [pTable] -- The DFS prefix table to use.
//              [pPath] -- The prefix whose children are to be enumerated.
//              [pCookie] -- On first call, this point to a NULL. On return,
//                      it will be set to a cookie that should be returned
//                      on subsequent calls to continue the enumeration.
//
//  Returns:    On successful return, a pointer to the child prefix that has a
//              valid pData, or NULL if at the end of the enumeration, or if
//              pPath is not a valid prefix in the table to begin with.
//
//-----------------------------------------------------------------------------

PVOID
DfsNextUnicodePrefixChild(
    IN PDFS_PREFIX_TABLE pTable,
    IN PUNICODE_STRING pPath,
    OUT PVOID *ppCookie)
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    UNICODE_STRING          suffix;
    PVOID                   pData;

    if ((*ppCookie) == NULL) {

        if (pPath->Length > 0) {

            status = _LookupPrefixTable(pTable,pPath,&suffix,&pEntry);

            if (NT_SUCCESS(status)) {

                pEntry = pEntry->pFirstChildEntry;

            }

        }

    } else if ((*ppCookie) == (PVOID) -1) {

        status = STATUS_NO_MORE_ENTRIES;

    } else {

        pEntry = (PDFS_PREFIX_TABLE_ENTRY) (*ppCookie);

        pEntry = pEntry->pSiblingEntry;

    }

    pData = NULL;

    (*ppCookie) = (PVOID) -1;

    if (NT_SUCCESS(status)) {

        if (pEntry != NULL) {

            (*ppCookie) = (PVOID) pEntry;

            pData = pEntry->pData;

        }

    }

    return( pData );

}

VOID
RemoveFirstComponent(
    PUNICODE_STRING Path,
    PUNICODE_STRING Remainder)
{

    *Remainder = *Path;

    if (Remainder->Length == 0 ||
        Remainder->Length == sizeof(WCHAR)) {
        return;
    }

    //
    // Strip leading \'s

    while (Remainder->Length > 0 && Remainder->Buffer[0] == PATH_DELIMITER) {

        Remainder->Length -= sizeof(WCHAR);
        Remainder->Buffer++;

    }

    while (Remainder->Length > 0 && Remainder->Buffer[0] != PATH_DELIMITER) {
        Remainder->Length -= sizeof(WCHAR);
        Remainder->Buffer++;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\registry.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       registry.c
//
//  Contents:   Module to read in registry parameters.
//
//              This module is intended as a simple, reusable, interface to the
//              registry. Among its features are:
//
//              o Kernel Callable.
//
//              o Intuitive (it is to me!) - To read the value for /a/b/c/d,
//                  you say KRegGetValue("/a/b/c/d"), instead of calling at
//                  least 3 different Nt APIs. Any and all strings returned are
//                  guaranteed to be NULL terminated.
//
//              o Allocates memory on behalf of caller - so we don't waste any
//                  by allocating max amounts.
//
//              o Completely non-reentrant - 'cause it maintains state across
//                  calls. (It would be simple to make it multi-threaded tho)
//
//
//  Classes:
//
//  Functions:  KRegSetRoot
//              KRegCloseRoot
//              KRegGetValue
//              KRegGetNumValuesAndSubKeys
//              KRegEnumValueSet
//              KRegEnumSubKeySet
//
//
//  History:    18 Sep 92       Milans created
//
//-----------------------------------------------------------------------------


#include "registry.h"
#include "regsups.h"


//
// If we ever needed to go multithreaded, we should return HKEY_ROOT to caller
// instead of keeping it here.
//

static HKEY HKEY_ROOT = NULL;                    // Handle to root key

#define KREG_SIZE_THRESHOLD     5                // For allocation optimization

//
// Some commonly used error format strings.
//

#if DBG == 1

static char *szErrorOpen = "Error opening %ws section.\n";
static char *szErrorRead = "Error reading %ws section.\n";

#endif


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, KRegInit )
#pragma alloc_text( PAGE, KRegCloseRoot )
#pragma alloc_text( PAGE, KRegSetRoot )
#pragma alloc_text( PAGE, KRegCreateKey )
#pragma alloc_text( PAGE, KRegGetValue )
#pragma alloc_text( PAGE, KRegSetValue )
#pragma alloc_text( PAGE, KRegDeleteValue )
#pragma alloc_text( PAGE, KRegGetNumValuesAndSubKeys )
#pragma alloc_text( PAGE, KRegEnumValueSet )
#pragma alloc_text( PAGE, KRegEnumSubKeySet )
#pragma alloc_text( PAGE, KRegFreeArray )
#endif // ALLOC_PRAGMA


//+----------------------------------------------------------------------------
//
//  Function:  KREG_CHECK_HARD_STATUS, macro
//
//  Synopsis:  If Status is not STATUS_SUCCESS, print out debug msg and return.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

#define KREG_CHECK_HARD_STATUS(Status, M1, M2)  \
         if (!NT_SUCCESS(Status)) {             \
            kreg_debug_out(M1, M2);             \
            return(Status);                     \
         }


//+----------------------------------------------------------------------------
//
//  Function:  KRegInit
//
//  Synopsis:
//
//  Arguments: None
//
//  Returns:   STATUS_SUCCESS
//
//-----------------------------------------------------------------------------

NTSTATUS
KRegInit(void)
{
   return(STATUS_SUCCESS);
}


//+----------------------------------------------------------------------------void
//
//  Function:  KRegCloseRoot
//
//  Synopsis:  Close the Root opened by KRegSetRoot.
//
//  Arguments: None
//
//  Returns:   Nothing
//
//-----------------------------------------------------------------------------

void
KRegCloseRoot()
{
   if (HKEY_ROOT) {
      NtClose(HKEY_ROOT);
      HKEY_ROOT = NULL;
   }
}



//+----------------------------------------------------------------------------
//
//  Function:  KRegSetRoot
//
//  Synopsis:  Sets a particular key as the "root" key for subsequent calls
//             to registry routines.
//
//  Arguments: wszRootName - Name of root key
//
//  Returns:   Result of opening the key.
//
//-----------------------------------------------------------------------------

NTSTATUS
KRegSetRoot(
   IN PWSTR wszRootName
   )
{
   NTSTATUS Status;

   if (HKEY_ROOT != NULL) {
      NtClose(HKEY_ROOT);
   }

   Status = NtOpenKey(
               &HKEY_ROOT,                       // Handle to DFS root key
               KEY_READ | KEY_WRITE,             // Only need to read
               KRegpAttributes(                  // Name of Key
                  NULL,
                  wszRootName
                  )
               );

   return(Status);
}



//+----------------------------------------------------------------------------
//
//  Function:   KRegDeleteKey
//
//  Synopsis:   Deletes a key from the registry.
//
//  Arguments:  [wszKey] -- name of key relative to the current root.
//
//  Returns:    Status from deleting the key.
//
//-----------------------------------------------------------------------------

NTSTATUS
KRegDeleteKey(
    IN PWSTR wszKey)
{
    NTSTATUS Status;
    APWSTR   awszSubKeys;
    ULONG    cSubKeys, i;
    HKEY     hkey;

    //
    // NtDeleteKey won't delete key's which have subkeys. So, we first
    // enumerate all the subkeys and delete them, before deleting the key.
    //

    Status = KRegEnumSubKeySet(wszKey, &cSubKeys, &awszSubKeys);

    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    for (i = 0; i < cSubKeys && NT_SUCCESS(Status); i++) {

        Status = NtOpenKey(
                    &hkey,
                    KEY_ALL_ACCESS,
                    KRegpAttributes(HKEY_ROOT, awszSubKeys[i])
                    );

        if (NT_SUCCESS(Status)) {
            Status = NtDeleteKey( hkey );
            NtClose(hkey);
        }

    }


    //
    // If we were able to delete all the subkeys, we can delete the
    // key itself.
    //

    if (NT_SUCCESS(Status)) {
        Status = NtOpenKey(
                    &hkey,
                    KEY_ALL_ACCESS,
                    KRegpAttributes(HKEY_ROOT, wszKey)
                    );

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            Status = STATUS_SUCCESS;
        } else if (NT_SUCCESS(Status)) {
            Status = NtDeleteKey( hkey );
            NtClose(hkey);
        }
    }

    KRegFreeArray( cSubKeys, (APBYTE) awszSubKeys );

    return(Status);
}


//+----------------------------------------------------------------------------
//
//  Function:   KRegCreateKey
//
//  Synopsis:   Creates a new key in the registry under the subkey given
//              in wszSubKey. wszSubKey may be NULL, in which case the
//              new key is created directly under the current root.
//
//  Arguments:  [wszSubKey] -- Name of subkey relative to root key under
//                             which new key will be created.
//              [wszNewKey] -- Name of new key to be created.
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
KRegCreateKey(
    IN PWSTR wszSubKey,
    IN PWSTR wszNewKey)
{
   HKEY  hkeySubKey, hkeyNewKey;
   NTSTATUS Status;
   UNICODE_STRING ustrValueName;


   if (wszSubKey != NULL) {
       Status = NtOpenKey(
                   &hkeySubKey,
                   KEY_WRITE,
                   KRegpAttributes(HKEY_ROOT, wszSubKey)
                   );

       KREG_CHECK_HARD_STATUS(Status, szErrorOpen, wszSubKey);
   } else {
       hkeySubKey = HKEY_ROOT;
   }

   Status = NtCreateKey(
               &hkeyNewKey,
               KEY_WRITE,
               KRegpAttributes(hkeySubKey, wszNewKey),
               0L,                               // TitleIndex
               NULL,                             // Class
               REG_OPTION_NON_VOLATILE,          // Create option
               NULL);                            // Create disposition

   if (wszSubKey != NULL) {
       NtClose(hkeySubKey);
   }

   if (!NT_SUCCESS(Status)) {
       kreg_debug_out(szErrorOpen, wszNewKey);
       NtClose(hkeyNewKey);
       return(Status);
   }

   NtClose(hkeyNewKey);

   return( Status );
}



//+----------------------------------------------------------------------------
//
//  Function:  KRegGetValue
//
//  Synopsis:  Given a Value Name and a handle, will allocate memory for the
//             handle and fill it with the Value Data for the value name.
//
//  Arguments: [wszSubKey] - Name of subkey relative to root key
//             [wszValueName] - name of value data
//             [ppValueData] - pointer to pointer to byte data.
//
//  Returns:   STATUS_SUCCESS, STATUS_NO_MEMORY, Status from NtReg api.
//
//  Notes:     It will allocate memory for the data, and return a pointer to
//             it in ppValueData. Caller must free it.
//
//-----------------------------------------------------------------------------

NTSTATUS
KRegGetValue(
   IN PWSTR wszSubKey,
   IN PWSTR wszValueName,
   OUT PBYTE *ppValueData
   )
{
   HKEY  hkeySubKey;
   ULONG dwUnused, cbMaxDataSize;
   ULONG cbActualSize;
   PBYTE pbData = NULL;
   NTSTATUS Status;

   Status = NtOpenKey(
               &hkeySubKey,
               KEY_READ,
               KRegpAttributes(HKEY_ROOT, wszSubKey)
               );

   KREG_CHECK_HARD_STATUS(Status, szErrorOpen, wszSubKey);

   Status = KRegpGetKeyInfo(
               hkeySubKey,
               &dwUnused,                        // Number of Subkeys
               &dwUnused,                        // Max size of subkey length
               &dwUnused,                        // # of Values
               &dwUnused,                        // Max size of value Name
               &cbMaxDataSize                    // Max size of value Data
               );

   if (!NT_SUCCESS(Status)) {
      kreg_debug_out(szErrorRead, wszSubKey);
      NtClose(hkeySubKey);
      return(Status);
   }

   //
   // Just in case the value is of type REG_SZ, provide for inserting a
   // UNICODE_NULL at the end.
   //

   cbMaxDataSize += sizeof(UNICODE_NULL);

   pbData = kreg_alloc(cbMaxDataSize);
   if (pbData == NULL) {
      Status = STATUS_NO_MEMORY;
      goto Cleanup;
   }
   cbActualSize = cbMaxDataSize;

   Status = KRegpGetValueByName(
               hkeySubKey,
               wszValueName,
               pbData,
               &cbActualSize);


   if (NT_SUCCESS(Status)) {
      if ((cbMaxDataSize - cbActualSize) < KREG_SIZE_THRESHOLD) {

         //
         // Optimization - no need to double allocate if actual size and max
         //                size are pretty close.
         //

         *ppValueData = pbData;
         pbData = NULL;                          // "deallocate" pbData

      } else {

         //
         // Big enough difference between actual and max size, warrants
         // allocating a smaller buffer.
         //

         *ppValueData = (PBYTE) kreg_alloc(cbActualSize);
         if (*ppValueData == NULL) {

             //
             // Well, we couldn't "reallocate" a smaller chunk, we'll just
             // live on the edge and return the original buffer.
             //
             *ppValueData = pbData;
             pbData = NULL;
         } else {
            RtlMoveMemory(*ppValueData, pbData, cbActualSize);
         }

      }
   }


Cleanup:

   NtClose(hkeySubKey);
   if (pbData != NULL) {
       kreg_free(pbData);
   }

   return(Status);
}



//+----------------------------------------------------------------------------
//
//  Function:  KRegSetValue
//
//  Synopsis:  Given a Key Name, Value Name, and type, size and data, this
//             routine will update the registry's value to the type and data.
//             The valuename will be created if it doesn't exist. The key
//             must already exist.
//
//  Arguments: [wszSubKey] - Name of subkey relative to root key
//             [wszValueName] - name of value data
//             [ulType] - as in REG_DWORD, REG_SZ, REG_MULTI_SZ, etc.
//             [cbSize] - size in bytes of data. If type == REG_SZ, data need
//                        !not! include the terminating NULL. One will be
//                        appended as needed.
//             [pValueData] - pointer to pointer to byte data.
//
//  Returns:   STATUS_SUCCESS, STATUS_NO_MEMORY, Status from NtReg api.
//
//  Notes:     It will allocate memory for the data, and return a pointer to
//             it in ppValueData. Caller must free it.
//
//-----------------------------------------------------------------------------

NTSTATUS
KRegSetValue(
   IN PWSTR wszSubKey,
   IN PWSTR wszValueName,
   IN ULONG ulType,
   IN ULONG cbSize,
   IN PBYTE pValueData
   )
{
   HKEY  hkeySubKey;
   NTSTATUS Status;
   UNICODE_STRING ustrValueName;
   PWSTR pwszValueData;



   Status = NtOpenKey(
               &hkeySubKey,
               KEY_WRITE,
               KRegpAttributes(HKEY_ROOT, wszSubKey)
               );

   KREG_CHECK_HARD_STATUS(Status, szErrorOpen, wszSubKey);

   RtlInitUnicodeString(&ustrValueName, wszValueName);

   if (ulType == REG_SZ) {

       pwszValueData = (PWSTR) kreg_alloc(cbSize+sizeof(UNICODE_NULL));

       if (pwszValueData == NULL) {
           NtClose(hkeySubKey);
           return(STATUS_INSUFFICIENT_RESOURCES);
       }

       RtlMoveMemory((PVOID) pwszValueData, (PVOID) pValueData, cbSize);
       pwszValueData[cbSize/sizeof(WCHAR)] = UNICODE_NULL;
       cbSize += sizeof(UNICODE_NULL);
   } else {
       pwszValueData = (PWSTR) pValueData;
   }

   Status = NtSetValueKey(
               hkeySubKey,
               &ustrValueName,
               0L,                               // TitleIndex
               ulType,
               pwszValueData,
               cbSize);

   if (ulType == REG_SZ) {
       kreg_free(pwszValueData);
   }

   if (NT_SUCCESS(Status)) {
       NtFlushKey(hkeySubKey);
   }

   NtClose(hkeySubKey);
   return(Status);
}


//+----------------------------------------------------------------------------
//
//  Function:   KRegDeleteValue
//
//  Synopsis:   Deletes a value name
//
//  Arguments:  [wszSubKey] -- Name of subkey under which wszValueName exists.
//              [wszValueName] -- Name of Value to delete.
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS KRegDeleteValue(
    IN PWSTR wszSubKey,
    IN PWSTR wszValueName)
{
   HKEY  hkeySubKey;
   NTSTATUS Status;
   UNICODE_STRING ustrValueName;

   Status = NtOpenKey(
               &hkeySubKey,
               KEY_WRITE,
               KRegpAttributes(HKEY_ROOT, wszSubKey)
               );

   KREG_CHECK_HARD_STATUS(Status, szErrorOpen, wszSubKey);
   RtlInitUnicodeString(&ustrValueName, wszValueName);

   Status = NtDeleteValueKey(
               hkeySubKey,
               &ustrValueName);


   if (NT_SUCCESS(Status)) {
       NtFlushKey(hkeySubKey);
   }

   NtClose(hkeySubKey);
   return(Status);
}


//+----------------------------------------------------------------------------
//
//  Function:  KRegGetNumValuesAndSubKeys
//
//  Synopsis:  Given a Subkey, return how many subkeys and values it has.
//
//  Arguments: [wszSubKey] - for which info is required.
//             [plNumValues] - receives number of values this subkey has.
//             [plNumSubKeys] - receives number of subkeys under this subkey.
//
//  Returns:   STATUS_SUCCESS, or Status from NtRegAPI.
//
//-----------------------------------------------------------------------------

NTSTATUS
KRegGetNumValuesAndSubKeys(
   IN PWSTR wszSubKey,
   OUT PULONG pcNumValues,
   OUT PULONG pcNumSubKeys
   )
{
   HKEY  hKeySubKey;
   ULONG dwUnused;
   NTSTATUS Status;

   Status = NtOpenKey(
               &hKeySubKey,
               KEY_READ,
               KRegpAttributes(HKEY_ROOT, wszSubKey)
               );

   KREG_CHECK_HARD_STATUS(Status, szErrorOpen, wszSubKey);

   Status = KRegpGetKeyInfo(
               hKeySubKey,
               pcNumSubKeys,                     // Number of Subkeys
               &dwUnused,                        // Max size of subkey length
               pcNumValues,                      // # of Values
               &dwUnused,                        // Max size of value Name
               &dwUnused                         // Max size of value Data
               );

   if (!NT_SUCCESS(Status)) {
      kreg_debug_out(szErrorRead, wszSubKey);
      NtClose(hKeySubKey);
      return(Status);
   }

   NtClose(hKeySubKey);
   return(Status);
}


//+----------------------------------------------------------------------------
//
//  Function:  KRegEnumValueSet
//
//  Synopsis:  Given a subkey, return the names and data for all its values.
//
//  Arguments: [wszSubKey] - Name of subkey to read.
//             [pcMaxElements] - On return, contains number of names and
//                               data actually read.
//             [pawszValueNames] - Pointer to array of PWSTRS. This routine
//                               will allocate memory for the array and the
//                               strings.
//             [papbValueData] - pointer to array of PBYTES. This routine
//                               will allocate the array and the memory for the
//                               data, stuffing the pointers to data into this
//                               array.
//             [paValueStatus] - Status of reading the corresponding Value. The
//                               array will be allocated here.
//
//  Returns:   STATUS_SUCCESS, STATUS_NO_MEMORY, or Status from NtRegAPI.
//
//  Notes:     Returned Value Names are always NULL terminated.
//             If the Value Data is of type REG_SZ, it, too, is NULL terminated
//             Caller frees the last three OUT params (and the contents of
//             awszValueNames and apbValueData!) only on SUCCESSFUL return.
//
//-----------------------------------------------------------------------------

NTSTATUS
KRegEnumValueSet(
   IN PWSTR wszSubKey,
   OUT PULONG pcMaxElements,
   OUT APWSTR *pawszValueNames,
   OUT APBYTE *papbValueData,
   OUT ANTSTATUS *paValueStatus
   )
{
   ULONG i = 0;
   HKEY  hKeySubKey;
   ULONG dwUnused, cbMaxNameSize, cbMaxDataSize;
   PWSTR wszName = NULL;
   PBYTE pbData = NULL;
   NTSTATUS Status;

   APWSTR       awszValueNames;
   APBYTE       apbValueData;
   ANTSTATUS    aValueStatus;
   ULONG        cMaxElements;

   awszValueNames = *pawszValueNames = NULL;
   apbValueData = *papbValueData = NULL;
   aValueStatus = *paValueStatus = NULL;

   Status = NtOpenKey(
               &hKeySubKey,
               KEY_READ,
               KRegpAttributes(HKEY_ROOT, wszSubKey)
               );

   KREG_CHECK_HARD_STATUS(Status, szErrorOpen, wszSubKey);

   Status = KRegpGetKeyInfo(
               hKeySubKey,
               &dwUnused,                        // Number of Subkeys
               &dwUnused,                        // Max size of subkey length
               &cMaxElements,                    // # of Values
               &cbMaxNameSize,                   // Max size of value Name
               &cbMaxDataSize                    // Max size of value Data
               );


   if (!NT_SUCCESS(Status)) {
      kreg_debug_out(szErrorRead, wszSubKey);
      NtClose(hKeySubKey);
      return(Status);
   }

   //
   // Allocate memory for the arrays.
   //

   awszValueNames = *pawszValueNames = kreg_alloc(cMaxElements * sizeof(PWSTR));
   apbValueData = *papbValueData = kreg_alloc(cMaxElements * sizeof(PBYTE));
   aValueStatus = *paValueStatus = kreg_alloc(cMaxElements * sizeof(NTSTATUS));

   if (awszValueNames == NULL || apbValueData == NULL || aValueStatus == NULL) {
      Status = STATUS_NO_MEMORY;
      goto Cleanup;

   }

   //
   // Initialize the arrays
   //

   RtlZeroMemory(awszValueNames, cMaxElements * sizeof(PWSTR));
   RtlZeroMemory(apbValueData, cMaxElements * sizeof(PBYTE));
   RtlZeroMemory(aValueStatus, cMaxElements * sizeof(NTSTATUS));

   //
   // For name, we need an extra spot for the terminating NULL
   //

   wszName = kreg_alloc(cbMaxNameSize + sizeof(WCHAR));
   pbData = kreg_alloc(cbMaxDataSize);

   if (pbData == NULL || wszName == NULL) {
      Status = STATUS_NO_MEMORY;
      goto Cleanup;
   }

   for (i = 0; i < cMaxElements; i++) {
      ULONG cbActualNameSize, cbActualDataSize;

      cbActualNameSize = cbMaxNameSize;
      cbActualDataSize = cbMaxDataSize;

      Status = KRegpEnumKeyValues(
                           hKeySubKey,
                           i,
                           wszName,
                           &cbActualNameSize,
                           pbData,
                           &cbActualDataSize
                           );
      if (Status == STATUS_NO_MORE_ENTRIES) {
         Status = STATUS_SUCCESS;
         break;
      } else if (!NT_SUCCESS(Status)) {
         aValueStatus[i] = Status;
         continue;
      } else {
         aValueStatus[i] = Status;
      }

      cbActualNameSize += sizeof(WCHAR);         // For terminating NULL
      awszValueNames[i] = (PWSTR) kreg_alloc(cbActualNameSize);
      apbValueData[i] = (PBYTE) kreg_alloc(cbActualDataSize);

      if (apbValueData[i] == NULL || awszValueNames[i] == NULL) {
         Status = aValueStatus[i] = STATUS_NO_MEMORY;
         goto Cleanup;
      }
      RtlMoveMemory(awszValueNames[i], wszName, cbActualNameSize);
      RtlMoveMemory(apbValueData[i], pbData, cbActualDataSize);
   }


Cleanup:

   NtClose(hKeySubKey);
   if (wszName != NULL) {
       kreg_free(wszName);
   }
   if (pbData != NULL) {
       kreg_free(pbData);
   }

   if (!NT_SUCCESS(Status)) {
      *pcMaxElements = 0;

      KRegFreeArray(i+1, (APBYTE) awszValueNames);
      KRegFreeArray(i+1, apbValueData);

      if (aValueStatus != NULL) {
         kreg_free(aValueStatus);
      }

   } else {                                      // Status success

      *pcMaxElements = i;
   }

   return(Status);
}




//+----------------------------------------------------------------------------
//
//  Function:   KRegEnumSubKeySet
//
//  Synopsis:   This one's slightly trick. Given a Subkey, it returns an array
//              of its subkey-names. The following is true - say the root is
//              /a/b/c. Say wszSubKey is d. Say d has subkeys s1, s2, and s3.
//              Then the array of subkey-names returned will contain the names
//              d/s1, d/s2, d/s3.
//
//  Arguments:  [wszSubKey] - the Subkey relative to the root.
//              [pcMaxElements] - On return, # subkeys actually being returned.
//              [awszValueNames] - Unitialized array of PWSTR (room for at least
//                                *plMaxElements). This routine will allocate
//                                memory for the subkey names, and fill in this
//                                array with pointers to them.
//
//  Returns:
//
//  Notes:      Caller must free at most *plMaxElements members of
//              awszSubKeyNames. See synopsis above for form of subkey names.
//
//-----------------------------------------------------------------------------

NTSTATUS
KRegEnumSubKeySet(
   IN PWSTR wszSubKey,
   IN OUT PULONG pcMaxElements,
   OUT APWSTR *pawszSubKeyNames
   )
{
   ULONG        i, j = 0;
   APWSTR       awszSubKeyNames = NULL;
   PWSTR        wszBuffer = NULL;
   HKEY         hKeySubKey;
   ULONG        dwUnused, cbMaxNameSize, cwszSubKey;
   NTSTATUS     Status;

   cwszSubKey = wcslen(wszSubKey);

   *pawszSubKeyNames = NULL;

   Status = NtOpenKey(
               &hKeySubKey,
               KEY_READ,
               KRegpAttributes(HKEY_ROOT, wszSubKey)
               );

   KREG_CHECK_HARD_STATUS(Status, szErrorOpen, wszSubKey);

   Status = KRegpGetKeyInfo(
               hKeySubKey,
               pcMaxElements,                    // Number of Subkeys
               &cbMaxNameSize,                   // Max size of subkey name
               &dwUnused,                        // # of Values
               &dwUnused,                        // Max size of value Name
               &dwUnused                         // Max size of value Data
               );

   if (pcMaxElements == 0) {
       NtClose(hKeySubKey);
       *pawszSubKeyNames = NULL;
       return(STATUS_SUCCESS);
   }

   if (!NT_SUCCESS(Status)) {
      kreg_debug_out(szErrorRead, wszSubKey);
      goto Cleanup;
   }

   *pawszSubKeyNames = kreg_alloc(
                        (*pcMaxElements + 1) * sizeof(PWSTR)
                        );
   awszSubKeyNames = *pawszSubKeyNames;
   wszBuffer = kreg_alloc(cbMaxNameSize + sizeof(WCHAR));

   if (wszBuffer == NULL || awszSubKeyNames == NULL) {
      Status = STATUS_NO_MEMORY;
      goto Cleanup;
   } else {
      RtlZeroMemory(awszSubKeyNames, (*pcMaxElements + 1) * sizeof(PWSTR));
   }

   for (i = j = 0; j < *pcMaxElements; i++) {
      ULONG cbActualNameSize, cNameIndex;

      cbActualNameSize = cbMaxNameSize;

      Status = KRegpEnumSubKeys(
                  hKeySubKey,
                  i,
                  wszBuffer,
                  &cbActualNameSize
                  );
      if (Status == STATUS_NO_MORE_ENTRIES) {
         Status = STATUS_SUCCESS;
         break;
      } else if (!NT_SUCCESS(Status)) {
         continue;
      }

      cbActualNameSize += sizeof(WCHAR);         // for terminating NULL
      awszSubKeyNames[j] = (PWSTR) kreg_alloc(
                                       cwszSubKey * sizeof(WCHAR) +
                                       sizeof(WCHAR) + // for backslash
                                       cbActualNameSize
                                       );
      if (awszSubKeyNames[j] == NULL) {
          Status = STATUS_NO_MEMORY;
          goto Cleanup;
      } else {
          RtlZeroMemory(
                awszSubKeyNames[j], 
                cwszSubKey * sizeof(WCHAR) +
                sizeof(WCHAR) + // for backslash
                cbActualNameSize);
          if (wszSubKey[0] != UNICODE_NULL) {
              wcscpy(awszSubKeyNames[j], wszSubKey);
              wcscat(awszSubKeyNames[j], UNICODE_PATH_SEP_STR);
              cNameIndex = cwszSubKey + 1;
          } else {
              cNameIndex = 0;
          }

          RtlMoveMemory(
            &awszSubKeyNames[j][cNameIndex],
            wszBuffer,
            cbActualNameSize);
          j++;
      }
   }


Cleanup:
   NtClose(hKeySubKey);
   if (wszBuffer != NULL) {
      kreg_free(wszBuffer);
   }

   if (!NT_SUCCESS(Status)) {
      *pcMaxElements = 0;

      KRegFreeArray(j, (APBYTE) awszSubKeyNames);

   } else {                                      // status success
      *pcMaxElements = j;
   }

   return(Status);
}



//+----------------------------------------------------------------------------
//
//  Function:   KRegFreeArray
//
//  Synopsis:   Given an array of pointers, frees the pointers and the array.
//
//  Arguments:  [cElements] - Number of elements to free. Some elements can be
//                            NULL.
//              [pa]        - pointer to the array.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
KRegFreeArray(
   IN ULONG cElements,
   IN APBYTE pa)
{
   ULONG i;

   if (pa != NULL) {
      for (i = 0; i < cElements; i++) {
         if (pa[i] != NULL) {
            kreg_free(pa[i]);
         }
      }

      kreg_free(pa);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\provider.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       provider.c
//
//  Contents:   Module to initialize DFS driver providers.
//
//  Classes:
//
//  Functions:  ProviderInit()
//
//  History:    12 Sep 1992     Milans created.
//              05 Apr 1993     Milans moved into driver.
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "registry.h"
#include "regkeys.h"

#include "provider.h"

#define MAX_ENTRY_PATH          80               // Max. length of entry path

#define Dbg                     DEBUG_TRACE_INIT
#define prov_debug_out(x, y)    DebugTrace(0, Dbg, x, y)


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, ProviderInit )
#endif // ALLOC_PRAGMA


//+----------------------------------------------------------------------------
//
//  Function:  ProviderInit
//
//  Synopsis:  Initializes the provider list with
//              - Local File service provider
//              - Standard remote Cairo provider
//              - Downlevel LanMan provider.
//
//  Arguments: None
//
//  Returns:   STATUS_SUCCESS
//
//-----------------------------------------------------------------------------

NTSTATUS
ProviderInit(void)
{
   NTSTATUS Status;
   ULONG i, cProviders;
   APWSTR awszProviders;                          // array of provider names
   PBYTE pData;
   ULONG ProviderId, Capabilities;
   UNICODE_STRING ustrProviderName;


   Status = KRegSetRoot(wszRegRootDFS);
   if (!NT_SUCCESS(Status)) {
       prov_debug_out("ProviderInit: Error %08lx opening Registry!\n", Status);
       return(Status);
   }


   //
   // Get all the Provider subkeys.
   //

   Status = KRegEnumSubKeySet(wszProviderKey, &cProviders, &awszProviders);
   if (!NT_SUCCESS(Status)) {
       prov_debug_out("ProviderInit: Error %08lx reading Providers!\n", Status);
       KRegCloseRoot();
       return(Status);
   }

   //
   // Get the parameters for each provider and define the provider
   //

   for (i = 0; i < cProviders; i++) {

      //
      // Get the Provider ID
      //

      Status = KRegGetValue(awszProviders[i], wszProviderId, &pData);

      if (NT_SUCCESS(Status)) {
         ProviderId = *((ULONG *)pData);
         DfsFree(pData);
      } else {
         prov_debug_out( "Error reading Provider Id for %ws\n", awszProviders[i]);
         continue;
      }


      //
      // Get the Provider Caps
      //

      Status = KRegGetValue(awszProviders[i], wszCapabilities, &pData);

      if (NT_SUCCESS(Status)) {
         Capabilities = *((ULONG *)pData);
         DfsFree(pData);
      } else {
         prov_debug_out("Error reading Capabilities for %ws\n", awszProviders[i]);
         continue;
      }


      //
      // Get the DeviceName
      //

      Status = KRegGetValue(awszProviders[i], wszDeviceName, &pData);

      if (NT_SUCCESS(Status)) {

         RtlInitUnicodeString(&ustrProviderName, (PWSTR) pData);
         prov_debug_out("Defining %ws provider.\n", awszProviders[i]);
         prov_debug_out("\tTarget = %wZ\n", &ustrProviderName);
         Status = DfsInsertProvider(
                     &ustrProviderName,
                     Capabilities,
                     ProviderId);
         if (!NT_SUCCESS(Status)) {
             DfsFree(pData);
         }
      } else {

         //
         // Device name is "optional"
         //

         prov_debug_out("Defining %ws provider.\n", awszProviders[i]);
         prov_debug_out("\tNo Target\n", 0);
         RtlInitUnicodeString(&ustrProviderName, NULL);
         Status = DfsInsertProvider(
                     &ustrProviderName,
                     Capabilities,
                     ProviderId);
      }


      //
      // See if provider definition went ok
      //

      if (!NT_SUCCESS(Status)) {
          prov_debug_out("Definition of %ws provider failed!\n", awszProviders[i]);
          prov_debug_out("Error = %08lx\n", Status);
      }

   }

   KRegCloseRoot();
   KRegFreeArray(cProviders, (APBYTE) awszProviders);

   return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\regsups.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       regsups.h
//
//  Contents:   support routines for registry.
//
//  Classes:
//
//  Functions:
//
//  History:    18 Sep 92 	Milans created.
//
//-----------------------------------------------------------------------------

#ifndef _REGSUPS_
#define _REGSUPS_

OBJECT_ATTRIBUTES *KRegpAttributes(
   IN HANDLE hParent,
   IN PWSTR  wszName);

NTSTATUS KRegpGetValueByName(
   IN HKEY  hKey,
   IN PWSTR wszValueName,
   OUT PBYTE pbData,
   IN OUT PULONG pcbSize);

NTSTATUS KRegpGetKeyInfo(
   IN  HKEY	hKey,
   OUT PULONG	pcNumSubKeys,
   OUT PULONG 	pcbMaxSubKeyLength,
   OUT PULONG 	pcNumValues,
   OUT PULONG 	pcbMaxValueName,
   OUT PULONG 	pcbMaxValueData);

NTSTATUS KRegpEnumKeyValues(
   HKEY hKey,
   ULONG iValue,
   PWSTR wszValueName,
   PULONG pcbMaxValueName,
   PBYTE pbData,
   PULONG pcbMaxDataSize);

NTSTATUS KRegpEnumSubKeys(
   HKEY hKey,
   ULONG iSubKey,
   PWSTR  wszSubKeyName,
   PULONG pcbMaxNameSize);

#endif // _REGSUPS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\regsups.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       regsups.c
//
//  Contents:   Support routines for registry - mainly wrappers for NtAPI.
//              The native NT registry API deal with unweildy OBJECT_ATTRIBUTES
//              structures to simply name a registry entry, and also deal
//              with open-ended structures. This module wraps around the native
//              NT api and presents a more logical interface tot the registry.
//
//              The routines all have a uniform theme:
//
//                o Declare a KEY_XXX (NT defined) structure on the stack,
//                  with an "arbitrary guess" for size of data.
//
//                o Make the NT call.
//
//                o If NT call returns STATUS_BUFFER_OVERFLOW, allocate a
//                  KEY_XXX structure of the correct size from heap, and make
//                  NT call again.
//
//                o If success, copy data to caller's data buffer, and free
//                  anything we allocated on the heap.
//
//              With a generous initial guess for data buffer size, most of
//              the time these calls will make a single NT call. Only for
//              large data will we pay the overhead of memory allocation.
//
//  Classes:
//
//  Functions:  KRegpAttributes
//              KRegpGetValueByName
//              KRegpGetKeyInfo
//              KRegpEnumKeyValues
//              KRegpEnumSubKeys
//
//  History:    18 Sep 92       Milans created.
//
//-----------------------------------------------------------------------------


#include "registry.h"
#include "regsups.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, KRegpAttributes )
#pragma alloc_text( PAGE, KRegpGetValueByName )
#pragma alloc_text( PAGE, KRegpGetKeyInfo )
#pragma alloc_text( PAGE, KRegpEnumKeyValues )
#pragma alloc_text( PAGE, KRegpEnumSubKeys )
#endif // ALLOC_PRAGMA


//-----------------------------------------------------------------------------
//
// The NT Reg API uses a few open ended structs for info related calls. This
// defines the max size of our structs.
//
// This is just an "optimization". When the NT API's want an open ended data
// buffer, we will initially supply one of MAX_INFO_LENGTH. If this is not
// sufficient, the NT API will return STATUS_BUFFER_OVERFLOW. At that point,
// we will allocate on the heap the proper size buffer, and call again.
//
//-----------------------------------------------------------------------------



#define MAX_INFO_LENGTH         512             // Maximum length of info bufs


//-----------------------------------------------------------------------------
//
// Struct for Value information (ie, value name, data, etc.)
//

typedef struct tag_KEY_VALUE_INFORMATION {
   KEY_VALUE_FULL_INFORMATION   vi;
   BYTE buffer[MAX_INFO_LENGTH];
} KEY_VALUE_INFORMATION;

#define KEY_VALUE_INFORMATION_LENGTH    sizeof(KEY_VALUE_FULL_INFORMATION) + \
                                        MAX_INFO_LENGTH

//-----------------------------------------------------------------------------
//
// Struct for Key information (ie, # of subkeys, # of values, etc.)
//

typedef struct tag_KEY_INFORMATION {
   KEY_FULL_INFORMATION ki;
   BYTE buffer[MAX_INFO_LENGTH];
} KEY_INFORMATION;

#define KEY_INFORMATION_LENGTH  sizeof(KEY_FULL_INFORMATION) + MAX_INFO_LENGTH


//-----------------------------------------------------------------------------
//
// Struct for a particular subkey's information
//

typedef struct tag_KEY_SUBKEY_INFORMATION {
   KEY_NODE_INFORMATION ni;
   BYTE buffer[MAX_INFO_LENGTH];
} KEY_SUBKEY_INFORMATION;

#define KEY_SUBKEY_INFORMATION_LENGTH   sizeof(KEY_NODE_INFORMATION) + \
                                        MAX_INFO_LENGTH



//+----------------------------------------------------------------------------
//
//  Function:  KRegpAttributes
//
//  Synopsis:  The NT reg API often calls for an Object Attributes structure
//             for things like names etc. This routine bundles a name and its
//             parent into such a structure.
//
//  Arguments: [hParent]  Handle to parent of object
//             [wszName]  Name of object
//
//  Returns:   Address of initialized object attributes structure.
//
//  Notes:     Return value is address to static variable.
//
//-----------------------------------------------------------------------------

OBJECT_ATTRIBUTES *
KRegpAttributes(
   IN HANDLE hParent,
   IN PWSTR  wszName)
{
   static OBJECT_ATTRIBUTES objAttributes;
   static UNICODE_STRING usName;

   RtlInitUnicodeString(&usName, wszName);
   InitializeObjectAttributes(
      &objAttributes,                            // Destination
      &usName,                                   // Name
      OBJ_CASE_INSENSITIVE,                      // Attributes
      hParent,                                   // Parent
      NULL);                                     // Security

   return(&objAttributes);
}



//+----------------------------------------------------------------------------
//
//  Function:  KRegpGetValueByName
//
//  Synopsis:  Given a Value Name, returns the value's data.
//
//  Arguments: [hkey] Handle of key
//             [wszValueName] Value Name to query
//             [pbData] Pointer to data buffer
//             [pcbSize] Pointer to ULONG. On entry, it must show size of
//                        data buffer. On successful exit, it will be set to
//                        actual length of data retrieved.
//
//  Returns:   STATUS_BUFFER_TOO_SMALL, Status from NT Reg API.
//
//-----------------------------------------------------------------------------

NTSTATUS
KRegpGetValueByName(
   IN HKEY  hKey,
   IN PWSTR wszValueName,
   OUT PBYTE pbData,
   IN OUT PULONG pcbSize)
{
   KEY_VALUE_INFORMATION viValue, *pviValue;
   UNICODE_STRING ustrValueName;
   ULONG    cbActualLength, cbRequiredSize;
   NTSTATUS Status;

   RtlInitUnicodeString(&ustrValueName, wszValueName);
   pviValue = &viValue;
   Status = NtQueryValueKey(
               hKey,
               &ustrValueName,
               KeyValueFullInformation,
               (PVOID) pviValue,
               KEY_VALUE_INFORMATION_LENGTH,
               &cbActualLength
               );

   if (Status == STATUS_BUFFER_OVERFLOW) {

       //
       // Our default buffer of MAX_INFO_LENGTH size didn't quite cut it
       // Forced to allocate from heap and make call again.
       //

       pviValue = (KEY_VALUE_INFORMATION *) ExAllocatePoolWithTag(
                                                PagedPool,
                                                cbActualLength,
                                                ' sfD');
       if (!pviValue) {
           return(STATUS_NO_MEMORY);
       }

       Status = NtQueryValueKey(
                    hKey,
                    &ustrValueName,
                    KeyValueFullInformation,
                    (PVOID) pviValue,
                    cbActualLength,
                    &cbActualLength);
   }

   if (!NT_SUCCESS(Status)) {
       goto Cleanup;
   }

   if (pviValue->vi.Type == REG_SZ) {
       cbRequiredSize = pviValue->vi.DataLength + sizeof(UNICODE_NULL);
   } else {
       cbRequiredSize = pviValue->vi.DataLength;
   }

   if (cbRequiredSize > *pcbSize) {
      Status = STATUS_BUFFER_TOO_SMALL;
      goto Cleanup;
   }

   RtlMoveMemory(pbData, ((BYTE *) pviValue) + pviValue->vi.DataOffset,
                 pviValue->vi.DataLength);

   if (pviValue->vi.Type == REG_SZ) {
       ((PWSTR) pbData)[cbRequiredSize/sizeof(WCHAR) - 1] = UNICODE_NULL;
   }

   *pcbSize = cbRequiredSize;


Cleanup:
   if (pviValue != &viValue) {

       //
       // Must have had to allocate from heap, so free the heap
       //

       DfsFree(pviValue);
   }

   return(Status);
}




//+----------------------------------------------------------------------------
//
//  Function:  KRegpGetKeyInfo
//
//  Synopsis:  Given a key, return the number of subkeys, values, and their
//             max sizes.
//
//  Arguments: [hkey]                   Handle to key.
//             [pcNumSubKeys]           Receives # of subkeys that hkey has
//             [pcbMaxSubKeyLength]     Receives max length of subkey name
//             [pcNumValues]            Receives # of values that hkey has
//             [pcbMaxValueLength]      Receives max length of value name
//             [pcbMaxValueData]        Receives max length of value data
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
KRegpGetKeyInfo(
   IN  HKEY     hKey,
   OUT PULONG   pcNumSubKeys,
   OUT PULONG   pcbMaxSubKeyLength,
   OUT PULONG   pcNumValues,
   OUT PULONG   pcbMaxValueName,
   OUT PULONG   pcbMaxValueData)
{
   KEY_INFORMATION      kiInfo, *pkiInfo;
   ULONG                lActualLength;
   NTSTATUS             Status;

   pkiInfo = &kiInfo;
   Status = NtQueryKey(
               hKey,
               KeyFullInformation,
               pkiInfo,
               KEY_INFORMATION_LENGTH,
               &lActualLength);

   if (Status == STATUS_BUFFER_OVERFLOW) {

       //
       // Our default buffer of MAX_INFO_LENGTH size didn't quite cut it
       // Forced to allocate from heap and make call again.
       //

       pkiInfo = (KEY_INFORMATION *) ExAllocatePoolWithTag(
                                        PagedPool,
                                        lActualLength,
                                        ' sfD');
       if (!pkiInfo) {
           return(STATUS_NO_MEMORY);
       }

       Status = NtQueryKey(
                    hKey,
                    KeyFullInformation,
                    pkiInfo,
                    lActualLength,
                    &lActualLength);

   }

   if (NT_SUCCESS(Status)) {
      *pcNumSubKeys = pkiInfo->ki.SubKeys;
      *pcbMaxSubKeyLength = pkiInfo->ki.MaxNameLen;
      *pcNumValues = pkiInfo->ki.Values;
      *pcbMaxValueName = pkiInfo->ki.MaxValueNameLen;
      *pcbMaxValueData = pkiInfo->ki.MaxValueDataLen;
   }

   if (pkiInfo != &kiInfo) {
       DfsFree(pkiInfo);
   }

   return(Status);

}



//+----------------------------------------------------------------------------
//
//  Function:  KRegpEnumKeyValues
//
//  Synopsis:  Given a key, return the name and data of the i'th value, where
//             the first value has an index of 0.
//
//  Arguments: [hkey] --                Handle to key
//             [i] --                   Index of value to get
//             [wszValueName] --        Pointer to buffer to hold value name.
//             [pcbMaxValueName] --     on entry, size in bytes of wszValueName.
//                                      On exit, will hold size of wszValueName.
//             [pbData] --              pointer to buffer to hold value data.
//             [pcbMaxDataSize] --      on entry, size of pbData. On successful
//                                      return, size of pbData.
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
KRegpEnumKeyValues(
   HKEY hKey,
   ULONG iValue,
   PWSTR wszValueName,
   PULONG pcbMaxValueName,
   PBYTE pbData,
   PULONG pcbMaxDataSize)
{
   KEY_VALUE_INFORMATION        viValue, *pviValue;
   ULONG                        dwActualLength;
   NTSTATUS                     Status;

   pviValue = &viValue;
   Status = NtEnumerateValueKey(
               hKey,
               iValue,
               KeyValueFullInformation,
               pviValue,
               KEY_VALUE_INFORMATION_LENGTH,
               &dwActualLength);

   if (Status == STATUS_BUFFER_OVERFLOW) {

       //
       // Our default buffer of MAX_INFO_LENGTH size didn't quite cut it
       // Forced to allocate from heap and make call again.
       //

       pviValue = (KEY_VALUE_INFORMATION *) ExAllocatePoolWithTag(
                                                PagedPool,
                                                dwActualLength,
                                                ' sfD');
       if (!pviValue) {
           return(STATUS_NO_MEMORY);
       }
       Status = NtEnumerateValueKey(
                    hKey,
                    iValue,
                    KeyValueFullInformation,
                    pviValue,
                    dwActualLength,
                    &dwActualLength);
   }


   if (NT_SUCCESS(Status)) {
      if ( (*pcbMaxValueName < pviValue->vi.NameLength) ||
           (*pcbMaxDataSize < pviValue->vi.DataLength) ) {
               Status = STATUS_BUFFER_TOO_SMALL;
               goto Cleanup;
      }

      *pcbMaxValueName = pviValue->vi.NameLength;

      RtlMoveMemory(
         (BYTE *) wszValueName,
         (BYTE *) pviValue->vi.Name,
         pviValue->vi.NameLength
         );
      wszValueName[pviValue->vi.NameLength / sizeof(WCHAR)] = L'\0';

      RtlMoveMemory(
         pbData,
         ((BYTE *) &viValue) + pviValue->vi.DataOffset,
         pviValue->vi.DataLength
         );
      *pcbMaxDataSize = pviValue->vi.DataLength;
   }


Cleanup:
   if (pviValue != &viValue) {
       DfsFree(pviValue);
   }
   return(Status);
}



//+----------------------------------------------------------------------------
//
//  Function:   KRegpEnumSubKeys
//
//  Synopsis:   Retrieve the i'th subkey name of a key.
//
//  Arguments:  [hKey] --              Parent key
//              [iSubKey] --           index of the subkey
//              [wszSubKeyName]        Buffer to hold name of subkey
//              [pcbMaxNameSize]       On entry, size in bytes of wszSubKeyName
//                                     On exit, size of name.
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
KRegpEnumSubKeys(
   HKEY hKey,
   ULONG iSubKey,
   PWSTR  wszSubKeyName,
   PULONG pcbMaxNameSize
   )
{
   KEY_SUBKEY_INFORMATION si, *psi;
   ULONG dwActualLength;
   NTSTATUS Status;

   psi = &si;
   Status = NtEnumerateKey(
               hKey,
               iSubKey,
               KeyNodeInformation,
               psi,
               KEY_SUBKEY_INFORMATION_LENGTH,
               &dwActualLength
               );

   if (Status == STATUS_BUFFER_OVERFLOW) {

       //
       // Our default buffer of MAX_INFO_LENGTH size didn't quite cut it
       // Forced to allocate from heap and make call again.
       //

       psi = (KEY_SUBKEY_INFORMATION *) ExAllocatePoolWithTag(
                                            PagedPool,
                                            dwActualLength,
                                            ' sfD');
       if (!psi) {
           return(STATUS_NO_MEMORY);
       }

       Status = NtEnumerateKey(
                    hKey,
                    iSubKey,
                    KeyNodeInformation,
                    psi,
                    dwActualLength,
                    &dwActualLength
                    );

   }

   if (NT_SUCCESS(Status)) {
      if (*pcbMaxNameSize < si.ni.NameLength) {
          Status = STATUS_BUFFER_TOO_SMALL;
          goto Cleanup;
      }

      RtlMoveMemory(
         (BYTE *) wszSubKeyName,
         (BYTE *) psi->ni.Name,
         psi->ni.NameLength
         );
      wszSubKeyName[psi->ni.NameLength / sizeof(WCHAR)] = UNICODE_NULL;
      *pcbMaxNameSize = psi->ni.NameLength;
   }

Cleanup:
   if (psi != &si) {
       DfsFree(psi);
   }
   return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\reset.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       reset.h
//
//  Contents:   Protos for reset.c
//
//  Functions:  DfsFsctrlResetPkt
//
//-----------------------------------------------------------------------------

#ifndef _RESET_H_
#define _RESET_H_

NTSTATUS
DfsFsctrlResetPkt(
    IN PIRP Irp
    );

NTSTATUS
DfsFsctrlMarkStalePktEntries(
    IN PIRP Irp
    );

NTSTATUS
DfsFsctrlFlushStalePktEntries(
    IN PIRP Irp
    );

NTSTATUS
DfsFsctrlStopDfs(
    IN PIRP Irp
    );

#endif // _RESET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\registry.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       registry.h
//
//  Contents:   Module to interface with the NT registry. This is a free
//              standing module that one should be able to cut and paste
//              into any kernel/user application.
//
//              To use this module (and the associated regsups.c and regkeys.c)
//              in another project, one needs to do the following:
//
//              o  #define kreg_debug_out, kreg_alloc, and kreg_free, as
//                 appropriate for the application/kernel component.
//              o  If linking into a device driver or some kernel component,
//                 compile with the -D KERNEL_MODE
//  Classes:
//
//  Functions:  KRegInit()
//              KRegSetRoot()
//              KRegCloseRoot()
//              KRegGetValue()
//              KRegGetNumValuesAndSubKeys()
//              KRegEnumValueSet()
//              KRegEnumSubKeySet()
//
//  History:    18 Sep 92       Milans created
//
//-----------------------------------------------------------------------------

#ifndef _REGISTRY_
#define _REGISTRY_

#include <wchar.h>                               // For wstring routines

#include "dfsprocs.h"                            // For DebugTrace definition
                                                 // only. Replace at will.


//-----------------------------------------------------------------------------
//
// The following are needed to use registry.h in an application. Change as
// appropriate for the particular situation.
//

//
// Define KREG_DEBUG_OUT(x,y) appropriately for your application. x,y are like
// a pair of arguments to printf, the first a format string and the second a
// single argument.
//

#define kreg_debug_out(x,y)     DebugTrace(0, DEBUG_TRACE_REGISTRY, x, y)


//
// Define KREG_ALLOC and KREG_FREE appropriately for your application.
// Semantics are exactly like malloc and free
//

#define kreg_alloc(x)           ExAllocatePoolWithTag(PagedPool, (x), ' sfD')
#define kreg_free(x)            DfsFree(x)


//
// End of application dependent stuff.
//
//-----------------------------------------------------------------------------

#ifdef KERNEL_MODE

#define NtClose         ZwClose
#define NtCreateKey     ZwCreateKey
#define NtDeleteKey     ZwDeleteKey
#define NtDeleteValueKey ZwDeleteValueKey
#define NtEnumerateKey  ZwEnumerateKey
#define NtEnumerateValueKey ZwEnumerateValueKey
#define NtFlushKey      ZwFlushKey
#define NtOpenKey       ZwOpenKey
#define NtQueryKey      ZwQueryKey
#define NtQueryValueKey ZwQueryValueKey
#define NtSetValueKey   ZwSetValueKey

#endif // KERNEL_MODE


//
// Some types used by registry calls.
//

typedef unsigned char BYTE;
typedef unsigned char *PBYTE;                    // Pointer to bytes

typedef PWSTR   *APWSTR;                         // Array of PWSTR
typedef PBYTE   *APBYTE;                         // Array of PBYTES
typedef NTSTATUS *ANTSTATUS;                     // Array of NTSTATUS



NTSTATUS KRegInit(void);

NTSTATUS KRegSetRoot(
            IN PWSTR wszRootName);

void KRegCloseRoot(void);

NTSTATUS KRegCreateKey(
            IN PWSTR wszSubKey,
            IN PWSTR wszNewKey);

NTSTATUS KRegDeleteKey(
            IN PWSTR wszKey);

NTSTATUS KRegGetValue(
            IN PWSTR wszSubKey,
            IN PWSTR wszValueName,
            OUT PBYTE *ppValueData);

NTSTATUS KRegSetValue(
            IN PWSTR wszSubKey,
            IN PWSTR wszValueName,
            IN ULONG ulType,
            IN ULONG cbSize,
            IN PBYTE pValueData);

NTSTATUS KRegDeleteValue(
            IN PWSTR wszSubKey,
            IN PWSTR wszValueName);

NTSTATUS KRegGetValueSet(
            IN PWSTR wszSubKey,
            IN ULONG lNumValues,
            IN PWSTR wszValueNames[],
            OUT PBYTE lpbValueData[],
            OUT NTSTATUS aValueStatus[]);

NTSTATUS KRegGetNumValuesAndSubKeys(
            IN PWSTR wszSubKey,
            OUT PULONG plNumValues,
            OUT PULONG plNumSubKeys);

NTSTATUS KRegEnumValueSet(
            IN PWSTR wszSubKey,
            IN OUT PULONG plMaxElements,
            OUT APWSTR *pawszValueNames,
            OUT APBYTE *palpbValueData,
            OUT ANTSTATUS *paValueStatus);

NTSTATUS KRegEnumSubKeySet(
            IN PWSTR wszSubKey,
            IN OUT PULONG plMaxElements,
            OUT APWSTR *pawszSubKeyNames);

VOID KRegFreeArray(
            IN ULONG cElements,
            IN APBYTE pa);

#endif // ifndef _REGISTRY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\reset.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       reset.c
//
//  Contents:   Module to reset PKT to just-inited state
//
//  History:    12 Feb 1998     JHarper created.
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "fsctrl.h"

#define Dbg                     DEBUG_TRACE_RESET

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsFsctrlResetPkt )
#pragma alloc_text( PAGE, DfsFsctrlStopDfs )
#endif // ALLOC_PRAGMA


//+----------------------------------------------------------------------------
//
//  Function:  DfsFsctrlResetPkt
//
//  Synopsis:  Walks the Pkt, getting it back to 'just boot' state
//              Used for 'unjoin' or teardown of a Dfs/FtDfs
//
//  Arguments:  [Irp] --
//
//  Returns:   STATUS_SUCCESS
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlResetPkt(
    IN PIRP Irp)
{
    PDFS_PKT Pkt;
    NTSTATUS status;
    PDFS_PKT_ENTRY curEntry;
    PDFS_PKT_ENTRY nextEntry;

    STD_FSCTRL_PROLOGUE("DfsFsctrlResetPkt", FALSE, FALSE);

    DebugTrace(+1, Dbg, "DfsFsctrlResetPkt()\n", 0);

    Pkt = _GetPkt();
    PktAcquireExclusive(Pkt, TRUE);
    curEntry = PktFirstEntry(Pkt);

    while (curEntry != NULL)  {

        nextEntry = PktNextEntry(Pkt, curEntry);
        PktEntryDestroy(curEntry, Pkt, (BOOLEAN) TRUE);
        curEntry = nextEntry;
    }

    DfsFreePrefixTable(&Pkt->LocalVolTable);
    DfsFreePrefixTable(&Pkt->PrefixTable);
    DfsFreePrefixTable(&Pkt->ShortPrefixTable);

    DfsInitializeUnicodePrefix(&Pkt->LocalVolTable);
    DfsInitializeUnicodePrefix(&Pkt->PrefixTable);
    DfsInitializeUnicodePrefix(&Pkt->ShortPrefixTable);

    Pkt->DomainPktEntry = NULL;

    status = STATUS_SUCCESS;

    PktRelease(Pkt);

    DebugTrace(-1, Dbg, "DfsFsctrlResetPkt - returning %08lx\n", ULongToPtr( status ));

    DfsCompleteRequest(Irp, status);

    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlStopDfs
//
//  Synopsis:   Sets the state of the Dfs driver so that it will stop handling
//              referral requests
//
//  Arguments:  [Irp] --
//
//  Returns:    [STATUS_SUCCESS] -- Successfully set the state to started.
//
//              [STATUS_UNSUCCESSFUL] -- An error occured trying to set the
//                      state of Dfs to stopped.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlStopDfs(
    IN PIRP Irp)
{
    NTSTATUS status;

    STD_FSCTRL_PROLOGUE("DfsFsctrlStopDfs", FALSE, FALSE);

    DebugTrace(-1, Dbg, "DfsFsctrlStopDfs()\n", 0);

    DfsData.OperationalState = DFS_STATE_STOPPED;

    DfsData.MachineState = DFS_UNKNOWN;

    status = STATUS_SUCCESS;

    DebugTrace(-1, Dbg, "DfsFsctrlStartDfs - returning %08lx\n", ULongToPtr( status ));

    DfsCompleteRequest(Irp, status);

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:  DfsFsctrlMarkStalePktEntries
//
//  Synopsis:  Walks the Pkt, marking all entries stale
//
//  Arguments:  [Irp] --
//
//  Returns:   STATUS_SUCCESS
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlMarkStalePktEntries(
    IN PIRP Irp)
{
    PDFS_PKT Pkt;
    NTSTATUS status;
    PDFS_PKT_ENTRY curEntry;
    PDFS_PKT_ENTRY nextEntry;

    STD_FSCTRL_PROLOGUE("DfsFsctrlMarkStalePktEntries", FALSE, FALSE);

    DebugTrace(+1, Dbg, "DfsFsctrlMarkStalePktEntries()\n", 0);

    Pkt = _GetPkt();
    PktAcquireExclusive(Pkt, TRUE);
    curEntry = PktFirstEntry(Pkt);

    while (curEntry != NULL)  {
        nextEntry = PktNextEntry(Pkt, curEntry);
        if (curEntry->Type & PKT_ENTRY_TYPE_LOCAL_XPOINT)
            curEntry->Type |= PKT_ENTRY_TYPE_STALE;
        curEntry = nextEntry;
    }

    status = STATUS_SUCCESS;
    PktRelease(Pkt);
    DebugTrace(-1, Dbg, "DfsFsctrlMarkStalePktEntries - returning %08lx\n", ULongToPtr( status ));
    DfsCompleteRequest(Irp, status);
    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:  DfsFsctrlFlushStalePktEntries
//
//  Synopsis:  Walks the Pkt, removing all stale entries
//
//  Arguments:  [Irp] --
//
//  Returns:   STATUS_SUCCESS
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlFlushStalePktEntries(
    IN PIRP Irp)
{
    PDFS_PKT Pkt;
    NTSTATUS status;
    PDFS_PKT_ENTRY curEntry;
    PDFS_PKT_ENTRY nextEntry;
    DFS_PKT_ENTRY_ID Id;

    STD_FSCTRL_PROLOGUE("DfsFsctrlFlushStalePktEntries", FALSE, FALSE);

    DebugTrace(+1, Dbg, "DfsFsctrlFlushStalePktEntries()\n", 0);

    Pkt = _GetPkt();
    PktAcquireExclusive(Pkt, TRUE);
    curEntry = PktFirstEntry(Pkt);

    while (curEntry != NULL)  {
        nextEntry = PktNextEntry(Pkt, curEntry);
        if (curEntry->Type & PKT_ENTRY_TYPE_STALE) {
            Id = curEntry->Id;
            Id.Prefix.Buffer = ExAllocatePoolWithTag(
                                PagedPool,
                                Id.Prefix.MaximumLength + Id.ShortPrefix.MaximumLength,
                                ' sfD');
            if (Id.Prefix.Buffer != NULL) {
                Id.ShortPrefix.Buffer = &Id.Prefix.Buffer[Id.Prefix.MaximumLength/sizeof(WCHAR)];
                RtlCopyMemory(
                        Id.Prefix.Buffer,
                        curEntry->Id.Prefix.Buffer,
                        Id.Prefix.MaximumLength);
                RtlCopyMemory(
                        Id.ShortPrefix.Buffer,
                        curEntry->Id.ShortPrefix.Buffer,
                        Id.ShortPrefix.MaximumLength);
                DfsInternalDeleteExitPoint(&Id, PKT_ENTRY_TYPE_CAIRO);
                ExFreePool(Id.Prefix.Buffer);
            }
        }
        curEntry = nextEntry;
    }

    status = STATUS_SUCCESS;
    PktRelease(Pkt);
    DebugTrace(-1, Dbg, "DfsFsctrlFlushStalePktEntries - returning %08lx\n", ULongToPtr( status ));
    DfsCompleteRequest(Irp, status);
    return( status );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\regkeys.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       regkeys.c
//
//  Contents:   constant registry strings
//
//  Classes:
//
//  Functions:
//
//  History:    11 Sep 92       Milans created
//
//-----------------------------------------------------------------------------

#include "registry.h"
#include "regkeys.h"
#include "dfsstr.h"

#define REG_MACHINE     L"\\REGISTRY\\MACHINE\\"

const PWSTR wszRegRootVolumes =
       REG_MACHINE VOLUMES_DIR;

const PWSTR wszLocalVolumesSection =
       REG_MACHINE REG_KEY_LOCAL_VOLUMES;

const PWSTR wszRegDfsDriver = 
       REG_MACHINE REG_KEY_DFSDRIVER;

const PWSTR wszRegDfsHost = 
       REG_MACHINE DFSHOST_DIR;

const PWSTR wszEntryPath = REG_VALUE_ENTRY_PATH;
const PWSTR wszShortEntryPath = REG_VALUE_SHORT_PATH;
const PWSTR wszStorageId = REG_VALUE_STORAGE_ID;
const PWSTR wszShareName = REG_VALUE_SHARE_NAME;
const PWSTR wszEntryType = REG_VALUE_ENTRY_TYPE;
const PWSTR wszServiceType = L"ServiceType";

const PWSTR wszProviderKey = L"Providers";
const PWSTR wszDeviceName = L"DeviceName";
const PWSTR wszProviderId = L"ProvID";
const PWSTR wszCapabilities = L"Capabilities";
const PWSTR wszIpCacheTimeout = L"IpCacheTimeout";
const PWSTR wszDefaultTimeToLive = REG_VALUE_TIMETOLIVE;

const PWSTR wszRegComputerNameRt =
    REG_MACHINE L"SYSTEM\\CurrentControlSet\\Control\\ComputerName";
const PWSTR wszRegComputerNameSubKey = L"ComputerName";
const PWSTR wszRegComputerNameValue = L"ComputerName";
const PWSTR wszMaxReferrals = L"DfsReferralLimit";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\sitesup.c ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.
//
//  File:       sitesup.c
//
//  Contents:   Support routines for managing DFS_SITE_INFO entries
//
//  Functions:  DfsInitSites - Initialize the hash table for DFS_SITE_INFO lookup
//              DfsLookupSiteInfo - Lookup a DFS_SITE_INFO
//              DfsAllocateSiteInfo - Allocate a DFS_SITE_INFO
//              DfsInsertSiteInfo - Put a DFS_SITE_INFO into the table
//              DfsDeleteSiteInfo - Remove a DFS_SITE_INFO from the table
//              DfsReleaseSiteInfo - Stop using a DFS_SITE_INFO
//
//              DfsFsctrlCreateSiteInfo - Load a Site table entry
//              DfsFsctrlDeleteSiteInfo - Remove a Site table entry
//
//--------------------------------------------------------------------------


#include "dfsprocs.h"
#include "attach.h"
#include "sitesup.h"
#include "fsctrl.h"

#define Dbg     0x1000

#define DEFAULT_HASH_SIZE       16      // default size of hash table

NTSTATUS
DfsInitSiteInfoHashTable(
    IN  ULONG cHash,
    OUT PSITE_HASH_TABLE *ppHashTable
);

NTSTATUS
DfsAllocateSiteInfo(
  IN    PUNICODE_STRING pServerName,
  IN    ULONG SiteCount,
  IN    PUNICODE_STRING pSiteNames,
  OUT   PDFS_SITE_INFO *ppSiteInfo
);

PDFS_SITE_INFO
DfsLookupSiteInfo(
  IN    PUNICODE_STRING ServerName
);

VOID
DfsInsertSiteInfo(
  IN    PUNICODE_STRING pServerName,
  IN    PDFS_SITE_INFO pSiteInfo
);

VOID
DfsDeleteSiteInfo(
    PDFS_SITE_INFO pSiteInfo
);

VOID
DfsReleaseSiteInfo(
  IN    PDFS_SITE_INFO pSiteInfo
);

ULONG
DfsHashSiteName(
    IN PUNICODE_STRING ServerName,
    IN DWORD HashMask
);

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DfsInitSites)
#pragma alloc_text(PAGE, DfsUninitSites)
#pragma alloc_text(PAGE, DfsInitSiteInfoHashTable)
#pragma alloc_text(PAGE, DfsAllocateSiteInfo)
#pragma alloc_text(PAGE, DfsReleaseSiteInfo)
#pragma alloc_text(PAGE, DfsHashSiteName)
#pragma alloc_text(PAGE, DfsFsctrlCreateSiteInfo)
#pragma alloc_text(PAGE, DfsFsctrlDeleteSiteInfo)
#pragma alloc_text(PAGE, DfsLookupSiteInfo)
#pragma alloc_text(PAGE, DfsInsertSiteInfo)
#pragma alloc_text(PAGE, DfsDeleteSiteInfo)

#endif

#ifdef DBG
VOID
DfsDumpSiteTable(void);
#endif

//+-------------------------------------------------------------------------
//
//  Function:   DfsInitSiteHashTable - Initialize the DFS_SITE_INFO lookup hash table
//
//  Synopsis:   This function initializes data structures which are
//              used for looking up a DFS_SITE_INFO associated with some site.
//
//  Arguments:  [cHash] -- Size of the hash table to be allocated.  Must be
//                         a power of two.  If zero, a default size is used.
//
//  Returns:    NTSTATUS -- STATUS_SUCCESS, unless memory allocation
//                          fails.
//
//  Note:       The hash buckets are initialized to zero, then later
//              initialized to a list head when used.  This is a debugging
//              aid to determine if some hash buckets are never used.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsInitSiteHashTable(
    ULONG cHash,
    PSITE_HASH_TABLE *ppHashTable)
{
    PSITE_HASH_TABLE pHashTable;
    ULONG cbHashTable;

    if (cHash == 0) {
        cHash = DEFAULT_HASH_SIZE;
    }

    ASSERT ((cHash & (cHash-1)) == 0);  // Assure cHash is a power of two

    cbHashTable = sizeof(SITE_HASH_TABLE) + (cHash-1) * sizeof(LIST_ENTRY);
    pHashTable = ExAllocatePoolWithTag(NonPagedPool, cbHashTable, ' sfD');
    if (pHashTable == NULL) {
        return STATUS_NO_MEMORY;
    }
    pHashTable->NodeTypeCode = DFS_NTC_SITE_HASH;
    pHashTable->NodeByteSize = (NODE_BYTE_SIZE) cbHashTable;

    pHashTable->HashMask = (cHash-1);
    ExInitializeFastMutex( &pHashTable->HashListMutex );
    RtlZeroMemory(&pHashTable->HashBuckets[0], cHash * sizeof(LIST_ENTRY));

    *ppHashTable = pHashTable;

    return(STATUS_SUCCESS);
}

NTSTATUS
DfsInitSites(
    ULONG cHash)
{
    NTSTATUS status;

    status = DfsInitSiteHashTable( cHash, &DfsData.SiteHashTable );

    return status;
}

VOID
DfsUninitSites(
    VOID)
{
    ExFreePool (DfsData.SiteHashTable);
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsLookupSiteInfo - Lookup a DFS_SITE_INFO in the hash table
//
//  Synopsis:   This function will lookup a DFS_SITE_INFO.
//              It will increment the UseCount on the DFS_SITE_INFO.
//
//  Arguments:  [ServerName] -- Servername for which the DFS_SITE_INFO is
//                         being looked up.
//
//  Returns:    PVOID -- pointer to the DFS_SITE_INFO found, or NULL if none
//
//  Algorithm:  Knuth would call it hashing with conflict resoulution
//              by chaining.
//
//  History:    20 Feb 1993     Alanw   Created
//              11 Nov 1997     JHarper Modified for sites (used fcbsup.c as template)
//
//--------------------------------------------------------------------------


PDFS_SITE_INFO
DfsLookupSiteInfo(
    PUNICODE_STRING ServerName)
{
    PLIST_ENTRY pListHead, pLink;
    PDFS_SITE_INFO pSiteInfo;
    PSITE_HASH_TABLE pHashTable = DfsData.SiteHashTable;

    ExAcquireFastMutex( &pHashTable->HashListMutex );
    pListHead = &pHashTable->HashBuckets[ DfsHashSiteName(ServerName, pHashTable->HashMask) ];

    if ((pListHead->Flink == NULL) ||           // list not initialized
        (pListHead->Flink == pListHead)) {      // list empty
        ExReleaseFastMutex( &pHashTable->HashListMutex );
        return NULL;
    }

    for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
        pSiteInfo = CONTAINING_RECORD(pLink, DFS_SITE_INFO, HashChain);
        if (RtlCompareUnicodeString(&pSiteInfo->ServerName,ServerName,TRUE) == 0) {
            pSiteInfo->UseCount++;
            ExReleaseFastMutex( &pHashTable->HashListMutex );
            return pSiteInfo;
        }
    }
    ExReleaseFastMutex( &pHashTable->HashListMutex );
    return NULL;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsInsertSiteInfo - Inserts a DFS_SITE_INFO into the hash table
//
//  Synopsis:   This function associates a DFS_SITE_INFO to a Server.  This
//              involves removing any existing entry, and adding the new.
//
//  Arguments:  [pSiteInfo] -- Pointer to the DFS_SITE_INFO to be inserted.
//              [pServerName] -- Pointer to the corresponding server name, used
//                              as the hash key.
//
//  Returns:    -nothing-
//
//--------------------------------------------------------------------------

VOID
DfsInsertSiteInfo(
    PUNICODE_STRING pServerName,
    PDFS_SITE_INFO pSiteInfo)
{
    PSITE_HASH_TABLE pHashTable = (PSITE_HASH_TABLE) DfsData.SiteHashTable;
    PLIST_ENTRY pListHead;
    PDFS_SITE_INFO pExistingSiteInfo;

    pExistingSiteInfo = DfsLookupSiteInfo( &pSiteInfo->ServerName);

    //
    // Put the new one in
    //

    ExAcquireFastMutex( &pHashTable->HashListMutex );

    pListHead = &pHashTable->HashBuckets[ DfsHashSiteName(pServerName, pHashTable->HashMask) ];

    if (pListHead->Flink == NULL) {
        InitializeListHead(pListHead);
    }
    InsertHeadList(pListHead, &pSiteInfo->HashChain);
    ExReleaseFastMutex( &pHashTable->HashListMutex );

    if (pExistingSiteInfo != NULL) {

        DfsDeleteSiteInfo(
            pExistingSiteInfo);

        DfsReleaseSiteInfo(
            pExistingSiteInfo);

    }

    DebugTrace(0, Dbg, "Added SiteInfo %08lx ", pSiteInfo);
    DebugTrace(0, Dbg, "For Server %wZ ", pServerName);

}


//+-------------------------------------------------------------------------
//
//  Function:   DfsDeleteSiteInfo - Delete a DFS_SITE_INFO from the lookup hash table
//
//  Synopsis:   This function Deletes a DFS_SITE_INFO from the hash table.
//
//  Arguments:  [pSiteInfo] -- Pointer to the DFS_SITE_INFO to delete
//
//  Returns:    -nothing-
//
//--------------------------------------------------------------------------

VOID
DfsDeleteSiteInfo(
    PDFS_SITE_INFO pSiteInfo)
{
    PSITE_HASH_TABLE pHashTable = (PSITE_HASH_TABLE) DfsData.SiteHashTable;

    ExAcquireFastMutex( &pHashTable->HashListMutex);
    pSiteInfo->Flags |= SITE_INFO_DELETE_PENDING;
    RemoveEntryList(&pSiteInfo->HashChain);
    InitializeListHead(&pSiteInfo->HashChain);
    ExReleaseFastMutex( &pHashTable->HashListMutex );

    DebugTrace(0, Dbg, "deleted SiteInfo %08lx ", pSiteInfo);
    DebugTrace(0, Dbg, "For server %wZ ", &pSiteInfo->ServerName);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsAllocateSiteInfo - Allocate a DFS_SITE_INFO
//
//  Synopsis:   This function allocates a contiguous DFS_SITE_INFO struct.  The
//              strings are stored in the allocated buffer after the DFS_SITE_INFO
//              structure.
//
//  Arguments:  [pServerName] -- The server name for the site list
//              [ppSiteInfo] -- On successful return, has pointer to newly allocated
//                      DFS_SITE_INFO.
//
//  Returns:    [STATUS_SUCCESS] -- Successfully allocated DFS_SITE_INFO
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory condition
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsAllocateSiteInfo(
    PUNICODE_STRING pServerName,
    ULONG SiteCount,
    PUNICODE_STRING pSiteNames,
    PDFS_SITE_INFO *ppSiteInfo)
{
    NTSTATUS status;
    PDFS_SITE_INFO pSiteInfo;
    ULONG Size;
    ULONG i;
    LPWSTR pwCh;
    PUNICODE_STRING pustr;

    if (SiteCount < 1) {

        DebugTrace(0, Dbg, "DfsAllocateSiteInfo SiteCount = %d\n", ULongToPtr( SiteCount ));

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    DebugTrace(0, Dbg, "DfsAllocateSiteInfo(%wZ)\n", pServerName);

    //
    // Size the buffer - include storage for the unicode strings after the
    // DFS_SITE_INFO structure.
    //

    Size = sizeof(DFS_SITE_INFO) +
             pServerName->Length +
                sizeof(UNICODE_STRING) * (SiteCount - 1);

    for (i = 0; i < SiteCount; i++) {

        Size += pSiteNames[i].Length;

    }

    pSiteInfo = (PDFS_SITE_INFO) ExAllocatePoolWithTag( NonPagedPool, Size, ' sfD' );

    if (pSiteInfo != NULL) {

        RtlZeroMemory( pSiteInfo, Size );

        pSiteInfo->NodeTypeCode = DFS_NTC_SITE_INFO;
        pSiteInfo->NodeByteSize = (USHORT)Size;

        pwCh = (LPWSTR) &pSiteInfo->SiteName[SiteCount];

        pustr = &pSiteInfo->ServerName;
        pustr->Length = pustr->MaximumLength = pServerName->Length;
        pustr->Buffer = pwCh;
        RtlCopyMemory(pwCh, pServerName->Buffer, pServerName->Length);
        pwCh += pustr->Length / sizeof(WCHAR);

        pSiteInfo->SiteCount = SiteCount;

        for (i = 0; i < SiteCount; i++) {

            pustr = &pSiteInfo->SiteName[i];
            pustr->Length = pustr->MaximumLength = pSiteNames[i].Length;
            pustr->Buffer = pwCh;
            RtlCopyMemory(pwCh, pSiteNames[i].Buffer, pSiteNames[i].Length);
            pwCh += pustr->Length / sizeof(WCHAR);

        }

        *ppSiteInfo = pSiteInfo;

        status = STATUS_SUCCESS;

        DebugTrace(0, Dbg, "DfsAllocateSiteInfo pSiteInfo = %d\n", pSiteInfo);

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;

    }

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsReleaseSiteInfo
//
//  Synopsis:   Decrements UseCount of and possibly frees a DFS_SITE_INFO
//
//  Arguments:  [pSiteInfo] -- The DFS_SITE_INFO to release
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsReleaseSiteInfo(
    PDFS_SITE_INFO pSiteInfo)
{
    PSITE_HASH_TABLE pHashTable = (PSITE_HASH_TABLE) DfsData.SiteHashTable;

    //
    // There's a potential race with DfsDeleteSiteInfo's setting of the
    // DELETE_PENDING and the test below of DELETE_PENDING, so we still have
    // to acquire the lock to safely test the DELETE_PENDING bit.
    //

    ExAcquireFastMutex( &pHashTable->HashListMutex );

    pSiteInfo->UseCount--;

    if ((pSiteInfo->Flags & SITE_INFO_DELETE_PENDING) != 0 && pSiteInfo->UseCount == 0) {

        ExFreePool(pSiteInfo);

    }

    ExReleaseFastMutex( &pHashTable->HashListMutex );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsHashSiteNames
//
//  Synopsis:   Generates a hash 0-N - ignores case
//
//  Arguments:  [pServerName] -- The Server name to hash
//
//  Returns:    Nothing
//
//  Notes: Might need to convert DNS-style names to short names (??)
//
//-----------------------------------------------------------------------------

ULONG
DfsHashSiteName(
    PUNICODE_STRING ServerName,
    DWORD HashMask)
{
    ULONG BucketNo = 0;
    WCHAR *pBuffer = ServerName->Buffer;
    WCHAR *pBufferEnd = &pBuffer[ServerName->Length / sizeof(WCHAR)];
    ULONG wCh;

    BucketNo = 0;

    while (pBuffer != pBufferEnd) {
    
        wCh = (*pBuffer < L'a')
                 ? *pBuffer
                 : ((*pBuffer < L'z')
                     ? (*pBuffer - L'a' + L'A')
                     : RtlUpcaseUnicodeChar(*pBuffer));
        BucketNo *= 131;
        BucketNo += wCh;
        pBuffer++;

    }

    BucketNo = BucketNo & HashMask;
    return BucketNo;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctrlCreateSiteInfo, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Notes:      We only process this FSCTRL from the file system process,
//              never from the driver.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsFsctrlCreateSiteInfo(
    PIRP Irp,
    PVOID InputBuffer,
    ULONG InputBufferLength)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_CREATE_SITE_INFO_ARG arg;
    PDFS_SITE_INFO pSiteInfo;
    ULONG i;
    ULONG Size;

    STD_FSCTRL_PROLOGUE(DfsFsctrlCreateSiteInfo, TRUE, FALSE);

    if (InputBufferLength < sizeof(DFS_CREATE_SITE_INFO_ARG)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    //
    // unmarshal the arguments...
    //

    arg = (PDFS_CREATE_SITE_INFO_ARG) InputBuffer;

    Size = InputBufferLength - FIELD_OFFSET(DFS_CREATE_SITE_INFO_ARG, SiteName);

    if ( (Size / sizeof(arg->SiteName[0])) < arg->SiteCount ) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    OFFSET_TO_POINTER(arg->ServerName.Buffer, arg);

    if (!UNICODESTRING_IS_VALID(arg->ServerName, InputBuffer, InputBufferLength)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    for (i = 0; i < arg->SiteCount; i++) {
        OFFSET_TO_POINTER(arg->SiteName[i].Buffer, arg);
        if (!UNICODESTRING_IS_VALID(arg->SiteName[i], InputBuffer, InputBufferLength)) {
            status = STATUS_INVALID_PARAMETER;
            goto exit_with_status;
        }
    }

    if (NT_SUCCESS(status)) {

        status = DfsAllocateSiteInfo(
                    &arg->ServerName,
                    arg->SiteCount,
                    &arg->SiteName[0],
                    &pSiteInfo);

        if (NT_SUCCESS(status)) {

            DfsInsertSiteInfo(
                &arg->ServerName,
                pSiteInfo);

        }

    }

exit_with_status:

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg,
        "DfsFsctrlCreateSiteInfo: Exit -> %08lx\n", ULongToPtr( status ) );

    return status;

}

//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctrlDeleteSiteInfo, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Notes:      We only process this FSCTRL from the file system process,
//              never from the driver.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsFsctrlDeleteSiteInfo(
    PIRP Irp,
    PVOID InputBuffer,
    ULONG InputBufferLength)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_DELETE_SITE_INFO_ARG arg;
    PDFS_SITE_INFO pSiteInfo;

    STD_FSCTRL_PROLOGUE(DfsFsctrlDeleteSiteInfo, TRUE, FALSE);

    if (InputBufferLength < sizeof(DFS_DELETE_SITE_INFO_ARG)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    //
    // unmarshal the arguments...
    //

    arg = (PDFS_DELETE_SITE_INFO_ARG) InputBuffer;

    OFFSET_TO_POINTER(arg->ServerName.Buffer, arg);

    if (!UNICODESTRING_IS_VALID(arg->ServerName, InputBuffer, InputBufferLength)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    pSiteInfo = DfsLookupSiteInfo(
                    &arg->ServerName);

    //
    // The DfsLookupSiteInfo() call bumped the usecount, so we're sure pSiteInfo
    // won't become invalid as we're using it.
    //

    if (pSiteInfo != NULL) {

        //
        // Removes from the table, but doesn't free the memory
        //
        DfsDeleteSiteInfo(
            pSiteInfo);

        //
        // This will decrement the usecount, and if it goes to zero, frees the memory
        //
        DfsReleaseSiteInfo(
            pSiteInfo);

    }

exit_with_status:

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg,
        "DfsFsctrlDeleteSiteInfo: Exit -> %08lx\n", ULongToPtr( status ) );

    return status;

}

#ifdef DBG

VOID
DfsDumpSiteTable(void)
{
    PLIST_ENTRY pListHead, pLink;
    PDFS_SITE_INFO pSiteInfo;
    PSITE_HASH_TABLE pHashTable = DfsData.SiteHashTable;
    ULONG i, j;

    DbgPrint("---------Site Table----------\n");

    for (i = 0; i <= pHashTable->HashMask; i++) {

        pListHead = &pHashTable->HashBuckets[i];

        if ((pListHead->Flink == NULL) ||           // list not initialized
            (pListHead->Flink == pListHead)) {      // list empty
            continue;
        }

        for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
            pSiteInfo = CONTAINING_RECORD(pLink, DFS_SITE_INFO, HashChain);
            DbgPrint("\t[%02d][%wZ][%d]", i, &pSiteInfo->ServerName, pSiteInfo->SiteCount);
            for (j = 0; j < pSiteInfo->SiteCount; j++) {
                DbgPrint("(%wZ)", &pSiteInfo->SiteName[j]);
            }
            DbgPrint("\n");
        }
    }
    DbgPrint("-----------------------------\n");
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\regkeys.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       regkeys.h
//
//  Contents:   Defines for registry key names.
//              There are two specific hives of interest to DFS. One is
//              the Control\Cairo hive, shared with Security, from where
//              the cairo domain name of the machine is retrieved. The
//              other hive is the services\Dfs hive, from where the
//              DFS parameters are retrieved.
//
//              Thus, there are two "roots" defined, each with the subkeys
//              under the roots, and the specific value names under each
//              subkey.
//
//  Classes:
//
//  Functions:
//
//  History:    11 Sep 92       Milans Created
//
//-----------------------------------------------------------------------------

#ifndef _REG_KEYS_
#define _REG_KEYS_

extern const PWSTR wszRegComputerNameRt;         // Root sect for computer name
extern const PWSTR wszRegComputerNameSubKey;     // Subkey for computer name
extern const PWSTR wszRegComputerNameValue;      // Value name of computer name

extern const PWSTR wszRegRootVolumes;            // Root of the Dfs volume object store

extern const PWSTR wszLocalVolumesSection;       // Root key for local volumes
                                                 // local volume.
extern const PWSTR wszEntryType;                 // EntryType for local vol
extern const PWSTR wszServiceType;               // ServiceType for local vol

extern const PWSTR wszProviderKey;               // Subkey for providers
extern const PWSTR wszDeviceName;                // Value name for prov. name
extern const PWSTR wszProviderId;                // Value name for prov. id
extern const PWSTR wszCapabilities;              // Value name for prov. caps

extern const PWSTR wszEntryPath;                 // EntryPath for local vol
extern const PWSTR wszShortEntryPath;            // ShortEntryPath for local vol
extern const PWSTR wszStorageId;                 // StorageId for MachShare.
extern const PWSTR wszShareName;                 // Sharename for local vol
extern const PWSTR wszRegDfsDriver;
extern const PWSTR wszRegDfsHost;
extern const PWSTR wszIpCacheTimeout;
extern const PWSTR wszDefaultTimeToLive;
extern const PWSTR wszMaxReferrals;



#endif // _REG_KEYS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\srv.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       srv.h
//
//  Contents:   Support for interacting with the SMB server.
//
//  Classes:    None
//
//  Functions:  DfsSrvFsctrl
//
//-----------------------------------------------------------------------------

#ifndef _SRV_DFS_
#define _SRV_DFS_

VOID DfsSrvFsctrl(
    IN ULONG IoControlCode,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus);

#endif // _SRV_DFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\sitesup.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.
//
//  File:       sitesup.h
//
//  Contents:   Declarations for DFS_SITE lookup support functions.
//
//  History:    11 Nov 1997     Jharper Created
//
//--------------------------------------------------------------------------

#ifndef __SITESUP_H_
#define __SITESUP_H_

//
// For machine names we associate a list of sites
//

typedef struct _DFS_SITE_INFO {

    //
    //  Type and size of this record (must be DFS_NTC_SITEINFO)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A list entry for the hash table chain.
    //

    LIST_ENTRY HashChain;

    //
    // Count (for multi-threading)
    // Uses ExInterlockedIncrementLong()/ExInterlockedDecrementLong
    //

    ULONG UseCount;

    //
    // Flags
    //

    ULONG Flags;

    //
    //  The server name
    //

    UNICODE_STRING ServerName;

    //
    // Number of SiteNames associated with this server
    //

    ULONG SiteCount;

    //
    // The site names themselves.  There are actually N of these
    // where N is stored in SiteCount
    //

    UNICODE_STRING SiteName[1];

} DFS_SITE_INFO, *PDFS_SITE_INFO;

#define SITE_INFO_DELETE_PENDING    0x00000001  // DFS_SITE_INFO should be freed

//
//
//  Declaration of the hash table.  The hash table can be variably
//  sized, with the hash table size being a parameter of the hash
//  function.
//

typedef struct _SITE_HASH_TABLE {

    //
    //  The type and size of this record (must be DFS_NTC_SITE_HASH)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Mask value for the hash function.  The hash table size is
    //  assumed to be a power of two; the mask is the size - 1.
    //

    ULONG HashMask;

    //
    //  A mutex to protect access to the hash bucket chains
    //

    FAST_MUTEX HashListMutex;

    //
    //  An array of list heads for the hash table chains.  There
    //  are actually N of these where N is the hash table size.
    //

    LIST_ENTRY  HashBuckets[1];

} SITE_HASH_TABLE, *PSITE_HASH_TABLE;



NTSTATUS
DfsInitSites(
    IN ULONG cHash
);

VOID
DfsUninitSites(
    VOID
);

PDFS_SITE_INFO
DfsLookupSiteInfo(
    IN PUNICODE_STRING Servername
);

VOID
DfsReleaseSiteInfo(
    IN PDFS_SITE_INFO SiteInfo
);

NTSTATUS
DfsFsctrlCreateSiteInfo(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
);

NTSTATUS
DfsFsctrlDeleteSiteInfo(
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
);

#endif  // __SITESUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\spcsup.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1998, Microsoft Corporation.
//
//  File:       spcsup.h
//
//  Contents:   Declarations for DFS_SPECIAL_INFO hash table
//
//  History:    11 Nov 1997     Jharper Created
//
//--------------------------------------------------------------------------

#ifndef __SPCSUP_H_
#define __SPCSUP_H_

//
// For names we associate a list of names
//

typedef struct _DFS_SPECIAL_INFO {

    //
    //  Type and size of this record (must be DFS_NTC_SPECIAL_INFO)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A list entry for the hash table chain.
    //

    LIST_ENTRY HashChain;

    //
    // Use Count (for multi-threading)
    // Uses ExInterlockedIncrementLong()/ExInterlockedDecrementLong
    //

    ULONG UseCount;

    //
    // Flags
    //

    ULONG Flags;

    //
    //  The special name
    //

    UNICODE_STRING SpecialName;

    //
    // The time this entry becomes invalid
    //

    LARGE_INTEGER ExpireTime;

    //
    // Flags representing type (PRIMARY/SECONDARY and DNS/NETBIOS)
    //

    ULONG TypeFlags;

    //
    // Trust information
    //

    ULONG TrustDirection;
    ULONG TrustType;

    //
    // Number of Names associated with this special name
    //

    LONG NameCount;

    //
    // The names themselves.  There are actually N of these
    // where N is stored in NameCount
    //

    UNICODE_STRING Name[1];

} DFS_SPECIAL_INFO, *PDFS_SPECIAL_INFO;

#define SPECIAL_INFO_DELETE_PENDING    0x00000001  // DFS_SPECIAL_INFO should be freed
#define SPECIAL_INFO_IS_LONG_NAME      0x00000002
#define SPECIAL_INFO_NEEDS_REFRESH     0x00000004

#define MAX_SPC_LONG_NAME_SIZE  2048
//
//
//  Declaration of the hash table.  The hash table can be variably
//  sized, with the hash table size being a parameter of the hash
//  function.
//

typedef struct _SPECIAL_HASH_TABLE {

    //
    //  The type and size of this record (must be DFS_NTC_SPECIAL_HASH)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    // The timeout (in sec) to give to clients who ask for a special referral
    //

    ULONG SpcTimeout;

    //
    //  Mask value for the hash function.  The hash table size is
    //  assumed to be a power of two; the mask is the size - 1.
    //

    ULONG HashMask;

    //
    //  A mutex to protect access to the hash bucket chains
    //

    FAST_MUTEX HashListMutex;

    //
    //  An array of list heads for the hash table chains.  There
    //  are actually N of these where N is the hash table size.
    //

    LIST_ENTRY  HashBuckets[1];

} SPECIAL_HASH_TABLE, *PSPECIAL_HASH_TABLE;



NTSTATUS
DfsInitSpcHashTable(
    IN PSPECIAL_HASH_TABLE *ppHashTable,
    IN ULONG cHash
);

VOID
DfsUninitSpcHashTable(
    IN PSPECIAL_HASH_TABLE pHashTable
    );

PDFS_SPECIAL_INFO
DfsLookupSpcInfo(
    IN PSPECIAL_HASH_TABLE pHashTable,
    IN PUNICODE_STRING SpecialName
);

VOID
DfsReleaseSpcInfo(
    IN PSPECIAL_HASH_TABLE pHashTable,
    IN PDFS_SPECIAL_INFO SpcInfo
);

NTSTATUS
DfsFsctrlCreateSpcInfo(
    IN PSPECIAL_HASH_TABLE pHashTable,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
);

NTSTATUS
DfsFsctrlDeleteSpcInfo(
    IN PSPECIAL_HASH_TABLE pHashTable,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
);

VOID
DfsSpcInfoFindOpen(
    IN PSPECIAL_HASH_TABLE pHashTable
);

PDFS_SPECIAL_INFO
DfsSpcInfoFindFirst(
    IN PSPECIAL_HASH_TABLE pHashTable
);

PDFS_SPECIAL_INFO
DfsSpcInfoFindNext(
    IN PSPECIAL_HASH_TABLE pHashTable,
    IN PDFS_SPECIAL_INFO pSpcInfo
);

VOID
DfsSpcInfoFindClose(
    IN PSPECIAL_HASH_TABLE pHashTable
);

VOID
DfsDeleteSpcInfo(
    IN PSPECIAL_HASH_TABLE pHashTable,
    IN PDFS_SPECIAL_INFO pSpcInfo
);

NTSTATUS
DfsFsctrlGetDomainToRefresh(
    PIRP Irp,
    PVOID OutputBuffer,
    ULONG OutputBufferLength);

#endif  // __SPECIALSUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\spcsup.c ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1998, Microsoft Corporation.
//
//  File:       spcsup.c
//
//  Contents:   Support routines for managing DFS_SPECIAL_INFO entries
//
//              DfsInitSpcInfoHashTable - Initialize a DFS_SPECIAL_HASH table
//              DfsLookupSpcInfo - Lookup a DFS_SPECIAL_INFO
//              DfsAllocateSpcInfo - Allocate a DFS_SPECIAL_INFO
//              DfsInsertSpcInfo - Put a DFS_SPECIAL_INFO into the table
//              DfsDeleteSpcInfo - Remove a DFS_SPECIAL_INFO from the table
//              DfsReleaseSpcInfo - Stop using a DFS_SPECIAL_INFO
//
//              DfsFsctrlCreateSpcInfo - Load a special table entry
//              DfsFsctrlDeleteSpcInfo - Remove a special table entry
//
//--------------------------------------------------------------------------

#include "dfsprocs.h"
#include "attach.h"
#include "spcsup.h"
#include "fsctrl.h"
#include "dfssrv.h"

#define Dbg     0x4000

#define DEFAULT_HASH_SIZE       16  // default size of hash table

NTSTATUS
DfsAllocateSpcInfo(
    IN  PUNICODE_STRING pSpecialName,
    IN  ULONG TypeFlags,
    IN  ULONG TrustDirection,
    IN  ULONG TrustType,
    IN  ULONG TimeToLive,
    IN  LONG NameCount,
    IN  PUNICODE_STRING pNames,
    OUT PDFS_SPECIAL_INFO *ppSpcInfo
);

VOID
DfsInsertSpcInfo(
    IN PSPECIAL_HASH_TABLE pHashTable,
    IN PUNICODE_STRING pSpecialName,
    IN ULONG Timeout,
    IN PDFS_SPECIAL_INFO pSpcInfo
);

ULONG
DfsHashSpcName(
    IN PUNICODE_STRING SpecialName,
    IN DWORD HashMask
);

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DfsInitSpcHashTable)
#pragma alloc_text(PAGE, DfsUninitSpcHashTable)
#pragma alloc_text(PAGE, DfsAllocateSpcInfo)
#pragma alloc_text(PAGE, DfsReleaseSpcInfo)
#pragma alloc_text(PAGE, DfsHashSpcName)
#pragma alloc_text(PAGE, DfsFsctrlCreateSpcInfo)
#pragma alloc_text(PAGE, DfsFsctrlDeleteSpcInfo)
#pragma alloc_text(PAGE, DfsLookupSpcInfo)
#pragma alloc_text(PAGE, DfsInsertSpcInfo)
#pragma alloc_text(PAGE, DfsDeleteSpcInfo)

#endif

#ifdef DBG
VOID
DfsDumpSpcTable(
    PSPECIAL_HASH_TABLE pHashTable
);
#endif

//+-------------------------------------------------------------------------
//
//  Function:   DfsInitSpcHashTable - Initialize the DFS_SPECIAL_INFO lookup hash table
//
//  Synopsis:   This function initializes data structures which are
//              used for looking up a DFS_SPECIAL_INFO.
//
//  Arguments:  [cHash] -- Size of the hash table to be allocated.  Must be
//                         a power of two.  If zero, a default size is used.
//
//  Returns:    NTSTATUS -- STATUS_SUCCESS, unless memory allocation
//                          fails.
//
//  Note:       The hash buckets are initialized to zero, then later
//              initialized to a list head when used.  This is a debugging
//              aid to determine if some hash buckets are never used.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsInitSpcHashTable(
    PSPECIAL_HASH_TABLE *ppHashTable,
    ULONG cHash)
{
    PSPECIAL_HASH_TABLE pHashTable;
    ULONG cbHashTable;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    if (cHash == 0) {
        cHash = DEFAULT_HASH_SIZE;
    }

    ASSERT ((cHash & (cHash-1)) == 0);  // Assure cHash is a power of two

    cbHashTable = sizeof(SPECIAL_HASH_TABLE) + (cHash-1) * sizeof(LIST_ENTRY);
    pHashTable = ExAllocatePoolWithTag(NonPagedPool, cbHashTable, ' sfD');

    if (pHashTable == NULL) {

        NtStatus = STATUS_NO_MEMORY;

    }

    if (NT_SUCCESS(NtStatus)) {

        pHashTable->NodeTypeCode = DFS_NTC_SPECIAL_HASH;
        pHashTable->NodeByteSize = (NODE_BYTE_SIZE) cbHashTable;

        pHashTable->HashMask = (cHash-1);
        pHashTable->SpcTimeout = 0;
        ExInitializeFastMutex( &pHashTable->HashListMutex );
        RtlZeroMemory(&pHashTable->HashBuckets[0], cHash * sizeof(LIST_ENTRY));

        *ppHashTable = pHashTable;

    }

    return NtStatus;
}

VOID
DfsUninitSpcHashTable (
    PSPECIAL_HASH_TABLE pHashTable
    )
{
    ExFreePool (pHashTable);
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsLookupSpcInfo - Lookup a DFS_SPECIAL_INFO in the hash table
//
//  Synopsis:   This function will lookup a DFS_SPECIAL_INFO.
//              It will increment the UseCount on the DFS_SPECIAL_INFO.
//
//  Arguments:  [SpecialName] -- SpecialName for which the DFS_SPECIAL_INFO is
//                               being looked up.
//
//  Returns:    pointer to the DFS_SPECIAL_INFO found, or NULL if none
//
//  Algorithm:  Knuth would call it hashing with conflict resoulution
//              by chaining.
//
//--------------------------------------------------------------------------


PDFS_SPECIAL_INFO
DfsLookupSpcInfo(
    PSPECIAL_HASH_TABLE pHashTable,
    PUNICODE_STRING SpecialName)
{
    PLIST_ENTRY pListHead, pLink;
    PDFS_SPECIAL_INFO pSpcInfo;

    ExAcquireFastMutex( &pHashTable->HashListMutex );
    pListHead = &pHashTable->HashBuckets[ DfsHashSpcName(SpecialName, pHashTable->HashMask) ];

    if ((pListHead->Flink == NULL) ||           // list not initialized
        (pListHead->Flink == pListHead)) {      // list empty
        ExReleaseFastMutex( &pHashTable->HashListMutex );
        return NULL;
    }

    for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
        pSpcInfo = CONTAINING_RECORD(pLink, DFS_SPECIAL_INFO, HashChain);
        if (RtlCompareUnicodeString(&pSpcInfo->SpecialName,SpecialName,TRUE) == 0) {
            pSpcInfo->UseCount++;
            ExReleaseFastMutex( &pHashTable->HashListMutex );
            return pSpcInfo;
        }
    }
    ExReleaseFastMutex( &pHashTable->HashListMutex );
    return NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsInsertSpcInfo - Inserts a DFS_SPECIAL_INFO into the hash table
//
//  Synopsis:   This function associates a DFS_SPECIAL_INFO to a SpecialName.  This
//              involves removing any existing entry, and adding the new.
//
//  Arguments:  [pSpcInfo] -- Pointer to the DFS_SPECIAL_INFO to be inserted.
//              [Timeout] -- Timeout, in seconds, to put on the special info table
//              [pSpecialName] -- Pointer to the corresponding SpecialName name, used
//                              as the hash key.
//
//  Returns:    -nothing-
//
//--------------------------------------------------------------------------

VOID
DfsInsertSpcInfo(
    PSPECIAL_HASH_TABLE pHashTable,
    PUNICODE_STRING pSpecialName,
    ULONG Timeout,
    PDFS_SPECIAL_INFO pSpcInfo)
{
    PLIST_ENTRY pListHead;
    PDFS_SPECIAL_INFO pExistingSpcInfo;

    pExistingSpcInfo = DfsLookupSpcInfo(
                            pHashTable,
                            &pSpcInfo->SpecialName);

    //
    // Put the new one in
    //

    ExAcquireFastMutex( &pHashTable->HashListMutex );

    pListHead = &pHashTable->HashBuckets[ DfsHashSpcName(pSpecialName, pHashTable->HashMask) ];

    if (pListHead->Flink == NULL) {
        InitializeListHead(pListHead);
    }
    InsertHeadList(pListHead, &pSpcInfo->HashChain);
    //
    // Set timeout to give to clients (global timeout)
    //
    pHashTable->SpcTimeout = Timeout;
    ExReleaseFastMutex( &pHashTable->HashListMutex );

    if (pExistingSpcInfo != NULL) {

        DfsDeleteSpcInfo(
            pHashTable,
            pExistingSpcInfo);

        DfsReleaseSpcInfo(
            pHashTable,
            pExistingSpcInfo);

    }

    DebugTrace(0, Dbg, "Added SpcInfo %08lx ", pSpcInfo);
    DebugTrace(0, Dbg, "For SpecialName %wZ ", pSpecialName);

}


//+-------------------------------------------------------------------------
//
//  Function:   DfsDeleteSpcInfo - Delete a DFS_SPECIAL_INFO from the lookup hash table
//
//  Synopsis:   This function Deletes a DFS_SPECIAL_INFO from the hash table.
//
//  Arguments:  [pSpcInfo] -- Pointer to the DFS_SPECIAL_INFO to delete
//
//  Returns:    -nothing-
//
//--------------------------------------------------------------------------

VOID
DfsDeleteSpcInfo(
    PSPECIAL_HASH_TABLE pHashTable,
    PDFS_SPECIAL_INFO pSpcInfo)
{
    ExAcquireFastMutex( &pHashTable->HashListMutex);
    pSpcInfo->Flags |= SPECIAL_INFO_DELETE_PENDING;
    RemoveEntryList(&pSpcInfo->HashChain);

    //
    // This InitializeListHead is to prevent two simultaneous deleters
    //  from corrupting memory
    //
    InitializeListHead( &pSpcInfo->HashChain );

    ExReleaseFastMutex( &pHashTable->HashListMutex );

    DebugTrace(0, Dbg, "deleted SpcInfo %08lx ", pSpcInfo);
    DebugTrace(0, Dbg, "For SpecialName %wZ ", &pSpcInfo->SpecialName);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsAllocateSpcInfo - Allocate a DFS_SPECIAL_INFO
//
//  Synopsis:   This function allocates a contiguous DFS_SPECIAL_INFO struct.  The
//              strings are stored in the allocated buffer after the DFS_SPECIAL_INFO
//              structure.
//
//  Arguments:  [pSpecialName] -- The SpecialName name for the spc list
//              [TypeFlags]  -- Indicates PRIMARY/SECONDARY and NETBIOS/DNS
//              [TimeToLive]  -- Time, in seconds, for this entry to live
//              [NameCount] -- Number of names
//              [pNames] -- pointer to array (of size NameCount) of names
//              [ppSpcInfo] -- On successful return, has pointer to newly allocated
//                      DFS_SPECIAL_INFO.
//
//  Returns:    [STATUS_SUCCESS] -- Successfully allocated DFS_SPECIAL_INFO
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory condition
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsAllocateSpcInfo(
    PUNICODE_STRING pSpecialName,
    ULONG TypeFlags,
    ULONG TrustDirection,
    ULONG TrustType,
    ULONG TimeToLive,
    LONG NameCount,
    PUNICODE_STRING pNames,
    PDFS_SPECIAL_INFO *ppSpcInfo)
{
    NTSTATUS status;
    PDFS_SPECIAL_INFO pSpcInfo;
    ULONG Size;
    LONG i;
    LPWSTR pwCh;
    PUNICODE_STRING pustr;
    LARGE_INTEGER now;

    DebugTrace(0, Dbg, "DfsAllocateSpcInfo(%wZ)\n", pSpecialName);

    //
    // Size the buffer - include storage for the unicode strings after the
    // DFS_SPECIAL_INFO structure.
    //

    Size = sizeof(DFS_SPECIAL_INFO) +
             pSpecialName->Length;

    if (NameCount > 1) {

        Size += (sizeof(UNICODE_STRING) * (NameCount - 1));

    }

    for (i = 0; i < NameCount; i++) {

        Size += pNames[i].Length;

    }

    pSpcInfo = (PDFS_SPECIAL_INFO) ExAllocatePoolWithTag( NonPagedPool, Size, ' sfD' );

    if (pSpcInfo != NULL) {

        RtlZeroMemory( pSpcInfo, Size );

        pSpcInfo->NodeTypeCode = DFS_NTC_SPECIAL_INFO;
        pSpcInfo->NodeByteSize = (USHORT)Size;

        pwCh = (LPWSTR) &pSpcInfo->Name[NameCount < 0 ? 0 : NameCount];

        pustr = &pSpcInfo->SpecialName;
        pustr->Length = pustr->MaximumLength = pSpecialName->Length;
        pustr->Buffer = pwCh;
        RtlCopyMemory(pwCh, pSpecialName->Buffer, pSpecialName->Length);
        pwCh += pustr->Length / sizeof(WCHAR);

	if (pustr->Length > ((MAX_SPCNAME_LEN - 1) * sizeof(WCHAR))) {
           pSpcInfo->Flags |= SPECIAL_INFO_IS_LONG_NAME;
	}

        KeQuerySystemTime(&now);
        pSpcInfo->NameCount = NameCount;
        pSpcInfo->TypeFlags = TypeFlags;
        pSpcInfo->TrustDirection = TrustDirection;
        pSpcInfo->TrustType = TrustType;
        pSpcInfo->ExpireTime.QuadPart = now.QuadPart + UInt32x32To64(
                                                           TimeToLive,
                                                           10 * 1000 * 1000);

        for (i = 0; i < NameCount; i++) {

            pustr = &pSpcInfo->Name[i];
            pustr->Length = pustr->MaximumLength = pNames[i].Length;
            pustr->Buffer = pwCh;
            RtlCopyMemory(pwCh, pNames[i].Buffer, pNames[i].Length);
            pwCh += pustr->Length / sizeof(WCHAR);

        }

        *ppSpcInfo = pSpcInfo;

        status = STATUS_SUCCESS;

        DebugTrace(0, Dbg, "DfsAllocateSpcInfo pSpcInfo = %d\n", pSpcInfo);

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;

    }

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsReleaseSpcInfo
//
//  Synopsis:   Decrements UseCount of and possibly frees a DFS_SPECIAL_INFO
//
//  Arguments:  [pSpcInfo] -- The DFS_SPECIAL_INFO to release
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsReleaseSpcInfo(
    PSPECIAL_HASH_TABLE pHashTable,
    PDFS_SPECIAL_INFO pSpcInfo)
{
    //
    // There's a potential race with DfsDeleteSpcInfo's setting of the
    // DELETE_PENDING and the test below of DELETE_PENDING, so we still have
    // to acquire the lock to safely test the DELETE_PENDING bit.
    //

    ExAcquireFastMutex( &pHashTable->HashListMutex );

    pSpcInfo->UseCount--;

    if ((pSpcInfo->Flags & SPECIAL_INFO_DELETE_PENDING) != 0 && pSpcInfo->UseCount == 0) {

        ExFreePool(pSpcInfo);

    }

    ExReleaseFastMutex( &pHashTable->HashListMutex );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsSpcInfoFindOpen
//
//  Synopsis:   Notifies the table that the first/next calls are about to start
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

VOID
DfsSpcInfoFindOpen(
    PSPECIAL_HASH_TABLE pHashTable)
{
    ExAcquireFastMutex( &pHashTable->HashListMutex );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsSpcInfoFindFirst
//
//  Synopsis:   Gets the first entry in the Special table.
//
//  Arguments:  None.
//
//  Returns:    [pSpcInfo] -- The first entry in the table.
//
//-----------------------------------------------------------------------------

PDFS_SPECIAL_INFO
DfsSpcInfoFindFirst(
    PSPECIAL_HASH_TABLE pHashTable)
{
    PLIST_ENTRY pListHead, pLink;
    PDFS_SPECIAL_INFO pSpcInfo;
    ULONG i, j;

    for (i = 0; i <= pHashTable->HashMask; i++) {

        pListHead = &pHashTable->HashBuckets[i];

        if ((pListHead->Flink == NULL) ||           // list not initialized
            (pListHead->Flink == pListHead)) {      // list empty
            continue;
        }
        pLink = pListHead->Flink;
        pSpcInfo = CONTAINING_RECORD(pLink, DFS_SPECIAL_INFO, HashChain);
        return pSpcInfo;
    }

    //
    // Table is empty.  Return NULL
    //

    return NULL;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsSpcInfoFindNext
//
//  Synopsis:   Gets the next entry in the Special table.
//
//  Arguments:  [pSpcInfo] -- The current DFS_SPECIAL_INFO entry.
//
//  Returns:    [pSpcInfo] -- The next DFS_SPECIAL_INFO entry in the table.
//              NULL - No more entries
//
//-----------------------------------------------------------------------------

PDFS_SPECIAL_INFO
DfsSpcInfoFindNext(
    PSPECIAL_HASH_TABLE pHashTable,
    PDFS_SPECIAL_INFO pSpcInfo)
{
    PLIST_ENTRY pListHead, pLink;
    ULONG i, j;

    //
    // Point to the next entry.  It might be a hash chain head!!!
    //

    pLink = pSpcInfo->HashChain.Flink;

    //
    // See if we're pointing to the head
    //

    for (i = 0; i <= pHashTable->HashMask; i++) {

        if (pLink == &pHashTable->HashBuckets[i]) {
            //
            // We're in hash chain i, and we hit the end.
            // Go to the next chain.
            //
            for (j = i+1; j <= pHashTable->HashMask; j++) {

                pListHead = &pHashTable->HashBuckets[j];

                if ((pListHead->Flink == NULL) ||           // list not initialized
                    (pListHead->Flink == pListHead)) {      // list empty
                    continue;
                }
                //
                // We found another hash chain.  Point to the 1st entry
                //
                pLink = pListHead->Flink;
                pSpcInfo = CONTAINING_RECORD(pLink, DFS_SPECIAL_INFO, HashChain);
                return pSpcInfo;
            }
            //
            // We got to the end without finding any more entries.
            //
            return NULL;
        }

    }

    //
    // Still in the same hash chain, and there's an entry after this one
    //

    pSpcInfo = CONTAINING_RECORD(pLink, DFS_SPECIAL_INFO, HashChain);
    return pSpcInfo;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsSpcInfoFindClose
//
//  Synopsis:   Notifies the table that the first/next calls are complete.
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

VOID
DfsSpcInfoFindClose(
    PSPECIAL_HASH_TABLE pHashTable)
{
    ExReleaseFastMutex( &pHashTable->HashListMutex );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsHashSpcNames
//
//  Synopsis:   Generates a hash 0-N - ignores case
//
//  Arguments:  [pSpecialName] -- The SpecialName name to hash
//
//  Returns:    Nothing
//
//  Notes: Might need to convert DNS-style names to short names (??)
//
//-----------------------------------------------------------------------------

ULONG
DfsHashSpcName(
    PUNICODE_STRING SpecialName,
    DWORD HashMask)
{
    ULONG BucketNo = 0;
    WCHAR *pBuffer = SpecialName->Buffer;
    WCHAR *pBufferEnd = &pBuffer[SpecialName->Length / sizeof(WCHAR)];
    ULONG wCh;

    BucketNo = 0;

    while (pBuffer != pBufferEnd) {

        wCh = (*pBuffer < L'a')
                 ? *pBuffer
                 : ((*pBuffer < L'z')
                     ? (*pBuffer - L'a' + L'A')
                     : RtlUpcaseUnicodeChar(*pBuffer));
        BucketNo *= 131;
        BucketNo += wCh;
        pBuffer++;

    }

    BucketNo = BucketNo & HashMask;
    return BucketNo;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctrlCreateSpcInfo, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

NTSTATUS
DfsFsctrlCreateSpcInfo(
    PSPECIAL_HASH_TABLE pHashTable,
    PIRP Irp,
    PVOID InputBuffer,
    ULONG InputBufferLength)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_CREATE_SPECIAL_INFO_ARG arg;
    PDFS_SPECIAL_INFO pSpcInfo;
    PDFS_SPECIAL_INFO pExistingSpcInfo = NULL;
    LONG i;
    ULONG Size;

    STD_FSCTRL_PROLOGUE(DfsFsctrlCreateSpcInfo, TRUE, FALSE);

    //
    // Namecount can be -1 as a special case (names need to be expanded)
    //
    arg = (PDFS_CREATE_SPECIAL_INFO_ARG) InputBuffer;

    if (InputBufferLength < sizeof(DFS_CREATE_SPECIAL_INFO_ARG) ||
        arg->NameCount < -1 ) {

        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    //
    // unmarshal the arguments...
    //
    Size = InputBufferLength - FIELD_OFFSET(DFS_CREATE_SPECIAL_INFO_ARG, Name);

    OFFSET_TO_POINTER(arg->SpecialName.Buffer, arg);

    if (!UNICODESTRING_IS_VALID(arg->SpecialName, InputBuffer, InputBufferLength)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    for (i = 0; i < arg->NameCount; i++) {

        //
        // Make sure we haven't overrun the buffer supplied!
        //
        if( (PBYTE)(&arg->Name[i]) + sizeof(arg->Name[i]) >
            (PBYTE)InputBuffer + InputBufferLength ) {

            status = STATUS_INVALID_PARAMETER;
            goto exit_with_status;
        }

        OFFSET_TO_POINTER(arg->Name[i].Buffer, arg);
        if (!UNICODESTRING_IS_VALID(arg->Name[i], InputBuffer, InputBufferLength)) {
            status = STATUS_INVALID_PARAMETER;
            goto exit_with_status;
        }
    }

    status = DfsAllocateSpcInfo(
                &arg->SpecialName,
                arg->Flags,
                arg->TrustDirection,
                arg->TrustType,
                arg->Timeout,
                arg->NameCount,
                &arg->Name[0],
                &pSpcInfo);


    if (NT_SUCCESS(status)) {

        if (pSpcInfo->NameCount >= 0) {

            DfsInsertSpcInfo(
                pHashTable,
                &arg->SpecialName,
                arg->Timeout,
                pSpcInfo);

        } else {

            pExistingSpcInfo = DfsLookupSpcInfo(
                                pHashTable,
                                &pSpcInfo->SpecialName);

            if (pExistingSpcInfo == NULL) {

                DfsInsertSpcInfo(
                    pHashTable,
                    &arg->SpecialName,
                    arg->Timeout,
                    pSpcInfo);

            } else {

                pHashTable->SpcTimeout = arg->Timeout;
                pExistingSpcInfo->ExpireTime.QuadPart = 0;
                DfsReleaseSpcInfo(pHashTable, pExistingSpcInfo);
                ExFreePool(pSpcInfo);

            }

       }

    }

exit_with_status:

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg,
        "DfsFsctrlCreateSpcInfo: Exit -> %08lx\n", ULongToPtr( status ) );

    return status;

}

//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctrlDeleteSpcInfo, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Notes:      We only process this FSCTRL from the file system process,
//              never from the driver.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsFsctrlDeleteSpcInfo(
    PSPECIAL_HASH_TABLE pHashTable,
    PIRP Irp,
    PVOID InputBuffer,
    ULONG InputBufferLength)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_DELETE_SPECIAL_INFO_ARG arg;
    PDFS_SPECIAL_INFO pSpcInfo;

    STD_FSCTRL_PROLOGUE(DfsFsctrlDeleteSpcInfo, TRUE, FALSE);

    if (InputBufferLength < sizeof(DFS_DELETE_SPECIAL_INFO_ARG)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    //
    // unmarshal the arguments...
    //

    arg = (PDFS_DELETE_SPECIAL_INFO_ARG) InputBuffer;

    OFFSET_TO_POINTER(arg->SpecialName.Buffer, arg);

    if (!UNICODESTRING_IS_VALID(arg->SpecialName, InputBuffer, InputBufferLength)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    pSpcInfo = DfsLookupSpcInfo(
                    pHashTable,
                    &arg->SpecialName);

    //
    // The DfsLookupSpcInfo() call bumped the usecount, so we're sure pSpcInfo
    // won't become invalid as we're using it.
    //

    if (pSpcInfo != NULL) {

        //
        // Removes from the table, but doesn't free the memory
        //
        DfsDeleteSpcInfo(
            pHashTable,
            pSpcInfo);

        //
        // This will decrement the usecount, and if it goes to zero, frees the memory
        //
        DfsReleaseSpcInfo(
            pHashTable,
            pSpcInfo);

    }

exit_with_status:

    DfsCompleteRequest( Irp, status );

    DebugTrace(-1, Dbg,
        "DfsFsctrlDeleteSpcInfo: Exit -> %08lx\n", ULongToPtr( status ));

    return status;

}

#ifdef DBG

VOID
DfsDumpSpcTable(
    PSPECIAL_HASH_TABLE pHashTable)
{
    PLIST_ENTRY pListHead, pLink;
    PDFS_SPECIAL_INFO pSpcInfo;
    LONG i, j;

    DbgPrint("---------Spc Table----------\n");

    DbgPrint("\tTimeout=0x%x(%d)\n", pHashTable->SpcTimeout);

    DfsSpcInfoFindOpen(pHashTable);
    for (pSpcInfo = DfsSpcInfoFindFirst(pHashTable);
            pSpcInfo != NULL;
                pSpcInfo = DfsSpcInfoFindNext(pHashTable,pSpcInfo)) {
        DbgPrint("\t[%wZ][%d]", &pSpcInfo->SpecialName, pSpcInfo->NameCount);
        for (j = 0; j < pSpcInfo->NameCount; j++) {
            DbgPrint("(%wZ)", &pSpcInfo->Name[j]);
        }
        DbgPrint("\n");
    }
    DfsSpcInfoFindClose(pHashTable);


    DbgPrint("-----------------------------\n");
}

#endif


NTSTATUS
DfsFsctrlGetDomainToRefresh(
    PIRP Irp,
    PVOID OutputBuffer,
    ULONG OutputBufferLength)
{
    LPWSTR Buffer;
    BOOLEAN Found = FALSE;
    PSPECIAL_HASH_TABLE pHashTable;
    ULONG i;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PLIST_ENTRY pListHead, pLink;
    PDFS_SPECIAL_INFO pSpcInfo;
    PUNICODE_STRING pustr;

    pHashTable = DfsData.SpcHashTable;

    ExAcquireFastMutex( &pHashTable->HashListMutex );

    for (i = 0; (i <= pHashTable->HashMask) && (Found == FALSE); i++) {

        pListHead = &pHashTable->HashBuckets[i];

        if ((pListHead->Flink == NULL) ||           // list not initialized
            (pListHead->Flink == pListHead)) {      // list empty
            continue;
        }
        for(pLink = pListHead->Flink;
	    (pLink) && (Found == FALSE);
            pLink = pSpcInfo->HashChain.Flink) {
	     
            if (pLink == pListHead) {
                break;
            }
            pSpcInfo = CONTAINING_RECORD(pLink, DFS_SPECIAL_INFO, HashChain);
	
            if (pSpcInfo->Flags & SPECIAL_INFO_NEEDS_REFRESH) {
                pSpcInfo->Flags &= ~SPECIAL_INFO_NEEDS_REFRESH;
		
                pustr = &pSpcInfo->SpecialName;
                if (pustr->Length < (OutputBufferLength - sizeof(WCHAR))) {
                    RtlCopyMemory(OutputBuffer, pustr->Buffer, pustr->Length);
                    Buffer = OutputBuffer;
                    Buffer += (pustr->Length / sizeof(WCHAR));
                    *Buffer = UNICODE_NULL;

                    Irp->IoStatus.Information = pustr->Length + sizeof(WCHAR);

                    Status = STATUS_SUCCESS;
		    Found = TRUE;
                    break;
                }
	    }
	}
    }
    ExReleaseFastMutex( &pHashTable->HashListMutex );

    DfsCompleteRequest( Irp, Status );
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\h\dfshr.h ===
//-------------------------------------------------------------------------
//
// File:        dfshr.h
//
// Contents:    This file has all the user mode SCODES to be used in HResults.
//
// History:     05-11-93        SudK    Created.
//
//-------------------------------------------------------------------------
#if 0
#include <scode.h>

#ifndef __DFSHR_H__
#define __DFSHR_H__

//
//  Macros to create DFS NTSTATUS values at various severity levels
//

#ifndef FACILITY_DFS

//
//  The following are taken from the (obsolescent) scode.h.
//
#define FACILITY_CAIRO_BASE     0x100
#define FACILITY_DFS                     (FACILITY_CAIRO_BASE + 25)
#endif  // FACILITY_DFS

#define MAKE_DFS_STATUS(s,e)    (((s)<<30) | (FACILITY_DFS<<16) | (e))

#define MAKE_DFS_S_STATUS(e)    MAKE_DFS_STATUS(STATUS_SEVERITY_SUCCESS, e)
#define MAKE_DFS_E_STATUS(e)    MAKE_DFS_STATUS(STATUS_SEVERITY_ERROR,   e)
#define MAKE_DFS_W_STATUS(e)    MAKE_DFS_STATUS(STATUS_SEVERITY_WARNING, e)
#define MAKE_DFS_I_STATUS(e)    MAKE_DFS_STATUS(STATUS_SEVERITY_INFORMAITON, e)



//
//  Below are definitions of SCODEs returned by DFS user level
//  API components.
//

#define MAKE_DFS_SCODE(s,e)     HR_MAKE_SCODE((s), (e))

#define MAKE_DFS_S_SCODE(e)     MAKE_DFS_SCODE(SEVERITY_SUCCESS, e)
#define MAKE_DFS_E_SCODE(e)     MAKE_DFS_SCODE(SEVERITY_ERROR,   e)

//
//  Add SeverityLevel ERROR SCODEs here.
//  Choose sequence numbers from the bottom.
//
#define DFS_E_VOLUME_OBJECT_CORRUPT             MAKE_DFS_E_SCODE(1)
#define DFS_E_SERVICE_ALREADY_EXISTS            MAKE_DFS_E_SCODE(2)
#define DFS_E_SERVICE_OBJECT_CORRUPT            MAKE_DFS_E_SCODE(3)
#define DFS_E_INCONSISTENT                      MAKE_DFS_E_SCODE(4)
#define DFS_E_INVALID_ARGUMENT                  MAKE_DFS_E_SCODE(5)
#define DFS_E_INVALID_STORAGE_ID                MAKE_DFS_E_SCODE(6)
#define DFS_E_INVALID_SERVICE_NAME              MAKE_DFS_E_SCODE(7)
#define DFS_E_NO_SUCH_SERVICE_NAME              MAKE_DFS_E_SCODE(8)
#define DFS_E_NOT_CHILD_VOLUME                  MAKE_DFS_E_SCODE(9)
#define DFS_E_SERVICE_NOT_COOPERATING           MAKE_DFS_E_SCODE(10)
#define DFS_E_BAD_VOLUME_OBJECT_NAME            MAKE_DFS_E_SCODE(11)
#define DFS_E_BAD_ENTRY_PATH                    MAKE_DFS_E_SCODE(12)
#define DFS_E_NOTYET_INITIALISED                MAKE_DFS_E_SCODE(13)
#define DFS_E_SERVICE_NOT_FOUND                 MAKE_DFS_E_SCODE(14)
#define DFS_E_VOLUME_OBJECT_OFFLINE             MAKE_DFS_E_SCODE(15)
#define DFS_E_BAD_COMMAND                       MAKE_DFS_E_SCODE(16)
#define DFS_E_NOT_SUPPORTED                     MAKE_DFS_E_SCODE(17)
#define DFS_E_LEAF_VOLUME                       MAKE_DFS_E_SCODE(18)
#define DFS_E_MORE_THAN_ONE_SERVICE_EXISTS      MAKE_DFS_E_SCODE(19)
#define DFS_E_CANT_CREATE_EXITPOINT             MAKE_DFS_E_SCODE(20)
#define DFS_E_UNKNOWN                           MAKE_DFS_E_SCODE(21)
#define DFS_E_INVALID_SERVICE_TYPE              MAKE_DFS_E_SCODE(22)
#define DFS_E_VOLUME_OBJECT_UNAVAILABLE         MAKE_DFS_E_SCODE(23)
#define DFS_E_INVALID_VOLUME_TYPE               MAKE_DFS_E_SCODE(24)
#define DFS_E_NOTYET_IMPLEMENTED                MAKE_DFS_E_SCODE(25)
#define DFS_E_ONE_SERVICE_ONLY_ALLOWED          MAKE_DFS_E_SCODE(27)
#define DFS_E_NOT_AGGREGATABLE                  MAKE_DFS_E_SCODE(28)
#define DFS_E_NOT_DC                            MAKE_DFS_E_SCODE(29)
#define DFS_E_NO_DC_IN_DOMAIN                   MAKE_DFS_E_SCODE(30)


//
// The SUCCESS SCODEs that DFS can return. Choose sequence numbers in order.
//
#define DFS_S_SUCCESS                           MAKE_DFS_S_SCODE(100)
#define DFS_S_INCONSISTENT                      MAKE_DFS_S_SCODE(101)


//
// The following error codes are there for Compatibility purposes alone.
// The should go away and be redefined with new DFS error code names. 
//

#define INVALID_PARTITION_NAME                  MAKE_DFS_E_SCODE(51)
#define CONTAINER_INTERFACE_NOT_SUPPORTED       MAKE_DFS_E_SCODE(52)
#define INSUFFICIENT_MEMORY                     MAKE_DFS_E_SCODE(53)
#define COULDNT_SET_PROPERTY                    MAKE_DFS_E_SCODE(54)
#define CANNOT_DELETE_PARTITION                 MAKE_DFS_E_SCODE(55)
#define INVALID_ENTRY_PATH                      MAKE_DFS_E_SCODE(56)
#define INVALID_SERVICE_NAME                    MAKE_DFS_E_SCODE(57)
#define INVALID_PARTITION_INFO                  MAKE_DFS_E_SCODE(58)



#define DFSM_STATUS_SERVICE_ENTRY_NOT_FOUND     MAKE_DFS_E_SCODE(59)
#define DFSM_STATUS_NO_MORE_SERVICES            MAKE_DFS_E_SCODE(60)
#define DFSM_STATUS_BAD_PROPERTY_READ           MAKE_DFS_E_SCODE(61)
#define DFSM_STATUS_NO_DEVICE_OBJECT            MAKE_DFS_E_SCODE(62)
#define DFSM_STATUS_BAD_COMMAND                 MAKE_DFS_E_SCODE(63)
#define DFSM_STATUS_NOT_SUPPORTED               MAKE_DFS_E_SCODE(64)

#define DFS_E_NOSUCH_LOCAL_VOLUME       MAKE_DFS_E_STATUS(65)
#define DFS_E_BAD_EXIT_POINT            MAKE_DFS_E_STATUS(66)

#endif  // __DFSHR_H__
#endif // #if 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\h\dfserr.h ===
//-------------------------------------------------------------------------
//
// File:        dfserr.h
//
// Contents:    This file has all the DFS driver error codes defined.
//              This includes only NTSTATUS codes returned from the
//              DFS driver.  For user-level HRESULTs, see oleerror.mc.
//
// History:     04-Feb-93       SudK    Created.
//              23 Sep 93       Alanw   Cleaned up, changed naming
//                                      convention to be DFS_STATUS_xxx
//
//  NOTES:       these error codes may need to be moved into
//                      ntstatus.mc.
//
//-------------------------------------------------------------------------

#ifndef _DFSERR_H_
#define _DFSERR_H_

//
//  The following are errror status codes which can be returned by the
//  DFS driver.
//

#define DFS_STATUS_NOSUCH_LOCAL_VOLUME          STATUS_OBJECT_NAME_NOT_FOUND
#define DFS_STATUS_BAD_EXIT_POINT               STATUS_OBJECT_NAME_INVALID
#define DFS_STATUS_STORAGEID_ALREADY_INUSE      STATUS_OBJECT_NAME_COLLISION
#define DFS_STATUS_BAD_STORAGEID                STATUS_OBJECT_PATH_INVALID

//
//  Defines for PKT specific errors
//

#define DFS_STATUS_ENTRY_EXISTS             STATUS_OBJECT_NAME_COLLISION
#define DFS_STATUS_NO_SUCH_ENTRY            STATUS_OBJECT_NAME_NOT_FOUND
#define DFS_STATUS_NO_DOMAIN_SERVICE        STATUS_CANT_ACCESS_DOMAIN_INFO
#define DFS_STATUS_LOCAL_ENTRY              STATUS_CANNOT_DELETE
#define DFS_STATUS_INCONSISTENT             STATUS_INTERNAL_DB_CORRUPTION
#define DFS_STATUS_RESYNC_INFO              STATUS_MEDIA_CHECK

#endif  // _DFSERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\driver\srv.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       srv.c
//
//  Contents:   Support for interacting with the SMB server.
//
//  Classes:    None
//
//  Functions:  DfsSrvFsctrl
//              DfsFsctrlTranslatePath
//              DfsFsctrlGetReferrals
//              DfsFsctrlIsShareInDfs
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "srv.h"

#include "smbtypes.h"
#include "smbtrans.h"

#include "know.h"
#include "ftdfs.h"

#include "sitesup.h"
#include "ipsup.h"
#include "spcsup.h"
#include "dfslpc.h"
#include "fsctrl.h"
#include "dfswml.h"

#include <ntlsa.h>

#include <netevent.h>

#define Dbg     DEBUG_TRACE_REFERRALS
#define MAXIMUM_DFS_REFERRALS 4096

DFS_IPADDRESS ZeroIpAddress = {0};

NTSTATUS
DfspFormPrefix(
    IN PDFS_LOCAL_VOL_ENTRY LvEntry,
    IN PUNICODE_STRING ParentPath,
    IN PUNICODE_STRING DfsPathName,
    IN OUT PUNICODE_STRING Prefix);

ULONG
DfspGetV1ReferralSize(
    IN PDFS_PKT_ENTRY PktEntry,
    IN PUNICODE_STRING MachineName);

ULONG
DfspGetV2ReferralSize(
    IN PDFS_PKT_ENTRY PktEntry,
    IN PUNICODE_STRING MachineName);

ULONG
DfspGetV3ReferralSize(
    IN PDFS_PKT_ENTRY PktEntry,
    IN PUNICODE_STRING MachineName);

VOID
DfspGetV1Referral(
    IN PDFS_PKT_ENTRY PktEntry,
    IN PUNICODE_STRING MachineName,
    OUT PRESP_GET_DFS_REFERRAL Ref);

NTSTATUS
DfspGetV2Referral(
    IN PDFS_PKT_ENTRY PktEntry,
    IN PUNICODE_STRING MachineName,
    IN ULONG BufferSize,
    OUT PRESP_GET_DFS_REFERRAL Ref,
    OUT PULONG ReferralSize);

NTSTATUS
DfspGetV3Referral(
    IN PDFS_PKT_ENTRY PktEntry,
    IN PUNICODE_STRING MachineName,
    IN PDFS_IP_INFO pIpInfo,
    IN ULONG BufferSize,
    OUT PRESP_GET_DFS_REFERRAL Ref,
    OUT PULONG ReferralSize);

NTSTATUS
DfspGetOneV3SpecialReferral(
    IN PDFS_SPECIAL_INFO pSpcInfo,
    IN PUNICODE_STRING Name,
    IN PDFS_IP_INFO pIpInfo,
    OUT PRESP_GET_DFS_REFERRAL Ref,
    IN ULONG MaximumSize,
    PULONG ReturnedSize);

NTSTATUS
DfspGetAllV3SpecialReferral(
    IN PDFS_IP_INFO pIpInfo,
    OUT PRESP_GET_DFS_REFERRAL Ref,
    IN ULONG MaximumSize,
    PULONG ReturnedSize);

NTSTATUS
DfspGetV3FtDfsReferral(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ShareName,
    IN PDFS_IP_INFO pIpInfo,
    OUT PRESP_GET_DFS_REFERRAL Ref,
    IN ULONG MaximumSize,
    PULONG ReturnedSize);

NTSTATUS
DfsFsctrlTranslatePath(
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength);

NTSTATUS
DfsFsctrlGetReferrals(
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PULONG ReturnedSize);

NTSTATUS
DfsFsctrlIsShareInDfs(
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength);

NTSTATUS
DfsFsctrlFindShare(
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength);

VOID
SrvShuffle(
    PDFS_REFERRAL_LIST pRefList,
    LONG nStart,
    LONG nEnd);

ULONG
DfsIpOrdering(
    IN PDFS_IP_INFO pIpInfo,
    IN ULONG RefCount,
    IN PDFS_REFERRAL_LIST pRefList);


PDFS_SPECIAL_INFO
DfspLookupSpcEntry(
    IN PUNICODE_STRING SpecialName);

BOOLEAN
DfspIsSpecialShare(
    PUNICODE_STRING ShareName);

#define UNICODE_STRING_STRUCT(s) \
        {sizeof(s) - sizeof(WCHAR), sizeof(s) - sizeof(WCHAR), (s)}

static UNICODE_STRING SpecialShares[] = {
    UNICODE_STRING_STRUCT(L"SYSVOL"),
    UNICODE_STRING_STRUCT(L"NETLOGON"),
    UNICODE_STRING_STRUCT(L"DEBUG")
};



#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsSrvFsctrl )
#pragma alloc_text( PAGE, DfsFsctrlTranslatePath )
#pragma alloc_text( PAGE, DfsFsctrlGetReferrals )
#pragma alloc_text( PAGE, DfsFsctrlIsShareInDfs )
#pragma alloc_text( PAGE, DfsFsctrlFindShare )
#pragma alloc_text( PAGE, DfsIpOrdering )

#pragma alloc_text( PAGE, DfspFormPrefix )
#pragma alloc_text( PAGE, DfspGetV1ReferralSize )
#pragma alloc_text( PAGE, DfspGetV2ReferralSize )
#pragma alloc_text( PAGE, DfspGetV3ReferralSize )
#pragma alloc_text( PAGE, DfspGetV1Referral )
#pragma alloc_text( PAGE, DfspGetV2Referral )
#pragma alloc_text( PAGE, DfspGetV3Referral )
#pragma alloc_text( PAGE, DfspGetAllV3SpecialReferral )
#pragma alloc_text( PAGE, DfspGetOneV3SpecialReferral )
#pragma alloc_text( PAGE, DfspLookupSpcEntry )

#endif // ALLOC_PRAGMA

//+----------------------------------------------------------------------------
//
//  Function:   DfsSrvFsctrl
//
//  Synopsis:   Process fsctrls used by the server to communicate with Dfs.
//
//  Arguments:  [IoControlCode] -- The fsctrl code.
//              [InputBuffer] -- Input buffer for fsctrl.
//              [InputBufferLength] -- Length in bytes of InputBuffer
//              [OutputBuffer] -- Output buffer for fsctrl.
//              [OutputBufferLength] -- Length in bytes of OutputBuffer
//              [IoStatus] -- place to return status of fsctrl.
//
//  Returns:    [STATUS_SUCCESS] -- Fsctrl handled successfully.
//
//              [STATUS_INVALID_DEVICE_REQUEST] -- Unrecognized fsctrl code.
//
//              Status returned by the appropriate fsctrl handler.
//
//-----------------------------------------------------------------------------

VOID DfsSrvFsctrl(
    IN ULONG IoControlCode,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus)
{

    KPROCESSOR_MODE PreviousMode;
    ULONG returnedSize = 0;

    if (IoControlCode == FSCTL_DFS_IS_ROOT) {
        if (DfsData.MachineState == DFS_ROOT_SERVER) {
            IoStatus->Status = STATUS_SUCCESS;
        } else {
            IoStatus->Status = STATUS_PATH_NOT_COVERED;
            DFS_TRACE_HIGH(ERROR, DfsSrvFsctrl_Error1, LOGSTATUS(IoStatus->Status));
        }
        return;
    } else if (IoControlCode ==  FSCTL_DFS_IS_SHARE_IN_DFS) {
        IoStatus->Status = DfsFsctrlIsShareInDfs(
                                InputBuffer,
                                InputBufferLength);
        return;
    }

    PreviousMode = ExGetPreviousMode();
    if (PreviousMode != KernelMode) {
        IoStatus->Status = STATUS_INVALID_PARAMETER;
        DFS_TRACE_HIGH(ERROR, DfsSrvFsctrl_Error2, LOGSTATUS(IoStatus->Status));
        return;
    }

    switch (IoControlCode) {
    case FSCTL_DFS_TRANSLATE_PATH:
        IoStatus->Status = DfsFsctrlTranslatePath(
                                InputBuffer,
                                InputBufferLength);
        break;

    case FSCTL_DFS_GET_REFERRALS:
        IoStatus->Status = DfsFsctrlGetReferrals(
                                InputBuffer,
                                InputBufferLength,
                                OutputBuffer,
                                OutputBufferLength,
                                &returnedSize);

        IoStatus->Information = returnedSize;

        break;

    case FSCTL_DFS_REPORT_INCONSISTENCY:
        IoStatus->Status = STATUS_SUCCESS;
        break;

    case FSCTL_DFS_FIND_SHARE:
        IoStatus->Status = DfsFsctrlFindShare(
                                InputBuffer,
                                InputBufferLength);
        break;

    default:
        IoStatus->Status = STATUS_INVALID_DEVICE_REQUEST;
        DFS_TRACE_HIGH(ERROR, DfsSrvFsctrl_Error3, LOGSTATUS(IoStatus->Status));
        break;

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlTranslatePath
//
//  Synopsis:   Given a share path of the form \??\X:\foo\bar
//              and a full-blown Dfs prefix of the form \Root\Dfs\frum\bump,
//              this routine will determine the path relative to
//              \??\X:\foo\bar that maps to \Root\Dfs\frum\bump.
//
//              In the above example, if \??\X:\foo\bar maps to
//              \Root\Dfs\frum, then this routine will return \bump.
//
//              Since this fsctrl is intended for use by the server, the
//              input parameter \Root\Dfs\frum\bump will itself be truncated
//              to indicate the relative path.
//
//  Arguments:  [InputBuffer] -- Pointer to DFS_TRANSLATE_PATH_ARG.
//
//              [InputBufferLength] -- Length in bytes of InputBuffer
//
//  Returns:    [STATUS_SUCCESS] -- Input path successfully translated.
//
//              [STATUS_PATH_NOT_COVERED] -- The input path crossed a junction
//                      point, or is not in the dfs at all.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlTranslatePath(
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength)
{
    PDFS_TRANSLATE_PATH_ARG arg = (PDFS_TRANSLATE_PATH_ARG) InputBuffer;
    PDFS_PKT pkt;
    PDFS_PKT_ENTRY pktEntry, shortPktEntry;
    PUNICODE_PREFIX_TABLE_ENTRY lvPrefix;
    PDFS_LOCAL_VOL_ENTRY lvEntry;
    UNICODE_STRING lvName;
    WCHAR nameBuffer[MAX_PATH];
    UNICODE_STRING prefix;
    UNICODE_STRING lastComponent;
    UNICODE_STRING remPath, shortRemPath;
    NTSTATUS status = STATUS_SUCCESS;

    DebugTrace(+1, Dbg, "DfsFsctrlTranslatePath entered\n", 0);

    DFS_TRACE_NORM(EVENT, DfsFsctrlTranslatePath_Start,
                   LOGSTATUS(status)
                   LOGUSTR(arg->SubDirectory)
                   LOGUSTR(arg->DfsPathName)
                   LOGUSTR(arg->ParentPathName));

    lvName = arg->SubDirectory;

    DebugTrace( 0, Dbg, "lvName=%wZ\n", &lvName);

    RtlZeroMemory( &prefix, sizeof(prefix) );

    //
    // Lookup the localVol in the local volume prefix table.
    //

    pkt = _GetPkt();

    PktAcquireExclusive( pkt, TRUE );

    lvPrefix = DfsFindUnicodePrefix(
                    &pkt->LocalVolTable,
                    &lvName,
                    &remPath);

    if (lvPrefix != NULL) {

        DebugTrace( 0, Dbg, "found lvPrefix=0x%x\n", lvPrefix);

        lvEntry = CONTAINING_RECORD(
                        lvPrefix,
                        DFS_LOCAL_VOL_ENTRY,
                        PrefixTableEntry);

        if (lvEntry->LocalPath.Length == lvName.Length) {

            DebugTrace( 0, Dbg, "found path for a local vol\n", 0);
            DebugTrace( 0, Dbg, "lvEntry->LocalPath=%wZ\n", &lvEntry->LocalPath);


            //
            // Found an exact match for a local volume. Next, we check
            // whether the Dfs path crosses an exit point.
            //

            prefix.Length = 0;
            prefix.MaximumLength = sizeof( nameBuffer );
            prefix.Buffer = nameBuffer;

            status = DfspFormPrefix(
                        lvEntry,
                        &arg->ParentPathName,
                        &arg->DfsPathName,
                        &prefix);

            if (arg->Flags & DFS_TRANSLATE_STRIP_LAST_COMPONENT) {

                DebugTrace( 0, Dbg, "prefix=%wZ\n", &prefix);

                lastComponent = prefix;

                RemoveLastComponent( &lastComponent, &prefix );

                lastComponent.Length -= prefix.Length;
                lastComponent.MaximumLength -= prefix.Length;
                lastComponent.Buffer += (prefix.Length / sizeof(WCHAR));

                DebugTrace( 0, Dbg, "lastComponent=%wZ\n", &lastComponent);

            }

            if (NT_SUCCESS(status)) {

                pktEntry = PktLookupEntryByPrefix(pkt, &prefix, &remPath);

                shortPktEntry =
                    PktLookupEntryByShortPrefix(pkt, &prefix, &shortRemPath);

                if (shortPktEntry != NULL) {

                    if (pktEntry == NULL ||
                            shortPktEntry->Id.Prefix.Length >
                                pktEntry->Id.Prefix.Length) {

                        pktEntry = shortPktEntry;

                        remPath = shortRemPath;

                    }

                }

                DebugTrace( 0, Dbg, "pktEntry=0x%x\n", pktEntry);

                if (pktEntry != NULL) {

                    //
                    // Found a pkt entry that matches. Is it the one belonging
                    // to the local volume that matched?
                    //

                    if (pktEntry == lvEntry->PktEntry) {

                        DebugTrace( 0, Dbg, "pktEntry===lvEntryPktEntry\n", 0);

                        ASSERT( pktEntry->LocalService != NULL );

                        //
                        // For DfsPathName which is relative to some parent
                        // path, we don't need to adjust the DfsPathName;
                        // simply checking to see if we landed up with the
                        // same Pkt Entry is all that is needed.
                        //

                        if (arg->ParentPathName.Length == 0) {

                            if (arg->Flags & DFS_TRANSLATE_STRIP_LAST_COMPONENT) {
                                DebugTrace( 0, Dbg, "STRIP_LAST on \n", 0);
                                remPath.Length += lastComponent.Length;
                            }

                            arg->DfsPathName.Length = remPath.Length;

                            RtlMoveMemory(
                                arg->DfsPathName.Buffer,
                                remPath.Buffer,
                                remPath.Length);

                            arg->DfsPathName.Buffer[
                                remPath.Length/sizeof(WCHAR)] = UNICODE_NULL;

                            DebugTrace( 0, Dbg, "arg->DfsPathName=%wZ\n", &arg->DfsPathName);

                        }

                        status = STATUS_SUCCESS;

                    } else {

                        //
                        // Must have crossed a junction point (to another local
                        // volume!)
                        //

                        status = STATUS_PATH_NOT_COVERED;
                    }

                } else {

                    //
                    // We don't know anything about this Dfs path. The client
                    // must be guessing...
                    //

                    status = STATUS_PATH_NOT_COVERED;

                }

            }

        } else {

            //
            // Didn't find an exact match for the given local volume name.
            //

            status = STATUS_PATH_NOT_COVERED;

        }

    } else {

        //
        // Didn't find a match for the given local volume at all!
        //

        status = STATUS_PATH_NOT_COVERED;

    }

    PktRelease( pkt );

    if (prefix.Buffer != NULL && prefix.Buffer != nameBuffer) {
        ExFreePool( prefix.Buffer );
    }

    DebugTrace( 0, Dbg, "DfsFsctrlTranslatePath exit 0x%x\n", ULongToPtr( status ));
    DebugTrace( 0, Dbg, "-->arg->SubDirectory=%wZ\n", &arg->SubDirectory);
    DebugTrace( 0, Dbg, "-->arg->ParentPathName=%wZ\n", &arg->ParentPathName);
    DebugTrace(-1, Dbg, "-->arg->DfsPathName=%wZ\n", &arg->DfsPathName);


    DFS_TRACE_ERROR_HIGH(status, ALL_ERROR, DfsFsctrlTranslatePath_Error1, 
                         LOGSTATUS(status)
                         LOGUSTR(arg->SubDirectory)
                         LOGUSTR(arg->ParentPathName)
                         LOGUSTR(arg->DfsPathName));

    DFS_TRACE_NORM(EVENT, DfsFsctrlTranslatePath_End,
               LOGSTATUS(status)
               LOGUSTR(arg->SubDirectory)
               LOGUSTR(arg->DfsPathName)
               LOGUSTR(arg->ParentPathName));

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspFormPrefix
//
//  Synopsis:   Helper routine that forms the arguments to
//              DfsFsctrlTranslatePath into a prefix appropriate for looking
//              up in the Pkt.
//
//  Arguments:  [LvEntry] -- The local volume entry on which the ParentPath
//                      was opened.
//              [ParentPath] -- The path of the parent object, relative to
//                      the dfs volume referenced by LvEntry. (equivalently,
//                      it is also relative to the Share Path). If this is a 0
//                      length string, then this is not a relative open.
//              [DfsPathName] -- The name of the file that is being translated.
//              [Prefix] -- The fully formed prefix is returned here. On
//                      entry, this should be initialized to have a buffer of
//                      some reasonable size; on return, the buffer might be
//                      replaced with a bigger one if needed, in which case
//                      the buffer should be freed using ExFreePool.
//
//  Returns:    [STATUS_SUCCESS] -- Successfully formed prefix.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Unable to form prefix.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspFormPrefix(
    IN PDFS_LOCAL_VOL_ENTRY LvEntry,
    IN PUNICODE_STRING ParentPath,
    IN PUNICODE_STRING DfsPathName,
    IN OUT PUNICODE_STRING Prefix)
{
    NTSTATUS status;
    ULONG sizeRequired;

    DebugTrace(+1, Dbg, "DfspFormPrefix(LvEntry=0x%x)\n", LvEntry);
    DebugTrace( 0, Dbg, "               ParentPath=%wZ\n", ParentPath);
    DebugTrace( 0, Dbg, "               DfsPathName=%wZ\n", DfsPathName);

    ASSERT(Prefix->Buffer != NULL);

    sizeRequired = sizeof(UNICODE_PATH_SEP) +
                        ParentPath->Length +
                            sizeof(UNICODE_PATH_SEP) +
                                DfsPathName->Length;

    if (ParentPath->Length > 0) {

        sizeRequired += LvEntry->PktEntry->Id.Prefix.Length;

    }

    if (sizeRequired > MAXUSHORT) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        DFS_TRACE_HIGH(ERROR, DfspFormPrefix_Error1, 
                       LOGSTATUS(status)
                       LOGUSTR(*ParentPath)
                       LOGUSTR(*DfsPathName));
        return status;

    }

    if (sizeRequired > Prefix->MaximumLength) {

        Prefix->MaximumLength = (USHORT)sizeRequired;

        Prefix->Buffer = ExAllocatePoolWithTag(PagedPool, sizeRequired, ' sfD');

    }

    if (Prefix->Buffer != NULL) {

        if (ParentPath->Length > 0) {

            RtlAppendUnicodeStringToString(
                    Prefix,
                    &LvEntry->PktEntry->Id.Prefix);

            DfsConcatenateFilePath(
                    Prefix,
                    ParentPath->Buffer,
                    (USHORT) (ParentPath->Length));

        } else {

            RtlAppendUnicodeToString(
                    Prefix,
                    UNICODE_PATH_SEP_STR);

        }

        DfsConcatenateFilePath(
            Prefix,
            DfsPathName->Buffer,
            DfsPathName->Length);

        status = STATUS_SUCCESS;

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;

    }

    DebugTrace( 0, Dbg, "on exit, Prefix=%wZ\n", Prefix);
    DebugTrace(-1, Dbg, "DfspFormPrefix exit 0x%x\n", ULongToPtr( status ));

    DFS_TRACE_ERROR_HIGH(status, ALL_ERROR, DfspFormPrefix_Error2, 
                         LOGSTATUS(status)
                         LOGUSTR(*ParentPath)
                         LOGUSTR(*DfsPathName));
    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlGetReferrals
//
//  Synopsis:   Returns a referral buffer for the given prefix.
//
//  Arguments:  [InputBuffer] -- Pointer to DFS_GET_REFERRALS_INPUT_ARG
//              [InputBufferLength] -- Length of InputBuffer.
//              [OutputBuffer] -- On successful return, contains a
//                      DFS_GET_REFERRALS_OUTPUT_BUFFER.
//              [OutputBufferLength] -- Length in bytes of OutputBuffer.
//              [ReturnedSize] -- On successful return, size of the returned
//                      referral. If returning STATUS_BUFFER_OVERFLOW, this
//                      variable contains the size of the buffer required to
//                      fit the entire referral.
//
//  Returns:    [STATUS_SUCCESS] -- DFS_GET_REFERRALS_OUTPUT_BUFFER
//                      successfully returned.
//
//              [STATUS_BUFFER_OVERFLOW] -- Couldn't fit all the referrals
//                      in the buffer; the required buffer length is returned
//                      in ReturnedSize.
//
//              [STATUS_NO_SUCH_DEVICE] -- Unable to find the Dfs volume in
//                      the local pkt.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlGetReferrals(
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PULONG ReturnedSize)
{

    NTSTATUS status = STATUS_SUCCESS;
    PDFS_GET_REFERRALS_INPUT_ARG arg =
        (PDFS_GET_REFERRALS_INPUT_ARG) InputBuffer;
    PRESP_GET_DFS_REFERRAL ref =
        (PRESP_GET_DFS_REFERRAL) OutputBuffer;
    PDFS_PKT pkt;
    PDFS_PKT_ENTRY pktEntry, shortPfxEntry;
    PDFS_IPADDRESS pIpAddress = NULL;
    UNICODE_STRING prefix;
    UNICODE_STRING PrefixTail;
    UNICODE_STRING remPath;
    UNICODE_STRING DomainName;
    UNICODE_STRING ShareName;
    ULONG i, size, maxLevel;
    LPWSTR AltList;
    PDFS_IP_INFO pIpInfo = NULL;
    PDFS_SPECIAL_INFO pSpcInfo = NULL;
    PSPECIAL_HASH_TABLE pHashTable = DfsData.SpcHashTable;

    DFS_TRACE_NORM(EVENT, DfsFsctrlGetReferrals_Start,
                   LOGSTATUS(status)
                   LOGUSTR(arg->DfsPathName));

    //
    // If we're not started, then say so
    //

    if (DfsData.OperationalState != DFS_STATE_STARTED && DfsData.IsDC == FALSE) {
        status = STATUS_DFS_UNAVAILABLE;
        DFS_TRACE_HIGH(ERROR, DfsFsctrlGetReferrals_Error1, LOGSTATUS(status));
        //return( status );
        goto cleanup;
    }

    if (InputBufferLength == sizeof(DFS_GET_REFERRALS_INPUT_ARG)
            &&
        RtlCompareMemory(
            &ZeroIpAddress,
            &arg->IpAddress,
            sizeof(DFS_IPADDRESS)) != sizeof(DFS_IPADDRESS)) {

        pIpAddress = &arg->IpAddress;

    }

    prefix = arg->DfsPathName;

    if ((maxLevel = arg->MaxReferralLevel) > 3)
        maxLevel = 3;

    DebugTrace(0, Dbg, "DfsFsctrlGetReferrals(maxLevel=%d)\n", ULongToPtr( maxLevel ));

    // Create domain, sharename, remainder from prefix

    remPath.Length = remPath.MaximumLength = 0;

    DfspParsePath(&prefix, &DomainName, &ShareName, &remPath);

    // See if this is a special name referral

    if (DfsData.IsDC == TRUE) {

        if (maxLevel >= 3 &&
            (DomainName.Length == 0 ||
            (DomainName.Length > 0 && ShareName.Length == 0))) {

            DebugTrace(0, Dbg, "DfsFsctrlGetReferrals: case 1\n", 0);

            ref->PathConsumed = 0;

            if (DomainName.Length > 0) {

                pSpcInfo = DfspLookupSpcEntry(&DomainName);

                if (pSpcInfo != NULL && pSpcInfo->NameCount > 1) {

                    pIpInfo = DfsLookupSiteByIpaddress(pIpAddress, TRUE);

                }

                status = DfspGetOneV3SpecialReferral(
                            pSpcInfo,
                            &DomainName,
                            pIpInfo,
                            ref,
                            OutputBufferLength,
                            ReturnedSize);

                if (pSpcInfo != NULL) {

                    DfsReleaseSpcInfo(pHashTable, pSpcInfo);
                    pSpcInfo = NULL;

                }

            } else {

                status = DfspGetAllV3SpecialReferral(
                            pIpInfo,
                            ref,
                            OutputBufferLength,
                            ReturnedSize);

            }

            DfsReleaseIpInfo(pIpInfo);
            if (DfsEventLog > 1)
                LogWriteMessage(DFS_REFERRAL_REQUEST, status, 1, &prefix);
            //return( status );
            goto cleanup;
        }

    }

    //
    // If we are going to hand out regular referrals,
    // check to see that we are a root server, and that the
    // referral request looks good.
    //

    pSpcInfo = DfspLookupSpcEntry(&DomainName);

    if (DfsData.MachineState == DFS_ROOT_SERVER
            &&
        DfsData.OperationalState == DFS_STATE_STARTED
	    &&
        DfsData.LvState == LV_INITIALIZED
	    &&
        DomainName.Length > 0
            &&
        ShareName.Length > 0
            &&
        (pSpcInfo == NULL || remPath.Length > 0)
    ) {

        DebugTrace(0, Dbg, "DfsFsctrlGetReferrals: case 2\n", 0);

        pkt = _GetPkt();

        if (maxLevel >= 3) {

            PktAcquireShared( pkt, TRUE );
            pktEntry = PktLookupEntryByPrefix( pkt, &prefix, &remPath);
            PktRelease( pkt );

            if (pktEntry != NULL && pktEntry->Info.ServiceCount > 1) {

                pIpInfo = DfsLookupSiteByIpaddress(pIpAddress, TRUE);

            }

        }

        PktAcquireShared( pkt, TRUE );

        //
        // Look up the name the client wants a referral for
        //
        if ((pktEntry = PktLookupEntryByPrefix( pkt, &prefix, &remPath)) != NULL) {
            //
            // See if there is a better match with an 8.3 prefix
            //
            shortPfxEntry = PktLookupEntryByShortPrefix( pkt, &prefix, &remPath );
            if ((maxLevel == 2 || maxLevel == 3) &&
                    shortPfxEntry != NULL &&
                        (shortPfxEntry->Id.Prefix.Length >
                            pktEntry->Id.Prefix.Length)) {

                pktEntry = shortPfxEntry;
                RemoveFirstComponent(&pktEntry->Id.ShortPrefix, &PrefixTail);
            } else {
                RemoveFirstComponent(&pktEntry->Id.Prefix, &PrefixTail);
            }
            ref->PathConsumed = sizeof(UNICODE_PATH_SEP) +
                                    DomainName.Length +
                                        PrefixTail.Length;
            //
            // Found an entry for the requested path. First, size the referral,
            // then, if it will fit in the output buffer, marshal it in.
            //
            switch (maxLevel) {
            case 1:
                size = DfspGetV1ReferralSize(pktEntry, &DomainName); break;
            case 2:
                size = DfspGetV2ReferralSize(pktEntry, &DomainName); break;
            case 3:
                size = DfspGetV3ReferralSize(pktEntry, &DomainName); break;
            default:
                ASSERT(FALSE && "Invalid MaxLevel");
            }

	    status = STATUS_SUCCESS;
            //
            // For level 1 referral, we fail if buffer is not big enough to
            // fit entire referral. For level 2 and 3, we try to fit as many
            // entries as possible into the refferal.

            switch (maxLevel) {
            case 1:
                   if (size <= OutputBufferLength) {
                       DfspGetV1Referral(pktEntry, &DomainName, ref); 
                   } else {
                       status = STATUS_BUFFER_OVERFLOW;
                       DFS_TRACE_HIGH(ERROR, DfsFsctrlGetReferals_Error1, LOGSTATUS(status));
                   }
	           break;
            case 2:
                   status = DfspGetV2Referral(pktEntry, &DomainName, OutputBufferLength, ref, &size); break;
            case 3:
                   status = DfspGetV3Referral(pktEntry, &DomainName, pIpInfo, OutputBufferLength, ref, &size); break;
            default:
                   ASSERT(FALSE && "Invalid MaxLevel");
            }
            if (status == STATUS_SUCCESS) {
                *ReturnedSize = size;
            } 

            PktRelease( pkt );
            DfsReleaseIpInfo(pIpInfo);
            if (DfsEventLog > 1)
                LogWriteMessage(DFS_REFERRAL_REQUEST, status, 1, &prefix);
            //return( status );
            goto cleanup;
        }

        PktRelease( pkt );
    }

    if (pSpcInfo != NULL) {

        DfsReleaseSpcInfo(pHashTable, pSpcInfo);

    }

    if (DfsData.IsDC == TRUE) {

        //
        // See if this is an FtDFS referral
        //

        if (maxLevel >= 3
                &&
            DomainName.Length > 0
                &&
            ShareName.Length > 0
                &&
            remPath.Length == 0
        ) {

            DebugTrace( 0, Dbg, "DfsFsctrlGetReferrals: case 3\n", 0);
            DebugTrace( 0, Dbg, "           DomainName=%wZ\n", &DomainName);
            DebugTrace( 0, Dbg, "           ShareName=%wZ\n", &ShareName);

            pIpInfo = DfsLookupSiteByIpaddress(pIpAddress, TRUE);

            status = DfspGetV3FtDfsReferral(
                        &DomainName,
                        &ShareName,
                        pIpInfo,
                        ref,
                        OutputBufferLength,
                        ReturnedSize);

            DebugTrace(-1, Dbg, "DfsFsctrlGetReferrals: exit->0x%x\n", ULongToPtr( status ));

            DfsReleaseIpInfo(pIpInfo);
            if (DfsEventLog > 1)
                LogWriteMessage(DFS_REFERRAL_REQUEST, status, 1, &prefix);
            //return( status );
            goto cleanup;
        }

    }

    //
    // Nobody claimed this referral
    //

    DfsReleaseIpInfo(pIpInfo);

    if (DfsEventLog > 1)
        LogWriteMessage(DFS_REFERRAL_REQUEST, STATUS_NO_SUCH_DEVICE, 1, &prefix);
    DebugTrace(-1, Dbg, "DfsFsctrlGetReferrals: exit STATUS_NO_SUCH_DEVICE\n", 0);
    status = STATUS_NO_SUCH_DEVICE;
    DFS_TRACE_HIGH(ERROR, DfsFsctrlGetReferals_Error2, LOGSTATUS(status));
    
cleanup:
    DFS_TRACE_NORM(EVENT, DfsFsctrlGetReferrals_End,
                   LOGSTATUS(status)
                   LOGUSTR(arg->DfsPathName));

    return(status);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspGetV1ReferralSize, private
//
//  Synopsis:   Sizes a V1 referral given a PktEntry
//
//  Arguments:  [PktEntry] -- The pkt entry to be returned in the referral
//
//  Returns:    Size in bytes of a buffer required to hold the V1 referral
//              for this Pkt Entry
//
//-----------------------------------------------------------------------------

ULONG
DfspGetV1ReferralSize(
    IN PDFS_PKT_ENTRY PktEntry,
    IN PUNICODE_STRING MachineName)
{
    ULONG i, size;

    size = sizeof( RESP_GET_DFS_REFERRAL );

    for (i = 0; i < PktEntry->Info.ServiceCount; i++) {

        size += sizeof(DFS_REFERRAL_V1) +
                    PktEntry->Info.ServiceList[i].Address.Length +
                        sizeof(UNICODE_NULL);

    }

    return( size );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspGetV2ReferralSize, private
//
//  Synopsis:   Sizes a V2 referral given a PktEntry
//
//  Arguments:  [PktEntry] -- The pkt entry to be returned in the referral
//
//  Returns:    Size in bytes of a buffer required to hold the V2 referral
//              for this Pkt Entry
//
//-----------------------------------------------------------------------------

ULONG
DfspGetV2ReferralSize(
    IN PDFS_PKT_ENTRY PktEntry,
    IN PUNICODE_STRING MachineName)
{
    UNICODE_STRING PrefixTail;
    ULONG i, size;

    DebugTrace(+1, Dbg, "DfsPGetV2ReferralSize()\n", 0);

    size = sizeof( RESP_GET_DFS_REFERRAL );

    for (i = 0; i < PktEntry->Info.ServiceCount; i++) {

        size += sizeof(DFS_REFERRAL_V2) +
                    PktEntry->Info.ServiceList[i].Address.Length +
                        sizeof(UNICODE_NULL);

    }

    RemoveFirstComponent(&PktEntry->Id.Prefix, &PrefixTail);

    size += sizeof(UNICODE_PATH_SEP) +
                MachineName->Length +
                    PrefixTail.Length +
                        sizeof(UNICODE_NULL);

    RemoveFirstComponent(&PktEntry->Id.ShortPrefix, &PrefixTail);

    size += sizeof(UNICODE_PATH_SEP) +
                MachineName->Length +
                    PrefixTail.Length +
                        sizeof(UNICODE_NULL);

    DebugTrace(-1, Dbg, "DfspGetV2ReferralSize() -- returning 0x%x\n", ULongToPtr( size ));

    return( size );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfspGetV3ReferralSize, private
//
//  Synopsis:   Sizes a V3 referral given a PktEntry
//
//  Arguments:  [PktEntry] -- The pkt entry to be returned in the referral
//
//  Returns:    Size in bytes of a buffer required to hold the V3 referral
//              for this Pkt Entry
//
//-----------------------------------------------------------------------------

ULONG
DfspGetV3ReferralSize(
    IN PDFS_PKT_ENTRY PktEntry,
    IN PUNICODE_STRING MachineName)
{
    UNICODE_STRING PrefixTail;
    ULONG i, size;

    DebugTrace(+1, Dbg, "DfsPGetV3ReferralSize()\n", 0);

    size = sizeof( RESP_GET_DFS_REFERRAL );

    for (i = 0; i < PktEntry->Info.ServiceCount; i++) {

        size += sizeof(DFS_REFERRAL_V3) +
                    PktEntry->Info.ServiceList[i].Address.Length +
                        sizeof(UNICODE_NULL);

    }

    RemoveFirstComponent(&PktEntry->Id.Prefix, &PrefixTail);

    size += sizeof(UNICODE_PATH_SEP) +
                MachineName->Length +
                    PrefixTail.Length +
                        sizeof(UNICODE_NULL);

    RemoveFirstComponent(&PktEntry->Id.ShortPrefix, &PrefixTail);

    size += sizeof(UNICODE_PATH_SEP) +
                MachineName->Length +
                    PrefixTail.Length +
                        sizeof(UNICODE_NULL);

    DebugTrace(-1, Dbg, "DfspGetV3ReferralSize() -- returning 0x%x\n", ULongToPtr( size ));

    return( size );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfspGetV1Referral, private
//
//  Synopsis:   Marshals a pkt entry into a RESP_GET_DFS_REFERRAL buffer with
//              V1 referrals
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

VOID
DfspGetV1Referral(
    IN PDFS_PKT_ENTRY PktEntry,
    IN PUNICODE_STRING MachineName,
    OUT PRESP_GET_DFS_REFERRAL Ref)
{
    PDFS_REFERRAL_V1 pv1;
    ULONG i;

    Ref->NumberOfReferrals = (USHORT) PktEntry->Info.ServiceCount;

    Ref->ReferralServers =
        (PktEntry->Type & PKT_ENTRY_TYPE_REFERRAL_SVC ? 1 : 0);

    Ref->StorageServers = 1;

    for (i = 0, pv1 = &Ref->Referrals[0].v1;
            i < PktEntry->Info.ServiceCount;
                i++) {

         PDFS_SERVICE pSvc;

         pSvc = &PktEntry->Info.ServiceList[i];

         pv1->VersionNumber = 1;

         pv1->Size = sizeof(DFS_REFERRAL_V1) +
                        pSvc->Address.Length +
                            sizeof(UNICODE_NULL);

         pv1->ServerType =
            pSvc->Type & DFS_SERVICE_TYPE_DOWN_LEVEL ? 0 : 1;

         RtlCopyMemory(
            pv1->ShareName,
            pSvc->Address.Buffer,
            pSvc->Address.Length);

         pv1->ShareName[ pSvc->Address.Length / sizeof(WCHAR) ] =
            UNICODE_NULL;

         pv1 = (PDFS_REFERRAL_V1) ( ((PCHAR) pv1) + pv1->Size );

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspGetV2Referral, private
//
//  Synopsis:   Marshals a pkt entry into a RESP_GET_DFS_REFERRAL buffer with
//              V2 referrals
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspGetV2Referral(
    IN PDFS_PKT_ENTRY PktEntry,
    IN PUNICODE_STRING MachineName,
    IN ULONG BufferSize,
    OUT PRESP_GET_DFS_REFERRAL Ref,
    OUT PULONG ReferralSize)
{
    PDFS_REFERRAL_V2 pv2;
    ULONG i;
    ULONG j;
    LPWSTR dfsPath, alternatePath, nextAddress;
    UNICODE_STRING PrefixTail;
    ULONG CumulativeSize, CurrentSize;
    ULONG optimalReferralCount;
    USHORT totalReferrals = 0;
    NTSTATUS status;

    // Setup the maximum number of referrals that we intend to return.

    if (DfsData.Pkt.MaxReferrals != 0) {
      optimalReferralCount = DfsData.Pkt.MaxReferrals;
    }
    else {
      optimalReferralCount = MAXIMUM_DFS_REFERRALS;
    }

    DebugTrace(+1, Dbg, "DfspGetV2Referral()\n", 0);

    // Calculate the size of the referral, and make sure our size does not
    // exceed the passed in buffer len.
    CumulativeSize = sizeof (RESP_GET_DFS_REFERRAL) +
                        MachineName->Length + PktEntry->Id.Prefix.Length +
                            sizeof(UNICODE_PATH_SEP) + sizeof(UNICODE_NULL) +
                                MachineName->Length + PktEntry->Id.ShortPrefix.Length +
                                    sizeof(UNICODE_PATH_SEP) + sizeof(UNICODE_NULL);

    if (BufferSize < CumulativeSize) {
        status = STATUS_BUFFER_OVERFLOW;
        DFS_TRACE_HIGH(ERROR, DfspGetV2Referral_Error1, 
                       LOGSTATUS(status)
                       LOGUSTR(*MachineName));
        return status;
    }
    Ref->NumberOfReferrals = (USHORT) PktEntry->Info.ServiceCount;

    Ref->ReferralServers =
        (PktEntry->Type & PKT_ENTRY_TYPE_REFERRAL_SVC ? 1 : 0);

    Ref->StorageServers =
        (PktEntry->Type & PKT_ENTRY_TYPE_OUTSIDE_MY_DOM ? 0 : 1);

    pv2 = &Ref->Referrals[0].v2;

    for (i = 0; i < Ref->NumberOfReferrals; i++) {
       PDFS_SERVICE pSvc;

       pSvc = &PktEntry->Info.ServiceList[i];
       if ((pSvc->Type & DFS_SERVICE_TYPE_OFFLINE) == 0) {
	 totalReferrals++;
       }
    }

    for (i = j = 0; i < Ref->NumberOfReferrals; i++) {
       PDFS_SERVICE pSvc;

       pSvc = &PktEntry->Info.ServiceList[i];
       if ((pSvc->Type & DFS_SERVICE_TYPE_OFFLINE) == 0) {
           CurrentSize = sizeof(DFS_REFERRAL_V2) + pSvc->Address.Length + sizeof(UNICODE_NULL);
           if (((CumulativeSize + CurrentSize) >= BufferSize) || (j >= optimalReferralCount)) 
                break;
           j++;
	   CumulativeSize += CurrentSize;
       }
    }

    // Adjust the number of referrals accordingly.
    Ref->NumberOfReferrals = (USHORT)i;

    //
    // Copy the volume prefix into the response buffer, just past the end
    // of all the V2 referrals
    //

    nextAddress = dfsPath = (LPWSTR) &pv2[j];

    *nextAddress++ = UNICODE_PATH_SEP;

    RtlCopyMemory(
        nextAddress,
        MachineName->Buffer,
        MachineName->Length);

    nextAddress += MachineName->Length/sizeof(WCHAR);

    RemoveFirstComponent(&PktEntry->Id.Prefix, &PrefixTail);

    RtlCopyMemory(
        nextAddress,
        PrefixTail.Buffer,
        PrefixTail.Length);

    nextAddress += PrefixTail.Length/sizeof(WCHAR);

    *nextAddress++ = UNICODE_NULL;

    //
    // Copy the 8.3 volume prefix into the response buffer after the
    // dfsPath
    //

    alternatePath = nextAddress;

    *nextAddress++ = UNICODE_PATH_SEP;

    RtlCopyMemory(
        nextAddress,
        MachineName->Buffer,
        MachineName->Length);

    nextAddress += MachineName->Length/sizeof(WCHAR);

    RemoveFirstComponent(&PktEntry->Id.ShortPrefix, &PrefixTail);

    RtlCopyMemory(
        nextAddress,
        PrefixTail.Buffer,
        PrefixTail.Length);

    nextAddress += PrefixTail.Length/sizeof(WCHAR);

    *nextAddress++ = UNICODE_NULL;

    //
    // nextAddress is pointer into buffer where the individual service addresses
    // will go.
    //

    for (i = j = 0; i < Ref->NumberOfReferrals; i++) {
         PDFS_SERVICE pSvc;

         //
         // Only take online services
         //
         pSvc = &PktEntry->Info.ServiceList[i];
         if ((pSvc->Type & DFS_SERVICE_TYPE_OFFLINE) == 0) {
             pv2->VersionNumber = 2;
             pv2->Size = sizeof(DFS_REFERRAL_V2);
             pv2->ServerType =
                pSvc->Type & DFS_SERVICE_TYPE_DOWN_LEVEL ? 0 : 1;
             pv2->Proximity = 0;
             pv2->TimeToLive = PktEntry->Info.Timeout;
             pv2->DfsPathOffset = (USHORT) (((PCHAR) dfsPath) - ((PCHAR) pv2));
             pv2->DfsAlternatePathOffset =
                (USHORT) (((PCHAR) alternatePath) - ((PCHAR) pv2));
             pv2->NetworkAddressOffset =
                (USHORT) (((PCHAR) nextAddress) - ((PCHAR) pv2));
             RtlCopyMemory(
                nextAddress,
                pSvc->Address.Buffer,
                pSvc->Address.Length);
             nextAddress[ pSvc->Address.Length/sizeof(WCHAR) ] = UNICODE_NULL;
             nextAddress += pSvc->Address.Length/sizeof(WCHAR) + 1;
             pv2++;
             j++;
         }
    }

    Ref->NumberOfReferrals = (USHORT) j;
    
    //
    // we have more than one service, but cannot fit any into the buffer
    // return buffer overflow.
    //
    if ((totalReferrals > 0) && (Ref->NumberOfReferrals == 0)) {
        status = STATUS_BUFFER_OVERFLOW;
        DFS_TRACE_HIGH(ERROR, DfspGetV2Referral_Error2, 
                       LOGSTATUS(status)
                       LOGUSTR(*MachineName));
        return status;
    }

    *ReferralSize = (ULONG)((PUCHAR)nextAddress - (PUCHAR)Ref);

    DebugTrace(-1, Dbg, "DfspGetV2Referral() -- exit\n", 0);

    return STATUS_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfspGetV3Referral, private
//
//  Synopsis:   Marshals a pkt entry into a RESP_GET_DFS_REFERRAL buffer with
//              V3 referrals
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspGetV3Referral(
    IN PDFS_PKT_ENTRY PktEntry,
    IN PUNICODE_STRING MachineName,
    IN PDFS_IP_INFO pIpInfo,
    IN ULONG BufferSize,
    OUT PRESP_GET_DFS_REFERRAL Ref,
    OUT PULONG ReferralSize)
{
    PDFS_REFERRAL_V3 pv3;
    ULONG i;
    ULONG j;
    LPWSTR dfsPath, alternatePath, nextAddress;
    UNICODE_STRING PrefixTail;
    PDFS_REFERRAL_LIST pRefList = NULL;
    ULONG CumulativeSize, Ndx, CurrentSize;
    USHORT totalReferrals;
    ULONG InSite;
    ULONG optimalReferralCount;
    NTSTATUS status;

    // Setup the maximum number of referrals that we intend to return.
    if (DfsData.Pkt.MaxReferrals != 0) {
      optimalReferralCount = DfsData.Pkt.MaxReferrals;
    }
    else {
      optimalReferralCount = MAXIMUM_DFS_REFERRALS;
    }

    DebugTrace(+1, Dbg, "DfspGetV3Referral()\n", 0);

    // Calculate the size of the referral, and make sure our size does not
    // exceed the passed in buffer len.
    CumulativeSize = 
            sizeof (RESP_GET_DFS_REFERRAL) +
              MachineName->Length + PktEntry->Id.Prefix.Length +
                 sizeof(UNICODE_PATH_SEP) + sizeof(UNICODE_NULL) + 
                   MachineName->Length + PktEntry->Id.ShortPrefix.Length + 
                      sizeof(UNICODE_PATH_SEP) + sizeof(UNICODE_NULL);

    if (BufferSize < CumulativeSize) {
        status = STATUS_BUFFER_OVERFLOW;
        DFS_TRACE_HIGH(ERROR, DfspGetV3Referral_Error1, 
                       LOGSTATUS(status)
                       LOGUSTR(*MachineName));
        return status;
    }

    Ref->NumberOfReferrals = (USHORT) PktEntry->Info.ServiceCount;
    totalReferrals = Ref->NumberOfReferrals;

    //
    // Alloc and init a DFS_REFERRAL_LIST
    //

    if (Ref->NumberOfReferrals) {
        pRefList = ExAllocatePoolWithTag(
                      PagedPool,
                      sizeof(DFS_REFERRAL_LIST) * Ref->NumberOfReferrals,
                    ' sfD');

        if (pRefList == NULL) {
            DebugTrace(-1,
              Dbg,
              "DfspGetV3Referral() exit STATUS_INSUFFICIENT_RESOURCES\n",
              0);
            status = STATUS_INSUFFICIENT_RESOURCES;
            DFS_TRACE_HIGH(ERROR, DfspGetV3Referral_Error2, 
                           LOGSTATUS(status)
                           LOGUSTR(*MachineName));
            return status;
        }
    }


    //
    // Initialize it
    //

    for (i = j = 0; i < Ref->NumberOfReferrals; i++) {
        //
        // Skip offline entries
        //
        if ((PktEntry->Info.ServiceList[i].Type & DFS_SERVICE_TYPE_OFFLINE) == 0) {
            pRefList[j].pName = PktEntry->Info.ServiceList[i].Name;
            pRefList[j].pAddress = PktEntry->Info.ServiceList[i].Address;
            pRefList[j].Type = PktEntry->Info.ServiceList[i].Type;
            j++;
        }
    }

    Ref->NumberOfReferrals = (USHORT)j;

    if (Ref->NumberOfReferrals) {
        //
        // Shuffle the list in case we don't have site info
        //

        SrvShuffle(pRefList, 0, Ref->NumberOfReferrals - 1);

        //
        // Determine client's site based on the IP address srv gave us.
        //

        if (pIpInfo != NULL) {

            //
            // Reorder by site
            //
  
            InSite = DfsIpOrdering(pIpInfo, Ref->NumberOfReferrals, pRefList);
	    if (PktEntry->Type & PKT_ENTRY_TYPE_INSITE_ONLY) {
	      Ref->NumberOfReferrals = (USHORT)InSite;
	    }
        }
    }

    Ref->ReferralServers =
        (PktEntry->Type & PKT_ENTRY_TYPE_REFERRAL_SVC ? 1 : 0);

    Ref->StorageServers =
        (PktEntry->Type & PKT_ENTRY_TYPE_OUTSIDE_MY_DOM ? 0 : 1);

    totalReferrals = Ref->NumberOfReferrals;

    pv3 = &Ref->Referrals[0].v3;

    //
    // Now, we have a shuffled list of referrals. see how many we can give back
    // to the client in the buffer allocated.
    // We pick the first entry, followed by the last entry, then the second
    // entry followed by the last but one, and so on. The purpose of this
    // logic is to ensure that we split the returned referrals between
    // the "insite" referrals that are on the top of the list and the 
    // "outsite" referrals that are at the bottom
    //

    for (i = 0; i < Ref->NumberOfReferrals; i++) {
        Ndx = i / 2;
        if (i & 1) {
            Ndx = Ref->NumberOfReferrals - Ndx - 1;
        }

        CurrentSize = sizeof(DFS_REFERRAL_V3) + 
	            pRefList[Ndx].pAddress.Length + sizeof(UNICODE_NULL);
        if (((CumulativeSize + CurrentSize) >= BufferSize) || (i >= optimalReferralCount)) 
            break;
          CumulativeSize += CurrentSize;
    }

    // Adjust the number of referrals accordingly.
    Ref->NumberOfReferrals = (USHORT)i;

    //
    // Copy the volume prefix into the response buffer, just past the end
    // of all the V3 referrals
    //

    nextAddress = dfsPath = (LPWSTR) &pv3[ Ref->NumberOfReferrals ];

    *nextAddress++ = UNICODE_PATH_SEP;

    RtlCopyMemory(
        nextAddress,
        MachineName->Buffer,
        MachineName->Length);

    nextAddress += MachineName->Length/sizeof(WCHAR);

    RemoveFirstComponent(&PktEntry->Id.Prefix, &PrefixTail);

    RtlCopyMemory(
        nextAddress,
        PrefixTail.Buffer,
        PrefixTail.Length);

    nextAddress += PrefixTail.Length/sizeof(WCHAR);

    *nextAddress++ = UNICODE_NULL;

    //
    // Copy the 8.3 volume prefix into the response buffer after the
    // dfsPath
    //

    alternatePath = nextAddress;

    *nextAddress++ = UNICODE_PATH_SEP;

    RtlCopyMemory(
        nextAddress,
        MachineName->Buffer,
        MachineName->Length);

    nextAddress += MachineName->Length/sizeof(WCHAR);

    RemoveFirstComponent(&PktEntry->Id.ShortPrefix, &PrefixTail);

    RtlCopyMemory(
        nextAddress,
        PrefixTail.Buffer,
        PrefixTail.Length);

    nextAddress += PrefixTail.Length/sizeof(WCHAR);

    *nextAddress++ = UNICODE_NULL;

    //
    // nextAddress is pointer into buffer where the individual service addresses
    // will go.
    //

    for (i = 0; i < Ref->NumberOfReferrals; i++) {
      if (i < ((ULONG)Ref->NumberOfReferrals + 1) / 2) {
        Ndx = i;
      }
      else {
        Ndx = totalReferrals - Ref->NumberOfReferrals + i;
      }
      pv3->VersionNumber = 3;
      pv3->Size = sizeof(DFS_REFERRAL_V3);
      pv3->ServerType = pRefList[Ndx].Type & DFS_SERVICE_TYPE_DOWN_LEVEL ? 0 : 1;
      pv3->StripPath = 0;                        // for now
      pv3->NameListReferral = 0;
      pv3->TimeToLive = PktEntry->Info.Timeout;
      pv3->DfsPathOffset = (USHORT) (((PCHAR) dfsPath) - ((PCHAR) pv3));

      pv3->DfsAlternatePathOffset =
         (USHORT) (((PCHAR) alternatePath) - ((PCHAR) pv3));

      pv3->NetworkAddressOffset =
         (USHORT) (((PCHAR) nextAddress) - ((PCHAR) pv3));

      RtlZeroMemory(
         &pv3->ServiceSiteGuid,
         sizeof (GUID));

      RtlCopyMemory(
         nextAddress,
         pRefList[Ndx].pAddress.Buffer,
         pRefList[Ndx].pAddress.Length);

      nextAddress[ pRefList[Ndx].pAddress.Length/sizeof(WCHAR) ] = UNICODE_NULL;
      nextAddress += pRefList[Ndx].pAddress.Length/sizeof(WCHAR) + 1;

      pv3++;
    }

    if (pRefList) {
      ExFreePool(pRefList);
    }

    //
    // we have more than one service, but cannot fit any into the buffer
    // return buffer overflow.
    //
    if ((totalReferrals > 0) && (Ref->NumberOfReferrals == 0)) {
      return STATUS_BUFFER_OVERFLOW;
    }

    *ReferralSize = (ULONG)((PUCHAR)nextAddress - (PUCHAR)Ref);

    DebugTrace(-1, Dbg, "DfspGetV3Referral() -- returning STATUS_SUCCESS\n", 0);

    return STATUS_SUCCESS;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspGetOneV3SpecialReferral, private
//
//  Synopsis:   Marshals a special referral
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspGetOneV3SpecialReferral(
    IN PDFS_SPECIAL_INFO pSpcInfo,
    IN PUNICODE_STRING Name,
    IN PDFS_IP_INFO pIpInfo,
    OUT PRESP_GET_DFS_REFERRAL Ref,
    IN ULONG MaximumSize,
    OUT PULONG ReturnedSize)
{
    PDFS_REFERRAL_V3 pv3;
    PDFS_REFERRAL_LIST pRefList;
    LPWSTR pwName;
    LONG i, j;
    ULONG size;
    NTSTATUS status;
    DFS_REFERRAL_LIST MustKeep;
    BOOLEAN FoundMustKeep;

    ULONG CumulativeSize;
    ULONG CurrentSize;
    ULONG NameCount;

    // ASSERT(Name->Length > 0);

    DebugTrace(+1, Dbg, "DfspGetOneV3SpecialReferral(%ws)\n", Name->Buffer);

    //
    // Calculate the size
    //

    if (pSpcInfo == NULL) {
        status = STATUS_NO_SUCH_DEVICE;
        DebugTrace(-1, Dbg, "DfspGetOneV3SpecialReferral() -- exit STATUS_NO_SUCH_DEVICE\n", 0);
        DFS_TRACE_HIGH(ERROR, DfspGetOneV3SpecialReferral_Error1, 
                       LOGSTATUS(status)
                       LOGUSTR(*Name));
        return status;

    }
     
    CumulativeSize = sizeof( RESP_GET_DFS_REFERRAL ) +    
           sizeof(DFS_REFERRAL_V3) +
           pSpcInfo->SpecialName.Length +
           sizeof(UNICODE_NULL) + 
           sizeof(UNICODE_NULL);
          

    if (MaximumSize < CumulativeSize) {
        *((PULONG) Ref) = CumulativeSize + sizeof(ULONG);
        return STATUS_BUFFER_OVERFLOW;
    }


    //
    // Alloc and init a DFS_REFERRAL_LIST
    //

    pRefList = ExAllocatePoolWithTag(
                    PagedPool,
                    sizeof(DFS_REFERRAL_LIST) * pSpcInfo->NameCount,
                    ' sfD');

    if (pRefList == NULL) {

        DebugTrace(-1,
            Dbg,
            "DfspGetOneV3SpecialReferral() exit STATUS_INSUFFICIENT_RESOURCES\n",
            0);
        status = STATUS_INSUFFICIENT_RESOURCES;
        DFS_TRACE_HIGH(ERROR, DfspGetOneV3SpecialRefferal_Error2, 
                       LOGSTATUS(status)
                       LOGUSTR(*Name));

        return  status;

    }

    //
    // Initialize it
    //

    for (j = 0; j < pSpcInfo->NameCount; j++) {
        pRefList[j].pName = pSpcInfo->Name[j];
        pRefList[j].pAddress = pSpcInfo->Name[j];
        pRefList[j].Type = 0;

    }

    //
    // Shuffle the list in case we don't have site info
    //

    SrvShuffle(pRefList, 1, pSpcInfo->NameCount - 1);

    NameCount = 0;

    if (pSpcInfo->NameCount > 0) {
        MustKeep = pRefList[0];

        CurrentSize = sizeof(UNICODE_PATH_SEP);
        CurrentSize += MustKeep.pName.Length;
        CurrentSize += sizeof(UNICODE_NULL);
	
        CumulativeSize += CurrentSize;
    }

    //
    // Determine client's site based on the IP address srv gave us.
    //

    if (pIpInfo != NULL) {

        //
        // Reorder by site
        //

        DfsIpOrdering(pIpInfo, pSpcInfo->NameCount, pRefList);
    }

    FoundMustKeep = FALSE;

    for (j = 0; j < pSpcInfo->NameCount; j++) {
        if ((FoundMustKeep == FALSE) && 
            (MustKeep.pName.Buffer == pRefList[j].pName.Buffer)) {

            FoundMustKeep = TRUE;
	    if (CumulativeSize >= MaximumSize) {
	      break;
	    }
        } 
        else {
            CurrentSize = sizeof(UNICODE_PATH_SEP);
            CurrentSize += pRefList[j].pName.Length;
            CurrentSize += sizeof(UNICODE_NULL);

            if (CumulativeSize + CurrentSize >= MaximumSize) {
                break;
            }
            CumulativeSize += CurrentSize;
        }
    }

    if ((pSpcInfo->NameCount > 0) && (FoundMustKeep == FALSE)) {
        if (CumulativeSize < MaximumSize) {
            NameCount++;
            pRefList[j] = MustKeep;
        }
    }

    NameCount += j;

    if ((NameCount == 0) && (pSpcInfo->NameCount > 0)) {
        *ReturnedSize = CumulativeSize + CurrentSize;
        ExFreePool(pRefList);
        return STATUS_BUFFER_OVERFLOW;
    }

    //
    // Fill in the referral
    //

    DebugTrace( 0, Dbg, "DfspGetOneV3SpecialReferral pSpcInfo = 0x%x\n", pSpcInfo);

    Ref->NumberOfReferrals = 1;
    Ref->StorageServers = Ref->ReferralServers = 0;
    Ref->PathConsumed = 0;
    pv3 = &Ref->Referrals[0].v3;
    pv3->NumberOfExpandedNames = (USHORT) NameCount;
    //
    // Copy the Special Names right after the V3 referral
    //

    pwName = (LPWSTR) &pv3[1];
    pv3->SpecialNameOffset = (USHORT) (((PCHAR) pwName) - ((PCHAR) pv3));
    pv3->VersionNumber = 3;
    pv3->Size = sizeof(DFS_REFERRAL_V3);
    pv3->ServerType = 0;
    pv3->StripPath = 0;                        // for now
    pv3->NameListReferral = 1;
    pv3->TimeToLive = DfsData.SpcHashTable->SpcTimeout;

    *pwName++ = UNICODE_PATH_SEP;

    RtlCopyMemory(
        pwName,
        pSpcInfo->SpecialName.Buffer,
        pSpcInfo->SpecialName.Length);

    pwName[ pSpcInfo->SpecialName.Length/sizeof(WCHAR) ] = UNICODE_NULL;
    pwName += pSpcInfo->SpecialName.Length/sizeof(WCHAR) + 1;

    pv3->ExpandedNameOffset = (USHORT) (((PCHAR) pwName) - ((PCHAR) pv3));

    for (j = 0; j < pv3->NumberOfExpandedNames; j++) {

        *pwName++ = UNICODE_PATH_SEP;

        RtlCopyMemory(
            pwName,
            pRefList[j].pName.Buffer,
            pRefList[j].pName.Length);

        pwName[ pRefList[j].pName.Length/sizeof(WCHAR) ] = UNICODE_NULL;
        pwName += pRefList[j].pName.Length/sizeof(WCHAR) + 1;

    }



    // Double UNICODE_NULL at end

    *pwName++ = UNICODE_NULL;
    *ReturnedSize = CumulativeSize;
    ExFreePool(pRefList);

    DebugTrace(-1, Dbg, "DfspGetOneV3SpecialReferral() -- exit\n", 0);

    return STATUS_SUCCESS;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspGetAllV3SpecialReferral, private
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspGetAllV3SpecialReferral(
    IN PDFS_IP_INFO pIpInfo,
    OUT PRESP_GET_DFS_REFERRAL Ref,
    IN ULONG MaximumSize,
    OUT PULONG ReturnedSize)
{
    PDFS_REFERRAL_V3 pv3;
    PDFS_SPECIAL_INFO pSpcInfo;
    PSPECIAL_HASH_TABLE pHashTable = DfsData.SpcHashTable;
    PDFS_REFERRAL_LIST pRefList;
    LPWSTR pwName;
    LONG i, j;
    ULONG size;
    ULONG SpcCount;
    NTSTATUS status;

    DebugTrace(+1, Dbg, "DfspGetAllV3SpecialReferral()\n", 0);

    //
    // return all special names, with DFS_SPECIAL_INFO_PRIMARY's expanded
    //

    size = sizeof( RESP_GET_DFS_REFERRAL );

    DfsSpcInfoFindOpen(pHashTable);

    for (SpcCount = 0, pSpcInfo = DfsSpcInfoFindFirst(pHashTable);
            pSpcInfo != NULL;
                pSpcInfo = DfsSpcInfoFindNext(pHashTable,pSpcInfo)) {

        //
        // Skip downlevel trusts - they can't have a SYSVOL or an FtDfs
        // in them.
        //

        if (pSpcInfo->TrustType != TRUST_TYPE_UPLEVEL)
            continue;

        size += sizeof(DFS_REFERRAL_V3) +
                    sizeof(UNICODE_PATH_SEP) +
                        pSpcInfo->SpecialName.Length +
                            sizeof(UNICODE_NULL);

        if ((pSpcInfo->TypeFlags & DFS_SPECIAL_INFO_PRIMARY) != 0) {

            for (j = 0; j < pSpcInfo->NameCount; j++) {

                size += sizeof(UNICODE_PATH_SEP) +
                            pSpcInfo->Name[j].Length +
                                sizeof(UNICODE_NULL);

            }

        }

        //
        // Double UNICODE_NULL at end
        //

        size += sizeof(WCHAR);

        SpcCount++;

    }

    //
    // If no entries to return say so
    //

    if (SpcCount == 0) {

        DfsSpcInfoFindClose(pHashTable);
        if (pIpInfo != NULL) {
            DfsReleaseIpInfo(pIpInfo);
        }
        DebugTrace(-1, Dbg, "DfspGetAllV3SpecialReferral() -- exit STATUS_NO_SUCH_DEVICE\n", 0);

        status = STATUS_NO_SUCH_DEVICE;
        DFS_TRACE_HIGH(ERROR, DfspGetAllV3SpecialReferral_Error1, LOGSTATUS(status));
        return  status;

    }

    //
    // See if it will fit - respond with needed size if it doesn't
    //

    if (size > MaximumSize) {

        *((PULONG) Ref) = size;
        *ReturnedSize = sizeof(ULONG);
        DfsSpcInfoFindClose(pHashTable);
        if (pIpInfo != NULL) {
            DfsReleaseIpInfo(pIpInfo);
        }
        DebugTrace(-1, Dbg, "DfspGetAllV3SpecialReferral() -- exit STATUS_BUFFER_OVERFLOW\n", 0);
        status = STATUS_BUFFER_OVERFLOW;
        DFS_TRACE_HIGH(ERROR, DfspGetAllV3SpecialReferral_Error2, LOGSTATUS(status));
        return  STATUS_BUFFER_OVERFLOW;

    }

    *ReturnedSize = size;

    Ref->NumberOfReferrals = (USHORT) SpcCount;

    Ref->StorageServers = Ref->ReferralServers = 0;

    Ref->PathConsumed = 0;

    pv3 = &Ref->Referrals[0].v3;

    //
    // Copy the Special Names right after the V3 referrals
    //

    pwName = (LPWSTR) &pv3[SpcCount];

    for (i = 0, pSpcInfo = DfsSpcInfoFindFirst(pHashTable);
            pSpcInfo != NULL;
                pSpcInfo = DfsSpcInfoFindNext(pHashTable,pSpcInfo)) {


        //
        // Skip downlevel trusts - they can't have a SYSVOL or an FtDfs
        // in them.
        //

        if (pSpcInfo->TrustType != TRUST_TYPE_UPLEVEL)
            continue;

        pv3[i].SpecialNameOffset = (USHORT) (((PCHAR) pwName) - ((PCHAR) &pv3[i]));
        pv3[i].VersionNumber = 3;
        pv3[i].Size = sizeof(DFS_REFERRAL_V3);
        pv3[i].ServerType = 0;
        pv3[i].StripPath = 0;                        // for now
        pv3[i].NameListReferral = 1;
        pv3[i].TimeToLive = pHashTable->SpcTimeout;

        *pwName++ = UNICODE_PATH_SEP;

        RtlCopyMemory(
            pwName,
            pSpcInfo->SpecialName.Buffer,
            pSpcInfo->SpecialName.Length);

        pwName[ pSpcInfo->SpecialName.Length/sizeof(WCHAR) ] = UNICODE_NULL;

        pwName += pSpcInfo->SpecialName.Length/sizeof(WCHAR) + 1;

        if ((pSpcInfo->TypeFlags & DFS_SPECIAL_INFO_PRIMARY) != 0) {

            //
            // Alloc and init a DFS_REFERRAL_LIST
            //

            pRefList = ExAllocatePoolWithTag(
                            PagedPool,
                            sizeof(DFS_REFERRAL_LIST) * pSpcInfo->NameCount,
                            ' sfD');

            if (pRefList == NULL) {

                DfsSpcInfoFindClose(pHashTable);
                if (pIpInfo != NULL) {
                    DfsReleaseIpInfo(pIpInfo);
                }

                DebugTrace(-1,
                    Dbg,
                    "DfspGetAllV3SpecialReferral() exit STATUS_INSUFFICIENT_RESOURCES\n",
                    0);

                status = STATUS_INSUFFICIENT_RESOURCES;
                DFS_TRACE_HIGH(ERROR, DfspGetAllV3SpecialReferral_Error3, LOGSTATUS(status));
                return  status;

            }

            //
            // Initialize it
            //

            for (j = 0; j < pSpcInfo->NameCount; j++) {

                pRefList[j].pName = pSpcInfo->Name[j];
                pRefList[j].pAddress = pSpcInfo->Name[j];
                pRefList[j].Type = 0;

            }

            //
            // Shuffle the list in case we don't have site info
            //

            SrvShuffle(pRefList, 0, pSpcInfo->NameCount - 1);

            //
            // Reorder by site
            //

            //
            // Determine client's site based on the IP address srv gave us.
            //

            if (pSpcInfo->NameCount > 1 && pIpInfo != NULL) {

                //
                // Reorder by site
                //

                DfsIpOrdering(pIpInfo, pSpcInfo->NameCount, pRefList);

            }

            //
            // Load the referrals
            //

            pv3[i].NumberOfExpandedNames = (USHORT) pSpcInfo->NameCount;
            pv3[i].ExpandedNameOffset = (USHORT) (((PCHAR) pwName) - ((PCHAR) &pv3[i]));

            for (j = 0; j < pSpcInfo->NameCount; j++) {

                *pwName++ = UNICODE_PATH_SEP;

                RtlCopyMemory(
                    pwName,
                    pRefList[j].pName.Buffer,
                    pRefList[j].pName.Length);

                pwName[ pRefList[j].pName.Length/sizeof(WCHAR) ] = UNICODE_NULL;
                pwName += pRefList[j].pName.Length/sizeof(WCHAR) + 1;

            }


            ExFreePool(pRefList);

            // Double UNICODE_NULL at end

            *pwName++ = UNICODE_NULL;

        } else {

            pv3[i].NumberOfExpandedNames = 0;
            pv3[i].ExpandedNameOffset = 0;

        }

        i++;

    }

    DfsSpcInfoFindClose(pHashTable);

    DebugTrace(-1, Dbg, "DfspGetAllV3SpecialReferral() -- exit\n", 0);

    return STATUS_SUCCESS;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspGetV3FtDfsReferral, private
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspGetV3FtDfsReferral(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ShareName,
    IN PDFS_IP_INFO pIpInfo,
    OUT PRESP_GET_DFS_REFERRAL Ref,
    IN ULONG MaximumSize,
    PULONG ReturnedSize)
{

    NTSTATUS status;
    PDFS_REFERRAL_V3 pv3;
    PSPECIAL_HASH_TABLE pFtHashTable = DfsData.FtDfsHashTable;
    PDFS_REFERRAL_LIST pRefList;
    PDFS_SPECIAL_INFO pFtInfo = NULL;
    LPWSTR dfsPath, alternatePath, ustrp;
    LONG i, j;
    ULONG k;
    ULONG size;
    UNICODE_STRING MachineName;
    UNICODE_STRING TempName;
    LARGE_INTEGER now;
    PDFS_SPECIAL_INFO pSpcInfo = NULL;
    PSPECIAL_HASH_TABLE pHashTable = DfsData.SpcHashTable;
    BOOLEAN fSysvol = FALSE;

    DFS_REFERRAL_LIST MustKeep;
    BOOLEAN SpecialInfoCreated  = FALSE;
    BOOLEAN FoundMustKeep;
    
    ULONG CumulativeSize;
    ULONG CurrentSize;
    ULONG TotalCount;


    DebugTrace(+1, Dbg, "DfspGetV3FtDfsReferral()\n", 0);

    if (DfspIsSpecialShare(ShareName) == TRUE) {

        pSpcInfo = DfspLookupSpcEntry(DomainName);

        if (pSpcInfo == NULL || pSpcInfo->NameCount == 0) {
            status = STATUS_NO_SUCH_DEVICE;
            goto ErrorOnSpecialShare;
        }

        size = sizeof(DFS_SPECIAL_INFO) + DomainName->Length;

        if (pSpcInfo->NameCount > 1)
            size += sizeof(UNICODE_STRING) * (pSpcInfo->NameCount - 1);

        for (i = 0; i < pSpcInfo->NameCount; i++) {
            size += sizeof(UNICODE_PATH_SEP) +
                        pSpcInfo->Name[i].Length +
                            sizeof(UNICODE_PATH_SEP) +
                                ShareName->Length;
        }

        pFtInfo = ExAllocatePoolWithTag(
                        PagedPool,
                        size,
                        ' sfD');

        if (pFtInfo == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorOnSpecialShare;
        }

        RtlZeroMemory(pFtInfo, size);

        ustrp = (LPWSTR) &pFtInfo->Name[pSpcInfo->NameCount];

        pFtInfo->SpecialName.Length = DomainName->Length;
        pFtInfo->SpecialName.MaximumLength = DomainName->MaximumLength;
        pFtInfo->SpecialName.Buffer = ustrp;

        RtlCopyMemory(
            ustrp,
            DomainName->Buffer,
            DomainName->Length);

        ustrp += DomainName->Length / sizeof(WCHAR);

        //
        // NOTE:
        // By setting UseCount to 1 and SPECIAL_INFO_DELETE_PENDING, the
        // call to DfsReleaseSpcInfo() will free up this chunk of memory.
        //

        InitializeListHead(&pFtInfo->HashChain);
        pFtInfo->NodeTypeCode = DFS_NTC_SPECIAL_INFO;
        pFtInfo->NodeByteSize = (USHORT) size;
        pFtInfo->UseCount = 1;
        pFtInfo->Flags = SPECIAL_INFO_DELETE_PENDING;
        pFtInfo->NameCount = pSpcInfo->NameCount;
	
	SpecialInfoCreated = TRUE;

        for (i = 0; i < pSpcInfo->NameCount; i++) {

            pFtInfo->Name[i].Length = sizeof(UNICODE_PATH_SEP) +
                                            pSpcInfo->Name[i].Length +
                                                sizeof(UNICODE_PATH_SEP) +
                                                    ShareName->Length;

            pFtInfo->Name[i].MaximumLength = pFtInfo->Name[i].Length;
            pFtInfo->Name[i].Buffer = ustrp;

            *ustrp++ = UNICODE_PATH_SEP;
            RtlCopyMemory(
                ustrp,
                pSpcInfo->Name[i].Buffer,
                pSpcInfo->Name[i].Length);
            ustrp += pSpcInfo->Name[i].Length / sizeof(WCHAR);
            *ustrp++ = UNICODE_PATH_SEP;
            RtlCopyMemory(
                ustrp,
                ShareName->Buffer,
                ShareName->Length);
            ustrp += ShareName->Length / sizeof(WCHAR);

        }

        if (pSpcInfo != NULL) {
            DfsReleaseSpcInfo(pHashTable, pSpcInfo);
            pSpcInfo = NULL;
        }

        fSysvol = TRUE;

        goto CreateReferral;

ErrorOnSpecialShare:

        if (pSpcInfo != NULL) {
            DfsReleaseSpcInfo(pHashTable, pSpcInfo);
            pSpcInfo = NULL;
        }

        DebugTrace(-1, Dbg,
            "DfspGetV3FtDfsReferral(Syvol or NetLogon) -- exit STATUS_NO_SUCH_DEVICE\n", 0);
        status = STATUS_NO_SUCH_DEVICE;
        DFS_TRACE_HIGH(ERROR, DfspGetV3FtDfsReferral_Error1, 
                       LOGSTATUS(status)
                       LOGUSTR(*DomainName)
                       LOGUSTR(*ShareName));
        return status; 

    }

    //
    // Check the FtDfs cache
    //
    pFtInfo = DfsLookupSpcInfo(
                    pFtHashTable,
                    ShareName);

    //
    // If the entry is old try to refresh it.
    //

    KeQuerySystemTime(&now);

    if (pFtInfo != NULL && now.QuadPart > pFtInfo->ExpireTime.QuadPart) {

        ExAcquireFastMutex( &pFtHashTable->HashListMutex );
        pFtInfo->ExpireTime.QuadPart = now.QuadPart + UInt32x32To64(
                                                           10 * 60,
                                                           10 * 1000 * 1000);
        ExReleaseFastMutex( &pFtHashTable->HashListMutex );
        DfsReleaseSpcInfo(pFtHashTable, pFtInfo);
        pFtInfo = NULL;

    }

    if (pFtInfo == NULL) {

        //
        // Try to get it into the cache
        //

        DfsLpcDomRequest(ShareName);

        //
        // And try again
        //

        pFtInfo = DfsLookupSpcInfo(
                        pFtHashTable,
                        ShareName);

        if (pFtInfo == NULL) {

            //
            // Not in the cache, and we couldn't get it
            //

            DebugTrace(-1, Dbg, "DfspGetV3FtDfsReferral(1) -- exit STATUS_NO_SUCH_DEVICE\n", 0);
            status = STATUS_NO_SUCH_DEVICE;
            DFS_TRACE_HIGH(ERROR, DfspGetV3FtDfsReferral_Error2, 
                           LOGSTATUS(status)
                           LOGUSTR(*DomainName)
                           LOGUSTR(*ShareName));
            return status; 

        }

    }

    if (pFtInfo->NameCount == 0) {

        DfsReleaseSpcInfo(pFtHashTable, pFtInfo);
        DebugTrace(-1, Dbg, "DfspGetOneV3SpecialReferral(2) -- exit STATUS_NO_SUCH_DEVICE\n", 0);
        status = STATUS_NO_SUCH_DEVICE;
        DFS_TRACE_HIGH(ERROR, DfspGetV3FtDfsReferral_Error3, 
                       LOGSTATUS(status)
                       LOGUSTR(*DomainName)
                       LOGUSTR(*ShareName));
        return STATUS_NO_SUCH_DEVICE; 

    }

CreateReferral:


    CumulativeSize = sizeof( RESP_GET_DFS_REFERRAL );

    // Longname

    CumulativeSize += sizeof(UNICODE_PATH_SEP) +
                          DomainName->Length +
                            sizeof(UNICODE_PATH_SEP) +
                              ShareName->Length +
                                sizeof(UNICODE_NULL);

    // Shortname

    CumulativeSize += sizeof(UNICODE_PATH_SEP) +
                              DomainName->Length +
                                  sizeof(UNICODE_PATH_SEP) +
                                       ShareName->Length +
                                         sizeof(UNICODE_NULL);

    if (CumulativeSize > MaximumSize) {
        *((PULONG) Ref) = (CumulativeSize + sizeof(ULONG));
        *ReturnedSize = sizeof(ULONG);
        DfsReleaseSpcInfo(pFtHashTable, pFtInfo);
        return STATUS_BUFFER_OVERFLOW;
    }



    //
    // Alloc and init a DFS_REFERRAL_LIST
    //

    pRefList = ExAllocatePoolWithTag(
                    PagedPool,
                    sizeof(DFS_REFERRAL_LIST) * pFtInfo->NameCount,
                    ' sfD');

    if (pRefList == NULL) {

        DfsReleaseSpcInfo(pFtHashTable, pFtInfo);

        DebugTrace(-1,
            Dbg,
            "DfspGetV3FtDfsReferral exit STATUS_INSUFFICIENT_RESOURCES\n",
            0);

        status = STATUS_INSUFFICIENT_RESOURCES;
        DFS_TRACE_HIGH(ERROR, DfspGetV3FtDfsReferral_Error4, 
                       LOGSTATUS(status)
                       LOGUSTR(*DomainName)
                       LOGUSTR(*ShareName));
        return  status;

    }

    //
    // Initialize it
    //

    for (i = 0; i < pFtInfo->NameCount; i++) {

        //
        // We need to extract the servername from the address
        //

        pRefList[i].pName = pFtInfo->Name[i];

        pRefList[i].pName.Buffer++;
        pRefList[i].pName.Length -= sizeof(WCHAR);

        for (k = 0;
            k < pRefList[i].pName.Length/sizeof(WCHAR)
                &&
            pRefList[i].pName.Buffer[k] != L'\\';
                k++) {

            /* NOTHING */;

        }

        if (k < pRefList[i].pName.Length/sizeof(WCHAR)) {

            pRefList[i].pName.Length = (USHORT) (k * sizeof(WCHAR));

        }

        pRefList[i].pAddress = pFtInfo->Name[i];
        pRefList[i].Type = 0;


    }

    //
    // Shuffle the list in case we don't have site info
    //

    SrvShuffle(pRefList, (SpecialInfoCreated == TRUE) ? 1 : 0, pFtInfo->NameCount - 1);

    TotalCount = 0;
    if ((SpecialInfoCreated == TRUE) && (pFtInfo->NameCount > 0)) {
        MustKeep = pRefList[0];

        CurrentSize = sizeof(UNICODE_PATH_SEP);
        CurrentSize += MustKeep.pAddress.Length;
        CurrentSize += sizeof(UNICODE_NULL);
	
        CumulativeSize += CurrentSize;
    }

    //
    // Determine client's site based on the IP address srv gave us.
    //

    if (pIpInfo != NULL) {

        //
        // Reorder by site
        //

        DfsIpOrdering(pIpInfo, pFtInfo->NameCount, pRefList);

    }
    
    FoundMustKeep = FALSE;
    for (i = 0; i < pFtInfo->NameCount; i++) {
        if ((SpecialInfoCreated == TRUE) && 
            (FoundMustKeep == FALSE) &&
            (MustKeep.pAddress.Buffer == pRefList[i].pAddress.Buffer)) {

            FoundMustKeep = TRUE;
	    if (CumulativeSize >= MaximumSize) {
	      break;
	    }
        }
        else {
            CurrentSize = sizeof(DFS_REFERRAL_V3) +
                              pRefList[i].pAddress.Length +
                                     sizeof(UNICODE_NULL);
            if ((CumulativeSize + CurrentSize) >= MaximumSize) {
                break;
            }
            CumulativeSize += CurrentSize;
        }
    }
    if ((pFtInfo->NameCount > 0) && (SpecialInfoCreated == TRUE) && (FoundMustKeep == FALSE)) {
        if (CumulativeSize < MaximumSize) {
            TotalCount++;
            pRefList[i] = MustKeep;
        }
    }
    TotalCount += i;
    if ((TotalCount == 0) && (pFtInfo->NameCount > 0)) {
        *ReturnedSize = CumulativeSize + CurrentSize;
        DfsReleaseSpcInfo(pFtHashTable, pFtInfo);
        ExFreePool(pRefList);
        return STATUS_BUFFER_OVERFLOW;
    }

    //
    // Fill in the referral
    //

    Ref->NumberOfReferrals = (USHORT) TotalCount;

    Ref->ReferralServers = 1;   // Means the FtDFS roots can handle referrals (should be true)
    Ref->StorageServers = 1;    // Means the FtDFS roots contain data/storage (should be true)

    pv3 = &Ref->Referrals[0].v3;

    //
    // Copy the FtDfs prefix into the response buffer, just past the end
    // of all the V3 referrals
    //

    dfsPath = ustrp = (LPWSTR) &pv3[ TotalCount ];

    *ustrp++ = UNICODE_PATH_SEP;

    RtlCopyMemory(
        ustrp,
        DomainName->Buffer,
        DomainName->Length);

    ustrp += DomainName->Length / sizeof(WCHAR);
    *ustrp++ = UNICODE_PATH_SEP;

    RtlCopyMemory(
        ustrp,
        ShareName->Buffer,
        ShareName->Length);

    ustrp += ShareName->Length / sizeof(WCHAR);
    *ustrp++ = UNICODE_NULL;

    //
    // Copy the 8.3 volume prefix into the response buffer after the
    // dfsPath
    //

    alternatePath = ustrp;

    *ustrp++ = UNICODE_PATH_SEP;

    RtlCopyMemory(
        ustrp,
        DomainName->Buffer,
        DomainName->Length);

    ustrp += DomainName->Length / sizeof(WCHAR);
    *ustrp++ = UNICODE_PATH_SEP;

    RtlCopyMemory(
        ustrp,
        ShareName->Buffer,
        ShareName->Length);

    ustrp += ShareName->Length / sizeof(WCHAR);
    *ustrp++ = UNICODE_NULL;

    //
    // Initialize pointer into buffer where the individual service addresses
    // will go.
    //

    for (i = 0; i < Ref->NumberOfReferrals; i++) {

         pv3->VersionNumber = 3;
         pv3->Size = sizeof(DFS_REFERRAL_V3);
         pv3->ServerType = (fSysvol == TRUE) ? 0 : 1;
         pv3->StripPath = 0;                        // for now
         pv3->NameListReferral = 0;
         pv3->TimeToLive = pFtHashTable->SpcTimeout;
         pv3->DfsPathOffset = (USHORT) (((PCHAR) dfsPath) - ((PCHAR) pv3));
         pv3->DfsAlternatePathOffset =
            (USHORT) (((PCHAR) alternatePath) - ((PCHAR) pv3));

         pv3->NetworkAddressOffset =
            (USHORT) (((PCHAR) ustrp) - ((PCHAR) pv3));

         RtlZeroMemory(
            &pv3->ServiceSiteGuid,
            sizeof (GUID));

         RtlCopyMemory(
            ustrp,
            pRefList[i].pAddress.Buffer,
            pRefList[i].pAddress.Length);

         ustrp += pRefList[i].pAddress.Length / sizeof(WCHAR);
         *ustrp++ = UNICODE_NULL;

         pv3++;

    }

    DfsReleaseSpcInfo(pFtHashTable, pFtInfo);
    ExFreePool(pRefList);
    *ReturnedSize = CumulativeSize;
    return STATUS_SUCCESS;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlIsShareInDfs
//
//  Synopsis:   Determines whether a share path is also in the Dfs.
//
//  Arguments:  [InputBuffer] -- Pointer to DFS_IS_SHARE_IN_DFS_ARG.
//              [InputBufferLength] -- Length in bytes of InputBuffer.
//
//  Returns:    [STATUS_SUCCESS] -- Share path is in Dfs
//
//              [STATUS_NO_SUCH_DEVICE] -- Share path is not in Dfs.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlIsShareInDfs(
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength)
{
    PDFS_IS_SHARE_IN_DFS_ARG arg = (PDFS_IS_SHARE_IN_DFS_ARG) InputBuffer;
    PDFS_PKT pkt;
    PUNICODE_PREFIX_TABLE_ENTRY lvPrefix;
    PDFS_LOCAL_VOL_ENTRY lvEntry;
    UNICODE_STRING lvName, remPath;
    NTSTATUS status = STATUS_SUCCESS;

    //
    // Verify the buffer is at least of size DFS_IS_SHARE_IN_DFS_ARG
    // And that this is the system process.
    //
    
    if (InputBufferLength < sizeof(DFS_IS_SHARE_IN_DFS_ARG)
            ||
        PsGetCurrentProcess() != DfsData.OurProcess
    ) {
        status = STATUS_INVALID_PARAMETER;
        DFS_TRACE_HIGH(ERROR, DfsFsctrlIsShareInDfs_Error1, LOGSTATUS(status));
        return status;
    }

    lvName = arg->SharePath;

    DebugTrace(+1, Dbg, "DfsFsctrlIsShareInDfs(%wZ)\n", &lvName);

    //
    // Lookup the localVol in the local volume prefix table.
    //

    pkt = _GetPkt();

    PktAcquireShared( pkt, TRUE );

    lvPrefix = DfsFindUnicodePrefix(
                    &pkt->LocalVolTable,
                    &lvName,
                    &remPath);

    DebugTrace( 0, Dbg, "  lvPrefix=0x%x\n", lvPrefix);

    if (lvPrefix != NULL) {

        lvEntry = CONTAINING_RECORD(
                        lvPrefix,
                        DFS_LOCAL_VOL_ENTRY,
                        PrefixTableEntry);

        DebugTrace( 0, Dbg, "  lvEntry=0x%x\n", lvEntry);
        DebugTrace( 0, Dbg, "  lvEntry->LocalPath=[%wZ]\n", &lvEntry->LocalPath);

        if (lvEntry->LocalPath.Length == lvName.Length) {

            if (RtlEqualUnicodeString(
                    &lvEntry->ShareName, &arg->ShareName, TRUE)) {

                arg->ShareType = DFS_SHARE_TYPE_DFS_VOLUME;

                if (lvEntry->PktEntry->Type & PKT_ENTRY_TYPE_REFERRAL_SVC)
                    arg->ShareType |= DFS_SHARE_TYPE_ROOT;

                status = STATUS_SUCCESS;

            } else {

                DebugTrace( 0, Dbg, "  NO_SUCH_DEVICE(1)\n", 0);
                status = STATUS_NO_SUCH_DEVICE;

            }

        } else {

            DebugTrace( 0, Dbg, "  NO_SUCH_DEVICE(2)\n", 0);
            status = STATUS_NO_SUCH_DEVICE;

        }

    } else {

        DebugTrace( 0, Dbg, "  NO_SUCH_DEVICE(3)\n", 0);
        status = STATUS_NO_SUCH_DEVICE;

    }

    PktRelease( pkt );

    DebugTrace(-1, Dbg, "DfsFsctrlIsShareInDfs exit 0x%x\n", ULongToPtr( status ));
    DFS_TRACE_ERROR_HIGH(status, ALL_ERROR, DfsFsctrlIsShareInDfs_Error2, LOGSTATUS(status));

    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlFindShare
//
//  Synopsis:   Determines whether a share path is an FtDFS root
//
//  Arguments:  [InputBuffer] -- Pointer to DFS_FIND_SHARE_ARG
//              [InputBufferLength] -- Length in bytes of InputBuffer.
//
//  Returns:    [STATUS_PATH_NOT_COVERED] -- Share path is an FtDFS root
//              [STATUS_BAD_NETWORK_NAME] -- Share path is NOT an FtDFS root
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlFindShare(
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength)
{
    PSPECIAL_HASH_TABLE pFtHashTable = DfsData.FtDfsHashTable;
    PDFS_SPECIAL_INFO pFtInfo;
    NTSTATUS status = STATUS_SUCCESS;

 
    PDFS_FIND_SHARE_ARG arg = (PDFS_FIND_SHARE_ARG) InputBuffer;
    
    DFS_TRACE_NORM(EVENT, DfsFsctrlFindShare_Start,
                    LOGSTATUS(status)
                    LOGUSTR(arg->ShareName));

    DebugTrace(+1, Dbg, "DfsFsctrlFindShare(%ws)\n", arg->ShareName.Buffer);

    //
    // See if we have the FtDfs info cached
    //
    pFtInfo = DfsLookupSpcInfo(
                    pFtHashTable,
                    &arg->ShareName);

    if (pFtInfo != NULL) {

        if (pFtInfo->NameCount > 0) {
            
            status = STATUS_PATH_NOT_COVERED;

        } else {

            status = STATUS_BAD_NETWORK_NAME;

        }

        DfsReleaseSpcInfo(
                    pFtHashTable,
                    pFtInfo);

       DebugTrace(-1, Dbg, "DfsFsctrlFindShare() -- returning 0x%x\n", ULongToPtr( status ));
       DFS_TRACE_ERROR_HIGH(status, ALL_ERROR, DfsFsctrlFindShare_Error1, LOGSTATUS(status));
       //return status;
       goto cleanup;
    }

    //
    // Not in cache -- call up pipe to dfssvc.exe
    //

    status = DfsLpcDomRequest(&arg->ShareName);

    //
    // If success, return STATUS_PATH_NOT_COVERED

    if (NT_SUCCESS(status)) {

        status = STATUS_PATH_NOT_COVERED;

    } else {

        status = STATUS_BAD_NETWORK_NAME;

    }

    DebugTrace(-1, Dbg, "DfsFsctrlFindShare() -- returning 0x%x\n", ULongToPtr( status ));

    DFS_TRACE_ERROR_HIGH(status, ALL_ERROR, DfsFsctrlFindShare_Error2, LOGSTATUS(status));
cleanup:
    DFS_TRACE_NORM(EVENT, DfsFsctrlFindShare_End,
                    LOGSTATUS(status)
                    LOGUSTR(arg->ShareName));

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   SrvShuffle
//
//  Synopsis:   Shuffles a cost equivalent group of (pointers to) services around
//              for load balancing. Uses the classic card shuffling algorithm - for
//              each card in the deck, exchange it with a random card in the
//              deck.
//
//-----------------------------------------------------------------------------

VOID
SrvShuffle(
    PDFS_REFERRAL_LIST pRefList,
    LONG nStart,
    LONG nEnd)
{
    LONG i;
    LARGE_INTEGER seed;

    //
    // We allow caller to have nEnd to be before nStart, so check for this
    //
    if (nStart >= nEnd)
        return;

    KeQuerySystemTime( &seed );

    for (i = nStart; i <= nEnd; i++) {

        DFS_REFERRAL_LIST pTempEntry;
        ULONG j;

        j = (RtlRandom( &seed.LowPart ) % (nEnd - nStart + 1)) + nStart;

        pTempEntry = pRefList[i];

        pRefList[i] = pRefList[j];

        pRefList[j] = pTempEntry;

    }
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsIpOrdering
//
//  Synopsis:   Reorders a list of names based upon the passed-in client ip address.
//
//-----------------------------------------------------------------------------

ULONG
DfsIpOrdering(
    IN PDFS_IP_INFO pIpInfo,
    IN ULONG RefCount,
    IN PDFS_REFERRAL_LIST pRefList)
{
    PDFS_REFERRAL_LIST pOrdRefList;
    PDFS_SITE_INFO pSiteInfo;
    BOOLEAN ToFront;
    LONG Front = RefCount;
    LONG Back;
    ULONG i, j;

    DebugTrace(+1, Dbg, "DfsIpOrdering()\n", 0);

    //
    // Create an ordered list of addresses based on Sites
    //

    pOrdRefList = ExAllocatePoolWithTag(
                        PagedPool,
                        sizeof(DFS_REFERRAL_LIST) * RefCount,
                        ' sfD');

    if (pOrdRefList != NULL) {

        Front = 0;
        Back = RefCount - 1;

        for (i = 0; i < RefCount; i++) {

            //
            // Scan the list of alternates, placing each alternate either toward the
            // front of the ordered list (if site matches) or toward the rear of the
            // ordered list (if sites don't match).
            //

            ToFront = FALSE;
	    
            pSiteInfo = DfsLookupSiteInfo(&pRefList[i].pName);


            if (pSiteInfo != NULL) {

                for (j = 0; ToFront == FALSE && j < pSiteInfo->SiteCount; j++) {

                    if (RtlCompareUnicodeString(
                        &pIpInfo->SiteName,
                        &pSiteInfo->SiteName[j],
                        TRUE) == 0) {
                            
                        ToFront = TRUE;
                    }
                }

                DfsReleaseSiteInfo(pSiteInfo);
            }

            if (ToFront == TRUE) {

                pOrdRefList[Front++] = pRefList[i];

            } else {

                pOrdRefList[Back--] = pRefList[i];

            }

        }

        //
        // Replace the unordered list with the ordered one
        //

        for (i = 0; i < RefCount; i++) {

            pRefList[i] = pOrdRefList[i];

        }

        ExFreePool(pOrdRefList);

    }

    DebugTrace(-1, Dbg, "DfsIpOrdering()--exit\n", 0);

    return Front;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfspLookupSpcEntry
//
//  Synopsis:   Returns a special list info entry, expanded if necessary
//
//-----------------------------------------------------------------------------

PDFS_SPECIAL_INFO
DfspLookupSpcEntry(
    IN PUNICODE_STRING SpecialName)
{
    PSPECIAL_HASH_TABLE pHashTable = DfsData.SpcHashTable;
    PDFS_SPECIAL_INFO pSpcInfo = NULL;
    LARGE_INTEGER now;
    ULONG TypeFlags;

    DebugTrace(+1, Dbg, "DfspLookupSpcEntry(%wZ)\n", SpecialName);

    //
    // Check the SpcName cache
    //
    pSpcInfo = DfsLookupSpcInfo(
                    pHashTable,
                    SpecialName);

    if (pSpcInfo != NULL) {

        //
        // If the entry is old or unexpanded, try to expand it
        //

        KeQuerySystemTime(&now);

        if ((now.QuadPart > pSpcInfo->ExpireTime.QuadPart ||
             pSpcInfo->NameCount == -1)
         ) {

            ExAcquireFastMutex( &pHashTable->HashListMutex );
            if (now.QuadPart > pSpcInfo->ExpireTime.QuadPart) {

                pSpcInfo->ExpireTime.QuadPart = now.QuadPart + UInt32x32To64(
                                                                   60 * 60,
                                                                   10 * 1000 * 1000);
                TypeFlags = pSpcInfo->TypeFlags;
                ExReleaseFastMutex( &pHashTable->HashListMutex );
                DfsReleaseSpcInfo(pHashTable, pSpcInfo);

                //
                // Try to refresh the cache
                //

		if (pSpcInfo->Flags & SPECIAL_INFO_IS_LONG_NAME) {
		  pSpcInfo->Flags |= SPECIAL_INFO_NEEDS_REFRESH;
		}

                DfsLpcSpcRequest(SpecialName, TypeFlags);

                //
                // And try again
                //

                pSpcInfo = DfsLookupSpcInfo(
                                pHashTable,
                                SpecialName);

            } else {

                ExReleaseFastMutex( &pHashTable->HashListMutex );

            }

        }

        if (pSpcInfo != NULL) {

            if (pSpcInfo->NameCount == -1) {

                DfsReleaseSpcInfo(pHashTable, pSpcInfo);
                pSpcInfo = NULL;

            }

        }

    }

    DebugTrace(-1, Dbg, "DfspLookupSpcEntry returning 0x%x\n", pSpcInfo);

    return pSpcInfo;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspIsSpecialShare, local
//
//  Synopsis:   Sees if a share name is a special share.
//
//  Arguments:  [ShareName] -- Name of share to test.
//
//  Returns:    TRUE if special, FALSE otherwise.
//
//-----------------------------------------------------------------------------

BOOLEAN
DfspIsSpecialShare(
    PUNICODE_STRING ShareName)
{
    ULONG i;
    BOOLEAN fSpecial = FALSE;

    for (i = 0;
            (i < (sizeof(SpecialShares) / sizeof(SpecialShares[0]))) &&
                !fSpecial;
                    i++) {

        if (SpecialShares[i].Length == ShareName->Length) {

            if (RtlCompareUnicodeString(&SpecialShares[i],ShareName,TRUE) == 0) {

                fSpecial = TRUE;

            }

        }

    }

    return( fSpecial );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\h\dfsgluon.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       DfsGluon.h
//
//  Contents:   Declarations for dfs use of gluons
//
//  Classes:
//
//  Functions:
//
//  History:    March 24, 1994		Milans Created
//
//-----------------------------------------------------------------------------


#ifndef _DFS_GLUON_
#define _DFS_GLUON_

#include <gluon.h>


//
// Marshalling info for TAddress
//

extern MARSHAL_INFO MiTAddress;

#define INIT_TADDRESS_MARSHAL_INFO()					\
    static MARSHAL_TYPE_INFO _MCode_TAddress[] = {			\
    	_MCode_conformant(TA_ADDRESS, Address, AddressLength),		\
    	_MCode_ush(TA_ADDRESS, AddressLength),				\
	_MCode_ush(TA_ADDRESS, AddressType),				\
	_MCode_cauch(TA_ADDRESS, Address, AddressLength) 		\
    };									\
    MARSHAL_INFO MiTAddress = _mkMarshalInfo(TA_ADDRESS, _MCode_TAddress);

//
// Marshalling info for DS_TRANSPORT
//

extern MARSHAL_INFO MiDSTransport;

#define INIT_DS_TRANSPORT_MARSHAL_INFO()				\
    static MARSHAL_TYPE_INFO _MCode_DSTransport[] = {			\
        _MCode_conformant(DS_TRANSPORT, taddr.Address, taddr.AddressLength), \
    	_MCode_ush(DS_TRANSPORT, usFileProtocol),			\
	_MCode_ush(DS_TRANSPORT, iPrincipal),				\
	_MCode_ush(DS_TRANSPORT, grfModifiers),				\
	_MCode_struct(DS_TRANSPORT, taddr, &MiTAddress)		\
    };									\
    MARSHAL_INFO MiDSTransport = _mkMarshalInfo(DS_TRANSPORT, _MCode_DSTransport);


//
// The following is needed to define an array of pointers to DS_TRANSPORT
//

typedef struct _DS_TRANSPORT_P {
    PDS_TRANSPORT pDSTransport;
} DS_TRANSPORT_P;

#define INIT_DS_TRANSPORT_P_MARSHAL_INFO()				\
    static MARSHAL_TYPE_INFO _MCode_DSTransportP[] = {			\
    	_MCode_pstruct(DS_TRANSPORT_P, pDSTransport, &MiDSTransport)	\
    };									\
    MARSHAL_INFO MiDSTransportP = _mkMarshalInfo(DS_TRANSPORT_P, _MCode_DSTransportP);

extern MARSHAL_INFO MiDSTransportP;

//
// Marshalling info for DS_MACHINE
//

extern MARSHAL_INFO MiDSMachine;

#define INIT_DS_MACHINE_MARSHAL_INFO()					\
    static MARSHAL_TYPE_INFO _MCode_DSMachine[] = {			\
        _MCode_conformant(DS_MACHINE, rpTrans, cTransports),		\
    	_MCode_guid(DS_MACHINE, guidSite),				\
	_MCode_guid(DS_MACHINE, guidMachine),				\
	_MCode_ul(DS_MACHINE, grfFlags),				\
	_MCode_pwstr(DS_MACHINE, pwszShareName),			\
	_MCode_ul(DS_MACHINE, cPrincipals),				\
	_MCode_pcapwstr(DS_MACHINE, prgpwszPrincipals, cPrincipals),	\
	_MCode_ul(DS_MACHINE, cTransports),				\
	_MCode_castruct(DS_MACHINE, rpTrans, cTransports, &MiDSTransportP) \
    };									\
    MARSHAL_INFO MiDSMachine = _mkMarshalInfo(DS_MACHINE, _MCode_DSMachine);

//
// The following is needed to define an array of pointers to DS_MACHINE
//

typedef struct _DS_MACHINE_P {
    PDS_MACHINE pDSMachine;
} DS_MACHINE_P;

#define INIT_DS_MACHINE_P_MARSHAL_INFO()				\
    static MARSHAL_TYPE_INFO _MCode_DSMachineP[] = {			\
    	_MCode_pstruct(DS_MACHINE_P, pDSMachine, &MiDSMachine)		\
    };									\
    MARSHAL_INFO MiDSMachineP = _mkMarshalInfo(DS_MACHINE_P, _MCode_DSMachineP);

extern MARSHAL_INFO MiDSMachineP;
//
// Marshalling info for DS_GLUON
//

extern MARSHAL_INFO MiDSGluon;

#define INIT_DS_GLUON_MARSHAL_INFO() 					\
    static MARSHAL_TYPE_INFO _MCode_DSGluon[] = {			\
    	_MCode_conformant(DS_GLUON, rpMachines, cMachines),		\
    	_MCode_guid(DS_GLUON, guidThis),				\
	_MCode_pwstr(DS_GLUON, pwszName),				\
	_MCode_ul(DS_GLUON, grfFlags),					\
	_MCode_ul(DS_GLUON, cMachines),					\
	_MCode_castruct(DS_GLUON, rpMachines, cMachines, &MiDSMachineP)	\
    };									\
    MARSHAL_INFO MiDSGluon = _mkMarshalInfo(DS_GLUON, _MCode_DSGluon);

typedef struct _DS_GLUON_P {
    PDS_GLUON pDSGluon;
} DS_GLUON_P;

extern MARSHAL_INFO MiDSGluonP;

#define INIT_DS_GLUON_P_MARSHAL_INFO()					\
    static MARSHAL_TYPE_INFO _MCode_DSGluonP[] = {			\
    	_MCode_pstruct(DS_GLUON_P, pDSGluon, &MiDSGluon)		\
    };									\
    MARSHAL_INFO MiDSGluonP = _mkMarshalInfo(DS_GLUON_P, _MCode_DSGluonP);

#endif // _DFS_GLUON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\h\dfsrtl.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:   DfsRtl.h
//
//  Contents:
//
//  Functions:
//
//  History:     27 May 1992 PeterCo Created.
//
//-----------------------------------------------------------------------------

#ifndef _DFSRTL_
#define _DFSRTL_

#include <stddef.h>

BOOLEAN
DfsRtlPrefixPath (
    IN PUNICODE_STRING Prefix,
    IN PUNICODE_STRING Test,
    IN BOOLEAN IgnoreCase
);

#endif // _DFSRTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\h\dfssrv.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dfssrv.h

Abstract:

    Header file for dfssrv's lpc server.  Defines structures
    common to the server and dfs.sys

Author:

    Jim harper (jharper) 11-Dec-1997 (based on xactsrv2.h)

Revision History:

--*/

#ifndef _DFSSRV_
#define _DFSSRV_

#define MAX_FTNAME_LEN  96
#define MAX_SPCNAME_LEN 94

//
// Structures for messages that are passed across the LPC port between
// the server dfssvc and dfs.sys
//
// *** The PORT_MESSAGE structure *must* be the first element of these
//     structures!

typedef struct _DFSSRV_REQUEST_MESSAGE {

    PORT_MESSAGE PortMessage;
    ULONG MessageType;

    union {

        struct {
            DFS_IPADDRESS IpAddress;
        } GetSiteName;

        struct {
            WCHAR FtName[MAX_FTNAME_LEN];
        } GetFtDfs;

        struct {
            WCHAR SpcName[MAX_SPCNAME_LEN];
            ULONG Flags;
        } GetSpcName;

    } Message;


} DFSSRV_REQUEST_MESSAGE, *PDFSSRV_REQUEST_MESSAGE;

typedef struct _DFSSRV_REPLY_MESSAGE {

    PORT_MESSAGE PortMessage;

    union {

        struct {
            NTSTATUS Status;
        } Result;

    } Message;

} DFSSRV_REPLY_MESSAGE, *PDFSSRV_REPLY_MESSAGE;

//
// Message types that can be sent to DFSSRV.
//

#define DFSSRV_MESSAGE_GET_SITE_NAME         0
#define DFSSRV_MESSAGE_GET_DOMAIN_REFERRAL   1
#define DFSSRV_MESSAGE_GET_SPC_ENTRY         2
#define DFSSRV_MESSAGE_WAKEUP                3

//
// The name of the LPC port the dfs server creates and uses for communication
// with the dfs driver.  This name is included in the connect FSCTL sent to
// the driver so that the driver knows what port to connect to.
//

#define DFS_PORT_NAME_W  L"\\DfsSrvLpcPort"
#define DFS_PORT_NAME_A   "\\DfsSrvLpcPort"

//
// The maximum size of a message that can be sent over the port.
//

#define DFS_PORT_MAX_MESSAGE_LENGTH                                      \
    ( sizeof(DFSSRV_REQUEST_MESSAGE) > sizeof(DFSSRV_REPLY_MESSAGE) ?    \
         sizeof(DFSSRV_REQUEST_MESSAGE) : sizeof(DFSSRV_REPLY_MESSAGE) )


#endif // ndef _DFSSRV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\h\dfsmrshl.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       DfsMrshl.h
//
//  Contents:   Defines for Dfs marshalling routines
//
//  Classes:
//
//  Functions:
//
//  History:    March 29, 1994          Milans Created from Peterco's dfsrtl.h
//
//-----------------------------------------------------------------------------

#ifndef _DFSMRSHL_
#define _DFSMRSHL_

#ifdef __cplusplus
extern "C" {
#endif

#include <stddef.h>
#include <guiddef.h>
//
// MARSHALLING AND UNMARSHALLING SUPPORT
//

#ifdef  KERNEL_MODE
#define MarshalBufferAllocate(x)   ExAllocatePool(PagedPool, x)
#define MarshalBufferFree(x)       ExFreePool(x)
#else
#include <stdlib.h>
#define MarshalBufferAllocate(x)   malloc(x)
#define MarshalBufferFree(x)       free(x)
#endif // KERNEL_MODE

#define DfsAllocate                MarshalBufferAllocate
#define DfsFree                    MarshalBufferFree

//
// Structure used when marshalling and unmarhalling
//
typedef struct _MARSHAL_BUFFER {

    PUCHAR  First;
    PUCHAR  Current;
    PUCHAR  Last;

} MARSHAL_BUFFER, *PMARSHAL_BUFFER;


typedef struct _MARSHAL_TYPE_INFO {

    ULONG _type;                    // the type of item to be marshalled
    ULONG _off;                     // offset of item (in the struct)
    ULONG _cntsize;                 // size of counter for counted array
    ULONG _cntoff;                  // else, offset count item (in the struct)
    struct _MARSHAL_INFO * _subinfo;// if compound type, need info

} MARSHAL_TYPE_INFO, *PMARSHAL_TYPE_INFO;


typedef struct _MARSHAL_INFO {

    ULONG _size;                    // size of item
    ULONG _typecnt;                 // number of type infos
    PMARSHAL_TYPE_INFO _typeInfo;   // type infos

} MARSHAL_INFO, *PMARSHAL_INFO;

#define _mkMarshalInfo(s, i)\
    {(ULONG)sizeof(s),(ULONG)(sizeof(i)/sizeof(MARSHAL_TYPE_INFO)),i}


#define MTYPE_BASE_TYPE             (0x0000ffffL)

#define MTYPE_COMPOUND              (0x00000001L)
#define MTYPE_GUID                  (0x00000002L)
#define MTYPE_STRING                (0x00000003L)
#define MTYPE_UNICODE_STRING        (0x00000004L)
#define MTYPE_ULONG                 (0x00000005L)
#define MTYPE_USHORT                (0x00000006L)
#define MTYPE_PWSTR                 (0x00000007L)
#define MTYPE_UCHAR                 (0x00000008L)
#define MTYPE_CONFORMANT_CNT        (0x00000009L)

#define MTYPE_INDIRECT      (0x80000000L)

#define MTYPE_COMPLEX_TYPE          (0x7fff0000L)

#define MTYPE_STATIC_ARRAY  (0x00010000L)
#define MTYPE_COUNTED_ARRAY (0x00020000L)


#define _MCode_conformant(s,m,c)\
    {MTYPE_CONFORMANT_CNT, sizeof(((s *) 0)->m[0]), sizeof(((s *) 0)->c), offsetof(s,c), 0L}

#define _MCode_Base(t,s,m,i)\
    {t,offsetof(s,m),0L,0L,i}

#define _MCode_struct(s,m,i)\
    _MCode_Base(MTYPE_COMPOUND,s,m,i)
#define _MCode_guid(s,m)\
    _MCode_Base(MTYPE_GUID,s,m,NULL)
#define _MCode_str(s,m)\
    _MCode_Base(MTYPE_STRING,s,m,NULL)
#define _MCode_ustr(s,m)\
    _MCode_Base(MTYPE_UNICODE_STRING,s,m,NULL)
#define _MCode_pwstr(s,m)\
    _MCode_Base(MTYPE_PWSTR,s,m,NULL)
#define _MCode_ul(s,m)\
    _MCode_Base(MTYPE_ULONG,s,m,NULL)
#define _MCode_ush(s,m)\
    _MCode_Base(MTYPE_USHORT,s,m,NULL)
#define _MCode_uch(s,m)\
    _MCode_Base(MTYPE_UCHAR,s,m,NULL)

#define _MCode_pstruct(s,m,i)\
    _MCode_Base(MTYPE_COMPOUND|MTYPE_INDIRECT,s,m,i)
#define _MCode_pguid(s,m)\
    _MCode_Base(MTYPE_GUID|MTYPE_INDIRECT,s,m,NULL)
#define _MCode_pstr(s,m)\
    _MCode_Base(MTYPE_STRING|MTYPE_INDIRECT,s,m,NULL)
#define _MCode_pustr(s,m)\
    _MCode_Base(MTYPE_UNICODE_STRING|MTYPE_INDIRECT,s,m,NULL)
#define _MCode_pul(s,m)\
    _MCode_Base(MTYPE_ULONG|MTYPE_INDIRECT,s,m,NULL)
#define _MCode_push(s,m)\
    _MCode_Base(MTYPE_USHORT|MTYPE_INDIRECT,s,m,NULL)
#define _MCode_puch(s,m)\
    _MCode_Base(MTYPE_UCHAR|MTYPE_INDIRECT,s,m,NULL)

#define _MCode_aStatic(t,s,m,c,i)\
    {t|MTYPE_STATIC_ARRAY,offsetof(s,m),0L,c,i}

#define _MCode_astruct(s,m,c,i)\
    _MCode_aStatic(MTYPE_COMPOUND,s,m,c,i)
#define _MCode_aguid(s,m,c)\
    _MCode_aStatic(MTYPE_GUID,s,m,c,NULL)
#define _MCode_astr(s,m,c)\
    _MCode_aStatic(MTYPE_STRING,s,m,c,NULL)
#define _MCode_austr(s,m,c)\
    _MCode_aStatic(MTYPE_UNICODE_STRING,s,m,c,NULL)
#define _MCode_aul(s,m,c)\
    _MCode_aStatic(MTYPE_ULONG,s,m,c,NULL)
#define _MCode_aush(s,m,c)\
    _MCode_aStatic(MTYPE_USHORT,s,m,c,NULL)
#define _MCode_auch(s,m,c)\
    _MCode_aStatic(MTYPE_UCHAR,s,m,c,NULL)

#define _MCode_pastruct(s,m,c,i)\
    _MCode_aStatic(MTYPE_COMPOUND|MTYPE_INDIRECT,s,m,c,i)
#define _MCode_paguid(s,m,c)\
    _MCode_aStatic(MTYPE_GUID|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pastr(s,m,c)\
    _MCode_aStatic(MTYPE_STRING|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_paustr(s,m,c)\
    _MCode_aStatic(MTYPE_UNICODE_STRING|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_paul(s,m,c)\
    _MCode_aStatic(MTYPE_ULONG|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_paush(s,m,c)\
    _MCode_aStatic(MTYPE_USHORT|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pauch(s,m,c)\
    _MCode_aStatic(MTYPE_UCHAR|MTYPE_INDIRECT,s,m,c,NULL)

#define _MCode_aCounted(t,s,m,c,i) {\
    t|MTYPE_COUNTED_ARRAY,\
    offsetof(s,m),\
    sizeof(((s *)0)->c),\
    offsetof(s,c),\
    i\
    }

#define _MCode_castruct(s,m,c,i)\
    _MCode_aCounted(MTYPE_COMPOUND,s,m,c,i)
#define _MCode_caguid(s,m,c)\
    _MCode_aCounted(MTYPE_GUID,s,m,c,NULL)
#define _MCode_capwstr(s,m,c)\
    _MCode_aCounted(MTYPE_PWSTR,s,m,c,NULL)
#define _MCode_castr(s,m,c)\
    _MCode_aCounted(MTYPE_STRING,s,m,c,NULL)
#define _MCode_caustr(s,m,c)\
    _MCode_aCounted(MTYPE_UNICODE_STRING,s,m,c,NULL)
#define _MCode_caul(s,m,c)\
    _MCode_aCounted(MTYPE_ULONG,s,m,c,NULL)
#define _MCode_caush(s,m,c)\
    _MCode_aCounted(MTYPE_USHORT,s,m,c,NULL)
#define _MCode_cauch(s,m,c)\
    _MCode_aCounted(MTYPE_UCHAR,s,m,c,NULL)

#define _MCode_pcastruct(s,m,c,i)\
    _MCode_aCounted(MTYPE_COMPOUND|MTYPE_INDIRECT,s,m,c,i)
#define _MCode_pcaguid(s,m,c)\
    _MCode_aCounted(MTYPE_GUID|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pcapwstr(s,m,c)\
    _MCode_aCounted(MTYPE_PWSTR|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pcastr(s,m,c)\
    _MCode_aCounted(MTYPE_STRING|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pcaustr(s,m,c)\
    _MCode_aCounted(MTYPE_UNICODE_STRING|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pcaul(s,m,c)\
    _MCode_aCounted(MTYPE_ULONG|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pcaush(s,m,c)\
    _MCode_aCounted(MTYPE_USHORT|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pcauch(s,m,c)\
    _MCode_aCounted(MTYPE_UCHAR|MTYPE_INDIRECT,s,m,c,NULL)



#define MarshalBufferInitialize( MarshalBuffer, BufferLength, Buffer ) {\
    (MarshalBuffer)->First = (PUCHAR)(Buffer);                          \
    (MarshalBuffer)->Current = (PUCHAR)(Buffer);                        \
    (MarshalBuffer)->Last = &(MarshalBuffer)->Current[(BufferLength)];  \
    }


//
// Defines and functions for unmarshalling base types.
// The BYTE masks are perfectly fine and they dont care if
// we are on working on LITTLE_ENDIAN or BIG_ENDIAN etc.
//

#define BYTE_0_MASK 0xFF

#define BYTE_0(Value) (UCHAR)(  (Value)        & BYTE_0_MASK)
#define BYTE_1(Value) (UCHAR)( ((Value) >>  8) & BYTE_0_MASK)
#define BYTE_2(Value) (UCHAR)( ((Value) >> 16) & BYTE_0_MASK)
#define BYTE_3(Value) (UCHAR)( ((Value) >> 24) & BYTE_0_MASK)


#define DfsRtlGetUshort(MarshalBuffer, pValue) (                        \
    ((MarshalBuffer)->Current + sizeof(USHORT) <= (MarshalBuffer)->Last) ?           \
        *(pValue) = (USHORT)((MarshalBuffer)->Current[0]     ) |        \
                            ((MarshalBuffer)->Current[1] << 8),         \
        (MarshalBuffer)->Current += 2,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_DATA_ERROR                                               \
    )

#define DfsRtlPutUshort(MarshalBuffer, pValue) (                        \
    ((MarshalBuffer)->Current + sizeof(USHORT) <= (MarshalBuffer)->Last) ?           \
        (MarshalBuffer)->Current[0] = BYTE_0(*pValue),                  \
        (MarshalBuffer)->Current[1] = BYTE_1(*pValue),                  \
        (MarshalBuffer)->Current += 2,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_BUFFER_TOO_SMALL                                         \
    )

#define DfsRtlGetUlong(MarshalBuffer, pValue) (                         \
    ((MarshalBuffer)->Current + sizeof(ULONG) <= (MarshalBuffer)->Last) ?           \
        *(pValue) = (ULONG) ((MarshalBuffer)->Current[0]      ) |       \
                            ((MarshalBuffer)->Current[1] <<  8) |       \
                            ((MarshalBuffer)->Current[2] << 16) |       \
                            ((MarshalBuffer)->Current[3] << 24),        \
        (MarshalBuffer)->Current += 4,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_DATA_ERROR                                               \
    )

#define DfsRtlPutUlong(MarshalBuffer, pValue) (                         \
    ((MarshalBuffer)->Current + sizeof(ULONG) <= (MarshalBuffer)->Last) ?           \
        (MarshalBuffer)->Current[0] = BYTE_0(*pValue),                  \
        (MarshalBuffer)->Current[1] = BYTE_1(*pValue),                  \
        (MarshalBuffer)->Current[2] = BYTE_2(*pValue),                  \
        (MarshalBuffer)->Current[3] = BYTE_3(*pValue),                  \
        (MarshalBuffer)->Current += 4,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_BUFFER_TOO_SMALL                                         \
    )

#define DfsRtlGetGuid(MarshalBuffer, pValue) (                          \
    ((MarshalBuffer)->Current + 16 <= (MarshalBuffer)->Last) ?          \
        (pValue)->Data1 = (ULONG) ((MarshalBuffer)->Current[0]      ) | \
                                  ((MarshalBuffer)->Current[1] <<  8) | \
                                  ((MarshalBuffer)->Current[2] << 16) | \
                                  ((MarshalBuffer)->Current[3] << 24) , \
        (pValue)->Data2 = (USHORT)((MarshalBuffer)->Current[4]      ) | \
                                  ((MarshalBuffer)->Current[5] <<  8) , \
        (pValue)->Data3 = (USHORT)((MarshalBuffer)->Current[6]      ) | \
                                  ((MarshalBuffer)->Current[7] <<  8) , \
        memcpy((pValue)->Data4, &(MarshalBuffer)->Current[8], 8),       \
        (MarshalBuffer)->Current += 16,                                 \
        STATUS_SUCCESS                                                  \
     :  STATUS_DATA_ERROR                                               \
    )


//
// This routine is being used for DFS_UPD_REFERRAL_BUFFER. These
// routines will continue to be used in the future as well since
// we want to keep the structure of DFS_UPD_REFERRAL_BUFFER well
// defined rather than using the Marshalling routines provided here.
//
#define _PutGuid(cp, pguid)                      \
        cp[0] = BYTE_0((pguid)->Data1),          \
        cp[1] = BYTE_1((pguid)->Data1),          \
        cp[2] = BYTE_2((pguid)->Data1),          \
        cp[3] = BYTE_3((pguid)->Data1),          \
        cp[4] = BYTE_0((pguid)->Data2),          \
        cp[5] = BYTE_1((pguid)->Data2),          \
        cp[6] = BYTE_0((pguid)->Data3),          \
        cp[7] = BYTE_1((pguid)->Data3),          \
        memcpy(&cp[8], (pguid)->Data4, 8)


#define _PutULong(cp, ularg)                    \
        cp[0] = BYTE_0(ularg),                  \
        cp[1] = BYTE_1(ularg),                  \
        cp[2] = BYTE_2(ularg),                  \
        cp[3] = BYTE_3(ularg)


#define _GetULong(cp, ularg)                    \
        ularg = (ULONG) (cp[0])         |       \
                        (cp[1] << 8)    |       \
                        (cp[2] << 16)   |       \
                        (cp[3] << 24)


#define DfsRtlPutGuid(MarshalBuffer, pValue) (                          \
    ((MarshalBuffer)->Current + 16 <= (MarshalBuffer)->Last) ?          \
        (MarshalBuffer)->Current[0] = BYTE_0((pValue)->Data1),          \
        (MarshalBuffer)->Current[1] = BYTE_1((pValue)->Data1),          \
        (MarshalBuffer)->Current[2] = BYTE_2((pValue)->Data1),          \
        (MarshalBuffer)->Current[3] = BYTE_3((pValue)->Data1),          \
        (MarshalBuffer)->Current[4] = BYTE_0((pValue)->Data2),          \
        (MarshalBuffer)->Current[5] = BYTE_1((pValue)->Data2),          \
        (MarshalBuffer)->Current[6] = BYTE_0((pValue)->Data3),          \
        (MarshalBuffer)->Current[7] = BYTE_1((pValue)->Data3),          \
        memcpy(&(MarshalBuffer)->Current[8], (pValue)->Data4, 8),       \
        (MarshalBuffer)->Current += 16,                                 \
        STATUS_SUCCESS                                                  \
     :  STATUS_BUFFER_TOO_SMALL                                         \
    )



#define DfsRtlSizeString(pString, pSize) (                              \
    ((pString)->Length > 0) ? (                                         \
        ((pString)->Buffer != NULL) ?                                   \
            (*(pSize)) += (2 + (pString)->Length),                      \
            STATUS_SUCCESS                                              \
        :   STATUS_DATA_ERROR                                           \
        )                                                               \
    :   ((*(pSize)) += 2,                                               \
        STATUS_SUCCESS)                                                 \
    )

#define DfsRtlSizepwString(pString, pSize) (                            \
        (*pString != NULL) ?                                            \
            (*(pSize)) += ((1 + wcslen(*pString))*sizeof(WCHAR)),       \
            STATUS_SUCCESS                                              \
    :   ((*(pSize)) += 2,                                               \
        STATUS_SUCCESS)                                                 \
    )

#define DfsRtlSizeUnicodeString(pUnicodeString, pSize)                  \
    DfsRtlSizeString(pUnicodeString, pSize)


NTSTATUS
DfsRtlGet(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    IN  PMARSHAL_INFO MarshalInfo,
    OUT PVOID Item
);


NTSTATUS
DfsRtlPut(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    IN  PMARSHAL_INFO MarshalInfo,
    OUT PVOID Item
);


NTSTATUS
DfsRtlSize(
    IN  PMARSHAL_INFO MarshalInfo,
    IN  PVOID Item,
    OUT PULONG Size
);

VOID
DfsRtlUnwindGet(
    IN  PMARSHAL_INFO MarshalInfo,
    IN  PMARSHAL_TYPE_INFO LastTypeInfo,
    IN  PVOID Item
);

//+----------------------------------------------------------------------------
//
//  Macro:      POINTER_TO_OFFSET
//
//  Synopsis:   Some fsctls communicate via buffers that contain "pointers"
//              which are really offsets from the beginning of the buffer.
//              This macro converts the pointers to buffer offsets
//
//  Arguments:  [field] -- The field to fix up.
//              [buffer] -- The beginning of the buffer.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

#define POINTER_TO_OFFSET(field, buffer)  \
    ( ((PCHAR)field) -= ((ULONG_PTR)buffer) )

#ifdef __cplusplus
}
#endif

#endif // _DFSMRSHL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\h\dfsstr.h ===
//+--------------------------------------------------------------------------
// Module Name: Dfsstr.h
//
// Copyright 1985-96, Microsoft Corporation
//
// Contents:    This module is a common place for all strings in DFS.
//
//---------------------------------------------------------------------------

#ifndef _DFSSTRING_H_
#define _DFSSTRING_H_

//
// Display names for use by Dfs related code
//

#define DFS_COMPONENT_NAME      L"Distributed File System"
#define DFS_PROVIDER_NAME       DFS_COMPONENT_NAME

//
// Commonly used strings and characters
//

#define UNICODE_PATH_SEP_STR    L"\\"
#define UNICODE_PATH_SEP        L'\\'
#define UNICODE_DRIVE_SEP_STR   L":"
#define UNICODE_DRIVE_SEP       L':'


//
// Registry key and value names for storing Dfs volume information
//

#define DFSHOST_DIR             L"SOFTWARE\\Microsoft\\DfsHost"
#define VOLUMES_DIR             DFSHOST_DIR L"\\volumes\\"
#define REBOOT_KEY              DFSHOST_DIR L"\\Reboot\\"
#define CHANGE_LOG_DIR          DFSHOST_DIR L"\\ChangeLog\\"
#define REG_VALUE_REBOOT        L"RebootNow"
#define LDAP_VOLUMES_DIR        L"\\"
#define DOMAIN_ROOT_VOL         L"domainroot"
#define SITE_ROOT               L"siteroot"
#define ROOT_SHARE_VALUE_NAME   L"RootShare"
#define FTDFS_VALUE_NAME        L"FTDfs"
#define FTDFS_DN_VALUE_NAME     L"FTDfsObjectDN"
#define CHANGE_ID_VALUE_NAME    L"ChangeId"
#define MAX_CHANGES_VALUE_NAME  L"MaxChanges"
#define NUM_CHANGES_VALUE_NAME  L"NumberOfChanges"
#define MACHINE_VALUE_NAME      L"LastMachineName"
#define CLUSTER_VALUE_NAME      L"MachineName"
#define DOMAIN_VALUE_NAME       L"LastDomainName"
#define CHANGES_KEY_NAME        L"Changes"
#define SITE_VALUE_NAME         L"SiteTable"

//
// Registry name for timeouts
//
#define SYNC_INTERVAL_NAME      L"SyncIntervalInSeconds"
#define DCLOCK_INTERVAL_NAME    L"DcLockIntervalInSeconds"

//
// The share to connect with to get a referral
//

#define ROOT_SHARE_NAME         L"\\IPC$"
#define ROOT_SHARE_NAME_NOBS    L"IPC$"

//
// Names of driver created objects
//

#define DFS_DEVICE_DIR          L"\\Device\\WinDfs"
#define ORG_NAME                L"Root"
#define DFS_DEVICE_ROOT         L"\\Device\\WinDfs\\Root"
#define DFS_DEVICE_ORG          DFS_DEVICE_ROOT

//
// The share name used to identify UNC access to a Dfs name
//

#define DFS_SHARENAME           L"\\DFS"
#define DFS_SHARENAME_NOBS      L"DFS"

//
// Registry key and value names for storing local volume information
//

#define REG_KEY_DFSDRIVER       L"SYSTEM\\CurrentControlSet\\Services\\DfsDriver"
#define REG_KEY_DFSSVC          L"SYSTEM\\CurrentControlSet\\Services\\Dfs"
#define REG_KEY_LOCAL_VOLUMES   REG_KEY_DFSDRIVER L"\\LocalVolumes"
#define REG_VALUE_ENTRY_PATH    L"EntryPath"
#define REG_VALUE_SHORT_PATH    L"ShortEntryPath"
#define REG_VALUE_ENTRY_TYPE    L"EntryType"
#define REG_VALUE_STORAGE_ID    L"StorageId"
#define REG_VALUE_SHARE_NAME    L"ShareName"
#define REG_VALUE_TIMETOLIVE    L"TimeToLiveInSecs"
#define REG_VALUE_VERBOSE       L"DfsSvcVerbose"
#define REG_VALUE_LDAP          L"DfsSvcLdap"
#define REG_VALUE_DFSDNSCONFIG  L"DfsDnsConfig"
#define REG_VALUE_IDFSVOL       L"IDfsVolInfoLevel"
#define REG_VALUE_DFSSVC        L"DfsSvcInfoLevel"
#define REG_VALUE_DFSIPC        L"DfsIpcInfoLevel"


//
// Registry key and value name for retrieving list of trusted domain names
//

#define REG_KEY_TRUSTED_DOMAINS  L"SYSTEM\\CurrentControlSet\\Services\\NetLogon\\Parameters"
#define REG_VALUE_TRUSTED_DOMAINS L"TrustedDomainList"

//
// Registry key to enable domain dfs
//

#define REG_KEY_ENABLE_DOMAIN_DFS L"SYSTEM\\CurrentControlSet\\Control\\EnableDomainDfs"

//
// Registry keys for event logging verbosity
//

#define REG_KEY_EVENTLOG L"SOFTWARE\\MicroSoft\\Windows NT\\CurrentVersion\\Diagnostics"

#define REG_VALUE_EVENTLOG_GLOBAL   L"RunDiagnosticLoggingGlobal"
#define REG_VALUE_EVENTLOG_DFS      L"RunDiagnosticLoggingDfs"

//
// The following two are related and must be kept in sync. One is the name
// of the named pipe as used by user-level processes. The second names the
// same pipe for kernel-mode code.
//

#define DFS_MESSAGE_PIPE        L"\\\\.\\pipe\\DfsSvcMessage"
#define DFS_KERNEL_MESSAGE_PIPE L"\\Device\\NamedPipe\\DfsSvcMessage"


#endif //_DFSSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\h\lmerrext.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       lmerrext.h
//
//  Contents:   Dfs NET_API_STATUS codes until they let me check in to lmerr.h
//              proper.
//
//  Classes:
//
//  Functions:
//
//  History:    July 17, 1996           Milans created
//              Feb 17, 1999            Updated lmerr.h
//
//-----------------------------------------------------------------------------

#ifndef DFS_RESTORE_VOLUME
#define DFS_RESTORE_VOLUME      2
#endif // DFS_RESTORE_VOLUME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\h\libsup.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:   dfslib.h
//
//  Contents:
//
//  Functions:
//
//  History:     27 May 1992 PeterCo Created.
//
//-----------------------------------------------------------------------------


#ifdef ExAllocatePool
#undef ExAllocatePool
#endif

#define ExAllocatePool(pool, size)  malloc(size)
#define ExAllocatePoolWithTag(pool, size, tag)  malloc(size)

#if defined ExFreePool
#undef ExFreePool
#endif
#define ExFreePool(ptr)             free(ptr)

#define ExRaiseStatus(sts)          RtlRaiseStatus(sts)

#ifdef DebugTrace
#undef DebugTrace
#endif
#define DebugTrace(a, b, c, d)

#define ZwCreateFile            NtCreateFile
#define ZwOpenFile              NtOpenFile
#define ZwFlushVirtualMemory    NtFlushVirtualMemory
#define ZwSetInformationFile    NtSetInformationFile
#define ZwQueryInformationFile  NtQueryInformationFile
#define ZwCreateSection         NtCreateSection
#define ZwClose                 NtClose
#define ZwQuerySection          NtQuerySection
#define ZwMapViewOfSection      NtMapViewOfSection
#define ZwUnmapViewOfSection    NtUnmapViewOfSection
#define ZwReadFile              NtReadFile
#define ZwWriteFile             NtWriteFile

#define try_return(S) { S; goto try_exit; }

//
// These are from io.h
//
#define close _close
#define creat _creat
#define write _write
int _close(int);
int _creat(const char *, int);
int _write(int, const void *, unsigned int);

NTSTATUS
DfsOpen(
    IN  OUT PHANDLE DfsHandle,
    IN      PUNICODE_STRING DfsName
    );

NTSTATUS
DfsFsctl(
    IN  HANDLE DfsHandle,
    IN  ULONG FsControlCode,
    IN  PVOID InputBuffer OPTIONAL,
    IN  ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN  ULONG OutputBufferLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\h\ntext.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       ntext.h
//
//  Contents:   Missing NT Function prototypes.
//
//  Classes:
//
//  Functions:  ZwFsControlFile
//
//  History:    12-28-95        Milans Created
//
//-----------------------------------------------------------------------------

#ifndef _NT_EXT_
#define _NT_EXT_

#ifdef KERNEL_MODE

NTSYSAPI
NTSTATUS
NTAPI
ZwFsControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FsControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength);

#else // !KERNEL_MODE

NTSYSAPI
NTSTATUS
NTAPI
NtClose(
    IN HANDLE Handle);

NTSYSAPI
VOID
NTAPI
RtlRaiseStatus (
    IN NTSTATUS Status);

#endif // KERNEL_MODE

#endif // _NT_EXT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\h\nodetype.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       NODETYPE.H
//
//  Contents:
//      This module defines all of the node type codes used in this development
//      shell.  Every major data structure in the file system is assigned a
//      node type code.  This code is the first CSHORT in the structure and is
//      followed by a CSHORT containing the size, in bytes, of the structure.
//
//  Functions:
//
//  History:    12 Nov 1991     AlanW   Created from CDFS souce.
//               8 May 1992     PeterCo Removed all EP related stuff.
//                                      Added PKT related stuff.
//
//-----------------------------------------------------------------------------


#ifndef _NODETYPE_
#define _NODETYPE_

typedef CSHORT NODE_TYPE_CODE, *PNODE_TYPE_CODE;

#define NTC_UNDEFINED                   ((NODE_TYPE_CODE)0x0000)

#define DFS_NTC_DATA_HEADER            ((NODE_TYPE_CODE)0x0D01)
#define DFS_NTC_IRP_CONTEXT            ((NODE_TYPE_CODE)0x0D02)
#define DFS_NTC_REFERRAL               ((NODE_TYPE_CODE)0x0D03)
#define DFS_NTC_VCB                    ((NODE_TYPE_CODE)0x0D04)
#define DFS_NTC_PROVIDER               ((NODE_TYPE_CODE)0x0D05)
#define DFS_NTC_FCB_HASH               ((NODE_TYPE_CODE)0x0D06)
#define DFS_NTC_FCB                    ((NODE_TYPE_CODE)0x0D07)
#define DFS_NTC_DNR_CONTEXT            ((NODE_TYPE_CODE)0x0D08)
#define DFS_NTC_PKT                    ((NODE_TYPE_CODE)0x0D09)
#define DFS_NTC_PKT_ENTRY              ((NODE_TYPE_CODE)0x0D0A)
#define DFS_NTC_SITE_HASH              ((NODE_TYPE_CODE)0x0D0B)
#define DFS_NTC_INSTRUM                ((NODE_TYPE_CODE)0x0D0C)
#define DFS_NTC_INSTRUM_FREED          ((NODE_TYPE_CODE)0x0D0D)
#define DFS_NTC_PWSTR                  ((NODE_TYPE_CODE)0x0D0E)
#define DFS_NTC_SITE_INFO              ((NODE_TYPE_CODE)0x0D0F)
#define DFS_NTC_IP_INFO                ((NODE_TYPE_CODE)0x0D11)
#define DFS_NTC_IP_HASH                ((NODE_TYPE_CODE)0x0D12)
#define DFS_NTC_SPECIAL_INFO           ((NODE_TYPE_CODE)0x0D13)
#define DFS_NTC_SPECIAL_HASH           ((NODE_TYPE_CODE)0x0D14)

typedef CSHORT NODE_BYTE_SIZE, *PNODE_BYTE_SIZE;

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//          :
//  } RECORD_NAME;
//  typedef RECORD_NAME *PRECORD_NAME;
//

#define NodeType(Ptr) (*((NODE_TYPE_CODE UNALIGNED *)(Ptr)))
#define NodeSize(Ptr) (*(((PNODE_BYTE_SIZE)(Ptr))+1))

#endif // _NODETYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\h\prefix.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       prefix.hxx
//
//  Contents:   PREFIX table definition
//
//  History:    SethuR -- Implemented
//
//  Notes:      The DFS prefix table data structure consists of three
//              entities and methods to manipulate them. They are the
//              DFS_PREFIX_TABLE_ENTRY,DFS_PREFIX_TABLE_BUCKET and the
//              DFS_PREFIX_TABLE.
//
//              The DFS_PREFIX_TABLE is a hash table of DFS_PREFIX_TABLE_ENTRY's
//              wherein collisions are resolved through linear chaining. The
//              hash table is organized as an array of collision lists
//              (DFS_PREFIX_TABLE_BUCKET). A brief description with each of
//              these entities is attached to the declaration.
//
//              There are certain characterstics that distinguish this
//              hash table from other hash tables. These are the extensions
//              provided to accomodate the special operations.
//
//--------------------------------------------------------------------------

#ifndef __PREFIX_HXX__
#define __PREFIX_HXX__

//+---------------------------------------------------------------------
//
// Struct:  DFS_PREFIX_TABLE_ENTRY
//
// History:
//
// Notes:   Each DFS_PREFIX_TABLE entry is in reality a member of two linked
//          lists -- a doubly linked list chaining the entries in a bucket
//          and a singly linked list establishing the path from any entry to
//          the root of the name space. In addition we have the data associated
//          with each entry, viz., the name and the data (pData). We also
//          keep track of the number of children of each entry. It can also
//          be defined as the number of paths to the root of which this entry
//          is a member.
//
//----------------------------------------------------------------------

typedef struct _DFS_PREFIX_TABLE_ENTRY_
{
   struct _DFS_PREFIX_TABLE_ENTRY_  *pParentEntry;
   struct _DFS_PREFIX_TABLE_ENTRY_  *pNextEntry;
   struct _DFS_PREFIX_TABLE_ENTRY_  *pPrevEntry;

   //
   // pFirstChildEntry and pSiblingEntry are used purely for enumeration
   //
   struct _DFS_PREFIX_TABLE_ENTRY_  *pFirstChildEntry;
   struct _DFS_PREFIX_TABLE_ENTRY_  *pSiblingEntry;

   ULONG                             NoOfChildren;

   UNICODE_STRING                    PathSegment;
   PVOID                             pData;
} DFS_PREFIX_TABLE_ENTRY, *PDFS_PREFIX_TABLE_ENTRY;

//+---------------------------------------------------------------------
//
// Struct:  DFS_PREFIX_TABLE_BUCKET
//
// History:
//
// Notes:   The DFS_PREFIX_TABLE_BUCKET is a doubly linked list of
//          DFS_PREFIX_TABLE_ENTRY's. The current implementation employs
//          the notion of a sentinel entry associated with each bucket. The
//          end pointers are never null but are always looped back to the
//          sentinel entry. The reason we employ such an organization is that
//          it considerably simplifies the list manipulation routines. The
//          reason this needs to be a doubly linked list is that we would like
//          to have the ability of deleting entries without having to traverse
//          the buckets from beginning.
//
//          The following inline methods ( macro defns. ) are provided for
//          inserting, deleting and looking up an entry in the bucket.
//
//----------------------------------------------------------------------

typedef struct _PREFIX_TABLE_BUCKET_
{
   ULONG                  NoOfEntries;   // High water mark for entries hashing to the bkt.
   DFS_PREFIX_TABLE_ENTRY SentinelEntry;
} PREFIX_TABLE_BUCKET, *PPREFIX_TABLE_BUCKET;

//+---------------------------------------------------------------------
//
// Struct:  NAME_PAGE
//
// History:
//
// Notes:   The name segments associated with the various entries are all
//          stored together in a name page. This allows us to amortize the
//          memory allocation costs over a number of entries and also allows
//          us to speed up traversal ( for details see DFS_PREFIX_TABLE
//          definition ).
//
//----------------------------------------------------------------------

#define FREESPACE_IN_NAME_PAGE ((PAGE_SIZE - sizeof(ULONG) - sizeof(PVOID)) / sizeof(WCHAR))

typedef struct _NAME_PAGE_
{
   struct _NAME_PAGE_  *pNextPage;
   LONG                cFreeSpace; // free space avilable in WCHAR's
   WCHAR               Names[FREESPACE_IN_NAME_PAGE];
} NAME_PAGE, *PNAME_PAGE;

typedef struct _NAME_PAGE_LIST_
{
   PNAME_PAGE  pFirstPage;
} NAME_PAGE_LIST, *PNAME_PAGE_LIST;

//+---------------------------------------------------------------------
//
// Struct:  DFS_PREFIX_TABLE
//
// History:
//
// Notes:   The DFS_PREFIX_TABLE is a hashed collection of DFS_PREFIX_TABLE_ENTRY
//          organized in the form of buckets. In addition one other space
//          conserving measure is adopted. There is only one copy of each
//          name segment stored in the table. As an example consider the
//          two pathnames \foo\bar and \bar\foo. We only store one copy of foo
//          and bar eventhough we accomdate both these paths. A beneficial
//          side effect of storing single copies is that our traversal of the
//          collision chain is considerably speeded up since once we have
//          located the pointer to the name, subsequent comparisons need merely
//          compare pointers as opposed to strings.
//
//----------------------------------------------------------------------

#define NO_OF_HASH_BUCKETS 57

typedef struct _DFS_PREFIX_TABLE
{
   BOOLEAN             CaseSensitive;
   NAME_PAGE_LIST      NamePageList;
   //
   // NextEntry is used purely for enumeration
   //
   PDFS_PREFIX_TABLE_ENTRY NextEntry;
   DFS_PREFIX_TABLE_ENTRY RootEntry;
   PREFIX_TABLE_BUCKET Buckets[NO_OF_HASH_BUCKETS];

#ifdef KERNEL_MODE

   // Zone for allocating DFS_PREFIX_TABLE entries .....

   ZONE_HEADER         PrefixTableEntryZone;

#else

   // A DFS_PREFIX_TABLE is part of DS_DATA. We need to make the sizes of
   // these structures identical in user and kernel mode, so that user-mode
   // utilities like dfsdump can work.

   CHAR                UnusedBuffer[sizeof(ZONE_HEADER)];

#endif
} DFS_PREFIX_TABLE, *PDFS_PREFIX_TABLE;

//+---------------------------------------------------------------------
//
// Struct:  DFS_PREFIX_TABLE API.
//
// History:
//
// Notes:   The following API's are provided for manipulating the
//          DFS_PREFIX_TABLE.
//
//----------------------------------------------------------------------

extern
NTSTATUS DfsInitializePrefixTable(PDFS_PREFIX_TABLE pTable,
                                  BOOLEAN           fCaseSensitive);

extern
NTSTATUS DfsFreePrefixTable(PDFS_PREFIX_TABLE pTable);

extern
NTSTATUS DfsInsertInPrefixTable(PDFS_PREFIX_TABLE pTable,
                                PUNICODE_STRING   pPath,
                                PVOID             pData);
extern
NTSTATUS DfsLookupPrefixTable(PDFS_PREFIX_TABLE   pTable,
                              PUNICODE_STRING     pPath,
                              PUNICODE_STRING     pSuffix,
                              PVOID               *ppData);

extern
NTSTATUS DfsRemoveFromPrefixTable(PDFS_PREFIX_TABLE pTable,
                                  PUNICODE_STRING pPath);

//
// The RTL Prefix Table function signatures are slightly different.
// For now we will define a mapping between them to ease the porting
// effort. Subsequently we will change our signatures to confirm to
// the RTL routine.
//

#define DfsInitializeUnicodePrefix(pTable) \
        (DfsInitializePrefixTable(pTable,FALSE) == STATUS_SUCCESS)

#define DfsRemoveUnicodePrefix(pTable,pPath)  \
        (DfsRemoveFromPrefixTable(pTable,pPath) == STATUS_SUCCESS)

#define DfsInsertUnicodePrefix(pTable,pPath,pData) \
        (DfsInsertInPrefixTable(pTable,pPath,pData) == STATUS_SUCCESS)

PVOID    DfsFindUnicodePrefix(PDFS_PREFIX_TABLE   pTable,
                              PUNICODE_STRING     pPath,
                              PUNICODE_STRING     pSuffix);

PVOID   DfsNextUnicodePrefix(PDFS_PREFIX_TABLE    pTable,
                             BOOLEAN              fRestart);

PVOID   DfsNextUnicodePrefixChild(PDFS_PREFIX_TABLE pTable,
                                  PUNICODE_STRING   pPath,
                                  PVOID             *ppCookie);

#endif // __PREFIX_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\h\upkt.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       UPKT.H
//
//  Contents:   This module defines the prototypes for user mode access
//              to the local partition knowledge table (PKT).
//
//  Functions:
//
//  History:    alanw   21 Sep 1992     Added prototypes from dotdfs.h.
//
//-----------------------------------------------------------------------------


#ifndef _UPKT_
#define _UPKT_

#ifdef __cplusplus
extern "C" {
#endif

#include "pkt.h"

NTSTATUS
PktOpen(
    IN  OUT PHANDLE PktHandle,
    IN      ACCESS_MASK DesiredAccess,
    IN      ULONG ShareAccess,
    IN      PUNICODE_STRING DfsNtPathName OPTIONAL
    );

VOID
PktClose(
    IN      HANDLE PktHandle
    );

NTSTATUS
PktCreateEntry(
    IN      HANDLE PktHandle,
    IN      ULONG EntryType,
    IN      PDFS_PKT_ENTRY_ID EntryId,
    IN      PDFS_PKT_ENTRY_INFO EntryInfo OPTIONAL,
    IN      ULONG CreateDisposition
    );

NTSTATUS
PktCreateSubordinateEntry(
    IN      HANDLE PktHandle,
    IN      PDFS_PKT_ENTRY_ID SuperiorId,
    IN      ULONG SubordinateType,
    IN      PDFS_PKT_ENTRY_ID SubordinateId,
    IN      PDFS_PKT_ENTRY_INFO SubordinateInfo OPTIONAL,
    IN      ULONG CreateDisposition
    );

NTSTATUS
PktDestroyEntry(
    IN      HANDLE PktHandle,
    IN      DFS_PKT_ENTRY_ID victim
    );

NTSTATUS
PktGetRelationInfo(
    IN      HANDLE PktHandle,
    IN      PDFS_PKT_ENTRY_ID   EntryId,
    IN OUT  PDFS_PKT_RELATION_INFO      relationInfo
    );

NTSTATUS
PktValidateLocalVolumeInfo(
    IN      PDFS_PKT_RELATION_INFO relationInfo);

NTSTATUS
PktPruneLocalPartition(
    IN      PDFS_PKT_ENTRY_ID EntryId);

NTSTATUS
PktIsChildnameLegal(
    IN      PWCHAR pwszParent,
    IN      PWCHAR pwszChild,
    IN      GUID   *pidChild
    );

NTSTATUS
PktGetEntryType(
    IN      PWSTR pwszPrefix,
    IN      PULONG pType);

NTSTATUS
DfsDeleteLocalPartition(
    IN      const PDFS_PKT_ENTRY_ID VolumeId);

NTSTATUS
DfsDCSetVolumeState(
    IN      const PDFS_PKT_ENTRY_ID VolumeId,
    IN      const ULONG State);

NTSTATUS
DfsSetVolumeTimeout(
    IN      const PDFS_PKT_ENTRY_ID VolumeId,
    IN      const ULONG State);

NTSTATUS
DfsSetServiceState(
    IN      PDFS_PKT_ENTRY_ID VolumeId,
    IN      PWSTR ServiceName,
    IN      ULONG State);

NTSTATUS
DfsSetServerInfo(
    IN PDFS_PKT_ENTRY_ID pId,
    IN PUNICODE_STRING DfsNtPathName
    );

NTSTATUS
DfsCheckStgIdInUse(
    IN      PDFS_PKT_ENTRY_ID pEntryId
    );

NTSTATUS
DfsCreateSiteEntry(
    IN      PCHAR Arg,
    IN      ULONG size
    );

NTSTATUS
DfsDeleteSiteEntry(
    IN      PCHAR Arg,
    IN      ULONG size
    );

#ifdef __cplusplus
}
#endif

#endif //_UPKT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\h\pkt.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       PKT.H
//
//  Contents:   This module defines the data structures that make up the
//              major internal part of the Partition Knowledge Table (PKT).
//              The Partition Knowledge Table is used by the Dfs file
//              system to resolve a name to a specific partition (volume).
//
//  Functions:
//
//  History:    1 May 1992  PeterCo Created.
//-----------------------------------------------------------------------------



#ifndef _PKT_
#define _PKT_

//
// Pick up marshalling info for gluons
//

#include "dfsgluon.h"

//
// New Prefix Table Implementation
//
#include "prefix.h"

//
//  For determining the status of the Uid
//
#define GuidEqual(g1, g2)\
    (RtlCompareMemory((g1), (g2), sizeof(GUID)) == sizeof(GUID))

extern GUID _TheNullGuid;

#define NullGuid( guid )\
    (GuidEqual(guid, &_TheNullGuid))

#define DEFAULT_PKT_ENTRY_TIMEOUT 300



//
//  Defines for Create Dispositions (we mimic the io system here).
//

#define PKT_ENTRY_CREATE            FILE_CREATE
#define PKT_ENTRY_REPLACE           FILE_OPEN
#define PKT_ENTRY_SUPERSEDE         FILE_SUPERSEDE

//
//  Different kind of referrals that a DC can give out.
//

#define DFS_STORAGE_REFERRAL                    (0x0001)
#define DFS_REFERRAL_REFERRAL                   (0x0002)

//
//  Types of service that can be supported by a provider.
//  A disjunction of any of the following values.
//

#define DFS_SERVICE_TYPE_MASTER                 (0x0001)
#define DFS_SERVICE_TYPE_READONLY               (0x0002)
#define DFS_SERVICE_TYPE_LOCAL                  (0x0004)
#define DFS_SERVICE_TYPE_REFERRAL               (0x0008)
#define DFS_SERVICE_TYPE_ACTIVE                 (0x0010)
#define DFS_SERVICE_TYPE_DOWN_LEVEL             (0x0020)
#define DFS_SERVICE_TYPE_COSTLIER               (0x0040)
#define DFS_SERVICE_TYPE_OFFLINE                (0x0080)

//
//  The status possibilities...
//

#define DFS_SERVICE_STATUS_VERIFIED     (0x0001)
#define DFS_SERVICE_STATUS_UNVERIFIED   (0x0002)

//
//  Types of Partition Knowledge Table Entries.
//  Low-order bits in these definitions correspond to volume object
//  types as defined in dfsh.idl.  High-order bits are specific
//  to PKT entries.
//

#define PKT_ENTRY_TYPE_CAIRO            0x0001   // Entry refers to Cairo srv
#define PKT_ENTRY_TYPE_MACHINE          0x0002   // Entry is a machine volume
#define PKT_ENTRY_TYPE_NONCAIRO         0x0004   // Entry refers to downlevel
#define PKT_ENTRY_TYPE_LEAFONLY         0x0008
#define PKT_ENTRY_TYPE_OUTSIDE_MY_DOM   0x0010   // Entry refers to volume in
                                                 // foreign domain
#define PKT_ENTRY_TYPE_INSITE_ONLY      0x0020   // Only give insite referrals.
#define PKT_ENTRY_TYPE_REFERRAL_SVC     0x0080   // Entry refers to a DC

#define PKT_ENTRY_TYPE_PERMANENT        0x0100   // Entry cannot be scavenged
#define PKT_ENTRY_TYPE_LOCAL            0x0400   // Entry refers to local vol
#define PKT_ENTRY_TYPE_LOCAL_XPOINT     0x0800   // Entry refers to exit pt
#define PKT_ENTRY_TYPE_MACH_SHARE       0x1000   // Entry refers to a private
                                                 // machine share
#define PKT_ENTRY_TYPE_OFFLINE          0x2000   // Entry refers to a volume
                                                 // that is offline
#define PKT_ENTRY_TYPE_STALE            0x4000   // Entry is stale

#define PKT_ENTRY_TYPE_INHERIT_MASK     PKT_ENTRY_TYPE_INSITE_ONLY
//
// Type of messages the driver can send to DfsManager / DfsService
//

#define DFS_MSGTYPE_KNOW_INCONSISTENCY  0x0001
#define DFS_MSGTYPE_GET_DOMAIN_REFERRAL 0x0002
#if (DBG == 1) || (_CT_TEST_HOOK == 1)
    #define DFS_MSGTYPE_SET_RECOVERY_BREAK_POINT    0x0003
#endif


//
//  There is one DFS_MACHINE_ENTRY for every unique DS_MACHINE that the
//  Dfs driver knows about. If a particular cairo server services multiple Dfs
//  volumes, then multiple DFS_SERVICE structs will point to a single, ref
//  counted DFS_MACHINE_ENTRY.
//

typedef struct DFS_MACHINE_ENTRY {

    PDS_MACHINE         pMachine;       // The addressing info is here.
    UNICODE_STRING      MachineName;    // The MachineName (principalName).
    ULONG               UseCount;       // Number of DFS_SVC structs using this
    ULONG               ConnectionCount;// The number of pkt entries that are
                                        // using this as their active machine
    UNICODE_PREFIX_TABLE_ENTRY  PrefixTableEntry;

} DFS_MACHINE_ENTRY, *PDFS_MACHINE_ENTRY;

//
// Marshalling info for DFS_MACHINE_ENTRY
//

extern MARSHAL_INFO MiMachineEntry;

#define INIT_DFS_MACHINE_ENTRY_MARSHAL_INFO()                               \
    static MARSHAL_TYPE_INFO _MCode_Machine_Entry[] = {                     \
        _MCode_pstruct(DFS_MACHINE_ENTRY, pMachine, &MiDSMachine)           \
    };                                                                      \
    MARSHAL_INFO MiMachineEntry = _mkMarshalInfo(DFS_SERVICE, _MCode_Machine_Entry);


//
//  A DFS_SERVICE structure is used to describe the provider and
//  network address to be contacted for a specific partition of
//  the distributed file system.
//

typedef struct _DFS_SERVICE {

    ULONG Type;             // type of service (see above)
    ULONG Capability;       // capability of this service
    ULONG Status;           // current status
    ULONG ProviderId;       // identifies which provider
    UNICODE_STRING Name;    // service name (for authentication)
    PFILE_OBJECT ConnFile;  // pointer to tree conn. file if active connection
    struct _PROVIDER_DEF* pProvider;    // pointer to provider definition
    UNICODE_STRING Address; // network address
    UNICODE_STRING StgId;   // The local storage id on the server.
    PDFS_MACHINE_ENTRY  pMachEntry;  // The addressing info is here.
    ULONG Cost;             // The site based cost of this service.

} DFS_SERVICE, *PDFS_SERVICE;

//
//  Marshalling information for DFS_SERVICE
//
//  NOTE:       ConnFile and pProvider have significance only to the driver and
//              are not marshalled.
//
extern MARSHAL_INFO MiService;

#define INIT_DFS_SERVICE_MARSHAL_INFO()                                     \
    static MARSHAL_TYPE_INFO _MCode_Service[] = {                           \
        _MCode_ul(DFS_SERVICE, Type),                                       \
        _MCode_ul(DFS_SERVICE, Capability),                                 \
        _MCode_ul(DFS_SERVICE, Status),                                     \
        _MCode_ul(DFS_SERVICE, ProviderId),                                 \
        _MCode_ustr(DFS_SERVICE, Name),                                     \
        _MCode_ustr(DFS_SERVICE, Address),                                  \
        _MCode_ustr(DFS_SERVICE, StgId),                                    \
        _MCode_pstruct(DFS_SERVICE, pMachEntry, &MiMachineEntry)            \
    };                                                                      \
    MARSHAL_INFO MiService = _mkMarshalInfo(DFS_SERVICE, _MCode_Service);


//
//  Structure used in FSCTL_DFS_UPDATE_MACH_ADDRESS
//

typedef struct _DFS_MACHINE_INFO        {

    UNICODE_STRING      MachineName;    // Name of Machine (prefix alone).
    PDS_MACHINE         pMachine;       // The new addressing info is here

} DFS_MACHINE_INFO, *PDFS_MACHINE_INFO;

//
// Marshalling info for DFS_MACHINE_INFO
//

extern MARSHAL_INFO MiDfsMachineInfo;

#define INIT_DFS_MACHINE_INFO()                                         \
    static MARSHAL_TYPE_INFO _MCode_MachineInfo[] = {                   \
        _MCode_ustr(DFS_MACHINE_INFO, MachineName),                     \
        _MCode_pstruct(DFS_MACHINE_INFO, pMachine, &MiDSMachine)        \
    };                                                                  \
    MARSHAL_INFO MiDfsMachineInfo =                                     \
                _mkMarshalInfo(DFS_MACHINE_INFO, _MCode_MachineInfo);



//
//  How a partition table entry is identified.
//
typedef struct _DFS_PKT_ENTRY_ID {

    GUID Uid;               // a unique identifier for this partition
    UNICODE_STRING Prefix;  //  The entry path prefix of this partition
    UNICODE_STRING ShortPrefix; // 8.3 version of entry path

} DFS_PKT_ENTRY_ID, *PDFS_PKT_ENTRY_ID;

//
// Marshalling information for DFS_PKT_ENTRY_ID
//
extern MARSHAL_INFO MiPktEntryId;

#define INIT_DFS_PKT_ENTRY_ID_MARSHAL_INFO()                                \
    static MARSHAL_TYPE_INFO _MCode_PktEntryId[] = {                        \
        _MCode_guid(DFS_PKT_ENTRY_ID, Uid),                                 \
        _MCode_ustr(DFS_PKT_ENTRY_ID, Prefix),                              \
        _MCode_ustr(DFS_PKT_ENTRY_ID, ShortPrefix)                          \
    };                                                                      \
    MARSHAL_INFO MiPktEntryId =                                             \
        _mkMarshalInfo(DFS_PKT_ENTRY_ID, _MCode_PktEntryId);


//
//  The DfsCreate/DeleteExitPoint FSCTRLs arguments are passed through
//  following structure.
//
typedef struct _DFS_EXIT_POINT_ARG {

    DFS_PKT_ENTRY_ID    Id;
    ULONG               Type;

} DFS_EXIT_POINT_ARG, *PDFS_EXIT_POINT_ARG;

//
// Marshalling information for DFS_EXIT_POINT_ARG
//
extern MARSHAL_INFO MiExitPointArg;

#define INIT_DFS_EXIT_POINT_ARG_MARSHAL_INFO()                  \
    static MARSHAL_TYPE_INFO _MCode_ExitPointArg[] = {          \
        _MCode_struct(DFS_EXIT_POINT_ARG, Id, &MiPktEntryId),   \
        _MCode_ul(DFS_EXIT_POINT_ARG, Type)                     \
    };                                                          \
    MARSHAL_INFO MiExitPointArg =                               \
        _mkMarshalInfo(DFS_EXIT_POINT_ARG, _MCode_ExitPointArg);

//
// The DfsSetVolumeState FSCTRLs arguments are passed through the following
// structure
//

typedef DFS_EXIT_POINT_ARG      DFS_SETSTATE_ARG;

#define MiSetStateArg           MiExitPointArg


//
//  The DfsSetVolumeTimeout FSCTRLs arguments are passed through
//  following structure.
//
typedef struct _DFS_SET_VOLUME_TIMEOUT_ARG {

    DFS_PKT_ENTRY_ID    Id;
    ULONG               Timeout;

} DFS_SET_VOLUME_TIMEOUT_ARG, *PDFS_SET_VOLUME_TIMEOUT_ARG;

//
// Marshalling information for DFS_SET_VOLUME_TIMEOUT_ARG
//
extern MARSHAL_INFO MiSetVolTimeoutArg;

#define INIT_DFS_SET_VOLUME_TIMEOUT_ARG_MARSHAL_INFO()                      \
    static MARSHAL_TYPE_INFO _MCode_SetVolTimeoutArg[] = {                  \
        _MCode_struct(DFS_SET_VOLUME_TIMEOUT_ARG, Id, &MiPktEntryId),       \
        _MCode_ul(DFS_SET_VOLUME_TIMEOUT_ARG, Timeout)                      \
    };                                                                      \
    MARSHAL_INFO MiSetVolTimeoutArg =                                       \
        _mkMarshalInfo(DFS_SET_VOLUME_TIMEOUT_ARG, _MCode_SetVolTimeoutArg);



//
//  The DfsSetServiceState FSCTRLs arguments are passed through the following
//  structure
//

typedef struct _DFS_DC_SET_SERVICE_STATE {

    DFS_PKT_ENTRY_ID    Id;
    UNICODE_STRING      ServiceName;
    ULONG               State;

} DFS_DC_SET_SERVICE_STATE, *PDFS_DC_SET_SERVICE_STATE;

//
// Marshalling information for DFS_DC_SET_SERVICE_STATE
//

extern MARSHAL_INFO MiDCSetServiceState;

#define INIT_DFS_DC_SET_SERVICE_STATE_MARSHAL_INFO()                        \
    static MARSHAL_TYPE_INFO _MCode_DfsDCSetServiceState[] = {              \
        _MCode_struct(DFS_DC_SET_SERVICE_STATE, Id, &MiPktEntryId),         \
        _MCode_ustr(DFS_DC_SET_SERVICE_STATE, ServiceName),                 \
        _MCode_ul(DFS_DC_SET_SERVICE_STATE, State)                          \
    };                                                                      \
    MARSHAL_INFO MiDCSetServiceState =                                      \
        _mkMarshalInfo(DFS_DC_SET_SERVICE_STATE, _MCode_DfsDCSetServiceState);



//
//  The DfsVolumeVerifyArgs are passed through this marshalled structure.
//
typedef struct _DFS_VOLUME_VERIFY_ARG {

    DFS_PKT_ENTRY_ID    Id;
    UNICODE_STRING      ServiceName;

} DFS_VOLUME_VERIFY_ARG, *PDFS_VOLUME_VERIFY_ARG;

//
// Marshalling information for DFS_VOLUME_VERIFY_ARG;
//
extern MARSHAL_INFO MiVolumeVerifyArg;

#define INIT_DFS_VOLUME_VERIFY_ARG_MARSHAL_INFO()                       \
    static MARSHAL_TYPE_INFO _MCode_VolumeVerifyArg[] = {               \
        _MCode_struct(DFS_VOLUME_VERIFY_ARG, Id, &MiPktEntryId),        \
        _MCode_ustr(DFS_VOLUME_VERIFY_ARG, ServiceName)                 \
    };                                                                  \
    MARSHAL_INFO MiVolumeVerifyArg =                                    \
        _mkMarshalInfo(DFS_VOLUME_VERIFY_ARG, _MCode_VolumeVerifyArg);



//
//  The guts of a partition table entry
//
typedef struct _DFS_PKT_ENTRY_INFO {

    ULONG Timeout;              // this entry's timeout
    ULONG ServiceCount;         // number of services in list
    PDFS_SERVICE ServiceList;   // array of servers that support the partition

} DFS_PKT_ENTRY_INFO, *PDFS_PKT_ENTRY_INFO;

//
// Marshalling information for DFS_PKT_ENTRY_INFO
//
extern MARSHAL_INFO MiPktEntryInfo;

#define INIT_DFS_PKT_ENTRY_INFO_MARSHAL_INFO()                              \
    static MARSHAL_TYPE_INFO _MCode_PktEntryInfo[] = {                      \
        _MCode_ul(DFS_PKT_ENTRY_INFO, Timeout),                             \
        _MCode_ul(DFS_PKT_ENTRY_INFO, ServiceCount),                        \
        _MCode_pcastruct(DFS_PKT_ENTRY_INFO,ServiceList,ServiceCount,&MiService)\
    };                                                                      \
    MARSHAL_INFO MiPktEntryInfo =                                           \
        _mkMarshalInfo(DFS_PKT_ENTRY_INFO, _MCode_PktEntryInfo);



//
//  A Partition Knowledge Table Entry (PktEntry) identifies each known
//  partition.
//

typedef struct _DFS_PKT_ENTRY {

    NODE_TYPE_CODE NodeTypeCode;    // node type -> DSFS_NTC_PKT_ENTRY
    NODE_BYTE_SIZE NodeByteSize;    // node size
    LIST_ENTRY Link;                // link for PKT EntryList
    ULONG Type;                     // type of partition (see above)
    ULONG USN;                      // Unique Serial Number
    DFS_PKT_ENTRY_ID Id;            // the Id of this entry
    DFS_PKT_ENTRY_INFO Info;        // info of this entry
    ULONG ExpireTime;               // time when partition should be deleted
    ULONG UseCount;                 // # threads (DnrContexts) are looking at it.
    ULONG FileOpenCount;            // # of files opened via this entry
    PDFS_SERVICE ActiveService;     // pointer into info to active service
    PDFS_SERVICE LocalService;      // pointer to local service (if any)
    struct _DFS_PKT_ENTRY *Superior;// this entrys  superior (if any)
    ULONG SubordinateCount;         // number of subordinates (if any)
    LIST_ENTRY SubordinateList;     // list of subordinates (if any)
    LIST_ENTRY SiblingLink;         // link to other siblings (if any)
    struct _DFS_PKT_ENTRY *ClosestDC; // Link to closest superiorDC in PKT.
    LIST_ENTRY ChildList;           // Link to subordinate PKT entries (if any)
    LIST_ENTRY NextLink;            // Link to link up parent's Subord list.
    UNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry;// prefix table entry

} DFS_PKT_ENTRY, *PDFS_PKT_ENTRY;

//
// Marshalling information for DFS_PKT_ENTRY
//
// Note that we only marshal the id and the info...no relational info
//
//
extern MARSHAL_INFO MiPktEntry;

#define INIT_DFS_PKT_ENTRY_MARSHAL_INFO()                                   \
    static MARSHAL_TYPE_INFO _MCode_PktEntry[] = {                          \
        _MCode_ul(DFS_PKT_ENTRY, Type),                                     \
        _MCode_struct(DFS_PKT_ENTRY, Id, &MiPktEntryId),                    \
        _MCode_struct(DFS_PKT_ENTRY, Info, &MiPktEntryInfo)                 \
    };                                                                      \
    MARSHAL_INFO MiPktEntry = _mkMarshalInfo(DFS_PKT_ENTRY, _MCode_PktEntry);



//
//  A Local Volume Entry is a back pointer from the local volume name to
//  a pkt entry whose local service == local volume name.
//

typedef struct _DFS_LOCAL_VOL_ENTRY {
    PDFS_PKT_ENTRY              PktEntry;
    UNICODE_STRING              LocalPath;
    UNICODE_STRING              ShareName;
    UNICODE_PREFIX_TABLE_ENTRY  PrefixTableEntry;
} DFS_LOCAL_VOL_ENTRY, *PDFS_LOCAL_VOL_ENTRY;


//
//  A Parition Knowledge Table encapsulates all the knowledge that has
//  been obtained about partitions in the distributed file system. There
//  is only one instance of this struct in the entire system, and is
//  part of the DsData structure.
//

typedef struct _DFS_PKT {

    NODE_TYPE_CODE NodeTypeCode;        // node type -> DSFS_NTC_PKT
    NODE_BYTE_SIZE NodeByteSize;        // node size...
    ERESOURCE Resource;                 // resource to guard access to Pkt
    KSPIN_LOCK  UseCountLock;           // Use while changing UseCount
    ULONG EntryCount;                   // number of entries in the PKT
    LIST_ENTRY EntryList;               // list of entries in the PKT
    PDFS_PKT_ENTRY DomainPktEntry;      // pointer to domain service.
    DFS_PREFIX_TABLE LocalVolTable;     // table of local volumes
    DFS_PREFIX_TABLE PrefixTable;       // prefix table
    DFS_PREFIX_TABLE ShortPrefixTable;  // prefix table containing 8.3 prefixes
    UNICODE_PREFIX_TABLE DSMachineTable;// Table for DSMachines
    ULONG DefaultTimeToLive;            // Default time to live (in seconds)
    ULONG MaxReferrals;                 // maximum referrals to return.
} DFS_PKT, *PDFS_PKT;



//
// PKT Relational Information structure
//
// This structure incapsulates the relationship between a pkt entry and
// all of its subordinates.
//

typedef struct _DFS_PKT_RELATION_INFO {

    DFS_PKT_ENTRY_ID EntryId;               // the Id of the parent entry
    ULONG SubordinateIdCount;               // number of subordinates
    PDFS_PKT_ENTRY_ID SubordinateIdList;    // list of subordinate Ids

} DFS_PKT_RELATION_INFO, *PDFS_PKT_RELATION_INFO;

//
// Marshalling information for DFS_PKT_RELATION_INFO
//
extern MARSHAL_INFO MiPktRelationInfo;

#define INIT_DFS_PKT_RELATION_INFO_MARSHAL_INFO()                           \
    static MARSHAL_TYPE_INFO _MCode_PktRelationInfo[] = {                   \
        _MCode_struct(DFS_PKT_RELATION_INFO, EntryId, &MiPktEntryId),       \
        _MCode_ul(DFS_PKT_RELATION_INFO, SubordinateIdCount),               \
        _MCode_pcastruct(DFS_PKT_RELATION_INFO, SubordinateIdList,          \
            SubordinateIdCount, &MiPktEntryId)                              \
    };                                                                      \
    MARSHAL_INFO MiPktRelationInfo =                                        \
        _mkMarshalInfo(DFS_PKT_RELATION_INFO, _MCode_PktRelationInfo);


//
// The Local Volume Config structure
//
// Encapsulates a local volume configuration information.
//

typedef struct _DFS_LOCAL_VOLUME_CONFIG {

    ULONG EntryType;
    ULONG ServiceType;
    UNICODE_STRING StgId;
    UNICODE_STRING Share;
    DFS_PKT_RELATION_INFO RelationInfo;

} DFS_LOCAL_VOLUME_CONFIG, *PDFS_LOCAL_VOLUME_CONFIG;

//
// Marshalling information for DFS_LOCAL_VOLUME_CONFIG
//
extern MARSHAL_INFO MiLocalVolumeConfig;

#define INIT_LOCAL_VOLUME_CONFIG_MARSHAL_INFO()                             \
    static MARSHAL_TYPE_INFO _MCode_LocalVolumeConfig[] = {                 \
        _MCode_ul(DFS_LOCAL_VOLUME_CONFIG, EntryType),                      \
        _MCode_ul(DFS_LOCAL_VOLUME_CONFIG, ServiceType),                    \
        _MCode_struct(DFS_LOCAL_VOLUME_CONFIG, RelationInfo, &MiPktRelationInfo) \
    };                                                                      \
    MARSHAL_INFO MiLocalVolumeConfig = _mkMarshalInfo(DFS_LOCAL_VOLUME_CONFIG, _MCode_LocalVolumeConfig);


//
// The DFS_CHECK_VOLUME_ARG  structure encapsulates the arguments to
// CheckRemotePartition call.
//

typedef struct _DFS_CHECK_VOLUME_ARG {

    DFS_LOCAL_VOLUME_CONFIG         ConfigInfo;
    UNICODE_STRING                  ServiceName;

} DFS_CHECK_VOLUME_ARG, *PDFS_CHECK_VOLUME_ARG;

//
// Marshalling information for DFS_CHECK_VOLUME_ARG.
//

extern MARSHAL_INFO MiCheckVolumeArg;

#define INIT_DFS_CHECK_VOLUME_ARG_MARSHAL_INFO()                        \
    static MARSHAL_TYPE_INFO    _MCode_CheckVolumeArg[] = {             \
        _MCode_struct(DFS_CHECK_VOLUME_ARG, ConfigInfo, &MiLocalVolumeConfig), \
        _MCode_ustr(DFS_CHECK_VOLUME_ARG, ServiceName)                  \
    };                                                                  \
    MARSHAL_INFO MiCheckVolumeArg =                                     \
        _mkMarshalInfo(DFS_CHECK_VOLUME_ARG, _MCode_CheckVolumeArg);



//
// The DFS_PKT_CREATE_ENTRY_ARG structure encapsulates the arguments
// to the create entry call.
//

typedef struct _DFS_PKT_CREATE_ENTRY_ARG {

    ULONG EntryType;
    DFS_PKT_ENTRY_ID EntryId;
    DFS_PKT_ENTRY_INFO EntryInfo;
    ULONG CreateDisposition;

} DFS_PKT_CREATE_ENTRY_ARG, *PDFS_PKT_CREATE_ENTRY_ARG;

//
// Marshalling information for DFS_PKT_CREATE_ENTRY_ARG
//
extern MARSHAL_INFO MiPktCreateEntryArg;

#define INIT_DFS_PKT_CREATE_ENTRY_ARG_MARSHAL_INFO()                        \
    static MARSHAL_TYPE_INFO _MCode_PktCreateEntryArg[] = {                 \
        _MCode_ul(DFS_PKT_CREATE_ENTRY_ARG, EntryType),                     \
        _MCode_struct(DFS_PKT_CREATE_ENTRY_ARG, EntryId, &MiPktEntryId),    \
        _MCode_struct(DFS_PKT_CREATE_ENTRY_ARG, EntryInfo, &MiPktEntryInfo),\
        _MCode_ul(DFS_PKT_CREATE_ENTRY_ARG, CreateDisposition)              \
    };                                                                      \
    MARSHAL_INFO MiPktCreateEntryArg =                                      \
        _mkMarshalInfo(DFS_PKT_CREATE_ENTRY_ARG, _MCode_PktCreateEntryArg);


//
// The DFS_PKT_CREATE_SUBORDINATE_ENTRY_ARG structure encapsulates the arguments
// to the create entry call.
//

typedef struct _DFS_PKT_CREATE_SUBORDINATE_ENTRY_ARG {

    DFS_PKT_ENTRY_ID EntryId;
    ULONG SubEntryType;
    DFS_PKT_ENTRY_ID SubEntryId;
    DFS_PKT_ENTRY_INFO SubEntryInfo;
    ULONG CreateDisposition;

} DFS_PKT_CREATE_SUBORDINATE_ENTRY_ARG, *PDFS_PKT_CREATE_SUBORDINATE_ENTRY_ARG;

//
// Marshalling information for DFS_PKT_CREATE_SUBORDINATE_ENTRY_ARG
//
extern MARSHAL_INFO MiPktCreateSubordinateEntryArg;

#define INIT_DFS_PKT_CREATE_SUBORDINATE_ENTRY_ARG_MARSHAL_INFO()            \
    static MARSHAL_TYPE_INFO _MCode_PktCreateSubordinateEntryArg[] = {      \
        _MCode_struct(DFS_PKT_CREATE_SUBORDINATE_ENTRY_ARG, EntryId,        \
                        &MiPktEntryId),                                     \
        _MCode_ul(DFS_PKT_CREATE_SUBORDINATE_ENTRY_ARG, SubEntryType),      \
        _MCode_struct(DFS_PKT_CREATE_SUBORDINATE_ENTRY_ARG, SubEntryId,     \
                        &MiPktEntryId),                                     \
        _MCode_struct(DFS_PKT_CREATE_SUBORDINATE_ENTRY_ARG, SubEntryInfo,   \
                        &MiPktEntryInfo),                                   \
        _MCode_ul(DFS_PKT_CREATE_SUBORDINATE_ENTRY_ARG, CreateDisposition)  \
    };                                                                      \
    MARSHAL_INFO MiPktCreateSubordinateEntryArg =                           \
        _mkMarshalInfo(DFS_PKT_CREATE_SUBORDINATE_ENTRY_ARG,                \
                        _MCode_PktCreateSubordinateEntryArg);


//
// The DFS_HANDLE_SERVER_INFO data structure is used to pass back the
// full file name and server DN, and server Machine ID to the caller.
//

typedef struct _DFS_HANDLE_SERVER_INFO {

    UNICODE_STRING FullFileName;
    UNICODE_STRING ServerDN;
    UNICODE_STRING ServerNetBIOSName;
    GUID           ServerID;

} DFS_HANDLE_SERVER_INFO, *PDFS_HANDLE_SERVER_INFO;

//
// Marshalling info for DFS_HANDLE_SERVER_INFO
//

extern MARSHAL_INFO MiHandleServerInfo;

#define INIT_DFS_HANDLE_SERVER_INFO_MARSHAL_INFO()                          \
    static MARSHAL_TYPE_INFO _MCode_HandleServerInfo[] = {                  \
        _MCode_ustr(DFS_HANDLE_SERVER_INFO, FullFileName),                  \
        _MCode_ustr(DFS_HANDLE_SERVER_INFO, ServerDN),                      \
        _MCode_ustr(DFS_HANDLE_SERVER_INFO, ServerNetBIOSName),             \
        _MCode_guid(DFS_HANDLE_SERVER_INFO, ServerID)                       \
    };                                                                      \
    MARSHAL_INFO MiHandleServerInfo =                                       \
        _mkMarshalInfo(DFS_HANDLE_SERVER_INFO, _MCode_HandleServerInfo);


#ifndef _UPKT_          
//
//  PARTITION KNOWLEDGE TABLE PUBLIC INLINE FUNCTIONS
//

#define _GetPkt()       (&DfsData.Pkt)

//+-------------------------------------------------------------------------
//
//  Function:   PktAcquireShared, public inline
//
//  Synopsis:   PktAcquireShared acquires the partition knowledge table
//              for shared access.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT
//              [WaitOk] - indicates if the call is allowed to wait for
//                  the PKT to become available or must return immediately.
//
//  Returns:    [TRUE] - is the PKT has been acquired.
//              [FALSE] - the PKT could not be acquired.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktAcquireShared( pPkt, WaitOk )\
{ \
    FsRtlEnterFileSystem(); \
    ExAcquireResourceSharedLite( &((pPkt)->Resource), WaitOk ); \
}

//+-------------------------------------------------------------------------
//
//  Function:   PktAcquireExclusive, public inline
//
//  Synopsis:   PktAcquireExclusive acquires the partition knowledge table
//              for exclusive access.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT
//              [WaitOk] - indicates if the call is allowed to wait for
//                  the PKT to become available or must return immediately.
//
//  Returns:    [TRUE] - is the PKT has been acquired.
//              [FALSE] - the PKT could not be acquired.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktAcquireExclusive( pPkt, WaitOk )\
{ \
    FsRtlEnterFileSystem(); \
    ExAcquireResourceExclusiveLite( &((pPkt)->Resource), WaitOk ); \
}


//+-------------------------------------------------------------------------
//
//  Function:   PktRelease, public inline
//
//  Synopsis:   PktRelease releases the PKT.  It can have been acquired
//              for exclusive or shared access.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktRelease( pPkt )\
{ \
    ExReleaseResourceLite( &((pPkt)->Resource) ); \
    FsRtlExitFileSystem(); \
}

//+-------------------------------------------------------------------------
//
//  Function:   PktInvalidateEntry, public inline
//
//  Synopsis:   PktInvalidateEntry destroys a PKT Entry.  The entry cannot
//              be local, and it cannot be an exit point.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT.
//              [Victim] - pointer to the entry to be invalidated.
//
//  Returns:    [STATUS_SUCCESS] - all is well.
//              [DFS_STATUS_LOCAL_ENTRY] - an attempt was made to
//                  invalidate a local entry, or an entry that is a
//                  local exit point.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktInvalidateEntry(p, e) (                                          \
    ((e)->Type & (PKT_ENTRY_TYPE_LOCAL|PKT_ENTRY_TYPE_LOCAL_XPOINT))        \
    ? (DFS_STATUS_LOCAL_ENTRY)                                              \
    : (PktEntryDestroy(e, p, (BOOLEAN)TRUE), STATUS_SUCCESS)                \
    )


//+-------------------------------------------------------------------------
//
//  Function:   PktFirstEntry, public inline
//
//  Synopsis:   PktFirstEntry returns the first entry in the list of
//              PKT entries.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT.
//
//  Returns:    A pointer to the first entry in the PKT, or NULL if the
//              PKT is empty.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktFirstEntry(p) (                                                  \
    ((p)->EntryList.Flink != &(p)->EntryList)                               \
    ? (CONTAINING_RECORD((p)->EntryList.Flink, DFS_PKT_ENTRY, Link))        \
    : (NULL)                                                                \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktNextEntry, public inline
//
//  Synopsis:   PktNextEntry returns the next entry in the list of
//              PKT entries.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT.
//              [Entry] - a pointer to the previous entry.
//
//  Returns:    A pointer to the next entry in the PKT, or NULL if we
//              are at the end of the list.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktNextEntry(p, e) (                                                \
    ((e)->Link.Flink != &(p)->EntryList)                                    \
    ? (CONTAINING_RECORD((e)->Link.Flink, DFS_PKT_ENTRY, Link))             \
    : (NULL)                                                                \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktLinkEntry, public inline
//
//  Synopsis:   PktLinkEntry links an entry into the list of entries
//              in the PKT.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT.
//              [Entry] - a pointer to the entry to be linked in.
//
//  Returns:    VOID
//
//  Notes:      Care must be taken to insure that the entry is not already
//              linked into the PKT entry list before calling this routine.
//              No checking is done to prevent an entry from being linked
//              twice...
//
//--------------------------------------------------------------------------
#define PktLinkEntry(p, e) {                                                \
    InsertTailList(&(p)->EntryList, &(e)->Link);                            \
    (p)->EntryCount++;                                                      \
    }

//+-------------------------------------------------------------------------
//
//  Function:   PktUnlinkEntry, public inline
//
//  Synopsis:   PktUnlinkEntry unlinks an entry from the list of entries
//              in the PKT.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT.
//              [Entry] - a pointer to the entry to be unlinked.
//
//  Returns:    VOID
//
//  Notes:      Care must be taken to insure that the entry is in fact
//              already linked into the PKT entry list before calling this
//              routine. No checking is done to prevent an entry from being
//              unlinked twice...
//
//--------------------------------------------------------------------------
#define PktUnlinkEntry(p, e) {                                              \
    RemoveEntryList(&(e)->Link);                                            \
    (p)->EntryCount--;                                                      \
    }

//+----------------------------------------------------------------------------
//
//  Function:   PktSetDomainEntry, public inline
//
//  Synopsis:   Sets the Domain Pkt Entry in the Pkt to point to the given
//              pkt entry.
//
//  Arguments:  [Pkt] -- pointer to the pkt whose DomainPktEnry field is to be
//                      set.
//              [DCEntry] -- pointer to the pkt entry to serve as the domain
//                      pkt entry.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

#define PktSetDomainEntry(p, e) {                                           \
    (p)->DomainPktEntry = e;                                                \
    if (SeRenameSd == NULL) {                                               \
        (VOID) DfspInitSecDesc(p);                                          \
    }                                                                       \
}

//+----------------------------------------------------------------------------
//
//  Function:   PktSetTypeInheritance, public inline
//
//  Synopsis:   Sets the Domain Pkt Entry type to inherit the main parent's type
//
//  Arguments:  [sup] -- Parent entry.
//              [sub] -- Child entry
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

#define PktSetTypeInheritance(sup, sub) {                                        \
   (sub)->Type |= (sup)->Type & PKT_ENTRY_TYPE_INHERIT_MASK;                     \
}

#define PktServiceListValidate(e)       TRUE


//
//  PARTITION KNOWLEDGE TABLE PUBLIC FUNCTIONS (pkt.c)
//

NTSTATUS
PktInitialize(
    IN  PDFS_PKT Pkt
    );

VOID
PktUninitialize(
    IN  PDFS_PKT Pkt);

NTSTATUS
PktInitializeLocalPartition(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING LocalVolumeName,
    IN  PDFS_LOCAL_VOLUME_CONFIG ConfigInfo
    );

NTSTATUS
PktCreateEntry(
    IN  PDFS_PKT Pkt,
    IN  ULONG EntryType,
    IN  PDFS_PKT_ENTRY_ID PktEntryId,
    IN  PDFS_PKT_ENTRY_INFO PktEntryInfo OPTIONAL,
    IN  ULONG CreateDisposition,
    OUT PDFS_PKT_ENTRY *ppPktEntry
    );

NTSTATUS
PktCreateDomainEntry(
    IN  PUNICODE_STRING DomainName);

NTSTATUS
PktCreateMachineEntry(
    IN  PUNICODE_STRING MachineName);

NTSTATUS
PktCreateEntryFromReferral(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING ReferralPath,
    IN  ULONG ReferralSize,
    IN  PVOID ReferralBuffer,
    IN  ULONG CreateDisposition,
    OUT ULONG *ReferralType,
    OUT PDFS_PKT_ENTRY *ppPktEntry
    );

NTSTATUS
PktCreateSubordinateEntry(
    IN      PDFS_PKT Pkt,
    IN      PDFS_PKT_ENTRY Superior,
    IN      ULONG SubordinateType,
    IN      PDFS_PKT_ENTRY_ID SubordinateId,
    IN      PDFS_PKT_ENTRY_INFO SubordinateInfo OPTIONAL,
    IN      ULONG CreateDisposition,
    IN  OUT PDFS_PKT_ENTRY *Subordinate
    );

PDFS_PKT_ENTRY
PktLookupEntryById(
    IN      PDFS_PKT Pkt,
    IN      PDFS_PKT_ENTRY_ID Id
    );

PDFS_PKT_ENTRY
PktLookupEntryByPrefix(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING Prefix,
    OUT PUNICODE_STRING Remaining
    );

PDFS_PKT_ENTRY
PktLookupEntryByShortPrefix(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING Prefix,
    OUT PUNICODE_STRING Remaining
    );

NTSTATUS
PktEntryModifyPrefix(
    IN  PDFS_PKT        Pkt,
    IN  PUNICODE_STRING LocalPath,
    IN  PDFS_PKT_ENTRY  Entry
    );

PDFS_PKT_ENTRY
PktLookupEntryByUid(
    IN  PDFS_PKT Pkt,
    IN  GUID *Uid
    );

PDFS_PKT_ENTRY
PktLookupReferralEntry(
    IN  PDFS_PKT        Pkt,
    IN  PDFS_PKT_ENTRY  pEntry
);

PDFS_PKT_ENTRY
PktGetReferralEntryForPath(
    PDFS_PKT            Pkt,
    UNICODE_STRING      Path,
    ULONG               *Type
);

NTSTATUS
PktSetRelationInfo(
    IN      PDFS_PKT Pkt,
    IN      PDFS_PKT_RELATION_INFO RelationInfo
    );

VOID
PktTrimSubordinates(
    IN      PDFS_PKT Pkt,
    IN      PDFS_PKT_ENTRY Entry,
    IN      PDFS_PKT_RELATION_INFO RInfo
    );

//
//  DFS PKT PRIVATE FUNCTIONS (pkt.c)
//

NTSTATUS
PktpRecoverLocalPartition(
    IN      PDFS_PKT Pkt,
    IN      PDFS_LOCAL_VOLUME_CONFIG ConfigInfo,
    IN      PVOID Buffer,
    IN      ULONG BufferSize,
    IN      NTSTATUS ErrorStatus
    );

NTSTATUS
PktpOpenDomainService(
    IN      PDFS_PKT Pkt,
    IN      PDFS_PKT_ENTRY PktEntry,
    IN  OUT PHANDLE DomainServiceHandle
    );

NTSTATUS
PktpValidateLocalPartition(
    IN PDFS_PKT Pkt,
    IN PDFS_LOCAL_VOLUME_CONFIG ConfigInfo
    );

NTSTATUS
DfsGetMachPktEntry(
    UNICODE_STRING      Path
);

VOID
RemoveLastComponent(
    IN PUNICODE_STRING  Prefix,
    OUT PUNICODE_STRING newPrefix);

VOID
RemoveFirstComponent(
    IN PUNICODE_STRING Prefix,
    OUT PUNICODE_STRING newPrefix);



//
//  DFS SERVICE PUBLIC FUNCTIONS (pktsup.c)
//

NTSTATUS
PktEntrySetLocalService(
    IN  PDFS_PKT        Pkt,
    IN  PDFS_PKT_ENTRY  Entry,
    IN  PDFS_SERVICE    LocalService,
    IN  PDFS_LOCAL_VOL_ENTRY LocalVolEntry,
    IN  PUNICODE_STRING LocalPath,
    IN  PUNICODE_STRING ShareName);

VOID
PktEntryUnsetLocalService(
    IN  PDFS_PKT        Pkt,
    IN  PDFS_PKT_ENTRY  Entry,
    IN  PUNICODE_STRING LocalPath);

VOID
PktEntryRemoveLocalService(
    IN  PDFS_PKT        Pkt,
    IN  PDFS_PKT_ENTRY  Entry,
    IN  PUNICODE_STRING LocalPath);

PDFS_LOCAL_VOL_ENTRY
PktEntryLookupLocalService(
    IN  PDFS_PKT        Pkt,
    IN  PUNICODE_STRING LocalPath,
    OUT PUNICODE_STRING Remaining
    );

NTSTATUS
PktServiceConstruct(
    OUT PDFS_SERVICE Service,
    IN  ULONG ServiceType,
    IN  ULONG ServiceCapability,
    IN  ULONG ServiceStatus,
    IN  ULONG ServiceProviderId,
    IN  PUNICODE_STRING ServiceName OPTIONAL,
    IN  PUNICODE_STRING ServiceAddress OPTIONAL
    );

VOID
PktServiceDestroy(
    IN  PDFS_SERVICE Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
    );

VOID
PktDSTransportDestroy(
    IN  PDS_TRANSPORT Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
    );

VOID
PktDSMachineDestroy(
    IN  PDS_MACHINE Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
    );


//
//  PKT ENTRY ID PUBLIC FUNCTIONS (pktsup.c)
//

NTSTATUS
PktEntryIdConstruct(
    OUT PDFS_PKT_ENTRY_ID PktEntryId,
    IN  GUID *Uid OPTIONAL,
    IN  UNICODE_STRING *Prefix OPTIONAL,
    IN  UNICODE_STRING *ShortPrefix OPTIONAL
    );

VOID
PktEntryIdDestroy(
    IN  PDFS_PKT_ENTRY_ID Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
    );

PDFS_SERVICE
PktGetService(
    IN  PDFS_PKT_ENTRY  entry,
    IN  PUNICODE_STRING serviceName
    );


//
//  PKT ENTRY ID PUBLIC INLINE FUNCTIONS
//

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryIdEqual, public inline
//
//  Synopsis:   PktpEntryIdEqual determines if two entry Ids are equal
//              or not.
//
//  Arguments:  [Id1] - a pointer to an Id to compare.
//              [Id2] - a pointer to an Id to compare.
//
//  Returns:    [TRUE] - if both Ids are equal.
//              [FALSE] - if the Ids are not equal.
//
//  Notes:      The comparison on the Prefix is done case insensitive.
//
//--------------------------------------------------------------------------
#define PktEntryIdEqual(Id1, Id2) (                                         \
    (GuidEqual(&(Id1)->Uid, &(Id2)->Uid)) &&                                \
    (RtlEqualUnicodeString(&(Id1)->Prefix, &(Id2)->Prefix, (BOOLEAN)TRUE))  \
    )

//
//  PKT ENTRY ID PRIVATE INLINE FUNCTIONS
//

//+-------------------------------------------------------------------------
//
//  Function:   PktpEntryIdMove, private inline
//
//  Synopsis:   PktpEntryIdMove removes the values from the source Id and
//              places them on the destination Id.
//
//  Arguments:  [DestId] - a pointer to an Id that is to receive the
//                  sources values.
//              [SrcId] - a pointer to an Id that is to be stripped of
//                  its values.
//
//  Returns:    VOID
//
//  Notes:      Any values that are currently on the destination Id are
//              overwritten.  No memory is freed (either on the source,
//              or the destination) by this call.
//
//--------------------------------------------------------------------------
#define PktpEntryIdMove(DestId, SrcId) {                                    \
    (*(DestId)) = (*(SrcId));                                               \
    (SrcId)->Prefix.Length = (SrcId)->Prefix.MaximumLength = 0;             \
    (SrcId)->Prefix.Buffer = NULL;                                          \
    (SrcId)->ShortPrefix.Length = (SrcId)->ShortPrefix.MaximumLength = 0;   \
    (SrcId)->ShortPrefix.Buffer = NULL;                                     \
    }


//
//  PKT ENTRY INFO PUBLIC FUNCTIONS (pktsup.c)
//

//NTSTATUS
//PktEntryInfoConstruct(
//    OUT PDFS_PKT_ENTRY_INFO PktEntryInfo,
//    IN  PULONG ExpireTime OPTIONAL,
//    IN  ULONG ServiceCount,
//    IN  PDFS_SERVICE ServiceList OPTIONAL
//    );

VOID
PktEntryInfoDestroy(
    IN  PDFS_PKT_ENTRY_INFO Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
    );

//
//  PKT ENTRY INFO PRIVATE INLINE FUNCTIONS
//

//
// The following inlines operate on Entry Infos
//

//+-------------------------------------------------------------------------
//
//  Function:   PktpEntryInfoMove, private inline
//
//  Synopsis:   PktpEntryInfoMove removes the values from the source Info and
//              places them on the destination Info.
//
//  Arguments:  [DestInfo] - a pointer to an Info that is to receive the
//                  sources values.
//              [SrcInfo] - a pointer to an Info that is to be stripped of
//                  its values.
//
//  Returns:    VOID
//
//  Notes:      Any values that are currently on the destination Info are
//              overwritten.  No memory is freed (either on the source,
//              or the destination) by this call.
//
//--------------------------------------------------------------------------
#define PktpEntryInfoMove(DestInfo, SrcInfo) {                          \
    (*(DestInfo)) = (*(SrcInfo));                                       \
    (SrcInfo)->ServiceCount = 0L;                                       \
    (SrcInfo)->ServiceList = NULL;                                      \
    }


//
// PKT ENTRY PUBLIC INLINE FUNCTIONS
//

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryFirstSubordinate, public inline
//
//  Synopsis:   PktEntryFirstSubordinate returns the first entry in the
//              list of subordinates.
//
//  Arguments:  [Superior] - pointer to a PKT entry.
//
//  Returns:    A pointer to the first entry in the list of subordinates,
//              or NULL if the list is empty.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktEntryFirstSubordinate(s) (                                   \
      ((s)->SubordinateList.Flink != &(s)->SubordinateList)             \
      ? (CONTAINING_RECORD((s)->SubordinateList.Flink, DFS_PKT_ENTRY,   \
                                SiblingLink))                           \
      : (NULL)                                                          \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryNextSubordinate, public inline
//
//  Synopsis:   PktEntryNextSubordinate returns the next entry in the
//              list of subordinates.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry (the one
//                  which we are getting the subordinates for).
//              [Subordinate] - pointer to the last subordinate retreived
//                  via this routine (or PktEntryFirstSubordinate).
//
//  Returns:    A pointer to the next entry in the list of subordinates,
//              or NULL if we've hit the end of the list.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktEntryNextSubordinate(s, m) (                                     \
    ((m)->SiblingLink.Flink != &(s)->SubordinateList)                       \
    ? (CONTAINING_RECORD((m)->SiblingLink.Flink,DFS_PKT_ENTRY,SiblingLink))\
    : (NULL)                                                                \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryLinkSubordinate, public inline
//
//  Synopsis:   PktEntryLinkSubordinate links a subordinate to a superior's
//              list of subordinates.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry.
//              [Subordinate] - pointer to the subordinate to be linked in.
//
//  Returns:    VOID
//
//  Notes:      If the subordinate is part of another superior's list, it
//              will be removed from that list as a by-product of being
//              put on the specified Superior's list.  The Superior pointer
//              of the subordinate is adjusted appropriately.
//
//              If the superior is a local entry, the subordinate will
//              be modified to indicate that it is a local exit point.
//
//--------------------------------------------------------------------------
#define PktEntryLinkSubordinate(sup, sub) {                                 \
    while(1) {                                                              \
        if((sub)->Superior == (sup))                                        \
            break;                                                          \
        if((sub)->Superior != NULL)                                         \
            PktEntryUnlinkSubordinate((sub)->Superior, (sub));              \
        InsertTailList(&(sup)->SubordinateList, &(sub)->SiblingLink);       \
        (sup)->SubordinateCount++;                                          \
        (sub)->Superior = (sup);                                            \
        if((sup)->Type & PKT_ENTRY_TYPE_LOCAL)                              \
            (sub)->Type |= PKT_ENTRY_TYPE_LOCAL_XPOINT;                     \
        break;                                                              \
    }                                                                       \
    }

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryUnlinkSubordinate, public inline
//
//  Synopsis:   PktEntryUnlinkSubordinate unlinks a subordinate from a
//              superior's list of subordinates.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry.
//              [Subordinate] - pointer to the subordinate to be unlinked.
//
//  Returns:    VOID
//
//  Notes:      The Superior pointer of the subordinate is NULLed as a
//              by-product of this operation.
//
//              By default, the subordinate is modified to indicate that
//              it is not an exit point (it cannot be an exit point if it
//              has no superior).
//
//              Milans - We need to turn off the PKT_ENTRY_TYPE_PERMANENT
//              bit if the PKT_ENTRY_TYPE_LOCAL bit is not set, and we are
//              not the DC. If we decide that a machine can be a server for
//              a volume in another domain, then we need to do something
//              about the != DS_DC clause.
//
//--------------------------------------------------------------------------
#define PktEntryUnlinkSubordinate(sup, sub) {                               \
    ASSERT((sub)->Superior == (sup));                                       \
    ASSERT((sup)->SubordinateCount > 0);                                    \
    RemoveEntryList(&(sub)->SiblingLink);                                   \
    (sup)->SubordinateCount--;                                              \
    (sub)->Superior = NULL;                                                 \
    (sub)->Type &= ~PKT_ENTRY_TYPE_LOCAL_XPOINT;                            \
    if ( DfsData.MachineState != DFS_ROOT_SERVER &&                         \
         (((sub)->Type & PKT_ENTRY_TYPE_LOCAL) == 0) ) {                    \
         (sub)->Type &= ~PKT_ENTRY_TYPE_PERMANENT;                          \
    }                                                                       \
}

//
// The following set of inline functions work on the Links maintained in
// the PKT to be able to get to referral entries for interdomain stuff real
// fast. These functions are similar to the above functions.
//

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryFirstChild, public inline
//
//  Synopsis:   PktEntryFirstChild returns the first entry in the
//              list of child links of a PKT entry.
//
//  Arguments:  [SuperiorDC] - pointer to a PKT entry.
//
//  Returns:    A pointer to the first entry in the list of children,
//              or NULL if the list is empty.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktEntryFirstChild(s) (                                         \
    ((s)->ChildList.Flink != &(s)->ChildList)                           \
    ? (CONTAINING_RECORD((s)->ChildList.Flink,DFS_PKT_ENTRY,NextLink))  \
    : (NULL)                                                            \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryNextChild, public inline
//
//  Synopsis:   PktEntryNextChild returns the next entry in the
//              list of children.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry (the one
//                  which we are getting the subordinates for).
//              [Subordinate] - pointer to the last child retreived
//                  via this routine (or PktEntryFirstChild).
//
//  Returns:    A pointer to the next entry in the list of children,
//              or NULL if we've hit the end of the list.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktEntryNextChild(s, m) (                                       \
    ((m)->NextLink.Flink != &(s)->ChildList)                            \
    ? (CONTAINING_RECORD((m)->NextLink.Flink,DFS_PKT_ENTRY,NextLink))   \
    : (NULL)                                                            \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryLinkChild, public inline
//
//  Synopsis:   PktEntryLinkChild links a child to a closestDC's
//              list of children.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry.
//              [Subordinate] - pointer to the subordinate to be linked in.
//
//  Returns:    VOID
//
//  Notes:      If the child is part of another superior's list, it
//              will be removed from that list as a by-product of being
//              put on the specified Superior's list.  The Superior pointer
//              of the child is adjusted appropriately.
//
//
//--------------------------------------------------------------------------
#define PktEntryLinkChild(sup, sub) {                                     \
    while(1) {                                                            \
        if (sub == sup) {                                                 \
            (sub)->ClosestDC = NULL;                                      \
            break;                                                        \
        }                                                                 \
        if((sub)->ClosestDC == (sup))                                     \
            break;                                                        \
        if((sub)->ClosestDC != NULL)                                      \
            PktEntryUnlinkChild((sub)->ClosestDC, (sub));                 \
        InsertTailList(&(sup)->ChildList, &(sub)->NextLink);              \
        (sub)->ClosestDC = (sup);                                         \
        break;                                                            \
    }                                                                     \
    }

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryUnlinkChild, public inline
//
//  Synopsis:   PktEntryUnlinkChild unlinks a child from a
//              superior's list of children.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry.
//              [Subordinate] - pointer to the subordinate to be unlinked.
//
//  Returns:    VOID
//
//  Notes:      The Superior pointer of the child is NULLed as a
//              by-product of this operation.
//
//
//--------------------------------------------------------------------------
#define PktEntryUnlinkChild(sup, sub) {                                  \
    ASSERT((sub)->ClosestDC == (sup));                                   \
    RemoveEntryList(&(sub)->NextLink);                                   \
    (sub)->ClosestDC = NULL;                                             \
    }

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryUnlinkAndRelinkChild, public inline
//
//  Synopsis:   PktEntryUnlinkAndRelinkChild unlinks a child from a
//              superior's list of children and relinks it to the parent of
//              the superior.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry.
//              [Subordinate] - pointer to the subordinate to be unlinked.
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------
#define PktEntryUnlinkAndRelinkChild(sup, sub) {                        \
    PktEntryUnlinkChild(sup, sub);                                      \
    if ((sup)->ClosestDC != NULL) {                                     \
        PktEntryLinkChild((sup)->ClosestDC, sub);                       \
    }                                                                   \
    }

//
// PKT ENTRY PUBLIC FUNCTIONS (pktsup.c)
//

NTSTATUS
PktEntryAssemble(
    IN  OUT PDFS_PKT_ENTRY Entry,
    IN      PDFS_PKT Pkt,
    IN      ULONG EntryType,
    IN      PDFS_PKT_ENTRY_ID EntryId,
    IN      PDFS_PKT_ENTRY_INFO EntryInfo OPTIONAL
    );

NTSTATUS
PktEntryReassemble(
    IN  OUT PDFS_PKT_ENTRY Entry,
    IN      PDFS_PKT Pkt OPTIONAL,
    IN      ULONG EntryType,
    IN      PDFS_PKT_ENTRY_ID EntryId OPTIONAL,
    IN      PDFS_PKT_ENTRY_INFO EntryInfo OPTIONAL
    );

VOID
PktEntryDestroy(
    IN  PDFS_PKT_ENTRY Victim OPTIONAL,
    IN  PDFS_PKT Pkt,
    IN  BOOLEAN DeallocateAll
    );

VOID
PktEntryClearSubordinates(
    IN      PDFS_PKT_ENTRY PktEntry
    );

VOID
PktEntryClearChildren(
    IN      PDFS_PKT_ENTRY PktEntry
    );

NTSTATUS
PktEntryCreateReferral(
    IN  PDFS_PKT_ENTRY PktEntry,
    IN  ULONG ServiceTypes,
    IN  PVOID ReferralBuffer
    );


//
// PKT RELATION INFO PUBLIC FUNCTIONS (pktsup.c)
//

NTSTATUS
PktRelationInfoConstruct(
    IN OUT  PDFS_PKT_RELATION_INFO RelationInfo,
    IN      PDFS_PKT Pkt,
    IN      PDFS_PKT_ENTRY_ID PktEntryId
    );

NTSTATUS
PktRelationInfoValidate(
    IN      PDFS_PKT_RELATION_INFO Local,
    IN      PDFS_PKT_RELATION_INFO Remote,
    IN      UNICODE_STRING         ServiceName
    );

VOID
PktRelationInfoDestroy(
    IN      PDFS_PKT_RELATION_INFO RelationInfo,
    IN      BOOLEAN DeallocateAll
    );

VOID
LocalVolumeConfigInfoDestroy(
    IN  PDFS_LOCAL_VOLUME_CONFIG Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
    );

#endif // NOT _UPKT_

#endif // _PKT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\lib\udfsrtl.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:   uDfsRtl.C
//
//  Contents:
//
//  Functions:
//
//  History:     27 May 1992 PeterCo Created.
//
//-----------------------------------------------------------------------------

#include <ntifs.h>
#include <ntext.h>
#include "nodetype.h"
#include "dfsmrshl.h"
#include "dfsrtl.h"
#include "libsup.h"
#include "upkt.h"

#include "dfsrtl.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\lib\udfsmrsh.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       UDfsMrshl.c
//
//  Contents:   User level code to do marshalling of Dfs data structures
//
//  Classes:
//
//  Functions:
//
//  History:    March 31, 1994          Milans created
//
//-----------------------------------------------------------------------------

#include <ntifs.h>
#include <ntext.h>
#include "nodetype.h"
#include "dfsmrshl.h"
#include "upkt.h"
#include "libsup.h"

#include "dfsmrshl.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\lib\libsup.c ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:   LibSup.c
//
//  Contents:
//
//  Functions:
//
//  History:
//
//  Notes:
//
//--------------------------------------------------------------------------


#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "libsup.h"
#include "ntddnfs.h"
#include "dfsfsctl.h"
#include "malloc.h"

UNICODE_STRING LocalDfsName = {
    sizeof(DFS_SERVER_NAME)-sizeof(UNICODE_NULL),
    sizeof(DFS_SERVER_NAME)-sizeof(UNICODE_NULL),
    DFS_SERVER_NAME
};

//+-------------------------------------------------------------------------
//
//  Function:   DfsOpen, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

static FILE_FULL_EA_INFORMATION PrincipalEAHeader = {
    0, 0, (sizeof EA_NAME_PRINCIPAL-1), 0,
    ""
};

NTSTATUS
DfsOpen(
    IN  OUT PHANDLE DfsHandle,
    IN      PUNICODE_STRING DfsName OPTIONAL
)
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    PUNICODE_STRING name;

    if (ARGUMENT_PRESENT(DfsName)) {
        name = DfsName;
    } else {
        name = &LocalDfsName;
    }

    InitializeObjectAttributes(
        &objectAttributes,
        name,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    status = NtCreateFile(
        DfsHandle,
        SYNCHRONIZE | FILE_WRITE_DATA,
        &objectAttributes,
        &ioStatus,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_IF,
        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0);

    if (NT_SUCCESS(status))
        status = ioStatus.Status;

    return status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctlEx, local
//
//  Synopsis:   Issues an NtFsControlFile call to the Dsfs file system
//              driver.
//
//  Arguments:  [DfsFile] -- Target of fsctl
//              [FsControlCode] -- The file system control code to be used
//              [InputBuffer] -- The fsctl input buffer
//              [InputBufferLength]
//              [OutputBuffer] -- The fsctl output buffer
//              [OutputBufferLength]
//              [pInformation] -- Information field of returned IoStatus.
//
//  Returns:    NTSTATUS - the status of the open or fsctl operation.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsFsctlEx(
    IN HANDLE DfsFile,
    IN ULONG FsControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG pInformation
) {
    NTSTATUS Stat;
    IO_STATUS_BLOCK IoStatus;

    Stat = NtFsControlFile(
        DfsFile,
        NULL,           // Event,
        NULL,           // ApcRoutine,
        NULL,           // ApcContext,
        &IoStatus,
        FsControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength );

   if ( NT_SUCCESS(Stat) ) {
       Stat = IoStatus.Status;
       *pInformation = (ULONG)IoStatus.Information;
   }

   return Stat;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctl, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

NTSTATUS
DfsFsctl(
    IN  HANDLE DfsHandle,
    IN  ULONG FsControlCode,
    IN  PVOID InputBuffer OPTIONAL,
    IN  ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN  ULONG OutputBufferLength
)
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;

    status = NtFsControlFile(
        DfsHandle,
        NULL,       // Event,
        NULL,       // ApcRoutine,
        NULL,       // ApcContext,
        &ioStatus,
        FsControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength
    );

    if(NT_SUCCESS(status))
        status = ioStatus.Status;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\lib\uminfo.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:   uMInfo.C
//
//  Contents:
//  This module implements the user mode utility for initializing .DFS
//  files and reading them back.
//
//  Functions:
//
//  History:     27 May 1992 PeterCo Created.
//
//-----------------------------------------------------------------------------

#include <ntifs.h>
#include <ntext.h>
#include "nodetype.h"
#include "dfsmrshl.h"
#include "libsup.h"
#include "upkt.h"

#include "minfo.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\lib\upkt.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       UPkt.c
//
//  Contents:   This module contains user mode functions which support
//              operations on the DFS Partition Knowledge Table.
//
//  Functions:  PktOpen -
//              PktClose -
//              PktCreateEntry -
//              PktCreateSubordinateEntry -
//              PktFlushCache -
//              PktDestroyEntry -
//              PktModifyEntryGuid -
//              PktSetRelationInfo -
//
//  History:
//
//  [mikese] I replaced MemAlloc's by malloc's, but consider using
//                   RtlAllocateHeap.
//          Also, most of the routines in the module have a remarkably similar
//          structure, and could probably be recoded using a common subroutine.
//
//-----------------------------------------------------------------------------


#include <ntifs.h>
#include <ntext.h>
#include "dfsmrshl.h"
#include "nodetype.h"
#include "libsup.h"
#include "upkt.h"
#include "dfsfsctl.h"
#include "fsctrl.h"    // needed for FSCTL_DFS_PKT_FLUSH_CACHE

#define MAX_OUT_BUFFER_SIZE_RELINFO     0x1000  


//+-------------------------------------------------------------------------
//
//  Function:   PktOpen, public
//
//  Synopsis:   Returns a handle to the Dfs PKT so operations can be made
//              to it.
//
//  Arguments:
//
//  Returns:    [STATUS_SUCCESS] -- Successfully opened the pkt.
//
//              [STATUS_FS_DRIVER_REQUIRED] -- Dfs driver not loaded
//
//--------------------------------------------------------------------------

NTSTATUS
PktOpen(
    IN  OUT PHANDLE PktHandle,
    IN      ACCESS_MASK DesiredAccess,
    IN      ULONG ShareAccess,
    IN      PUNICODE_STRING DfsNtPathName OPTIONAL
)
{
    NTSTATUS status;
    HANDLE dfsHandle;

    status = DfsOpen(&dfsHandle, DfsNtPathName);

    if(NT_SUCCESS(status)) {

       *PktHandle = dfsHandle;

    } else {

        status = STATUS_FS_DRIVER_REQUIRED;

    }

    return status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PktClose, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------------
VOID
PktClose(
    IN      HANDLE PktHandle
)
{
    NTSTATUS status = STATUS_SUCCESS;

    if(NT_SUCCESS(status))
        NtClose(PktHandle);
}


//+-------------------------------------------------------------------------
//
//  Function:   PktCreateEntry, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

NTSTATUS
PktCreateEntry(
    IN      HANDLE PktHandle,
    IN      ULONG EntryType,
    IN      PDFS_PKT_ENTRY_ID EntryId,
    IN      PDFS_PKT_ENTRY_INFO EntryInfo,
    IN      ULONG CreateDisposition
)
{
    NTSTATUS                    status;
    DFS_PKT_CREATE_ENTRY_ARG    arg;
    MARSHAL_BUFFER              marshalBuffer;
    ULONG                       size;

    arg.EntryType = EntryType;
    arg.EntryId = (*EntryId);
    arg.EntryInfo = (*EntryInfo);
    arg.CreateDisposition = CreateDisposition;

    size = 0L;
    status = DfsRtlSize(&MiPktCreateEntryArg, &arg, &size);
    if(NT_SUCCESS(status))
    {

        PVOID buffer = malloc ( size );

        if ( buffer == NULL )
            return(STATUS_NO_MEMORY);

        MarshalBufferInitialize(&marshalBuffer, size, buffer);
        status = DfsRtlPut(
            &marshalBuffer,
            &MiPktCreateEntryArg,
            &arg
        );

        if(NT_SUCCESS(status))
        {

            status = DfsFsctl(
                PktHandle,
                FSCTL_DFS_PKT_CREATE_ENTRY,
                buffer,
                size,
                NULL,
                0L
            );
        }
        free(buffer);
    }
    return status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PktCreateSubordinateEntry, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

NTSTATUS
PktCreateSubordinateEntry(
    IN      HANDLE PktHandle,
    IN      PDFS_PKT_ENTRY_ID SuperiorId,
    IN      ULONG SubordinateType,
    IN      PDFS_PKT_ENTRY_ID SubordinateId,
    IN      PDFS_PKT_ENTRY_INFO SubordinateInfo OPTIONAL,
    IN      ULONG CreateDisposition
)
{
    NTSTATUS                                    status;
    DFS_PKT_CREATE_SUBORDINATE_ENTRY_ARG        arg;
    MARSHAL_BUFFER                              marshalBuffer;
    ULONG                                       size;

    arg.EntryId = (*SuperiorId);
    arg.SubEntryType = SubordinateType;
    arg.SubEntryId = (*SubordinateId);
    arg.SubEntryInfo = (*SubordinateInfo);
    arg.CreateDisposition = CreateDisposition;

    size = 0L;
    status = DfsRtlSize(&MiPktCreateSubordinateEntryArg, &arg, &size);
    if(NT_SUCCESS(status)) {

        PVOID buffer = malloc ( size );

        if ( buffer == NULL )
            return(STATUS_NO_MEMORY);

        MarshalBufferInitialize(&marshalBuffer, size, buffer);
        status = DfsRtlPut(
            &marshalBuffer,
            &MiPktCreateSubordinateEntryArg,
            &arg
        );

        if(NT_SUCCESS(status)) {

            status = DfsFsctl(
                PktHandle,
                FSCTL_DFS_PKT_CREATE_SUBORDINATE_ENTRY,
                buffer,
                size,
                NULL,
                0L
            );
        }
        free(buffer);
    }
    return status;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktDestroyEntry, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

NTSTATUS
PktDestroyEntry(
    IN      HANDLE PktHandle,
    IN      DFS_PKT_ENTRY_ID    victim
)
{
    NTSTATUS            status;
    MARSHAL_BUFFER      marshalBuffer;
    ULONG               size;

    size = 0L;
    status = DfsRtlSize(&MiPktEntryId, &victim, &size);
    if(NT_SUCCESS(status))
    {
        PVOID buffer = malloc ( size );

        if ( buffer == NULL )
            return(STATUS_NO_MEMORY);

        MarshalBufferInitialize(&marshalBuffer, size, buffer);
        status = DfsRtlPut(
            &marshalBuffer,
            &MiPktEntryId,
            &victim
        );

        if(NT_SUCCESS(status))
        {

            status = DfsFsctl(
                PktHandle,
                FSCTL_DFS_PKT_DESTROY_ENTRY,
                buffer,
                size,
                NULL,
                0L
            );
        }
        free(buffer);
    }
    return status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PktGetRelationInfo, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Notes:      The relationalInfo structure should be made available
//              by the caller but additional memory is allocated in here.
//              The caller should deallocate all that memory himself.
//
//--------------------------------------------------------------------------
NTSTATUS
PktGetRelationInfo(
    IN      HANDLE PktHandle,
    IN      PDFS_PKT_ENTRY_ID   EntryId,
    IN OUT  PDFS_PKT_RELATION_INFO RelationInfo
)
{
    NTSTATUS            status;
    MARSHAL_BUFFER      marshalBuffer;
    ULONG               size;
    PVOID               OutputBuffer;

    size = 0L;
    status = DfsRtlSize(&MiPktEntryId, EntryId, &size);
    if(NT_SUCCESS(status))
    {
        PVOID buffer = malloc ( size );

        if ( buffer == NULL )
            return(STATUS_NO_MEMORY);

        MarshalBufferInitialize(&marshalBuffer, size, buffer);
        status = DfsRtlPut(
            &marshalBuffer,
            &MiPktEntryId,
            EntryId
        );


        if(NT_SUCCESS(status))
        {

            // Do we want to retry with larger sizes?
            OutputBuffer = malloc ( MAX_OUT_BUFFER_SIZE_RELINFO );
            if ( OutputBuffer == NULL )
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {

                status = DfsFsctl(
                            PktHandle,
                            FSCTL_DFS_PKT_GET_RELATION_INFO,
                            buffer,
                            size,
                            OutputBuffer,
                            MAX_OUT_BUFFER_SIZE_RELINFO);

                //
                // We can get rid of this right away.
                //


                if(NT_SUCCESS(status)) {

                    MarshalBufferInitialize(
                        &marshalBuffer,
                        MAX_OUT_BUFFER_SIZE_RELINFO,
                        OutputBuffer
                    );

                    status = DfsRtlGet(
                        &marshalBuffer,
                        &MiPktRelationInfo,
                        RelationInfo
                    );
                }

                free(OutputBuffer);
            }
        }
        free(buffer);

    }   //Status from DfsRtlSize

    if (!NT_SUCCESS(status))    {
        RtlZeroMemory(RelationInfo, sizeof(DFS_PKT_RELATION_INFO));
    }

    return status;
}


//+----------------------------------------------------------------------------
//
//  Function:   PktValidateLocalVolumeInfo, public
//
//  Synopsis:   Asks the Dfs driver to validate its local volume info with
//              the one that is passed in.
//
//  Arguments:  [relationInfo] -- The DFS_PKT_RELATION_INFO to validate
//                      against.
//
//  Returns:    [STATUS_SUCCESS] -- Successfully validated local volume info
//
//              [STATUS_REGISTRY_RECOVERED] -- Successfully validated info,
//                      but had to make changes to local info
//
//              [DFS_STATUS_NOSUCH_LOCAL_VOLUME] -- The driver has no record
//                      of local volume described in relation info.
//
//              [STATUS_UNSUCCESSFUL] -- Unable to fixup the local relation
//                      info. An appropriate message was logged to the
//                      local eventlog.
//
//              [STATUS_DATA_ERROR] -- Passed in relationInfo is bogus.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory condition.
//
//              [STATUS_FS_DRIVER_REQUIRED] -- Unable to open handle to the
//                      Dfs driver
//
//-----------------------------------------------------------------------------

NTSTATUS
PktValidateLocalVolumeInfo(
    IN PDFS_PKT_RELATION_INFO relationInfo)
{
    NTSTATUS status;
    HANDLE dfsHandle;
    MARSHAL_BUFFER marshalBuffer;
    PUCHAR pBuffer;
    ULONG cbBuffer;

    status = DfsOpen(&dfsHandle, NULL);

    if (NT_SUCCESS(status)) {

        cbBuffer = 0;

        status = DfsRtlSize( &MiPktRelationInfo, relationInfo, &cbBuffer );

        if (NT_SUCCESS(status)) {

            pBuffer = malloc( cbBuffer );

            if (pBuffer != NULL) {

                MarshalBufferInitialize(&marshalBuffer, cbBuffer, pBuffer);

                status = DfsRtlPut(
                            &marshalBuffer,
                            &MiPktRelationInfo,
                            relationInfo);


            } else {

                status = STATUS_INSUFFICIENT_RESOURCES;

            }

            if (NT_SUCCESS(status)) {

                status = DfsFsctl(
                            dfsHandle,
                            FSCTL_DFS_VERIFY_LOCAL_VOLUME_KNOWLEDGE,
                            pBuffer,
                            cbBuffer,
                            NULL,
                            0);

            }

            if (pBuffer != NULL)
                free(pBuffer);

        }

        NtClose( dfsHandle );

    }

    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   PktPruneLocalPartition
//
//  Synopsis:   Asks the Dfs Driver to get rid of a local volume that is
//              not supposed to be supported by this server.
//
//  Arguments:  [EntryId] -- The entry id of the volume to prune.
//
//  Returns:    [STATUS_SUCCESS] -- Successfully pruned the volume
//
//              [DFS_STATUS_NOSUCH_LOCAL_VOLUME] -- The driver has no record
//                      of local volume described in relation info.
//
//              [STATUS_UNSUCCESSFUL] -- Unable to fixup the local relation
//                      info. An appropriate message was logged to the
//                      local eventlog.
//
//              [STATUS_DATA_ERROR] -- Passed in relationInfo is bogus.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory condition.
//
//              [STATUS_FS_DRIVER_REQUIRED] -- Unable to open handle to the
//                      Dfs driver
//
//-----------------------------------------------------------------------------

NTSTATUS
PktPruneLocalPartition(
    IN PDFS_PKT_ENTRY_ID EntryId)
{
    NTSTATUS status;
    HANDLE dfsHandle;
    MARSHAL_BUFFER marshalBuffer;
    PUCHAR pBuffer;
    ULONG cbBuffer;

    status = DfsOpen(&dfsHandle, NULL);

    if (NT_SUCCESS(status)) {

        cbBuffer = 0;

        status = DfsRtlSize( &MiPktEntryId, EntryId, &cbBuffer );

        if (NT_SUCCESS(status)) {

            pBuffer = malloc( cbBuffer );

            if (pBuffer != NULL) {

                MarshalBufferInitialize(&marshalBuffer, cbBuffer, pBuffer);

                status = DfsRtlPut(
                            &marshalBuffer,
                            &MiPktEntryId,
                            EntryId);


            } else {

                status = STATUS_INSUFFICIENT_RESOURCES;

            }

            if (NT_SUCCESS(status)) {

                status = DfsFsctl(
                            dfsHandle,
                            FSCTL_DFS_PRUNE_LOCAL_PARTITION,
                            pBuffer,
                            cbBuffer,
                            NULL,
                            0);

            }

            if (pBuffer != NULL)
                free(pBuffer);

        }

        NtClose( dfsHandle );

    }

    return( status );
}


//+----------------------------------------------------------------------------
//
//  Function:   PktIsChildnameLegal, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
PktIsChildnameLegal(
    IN PWCHAR   pwszParent,
    IN PWCHAR   pwszChild,
    IN GUID     *pidChild)
{
    HANDLE           dfsHandle;
    NTSTATUS         Status;
    DFS_PKT_ENTRY_ID idParent, idChild;
    MARSHAL_BUFFER   marshalBuffer;
    PUCHAR           pBuffer;
    ULONG            cbBuffer;

    RtlZeroMemory( &idParent, sizeof(DFS_PKT_ENTRY_ID) );

    RtlZeroMemory( &idChild, sizeof(DFS_PKT_ENTRY_ID) );

    RtlInitUnicodeString( &idParent.Prefix, pwszParent );

    RtlInitUnicodeString( &idChild.Prefix, pwszChild );

    idChild.Uid = *pidChild;

    cbBuffer = 0;

    Status = DfsOpen(&dfsHandle, NULL);

    if (NT_SUCCESS(Status)) {

        Status = DfsRtlSize( &MiPktEntryId, &idParent, &cbBuffer );

        if (NT_SUCCESS(Status)) {

            Status = DfsRtlSize( &MiPktEntryId, &idChild, &cbBuffer );
        }

        if (NT_SUCCESS(Status)) {

            pBuffer = malloc( cbBuffer );

            if (pBuffer != NULL) {

                MarshalBufferInitialize( &marshalBuffer, cbBuffer, pBuffer );

                Status = DfsRtlPut(
                            &marshalBuffer,
                            &MiPktEntryId,
                            &idParent );

                if (NT_SUCCESS(Status)) {

                    Status = DfsRtlPut(
                                &marshalBuffer,
                                &MiPktEntryId,
                                &idChild );

                }

                if (NT_SUCCESS(Status)) {

                    Status = DfsFsctl(
                                dfsHandle,
                                FSCTL_DFS_IS_CHILDNAME_LEGAL,
                                pBuffer,
                                cbBuffer,
                                NULL,
                                0L);

                }

                free( pBuffer );

            } else {

                Status = STATUS_INSUFFICIENT_RESOURCES;

            }

        }

        NtClose( dfsHandle );

    }

    return( Status );

}


//+----------------------------------------------------------------------------
//
//  Function:   PktGetEntryType, public
//
//  Synopsis:   Given a prefix, this routine retrieves the entry type of the
//              PktEntry
//
//  Arguments:  [pwszPrefix] -- The prefix whose PktEntry's type is required
//              [pType] -- The type is returned here.
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
PktGetEntryType(
    IN PWSTR pwszPrefix,
    IN PULONG pType)
{
    HANDLE           dfsHandle;
    NTSTATUS         Status;

    Status = DfsOpen(&dfsHandle, NULL);

    if (NT_SUCCESS(Status)) {

        Status = DfsFsctl(
                    dfsHandle,
                    FSCTL_DFS_GET_ENTRY_TYPE,
                    pwszPrefix,
                    wcslen(pwszPrefix) * sizeof(WCHAR),
                    pType,
                    sizeof(ULONG));

        NtClose( dfsHandle );

    }

    return( Status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsSetServiceState
//
//  Synopsis:   Sets the state of a service on a volume.
//
//  Arguments:  [VolumeId] -- The volume on which to operate
//              [ServiceName] -- Name of service
//              [State] -- Either 0 or DFS_SERVICE_TYPE_OFFLINE
//
//  Returns:    [STATUS_SUCCESS] -- The specified replica was set
//                      online/offline as speficied.
//
//              [DFS_STATUS_NO_SUCH_ENTRY] -- The specified volume was not
//                      found, or the specified replica is not a server for
//                      the volume.
//
//              [STATUS_DATA_ERROR] -- marshalling or unmarshalling error.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory situation.
//
//              Status from opening handle to the Dfs driver.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsSetServiceState(
    IN PDFS_PKT_ENTRY_ID VolumeId,
    IN PWSTR ServiceName,
    IN ULONG State)
{
    NTSTATUS                    status;
    HANDLE                      dfsHandle = NULL;
    DFS_DC_SET_SERVICE_STATE    setSvcState;
    MARSHAL_BUFFER              marshalBuffer;
    PUCHAR                       buffer = NULL;
    ULONG                       size;

    status = DfsOpen( &dfsHandle, NULL );

    if (NT_SUCCESS(status)) {

        setSvcState.Id = *VolumeId;
        RtlInitUnicodeString(
            &setSvcState.ServiceName,
            ServiceName);
        setSvcState.State = State;

        size = 0;

        status = DfsRtlSize( &MiDCSetServiceState, &setSvcState, &size );

        if (NT_SUCCESS(status)) {

            buffer = (PUCHAR) malloc( size );

            if (buffer == NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;

            }

        }

        if (NT_SUCCESS(status)) {

            MarshalBufferInitialize( &marshalBuffer, size, buffer );

            status = DfsRtlPut( &
                        marshalBuffer,
                        &MiDCSetServiceState,
                        &setSvcState );

        }

        if (NT_SUCCESS(status)) {

            status = DfsFsctl(
                        dfsHandle,
                        FSCTL_DFS_SET_SERVICE_STATE,
                        buffer,
                        size,
                        NULL,
                        0);

        }

        NtClose( dfsHandle );

        if (buffer != NULL) {

            free( buffer );

        }

    }

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsDCSetVolumeState
//
//  Synopsis:   Sets the state of a volume in the DCs. This will control
//              whether referrals will be given out to this volume or not.
//
//  Arguments:  [VolumeId] -- The volume on which to operate
//              [State] -- Either 0 or PKT_ENTRY_TYPE_OFFLINE
//
//  Returns:    [STATUS_SUCCESS] -- The specified replica was set
//                      online/offline as speficied.
//
//              [DFS_STATUS_NO_SUCH_ENTRY] -- The specified volume was not
//                      found.
//
//              [STATUS_DATA_ERROR] -- marshalling or unmarshalling error.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory situation.
//
//              Status from opening handle to the Dfs driver.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsDCSetVolumeState(
    IN const PDFS_PKT_ENTRY_ID VolumeId,
    IN const ULONG State)
{
    NTSTATUS                    status;
    HANDLE                      dfsHandle = NULL;
    DFS_SETSTATE_ARG            setStateArg;
    MARSHAL_BUFFER              marshalBuffer;
    PUCHAR                      buffer = NULL;
    ULONG                       size;

    status = DfsOpen( &dfsHandle, NULL );

    if (NT_SUCCESS(status)) {

        setStateArg.Id = *VolumeId;
        setStateArg.Type = State;

        size = 0;

        status = DfsRtlSize( &MiSetStateArg, &setStateArg, &size );

        if (NT_SUCCESS(status)) {

            buffer = (PUCHAR) malloc( size );

            if (buffer == NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;

            }

        }

        if (NT_SUCCESS(status)) {

            MarshalBufferInitialize( &marshalBuffer, size, buffer );

            status = DfsRtlPut( &
                        marshalBuffer,
                        &MiSetStateArg,
                        &setStateArg );

        }

        if (NT_SUCCESS(status)) {

            status = DfsFsctl(
                        dfsHandle,
                        FSCTL_DFS_DC_SET_VOLUME_STATE,
                        buffer,
                        size,
                        NULL,
                        0);

        }

        NtClose( dfsHandle );

        if (buffer != NULL) {

            free( buffer );

        }

    }

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsSetVolumeTimeout
//
//  Synopsis:   Sets the timeout of a volume in the DCs.
//
//  Arguments:  [VolumeId] -- The volume on which to operate
//              [Timeout] -- Timeout, in seconds
//
//  Returns:    [STATUS_SUCCESS] -- The specified timeout was set as specified.
//
//              [DFS_STATUS_NO_SUCH_ENTRY] -- The specified volume was not
//                      found.
//
//              [STATUS_DATA_ERROR] -- marshalling or unmarshalling error.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory situation.
//
//              Status from opening handle to the Dfs driver.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsSetVolumeTimeout(
    IN const PDFS_PKT_ENTRY_ID VolumeId,
    IN const ULONG Timeout)
{
    NTSTATUS                    status;
    HANDLE                      dfsHandle = NULL;
    DFS_SET_VOLUME_TIMEOUT_ARG  setVolTimeoutArg;
    MARSHAL_BUFFER              marshalBuffer;
    PUCHAR                      buffer = NULL;
    ULONG                       size;

    status = DfsOpen( &dfsHandle, NULL );

    if (NT_SUCCESS(status)) {

        setVolTimeoutArg.Id = *VolumeId;
        setVolTimeoutArg.Timeout = Timeout;

        size = 0;

        status = DfsRtlSize( &MiSetVolTimeoutArg, &setVolTimeoutArg, &size );

        if (NT_SUCCESS(status)) {

            buffer = (PUCHAR) malloc( size );

            if (buffer == NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;

            }

        }

        if (NT_SUCCESS(status)) {

            MarshalBufferInitialize( &marshalBuffer, size, buffer );

            status = DfsRtlPut( &
                        marshalBuffer,
                        &MiSetVolTimeoutArg,
                        &setVolTimeoutArg );

        }

        if (NT_SUCCESS(status)) {

            status = DfsFsctl(
                        dfsHandle,
                        FSCTL_DFS_SET_VOLUME_TIMEOUT,
                        buffer,
                        size,
                        NULL,
                        0);

        }

        NtClose( dfsHandle );

        if (buffer != NULL) {

            free( buffer );

        }

    }

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsCreateSiteEntry
//
//  Synopsis:   Loads a Site entry into the dfs site table
//
//  Arguments:  [pInfoArg] -- DFS_CREATE_SITE_INFO_ARG with info to update
//
//  Returns:    Status from opening handle to the Dfs driver.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsCreateSiteEntry(
    PCHAR arg,
    ULONG size)
{
    NTSTATUS                    status;
    HANDLE                      dfsHandle = NULL;

    status = DfsOpen( &dfsHandle, NULL );

    if (NT_SUCCESS(status)) {


        status = DfsFsctl(
                    dfsHandle,
                    FSCTL_DFS_CREATE_SITE_INFO,
                    arg,
                    size,
                    NULL,
                    0);

        NtClose( dfsHandle );

    }

    return( status );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsDeleteSiteEntry
//
//  Synopsis:   Loads a Site entry into the dfs site table
//
//  Arguments:  [pInfoArg] -- DFS_DELETE_SITE_INFO_ARG with info to update
//
//  Returns:    Status from opening handle to the Dfs driver.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsDeleteSiteEntry(
    PCHAR arg,
    ULONG size)
{
    NTSTATUS                    status;
    HANDLE                      dfsHandle = NULL;

    status = DfsOpen( &dfsHandle, NULL );

    if (NT_SUCCESS(status)) {


        status = DfsFsctl(
                    dfsHandle,
                    FSCTL_DFS_DELETE_SITE_INFO,
                    arg,
                    size,
                    NULL,
                    0);

        NtClose( dfsHandle );

    }

    return( status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\setup\init.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       init.cxx
//
//  Contents:   This has the dll initialisation for the Dfs Setup DLL
//
//  Functions:
//
//  History:    19-Jan-96       Milans created
//
//-----------------------------------------------------------------------------

#include <windows.h>

HINSTANCE g_hInstance;

extern "C" BOOL
DllMain(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpReserved)
{
    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hInstance = hDll;
        DisableThreadLibraryCalls(hDll);
        break;

    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\setup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by app.rc
//
#define IDS_APP_MSG_NOT_FOUND           1
#define IDS_MSGTITLE                    2
#define IDC_NEWSHARE                    3
#define IDC_BROWSE                      3
#define IDS_DFSHOSTING                  3
#define IDD_CONFIGDFS                   101
#define IDD_DFSSHARE                    101
#define IDD_NEWSHARE                    102
#define IDD_CREATEDFS                   104
#define IDC_HOSTDFS                     1000
#define IDC_DFSROOT                     1001
#define IDC_DIRECTORY_TEXT              1003
#define IDC_CREATESHARE                 1006
#define IDC_DIRECTORY                   1007
#define IDC_MAKEFTDFS                   1008
#define IDC_FTDFS                       1009
#define IDC_CREATE_FTDFS                1010
#define IDC_JOIN_FTDFS                  1011
#define IDC_CREATE_DFS                  1012
#define IDC_CREATE_FTDFS_TX             1013
#define IDC_JOIN_FTDFS_CB               1014
#define IDC_CREATE_DOMAIN_TX            1016

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        108
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\setup\registry.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       registry.cxx
//
//  Contents:   implementations for CRegKey member Members
//
//  Members:    CRegKey::CRegKey - constructor for registry key object
//              CRegKey::CRegKey - constructor for registry key object
//              CRegKey::CreateKey - real worker for constructors
//              CRegKey::~CRegKey - destructor for registry key object
//              CRegKey::Delete - delete a registry key
//              CRegKey::EnumValues - enumerate values of a registry key
//              CRegKey::EnumKeys - enumerate subkeys of a registry key
//              CRegKey::NotifyChange - setup change notification for a key
//
//              CRegValue::GetValue - sets a registry value
//              CRegValue::SetValue - retrieves a registry value
//              CRegValue::Delete - deletes a registry value
//              CRegValue::GetTypeCode - returns the type code of the value
//
//              CRegMSZ::SetStrings - sets a multi-string registry value
//              CRegMSZ::GetStrings - retrieves a multi-string registry value
//
//  History:    09/30/92    Rickhi  Created
//              09/22/93    AlokS   Took out exception throwing code
//                                  and added proper return code for
//                                  each method.
//
//              07/26/94    AlokS   Made it real light weight for simple
//                                  registry set/get operations
//
//  Notes:      see notes in registry.hxx
//
//----------------------------------------------------------------------------

#include    <stdlib.h>
#include    <windows.h>
#include    <registry.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using HKEY for parent
//
//  Arguments:  [hkParent] - handle to parent key
//              [pwszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pwszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//              [fThrowExceptionOnError] - Constructor throw exception on error
//
//  Signals:    Internal error state is set if construction fails.
//
//  Returns:    -none-
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All except the hkParent and pwszPath are optional parameters.
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        HKEY hkParent,
        const LPWSTR pwszPath,
        REGSAM samDesiredAccess,
        const LPWSTR pwszClass,
        DWORD dwOptions,
        DWORD *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
    :_hkParent(hkParent),
     _hkThis(NULL),
     _dwErr (ERROR_SUCCESS)
{
    _dwErr = CreateKey( _hkParent,
                     pwszPath,
                     samDesiredAccess,
                     pwszClass,
                     dwOptions,
                     pdwDisposition,
                     pSecurityAttributes );
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using CRegKey for parent
//
//  Arguments:  [prkParent] - ptr to Parent CRegKey
//              [pwszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pwszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//              [fThrowExceptionOnError] - Constructor throw exception on error
//
//  Signals:    Internal Error state is set if error occures during construction.
//
//  Returns:    nothing
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All except the prkParent and pwszPath are optional parameters.
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        const CRegKey &crkParent,
        const LPWSTR pwszPath,
        REGSAM samDesiredAccess,
        const LPWSTR pwszClass,
        DWORD dwOptions,
        DWORD *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
    :_hkParent(crkParent.GetHandle()),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
    _dwErr = CreateKey ( _hkParent,
                      pwszPath,
                      samDesiredAccess,
                      pwszClass,
                      dwOptions,
                      pdwDisposition,
                      pSecurityAttributes );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using HKEY for parent
//                              Merely opens the key, if exist
//
//  Arguments:  [hkParent] - HKEY to Parent
//                              [dwErr]      - Error code returned here
//                      [pwszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    Internal Error state is set if error occures during construction
//
//  Returns:    nothing
//
//  History:    09/22/93    AlokS  Created
//
//  Notes:      Check error status to determine if constructor succeeded
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        HKEY hkParent,
        DWORD *pdwErr,
        const LPWSTR pwszPath,
        REGSAM samDesiredAccess )
    :_hkParent(hkParent),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
     *pdwErr = _dwErr = OpenKey  ( _hkParent, pwszPath, samDesiredAccess );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CRegKey
//
//  Synopsis:   Constructor for registry key object, using CRegKey for parent
//                              Merely opens the key, if exist
//
//  Arguments:  [prkParent] - ptr to Parent CRegKey
//              [dwErr]           -  Error code returned here.
//                      [pwszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    Internal Error state is set if error occures during construction
//
//  Returns:    nothing
//
//  History:    09/22/93    AlokS  Created
//
//  Notes:      Check error status to determine if constructor succeeded
//
//--------------------------------------------------------------------------

CRegKey::CRegKey (
        const CRegKey  &crkParent,
        DWORD *pdwErr,
        const LPWSTR pwszPath,
        REGSAM   samDesiredAccess )
    :_hkParent(crkParent.GetHandle()),
     _hkThis(NULL),
     _dwErr(ERROR_SUCCESS)
{
     *pdwErr = _dwErr = OpenKey ( _hkParent, pwszPath, samDesiredAccess );
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::~CRegKey, public
//
//  Synopsis:   Destructor for registry key object
//
//  Arguments:  none
//
//  Signals:    nothing
//
//  Returns:    nothing
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

CRegKey::~CRegKey()
{
    if (_hkThis != NULL)
        RegCloseKey(_hkThis);
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::CreateKey, private
//
//  Synopsis:   This method does the real work of the constructors.
//
//  Arguments:  [hkParent] - handle to parent key
//              [pwszPath] - pathname to key
//              [samDesiredAccess] - desired access rights to the key
//              [pwszClass] - class for the key
//              [dwOptions] - options for the key eg volatile or not
//              [pdwDisposition] - to find out if key was opened or created
//              [pSecurityAttributes] - used only if the key is created
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      All parameters are required.
//
//--------------------------------------------------------------------------

DWORD CRegKey::CreateKey (
        HKEY hkParent,
        const LPWSTR  pwszPath,
        REGSAM  samDesiredAccess,
        const LPWSTR  pwszClass,
        DWORD   dwOptions,
        DWORD   *pdwDisposition,
        const LPSECURITY_ATTRIBUTES pSecurityAttributes )
{
    DWORD   dwDisposition;
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;
    LPSECURITY_ATTRIBUTES lpsec = pSecurityAttributes;

    //  create/open the key
    if ((dwRc = RegCreateKeyEx(hkParent,
                           pwszPath,           //  path to key
                           0,                  //  title index
                           pwszClass,          //  class of key
                           dwOptions,          //  key options
                           samDesiredAccess,   //  desired access
                           lpsec,              //  if created
                           &_hkThis,           //  handle
                           &dwDisposition)     //  opened/created
                          )==ERROR_SUCCESS)
    {
        //  save away the name
        _cwszName.Set(pwszPath);

        //  setup the return parameters
        if (pdwDisposition != NULL)
            *pdwDisposition = dwDisposition;

    }
    else
        dwErr = Creg_ERROR(dwRc);

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::OpenKey, private
//
//  Synopsis:   This method does the real work of the constructors.
//
//  Arguments:  [hkParent] - handle to parent key
//                      [pwszPath] - pathname to key
//                      [samDesiredAccess] - desired access rights to the key
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/22/93        AlokS  Created
//
//  Notes:      All parameters are required.
//
//--------------------------------------------------------------------------

DWORD CRegKey::OpenKey (
        HKEY    hkParent,
        const  LPWSTR  pwszPath,
        REGSAM  samDesiredAccess )
{
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;

    //  open the key
    if ((dwRc = RegOpenKeyEx(hkParent,
                         pwszPath,           //  path to key
                         0,                  //  reserved
                         samDesiredAccess,   //  desired access
                         &_hkThis            //  handle
                        ))==ERROR_SUCCESS)
    {
        //  save away the name
        _cwszName.Set(pwszPath);

    }
    else
        dwErr = Creg_ERROR(dwRc);

    return(dwErr);
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::Delete, public
//
//  Synopsis:   Deletes an existing key from the registry.  Note that
//              the key object still exists, the destructor must be
//              called seperately.
//
//  Arguments:  none
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CRegKey::Delete(void)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD   dwRc;
    SRegKeySet *pChildren;

    dwErr = this->EnumKeys(&pChildren);

    if (dwErr == ERROR_SUCCESS) {

        ULONG i;
        DWORD dwErrDelete = ERROR_SUCCESS;

        for(i = 0; i < pChildren->cKeys; i++) {

            dwErr = pChildren->aprkKey[i]->Delete();

            if (dwErr != ERROR_SUCCESS) {

                dwErrDelete = dwErr;

            }

            delete pChildren->aprkKey[i];

        }

        if (dwErrDelete == ERROR_SUCCESS) {

            if (( dwRc= RegDeleteKey(_hkThis, NULL))!=ERROR_SUCCESS) {

                dwErr = Creg_ERROR(dwRc);

            }

        } else {

            dwErr = dwErrDelete;

        }

        delete pChildren;

    }

    return(dwErr);
}

//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::EnumValues, public
//
//  Synopsis:   Enumerates the values stored in an open registry key.
//
//  Arguments:  [pprvs] - SRegValueSet allocated and returned by this
//                                    method.  The caller is responsible for releasing
//                                    the allocated CRegValue objects via delete and the
//                                    SRegValueSet structure via CRegKey::MemFree.
//
//  Signals:  none
//
//  Returns:  ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:      The data associated with each Value is not returned. The
//              caller may invoke the GetValue method of each CRegValue
//              returned to get it's associated data.
//
//--------------------------------------------------------------------------

DWORD CRegKey::EnumValues(SRegValueSet **pprvs)
{
    DWORD dwErr = ERROR_SUCCESS;

    //  figure out how many values are currently stored in this key
    //  and allocate a buffer to hold the return results.

    WCHAR   wszClass[MAX_PATH];
    ULONG   cbClass = sizeof(wszClass);
    ULONG   cSubKeys, cbMaxSubKeyLen, cbMaxClassLen;
    ULONG   cValues, cbMaxValueIDLen, cbMaxValueLen;
    SECURITY_DESCRIPTOR SecDescriptor;
    FILETIME ft;

    DWORD dwRc = RegQueryInfoKey(_hkThis,
                               wszClass,
                               &cbClass,
                               NULL,
                               &cSubKeys,
                               &cbMaxSubKeyLen,
                               &cbMaxClassLen,
                               &cValues,
                               &cbMaxValueIDLen,
                               &cbMaxValueLen,
                               (DWORD *)&SecDescriptor,
                               &ft );

    if ( dwRc == ERROR_SUCCESS )
    {
        *pprvs = (SRegValueSet *) new BYTE [ sizeof(SRegValueSet)+
                                             cValues*sizeof(CRegValue *) ];
        if ( *pprvs == NULL )
        {
            dwErr = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        //   QueryInfo failed.
        dwErr = Creg_ERROR(dwRc);
    }
    if (dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    //  loop enumerating and creating a RegValue object for each value
    DWORD   dwIndex=0;

    do
    {
        WCHAR   wszValueID[MAX_PATH];
        ULONG   cbValueID = sizeof(wszValueID);
        DWORD   dwTypeCode;
        CRegValue *pRegVal;

        if ((dwRc = RegEnumValue(_hkThis,         //  handle
                        dwIndex,        //  index
                        wszValueID,     //  value id
                        &cbValueID,     //  length of value name
                        NULL,           //  title index
                        &dwTypeCode,    //  data type
                        NULL,           //  data buffer
                        NULL            //  size of data buffer
                      ))==ERROR_SUCCESS)
        {
            //  create the appropriate class of value object
            switch (dwTypeCode)
            {
            case REG_SZ:
                pRegVal = (CRegValue *) new CRegSZ((const CRegKey &)*this, wszValueID);
                break;

            case REG_DWORD:
                pRegVal = (CRegValue *) new CRegDWORD((const CRegKey &)*this, wszValueID);
                break;

            case REG_BINARY:
                pRegVal = (CRegValue *) new CRegBINARY((const CRegKey &)*this, wszValueID);
                break;

            default:
                pRegVal = (CRegValue *) new CRegBINARY((const CRegKey &)*this, wszValueID);
                break;
            }

            //  save ptr to value object and count another entry
            (*pprvs)->aprvValue[dwIndex++] = pRegVal;
        }
        else
        {
            //  error, we're done with the enumeration
            break;
        }

    } while (dwIndex < cValues);


    //  finished the enumeration, check the results
    if (dwRc == ERROR_NO_MORE_ITEMS || dwRc == ERROR_SUCCESS)
    {
        //  set the return count
        (*pprvs)->cValues = dwIndex;
    }
    else
    {
        //  Cleanup and return an error
        while (dwIndex)
        {
            delete (*pprvs)->aprvValue[--dwIndex];
        }

        delete [] *pprvs;

        dwErr = Creg_ERROR(dwRc);
    }

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegKey::EnumKeys, public
//
//  Synopsis:   Enumerates the subkeys of an open registry key.
//
//  Arguments:  [pprks] - SRegKeySet allocated and returned by this method.
//                        The caller is responsible for releasing all the
//                        allocated CRegKey objects and the SRegKeySet
//                        structure.
//
//  Signals:    none
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CRegKey::EnumKeys(SRegKeySet **pprks)
{
    //  figure out how many keys are currently stored in this key
    //  and allocate a buffer to hold the return results.

    WCHAR   wszClass[MAX_PATH];
    ULONG   cbClass = sizeof(wszClass);
    ULONG   cSubKeys, cbMaxSubKeyLen, cbMaxClassLen;
    ULONG   cValues, cbMaxValueIDLen, cbMaxValueLen;
    SECURITY_DESCRIPTOR SecDescriptor;
    FILETIME ft;
    DWORD  dwErr = ERROR_SUCCESS;

    DWORD dwRc = RegQueryInfoKey(_hkThis,
                     wszClass,
                     &cbClass,
                     NULL,
                     &cSubKeys,
                     &cbMaxSubKeyLen,
                     &cbMaxClassLen,
                     &cValues,
                     &cbMaxValueIDLen,
                     &cbMaxValueLen,
                     (DWORD *)&SecDescriptor,
                     &ft);

    if ( dwRc == ERROR_SUCCESS )
    {
        *pprks = (SRegKeySet*) new BYTE [sizeof(SRegKeySet)+cSubKeys*sizeof(CRegKey *)];
        if ( *pprks == NULL )
        {
            dwErr = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        //  QueryInfo failed..
        dwErr = Creg_ERROR(dwRc);
    }

    if (dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }
    //  loop enumerating and creating a RegKey object for each subkey
    DWORD   dwIndex=0;

    do
    {
        WCHAR   wszKeyName[MAX_PATH];
        ULONG   cbKeyName = sizeof(wszKeyName);
        WCHAR   wszClass[MAX_PATH];
        ULONG   cbClass = sizeof(wszClass);
        FILETIME ft;

        if ((dwRc = RegEnumKeyEx(_hkThis,         //  handle
                                dwIndex,        //  index
                                wszKeyName,     //  key name
                                &cbKeyName,     //  length of key name
                                NULL,           //  title index
                                wszClass,       //  class
                                &cbClass,       //  length of class
                                &ft             //  last write time
                              ))==ERROR_SUCCESS)
        {
            //  Create a CRegKey object for the subkey
            CRegKey *pRegKey = (CRegKey *) new CRegKey((const CRegKey &)*this, wszKeyName);
            if (ERROR_SUCCESS != (dwErr = pRegKey->QueryErrorStatus()))
            {
                break;
            }
            (*pprks)->aprkKey[dwIndex++] = pRegKey;
        }
        else
        {
            //  error, we're done with the enumeration
            break;
        }

    } while (dwIndex < cSubKeys);


    //  finished the enumeration, check the results
    if ((dwErr == ERROR_SUCCESS) &&
        ((dwRc == ERROR_NO_MORE_ITEMS || dwRc == ERROR_SUCCESS)))
    {
        //  set the return count
        (*pprks)->cKeys = dwIndex;
    }
    else
    {
        //  Cleanup and return an error
        while (dwIndex)
        {
            delete (*pprks)->aprkKey[--dwIndex];
        }

        delete [] *pprks;

        dwErr = Creg_ERROR(dwRc);
    }

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegValue::GetValue, public
//
//  Purpose:    Returns the data associated with a registry value.
//
//  Arguements: [pbData] - ptr to buffer supplied by caller.
//              [cbData] - size of data buffer supplied.
//              [pdwTypeCode] - type of data returned.
//
//  Signals:
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//
//
//--------------------------------------------------------------------------

DWORD CRegValue::GetValue(LPBYTE pbData, ULONG* pcbData, DWORD *pdwTypeCode)
{
    DWORD dwRc = RegQueryValueEx(GetParentHandle(),
                                    (LPWSTR)_cwszValueID,    //  value id
                                    NULL,        //  title index
                                    pdwTypeCode, //  type of data returned
                                    pbData,       //  data
                                    pcbData);       // size of data
    return(dwRc);
}


//+-------------------------------------------------------------------------
//
//  Member:     CRegValue::SetValue
//
//  Purpose:    Writes the data associated with a registry value.
//
//  Arguements: [pbData] - ptr to data to write.
//                      [cbData] - size of data to write.
//                      [dwTypeCode] - type of data to write.
//
//  Signals:    -none-
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/92    Rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD CRegValue::SetValue(const LPBYTE pbData, ULONG cbData, DWORD dwTypeCode)
{
    DWORD   dwRc;
    DWORD dwErr = ERROR_SUCCESS;
    if ((dwRc = RegSetValueEx(GetParentHandle(),        //  key handle
                             (LPWSTR)_cwszValueID,  //  value id
                              NULL,      //  title index
                              dwTypeCode,    //  type of info in buffer
                              pbData,        //  data
                              cbData)        //  size of data
                             )!= ERROR_SUCCESS)
    {
        dwErr = Creg_ERROR(dwRc);
    }
    return(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Function:   DelRegKeyTree
//
//  Purpose:    Deletes a key and any of it's children. This is like
//              delnode for registry
//
//  Arguements: [hParent]      - Handle to Parent Key
//              [lpwszKeyPath] - Path (relative to Parent) of the key
//
//  Signals:
//
//  Returns:    ERROR_SUCCESS on success. Else error from either Registry APIs
//              or from Memory allocation
//
//  History:    09/30/93    AlokS  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

DWORD DelRegKeyTree ( HKEY hParent, LPWSTR lpwszKeyPath)
{
    DWORD dwErr = ERROR_SUCCESS;
    CRegKey cregKey ( hParent,
                      lpwszKeyPath
                    );
    if (ERROR_SUCCESS != (dwErr = cregKey.QueryErrorStatus()))
    {
        return(dwErr);
    }

    // Enumerate the children of the key. We will
    // not propogate to the caller errors from enumeration
    SRegKeySet *pRegKeySet = NULL;
    if (ERROR_SUCCESS == (dwErr = cregKey.EnumKeys ( & pRegKeySet)))
    {
        // Now we have set of Keys which need to be deleted in depth
        // first manner
        for (ULONG i = 0; i < pRegKeySet->cKeys; i++ )
        {
            dwErr = DelRegKeyTree ( cregKey.GetHandle(),
                                 pRegKeySet->aprkKey[i]->GetName()
                               );

            // Delete the key itself
            delete pRegKeySet->aprkKey[i];
        }

        // Delete the enumerator structure
        delete pRegKeySet;
    }

    // Finally delete this key
    dwErr = cregKey.Delete();

    return(dwErr);
}


DWORD CRegKey::DeleteChildren()
{
    //  figure out how many keys are currently stored in this key

    ULONG   cSubKeys, cbMaxSubKeyLen;
    DWORD  dwErr = ERROR_SUCCESS;

    DWORD dwRc = RegQueryInfoKey(_hkThis,
                     NULL,
                     NULL,
                     NULL,
                     &cSubKeys,
                     &cbMaxSubKeyLen,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     NULL);

    if ( dwRc != ERROR_SUCCESS )
    {
         //  QueryInfo failed..
        dwErr = Creg_ERROR(dwRc);
    }

    if (dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }
    //  loop enumerating and creating a RegKey object for each subkey
    DWORD   dwIndex=0;

    do
    {
        WCHAR   wszKeyName[MAX_PATH];
        ULONG   cbKeyName = sizeof(wszKeyName);
        FILETIME ft;

        if ((dwRc = RegEnumKeyEx(_hkThis,         //  handle
                                dwIndex,        //  index
                                wszKeyName,     //  key name
                                &cbKeyName,     //  length of key name
                                NULL,           //  title index
                                NULL,       //  class
                                NULL,       //  length of class
                                &ft             //  last write time
                              ))==ERROR_SUCCESS)
        {
            //  Create a CRegKey object for the subkey
            CRegKey *pRegKey = (CRegKey *) new CRegKey((const CRegKey &)*this, wszKeyName);
            if (ERROR_SUCCESS != (dwErr = pRegKey->QueryErrorStatus()))
            {
                break;
            }
            pRegKey->DeleteChildren();
            delete pRegKey;
            dwRc = RegDeleteKey(_hkThis, wszKeyName);
        }
        else
        {
            //  error, we're done with the enumeration
            break;
        }

    } while (dwIndex < cSubKeys);


    //  finished the enumeration, check the results
    if ((dwErr == ERROR_SUCCESS) && 
        (dwRc != ERROR_NO_MORE_ITEMS && dwRc != ERROR_SUCCESS))
    {
        dwErr = Creg_ERROR(dwRc);
    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\setup\dfssetup.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1995, Microsoft Corporation
//
//  File:       dfssetup.cxx
//
//  Contents:   Code to setup Dfs on a machine.
//
//              Note that this code can be built as an exe or as a DLL. To
//              switch between the two, simply edit the following fields in
//              the sources file:
//                      TARGETTYPE=[PROGRAM | DYNLINK]
//                      UMTYPE=[console | windows]
//              Delete the following two lines from sources to build an exe.
//                      DLLDEF=obj\*\dfssetup.def
//                      DLLENTRY=_DllMainCRTStartup
//                      DLLBASE=@$(BASEDIR)\PUBLIC\SDK\LIB\coffbase.txt,dfssetup
//
//  Classes:    None
//
//  Functions:
//
//  History:    12-28-95        Milans  Created
//
//-----------------------------------------------------------------------------

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdlib.h>
}

#include <windows.h>
#include <rpc.h>                                 // For UuidCreate

#include <winldap.h>
#include <dsgetdc.h>

#include <lm.h>
#include <dfsstr.h>
#include <dfsmsrv.h>

#include <debug.h>                               // Needed for debug printing
#include <dfsm.hxx>                              // Needed for volume types
#include <lmerrext.h>

#include "registry.hxx"                          // Helper functions...
#include "setupsvc.hxx"

#include "config.hxx"                            // Config UI functions

//
// Until we get the schema right in the DS, we have to set our own SD on
// certain objects
//

#include <aclapi.h>
#include <permit.h>

DECLARE_DEBUG(DfsSetup)
DECLARE_INFOLEVEL(DfsSetup)

#if DBG == 1
#define dprintf(x)      DfsSetupInlineDebugOut x
# else
#define dprintf(x)
#endif

#define MAX_NETBIOS_NAME_LEN    16+1

extern DWORD
RemoveDfs(void);

BOOLEAN
DfsCheckForOldDfsService();

BOOLEAN
DfsIsDfsServiceRunning();

VOID
Usage();

DWORD
SetupDfsRoot(
    LPWSTR wszDfsRootShare);

DWORD
SetupFTDfs(
    IN LPWSTR wszRootShare,
    IN LPWSTR wszFTDfsName);

DWORD
InitializeVolumeObjectStorage();

DWORD
CreateVolumeObject(
    IN LPWSTR wszObjectName,
    IN LPWSTR pwszEntryPath,
    IN LPWSTR pwszServer,
    IN LPWSTR pwszShare,
    IN LPWSTR pwszComment,
    OUT GUID *guidVolume);

DWORD
CreateFTRootVolumeInfo(
    LPWSTR wszObjectName,
    LPWSTR wszFTDfsConfigDN,
    LPWSTR wszDomainName,
    LPWSTR wszDfsName,
    LPWSTR wszServerName,
    LPWSTR wszShareName,
    LPWSTR wszSharePath,
    LPWSTR wszDCName,
    BOOLEAN fNewFTDfs);

DWORD
StoreLvolInfo(
    IN GUID  *pVolumeID,
    IN PWSTR pwszStorageID,
    IN PWSTR pwszShareName,
    IN PWSTR pwszEntryPath,
    IN ULONG ulVolumeType);

DWORD
GetDomainAndComputerName(
    OUT LPWSTR wszDomain OPTIONAL,
    OUT LPWSTR wszComputer OPTIONAL);

DWORD
GetSharePath(
    IN LPWSTR wszShareName,
    OUT LPWSTR wszSharePath);

DWORD
TeardownFtDfs(
    IN LPWSTR wszRootShare,
    IN LPWSTR wszFTDfsName);

//+----------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   Entry point in case you want to build this as an exe.
//              Configures all Dfs components on a machine.
//
//  Arguments:  [argc] --
//              [argv] --
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

void _cdecl
main(int argc, char *argv[])
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cbRootLen;
    BOOL fRootSetup = FALSE;
    BOOLEAN OldDfsService = FALSE;
    WCHAR wszDfsRootShare[ MAX_PATH ];


    //
    // Figure out the type of machine we are installing on - client or root
    //


    if (argc != 1 && argc != 3) {
        Usage();
        return;
    }

    if (argc == 3) {

        fRootSetup = TRUE;

    }

    if ((dwErr == ERROR_SUCCESS) && fRootSetup) {

        if (_stricmp( argv[1], "-root" ) != 0) {

            Usage();

            return;

        }

        cbRootLen = strlen(argv[2]);

        mbstowcs( wszDfsRootShare, argv[2], cbRootLen + 1 );

        dprintf((DEB_ERROR,"Setting up Dfs Root...\n"));

    } else {

        dprintf((DEB_ERROR,"Setting up Dfs Server...\n"));

    }

    //
    // Configure the Dfs Driver
    //

    if (dwErr == ERROR_SUCCESS) {

        dwErr = ConfigDfs();

        if (dwErr == ERROR_SUCCESS) {

            dwErr = ConfigDfsService();

            if (dwErr != ERROR_SUCCESS) {

                dprintf((
                    DEB_ERROR, "Win32 error configuring Dfs Service %d\n",
                    dwErr));

                (void)RemoveDfs();

            } else {

                dprintf((DEB_ERROR,"Successfully configured Dfs...\n") );

            }

        } else {

            dprintf((DEB_ERROR,"Error %d configuring Dfs driver!\n", dwErr));

        }


    }

    //
    // If this is a root setup, configure the necessary information
    //

    if (dwErr == ERROR_SUCCESS && fRootSetup) {

        dwErr = SetupDfsRoot( wszDfsRootShare );

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   SetupDfsRoot
//
//  Synopsis:   Does necessary setup to make this Dfs a root of the Dfs.
//
//  Arguments:  [wszDfsRootShare] -- The share to use as the Dfs root.
//
//  Returns:    Win32 error from configuring the root storages etc.
//
//-----------------------------------------------------------------------------

DWORD
SetupDfsRoot(
    LPWSTR wszDfsRootShare)
{
    DWORD dwErr = ERROR_SUCCESS;
    GUID guid;
    WCHAR wszDfsRootPath[ MAX_PATH ];
    WCHAR wszComputerName[ MAX_NETBIOS_NAME_LEN ];
    PWCHAR wszDfsRootPrefix = NULL;

    dwErr = GetDomainAndComputerName( NULL, wszComputerName );

    //
    // Figure out the share path for the Root Dfs share
    //

    if (dwErr == ERROR_SUCCESS) {

        dwErr = GetSharePath( wszDfsRootShare, wszDfsRootPath );

    }

    //
    // We have all the info we need now. Lets get to work....
    //
    //  1. Initialize the volume object section in the registry.
    //
    //  2. Initialize (ie, create if necessary) the storage used for the
    //     Dfs root.
    //
    //  3. Create the root volume object.
    //
    //  4. Configure the root volume as a local volume by updating the
    //     LocalVolumes section in the registry.
    //

    //
    // Initialize the Dfs Manager Volume Object Store
    //

    if (dwErr == ERROR_SUCCESS) {

        dwErr = InitializeVolumeObjectStorage();

    }


    if (dwErr == ERROR_SUCCESS) {

        dprintf((DEB_ERROR,
            "Setting [%ws] as Dfs storage root...\n", wszDfsRootPath));

        dwErr = DfsInitGlobals( wszComputerName, DFS_MANAGER_SERVER );

        if (dwErr == ERROR_SUCCESS) {

            wszDfsRootPrefix = new WCHAR[1 +
                                      wcslen(wszComputerName) +
                                      1 +
                                      wcslen(wszDfsRootShare) +
                                      1];

            if (wszDfsRootPrefix == NULL) {

                dwErr = ERROR_OUTOFMEMORY;

            }

        }

        if (dwErr == ERROR_SUCCESS) {

            wszDfsRootPrefix[0] = UNICODE_PATH_SEP;
            wcscpy( &wszDfsRootPrefix[1], wszComputerName );
            wcscat( wszDfsRootPrefix, UNICODE_PATH_SEP_STR );
            wcscat( wszDfsRootPrefix, wszDfsRootShare );

            dwErr = CreateVolumeObject(
                    DOMAIN_ROOT_VOL,             // Name of volume object
                    wszDfsRootPrefix,            // EntryPath of volume
                    wszComputerName,             // Server name
                    wszDfsRootShare,             // Share name
                    L"Dfs Root Volume",          // Comment
                    &guid);                      // Id of created volume

        }

        if (dwErr == ERROR_SUCCESS) {

            dwErr = StoreLvolInfo(
                    &guid,
                    wszDfsRootPath,
                    wszDfsRootShare,
                    wszDfsRootPrefix,
                    DFS_VOL_TYPE_DFS | DFS_VOL_TYPE_REFERRAL_SVC);

        }

        if (wszDfsRootPrefix != NULL)
            delete [] wszDfsRootPrefix;

        if (dwErr != ERROR_SUCCESS)
            dwErr = ERROR_INVALID_FUNCTION;

        if (dwErr == ERROR_SUCCESS) {

            DWORD dwErr;
            CRegKey cregVolumesDir( HKEY_LOCAL_MACHINE, &dwErr, VOLUMES_DIR );

            if (dwErr == ERROR_SUCCESS) {

                CRegSZ cregRootShare(
                            cregVolumesDir,
                            ROOT_SHARE_VALUE_NAME,
                            wszDfsRootShare );

                dwErr = cregRootShare.QueryErrorStatus();

            }

        }

    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   SetupFTDfs
//
//  Synopsis:   Main exported function
//
//  Arguments:  [argc] --
//              [argv] --
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

DWORD
SetupFTDfs(
    IN LPWSTR wszRootShare,
    IN LPWSTR wszFTDfsName)
{
    DWORD dwErr = ERROR_SUCCESS;

    WCHAR wszDomainName[MAX_PATH+1];
    WCHAR wszComputerName[MAX_PATH+1];
    WCHAR wszRootSharePath[MAX_PATH+1];
    WCHAR wszDfsConfigDN[MAX_PATH+1];
    WCHAR wszSDDfsConfigDN[MAX_PATH+1];
    WCHAR wszConfigurationDN[ MAX_PATH+1 ];
    WCHAR wszServerShare[MAX_PATH+1];

    PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
    LDAP *pldap = NULL;
    PLDAPMessage pMsg = NULL;

    LDAPModW ldapModClass, ldapModCN, ldapModPkt, ldapModPktGuid, ldapModServer;
    LDAP_BERVAL ldapPkt, ldapPktGuid;
    PLDAP_BERVAL rgModPktVals[2];
    PLDAP_BERVAL rgModPktGuidVals[2];
    LPWSTR rgModClassVals[2];
    LPWSTR rgModCNVals[2];
    LPWSTR rgModServerVals[5];
    LPWSTR rgAttrs[5];
    PLDAPModW rgldapMods[6];
    BOOLEAN fNewFTDfs;

    //
    // We need some information before we start:
    //
    // 1. Our Domain name
    //
    // 2. Our Computer name
    //
    // 3. The share path of wszRootShare
    //
    // 4. The DN of the Configuration OU of our domain
    //

    dwErr = GetDomainAndComputerName( wszDomainName, wszComputerName );

    if (dwErr != ERROR_SUCCESS) {

        dprintf((
            DEB_ERROR,
            "Win32 Error %d getting Domain/Computer name\n", dwErr));

        goto Cleanup;

    }

    dwErr = GetSharePath( wszRootShare, wszRootSharePath );

    if (dwErr != ERROR_SUCCESS) {

        dprintf((
            DEB_ERROR,
            "Win32 Error %d getting share path for %ws\n",
            dwErr, wszRootShare));

        goto Cleanup;
    }

    dwErr = DsGetDcName(
                NULL,                            // Computer to remote to
                NULL,                            // Domain - use our own
                NULL,                            // Domain Guid
                NULL,                            // Site Guid
                DS_DIRECTORY_SERVICE_REQUIRED |  // Flags
                    DS_PDC_REQUIRED,
                &pDCInfo);                       // Return info

    if (dwErr != ERROR_SUCCESS) {

        dprintf((
            DEB_ERROR,
            "DsGetDcName failed with Win32 Error %d\n", dwErr));

        goto Cleanup;
    }

    pldap = ldap_initW(&pDCInfo->DomainControllerAddress[2], LDAP_PORT);

    if (pldap == NULL) {

        dprintf((DEB_ERROR, "ldap_init failed\n"));

        goto Cleanup;

    }

    dwErr = ldap_set_option(pldap, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);
    if (dwErr != LDAP_SUCCESS) {

	dprintf((
		 DEB_ERROR,
		 "ldap_set_option failed with ldap error %d\n", dwErr));

	pldap = NULL;

	goto Cleanup;

    }

    dwErr = ldap_bind_s(pldap, NULL, NULL, LDAP_AUTH_SSPI);

    if (dwErr != LDAP_SUCCESS) {

        dprintf((
            DEB_ERROR,
            "ldap_bind_s failed with ldap error %d\n", dwErr));

        pldap = NULL;

        goto Cleanup;

    }

    rgAttrs[0] = L"defaultnamingContext";
    rgAttrs[1] = NULL;

    dwErr = ldap_search_sW(
                pldap,
                L"",
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                rgAttrs,
                0,
                &pMsg);

    if (dwErr == LDAP_SUCCESS) {

        PLDAPMessage pEntry = NULL;
        PWCHAR *rgszNamingContexts = NULL;
        DWORD i, cNamingContexts;
        BOOLEAN fFoundCfg;

        if ((pEntry = ldap_first_entry(pldap, pMsg)) != NULL &&
                (rgszNamingContexts = ldap_get_valuesW(pldap, pEntry, rgAttrs[0])) != NULL &&
                    (cNamingContexts = ldap_count_valuesW(rgszNamingContexts)) > 0) {

            wcscpy( wszConfigurationDN, *rgszNamingContexts );
            fFoundCfg = TRUE;

            if (!fFoundCfg) {

                dwErr = ERROR_UNEXP_NET_ERR;

            }

        } else {

            dwErr = ERROR_UNEXP_NET_ERR;

        }

        if (pEntry != NULL)
            ldap_msgfree( pEntry );

        if (rgszNamingContexts != NULL)
            ldap_value_freeW( rgszNamingContexts );

    }

    if (dwErr != ERROR_SUCCESS) {

        dprintf((DEB_ERROR, "Unable to find Configuration naming context\n"));

        goto Cleanup;

    }

    //
    // Great, we have all the parameters now, so configure the DS
    //

    //
    // See if the DfsConfiguration object exists; if not, create it.
    //

    wsprintf(
        wszDfsConfigDN,
        L"CN=Dfs-Configuration,CN=System,%ws",
        wszConfigurationDN);

    rgAttrs[0] = L"cn";
    rgAttrs[1] = NULL;

    dwErr = ldap_search_sW(
                pldap,
                wszDfsConfigDN,
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                rgAttrs,
                0,
                &pMsg);

    if (dwErr == LDAP_SUCCESS)
        ldap_msgfree( pMsg );

    if (dwErr == LDAP_NO_SUCH_OBJECT) {

        rgModClassVals[0] = L"dfsConfiguration";
        rgModClassVals[1] = NULL;

        ldapModClass.mod_op = LDAP_MOD_ADD;
        ldapModClass.mod_type = L"objectClass";
        ldapModClass.mod_vals.modv_strvals = rgModClassVals;

        rgModCNVals[0] = L"Dfs-Configuration";
        rgModCNVals[1] = NULL;

        ldapModCN.mod_op = LDAP_MOD_ADD;
        ldapModCN.mod_type = L"cn";
        ldapModCN.mod_vals.modv_strvals = rgModCNVals;

        rgldapMods[0] = &ldapModClass;
        rgldapMods[1] = &ldapModCN;
        rgldapMods[2] = NULL;

        dwErr = ldap_add_sW(
                    pldap,
                    wszDfsConfigDN,
                    rgldapMods);

    }

    if (dwErr != LDAP_SUCCESS) {

        dprintf((
            DEB_ERROR,
            "1:ldap_add_s for %ws failed with LDAP error %d\n",
            wszDfsConfigDN, dwErr ));

        goto Cleanup;

    }

    //
    // Check to see if we are joining an FTDfs or creating a new one.
    //

    wsprintf(
        wszDfsConfigDN,
        L"CN=%ws,CN=Dfs-Configuration,CN=System,%ws",
        wszFTDfsName,
        wszConfigurationDN);

    wsprintf(
        wszServerShare,
        L"\\\\%ws\\%ws",
        wszComputerName,
        wszRootShare);

    rgAttrs[0] = L"remoteServerName";
    rgAttrs[1] = NULL;

    dwErr = ldap_search_sW(
                pldap,
                wszDfsConfigDN,
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                rgAttrs,
                0,
                &pMsg);

    if (dwErr == ERROR_SUCCESS) {

        //
        // We are joining an existing FT Dfs. Append our server\share to it
        //

        LDAPMessage *pmsgServers;
        PWCHAR *rgServers, *rgNewServers;
        DWORD cServers;

        fNewFTDfs = FALSE;

        pmsgServers = ldap_first_entry(pldap, pMsg);

        if (pmsgServers != NULL) {

            rgServers = ldap_get_valuesW(
                            pldap,
                            pmsgServers,
                            L"remoteServerName");

            if (rgServers != NULL) {

                cServers = ldap_count_valuesW( rgServers );

                rgNewServers = new LPWSTR [ cServers + 2 ];

                if (rgNewServers != NULL) {

                    CopyMemory( rgNewServers, rgServers, cServers * sizeof(rgServers[0]) );

                    rgNewServers[cServers] = wszServerShare;
                    rgNewServers[cServers+1] = NULL;

                    ldapModServer.mod_op = LDAP_MOD_REPLACE;
                    ldapModServer.mod_type = L"remoteServerName";
                    ldapModServer.mod_vals.modv_strvals = rgNewServers;

                    rgldapMods[0] = &ldapModServer;
                    rgldapMods[1] = NULL;

                    dwErr = ldap_modify_sW(pldap, wszDfsConfigDN, rgldapMods);
                    if (LDAP_ATTRIBUTE_OR_VALUE_EXISTS == dwErr)
                        dwErr = ERROR_SUCCESS;

                    delete [] rgNewServers;

                } else {

                    dwErr = ERROR_OUTOFMEMORY;
                }

                ldap_value_freeW( rgServers );

            } else {

                dwErr = ERROR_OUTOFMEMORY;

            }

            ldap_msgfree( pmsgServers );

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

    } else if (dwErr == LDAP_NO_SUCH_OBJECT) {

        GUID idPkt;
        DWORD dwPktVersion = 1;

        //
        // We are creating a new FTDfs, create a container to hold the Dfs
        // configuration for it.
        //

        fNewFTDfs = TRUE;

        //
        // Generate the class and CN attributes
        //

        rgModClassVals[0] = L"ftDfs";
        rgModClassVals[1] = NULL;

        ldapModClass.mod_op = LDAP_MOD_ADD;
        ldapModClass.mod_type = L"objectClass";
        ldapModClass.mod_vals.modv_strvals = rgModClassVals;

        rgModCNVals[0] = wszFTDfsName;
        rgModCNVals[1] = NULL;

        ldapModCN.mod_op = LDAP_MOD_ADD;
        ldapModCN.mod_type = L"cn";
        ldapModCN.mod_vals.modv_strvals = rgModCNVals;

        //
        // Generate the null PKT attribute
        //

        ldapPkt.bv_len = sizeof(DWORD);
        ldapPkt.bv_val = (PCHAR) &dwPktVersion;

        rgModPktVals[0] = &ldapPkt;
        rgModPktVals[1] = NULL;

        ldapModPkt.mod_op = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
        ldapModPkt.mod_type = L"pKT";
        ldapModPkt.mod_vals.modv_bvals = rgModPktVals;

        //
        // Generate a PKT Guid attribute
        //

        UuidCreate( &idPkt );

        ldapPktGuid.bv_len = sizeof(GUID);
        ldapPktGuid.bv_val = (PCHAR) &idPkt;

        rgModPktGuidVals[0] = &ldapPktGuid;
        rgModPktGuidVals[1] = NULL;

        ldapModPktGuid.mod_op = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
        ldapModPktGuid.mod_type = L"pKTGuid";
        ldapModPktGuid.mod_vals.modv_bvals = rgModPktGuidVals;

        //
        // Generate a Remote-Server-Name attribute
        //

        rgModServerVals[0] = wszServerShare;
        rgModServerVals[1] = NULL;

        ldapModServer.mod_op = LDAP_MOD_ADD;
        ldapModServer.mod_type = L"remoteServerName";
        ldapModServer.mod_vals.modv_strvals = rgModServerVals;

        //
        // Assemble all the LDAPMod structures
        //

        rgldapMods[0] = &ldapModClass;
        rgldapMods[1] = &ldapModCN;
        rgldapMods[2] = &ldapModPkt;
        rgldapMods[3] = &ldapModPktGuid;
        rgldapMods[4] = &ldapModServer;
        rgldapMods[5] = NULL;

        //
        // Create the Dfs metadata object.
        //

        dwErr = ldap_add_sW( pldap, wszDfsConfigDN, rgldapMods );

        if (dwErr == ERROR_SUCCESS) {


            dprintf((
                DEB_ERROR,
                "2:ldap_add_s worked for %ws with ldap error %d\n",
                wszDfsConfigDN, dwErr));

        }

    }

    if (dwErr != LDAP_SUCCESS) {

        dprintf((
            DEB_ERROR,
            "2:ldap_add_s failed for %ws with ldap error %d\n",
            wszDfsConfigDN, dwErr));

        goto Cleanup;

    }

    //
    // Finally, create the root volume object
    //

    dwErr = CreateFTRootVolumeInfo(
                DOMAIN_ROOT_VOL,
                wszDfsConfigDN,
                wszDomainName,
                wszFTDfsName,
                wszComputerName,
                wszRootShare,
                wszRootSharePath,
                &pDCInfo->DomainControllerAddress[2],
                fNewFTDfs);

    if (dwErr != LDAP_SUCCESS) {

        dprintf((
            DEB_ERROR, "CreateVolumeObject failed with error %d\n", dwErr));

    } else {

        dprintf((
            DEB_ERROR, "Successfully created FT-Dfs Configuration!\n"));

    }

Cleanup:

    if (pDCInfo != NULL)
        NetApiBufferFree( pDCInfo );

    if (pldap != NULL)
        ldap_unbind( pldap );

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   RemoveDfsRoot
//
//  Synopsis:   Removes the Dfs Root config info.
//
//  Arguments:  None
//
//  Returns:    Win32 error from registry actions
//
//-----------------------------------------------------------------------------

DWORD
RemoveDfsRoot()
{
    DWORD dwErr;
    CRegKey cregVolumesDir( HKEY_LOCAL_MACHINE, &dwErr, VOLUMES_DIR );
    CRegKey *pcregLV = NULL;

    if (dwErr != ERROR_SUCCESS) {                            // Unable to open volumes dir
        return(dwErr);
    }

    pcregLV = new CRegKey(                       // Open local volumes section
                    HKEY_LOCAL_MACHINE,
                    REG_KEY_LOCAL_VOLUMES);

    if (pcregLV != NULL) {

        dwErr = pcregLV->QueryErrorStatus();

    } else {

        dwErr = ERROR_OUTOFMEMORY;

    }

    if (dwErr == ERROR_SUCCESS) {

        dwErr = pcregLV->Delete();                  // Delete local volumes

        delete pcregLV;

        pcregLV = NULL;

        if (dwErr == ERROR_SUCCESS) {

            //
            // Recreate an empty local volumes key
            //

            pcregLV = new CRegKey( HKEY_LOCAL_MACHINE, REG_KEY_LOCAL_VOLUMES);

            cregVolumesDir.Delete();             // Delete volumes dir

        }

    }

    if (pcregLV != NULL) {

        delete pcregLV;

    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsSetupDfs
//
//  Synopsis:   Entry point in case you want to build this as a DLL. This
//              function is suitable for being called from a setup .inf
//              file.
//
//  Arguments:  [cArgs] -- Count of args
//              [lpszArgs] -- Array of args
//              [lpszTextOut] -- On return, points to a global buffer
//                      containing the null string. This is required by the
//                      .inf file
//
//  Returns:    TRUE.
//
//-----------------------------------------------------------------------------

LPSTR szReturn = "";

extern "C" BOOL
DfsSetupDfs(
    DWORD cArgs,
    LPSTR lpszArgs[],
    LPSTR *lpszTextOut)
{
    int argc;
    LPSTR *argv;

    argv = (LPSTR *) malloc( (cArgs+1) * sizeof(LPSTR) );

    if (argv == NULL) {
        return( FALSE );
    }

    argv[0] = "DfsSetup";
    for (argc = 1; argc <= (int) cArgs; argc++) {
        argv[ argc ] = lpszArgs[ argc-1 ];
    }

    main( argc, argv );

    free( argv );

    *lpszTextOut = szReturn;

    return( TRUE );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsSetupDfsRoot
//
//  Synopsis:   Entry point for setting up just the root part of Dfs in
//              case you want to build this as a DLL. This function is
//              suitable for being called from a setup .inf file.
//
//  Arguments:  [cArgs] -- Count of args
//              [lpszArgs] -- Array of args
//              [lpszTextOut] -- On return, points to a global buffer
//                      containing the null string. This is required by the
//                      .inf file
//
//  Returns:    TRUE.
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsSetupDfsRoot(
    DWORD cArgs,
    LPSTR szArgs[],
    LPSTR *szTextOut)
{

    if (cArgs == 1) {

        DWORD dwErr;
        WCHAR wszDfsRootShare[MAX_PATH];

        mbstowcs( wszDfsRootShare, szArgs[0], strlen(szArgs[0]) + 1);

        dwErr = SetupDfsRoot( wszDfsRootShare );

    }

    *szTextOut = szReturn;

    return( TRUE );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsSetupGetConfig
//
//  Synopsis:   Reads the current configuration from the registry.
//
//  Arguments:  [pcfg] -- The DFS_CONFIGURATION info to fill
//
//  Returns:    TRUE if successfully read the config info, FALSE otherwise
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsSetupGetConfig(
    HWND hwnd,
    DFS_CONFIGURATION *pcfg)
{
    DWORD dwErr;
    CRegKey cregVolumesDir( HKEY_LOCAL_MACHINE, &dwErr, VOLUMES_DIR );
    ULONG cbBuffer;
    WCHAR wszErr[128];

    ZeroMemory( pcfg, sizeof(DFS_CONFIGURATION) );

    if (dwErr == ERROR_ACCESS_DENIED) {

        MessageBox(
            hwnd,
            L"Insufficient priviledge",
            DFS_COMPONENT_NAME,
            MB_OK | MB_ICONSTOP);

        return( FALSE );

    } else if (dwErr != ERROR_SUCCESS && dwErr != ERROR_FILE_NOT_FOUND) {

        swprintf(wszErr, L"Unexpected error %08lx accessing registry", dwErr);

        MessageBox( hwnd, wszErr, DFS_COMPONENT_NAME, MB_OK | MB_ICONSTOP);

        return( FALSE );

    }

    if (dwErr == ERROR_SUCCESS) {

        pcfg->fHostsDfs = TRUE;

        CRegSZ cregRootShare( cregVolumesDir, ROOT_SHARE_VALUE_NAME );

        dwErr = cregRootShare.QueryErrorStatus();

        if (dwErr == ERROR_SUCCESS) {

            cbBuffer = sizeof(pcfg->szRootShare);

            dwErr = cregRootShare.GetString( pcfg->szRootShare, &cbBuffer );

        }

        if (dwErr == ERROR_SUCCESS) {

            DWORD dwErrFTDfs;

            CRegSZ cregFTDfs( cregVolumesDir, FTDFS_VALUE_NAME );

            dwErrFTDfs = cregFTDfs.QueryErrorStatus();

            if (dwErrFTDfs == ERROR_SUCCESS) {

                pcfg->fFTDfs = TRUE;

                cbBuffer = sizeof(pcfg->szFTDfs);

                dwErr = cregFTDfs.GetString(pcfg->szFTDfs, &cbBuffer);

            }

        }

        if (dwErr != ERROR_SUCCESS) {

            swprintf(wszErr, L"Error %08lx accessing registry", dwErr);

            MessageBox( hwnd, wszErr, DFS_COMPONENT_NAME, MB_OK | MB_ICONSTOP);

            return( FALSE );

        }

    }

    return( TRUE );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsSetupConfigure
//
//  Synopsis:   Presents the dialog box for configuring the Dfs root.
//
//  Arguments:  [cArgs] -- Count of args
//              [lpszArgs] -- Array of args
//              [lpszTextOut] -- On return, points to a global buffer
//                      containing the name of the share selected by the
//                      user to serve as the root of the Dfs. If the user
//                      hits Cancel, or decides not to setup a Dfs root,
//                      this string is set to point to the NULL string.
//
//  Returns:    TRUE iff machine should be rebooted
//
//-----------------------------------------------------------------------------

LPSTR szCancel = "Cancel";
LPSTR szReboot = "Reboot";

BOOLEAN
DfsSetupConfigure(
    DWORD cArgs,
    LPSTR szArgs[],
    LPSTR *szTextOut)
{
    DWORD dwErr = 0;
    HWND hwnd;
    DFS_CONFIGURATION dfscfg, dfsNewCfg;
    CHAR *pchUnused;

    BOOLEAN fRtn=FALSE;

    *szTextOut = szCancel;                       // Default return result

    ASSERT( cArgs == 1 );

    hwnd = (HWND) LongToHandle( strtoul( szArgs[0], &pchUnused, 16 ) );

    //
    // Read the current configuration
    //


        HCURSOR hCursor=LoadCursor(NULL,IDC_WAIT);

    if (!DfsSetupGetConfig( hwnd, &dfscfg )) {

        return fRtn;

    }

    //
    // Next, pop up a dialog to allow the user to change the configuration
    //

    dfsNewCfg = dfscfg;

    // Prompt the user for what flavour of Dfs to create
    if (ConfigureDfs( hwnd, &dfsNewCfg ) == TRUE)
    {
        // Prompt the user for a local machine share
        if (ConfigDfsShare(hwnd, &dfsNewCfg) == TRUE)
        {
                        // Set the Hourglass
                        if (hCursor)
                                SetCursor(hCursor);


            //
            // User hit OK. Figure out what changed, if anything.
            //

            if (dfscfg.fHostsDfs == FALSE && dfsNewCfg.fHostsDfs == FALSE) {

                //
                // No change...
                //

                NOTHING;

            } else if (dfscfg.fHostsDfs == FALSE && dfsNewCfg.fHostsDfs == TRUE) {

                //
                // We want to host a new Dfs, so call SetupDfsRoot or
                // SetupFTDfsRoot depending on what kind of Dfs Host the user
                // wants to setup
                //

                if (dfsNewCfg.fFTDfs) {
                    dwErr = SetupFTDfs( dfsNewCfg.szRootShare, dfsNewCfg.szFTDfs );
                } else {
                    dwErr = SetupDfsRoot( dfsNewCfg.szRootShare );
                }

                *szTextOut = szReboot;
                if (dwErr == 0) {
                    CRegKey RebootKey(HKEY_LOCAL_MACHINE, REBOOT_KEY, KEY_ALL_ACCESS,
                                        NULL, REG_OPTION_VOLATILE);
                    dwErr = RebootKey.QueryErrorStatus();
                    if (dwErr) {
                        dprintf((DEB_ERROR,"DfsStopHosting could not add reboot key\n"));
                    }
                    else {
                        CRegDWORD rvReboot((const CRegKey &) RebootKey, REG_VALUE_REBOOT, 1);
                        dwErr = rvReboot.QueryErrorStatus();
                    }
                }

            } else if (dfscfg.fHostsDfs == TRUE && dfsNewCfg.fHostsDfs == FALSE) {

                //
                // We want to delete our Dfs root
                //

                if (MessageBox(
                        hwnd,
                        L"Are you sure you want to delete the Dfs\n"
                            L"rooted at this machine?",
                        DFS_COMPONENT_NAME,
                        MB_ICONQUESTION | MB_YESNO) == IDYES) {

                    dwErr = RemoveDfsRoot();

                    *szTextOut = dwErr == ERROR_SUCCESS ? szReboot : szCancel;

                    if (dwErr == 0) {
                        CRegKey RebootKey(HKEY_LOCAL_MACHINE, REBOOT_KEY, KEY_ALL_ACCESS,
                                            NULL, REG_OPTION_VOLATILE);
                        dwErr = RebootKey.QueryErrorStatus();
                        if (dwErr) {
                            dprintf((DEB_ERROR,"DfsStopHosting could not add reboot key\n"));
                        }
                        else {
                            CRegDWORD rvReboot((const CRegKey &) RebootKey, REG_VALUE_REBOOT, 1);
                            dwErr = rvReboot.QueryErrorStatus();
                        }
                    }
                }

            } else if (dfscfg.fHostsDfs == TRUE && dfsNewCfg.fHostsDfs == TRUE) {

                //
                // User might have changed the root share, or simply changed
                // status with respect to FTDfs
                //

                if ((_wcsicmp( dfscfg.szRootShare, dfsNewCfg.szRootShare )) != 0 ||
                       dfscfg.fFTDfs != dfsNewCfg.fFTDfs) {

                    dwErr = RemoveDfsRoot();

                    if (dwErr == ERROR_SUCCESS) {

                        if (dfsNewCfg.fFTDfs) {

                            dwErr = SetupFTDfs(
                                        dfsNewCfg.szRootShare,
                                        dfsNewCfg.szFTDfs);

                        } else {

                            dwErr = SetupDfsRoot( dfsNewCfg.szRootShare );

                        }

                    }

                    *szTextOut = szReboot;

                    if (dwErr == 0) {
                        CRegKey RebootKey(HKEY_LOCAL_MACHINE, REBOOT_KEY, KEY_ALL_ACCESS,
                                            NULL, REG_OPTION_VOLATILE);
                        dwErr = RebootKey.QueryErrorStatus();
                        if (dwErr) {
                            dprintf((DEB_ERROR,"DfsStopHosting could not add reboot key\n"));
                        }
                        else {
                            CRegDWORD rvReboot((const CRegKey &) RebootKey, REG_VALUE_REBOOT, 1);
                            dwErr = rvReboot.QueryErrorStatus();
                        }
                    }

                }

                //
                // Raid: 455295 Put in code to handle FTDfs name change
                //

            }

            //
            // Only request a reboot if everything has gone fine so far.
            // MariusB and JonN 8/20/97
            //
            if (!dwErr)
                fRtn=TRUE;
        }
    }

    return  fRtn;
}

//+----------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   Prints out the usage message in case you want to build this
//              as an .exe
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

VOID
Usage()
{

    dprintf((DEB_ERROR,"Usage: dfssetup -root <path name> -share <root share>\n"));
    dprintf((DEB_ERROR,"  <path name> is the name of an empty directory to use\n"));
    dprintf((DEB_ERROR,"  as the root storage for Dfs\n"));
    dprintf((DEB_ERROR,"  <root share> is the share name to access <path name>\n"));

}

//+----------------------------------------------------------------------------
//
//  Function:   InitializeVolumeObjectStorage
//
//  Synopsis:   Initializes the Dfs Manager Volume Object store.
//
//  Arguments:  None
//
//  Returns:    DWORD from registry operations.
//
//-----------------------------------------------------------------------------

DWORD
InitializeVolumeObjectStorage()
{
    DWORD dwErr;
    CRegKey *pcregVolumeObjectStore = NULL;

    pcregVolumeObjectStore = new CRegKey(HKEY_LOCAL_MACHINE, VOLUMES_DIR );

    if (pcregVolumeObjectStore != NULL) {

        dwErr = pcregVolumeObjectStore->QueryErrorStatus();

        if ( dwErr == ERROR_SUCCESS ) {

            dwErr = pcregVolumeObjectStore->Delete();

            if (dwErr == ERROR_SUCCESS) {

                delete pcregVolumeObjectStore;

                pcregVolumeObjectStore = new CRegKey(
                                                HKEY_LOCAL_MACHINE,
                                                VOLUMES_DIR );

                if (pcregVolumeObjectStore != NULL) {

                    dwErr = pcregVolumeObjectStore->QueryErrorStatus();

                } else {

                    dwErr = ERROR_OUTOFMEMORY;
                }

            }

        }

    } else {

        dwErr = ERROR_OUTOFMEMORY;

    }

    if (dwErr == ERROR_SUCCESS) {

        dprintf((DEB_ERROR,"Successfully inited Dfs Manager Volume Storage...\n"));

    }

    if (pcregVolumeObjectStore != NULL) {

        delete pcregVolumeObjectStore;

    }

    return(dwErr);

}

//+----------------------------------------------------------------------------
//
//  Function:   CreateVolumeObject
//
//  Synopsis:   Creates a volume object to bootstrap the Dfs namespace.
//
//  Arguments:  [pwszObjectName] -- The name of the volume object, relative
//                      to VOLUMES_DIR
//              [pwszEntryPath] -- EntryPath of the volume.
//              [pwszServer] -- Name of server used to access this Dfs volume
//              [pwszShare] -- Name of share used to access this Dfs volume
//              [pwszComment] -- Comment to stamp on the volume object.
//              [guidVolume] -- ID of newly create dfs volume
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
CreateVolumeObject(
    LPWSTR wszObjectName,
    LPWSTR pwszEntryPath,
    LPWSTR pwszServer,
    LPWSTR pwszShare,
    LPWSTR pwszComment,
    GUID *guidVolume)
{
    DWORD dwErr;
    WCHAR wszFullObject[ MAX_PATH ];

    //
    // First, compute the full object name, storage ids, and machine name.
    //

    wcscpy( wszFullObject, VOLUMES_DIR );
    wcscat( wszFullObject, wszObjectName );

    //
    // Next, get a guid for this volume
    //

    UuidCreate( guidVolume );

    //
    // Lastly, create this volume object
    //

    dwErr = DfsManagerCreateVolumeObject(
                wszFullObject,
                pwszEntryPath,
                pwszServer,
                pwszShare,
                pwszComment,
                guidVolume);

    if (dwErr == ERROR_SUCCESS) {

        dprintf((DEB_ERROR,"Successfully inited Dfs Manager Volume [%ws]...\n", pwszEntryPath));

    }

    return(dwErr);

}

//+----------------------------------------------------------------------------
//
//  Function:   CreateFTRootVolumeInfo
//
//  Synopsis:   Creates a Dfs volume object - used to bootstrap a Dfs by
//              creating a root volume object
//
//  Arguments:  [wszObjectName] -- Name of volume object
//              [wszFTDfsConfigDN] -- The DN of the FTDfs config object in DS
//              [wszDomainName] -- Name of FTDfs domain
//              [wszDfsName] -- Name of Dfs
//              [wszServerName] -- Name of root server
//              [wszShareName] -- Name of root share
//              [wszDCName] -- DC to use
//              [fNewFTDfs] -- If true, this is a new FTDfs
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
CreateFTRootVolumeInfo(
    LPWSTR wszObjectName,
    LPWSTR wszFTDfsConfigDN,
    LPWSTR wszDomainName,
    LPWSTR wszDfsName,
    LPWSTR wszServerName,
    LPWSTR wszShareName,
    LPWSTR wszSharePath,
    LPWSTR wszDCName,
    BOOLEAN fNewFTDfs)
{
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR wszFullObjectName[ MAX_PATH ];
    WCHAR wszDfsPrefix[ MAX_PATH ];
    GUID idVolume;
    static BOOLEAN fInited = FALSE;

    wcscpy( wszDfsPrefix, UNICODE_PATH_SEP_STR );
    wcscat( wszDfsPrefix, wszDomainName );
    wcscat( wszDfsPrefix, UNICODE_PATH_SEP_STR );
    wcscat( wszDfsPrefix, wszDfsName );

    wcscpy( wszFullObjectName, LDAP_VOLUMES_DIR );
    wcscat( wszFullObjectName, wszObjectName );

    if (!fInited) {

        //
        // Create the volumes dir key that indicates that this machine is to
        // be a root of an FTDfs
        //

        CRegKey cregVolumesDir( HKEY_LOCAL_MACHINE, VOLUMES_DIR );

        dwErr = cregVolumesDir.QueryErrorStatus();

        if (dwErr == ERROR_SUCCESS) {

            CRegSZ cregRootShare(
                        cregVolumesDir,
                        ROOT_SHARE_VALUE_NAME,
                        wszShareName );

            dwErr = cregRootShare.QueryErrorStatus();

            if (dwErr == ERROR_SUCCESS) {

                CRegSZ cregFTDfs(
                        cregVolumesDir,
                        FTDFS_VALUE_NAME,
                        wszDfsName);

                CRegSZ cregFTDfsConfigDN(
                        cregVolumesDir,
                        FTDFS_DN_VALUE_NAME,
                        wszFTDfsConfigDN);

                dwErr = cregFTDfs.QueryErrorStatus();

                if (dwErr == ERROR_SUCCESS) {

                    dwErr = cregFTDfsConfigDN.QueryErrorStatus();

                    if (dwErr != ERROR_SUCCESS)
                        cregFTDfs.Delete();

                }

            }

        }

        if (dwErr == ERROR_SUCCESS) {

            dwErr = DfsInitGlobals(
                        wszDfsName,
                        DFS_MANAGER_FTDFS);

        }

        if (dwErr == ERROR_SUCCESS)
            fInited = TRUE;

    }

    DfsManagerSetDcName(wszDCName);

    if (dwErr == ERROR_SUCCESS) {

        if (fNewFTDfs) {

            //
            // Generate a Guid for the new Volume
            //

            UuidCreate( &idVolume );

            dwErr = DfsManagerCreateVolumeObject(
                        wszFullObjectName,
                        wszDfsPrefix,
                        wszServerName,
                        wszShareName,
                        L"Root Volume",
                        &idVolume);

        } else {

            dwErr = DfsManagerAddService(
                        wszFullObjectName,
                        wszServerName,
                        wszShareName,
                        &idVolume);

        }

    }

    if (dwErr == ERROR_SUCCESS) {

        dwErr = StoreLvolInfo(
                    &idVolume,
                    wszSharePath,
                    wszShareName,
                    wszDfsPrefix,
                    DFS_VOL_TYPE_DFS | DFS_VOL_TYPE_REFERRAL_SVC);

    }

    return( dwErr );
}

//+----------------------------------------------------------------------------
//
//  Function:   StoreLvolInfo
//
//  Synopsis:   Stores information about a local volume in the registry.
//
//  Arguments:  [pVolumeID] -- Id of dfs volume
//              [pwszStorageId] -- Storage used by dfs volume
//              [pwszShareName] -- LM Share used to access dfs volume
//              [pwszEntryPath] -- EntryPath of dfs volume
//              [ulVolumeType] -- Type of dfs volume. See DFS_VOL_TYPE_xxx
//
//  Returns:    DWORD from registry operations.
//
//-----------------------------------------------------------------------------

extern VOID
GuidToString(
    IN GUID *pID,
    OUT PWSTR pwszID);

DWORD
StoreLvolInfo(
    IN GUID  *pVolumeID,
    IN PWSTR pwszStorageID,
    IN PWSTR pwszShareName,
    IN PWSTR pwszEntryPath,
    IN ULONG ulVolumeType)
{
    DWORD dwErr;
    WCHAR wszLvolKey[_MAX_PATH];
    UNICODE_STRING ustrNtStorageId;
    PWCHAR pwcGuid;

    wcscpy(wszLvolKey, REG_KEY_LOCAL_VOLUMES);
    wcscat(wszLvolKey, UNICODE_PATH_SEP_STR);
    pwcGuid = wszLvolKey + wcslen(wszLvolKey);
    ASSERT( *pwcGuid == UNICODE_NULL );

    GuidToString( pVolumeID, pwcGuid );

    if (!RtlDosPathNameToNtPathName_U(
            pwszStorageID,
            &ustrNtStorageId,
            NULL,
            NULL)) {

        return(ERROR_OUTOFMEMORY);

    } else {

        ustrNtStorageId.Buffer[ustrNtStorageId.Length/sizeof(WCHAR)] = UNICODE_NULL;

    }

    CRegKey rkeyLvol(HKEY_LOCAL_MACHINE, wszLvolKey, KEY_WRITE, NULL, REG_OPTION_NON_VOLATILE);

    dwErr = rkeyLvol.QueryErrorStatus();

    if (dwErr != ERROR_SUCCESS) {
        RtlFreeUnicodeString(&ustrNtStorageId);
        return(dwErr);
    }

    CRegSZ rvEntryPath((const CRegKey &) rkeyLvol, REG_VALUE_ENTRY_PATH, pwszEntryPath);

    CRegSZ rvShortEntryPath((const CRegKey &) rkeyLvol, REG_VALUE_SHORT_PATH, pwszEntryPath);

    CRegDWORD rvEntryType((const CRegKey &) rkeyLvol, REG_VALUE_ENTRY_TYPE, ulVolumeType);

    CRegSZ rvStorageId((const CRegKey &) rkeyLvol, REG_VALUE_STORAGE_ID, ustrNtStorageId.Buffer);

    CRegSZ rvShareName((const CRegKey &) rkeyLvol, REG_VALUE_SHARE_NAME, pwszShareName);

    RtlFreeUnicodeString(&ustrNtStorageId);

    if (ERROR_SUCCESS != (dwErr = rvEntryPath.QueryErrorStatus()) ||
            ERROR_SUCCESS != (dwErr = rvShortEntryPath.QueryErrorStatus()) ||
                ERROR_SUCCESS != (dwErr = rvEntryType.QueryErrorStatus()) ||
                    ERROR_SUCCESS != (dwErr = rvStorageId.QueryErrorStatus()) ||
                        ERROR_SUCCESS != (dwErr = rvShareName.QueryErrorStatus())) {

        rkeyLvol.Delete();
    } else {

        dprintf((DEB_ERROR,"Successfully stored local volume info for [%ws]\n", pwszEntryPath));
    }

    return(dwErr);

}


//+------------------------------------------------------------------
//
// Function: CheckForOldDfsService
//
// Synopsis:
//
// Effects: -none-
//
// Arguments: -none-
//
// Returns: TRUE if the old (pre -ds build) dfs service is installed
//
//
// History: 10-09-96        JimMcN       Created
//
// Notes:
//
//
//-------------------------------------------------------------------


BOOLEAN DfsCheckForOldDfsService( )
{
    DWORD dwErr = 0;
    DWORD DfsVersion;

    // Open Service Controller
    CService cSvc;

    if (!(dwErr = cSvc.Init()))
    {

        dwErr = cSvc._OpenService(L"Dfs", SERVICE_QUERY_STATUS);
        cSvc._CloseService();

        if (dwErr != 0) {
            return(FALSE);
        }

        CRegKey cregDfsService( HKEY_LOCAL_MACHINE,
                                &dwErr,
                                L"System\\CurrentControlSet\\Services\\Dfs"
                               );

        if (dwErr == ERROR_SUCCESS) {
            CRegDWORD DfsNewService((const CRegKey &)cregDfsService,
                                     L"DfsVersion", &DfsVersion);

            dwErr = DfsNewService.QueryErrorStatus();

            if (dwErr != 0) {
                dprintf((DEB_ERROR,"CheckForOldDfsService Failed Newserv\n"));
                return(TRUE);
            }

            if (DfsVersion < DFS_VERSION_NUMBER) {
                return(TRUE);
            }

            return(FALSE);

        }

        return(FALSE);
    }
    return FALSE ;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetDomainAndComputerName
//
//  Synopsis:   Retrieves the domain and computer name of the local machine
//
//  Arguments:  [wszDomain] -- On successful return, contains name of domain.
//                      If this parameter is NULL on entry, the domain name is
//                      not returned.
//
//              [wszComputer] -- On successful return, contains name of
//                      computer. If this parameter is NULL on entry, the
//                      computer name is not returned.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully returning names.
//
//              Win32 Error from calling NetWkstaGetInfo
//
//-----------------------------------------------------------------------------

DWORD
GetDomainAndComputerName(
    OUT LPWSTR wszDomain OPTIONAL,
    OUT LPWSTR wszComputer OPTIONAL)
{

    DWORD dwErr;
    PWKSTA_INFO_100 wkstaInfo = NULL;

    dwErr = NetWkstaGetInfo( NULL, 100, (LPBYTE *) &wkstaInfo );

    if (dwErr == NERR_Success) {

        if (wszDomain)
            wcscpy(wszDomain, wkstaInfo->wki100_langroup);

        if (wszComputer)
            wcscpy(wszComputer, wkstaInfo->wki100_computername);

        NetApiBufferFree( wkstaInfo );

    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   GetSharePath
//
//  Synopsis:   Returns the share path for a share on the local machine
//
//  Arguments:  [wszShare] -- Name of share
//
//              [wszPath] -- On return, share path of wszShare
//
//  Returns:    [ERROR_SUCCESS] -- Successfully returning share path
//
//              Win32 error from NetShareGetInfo
//
//-----------------------------------------------------------------------------

DWORD
GetSharePath(
    IN LPWSTR wszShare,
    OUT LPWSTR wszPath)
{
    DWORD dwErr;
    PSHARE_INFO_2 pshi2;

    dwErr = NetShareGetInfo(
                NULL,                        // Server (local machine)
                wszShare,                    // Share Name
                2,                           // Level,
                (LPBYTE *) &pshi2);          // Buffer

    if (dwErr == ERROR_SUCCESS) {

        wcscpy( wszPath, pshi2->shi2_path );

        NetApiBufferFree( pshi2 );
    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsIsServiceRunning
//
//  Synopsis:   Check for active dfs servvice..
//
//  Arguments:
//
//  Returns:    [TRUE] -- if dfs service is active.
//              FALSE otherwise.
//
//-----------------------------------------------------------------------------
BOOLEAN
DfsIsDfsServiceRunning()

{
    DWORD dwErr;
    CService cSvc;

    if (!(dwErr = cSvc.Init()))
    {
        dwErr = cSvc._OpenService(L"Dfs", SERVICE_QUERY_STATUS);
        cSvc._CloseService();
        return(dwErr == 0);

    }
    return(FALSE);
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsGetDfsName
//
//  Synopsis:   Returns the share for a local dfs
//
//  Arguments:  [DfsRootShare] -- Name of share
//
//  Returns:    [TRUE] -- Successfully returning share path
//
//              FALSE otherwise.
//
//-----------------------------------------------------------------------------
BOOLEAN
DfsGetDfsName(
    OUT LPWSTR DfsRootShare,
    IN OUT ULONG *Length,
    OUT BOOLEAN *IsFtDfs)

{
    DWORD dwErr;
    ULONG SaveLength = *Length;
    //    CService cSvc;
    ULONG ul = MAX_PATH;

    WCHAR wc[MAX_PATH];

    *IsFtDfs = FALSE;

#if 0
    if (!(dwErr = cSvc.Init()))
    {

        dwErr = cSvc._OpenService(L"Dfs", SERVICE_QUERY_STATUS);
        cSvc._CloseService();

        if (dwErr != 0) {
            return(FALSE);
        }

    }
#endif

    CRegKey VolKey(HKEY_LOCAL_MACHINE, &dwErr, VOLUMES_DIR, KEY_READ);

    if (dwErr) {
        dprintf((DEB_ERROR,"DfsGetDfsName Failed to open VOLUMES_DIR\n"));
        return(FALSE);
    }

    CRegSZ RootShare((const CRegKey &)VolKey, ROOT_SHARE_VALUE_NAME);

    dwErr = RootShare.QueryErrorStatus();

    if (dwErr) {
        dprintf((DEB_ERROR,"DfsGetDfsName Failed to get root share name\n"));
        return(FALSE);
    }

    dwErr = RootShare.GetString(DfsRootShare, Length);

    if (dwErr) {
        dprintf((DEB_ERROR,"DfsGetDfsName Failed to get root share val\n"));
        return(FALSE);
    }

    CRegSZ FtDfs((const CRegKey &)VolKey, FTDFS_VALUE_NAME);


    dwErr = FtDfs.QueryErrorStatus();

    dwErr = FtDfs.GetString(wc, &ul);
    *IsFtDfs = (dwErr == 0);
    if (*IsFtDfs) {
        memset(DfsRootShare, 0, SaveLength);
        memcpy(DfsRootShare, wc, ul);
        *Length=ul;    }
    dprintf((DEB_ERROR,"DfsGetDfsName is %s FTDFS\n", *IsFtDfs?"":"NOT"));
    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsNeedReboot
//
//  Synopsis:   Returns true if reboot is required for completing configuration.
//
//  Arguments:
//
//  Returns:    [TRUE] -- Reboot Needed.
//
//              FALSE otherwise.
//
//-----------------------------------------------------------------------------
BOOLEAN
DfsNeedReboot()
{

    DWORD dwErr;
    DWORD RebootDW = 20;
    WCHAR buffer[20];
    CRegKey RebootKey(HKEY_LOCAL_MACHINE, &dwErr, REBOOT_KEY, KEY_READ);

    if (dwErr = RebootKey.QueryErrorStatus()) {
        return(FALSE);
    }

    CRegSZ RebootVal((const CRegKey &)RebootKey, REG_VALUE_REBOOT);

    dwErr = RebootVal.QueryErrorStatus();
        DWORD         GetString(      LPWSTR pwszData, ULONG *pcbData);

    dwErr =  RebootVal.GetString(buffer, &RebootDW);
    dprintf((DEB_ERROR,"DfsNeedReboot is %s Needed\n", dwErr == 0?"":"NOT"));

    return(dwErr == 0);


}

//+----------------------------------------------------------------------------
//
//  Function:   DfsStopHostingDfs
//
//  Synopsis:   Remove this machine from a machine/ft dfs.
//
//  Arguments:
//
//  Returns:    ERROR_SUCCESS if no error
//
//              setup error otherwise.
//
//-----------------------------------------------------------------------------
DWORD
DfsStopHostingDfs()
{
    DWORD dwErr = 0;
    BOOLEAN ftDfs = FALSE;
    ULONG ul = MAX_PATH;

    WCHAR FtDfsName[MAX_PATH];
    WCHAR DfsRootShare[MAX_PATH];
    WCHAR wszFullObjectName[MAX_PATH];
    WCHAR wszDomainName[MAX_PATH];
    WCHAR wszComputerName[MAX_PATH];

    if (DfsGetDfsName(FtDfsName, &ul, &ftDfs)) {
        if (ftDfs) {

            wcscpy( wszFullObjectName, LDAP_VOLUMES_DIR );
            wcscat( wszFullObjectName, DOMAIN_ROOT_VOL );

            dwErr = DfsInitGlobals(
                        FtDfsName,
                        DFS_MANAGER_FTDFS);

            if (dwErr) {
                dprintf((DEB_ERROR,"DfsStopHostingDfs init globals fail.\n"));
                return(dwErr);
            }

            CRegKey VolKey(HKEY_LOCAL_MACHINE, &dwErr, VOLUMES_DIR, KEY_READ);

            if (dwErr) {
                dprintf((DEB_ERROR,"DfsGetDfsName Failed to open VOLUMES_DIR\n"));
                return(dwErr);
            }

            CRegSZ RootShare((const CRegKey &)VolKey, ROOT_SHARE_VALUE_NAME);

            dwErr = RootShare.QueryErrorStatus();

            if (dwErr) {
                dprintf((DEB_ERROR,"DfsGetDfsName Failed to get root share name\n"));
                return(dwErr);
            }

            ul = MAX_PATH;
            dwErr = RootShare.GetString(DfsRootShare, &ul);

            if (dwErr) {
                dprintf((DEB_ERROR,"DfsGetDfsName Failed to get root share val\n"));
                return(dwErr);
            }

            dwErr = GetDomainAndComputerName( wszDomainName, wszComputerName );
            if (dwErr) {
                dprintf((DEB_ERROR,"DfsGetDfsName Failed computer name\n"));
                return(dwErr);
            }

            dwErr = DfsManagerRemoveService(wszFullObjectName, wszComputerName);
            if (dwErr && dwErr != NERR_DfsCantRemoveLastServerShare) {
                return(dwErr);
            }
            dwErr = TeardownFtDfs(DfsRootShare, FtDfsName);
        }
        if (dwErr)
            return(dwErr);

        dwErr = RemoveDfsRoot();

    }

    if (dwErr == 0) {
        CRegKey RebootKey(HKEY_LOCAL_MACHINE, REBOOT_KEY, KEY_ALL_ACCESS, NULL, REG_OPTION_VOLATILE);
        dwErr = RebootKey.QueryErrorStatus();
        if (dwErr) {
            dprintf((DEB_ERROR,"DfsStopHosting could not add reboot key\n"));
        }
        else {
            CRegDWORD rvReboot((const CRegKey &) RebootKey, REG_VALUE_REBOOT, 1);
            dwErr = rvReboot.QueryErrorStatus();
        }
    }
    else {
        dprintf((DEB_ERROR,"DfsStopHosting Dfs Failed to remove dfs root\n"));
    }

    return(dwErr);

}

//+----------------------------------------------------------------------------
//
//  Function:   TeardownFtDfs
//
//  Synopsis:   Removes FtDfs information from the ds.
//
//  Arguments:  wszRootShare the share hosting the dfs.
//              wszFTDfsName the name of the FtDfs to remove from the ds.
//
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

DWORD
TeardownFtDfs(
    IN LPWSTR wszRootShare,
    IN LPWSTR wszFTDfsName)
{
    DWORD dwErr = ERROR_SUCCESS;

    DWORD i, j;
    WCHAR wszDomainName[MAX_PATH];
    WCHAR wszComputerName[MAX_PATH];
    WCHAR wszRootSharePath[MAX_PATH];
    WCHAR wszConfigurationDN[ MAX_PATH ];
    WCHAR wszDfsConfigDN[ MAX_PATH ];
    WCHAR wszServerShare[MAX_PATH];


    PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
    LDAP *pldap = NULL;
    PLDAPMessage pMsg = NULL;

    LDAPModW ldapModClass, ldapModCN, ldapModPkt, ldapModPktGuid, ldapModServer;
    LDAP_BERVAL ldapPkt, ldapPktGuid;
    PLDAP_BERVAL rgModPktVals[2];
    PLDAP_BERVAL rgModPktGuidVals[2];
    LPWSTR rgModClassVals[2];
    LPWSTR rgModCNVals[2];
    LPWSTR rgModServerVals[5];
    LPWSTR rgAttrs[5];
    PLDAPModW rgldapMods[6];
    BOOLEAN fNewFTDfs;

    //
    // We need some information before we start:
    //
    // 1. Our Domain name
    //
    // 2. Our Computer name
    //
    // 3. The share path of wszRootShare
    //
    // 4. The DN of the Configuration OU of our domain
    //

    dwErr = GetDomainAndComputerName( wszDomainName, wszComputerName );

    if (dwErr != ERROR_SUCCESS) {

        dprintf((
            DEB_ERROR,
            "Win32 Error %d getting Domain/Computer name\n", dwErr));

        goto Cleanup;

    }

    dwErr = GetSharePath( wszRootShare, wszRootSharePath );

    if (dwErr != ERROR_SUCCESS) {

        dprintf((
            DEB_ERROR,
            "Win32 Error %d getting share path for %ws\n",
            dwErr, wszRootShare));

        goto Cleanup;
    }

    dwErr = DsGetDcName(
                NULL,                            // Computer to remote to
                NULL,                            // Domain - use our own
                NULL,                            // Domain Guid
                NULL,                            // Site Guid
                DS_DIRECTORY_SERVICE_REQUIRED |  // Flags
                    DS_PDC_REQUIRED,
                &pDCInfo);                       // Return info

    if (dwErr != ERROR_SUCCESS) {

        dprintf((
            DEB_ERROR,
            "DsGetDcName failed with Win32 Error %d\n", dwErr));

        goto Cleanup;
    }

    pldap = ldap_initW(&pDCInfo->DomainControllerAddress[2], LDAP_PORT);

    if (pldap == NULL) {

        dprintf((DEB_ERROR, "ldap_init failed\n"));

        goto Cleanup;

    }

    dwErr = ldap_set_option(pldap, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);
    if (dwErr != LDAP_SUCCESS) {

	dprintf((
		 DEB_ERROR,
		 "ldap_set_option failed with ldap error %d\n", dwErr));

	pldap = NULL;

	goto Cleanup;

    }

    dwErr = ldap_bind_s(pldap, NULL, NULL, LDAP_AUTH_SSPI);

    if (dwErr != LDAP_SUCCESS) {

        dprintf((
            DEB_ERROR,
            "ldap_bind_s failed with ldap error %d\n", dwErr));

        pldap = NULL;

        goto Cleanup;

    }

    rgAttrs[0] = L"defaultnamingContext";
    rgAttrs[1] = NULL;

    dwErr = ldap_search_sW(
                pldap,
                L"",
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                rgAttrs,
                0,
                &pMsg);

    if (dwErr == LDAP_SUCCESS) {

        PLDAPMessage pEntry = NULL;
        PWCHAR *rgszNamingContexts = NULL;
        DWORD i, cNamingContexts;
        BOOLEAN fFoundCfg;

        if ((pEntry = ldap_first_entry(pldap, pMsg)) != NULL &&
                (rgszNamingContexts = ldap_get_valuesW(pldap, pEntry, rgAttrs[0])) != NULL &&
                    (cNamingContexts = ldap_count_valuesW(rgszNamingContexts)) > 0) {

            wcscpy( wszConfigurationDN, *rgszNamingContexts );
            fFoundCfg = TRUE;

            if (!fFoundCfg) {

                dwErr = ERROR_UNEXP_NET_ERR;

            }

        } else {

            dwErr = ERROR_UNEXP_NET_ERR;

        }

        if (rgszNamingContexts != NULL)
            ldap_value_freeW( rgszNamingContexts );

        ldap_msgfree( pMsg );
    }

    if (dwErr != ERROR_SUCCESS) {

        dprintf((DEB_ERROR, "TD:Unable to find Configuration naming context\n"));

        goto Cleanup;

    }

    //
    // Great, we have all the parameters now, so configure the DS
    //

    //
    // See if the DfsConfiguration object exists; if not, create it.
    //

    wsprintf(
        wszDfsConfigDN,
        L"CN=Dfs-Configuration,CN=System,%ws",
        wszConfigurationDN);

    rgAttrs[0] = L"cn";
    rgAttrs[1] = NULL;

    dwErr = ldap_search_sW(
                pldap,
                wszDfsConfigDN,
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                rgAttrs,
                0,
                &pMsg);

    if (dwErr == LDAP_SUCCESS)
        ldap_msgfree( pMsg );

    if (dwErr != LDAP_SUCCESS) {

        dprintf((
            DEB_ERROR,
            "3: ldap_search_sW for %ws failed with LDAP error %d\n",
            wszDfsConfigDN, dwErr ));

        goto Cleanup;

    }

    //
    // Check to see if we are joining an FTDfs or creating a new one.
    //

    wsprintf(
        wszDfsConfigDN,
        L"CN=%ws,CN=Dfs-Configuration,CN=System,%ws",
        wszFTDfsName,
        wszConfigurationDN);

    wsprintf(
        wszServerShare,
        L"\\\\%ws\\%ws",
        wszComputerName,
        wszRootShare);

    rgAttrs[0] = L"remoteServerName";
    rgAttrs[1] = NULL;

    dwErr = ldap_search_sW(
                pldap,
                wszDfsConfigDN,
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                rgAttrs,
                0,
                &pMsg);

    if (dwErr == ERROR_SUCCESS) {

        //
        // We found a Dfs object to modify/delete
        //

        LDAPMessage *pmsgServers;
        PWCHAR *rgServers, *rgNewServers;
        DWORD cServers;

        fNewFTDfs = FALSE;

        pmsgServers = ldap_first_entry(pldap, pMsg);

        if (pmsgServers != NULL) {

            rgServers = ldap_get_valuesW(
                            pldap,
                            pmsgServers,
                            L"remoteServerName");

            if (rgServers != NULL) {

                cServers = ldap_count_valuesW( rgServers );

                rgNewServers = new LPWSTR [ cServers + 1 ];

                if (rgNewServers != NULL) {
                    for (i = j = 0; i < cServers; i += 1) {
                        if (wcscmp(wszServerShare, rgServers[i]) == 0) {
                            continue;
                        }
                        rgNewServers[j++] = rgServers[i];
                    }
                    rgNewServers[j] = NULL;
                    if (j) {
                        ldapModServer.mod_op = LDAP_MOD_REPLACE;
                        ldapModServer.mod_type = L"remoteServerName";
                        ldapModServer.mod_vals.modv_strvals = rgNewServers;

                        rgldapMods[0] = &ldapModServer;
                        rgldapMods[1] = NULL;

                        dwErr = ldap_modify_sW(pldap, wszDfsConfigDN, rgldapMods);
                    } else {

                        //
                        // Delete the Dfs metadata object.
                        //

                        dwErr = ldap_delete_sW( pldap, wszDfsConfigDN);

                    }

                    delete [] rgNewServers;

                } else {

                    dwErr = ERROR_OUTOFMEMORY;
                }

                ldap_value_freeW( rgServers );

            } else {

                dwErr = ERROR_OUTOFMEMORY;

            }

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

        ldap_msgfree( pMsg );
    }
    if (dwErr != LDAP_SUCCESS) {

        dprintf((
            DEB_ERROR,
            "4: ldap_modify_s/ldap_delete_s failed for %ws with ldap error %d\n",
            wszDfsConfigDN, dwErr));

        goto Cleanup;

    }

Cleanup:

    if (pDCInfo != NULL)
        NetApiBufferFree( pDCInfo );

    if (pldap != NULL)
        ldap_unbind( pldap );

    return( dwErr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\setup\config.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996-1996, Microsoft Corporation.
//
//  File:       config.cxx
//
//  Contents:   Dialog for configuration of Dfs
//
//  History:    6-Feb-96       BruceFo created
//
//-----------------------------------------------------------------------------

#include <windows.h>
#include <ole2.h>
#include <windowsx.h>
#include <shlobj.h>
#include <lm.h>


// Update for share validation
extern "C"
{
#include <netcan.h>         // in net/inc
#include <icanon.h>
#include <dsrole.h> // DsRoleGetPrimaryDomainInformation
}

#include <msshrui.h>

#include <debug.h>
#include <dfsstr.h>
#include "messages.h"
#include "resource.h"
#include "config.hxx"

DECLARE_DEBUG(DfsSetup)

#if DBG == 1
#define dprintf(x)      DfsSetupInlineDebugOut x
#else
#define dprintf(x)
#endif

#define CHECK_HRESULT(hr) \
        if ( FAILED(hr) ) \
        { \
            dprintf((DEB_ERROR, \
                "**** HRESULT ERROR RETURN <%s @line %d> -> 0x%08lx\n", \
                __FILE__, __LINE__, hr)); \
        }

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))
extern HINSTANCE g_hInstance;

//+-------------------------------------------------------------------------
//
//  Function:   SetErrorFocus
//
//  Synopsis:   Set focus to an edit control and select its text.
//
//  Arguments:  [hwnd] - dialog window
//              [idCtrl] - edit control to set focus to (and select)
//
//  Returns:    nothing
//
//  History:    3-May-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

VOID
SetErrorFocus(
    IN HWND hwnd,
    IN UINT idCtrl
    )
{
    HWND hCtrl = ::GetDlgItem(hwnd, idCtrl);
    ::SetFocus(hCtrl);
    ::SendMessage(hCtrl, EM_SETSEL, 0, -1);
}

//+-------------------------------------------------------------------------
//
//  Function:   MyFormatMessageText
//
//  Synopsis:   Given a resource IDs, load strings from given instance
//              and format the string into a buffer
//
//  History:    11-Aug-93 WilliamW   Created.
//
//--------------------------------------------------------------------------
VOID
MyFormatMessageText(
    IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     dwBufferSize,
    IN va_list * parglist
    )
{
    //
    // get message from system or app msg file.
    //

    DWORD dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE,
                             g_hInstance,
                             dwMsgId,
                             LANG_USER_DEFAULT,
                             pszBuffer,
                             dwBufferSize,
                             parglist);

    if (0 == dwReturn)   // couldn't find message
    {
        dprintf((DEB_IERROR,
            "FormatMessage failed, 0x%08lx\n",
            GetLastError()));

        WCHAR szText[200];
        LoadString(g_hInstance, IDS_APP_MSG_NOT_FOUND, szText, ARRAYLEN(szText));
        wsprintf(pszBuffer,szText,dwMsgId);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   MyFormatMessage
//
//  Synopsis:   Given a resource IDs, load strings from given instance
//              and format the string into a buffer
//
//  History:    11-Aug-93 WilliamW   Created.
//
//--------------------------------------------------------------------------
VOID
MyFormatMessage(
    IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     dwBufferSize,
    ...
    )
{
    va_list arglist;

    va_start(arglist, dwBufferSize);
    MyFormatMessageText(dwMsgId, pszBuffer, dwBufferSize, &arglist);
    va_end(arglist);
}

//+-------------------------------------------------------------------------
//
//  Method:     MyCommonDialog
//
//  Synopsis:   Common popup dialog routine - stole from diskadm directory
//
//--------------------------------------------------------------------------
DWORD
MyCommonDialog(
    IN HWND    hwnd,
    IN HRESULT dwMsgCode,
    IN PWSTR   pszCaption,
    IN DWORD   dwFlags,
    IN va_list arglist
    )
{
    WCHAR szMsgBuf[500];

    MyFormatMessageText(dwMsgCode, szMsgBuf, ARRAYLEN(szMsgBuf), &arglist);
    SetCursor(LoadCursor(NULL, IDC_ARROW)); // in case it's an hourglass...
    return MessageBox(hwnd, szMsgBuf, pszCaption, dwFlags);
}

//+-------------------------------------------------------------------------
//
//  Method:     MyErrorDialog
//
//  Synopsis:   This routine retreives a message from the app or system
//              message file and displays it in a message box.
//
//  Note:       Stole from diskadm directory
//
//--------------------------------------------------------------------------
VOID
MyErrorDialog(
    IN HWND hwnd,
    IN HRESULT dwErrorCode,
    ...
    )
{
    WCHAR szCaption[100];
    va_list arglist;
    va_start(arglist, dwErrorCode);
    LoadString(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));
    MyCommonDialog(hwnd, dwErrorCode, szCaption, MB_ICONSTOP | MB_OK, arglist);
    va_end(arglist);
}

//+-------------------------------------------------------------------------
//
//  Method:     MyConfirmationDialog
//
//  Synopsis:   This routine retreives a message from the app or system
//              message file and displays it in a message box.
//
//  Note:       Stole from diskadm directory
//
//--------------------------------------------------------------------------
DWORD
MyConfirmationDialog(
    IN HWND hwnd,
    IN HRESULT dwMsgCode,
    IN DWORD dwFlags,
    ...
    )
{
    WCHAR szCaption[100];
    DWORD dwReturn;
    va_list arglist;
    va_start(arglist, dwFlags);
    LoadString(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));
    dwReturn = MyCommonDialog(hwnd, dwMsgCode, szCaption, dwFlags, arglist);
    va_end(arglist);
    return dwReturn;
}


//+-------------------------------------------------------------------------
//
//  Method:     IsLocalShareable, private
//
//  Synopsis:   Returns TRUE if the path is a local path on a shareable media
//              type.
//
//--------------------------------------------------------------------------

BOOL
IsLocalShareable(
    IN LPWSTR pszPath
    )
{
    // ok? local, etc...
    if (NULL != pszPath
        && pszPath[1] == L':'
        )
    {
        // assume it's a drive letter. See if it's local.
        WCHAR szRoot[3];
        szRoot[0] = pszPath[0];
        szRoot[1] = L':';
        szRoot[2] = L'\0';
        UINT info = GetDriveType(szRoot);
        switch (info)
        {
        // the following list is a list of drive types I believe can
        // be shared by the server
        case DRIVE_FIXED:
        case DRIVE_REMOVABLE:
        case DRIVE_CDROM:
            return TRUE;
            break;
        }
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     BrowseCallback, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------

int
BrowseCallback(
    IN HWND hwnd,
    IN UINT uMsg,
    IN LPARAM lParam,
    IN LPARAM lpData
    )
{
    if (uMsg == BFFM_SELCHANGED)
    {
        LPITEMIDLIST pidl = (LPITEMIDLIST)lParam;
        TCHAR szPath[MAX_PATH];
        BOOL fEnable = FALSE;

        if (SHGetPathFromIDList(pidl, szPath))
        {
            // ok? local, etc...
            if (IsLocalShareable(szPath))
            {
                fEnable = TRUE;
            }
        }

        SendMessage(hwnd, BFFM_ENABLEOK, 0, fEnable);
    }

    return 0;
}

//+-------------------------------------------------------------------------
//
//  Method:     OnBrowse
//
//  Synopsis:
//
//--------------------------------------------------------------------------

BOOL
OnBrowse(
    IN HWND hwnd
    )
{
    LPITEMIDLIST pidlRoot;
    HRESULT hr = SHGetSpecialFolderLocation(hwnd, CSIDL_DRIVES, &pidlRoot);
    CHECK_HRESULT(hr);
    if (FAILED(hr))
    {
        return FALSE;
    }

    WCHAR szCaptionText[MAX_PATH];
    MyFormatMessage(MSG_BROWSE,szCaptionText,ARRAYLEN(szCaptionText));

    WCHAR szDisplayName[MAX_PATH];
    BROWSEINFO bi =
    {
        hwnd,
        pidlRoot,
        szDisplayName,
        szCaptionText,
        BIF_RETURNONLYFSDIRS,
        BrowseCallback,
        (LPARAM)0,
        0
    };

    LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
    if (NULL != pidl)
    {
        WCHAR szPath[MAX_PATH];
        SHGetPathFromIDList(pidl, szPath);

        dprintf((DEB_ITRACE, "SHBrowseForFolder: got %ws\n", szPath));

        SetDlgItemText(hwnd, IDC_DIRECTORY, szPath);
        SetFocus(GetDlgItem(hwnd, IDC_CREATESHARE));    // so you can just hit "enter" afterwards...
    }
    else
    {
        dprintf((DEB_ITRACE, "SHBrowseForFolder was cancelled\n"));
    }

    // Now, free the shell data
    IMalloc* pMalloc;
    hr = SHGetMalloc(&pMalloc);
    CHECK_HRESULT(hr);
    if (SUCCEEDED(hr))
    {
        pMalloc->Free(pidlRoot);
        pMalloc->Free(pidl);
        pMalloc->Release();
    }

    return TRUE;
}


//-----------------------------------------------------------------------------
// New Share Dialog
//-----------------------------------------------------------------------------

INT_PTR CALLBACK
DlgProcNewShare(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    static LPWSTR s_pszPath;

    switch (uMsg)
    {
    case WM_INITDIALOG:
    {
        s_pszPath = (LPWSTR)lParam;
        if (NULL == s_pszPath)
        {
            EndDialog(hwnd, -1);    // internal error
        }

        EnableWindow(GetDlgItem(hwnd, IDC_CREATESHARE), FALSE);
        SendDlgItemMessage(hwnd, IDC_DIRECTORY, EM_LIMITTEXT, (WPARAM)(MAX_PATH - 1), (LPARAM)0);

        return 1;   // didn't call SetFocus
    }

    case WM_COMMAND:
    {
        WORD wNotifyCode = HIWORD(wParam);
        WORD wID = LOWORD(wParam);

        switch (wID)
        {
        case IDC_CREATESHARE:
        {
            GetDlgItemText(hwnd, IDC_DIRECTORY, s_pszPath, MAX_PATH);
            if (!IsLocalShareable(s_pszPath))
            {
                MyErrorDialog(hwnd, MSG_ILLEGAL_DIRECTORY, s_pszPath);
                SetErrorFocus(hwnd, IDC_DIRECTORY);
                return TRUE;
            }

            DWORD attribs = GetFileAttributes(s_pszPath);
            if (0xffffffff == attribs)
            {
                if (ERROR_PATH_NOT_FOUND == GetLastError()
                    || ERROR_FILE_NOT_FOUND == GetLastError()
                    )
                {
                    DWORD dw = MyConfirmationDialog(hwnd, MSG_NODIRECTORY, MB_YESNO | MB_ICONQUESTION, s_pszPath);
                    if (dw == IDNO)
                    {
                        // ok, go away...
                        SetErrorFocus(hwnd, IDC_DIRECTORY);
                        return TRUE;
                    }

                    // try to create the directory

                    BOOL b = CreateDirectory(s_pszPath, NULL);
                    dprintf((DEB_TRACE,
                                "CreateDirectory(%ws) = %d, last error = %d\n",
                                s_pszPath, b, GetLastError()));
                    if (!b)
                    {
                        MyErrorDialog(hwnd, MSG_COULDNT_CREATE_DIRECTORY, s_pszPath);
                        SetErrorFocus(hwnd, IDC_DIRECTORY);
                        return TRUE;
                    }
                }
                else
                {
                    dprintf((DEB_ERROR, "GetFileAttributes(%ws) failed, 0x%08lx\n",
                        s_pszPath, GetLastError()));
                    MyErrorDialog(hwnd, MSG_FILEATTRIBSFAIL, s_pszPath);
                    SetErrorFocus(hwnd, IDC_DIRECTORY);
                    return TRUE;
                }
            }
            else if (!(attribs & FILE_ATTRIBUTE_DIRECTORY))
            {
                MyErrorDialog(hwnd, MSG_NOT_A_DIRECTORY);
                SetErrorFocus(hwnd, IDC_DIRECTORY);
                return TRUE;
            }

            EndDialog(hwnd, TRUE);
            break;
        }

        case IDCANCEL:
            EndDialog(hwnd, FALSE);
            break;

        case IDC_BROWSE:
            return OnBrowse(hwnd);

        case IDC_DIRECTORY:
            if (wNotifyCode == EN_CHANGE)
            {
                EnableWindow(
                    GetDlgItem(hwnd, IDC_CREATESHARE),
                    (GetWindowTextLength(GetDlgItem(hwnd, IDC_DIRECTORY)) > 0) ? TRUE : FALSE);
            }
            break;

        }
        return 0;
    }

    default:
        return 0;   // didn't process
    }
}

// TRUE == success, FALSE == failure
BOOL
FillCombo(
    IN HWND hwnd,
    IN LPWSTR pszSelectShare,   // only one of pszSelectShare & pszSelectPath
    IN LPWSTR pszSelectPath     // ... can be non-NULL
    )
{
    LPWSTR pszShareForPath = NULL;  // if passed pszSelectPath, this figures out the share name corresponding to it

    //
    // Fill the combo box with a list of existing shares from which to
    // pick one to use as the Dfs share. First, if necessary, try level 2
    // so we get a path to compare against pszSelectPath. If that fails with
    // access denied, then fall back to level 1.
    //

    int level;
    DWORD dwErr, entriesread, totalentries;
    PSHARE_INFO_1 pshi1Base = NULL;
    PSHARE_INFO_1 pshi1 = NULL;

    if (NULL != pszSelectPath)
    {
        level = 2;
        dwErr = NetShareEnum(
                    NULL,                   // Server (local machine)
                    2,                      // Level
                    (LPBYTE *) &pshi1Base,  // Buffer
                    0xffffffff,             // max len (all)
                    &entriesread,
                    &totalentries,
                    NULL);                  // resume handle (unimplemented)
    }

    if (NULL == pshi1Base)
    {
        level = 1;
        dwErr = NetShareEnum(
                    NULL,                   // Server (local machine)
                    1,                      // Level
                    (LPBYTE *) &pshi1Base,  // Buffer
                    0xffffffff,             // max len (all)
                    &entriesread,
                    &totalentries,
                    NULL);                  // resume handle (unimplemented)
        if (dwErr != ERROR_SUCCESS)
        {
            MyErrorDialog(hwnd, MSG_NOSERVER);
            return FALSE;
        }
    }

    // assert(entriesread == totalentries);

    HWND hwndCombo = GetDlgItem(hwnd, IDC_DFSROOT);
    for (DWORD i = 0; i < entriesread; i++)
    {
        pshi1 = (level == 1)
                        ? &(pshi1Base[i])
                        : (PSHARE_INFO_1)&(((PSHARE_INFO_2)pshi1Base)[i])
                        ;
        if (pshi1->shi1_type == STYPE_DISKTREE)
        {
            ComboBox_AddString(hwndCombo, pshi1->shi1_netname);

            if (NULL != pszSelectPath && NULL == pszShareForPath && level == 2)
            {
                LPWSTR pszPath = ((PSHARE_INFO_2)pshi1)->shi2_path;
                if (0 == _wcsicmp(pszPath, pszSelectPath))
                {
                    pszShareForPath = pshi1->shi1_netname;
                }
            }
        }
    }

    int index = -1;
    if (NULL != pszSelectShare)
    {
        index = ComboBox_FindStringExact(hwndCombo, -1, pszSelectShare);
        if (index == CB_ERR)
        {
            index = -1;
        }
    }
    else if (NULL != pszSelectPath)
    {
        if (NULL != pszShareForPath)
        {
            index = ComboBox_FindStringExact(hwndCombo, -1, pszShareForPath);
            if (index == CB_ERR)
            {
                index = -1;
            }
        }
    }

    if (-1 == index)
    {
        if (ComboBox_GetCount(hwndCombo) > 0)
        {
            index = 0;
        }
    }

    if (index != -1)
    {
        ComboBox_SetCurSel(hwndCombo, index);
    }

    pshi1=&pshi1Base[0];
    NetApiBufferFree(pshi1);

    return TRUE;
}


//-----------------------------------------------------------------------------
// DFS Share Dialog
//-----------------------------------------------------------------------------

INT_PTR CALLBACK
DlgProcDfsShare(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    static DFS_CONFIGURATION* s_pConfig;

    switch (uMsg)
    {
    case WM_INITDIALOG:
    {
        s_pConfig = (DFS_CONFIGURATION*) lParam;
        if (NULL == s_pConfig)
        {
            EndDialog(hwnd, -1);    // fail!
            return TRUE;
        }

        if (!FillCombo(hwnd, s_pConfig->szRootShare, NULL))
        {
            EndDialog(hwnd, -1);    // fail!
            return TRUE;
        }

        s_pConfig->fHostsDfs=FALSE;

        HWND hwndCombo = GetDlgItem(hwnd, IDC_DFSROOT);
        int index = ComboBox_GetCurSel(hwndCombo);
        if (index == CB_ERR)
            EnableWindow(GetDlgItem(hwnd,IDOK), FALSE);

        return 1;   // didn't call SetFocus
    }

    case WM_COMMAND:
    {
        WORD wNotifyCode = HIWORD(wParam);
        WORD wID = LOWORD(wParam);

        switch (wID)
        {
        case IDOK:
        {
            HWND hwndCombo = GetDlgItem(hwnd, IDC_DFSROOT);
            int index = ComboBox_GetCurSel(hwndCombo);
            if (index != CB_ERR)
            {
                int len = ComboBox_GetLBTextLen(hwndCombo, index);
                if (len < ARRAYLEN(s_pConfig->szRootShare) - 1)
                {
                    ComboBox_GetLBText(hwndCombo, index, s_pConfig->szRootShare);
                    s_pConfig->fHostsDfs=TRUE;
                }
                else
                {
                    // internal error!
                }
            }
            else
            {
                // internal error!
            }


            EndDialog(hwnd, TRUE);
            break;
        }

        case IDCANCEL:
            EndDialog(hwnd, FALSE);
            break;

        case IDC_NEWSHARE:
        {
            // let the user create a new share on the machine.
            WCHAR szPath[MAX_PATH];
            INT_PTR ret = DialogBoxParam(
                            g_hInstance,
                            MAKEINTRESOURCE(IDD_NEWSHARE),
                            hwnd,
                            DlgProcNewShare,
                            (LPARAM)szPath);
            if (ret == -1 || !ret)
            {
                // don't need to refresh.
                return TRUE;
            }

            dprintf((DEB_TRACE, "User wants to share path %ws\n", szPath));

            HINSTANCE hinst = LoadLibrary(TEXT("ntshrui.dll"));
            if (NULL == hinst)
            {
                MyErrorDialog(hwnd, MSG_NONTSHRUI);
                return TRUE;
            }

            PFNSHARINGDIALOG pfnSharingDialog = (PFNSHARINGDIALOG)GetProcAddress(hinst, "SharingDialogW");
            if (NULL == pfnSharingDialog)
            {
                FreeLibrary(hinst);
                MyErrorDialog(hwnd, MSG_NONTSHRUI);
                return TRUE;
            }

            BOOL b = (*pfnSharingDialog)(hwnd, NULL, szPath);
            if (!b)
            {
                // dialog failed
                FreeLibrary(hinst);
                return TRUE;
            }

            FreeLibrary(hinst);

            HWND hwndCombo = GetDlgItem(hwnd, IDC_DFSROOT);
            ComboBox_ResetContent(hwndCombo);

            if (!FillCombo(hwnd, NULL, szPath))
            {
                return TRUE;
            }

            hwndCombo = GetDlgItem(hwnd, IDC_DFSROOT);
            int index = ComboBox_GetCurSel(hwndCombo);

            if (index == CB_ERR)
                EnableWindow(GetDlgItem(hwnd,IDOK), FALSE);
            else
                EnableWindow(GetDlgItem(hwnd,IDOK), TRUE);

            break;
        }

        }
        return 0;
    }

    default:
        return 0;   // didn't process
    }
}


extern "C" NET_API_STATUS NET_API_FUNCTION I_NetDfsGetFtServers(
                                    IN PVOID  pLDAP OPTIONAL,
                                    IN LPWSTR wszDomainName OPTIONAL,
                                    IN LPWSTR wszDfsName,
                                    OUT LPWSTR **List
                                    );



//-----------------------------------------------------------------------------
// Fill FTDFS for this domain
//-----------------------------------------------------------------------------

// TRUE == success, FALSE == failure
BOOL
FillFTDfsCombo(
    IN HWND hwnd
    )
{


    LPWSTR *list;

    if (I_NetDfsGetFtServers(NULL,NULL,NULL,&list)==NO_ERROR)
    {

        HWND hwndCombo = GetDlgItem(hwnd, IDC_JOIN_FTDFS_CB);
        for (int i=0; list[i] != NULL; i++)
        {
            ComboBox_AddString(hwndCombo, list[i]);
        }

        NetApiBufferFree(list);

        // Select the first item in the combo
        ComboBox_SetCurSel(hwndCombo,0);
    }


    return TRUE;
}




//-----------------------------------------------------------------------------
// Create DFS Share dialog
//-----------------------------------------------------------------------------

INT_PTR CALLBACK
DlgProcCreateDfs(
    IN HWND   hwnd,
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    static DFS_CONFIGURATION* s_pConfig;

    switch (uMsg)
    {

    case WM_INITDIALOG:
    {
        s_pConfig =  (DFS_CONFIGURATION*) lParam;
        // Note that _InitConfigDfs might disable the IDC_JOIN_FTDFS button
        _InitConfigDfs(hwnd,s_pConfig);
        _ShowDomainName(hwnd);

        //
        // Enable the IDC_CREATE_FTDFS button only if
        // this can be shown not to be a workgroup server.
        // JonN 8/22/97
        //
        BOOL fDisableFTDFS = TRUE;
        DSROLE_PRIMARY_DOMAIN_INFO_BASIC* proleinfo = NULL;
        DWORD dwErr = DsRoleGetPrimaryDomainInformation(
            NULL,
            DsRolePrimaryDomainInfoBasic,
            reinterpret_cast<PBYTE*>(&proleinfo) );
        if ( ERROR_SUCCESS == dwErr )
        {
            // ASSERT( NULL != proleinfo );
            switch (proleinfo->MachineRole)
            {
            case DsRole_RoleMemberWorkstation:
            case DsRole_RoleMemberServer:
            case DsRole_RoleBackupDomainController:
            case DsRole_RolePrimaryDomainController:
                fDisableFTDFS = FALSE;
            default:
                break;
            }
            DsRoleFreeMemory( proleinfo );
        }
        if (fDisableFTDFS)
        {
            EnableWindow(GetDlgItem(hwnd, IDC_CREATE_FTDFS), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_CREATE_FTDFS_TX), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_JOIN_FTDFS), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_JOIN_FTDFS_CB), FALSE);
            SetFocus(    GetDlgItem(hwnd, IDC_CREATE_DFS ));
            return 0; // called SetFocus
        }

        return 1;   // didn't call SetFocus
    }

    case WM_COMMAND:
    {
        WORD wNotifyCode = HIWORD(wParam);
        WORD wID = LOWORD(wParam);

        switch (wNotifyCode)
        {
            case EN_CHANGE:
            {
                EnableWindow(GetDlgItem(hwnd, IDOK), _VerifyState(hwnd,DFSTYPE_CREATE_FTDFS));
                return 0;
            }
        }


        switch (wID)
        {

            case IDOK:
            {
                switch (s_pConfig->nDfsType)
                {
                case DFSTYPE_CREATE_FTDFS:
                    GetDlgItemText(hwnd, IDC_CREATE_FTDFS_TX,s_pConfig->szFTDfs,NNLEN);
                    if (!_ValidateShare(s_pConfig->szFTDfs))
                    {
                        MessageBox(hwnd,L"Invalid FTDfs Name.  You must enter a valid FTDfs name before continuing.",L"Dfs Administration",MB_ICONEXCLAMATION | MB_OK);
                        return 0;
                    }
                    break;
                case DFSTYPE_JOIN_FTDFS:
                    {
                        HWND hwndCombo = GetDlgItem(hwnd, IDC_JOIN_FTDFS_CB);
                        int index = ComboBox_GetCurSel(hwndCombo);
                        if (index != CB_ERR)
                        {
                            int len = ComboBox_GetLBTextLen(hwndCombo, index);
                            if (len < ARRAYLEN(s_pConfig->szFTDfs) - 1)
                            {
                                ComboBox_GetLBText(hwndCombo, index, s_pConfig->szFTDfs);
                            }
                            else
                            {
                                // internal error!
                            }
                        }
                        else
                        {
                            // internal error!
                        }
                    }

                    break;
                case DFSTYPE_CREATE_DFS:
                    s_pConfig->szFTDfs[0]=NULL;
                    break;
                }

                // TODO need to store the option
                EndDialog(hwnd, TRUE);
                break;
            }
                // need to cancel everything
            case IDCANCEL:
                s_pConfig->fFTDfs=FALSE;
                EndDialog(hwnd, FALSE);
                break;

            case IDC_CREATE_FTDFS:
                CheckDlgButton(hwnd, IDC_CREATE_FTDFS, BST_CHECKED);
                EnableWindow(GetDlgItem(hwnd, IDC_CREATE_FTDFS_TX), TRUE);
                EnableWindow(GetDlgItem(hwnd, IDC_JOIN_FTDFS_CB), FALSE);
                s_pConfig->nDfsType=DFSTYPE_CREATE_FTDFS;
                EnableWindow(GetDlgItem(hwnd, IDOK), _VerifyState(hwnd,s_pConfig->nDfsType));
                s_pConfig->fFTDfs=TRUE;
                break;
            case IDC_JOIN_FTDFS:
                {
                    CheckDlgButton(hwnd, IDC_JOIN_FTDFS, BST_CHECKED);
                    EnableWindow(GetDlgItem(hwnd, IDC_CREATE_FTDFS_TX), FALSE);
                    EnableWindow(GetDlgItem(hwnd, IDC_JOIN_FTDFS_CB), TRUE);
                    s_pConfig->nDfsType=DFSTYPE_JOIN_FTDFS;

                    EnableWindow(GetDlgItem(hwnd, IDOK), _VerifyState(hwnd,s_pConfig->nDfsType));
                    s_pConfig->fFTDfs=TRUE;
                }
                break;
            case IDC_CREATE_DFS:
                CheckDlgButton(hwnd, IDC_CREATE_DFS, BST_CHECKED);
                EnableWindow(GetDlgItem(hwnd, IDC_CREATE_FTDFS_TX), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_JOIN_FTDFS_CB), FALSE);
                s_pConfig->nDfsType=DFSTYPE_CREATE_DFS;
                EnableWindow(GetDlgItem(hwnd, IDOK), _VerifyState(hwnd,s_pConfig->nDfsType));
                s_pConfig->fFTDfs=FALSE;
                break;


            }
            return 0;
        }

   }
   return 0;   // didn't process
}


BOOL _InitConfigDfs(IN HWND hwnd,DFS_CONFIGURATION* pConfig )
{

    if (NULL == pConfig)
    {
        EndDialog(hwnd, -1);    // fail!
        return TRUE;
    }

    if (!FillFTDfsCombo(hwnd))
    {
        EndDialog(hwnd, -1);    // fail!
        return TRUE;
    }

    // Test to see if we have any item to join to
    EnableWindow(GetDlgItem(hwnd,IDC_JOIN_FTDFS), _VerifyState(hwnd,DFSTYPE_JOIN_FTDFS));



    // Disable the join dialog
    // Init UI
    switch (pConfig->nDfsType)
    {
    case DFSTYPE_CREATE_FTDFS:
        {
            CheckDlgButton(hwnd, IDC_CREATE_FTDFS, BST_CHECKED);
            SetDlgItemText(hwnd, IDC_CREATE_FTDFS_TX,pConfig->szFTDfs);
            EnableWindow(GetDlgItem(hwnd, IDC_JOIN_FTDFS_CB), FALSE);
        }
        break;
    case DFSTYPE_JOIN_FTDFS:
        {
            CheckDlgButton(hwnd, IDC_JOIN_FTDFS, BST_CHECKED);
            EnableWindow(GetDlgItem(hwnd, IDC_CREATE_FTDFS_TX), FALSE);

            HWND hwndCombo = GetDlgItem(hwnd, IDC_JOIN_FTDFS_CB);
            int index = -1;

            if (NULL != pConfig->szFTDfs)
            {
                index = ComboBox_FindStringExact(hwndCombo, -1, pConfig->szFTDfs);
                if (index == CB_ERR)
                {
                    index = -1;
                }
            }
            else if (NULL != pConfig->szFTDfs)
            {
                if (NULL != pConfig->szFTDfs)
                {
                    index = ComboBox_FindStringExact(hwndCombo, -1, pConfig->szFTDfs);
                    if (index == CB_ERR)
                    {
                        index = -1;
                    }
                }
            }

            if (-1 == index)
            {
                if (ComboBox_GetCount(hwndCombo) > 0)
                {
                    index = 0;
                }
            }

            if (index != -1)
            {
                ComboBox_SetCurSel(hwndCombo, index);
            }

            EnableWindow(GetDlgItem(hwnd,IDC_JOIN_FTDFS), _VerifyState(hwnd,DFSTYPE_JOIN_FTDFS));


        }
        break;

    case DFSTYPE_CREATE_DFS:
        {
            CheckDlgButton(hwnd, IDC_CREATE_DFS, BST_CHECKED);
            EnableWindow(GetDlgItem(hwnd, IDC_CREATE_FTDFS_TX), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_JOIN_FTDFS_CB), FALSE);
        }
        break;
    default:
        CheckDlgButton(hwnd, IDC_CREATE_FTDFS, BST_CHECKED);
        pConfig->nDfsType=DFSTYPE_CREATE_FTDFS;
        pConfig->fFTDfs=TRUE;
        EnableWindow(GetDlgItem(hwnd, IDC_JOIN_FTDFS_CB), FALSE);
    }

    EnableWindow(GetDlgItem(hwnd, IDOK), _VerifyState(hwnd,pConfig->nDfsType));

    return TRUE;

}




BOOL _VerifyState(IN HWND hwnd, IN int nType)
{
    BOOL frtn=FALSE;

    switch (nType)
    {
        case DFSTYPE_CREATE_FTDFS:
            {
                TCHAR szText[MAX_PATH];
                GetDlgItemText(hwnd, IDC_CREATE_FTDFS_TX,szText,MAX_PATH);
                if (wcslen(szText)>0)
                    frtn=TRUE;
            }
            break;
        case DFSTYPE_JOIN_FTDFS:
            {
                HWND hwndCombo = GetDlgItem(hwnd, IDC_JOIN_FTDFS_CB);
                int index = ComboBox_GetCurSel(hwndCombo);
                if (index != CB_ERR)
                    frtn=TRUE;
            }
            break;
        case DFSTYPE_CREATE_DFS:
            {
                frtn=TRUE;
            }
            break;

    }

    return frtn;
}



BOOL _ValidateShare(LPCWSTR lpszShare)
{

    WCHAR pathName[ MAX_PATH ];
    DWORD pathtype;

    // validate input
    if (lpszShare==NULL || wcslen( lpszShare ) > MAX_PATH)
    {
        return FALSE;
    }

    // copy string
    wcscpy( pathName, lpszShare);

    // check for valid path
    if( wcslen( pathName ) > NNLEN ||
        wcspbrk( pathName, L"\\/ " ) ||
        NetpwPathType( pathName, &pathtype, FALSE ) != NO_ERROR ||
        pathtype != ITYPE_PATH )
    {
        return FALSE;
    }


    return TRUE;
}

DWORD
GetDomainAndComputerName(
    OUT LPWSTR wszDomain OPTIONAL,
    OUT LPWSTR wszComputer OPTIONAL);



VOID
_ShowDomainName(
    IN HWND hwnd)
{
    WCHAR wszDomainName[MAX_PATH];
    WCHAR wszDomainNamePath[MAX_PATH];
    DWORD dwErr = GetDomainAndComputerName( wszDomainName, NULL);

    if (dwErr != ERROR_SUCCESS)
        return;

    if (wcslen(wszDomainName)>MAX_PATH-5)
        return;

    wsprintf(wszDomainNamePath,L"\\\\%ws\\",wszDomainName);
    int len = wcslen(wszDomainNamePath);

    SetDlgItemText(hwnd, IDC_CREATE_DOMAIN_TX, wszDomainNamePath);

    HDC hdc = GetDC(hwnd);
    if (NULL != hdc)
    {
        // make sure the right font is selected in...

        HFONT hfontDlg = (HFONT)SendMessage(hwnd, WM_GETFONT, 0, 0);
        if (NULL != hfontDlg)
        {
            HFONT hfontOld = SelectFont(hdc, hfontDlg);

            SIZE size;
            BOOL b = GetTextExtentPoint32(hdc, wszDomainNamePath, len, &size);

            if (hfontOld)
            {
                SelectFont(hdc, hfontOld);
            }

            if (b)
            {
                // resize the static control to size.cx. Then, resize the
                // adjacent edit control to adjust for it.

                HWND hwndMountAsFixed = GetDlgItem(hwnd, IDC_CREATE_DOMAIN_TX);
                HWND hwndMountAs      = GetDlgItem(hwnd, IDC_CREATE_FTDFS_TX);
                RECT rc1, rc2;

                // Get static control coordinates
                GetWindowRect(hwndMountAsFixed, &rc1);
                MapWindowPoints(NULL, hwnd, (LPPOINT)&rc1, 2); // map x,y to dialog-relative coordinates instead of windows-relative coordinates

                // Get edit control coordinates
                GetWindowRect(hwndMountAs, &rc2);
                MapWindowPoints(NULL, hwnd, (LPPOINT)&rc2, 2); // map x,y to dialog-relative coordinates instead of windows-relative coordinates

                // Make sure the edit control doesn't take up more than 50% of
                // the width. If it does, put it in the tab order (it's already
                // a read-only edit control).
                int halfwidth = (rc2.right - rc1.left) / 2;
                if (size.cx > halfwidth)
                {
                    size.cx = halfwidth;
                    //SetWindowLong(hwndMountAsFixed, GWL_STYLE,
                    //    GetWindowLong(hwndMountAsFixed, GWL_STYLE) | WS_TABSTOP);
                }
                else
                {
                    if (GetFocus() == hwndMountAsFixed)
                    {
                        ::SetFocus(hwndMountAs);
                    }
                    //SetWindowLong(hwndMountAsFixed, GWL_STYLE,
                    //    GetWindowLong(hwndMountAsFixed, GWL_STYLE) & ~WS_TABSTOP);
                }

                size.cx+=10;

                SetWindowPos(
                    hwndMountAsFixed,
                    NULL,
                    0, 0,
                    size.cx,
                    rc1.bottom - rc1.top,   // leave height intact
                    SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

                // adjust the edit control

                size.cx += 2;   // add a buffer between controls
                SetWindowPos(
                    hwndMountAs,
                    NULL,
                    rc1.left + size.cx, // left side + static width + buffer
                    rc2.top,
                    (rc2.right - rc1.left) - size.cx, // total width - static width - buffer
                    rc2.bottom - rc2.top, // leave height intact
                    SWP_NOZORDER | SWP_NOACTIVATE);

            }
            else
            {
                //appDebugOut((DEB_ERROR, "GetTextExtentPoint32 failed, 0x%08lx\n", GetLastError()));
            }
        }

        ReleaseDC(GetDlgItem(hwnd, IDC_CREATE_DOMAIN_TX), hdc);
    }
    else
    {
        //appDebugOut((DEB_ERROR, "GetDC failed, 0x%08lx\n", GetLastError()));
    }
}

int
ConfigDfsShare(
    IN HWND hwnd,
    IN DFS_CONFIGURATION* pConfiguration
    )
{
    HMODULE hmod=GetModuleHandle(TEXT("dfssetup.dll"));

    return (int)DialogBoxParam(
                hmod,
                MAKEINTRESOURCE(IDD_DFSSHARE),
                hwnd,
                DlgProcDfsShare,
                (LPARAM)pConfiguration);

}

int
ConfigureDfs(
    IN HWND hwnd,
    IN DFS_CONFIGURATION* pConfiguration
    )
{
    HMODULE hmod=GetModuleHandle(TEXT("dfssetup.dll"));

    return (int)DialogBoxParam(
                hmod,
                MAKEINTRESOURCE(IDD_CREATEDFS),
                hwnd,
                DlgProcCreateDfs,
                (LPARAM)pConfiguration);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\ui\dfscmd\cmd.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:      cmd.cxx
//
//  Contents:  Command-line operations
//
//  History:   7-May-96     BruceFo     Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <shlobj.h>
#include "cmd.hxx"
#include "myutil.hxx"

ULONG
DfscmdPrintf(
    PWCHAR format,
    ...);

//
//      -- create intermediate directories
//      -- don't remove if it's the last one
//      --

// This function determines where the server and share name are in a UNC path,
// and sets them to the output parameters. Note that the input parameter is
// munged in the process. E.g.:
//        input:  \\brucefo4\root\hello
//        output: \\brucefo4\0root\hello
//                  ^server   ^share
//
// FALSE is returned if it doesn't appear to be a UNC path. TRUE is returned
// if everything seems ok.

BOOL
GetServerShare(
    IN OUT PWSTR pszUncPath,
    OUT PWSTR* ppszServer,
    OUT PWSTR* ppszShare
    )
{
    appAssert(NULL != pszUncPath);

    //
    // Do a quick check that this is a UNC path
    //

    PWSTR pT;

    if (   L'\\' != pszUncPath[0]
        || L'\\' != pszUncPath[1]
        || L'\\' == pszUncPath[2] || L'\0' == pszUncPath[2]
        || (NULL == (pT = wcschr(&pszUncPath[3], L'\\')))
        )
    {
        return FALSE;
    }

    *ppszServer = &pszUncPath[2];
    *pT++ = L'\0';
    *ppszShare = pT;

    appDebugOut((DEB_TRACE,
        "GetServerShare: Server: %ws, share: %ws\n",
        *ppszServer, *ppszShare));
    return TRUE;
}

// This function determines the appropriate Dfs name to pass to the NetDfs
// APIs. The input buffer is modified. E.g.:
//        input:  \\dfsname\dfsshare
//        output: \\dfsname\0dfsshare
//                  ^dfs
//
// FALSE is returned if it doesn't appear to be a dfs name. TRUE is returned
// if everything seems ok.

BOOL
GetDfs(
    IN OUT PWSTR pszDfsName,
    OUT PWSTR* ppszDfs
    )
{
    appAssert(NULL != pszDfsName);

    //
    // Do a quick check that this is a Dfs name
    //

    PWSTR pT;

    if (   L'\\' != pszDfsName[0]
        || L'\\' != pszDfsName[1]
        || L'\\' == pszDfsName[2] || L'\0' == pszDfsName[2]
        || (NULL == (pT = wcschr(&pszDfsName[3], L'\\')))
        )
    {
        return FALSE;
    }

    *ppszDfs = &pszDfsName[2];

    //
    // Go to next slash or end
    //
    pT++;
    while (*pT != L'\\' && *pT != L'\0')
        pT++;

    *pT = L'\0';

    appDebugOut((DEB_TRACE,
        "GetDfs: Dfs: %ws\n",
        *ppszDfs));
    return TRUE;
}


VOID
CmdMap(
    IN PWSTR pszDfsPath,
    IN PWSTR pszUncPath,
    IN PWSTR pszComment,
    IN BOOLEAN fRestore
    )
{
    appDebugOut((DEB_TRACE,"CmdMap(%ws, %ws, %ws)\n",
        pszDfsPath, pszUncPath, pszComment));

    PWSTR pszServer, pszShare;
    if (!GetServerShare(pszUncPath, &pszServer, &pszShare))
    {
		Usage();
    }


    NET_API_STATUS status = NetDfsAdd(
                                pszDfsPath,
                                pszServer,
                                pszShare,
                                pszComment,
                                (fRestore == FALSE) ?
                                    DFS_ADD_VOLUME : DFS_ADD_VOLUME | DFS_RESTORE_VOLUME);
    if (status == NERR_Success)
    {
        // Notify shell of change.

        appDebugOut((DEB_TRACE,
            "Notify shell about new path %ws\n",
            pszDfsPath));

        SHChangeNotify(SHCNE_MKDIR, SHCNF_PATH, pszDfsPath, NULL);
    }
    else
    {
		DfsErrorMessage(status);
    }
}

VOID
CmdUnmap(
    IN PWSTR pszDfsPath
    )
{
    appDebugOut((DEB_TRACE,"CmdUnmap(%ws)\n",
        pszDfsPath));

    //
    // Delete all the replicas, and hence the volume
    //

    HRESULT hr = S_OK;
    PDFS_INFO_3 pVolumeInfo = NULL;
    NET_API_STATUS status = NetDfsGetInfo(
                                pszDfsPath,
                                NULL,
                                NULL,
                                3,
                                (LPBYTE*)&pVolumeInfo);
    CHECK_NET_API_STATUS(status);
    if (NERR_Success == status)
    {
        // now, we have pVolumeInfo memory to delete

        for (ULONG i = 0; i < pVolumeInfo->NumberOfStorages; i++)
        {
            appDebugOut((DEB_TRACE,
                "Deleting replica %d of %d\n",
                i + 1, pVolumeInfo->NumberOfStorages));

            PDFS_STORAGE_INFO pDfsStorageInfo = &pVolumeInfo->Storage[i];

            status = NetDfsRemove(
                            pszDfsPath,
                            pDfsStorageInfo->ServerName,
                            pDfsStorageInfo->ShareName);
            if (status != NERR_Success)
            {
				DfsErrorMessage(status);
            }
        }
        NetApiBufferFree(pVolumeInfo);
    }
    else
    {
		DfsErrorMessage(status);
    }

    // Notify shell of change.

    appDebugOut((DEB_TRACE,
            "Notify shell about deleted path %ws\n",
            pszDfsPath));

    SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, pszDfsPath, NULL);
}

VOID
CmdAdd(
    IN PWSTR pszDfsPath,
    IN PWSTR pszUncPath,
    IN BOOLEAN fRestore
    )
{
    appDebugOut((DEB_TRACE,"CmdAdd(%ws, %ws)\n",
        pszDfsPath, pszUncPath));

    PWSTR pszServer, pszShare;
    if (!GetServerShare(pszUncPath, &pszServer, &pszShare))
    {
		Usage();
    }

    NET_API_STATUS status = NetDfsAdd(
                                pszDfsPath,
                                pszServer,
                                pszShare,
                                NULL,
                                (fRestore == FALSE) ? 0 : DFS_RESTORE_VOLUME);
    if (status != NERR_Success)
    {
		DfsErrorMessage(status);
    }
}

VOID
CmdRemove(
    IN PWSTR pszDfsPath,
    IN PWSTR pszUncPath
    )
{
    appDebugOut((DEB_TRACE,"CmdRemove(%ws, %ws)\n",
        pszDfsPath, pszUncPath));

    PWSTR pszServer, pszShare;
    if (!GetServerShare(pszUncPath, &pszServer, &pszShare))
    {
		Usage();
    }

    NET_API_STATUS status = NetDfsRemove(
                                pszDfsPath,
                                pszServer,
                                pszShare);
    if (status != NERR_Success)
    {
		DfsErrorMessage(status);
    }
}

VOID
CmdView(
    IN PWSTR pszDfsName,    // of form \\dfsname\dfsshare
    IN DWORD level,
    IN BOOLEAN fBatch,
    IN BOOLEAN fRestore
    )
{
    appDebugOut((DEB_TRACE,"CmdView(%ws, %d)\n",
        pszDfsName, level));

    PWSTR pszDfs;   // of form 'dfsname'
    if (!GetDfs(pszDfsName, &pszDfs))
    {
		Usage();
    }

    DWORD entriesread;
    LPBYTE buffer;
    DWORD resumeHandle = 0;
    NET_API_STATUS status = NetDfsEnum(
                                pszDfs,
                                level,
                                0xffffffff,
                                (LPBYTE*)&buffer,
                                &entriesread,
                                &resumeHandle);
    if (status == NERR_Success)
    {
        PDFS_INFO_3 pDfsInfo = (PDFS_INFO_3)buffer;
        DWORD i, j;
        LPDFS_STORAGE_INFO pStorage;

#if DBG == 1
        appDebugOut((DEB_TRACE,"NetDfsEnum returned %d entries\n", entriesread));
        for (i = 0; i < entriesread; i++)
        {
            if (level == 1)
            {
                pDfsInfo = (PDFS_INFO_3)(&(((PDFS_INFO_1)buffer)[i]));
            }
            else if (level == 2)
            {
                pDfsInfo = (PDFS_INFO_3)(&(((PDFS_INFO_2)buffer)[i]));
            }
            else if (level == 3)
            {
                pDfsInfo = &(((PDFS_INFO_3)buffer)[i]);
            }
            else
            {
                // bug!
                break;
            }
            appDebugOut((DEB_TRACE,"\t%ws\n", pDfsInfo->EntryPath));
        }
        pDfsInfo = (PDFS_INFO_3)buffer;
#endif // DBG == 1

        if (fBatch == FALSE)
        {
            for (i = 0; i < entriesread; i++)
            {
                DfscmdPrintf(L"%ws", pDfsInfo->EntryPath);

                if (level == 1)
                {
                    DfscmdPrintf(L"\r\n");
                    pDfsInfo = (LPDFS_INFO_3)
                                ((LPBYTE) pDfsInfo + sizeof(DFS_INFO_1));
                    continue;
                }

                if (L'\0' != *pDfsInfo->Comment)
                {
                    // Print the comment at column 60.
                    int len = wcslen(pDfsInfo->EntryPath);
                    while (len++ < 58)
                    {
                        DfscmdPrintf(L" ");    // putchar?
                    }

                    DfscmdPrintf(L"  %ws\r\n", pDfsInfo->Comment);
                }
                else
                {
                    DfscmdPrintf(L"\r\n");
                }

                if (level == 2)
                {
                    pDfsInfo = (LPDFS_INFO_3)
                                ((LPBYTE) pDfsInfo + sizeof(DFS_INFO_2));
                    continue;
                }

                pStorage = pDfsInfo->Storage;

                for (j = 0; j < pDfsInfo->NumberOfStorages; j++)
                {
                    DfscmdPrintf(L"\t\\\\%ws\\%ws\r\n",
                        pStorage[j].ServerName,
                        pStorage[j].ShareName);
                }

                pDfsInfo = (LPDFS_INFO_3)
                                ((LPBYTE) pDfsInfo + sizeof(DFS_INFO_3));
            }
        }
        else
        {
            DfscmdPrintf(L"REM BATCH RESTORE SCRIPT\r\n\r\n");
            for (i = 0; i < entriesread; i++)
            {
                pStorage = pDfsInfo->Storage;
    
                for (j = 0; j < pDfsInfo->NumberOfStorages; j++)
                {

                    if (pDfsInfo->Comment == NULL
                          ||
                        j > 0
                          || 
                        (wcslen(pDfsInfo->Comment) == 1 && pDfsInfo->Comment[0] == L' ')
                    ) {

                        DfscmdPrintf(L"%wsdfscmd /%ws \"%ws\" \"\\\\%ws\\%ws\"%ws\r\n",
                            (i == 0) ? L"REM " : L"",
                            (j == 0) ? L"map" : L"add",
                            pDfsInfo->EntryPath,
                            pStorage[j].ServerName,
                            pStorage[j].ShareName,
                            (fRestore == TRUE) ? L" /restore" : L"");

                     } else {

                        DfscmdPrintf(L"%wsdfscmd /%ws \"%ws\" \"\\\\%ws\\%ws\" \"%ws\"%ws\r\n",
                            (i == 0) ? L"REM " : L"",
                            (j == 0) ? L"map" : L"add",
                            pDfsInfo->EntryPath,
                            pStorage[j].ServerName,
                            pStorage[j].ShareName,
                            pDfsInfo->Comment,
                            (fRestore == TRUE) ? L" /restore" : L"");

                     }
                }
                DfscmdPrintf(L"\r\n");
                pDfsInfo = (LPDFS_INFO_3) ((LPBYTE) pDfsInfo + sizeof(DFS_INFO_3));
            }
        }

        NetApiBufferFree( buffer );
    }
    else
    {
		DfsErrorMessage(status);
    }
}


//
// The following is copied from dfsutil code, which allows redirection of
// output to a file.
//

#define MAX_MESSAGE_BUF 4096
#define MAX_ANSI_MESSAGE_BUF (MAX_MESSAGE_BUF * 3)

WCHAR MsgBuf[MAX_MESSAGE_BUF];
CHAR AnsiBuf[MAX_ANSI_MESSAGE_BUF];

ULONG
DfscmdPrintf(
   PWCHAR format,
   ...)
{
   DWORD written;
   va_list va;

   va_start(va, format);
   wvsprintf(MsgBuf, format, va);
   written = WideCharToMultiByte(CP_OEMCP, 0,
                MsgBuf, wcslen(MsgBuf),
                AnsiBuf, MAX_ANSI_MESSAGE_BUF,
                NULL, NULL);
   WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), AnsiBuf, written, &written, NULL);

   va_end(va);
   return written;
}
                              

#ifdef MOVERENAME

VOID
CmdMove(
    IN PWSTR pszDfsPath1,
    IN PWSTR pszDfsPath2
    )
{
    appDebugOut((DEB_TRACE,"CmdMove(%ws, %ws)\n",
        pszDfsPath1, pszDfsPath2));

    NET_API_STATUS status = NetDfsMove(
                                pszDfsPath1,
                                pszDfsPath2);
    if (status != NERR_Success)
    {
		DfsErrorMessage(status);
    }
}

VOID
CmdRename(
    IN PWSTR pszPath,
    IN PWSTR pszNewPath
    )
{
    appDebugOut((DEB_TRACE,"CmdRename(%ws, %ws)\n",
        pszPath, pszNewPath));

    NET_API_STATUS status = NetDfsRename(
                                pszPath,
                                pszNewPath);
    if (status != NERR_Success)
    {
		DfsErrorMessage(status);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\setup\setupsvc.cxx ===
//+------------------------------------------------------------------
//
// File:        SETUPSVC.CXX
//
// Contents:
//
// Synoposis:
//
// Classes:     CService
//
// Functions:
//
// History:     May 19, 1993        AlokS       Created
//
//-------------------------------------------------------------------

#include <windows.h>
#include <ole2.h>
#include <registry.hxx>
#include <setupsvc.hxx>
#include <dfsstr.h>

#include "messages.h"

VOID
    MyFormatMessage(
    IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     dwBufferSize,
    ...
    );

//+------------------------------------------------------------------
//
// Class: CService
//
// Purpose: Helper class for dealing with Service Controller
//
// Interface: CService::CService()          = Constructor
//            CService::~CService()         = Destructor
//            CService::Init()              = Initializes the class
//            CService::_CreateService()    = Install a Win32 Service
//            CService::_OpenService()      = Open an existing service
//            CService::_QueryServiceStatus() = Query servcie status.
//            CService::_CloseService()     = Close all resources associated with
//                       the service
//            CService::_DeleteService()    = Remove a Win32 Service
//            CService::_DisableService()   = Disables a Win32 Service
//            CService::_StartService()     = Start an existing service
//            CService::_StopService()      = Stop an existing, running service
//            CService::_ConfigService()    = Combo operation. Create if
//                                         not present else reconfigure it
//
// History: May 20, 1993         AlokS       Created
//
// Notes: This is a smart wrapper class for Service APIs. But it is not
//        multi-thread safe.
//
//-------------------------------------------------------------------

//+------------------------------------------------------------------
//
// Member: CService::CService
//
// Synopsis: Create an instance
//
// Effects: Instantiates the class
//
// Arguments: -none-
//
// Returns  : None.
//
// History: May 20, 1993         AlokS       Created
//
// Notes: The class allows only one handle to service per instance of this
//        class. Plus, it is not written to close handles before opening
//        new service. However, it does guarantee to close handles
//        (SC database and one Service handle) at destruction time.
//
//-------------------------------------------------------------------

CService::CService():
       _schSCManager(NULL),
       _scHandle(NULL)
{
    ;
}
//+------------------------------------------------------------------
//
// Member: CService::Init
//
// Synopsis: Open handle to Service Controller
//
// Effects: -do-
//
// Arguments: -none-
//
// Returns  : 0 on success else error from opening SC.
//
// History: Nov 4, 1993         AlokS       Created
//
// Notes: The class allows only one handle to service per instance of this
//        class. Plus, it is not written to close handles before opening
//        new service. However, it does guarantee to close handles
//        (SC database and one Service handle) at destruction time.
//
//-------------------------------------------------------------------
DWORD   CService::Init()
{
    DWORD dwStatus = 0;
    // Open the local SC database
    _schSCManager =  OpenSCManager(NULL, // Machine Name
                                   NULL, // Database Name
                                   SC_MANAGER_CREATE_SERVICE|
                                   SC_MANAGER_LOCK
                                  );
    if (_schSCManager == NULL)
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR, "Error: %lx in opening SCManager", dwStatus));
    }
    return(dwStatus);
}
//+------------------------------------------------------------------
//
// Member: CService::~CService
//
// Synopsis: Release all resources
//
// Effects: Closes SC database handle as well as any  service handle
//
// Arguments: none
//
// History: May 20, 1993         AlokS       Created
//
// Notes: Remember that we have only 1 service handle per instance.
//
//-------------------------------------------------------------------

CService::~CService()
{

    if (_schSCManager != NULL)
        CloseServiceHandle (_schSCManager);

    if (_scHandle != NULL)
        CloseServiceHandle (_scHandle);
}
//+------------------------------------------------------------------
//
// Member: CService::_CreateService
//
// Synopsis: This method is used to install a new Win32 Service or driver
//
// Effects: Creates a service.
//
// Arguments: all [in] parameters. See CreateService() API documentation
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes: The handle of newly created service is remembered and closed by
//        destructor
//
//-------------------------------------------------------------------

DWORD CService::_CreateService(const LPWSTR  lpwszServiceName,
                            const LPWSTR  lpwszDisplayName,
                                  DWORD   fdwDesiredAccess,
                                  DWORD   fdwServiceType,
                                  DWORD   fdwStartType,
                                  DWORD   fdwErrorControl,
                            const LPWSTR  lpwszBinaryPathName,
                            const LPWSTR  lpwszLoadOrderGroup,
                            const LPDWORD lpdwTagID,
                            const LPWSTR  lpwszDependencies,
                            const LPWSTR  lpwszServiceStartName,
                            const LPWSTR  lpwszPassword)
{
    if (_schSCManager==NULL)
    {
        return(ERROR_INVALID_HANDLE);
    }
    DWORD dwStatus =0;

    _scHandle  = CreateService(_schSCManager,
                                lpwszServiceName,
                                lpwszDisplayName,
                                fdwDesiredAccess,
                                fdwServiceType,
                                fdwStartType,
                                fdwErrorControl,
                                lpwszBinaryPathName,
                                lpwszLoadOrderGroup,
                                lpdwTagID,
                                lpwszDependencies,
                                lpwszServiceStartName,
                                lpwszPassword
                               );
    if (_scHandle==NULL)
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR,
                   "Error: %lx in CreateService: %ws\n",
                   dwStatus,
                   lpwszServiceName));
    }

    return dwStatus;
}
//+------------------------------------------------------------------
//
// Member: CService::_OpenService
//
// Synopsis: Opens the service if caller has specified proper access
//
// Effects: Opens a service, if one exists
//
// Arguments: [in] lpwszServiceName = Name of the service
//            [in] fdwDesiredAccess = Open Access mode bits
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes: The handle of opened service is remembered and closed by
//        destructor
//
//-------------------------------------------------------------------

DWORD CService::_OpenService( const LPWSTR lpwszServiceName,
                                 DWORD fdwDesiredAccess
                        )
{

    if (_schSCManager==NULL)
    {
        return(ERROR_INVALID_HANDLE);
    }
    DWORD dwStatus =0;
    _scHandle = OpenService ( _schSCManager,
                              lpwszServiceName,
                              fdwDesiredAccess
                            );
    if (_scHandle==NULL)
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR,
                       "Error: %lx in OpeningService: %ws\n",
                       dwStatus,
                       lpwszServiceName
                    ));
    }
    return dwStatus;

}

//+------------------------------------------------------------------
//
// Member: CService::_StartService
//
// Synopsis: Start the named service
//
// Effects: Opens a service, if one exists
//
// Arguments: [in] lpwszServiceName = Name of the service to start
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes: The handle of opened service is remembered and closed by
//        destructor
//
//-------------------------------------------------------------------

DWORD CService::_StartService( const LPWSTR lpwszServiceName
                          )
{

    if (_schSCManager==NULL)
    {
        return(ERROR_INVALID_HANDLE);
    }
    DWORD dwStatus =0;
    if (_scHandle)
        _CloseService();

    _scHandle = OpenService ( _schSCManager,
                              lpwszServiceName,
                              SERVICE_START|SERVICE_QUERY_STATUS
                             );
    if (_scHandle==NULL)
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR,
                       "Error: %lx in Opening Service: %ws\n",
                       dwStatus,
                       lpwszServiceName
                    ));
    }
    else if (!StartService(_scHandle, NULL, NULL))
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR,
                      "Error: %lx in Starting Service: %ws\n",
                      dwStatus,
                      lpwszServiceName
                   ));
    }
    return dwStatus;

}
//+------------------------------------------------------------------
//
// Member: CService::_StopService
//
// Synopsis: Stop the named service
//
// Effects: Opens a service, if one exists
//
// Arguments: [in] lpwszServiceName = Name of the service to stop
//
// Returns: 0 on success
//
// History: May 9, 1994         DaveStr       Created
//
// Notes: The handle of opened service is remembered and closed by
//        destructor
//
//-------------------------------------------------------------------

DWORD CService::_StopService( const LPWSTR lpwszServiceName
                          )
{
    SERVICE_STATUS ss;

    if (_schSCManager==NULL)
    {
        return(ERROR_INVALID_HANDLE);
    }
    DWORD dwStatus =0;
    if (_scHandle)
        _CloseService();

    _scHandle = OpenService ( _schSCManager,
                              lpwszServiceName,
                              SERVICE_STOP|SERVICE_QUERY_STATUS
                             );
    if (_scHandle==NULL)
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR,
                       "Error: %lx in Opening Service: %ws\n",
                       dwStatus,
                       lpwszServiceName
                    ));
    }
    else if (!ControlService(_scHandle, SERVICE_CONTROL_STOP, &ss))
    {
        dwStatus = GetLastError();
        DSSCDebugOut(( DEB_IERROR,
                      "Error: %lx in Controlling (stopping) Service: %ws\n",
                      dwStatus,
                      lpwszServiceName
                   ));
    }
    return dwStatus;
}
//+------------------------------------------------------------------
//
// Member: CService::_DeleteService
//
// Synopsis: Remove the named service
//
// Effects: Deletes a service, if one exists
//
// Arguments: [in] lpwszServiceName = Name of the service to remove
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes:
//
//
//-------------------------------------------------------------------
DWORD CService::_DeleteService( const LPWSTR lpwszServiceName )

{
    DWORD dwStatus;
    // Open the service
    dwStatus =  _OpenService(lpwszServiceName,
                             SERVICE_CHANGE_CONFIG|
                             DELETE
                            );
    if (!dwStatus)
    {
        // We have a handle to the existing service. So, delete it.
        if (!DeleteService ( _scHandle))
        {
            dwStatus = GetLastError();
            DSSCDebugOut(( DEB_IERROR,
                          "Error: %lx in DeleteService: %ws\n",
                           dwStatus,
                          lpwszServiceName
                        ));
            _CloseService();
        }
    }
    return dwStatus;
}

//+------------------------------------------------------------------
//
// Member: CService::_DisableService
//
// Synopsis: Disable the named service
//
// Effects: Disables a service, if one exists
//
// Arguments: [in] lpwszServiceName = Name of the service to disable
//
// Returns: 0 on success
//
// History: Dec 8, 1993         AlokS       Created
//
// Notes:
//
//
//-------------------------------------------------------------------
DWORD CService::_DisableService( const LPWSTR lpwszServiceName )
{
    DWORD dwStatus;
    // Open the service
    dwStatus =  _OpenService(lpwszServiceName,
                             SERVICE_CHANGE_CONFIG
                            );
    if (!dwStatus)
    {
        // We have a handle to the existing service. So, delete it.
        if (!ChangeServiceConfig ( _scHandle,           // Handle
                                   SERVICE_NO_CHANGE,   // Type
                                   SERVICE_DISABLED,    // Start
                                   SERVICE_NO_CHANGE,   // Error
                                   NULL,                // Path
                                   NULL,                // Load order
                                   NULL,                // Tag
                                   NULL,                // Depend
                                   NULL,                // Start name
                                   NULL,                // Password
                                   NULL                 // Display Name
                                  ))
        {
            dwStatus = GetLastError();
            DSSCDebugOut(( DEB_IERROR,
                          "Error: %lx in ChangeService: %ws\n",
                           dwStatus,
                          lpwszServiceName
                        ));
            _CloseService();
        }
    }
    return dwStatus;
}
//+------------------------------------------------------------------
//
// Member: CService::_CloseService
//
// Synopsis:  Close a service for which we have an open handle
//
// Effects: Close service handle, if opened previously
//
// Arguments: -none-
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes:
//
//
//-------------------------------------------------------------------
void CService::_CloseService( )
{
    if (_scHandle != NULL)
        CloseServiceHandle ( _scHandle);
    _scHandle = NULL;
}

//+------------------------------------------------------------------
//
// Member: CService::_QueryServiceStatus
//
// Synopsis:  query current service status
//
// Effects: none
//
// Arguments: service_status - service status structure.
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes:
//
//
//-------------------------------------------------------------------
DWORD CService::_QueryServiceStatus(LPSERVICE_STATUS ss)
{
    if (_scHandle != NULL) {

        if (!QueryServiceStatus(_scHandle, ss))
            return(GetLastError());

        return(0);
    }

    return(ERROR_INVALID_HANDLE);
}

//+------------------------------------------------------------------
//
// Member: CService::ConfigService
//
// Synopsis: Create else Open/Change the named Service
//
// Effects: It first tries to create a service. If one exists already,
//          it changes the configuration to new configuration.
//
// Arguments: Lots of them. See documentation on CreateService() API.
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes: Most people should use this method only for setting up services
//
// MAJOR NOTE: It is essential that all the keys being asked to change
//             be actually present before they can be changed
//
//
//
//-------------------------------------------------------------------
WCHAR MsgBuf[0x1000];

DWORD CService::_ConfigService(   DWORD fdwServiceType,
                                  DWORD fdwStartType,
                                  DWORD fdwErrorControl,
                            const LPWSTR lpwszBinaryPathName,
                            const LPWSTR lpwszLoadOrderGroup,
                            const LPWSTR lpwszDependencies,
                            const LPWSTR lpwszServiceStartName,
                            const LPWSTR lpwszPassword,
                            const LPWSTR lpwszDisplayName,
                            const LPWSTR lpwszServiceName
                          )
{
    if (_schSCManager==NULL)
    {
        return(ERROR_INVALID_HANDLE);
    }

    DWORD dwStatus = ERROR_SERVICE_DATABASE_LOCKED;
    SC_LOCK scLock;

    //
    // Let us lock the database.  There could be a problem here
    // because the service controller also locks the database when
    // starting a service so it reads the startup parameters properly.
    // If this is the case, and the database is locked, we just try
    // up to 5 times to lock it ourselves before we fail. 
    //
    for ( ULONG tries = 0;
          (tries < 5) && (dwStatus == ERROR_SERVICE_DATABASE_LOCKED);
          tries++ )
    {
        scLock = LockServiceDatabase (_schSCManager);

        if ( scLock == NULL )
        {
            dwStatus = GetLastError();

            DSSCDebugOut((DEB_ERROR, "LockServiceDatabase(try %d) == %#0x\n",
                         tries, dwStatus));

            if ( dwStatus == ERROR_SERVICE_DATABASE_LOCKED )
            {
                Sleep ( 2 * 1000 );
            }
        }
        else
        {
            dwStatus = 0;
        }
    }

    if ( dwStatus != 0 )
    {
        return dwStatus;
    }

    // First, we try to create the service.
    dwStatus   =  _CreateService(
                                  lpwszServiceName,
                                  lpwszDisplayName,
                                  GENERIC_WRITE,         // Access
                                  fdwServiceType,
                                  fdwStartType,
                                  fdwErrorControl,
                                  lpwszBinaryPathName,
                                  lpwszLoadOrderGroup,
                                  NULL,                  // Tag ID
                                  lpwszDependencies,
                                  lpwszServiceStartName,
                                  lpwszPassword
                                 );
    // It is possible that service exists
    if ((dwStatus == ERROR_SERVICE_EXISTS) ||
        (dwStatus == ERROR_DUP_NAME))
    {
        // Open the service
        dwStatus =  _OpenService(lpwszServiceName,
                                 SERVICE_CHANGE_CONFIG|DELETE);

        if (!dwStatus) {

            if (!ChangeServiceConfig(_scHandle,
                                 fdwServiceType,
                                 fdwStartType,
                                 fdwErrorControl,
                                 lpwszBinaryPathName,
                                 lpwszLoadOrderGroup,
                                 NULL,
                                 lpwszDependencies,
                                 lpwszServiceStartName,
                                 lpwszPassword,
                                 lpwszDisplayName
                                 )) {

                //
                // Change didn't work, lets try to delete and recreate this
                // service.
                //

                dwStatus = 0;

                if (!DeleteService ( _scHandle)) {
                    // This is hopeless. Let us give up now
                    dwStatus = GetLastError();
                    DSSCDebugOut(( DEB_IERROR,
                                   "Error: %lx in DeleteService: %ws\n",
                                   dwStatus,
                                   lpwszServiceName));

                }

                _CloseService();

                if (!dwStatus) {
                    // last attempt to create
                    dwStatus   =  _CreateService(
                                                 lpwszServiceName,
                                                 lpwszDisplayName,
                                                 GENERIC_WRITE,         // Access
                                                 fdwServiceType,
                                                 fdwStartType,
                                                 fdwErrorControl,
                                                 lpwszBinaryPathName,
                                                 lpwszLoadOrderGroup,
                                                 NULL,                  // Tag ID
                                                 lpwszDependencies,
                                                 lpwszServiceStartName,
                                                 lpwszPassword
                                                );
                    DSSCDebugOut(( DEB_IERROR,
                                   "This is hopeless. Recreating failed!!\n"));

                }

            }

        } // OpenService

    } // CreateService

    //
    // Set description
    //

    if (dwStatus == ERROR_SUCCESS) {

        SERVICE_DESCRIPTION ServiceDescription;

        // Open the service if the above did not
        if (_scHandle == NULL) {
            dwStatus =  _OpenService(
                                lpwszServiceName,
                                SERVICE_CHANGE_CONFIG);
        }

        if (dwStatus == ERROR_SUCCESS) {
            ULONG i;
            MyFormatMessage(MSG_DFS_DESCRIPTION, MsgBuf, sizeof(MsgBuf));
            for (i = 0; MsgBuf[i] != UNICODE_NULL && i < (sizeof(MsgBuf)/sizeof(WCHAR)); i++) {
                if (MsgBuf[i] == L'\r')
                    MsgBuf[i] = UNICODE_NULL;
                else if (MsgBuf[i] == L'\n')
                    MsgBuf[i] = UNICODE_NULL;
            }
            ServiceDescription.lpDescription = MsgBuf;

            dwStatus = ChangeServiceConfig2(
                           _scHandle,
                           SERVICE_CONFIG_DESCRIPTION, // InfoLevel
                           &ServiceDescription);

            dwStatus = (dwStatus != 0) ? ERROR_SUCCESS : GetLastError();

        }

   }

    _CloseService();
    UnlockServiceDatabase ( scLock);
    return dwStatus;
}

//+------------------------------------------------------------------
//
// Function: _StartService
//
// Synopsis:
//
// Effects: Starts the Service and any other
//          service dependent on it. It also ensures that the
//          service has started befor returning.
//
// Arguments: [pwsz] -- name of the service to be started
//
// Returns: 0 on success
//
// History: Nov 12, 1993         AlokS       Created
//
// Notes:   This code was borrowed from the original StartDfs code
//          written by Aloks and parameterized  to allow other
//          services to be started. An interesting question is
//          whether this should be made a method of CDSSvc class.
//          (TBD by AlokS)
//
//-------------------------------------------------------------------
DWORD _SynchStartService(WCHAR *pwszServiceName)
{
    DWORD dwRc;
    // Open Service Controller
    CService cSvc;
    if ((dwRc = cSvc.Init())== ERROR_SUCCESS)
    {
        // Start the Service
        dwRc = cSvc._StartService(pwszServiceName);
        if (dwRc == ERROR_SERVICE_ALREADY_RUNNING)
        {
            // We are done!
            return ( ERROR_SUCCESS );
        }
    }
    if (dwRc)
    {
        DSSCDebugOut((DEB_IERROR, "Error starting:  %ws\n",pwszServiceName));
        return(dwRc);
    }

    // Wait for the service to start running
    SERVICE_STATUS scStatus;
    DWORD          MaxTries = 0;
    do
    {
        if (!QueryServiceStatus(cSvc.QueryService(),
                                &scStatus
                               ))
        {
            dwRc = GetLastError();
            DSSCDebugOut((DEB_IERROR, "Error Querying service\n"));
            break;
        }
        else if (scStatus.dwCurrentState != SERVICE_RUNNING)
        {
            Sleep(SERVICE_WAIT_TIME);
            MaxTries++;
        }

    } while ( scStatus.dwCurrentState != SERVICE_RUNNING && MaxTries < MAX_SERVICE_WAIT_RETRIES);
    if (MaxTries == MAX_SERVICE_WAIT_RETRIES)
    {
        dwRc = ERROR_SERVICE_REQUEST_TIMEOUT;
    }
    return(dwRc);
}

//+------------------------------------------------------------------
//
// Function: ConfigDfs
//
// Synopsis:
//
// Effects: Configures DFS File System Driver
//
// Arguments: -none-
//
// Returns: 0 on success
//
// History: May 20, 1993         AlokS       Created
//
// Notes:
//
//-------------------------------------------------------------------

DWORD ConfigDfs()
{
    DWORD    dwErr = ERROR_SUCCESS;

    // Open Service Controller
    CService cSvc;
    if (dwErr = cSvc.Init())
        return dwErr;

    // Create DFS (Driver)
    dwErr = cSvc._ConfigService(
                    SERVICE_FILE_SYSTEM_DRIVER, // Service Type
                    SERVICE_BOOT_START,         // Start Type
                    SERVICE_ERROR_NORMAL,       // Error Control
                                                // service file
                    L"\\SystemRoot\\system32\\drivers\\Dfs.sys",
                    L"filter",                  // Load order group
                    NULL,                       // Dependency
                    NULL,                       // Service start name
                    NULL,                       // password
                    L"DfsDriver",               // display name
                    L"DfsDriver"                // Service Name
                    );

    if (dwErr)
        return dwErr;

    //
    // Registry Changes
    //

    //
    // Fix up the NetworkProvider order level - delete the Dfs provider
    // if one has been inserted there
    //

    if (dwErr == ERROR_SUCCESS) {

        CRegKey cregNP( HKEY_LOCAL_MACHINE,
                        L"System\\CurrentControlSet\\Control\\NetworkProvider\\Order",
                        KEY_READ | KEY_WRITE,
                        NULL,
                        REG_OPTION_NON_VOLATILE);

        dwErr = cregNP.QueryErrorStatus();

        if (dwErr == ERROR_SUCCESS) {

            CRegSZ cregOrder( cregNP, L"ProviderOrder" );
            dwErr = cregOrder.QueryErrorStatus();

            if (dwErr == ERROR_SUCCESS) {

                WCHAR wszProviders[128];
                WCHAR *pwszProviders = wszProviders;
                PWCHAR pwszDfs;
                ULONG cbProviders = sizeof(wszProviders);

                dwErr = cregOrder.GetString( pwszProviders, &cbProviders );

                if (dwErr == ERROR_MORE_DATA) {

                    pwszProviders = new WCHAR[ cbProviders / sizeof(WCHAR) ];
                    if (pwszProviders == NULL) {
                        dwErr = ERROR_OUTOFMEMORY;
                    } else {
                        dwErr = cregOrder.GetString( pwszProviders, &cbProviders );
                    }
                }

                if (dwErr == ERROR_SUCCESS) {

                    //
                    // Delete Dfs only if its not already there.
                    //

                    pwszDfs = wcsstr(pwszProviders, L"Dfs,");

                    if (pwszDfs != NULL) {
                        *pwszDfs = UNICODE_NULL;
                        wcscat( pwszProviders, pwszDfs + 4);
                        dwErr = cregOrder.SetString( pwszProviders );
                    }
                }

                if (pwszProviders != wszProviders && pwszProviders != NULL) {
                    delete [] pwszProviders;
                }
            }
        }
    }

    //
    // Cleanup the LocalVolumes section
    //

    if (dwErr == ERROR_SUCCESS) {

        CRegKey cregLV( HKEY_LOCAL_MACHINE, REG_KEY_LOCAL_VOLUMES );

        dwErr = cregLV.QueryErrorStatus();

        if (dwErr == ERROR_SUCCESS) {

            dwErr = cregLV.DeleteChildren();

        }

    }

    if (dwErr == ERROR_SUCCESS) {
        dwErr = RegDeleteKey( HKEY_LOCAL_MACHINE, REG_KEY_LOCAL_VOLUMES );
    }


    //
    // Create an empty local volumes section
    //

    if (dwErr == ERROR_SUCCESS) {

        CRegKey cregLV( HKEY_LOCAL_MACHINE, REG_KEY_LOCAL_VOLUMES );

        dwErr = cregLV.QueryErrorStatus();

    }

    //
    // Add DfsInit to be run after autocheck...
    //

    if (dwErr == ERROR_SUCCESS) {

        CRegKey cregSM( HKEY_LOCAL_MACHINE,
                L"SYSTEM\\CurrentControlSet\\Control\\Session Manager",
                KEY_ALL_ACCESS);

        dwErr = cregSM.QueryErrorStatus();

        if (dwErr == ERROR_SUCCESS) {

            CRegMSZ cregBootExec( cregSM, L"BootExecute" );

            dwErr = cregBootExec.QueryErrorStatus();

            if (dwErr == ERROR_SUCCESS) {

                WCHAR  wszBootExec[128];
                DWORD  cbBootExec = sizeof(wszBootExec);
                LPWSTR pwszNextString;

                dwErr = cregBootExec.GetString(
                            wszBootExec,
                            &cbBootExec);

                if (dwErr == ERROR_SUCCESS) {

                    for (pwszNextString = wszBootExec;
                            *pwszNextString != UNICODE_NULL &&
                                (_wcsicmp(pwszNextString, L"DfsInit") != 0);
                                    pwszNextString += (wcslen(pwszNextString)
                                        + 1)) {
                         ;
                    }

                    if (*pwszNextString == UNICODE_NULL) {

                        wcscpy(pwszNextString, L"DfsInit");

                        pwszNextString += (sizeof(L"DfsInit") / sizeof(WCHAR));

                        *pwszNextString = UNICODE_NULL;

                        cregBootExec.SetString(wszBootExec);

                    }

                }

            }

        }
        // even if we didn't find BootExecute, we want to continue
        // with setting up the registry. So return success.
        dwErr = ERROR_SUCCESS; 
    }
    // Now Add value so that we recognize that this is the ds version of dfs.



    return dwErr;
}

//+------------------------------------------------------------------
//
// Function: StartDfs
//
// Synopsis:
//
// Effects: Starts out the DFS Service.
//
// Arguments: -none-
//
// Returns: 0 on success
//
// History: Nov 12, 1993         AlokS       Created
//
// Notes:
//
//-------------------------------------------------------------------
DWORD StartDfs (
    GUID *pguidDomain,
    PWSTR pwszDomain
    )
{
    DWORD dwRc;

    //
    // We load the dfs driver and then call FindDomainController. This
    // call to FindDomainController is expected to seed the Dfs driver
    // with domain info.
    //

    dwRc = _SynchStartService(L"Dfs");

    return(dwRc);
}

//+------------------------------------------------------------------
//
// Function: RemoveDfs
//
// Synopsis:
//
// Effects: Remove DFS driver
//
//-------------------------------------------------------------------

DWORD
RemoveDfs(void)
{
    //DbgCommonApiTrace(RemoveDfs);

    DWORD dwErr = ERROR_SUCCESS;

    // Open Service Controller
    CService cSvc;
    if (!(dwErr = cSvc.Init()))
    {
        // Disable DFS driver
        dwErr = cSvc._DisableService(L"Dfs");
    }
    if (dwErr)
    {
        return(dwErr);
    }
    /*
     * Registry Changes
     */
    // Now, we remove entries under DFS entry in registry

    //
    // Remove Dfs from the NetworkProvider list
    //
    if (dwErr == ERROR_SUCCESS) {

        CRegKey cregNP( HKEY_LOCAL_MACHINE,
                        L"System\\CurrentControlSet\\Control\\NetworkProvider\\Order",
                        KEY_READ | KEY_WRITE,
                        NULL,
                        REG_OPTION_NON_VOLATILE);

        dwErr = cregNP.QueryErrorStatus();

        if (dwErr == ERROR_SUCCESS) {

            CRegSZ cregOrder( cregNP, L"ProviderOrder" );
            dwErr = cregOrder.QueryErrorStatus();

            if (dwErr == ERROR_SUCCESS) {

                WCHAR wszProviders[128];
                WCHAR *pwszProviders = wszProviders;
                WCHAR *pwszDfs, *pwszAfterDfs;
                ULONG cbProviders = sizeof(wszProviders);

                dwErr = cregOrder.GetString( pwszProviders, &cbProviders );

                if (dwErr == ERROR_MORE_DATA) {

                    pwszProviders = new WCHAR[ cbProviders / sizeof(WCHAR) ];
                    if (pwszProviders == NULL) {
                        dwErr = ERROR_OUTOFMEMORY;
                    } else {
                        dwErr = cregOrder.GetString( pwszProviders, &cbProviders );
                    }
                }

                if (dwErr == ERROR_SUCCESS) {

                    //
                    // Delete Dfs only if its there.
                    //

                    pwszDfs = wcsstr(pwszProviders, L"Dfs,");
                    if (pwszDfs != NULL) {

                        pwszAfterDfs = pwszDfs + wcslen(L"Dfs,");

                        memmove(
                            (PVOID) pwszDfs,
                            (PVOID) pwszAfterDfs,
                            (wcslen( pwszAfterDfs ) + 1) * sizeof(WCHAR));

                        dwErr = cregOrder.SetString( pwszProviders );
                    }
                }

                if (pwszProviders != wszProviders && pwszProviders != NULL) {
                    delete [] pwszProviders;
                }

            }

        }

    }

    return dwErr ;
}

//+------------------------------------------------------------------
//
// Function: ConfigDfsService
//
// Synopsis:
//
// Effects: Configures Dfs Service
//
//-------------------------------------------------------------------

DWORD
ConfigDfsService()
{
    DWORD dwErr = 0;
    ULONG i;

    // Open Service Controller
    CService cSvc;
    if (dwErr = cSvc.Init())
        return dwErr;

    //
    // Get localizable name of service
    //
    MyFormatMessage(MSG_DFS_COMPONENT_NAME, MsgBuf, sizeof(MsgBuf));
    for (i = 0; MsgBuf[i] != UNICODE_NULL && i < (sizeof(MsgBuf)/sizeof(WCHAR)); i++) {
        if (MsgBuf[i] == L'\r')
            MsgBuf[i] = UNICODE_NULL;
        else if (MsgBuf[i] == L'\n')
            MsgBuf[i] = UNICODE_NULL;
    }

    // Create entry for Dfs Manager
    dwErr = cSvc._ConfigService(

               SERVICE_WIN32_OWN_PROCESS,  // Service Type
               SERVICE_AUTO_START,         // Start Type
               SERVICE_ERROR_NORMAL,       // Error Control
               L"%SystemRoot%\\system32\\Dfssvc.exe",  // service binary
               L"Dfs",                     // Load order group
               L"LanmanWorkstation\0LanmanServer\0DfsDriver\0Mup\0",   // Dependency
               NULL,                       // Logon Name
               NULL,                       // Logon Password
               MsgBuf,                     // display name
               L"Dfs"                      // Service Name
               );

    if (dwErr == ERROR_SUCCESS) {
        CRegKey cregDfs( HKEY_LOCAL_MACHINE,
                          &dwErr,
                          L"System\\CurrentControlSet\\Services\\Dfs"
                       );

        if (dwErr == ERROR_SUCCESS)  {

            CRegDWORD DfsVer ((const CRegKey &)cregDfs, L"DfsVersion",
                               DFS_VERSION_NUMBER);

            dwErr = DfsVer.QueryErrorStatus();

        }
    }
    return dwErr ;
}


//+------------------------------------------------------------------
//
// Function: RemoveDfsService
//
// Synopsis:
//
// Effects: Remove Dfs Service
//
// Arguments: -none-
//
// Returns: 0 on success
//
//
// History: May 20, 1993         AlokS       Created
//
// Notes:
//
//
//-------------------------------------------------------------------


DWORD RemoveDfsService( )
{
    DWORD dwErr = 0;

        // Open Service Controller
    CService cSvc;
    if (!(dwErr = cSvc.Init()))
    {
        // Delete  DFSManager Service
        dwErr = cSvc._DeleteService(L"DfsService");
    }

    return dwErr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\ui\dfscmd\makefile.inc ===
$(O)\app.res: \
        $(SDK_INC_PATH)\windows.h \
        $(SDK_INC_PATH)\common.ver \
        $(SDK_INC_PATH)\ntverp.h \
        app.rc \
        app.rc2 \
        resource.h \
        sharing.ico \
        $(O)\messages.h \
        $(O)\messages.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\ui\dfscmd\myutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       myutil.cxx
//
//  Contents:   Helper APIs for Sharing Tool
//
//  History:    6-Jun-93   WilliamW   Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Member:     MyGetLastComponent, public
//
//  Synopsis:   Parse a string to a (prefix, last-component) pair.  Any
//              trailing text after L'.' will be ignored
//
//  History:    07-May-93   WilliamW   Created
//
//  Notes:      pszPrefix and pszLastComponent should be pre-allocated
//
//--------------------------------------------------------------------------

VOID
MyGetLastComponent(
    IN  PWSTR pszStr,
    OUT PWSTR pszPrefix,
    OUT PWSTR pszLastComponent
    )
{
    PWSTR pszTmp     = NULL;
    PWSTR pszTmpLast = NULL;

    //
    // Manufacture the prefix part by replacing L'\\' with L'\0'
    //

    wcscpy(pszPrefix, pszStr);

    pszTmp = wcsrchr(pszPrefix, L'\\');
    if (pszTmp != NULL)
    {
        *pszTmp = L'\0';

        //
        // Extract the last component.  The L'.' part will be replaced
        // by a L'\0'
        //

        pszTmpLast = pszTmp + 1;
        pszTmp = wcsrchr(pszTmpLast, L'.');
        if (pszTmp != NULL)
        {
            //
            // Replace with a L'\0' character
            //

            *pszTmp = L'\0';
        }
        wcscpy(pszLastComponent, pszTmpLast);
    }
    else
    {
        *pszPrefix = L'\0';
        wcscpy(pszLastComponent, pszStr);
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     MyFindLastComponent, public
//
//  Synopsis:   Parse a string to find the last component. This is different
//              from MyGetLastComponent as it doesn't copy any data, but just
//              looks for the last backslash and points one after it.
//
//  History:    21-Nov-94   BruceFo
//
//--------------------------------------------------------------------------

PWSTR
MyFindLastComponent(
    IN const WCHAR* pszStr
    )
{
    PWSTR pszTmp = wcsrchr(pszStr, L'\\');
    if (pszTmp != NULL)
    {
        return pszTmp + 1;
    }
    else
    {
        return (PWSTR)pszStr;  // cast away const
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     MyGetNextComponent(), public
//
//  Synopsis:   Parse a string to a (next-components, remaing-components)
//              pair.  Any
//
//  History:    07-May-93   WilliamW   Created
//
//  Notes:      pszNextComponent and pszRemaining should be pre-allocated.
//
//--------------------------------------------------------------------------
VOID
MyGetNextComponent(
    IN  PWSTR pszStr,
    OUT PWSTR pszNextComponent,
    OUT PWSTR pszRemaining
    )
{
    PWSTR pszTmp = NULL;

    if (*pszStr == L'\0')
    {
       *pszNextComponent = *pszRemaining = L'\0';
       return;
    }

#if DBG == 1
    if (*pszStr == L'\\')
    {
        appDebugOut((DEB_IERROR,
            "WARNING: MyGetNextComponent takes a relative path as its first argument\n"));
    }
#endif // DBG == 1

    //
    // Manufacture the next component part by replacing L'\\' with L'\0'
    //

    pszTmp = wcschr(pszStr, L'\\');
    if (pszTmp != NULL)
    {
        ULONG cchNextComponent = (ULONG)(pszTmp - pszStr);
        wcsncpy(pszNextComponent, pszStr, cchNextComponent);
        pszNextComponent[cchNextComponent] = L'\0';

        //
        // Handle the remaining component.
        //

        wcscpy(pszRemaining, pszTmp + 1);
    }
    else
    {
        //
        // No remaining part, this is the last component
        //

        *pszRemaining = L'\0';

        wcscpy(pszNextComponent, pszStr);
    }
}




//+-------------------------------------------------------------------------
//
//  Method:     MyStrStr
//
//  Synopsis:   A case insensitive version of wcsstr (i.e. strstr)
//
//--------------------------------------------------------------------------
PWSTR
MyStrStr(
    IN PWSTR pszInStr,
    IN PWSTR pszInSubStr
    )
{
    if (   pszInStr == NULL
        || pszInSubStr == NULL
        || *pszInStr == L'\0'
        || *pszInSubStr == L'\0')
    {
       return NULL;
    }

    INT iSubStrLen = wcslen(pszInSubStr);
    INT iStrLen = wcslen(pszInStr);

    PWSTR pszHeadInStr = pszInStr;
    PWSTR pszTailInStr = pszInStr + iSubStrLen;

    PWSTR pszEndInStr = pszInStr + iStrLen;

    while (pszTailInStr <= pszEndInStr)
    {
        if (0 != _wcsnicmp(pszHeadInStr, pszInSubStr, iSubStrLen))
        {
            return pszHeadInStr;
        }

        pszHeadInStr++;
        pszTailInStr++;
    }

    return NULL;
}


//+-------------------------------------------------------------------------
//
//  Method:     MyFindPostfix
//
//  Synopsis:   Match the prefix with the string. If the string doesn't have
//              the prefix, return a pointer to the string itself. If it does,
//              then check to see if the character after the prefix is a
//              backslash. If it is, return a pointer to the character
//              following the backslash. Otherwise, return a pointer to the
//              character immediately after the prefix.
//
//              Examples:
//                      string          prefix      return
//                      \foo\bar\baz    \bad        \foo\bar\baz
//                      \foo\bar\baz    \foo\bar    baz
//                      \foo\bar\baz    \f          oo\bar\baz
//
//--------------------------------------------------------------------------

PWSTR
MyFindPostfix(
    IN PWSTR pszString,
    IN PWSTR pszPrefix
    )
{
    UINT cchPrefixLen = wcslen(pszPrefix);
    if (0 == _wcsnicmp(pszString, pszPrefix, cchPrefixLen))
    {
        PWSTR pszReturn = pszString + cchPrefixLen;

        if (*pszReturn == L'\\')
        {
            //
            // skip past the leading backslash.
            //
            ++pszReturn;
        }

        return pszReturn;
    }
    else
    {
        // prefix didn't match, return argument string

//         appDebugOut((DEB_ITRACE,
//                 "No postfix of ('%ws', '%ws')\n",
//                 pszString,
//                 pszPrefix));

        return pszString;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   MyFormatMessageText
//
//  Synopsis:   Given a resource IDs, load strings from given instance
//              and format the string into a buffer
//
//  History:    11-Aug-93 WilliamW   Created.
//
//--------------------------------------------------------------------------
VOID
MyFormatMessageText(
    