ype != ACPI_METHOD_ARGUMENT_INTEGER) {
        pVideoDebugPrint((Warn, 
            "VIDEOPRT: _BCL returned an invalid argument."));
        Status = STATUS_ACPI_INVALID_DATA;
        goto Fallout;
    }

    //
    // Full power level should be greater than the battery level
    //

    ASSERT (Level >= Argument->Argument); 
    
    Level = Argument->Argument;
    pVpBacklightStatus->bBIOSDefaultDCKnown = TRUE;
    pVpBacklightStatus->ucBIOSDefaultDC = (unsigned char) Level;

    //
    // Run through the list of supported modes that follow the AC/DC
    //  values and return them to the caller.
    //

    *pulNumberOfLevelsSupported = 0;
    for (count = 0; count < (Buffer->Count - 2); count++) {

        //
        // Proceed to the next argument
        //

        Argument = ACPI_METHOD_NEXT_ARGUMENT(Argument);

        if (Argument->Type != ACPI_METHOD_ARGUMENT_INTEGER) {
            pVideoDebugPrint((Warn, 
                "VIDEOPRT: _BCL returned an invalid argument."));
            Status = STATUS_ACPI_INVALID_DATA;
            goto Fallout;
        }

        //
        // Save off the argument in our array of levels.
        //

        Level = Argument->Argument;
        *ucLevels++ = (unsigned char) Level;
        *pulNumberOfLevelsSupported += 1;
        
    }

    Status = NO_ERROR;

Fallout:

    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }

    return Status;

}

NTSTATUS
VpSetLCDPowerUsage(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FullPower
    )

/*++

Routine Description:

    It changes the brightness level, based on the value of FullPower.
    
Arguments:

    DeviceObject: the ACPI device object attached to our LCD device.
    
    FullPower: if TRUE, it sets the brightness level to FullPower level  
               if FALSE, it sets the brightness level to Battery level  
Returns:

    NO_ERROR if it succeeds
    Various error codes if it fails
    
--*/

{
    PACPI_EVAL_OUTPUT_BUFFER Buffer = NULL;
    PACPI_METHOD_ARGUMENT Argument = NULL;
    ULONG Granularity = 80;
    ULONG BufferMaxSize = 4096;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    ULONG Level = 100;
    PBACKLIGHT_STATUS pVpBacklightStatus = &VpBacklightStatus;

    PAGED_CODE();
    ASSERT (DeviceObject != NULL);

    //
    // Track whether we are running on AC or DC
    //

    VpRunningOnAC = FullPower;

    //
    // If we are using the new API for backlight control, we don't need to query the 
    //  BIOS with _BCL.  We will set the AC or DC level as appropriate with _BCM.
    //

    if (pVpBacklightStatus->bNewAPISupported) {

        if (VpRunningOnAC) {

            Level = (ULONG) pVpBacklightStatus->ucACBrightness;
        }
        else {

            Level = (ULONG) pVpBacklightStatus->ucDCBrightness;
        }

        Status = pVideoPortACPIIoctl(
            DeviceObject,
            (ULONG) ('MCB_'),
            &Level,
            NULL,
            0,
            (PACPI_EVAL_OUTPUT_BUFFER)NULL);

        return Status;

    }

    //
    // Get the list of brightness levels supported
    //

    do {

        Buffer = (PACPI_EVAL_OUTPUT_BUFFER)ExAllocatePoolWithTag(
            PagedPool,
            Granularity,
            VP_TAG);
    
        if (Buffer == NULL) {
            
            pVideoDebugPrint((Warn, 
                "VIDEOPRT: VpSetLCDPowerUsage: Memory allocation failed."));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlZeroMemory(Buffer, Granularity);   

        Status = pVideoPortACPIIoctl(
            DeviceObject,
            (ULONG) ('LCB_'),
            NULL,
            NULL,
            Granularity,
            Buffer);
    
        if (Status == STATUS_BUFFER_OVERFLOW) {

            ExFreePool(Buffer);
            Buffer = NULL;
            Granularity <<= 1;
            
            if (Granularity > BufferMaxSize) {

                pVideoDebugPrint((Warn, 
                    "VIDEOPRT: _BCL failed. Expected buffer is too big."));
                Status = STATUS_ACPI_INVALID_DATA;
                break;
            }
        
        } else if (!NT_SUCCESS(Status)) {
            
            pVideoDebugPrint((Warn, 
                "VIDEOPRT: _BCL failed. Status = 0x%x\n", Status));
        
        } else {

            pVideoDebugPrint((Trace, "VIDEOPRT: _BCL succeeded.\n"));
        }
    
    } while (Status == STATUS_BUFFER_OVERFLOW);

    if ((Buffer == NULL) || (!NT_SUCCESS(Status))) 
        goto Fallout;

    //
    // Now try to set the state.
    //

    if (Buffer->Count < 2) {
        pVideoDebugPrint((Warn, 
            "VIDEOPRT: _BCL returned an invalid number of arguments."));
        Status = STATUS_ACPI_INVALID_DATA;
        goto Fallout;
    }
        
    Argument = Buffer->Argument;
    
    if (Argument->Type != ACPI_METHOD_ARGUMENT_INTEGER) {
        pVideoDebugPrint((Warn, 
            "VIDEOPRT: _BCL returned an invalid argument."));
        Status = STATUS_ACPI_INVALID_DATA;
        goto Fallout;
    }

    Level = Argument->Argument;

    if (!FullPower) {
    
        Argument = ACPI_METHOD_NEXT_ARGUMENT(Argument);
        
        if (Argument->Type != ACPI_METHOD_ARGUMENT_INTEGER) {
            pVideoDebugPrint((Warn, 
                "VIDEOPRT: _BCL returned an invalid argument."));
            Status = STATUS_ACPI_INVALID_DATA;
            goto Fallout;
        }

        //
        // Full power level should be greater than the battery level
        //

        ASSERT (Level >= Argument->Argument); 
        
        Level = Argument->Argument;
    }

    Status = pVideoPortACPIIoctl(
        DeviceObject,
        (ULONG) ('MCB_'),
        &Level,
        NULL,
        0,
        (PACPI_EVAL_OUTPUT_BUFFER)NULL);

    if (!NT_SUCCESS(Status)) {

        pVideoDebugPrint((Warn, 
            "VIDEOPRT: _BCM failed. Status = 0x%x\n", Status));
    
    } else {

        pVideoDebugPrint((Trace, "VIDEOPRT: _BCM succeeded.\n"));
    }
    
Fallout:

    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }

    return Status;
}

VOID
VpPowerStateCallback(
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    )
    
/*++

Routine Description:

    This is the callback routine that is called when the power state changes.
    
Arguments:

    CallbackContext: NULL
    
    Argument1: event code
    
    Argument2: if Argument1 is PO_CB_AC_STATUS, Argument2 contains TRUE if 
               the current power source is AC and FALSE otherwise. 

Note:

    This function can be called at DISPATCH_LEVEL
    
--*/

{
    PPOWER_STATE_WORK_ITEM PowerStateWorkItem = NULL;

    ASSERT (CallbackContext == NULL);

    switch ((ULONG_PTR)Argument1) {

    case PO_CB_LID_SWITCH_STATE:
    case PO_CB_AC_STATUS:

        PowerStateWorkItem = 
            (PPOWER_STATE_WORK_ITEM)ExAllocatePoolWithTag(
                NonPagedPool, 
                sizeof(POWER_STATE_WORK_ITEM), 
                VP_TAG);

        if (PowerStateWorkItem != NULL) {

            PowerStateWorkItem->Argument1 = Argument1;
            PowerStateWorkItem->Argument2 = Argument2;

            ExInitializeWorkItem(
                &PowerStateWorkItem->WorkItem,
                VpDelayedPowerStateCallback,
                PowerStateWorkItem);

            ExQueueWorkItem(
                &PowerStateWorkItem->WorkItem,
                DelayedWorkQueue);

        } else {

            pVideoDebugPrint((Warn, 
                "VIDEOPRT: VpPowerStateCallback: Memory allocation failed."));
        }

        break;

    default:
        
        //
        // Ignore all other cases
        //

        break;
    }
}


VOID
VpDelayedPowerStateCallback(
    IN PVOID Context
    )

/*++

Routine Description:

    VpPowerStateCallback queues this work item in order to handle 
    PowerState changes at PASSIVE_LEVEL.
    
Arguments:

    Context: pointer to POWER_STATE_WORK_ITEM 

--*/

{
    PPOWER_STATE_WORK_ITEM PowerStateWorkItem = 
        (PPOWER_STATE_WORK_ITEM)Context;
    PDEVICE_OBJECT AttachedDevice = NULL;
    NTSTATUS status;
    POWER_STATE powerState;
    PCHILD_PDO_EXTENSION pdoExtension;

    PAGED_CODE();
    ASSERT (PowerStateWorkItem != NULL);

    KeWaitForSingleObject(&LCDPanelMutex,
        Executive,
        KernelMode,
        FALSE,
        (PTIME)NULL);

    if (LCDPanelDevice == NULL) {
        goto Fallout;
    }

    switch ((ULONG_PTR)PowerStateWorkItem->Argument1) {

    case PO_CB_AC_STATUS:

        AttachedDevice = IoGetAttachedDeviceReference(LCDPanelDevice);
        
        VpSetLCDPowerUsage(
            AttachedDevice, 
            (PowerStateWorkItem->Argument2 != 0));
        
        ObDereferenceObject(AttachedDevice);
        
        break;

    case PO_CB_LID_SWITCH_STATE:

        pdoExtension = LCDPanelDevice->DeviceExtension;

        if ((ULONG_PTR)PowerStateWorkItem->Argument2 == 0) {
        
            //
            // The lid is closed. Put the LCD Panel into D3 and override
            // any future power requests to the panel.
            //

            pdoExtension->PowerOverride = TRUE;
            powerState.DeviceState = PowerDeviceD3;
            pVideoDebugPrint((Trace, "VIDEOPRT: LCD Panel Closed.\n"));

        } else if ((ULONG_PTR)PowerStateWorkItem->Argument2 == 1) {

            pdoExtension->PowerOverride = FALSE;
            powerState.DeviceState = PowerDeviceD0;
            pVideoDebugPrint((Trace, "VIDEOPRT: LCD Panel Open.\n"));

        } else {

            pVideoDebugPrint((Error, "VIDEOPRT: Unknown LCD lid close event recieved.\n"));
            ASSERT(FALSE);
            goto Fallout;
        }

        if (pdoExtension->pFdoExtension->DevicePowerState == PowerDeviceD0)
        {

            if (VpLidCloseSetPower == TRUE)
            {

                status = PoRequestPowerIrp (LCDPanelDevice,
                IRP_MN_SET_POWER,
                powerState,
                pVideoPortPowerIrpComplete,
                (PVOID)NULL,
                NULL);

                if (status != STATUS_PENDING) {
                    pVideoDebugPrint((Error, "VIDEOPRT: Could not send power IRP to toggle panel\n"));
                }
            }
        }
    
        break;

    default:
        
        pVideoDebugPrint((Warn, 
            "VIDEOPRT: Unexpected PowerState event recieved.\n"));
        
        ASSERT(FALSE);
        break;
    }

Fallout:

    KeReleaseMutex(&LCDPanelMutex, FALSE);

    ExFreePool(Context);
}


VOID
VpRegisterPowerStateCallback(
    VOID
    )

/*++

Routine Description:

    This routine registers the PowerState callback routine.
    
--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING CallbackName;
    PCALLBACK_OBJECT CallbackObject;
    NTSTATUS Status;

    PAGED_CODE();

    RtlInitUnicodeString(&CallbackName, L"\\Callback\\PowerState");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &CallbackName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,  
        NULL,
        NULL
        );

    Status = ExCreateCallback(
        &CallbackObject,
        &ObjectAttributes,
        FALSE,
        TRUE
        );

    if (NT_SUCCESS(Status)) {
        
        PowerStateCallbackHandle = ExRegisterCallback(
            CallbackObject,
            VpPowerStateCallback,
            NULL
            );

        if (PowerStateCallbackHandle == NULL) {

            pVideoDebugPrint((Warn, 
                "VIDEOPRT: Could not register VpPowerStateCallback.\n"));
        
        } else {

            pVideoDebugPrint((Trace, 
                "VIDEOPRT: VpPowerStateCallback registered. \n"));
        }
    
    } else {

        pVideoDebugPrint((Warn, 
            "VIDEOPRT: Could not get the PowerState callback object.\n"));
    }
}


VOID
VpRegisterLCDCallbacks(
    VOID
    )

/*++

Routine Description:

    This routine registers a callback with the system so that we can
    be notified of power state changes.
        
--*/

{
    PAGED_CODE();

    //
    // Register power state callback. This works for the lid as well.
    //

    if (PowerStateCallbackHandle == NULL) {
        VpRegisterPowerStateCallback();
    }
    
}


VOID
VpUnregisterLCDCallbacks(
    VOID
    )

/*++

Routine Description:

    This routine unregisters the callbacks previously registered by 
    VpRegisterLCDCallbacks

Arguments:

    None. 
    
Note:    
    
    The global PowerStateCallbackHandle acts as an implicit parameter.

--*/

{
    PAGED_CODE();

    //
    // Unregister power state callback
    //

    if (PowerStateCallbackHandle != NULL) {
        
        ExUnregisterCallback(PowerStateCallbackHandle);
        PowerStateCallbackHandle = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\port\ddc.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    ddc.c

Abstract:

    This is the NT Video port Display Data Channel (DDC) code. It contains the
    implementations for the EDID industry standard Extended Display
    Identification Data manipulations.

Author:

    Bruce McQuistan (brucemc) 23-Sept-1996

Environment:

    kernel mode only

Notes:

    Based on VESA EDID Specification Version 2, April 9th, 1996
    Updated to support VESA E-DDC Proposed Standard Version 1P, July 13, 1999.

--*/

#include "videoprt.h"

//
// Make it easy to change debug verbosity.
//

#define DEBUG_DDC                   1

//
// Define constants used by DDC.
//

#define EDID_1_SIZE                 128
#define EDID_2_SIZE                 256
#define EDID_QUERY_RETRIES          5
#define DDC_I2C_DELAY               5               // Microseconds
#define DDC_ADDRESS_SET_OFFSET      (UCHAR)0xA0     // To set word offset into EDID
#define DDC_ADDRESS_READ            (UCHAR)0xA1     // To read EDID
#define DDC_ADDRESS_PD_SET_OFFSET   (UCHAR)0xA2     // As above for display with P&D connector
#define DDC_ADDRESS_PD_READ         (UCHAR)0xA3     // As above for display with P&D connector
#define DDC_ADDRESS_SET_SEGMENT     (UCHAR)0x60     // To set index to 256 bytes EDID segment

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, VideoPortDDCMonitorHelper)
#pragma alloc_text (PAGE, DDCReadEdidSegment)
#endif  // ALLOC_PRAGMA

//
// Exported routines.
//

VIDEOPORT_API
BOOLEAN
VideoPortDDCMonitorHelper(
    IN PVOID pHwDeviceExtension,
    IN PVOID pDDCControl,
    IN OUT PUCHAR pucEdidBuffer,
    IN ULONG ulEdidBufferSize
    )

/*++

Routine Description:

    This routine reads the EDID structure from the monitor using DDC.

    If caller asks for 256 bytes he may receive:
        1. One 128 bytes EDID
        2. Two 128 bytes EDIDs
        3. One 256 bytes EDID (from P&D display)
        4. No EDID

    Caller should always ask for 256 bytes, since it is impossble to
    read second 128 bytes block of the segment only.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pDDCControl        - DDC access control block.
    pucEdidBuffer      - Buffer where information will be stored.
                         For ACPI devices first four bytes are preset by
                         the videoprt to indicated attempt to read the EDID.
                         We should clear those bytes in case of the EDID
                         read failure to prevent videoprt from unnecessary
                         call of the ACPI method.
    ulEdidBufferSize   - Size of the buffer to fill.

Returns:

    TRUE  - DDC read OK.
    FALSE - DDC read failed.

--*/

{
    ULONG ulChecksum;                   // EDID checksum
    ULONG ulScratch;                    // Temp variable
    ULONG ulTry;                        // EDID read retry counter
    ULONG ulSize;                       // EDID size to read
    UCHAR ucEdidSegment;                // E-DDC segment to read
    BOOLEAN bEnhancedDDC;               // Use enhanced DDC flag
    VIDEO_I2C_CONTROL i2CControl;       // I2C lines handling functions

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pDDCControl);
    ASSERT(NULL != pucEdidBuffer);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    //
    // Check the size of the input structure.
    //

    if (((PDDC_CONTROL)pDDCControl)->Size == sizeof (I2C_FNC_TABLE))
    {
        ucEdidSegment = 0;
        bEnhancedDDC  = FALSE;      // Make sure we are backword compatible
    }
    else if (((PDDC_CONTROL)pDDCControl)->Size == sizeof (DDC_CONTROL))
    {
        ucEdidSegment = ((PDDC_CONTROL)pDDCControl)->EdidSegment;
        bEnhancedDDC  = TRUE;
    }
    else
    {
        pVideoDebugPrint((0, "VIDEOPRT!VideoPortDDCMonitorHelper: Invalid DDC_CONTROL\n"));
        ASSERT(FALSE);
        return FALSE;
    }

    i2CControl.WriteClockLine = ((PDDC_CONTROL)pDDCControl)->I2CCallbacks.WriteClockLine;
    i2CControl.WriteDataLine = ((PDDC_CONTROL)pDDCControl)->I2CCallbacks.WriteDataLine;
    i2CControl.ReadClockLine = ((PDDC_CONTROL)pDDCControl)->I2CCallbacks.ReadClockLine;
    i2CControl.ReadDataLine = ((PDDC_CONTROL)pDDCControl)->I2CCallbacks.ReadDataLine;
    i2CControl.I2CDelay = DDC_I2C_DELAY * 10;       // 100ns units

    ASSERT(NULL != i2CControl.WriteClockLine);
    ASSERT(NULL != i2CControl.WriteDataLine);
    ASSERT(NULL != i2CControl.ReadClockLine);
    ASSERT(NULL != i2CControl.ReadDataLine);

    //
    // Initialize I2C lines and switch monitor to DDC2 mode only for the first EDID.
    // This is the most time consuming operation, we don't want to repeat it.
    // We can safely assume we'll be always asked for the segment 0 first.
    // Once switched to DDC2 the monitor will stay in that mode.
    //

    if (0 == ucEdidSegment)
    {
        //
        // Initialize SDA and SCL lines to default state of released high (input).
        //

        i2CControl.WriteDataLine(pHwDeviceExtension, 1);
        DELAY_MICROSECONDS(DDC_I2C_DELAY);
        i2CControl.WriteClockLine(pHwDeviceExtension, 1);
        DELAY_MICROSECONDS(DDC_I2C_DELAY);

        //
        // Send 9 clock pulses on SCL to switch DDC2-capable monitor to DDC2 mode.
        //

        for (ulScratch = 0; ulScratch < 9; ulScratch++)
        {
            i2CControl.WriteClockLine(pHwDeviceExtension, 0);
            DELAY_MICROSECONDS(DDC_I2C_DELAY);
            i2CControl.WriteClockLine(pHwDeviceExtension, 1);
            DELAY_MICROSECONDS(DDC_I2C_DELAY);
        }

        if (I2CWaitForClockLineHigh2(pHwDeviceExtension, &i2CControl) == FALSE)
        {
            pVideoDebugPrint((0, "VIDEOPRT!VideoPortDDCMonitorHelper: Can't switch to DDC2\n"));
            RtlZeroMemory(pucEdidBuffer, sizeof (ULONG));   // Let videoprt know we tried to read
            return FALSE;
        }
    }

    //
    // Using A0/A1 we can read two 128 byte EDIDs. If we are asked for a bigger size
    // we will do two reads.
    //

    ulSize = ulEdidBufferSize > EDID_1_SIZE ? EDID_1_SIZE : ulEdidBufferSize;

    if (DDCReadEdidSegment(pHwDeviceExtension,
                           &i2CControl,
                           pucEdidBuffer,
                           ulSize,
                           ucEdidSegment,
                           0x00,
                           DDC_ADDRESS_SET_OFFSET,
                           DDC_ADDRESS_READ,
                           bEnhancedDDC) == TRUE)
    {
        if (ulEdidBufferSize <= EDID_1_SIZE)
        {
            return TRUE;
        }

        ulSize = ulEdidBufferSize - EDID_1_SIZE;

        //
        // We can read maximum two EDIDs per segment - make sure our size is correct.
        //

        if (ulSize > EDID_1_SIZE)
        {
            ulSize = EDID_1_SIZE;
        }

        //
        // We don't care about return code here - we've already got first EDID,
        // and it is possible the second one doesn't exist.
        //

        DDCReadEdidSegment(pHwDeviceExtension,
                           &i2CControl,
                           pucEdidBuffer + EDID_1_SIZE,
                           ulSize,
                           ucEdidSegment,
                           0x80,
                           DDC_ADDRESS_SET_OFFSET,
                           DDC_ADDRESS_READ,
                           bEnhancedDDC);

        return TRUE;
    }

    //
    // Check for P&D 256 EDID at A2/A3 only for segment 0.
    //

    if (0 != ucEdidSegment)
        return FALSE;

    //
    // P&D display is a special case - its 256 bytes EDID can be accessed using
    // A2/A3 or using segment 1 and A0/A1. We shoudn't read its EDID twice though
    // since we're going to use A2/A3 only if we can't read segment 0 using A0/A1,
    // which most likely means that there are no multiple EDIDs.
    //
    // Note: In this case we don't want to program E-DDC segment, so we just
    // always force bEnhancedDDC to FALSE.
    //

    return DDCReadEdidSegment(pHwDeviceExtension,
                              &i2CControl,
                              pucEdidBuffer,
                              ulEdidBufferSize,
                              ucEdidSegment,
                              0x00,
                              DDC_ADDRESS_PD_SET_OFFSET,
                              DDC_ADDRESS_PD_READ,
                              FALSE);
}   // VideoPortDDCMonitorHelper()

//
// Local routines.
//

BOOLEAN
DDCReadEdidSegment(
    IN PVOID pHwDeviceExtension,
    IN PVIDEO_I2C_CONTROL pI2CControl,
    IN OUT PUCHAR pucEdidBuffer,
    IN ULONG ulEdidBufferSize,
    IN UCHAR ucEdidSegment,
    IN UCHAR ucEdidOffset,
    IN UCHAR ucSetOffsetAddress,
    IN UCHAR ucReadAddress,
    IN BOOLEAN bEnhancedDDC
    )

/*++

Routine Description:

    This routine reads the EDID structure at given segment.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CControl        - I2C lines control functions.
    pucEdidBuffer      - Buffer where information will be stored.
    ulEdidBufferSize   - Size of the buffer to fill.
    ucEdidSegment      - 256 bytes EDID segment to read.
    ucEdidOffset       - Offset within the segment.
    ucSetOffsetAddress - DDC command.
    ucReadAddress      - DDC command.
    bEnhancedDDC       - TRUE if we want to use 0x60 for segment addressing.

Returns:

    TRUE  - DDC read OK.
    FALSE - DDC read failed.

--*/

{
    ULONG ulScratch;                    // Temp variable
    ULONG ulTry;                        // EDID read retry counter

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CControl);
    ASSERT(NULL != pucEdidBuffer);
    ASSERT(NULL != pI2CControl->WriteClockLine);
    ASSERT(NULL != pI2CControl->WriteDataLine);
    ASSERT(NULL != pI2CControl->ReadClockLine);
    ASSERT(NULL != pI2CControl->ReadDataLine);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    for (ulTry = 0; ulTry < EDID_QUERY_RETRIES; ulTry++)
    {
        RtlZeroMemory(pucEdidBuffer, ulEdidBufferSize);

        //
        // Set EDID segment for E-DDC.
        //

        if (TRUE == bEnhancedDDC)
        {
            if (I2CStart2(pHwDeviceExtension, pI2CControl) == FALSE)
            {
                I2CStop2(pHwDeviceExtension, pI2CControl);
                pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C start\n"));
                continue;
            }

            pucEdidBuffer[0] = DDC_ADDRESS_SET_SEGMENT;
            pucEdidBuffer[1] = ucEdidSegment;

            if (I2CWrite2(pHwDeviceExtension, pI2CControl, pucEdidBuffer, 2) == FALSE)
            {
                //
                // For segment 0 we don't care about return code here since monitor
                // may not support E-DDC.
                //

                if (0 != ucEdidSegment)
                {
                    I2CStop2(pHwDeviceExtension, pI2CControl);
                    pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C write\n"));
                    continue;
                }
            }
        }

        if (I2CStart2(pHwDeviceExtension, pI2CControl) == FALSE)
        {
            I2CStop2(pHwDeviceExtension, pI2CControl);
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C start\n"));
            continue;
        }

        //
        // Set offset to read from.
        //

        pucEdidBuffer[0] = ucSetOffsetAddress;
        pucEdidBuffer[1] = ucEdidOffset;

        if (I2CWrite2(pHwDeviceExtension, pI2CControl, pucEdidBuffer, 2) == FALSE)
        {
            I2CStop2(pHwDeviceExtension, pI2CControl);
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C write\n"));
            continue;
        }

        if (I2CStart2(pHwDeviceExtension, pI2CControl) == FALSE)
        {
            I2CStop2(pHwDeviceExtension, pI2CControl);
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C start\n"));
            continue;
        }

        //
        // Tell the monitor that we want to read EDID.
        //

        pucEdidBuffer[0] = ucReadAddress;

        if (I2CWrite2(pHwDeviceExtension, pI2CControl, pucEdidBuffer, 1) == FALSE)
        {
            I2CStop2(pHwDeviceExtension, pI2CControl);
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C write\n"));
            continue;
        }

        //
        // Read EDID from the monitor.
        //

        if (I2CRead2(pHwDeviceExtension, pI2CControl, pucEdidBuffer, ulEdidBufferSize, TRUE) == FALSE)
        {
            I2CStop2(pHwDeviceExtension, pI2CControl);
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed I2C read\n"));
            continue;
        }

        I2CStop2(pHwDeviceExtension, pI2CControl);

        //
        // Calculate the EDID checksum in case when we read full EDID.
        // We should have 0x00 in LSB for proper EDID.
        //

        if (((EDID_1_SIZE == ulEdidBufferSize) && ((0x00 == ucEdidOffset) || (0x80 == ucEdidOffset))) ||
            ((EDID_2_SIZE == ulEdidBufferSize) && (0x00 == ucEdidOffset)))
        {
            ULONG ulChecksum = 0;

            for (ulScratch = 0; ulScratch < ulEdidBufferSize; ulScratch++)
                ulChecksum += pucEdidBuffer[ulScratch];
  
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: EDID checksum = 0x%08X\n", ulChecksum));

            if (((ulChecksum & 0xFF) == 0) &&
                 (0 != ulChecksum) &&
                 (ulChecksum != ulEdidBufferSize * 0xFF))
            {
                pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Full EDID read OK\n"));
                return TRUE;
            }

            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Invalid checksum\n"));
        }
        else
        {
            pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Partial EDID read OK\n"));
            return TRUE;
        }
    }

    pVideoDebugPrint((DEBUG_DDC, "VIDEOPRT!DDCReadEdidSegment: Failed\n"));
    RtlZeroMemory(pucEdidBuffer, sizeof (ULONG));   // Let videoprt know we tried to read
    return FALSE;
}   // DDCReadEdidSegment()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\port\dump.c ===
/*++

Copyright (c) 1990-2002  Microsoft Corporation

Module Name:

    dump.c

Abstract:

    This module supplies support for building a mini-dump file.

Author:

    Oleg Kagan (olegk) Jun. 2002

Environment:

    kernel mode only

Revision History:

--*/

#include "videoprt.h"

#define TRIAGE_DUMP_DATA_SIZE (TRIAGE_DUMP_SIZE - sizeof(ULONG))

ULONG
pVpAppendSecondaryMinidumpData(
    PVOID pvSecondaryData,
    ULONG ulSecondaryDataSize,
    PVOID pvDump
    )

/*++

Routine Description:

    Adds precollected video driver specific data
    
Arguments:

    pvDump - points to the begiinig of the dump buffer
    pvSecondaryDumpData - points to the secondary data buffer
    ulSecondaryDataSize - size of the secondary data buffer
    
Return Value:

    Resulting length of the minidump

--*/
                                
{
    PMEMORY_DUMP pDump = (PMEMORY_DUMP)pvDump;
    ULONG_PTR DumpDataEnd = (ULONG_PTR)pDump + TRIAGE_DUMP_DATA_SIZE;
    PDUMP_HEADER pdh = &(pDump->Header);

    PVOID pBuffer = (PVOID)((ULONG_PTR)pvDump + TRIAGE_DUMP_SIZE);
    PDUMP_BLOB_FILE_HEADER BlobFileHdr = (PDUMP_BLOB_FILE_HEADER)(pBuffer);
    PDUMP_BLOB_HEADER BlobHdr = (PDUMP_BLOB_HEADER)(BlobFileHdr + 1);
    
    if (!pvDump) return 0;
   
    if (pvSecondaryData && ulSecondaryDataSize) {
    
        if (ulSecondaryDataSize > MAX_SECONDARY_DUMP_SIZE) 
            ulSecondaryDataSize = MAX_SECONDARY_DUMP_SIZE;
            
        pdh->RequiredDumpSpace.QuadPart = TRIAGE_DUMP_SIZE + ulSecondaryDataSize;
    
        BlobFileHdr->Signature1 = DUMP_BLOB_SIGNATURE1;
        BlobFileHdr->Signature2 = DUMP_BLOB_SIGNATURE2;
        BlobFileHdr->HeaderSize = sizeof(*BlobFileHdr);
        BlobFileHdr->BuildNumber = NtBuildNumber;
        
        BlobHdr->HeaderSize = sizeof(*BlobHdr);
        BlobHdr->Tag = VpBugcheckGUID;
        BlobHdr->PrePad = 0;
        BlobHdr->PostPad = MAX_SECONDARY_DUMP_SIZE - ulSecondaryDataSize;
        BlobHdr->DataSize = ulSecondaryDataSize;
        
        RtlCopyMemory((PVOID)(BlobHdr + 1), pvSecondaryData, ulSecondaryDataSize);
    }
    
    return (ULONG)pdh->RequiredDumpSpace.QuadPart;
}

VOID
VpNotifyEaData(
    PDEVICE_OBJECT DeviceObject,
    PVOID pvDump
    )

{
    PDEVICE_OBJECT pPdo = IoGetDeviceAttachmentBaseRef(DeviceObject);

    if (pPdo) {

    	//
    	// Find the FDO that matches this PDO
    	//
    
    	PFDO_EXTENSION CurrFdo = FdoHead;
    
    	while (CurrFdo) {
    
    	    if (CurrFdo->PhysicalDeviceObject == pPdo) {
    		VpBugcheckDeviceObject = CurrFdo->FunctionalDeviceObject;
    	    }
    
    	    CurrFdo = CurrFdo->NextFdoExtension;
    	}
    
    	ASSERT(VpBugcheckDeviceObject != NULL);
    
    	if (pvDump) {
            if (!VpDump) {
                VpDump = ExAllocatePoolWithTag(PagedPool,
                                               TRIAGE_DUMP_SIZE + 0x1000, // XXX olegk - why 1000? why not 2*TRIAGE_DUMP_SIZE?
                                               VP_TAG);
            }
            
            if (VpDump) memcpy(VpDump, pvDump, TRIAGE_DUMP_SIZE + 0x1000);
    	}
    
    	ObDereferenceObject(pPdo);
    }
}

PRTL_PROCESS_MODULES
WdpGetLoadedModuleList(
    VOID
    )

/*++

Routine Description:

    This routine returns a pointer to a list of loaded modules.

Arguments:

    None.

Return Value:

    A pointer to memory with the loaded module list.

Notes:

    The caller is responsible for freeing the memory when no longer needed.

--*/

{
    PRTL_PROCESS_MODULES Buffer = NULL;
    ULONG BufferSize;
    ULONG ReturnLength = 4096;
    NTSTATUS Status;

    do
    {
        if (Buffer)
        {
            ExFreePool(Buffer);
        }

        BufferSize = ReturnLength;

        Buffer = ExAllocatePoolWithTag(NonPagedPool, BufferSize, VP_TAG);

        if (Buffer == NULL)
        {
            break;
        }

        Status = ZwQuerySystemInformation(SystemModuleInformation,
                                          Buffer,
                                          BufferSize,
                                          &ReturnLength);

    } while (Status == STATUS_INFO_LENGTH_MISMATCH);

    return Buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\port\edid.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

  edid.c

Abstract:

    This is the NT Video port Display Data Channel (DDC) code. It contains the
    implementations for the EDID industry standard Extended Display
    Identification Data manipulations.

Author:

    Bruce McQuistan (brucemc) 23-Sept-1996

Environment:

    kernel mode only

Notes:

    Based on VESA EDID Specification Version 2, April 9th, 1996

Revision History:

    7/3/97  - brucemc. fixed some detailed timing decoding macros.
    4/14/98 - brucemc. added support for version 3 (revision date 11/13/97).

--*/

#include "videoprt.h"
#include "pedid.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,EdidCheckSum)
#pragma alloc_text(PAGE,pVideoPortIsValidEDID)
#pragma alloc_text(PAGE,pVideoPortGetEDIDId)
#endif

BOOLEAN
EdidCheckSum(
    IN  PCHAR   pBlob,
    IN  ULONG   BlobSize
    )
{
    CHAR    chk=0;
    ULONG   i;

    for (i=0; i<BlobSize; i++)
        chk = (CHAR)(chk + ((CHAR*)pBlob)[i]);

    if (chk != 0)
    {
        pVideoDebugPrint((0, " ***** invalid EDID chksum at %x\n", pBlob));
        return FALSE;
    }

    return TRUE;

}

VOID
pVideoPortGetEDIDId(
    PVOID  pEdid,
    PWCHAR pwChar
    )
{
    WCHAR    _hex[] = L"0123456789ABCDEF";
    PUCHAR   pTmp;

    if ((((UNALIGNED ULONG*)pEdid)[0] == 0xFFFFFF00) &&
        (((UNALIGNED ULONG*)pEdid)[1] == 0x00FFFFFF))
        pTmp = &(((PEDID_V1)pEdid)->UC_OemIdentification[0]);
    else
        pTmp = &(((PEDID_V2)pEdid)->UC_Header[1]);

    pwChar[0] = 0x40 + ((pTmp[0] >> 2) & 0x1F);
    pwChar[1] = 0x40 + (((pTmp[0] << 3)|(pTmp[1] >> 5)) & 0x1F);
    pwChar[2] = 0x40 + (pTmp[1] & 0x1F) ;
    pwChar[3] = _hex[(pTmp[3] & 0xF0) >> 4];
    pwChar[4] = _hex[(pTmp[3] & 0x0F)];
    pwChar[5] = _hex[(pTmp[2] & 0xF0) >> 4];
    pwChar[6] = _hex[(pTmp[2] & 0x0F)];
    pwChar[7] = 0;
}


PVOID
pVideoPortGetMonitordescription(
    PVOID pEdid)
{
    PWSTR pStr = NULL;

    return NULL;
}


BOOLEAN
pVideoPortIsValidEDID(
    PVOID pEdid
    )
{
    CHAR    chk=0;
    UCHAR   versionNumber, revisionNumber;
    ULONG   i;

    ASSERT(pEdid);

    //
    // Version 1 EDID checking
    //

    if ((((UNALIGNED ULONG*)pEdid)[0] == 0xFFFFFF00) &&
        (((UNALIGNED ULONG*)pEdid)[1] == 0x00FFFFFF))
    {
        pVideoDebugPrint((1, " ***** Valid EDID1 header at %x\n", pEdid));
        return EdidCheckSum(pEdid, 128);
    }

    //
    // EDID V2 support
    //
    versionNumber   =   ((PEDID_V2) pEdid)->UC_Header[0];
    versionNumber >>= 4;

    revisionNumber  =   ((PEDID_V2) pEdid)->UC_Header[0];
    revisionNumber &= 7;

    //
    //  Note that the versionNumber cannot be 1 because then it would
    //  have to be of the form above.
    //

    if (versionNumber != 2)
        {
        pVideoDebugPrint((1, " ***** invalid EDID2 header at %x\n", &((PEDID_V2) pEdid)->UC_Header[0]));
        return FALSE;
        }

    return  EdidCheckSum(pEdid, 256);

}


BOOLEAN
VideoPortIsMonitorDescriptor(
    IN  PEDID_V1   Edid,
    IN  ULONG      BlockNumber
    )
/*++

Routine Description:

    Determines the Block is a VESA DDC compliant MonitorDescriptor.

Arguments:

    Edid    - pointer to an EDID
    BlockNumber - number indicating which block to query (1-4).

Return Value:

   TRUE if the block is a VESA DDC compliant MonitorDescriptor.
   FALSE if the block is not a VESA DDC compliant MonitorDescriptor
   STATUS_INVALID_PARAMETER if the BlockNumber is invalid.

--*/
{
    PMONITOR_DESCRIPTION    pMonitorDesc;

    switch(BlockNumber)    {

        default:
            pVideoDebugPrint((0, "Bogus DescriptorNumber\n"));
            return FALSE;

        case 1:
            pMonitorDesc = (PMONITOR_DESCRIPTION)GET_EDID_PDETAIL1(Edid);
            break;

        case 2:
            pMonitorDesc = (PMONITOR_DESCRIPTION)GET_EDID_PDETAIL2(Edid);
            break;

        case 3:
            pMonitorDesc = (PMONITOR_DESCRIPTION)GET_EDID_PDETAIL3(Edid);
            break;

        case 4:
            pMonitorDesc = (PMONITOR_DESCRIPTION)GET_EDID_PDETAIL4(Edid);
            break;
    }

    if ((pMonitorDesc->Flag1[0] == 0) && (pMonitorDesc->Flag1[1] == 0)) {

        return TRUE;
    }

    pVideoDebugPrint((1, " Not a monitordescriptor\n"));
    return FALSE;
}


NTSTATUS
pVideoPortGetMonitorInfo(
    IN  PMONITOR_DESCRIPTION             MonitorDesc,
    OUT UCHAR                            Ascii[64]
    )
/*++

Routine Description:

    Helper routine for decoding a VESA DDC compliant Monitor Description (Detailed Timing).

Arguments:

    MonitorDesc - Pointer to a MONITOR_DESCRIPTION extracted from the EDID.
    Ascii - Buffer to be filled in.

Return Value:

   STATUS_SUCCESS if successful
   STATUS_INVALID_PARAMETER if there's nothing to decode.

--*/

{
    PUCHAR pRanges = GET_MONITOR_RANGE_LIMITS(MonitorDesc);
    ULONG   index;

    if (IS_MONITOR_DATA_SN(MonitorDesc) ||
        IS_MONITOR_DATA_STRING(MonitorDesc) ||
        IS_MONITOR_DATA_NAME(MonitorDesc)    ) {

        //
        //  find the things length. It ends in 0xa.
        //

        RtlCopyMemory(Ascii, pRanges, 13);

        for (index = 0; index < 13; ++index) {

            if (Ascii[index] == 0x0a) {
                Ascii[index] = (UCHAR)NULL;
                break;
            }
        }

        Ascii[index] = (UCHAR)NULL;
        return STATUS_SUCCESS;
    }

  return STATUS_INVALID_PARAMETER;
}

NTSTATUS
VideoPortGetEdidMonitorDescription(
    IN  PEDID_V1    Edid,
    IN  ULONG       DescriptorNumber,
    OUT UCHAR       Ascii[64]
    )
/*++

Routine Description:

    Extracts VESA DDC compliant Monitor Descriptor indexed by DescriptorNumber and
    decodes it into the REGISTRY_MONITOR_DESCRIPTOR passed in by user.

Arguments:

    Edid - Pointer to the a copy of the EDID from the monitors ROM.
    DescriptorNumber - a ULONG enumerating which Detailed Descriptor to decode.
    Ascii - Buffer to be filled in.

Return Value:

   STATUS_SUCCESS or STATUS_INVALID_PARAMETER.

--*/

{
    NTSTATUS                retval;
    PMONITOR_DESCRIPTION    pMonitorDesc;

    switch(DescriptorNumber)    {

        default:
            pVideoDebugPrint((0, "Bogus DescriptorNumber\n"));
            return STATUS_INVALID_PARAMETER;

        case 1:
            pMonitorDesc = (PMONITOR_DESCRIPTION)GET_EDID_PDETAIL1(Edid);
            break;

        case 2:
            pMonitorDesc = (PMONITOR_DESCRIPTION)GET_EDID_PDETAIL2(Edid);
            break;

        case 3:
            pMonitorDesc = (PMONITOR_DESCRIPTION)GET_EDID_PDETAIL3(Edid);
            break;

        case 4:
            pMonitorDesc = (PMONITOR_DESCRIPTION)GET_EDID_PDETAIL4(Edid);
            break;
    }

    retval       = pVideoPortGetMonitorInfo(pMonitorDesc, Ascii);

    return retval;
}


ULONG
pVideoPortGetEdidOemID(
    IN  PVOID   pEdid,
    OUT PUCHAR  pBuffer
    )
{
    ULONG   count, versionNumber, revisionNumber, totalLength = 0;

    if ((((UNALIGNED ULONG*)pEdid)[0] == 0xFFFFFF00) &&
        (((UNALIGNED ULONG*)pEdid)[1] == 0x00FFFFFF)) {

        PEDID_V1    pEdidV1   = (PEDID_V1)pEdid;

        for (count = 1; count < 5; ++count) {

            if (VideoPortIsMonitorDescriptor(pEdidV1, count)) {

                if (STATUS_SUCCESS ==
                    VideoPortGetEdidMonitorDescription(pEdidV1,
                                                       count,
                                                       &(pBuffer[totalLength]))) {

                    totalLength              += strlen(&(pBuffer[totalLength]));

                    pBuffer[totalLength]      = '_';
                }
            }

            //
            //  NULL terminate it.
            //

             pBuffer[totalLength]      = (UCHAR) NULL;
        }

    return totalLength;
    }

    //
    // EDID V2 support
    //
    versionNumber   =   ((PEDID_V2) pEdid)->UC_Header[0];
    versionNumber >>= 4;

    revisionNumber  =   ((PEDID_V2) pEdid)->UC_Header[0];
    revisionNumber &= 7;

    //
    //  Note that the versionNumber cannot be 1 because then it would
    //  have to be of the form above.
    //

    if (versionNumber != 2) {

        pVideoDebugPrint((1, " ***** invalid EDID2 header at %x\n", &((PEDID_V2) pEdid)->UC_Header[0]));
        return 0;

    } else {

        PEDID_V2    pEdidV2   = (PEDID_V2)pEdid;

        //
        //  This string has ascii code 0x9 delineating the
        //  manufacturers name and terminating with 0xa. Replace these
        //  with '_' and NULL respectively.
        //

        memcpy(pBuffer, pEdidV2->UC_OemIdentification, 32);

        for(count = 0; count < 32; ++count) {

            if (pBuffer[count] == 0x9) {

                pBuffer[count] = '_';
                continue;
            }

            if (pBuffer[count] == 0xa)
                break;
        }

        pBuffer[count] = (UCHAR)NULL;

    }
    return (count + 1);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\port\i2c2.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    i2c2.c

Abstract:

    This is the NT Video port I2C helper code for interface version 2.

Author:

    Michael Maciesowicz (mmacie) 23-Apr-2001

Environment:

    kernel mode only

Notes:

--*/

#include "videoprt.h"

//
// Define constants used by I2C.
//

#define I2C_START_RETRIES       10
#define I2C_SCL_READ_RETRIES    10
#define I2C_DELAY(pI2CControl)  DELAY_MICROSECONDS((pI2CControl)->I2CDelay / 10)

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, I2CStart2)
#pragma alloc_text (PAGE, I2CStop2)
#pragma alloc_text (PAGE, I2CWrite2)
#pragma alloc_text (PAGE, I2CRead2)
#pragma alloc_text (PAGE, I2CWriteByte2)
#pragma alloc_text (PAGE, I2CReadByte2)
#pragma alloc_text (PAGE, I2CWaitForClockLineHigh2)
#endif  // ALLOC_PRAGMA

//
// Routines exported via VideoPortQueryServices().
//

BOOLEAN
I2CStart2(
    IN PVOID pHwDeviceExtension,
    IN PVIDEO_I2C_CONTROL pI2CControl
    )

/*++

Routine Description:

    This routine starts I2C communication.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CControl        - I2C hardware specific functions.

Returns:

    TRUE  - Start OK.
    FALSE - Start failed.

--*/

{
    ULONG ulRetry;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CControl);
    ASSERT(NULL != pI2CControl->WriteClockLine);
    ASSERT(NULL != pI2CControl->WriteDataLine);
    ASSERT(NULL != pI2CControl->ReadClockLine);
    ASSERT(NULL != pI2CControl->ReadDataLine);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    //
    // The I2C communications start signal is a SDA high->low while the SCL is high.
    //

    for (ulRetry = 0; ulRetry <= I2C_START_RETRIES; ulRetry++)
    {
        pI2CControl->WriteDataLine(pHwDeviceExtension, 1);           // Set SDA high
        I2C_DELAY(pI2CControl);
        if (pI2CControl->ReadDataLine(pHwDeviceExtension) == FALSE)  // SDA didn't take - ulRetry
            continue;
        pI2CControl->WriteClockLine(pHwDeviceExtension, 1);          // Set SCL high
        I2C_DELAY(pI2CControl);
        if (I2CWaitForClockLineHigh2(pHwDeviceExtension, pI2CControl) == FALSE)
        {
            pVideoDebugPrint((Warn, "VIDEOPRT: I2CStart2: SCL didn't take\n"));
            break;
        }
        pI2CControl->WriteDataLine(pHwDeviceExtension, 0);           // Set SDA low
        I2C_DELAY(pI2CControl);
        pI2CControl->WriteClockLine(pHwDeviceExtension, 0);          // Set SCL low
        I2C_DELAY(pI2CControl);
        return TRUE;
    }

    pVideoDebugPrint((Warn, "VIDEOPRT: I2CStart2: Failed\n"));
    return FALSE;
}   // I2CStart2()

BOOLEAN
I2CStop2(
    IN PVOID pHwDeviceExtension,
    IN PVIDEO_I2C_CONTROL pI2CControl
    )

/*++

Routine Description:

    This routine stops I2C communication.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CControl        - I2C hardware specific functions.

Returns:

    TRUE  - Stop OK.
    FALSE - Stop failed.

--*/

{
    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CControl);
    ASSERT(NULL != pI2CControl->WriteClockLine);
    ASSERT(NULL != pI2CControl->WriteDataLine);
    ASSERT(NULL != pI2CControl->ReadClockLine);
    ASSERT(NULL != pI2CControl->ReadDataLine);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    //
    // The I2C communications stop signal is a SDA low->high while the SCL is high.
    //

    pI2CControl->WriteDataLine(pHwDeviceExtension, 0);               // Set SDA low
    I2C_DELAY(pI2CControl);
    pI2CControl->WriteClockLine(pHwDeviceExtension, 1);              // Set SCL high
    I2C_DELAY(pI2CControl);
    if (I2CWaitForClockLineHigh2(pHwDeviceExtension, pI2CControl) == FALSE)
    {
        pVideoDebugPrint((Warn, "VIDEOPRT: I2CStop2: SCL didn't take\n"));
        return FALSE;
    }
    pI2CControl->WriteDataLine(pHwDeviceExtension, 1);               // Set SDA high
    I2C_DELAY(pI2CControl);
    if (pI2CControl->ReadDataLine(pHwDeviceExtension) != 1)
    {
        pVideoDebugPrint((Warn, "VIDEOPRT: I2CStop2: SDA didn't take\n"));
        return FALSE;
    }

    return TRUE;
}   // I2CStop2()

BOOLEAN
I2CWrite2(
    IN PVOID pHwDeviceExtension,
    IN PVIDEO_I2C_CONTROL pI2CControl,
    IN PUCHAR pucBuffer,
    IN ULONG ulLength
    )

/*++

Routine Description:

    This routine writes data over the I2C channel.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CControl        - I2C hardware specific functions.
    pucBuffer          - Points to data to be written.
    ulLength           - Number of bytes to write.

Returns:

    TRUE  - Write OK.
    FALSE - Write failed.

--*/

{
    ULONG ulCount;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CControl);
    ASSERT(NULL != pucBuffer);
    ASSERT(NULL != pI2CControl->WriteClockLine);
    ASSERT(NULL != pI2CControl->WriteDataLine);
    ASSERT(NULL != pI2CControl->ReadClockLine);
    ASSERT(NULL != pI2CControl->ReadDataLine);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    for (ulCount = 0; ulCount < ulLength; ulCount++)
    {
        if (I2CWriteByte2(pHwDeviceExtension, pI2CControl, pucBuffer[ulCount]) == FALSE)
        {
            return FALSE;
        }
    }

    return TRUE;
}   // I2CWrite2()

BOOLEAN
I2CRead2(
    IN PVOID pHwDeviceExtension,
    IN PVIDEO_I2C_CONTROL pI2CControl,
    OUT PUCHAR pucBuffer,
    IN ULONG ulLength,
    IN BOOLEAN bEndOfRead
    )

/*++

Routine Description:

    This routine reads data over the I2C channel.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CControl        - I2C hardware specific functions.
    pucBuffer          - Points to storage for data.
    ulLength           - Number of bytes to read.
    bEndOfRead         - Indicates end of read requests so we can send NAK.

Returns:

    TRUE  - Read OK.
    FALSE - Read failed.

--*/

{
    ULONG ulCount;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CControl);
    ASSERT(NULL != pucBuffer);
    ASSERT(NULL != pI2CControl->WriteClockLine);
    ASSERT(NULL != pI2CControl->WriteDataLine);
    ASSERT(NULL != pI2CControl->ReadClockLine);
    ASSERT(NULL != pI2CControl->ReadDataLine);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    //
    // On all but the last byte, we must send an ACK in order to ensure that the sending device will
    // send subsequent data bytes. On the last byte, we must send a NAK so that it will shut up.
    //

    for (ulCount = 0; ulCount < ulLength; ulCount++)
    {
        if ((ulLength - 1 == ulCount && bEndOfRead))
        {
            if (I2CReadByte2(pHwDeviceExtension, pI2CControl, pucBuffer + ulCount, TRUE) == FALSE)  // Last byte
            {
                return FALSE;
            }
        }
        else
        {
            if (I2CReadByte2(pHwDeviceExtension, pI2CControl, pucBuffer + ulCount, FALSE) == FALSE)
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}   // I2CRead2()

//
// Local routines.
//

BOOLEAN
I2CWriteByte2(
    IN PVOID pHwDeviceExtension,
    IN PVIDEO_I2C_CONTROL pI2CControl,
    IN UCHAR ucByte
    )

/*++

Routine Description:

    This routine writes byte over the I2C channel.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CControl        - I2C hardware specific functions.
    ucByte             - Byte to write.

Returns:

    TRUE  - Write OK.
    FALSE - Write failed.

--*/

{
    LONG lShift;
    UCHAR ucAck;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CControl);

    //
    // Bits are transmitted serially starting with the MSB.
    //

    for (lShift = 7; lShift >= 0; lShift--)
    {
        //
        // Transmitt data bit.
        //

        pI2CControl->WriteDataLine(pHwDeviceExtension, (UCHAR)((ucByte >> lShift) & 0x01));  // Set SDA
        I2C_DELAY(pI2CControl);

        //
        // After each data bit we must send high->low SCL pulse.
        //

        pI2CControl->WriteClockLine(pHwDeviceExtension, 1);       // Set SCL high
        I2C_DELAY(pI2CControl);
        if (I2CWaitForClockLineHigh2(pHwDeviceExtension, pI2CControl) == FALSE)
        {
            pVideoDebugPrint((Warn, "VIDEOPRT: I2CWriteByte2: SCL didn't take\n"));
            return FALSE;
        }
        pI2CControl->WriteClockLine(pHwDeviceExtension, 0);       // Set SCL low
        I2C_DELAY(pI2CControl);
    }

    //
    // The monitor sends ACK by preventing the SDA from going high after the clock pulse we use
    // to send our last data bit. If the SDA goes high after this bit, it is a NAK from the monitor.
    //

    pI2CControl->WriteDataLine(pHwDeviceExtension, 1);            // Set SDA high
    I2C_DELAY(pI2CControl);
    pI2CControl->WriteClockLine(pHwDeviceExtension, 1);           // Set SCL high
    I2C_DELAY(pI2CControl);
    if (I2CWaitForClockLineHigh2(pHwDeviceExtension, pI2CControl) == FALSE)
    {
        pVideoDebugPrint((Warn, "VIDEOPRT: I2CWriteByte2: SCL didn't take - ACK failed\n"));
        return FALSE;
    }
    ucAck = pI2CControl->ReadDataLine(pHwDeviceExtension);        // Read ACK bit
    pI2CControl->WriteClockLine(pHwDeviceExtension, 0);           // Set SCL low
    I2C_DELAY(pI2CControl);

    if (1 == ucAck)                                               // NAK from the monitor
    {
        pVideoDebugPrint((Warn, "VIDEOPRT: I2CWriteByte2: NAK received\n"));
        return FALSE;
    }

    return TRUE;
}   // I2CWriteByte2()

BOOLEAN
I2CReadByte2(
    IN PVOID pHwDeviceExtension,
    IN PVIDEO_I2C_CONTROL pI2CControl,
    OUT PUCHAR pucByte,
    IN BOOLEAN bEndOfRead
    )

/*++

Routine Description:

    This routine reads byte over the I2C channel.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CControl        - I2C hardware specific functions.
    pucBuffer          - Points to storage for data.
    bEndOfRead         - TRUE if this is last byte to read.

Returns:

    TRUE  - Read OK.
    FALSE - Read failed.

--*/

{
    LONG lShift;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CControl);
    ASSERT(NULL != pucByte);

    *pucByte = 0;

    //
    // The data bits are read from MSB to LSB. A data bit is read while the SCL is high.
    //

    for (lShift = 7; lShift >= 0; lShift--)
    {
        pI2CControl->WriteClockLine(pHwDeviceExtension, 1);       // Set SCL high
        I2C_DELAY(pI2CControl);
        if (I2CWaitForClockLineHigh2(pHwDeviceExtension, pI2CControl) == FALSE)
        {
            pVideoDebugPrint((Warn, "VIDEOPRT: I2CReadByte2: SCL didn't take\n"));
            return FALSE;
        }
        *pucByte |= pI2CControl->ReadDataLine(pHwDeviceExtension) << lShift;  // Read SDA
        pI2CControl->WriteClockLine(pHwDeviceExtension, 0);       // Set SCL low
        I2C_DELAY(pI2CControl);
    }

    //
    // Send the acknowledge bit. SDA low = ACK, SDA high = NAK.
    //

    if (bEndOfRead)
    {
        pI2CControl->WriteDataLine(pHwDeviceExtension, 1);        // Set SDA high - NAK
    }
    else
    {
        pI2CControl->WriteDataLine(pHwDeviceExtension, 0);        // Set SDA low - ACK
    }
    I2C_DELAY(pI2CControl);

    //
    // Send a SCL high->low pulse, then release the SDA by setting it high.
    //

    pI2CControl->WriteClockLine(pHwDeviceExtension, 1);           // Set SCL high
    I2C_DELAY(pI2CControl);
    if (I2CWaitForClockLineHigh2(pHwDeviceExtension, pI2CControl) == FALSE)
    {
        pVideoDebugPrint((Warn, "VIDEOPRT: I2CReadByte2: SCL didn't take - ACK failed\n"));
        return FALSE;
    }
    pI2CControl->WriteClockLine(pHwDeviceExtension, 0);           // Set SCL low
    I2C_DELAY(pI2CControl);
    pI2CControl->WriteDataLine(pHwDeviceExtension, 1);            // Set SDA high
    I2C_DELAY(pI2CControl);

    return TRUE;
}   // I2CReadByte2()

BOOLEAN
I2CWaitForClockLineHigh2(
    IN PVOID pHwDeviceExtension,
    IN PVIDEO_I2C_CONTROL pI2CControl
    )

/*++

Routine Description:

    This routine waits till SCL goes high
    (SCL low period can be stretched by slow devices).

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CControl        - I2C hardware specific functions.

Returns:

    TRUE  - OK - SCL high.
    FALSE - SCL didn't take.

--*/

{
    ULONG ulCount;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CControl);

    for (ulCount = 0; ulCount < I2C_SCL_READ_RETRIES; ulCount++)
    {
        if (pI2CControl->ReadClockLine(pHwDeviceExtension) == TRUE)
            return TRUE;

        I2C_DELAY(pI2CControl);
    }

    return FALSE;
}   // I2CWaitForClockLineHigh2()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\port\enum.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

  enum.c

Abstract:

    This is the NT Video port driver PnP enumeration support routines.

Author:

    Bruce McQuistan (brucemc)   Feb. 1997

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "videoprt.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,pVideoPnPCapabilities)
#pragma alloc_text(PAGE,pVideoPnPResourceRequirements)
#pragma alloc_text(PAGE,pVideoPnPQueryId)
#pragma alloc_text(PAGE,VpAddPdo)
#pragma alloc_text(PAGE,pVideoPortEnumerateChildren)
#pragma alloc_text(PAGE,pVideoPortCleanUpChildList)
#endif

const WCHAR gcwstrDosDeviceName[] = L"\\DosDevices\\LCD";


NTSTATUS
pVideoPnPCapabilities(
    IN  PCHILD_PDO_EXTENSION PdoExtension,
    IN  PDEVICE_CAPABILITIES Capabilities
    )
/*+
 *  Function:   pVideoPnPCapabilities
 *  Context:    Called in the context of an IRP_MN_QUERY_CAPABILITIES minor function
 *              and IRP_MJ_PNP major function.
 *
 *  Arguments:  PDEVICE_EXTENSION       DeviceExtension - a pointer to a
 *              CHILD_DEVICE_EXTENSION.
 *
 *              PDEVICE_CAPABILITIES    Capabilities    - a pointer to the
 *              Parameters.DeviceCapabilities.Capabilities of the IrpStack.
 *
 *
 *  Comments:   This routine fills in some capabilities data needed by the
 *              PnP device manager.
 *
-*/
{
    BOOLEAN success ;
    DEVICE_POWER_STATE unused ;
    UCHAR count ;

    //
    //  Make sure we're dealing with PDOs here.
    //

    ASSERT(IS_PDO(PdoExtension));

    if (!pVideoPortMapStoD(PdoExtension,
                           PowerSystemSleeping1,
                           &unused)) {

        return STATUS_UNSUCCESSFUL ;
    }

    for (count = PowerSystemUnspecified; count < PowerSystemMaximum; count++) {
       Capabilities->DeviceState[count] = PdoExtension->DeviceMapping[count] ;
    }

    //
    // Check to make sure that the monitor will actually get turned off
    // in sleep states.
    //

    if (Capabilities->DeviceState[PowerSystemSleeping1] == PowerDeviceD0) {
        Capabilities->DeviceState[PowerSystemSleeping1] = PowerDeviceD1 ;
        PdoExtension->DeviceMapping[PowerSystemSleeping1] =
            PowerDeviceD1 ;
        pVideoDebugPrint((0, "VideoPrt: QC - Override D0 for sleep on monitor.\n")) ;
    }

    PdoExtension->IsMappingReady = TRUE ;

    //
    // Begin with basic capabilities for the PDO
    //

    Capabilities->LockSupported  = FALSE;
    Capabilities->EjectSupported = FALSE;
    Capabilities->Removable      = FALSE;
    Capabilities->DockDevice     = FALSE;

    //
    //  Set the Raw bit to TRUE only for monitor like objects, since we
    //  act as drivers for them.
    //

    Capabilities->RawDeviceOK = FALSE;

    if (PdoExtension->VideoChildDescriptor->Type == Monitor) {
        Capabilities->RawDeviceOK    = TRUE;
        Capabilities->EjectSupported = TRUE;
        Capabilities->Removable      = TRUE;
        Capabilities->SurpriseRemovalOK = TRUE;
        Capabilities->SilentInstall = TRUE;
    }


    //
    // Out address field contains the ID returned during enumeration.
    // This is key for ACPI devices in order for ACPI to install the
    // filter properly.
    //

    Capabilities->Address = PdoExtension->VideoChildDescriptor->UId;

    //
    // We do not generate unique IDs for our devices because we maight have
    // two video cards with monitors attached, for which the driver would
    // end up returning the same ID.
    //

    Capabilities->UniqueID   = FALSE;


    //
    // The following are totally BOGUS.
    //

    Capabilities->SystemWake = PowerSystemUnspecified;
    Capabilities->DeviceWake = PowerDeviceUnspecified;

    Capabilities->D1Latency  = 10;
    Capabilities->D2Latency  = 10;
    Capabilities->D3Latency  = 10;

    return STATUS_SUCCESS;
}


NTSTATUS
pVideoPnPResourceRequirements(
    IN  PCHILD_PDO_EXTENSION PdoExtension,
    OUT PCM_RESOURCE_LIST *  ResourceList
    )
/*+
 *  Function:   pVideoPnPResourceRequirements
 *  Context:    Called in the context of an IRP_MN_QUERY_RESOURCE_REQUIREMENTS
 *              minor function and IRP_MJ_PNP major function.
 *  Arguments:  PDEVICE_EXTENSION   PdoExtension    - a pointer to a CHILD_DEVICE_EXTENSION.
 *              PCM_RESOURCE_LIST * ResourceList    - a pointer to the IRPs
 *              IoStatus.Information
 *
 *  Comments:   This routine tells the PnP device manager that the child
 *              devices (monitors) don't need system resources. This may not
 *              be the case for all child devices.
 *
-*/
{
    PVIDEO_CHILD_DESCRIPTOR     pChildDescriptor;

    //
    //  Make sure we're dealing with PDOs here.
    //

    ASSERT(IS_PDO(PdoExtension));

    //
    //  Get the child descriptor allocated during Enumerate phase.
    //

    pChildDescriptor = PdoExtension->VideoChildDescriptor;

    //
    //  If the descriptor is null, then there are serious problems.
    //

    ASSERT(pChildDescriptor);

    switch (pChildDescriptor->Type)   {

        default:

        //
        //  Monitors don't need pci resources.
        //

        case Monitor:

            *ResourceList = NULL;
            break;
    }

    return STATUS_SUCCESS;
}


BOOLEAN pGetACPIEdid(PDEVICE_OBJECT DeviceObject, PVOID pEdid)
/*+
 *  Function:   pGetACPIEdid
 *  Return Value:
 *      TRUE:   Success
 *      FALSE:  Failure
-*/
{
    UCHAR    EDIDBuffer[sizeof(ACPI_EVAL_OUTPUT_BUFFER) + EDID_BUFFER_SIZE];
    ULONG    EdidVersion = 2;
    BOOLEAN  bReturn = FALSE;

    RtlZeroMemory(EDIDBuffer, sizeof(EDIDBuffer));

    if (NT_SUCCESS (pVideoPortACPIIoctl(IoGetAttachedDevice(DeviceObject),
                                        (ULONG) ('CDD_'),
                                        &EdidVersion,
                                        NULL,
                                        sizeof(EDIDBuffer),
                                        (PACPI_EVAL_OUTPUT_BUFFER) EDIDBuffer) )
       )
    {
        ASSERT(((PACPI_EVAL_OUTPUT_BUFFER)EDIDBuffer)->Argument[0].Type == ACPI_METHOD_ARGUMENT_BUFFER);
        ASSERT(((PACPI_EVAL_OUTPUT_BUFFER)EDIDBuffer)->Argument[0].DataLength <= EDID_BUFFER_SIZE);
        bReturn = TRUE;
    }
    RtlCopyMemory(pEdid,
                  ((PACPI_EVAL_OUTPUT_BUFFER)EDIDBuffer)->Argument[0].Data,
                  EDID_BUFFER_SIZE);
    return bReturn;
}

#define TOTAL_NAMES_SIZE        512

NTSTATUS
pVideoPnPQueryId(
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      BUS_QUERY_ID_TYPE   BusQueryIdType,
    IN  OUT PWSTR             * BusQueryId
    )
/*+
 *  Function:   pVideoPnPQueryId
 *  Context:    Called in the context of an IRP_MN_QUERY_ID minor function
 *              and IRP_MJ_PNP major function.
 *  Arguments:  DeviceObject    - a PDEVICE_OBJECT created when we enumerated
 *              the child device.
 *              BusQueryIdType  - a BUS_QUERY_ID_TYPE passed in by the PnP
 *              device Manager.
 *              BusQueryId      - a PWSTR * written to in some cases by this
 *              routine.
 *
 *  Comments:
 *
-*/
{
    PUSHORT                 nameBuffer;
    LPWSTR                  deviceName;
    WCHAR                   buffer[64];
    PCHILD_PDO_EXTENSION    pDeviceExtension;
    PVIDEO_CHILD_DESCRIPTOR pChildDescriptor;
    PVOID                   pEdid;
    NTSTATUS                ntStatus = STATUS_SUCCESS;

    //
    //  Allocate enought to hold a MULTI_SZ. This will be passed to the Io
    //  subsystem (via BusQueryId) who has the responsibility of freeing it.
    //

    nameBuffer = ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,
                                       TOTAL_NAMES_SIZE,
                                       VP_TAG);

    if (!nameBuffer)
    {
        pVideoDebugPrint((0, "\t Can't allocate nameBuffer\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(nameBuffer, TOTAL_NAMES_SIZE);

    //
    //  Get the child descriptor allocated during Enumerate phase.
    //

    pDeviceExtension = (PCHILD_PDO_EXTENSION) DeviceObject->DeviceExtension;
    pChildDescriptor = pDeviceExtension->VideoChildDescriptor;

    //
    //  If the descriptor is null, then there are serious problems.
    //

    ASSERT(pChildDescriptor);

    //
    //  Setup pEdid.
    //

    pEdid = &(pChildDescriptor->Buffer);

    //
    //  Switch on the type to set up the strings appropriately. This switch
    //  generates the UNICODE_STRING deviceName, used by HardwareID and
    //  DeviceID bus queries.
    //

    switch(pChildDescriptor->Type) {

        case Monitor:

            /////////////////////////////////////////////////////////
            // Get the EDID if this is an ACPI device.
            /////////////////////////////////////////////////////////

            pChildDescriptor->ValidEDID = pVideoPortIsValidEDID(pEdid) ? GOOD_EDID : BAD_EDID;

            if (pChildDescriptor->bACPIDevice == TRUE)
            {
                if (pChildDescriptor->ACPIDDCFlag & ACPIDDC_TESTED)
                {
                    if (pChildDescriptor->ValidEDID != GOOD_EDID &&
                        (pChildDescriptor->ACPIDDCFlag & ACPIDDC_EXIST) )
                    {
                        pGetACPIEdid(DeviceObject, pEdid);
                        pChildDescriptor->ValidEDID = pVideoPortIsValidEDID(pEdid) ? GOOD_EDID : BAD_EDID;
                    }
                }
                else
                {
                    //
                    // If we found Miniport gets a right EDID, it's equivalent to that _DDC method doesn't exist
                    //
                    pChildDescriptor->ACPIDDCFlag = ACPIDDC_TESTED;
                    if (pChildDescriptor->ValidEDID != GOOD_EDID &&
                        pGetACPIEdid(DeviceObject, pEdid))
                    {
                        pChildDescriptor->ACPIDDCFlag |= ACPIDDC_EXIST;
                        pChildDescriptor->ValidEDID = pVideoPortIsValidEDID(pEdid) ? GOOD_EDID : BAD_EDID;
                    }
                }
            }

            //
            //  If there's an EDID, decode it's OEM id. Otherwise, use
            //  default.
            //

            if (pChildDescriptor->ValidEDID == GOOD_EDID) {

                pVideoDebugPrint((1, "\tNot a bogus edid\n"));

                pVideoPortGetEDIDId(pEdid, buffer);

                deviceName = buffer;

            } else {

                //
                //  Use the passed in default name.
                //

                deviceName = L"Default_Monitor";
            }

            break;

        case Other:

            deviceName = (LPWSTR) pEdid;
            break;

        default:

            pVideoDebugPrint((0, "\t Unsupported Type: %x\n", pChildDescriptor->Type));
            ASSERT(FALSE);
            deviceName = L"Unknown_Video_Device";

            break;
    }

    pVideoDebugPrint((2, "\t The basic deviceName is %ws\n", deviceName));

    //
    //  Craft a name dependent on what was passed in.
    //

    switch (BusQueryIdType) {

        case  BusQueryCompatibleIDs:

            //
            // Compatible ID used for INF matching.
            //

            pVideoDebugPrint((2, "\t BusQueryCompatibleIDs\n"));

            if (pChildDescriptor->Type != Monitor) {

                swprintf(nameBuffer, L"DISPLAY\\%ws", deviceName);
                pVideoDebugPrint((2, "\t BusQueryCompatibleIDs = %ws", nameBuffer));

            } else {

                //
                //  Put the default PNP id for monitors.
                //

                swprintf(nameBuffer, L"*PNP09FF");
                pVideoDebugPrint((2, "\t BusQueryCompatibleIDs = %ws", nameBuffer));
            }

            break;


        case BusQueryHardwareIDs:

            pVideoDebugPrint((2, "\t BusQueryHardwareIDs\n"));

            //
            //  By this time, the keys should have been created, so write
            //  the data to the registry. In this case the data is a string
            //  that looks like '\Monitor\<string>' where string is either
            //  'Default_Monitor' or a name extracted from the edid.
            //

            if (pChildDescriptor->Type == Monitor) {

                //
                // Write the DDC information in the DEVICE part of the
                // registry (the part under ENUM\DISPLAY\*)
                //

                HANDLE   hDeviceKey;
                NTSTATUS Status;

                Status = IoOpenDeviceRegistryKey(DeviceObject,
                                                 PLUGPLAY_REGKEY_DEVICE,
                                                 MAXIMUM_ALLOWED,
                                                 &hDeviceKey);


                if (NT_SUCCESS(Status)) {

                    RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                          hDeviceKey,
                                          (pChildDescriptor->ValidEDID == GOOD_EDID) ?
                                          L"EDID" : L"BAD_EDID",
                                          REG_BINARY,
                                          pEdid,
                                          EDID_BUFFER_SIZE);

                    ZwClose(hDeviceKey);
                }

                swprintf(nameBuffer, L"Monitor\\%ws", deviceName);

            } else {

                swprintf(nameBuffer, L"DISPLAY\\%ws", deviceName);
            }

            pVideoDebugPrint((2, "\t BusQueryHardwareIDs = %ws\n", nameBuffer));

            break;


        case BusQueryDeviceID:

            //
            // Device ID (top part of the ID)
            //

            pVideoDebugPrint((2, "\t BusQueryDeviceID\n"));

            swprintf(nameBuffer, L"DISPLAY\\%ws", deviceName);

            pVideoDebugPrint((2, "\t BusQueryDeviceID = %ws", nameBuffer));

            break;


        case BusQueryInstanceID:

            //
            // Instance ID (low part of the ID)
            //

            pVideoDebugPrint((2, "\t BusQueryInstanceID\n"));

            swprintf(nameBuffer, L"%08x&%02x&%02x", pChildDescriptor->UId,
                pDeviceExtension->pFdoExtension->SystemIoBusNumber,
                pDeviceExtension->pFdoExtension->SlotNumber);

            pVideoDebugPrint((2, "\t BusQueryInstanceID = %ws", nameBuffer));

            break;


        default:

            pVideoDebugPrint((0, "\t Bad QueryIdType:%x\n", BusQueryIdType));

            return STATUS_NOT_SUPPORTED;
            break;

    }

     pVideoDebugPrint((2, "\t returning %ws\n", nameBuffer));

    *BusQueryId = nameBuffer;

    return ntStatus;

}

NTSTATUS
VpAddPdo(
    PDEVICE_OBJECT          DeviceObject,
    PVIDEO_CHILD_DESCRIPTOR VideoChildDescriptor
    )
/*+
 *  Function:   VpAddPdo
 *  Context:    Called after enumerating a device identified by the miniports
 *              HwGetVideoChildDescriptor.
 *
 *  Arguments:  DeviceObject            - a PDEVICE_OBJECT created when we
 *              enumerated the device.
 *              VideoChildDescriptor    - a PVIDEO_CHILD_DESCRIPTOR allocated
 *              when we enumerated the device.
 *  Comments:   This routine actually makes the call that creates the child
 *              device object during enumeration.
 *
 *
-*/

{
    PFDO_EXTENSION       fdoExtension          = DeviceObject->DeviceExtension;
    PCHILD_PDO_EXTENSION pChildDeviceExtension = fdoExtension->ChildPdoList;
    PDEVICE_OBJECT       pChildPdo;
    USHORT               nameBuffer[STRING_LENGTH];
    NTSTATUS             ntStatus;
    NTSTATUS             ntStatus2;
    UNICODE_STRING       deviceName;
    POWER_STATE          state;
    PVOID                pEdid = VideoChildDescriptor->Buffer;
    UNICODE_STRING       symbolicLinkName;

    //
    //  Scan the old list to see if this is a duplicate. If a duplicate, mark it as
    //  VIDEO_ENUMERATED and return STATUS_SUCCESS, because we will want to count it.
    //  If no duplicates, pChildDeviceExtension will be NULL after exiting this loop
    //  and a DEVICE_OBJECT will be created for this device instance. Mark the new
    //  associated CHILD_DEVICE_EXTENSION as VIDEO_ENUMERATED.
    //

    while (pChildDeviceExtension) {

        PVIDEO_CHILD_DESCRIPTOR ChildDescriptor;
        BOOLEAN bEqualEDID = FALSE;

        ChildDescriptor = pChildDeviceExtension->VideoChildDescriptor;

        if (ChildDescriptor->UId == VideoChildDescriptor->UId)
        {
            if (ChildDescriptor->bACPIDevice == TRUE)
            {
                VideoChildDescriptor->ACPIDDCFlag = ChildDescriptor->ACPIDDCFlag;

                //
                // If it's non-monitor device, just ignore
                //
                if (VideoChildDescriptor->Type != Monitor)
                {
                    bEqualEDID = TRUE;
                }
                //
                // Check the device is active, since inactive CRT may return false EDID
                //
                else if (pCheckActiveMonitor(pChildDeviceExtension) == FALSE)
                {
                    bEqualEDID = TRUE;
                }
                else
                {
                    VideoChildDescriptor->ValidEDID = 
                            pVideoPortIsValidEDID(VideoChildDescriptor->Buffer) ? GOOD_EDID : BAD_EDID;

                    //
                    // For ACPI system, try to retrieve EDID again.
                    // At this moment, the handle of DeviceObject is still valid
                    //
                    if (VideoChildDescriptor->ValidEDID != GOOD_EDID &&
                        (ChildDescriptor->ACPIDDCFlag & ACPIDDC_EXIST))
                    {
                        if (!pGetACPIEdid(pChildDeviceExtension->ChildDeviceObject,
                                          VideoChildDescriptor->Buffer))
                        {
                            bEqualEDID = TRUE;
                        }
                    }
                    
                    if (!bEqualEDID)
                    {
                        VideoChildDescriptor->ValidEDID = 
                            pVideoPortIsValidEDID(VideoChildDescriptor->Buffer) ? GOOD_EDID : BAD_EDID;

                        if (VideoChildDescriptor->ValidEDID == ChildDescriptor->ValidEDID)
                        {
                            if (VideoChildDescriptor->ValidEDID != GOOD_EDID ||
                                memcmp(ChildDescriptor->Buffer,
                                       VideoChildDescriptor->Buffer,
                                       EDID_BUFFER_SIZE) == 0)
                            {
                                bEqualEDID = TRUE;
                            }
                        }
                    }
                }
            }
            //
            // For non-ACPI system, EDID has already contained VideoChildDescriptor
            //
            else
            {
                if (VideoChildDescriptor->Type != Monitor ||
                    ChildDescriptor->ValidEDID != GOOD_EDID ||
                    memcmp(ChildDescriptor->Buffer,
                           VideoChildDescriptor->Buffer,
                           EDID_BUFFER_SIZE) == 0)
                {
                    bEqualEDID = TRUE;
                }
            }
        }

        if (bEqualEDID)
        {
            pChildDeviceExtension->bIsEnumerated = TRUE;
            pVideoDebugPrint((1,
                              "VpAddPdo: duplicate device:%x\n",
                              VideoChildDescriptor->UId));

            //
            //  Replace the old child descriptor with the new one.  This will
            //  allow us to detect when and EDID changes, etc.
            //
            if (pChildDeviceExtension->VideoChildDescriptor->ValidEDID != NO_EDID)
            {
                RtlCopyMemory(VideoChildDescriptor,
                              pChildDeviceExtension->VideoChildDescriptor,
                              sizeof(VIDEO_CHILD_DESCRIPTOR) );
            }
            ExFreePool(pChildDeviceExtension->VideoChildDescriptor);
            pChildDeviceExtension->VideoChildDescriptor = VideoChildDescriptor;

            //
            //  Return STATUS_SUCCESS, because we want to count this as a member of the
            //  list (it's valid and in there already).
            //
            return STATUS_SUCCESS;
        }
        pChildDeviceExtension = pChildDeviceExtension->NextChild;
    }

    ntStatus = pVideoPortCreateDeviceName(L"\\Device\\VideoPdo",
                                          VideoChildDevices++,
                                          &deviceName,
                                          nameBuffer);

    if (NT_SUCCESS(ntStatus)) {

        //
        // Create the PDO for the child device.
        // Notice that we allocate the device extension as the size of
        // the FDO extension + the size of the miniports driver extension
        // for this device
        //

        ntStatus = IoCreateDevice(DeviceObject->DriverObject,
                                  sizeof(CHILD_PDO_EXTENSION),
                                  &deviceName,
                                  FILE_DEVICE_UNKNOWN,
                                  0,
                                  FALSE, //TRUE,
                                  &pChildPdo);

        //
        //  If the DeviceObject wasn't created, we won't get called to process
        //  the QueryId IRP where VideoChildDescriptor gets freed, so do it
        //  here.
        //

        if (!NT_SUCCESS(ntStatus)) {

            pVideoDebugPrint((0, "\t IoCreateDevice() failed with status %x\n", ntStatus));
            pVideoDebugPrint((0, "\t IoCreateDevice() doesn't like path %ws\n", deviceName.Buffer));
            ASSERT(0);

            return ntStatus;
        }

        //
        // Create a symbolic link so that user can call us.  This was added
        //  to support new ACPI backlight methods.  We will not fail VpAddPdo
        //  if IoCreateSymbolicLink fails.
        //
        
        RtlInitUnicodeString(&symbolicLinkName,
                             gcwstrDosDeviceName);
        
        ntStatus2 = IoCreateSymbolicLink(&symbolicLinkName,
                             &deviceName);

        //
        // Mark this object as supporting buffered I/O so that the I/O system
        // will only supply simple buffers in IRPs.
        // Set and clear the two power fields to ensure we only get called
        // as passive level to do power management operations.
        //

        pChildPdo->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;
        pChildPdo->Flags &= ~(DO_DEVICE_INITIALIZING | DO_POWER_INRUSH);
        pChildPdo->DeviceType = FILE_DEVICE_SCREEN;

        //
        //  Initialize fields in the ChildDeviceExtension.
        //

        pChildDeviceExtension = pChildPdo->DeviceExtension;

        pChildDeviceExtension->VideoChildDescriptor  = VideoChildDescriptor;
        pChildDeviceExtension->ChildDeviceObject     = pChildPdo;
        pChildDeviceExtension->pFdoExtension         = fdoExtension;
        pChildDeviceExtension->Signature             = VP_TAG;
        pChildDeviceExtension->ExtensionType         = TypePdoExtension;
        pChildDeviceExtension->ChildUId              = VideoChildDescriptor->UId;
        pChildDeviceExtension->bIsEnumerated         = TRUE;
        pChildDeviceExtension->HwDeviceExtension     = fdoExtension->HwDeviceExtension;
        pChildDeviceExtension->PowerOverride         = FALSE;

        KeInitializeMutex(&pChildDeviceExtension->SyncMutex, 0);

        //
        // Initialize the remove lock.
        //

        IoInitializeRemoveLock(&pChildDeviceExtension->RemoveLock, 0, 0, 256);

        //
        // Initialize Power stuff.
        // Set the devices current power state.
        // NOTE - we assume the device is on at this point in time ...
        //

        pChildDeviceExtension->DevicePowerState = PowerDeviceD0;

        state.DeviceState = pChildDeviceExtension->DevicePowerState;

        state = PoSetPowerState(pChildPdo,
                                DevicePowerState,
                                state);


        //
        // Insert into list
        //

        pChildDeviceExtension->NextChild = fdoExtension->ChildPdoList;
        fdoExtension->ChildPdoList       = pChildDeviceExtension;
    }

    return ntStatus;
}

NTSTATUS
pVideoPortEnumerateChildren(
    PDEVICE_OBJECT      DeviceObject,
    PIRP                Irp
    )
/*+
 *  Function:   pVideoPortEnumerateChildren
 *  Context:    Called in the context of an IRP_MN_QUERY_DEVICE_RELATIONS
 *              minor function and IRP_MJ_PNP major function.
 *  Arguments:
 *              PDEVICE_OBJECT      deviceObject       - Passed in by caller of VideoPortDispatch().
 *              PIRP                pIrp               - Passed in by caller of VideoPortDispatch().
 *
 *  Comments:   This routine enumerates devices attached to the video card. If
 *              it's called before the driver is initialized, it returns
 *              STATUS_INSUFFICIENT_RESOURCES. Otherwise, it attempts to read
 *              the edid from the device and refer to that via the
 *              DEVICE_EXTENSION and create a DEVICE_OBJECT (PDO) for each
 *              detected device. This sets up the IO subsystem for issuing
 *              further PnP IRPs such as IRP_MN_QUERY_DEVICE_ID
 *
 *
-*/

{
    UCHAR                   outputBuffer[sizeof(ACPI_EVAL_OUTPUT_BUFFER) + 128];
    PCHILD_PDO_EXTENSION    pChildDeviceExtension;
    PFDO_EXTENSION          fdoExtension    = DeviceObject->DeviceExtension;
    ULONG                   moreChild;
    ULONG                   moreDevices     = 1;
    ULONG                   Unused          = 0;
    ULONG                   count           = 0;
    PACPI_METHOD_ARGUMENT   pAcpiArguments  = NULL;
    VIDEO_CHILD_ENUM_INFO   childEnumInfo;
    ULONG                   relationsSize;
    PDEVICE_RELATIONS       deviceRelations = NULL;
    ULONG                   ulChildCount    = 0;
    ULONG                   debugCount      = 0;
    PDEVICE_OBJECT          *pdo;
    NTSTATUS                ntStatus;

    //
    // Make sure we are called with an FDO
    //

    ASSERT(IS_FDO(fdoExtension));

    if ((fdoExtension->AllowEarlyEnumeration == FALSE) &&
        (fdoExtension->HwInitStatus != HwInitSucceeded))
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Mark all of the child devices as not being enumerated
    //

    for (pChildDeviceExtension = fdoExtension->ChildPdoList;
         pChildDeviceExtension != NULL;
         pChildDeviceExtension = pChildDeviceExtension->NextChild)
    {
        pChildDeviceExtension->bIsEnumerated = FALSE;
    }

    //
    // Let's call ACPI to determine if we have the IDs of the devices that
    // need to be enumerated.
    //

    ntStatus = pVideoPortACPIIoctl(fdoExtension->AttachedDeviceObject,
                                   (ULONG) ('DOD_'),
                                   NULL,
                                   NULL,
                                   sizeof(outputBuffer),
                                   (PACPI_EVAL_OUTPUT_BUFFER) outputBuffer);

    if (NT_SUCCESS(ntStatus))
    {
        count = ((PACPI_EVAL_OUTPUT_BUFFER)outputBuffer)->Count;
        pAcpiArguments = &(((PACPI_EVAL_OUTPUT_BUFFER)outputBuffer)->Argument[0]);
    }


    childEnumInfo.Size                   = sizeof(VIDEO_CHILD_ENUM_INFO);
    childEnumInfo.ChildDescriptorSize    = EDID_BUFFER_SIZE;
    childEnumInfo.ChildIndex             = 0;
    childEnumInfo.ACPIHwId               = 0;
    childEnumInfo.ChildHwDeviceExtension = NULL;

    //
    // Call the miniport to enumerate the children
    // Keep calling for each ACPI device, and then call the driver if it
    // has any more devices.
    //

    while (moreDevices)
    {
        PVIDEO_CHILD_DESCRIPTOR pVideoChildDescriptor;

        //
        // Allocate Space for the Child Descriptor
        //

        pVideoChildDescriptor = ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,
                                                      sizeof(VIDEO_CHILD_DESCRIPTOR),
                                                      VP_TAG);

        if (!pVideoChildDescriptor)
        {
            break;
        }

        RtlZeroMemory(pVideoChildDescriptor, sizeof(VIDEO_CHILD_DESCRIPTOR));

        //
        // On ACPI machine, the HwId contains the ID returned by ACPI
        // Otherwise, the value is initialized to NULL and the miniport driver
        // must fill it out
        //

        if (count)
        {
            ASSERT(pAcpiArguments->Type == 0);
            ASSERT(pAcpiArguments->DataLength == 4);

            // The lower 16bit are HWID
            childEnumInfo.ACPIHwId = pAcpiArguments->Argument & 0x0000FFFF;
            pVideoChildDescriptor->bACPIDevice = TRUE;

            pAcpiArguments++;
            count--;
        }
        else
        {
            //
            // Increment the child index for non-ACPI devices
            //

            childEnumInfo.ChildIndex++;
            childEnumInfo.ACPIHwId = 0;
        }

        //
        // For ACPI CRTs, Miniport should return EDID directly.
        // So for CRT, the buffer is garanteed to be overwriten.
        // We use this attibute to distinguish the CRT from LCD and TV.
        //
        if (pVideoChildDescriptor->bACPIDevice)
        {
            *((PULONG)pVideoChildDescriptor->Buffer) = NONEDID_SIGNATURE;
        }

        moreChild = fdoExtension->HwGetVideoChildDescriptor(
                                       fdoExtension->HwDeviceExtension,
                                       &childEnumInfo,
                                       &(pVideoChildDescriptor->Type),
                                       (PUCHAR)(pVideoChildDescriptor->Buffer),
                                       &(pVideoChildDescriptor->UId),
                                       &Unused);

        if (moreChild == ERROR_MORE_DATA || moreChild == VIDEO_ENUM_MORE_DEVICES)
        {
            //
            //  Perform the required functions on the returned type.
            //
            ntStatus = VpAddPdo(DeviceObject,
                                pVideoChildDescriptor);

            if (NT_SUCCESS(ntStatus))
            {
                ++ulChildCount;
            }
            else
            {
                moreChild = VIDEO_ENUM_INVALID_DEVICE;
            }
        }

        //
        // Stop enumerating the driver returns an error
        // For ACPI devices, if miniports returns ERROR_MORE_DATA, stop enumeration.
        // If it returns VIDEO_ENUM_MORE_DEVICE, continue on to Non-ACPI device.
        // It is the responsibility of Miniport not to enumerate duplicated ACPI and Non-ACPI devices .
        //

        if (moreChild == ERROR_MORE_DATA &&
            (pVideoChildDescriptor->bACPIDevice == TRUE) && (count == 0))
        {
            moreDevices = 0;
        }

        if ((moreChild != ERROR_MORE_DATA) &&
            (moreChild != VIDEO_ENUM_MORE_DEVICES) &&
            (moreChild != VIDEO_ENUM_INVALID_DEVICE)
           )
        {
            moreDevices = 0;
        }

        //
        // Free the memory in case of error.
        //

        if ((moreChild != ERROR_MORE_DATA) && (moreChild != VIDEO_ENUM_MORE_DEVICES))
        {
            ExFreePool(pVideoChildDescriptor);
        }
    }

    //
    //  Now that we know how many devices we have, allocate the blob to be returned and
    //  fill it.
    //

    relationsSize = sizeof(DEVICE_RELATIONS) +
                    (ulChildCount * sizeof(PDEVICE_OBJECT));

    deviceRelations = ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,
                                            relationsSize,
                                            VP_TAG);

    if (deviceRelations == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(deviceRelations, relationsSize);

    //
    // Walk our chain of children, and store them in the relations array.
    //

    pChildDeviceExtension = fdoExtension->ChildPdoList;

    pdo = &(deviceRelations->Objects[0]);

    while (pChildDeviceExtension) {

        if (pChildDeviceExtension->bIsEnumerated) {

            //
            //  Refcount the ChildDeviceObject.
            //

            ObReferenceObject(pChildDeviceExtension->ChildDeviceObject);
            *pdo++ = pChildDeviceExtension->ChildDeviceObject;
            ++debugCount;
        }

        pChildDeviceExtension = pChildDeviceExtension->NextChild;
    }

    if (debugCount != ulChildCount) {
        pVideoDebugPrint((0, "List management ERROR line %d\n", __LINE__));
        ASSERT(FALSE);
    }

    fdoExtension->ChildPdoNumber = ulChildCount;
    deviceRelations->Count = ulChildCount;

    //
    //  Stuff that pDeviceRelations into the IRP and return SUCCESS.
    //

    Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;

    return STATUS_SUCCESS;

}

NTSTATUS
pVideoPortCleanUpChildList(
    PFDO_EXTENSION FdoExtension,
    PDEVICE_OBJECT DeviceObject
    )
/*+
 *  Function:   pVideoPortCleanUpChildList
 *  Context:    Called in the context of an IRP_MN_REMOVE_DEVICE
 *              minor function and IRP_MJ_PNP major function.
 *  Arguments:
 *              PFDO_EXTENSION FdoExtension - Device extension of the parent
 *              PDEVICE_OBJECT deviceObject - Device object to be deleted
 *
 *  Comments:   This routine deletes a monitor device object when it is no
 *              longer needed
 *              It actually determines if the device is still present by
 *              checking the enumerate flag in the device extension
 *              We only do lazy deletion, that is delete the device objects
 *              after reenumeration has shown the device not to be there
 *
-*/
{
    PCHILD_PDO_EXTENSION PrevChild = NULL;
    PCHILD_PDO_EXTENSION pChildDeviceExtension = FdoExtension->ChildPdoList;

    ASSERT(pChildDeviceExtension != NULL);

    //
    // Search the ChildPdoList for the device we are
    // removing.
    //

    while (pChildDeviceExtension)
    {
        if (pChildDeviceExtension->ChildDeviceObject == DeviceObject) {
            break;
        }

        PrevChild = pChildDeviceExtension;
        pChildDeviceExtension = pChildDeviceExtension->NextChild;
    }

    if (pChildDeviceExtension) {

        //
        // If the device is still enumerated, do not delete it as it is
        // too expensive for us to go check for device presence again.
        //

        if (pChildDeviceExtension->bIsEnumerated) {
            return STATUS_SUCCESS;
        }

        //
        // Remove the device from the list.
        //

        if (PrevChild == NULL) {

            FdoExtension->ChildPdoList = pChildDeviceExtension->NextChild;

        } else {

            PrevChild->NextChild = pChildDeviceExtension->NextChild;
        }

        //
        // Free the memory associated with this child device and then delete it.
        //

        ExFreePool(pChildDeviceExtension->VideoChildDescriptor);
        IoDeleteDevice(DeviceObject);
    }

    return STATUS_SUCCESS;
}


/*+
 *  Function:   pVideoPortConvertAsciiToWchar
 *              convert that Ascii into a LPWSTR which
 *              is then placed in Buffer.
 *
 *
 *  Arguments:  UCHAR   Ascii       - Pointer to an ascii string.
 *
 *              WCHAR   Buffer[64]  - Buffer used to convert from ascii to
 *                                    WCHAR.
 *
 *  Comments:   If DeviceName is returned to some caller outside the videoprt,
 *              then Buffer had better have the right lifetime.
 *
-*/

VOID
pVideoPortConvertAsciiToWChar(
    IN  PUCHAR  Ascii,
    OUT WCHAR   Buffer[64]
    )
{
    ANSI_STRING    ansiString;
    UNICODE_STRING us;

    //
    //  Create a unicode string holding the ascii Name.
    //

    RtlInitAnsiString(&ansiString, Ascii);

    //
    // Attach a buffer to the UNICODE_STRING
    //

    us.Buffer = Buffer;
    us.Length = 0;
    us.MaximumLength = 64;

    RtlZeroMemory(Buffer, sizeof(Buffer));

    RtlAnsiStringToUnicodeString(&us,
                                 &ansiString,
                                 FALSE);

}


NTSTATUS
pVideoPortQueryDeviceText(
    IN  PDEVICE_OBJECT      ChildDeviceObject,
    IN  DEVICE_TEXT_TYPE    TextType,
    OUT PWSTR *             ReturnValue
    )
/*+
 *  Function:
 *  Context:    Called in the context of an IRP_MN_QUERY_DEVICE_TEXT
 *              minor function and IRP_MJ_PNP major function.
 *  Arguments:
 *              PDEVICE_OBJECT      ChildDeviceObject  - Passed in by caller
 *                                  of pVideoPortPnpDispatch().
 *
 *              DEVICE_TEXT_TYPE    TextType           - Passed in by caller
 *                                  of pVideoPortPnpDispatch().
 *
 *              PWSTR *             ReturnValue        - Created by caller of
 *                                  this routine.
-*/
{
    PCHILD_PDO_EXTENSION    pdoExtension;
    PVIDEO_CHILD_DESCRIPTOR pChildDescriptor;

    PAGED_CODE();

    //
    //  Get the child descriptor allocated during Enumerate phase.
    //

    pdoExtension     = (PCHILD_PDO_EXTENSION) ChildDeviceObject->DeviceExtension;
    ASSERT(IS_PDO(pdoExtension));
    pChildDescriptor = pdoExtension->VideoChildDescriptor;

    *ReturnValue = NULL;

    switch (TextType) {

    case DeviceTextDescription:

        if (pChildDescriptor->Type == Monitor)
        {
            ULONG       asciiStringLength = 0;
            UCHAR       pTmp[64];
            PWSTR       tmpBuffer = (PWSTR)ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,
                                                                 128,
                                                                 VP_TAG);

            if (!tmpBuffer) {

                return STATUS_INSUFFICIENT_RESOURCES;
            }

            memset(pTmp, '0', 64);

            if (pChildDescriptor->ValidEDID == GOOD_EDID) {

                asciiStringLength = pVideoPortGetEdidOemID(&(pChildDescriptor->Buffer), pTmp);


                ASSERT(asciiStringLength <= 64);

                pVideoPortConvertAsciiToWChar(pTmp, tmpBuffer);

                if (asciiStringLength) {

                  pVideoDebugPrint((2, "Ascii name:%s\n", pTmp));
                  pVideoDebugPrint((2, "WChar name:%ws\n", tmpBuffer));
                }

                *ReturnValue = tmpBuffer;

            } else {

                wcscpy(tmpBuffer, L"Monitor");
                *ReturnValue = tmpBuffer;
            }

            return STATUS_SUCCESS;
        }

        return STATUS_NOT_SUPPORTED;

    default:

        return STATUS_NOT_SUPPORTED;
    }
}


BOOLEAN pCheckDeviceRelations(PFDO_EXTENSION FdoExtension, BOOLEAN bNewMonitor)
/*+
 *  Function:   pCheckDeviceRelations
 *  Arguments:
 *              bNewMonitor     New monitor has been plugged in
 *  Return Value:
 *      TRUE:   Monitors had been changed, need to reenumarate
 *      FALSE:  No child device change
-*/
{
    BOOLEAN bInvalidateRelation = FALSE;
    PCHILD_PDO_EXTENSION pChildDeviceExtension;
    UCHAR pEdid[EDID_BUFFER_SIZE + sizeof(ACPI_EVAL_OUTPUT_BUFFER)];

    for (pChildDeviceExtension = FdoExtension->ChildPdoList;
         pChildDeviceExtension != NULL;
         pChildDeviceExtension = pChildDeviceExtension->NextChild
        )
    {
        PVIDEO_CHILD_DESCRIPTOR VideoChildDescriptor = pChildDeviceExtension->VideoChildDescriptor;
        BOOLEAN     ValidEDID, bEqualEDID = TRUE;

        if (VideoChildDescriptor->bACPIDevice == TRUE)
        {
            //
            // If it's non-monitor device, just ignore
            //
            if (VideoChildDescriptor->Type != Monitor)
            {
                continue;
            }

            //
            // For each output device, we are going to retrieve EDID when it's active.
            //
            if (bNewMonitor)
            {
                VideoChildDescriptor->bInvalidate = TRUE;
            }
            else if (VideoChildDescriptor->bInvalidate == FALSE)
            {
                continue;
            }

            //
            // Check the device is active, since inactive CRT may return false EDID
            // If inactive, delay the EDID retieving until next hotkey switching
            //
            if (pCheckActiveMonitor(pChildDeviceExtension) == FALSE)
            {
                continue;
            }

            VideoChildDescriptor->bInvalidate = FALSE;

            //
            // Get DDC from Miniport first
            //
            {
            VIDEO_CHILD_ENUM_INFO childEnumInfo;
            VIDEO_CHILD_TYPE      childType;
            ULONG                 UId, Unused, moreChild;
            
            childEnumInfo.Size                   = sizeof(VIDEO_CHILD_ENUM_INFO);
            childEnumInfo.ChildDescriptorSize    = EDID_BUFFER_SIZE;
            childEnumInfo.ChildIndex             = 0;
            childEnumInfo.ACPIHwId               = VideoChildDescriptor->UId;
            childEnumInfo.ChildHwDeviceExtension = NULL;

            moreChild = FdoExtension->HwGetVideoChildDescriptor(
                                       FdoExtension->HwDeviceExtension,
                                       &childEnumInfo,
                                       &childType,
                                       (PUCHAR)pEdid,
                                       &UId,
                                       &Unused);
            ASSERT (moreChild == ERROR_MORE_DATA || moreChild == VIDEO_ENUM_MORE_DEVICES);

            ValidEDID = pVideoPortIsValidEDID(pEdid) ? GOOD_EDID : BAD_EDID;
            }

            //
            // For ACPI system, retrieve EDID again.
            // At this moment, the handle of DeviceObject is still valid
            //
            if (ValidEDID != GOOD_EDID &&
                VideoChildDescriptor->ACPIDDCFlag & ACPIDDC_EXIST)
            {
                if (!pGetACPIEdid(pChildDeviceExtension->ChildDeviceObject, pEdid))
                {
                    continue;
                }
                ValidEDID = pVideoPortIsValidEDID(pEdid) ? GOOD_EDID : BAD_EDID;
            }

            if (VideoChildDescriptor->ValidEDID != ValidEDID)
            {
                bEqualEDID = FALSE;
            }
            else if (ValidEDID == GOOD_EDID)
            {
                if (memcmp(VideoChildDescriptor->Buffer, pEdid, EDID_BUFFER_SIZE) != 0)
                {
                    bEqualEDID = FALSE;
                }
            }

            if (!bEqualEDID)
            {
                bInvalidateRelation = TRUE;
                //
                // Forcing UId to become a bad value will invalidate the device
                //
                VideoChildDescriptor->UId = 0xFFFF8086;
            }
        }
    }

    return bInvalidateRelation;
}

BOOLEAN pCheckActiveMonitor(PCHILD_PDO_EXTENSION pChildDeviceExtension)
{
    ULONG UId, flag;

    UId = pChildDeviceExtension->ChildUId;
    if (NT_SUCCESS
        (pVideoMiniDeviceIoControl(pChildDeviceExtension->ChildDeviceObject,
                                   IOCTL_VIDEO_GET_CHILD_STATE,
                                   &UId,
                                   sizeof(ULONG),
                                   &flag,
                                   sizeof(ULONG) ) )
       )
    {
        return ((flag & VIDEO_CHILD_ACTIVE) ?
                TRUE :
                FALSE);
    }

    if (pChildDeviceExtension->VideoChildDescriptor->bACPIDevice == TRUE)
    {
        UCHAR outputBuffer[0x10 + sizeof(ACPI_EVAL_OUTPUT_BUFFER)];

        if (NT_SUCCESS
            (pVideoPortACPIIoctl(IoGetAttachedDevice(pChildDeviceExtension->ChildDeviceObject),
                                 (ULONG) ('SCD_'),
                                 NULL,
                                 NULL,
                                 sizeof(outputBuffer),
                                 (PACPI_EVAL_OUTPUT_BUFFER)outputBuffer)
            )
           )
        {
            if ( ((PACPI_EVAL_OUTPUT_BUFFER)outputBuffer)->Argument[0].Argument & 0x02)
            {
                return TRUE;
            }
            else
            {
                return FALSE;
            }
        }
        else
        {
            return TRUE;
        }
    }
    else
    {
        //
        // For Non-ACPI machines, if miniport doesn't handle IOCTL_VIDEO_GET_CHILD_STATE, we just assume all Monitors are active
        //
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\port\i2c.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    i2c.c

Abstract:

    This is the NT Video port I2C helper code.

Author:

    Michael Maciesowicz (mmacie) 03-Sept-1999

Environment:

    kernel mode only

Notes:

--*/

#include "videoprt.h"

//
// Define constants used by I2C.
//

#define I2C_START_RETRIES       10
#define I2C_SCL_READ_RETRIES    10
#define I2C_DELAY()             DELAY_MICROSECONDS(5)

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, I2CStart)
#pragma alloc_text (PAGE, I2CStop)
#pragma alloc_text (PAGE, I2CWrite)
#pragma alloc_text (PAGE, I2CRead)
#pragma alloc_text (PAGE, I2CWriteByte)
#pragma alloc_text (PAGE, I2CReadByte)
#pragma alloc_text (PAGE, I2CWaitForClockLineHigh)
#endif  // ALLOC_PRAGMA

//
// Routines exported via VideoPortQueryServices().
//

BOOLEAN
I2CStart(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks
    )

/*++

Routine Description:

    This routine starts I2C communication.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.

Returns:

    TRUE  - Start OK.
    FALSE - Start failed.

--*/

{
    ULONG ulRetry;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);
    ASSERT(NULL != pI2CCallbacks->WriteClockLine);
    ASSERT(NULL != pI2CCallbacks->WriteDataLine);
    ASSERT(NULL != pI2CCallbacks->ReadClockLine);
    ASSERT(NULL != pI2CCallbacks->ReadDataLine);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    //
    // The I2C communications start signal is a SDA high->low while the SCL is high.
    //

    for (ulRetry = 0; ulRetry <= I2C_START_RETRIES; ulRetry++)
    {
        pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 1);           // Set SDA high
        I2C_DELAY();
        if (pI2CCallbacks->ReadDataLine(pHwDeviceExtension) == FALSE)  // SDA didn't take - ulRetry
            continue;
        pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);          // Set SCL high
        I2C_DELAY();
        if (I2CWaitForClockLineHigh(pHwDeviceExtension, pI2CCallbacks) == FALSE)
        {
            pVideoDebugPrint((Warn, "VIDEOPRT: I2CStart: SCL didn't take\n"));
            break;
        }
        pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 0);           // Set SDA low
        I2C_DELAY();
        pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 0);          // Set SCL low
        I2C_DELAY();
        return TRUE;
    }

    pVideoDebugPrint((Warn, "VIDEOPRT: I2CStart: Failed\n"));
    return FALSE;
}   // I2CStart()

BOOLEAN
I2CStop(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks
    )

/*++

Routine Description:

    This routine stops I2C communication.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.

Returns:

    TRUE  - Stop OK.
    FALSE - Stop failed.

--*/

{
    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);
    ASSERT(NULL != pI2CCallbacks->WriteClockLine);
    ASSERT(NULL != pI2CCallbacks->WriteDataLine);
    ASSERT(NULL != pI2CCallbacks->ReadClockLine);
    ASSERT(NULL != pI2CCallbacks->ReadDataLine);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    //
    // The I2C communications stop signal is a SDA low->high while the SCL is high.
    //

    pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 0);               // Set SDA low
    I2C_DELAY();
    pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);              // Set SCL high
    I2C_DELAY();
    if (I2CWaitForClockLineHigh(pHwDeviceExtension, pI2CCallbacks) == FALSE)
    {
        pVideoDebugPrint((Warn, "VIDEOPRT: I2CStop: SCL didn't take\n"));
        return FALSE;
    }
    pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 1);               // Set SDA high
    I2C_DELAY();
    if (pI2CCallbacks->ReadDataLine(pHwDeviceExtension) != 1)
    {
        pVideoDebugPrint((Warn, "VIDEOPRT: I2CStop: SDA didn't take\n"));
        return FALSE;
    }

    return TRUE;
}   // I2CStop()

BOOLEAN
I2CWrite(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    IN PUCHAR pucBuffer,
    IN ULONG ulLength
    )

/*++

Routine Description:

    This routine writes data over the I2C channel.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.
    pucBuffer          - Points to data to be written.
    ulLength           - Number of bytes to write.

Returns:

    TRUE  - Write OK.
    FALSE - Write failed.

--*/

{
    ULONG ulCount;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);
    ASSERT(NULL != pucBuffer);
    ASSERT(NULL != pI2CCallbacks->WriteClockLine);
    ASSERT(NULL != pI2CCallbacks->WriteDataLine);
    ASSERT(NULL != pI2CCallbacks->ReadClockLine);
    ASSERT(NULL != pI2CCallbacks->ReadDataLine);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    for (ulCount = 0; ulCount < ulLength; ulCount++)
    {
        if (I2CWriteByte(pHwDeviceExtension, pI2CCallbacks, pucBuffer[ulCount]) == FALSE)
        {
            return FALSE;
        }
    }

    return TRUE;
}   // I2CWrite()

BOOLEAN
I2CRead(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    OUT PUCHAR pucBuffer,
    IN ULONG ulLength
    )

/*++

Routine Description:

    This routine reads data over the I2C channel.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.
    pucBuffer          - Points to storage for data.
    ulLength           - Number of bytes to read.

Returns:

    TRUE  - Read OK.
    FALSE - Read failed.

--*/

{
    ULONG ulCount;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);
    ASSERT(NULL != pucBuffer);
    ASSERT(NULL != pI2CCallbacks->WriteClockLine);
    ASSERT(NULL != pI2CCallbacks->WriteDataLine);
    ASSERT(NULL != pI2CCallbacks->ReadClockLine);
    ASSERT(NULL != pI2CCallbacks->ReadDataLine);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    //
    // On all but the last byte, we must send an ACK in order to ensure that the sending device will
    // send subsequent data bytes. On the last byte, we must send a NAK so that it will shut up.
    //

    for (ulCount = 0; ulCount < ulLength; ulCount++)
    {
        if (ulLength - 1 == ulCount)
        {
            if (I2CReadByte(pHwDeviceExtension, pI2CCallbacks, pucBuffer + ulCount, FALSE) == FALSE)  // Last byte
            {
                return FALSE;
            }
        }
        else
        {
            if (I2CReadByte(pHwDeviceExtension, pI2CCallbacks, pucBuffer + ulCount, TRUE) == FALSE)
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}   // I2CRead()

//
// Local routines.
//

BOOLEAN
I2CWriteByte(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    IN UCHAR ucByte
    )

/*++

Routine Description:

    This routine writes byte over the I2C channel.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.
    ucByte             - Byte to write.

Returns:

    TRUE  - Write OK.
    FALSE - Write failed.

--*/

{
    LONG lShift;
    UCHAR ucAck;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);

    //
    // Bits are transmitted serially starting with the MSB.
    //

    for (lShift = 7; lShift >= 0; lShift--)
    {
        //
        // Transmitt data bit.
        //

        pI2CCallbacks->WriteDataLine(pHwDeviceExtension, (UCHAR)((ucByte >> lShift) & 0x01));  // Set SDA
        I2C_DELAY();

        //
        // After each data bit we must send high->low SCL pulse.
        //

        pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);       // Set SCL high
        I2C_DELAY();
        if (I2CWaitForClockLineHigh(pHwDeviceExtension, pI2CCallbacks) == FALSE)
        {
            pVideoDebugPrint((Warn, "VIDEOPRT: I2CWriteByte: SCL didn't take\n"));
            return FALSE;
        }
        pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 0);       // Set SCL low
        I2C_DELAY();
    }

    //
    // The monitor sends ACK by preventing the SDA from going high after the clock pulse we use
    // to send our last data bit. If the SDA goes high after this bit, it is a NAK from the monitor.
    //

    pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 1);            // Set SDA high
    I2C_DELAY();
    pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);           // Set SCL high
    I2C_DELAY();
    if (I2CWaitForClockLineHigh(pHwDeviceExtension, pI2CCallbacks) == FALSE)
    {
        pVideoDebugPrint((Warn, "VIDEOPRT: I2CWriteByte: SCL didn't take - ACK failed\n"));
        return FALSE;
    }
    ucAck = pI2CCallbacks->ReadDataLine(pHwDeviceExtension);        // Read ACK bit
    pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 0);           // Set SCL low
    I2C_DELAY();

    if (1 == ucAck)                                                 // NAK from the monitor
    {
        pVideoDebugPrint((Warn, "VIDEOPRT: I2CWriteByte: NAK received\n"));
        return FALSE;
    }

    return TRUE;
}   // I2CWriteByte()

BOOLEAN
I2CReadByte(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    OUT PUCHAR pucByte,
    IN BOOLEAN bMore
    )

/*++

Routine Description:

    This routine reads byte over the I2C channel.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.
    pucBuffer          - Points to storage for data.
    bMore              - TRUE if we want to continue reading, FALSE otherwise.

Returns:

    TRUE  - Read OK.
    FALSE - Read failed.

--*/

{
    LONG lShift;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);
    ASSERT(NULL != pucByte);

    *pucByte = 0;

    //
    // The data bits are read from MSB to LSB. A data bit is read while the SCL is high.
    //

    for (lShift = 7; lShift >= 0; lShift--)
    {
        pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);       // Set SCL high
        I2C_DELAY();
        if (I2CWaitForClockLineHigh(pHwDeviceExtension, pI2CCallbacks) == FALSE)
        {
            pVideoDebugPrint((Warn, "VIDEOPRT: I2CReadByte: SCL didn't take\n"));
            return FALSE;
        }
        *pucByte |= pI2CCallbacks->ReadDataLine(pHwDeviceExtension) << lShift;  // Read SDA
        pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 0);       // Set SCL low
        I2C_DELAY();
    }

    //
    // Send the acknowledge bit. SDA low = ACK, SDA high = NAK.
    //

    if (TRUE == bMore)
    {
        pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 0);        // Set SDA low - ACK
    }
    else
    {
        pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 1);        // Set SDA high - NAK
    }
    I2C_DELAY();

    //
    // Send a SCL high->low pulse, then release the SDA by setting it high.
    //

    pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);           // Set SCL high
    I2C_DELAY();
    if (I2CWaitForClockLineHigh(pHwDeviceExtension, pI2CCallbacks) == FALSE)
    {
        pVideoDebugPrint((Warn, "VIDEOPRT: I2CReadByte: SCL didn't take - ACK failed\n"));
        return FALSE;
    }
    pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 0);           // Set SCL low
    I2C_DELAY();
    pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 1);            // Set SDA high
    I2C_DELAY();

    return TRUE;
}   // I2CReadByte()

BOOLEAN
I2CWaitForClockLineHigh(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks
    )

/*++

Routine Description:

    This routine waits till SCL goes high
    (SCL low period can be stretched by slow devices).

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.

Returns:

    TRUE  - OK - SCL high.
    FALSE - SCL didn't take.

--*/

{
    ULONG ulCount;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);

    for (ulCount = 0; ulCount < I2C_SCL_READ_RETRIES; ulCount++)
    {
        if (pI2CCallbacks->ReadClockLine(pHwDeviceExtension) == TRUE)
            return TRUE;

        I2C_DELAY();
    }

    return FALSE;
}   // I2CWaitForClockLineHigh()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\port\pnp.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This is the pnp portion of the video port driver.

Environment:

    kernel mode only

Revision History:

--*/

#include "videoprt.h"

#pragma alloc_text(PAGE,pVideoPortSendIrpToLowerDevice)
#pragma alloc_text(PAGE,pVideoPortPowerCallDownIrpStack)
#pragma alloc_text(PAGE,pVideoPortHibernateNotify)
#pragma alloc_text(PAGE,pVideoPortPnpDispatch)
#pragma alloc_text(PAGE,pVideoPortPowerDispatch)
#pragma alloc_text(PAGE,InitializePowerStruct)


NTSTATUS
VpSetEventCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )

{
    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
pVideoPortSendIrpToLowerDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine will forward the start request to the next lower device and
    block until it's completion.

Arguments:

    DeviceObject - the device to which the start request was issued.

    Irp - the start request

Return Value:

    status

--*/

{
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;

    PKEVENT event;
    NTSTATUS status;

    event = ExAllocatePoolWithTag(NonPagedPool,
                                  sizeof(KEVENT),
                                  VP_TAG);

    if (event == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(event, SynchronizationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp,
                           VpSetEventCompletion,
                           event,
                           TRUE,
                           TRUE,
                           TRUE);

    status = IoCallDriver(fdoExtension->AttachedDeviceObject, Irp);

    if(status == STATUS_PENDING) {

        KeWaitForSingleObject(event, Executive, KernelMode, FALSE, NULL);

        status = Irp->IoStatus.Status;
    }

    ExFreePool(event);

    return status;

}



NTSTATUS
pVideoPortCompleteWithMoreProcessingRequired(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )

/*++

Routine Description:

    This routine is used as a completion routine when an IRP is passed
    down the stack but more processing must be done on the way back up.
    The effect of using this as a completion routine is that the IRP
    will not be destroyed in IoCompleteRequest as called by the lower
    level object.

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the IRP_MN_START_DEVICE irp.

    Event - Caller will wait on this event if STATUS_PENDING was
            returned.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    //
    // In case someone somewhere returned STATUS_PENDING, set
    // the Event our caller may be waiting on.
    //

    KeSetEvent(Event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
pVideoPortPowerCallDownIrpStack(
    PDEVICE_OBJECT AttachedDeviceObject,
    PIRP Irp
    )

/*++

Description:

    Pass the IRP to the next device object in the device stack.  This
    routine is used when more processing is required at this level on
    this IRP on the way back up.

    Note: Waits for completion.

Arguments:

    DeviceObject - the Fdo
    Irp - the request

Return Value:

    Returns the result from calling the next level.

--*/

{
    KEVENT      event;
    NTSTATUS    status;

    //
    // Initialize the event to wait on.
    //

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // Copy the stack location and set the completion routine.
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           pVideoPortCompleteWithMoreProcessingRequired,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );

    //
    // Call the next driver in the chain.
    //

    status = PoCallDriver(AttachedDeviceObject, Irp);
    if (status == STATUS_PENDING) {

        //
        // Wait for it.
        //
        // (peterj: in theory this shouldn't actually happen).
        //
        // Also, the completion routine does not allow the IRP to
        // actually complete so we can still get status from the IRP.
        //

        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        status = Irp->IoStatus.Status;
    }
    return status;
}

VOID
pVideoPortHibernateNotify(
    IN PDEVICE_OBJECT Pdo,
    BOOLEAN IsVideoObject
    )
/*++

Routine Description:

    Sends a DEVICE_USAGE_NOTIFICATION irp to our parent PDO that
    indicates we are on the hibernate path.

Arguments:

    Pdo - Supplies our PDO

Return Value:

    None.

--*/

{
    KEVENT Event;
    PIRP Irp;
    IO_STATUS_BLOCK IoStatusBlock;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    PDEVICE_OBJECT targetDevice = Pdo ;

    //
    // If the PDO is ourselves, the target device is actually the top of
    // the device stack.
    //

    if (IsVideoObject) {
      targetDevice = IoGetAttachedDeviceReference (Pdo) ;
    }

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);
    Irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                       targetDevice,
                                       NULL,
                                       0,
                                       NULL,
                                       &Event,
                                       &IoStatusBlock);
    if (Irp != NULL) {
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED ;
        irpSp = IoGetNextIrpStackLocation(Irp);
        irpSp->MajorFunction = IRP_MJ_PNP;
        irpSp->MinorFunction = IRP_MN_DEVICE_USAGE_NOTIFICATION;
        irpSp->Parameters.UsageNotification.InPath = TRUE;
        irpSp->Parameters.UsageNotification.Type = DeviceUsageTypeHibernation;

        status = IoCallDriver(targetDevice, Irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
        }
    }

    //
    // Make sure to deref if the object was referenced when the top of
    // the stack was obtained.
    //

    if (IsVideoObject) {
        ObDereferenceObject (targetDevice) ;
    }
}

ULONG
VpGetDeviceAddress(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine will get the address of a device (ie. slot number).

Arguments:

    DeviceObject - Object for which to retrieve the address

Returns:

    The address of the given device.

--*/

{
    KEVENT              Event;
    PIRP                QueryIrp = NULL;
    IO_STATUS_BLOCK     IoStatusBlock;
    PIO_STACK_LOCATION  NextStack;
    NTSTATUS            Status;
    DEVICE_CAPABILITIES Capabilities;
    PFDO_EXTENSION      FdoExtension = DeviceObject->DeviceExtension;

    RtlZeroMemory(&Capabilities, sizeof(DEVICE_CAPABILITIES));
    Capabilities.Size = sizeof(DEVICE_CAPABILITIES);
    Capabilities.Version = 1;
    Capabilities.Address = Capabilities.UINumber = (ULONG) -1;

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    QueryIrp = IoBuildSynchronousFsdRequest(IRP_MJ_FLUSH_BUFFERS,
                                            FdoExtension->AttachedDeviceObject,
                                            NULL,
                                            0,
                                            NULL,
                                            &Event,
                                            &IoStatusBlock);

    if (QueryIrp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    QueryIrp->IoStatus.Status = IoStatusBlock.Status = STATUS_NOT_SUPPORTED;

    NextStack = IoGetNextIrpStackLocation(QueryIrp);

    //
    // Set up for a QueryInterface Irp.
    //

    NextStack->MajorFunction = IRP_MJ_PNP;
    NextStack->MinorFunction = IRP_MN_QUERY_CAPABILITIES;

    NextStack->Parameters.DeviceCapabilities.Capabilities = &Capabilities;

    Status = IoCallDriver(FdoExtension->AttachedDeviceObject, QueryIrp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
        Status = IoStatusBlock.Status;
    }


    ASSERT(NT_SUCCESS(Status));

    return (Capabilities.Address >> 16) | ((Capabilities.Address & 0x7) << 5);
}


NTSTATUS
pVideoPortPnpDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the PnP dispatch routine for the video port driver.
    It accepts an I/O Request Packet, transforms it to a video Request
    Packet, and forwards it to the appropriate miniport dispatch routine.
    Upon returning, it completes the request and return the appropriate
    status value.

Arguments:

    DeviceObject - Pointer to the device object of the miniport driver to
        which the request must be sent.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value os the status of the operation.

--*/

{
    PDEVICE_SPECIFIC_EXTENSION DoSpecificExtension;
    PFDO_EXTENSION combinedExtension;
    PFDO_EXTENSION fdoExtension;
    PCHILD_PDO_EXTENSION pdoExtension = NULL;
    PIO_STACK_LOCATION irpStack;
    PVOID ioBuffer;
    ULONG inputBufferLength;
    ULONG outputBufferLength;
    PSTATUS_BLOCK statusBlock;
    NTSTATUS finalStatus;
    ULONG ioControlCode;
    BOOLEAN RemoveLockReleased = FALSE;
    PIO_REMOVE_LOCK pRemoveLock;
    PCHILD_PDO_EXTENSION childDeviceExtension;
    NTSTATUS RemoveLockStatus;
    PBACKLIGHT_STATUS pVpBacklightStatus = &VpBacklightStatus;
    PDEVICE_OBJECT AttachedDevice = NULL;
    ULONG ulACPIMethodParam1;
    BOOLEAN bSetBacklight = FALSE;
    

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the status buffer.
    // Assume SUCCESS for now.
    //

    statusBlock = (PSTATUS_BLOCK) &Irp->IoStatus;

    //
    // Get pointer to the port driver's device extension.
    //

    combinedExtension = DeviceObject->DeviceExtension;

    if (IS_PDO(DeviceObject->DeviceExtension)) {

        pdoExtension = DeviceObject->DeviceExtension;
        fdoExtension = pdoExtension->pFdoExtension;

        childDeviceExtension = (PCHILD_PDO_EXTENSION)
                               DeviceObject->DeviceExtension;

        pRemoveLock = &childDeviceExtension->RemoveLock;

    } else if (IS_FDO(DeviceObject->DeviceExtension)) {

        fdoExtension = DeviceObject->DeviceExtension;
        DoSpecificExtension = (PDEVICE_SPECIFIC_EXTENSION)(fdoExtension + 1);

        pRemoveLock = &fdoExtension->RemoveLock;

    } else {

        DoSpecificExtension = DeviceObject->DeviceExtension;
        fdoExtension = DoSpecificExtension->pFdoExtension;
        combinedExtension = fdoExtension;

        pVideoDebugPrint((2, "Pnp/Power irp's not supported by secondary DO\n"));

        statusBlock->Status = STATUS_NOT_SUPPORTED;
        goto Complete_Irp;
    }

    //
    // Get the requestor mode.
    //

    combinedExtension->CurrentIrpRequestorMode = Irp->RequestorMode;

#if REMOVE_LOCK_ENABLED
    RemoveLockStatus = IoAcquireRemoveLock(pRemoveLock, Irp);

    if (NT_SUCCESS(RemoveLockStatus) == FALSE) {

        ASSERT(FALSE);

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = RemoveLockStatus;

        IoCompleteRequest(Irp, IO_VIDEO_INCREMENT);
        return RemoveLockStatus;
    }
#endif

    //
    // Handle IRPs for the PDO.  Only PNP IRPs should be going to
    // that device.
    //

    if (IS_PDO(combinedExtension)) {

        ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

        pVideoDebugPrint((2, "VIDEO_TYPE_PDO : IRP_MJ_PNP: "));

        switch (irpStack->MinorFunction) {

        case IRP_MN_CANCEL_STOP_DEVICE:

            pVideoDebugPrint((2, "IRP_MN_CANCEL_STOP_DEVICE\n"));

            statusBlock->Status = STATUS_SUCCESS;
            break;

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:

            pVideoDebugPrint((2, "IRP_MN_DEVICE_USAGE_NOTIFICATION\n"));
            statusBlock->Status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
        
            pVideoDebugPrint((2, "IRP_MN_QUERY_PNP_DEVICE_STATE\n")) ;
            statusBlock->Status = STATUS_SUCCESS;
            
            break;

        case IRP_MN_QUERY_CAPABILITIES:

            pVideoDebugPrint((2, "IRP_MN_QUERY_CAPABILITIES\n"));

            statusBlock->Status = pVideoPnPCapabilities(childDeviceExtension,
                                                        irpStack->Parameters.DeviceCapabilities.Capabilities);

            break;

        case IRP_MN_QUERY_ID:

            pVideoDebugPrint((2, "IRP_MN_QUERY_ID\n"));

            statusBlock->Status = pVideoPnPQueryId(DeviceObject,
                                                   irpStack->Parameters.QueryId.IdType,
                                                   (PWSTR *)&(Irp->IoStatus.Information));

            break;

        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:

            pVideoDebugPrint((2, "IRP_MN_QUERY_RESOURCE_REQUIREMENTS\n"));

            statusBlock->Status =
                pVideoPnPResourceRequirements(childDeviceExtension,
                                             (PCM_RESOURCE_LIST * )&(Irp->IoStatus.Information));

            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            pVideoDebugPrint((2, "IRP_MN_QUERY_DEVICE_RELATIONS\n"));

            if (irpStack->Parameters.QueryDeviceRelations.Type ==
                TargetDeviceRelation) {

                PDEVICE_RELATIONS DeviceRelationsBuffer;
                PDEVICE_RELATIONS *pDeviceRelations;

                pDeviceRelations = (PDEVICE_RELATIONS *) &statusBlock->Information;

                if (*pDeviceRelations) {

                    //
                    // The caller supplied a device relation structure.
                    // However, we do not know if it is big enough, so
                    // free it and allocate our own.
                    //

                    ExFreePool(*pDeviceRelations);
                    *pDeviceRelations = NULL;
                }

                DeviceRelationsBuffer = ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,
                                                              sizeof(DEVICE_RELATIONS),
                                                              VP_TAG);

                if (DeviceRelationsBuffer) {

                    DeviceRelationsBuffer->Count = 1;
                    DeviceRelationsBuffer->Objects[0] = DeviceObject;

                    *pDeviceRelations = DeviceRelationsBuffer;

                    ObReferenceObject(DeviceObject);

                    statusBlock->Status = STATUS_SUCCESS;

                } else {

                    statusBlock->Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            break;

        case IRP_MN_QUERY_DEVICE_TEXT:

            pVideoDebugPrint((2, "IRP_MN_QUERY_DEVICE_TEXT\n"));

            statusBlock->Status =
                pVideoPortQueryDeviceText(DeviceObject,
                                          irpStack->Parameters.QueryDeviceText.DeviceTextType,
                                          (PWSTR *)&Irp->IoStatus.Information);

            break;

        case IRP_MN_QUERY_INTERFACE:

            pVideoDebugPrint((2, "IRP_MN_QUERY_INTERFACE\n"));

            if ((childDeviceExtension->pFdoExtension->HwQueryInterface) &&
                (childDeviceExtension->pFdoExtension->HwDeviceExtension)) {

                VP_STATUS status;

                status =
                    childDeviceExtension->pFdoExtension->HwQueryInterface(
                                         childDeviceExtension->pFdoExtension->HwDeviceExtension,
                                         (PQUERY_INTERFACE)
                                         &irpStack->Parameters.QueryInterface);

                if (status == 0)
                {
                    statusBlock->Status = STATUS_SUCCESS;

                }
            }

            break;

        case IRP_MN_SURPRISE_REMOVAL:
        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_STOP_DEVICE:

            pVideoDebugPrint((2, "IRP_MN_SURPRISE_REMOVAL/IRP_MN_QUERY_REMOVE_DEVICE/IRP_MN_QUERY_STOP_DEVICE/IRP_MN_STOP_DEVICE\n"));

            if (childDeviceExtension->VideoChildDescriptor->Type == Monitor) 
            {
                if (irpStack->MinorFunction == IRP_MN_SURPRISE_REMOVAL) {
                    KeWaitForSingleObject (&LCDPanelMutex,
                           Executive,
                           KernelMode,
                           FALSE,
                           (PTIME)NULL);
                    if (LCDPanelDevice == DeviceObject) {
                        LCDPanelDevice = NULL;
                    }
                    KeReleaseMutex (&LCDPanelMutex, FALSE);
                }
            }
            statusBlock->Status = STATUS_SUCCESS;

            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:

            pVideoDebugPrint((2, "IRP_MN_CANCEL_REMOVE_DEVICE\n"));
            statusBlock->Status = STATUS_SUCCESS;
            break;

        case IRP_MN_REMOVE_DEVICE:

            pVideoDebugPrint((2, "IRP_MN_REMOVE_DEVICE\n"));

            //
            // Check the see if this is the LCD Panel. If it is, set the LCD
            // panel device object to NULL. If not, leave it alone.
            //

            KeWaitForSingleObject (&LCDPanelMutex,
                   Executive,
                   KernelMode,
                   FALSE,
                   (PTIME)NULL);
            if (LCDPanelDevice == DeviceObject) {
                LCDPanelDevice = NULL;
            }
            KeReleaseMutex(&LCDPanelMutex, FALSE);

#if REMOVE_LOCK_ENABLED
            IoReleaseRemoveLockAndWait(pRemoveLock, Irp);
            RemoveLockReleased = TRUE;
#endif

            //
            // If this is one of our child pdo's, then
            // clean it up.
            //

            statusBlock->Status = pVideoPortCleanUpChildList(childDeviceExtension->pFdoExtension,
                                                             DeviceObject);

            break;

        case IRP_MN_START_DEVICE:

            {
                UCHAR nextMiniport = FALSE;
                PVIDEO_PORT_DRIVER_EXTENSION DriverObjectExtension;

                pVideoDebugPrint((2, "IRP_MN_START_DEVICE\n"));

                //
                // For a non-card device, just return success
                //

                if (childDeviceExtension->VideoChildDescriptor) {

                    //
                    // Once the monitor device is started, create an interface for it.
                    //

                    if (childDeviceExtension->VideoChildDescriptor->Type == Monitor)
                    {
                        statusBlock->Status = STATUS_SUCCESS;

                        //
                        // If the monitor is attached to the video adapter on the hibernation
                        // path then we want to send notification to the system that the
                        // monitor is on the hibernation path as well.
                        //

                        if (fdoExtension->OnHibernationPath == TRUE)
                        {
                            pVideoPortHibernateNotify (DeviceObject, TRUE);
                        }

                        //
                        // If this is the LCD Panel, update the global to indicate as
                        // much.
                        //

                        if (childDeviceExtension->ChildUId == 0x110)
                        {
                            KeWaitForSingleObject (&LCDPanelMutex,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PTIME)NULL);
                            LCDPanelDevice = DeviceObject;
                            KeReleaseMutex(&LCDPanelMutex, FALSE);
                            
                            //
                            // If the new backlight control interface is implemented,
                            //  set the backlight brightness level.
                            //

                            if ((pVpBacklightStatus->bNewAPISupported == TRUE) &&
                                (pVpBacklightStatus->bACBrightnessKnown == TRUE) &&
                                (VpRunningOnAC == TRUE))
                            {
                                ulACPIMethodParam1= (ULONG) pVpBacklightStatus->ucACBrightness;
                                bSetBacklight = TRUE;
                            }

                            if ((pVpBacklightStatus->bNewAPISupported == TRUE) &&
                                (pVpBacklightStatus->bDCBrightnessKnown == TRUE) &&
                                (VpRunningOnAC == FALSE))
                            {
                                ulACPIMethodParam1= (ULONG) pVpBacklightStatus->ucDCBrightness;
                                bSetBacklight = TRUE;
                            }

                            if ((bSetBacklight) && (LCDPanelDevice))
                            {
                                AttachedDevice = IoGetAttachedDeviceReference(LCDPanelDevice);

                                // Not checking status here deliberately, as we're not failing
                                //  this IRP if this call fails.

                                if (AttachedDevice) {

                                    pVideoPortACPIIoctl(
                                        AttachedDevice,
                                        (ULONG) ('MCB_'),
                                        &ulACPIMethodParam1,
                                        NULL,
                                        0,
                                        NULL);

                                    ObDereferenceObject(AttachedDevice);
                                }
                            }
                        }
                    }
                    else if (childDeviceExtension->VideoChildDescriptor->Type == Other)
                    {
                        statusBlock->Status = STATUS_SUCCESS;
                    }
                }
                else
                {

                    ASSERT(FALSE);

                    //
                    // Secondary video cards are handle here.
                    //

                    DriverObjectExtension = (PVIDEO_PORT_DRIVER_EXTENSION)
                                            IoGetDriverObjectExtension(
                                                DeviceObject->DriverObject,
                                                DeviceObject->DriverObject);

                }
            }

            break;

        default:

            pVideoDebugPrint((2, "PNP minor function %x not supported!\n", irpStack->MinorFunction ));

            statusBlock->Status = STATUS_NOT_SUPPORTED;

            break;
        }

    } else {

        ASSERT(IS_FDO(fdoExtension));
        ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

        pVideoDebugPrint((2, "VIDEO_TYPE_FDO : IRP_MJ_PNP: "));

        switch (irpStack->MinorFunction) {

        case IRP_MN_QUERY_STOP_DEVICE:

            pVideoDebugPrint((2, "IRP_MN_QUERY_STOP_DEVICE\n"));

            statusBlock->Status = STATUS_UNSUCCESSFUL;
            break;

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            {
            PVIDEO_PORT_DRIVER_EXTENSION DriverObjectExtension;
            PIO_RESOURCE_REQUIREMENTS_LIST requirements;
            ULONG Length;

            pVideoDebugPrint((2, "IRP_MN_QUERY_RESOURCE_REQUIREMENTS\n"));

            DriverObjectExtension = (PVIDEO_PORT_DRIVER_EXTENSION)
                                    IoGetDriverObjectExtension(
                                        DeviceObject->DriverObject,
                                        DeviceObject->DriverObject);

            //
            // We must first pass the Irp down to the PDO.
            //

            pVideoPortSendIrpToLowerDevice(DeviceObject, Irp);

            //
            // Determine the bus type and bus number
            //

            IoGetDeviceProperty(fdoExtension->PhysicalDeviceObject,
                                DevicePropertyLegacyBusType,
                                sizeof(fdoExtension->AdapterInterfaceType),
                                &fdoExtension->AdapterInterfaceType,
                                &Length);

            IoGetDeviceProperty(fdoExtension->PhysicalDeviceObject,
                                DevicePropertyBusNumber,
                                sizeof(fdoExtension->SystemIoBusNumber),
                                &fdoExtension->SystemIoBusNumber,
                                &Length);

            //
            // Get bus interface so we can use Get/SetBusData.
            //

            fdoExtension->ValidBusInterface =
                NT_SUCCESS(VpGetBusInterface(fdoExtension));

            requirements = irpStack->Parameters.FilterResourceRequirements.IoResourceRequirementList;

            if (requirements) {

                //
                // Append any legacy resources decoded by the device.
                //

                if (DriverObjectExtension->HwInitData.HwInitDataSize >
                    FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwLegacyResourceCount)) {

                    if( requirements->InterfaceType == PCIBus )
                    {

                        PCI_COMMON_CONFIG ConfigSpace;

                        VideoPortGetBusData((PVOID)((ULONG_PTR)(fdoExtension) +
                                                sizeof(FDO_EXTENSION) +
                                                sizeof(DEVICE_SPECIFIC_EXTENSION)),
                                            PCIConfiguration,
                                            0,
                                            &ConfigSpace,
                                            0,
                                            PCI_COMMON_HDR_LENGTH);

                        if (((ConfigSpace.BaseClass == PCI_CLASS_PRE_20) &&
                             (ConfigSpace.SubClass  == PCI_SUBCLASS_PRE_20_VGA)) ||
                            ((ConfigSpace.BaseClass == PCI_CLASS_DISPLAY_CTLR) &&
                             (ConfigSpace.SubClass  == PCI_SUBCLASS_VID_VGA_CTLR))) {

                            if (pVideoPortGetVgaStatusPci((PVOID)((ULONG_PTR)(fdoExtension) + sizeof(FDO_EXTENSION) + sizeof(DEVICE_SPECIFIC_EXTENSION)))) {

                                if (DriverObjectExtension->HwInitData.HwInitDataSize >
                                    FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwGetLegacyResources)) {

                                    if (DriverObjectExtension->HwInitData.HwGetLegacyResources) {

                                        //
                                        // If the miniport supplied a HwGetLegacyResources routine
                                        // it wasn't able to give us a list of resources at
                                        // DriverEntry time.  We'll give it a vendor/device id now
                                        // and see if it can give us a list of resources.
                                        //

                                        DriverObjectExtension->HwInitData.HwGetLegacyResources(
                                            ConfigSpace.VendorID,
                                            ConfigSpace.DeviceID,
                                            &DriverObjectExtension->HwInitData.HwLegacyResourceList,
                                            &DriverObjectExtension->HwInitData.HwLegacyResourceCount
                                            );
                                    }
                                }

                                if (DriverObjectExtension->HwInitData.HwLegacyResourceList) {

                                    if (VgaHwDeviceExtension) {

                                        ULONG Count;
                                        PVIDEO_ACCESS_RANGE AccessRange;

                                        Count       = DriverObjectExtension->HwInitData.HwLegacyResourceCount;
                                        AccessRange = DriverObjectExtension->HwInitData.HwLegacyResourceList;

                                        //
                                        // Mark VGA resources as shared if the vga driver is
                                        // already loaded.  Otherwise the PnP driver won't
                                        // be able to start.
                                        //

                                        while (Count--) {

                                            if (VpIsVgaResource(AccessRange)) {
                                                AccessRange->RangeShareable = TRUE;
                                            }

                                            AccessRange++;
                                        }
                                    }

                                    VpAppendToRequirementsList(
                                        DeviceObject,
                                        &requirements,
                                        DriverObjectExtension->HwInitData.HwLegacyResourceCount,
                                        DriverObjectExtension->HwInitData.HwLegacyResourceList);

                                } else {

                                    //
                                    // The driver didn't specify legacy resources, but we
                                    // know that it is a VGA, so add in the vga resources.
                                    //

                                    pVideoDebugPrint((1, "VGA device didn't specify legacy resources.\n"));

                                    DriverObjectExtension->HwInitData.HwLegacyResourceCount = NUM_VGA_LEGACY_RESOURCES;
                                    DriverObjectExtension->HwInitData.HwLegacyResourceList = VgaLegacyResources;

                                    VpAppendToRequirementsList(
                                        DeviceObject,
                                        &requirements,
                                        NUM_VGA_LEGACY_RESOURCES,
                                        VgaLegacyResources);
                                }
                            }
                        }
                    }
                }

                //
                // Now if there is an interrupt in the list, but
                // the miniport didn't register an ISR, then
                // release our claim on the interrupt.
                //

                if (!DriverObjectExtension->HwInitData.HwInterrupt) {

                    PIO_RESOURCE_LIST resourceList;
                    ULONG i;

                    //
                    // Scan the IO_RESOURCE_REQUIREMENTS_LIST for an
                    // interrupt.
                    //

                    resourceList = requirements->List;

                    for (i=0; i<resourceList->Count; i++) {

                        if (resourceList->Descriptors[i].Type == CmResourceTypeInterrupt) {

                            //
                            // We found an interrupt resource swap with last
                            // element in list, and decrement structure size and
                            // list count.
                            //

                            resourceList->Descriptors[i].Type = CmResourceTypeNull;

                            pVideoDebugPrint((1, "Removing Int from requirements list.\n"));
                        }
                    }
                }

            } else {

                pVideoDebugPrint((0, "We expected a list of resources!\n"));
                ASSERT(FALSE);
            }


            statusBlock->Information = (ULONG_PTR) requirements;
            statusBlock->Status = STATUS_SUCCESS;

            }

            break;

        case IRP_MN_START_DEVICE:
            {
            PVIDEO_PORT_DRIVER_EXTENSION DriverObjectExtension;
            PCM_RESOURCE_LIST allocatedResources;
            PCM_RESOURCE_LIST translatedResources;
            UCHAR nextMiniport = FALSE;
            ULONG RawListSize;
            ULONG TranslatedListSize;

            pVideoDebugPrint((2, "IRP_MN_START_DEVICE\n"));

            //
            // Retrieve the data we cached away during VideoPortInitialize.
            //

            DriverObjectExtension = (PVIDEO_PORT_DRIVER_EXTENSION)
                                    IoGetDriverObjectExtension(
                                        DeviceObject->DriverObject,
                                        DeviceObject->DriverObject);

            ASSERT(DriverObjectExtension);

            //
            // Grab the allocated resource the system gave us.
            //

            allocatedResources =
                irpStack->Parameters.StartDevice.AllocatedResources;
            translatedResources =
                irpStack->Parameters.StartDevice.AllocatedResourcesTranslated;

            //
            // Filter out any resources that we added to the list
            // before passing the irp on to PCI.
            //

            if (DriverObjectExtension->HwInitData.HwInitDataSize >
                FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwLegacyResourceCount)) {

                if (DriverObjectExtension->HwInitData.HwLegacyResourceList) {

                    if (allocatedResources) {
                        irpStack->Parameters.StartDevice.AllocatedResources =
                            VpRemoveFromResourceList(
                                allocatedResources,
                                DriverObjectExtension->HwInitData.HwLegacyResourceCount,
                                DriverObjectExtension->HwInitData.HwLegacyResourceList);

                    }

                    if ((irpStack->Parameters.StartDevice.AllocatedResources !=
                         allocatedResources) && translatedResources) {

                        irpStack->Parameters.StartDevice.AllocatedResourcesTranslated =
                            VpRemoveFromResourceList(
                                translatedResources,
                                DriverObjectExtension->HwInitData.HwLegacyResourceCount,
                                DriverObjectExtension->HwInitData.HwLegacyResourceList);

                    }
                }
            }

            //
            // The first thing we need to do is send the START_DEVICE
            // irp on to our parent.
            //

            pVideoPortSendIrpToLowerDevice(DeviceObject, Irp);

            //
            // Restore the original resources.
            //

            if (irpStack->Parameters.StartDevice.AllocatedResources !=
                allocatedResources) {

                ExFreePool(irpStack->Parameters.StartDevice.AllocatedResources);
                irpStack->Parameters.StartDevice.AllocatedResources
                    = allocatedResources;
            }

            if (irpStack->Parameters.StartDevice.AllocatedResourcesTranslated !=
                translatedResources) {

                ExFreePool(irpStack->Parameters.StartDevice.AllocatedResourcesTranslated);
                irpStack->Parameters.StartDevice.AllocatedResourcesTranslated
                    = translatedResources;
            }

            if (allocatedResources) {

                ASSERT(translatedResources);

                //
                // Cache assigned and translated resources.
                //

                RawListSize = GetCmResourceListSize(allocatedResources);
                TranslatedListSize = GetCmResourceListSize(translatedResources);

                ASSERT(RawListSize == TranslatedListSize);

                fdoExtension->RawResources = ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,
                                                                   RawListSize +
                                                                   TranslatedListSize,
                                                                   VP_TAG);

                fdoExtension->TranslatedResources = (PCM_RESOURCE_LIST)
                    ((PUCHAR)fdoExtension->RawResources + RawListSize);

                if (fdoExtension->RawResources == NULL) {

                    statusBlock->Status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                memcpy(fdoExtension->RawResources,
                       allocatedResources,
                       RawListSize);

                memcpy(fdoExtension->TranslatedResources,
                       translatedResources,
                       TranslatedListSize);
            }

            //
            // Get slot/function number
            //

            fdoExtension->SlotNumber = VpGetDeviceAddress(DeviceObject);

            //
            // Store the allocatedResources. This will allow us to
            // assign these resources when VideoPortGetAccessRanges
            // routines are called.
            //
            // NOTE: We do not actually have to copy the data, because
            //       we are going to call FindAdapter in the context
            //       of this function.  So, this data will be intact
            //       until we complete.
            //

            if ((allocatedResources != NULL) && (translatedResources != NULL)) {

                ULONG Count;
                PCM_PARTIAL_RESOURCE_DESCRIPTOR InterruptDesc;

                Count = 0;
                InterruptDesc = RtlUnpackPartialDesc(CmResourceTypeInterrupt,
                                                     translatedResources,
                                                     &Count);

                fdoExtension->AllocatedResources = allocatedResources;
                fdoExtension->SystemIoBusNumber =
                    allocatedResources->List->BusNumber;
                fdoExtension->AdapterInterfaceType =
                    allocatedResources->List->InterfaceType;

                //
                // Tuck away the giblets we need for PnP interrupt support!
                //
                if (InterruptDesc) {
                    fdoExtension->InterruptVector =
                        InterruptDesc->u.Interrupt.Vector;
                    fdoExtension->InterruptIrql =
                        (KIRQL)InterruptDesc->u.Interrupt.Level;
                    fdoExtension->InterruptAffinity =
                        InterruptDesc->u.Interrupt.Affinity;
                }

            }

            ACQUIRE_DEVICE_LOCK (combinedExtension);

            if (VideoPortFindAdapter(DeviceObject->DriverObject,
                                     (PVOID)&(DriverObjectExtension->RegistryPath),
                                     &(DriverObjectExtension->HwInitData),
                                     NULL,
                                     DeviceObject,
                                     &nextMiniport) == NO_ERROR) {

                if (nextMiniport == TRUE) {
                    pVideoDebugPrint((1, "VIDEOPRT: The Again parameter is ignored for PnP drivers.\n"));
                }

                statusBlock->Status = STATUS_SUCCESS;

                //
                // Only put the VGA device on the hibernation path. All other
                // devices should be allowed to turn off during hibernation or
                // shutdown.
                //
                // Note: This may change in the future if we decide to keep non-VGA
                // device (e.g. UGA primary display) on.
                //

                if (DeviceObject == DeviceOwningVga) {
                    pVideoPortHibernateNotify(fdoExtension->AttachedDeviceObject, FALSE);
                    fdoExtension->OnHibernationPath = TRUE;
                }

                //
                // If the system is already up and running, lets call
                // HwInitialize now.  This will allow us to enumerate
                // children.
                //

                if (VpSystemInitialized) {

                    VpEnableDisplay(fdoExtension, FALSE);

                    if (fdoExtension->HwInitialize(fdoExtension->HwDeviceExtension)) {
                        fdoExtension->HwInitStatus = HwInitSucceeded;
                    } else {
                        fdoExtension->HwInitStatus = HwInitFailed;
                    }

                    VpEnableDisplay(fdoExtension, TRUE);
                }

                //
                // Indicate that resources have been assigned to this device
                // so that a legacy driver can't acquire resources for the
                // same device.
                //

                AddToResourceList(fdoExtension->SystemIoBusNumber,
                                  fdoExtension->SlotNumber);


            } else {

                statusBlock->Status = STATUS_UNSUCCESSFUL;

                if (fdoExtension->RawResources) {
                    ExFreePool(fdoExtension->RawResources);
                }
            }

            RELEASE_DEVICE_LOCK (combinedExtension);

            //
            // Do ACPI specific stuff
            //
            if (NT_SUCCESS(pVideoPortQueryACPIInterface(DoSpecificExtension)))
            {
                DoSpecificExtension->bACPI = TRUE;
            }

            }


            break;


        case IRP_MN_QUERY_ID:

            pVideoDebugPrint((2, "IRP_MN_QUERYID with DeviceObject %p\n", DeviceObject));

            //
            // Return the Hardware ID returned by the video miniport driver
            // if it is provided.
            //

            if (irpStack->Parameters.QueryId.IdType == BusQueryHardwareIDs)
            {
                VIDEO_CHILD_TYPE      ChildType;
                VIDEO_CHILD_ENUM_INFO childEnumInfo;
                ULONG                 uId;
                ULONG                 unused;
                PUCHAR                nameBuffer;

                nameBuffer = ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,
                                                   EDID_BUFFER_SIZE,
                                                   VP_TAG);

                if (nameBuffer)
                {
                    RtlZeroMemory(nameBuffer, EDID_BUFFER_SIZE);

                    childEnumInfo.Size                   = sizeof(VIDEO_CHILD_ENUM_INFO);
                    childEnumInfo.ChildDescriptorSize    = EDID_BUFFER_SIZE;
                    childEnumInfo.ChildIndex             = DISPLAY_ADAPTER_HW_ID;
                    childEnumInfo.ACPIHwId               = 0;
                    childEnumInfo.ChildHwDeviceExtension = NULL;

                    ACQUIRE_DEVICE_LOCK (combinedExtension);
                    if (fdoExtension->HwGetVideoChildDescriptor(
                                            fdoExtension->HwDeviceExtension,
                                            &childEnumInfo,
                                            &ChildType,
                                            nameBuffer,
                                            &uId,
                                            &unused) == ERROR_MORE_DATA)
                    {

                        statusBlock->Information = (ULONG_PTR) nameBuffer;
                        statusBlock->Status = STATUS_SUCCESS;
                    }
                    RELEASE_DEVICE_LOCK (combinedExtension);
                }
            }

            goto CallNextDriver;

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            pVideoDebugPrint((2, "IRP_MN_QUERY_DEVICE_RELATIONS with DeviceObject\n"));
            pVideoDebugPrint((2, "\t\t DeviceObject %p, Type = ", DeviceObject));

            if (irpStack->Parameters.QueryDeviceRelations.Type == BusRelations) {

                pVideoDebugPrint((2, "BusRelations\n"));

                ACQUIRE_DEVICE_LOCK (combinedExtension);

                //
                // Disable VGA driver during the setup. Enumeration code
                // in the miniport can touch VGA registers.
                //

                if (VpSetupTypeAtBoot != SETUPTYPE_NONE)
                    VpEnableDisplay(fdoExtension, FALSE);

                statusBlock->Status = pVideoPortEnumerateChildren(DeviceObject, Irp);

                //
                // Renable VGA driver back during the setup.
                //

                if (VpSetupTypeAtBoot != SETUPTYPE_NONE)
                    VpEnableDisplay(fdoExtension, TRUE);

                RELEASE_DEVICE_LOCK (combinedExtension);

                if (!NT_SUCCESS(statusBlock->Status)) {

                    goto Complete_Irp;
                }
            }

            goto CallNextDriver;

        case IRP_MN_QUERY_REMOVE_DEVICE:

            pVideoDebugPrint((2, "IRP_MN_QUERY_REMOVE_DEVICE\n"));

            statusBlock->Status = STATUS_UNSUCCESSFUL;
            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:

            pVideoDebugPrint((2, "IRP_MN_CANCEL_REMOVE_DEVICE\n"));

            statusBlock->Status = STATUS_SUCCESS;

            goto CallNextDriver;

        case IRP_MN_REMOVE_DEVICE:

            pVideoDebugPrint((2, "IRP_MN_REMOVE_DEVICE\n"));

            VpDisableAdapterInterface(fdoExtension);

            pVideoPortSendIrpToLowerDevice(DeviceObject, Irp);

#if REMOVE_LOCK_ENABLED
            IoReleaseRemoveLockAndWait(pRemoveLock, Irp);
            RemoveLockReleased = TRUE;
#endif

            //
            // If we are attached to another device, remove the attachment
            //

            if (fdoExtension->AttachedDeviceObject) {
                IoDetachDevice(fdoExtension->AttachedDeviceObject);
            }

            //
            // Remove the DeviceObject
            //

            IoDeleteDevice(DeviceObject);
            statusBlock->Status = STATUS_SUCCESS;

            break;


        case IRP_MN_QUERY_INTERFACE:

            //
            // Normally I would only expect to get this IRP heading for
            // an PDO.  However, AndrewGo wants to be able to send down
            // these IRP's and he only has an FDO.  Instead of forcing
            // him to get a PDO somehow, we'll just handle the irp for
            // a FDO as well.
            //

            pVideoDebugPrint((2, "IRP_MN_QUERY_INTERFACE\n"));

            ACQUIRE_DEVICE_LOCK (combinedExtension);

            if ((fdoExtension->HwQueryInterface) &&
                (fdoExtension->HwDeviceExtension) &&
                (NO_ERROR == fdoExtension->HwQueryInterface(
                                      fdoExtension->HwDeviceExtension,
                                      (PQUERY_INTERFACE)
                                      &irpStack->Parameters.QueryInterface)))
            {
                statusBlock->Status = STATUS_SUCCESS;
            }
            else if (!NT_SUCCESS(statusBlock->Status))
            {
                //
                // The miniport didn't handle the QueryInterface request, see
                // if its an interface the videoprt supports.
                //

                PQUERY_INTERFACE qi = (PQUERY_INTERFACE)
                                      &irpStack->Parameters.QueryInterface;

                //
                // If we are responding to a known private GUID, expose
                // the known GUID interface ourselves.  Otherwise, pass
                // on to the miniport driver.
                //

                if (IsEqualGUID(qi->InterfaceType, &GUID_AGP_INTERFACE)) {

                    PAGP_INTERFACE AgpInterface = (PAGP_INTERFACE)qi->Interface;

                    AgpInterface->Size    = sizeof(AGP_INTERFACE);
                    AgpInterface->Version = AGP_INTERFACE_VERSION;
                    AgpInterface->Context = fdoExtension->HwDeviceExtension;

                    if (VideoPortGetAgpServices(fdoExtension->HwDeviceExtension,
                                                &AgpInterface->AgpServices)) {

                        statusBlock->Status = STATUS_SUCCESS;
                    }
                }
            }

            RELEASE_DEVICE_LOCK (combinedExtension);

            goto CallNextDriver;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:

            statusBlock->Status = STATUS_SUCCESS;
            
            goto CallNextDriver;

        default:

            pVideoDebugPrint((2, "PNP minor function %x not supported - forwarding \n", irpStack->MinorFunction ));

            goto CallNextDriver;
        }
    }

Complete_Irp:

    //
    // save the final status so we can return it after the IRP is completed.
    //

    finalStatus = statusBlock->Status;

#if REMOVE_LOCK_ENABLED
    if (RemoveLockReleased == FALSE) {
        IoReleaseRemoveLock(pRemoveLock, Irp);
    }
#endif

    IoCompleteRequest(Irp,
                      IO_VIDEO_INCREMENT);

    return finalStatus;

CallNextDriver:

    //
    // Call the next driver in the chain.
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);
    finalStatus = IoCallDriver(fdoExtension->AttachedDeviceObject, Irp);

#if REMOVE_LOCK_ENABLED
    if (RemoveLockReleased == FALSE) {
        IoReleaseRemoveLock(pRemoveLock, Irp);
    }
#endif

    return finalStatus;
}

VOID
InitializePowerStruct(
    IN PIRP Irp,
    OUT PVIDEO_POWER_MANAGEMENT vpPower,
    OUT BOOLEAN *bWakeUp
    )

/*++

Routine Description:

    This routine initializes the power management structure we'll pass
    down to the miniport.

Arguments:

    DeviceObject - The device object for the device.

    Irp - The irp we are handling

    vpPower - A pointer to the power structure we are initializing.

Returns:

    none.

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    if (bWakeUp)
        *bWakeUp = FALSE;

    //
    // Setup for call to the miniport.
    //

    vpPower->Length = sizeof(VIDEO_POWER_MANAGEMENT);
    vpPower->DPMSVersion = 0;
    vpPower->PowerState = irpStack->Parameters.Power.State.DeviceState;

    //
    // Special case hibernation.
    //

    if (irpStack->Parameters.Power.ShutdownType == PowerActionHibernate)
    {
        //
        // This indicates waking from Hibernation.
        //

        if (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0)
        {
            if (bWakeUp)
            {
                *bWakeUp = TRUE;
            }
        }
        else
        {
            vpPower->PowerState = VideoPowerHibernate;
        }
    }
    else if ((irpStack->Parameters.Power.ShutdownType >= PowerActionShutdown) &&
            (irpStack->Parameters.Power.ShutdownType < PowerActionWarmEject))
    {
        //
        // Special case shutdown - force VideoPowerShutdown.
        //
        // All video adapters must disable interrupts else they may fire an interrupt
        // when the bridge is disabled or when the machine reboots missing #RST on
        // PCI bus causing an interrupt storm.
        //
        // Devices on hibernation path must stay on, the miniport driver must ensure
        // this.
        // 

        vpPower->PowerState = VideoPowerShutdown;
    }
}

NTSTATUS
pVideoPortPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is a system-defined dispatch routine that handles all
    I/O request packets (IRPs) specifically for power. Currently that 
    list entails:

    IRP_MJ_POWER:
        IRP_MN_SET_POWER
        IRP_MN_QUERY_POWER

    This routine will process the IRPs as a bus driver for the monitor
    and child device objects and will process the IRPs as a function
    driver for the adapter device object.

Arguments:

    DeviceObject - Points to the DEVICE_OBJECT that this request is
                   targeting.
    Irp - Points to the IRP for this request.

Return Value:

    A NTSTATUS value indicating the success or failure of the operation.

--*/

{
    PFDO_EXTENSION fdoExtension;
    PCHILD_PDO_EXTENSION pdoExtension = NULL;
    PDEVICE_SPECIFIC_EXTENSION DoSpecificExtension;
    PIO_STACK_LOCATION irpStack;
    ULONG deviceId;
    VP_STATUS vpStatus;
    VIDEO_POWER_MANAGEMENT vpPowerMgmt;
    POWER_STATE powerState;
    KEVENT event;
    POWER_BLOCK context;
    BOOLEAN bDisplayAdapter;
    BOOLEAN bMonitor;
    BOOLEAN bShutdown;
    NTSTATUS finalStatus = STATUS_SOME_NOT_MAPPED;
    PBACKLIGHT_STATUS pVpBacklightStatus = &VpBacklightStatus;
    PDEVICE_OBJECT AttachedDevice = NULL;
    ULONG ulACPIMethodParam1;
    BOOLEAN bSetBacklight = FALSE;

    PAGED_CODE();

    //
    // Get pointer to the port driver's device extension.
    //

    if (IS_PDO(DeviceObject->DeviceExtension)) {

        pVideoDebugPrint((2, "VideoPortPowerDispatch: IS_PDO == TRUE (child device)\n"));

        pdoExtension = DeviceObject->DeviceExtension;
        fdoExtension = pdoExtension->pFdoExtension;

        bDisplayAdapter = FALSE;

        if (pdoExtension->VideoChildDescriptor->Type == Monitor) {

            bMonitor = TRUE;

        } else {

            bMonitor = FALSE;
        }

    } else if (IS_FDO(DeviceObject->DeviceExtension)) {

        pVideoDebugPrint((2, "VideoPortPowerDispatch: IS_FDO == TRUE (video adapter)\n"));

        fdoExtension = DeviceObject->DeviceExtension;
        DoSpecificExtension = (PDEVICE_SPECIFIC_EXTENSION)(fdoExtension + 1);

        bDisplayAdapter = TRUE;
        bMonitor = FALSE;

    } else {

        //
        // This case should never happen, if we got here something went terribly wrong.
        //

        pVideoDebugPrint((0, "VideoPortPowerDispatch: IRP not supported by secondary DeviceObject\n"));
        ASSERT(FALSE);

        //
        // Since this should never happen we don't really need this code here.
        // We're keeping it for now just in case of impossible happening.
        //

        PoStartNextPowerIrp(Irp);
        finalStatus = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return finalStatus;
    }

    //
    // Make sure that FindAdapter has succeeded. This ensures
    // that in the situation where a power IRP is sent before the
    // device is started, no attempt to process it is made.
    //

    if (bDisplayAdapter) {

        if ((fdoExtension->Flags & FINDADAPTER_SUCCEEDED) == 0) {
        
            pVideoDebugPrint ((1, "VideoPortPowerDispatch: Ignoring S IRP\n"));
        
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation (Irp);
        
            return PoCallDriver(fdoExtension->AttachedDeviceObject, Irp);
        }
    }

    //
    // Initialize the event that is used to synchronize the IRP
    // completions. Also initialize the power context structure.
    //

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);
    context.Event = &event;

    //
    // Obtain information about the specific request.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Check if this is a shutdown.
    //

    if ((irpStack->Parameters.Power.ShutdownType >= PowerActionShutdown) &&
        (irpStack->Parameters.Power.ShutdownType < PowerActionWarmEject)) {

        bShutdown = TRUE;

    } else {

        bShutdown = FALSE;
    }

    //
    // Set device id.
    //

    deviceId = bDisplayAdapter ? DISPLAY_ADAPTER_HW_ID : pdoExtension->ChildUId;

    //
    // Begin the switch for handling power IRPs
    //

    switch (irpStack->MinorFunction) {

    case IRP_MN_QUERY_POWER:

        //
        // Is this a system or device power IRP?
        //

        if (irpStack->Parameters.Power.Type == SystemPowerState) {

            pVideoDebugPrint((2, "VideoPortPowerDispatch: System query power IRP\n"));
            pVideoDebugPrint((2, "VideoPortPowerDispatch: Device object = %p\n", DeviceObject));
            pVideoDebugPrint((2, "VideoPortPowerDispatch: Requested state = %d\n",
                              irpStack->Parameters.Power.State.SystemState));

            //
            // This is a system power IRP. The objective here is to
            // quickly determine if we can safely support a proposed
            // transition to the requested system power state.
            //

            if (!pVideoPortMapStoD(DeviceObject->DeviceExtension,
                                   irpStack->Parameters.Power.State.SystemState,
                                   &powerState.DeviceState)) {

                pVideoDebugPrint((0, "VideoPortPowerDispatch: Couldn't get S->D mapping\n"));
                finalStatus = STATUS_UNSUCCESSFUL;
                break;
            }

            //
            // Mark the IRP as pending now as unless there is a failure,
            // this IRP will be returned with status_pending.
            //

            IoMarkIrpPending(Irp);

            //
            // Request the power IRP and go.
            //

            finalStatus = PoRequestPowerIrp(DeviceObject,
                                            IRP_MN_QUERY_POWER,
                                            powerState,
                                            pVideoPortPowerIrpComplete,
                                            Irp,
                                            NULL);

        } else {

            pVideoDebugPrint((2, "VideoPortPowerDispatch: Device query power IRP\n"));
            pVideoDebugPrint((2, "VideoPortPowerDispatch: Device object = %p\n", DeviceObject));
            pVideoDebugPrint((2, "VideoPortPowerDispatch: Requested state = %d\n",
                              irpStack->Parameters.Power.State.DeviceState));

            InitializePowerStruct(Irp, &vpPowerMgmt, NULL);

            //
            // For OEMs like Toshiba, they want alway map sleep state to D3 due to a 
            // legal patent issue.  The patent prohibit them from using more than one
            // sleep state.
            //

            if (bMonitor &&
                fdoExtension->OverrideMonitorPower &&
                (vpPowerMgmt.PowerState >= VideoPowerStandBy) &&
                (vpPowerMgmt.PowerState < VideoPowerOff)) {

                vpPowerMgmt.PowerState = VideoPowerOff;
            }

            //
            // Call the miniport. No need to acquire the miniport lock as
            // power IRP's are serial.
            //

            ACQUIRE_DEVICE_LOCK(fdoExtension);

            vpStatus = fdoExtension->HwGetPowerState(fdoExtension->HwDeviceExtension,
                                                     deviceId,
                                                     &vpPowerMgmt);

            RELEASE_DEVICE_LOCK(fdoExtension);

            if (vpStatus != NO_ERROR) {

                pVideoDebugPrint((1, "VideoPortPowerDispatch: Mini refused state %d\n",
                                 vpPowerMgmt.PowerState));

                //
                // If this is the shutdown ignore miniport. We should never ever get
                // here, since shutdown IRPs are unconditional, i.e. we're getting only
                // set requests, which are by definition unfailable, but this is just in
                // case power folks change their minds.
                //

                if (bShutdown) {

                    pVideoDebugPrint ((1, "VideoPortPowerDispatch: Ignoring miniport - forcing shutdown\n"));
                    finalStatus = STATUS_SUCCESS;

                } else {

                    finalStatus = STATUS_DEVICE_POWER_FAILURE;
                }

            } else {

                finalStatus = STATUS_SUCCESS;
            }
        }

        //
        // End processing for IRP_MN_QUERY_POWER. Indicate to the system that
        // the next PowerIrp can be sent.
        //

        break;

    case IRP_MN_SET_POWER:

        if (irpStack->Parameters.Power.Type == SystemPowerState) {

            pVideoDebugPrint((2, "VideoPortPowerDispatch: System set power IRP\n")) ;
            pVideoDebugPrint((2, "VideoPortPowerDispatch: Device object = %p\n", DeviceObject)) ;
            pVideoDebugPrint((2, "VideoPortPowerDispatch: Requested state = %d\n",
                             irpStack->Parameters.Power.State.SystemState)) ;

            //
            // Special case:
            //
            // The power guys decided they don't want us to send a D3 set power irp for our devices
            // down the stack if we are going to leave the device on during the shutdown.
            // We want to notify miniport driver but we're not going to request D3 irp.
            //
            // Note: We handle calls to miniport here for all devices on hibernation path at the 
            // shutdown (pdo and fdo) since we don't want to get out of order calls.
            //

            if (bShutdown && fdoExtension->OnHibernationPath) {

                //
                // Call the miniport if device is on now.
                //

                powerState.DeviceState = bDisplayAdapter ?
                    fdoExtension->DevicePowerState:
                    pdoExtension->DevicePowerState;

                if (powerState.DeviceState == PowerDeviceD0) {

                    vpPowerMgmt.Length = sizeof(VIDEO_POWER_MANAGEMENT);
                    vpPowerMgmt.DPMSVersion = 0;
                    vpPowerMgmt.PowerState = VideoPowerShutdown;

                    pVideoDebugPrint((2, "VideoPortPowerDispatch: HwSetPowerState for video power state %d\n",
                                     vpPowerMgmt.PowerState));

                    ACQUIRE_DEVICE_LOCK(fdoExtension);

                    vpStatus = fdoExtension->HwSetPowerState(fdoExtension->HwDeviceExtension,
                                                             deviceId,
                                                             &vpPowerMgmt);

                    RELEASE_DEVICE_LOCK(fdoExtension);

                    if (vpStatus != NO_ERROR) {

                        pVideoDebugPrint((0, "VideoPortPowerDispatch: ERROR IN MINIPORT!\n"));
                        pVideoDebugPrint((0, "VideoPortPowerDispatch: Miniport cannot refuse set power request\n"));

                        //
                        // Don't assert here for now - not all miniport drivers handle VideoPowerShutdown.
                        //
                    }
                }

                finalStatus = STATUS_SUCCESS;
                break;
            }

            //
            // If this is a S0 request for the monitor, ignore it (this is
            // so the monitor doesn't power up too early)
            //

            if (bMonitor && (irpStack->Parameters.Power.State.SystemState == PowerSystemWorking)) {

                finalStatus = STATUS_SUCCESS;
                break;
            }

            //
            // Get the device power state that matches the system power
            // state.
            //

            if (!pVideoPortMapStoD(DeviceObject->DeviceExtension,
                                   irpStack->Parameters.Power.State.SystemState,
                                   &powerState.DeviceState)) {

                pVideoDebugPrint((0, "VideoPortPowerDispatch: Couldn't get S->D mapping\n"));
                pVideoDebugPrint((0, "VideoPortPowerDispatch: Can't fail the set!!!\n"));

                if (irpStack->Parameters.Power.State.SystemState < PowerSystemSleeping1) {

                    powerState.DeviceState = PowerDeviceD0;

                } else {

                    powerState.DeviceState = PowerDeviceD3;
                }
            }

            //
            // Request a power IRP for a device power state.
            //

            IoMarkIrpPending(Irp);

            finalStatus = PoRequestPowerIrp(DeviceObject,
                                            IRP_MN_SET_POWER,
                                            powerState,
                                            pVideoPortPowerIrpComplete,
                                            Irp,
                                            NULL);

        } else {

            BOOLEAN bWakeUp;

            pVideoDebugPrint((2, "VideoPortPowerDispatch: Device set power IRP\n")) ;
            pVideoDebugPrint((2, "VideoPortPowerDispatch: Device object = %p\n", DeviceObject)) ;
            pVideoDebugPrint((2, "VideoPortPowerDispatch: Requested state = %d\n",
                             irpStack->Parameters.Power.State.DeviceState)) ;

            //
            // This is a set power request (device request). Here the
            // processing becomes a little more complex. The general
            // behavior is to just quickly tell the miniport to set
            // the requested power state and get out. However, in the
            // case of a hibernation request we will pass a special
            // code to the miniport telling it that this is hibernation.
            // It should save state, but NOT (repeat) NOT power off the
            // device.
            //

            InitializePowerStruct(Irp, &vpPowerMgmt, &bWakeUp);

            powerState.DeviceState = bDisplayAdapter ?
                fdoExtension->DevicePowerState:
                pdoExtension->DevicePowerState;

             //
             // Make sure not to power up the monitor if the override for
             // LCD panels is on.
             //

            if (bMonitor && pdoExtension->PowerOverride && 
               (irpStack->Parameters.Power.State.DeviceState < powerState.DeviceState)) {

                finalStatus = STATUS_SUCCESS;
                break;
            }

            //
            // If this is going to a more powered state. (i.e. waking up)
            // Send the IRP down the stack and then continue processing.
            // Since videoport is the bus driver for the monitors,
            // power down without sending the IRP to the device stack.
            //

            if (bDisplayAdapter &&
                (irpStack->Parameters.Power.State.DeviceState < powerState.DeviceState)) {

                pVideoDebugPrint ((1, "VideoPortPowerDispatch: PowerUp\n"));

                context.Event = &event;
                IoCopyCurrentIrpStackLocationToNext (Irp);

                IoSetCompletionRoutine(Irp,
                                       pVideoPortPowerUpComplete,
                                       &context,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                finalStatus = PoCallDriver(fdoExtension->AttachedDeviceObject, Irp);

                if (!NT_SUCCESS(finalStatus) || finalStatus == STATUS_PENDING) {

                    if (finalStatus != STATUS_PENDING) {

                        pVideoDebugPrint((0, "VideoPortPowerDispatch: Someone under us FAILED a set power???\n")) ;
                        ASSERT(FALSE);
                        break;

                    } else {

                        KeWaitForSingleObject(&event,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              NULL);
                    }

                } else {

                    context.Status = finalStatus;
                }

                finalStatus = STATUS_ALREADY_DISCONNECTED;

                //
                // End processing if the call to power up failed.
                //

                if (!NT_SUCCESS(context.Status)) {

                    pVideoDebugPrint ((0, "VideoPortPowerDispatch: Someone under us FAILED a powerup\n")) ;
                    break ;
                }
            }

            //
            // For OEMs like Toshiba, they want alway map sleep state to D3 due to a 
            // legal patent issue.  The patent prohibit them from using more than one
            // sleep state.
            //

            if (bMonitor &&
                fdoExtension->OverrideMonitorPower &&
                (vpPowerMgmt.PowerState >= VideoPowerStandBy) &&
                (vpPowerMgmt.PowerState < VideoPowerOff)) {

                vpPowerMgmt.PowerState = VideoPowerOff;
            }

            if ((deviceId == 0x110) &&
                (vpPowerMgmt.PowerState == VideoPowerOn))
            {
                //
                // If the new backlight control interface is implemented,
                //  set the backlight brightness level.
                //

                if ((pVpBacklightStatus->bNewAPISupported == TRUE) &&
                    (pVpBacklightStatus->bACBrightnessKnown == TRUE) &&
                    (VpRunningOnAC == TRUE))
                {
                    ulACPIMethodParam1= (ULONG) pVpBacklightStatus->ucACBrightness;
                    bSetBacklight = TRUE;
                }

                if ((pVpBacklightStatus->bNewAPISupported == TRUE) &&
                    (pVpBacklightStatus->bDCBrightnessKnown == TRUE) &&
                    (VpRunningOnAC == FALSE))
                {
                    ulACPIMethodParam1= (ULONG) pVpBacklightStatus->ucDCBrightness;
                    bSetBacklight = TRUE;
                }

                if ((bSetBacklight) && (LCDPanelDevice))
                {
                    AttachedDevice = IoGetAttachedDeviceReference(LCDPanelDevice);

                    // Not checking status here deliberately, as we're not failing
                    //  this IRP if this call fails.

                    if (AttachedDevice) {

                        pVideoPortACPIIoctl(
                            AttachedDevice,
                            (ULONG) ('MCB_'),
                            &ulACPIMethodParam1,
                            NULL,
                            0,
                            NULL);

                        ObDereferenceObject(AttachedDevice);
                    }
                }
            }

            //
            // Call the miniport.
            //

            pVideoDebugPrint((2, "VideoPortPowerDispatch: HwSetPowerState for video power state %d\n",
                             vpPowerMgmt.PowerState));

            ACQUIRE_DEVICE_LOCK(fdoExtension);

            vpStatus = fdoExtension->HwSetPowerState(fdoExtension->HwDeviceExtension,
                                                     deviceId,
                                                     &vpPowerMgmt);

            RELEASE_DEVICE_LOCK(fdoExtension);

            if (vpStatus != NO_ERROR) {

                pVideoDebugPrint((0, "VideoPortPowerDispatch: ERROR IN MINIPORT!\n"));
                pVideoDebugPrint((0, "VideoPortPowerDispatch: Miniport cannot refuse set power request\n"));

                //
                // Don't assert if shutdown - not all miniport drivers handle VideoPowerShutdown.
                // This code executes for devices not on the hibernation path during the shutdown.
                //

                if (!bShutdown)
                {
                    ASSERT(FALSE);
                }
            }

            //
            // Set the power state to let the system know that the power
            // state has been changed for the device.
            //

            PoSetPowerState(DeviceObject,
                            DevicePowerState,
                            irpStack->Parameters.Power.State);

            if (bDisplayAdapter) {

                fdoExtension->DevicePowerState =
                    irpStack->Parameters.Power.State.DeviceState;

            } else {

                pdoExtension->DevicePowerState =
                    irpStack->Parameters.Power.State.DeviceState;
            }

            //
            // Do some ACPI related stuff.
            //

            if (bDisplayAdapter && DoSpecificExtension->bACPI && (fdoExtension->DevicePowerState == PowerDeviceD0)) {

                //
                // If we received a Notify before SetPowerState, delay the action until now.
                //

                if (DoSpecificExtension->CachedEventID) {

                    pVideoPortACPIEventCallback(DoSpecificExtension, DoSpecificExtension->CachedEventID);

                } else if (bWakeUp) {

                    //
                    // On waking up from Hibernation, we simulate a notify(VGA, 0x90).
                    // This will also set _DOS(0).  Some machines don't keep _DOS value,
                    // So we have to set the value on waking up.
                    //

                    pVideoPortACPIEventCallback(DoSpecificExtension, 0x90);
                }
            }

            //
            // Set the final status if the IRP has not been passed down.
            // If the IRP has not been passed down yet, finalStatus is set
            // when it is passed down.
            //

            if (!bDisplayAdapter) {

                //
                // All PDO's must have STATUS_SUCCESS as a SET_POWER IRP
                // cannot fail.
                //

                finalStatus = STATUS_SUCCESS;
            }
        }

        break;

    default:

        //
        // Pass down requests we don't handle if this is an fdo, complete
        // the irp if it is a pdo.
        //

        if (bDisplayAdapter) {
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            return PoCallDriver(fdoExtension->AttachedDeviceObject, Irp);
        } else {
            PoStartNextPowerIrp(Irp);
            finalStatus = Irp->IoStatus.Status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return finalStatus;
        }
    }

    //
    // If status pending then just bail out of this routine
    // without completing anything as there is still an power
    // IRP outstanding. The completion routine takes care of
    // ensuring that the IRP is completed.
    //

    if (finalStatus != STATUS_PENDING) {

        //
        // Alert the system that the driver is ready for the next power IRP.
        //

        PoStartNextPowerIrp(Irp);

        //
        // All processing has been finished. Complete the IRP and get out.
        //

        if (bDisplayAdapter) {

            //
            // FDO Irps need to be sent to the bus driver. This path
            // indicates that it is an FDO Irp that has not already been
            // sent to the bus driver. (The only way it would have already
            // been sent is if this is an FDO power-up).
            //

            if (NT_SUCCESS(finalStatus)) {

                pVideoDebugPrint((1, "VideoPortPowerDispatch: Non-powerup FDO\n"));

                IoSkipCurrentIrpStackLocation (Irp);
                return PoCallDriver(fdoExtension->AttachedDeviceObject, Irp);

            } else if (finalStatus == STATUS_ALREADY_DISCONNECTED) {

                pVideoDebugPrint((2, "VideoPortPowerDispatch: Power iostatus modified, IRP already sent\n"));
                finalStatus = context.Status;
            }

            pVideoDebugPrint((2, "VideoPortPowerDispatch: Power fell through bDisplayAdapter\n")) ;
        }

        pVideoDebugPrint((1, "VideoPortPowerDispatch: Power completed with %x\n", finalStatus));

        Irp->IoStatus.Status = finalStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return finalStatus;
}

BOOLEAN
pVideoPortMapStoD(
    IN PVOID DeviceExtension,
    IN SYSTEM_POWER_STATE SystemState,
    OUT PDEVICE_POWER_STATE DeviceState
    )

/*++

Routine Description:

    This routine takes a system power state from a system power IRP and
    maps it to the correct D state for the device based on what is stored
    in its device extension.

Arguments:

    DeviceExtension - Points to either the FDO or PDO device extension.

    SystemState - The system power state being requested.

    DeviceState - A pointer to the location to store the device state.


Return Value:

    TRUE if successsful,
    FALSE otherwise.

--*/

{
    PFDO_EXTENSION combinedExtension = ((PFDO_EXTENSION)(DeviceExtension));
    
    if (combinedExtension->IsMappingReady != TRUE) {

        //
        // The mapping from system states to device states has not
        // happened yet. Package up a request to do this and send it
        // to the parent device stack.
        //

        PIRP irp;
        KEVENT event;
        PDEVICE_CAPABILITIES parentCapabilities;
        IO_STATUS_BLOCK statusBlock;
        PIO_STACK_LOCATION stackLocation;
        NTSTATUS status;
        UCHAR count;
        PDEVICE_OBJECT targetDevice;

        pVideoDebugPrint((1, "VideoPrt: No mapping ready. Creating mapping.\n"));
        
        if (IS_FDO(combinedExtension))  {
                targetDevice = combinedExtension->AttachedDeviceObject;
        } else {
                targetDevice = combinedExtension->pFdoExtension->AttachedDeviceObject;
        }

        //
        // Allocate memory for the device capabilities structure and
        // zero the memory.
        //

        parentCapabilities = ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,
                                                   sizeof (DEVICE_CAPABILITIES),
                                                   VP_TAG);

        if (parentCapabilities == NULL) {

            pVideoDebugPrint((0, "VideoPrt: Couldn't get memory for cap run.\n"));
            return FALSE;
        }

        RtlZeroMemory(parentCapabilities, sizeof (DEVICE_CAPABILITIES));
        parentCapabilities->Size = sizeof (DEVICE_CAPABILITIES) ;
        parentCapabilities->Version = 1 ;
        parentCapabilities->Address = -1 ;
        parentCapabilities->UINumber = -1 ;

        //
        // Prepare the IRP request.
        //

        KeInitializeEvent(&event, SynchronizationEvent, FALSE);

        irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                           targetDevice,
                                           NULL,
                                           0,
                                           NULL,
                                           &event,
                                           &statusBlock);

        if (irp == NULL) {

            pVideoDebugPrint((0, "VideoPrt: Couldn't get IRP for cap run.\n"));

            ExFreePool(parentCapabilities);
            return FALSE;
        }

        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        stackLocation = IoGetNextIrpStackLocation(irp);

        stackLocation->MajorFunction = IRP_MJ_PNP;
        stackLocation->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
        stackLocation->Parameters.DeviceCapabilities.Capabilities =
            parentCapabilities;

        status = IoCallDriver (targetDevice, irp);

        if (status == STATUS_PENDING) {

            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        }

        if (!(NT_SUCCESS(statusBlock.Status))) {

            pVideoDebugPrint ((0, "VideoPrt: Couldn't get parent caps.\n"));

        } else {

            for (count = PowerSystemUnspecified;
                 count < PowerSystemMaximum;
                 count++) {

#if DBG
                static PUCHAR SystemState[] = {"PowerSystemUnspecified",
                                               "PowerSystemWorking",
                                               "PowerSystemSleeping1",
                                               "PowerSystemSleeping2",
                                               "PowerSystemSleeping3",
                                               "PowerSystemHibernate",
                                               "PowerSystemShutdown",
                                               "PowerSystemMaximum"};

                static PUCHAR DeviceState[] = {"PowerDeviceUnspecified",
                                               "PowerDeviceD0",
                                               "PowerDeviceD1",
                                               "PowerDeviceD2",
                                               "PowerDeviceD3",
                                               "PowerDeviceMaximum"};

#endif

                combinedExtension->DeviceMapping[count] =
                    parentCapabilities->DeviceState[count];


#if DBG
                pVideoDebugPrint((1, "Mapping %s = %s\n",
                                  SystemState[count],
                                  DeviceState[combinedExtension->DeviceMapping[count]]));
#endif
            }

            //
            // For monitor devices, make sure to map not to D0 for any sleep state.
            //

            if (IS_PDO(combinedExtension) &&
                (((PCHILD_PDO_EXTENSION)(DeviceExtension))->VideoChildDescriptor->Type == Monitor))
            {
                for (count = PowerSystemSleeping1;
                     count <= PowerSystemSleeping3;
                     count++)
                {
                    if ((combinedExtension->DeviceMapping[count] == PowerDeviceD0) ||
                        (combinedExtension->pFdoExtension->OverrideMonitorPower))
                    {
                        pVideoDebugPrint((1, "Override sleep %d to D3\n", count)) ;
                        combinedExtension->DeviceMapping[count] = PowerDeviceD3 ;
                    }
                }
            }
        }

        ExFreePool(parentCapabilities);

        if (!NT_SUCCESS(statusBlock.Status)) {
            return FALSE;
        }

        combinedExtension->IsMappingReady = TRUE ;
    }

    //
    // Return the mapping now.
    //

    *DeviceState = combinedExtension->DeviceMapping[SystemState];
    return TRUE;
}

VOID
pVideoPortPowerIrpComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
)

/*++

Routine Description:

    This is a power management IRP completion routine that is set
    each time video requests a device power IRP in response to a
    system power IRP.

Arguments:

    DeviceObject - Points to the device object that initiated the IRP
    MinorFunction - Specified the minor function code of the completed IRP
    PowerState - Specifies the power state passed to PoRequestPowerIrp
    Context - Specifies the IRP that was pended waiting for this completion
              routine to fire
    IoStatus - Points to the IoStatus block in the completed IRP

Return Value:

    None.
--*/

{
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension ;
    PIRP irp = (PIRP) Context ;

    if (Context == NULL) {

        //
        // This is the fall through case. Since we have no IRP this
        // is just a place holder since callers of PoRequestPowerIrp
        // must specify a completion routine.
        //

        return;
    }

    //
    // Set the status in the IRP
    //

    irp->IoStatus.Status = IoStatus->Status;

    pVideoDebugPrint((2, "VideoPrt: Power completion Irp status: %X\n",
                         IoStatus->Status));

    //
    // Indicate to the system that videoprt is ready for the next
    // power IRP.
    //

    PoStartNextPowerIrp(irp);

    //
    // If this is an FDO, then pass the IRP down to the bus driver.
    //

    if (IS_FDO((PFDO_EXTENSION)(DeviceObject->DeviceExtension)) &&
        NT_SUCCESS(IoStatus->Status)) {

        pVideoDebugPrint((2, "VideoPrt: Completion passing down.\n"));

        IoSkipCurrentIrpStackLocation(irp);
        PoCallDriver(fdoExtension->AttachedDeviceObject, irp);

    } else {

        pVideoDebugPrint((2, "VideoPrt: Completion not passing down.\n"));

        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
}

NTSTATUS
pVideoPortPowerUpComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
)

/*++

Routine Description:

    This is an IRP completion routine that is set when a IRP must be
    passed down the device stack before videoport acts on it. (A power
    up case. The bus must be powered before the device.)

Arguments:

    DeviceObject - Points to the device object of the owner of the
                   completion routine
    Irp - Points to the IRP being completed
    Context - Specifies a videoport-defined context of POWER_BLOCK

Return Value:

    Always returns STATUS_MORE_PROCESSING_REQUIRED to stop further
    completion of the IRP.

--*/

{
    PPOWER_BLOCK block = (PPOWER_BLOCK)Context;

    block->Status = Irp->IoStatus.Status;
    KeSetEvent(block->Event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


PCM_PARTIAL_RESOURCE_DESCRIPTOR
RtlUnpackPartialDesc(
    IN UCHAR Type,
    IN PCM_RESOURCE_LIST ResList,
    IN OUT PULONG Count
    )
/*++

Routine Description:

    Pulls out a pointer to the partial descriptor you're interested in

Arguments:

    Type - CmResourceTypePort, ...
    ResList - The list to search
    Count - Points to the index of the partial descriptor you're looking
            for, gets incremented if found, i.e., start with *Count = 0,
            then subsequent calls will find next partial, make sense?

Return Value:

    Pointer to the partial descriptor if found, otherwise NULL

--*/
{
    ULONG i, j, hit;

    hit = 0;
    for (i = 0; i < ResList->Count; i++) {
        for (j = 0; j < ResList->List[i].PartialResourceList.Count; j++) {
            if (ResList->List[i].PartialResourceList.PartialDescriptors[j].Type == Type) {
                if (hit == *Count) {
                    (*Count)++;
                    return &ResList->List[i].PartialResourceList.PartialDescriptors[j];
                } else {
                    hit++;
                }
            }
        }
    }

    return NULL;
}

NTSTATUS
pVideoPortSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles SystemControl Irps.

Arguments:

    DeviceObject - The device object.

    Irp - The system control Irp.

Returns:

    Status

Notes:

    This function will simply complete the irp if we are handling for the PDO,
    or send the irp down if the device object is an FDO.

--*/

{
    NTSTATUS status;

    if (IS_PDO(DeviceObject->DeviceExtension)) {

        status = Irp->IoStatus.Status;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

    } else {

        PFDO_EXTENSION fdoExtension = (PFDO_EXTENSION)DeviceObject->DeviceExtension;

        IoCopyCurrentIrpStackLocationToNext(Irp);

        status = IoCallDriver(fdoExtension->AttachedDeviceObject, Irp);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\port\pedid.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

  pedid.h

Abstract:

    This is the NT Video port EDID header. It contains the definitions for
    the EDID industry standard Extended Display Identification Data structure
    as well as macros for accessing the fields of that data structure.

Author:

    Bruce McQuistan (brucemc) 20-Sept-1996

Environment:

    kernel mode only

Notes:

    Based on VESA EDID Specification Version 2, April 9th, 1996

Revision History:

--*/

//
//  Form of type stored in display ROM.
//

#pragma pack(1)
typedef struct __EDID_V1 {
    UCHAR   UC_Header[8];
    UCHAR   UC_OemIdentification[10];
    UCHAR   UC_Version[2];
    UCHAR   UC_BasicDisplayParameters[5];
    UCHAR   UC_ColorCharacteristics[10];
    UCHAR   UC_EstablishedTimings[3];
    USHORT  US_StandardTimingIdentifications[8];
    UCHAR   UC_Detail1[18];
    UCHAR   UC_Detail2[18];
    UCHAR   UC_Detail3[18];
    UCHAR   UC_Detail4[18];
    UCHAR   UC_ExtensionFlag;
    UCHAR   UC_CheckSum;
} EDID_V1, *PEDID_V1;
#pragma pack()

#pragma pack(1)
typedef struct __EDID_V2 {
    UCHAR   UC_Header[8];
    UCHAR   UC_OemIdentification[32];
    UCHAR   UC_SerialNumber[16];
    UCHAR   UC_Reserved1[8];
    UCHAR   UC_DisplayInterfaceParameters[15];
    UCHAR   UC_DisplayDeviceDescription[5];
    UCHAR   UC_DisplayResponseTime[2];
    UCHAR   UC_ColorLuminanceDescription[28];
    UCHAR   UC_DisplaySpatialDescription[10];
    UCHAR   UC_Reserved2[1];
    UCHAR   UC_GTFSupportInformation[1];
    UCHAR   UC_MapOfTimingInformation[2];
    UCHAR   UC_LuminanceTable[127];
    UCHAR   UC_CheckSum;
} EDID_V2, *PEDID_V2;
#pragma pack()

//
//  EDID decoding routines
//

//
//  Useful Bit manifest constants
//

#define EDIDBITNONE     0x00
#define EDIDBIT0        0x01
#define EDIDBIT1        0x02
#define EDIDBIT2        0x04
#define EDIDBIT3        0x08
#define EDIDBIT4        0x10
#define EDIDBIT5        0x20
#define EDIDBIT6        0x40
#define EDIDBIT7        0x80
#define EDIDBIT8        0x100
#define EDIDBIT9        0x200


//
//  3.4) XFER_CHARACTERISTIC is gamma*100 - 100, so invert in USER.
//  NOTE: This must be called from USER.
//
#define USER_CONVERT_TO_GAMMA(achar) \
    (achar + 100)/100

//
//  4.1) Chromaticity Coordinates Format macro. Use these to convert
//  from the binary format to the actual decimal representation.
//  NOTE: can only be called from USER.
//

#define USER_CONVERT_CHROMATICITY_FROM_BINARY_TO_DECIMAL(ashort)          \
    (ashort & EDIDBIT9)*(1/2) + (ashort & EDIDBIT8)*(1/4) +     \
    (ashort & EDIDBIT7)*(1/8) + (ashort & EDIDBIT6)*(1/16) +    \
    (ashort & EDIDBIT5)*(1/32) + (ashort & EDIDBIT4)*(1/64) +   \
    (ashort & EDIDBIT3)*(1/128) + (ashort & EDIDBIT2)*(1/256) + \
    (ashort & EDIDBIT1)*(1/512) + (ashort & EDIDBIT0)*(1/1024)

//
//  5.1) Macros for USER to decode the bitfields
//
//
// TIMING_I
#define USER_TIMING_I_IS_720x400x70HZ(timing1)  timing1 & EDIDBIT7
#define USER_TIMING_I_IS_720x400x88HZ(timing1)  timing1 & EDIDBIT6
#define USER_TIMING_I_IS_640x480x60HZ(timing1)  timing1 & EDIDBIT5
#define USER_TIMING_I_IS_640x480x67HZ(timing1)  timing1 & EDIDBIT4
#define USER_TIMING_I_IS_640x480x72HZ(timing1)  timing1 & EDIDBIT3
#define USER_TIMING_I_IS_640x480x75HZ(timing1)  timing1 & EDIDBIT2
#define USER_TIMING_I_IS_800x600x56HZ(timing1)  timing1 & EDIDBIT1
#define USER_TIMING_I_IS_800x600x60HZ(timing1)  timing1 & EDIDBIT0

// TIMING_II

#define USER_TIMING_II_IS_800x600x72HZ(timing2)      timing2 & EDIDBIT7
#define USER_TIMING_II_IS_800x600x75HZ(timing2)      timing2 & EDIDBIT6
#define USER_TIMING_II_IS_720x624x75HZ(timing2)      timing2 & EDIDBIT5
#define USER_TIMING_II_IS_1024x768x87HZ(timing2)     timing2 & EDIDBIT4
#define USER_TIMING_II_IS_1024x768x60HZ(timing2)     timing2 & EDIDBIT3
#define USER_TIMING_II_IS_1024x768x70HZ(timing2)     timing2 & EDIDBIT2
#define USER_TIMING_II_IS_1024x768x75HZ(timing2)     timing2 & EDIDBIT1
#define USER_TIMING_II_IS_1280x1024x75HZ(timing2)    timing2 & EDIDBIT0

// TIMING_III

#define USER_TIMING_III_IS_1152x870x75HZ(timing3)   timing3 & EDIDBIT7
#define USER_TIMING_III_IS_RESERVED1(timing3)       timing3 & EDIDBIT6
#define USER_TIMING_III_IS_RESERVED2(timing3)       timing3 & EDIDBIT5
#define USER_TIMING_III_IS_RESERVED3(timing3)       timing3 & EDIDBIT4
#define USER_TIMING_III_IS_RESERVED4(timing3)       timing3 & EDIDBIT3
#define USER_TIMING_III_IS_RESERVED5(timing3)       timing3 & EDIDBIT2
#define USER_TIMING_III_IS_RESERVED6(timing3)       timing3 & EDIDBIT1
#define USER_TIMING_III_IS_RESERVED7(timing3)       timing3 & EDIDBIT0


//
//  Function Prototypes exposed,
//

typedef enum    {
    Undefined,
    NonRGB,
    IsRGB,
    IsMonochrome
    }   DISPLAY_TYPE, *PDISPLAY_TYPE;





//
//  0) Header Macros
//
#define GET_HEADER_BYTE(pEdid, x)     pEdid->UC_Header[x]

/////////////////////////////////////////////
//  1) Oem_Identification macros
//

#define GET_EDID_OEM_ID_NAME(pEdid)  \
    *(UNALIGNED USHORT *)(&(pEdid->UC_OemIdentification[0]))

#define GET_EDID_OEM_PRODUCT_CODE(pEdid)  \
    *(UNALIGNED USHORT *)(&(pEdid->UC_OemIdentification[2]))

#define GET_EDID_OEM_SERIAL_NUMBER(pEdid)  \
    *(UNALIGNED ULONG *)(&(pEdid->UC_OemIdentification[4]))

#define GET_EDID_OEM_WEEK_MADE(pEdid)    pEdid->UC_OemIdentification[8]
#define GET_EDID_OEM_YEAR_MADE(pEdid)    pEdid->UC_OemIdentification[9]


/////////////////////////////////////////////
//  2) EDID Version macros
//

#define GET_EDID_VERSION(pEdid)     pEdid->UC_Version[0]
#define GET_EDID_REVISION(pEdid)    pEdid->UC_Version[1]


/////////////////////////////////////////////
//  3) EDID Basic Display Feature macros
//

#define GET_EDID_INPUT_DEFINITION(pEdid)    pEdid->UC_BasicDisplayParameters[0]
#define GET_EDID_MAX_X_IMAGE_SIZE(pEdid)    pEdid->UC_BasicDisplayParameters[1]
#define GET_EDID_MAX_Y_IMAGE_SIZE(pEdid)    pEdid->UC_BasicDisplayParameters[2]
#define GET_EDID_DISPLAY_XFER_CHAR(pEdid)   pEdid->UC_BasicDisplayParameters[3]
#define GET_EDID_FEATURE_SUPPORT(pEdid)     pEdid->UC_BasicDisplayParameters[4]

//
//  3.1) INPUT_DEFINITION masks.
//

#define INPUT_DEF_PULSE_REQUIRED_SYNC_MASK      EDIDBIT0
#define INPUT_DEF_GREEN_SYNC_SUPORTED_MASK      EDIDBIT1
#define INPUT_DEF_COMPOSITE_SYNC_SUPORTED_MASK  EDIDBIT2
#define INPUT_DEF_SEPARATE_SYNC_SUPPORTED_MASK  EDIDBIT3
#define INPUT_DEF_SETUP_BLANK_TO_BLACK_MASK     EDIDBIT4
#define INPUT_DEF_SIGNAL_LEVEL_STANDARD_MASK    (EDIDBIT5 | EDIDBIT6)
#define INPUT_DEF_DIGITAL_LEVEL_MASK            EDIDBIT7

//
//  3.1a) SIGNAL_LEVEL_STANDARD macros
//

typedef enum {
    POINT7_TO_POINT3,
    POINT714_TO_POINT286,
    ONE_TO_POINT4,
    POINT7_TO_0
    } SIGNAL_LEVEL, *PSIGNAL_LEVEL;

#define SIGNAL_LEVEL_IS_POINT7_TO_POINT3      EDIDBITNONE
#define SIGNAL_LEVEL_IS_POINT714_TO_POINT286  EDIDBIT5
#define SIGNAL_LEVEL_IS_1_TO_POINT4           EDIDBIT6
#define SIGNAL_LEVEL_IS_POINT7_TO_0           (EDIDBIT6 | EDIDBIT5)

//
//  3.2) Hoizontal IMAGE_SIZE is value of byte in centimeters.
//  3.3) Vertical IMAGE_SIZE is value of byte in centimeters.
//

//
//  3.4) XFER_CHARACTERISTIC is gamma*100 - 100, so invert in USER.
//  NOTE: This must be called from USER, so is in edid.h
//
//#define USER_CONVERT_TO_GAMMA(achar) \
//    (achar + 100)/100


//
//  3.5) FEATURE_SUPPORT masks
//

#define FEATURE_RESERVED_0_MASK     EDIDBIT0
#define FEATURE_RESERVED_1_MASK     EDIDBIT1
#define FEATURE_RESERVED_2_MASK     EDIDBIT2
#define FEATURE_DISPLAY_TYPE_MASK   (EDIDBIT3|EDIDBIT4)
#define FEATURE_ACTIVE_OFF_MASK     EDIDBIT5
#define FEATURE_SUSPEND_MASK        EDIDBIT6
#define FEATURE_STANDBY_MASK        EDIDBIT7

#define FEATURE_DISPLAY_TYPE_IS_UNDEFINED(x)    \
    ((x)&FEATURE_DISPLAY_TYPE_MASK) == FEATURE_DISPLAY_TYPE_MASK

#define FEATURE_DISPLAY_TYPE_IS_NON_RGB(x)      \
    ((x)&FEATURE_DISPLAY_TYPE_MASK) == EDIDBIT4

#define FEATURE_DISPLAY_TYPE_IS_RGB(x)          \
    ((x)&FEATURE_DISPLAY_TYPE_MASK) == EDIDBIT3

#define FEATURE_DISPLAY_TYPE_IS_MONOCHROME(x)   \
    ((x)&FEATURE_DISPLAY_TYPE_MASK) == EDIDBITNONE

//
//  Another copy of the data stucture for reference.
//
//
// typedef struct _EDID {
//    UCHAR   UC_Header[8];
//    UCHAR   UC_OemIdentification[10];
//    UCHAR   UC_Version[2];
//    UCHAR   UC_BasicDisplayParameters[5];
//    UCHAR   UC_ColorCharacteristics[10];
//    UCHAR   UC_EstablishedTimings[3];
//    USHORT  US_StandardTimingIdentifications[8];
//    UCHAR   UC_Detail1[18];
//    UCHAR   UC_Detail2[18];
//    UCHAR   UC_Detail3[18];
//    UCHAR   UC_Detail4[18];
//    UCHAR   UC_ExtensionFlag;
//    UCHAR   UC_CheckSum;
// } EDID, *PEDID;
//
/////////////////////////////////////////////
//  4) Color Characteristics - weird. The deal is that the first byte
//      in this array is the red and green low order bits. The next byte is
//      the blue and white low order bits. The remainder are the high order
//      bits of the colors.
//

#define GET_EDID_COLOR_CHAR_RG_LOW(pEdid)   pEdid->UC_ColorCharacteristics[0]
#define GET_EDID_COLOR_CHAR_RX_HIGH(pEdid)  pEdid->UC_ColorCharacteristics[2]
#define GET_EDID_COLOR_CHAR_RY_HIGH(pEdid)  pEdid->UC_ColorCharacteristics[3]
#define GET_EDID_COLOR_CHAR_GX_HIGH(pEdid)  pEdid->UC_ColorCharacteristics[4]
#define GET_EDID_COLOR_CHAR_GY_HIGH(pEdid)  pEdid->UC_ColorCharacteristics[5]

#define GET_RED_X_COLOR_CHARS(pEdid, lowbyte, highbyte)         \
            do  {                                               \
                lowbyte  = GET_EDID_COLOR_CHAR_RG_LOW(pEdid);   \
                lowbyte &= (EDIDBIT6 | EDIDBIT7);               \
                highbyte = GET_EDID_COLOR_CHAR_RX_HIGH(pEdid);  \
            }   while (0)


#define GET_RED_Y_COLOR_CHARS(pEdid, lowbyte, highbyte)         \
            do  {                                               \
                lowbyte  = GET_EDID_COLOR_CHAR_RG_LOW(pEdid);   \
                lowbyte &= (EDIDBIT4 | EDIDBIT5);               \
                highbyte = GET_EDID_COLOR_CHAR_RY_HIGH(pEdid);  \
            }   while (0)


#define GET_GREEN_X_COLOR_CHARS(pEdid, lowbyte, highbyte)       \
            do  {                                               \
                lowbyte  = GET_EDID_COLOR_CHAR_RG_LOW(pEdid);   \
                lowbyte &= (EDIDBIT2 | EDIDBIT3);               \
                highbyte = GET_EDID_COLOR_CHAR_GX_HIGH(pEdid);  \
            }   while (0)


#define GET_GREEN_Y_COLOR_CHARS(pEdid, lowbyte, highbyte)       \
            do  {                                               \
                lowbyte  = GET_EDID_COLOR_CHAR_RG_LOW(pEdid);   \
                lowbyte &= (EDIDBIT0 | EDIDBIT1);               \
                highbyte = GET_EDID_COLOR_CHAR_GY_HIGH(pEdid);  \
            }   while (0)

#define GET_EDID_COLOR_CHAR_BW_LOW(pEdid)   pEdid->UC_ColorCharacteristics[1]
#define GET_EDID_COLOR_CHAR_BX_HIGH(pEdid)  pEdid->UC_ColorCharacteristics[6]
#define GET_EDID_COLOR_CHAR_BY_HIGH(pEdid)  pEdid->UC_ColorCharacteristics[7]
#define GET_EDID_COLOR_CHAR_WX_HIGH(pEdid)  pEdid->UC_ColorCharacteristics[8]
#define GET_EDID_COLOR_CHAR_WY_HIGH(pEdid)  pEdid->UC_ColorCharacteristics[9]

#define GET_BLUE_X_COLOR_CHARS(pEdid, lowbyte, highbyte)        \
            do  {                                               \
                lowbyte  = GET_EDID_COLOR_CHAR_BW_LOW(pEdid);   \
                lowbyte &= (EDIDBIT6 | EDIDBIT7);               \
                highbyte = GET_EDID_COLOR_CHAR_BX_HIGH(pEdid);  \
            }   while (0)


#define GET_BLUE_Y_COLOR_CHARS(pEdid, lowbyte, highbyte)        \
            do  {                                               \
                lowbyte  = GET_EDID_COLOR_CHAR_RG_LOW(pEdid);   \
                lowbyte &= (EDIDBIT4 | EDIDBIT5);               \
                highbyte = GET_EDID_COLOR_CHAR_BY_HIGH(pEdid);  \
            }   while (0)

#define GET_WHITE_X_COLOR_CHARS(pEdid, lowbyte, highbyte)       \
            do  {                                               \
                lowbyte  = GET_EDID_COLOR_CHAR_BW_LOW(pEdid);   \
                lowbyte &= (EDIDBIT2 | EDIDBIT3);               \
                highbyte = GET_EDID_COLOR_CHAR_WX_HIGH(pEdid);  \
            }   while (0)


#define GET_WHITE_Y_COLOR_CHARS(pEdid, lowbyte, highbyte)       \
            do  {                                               \
                lowbyte  = GET_EDID_COLOR_CHAR_RG_LOW(pEdid);   \
                lowbyte &= (EDIDBIT0 | EDIDBIT1);               \
                highbyte = GET_EDID_COLOR_CHAR_WY_HIGH(pEdid);  \
            }   while (0)


//
//  4.1) Chromaticity Coordinates Format macro. Use these to convert
//  from the binary format to the actual decimal representation.
//  NOTE: can only be called from USER.
//
//
//#define USER_CONVERT_CHROMATICITY_FROM_BINARY_TO_DECIMAL(ashort)          \
//    (ashort & EDIDBIT9)*(1/2) + (ashort & EDIDBIT8)*(1/4) +     \
//    (ashort & EDIDBIT7)*(1/8) + (ashort & EDIDBIT6)*(1/16) +    \
//    (ashort & EDIDBIT5)*(1/32) + (ashort & EDIDBIT4)*(1/64) +   \
//    (ashort & EDIDBIT3)*(1/128) + (ashort & EDIDBIT2)*(1/256) + \
//    (ashort & EDIDBIT1)*(1/512) + (ashort & EDIDBIT0)*(1/1024)
//
//
//  Another copy of the data stucture for reference.
//
//
// typedef struct _EDID {
//    UCHAR   UC_Header[8];
//    UCHAR   UC_OemIdentification[10];
//    UCHAR   UC_Version[2];
//    UCHAR   UC_BasicDisplayParameters[5];
//    UCHAR   UC_ColorCharacteristics[10];
//    UCHAR   UC_EstablishedTimings[3];
//    USHORT  US_StandardTimingIdentifications[8];
//    UCHAR   UC_Detail1[18];
//    UCHAR   UC_Detail2[18];
//    UCHAR   UC_Detail3[18];
//    UCHAR   UC_Detail4[18];
//    UCHAR   UC_ExtensionFlag;
//    UCHAR   UC_CheckSum;
// } EDID, *PEDID;
//

/////////////////////////////////////////////
//  5) Established Timings
//      These are bitfields indicating the types of timings supported.
//
#define GET_EDID_ESTABLISHED_TIMING_I(pEdid)     pEdid->UC_EstablishedTimings[0]
#define GET_EDID_ESTABLISHED_TIMING_II(pEdid)    pEdid->UC_EstablishedTimings[1]
#define GET_EDID_ESTABLISHED_TIMING_III(pEdid)   pEdid->UC_EstablishedTimings[2]

//
//  5.1) Macros for USER to decode the bitfields
//  Also defined in edid.h
//
// TIMING_I
// #define USER_TIMING_I_IS_720x400x70HZ(timing1)  timing1 & EDIDBIT7
// #define USER_TIMING_I_IS_720x400x88HZ(timing1)  timing1 & EDIDBIT6
// #define USER_TIMING_I_IS_640x480x60HZ(timing1)  timing1 & EDIDBIT5
// #define USER_TIMING_I_IS_640x480x67HZ(timing1)  timing1 & EDIDBIT4
// #define USER_TIMING_I_IS_640x480x72HZ(timing1)  timing1 & EDIDBIT3
// #define USER_TIMING_I_IS_640x480x75HZ(timing1)  timing1 & EDIDBIT2
// #define USER_TIMING_I_IS_800x600x56HZ(timing1)  timing1 & EDIDBIT1
// #define USER_TIMING_I_IS_800x600x60HZ(timing1)  timing1 & EDIDBIT0
//
// // TIMING_II
//
// #define USER_TIMING_II_IS_800x600x72HZ(timing2)      timing2 & EDIDBIT7
// #define USER_TIMING_II_IS_800x600x75HZ(timing2)      timing2 & EDIDBIT6
// #define USER_TIMING_II_IS_832x624x75HZ(timing2)      timing2 & EDIDBIT5 // MAC only
// #define USER_TIMING_II_IS_1024x768x87HZ(timing2)     timing2 & EDIDBIT4
// #define USER_TIMING_II_IS_1024x768x60HZ(timing2)     timing2 & EDIDBIT3
// #define USER_TIMING_II_IS_1024x768x70HZ(timing2)     timing2 & EDIDBIT2
// #define USER_TIMING_II_IS_1024x768x75HZ(timing2)     timing2 & EDIDBIT1
// #define USER_TIMING_II_IS_1280x1024x75HZ(timing2)    timing2 & EDIDBIT0
//
// TIMING_III
//
// #define USER_TIMING_III_IS_1152x870x75HZ(timing3)   timing3 & EDIDBIT7  // MAC only
// #define USER_TIMING_III_IS_RESERVED1(timing3)       timing3 & EDIDBIT6
// #define USER_TIMING_III_IS_RESERVED2(timing3)       timing3 & EDIDBIT5
// #define USER_TIMING_III_IS_RESERVED3(timing3)       timing3 & EDIDBIT4
// #define USER_TIMING_III_IS_RESERVED4(timing3)       timing3 & EDIDBIT3
// #define USER_TIMING_III_IS_RESERVED5(timing3)       timing3 & EDIDBIT2
// #define USER_TIMING_III_IS_RESERVED6(timing3)       timing3 & EDIDBIT1
// #define USER_TIMING_III_IS_RESERVED7(timing3)       timing3 & EDIDBIT0
//

//
//  Another copy of the data stucture for reference.
//
//
// typedef struct _EDID {
//    UCHAR   UC_Header[8];
//    UCHAR   UC_OemIdentification[10];
//    UCHAR   UC_Version[2];
//    UCHAR   UC_BasicDisplayParameters[5];
//    UCHAR   UC_ColorCharacteristics[10];
//    UCHAR   UC_EstablishedTimings[3];
//    USHORT  US_StandardTimingIdentifications[8];
//    UCHAR   UC_Detail1[18];
//    UCHAR   UC_Detail2[18];
//    UCHAR   UC_Detail3[18];
//    UCHAR   UC_Detail4[18];
//    UCHAR   UC_ExtensionFlag;
//    UCHAR   UC_CheckSum;
// } EDID, *PEDID;
//

/////////////////////////////////////////////
//  6) Standard Timing Identifications
//
//      Has horizontal (x) active pixel count as lower byte, refresh rate
//      as first 6 bits of upper byte and, image aspect ratio as remaining
//      two bits in upper byte.
//
// Get standard timing ids
#define GET_EDID_STANDARD_TIMING_ID(pEdid, x)   \
    pEdid->US_StandardTimingIdentifications[x]


#define EDIDBIT14       0x4000
#define EDIDBIT15       0x8000

// Decode Horizontal active pixel range bits.
#define GET_X_ACTIVE_PIXEL_RANGE(ushort)   ((ushort&0xff)+ 31) * 8

// Decode Aspect ratio bits.
#define IS_ASPECT_RATIO_1_TO_1(ushort)      \
    (!(ushort & EDIDBIT14) && !(ushort & EDIDBIT15))

#define IS_ASPECT_RATIO_4_TO_3(ushort)      \
    ((ushort & EDIDBIT14) && !(ushort & EDIDBIT15))

#define IS_ASPECT_RATIO_5_TO_4(ushort)      \
    (!(ushort & EDIDBIT14) && (ushort & EDIDBIT15))

#define IS_ASPECT_RATIO_16_TO_9(ushort)     \
    ((ushort & EDIDBIT14) && (ushort & EDIDBIT15))

#define GET_HZ_REFRESH_RATE(ushort)         \
    ((ushort & 0x3f) + 60)

//
//  Another copy of the data stucture for reference.
//
//
// typedef struct _EDID {
//    UCHAR   UC_Header[8];
//    UCHAR   UC_OemIdentification[10];
//    UCHAR   UC_Version[2];
//    UCHAR   UC_BasicDisplayParameters[5];
//    UCHAR   UC_ColorCharacteristics[10];
//    UCHAR   UC_EstablishedTimings[3];
//    USHORT  US_StandardTimingIdentifications[8];
//    UCHAR   UC_Detail1[18];
//    UCHAR   UC_Detail2[18];
//    UCHAR   UC_Detail3[18];
//    UCHAR   UC_Detail4[18];
//    UCHAR   UC_ExtensionFlag;
//    UCHAR   UC_CheckSum;
// } EDID, *PEDID;
//


/////////////////////////////////////////////
//  7) Detailed Timing Description
//
//      Too ugly for words. See macros. Note that these fields in
//      the EDID can either be these data structures or a monitor
//      description data structure. If the first two bytes are 0x0000
//      then it's a monitor descriptor.
//
//
//
#define GET_EDID_PDETAIL1(pEdid)     &(pEdid->UC_Detail1)
#define GET_EDID_PDETAIL2(pEdid)     &(pEdid->UC_Detail2)
#define GET_EDID_PDETAIL3(pEdid)     &(pEdid->UC_Detail3)
#define GET_EDID_PDETAIL4(pEdid)     &(pEdid->UC_Detail4)

typedef struct __DETAILED_TIMING_DESCRIPTION {
    UCHAR       PixelClock[2];
    UCHAR       XLowerActive;
    UCHAR       XLowerBlanking;
    UCHAR       XUpper;
    UCHAR       YLowerActive;
    UCHAR       YLowerBlanking;
    UCHAR       YUpper;
    UCHAR       XLowerSyncOffset;
    UCHAR       XLowerSyncPulseWidth;
    UCHAR       YLowerSyncOffsetLowerPulseWidth;
    UCHAR       XSyncOffsetPulseWidth_YSyncOffsetPulseWidth;
    UCHAR       XSizemm;
    UCHAR       YSizemm;
    UCHAR       XYSizemm;
    UCHAR       XBorderpxl;
    UCHAR       YBorderpxl;
    UCHAR       Flags;
    } DETAILED_TIMING_DESCRIPTION, *PDETAILED_TIMING_DESCRIPTION;


#define GET_DETAIL_PIXEL_CLOCK(pDetail, ushort) \
    do  {                                       \
        ushort   = pDetail->PixelClock[0];      \
        ushort <<= 8;                           \
        ushort  |= pDetail->PixelClock[1];      \
    } while (0)

#define GET_DETAIL_X_ACTIVE(pDetailedTimingDesc, ushort)\
    do  {                                               \
        ushort   = pDetailedTimingDesc->XUpper;         \
        ushort  &= 0xf0;                                \
        ushort <<= 4;                                   \
        ushort  |= pDetailedTimingDesc->XLowerActive;   \
    } while (0)

#define GET_DETAIL_X_BLANKING(pDetailedTimingDesc, ushort)     \
    do  {                                               \
        ushort    = pDetailedTimingDesc->XUpper;        \
        ushort   &= 0xf;                                \
        ushort  <<= 8;                                  \
        ushort   |= pDetailedTimingDesc->XLowerBlanking;\
    } while (0)

#define GET_DETAIL_Y_ACTIVE(pDetailedTimingDesc, ushort)\
    do  {                                               \
        ushort   = pDetailedTimingDesc->YUpper;         \
        ushort  &= 0xf0;                                \
        ushort <<= 4;                                   \
        ushort  |= pDetailedTimingDesc->YLowerActive;   \
    } while (0)

#define GET_DETAIL_Y_BLANKING(pDetailedTimingDesc, ushort)     \
    do  {                                               \
        ushort    = pDetailedTimingDesc->YUpper;        \
        ushort   &= 0xf;                                \
        ushort  <<= 8;                                  \
        ushort   |= pDetailedTimingDesc->YLowerBlanking;\
    } while (0)

#define GET_DETAIL_X_SYNC_OFFSET(pDetailedTimingDesc, ushort)           \
    do  {                                                               \
        ushort    = pDetailedTimingDesc->XSyncOffsetPulseWidth_YSyncOffsetPulseWidth;        \
        ushort  >>= 6;                                                  \
        ushort  <<= 8;                                                  \
        ushort   |= pDetailedTimingDesc->XLowerSyncOffset;              \
    } while (0)

#define GET_DETAIL_X_SYNC_PULSEWIDTH(pDetailedTimingDesc, ushort)       \
    do  {                                                               \
        ushort    = pDetailedTimingDesc->XSyncOffsetPulseWidth_YSyncOffsetPulseWidth;        \
        ushort  >>= 4;                                                  \
        ushort   &= (EDIDBIT0|EDIDBIT1);                                \
        ushort  <<= 8;                                                  \
        ushort   |= pDetailedTimingDesc->XLowerSyncPulseWidth;          \
    } while (0)

#define GET_DETAIL_Y_SYNC_OFFSET(pDetailedTimingDesc, ushort)           \
    do  {                                                               \
        ushort    = pDetailedTimingDesc->XSyncOffsetPulseWidth_YSyncOffsetPulseWidth;        \
        ushort  >>= 2;                                                  \
        ushort   &= (EDIDBIT0|EDIDBIT1);                                \
        ushort  <<= 12;                                                 \
        ushort   |= pDetailedTimingDesc->YLowerSyncOffsetLowerPulseWidth;\
        ushort  >>= 4;                                                  \
    } while (0)

#define GET_DETAIL_Y_SYNC_PULSEWIDTH(pDetailedTimingDesc, ushort)       \
    do  {                                                               \
        ushort    = pDetailedTimingDesc->XSyncOffsetPulseWidth_YSyncOffsetPulseWidth;        \
        ushort   &= (EDIDBIT0|EDIDBIT1);                                \
        ushort  <<= 8;                                                  \
        ushort   |= (pDetailedTimingDesc->YLowerSyncOffsetLowerPulseWidth & 0xf);  \
    } while (0)

#define GET_DETAIL_X_SIZE_MM(pDetailedTimingDesc, ushort)   \
    do  {                                                   \
        ushort  |= pDetailedTimingDesc->XYSizemm;           \
        ushort >>= 4;                                       \
        ushort <<= 8;                                       \
        ushort  |= pDetailedTimingDesc->XSizemm;            \
    } while (0)

#define GET_DETAIL_Y_SIZE_MM(pDetailedTimingDesc, ushort)   \
    do  {                                                   \
        ushort  |= pDetailedTimingDesc->XYSizemm;           \
        ushort  &= 0xf;                                     \
        ushort <<= 8;                                       \
        ushort  |= pDetailedTimingDesc->YSizemm;            \
    } while (0)


#define GET_DETAIL_TIMING_DESC_FLAG(pDetailedTimingDesc)  \
    pDetailedTimingDesc->Flags

#define IS_DETAIL_FLAGS_INTERLACED(Flags)      Flags & EDIDBIT7

#define IS_DETAIL_FLAGS_FIELD_SEQ_STEREO_RIGHT(Flags)   \
    (!(Flags & EDIDBIT0) && (Flags & EDIDBIT5) && !(Flags & EDIDBIT6))

#define IS_DETAIL_FLAGS_FIELD_SEQ_STEREO_LEFT(Flags)    \
    (!(Flags & EDIDBIT0) && !(Flags & EDIDBIT5) && (Flags & EDIDBIT6))

#define IS_DETAIL_FLAGS_STEREO_RIGHT_EVEN(Flags)    \
    ((Flags & EDIDBIT0) && (Flags & EDIDBIT5) && !(Flags & EDIDBIT6))

#define IS_DETAIL_FLAGS_STEREO_LEFT_EVEN(Flags)     \
    ((Flags & EDIDBIT0) && !(Flags & EDIDBIT5) && (Flags & EDIDBIT6))

#define IS_DETAIL_FLAGS_STEREO_INTERLEAVED(Flags)   \
    (!(Flags & EDIDBIT0) && (Flags & EDIDBIT5) && (Flags & EDIDBIT6))

#define IS_DETAIL_FLAGS_SIDE_BY_SIDE(Flags)     \
    ((Flags & EDIDBIT0) && (Flags & EDIDBIT5) && (Flags & EDIDBIT6))

#define IS_DETAIL_FLAGS_ANALOGUE_COMPOSITE(Flags)    \
    (!(Flags & EDIDBIT4) && !(Flags & EDIDBIT3))

#define IS_DETAIL_FLAGS_BIPOLAR_ANALOGUE_COMPOSITE(Flags)    \
    (!(Flags & EDIDBIT4) && (Flags & EDIDBIT3))

#define IS_DETAIL_FLAGS_DIGITAL_COMPOSITE(Flags) \
    ((Flags & EDIDBIT4) && !(Flags & EDIDBIT3))

#define IS_DETAIL_FLAGS_DIGITAL_SEPARATE(Flags)  \
    ((Flags & EDIDBIT4) && (Flags & EDIDBIT3))

#define IS_DETAIL_FLAGS_SYNC_ON_ALL_3_LINES(Flags)   \
    ((IS_DETAIL_FLAGS_ANALOGUE_COMPOSITE(Flags) ||   \
      IS_DETAIL_FLAGS_BIPOLAR_ANALOGUE_COMPOSITE(Flags)) && \
     (Flags & EDIDBIT1))

#define IS_DETAIL_FLAGS_COMPOSITE_POLARITY(Flags)    \
    (IS_DETAIL_FLAGS_DIGITAL_COMPOSITE(Flags) && (Flags & EDIDBIT1))

#define IS_DETAIL_FLAGS_HSYNC_POLARITY(Flags)    \
    (IS_DETAIL_FLAGS_DIGITAL_SEPARATE(Flags) && (Flags & EDIDBIT1))

typedef struct  __MONITOR_DESCRIPTION {
        UCHAR   Flag1[2];
        UCHAR   ReservedFlag;
        UCHAR   DataTypeFlag;
        UCHAR   Flag2;
        UCHAR   MonitorSNorData[13];
        } MONITOR_DESCRIPTION, *PMONITOR_DESCRIPTION;

#define IS_MONITOR_DESCRIPTOR(pMonitorDesc)   \
    (((pMonitorDesc->Flag1[0]) == 0) && ((pMonitorDesc->Flag1[1]) == 0))

#define IS_MONITOR_DATA_SN(pMonitorDesc)   \
    (pMonitorDesc->DataTypeFlag == 0xff)

#define IS_MONITOR_DATA_STRING(pMonitorDesc)   \
    (pMonitorDesc->DataTypeFlag == 0xfe)

#define IS_MONITOR_RANGE_LIMITS(pMonitorDesc)    \
    (pMonitorDesc->DataTypeFlag == 0xfd)

#define IS_MONITOR_DATA_NAME(pMonitorDesc) \
    (pMonitorDesc->DataTypeFlag == 0xfc)


#define GET_MONITOR_RANGE_LIMITS(pMonitorDesc) \
    pMonitorDesc->MonitorSNorData

#define GET_RANGE_LIMIT_MIN_Y_RATE(pMonitorSNorData)    \
    pMonitorSNorData[5]

#define GET_RANGE_LIMIT_MAX_Y_RATE(pMonitorSNorData)    \
    pMonitorSNorData[6]

#define GET_RANGE_LIMIT_MIN_X_RATE(pMonitorSNorData)    \
    pMonitorSNorData[7]

#define GET_RANGE_LIMIT_MAX_X_RATE(pMonitorSNorData)    \
    pMonitorSNorData[8]

// This is really rate/10!
//
#define GET_RANGE_LIMIT_MAX_PIXELCLOCK_RATE(pMonitorSNorData)    \
    pMonitorSNorData[9]

#define GET_RANGE_LIMIT_PGTF(pMonitorSNorData)    \
    &pMonitorSNorData[10]


#define IS_MONITOR_DATA_COLOR_INFO(pMonitorDesc)   \
    (pMonitorDesc->DataTypeFlag == 0xfb)

//
//  More macros defined in edid.h
//
//#define USER_GET_COLOR_INFO_W1POINT_INDEX(pMonitorSNorData)   \
//    pMonitorSNorData[0]
//
//#define USER_GET_COLOR_INFO_W1_LOWBITS(pMonitorSNorData)   \
//    pMonitorSNorData[1]
//
//#define USER_GET_COLOR_INFO_W1_X(pMonitorSNorData)   \
//    pMonitorSNorData[2]
//
//#define USER_GET_COLOR_INFO_W1_Y(pMonitorSNorData)   \
//    pMonitorSNorData[3]
//
//#define USER_GET_COLOR_INFO_W1_GAMMA(pMonitorSNorData)   \
//    pMonitorSNorData[4]
//
//#define USER_GET_COLOR_INFO_W2POINT_INDEX(pMonitorSNorData)   \
//    pMonitorSNorData[5]
//
//#define USER_GET_COLOR_INFO_W2_LOWBITS(pMonitorSNorData)   \
//    pMonitorSNorData[6]

//#define USER_GET_COLOR_INFO_W2_X(pMonitorSNorData)   \
//    pMonitorSNorData[7]
//
//#define USER_GET_COLOR_INFO_W2_Y(pMonitorSNorData)   \
//    pMonitorSNorData[8]
//
//#define USER_GET_COLOR_INFO_W2_GAMMA(pMonitorSNorData)   \
//    pMonitorSNorData[9]
//
//
#define IS_MONITOR_DATA_TIMING_ID(pMonitorDesc)    \
    (pMonitorDesc->DataTypeFlag == 0xfa)


typedef union __MONITOR_OR_DETAIL  {
        MONITOR_DESCRIPTION             MonitorDescription;
        DETAILED_TIMING_DESCRIPTION     DetailedTimingDescription;
    } MONITOR_OR_DETAIL, *PMONITOR_OR_DETAIL;


/////////////////////////////////////////////
//  8) Extension Flag
//
//      Number of optional 128 byte EDID extension blocks to follow.
//

#define GET_EDID_EXTENSION_FLAG(pEdid)       pEdid->UC_ExtensionFlag

/////////////////////////////////////////////
//  9) Checksum
//
//

#define GET_EDID_CHECKSUM(pEdid)       pEdid->UC_Checksum

BOOLEAN
EdidCheckSum(
    IN  PCHAR   pBlob,
    IN  ULONG   BlobSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\port\ops.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

  ops.c

Abstract:

    video port stub routines for memory and io.

Author:

    Andre Vachon (andreva) 22-Feb-1997

Environment:

    kernel mode only

Notes:

    This module is a driver which implements OS dependant functions on the
    behalf of the video drivers

Revision History:

--*/

#include "videoprt.h"

#pragma alloc_text(PAGE,VideoPortGetAssociatedDeviceExtension)
#pragma alloc_text(PAGE,VideoPortGetAssociatedDeviceID)
#pragma alloc_text(PAGE,VideoPortAcquireDeviceLock)
#pragma alloc_text(PAGE,VideoPortReleaseDeviceLock)
#pragma alloc_text(PAGE,VideoPortGetRomImage)
#pragma alloc_text(PAGE,VpGetBusInterface)
#pragma alloc_text(PAGE,VideoPortGetVgaStatus)
#pragma alloc_text(PAGE,pVideoPortGetVgaStatusPci)
#pragma alloc_text(PAGE,VideoPortCheckForDeviceExistence)
#pragma alloc_text(PAGE,VpGetDeviceCount)
#pragma alloc_text(PAGE,VideoPortRegisterBugcheckCallback)
#pragma alloc_text(PAGE,VpAllocateNonPagedPoolPageAligned)
#pragma alloc_text(PAGE,VpAcquireLock)
#pragma alloc_text(PAGE,VpReleaseLock)

//
//ULONG
//VideoPortCompareMemory (
//    PVOID Source1,
//    PVOID Source2,
//    ULONG Length
//    )
//Forwarded to RtlCompareMemory(Source1,Source2,Length);
//


VP_STATUS
VideoPortDisableInterrupt(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    VideoPortDisableInterrupt allows a miniport driver to disable interrupts
    from its adapter. This means that the interrupts coming from the device
    will be ignored by the operating system and therefore not forwarded to
    the driver.

    A call to this function is valid only if the interrupt is defined, in
    other words, if the appropriate data was provided at initialization
    time to set up the interrupt.  Interrupts will remain disabled until
    they are reenabled using the VideoPortEnableInterrupt function.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

Return Value:

    NO_ERROR if the function completes successfully.

    ERROR_INVALID_FUNCTION if the interrupt cannot be disabled because it
      was not set up at initialization.

--*/

{

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // Only perform this operation if the interurpt is actually connected.
    //

    if (fdoExtension->InterruptObject) {

        HalDisableSystemInterrupt(fdoExtension->InterruptVector,
                                  fdoExtension->InterruptIrql);

        fdoExtension->InterruptsEnabled = FALSE;

        return NO_ERROR;

    } else {

        return ERROR_INVALID_FUNCTION;

    }

} // VideoPortDisableInterrupt()


VP_STATUS
VideoPortEnableInterrupt(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    VideoPortEnableInterrupt allows a miniport driver to enable interrupts
    from its adapter.  A call to this function is valid only if the
    interrupt is defined, in other words, if the appropriate data was
    provided at initialization time to set up the interrupt.

    This function is used to re-enable interrupts if they have been disabled
    using VideoPortDisableInterrupt.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

Return Value:

    NO_ERROR if the function completes successfully.

    ERROR_INVALID_FUNCTION if the interrupt cannot be disabled because it
        was not set up at initialization.


--*/

{

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // Only perform this operation if the interurpt is actually connected.
    //

    if (fdoExtension->InterruptObject) {

        fdoExtension->InterruptsEnabled = TRUE;

        HalEnableSystemInterrupt(fdoExtension->InterruptVector,
                                 fdoExtension->InterruptIrql,
                                 fdoExtension->InterruptMode);

        return NO_ERROR;

    } else {

        return ERROR_INVALID_FUNCTION;

    }

} // VideoPortEnableInterrupt()

PVOID
VideoPortGetRomImage(
    IN PVOID HwDeviceExtension,
    IN PVOID Unused1,
    IN ULONG Unused2,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine allows a miniport driver to get a copy of its devices
    ROM.  This function returns the pointer to a buffer containing the
    devices ROM.

Arguments;

    HwDeviceExtension - Points to the miniport driver's device extension.

    Unused1 - Reserved for future use.  Must be NULL.  (Buffer)

    Unused2 - Reserved for future use.  Must be zero.  (Offset)

    Length - Number of bytes to return.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

#if DBG
    if ((Unused1 != NULL) || (Unused2 != 0)) {
        pVideoDebugPrint((0,"VideoPortGetRomImage - Unused1 and Unused2 must be zero\n"));
        ASSERT(FALSE);
        return NULL;
    }
#endif

    //
    // Each time this routine is called the previous contents of the ROM
    // image are dropped.
    //

    if (fdoExtension->RomImage) {
        ExFreePool(fdoExtension->RomImage);
        fdoExtension->RomImage = NULL;
    }

    //
    // The caller should try to grab a buffer of length zero to free
    // any ROM Image already returned.
    //

    if (Length == 0) {
        return NULL;
    }

    //
    // This entry point is only valid for PnP Drivers.
    //

    if (((fdoExtension->Flags & LEGACY_DRIVER) == 0) &&
          fdoExtension->ValidBusInterface) {

        NTSTATUS status;
        PUCHAR Buffer;
        ULONG len, len1;
        PUCHAR outputBuffer;

        //
        // Allocate memory for our buffer
        //

        Buffer = ExAllocatePoolWithTag(PagedPool,
                                       Length * sizeof(UCHAR),
                                       VP_TAG);

        if (!Buffer) {

            pVideoDebugPrint((1, "VideoPortGetRomImage - could not allocate buffer\n"));
            return NULL;
        }

        // Try ACPI _ROM method first
        outputBuffer = ExAllocatePoolWithTag(PagedPool,
                                             (0x1000 + sizeof(ACPI_EVAL_OUTPUT_BUFFER))*sizeof(UCHAR),
                                             VP_TAG);
        if (!outputBuffer) {
            ExFreePool(Buffer);
            pVideoDebugPrint((1, "VideoPortGetRomImage - could not allocate buffer\n"));
            return NULL;
        }

        for (len = 0; len < Length; len += len1)
        {
            // _ROM can transfer only 4K at one time
            len1 = ((Length-len) < 0x1000) ? (Length-len) : 0x1000;
            status = pVideoPortACPIIoctl(
                        fdoExtension->AttachedDeviceObject,
                        (ULONG) ('MOR_'),
                        &len,
                        &len1,
                        len1+sizeof(ACPI_EVAL_OUTPUT_BUFFER),
                        (PACPI_EVAL_OUTPUT_BUFFER) outputBuffer);
            if (!NT_SUCCESS(status))
                break;
            RtlCopyMemory(Buffer+len,
                          ((PACPI_EVAL_OUTPUT_BUFFER)outputBuffer)->Argument[0].Data,
                          len1 * sizeof(UCHAR));
        }

        ExFreePool(outputBuffer);

        if (NT_SUCCESS(status)) {

            fdoExtension->RomImage = Buffer;
            return Buffer;
        }

        // If ACPI _ROM method failed
        Length = fdoExtension->BusInterface.GetBusData(
                     fdoExtension->BusInterface.Context,
                     PCI_WHICHSPACE_ROM,
                     Buffer,
                     0,
                     Length);

        if (Length) {

            fdoExtension->RomImage = Buffer;
            return Buffer;

        } else {

            ExFreePool(Buffer);
            return NULL;
        }

    } else {

        pVideoDebugPrint((0, "VideoPortGetRomImage - not supported on legacy devices\n"));
        return NULL;
    }
}


ULONG
VideoPortGetBusData(
    PVOID HwDeviceExtension,
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    if ((fdoExtension->Flags & LEGACY_DRIVER) ||
        (BusDataType != PCIConfiguration)) {

#if defined(NO_LEGACY_DRIVERS)
        pVideoDebugPrint((0, "VideoPortGetBusData: fdoExtension->Flags & LEGACY_DRIVER not supported for 64-bits.\n"));

        return 0;

#else
        return HalGetBusDataByOffset(BusDataType,
                                     fdoExtension->SystemIoBusNumber,
                                     SlotNumber,
                                     Buffer,
                                     Offset,
                                     Length);
#endif // NO_LEGACY_DRIVERS

    } else {

        if (fdoExtension->ValidBusInterface) {
            Length = fdoExtension->BusInterface.GetBusData(
                         fdoExtension->BusInterface.Context,
                         PCI_WHICHSPACE_CONFIG,
                         Buffer,
                         Offset,
                         Length);

            return Length;
        } else {
            return 0;
        }
    }

} // end VideoPortGetBusData()


UCHAR
VideoPortGetCurrentIrql(
    )

/*++

Routine Description:

    Stub to get Current Irql.

--*/

{

    return (KeGetCurrentIrql());

} // VideoPortGetCurrentIrql()


ULONG
VideoPortSetBusData(
    PVOID HwDeviceExtension,
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

{

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    if ((fdoExtension->Flags & LEGACY_DRIVER) ||
        (BusDataType != PCIConfiguration)) {

#if defined(NO_LEGACY_DRIVERS)
    pVideoDebugPrint((0, "VideoPortSetBusData: fdoExtension->Flags & LEGACY_DRIVER not supported for 64-bits.\n"));

    return 0;

#else

        return HalSetBusDataByOffset(BusDataType,
                                     fdoExtension->SystemIoBusNumber,
                                     SlotNumber,
                                     Buffer,
                                     Offset,
                                     Length);
#endif // NO_LEGACY_DRIVERS

    } else {

        if (fdoExtension->ValidBusInterface) {
            Length = fdoExtension->BusInterface.SetBusData(
                         fdoExtension->BusInterface.Context,
                         PCI_WHICHSPACE_CONFIG,
                         Buffer,
                         Offset,
                         Length);

            return Length;
        } else {
            return 0;
        }
    }

} // end VideoPortSetBusData()


//
//VOID
//VideoPortStallExecution(
//    IN ULONG Microseconds
//    )
//
//Forwarded to KeStallExecutionProcessor(Microseconds);
//


//
//VOID
//VideoPortMoveMemory(
//    IN PVOID Destination,
//    IN PVOID Source,
//    IN ULONG Length
//    )
//
//Forwarded to RtlMoveMemory(Destination,Source,Length);
//


//
// ALL the functions to read ports and registers are forwarded on free
// builds on x86 to the appropriate kernel function.
// This saves time and memory
//

#if DBG || !defined(_X86_)

UCHAR
VideoPortReadPortUchar(
    IN PUCHAR Port
    )

/*++

Routine Description:

    VideoPortReadPortUchar reads a byte from the specified port address.
    It requires a logical port address obtained from VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

Return Value:

    This function returns the byte read from the specified port address.

--*/

{

    UCHAR temp;

    temp = READ_PORT_UCHAR(Port);

    pVideoDebugPrint((3,"VideoPortReadPortUchar %x = %x\n", Port, temp));

    return(temp);

} // VideoPortReadPortUchar()

USHORT
VideoPortReadPortUshort(
    IN PUSHORT Port
    )

/*++

Routine Description:

    VideoPortReadPortUshort reads a word from the specified port address.
    It requires a logical port address obtained from VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.


Return Value:

    This function returns the word read from the specified port address.

--*/

{

    USHORT temp;

    temp = READ_PORT_USHORT(Port);

    pVideoDebugPrint((3,"VideoPortReadPortUshort %x = %x\n", Port, temp));

    return(temp);

} // VideoPortReadPortUshort()

ULONG
VideoPortReadPortUlong(
    IN PULONG Port
    )

/*++

Routine Description:

    VideoPortReadPortUlong reads a double word from the specified port
    address.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

Return Value:

    This function returns the double word read from the specified port address.

--*/

{

    ULONG temp;

    temp = READ_PORT_ULONG(Port);

    pVideoDebugPrint((3,"VideoPortReadPortUlong %x = %x\n", Port, temp));

    return(temp);

} // VideoPortReadPortUlong()

VOID
VideoPortReadPortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    VideoPortReadPortBufferUchar reads a number of bytes from a single port
    into a buffer.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Buffer - Points to an array of UCHAR values into which the values are
        stored.

    Count - Specifes the number of bytes to be read into the buffer.

Return Value:

    None.

--*/

{
    pVideoDebugPrint((3,"VideoPortReadPortBufferUchar %x\n", Port));

    READ_PORT_BUFFER_UCHAR(Port, Buffer, Count);

} // VideoPortReadPortBufferUchar()

VOID
VideoPortReadPortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    VideoPortReadPortBufferUshort reads a number of words from a single port
    into a buffer.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Buffer - Points to an array of words into which the values are stored.

    Count - Specifies the number of words to be read into the buffer.

Return Value:

    None.

--*/

{
    pVideoDebugPrint((3,"VideoPortReadPortBufferUshort %x\n", Port));

    READ_PORT_BUFFER_USHORT(Port, Buffer, Count);

} // VideoPortReadPortBufferUshort()

VOID
VideoPortReadPortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    VideoPortReadPortBufferUlong reads a number of double words from a
    single port into a buffer.  It requires a logical port address obtained
    from VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Buffer - Points to an array of double words into which the values are
        stored.

    Count - Specifies the number of double words to be read into the buffer.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortReadPortBufferUlong %x\n", Port));

    READ_PORT_BUFFER_ULONG(Port, Buffer, Count);

} // VideoPortReadPortBufferUlong()

#endif


//
// ALL the functions to read ports and registers are forwarded on free
// builds on x86 to the appropriate kernel function.
// This saves time and memory
//

#if DBG || !defined(_X86_)

UCHAR
VideoPortReadRegisterUchar(
    IN PUCHAR Register
    )

/*++

Routine Description:

    VideoPortReadRegisterUchar reads a byte from the specified register
    address.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Register - Specifies the register address.

Return Value:

    This function returns the byte read from the specified register address.

--*/

{

    UCHAR temp;

    temp = READ_REGISTER_UCHAR(Register);

    pVideoDebugPrint((3,"VideoPortReadRegisterUchar %x = %x\n", Register, temp));

    return(temp);

} // VideoPortReadRegisterUchar()

USHORT
VideoPortReadRegisterUshort(
    IN PUSHORT Register
    )

/*++

Routine Description:

    VideoPortReadRegisterUshort reads a word from the specified register
    address.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Register - Specifies the register address.

Return Value:

    This function returns the word read from the specified register address.

--*/

{

    USHORT temp;

    temp = READ_REGISTER_USHORT(Register);

    pVideoDebugPrint((3,"VideoPortReadRegisterUshort %x = %x\n", Register, temp));

    return(temp);

} // VideoPortReadRegisterUshort()

ULONG
VideoPortReadRegisterUlong(
    IN PULONG Register
    )

/*++

Routine Description:

    VideoPortReadRegisterUlong reads a double word from the specified
    register address.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Register - Specifies the register address.

Return Value:

    This function returns the double word read from the specified register
    address.

--*/

{

    ULONG temp;

    temp = READ_REGISTER_ULONG(Register);

    pVideoDebugPrint((3,"VideoPortReadRegisterUlong %x = %x\n", Register, temp));

    return(temp);

} // VideoPortReadRegisterUlong()

VOID
VideoPortReadRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);
}

VOID
VideoPortReadRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{
    READ_REGISTER_BUFFER_USHORT(Register, Buffer, Count);
}

VOID
VideoPortReadRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{
    READ_REGISTER_BUFFER_ULONG(Register, Buffer, Count);
}

VOID
VideoPortWritePortUchar(
    IN PUCHAR Port,
    IN UCHAR Value
    )

/*++

Routine Description:

    VideoPortWritePortUchar writes a byte to the specified port address.  It
    requires a logical port address obtained from VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Value - Specifies a byte to be written to the port.

Return Value:

    None.

--*/

{
    pVideoDebugPrint((3,"VideoPortWritePortUchar %x %x\n", Port, Value));

    WRITE_PORT_UCHAR(Port, Value);

} // VideoPortWritePortUchar()

VOID
VideoPortWritePortUshort(
    IN PUSHORT Port,
    IN USHORT Value
    )

/*++

Routine Description:

    VideoPortWritePortUshort writes a word to the specified port address.  It
    requires a logical port address obtained from VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Value - Specifies a word to be written to the port.

Return Value:

    None.

--*/

{
    pVideoDebugPrint((3,"VideoPortWritePortUhort %x %x\n", Port, Value));

    WRITE_PORT_USHORT(Port, Value);

} // VideoPortWritePortUshort()

VOID
VideoPortWritePortUlong(
    IN PULONG Port,
    IN ULONG Value
    )

/*++

Routine Description:

    VideoPortWritePortUlong writes a double word to the specified port address.
    It requires a logical port address obtained from VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Value - Specifies a double word to be written to the port.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortWritePortUlong %x %x\n", Port, Value));

    WRITE_PORT_ULONG(Port, Value);

} // VideoPortWritePortUlong()

VOID
VideoPortWritePortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    VideoPortWritePortBufferUchar writes a number of bytes to a
    specific port.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Buffer - Points to an array of bytes to be written.

    Count - Specifies the number of bytes to be written to the buffer.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortWritePortBufferUchar  %x \n", Port));

    WRITE_PORT_BUFFER_UCHAR(Port, Buffer, Count);

} // VideoPortWritePortBufferUchar()

VOID
VideoPortWritePortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    VideoPortWritePortBufferUshort writes a number of words to a
    specific port.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Buffer - Points to an array of words to be written.

    Count - Specifies the number of words to be written to the buffer.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortWritePortBufferUshort  %x \n", Port));

    WRITE_PORT_BUFFER_USHORT(Port, Buffer, Count);

} // VideoPortWritePortBufferUshort()

VOID
VideoPortWritePortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    VideoPortWritePortBufferUlong writes a number of double words to a
    specific port.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Buffer - Points to an array of double word to be written.

    Count - Specifies the number of double words to be written to the buffer.
Return Value:

    None.

--*/

{
    pVideoDebugPrint((3,"VideoPortWriteBufferUlong  %x \n", Port));

    WRITE_PORT_BUFFER_ULONG(Port, Buffer, Count);

} // VideoPortWritePortBufferUlong()

VOID
VideoPortWriteRegisterUchar(
    IN PUCHAR Register,
    IN UCHAR Value
    )

/*++

Routine Description:

    VideoPortWriteRegisterUchar writes a byte to the specified
    register address.  It requires a logical port address obtained
    from VideoPortGetDeviceBase.

Arguments:

    Register - Specifies the register address.

    Value - Specifies a byte to be written to the register.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortWritePortRegisterUchar  %x \n", Register));

    WRITE_REGISTER_UCHAR(Register, Value);

} // VideoPortWriteRegisterUchar()

VOID
VideoPortWriteRegisterUshort(
    IN PUSHORT Register,
    IN USHORT Value
    )

/*++

Routine Description:

    VideoPortWriteRegisterUshort writes a word to the specified
    register address.  It requires a logical port address obtained
    from VideoPortGetDeviceBase.

Arguments:

    Register - Specifies the register address.

    Value - Specifies a word to be written to the register.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortWritePortRegisterUshort  %x \n", Register));

    WRITE_REGISTER_USHORT(Register, Value);

} // VideoPortWriteRegisterUshort()

VOID
VideoPortWriteRegisterUlong(
    IN PULONG Register,
    IN ULONG Value
    )

/*++

Routine Description:

    VideoPortWriteRegisterUlong writes a double word to the
    specified register address.  It requires a logical port
    address obtained from VideoPortGetDeviceBase.

Arguments:

    Register - Specifies the register address.

    Value - Specifies a double word to be written to the register.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortWritePortRegisterUlong  %x \n", Register));

    WRITE_REGISTER_ULONG(Register, Value);

} // VideoPortWriteRegisterUlong()


VOID
VideoPortWriteRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{
    WRITE_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);
}

VOID
VideoPortWriteRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{
    WRITE_REGISTER_BUFFER_USHORT(Register, Buffer, Count);
}

VOID
VideoPortWriteRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{
    WRITE_REGISTER_BUFFER_ULONG(Register, Buffer, Count);
}

#endif // DBG

//
//VOID
//VideoPortZeroMemory(
//    IN PVOID Destination,
//    IN ULONG Length
//    )
//
//Forwarded to RtlZeroMemory(Destination,Length);
//

PVOID
VideoPortGetAssociatedDeviceExtension(
    IN PVOID DeviceObject
    )

/*++

Routine Description:

    This routine will return the HwDeviceExtension for the parent of the
    given device object.

Arguments:

    DeviceObject - The child device object (PDO).

Notes:

    This function is useful if you want to get the parent device extension
    for a child device object.  For example this is useful with I2C.

--*/

{
    PFDO_EXTENSION DeviceExtension;
    PCHILD_PDO_EXTENSION ChildDeviceExtension;

    PAGED_CODE();
    ASSERT(NULL != DeviceObject);

    ChildDeviceExtension = (PCHILD_PDO_EXTENSION)((PDEVICE_OBJECT)DeviceObject)->DeviceExtension;

    if (!IS_PDO(ChildDeviceExtension)) {
        ASSERT(FALSE);
        return NULL;
    }

    DeviceExtension = (PFDO_EXTENSION)ChildDeviceExtension->pFdoExtension;
    return (PVOID) DeviceExtension->HwDeviceExtension;
}

ULONG
VideoPortGetAssociatedDeviceID(
    IN PVOID DeviceObject
    )

/*++

Routine Description:

    This routine will return the ChildId for the given device object.

Arguments:

    DeviceObject - The child device object (PDO).

Notes:

    This function is useful if you want to get the child ID
    for a child device object.  For example this is useful with I2C.

--*/

{
    PCHILD_PDO_EXTENSION ChildDeviceExtension;

    PAGED_CODE();
    ASSERT(NULL != DeviceObject);

    ChildDeviceExtension = (PCHILD_PDO_EXTENSION)((PDEVICE_OBJECT)DeviceObject)->DeviceExtension;

    if (!IS_PDO(ChildDeviceExtension)) {
        ASSERT(FALSE);
        return VIDEO_INVALID_CHILD_ID;
    }

    return ChildDeviceExtension->ChildUId;
}

VOID
VideoPortAcquireDeviceLock(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine acquires the per device lock maintained by the videoprt.

Arguments:

    HwDeviceExtension - Pointer to the hardware device extension.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    ACQUIRE_DEVICE_LOCK(fdoExtension);
}

VOID
VideoPortReleaseDeviceLock(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine releases the per device lock maintained by the videoprt.

Arguments:

    HwDeviceExtension - Pointer to the hardware device extension.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    RELEASE_DEVICE_LOCK(fdoExtension);
}

PVOID
VpGetProcAddress(
    IN PVOID HwDeviceExtension,
    IN PUCHAR FunctionName
    )

/*++

Routine Description:

    This routine allows a video miniport to get access to VideoPort
    functions without linking to them directly.  This will allow an NT 5.0
    miniport to take advantage of NT 5.0 features while running on NT 5.0,
    but still retain the ability to load on NT 4.0.

Arguments:

    HwDeviceExtension - Pointer to the hardware device extension.

    FunctionName - pointer to a zero terminated ascii string which contains
        the function name we are looking for.

Returns:

    Pointer to the given function if it exists.
    NULL otherwise.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    PPROC_ADDRESS ProcAddress = VideoPortEntryPoints;

    //
    // Since the list of exported functions is small, and this routine
    // will not be called often we can get away with a linear search.
    //

    while (ProcAddress->FunctionName) {

        if (strcmp(ProcAddress->FunctionName, FunctionName) == 0) {
            return ProcAddress->FunctionAddress;
        }

        ProcAddress++;
    }

    return NULL;
}

NTSTATUS
VpGetBusInterface(
    PFDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    Send a QueryInterface Irp to our parent to retrieve
    the BUS_INTERFACE_STANDARD.

Returns:

    NT_STATUS code

--*/

{
    KEVENT             Event;
    PIRP               QueryIrp = NULL;
    IO_STATUS_BLOCK    IoStatusBlock;
    PIO_STACK_LOCATION NextStack;
    NTSTATUS           Status;

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    QueryIrp = IoBuildSynchronousFsdRequest(IRP_MJ_FLUSH_BUFFERS,
                                            FdoExtension->AttachedDeviceObject,
                                            NULL,
                                            0,
                                            NULL,
                                            &Event,
                                            &IoStatusBlock);

    if (QueryIrp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    QueryIrp->IoStatus.Status = IoStatusBlock.Status = STATUS_NOT_SUPPORTED;

    NextStack = IoGetNextIrpStackLocation(QueryIrp);

    //
    // Set up for a QueryInterface Irp.
    //

    NextStack->MajorFunction = IRP_MJ_PNP;
    NextStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

    NextStack->Parameters.QueryInterface.InterfaceType = &GUID_BUS_INTERFACE_STANDARD;
    NextStack->Parameters.QueryInterface.Size = sizeof(BUS_INTERFACE_STANDARD);
    NextStack->Parameters.QueryInterface.Version = 1;
    NextStack->Parameters.QueryInterface.Interface = (PINTERFACE) &FdoExtension->BusInterface;
    NextStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    FdoExtension->BusInterface.Size = sizeof(BUS_INTERFACE_STANDARD);
    FdoExtension->BusInterface.Version = 1;

    Status = IoCallDriver(FdoExtension->AttachedDeviceObject, QueryIrp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
        Status = IoStatusBlock.Status;
    }

    return Status;
}

BOOLEAN
VideoPortCheckForDeviceExistence(
    IN PVOID HwDeviceExtension,
    IN USHORT VendorId,
    IN USHORT DeviceId,
    IN UCHAR RevisionId,
    IN USHORT SubVendorId,
    IN USHORT SubSystemId,
    IN ULONG Flags
    )

/*++

Routine Description:

    Checks for the existance of a given PCI device in the system.

Returns:

    TRUE if the device is present,
    FALSE otherwise.

--*/

{
    PFDO_EXTENSION FdoExtension = GET_FDO_EXT(HwDeviceExtension);
    BOOLEAN Result = FALSE;

    if ((FdoExtension->Flags & LEGACY_DRIVER) == 0) {

        KEVENT             Event;
        PIRP               QueryIrp = NULL;
        IO_STATUS_BLOCK    IoStatusBlock;
        PIO_STACK_LOCATION NextStack;
        NTSTATUS           Status;

        PCI_DEVICE_PRESENT_INTERFACE Interface;

        KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

        QueryIrp = IoBuildSynchronousFsdRequest(IRP_MJ_FLUSH_BUFFERS,
                                                FdoExtension->AttachedDeviceObject,
                                                NULL,
                                                0,
                                                NULL,
                                                &Event,
                                                &IoStatusBlock);

        if (QueryIrp == NULL) {
            return FALSE;
        }

        QueryIrp->IoStatus.Status = IoStatusBlock.Status = STATUS_NOT_SUPPORTED;

        NextStack = IoGetNextIrpStackLocation(QueryIrp);

        //
        // Set up for a QueryInterface Irp.
        //

        NextStack->MajorFunction = IRP_MJ_PNP;
        NextStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

        NextStack->Parameters.QueryInterface.InterfaceType = &GUID_PCI_DEVICE_PRESENT_INTERFACE;
        NextStack->Parameters.QueryInterface.Size = sizeof(PCI_DEVICE_PRESENT_INTERFACE);
        NextStack->Parameters.QueryInterface.Version = 1;
        NextStack->Parameters.QueryInterface.Interface = (PINTERFACE) &Interface;
        NextStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

        FdoExtension->BusInterface.Size = sizeof(PCI_DEVICE_PRESENT_INTERFACE);
        FdoExtension->BusInterface.Version = 1;

        Status = IoCallDriver(FdoExtension->AttachedDeviceObject, QueryIrp);

        if (Status == STATUS_PENDING) {
            KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
            Status = IoStatusBlock.Status;
        }

        if (NT_SUCCESS(Status)) {

            //
            // We were able to acquire the interface.  Check for our device.
            //

            Interface.InterfaceReference(Interface.Context);

            Result = Interface.IsDevicePresent(VendorId,
                                               DeviceId,
                                               RevisionId,
                                               SubVendorId,
                                               SubSystemId,
                                               Flags);

            Interface.InterfaceDereference(Interface.Context);

        }
    }

    return Result;
}

//
// Use these until I can make forwarders work.
//

LONG
FASTCALL
VideoPortInterlockedExchange(
    IN OUT PLONG Target,
    IN LONG Value
    )

{
    return InterlockedExchange(Target, Value);
}

LONG
FASTCALL
VideoPortInterlockedIncrement(
    IN PLONG Addend
    )

{
    return InterlockedIncrement(Addend);
}

LONG
FASTCALL
VideoPortInterlockedDecrement(
    IN PLONG Addend
    )

{
    return InterlockedDecrement(Addend);
}

VP_STATUS
VideoPortGetVgaStatus(
    PVOID HwDeviceExtension,
    OUT PULONG VgaStatus
    )

/*++

Routine Description:

    VideoPortGetVgaStatus detect if the calling device is decoding
    Vga IO address

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension
    VgaStatus         - Points to the the result

Return Value:

    NO_ERROR if the function completes successfully.

    ERROR_INVALID_FUNCTION if it is a non-PCI device

--*/
{

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // We can not handle legacy devices
    //

    if (fdoExtension->AdapterInterfaceType != PCIBus) {

        *VgaStatus = 0;

        return ERROR_INVALID_FUNCTION;
    }
    else {

        *VgaStatus = pVideoPortGetVgaStatusPci( HwDeviceExtension );
        return (NO_ERROR);

    }
}

#define VGA_STATUS_REGISTER1 0x3DA

ULONG
pVideoPortGetVgaStatusPci(
    PVOID HwDeviceExtension
    )

{

    USHORT Command;
    PCI_COMMON_CONFIG ConfigSpace;
    PHYSICAL_ADDRESS PhysicalAddress;
    PUCHAR BaseReg;
    ULONG VgaEnable;

    //
    // assume VGA is disabled
    //

    VgaEnable = 0;

    //
    // Get the PCI config for this device
    //

    VideoPortGetBusData( HwDeviceExtension,
                         PCIConfiguration,
                         0,
                         &ConfigSpace,
                         0,
                         PCI_COMMON_HDR_LENGTH);


    if( !(ConfigSpace.Command & PCI_ENABLE_IO_SPACE) ) {

        return VgaEnable;

    }

    if (((ConfigSpace.BaseClass == PCI_CLASS_PRE_20) &&
         (ConfigSpace.SubClass  == PCI_SUBCLASS_PRE_20_VGA)) ||
        ((ConfigSpace.BaseClass == PCI_CLASS_DISPLAY_CTLR) &&
         (ConfigSpace.SubClass  == PCI_SUBCLASS_VID_VGA_CTLR))) {


        //
        // Map the VGA registers we are going to use.
        //

        PhysicalAddress.HighPart = 0;
        PhysicalAddress.LowPart  = VGA_STATUS_REGISTER1;

        BaseReg = VideoPortGetDeviceBase(HwDeviceExtension,
                                         PhysicalAddress,
                                         1,
                                         VIDEO_MEMORY_SPACE_IO);

        if (BaseReg) {

            //
            // If we got here the PCI config space for our device indicates
            // we are the VGA, and we were able to map the VGA resources.
            //

            VgaEnable = DEVICE_VGA_ENABLED;

            VideoPortFreeDeviceBase(HwDeviceExtension, BaseReg);
        }
    }

    return VgaEnable;
}

VOID
pVideoPortDpcDispatcher(
    IN PKDPC Dpc,
    IN PVOID HwDeviceExtension,
    IN PMINIPORT_DPC_ROUTINE DpcRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine handles DPCs and forwards them to the miniport callback
    routine.

Arguments:

    Dpc - The DPC which is executing.

    HwDeviceExtension - The HwDeviceExtension for the device which scheduled
        the DPC.

    DpcRoutine - The callback in the miniport which needs to be called.

    Context - The miniport supplied context.

Returns:

    None.

--*/

{
    DpcRoutine(HwDeviceExtension, Context);
}

BOOLEAN
VideoPortQueueDpc(
    IN PVOID HwDeviceExtension,
    IN PMINIPORT_DPC_ROUTINE CallbackRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    Allows a miniport driver to queue a DPC.

Arguments:

    HwDeviceExtension - The HwDeviceExtension for the miniport.

    CallbackRoutine - The entry point within the miniport to call when the DPC
        is scheduled.

    Context - A miniport supplies context which will be passed to the
        CallbackRoutine.

Returns:

    TRUE if successful,
    FALSE otherwise.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    return KeInsertQueueDpc(&fdoExtension->Dpc, CallbackRoutine, Context);
}

ULONG
VpGetDeviceCount(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    Allows a miniport driver to queue a DPC.

Arguments:

    HwDeviceExtension - The HwDeviceExtension for the miniport.

Returns:

    The number of started devices.

--*/

{
    return NumDevicesStarted;
}

VOID
pVpBugcheckCallback(
    IN KBUGCHECK_CALLBACK_REASON Reason,
    IN PKBUGCHECK_REASON_CALLBACK_RECORD Record,
    IN OUT PVOID ReasonSpecificData,
    IN ULONG ReasonSpecificDataLength
    )

/*++

Routine Description:

    This callback is called when a bugcheck occurs.  It allows the
    videoprt an opportunity to store data which can later be used
    to help diagnose the bugcheck.

Arguments:

    Reason - the reason we are being called

    Record - a pointer to the bugcheck reason record we set up

    ReasonSpecificData - pointer to KBUGCHECK_SECONDARY_DUMP_DATA

    ReasonSpecificDataLength - the size of the reason specific data

Returns:

    None.

Notes:

    This routine can be called at any time, and must not be pageable.

--*/

{
    ULONG BugcheckCode;
    PKBUGCHECK_SECONDARY_DUMP_DATA DumpData
        = (PKBUGCHECK_SECONDARY_DUMP_DATA)ReasonSpecificData;

    //
    // Only handle secondary dumps
    //

    if (Reason != KbCallbackSecondaryDumpData) {
        return;
    }

    //
    // Grab the bugcheck code.  We only handle EA currently.
    //

    BugcheckCode = *((PULONG)KiBugCheckData[0]);

    if (BugcheckCode == 0xEA) {
	    pVpGeneralBugcheckHandler(DumpData);
    }
}

VOID
pVpGeneralBugcheckHandler(
    PKBUGCHECK_SECONDARY_DUMP_DATA DumpData
    )

/*++

Routine Description:

    This routine calls all of the hooked bugcheck callbacks,
    and appends the data into the supplied buffer.

Arguments:

    DumpData - pointer to the location in which to store the dump data

Returns:

    None

--*/

{
    if (VpBugcheckDeviceObject != NULL) {

        PFDO_EXTENSION FdoExtension = VpBugcheckDeviceObject->DeviceExtension;

        //
        // Fill in the GUID, output buffer, and output buffer length
        //

        DumpData->OutBuffer = VpBugcheckData;
        DumpData->OutBufferLength = FdoExtension->BugcheckDataSize;
        memcpy(&DumpData->Guid, &VpBugcheckGUID, sizeof(VpBugcheckGUID));

        //
        // Call each "hooked" reason callback entry point
        //

        if (FdoExtension->BugcheckCallback) {

            FdoExtension->BugcheckCallback(
                FdoExtension->HwDeviceExtension,
                0xEA,
                VpBugcheckData,
                FdoExtension->BugcheckDataSize);
        }
    }
}

VOID
VpAcquireLock(
    VOID
    )

/*++

Routine Description:

    This routine will acquire the global video port lock.  This lock
    protects global data structures which are shared across drivers.

Arguments:

    none.

Returns:

    none.

--*/

{
    KeWaitForSingleObject(
        &VpGlobalLock,
        Executive,
        KernelMode,
        FALSE,
        (PTIME)NULL);
}

VOID
VpReleaseLock(
    VOID
    )

/*++

Routine Description:

    This routine will release the global video port lock.  This lock
    protects global data structures which are shared across drivers.

Arguments:

    none.

Returns:

    none.

--*/

{
    KeReleaseMutex(&VpGlobalLock, FALSE);
}

PVOID
VpAllocateNonPagedPoolPageAligned(
    ULONG Size
    )

/*++

Routine Description:

    This routine will allocate non-paged pool on a page alignment.

Arguments:

    Size - The number of bytes of memory to allocate.

Returns:

    A pointer to the allocated buffer.

--*/

{
    PVOID Buffer;

    if (Size < PAGE_SIZE) {
        Size = PAGE_SIZE;
    }

    Buffer = ExAllocatePoolWithTag(NonPagedPool, Size, VP_TAG);

    //
    // Make sure the buffer is page aligned.  In current builds,
    // allocating at least 1 page from non-paged pool, will always
    // result in a page aligned allocation.
    //
    // However, since this could change someday, verify that this
    // remains true.
    //

    if ((ULONG_PTR)Buffer & (PAGE_SIZE - 1)) {
        ExFreePool(Buffer);
        Buffer = NULL;
    }

    return Buffer;
}

VP_STATUS
VideoPortRegisterBugcheckCallback(
    IN PVOID HwDeviceExtension,
    IN ULONG BugcheckCode,
    IN PVIDEO_BUGCHECK_CALLBACK Callback,
    IN ULONG BugcheckDataSize
    )

/*++

Routine Description:

    This routine allows a video miniport to register for a callback at
    bugcheck time.  The driver will then have an opportunity to store
    data that can be used to help diagnose the bugcheck.  The data is
    appended to the dump file.

Arguments:

    HwDeviceExtension - a pointer to the device extension

    BugcheckCode - allows you to specify the bugcheck code you want to
        be notified for.

    Callback - a pointer to the miniport supplied callback function
        which will be invoked when a bugcheck occurs.  The callback function
        must be non-paged, and must not access pageable code or data.

    BugcheckDataSize - The amount of data the miniport will want to add
        to the minidump.

Returns:

    A status code indicating success or failure.

Notes:

    Currently only bugcheck EA's can be hooked.

    Currently we limit the data size to 4k.

    To unhook the callback, the miniport can specify NULL for the callback
    or 0 for the DataSize.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    VP_STATUS Status = STATUS_INSUFFICIENT_RESOURCES;

    //
    // For now let's only support hooking bugcheck EA.
    //

    if (BugcheckCode != 0xEA) {

        pVideoDebugPrint((0, "Currently only bugcheck 0xEA can be hooked.\n"));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Force the data size to be a multiple of 16 bytes.
    //

    BugcheckDataSize = (BugcheckDataSize + 15) & ~15;

    //
    // The kernel support code only allows 4k per caller for minidumps.
    //

    if (BugcheckDataSize > MAX_SECONDARY_DUMP_SIZE) {

        pVideoDebugPrint((0, "There is ~4k limit on bugcheck data size.\n"));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Acquire global videoprt lock, because we will be modifiying
    // global state.
    //

    VpAcquireLock();

    //
    // If the Callback is NULL, or the BugcheckDataSize is 0 then
    // they are unregistering the callback.
    //

    if ((Callback == NULL) || (BugcheckDataSize == 0)) {

        //
        // Only unregister if they were registered!
        //

        if (fdoExtension->BugcheckCallback) {

            fdoExtension->BugcheckCallback = NULL;
            fdoExtension->BugcheckDataSize = 0;
        }

        Status = NO_ERROR;

    } else {

        if (VpBugcheckData == NULL) {

            //
            // Try to acquire a large enough buffer for the bugcheck data for
            // this driver and all other drivers already registered
            //

            VpBugcheckData = VpAllocateNonPagedPoolPageAligned(PAGE_SIZE);

	}

	//
	// If the allocation succeeded then register the bugcheck
	// callback
	//

	if (VpBugcheckData) {

	    //
	    // Update the fdoExtension to indicate the callback is hooked.
	    //

	    fdoExtension->BugcheckCallback = Callback;
	    fdoExtension->BugcheckDataSize = BugcheckDataSize;

	    Status = NO_ERROR;
	}
    }

    //
    // Release the global videoprt lock
    //

    VpReleaseLock();

    return Status;
}

static
VOID
FreeDumpFileDacl(
    PACL pDacl
    )
{
    if (pDacl) ExFreePool(pDacl);
}

static
PACL 
CreateDumpFileDacl(
    VOID
    )
{
    ULONG ulDacLength = sizeof(ACL) 
                        + 2 * sizeof(ACCESS_ALLOWED_ACE) 
                        - 2 * sizeof(ULONG) 
                        + RtlLengthSid(SeExports->SeLocalSystemSid)
                        + RtlLengthSid(SeExports->SeCreatorOwnerSid);

    PACL pDacl = (PACL)ExAllocatePoolWithTag(PagedPool, ulDacLength, VP_TAG);
    
    if (pDacl &&
        NT_SUCCESS(RtlCreateAcl(pDacl, ulDacLength, ACL_REVISION)) &&
        NT_SUCCESS(RtlAddAccessAllowedAce(pDacl, 
                                          ACL_REVISION,
                                          GENERIC_ALL,
                                          SeExports->SeLocalSystemSid)) &&
        NT_SUCCESS(RtlAddAccessAllowedAce(pDacl, 
                                          ACL_REVISION,
                                          DELETE,
                                          SeExports->SeCreatorOwnerSid)))
    {
        return pDacl;
    }
    
    FreeDumpFileDacl(pDacl);
    return NULL;
}

static
BOOLEAN
InitDumpFileSid(
    PSID pSid,
    PACL pDacl
    )
{
    return (pSid && 
            pDacl &&
            NT_SUCCESS(RtlCreateSecurityDescriptor(pSid, SECURITY_DESCRIPTOR_REVISION)) &&
            NT_SUCCESS(RtlSetDaclSecurityDescriptor(pSid, TRUE, pDacl,FALSE)));
}

VOID
pVpWriteFile(
    PWSTR pwszFileName,
    PVOID pvBuffer,
    ULONG ulSize
    )

/*++

Routine Description:

    This routine is called when we are trying to recover from a bugcheck
    EA. 
    
Arguments:

    pwszFileName - name of dump file
    pvBuffer - data to write
    ulSize - size of the data to data

Returns:

    none.

Notes:

    This routine can be pagable because it will be called at passive level.

--*/

{
    SECURITY_DESCRIPTOR Sid;
    PACL pDacl = CreateDumpFileDacl();
    
    if (InitDumpFileSid(&Sid, pDacl)) {
        OBJECT_ATTRIBUTES ObjectAttributes;
        UNICODE_STRING UnicodeString;
        HANDLE FileHandle;
        NTSTATUS Status;
        IO_STATUS_BLOCK IoStatusBlock;

        RtlInitUnicodeString(&UnicodeString,
                             pwszFileName);

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   (HANDLE) NULL,
                                   &Sid);

        if (NT_SUCCESS(ZwCreateFile(&FileHandle,
                                    FILE_GENERIC_WRITE,
                                    &ObjectAttributes,
                                    &IoStatusBlock,
                                    NULL,
                                    FILE_ATTRIBUTE_HIDDEN,
                                    0, // exclusive
                                    FILE_SUPERSEDE,
                                    FILE_SYNCHRONOUS_IO_NONALERT | 
                                        FILE_WRITE_THROUGH,
                                    NULL,
                                    0)))
        {
            ZwWriteFile(FileHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        pvBuffer,
                        ulSize,
                        NULL,
                        NULL);
    
            //
            // Close the file.
            //
    
            ZwClose(FileHandle);
        }
    }
    
    FreeDumpFileDacl(pDacl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\port\sync.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    sync.c

Abstract:

    This file contains code for the video port synchronization routines.

Environment:

    kernel mode only

--*/

#include "videoprt.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, VideoPortCreateEvent)
#pragma alloc_text(PAGE, VideoPortCreateSpinLock)
#endif

VP_STATUS
VideoPortCreateSpinLock(
    IN PVOID HwDeviceExtension,
    OUT PSPIN_LOCK *SpinLock
    )

/*++

Routine Description:

    Creates a spin lock object

Arguments:

    HwDeviceExtension - pointer to the miniports device extension

    SpinLock - Location in which to store the pointer to the newly
        acquired spin lock.

Returns:

    NO_ERROR if the spin lock was created successfully, otherwise
    an appropriate error message is returned.

Notes:

    none

--*/

{
    PAGED_CODE();
    ASSERT(HwDeviceExtension != NULL);

    *SpinLock = ExAllocatePoolWithTag(NonPagedPool,
                                      sizeof(VIDEO_PORT_SPIN_LOCK),
                                      VP_TAG);

    if (*SpinLock) {
        KeInitializeSpinLock(&(*SpinLock)->Lock);
        return NO_ERROR;
    } else {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
}

VP_STATUS
VideoPortDeleteSpinLock(
    IN PVOID HwDeviceExtension,
    IN PSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    Deletes the given spin lock

Arguments:

    HwDeviceExtension - pointer to the miniports device extension

    SpinLock - A pointer to the spin lock being deleted.

Returns:

    NO_ERROR if the spin lock is deleted successfully.
Notes:

--*/

{
    ASSERT(HwDeviceExtension != NULL);
    ASSERT(SpinLock != NULL);

    ExFreePool(SpinLock);

    return NO_ERROR;
}

VOID
VideoPortAcquireSpinLock(
    IN PVOID HwDeviceExtension,
    IN PSPIN_LOCK SpinLock,
    OUT PUCHAR OldIrql
    )

/*++

Routine Description:

    Acquires the given spin lock

Arguments:

    HwDeviceExtension - pointer to the miniports device extension

    SpinLock - The spin lock being acquired

    OldIrql - location in which to store the old IRQL level

Returns:

    none

Notes:

--*/

{
    ASSERT(HwDeviceExtension != NULL);
    ASSERT(SpinLock != NULL);

    KeAcquireSpinLock(&SpinLock->Lock, OldIrql);
}

VOID
VideoPortAcquireSpinLockAtDpcLevel(
    IN PVOID HwDeviceExtension,
    IN PSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    Acquires the given spin lock.

Arguments:

    HwDeviceExtension - pointer to the miniports device extension

    SpinLock - The spin lock being acquired

Returns:

    none

Notes:

    This routine can only be called inside a DPC.

--*/

{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(HwDeviceExtension != NULL);
    ASSERT(SpinLock != NULL);

    KeAcquireSpinLockAtDpcLevel(&SpinLock->Lock);
}

VOID
VideoPortReleaseSpinLock(
    IN PVOID HwDeviceExtension,
    IN PSPIN_LOCK SpinLock,
    IN UCHAR NewIrql
    )

/*++

Routine Description:

    Releases ownership of a given spin lock

Arguments:

    HwDeviceExtension - pointer to the miniports device extension

    SpinLock - the spin lock being released

    NewIrql - Irql level to restore to.

Returns:

    none

Notes:

--*/

{
    ASSERT(HwDeviceExtension != NULL);
    ASSERT(SpinLock != NULL);

    KeReleaseSpinLock(&SpinLock->Lock, NewIrql);
}

VOID
VideoPortReleaseSpinLockFromDpcLevel(
    IN PVOID HwDeviceExtension,
    IN PSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    Releases ownership of a given spin lock

Arguments:

    HwDeviceExtension - pointer to the miniports device extension

    SpinLock - the spin lock being released

Returns:

    none

Notes:

    This routine can only be called inside a DPC.

--*/

{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(HwDeviceExtension != NULL);
    ASSERT(SpinLock != NULL);

    KeReleaseSpinLockFromDpcLevel(&SpinLock->Lock);
}

VP_STATUS
VideoPortCreateEvent(
    IN PVOID HwDeviceExtension,
    IN ULONG EventFlag,
    PVOID  Unused,
    OUT PEVENT *ppEvent
    )
{
    ULONG size;
    PEVENT p;
    EVENT_TYPE EventType;


    size = sizeof(VIDEO_PORT_EVENT);

    //
    //  Align size to next higher multiple of 8.
    //

    size = (size + 7) & ~7;

    p = (PEVENT) ExAllocatePoolWithTag( NonPagedPool,
                                        size + sizeof(KEVENT),
                                        VP_TAG );
    if ( p ) {

        p->fFlags = 0;
        p->pKEvent = (PUCHAR) p + size;

        if( (EventFlag & EVENT_TYPE_MASK) == NOTIFICATION_EVENT ) {

            EventType = NotificationEvent;

        } else {

            EventType = SynchronizationEvent;
        }

        KeInitializeEvent( p->pKEvent,
                           EventType,
                           (BOOLEAN) (EventFlag & INITIAL_EVENT_STATE_MASK ) );

        *ppEvent = p;

        return NO_ERROR;

    } else {

        return ERROR_NOT_ENOUGH_MEMORY;
    }
}

VP_STATUS
VideoPortDeleteEvent(
    IN PVOID HwDeviceExtension,
    IN PEVENT pEvent
    )
{
    if ( pEvent == NULL ) {

        pVideoDebugPrint((Error, "VideoPortDeleteEvent: Can't delete NULL event\n"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    if ( pEvent->fFlags & ENG_EVENT_FLAG_IS_MAPPED_USER ) {

        pVideoDebugPrint((Error, "VideoPortDeleteEvent: Can't delete mapped user event\n"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    if( pEvent->pKEvent == NULL ) {

        pVideoDebugPrint((Error, "VideoPortDeleteEvent: pKEvent is NULL\n"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    ExFreePool( (PVOID) pEvent );

    return NO_ERROR;
}

LONG
VideoPortSetEvent(
    IN PVOID HwDeviceExtension,
    IN PEVENT pEvent
    )
{
    return( KeSetEvent(pEvent->pKEvent, 0, FALSE) );
}

VOID
VideoPortClearEvent(
    IN PVOID HwDeviceExtension,
    IN PEVENT pEvent
    )
{
    KeClearEvent(pEvent->pKEvent);
}

LONG
VideoPortReadStateEvent(
    IN PVOID HwDeviceExtension,
    IN PEVENT pEvent
    )
{
    return ( KeReadStateEvent(pEvent->pKEvent) );
}


VP_STATUS
VideoPortWaitForSingleObject(
    IN PVOID HwDeviceExtension,
    IN PVOID pEvent,
    IN PLARGE_INTEGER Timeout
    )
{
    NTSTATUS status;

    if ( pEvent == NULL ) {

        return ERROR_INVALID_PARAMETER;
    }

    if( ((PEVENT) pEvent)->pKEvent == NULL) {

        return ERROR_INVALID_PARAMETER;
    }

    if (( (PEVENT) pEvent)->fFlags & ENG_EVENT_FLAG_IS_MAPPED_USER ) {

        pVideoDebugPrint((Error, "VideoPortVideoPortWaitForSingleObject: No wait ing on mapped user event\n")) ;
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    status = KeWaitForSingleObject( ((PEVENT) pEvent)->pKEvent,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    Timeout );

    if (status == STATUS_TIMEOUT) {

        return WAIT_TIMEOUT;

    } else if (NT_SUCCESS(status)) {

        return NO_ERROR;

    } else {

        return ERROR_INVALID_PARAMETER;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\port\registry.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Registry support for the video port driver.

Author:

    Andre Vachon (andreva) 01-Mar-1992

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "videoprt.h"


//
// Local routines.
//

BOOLEAN
CheckIoEnabled(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges
    );

ULONG
GetCmResourceListSize(
    PCM_RESOURCE_LIST CmResourceList
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,VpGetFlags)
#pragma alloc_text(PAGE,pOverrideConflict)
#pragma alloc_text(PAGE,VideoPortGetAccessRanges)
#pragma alloc_text(PAGE,pVideoPortReportResourceList)
#pragma alloc_text(PAGE,VideoPortVerifyAccessRanges)
#pragma alloc_text(PAGE,CheckIoEnabled)
#pragma alloc_text(PAGE,VpReleaseResources)
#pragma alloc_text(PAGE,VpIsResourceInList)
#pragma alloc_text(PAGE,VpAppendToRequirementsList)
#pragma alloc_text(PAGE,VpIsLegacyAccessRange)
#pragma alloc_text(PAGE,GetCmResourceListSize)
#pragma alloc_text(PAGE,VpRemoveFromResourceList)
#pragma alloc_text(PAGE,VpTranslateResource)
#pragma alloc_text(PAGE,VpIsVgaResource)
#endif

NTSTATUS
VpGetFlags(
    PUNICODE_STRING RegistryPath,
    PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    PULONG Flags
    )

/*++

Routine Description:

    Checks for the existance of the PnP key/value in the device's
    registry path.

Return Value:

    TRUE if the flag exists, FALSE otherwise.

--*/

{
    PWSTR    Path;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    ULONG    pnpEnabled = 0;
    ULONG    legacyDetect = 0;
    ULONG    defaultValue = 0;
    ULONG    bootDriver = 0;
    ULONG    reportDevice = 0;
    PWSTR    Table[] = {L"\\Vga", L"\\VgaSave", NULL};
    PWSTR    SubStr, *Item = Table;
    ULONG    Len;


    RTL_QUERY_REGISTRY_TABLE QueryTable[] = {
        {NULL, RTL_QUERY_REGISTRY_DIRECT, L"LegacyDetect",
         &legacyDetect,                   REG_DWORD, &defaultValue, 4},
        {NULL, RTL_QUERY_REGISTRY_DIRECT, L"BootDriver",
         &bootDriver,                     REG_DWORD, &defaultValue, 4},
        {NULL, RTL_QUERY_REGISTRY_DIRECT, L"ReportDevice",
         &reportDevice,                   REG_DWORD, &defaultValue, 4},
        {NULL, 0, NULL}
    };

    *Flags = 0;

    Path = ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,
                                 RegistryPath->Length + sizeof(UNICODE_NULL),
                                 VP_TAG);

    if (Path)
    {
        RtlCopyMemory(Path,
                      RegistryPath->Buffer,
                      RegistryPath->Length);

        *(Path + (RegistryPath->Length / sizeof(UNICODE_NULL))) = UNICODE_NULL;

        pVideoDebugPrint((1, "PnP path: %ws\n", Path));

        RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                               Path,
                               &QueryTable[0],
                               NULL,
                               NULL);

        //
        // If the PnP Entry points are present, then we will treat this
        // driver as a PnP driver.
        //

        if ( (HwInitializationData->HwInitDataSize >=
              FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwQueryInterface)) &&
             (HwInitializationData->HwSetPowerState != NULL)                &&
             (HwInitializationData->HwGetPowerState != NULL)                &&
             (HwInitializationData->HwGetVideoChildDescriptor != NULL) )
        {
            pVideoDebugPrint((1, "videoprt: The miniport is a PnP miniport."));

            pnpEnabled = TRUE;
        }

        //
        // REPORT_DEVICE is only valid if PNP_ENABLED is true.
        //
        // We don't want to report a device to the PnP system if
        // we don't have a PnP driver.
        //

        if (!pnpEnabled)
        {
            reportDevice = 0;
        }

        *Flags = (pnpEnabled   ? PNP_ENABLED   : 0) |
                 (legacyDetect ? LEGACY_DETECT : 0) |
                 (bootDriver   ? BOOT_DRIVER   : 0) |
                 (reportDevice ? REPORT_DEVICE : 0);

        //
        // Free the memory we allocated above.
        //

        ExFreePool(Path);


        //
        // Determine if the current miniport is the VGA miniport.
        //

        while (*Item) {

            Len = wcslen(*Item);

            SubStr = RegistryPath->Buffer + (RegistryPath->Length / 2) - Len;

            if (!_wcsnicmp(SubStr, *Item, Len)) {

                pVideoDebugPrint((1, "This IS the vga miniport\n"));
                *Flags |= VGA_DRIVER;
                break;
            }

            Item++;
        }

        pVideoDebugPrint((1, "Flags = %d\n", *Flags));

        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}

BOOLEAN
IsMirrorDriver(
    PFDO_EXTENSION fdoExtension
    )

/*++

Routine Description:

    Checks if the driver is a mirror onr or not.
    This function may be called ONLY after DriverRegistryPath was initialized.
    That is, after VideoPortFindAdapter2 or VideoPortCreateSecondaryDisplay 
    were called.

Return Value:

    TRUE if the driver is a mirror one, FALSE otherwise.

--*/

{
    ULONG MirrorDriver = 0;
    
    ASSERT ((fdoExtension != NULL) && IS_FDO(fdoExtension));

    VideoPortGetRegistryParameters(fdoExtension->HwDeviceExtension,
                                   L"MirrorDriver",
                                   FALSE,
                                   VpRegistryCallback,
                                   &MirrorDriver);
    
    return (MirrorDriver != 0);
}

BOOLEAN
pOverrideConflict(
    PFDO_EXTENSION FdoExtension,
    BOOLEAN bSetResources
    )

/*++

Routine Description:

    Determine if the port driver should override the conflict in the registry.

    bSetResources determines if the routine is checking the state for setting
    the resources in the registry, or for cleaning them.

    For example, if we are running basevideo and there is a conflict with the
    vga, we want to override the conflict, but not clear the contents of
    the registry.

Return Value:

    TRUE if it should, FALSE if it should not.

--*/

{

    UNICODE_STRING unicodeString;

    //
    // Drivers being detected should not generate a conflict in the eventlog.
    //

    if (FdoExtension->Flags & LEGACY_DETECT)
    {
        return TRUE;
    }

    //
    // \Driver\Vga is for backwards compatibility since we do not have it
    // anymore.  It has become \Driver\VgaSave.
    //

    RtlInitUnicodeString(&unicodeString, L"\\Driver\\Vga");

    if (!RtlCompareUnicodeString(&(FdoExtension->FunctionalDeviceObject->DriverObject->DriverName),
                                 &unicodeString,
                                 TRUE)) {

        //
        // Strings were equal - return SUCCESS
        //

        pVideoDebugPrint((1, "pOverrideConflict: found Vga string\n"));

        return TRUE;

    } else {

        RtlInitUnicodeString(&unicodeString, L"\\Driver\\VgaSave");

        if (!RtlCompareUnicodeString(&(FdoExtension->FunctionalDeviceObject->DriverObject->DriverName),
                                      &unicodeString,
                                      TRUE)) {
            //
            // Return TRUE if we are just checking for confict (never want this
            // driver to generate a conflict).
            // We want to return TRUE only if we are not in basevideo since we
            // only want to clear the resources if we are NOT in basevideo
            // we are clearing the resources.
            //


            pVideoDebugPrint((1, "pOverrideConflict: found VgaSave string.  Returning %d\n",
                             bSetResources));

            return (bSetResources || (!VpBaseVideo));


        } else {

            //
            // We failed all checks, so we will report a conflict
            //

            return FALSE;
        }
    }

} // end pOverrideConflict()

BOOLEAN
CheckResourceList(
    ULONG BusNumber,
    ULONG Slot
    )

/*++

Routine Description:

    This routine remembers which bus numbers and slot numbers we've handed
    out resources for.  This will prevent us from handing out resources
    to a legacy driver trying to control a device which a PnP driver
    is already controlling.

Arguments:

    BusNumber - The bus number on which the device resides.

    Slot - The slot/function number of the device on the bus.

Returns:

    TRUE if resources have already been handed out for the device,
    FALSE otherwise.

--*/

{
    PDEVICE_ADDRESS DeviceAddress;

    DeviceAddress = gDeviceAddressList;

    while (DeviceAddress) {

        if ((DeviceAddress->BusNumber == BusNumber) &&
            (DeviceAddress->Slot == Slot)) {

            return TRUE;
        }

        DeviceAddress = DeviceAddress->Next;
    }

    return FALSE;
}

VOID
AddToResourceList(
    ULONG BusNumber,
    ULONG Slot
    )

/*++

Routine Description:

    This routine checks to see if resources have already been handed
    out for the device on the given bus/slot.

Arguments:

    BusNumber - The bus number on which the device resides.

    Slot - The slot/function number of the device on the bus.

Returns:

    none

--*/

{
    PDEVICE_ADDRESS DeviceAddress;

    DeviceAddress = ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,
                                          sizeof(DEVICE_ADDRESS),
                                          VP_TAG);

    if (DeviceAddress) {

        DeviceAddress->BusNumber = BusNumber;
        DeviceAddress->Slot = Slot;

        DeviceAddress->Next = gDeviceAddressList;
        gDeviceAddressList = DeviceAddress;
    }
}


VIDEOPORT_API
VP_STATUS
VideoPortGetAccessRanges(
    PVOID HwDeviceExtension,
    ULONG NumRequestedResources,
    PIO_RESOURCE_DESCRIPTOR RequestedResources OPTIONAL,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges,
    PVOID VendorId,
    PVOID DeviceId,
    PULONG Slot
    )

/*++

Routine Description:

    Walk the appropriate bus to get device information.
    Search for the appropriate device ID.
    Appropriate resources will be returned and automatically stored in the
    resourcemap.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    NumRequestedResources - Number of entries in the RequestedResources array.

    RequestedResources - Optional pointer to an array ofRequestedResources
        the miniport driver wants to access.

    NumAccessRanges - Maximum number of access ranges that can be returned
        by the function.

    AccessRanges - Array of access ranges that will be returned to the driver.

    VendorId - Pointer to the vendor ID. On PCI, this is a pointer to a 16 bit
        word.

    DeviceId - Pointer to the Device ID. On PCI, this is a pointer to a 16 bit
        word.

    Slot - Pointer to the starting slot number for this search.

Return Value:

    ERROR_MORE_DATA if the AccessRange structure is not large enough for the
       PCI config info.
    ERROR_DEV_NOT_EXIST is the card is not found.

    NO_ERROR if the function succeded.

--*/

{
    PDEVICE_SPECIFIC_EXTENSION DoSpecificExtension;
    PFDO_EXTENSION fdoExtension;

    UNICODE_STRING unicodeString;
    ULONG i;
    ULONG j;

    PCM_RESOURCE_LIST cmResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmResourceDescriptor;


    VP_STATUS status;
    UCHAR bShare;

    PPCI_SLOT_NUMBER slotData = (PPCI_SLOT_NUMBER)Slot;


    DoSpecificExtension = GET_DSP_EXT(HwDeviceExtension);
    fdoExtension = DoSpecificExtension->pFdoExtension;

    // Hack Add extra R so the Device0 key does not get created as volatile
    // a mess up the subsequent driver install.

    *(LPWSTR) (((PUCHAR)DoSpecificExtension->DriverRegistryPath) +
               DoSpecificExtension->DriverRegistryPathLength) = L'R';

    RtlInitUnicodeString(&unicodeString, DoSpecificExtension->DriverRegistryPath);

    //
    // Assert drivers do set those parameters properly
    //

#if DBG

    if ((NumRequestedResources == 0) != (RequestedResources == NULL)) {

        pVideoDebugPrint((0, "VideoPortGetDeviceResources: Parameters for requested resource are inconsistent\n"));

    }

#endif

    //
    // An empty requested resource list means we want to automatic behavoir.
    // Just call the HAL to get all the information
    //

    if (NumRequestedResources == 0) {

        if ((fdoExtension->Flags & LEGACY_DRIVER) != LEGACY_DRIVER) {

            //
            // If a PnP driver is requesting resources, then return what the
            // system passed in to us.
            //

            cmResourceList = fdoExtension->AllocatedResources;

            //
            // Return the slot number to the device.
            //

            if (Slot) {
                *Slot = fdoExtension->SlotNumber;
            }

            if (cmResourceList) {
#if DBG
                DumpResourceList(cmResourceList);
#endif
                status = NO_ERROR;

            } else {

                //
                // The system should always pass us resources.
                //

                ASSERT(FALSE);
                status = ERROR_INVALID_PARAMETER;
            }

        } else {

#if defined(NO_LEGACY_DRIVERS)
            pVideoDebugPrint((0, "VideoPortGetDeviceResources: Sorry, no legacy device support.\n"));
            status = ERROR_INVALID_PARAMETER;
#else
        
            //
            // An empty requested resource list means we want to automatic behavoir.
            // Just call the HAL to get all the information
            //

            PCI_COMMON_CONFIG pciBuffer;
            PPCI_COMMON_CONFIG  pciData;

            //
            //
            // typedef struct _PCI_SLOT_NUMBER {
            //     union {
            //         struct {
            //             ULONG   DeviceNumber:5;
            //             ULONG   FunctionNumber:3;
            //             ULONG   Reserved:24;
            //         } bits;
            //         ULONG   AsULONG;
            //     } u;
            // } PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;
            //

            pciData = (PPCI_COMMON_CONFIG)&pciBuffer;

            //
            // Only PCI is supported for automatic querying
            //

            if (fdoExtension->AdapterInterfaceType == PCIBus) {

                status = ERROR_DEV_NOT_EXIST;

                //
                // Look on each slot
                //

                do
                {
                    //
                    // Look at each function.
                    //

                    do
                    {
                        if (HalGetBusData(PCIConfiguration,
                                          fdoExtension->SystemIoBusNumber,
                                          slotData->u.AsULONG,
                                          pciData,
                                          PCI_COMMON_HDR_LENGTH) == 0) {

                            //
                            // Out of functions. Go to next PCI bus.
                            //

                            continue;

                        }

                        if (pciData->VendorID != *((PUSHORT)VendorId) ||
                            pciData->DeviceID != *((PUSHORT)DeviceId)) {

                            //
                            // Not our PCI device. Try next device/function
                            //

                            continue;
                        }

                        //
                        // Check to see if resources have already been
                        // assigned for this bus/slot.
                        //

                        if (CheckResourceList(fdoExtension->SystemIoBusNumber,
                                               slotData->u.AsULONG) == FALSE)
                        {
                            if (NT_SUCCESS(HalAssignSlotResources(&unicodeString,
                                                                  &VideoClassName,
                                                                  fdoExtension->FunctionalDeviceObject->DriverObject,
                                                                  fdoExtension->FunctionalDeviceObject,
                                                                  PCIBus,
                                                                  fdoExtension->SystemIoBusNumber,
                                                                  slotData->u.AsULONG,
                                                                  &cmResourceList))) {

                                status = NO_ERROR;

                                AddToResourceList(fdoExtension->SystemIoBusNumber,
                                                  slotData->u.AsULONG);

                                break;

                            } else {

                                //
                                // ToDo: Log this error.
                                //

                                status = ERROR_INVALID_PARAMETER;
                            }

                        } else {

                            //
                            // Resources already assigned for this device.
                            //

                            pVideoDebugPrint((0, "VIDEOPRT: Another driver is already "
                                                 "controlling this device.\n"));
                            ASSERT(FALSE);

                            status = ERROR_DEV_NOT_EXIST;
                        }

                    } while (++slotData->u.bits.FunctionNumber != 0);

                    //
                    // break if we found the device already.
                    //

                    if (status != ERROR_DEV_NOT_EXIST) {

                        break;
                    }

                } while (++slotData->u.bits.DeviceNumber != 0);

            } else {

                //
                // This is not a supported bus type.
                //

                status = ERROR_INVALID_PARAMETER;

            }
#endif // NO_LEGACY_DRIVERS
        }

    } else {

        PIO_RESOURCE_REQUIREMENTS_LIST requestedResources;
        ULONG requestedResourceSize;
        NTSTATUS ntStatus;

        status = NO_ERROR;

        //
        // The caller has specified some resources.
        // Lets call IoAssignResources with that and see what comes back.
        //

        requestedResourceSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
                                   ((NumRequestedResources - 1) *
                                   sizeof(IO_RESOURCE_DESCRIPTOR));

        requestedResources = ExAllocatePoolWithTag(PagedPool,
                                                   requestedResourceSize,
                                                   VP_TAG);

        if (requestedResources) {

            RtlZeroMemory(requestedResources, requestedResourceSize);

            requestedResources->ListSize = requestedResourceSize;
            requestedResources->InterfaceType = fdoExtension->AdapterInterfaceType;
            requestedResources->BusNumber = fdoExtension->SystemIoBusNumber;
            requestedResources->SlotNumber = slotData->u.bits.DeviceNumber;
            requestedResources->AlternativeLists = 1;

            requestedResources->List[0].Version  = 1;
            requestedResources->List[0].Revision = 1;
            requestedResources->List[0].Count    = NumRequestedResources;

            RtlMoveMemory(&(requestedResources->List[0].Descriptors[0]),
                          RequestedResources,
                          NumRequestedResources * sizeof(IO_RESOURCE_DESCRIPTOR));

            ntStatus = IoAssignResources(&unicodeString,
                                         &VideoClassName,
                                         fdoExtension->FunctionalDeviceObject->DriverObject,
                                         fdoExtension->FunctionalDeviceObject,
                                         requestedResources,
                                         &cmResourceList);

            ExFreePool(requestedResources);

            if (!NT_SUCCESS(ntStatus)) {

                status = ERROR_INVALID_PARAMETER;

            }

        } else {

            status = ERROR_NOT_ENOUGH_MEMORY;

        }

    }

    if (status == NO_ERROR) {

        VIDEO_ACCESS_RANGE TempRange;

        //
        // We now have a valid cmResourceList.
        // Lets translate it back to access ranges so the driver
        // only has to deal with one type of list.
        //

        //
        // NOTE: The resources have already been reported at this point in
        // time.
        //

        //
        // Walk resource list to update configuration information.
        //

        for (i = 0, j = 0;
             (i < cmResourceList->List->PartialResourceList.Count) &&
                 (status == NO_ERROR);
             i++) {

            //
            // Get resource descriptor.
            //

            cmResourceDescriptor =
                &cmResourceList->List->PartialResourceList.PartialDescriptors[i];

            //
            // Get the share disposition
            //

            if (cmResourceDescriptor->ShareDisposition == CmResourceShareShared) {

                bShare = 1;

            } else {

                bShare = 0;

            }

            switch (cmResourceDescriptor->Type) {

            case CmResourceTypePort:
            case CmResourceTypeMemory:

                //
                // common part
                //

                TempRange.RangeLength =
                    cmResourceDescriptor->u.Memory.Length;
                TempRange.RangeStart =
                    cmResourceDescriptor->u.Memory.Start;
                TempRange.RangeVisible = 0;
                TempRange.RangeShareable = bShare;
                TempRange.RangePassive = 0;

                //
                // separate part
                //

                if (cmResourceDescriptor->Type == CmResourceTypePort) {
                    TempRange.RangeInIoSpace = 1;
                } else {
                    TempRange.RangeInIoSpace = 0;
                }

                //
                // See if we need to return the resource to the driver.
                //

                if (!VpIsLegacyAccessRange(fdoExtension, &TempRange)) {

                    if (j == NumAccessRanges) {

                        status = ERROR_MORE_DATA;
                        break;

                    } else {

                        //
                        // Only modify the AccessRange array if we are writing
                        // valid data.
                        //

                        AccessRanges[j] = TempRange;
                        j++;
                    }

                }

                break;

            case CmResourceTypeInterrupt:

                fdoExtension->MiniportConfigInfo->BusInterruptVector =
                    cmResourceDescriptor->u.Interrupt.Vector;
                fdoExtension->MiniportConfigInfo->BusInterruptLevel =
                    cmResourceDescriptor->u.Interrupt.Level;
                fdoExtension->MiniportConfigInfo->InterruptShareable =
                    bShare;

                break;

            case CmResourceTypeDma:

                fdoExtension->MiniportConfigInfo->DmaChannel =
                    cmResourceDescriptor->u.Dma.Channel;
                fdoExtension->MiniportConfigInfo->DmaPort =
                    cmResourceDescriptor->u.Dma.Port;
                fdoExtension->MiniportConfigInfo->DmaShareable =
                    bShare;

                break;

            default:

                pVideoDebugPrint((1, "VideoPortGetAccessRanges: Unknown descriptor type %x\n",
                                 cmResourceDescriptor->Type ));

                break;

            }

        }

        if (fdoExtension->Flags & LEGACY_DRIVER) {

            //
            // Free the resource provided by the IO system.
            //

            ExFreePool(cmResourceList);
        }
    }

    // Hack remove extra R

    *(LPWSTR) (((PUCHAR)DoSpecificExtension->DriverRegistryPath) +
               DoSpecificExtension->DriverRegistryPathLength) = UNICODE_NULL;

    return status;

} // VideoPortGetDeviceResources()

BOOLEAN
VpIsVgaResource(
    PVIDEO_ACCESS_RANGE AccessRange
    )

/*++

Routine Description:

    Indicates whether the given access range is a vga access range.

Arguments:

    AccessRange - The access range to examine.

Returns:

    TRUE if it is a VGA access range,
    FALSE otherwise.

Notes:

    This routine does not take into account the length of the access range.

--*/

{
    if (AccessRange->RangeInIoSpace) {

        ULONGLONG Port = AccessRange->RangeStart.QuadPart;

        if (((Port >= 0x3b0) && (Port <= 0x3bb)) ||
            ((Port >= 0x3c0) && (Port <= 0x3df))) {

            return TRUE;

        }

    } else {

        if (AccessRange->RangeStart.QuadPart == 0xa0000) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOLEAN
VpTranslateResource(
    IN PFDO_EXTENSION fdoExtension,
    IN OUT PULONG InIoSpace,
    IN PPHYSICAL_ADDRESS PhysicalAddress,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This routine ensures that we do not report any PnP assigned
    resources back to the system.

Arguments:

    fdoExtension - The device extension for the device.

    PhysicalAddress - The physical address that needs to be translated

    TranslatedAddress - The location in which to store the translated address.
Return Value:

    TRUE if the resource was translated
    FALSE otherwise.

--*/

{
    PCM_FULL_RESOURCE_DESCRIPTOR    pcmFullRaw;
    PCM_PARTIAL_RESOURCE_LIST       pcmPartialRaw;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pcmDescriptRaw;

    PCM_FULL_RESOURCE_DESCRIPTOR    pcmFullTranslated;
    PCM_PARTIAL_RESOURCE_LIST       pcmPartialTranslated;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pcmDescriptTranslated;

    ULONG i, j;
    BOOLEAN IoAddress = (BOOLEAN)(*InIoSpace & VIDEO_MEMORY_SPACE_IO);

    pcmFullRaw = fdoExtension->RawResources->List;
    pcmFullTranslated = fdoExtension->TranslatedResources->List;

    for (i = 0; i < fdoExtension->RawResources->Count; i++) {

        pcmPartialRaw = &(pcmFullRaw->PartialResourceList);
        pcmDescriptRaw = pcmPartialRaw->PartialDescriptors;

        pcmPartialTranslated = &(pcmFullTranslated->PartialResourceList);
        pcmDescriptTranslated = pcmPartialTranslated->PartialDescriptors;

        for (j = 0; j < pcmPartialRaw->Count; j++) {

            if ((pcmDescriptRaw->Type == CmResourceTypeMemory) &&
                (pcmDescriptRaw->u.Memory.Start.QuadPart == PhysicalAddress->QuadPart) &&
                (IoAddress == FALSE)) {

                *TranslatedAddress =
                    pcmDescriptTranslated->u.Memory.Start;

                if ((pcmDescriptTranslated->Type == CmResourceTypePort) &&
                    ((*InIoSpace & 0x4) == 0))
                {
                    *InIoSpace = VIDEO_MEMORY_SPACE_IO;

                } else {

                    *InIoSpace = 0;
                }

                return TRUE;
            }

            if ((pcmDescriptRaw->Type == CmResourceTypePort) &&
                (pcmDescriptRaw->u.Port.Start.QuadPart == PhysicalAddress->QuadPart) &&
                (IoAddress == TRUE)) {

                *TranslatedAddress =
                    pcmDescriptTranslated->u.Port.Start;

                if ((pcmDescriptTranslated->Type == CmResourceTypePort) &&
                    ((*InIoSpace & 0x4) == 0))
                {
                    *InIoSpace = VIDEO_MEMORY_SPACE_IO;

                } else {

                    *InIoSpace = 0;
                }

                return TRUE;
            }

            pcmDescriptRaw++;
            pcmDescriptTranslated++;
        }

        pcmFullRaw = (PCM_FULL_RESOURCE_DESCRIPTOR) pcmDescriptRaw;
        pcmFullTranslated = (PCM_FULL_RESOURCE_DESCRIPTOR) pcmDescriptTranslated;
    }

    return FALSE;
}


BOOLEAN
VpIsResourceInList(
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pResource,
    PCM_FULL_RESOURCE_DESCRIPTOR pFullResource,
    PCM_RESOURCE_LIST removeList
    )

/*++

Routine Description:

    This routine ensures that we do not report any PnP assigned
    resources back to the system.

Arguments:

    pResource - The resource which we are looking for in the removeList.

    pFullResource - contains bus info about pResource.

    removeList - Any resources in this list which appear in the
                 resourceList will be removed from the resourceList.

Return Value:

    TRUE if the resource is in the list,
    FALSE otherwise.

--*/

{
    PCM_FULL_RESOURCE_DESCRIPTOR    pcmFull;
    PCM_PARTIAL_RESOURCE_LIST       pcmPartial;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pcmDescript;

    ULONG i, j;

    if (!removeList) {

        //
        // If we have not list of resources to remove, then
        // simply return.
        //

        return FALSE;
    }

    pcmFull = &(removeList->List[0]);

    for (i=0; i<removeList->Count; i++)
    {
        pcmPartial = &(pcmFull->PartialResourceList);
        pcmDescript = &(pcmPartial->PartialDescriptors[0]);

        for (j=0; j<pcmPartial->Count; j++)
        {
            if (pcmDescript->Type == pResource->Type) {

                switch(pcmDescript->Type) {
                case CmResourceTypeMemory:
                case CmResourceTypePort:

                    if ((pResource->u.Memory.Start.LowPart >= pcmDescript->u.Memory.Start.LowPart) &&
                        ((pResource->u.Memory.Start.LowPart + pResource->u.Memory.Length) <=
                         (pcmDescript->u.Memory.Start.LowPart + pcmDescript->u.Memory.Length))) {

                        //
                        // The resources passed in match one of the resources
                        // in the list.
                        //

                        return TRUE;
                    }
                    break;

                case CmResourceTypeInterrupt:

                    //
                    // We don't want to report interrupts on the FDO.
                    //

                    return TRUE;

                default:

                    if (!memcmp(&pcmDescript->u, &pResource->u, sizeof(pResource->u))) {

                        //
                        // The resources passed in match one of the resources
                        // in the list.
                        //

                        return TRUE;
                    }
                }
            }

            pcmDescript++;
        }

        pcmFull = (PCM_FULL_RESOURCE_DESCRIPTOR) pcmDescript;
    }

    return FALSE;
}

VOID
VpReleaseResources(
    PFDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This routine will release all resource claims for a given device object.

Arguments:

    DeviceObject - The device object for which to release resource claims.

--*/
{
    PDEVICE_OBJECT DeviceObject = FdoExtension->FunctionalDeviceObject;
    ULONG_PTR emptyResourceList = 0;
    BOOLEAN ignore;

    pVideoDebugPrint((1, "videoprt: VpReleaseResources called.\n"));

    if (FdoExtension->Flags & (LEGACY_DETECT | VGA_DETECT)) {

        pVideoDebugPrint((2, "VideoPrt: VpReleaseResources LEGACY_DETECT\n"));
        IoReportResourceForDetection(FdoExtension->FunctionalDeviceObject->DriverObject,
                                     NULL,
                                     0L,
                                     DeviceObject,
                                     (PCM_RESOURCE_LIST)&emptyResourceList,
                                     sizeof (ULONG),
                                     &ignore);

    } else {

        pVideoDebugPrint((2, "VideoPrt: VpReleaseResources non-LEGACY_DETECT\n"));
        IoReportResourceUsage(&VideoClassName,
                              FdoExtension->FunctionalDeviceObject->DriverObject,
                              NULL,
                              0L,
                              DeviceObject,
                              (PCM_RESOURCE_LIST)&emptyResourceList,
                              sizeof(ULONG),
                              FALSE,
                              &ignore);
    }
}

NTSTATUS
VpAppendToRequirementsList(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *RequirementList,
    IN ULONG NumAccessRanges,
    IN PVIDEO_ACCESS_RANGE AccessRanges
    )

/*++

Routine Description:

    Builds a IoResourceRequirementsList for a given set of access ranges.

Arguments:

    ResourceList - Pointer to location of the requirments list.  Modified
        on completion to point to a new requirements list.

    NumAccessRanges - Number of access ranges in list.

    AccessRanges - List of resources.


Returns:

    STATUS_SUCCESS if successful, otherwise a status code.

Notes:

    This function free's the memory used by the original resource list,
    and allocates a new buffer for the appended resources list.

--*/

{
    PIO_RESOURCE_REQUIREMENTS_LIST OriginalRequirementList = *RequirementList;
    PIO_RESOURCE_DESCRIPTOR pioDescript;
    ULONG RequirementListSize;
    ULONG OriginalListSize;
    ULONG RequirementCount;
    ULONG i;

    RequirementCount = OriginalRequirementList->List[0].Count;
    OriginalListSize = OriginalRequirementList->ListSize;

    RequirementListSize = OriginalListSize +
                              NumAccessRanges * sizeof(IO_RESOURCE_DESCRIPTOR);

    *RequirementList =
        (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePoolWithTag(PagedPool,
                                                               RequirementListSize,
                                                               VP_TAG);

    //
    // Return NULL if the structure could not be allocated.
    // Otherwise, fill it out.
    //

    if (*RequirementList == NULL) {

        *RequirementList = OriginalRequirementList;
        return STATUS_INSUFFICIENT_RESOURCES;

    } else {

        //
        // Copy the original resource list into the new one.
        //

        memcpy(*RequirementList, OriginalRequirementList, OriginalListSize);

        //
        // Free the original list
        //

        ExFreePool(OriginalRequirementList);

        //
        // Point to first free entry in requirements list
        //

        pioDescript =
            &((*RequirementList)->List[0].Descriptors[(*RequirementList)->List[0].Count]);

        //
        // For each entry in the access range, fill in an entry in the
        // resource list
        //

        for (i = 0; i < NumAccessRanges; i++) {

            //
            // We will never claim 0xC0000.
            //

            if ((AccessRanges->RangeStart.LowPart == 0xC0000) &&
                (AccessRanges->RangeInIoSpace == FALSE))
            {
                AccessRanges++;
                continue;
            }

            if (AccessRanges->RangeLength == 0) {

                AccessRanges++;
                continue;
            }

            //
            // Watch to see if the VGA resources get added to the
            // requirements list.  If so set a flag so that we know
            // we don't need to reclaim VGA resources in FindAdapter.
            //

            if (VpIsVgaResource(AccessRanges)) {
                DeviceOwningVga = DeviceObject;
            }

            if (AccessRanges->RangeInIoSpace) {
                pioDescript->Type = CmResourceTypePort;
                pioDescript->Flags = CM_RESOURCE_PORT_IO;

                //
                // Disable 10_BIT_DECODE.  This is causing problems for the
                // PnP folks.  If someone has bad hardware, we'll just
                // require them to report all the passive port explicitly.
                //
                //if (VpIsVgaResource(AccessRanges)) {
                //
                //    pioDescript->Flags |= CM_RESOURCE_PORT_10_BIT_DECODE;
                //}

            } else {

                pioDescript->Type = CmResourceTypeMemory;
                pioDescript->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
            }

            if (AccessRanges->RangePassive & VIDEO_RANGE_PASSIVE_DECODE) {
                pioDescript->Flags |= CM_RESOURCE_PORT_PASSIVE_DECODE;
            }

            if (AccessRanges->RangePassive & VIDEO_RANGE_10_BIT_DECODE) {
                pioDescript->Flags |= CM_RESOURCE_PORT_10_BIT_DECODE;
            }

            pioDescript->ShareDisposition =
                    (AccessRanges->RangeShareable ?
                        CmResourceShareShared :
                        CmResourceShareDeviceExclusive);

            pioDescript->Option = IO_RESOURCE_PREFERRED;
            pioDescript->u.Memory.MinimumAddress = AccessRanges->RangeStart;
            pioDescript->u.Memory.MaximumAddress.QuadPart =
                                                   AccessRanges->RangeStart.QuadPart +
                                                   AccessRanges->RangeLength - 1;
            pioDescript->u.Memory.Alignment = 1;
            pioDescript->u.Memory.Length = AccessRanges->RangeLength;

            pioDescript++;
            AccessRanges++;
            RequirementCount++;
        }

        //
        // Update number of elements in list.
        //

        (*RequirementList)->List[0].Count = RequirementCount;
        (*RequirementList)->ListSize = RequirementListSize;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
pVideoPortReportResourceList(
    PDEVICE_SPECIFIC_EXTENSION DoSpecificExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges,
    PBOOLEAN Conflict,
    PDEVICE_OBJECT DeviceObject,
    BOOLEAN ClaimUnlistedResources
    )

/*++

Routine Description:

    Creates a resource list which is used to query or report resource usage
    in the system

Arguments:

    DriverObject - Pointer to the miniport's driver device extension.

    NumAccessRanges - Num of access ranges in the AccessRanges array.

    AccessRanges - Pointer to an array of access ranges used by a miniport
        driver.

    Conflict - Determines whether or not a conflict occured.

    DeviceObject - The device object to use when calling
        IoReportResourceUsage.

    ClaimUnlistedResources - If this flag is true, then the routine will
        also claim resources such as interrupts and DMA channels.

Return Value:

    Returns the final status of the operation

--*/

{
    PFDO_EXTENSION FdoExtension = DoSpecificExtension->pFdoExtension;
    PCM_RESOURCE_LIST resourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR fullResourceDescriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialResourceDescriptor;
    ULONG listLength = 0;
    ULONG size;
    ULONG i;
    ULONG Flags;
    NTSTATUS ntStatus;
    BOOLEAN overrideConflict;

#if DBG
    PVIDEO_ACCESS_RANGE SaveAccessRanges=AccessRanges;
#endif

    //
    // Create a resource list based on the information in the access range.
    // and the miniport config info.
    //

    listLength = NumAccessRanges;

    //
    // Determine if we have DMA and interrupt resources to report
    //

    if (FdoExtension->HwInterrupt &&
        ((FdoExtension->MiniportConfigInfo->BusInterruptLevel != 0) ||
         (FdoExtension->MiniportConfigInfo->BusInterruptVector != 0)) ) {

        listLength++;
    }

    if ((FdoExtension->MiniportConfigInfo->DmaChannel) &&
        (FdoExtension->MiniportConfigInfo->DmaPort)) {
       listLength++;
    }

    //
    // Allocate upper bound.
    //

    resourceList = (PCM_RESOURCE_LIST)
        ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,
                              sizeof(CM_RESOURCE_LIST) * 2 +
                                  sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) * listLength,
                              VP_TAG);

    //
    // Return NULL if the structure could not be allocated.
    // Otherwise, fill it out.
    //

    if (!resourceList) {

        return STATUS_INSUFFICIENT_RESOURCES;

    } else {

        size = sizeof(CM_RESOURCE_LIST) - sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

        resourceList->Count = 1;

        fullResourceDescriptor                = &(resourceList->List[0]);
        fullResourceDescriptor->InterfaceType = FdoExtension->AdapterInterfaceType;
        fullResourceDescriptor->BusNumber     = FdoExtension->SystemIoBusNumber;
        fullResourceDescriptor->PartialResourceList.Version  = 0;
        fullResourceDescriptor->PartialResourceList.Revision = 0;
        fullResourceDescriptor->PartialResourceList.Count    = 0;

        //
        // For each entry in the access range, fill in an entry in the
        // resource list
        //

        partialResourceDescriptor =
            &(fullResourceDescriptor->PartialResourceList.PartialDescriptors[0]);

        for (i = 0; i < NumAccessRanges; i++, AccessRanges++) {

            //
            // If someone tries to claim a range of length 0 skip it.
            //

            if (AccessRanges->RangeLength == 0) {
                continue;
            }

            if (AccessRanges->RangeInIoSpace) {

                //
        // Fix up odd Matrox legacy resources.
                //

                if ((AccessRanges->RangeStart.QuadPart == 0xCF8) &&
                    !(FdoExtension->Flags & PNP_ENABLED)) {
                    continue;
                }

                partialResourceDescriptor->Type = CmResourceTypePort;
                partialResourceDescriptor->Flags = CM_RESOURCE_PORT_IO;

                //
                // Check to see if the range should be marked as passive
                // decode.
                //

                if (AccessRanges->RangePassive & VIDEO_RANGE_PASSIVE_DECODE) {
                    partialResourceDescriptor->Flags |=
                        CM_RESOURCE_PORT_PASSIVE_DECODE;
                }

                if (AccessRanges->RangePassive & VIDEO_RANGE_10_BIT_DECODE) {
                    partialResourceDescriptor->Flags |=
                        CM_RESOURCE_PORT_10_BIT_DECODE;
                }

                //
                // If this is a 0x2E8 port with bit 14 on, and it is
                // not 0xE2E8 then mark the port as passive decode.
                //

                if (((AccessRanges->RangeStart.QuadPart & 0x43FE) == 0x42E8) &&
                    ((AccessRanges->RangeStart.QuadPart & 0xFFFC) != 0xE2E8)) {

                    pVideoDebugPrint((2, "Marking IO Port 0x%x as Passive Decode.\n",
                                         AccessRanges->RangeStart.LowPart));

                    partialResourceDescriptor->Flags |=
                        CM_RESOURCE_PORT_PASSIVE_DECODE;
                }

                //
                // ET4000 tries to claim this port but never touches it!
                //

                if ((AccessRanges->RangeStart.QuadPart & 0x217a) == 0x217a) {

                    pVideoDebugPrint((2, "Marking IO Port 0x%x as Passive Decode.\n",
                                         AccessRanges->RangeStart.LowPart));

                    partialResourceDescriptor->Flags |=
                        CM_RESOURCE_PORT_PASSIVE_DECODE;
                }

                //
                // If it is a VGA access range, mark it as 10-bit decode.
                //

                //
                // Disable 10_BIT_DECODE.  This is causing problems for the
                // PnP folks.  If someone has bad hardware, we'll just
                // require them to report all the passive port explicitly.
                //
                //if (VpIsVgaResource(AccessRanges)) {
                //
                //    partialResourceDescriptor->Flags |= CM_RESOURCE_PORT_10_BIT_DECODE;
                //}

            } else {

                //
        // Fix up odd memory resources to let legacy Trident boot.
                //

                if (AccessRanges->RangeStart.LowPart == 0x70) {
                    continue;
                }

                //
                // The device doesn't actually decode 0xC0000 so we
                // shouldn't report it as a resource.
                //

                if (AccessRanges->RangeStart.LowPart == 0xC0000) {
                    continue;
                }

                partialResourceDescriptor->Type = CmResourceTypeMemory;
                partialResourceDescriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
            }

            partialResourceDescriptor->ShareDisposition =
                    (AccessRanges->RangeShareable ?
                        CmResourceShareShared :
                        CmResourceShareDeviceExclusive);

            partialResourceDescriptor->u.Memory.Start =
                    AccessRanges->RangeStart;
            partialResourceDescriptor->u.Memory.Length =
                    AccessRanges->RangeLength;

            //
            // Increment the size for the new entry
            //

            if (!VpIsResourceInList(partialResourceDescriptor,
                                    fullResourceDescriptor,
                                    FdoExtension->RawResources))
            {
                //
                // Only include this resource if it is not in the
                // list of PnP allocated resources.
                //

                size += sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
                fullResourceDescriptor->PartialResourceList.Count += 1;
                partialResourceDescriptor++;

            }
        }

        if (ClaimUnlistedResources) {

            //
            // Fill in the entry for the interrupt if it was present.
            //

            if (FdoExtension->HwInterrupt &&
                ((FdoExtension->MiniportConfigInfo->BusInterruptLevel != 0) ||
                 (FdoExtension->MiniportConfigInfo->BusInterruptVector != 0)) ) {

                partialResourceDescriptor->Type = CmResourceTypeInterrupt;

                partialResourceDescriptor->ShareDisposition =
                        (FdoExtension->MiniportConfigInfo->InterruptShareable ?
                            CmResourceShareShared :
                            CmResourceShareDeviceExclusive);

                partialResourceDescriptor->Flags = 0;

                partialResourceDescriptor->u.Interrupt.Level =
                        FdoExtension->MiniportConfigInfo->BusInterruptLevel;
                partialResourceDescriptor->u.Interrupt.Vector =
                        FdoExtension->MiniportConfigInfo->BusInterruptVector;

                partialResourceDescriptor->u.Interrupt.Affinity = 0;

                //
                // Increment the size for the new entry
                //

                if (!VpIsResourceInList(partialResourceDescriptor,
                                        fullResourceDescriptor,
                                        FdoExtension->RawResources))
                {
                    //
                    // Only include this resource if it is not in the
                    // list of PnP allocated resources.
                    //

                    size += sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
                    fullResourceDescriptor->PartialResourceList.Count += 1;
                    partialResourceDescriptor++;

                } else {

                    pVideoDebugPrint((1, "pVideoPortReportResourceList: "
                                         "Not reporting PnP assigned resource.\n"));
                }
            }

            //
            // Fill in the entry for the DMA channel.
            //

            if ((FdoExtension->MiniportConfigInfo->DmaChannel) &&
                (FdoExtension->MiniportConfigInfo->DmaPort)) {

                partialResourceDescriptor->Type = CmResourceTypeDma;

                partialResourceDescriptor->ShareDisposition =
                        (FdoExtension->MiniportConfigInfo->DmaShareable ?
                            CmResourceShareShared :
                            CmResourceShareDeviceExclusive);

                partialResourceDescriptor->Flags = 0;

                partialResourceDescriptor->u.Dma.Channel =
                        FdoExtension->MiniportConfigInfo->DmaChannel;
                partialResourceDescriptor->u.Dma.Port =
                        FdoExtension->MiniportConfigInfo->DmaPort;

                partialResourceDescriptor->u.Dma.Reserved1 = 0;

                //
                // Increment the size for the new entry
                //

                if (!VpIsResourceInList(partialResourceDescriptor,
                                        fullResourceDescriptor,
                                        FdoExtension->RawResources))
                {
                    //
                    // Only include this resource if it is not in the
                    // list of PnP allocated resources.
                    //

                    size += sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
                    fullResourceDescriptor->PartialResourceList.Count += 1;
                    partialResourceDescriptor++;

                } else {

                    pVideoDebugPrint((1, "pVideoPortReportResourceList: "
                                         "Not reporting PnP assigned resource.\n"));
                }
            }
        }

        //
        // Determine if the conflict should be overriden.
        //

        //
        // If we are loading the VGA, do not generate an error if it conflicts
        // with another driver.
        //


        overrideConflict = pOverrideConflict(FdoExtension, TRUE);

#if DBG
        if (overrideConflict) {

            pVideoDebugPrint((2, "We are checking the vga driver resources\n"));

        } else {

            pVideoDebugPrint((2, "We are NOT checking vga driver resources\n"));

        }
#endif

        //
        // Report resources.
        //

        Flags = FdoExtension->Flags;

        if (Flags & (LEGACY_DETECT | VGA_DETECT)) {

            ntStatus = IoReportResourceForDetection(FdoExtension->FunctionalDeviceObject->DriverObject,
                                                    NULL,
                                                    0L,
                                                    DeviceObject,
                                                    resourceList,
                                                    size,
                                                    Conflict);

            if ((NT_SUCCESS(ntStatus) == FALSE) && (Flags & VGA_DETECT)) {

                //
                // There are a few occacations where reporting resources
                // for detection can fail when just calling IoReportResources
                // would have succeeded.  So, lets remove the VGA_DETECT
                // flag and try detecting resources again below.
                //

                Flags &= ~VGA_DETECT;
            }

        }

        if ((Flags & (LEGACY_DETECT | VGA_DETECT)) == 0) {

            ntStatus = IoReportResourceUsage(&VideoClassName,
                                             FdoExtension->FunctionalDeviceObject->DriverObject,
                                             NULL,
                                             0L,
                                             DeviceObject,
                                             resourceList,
                                             size,
                                             overrideConflict,
                                             Conflict);

            if (NT_SUCCESS(ntStatus)) {

                //
                // Make sure the Flags reflect the way we acquired
                // resources.
                //

                FdoExtension->Flags = Flags;

                pVideoDebugPrint((1, "Videoprt: Legacy resources claimed. "
                                     "Power management may be disabled.\n"));
            }
        }

#if DBG

        if (!NT_SUCCESS(ntStatus)) {

            //
            // We failed to get the resources we required.  Dump
            // the requested resources into the registry.
            //

            PUSHORT ValueData;
            ULONG ValueLength;
            PULONG pulData;
            PWCHAR p;
            ULONG   listLength;

            pVideoDebugPrint((1, "IoReportResourceList Failed:\n"));

            for(listLength = 0; listLength < NumAccessRanges; ++listLength) {

                pVideoDebugPrint((1, "Address: 0x%08x Length: 0x%08x I/O: %-5s Visible: %-5s Shared: %-5s\n",
                    SaveAccessRanges[listLength].RangeStart.LowPart,
                    SaveAccessRanges[listLength].RangeLength,
                    SaveAccessRanges[listLength].RangeInIoSpace ? "TRUE" : "FALSE",
                    SaveAccessRanges[listLength].RangeVisible   ? "TRUE" : "FALSE",
                    SaveAccessRanges[listLength].RangeShareable ? "TRUE" : "FALSE"));

            }

            ValueLength = NumAccessRanges *
                          (sizeof(VIDEO_ACCESS_RANGE) * 2 + 4) *
                          sizeof(USHORT) +
                          sizeof(USHORT);  // second NULL terminator for
                                           // multi_sz

            ValueData = ExAllocatePool(PagedPool,
                                       ValueLength);

            if (ValueData) {

                ULONG i, k;
                WCHAR HexDigit[] = {L"0123456789ABCDEF"};

                //
                // Convert the AccessRanges into Unicode.
                //

                p = (PWCHAR) ValueData;
                pulData = (PULONG)SaveAccessRanges;

                for (i=0; i<NumAccessRanges * 4; i++) {

                    for (k=0; k<8; k++) {
                        *p++ = HexDigit[0xf & (*pulData >> ((7-k) * 4))];
                    }

                    if ((i % 4) != 3) *p++ = (WCHAR) L' ';
                    else *p++ = UNICODE_NULL;

                    pulData++;
                }
                *p = UNICODE_NULL;

                RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                      DoSpecificExtension->DriverRegistryPath,
                                      L"RequestedResources",
                                      REG_MULTI_SZ,
                                      ValueData,
                                      ValueLength);

                ExFreePool(ValueData);
            }

        }

#endif
        if (FdoExtension->ResourceList) {

            ExFreePool(FdoExtension->ResourceList);

        }

        FdoExtension->ResourceList = resourceList;

        //
        // This is for hive compatibility back when we have the VGA driver
        // as opposed to VgaSave.
        // The Vga also cleans up the resource automatically.
        //

        //
        // If we tried to override the conflict, let's take a look a what
        // we want to do with the result
        //

        if ((NT_SUCCESS(ntStatus)) &&
            overrideConflict &&
            *Conflict) {

            //
            // For cases like Detection, a conflict is bad and we do
            // want to fail.
            //
            // In the case of Basevideo, a conflict is possible.  But we still
            // want to load the VGA anyways. Return success and reset the
            // conflict flag !
            //
            // pOverrideConflict with the FALSE flag will check that.
            //

            if (pOverrideConflict(FdoExtension, FALSE)) {

                VpReleaseResources(FdoExtension);

                ntStatus = STATUS_CONFLICTING_ADDRESSES;

            } else {

                *Conflict = FALSE;

                ntStatus = STATUS_SUCCESS;

            }
        }

        return ntStatus;
    }

} // end pVideoPortBuildResourceList()


VP_STATUS
VideoPortVerifyAccessRanges(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges
    )

/*++

Routine Description:

    VideoPortVerifyAccessRanges
    

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    NumAccessRanges - Number of entries in the AccessRanges array.

    AccessRanges - Pointer to an array of AccessRanges the miniport driver
        wants to access.

Return Value:

    ERROR_INVALID_PARAMETER in an error occured
    NO_ERROR if the call completed successfully

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    NTSTATUS status;
    BOOLEAN conflict;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // According to the DDK docs, you can free all your resources by
    // calling VideoPortVerifyAccessRanges with NumAccessRanges = 0.
    //

    if (NumAccessRanges == 0) {
        VpReleaseResources(fdoExtension);
    }

    //
    // If the device is not enabled then we won't allow the miniport
    // to claim resources for it.
    //

    if (!CheckIoEnabled(
            HwDeviceExtension,
            NumAccessRanges,
            AccessRanges)) {

        return ERROR_INVALID_PARAMETER;
    }

    //
    // All resources not passed in during the START_DEVICE irp should
    // be claimed on the FDO.  We will strip out the PDO resources
    // in pVideoPortReportResourceList if the miniport driver tries
    // to verify ranges acquired through VideoPortGetAccessRanges.
    //

    status = pVideoPortReportResourceList(
                 GET_DSP_EXT(HwDeviceExtension),
                 NumAccessRanges,
                 AccessRanges,
                 &conflict,
                 fdoExtension->FunctionalDeviceObject,
                 TRUE
                 );

    //
    // If we're upgrading, don't worry if the VGA driver can't get the
    // resources. Some older legacy driver may be loaded that consumes
    // those resources.
    //

    if ((VpSetupType == SETUPTYPE_UPGRADE) &&
        (fdoExtension->Flags & VGA_DRIVER) )
    {
        status = STATUS_SUCCESS;
        conflict = 0;
    }


    if ((NT_SUCCESS(status)) && (!conflict)) {

        //
        // Track the resources owned by the VGA driver.
        //

        if (fdoExtension->Flags & VGA_DRIVER) {

            if (VgaAccessRanges != AccessRanges) {

                ULONG Size = NumAccessRanges * sizeof(VIDEO_ACCESS_RANGE);

                if (VgaAccessRanges) {
                    ExFreePool(VgaAccessRanges);
                    VgaAccessRanges = NULL;
                    NumVgaAccessRanges = 0;
                }

                if (NumAccessRanges) {
                    VgaAccessRanges = ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION, Size, VP_TAG);

                    if (VgaAccessRanges) {
                        memcpy(VgaAccessRanges, AccessRanges, Size);
                        NumVgaAccessRanges = NumAccessRanges;
                    }
                }
            }
        }

        return NO_ERROR;

    } else {

        return ERROR_INVALID_PARAMETER;

    }

} // end VideoPortVerifyAccessRanges()

BOOLEAN
CheckIoEnabled(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges
    )

/*++

Routine Description:

    This routine ensures that IO is actually enabled if claiming
    IO ranges.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    NumAccessRanges - Number of entries in the AccessRanges array.

    AccessRanges - Pointer to an array of AccessRanges the miniport driver
        wants to access.

Return Value:

    TRUE if our IO access checks pass,
    FALSE otherwise.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    if (fdoExtension->Flags & LEGACY_DRIVER) {

        //
        // We will always return TRUE for legacy drivers.
        //

        return TRUE;
    }

    if (fdoExtension->AdapterInterfaceType == PCIBus) {

        //
        // Check to see if there are any IO ranges in the
        // list or resources.
        //

        ULONG i;
    USHORT Command;
    ULONG byteCount;

        //
        // Get the PCI Command register for this device.
        //

    byteCount = VideoPortGetBusData(
            HwDeviceExtension,
            PCIConfiguration,
            0,
            &Command,
            FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
            sizeof(USHORT));

    //
    // If the following test fails it means we couldn't get at
    // the I/O bits in the config space. Assume that the I/O is
    // on and proceed.
    //

    if (byteCount != sizeof (USHORT)) {
        ASSERT(FALSE);
        return TRUE;
    }

        for (i=0; i<NumAccessRanges; i++) {

            if (AccessRanges[i].RangeInIoSpace) {

                if (!(Command & PCI_ENABLE_IO_SPACE))
                    return FALSE;

            } else {

                if (!(Command & PCI_ENABLE_MEMORY_SPACE))
                    return FALSE;
            }
        }

        return TRUE;

    } else {

        //
        // Non-pci devices will always decode IO operations.
        //

        return TRUE;
    }
}

BOOLEAN
VpIsLegacyAccessRange(
    PFDO_EXTENSION fdoExtension,
    PVIDEO_ACCESS_RANGE AccessRange
    )

/*++

Routine Description:

    This return determines whether a given access range is
    included in the list of legacy access ranges.

Arguments:

    fdoExtension - The FDO extension for the device using the access range.

    AccessRange - The access range to look for in the resource list.

Returns:

    TRUE if the given access range is included in the list of reported
    legacy resources, FALSE otherwise.

--*/

{
    ULONG i;
    PVIDEO_ACCESS_RANGE CurrResource;

    if (fdoExtension->HwLegacyResourceList) {

        CurrResource = fdoExtension->HwLegacyResourceList;

        for (i=0; i<fdoExtension->HwLegacyResourceCount; i++) {

            if ((CurrResource->RangeStart.QuadPart ==
                 AccessRange->RangeStart.QuadPart) &&
                (CurrResource->RangeLength == AccessRange->RangeLength)) {

                return TRUE;
            }

            CurrResource++;
        }
    }

    return FALSE;
}

ULONG
GetCmResourceListSize(
    PCM_RESOURCE_LIST CmResourceList
    )

/*++

Routine Description:

    Get the size in bytes of a CmResourceList.

Arguments:

    CmResourceList - The list for which to get the size.

Returns:

    Size in bytes of the CmResourceList.

--*/

{
    PCM_FULL_RESOURCE_DESCRIPTOR    pcmFull;
    PCM_PARTIAL_RESOURCE_LIST       pcmPartial;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pcmDescript;
    ULONG i, j;

    pcmFull = &(CmResourceList->List[0]);
    for (i=0; i<CmResourceList->Count; i++) {

        pcmPartial = &(pcmFull->PartialResourceList);
        pcmDescript = &(pcmPartial->PartialDescriptors[0]);
        pcmDescript += pcmPartial->Count;
        pcmFull = (PCM_FULL_RESOURCE_DESCRIPTOR) pcmDescript;
    }

    return (ULONG)(((ULONG_PTR)pcmFull) - ((ULONG_PTR)CmResourceList));
}

PCM_RESOURCE_LIST
VpRemoveFromResourceList(
    PCM_RESOURCE_LIST OriginalList,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges
    )

/*++

Routine Description:

    Creates a new CmResourceList with the given access ranges
    removed.

Arguments:

    OriginalList - The original CmResourceList to operate on.

    NumAccessRanges - The number of entries in the remove list.

    AccessRanges - The list of ranges which should be removed from
        the list.

Returns:

    A pointer to the new CmResourceList.

Notes:

    The caller is responsible for freeing the memory returned by this
    function.

--*/

{
    PCM_RESOURCE_LIST FilteredList;
    ULONG Size = GetCmResourceListSize(OriginalList);
    ULONG remainingLength;
    ULONG ResourcesRemoved;

    FilteredList = ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION, Size, VP_TAG);

    if (FilteredList) {

        ULONG i, j, k;
        PCM_FULL_RESOURCE_DESCRIPTOR    pcmFull;
        PCM_PARTIAL_RESOURCE_LIST       pcmPartial;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR pcmDescript;

        //
        // Make a copy of the original list.
        //

        memcpy(FilteredList, OriginalList, Size);
        remainingLength = Size - sizeof(CM_RESOURCE_LIST);

        pcmFull = &(FilteredList->List[0]);
        for (i=0; i<FilteredList->Count; i++) {

            pcmPartial = &(pcmFull->PartialResourceList);
            pcmDescript = &(pcmPartial->PartialDescriptors[0]);

            ResourcesRemoved = 0;

            for (j=0; j<pcmPartial->Count; j++) {

                //
                // See if the current resource is in our legacy list.
                //

                for (k=0; k<NumAccessRanges; k++) {

                    if ((pcmDescript->u.Memory.Start.LowPart ==
                         AccessRanges[k].RangeStart.LowPart) &&
                        (AccessRanges[k].RangeStart.LowPart != 0xC0000)) {

                        //
                        // Remove the resource.
                        //

                        memmove(pcmDescript,
                                pcmDescript + 1,
                                remainingLength);

                        pcmDescript--;
                        ResourcesRemoved++;

                        break;
                    }
                }

                remainingLength -= sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
                pcmDescript++;
            }

            //
            // Update the resource count in the partial resource list
            //

            pcmPartial->Count -= ResourcesRemoved;
            if (pcmPartial->Count == 0) {
                FilteredList->Count--;
            }

            remainingLength -= sizeof(CM_PARTIAL_RESOURCE_LIST);
            pcmFull = (PCM_FULL_RESOURCE_DESCRIPTOR) pcmDescript;
        }

    } else {

        //
        // Make sure we always return a list.
        //

        ASSERT(FALSE);
        FilteredList = OriginalList;
    }

    return FilteredList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\port\videoprt.h ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    videoprt.h

Abstract:

    This module contains the structure definitions private to the video port
    driver.

Author:

    Andre Vachon (andreva) 02-Dec-1991

Notes:

Revision History:

--*/

#ifndef __VIDEOPRT_H__
#define __VIDEOPRT_H__

#define _NTDRIVER_

#ifndef FAR
#define FAR
#endif

#define _NTOSDEF_

#define INITGUID

#include "dderror.h"
#include "ntosp.h"
#include "wdmguid.h"
#include "stdarg.h"
#include "stdio.h"
#include "zwapi.h"
#include "ntiologc.h"

#include "ntddvdeo.h"
#include "video.h"
#include "ntagp.h"
#include "acpiioct.h"
#include "agp.h"
#include "inbv.h"
#include "ntrtl.h"
#include "ntiodump.h"


//
//  Forward declare some basic driver objects.
//

typedef struct _FDO_EXTENSION       *PFDO_EXTENSION;
typedef struct _CHILD_PDO_EXTENSION *PCHILD_PDO_EXTENSION;


//
// Debugging Macro
//
//
// When an IO routine is called, we want to make sure the miniport
// in question has reported its IO ports.
// VPResourceReported is TRUE when a miniport has called VideoPort-
// VerifyAccessRanges.
// It is set to FALSE as a default, and set back to FALSE when finishing
// an iteration in the loop of VideoPortInitialize (which will reset
// the default when we exit the loop also).
//
// This flag will also be set to TRUE by the VREATE entry point so that
// the IO functions always work after init.
//

#if DBG

#undef VideoDebugPrint
#define pVideoDebugPrint(arg) VideoPortDebugPrint arg

#else

#define pVideoDebugPrint(arg)

#endif

//
// Useful registry buffer length.
//

#define STRING_LENGTH 60

//
// Queue link for mapped addresses stored for unmapping
//

typedef struct _MAPPED_ADDRESS {
    struct _MAPPED_ADDRESS *NextMappedAddress;
    PVOID MappedAddress;
    PHYSICAL_ADDRESS PhysicalAddress;
    ULONG NumberOfUchars;
    ULONG RefCount;
    UCHAR InIoSpace;
    BOOLEAN bNeedsUnmapping;
    BOOLEAN bLargePageRequest;
} MAPPED_ADDRESS, *PMAPPED_ADDRESS;

//
// BusDataRegistry variables
//

typedef struct _VP_QUERY_DEVICE {
    PVOID MiniportHwDeviceExtension;
    PVOID CallbackRoutine;
    PVOID MiniportContext;
    VP_STATUS MiniportStatus;
    ULONG DeviceDataType;
} VP_QUERY_DEVICE, *PVP_QUERY_DEVICE;

typedef struct _BUGCHECK_DATA
{
    ULONG ulBugCheckCode;
    ULONG_PTR ulpBugCheckParameter1;
    ULONG_PTR ulpBugCheckParameter2;
    ULONG_PTR ulpBugCheckParameter3;
    ULONG_PTR ulpBugCheckParameter4;
} BUGCHECK_DATA, *PBUGCHECK_DATA;

//
// Definition of the data passed in for the VideoPortGetRegistryParameters
// function for the DeviceDataType.
//

#define VP_GET_REGISTRY_DATA 0
#define VP_GET_REGISTRY_FILE 1

//
// Int10 Transfer Area
//

#define VDM_TRANSFER_SEGMENT 0x2000
#define VDM_TRANSFER_OFFSET  0x0000
#define VDM_TRANSFER_LENGTH  0x1000

//
// the Extended BIOS data location
//

#define EXTENDED_BIOS_INFO_LOCATION 0x740

//
// Possible values for the InterruptFlags field in the DeviceExtension
//

#define VP_ERROR_LOGGED   0x01

//
// Port driver error logging
//

typedef struct _VP_ERROR_LOG_ENTRY {
    PVOID DeviceExtension;
    ULONG IoControlCode;
    VP_STATUS ErrorCode;
    ULONG UniqueId;
} VP_ERROR_LOG_ENTRY, *PVP_ERROR_LOG_ENTRY;


typedef struct _VIDEO_PORT_DRIVER_EXTENSION {

    UNICODE_STRING RegistryPath;
    VIDEO_HW_INITIALIZATION_DATA HwInitData;

} VIDEO_PORT_DRIVER_EXTENSION, *PVIDEO_PORT_DRIVER_EXTENSION;


//
// PnP Detection flags
//

#define PNP_ENABLED           0x001
#define LEGACY_DETECT         0x002
#define VGA_DRIVER            0x004
#define LEGACY_DRIVER         0x008
#define BOOT_DRIVER           0x010
#define REPORT_DEVICE         0x020
#define UPGRADE_FAIL_START    0x040
#define FINDADAPTER_SUCCEEDED 0x080
#define UPGRADE_FAIL_HWINIT   0x100
#define VGA_DETECT            0x200

//
// Setup flags
//

#define SETUPTYPE_NONE    0
#define SETUPTYPE_FULL    1
#define SETUPTYPE_MINI    2
#define SETUPTYPE_UPGRADE 4



//
// ResetHW Structure
//

typedef struct _VP_RESET_HW {
    PVIDEO_HW_RESET_HW ResetFunction;
    PVOID HwDeviceExtension;
} VP_RESET_HW, *PVP_RESET_HW;


//
// Videoprt allocation and DEVICE_EXTENSION header tag.
//

#define VP_TAG  0x74725076 // 'vPrt'

//
// Private EVENT support for miniport.
//

//
//  This flag indicates that the enveloping VIDEO_PORT_EVENT has a PKEVENT
//  field filled in by ObReferenceObjectByHandle(). It cannot be waited on
//  at all. Must be consistent with that in pw32kevt.h in gre.
//

#define ENG_EVENT_FLAG_IS_MAPPED_USER       0x1

//
//  This flag indicates that the enveloping VIDEO_PORT_EVENT is about to be
//  deleted and that the display driver callback is ongoing. Must be consistent
//  with that in pw32kevt.h in gre.
//

#define ENG_EVENT_FLAG_IS_INVALID           0x2

//
// NOTE: PVIDEO_PORT_EVENT is a private structure. It must be the same as
//       ENG_EVENT in pw32kevt.h for ENG/GDI.
//

typedef struct _VIDEO_PORT_EVENT {
    PVOID pKEvent;
    ULONG fFlags;
} VIDEO_PORT_EVENT, *PVIDEO_PORT_EVENT;

typedef struct _VIDEO_PORT_SPIN_LOCK {
    KSPIN_LOCK Lock;
} VIDEO_PORT_SPIN_LOCK, *PVIDEO_PORT_SPIN_LOCK;


typedef struct _VIDEO_ACPI_EVENT_CONTEXT {
    WORK_QUEUE_ITEM                   workItem;
    struct _DEVICE_SPECIFIC_EXTENSION *DoSpecificExtension;
    ULONG                             EventID;
} VIDEO_ACPI_EVENT_CONTEXT, *PVIDEO_ACPI_EVENT_CONTEXT;

//
//  The following takes the place of the EDID in the old DEVICE_EXTENSTION. this type
//  is private to the video port child enumeration code.
//

#define NO_EDID   0
#define GOOD_EDID 1
#define BAD_EDID  2


#define EDID_BUFFER_SIZE 256

#define NONEDID_SIGNATURE       0x95C3DA76

#define ACPIDDC_EXIST       0x01
#define ACPIDDC_TESTED      0x02

typedef struct __VIDEO_CHILD_DESCRIPTOR {
    VIDEO_CHILD_TYPE    Type;
    ULONG               UId;
    BOOLEAN             bACPIDevice;
    UCHAR               ACPIDDCFlag;
    BOOLEAN             ValidEDID;
    BOOLEAN             bInvalidate;
    UCHAR               Buffer[EDID_BUFFER_SIZE];
} VIDEO_CHILD_DESCRIPTOR, *PVIDEO_CHILD_DESCRIPTOR;


typedef struct __VP_DMA_ADAPTER {
    struct __VP_DMA_ADAPTER *NextVpDmaAdapter;
    PDMA_ADAPTER             DmaAdapterObject;
    ULONG                    NumberOfMapRegisters;
} VP_DMA_ADAPTER, *PVP_DMA_ADAPTER;


typedef enum _HW_INIT_STATUS
{
    HwInitNotCalled,  // HwInitialize has not yet been called
    HwInitSucceeded,  // HwInitialize has been called and succeeded
    HwInitFailed      // HwInitialize has been called and failed
} HW_INIT_STATUS, *PHW_INIT_STATUS;

typedef enum _EXTENSION_TYPE
{
    TypeFdoExtension,
    TypePdoExtension,
    TypeDeviceSpecificExtension
} EXTENSION_TYPE, *PEXTENSION_TYPE;

#define GET_DSP_EXT(p) ((((PDEVICE_SPECIFIC_EXTENSION)(p)) - 1))
#define GET_FDO_EXT(p) ((((PDEVICE_SPECIFIC_EXTENSION)(p)) - 1)->pFdoExtension)

//
// Define HW_DEVICE_EXTENSION verification macro.
//

#define IS_HW_DEVICE_EXTENSION(p) (((p) != NULL) && (GET_FDO_EXT(p)->HwDeviceExtension == (p)))
#define IS_PDO(p) (((p) != NULL) && \
                  (((PCHILD_PDO_EXTENSION)(p))->Signature == VP_TAG) && \
                  (((PCHILD_PDO_EXTENSION)(p))->ExtensionType == TypePdoExtension))
#define IS_FDO(p) (((p) != NULL) && \
                  (((PFDO_EXTENSION)(p))->Signature == VP_TAG) && \
                  (((PFDO_EXTENSION)(p))->ExtensionType == TypeFdoExtension))

typedef struct _ALLOC_ENTRY {
    PVOID Address;
    ULONG Size;
    struct _ALLOC_ENTRY *Next;
} *PALLOC_ENTRY, ALLOC_ENTRY;

//
// Device Object Specific Extension
//
// This is data that is allocated for each device object.  It contains
// a pointer back to the primary FDO_EXTENSION for the hardware device.
//

#ifdef IOCTL_VIDEO_USE_DEVICE_IN_SESSION
#define VIDEO_DEVICE_INVALID_SESSION    -1
#endif IOCTL_VIDEO_USE_DEVICE_IN_SESSION

typedef struct _DEVICE_SPECIFIC_EXTENSION {

    //
    // VideoPort signature.
    //

    ULONG Signature;

    //
    // Indicates the type of the device extension.
    //

    EXTENSION_TYPE ExtensionType;

    //
    // Pointer to the hardware specific device extension.
    //

    PFDO_EXTENSION pFdoExtension;

    //
    // Location of the miniport device extension.
    //

    PVOID HwDeviceExtension;

    //
    // Pointer to the path name indicating the path to the drivers node in
    // the registry's current control set
    //

    PWSTR DriverRegistryPath;
    ULONG DriverRegistryPathLength;

    //
    // Callout support - Physdisp of the device in GDI
    //

    PVOID             PhysDisp;
    BOOLEAN           bACPI;
    ULONG             CachedEventID;
    ULONG             AcpiVideoEventsOutstanding;

    //
    // Number used to create device object name.  (ie. Device\VideoX)
    //

    ULONG             DeviceNumber;

    //
    // Track whether the device has been opened.
    //

    BOOLEAN           DeviceOpened;

    //
    // Flags for DualView
    //

    ULONG             DualviewFlags;

    //
    // Old & New device registry paths
    //

    PWSTR DriverNewRegistryPath;
    ULONG DriverNewRegistryPathLength;

    PWSTR DriverOldRegistryPath;
    ULONG DriverOldRegistryPathLength;

#ifdef IOCTL_VIDEO_USE_DEVICE_IN_SESSION
    //
    // Session the device is currently enabled in
    //

    ULONG SessionId;
#endif IOCTL_VIDEO_USE_DEVICE_IN_SESSION

} DEVICE_SPECIFIC_EXTENSION, *PDEVICE_SPECIFIC_EXTENSION;

//
// Device Extension for the PHYSICAL Driver Object (PDO)
//

typedef struct _CHILD_PDO_EXTENSION {

    //
    // VideoPort signature.
    //

    ULONG Signature;

    //
    // Indicates the type of the device extension.
    //

    EXTENSION_TYPE ExtensionType;

    //
    // Pointer to the FDO extension.
    // It can also be used to determine if this is the PDO or FDO.
    //

    PFDO_EXTENSION pFdoExtension;

    //
    // Location of the miniport device extension.
    //

    PVOID HwDeviceExtension;

    //
    // This is only valid because ALL requests are processed synchronously.
    // NOTE: this must be consistent with DEVICE_EXTENSIONs.
    //

    KPROCESSOR_MODE          CurrentIrpRequestorMode;

    //
    //  Saved Power state to detect transitions.
    //

    DEVICE_POWER_STATE       DevicePowerState;

    //
    // Power management mappings.
    //

    DEVICE_POWER_STATE DeviceMapping[PowerSystemMaximum] ;
    BOOLEAN IsMappingReady ;

    //
    // Event object for pVideoPortDispatch synchronization.
    //

    KMUTEX                   SyncMutex;

    IO_REMOVE_LOCK RemoveLock;

    ////////////////////////////////////////////////////////////////////////////
    //
    //  END common header.
    //
    ////////////////////////////////////////////////////////////////////////////

    //
    // Non-paged copy of the UId in the VideoChildDescriptor, so we can do
    // power management at raise IRQL.
    //

    ULONG                    ChildUId;

    //
    //  Device descriptor (EDID for monitors,etc).
    //

    PVIDEO_CHILD_DESCRIPTOR  VideoChildDescriptor;

    //
    // Child PDO we created
    //

    PDEVICE_OBJECT           ChildDeviceObject;

    //
    // Child FDO
    //

    PDEVICE_OBJECT           ChildFdo;

    //
    // PDEVICE_OBJECT link pointer for enumeration.
    //

    struct _CHILD_PDO_EXTENSION*    NextChild;

    //
    //  BOOLEAN to indicate if this child device has been found
    //  in the last enumeration.
    //

    BOOLEAN		     bIsEnumerated;

    //
    // Is this a lid override case. If this variable is set to TRUE,
    // don't bring the panel out of D3.
    //

    BOOLEAN		     PowerOverride;
} CHILD_PDO_EXTENSION;


//
// Device Extension for the FUNCTIONAL Driver Object (FDO)
//

typedef struct _FDO_EXTENSION {

    //
    // VideoPort signature.
    //

    ULONG Signature;

    //
    // Indicates the type of the device extension.
    //

    EXTENSION_TYPE ExtensionType;

    //
    // Pointer to the FDO extension.
    // It can also be used to determine if this is the PDO or FDO.
    //

    PFDO_EXTENSION pFdoExtension;

    //
    // Location of the miniport device extension.
    //

    PVOID HwDeviceExtension;

    //
    // RequestorMode of the Currently processed IRP.
    // This is only valid because ALL requests are processed synchronously.
    // NOTE: this must be consistent with CHILD_PDO_EXTENSIONs.
    //

    KPROCESSOR_MODE         CurrentIrpRequestorMode;

    //
    //  Saved Power state to detect transitions.
    //

    DEVICE_POWER_STATE      DevicePowerState;

    //
    // Power management mappings.
    //

    DEVICE_POWER_STATE      DeviceMapping[PowerSystemMaximum] ;
    BOOLEAN                 IsMappingReady ;

    //
    // Monitor power override.  If TRUE, always set monitors to D3.
    //

    BOOLEAN                 OverrideMonitorPower;

    //
    // Event object for pVideoPortDispatch synchronization.
    //

    KMUTEX                  SyncMutex;

    IO_REMOVE_LOCK RemoveLock;

    ////////////////////////////////////////////////////////////////////////////
    //
    //  END common header.
    //
    ////////////////////////////////////////////////////////////////////////////

    //
    // Adapter device objects
    //

    PDEVICE_OBJECT FunctionalDeviceObject;
    PDEVICE_OBJECT PhysicalDeviceObject;
    PDEVICE_OBJECT AttachedDeviceObject;

    //
    // Point to the next FdoExtension
    //

    PFDO_EXTENSION NextFdoExtension;

    //
    // Pointer to the first Child PDO
    //

    ULONG                ChildPdoNumber;
    PCHILD_PDO_EXTENSION ChildPdoList;

    //
    // Pointer to the miniport config info so that the port driver
    // can modify it when the miniport is asking for configuration information.
    //

    PVIDEO_PORT_CONFIG_INFO MiniportConfigInfo;

    //
    // Miniport exports
    //

    PVIDEO_HW_FIND_ADAPTER         HwFindAdapter;
    PVIDEO_HW_INITIALIZE           HwInitialize;
    PVIDEO_HW_INTERRUPT            HwInterrupt;
    PVIDEO_HW_START_IO             HwStartIO;
    PVIDEO_HW_TIMER                HwTimer;
    PVIDEO_HW_POWER_SET            HwSetPowerState;
    PVIDEO_HW_POWER_GET            HwGetPowerState;
    PVIDEO_HW_START_DMA            HwStartDma;
    PVIDEO_HW_GET_CHILD_DESCRIPTOR HwGetVideoChildDescriptor;
    PVIDEO_HW_QUERY_INTERFACE      HwQueryInterface;
    PVIDEO_HW_CHILD_CALLBACK       HwChildCallback;

    //
    // Legacy resources used by the driver and reported to Plug and Play
    // via FILTER_RESOURCE_REQUIREMENTS.
    //

    PVIDEO_ACCESS_RANGE HwLegacyResourceList;
    ULONG               HwLegacyResourceCount;

    //
    // Linked list of all memory mapped io space (done through MmMapIoSpace)
    // requested by the miniport driver.
    // This list is kept so we can free up those ressources if the driver
    // fails to load or if it is unloaded at a later time.
    //

    PMAPPED_ADDRESS MappedAddressList;

    //
    // Interrupt object
    //

    PKINTERRUPT InterruptObject;

    //
    // Interrupt vector, irql and mode
    //

    ULONG InterruptVector;
    KIRQL InterruptIrql;
    KAFFINITY InterruptAffinity;
    KINTERRUPT_MODE InterruptMode;
    BOOLEAN InterruptsEnabled;

    //
    // Information about the BUS on which the adapteris located
    //

    INTERFACE_TYPE AdapterInterfaceType;
    ULONG SystemIoBusNumber;

    //
    // DPC used to log errors.
    //

    KDPC ErrorLogDpc;

    //
    // Stores the size and pointer to the EmulatorAccessEntries. These are
    // kept since they will be accessed later on when the Emulation must be
    // enabled.
    //

    ULONG NumEmulatorAccessEntries;
    PEMULATOR_ACCESS_ENTRY EmulatorAccessEntries;
    ULONG_PTR EmulatorAccessEntriesContext;

    //
    // Size of the miniport device extensions.
    //

    ULONG HwDeviceExtensionSize;

    //
    // Determines the size required to save the video hardware state
    //

    ULONG HardwareStateSize;

    //
    // Total memory usage of PTEs by a miniport driver.
    // This is used to track if the miniport is mapping too much memory
    //

    ULONG MemoryPTEUsage;

    //
    // Has the drivers HwInitialize routine been called.
    //

    HW_INIT_STATUS HwInitStatus;

    //
    // State set during an Interrupt that must be dealt with afterwards
    //

    ULONG InterruptFlags;

    //
    // LogEntry Packet so the information can be save when called from within
    // an interrupt.
    //

    VP_ERROR_LOG_ENTRY ErrorLogEntry;

    //
    // VDM and int10 support
    //

    PHYSICAL_ADDRESS VdmPhysicalVideoMemoryAddress;
    ULONG VdmPhysicalVideoMemoryLength;
    PEPROCESS VdmProcess;

    ////////////////////////////////////////////////////////////////////////////
    //
    // DMA support.
    //
    ////////////////////////////////////////////////////////////////////////////

    PVP_DMA_ADAPTER VpDmaAdapterHead;

    //
    // Adapter object returned by IoGetDmaAdapter. This is for old DMA stuff
    //

    PDMA_ADAPTER   DmaAdapterObject;

    //
    // DPC Support
    //

    KDPC Dpc;

    ////////////////////////////////////////////////////////////////////////////
    //
    // Plug and Play Support
    //
    ////////////////////////////////////////////////////////////////////////////

    PCM_RESOURCE_LIST ResourceList;
    PCM_RESOURCE_LIST AllocatedResources;   // bus driver list

    PCM_RESOURCE_LIST RawResources;         // complete list
    PCM_RESOURCE_LIST TranslatedResources;  // translated complete list

    //
    // Slot/Function number where the device is located
    //

    ULONG             SlotNumber;

    //
    // Indicates whether we can enumerate children right away, or if
    // we need to wait for HwInitialize to be called first.
    //

    BOOLEAN AllowEarlyEnumeration;

    //
    // Interface for communication with our bus driver.
    //

    BOOLEAN ValidBusInterface;
    BUS_INTERFACE_STANDARD BusInterface;

    //
    // Cache away a pointer to our driver object.
    //

    PDRIVER_OBJECT DriverObject;

    //
    // Flags that indicate type of driver (VGA, PNP, etc)
    //

    ULONG             Flags;

    //
    // ROM Support
    //

    PVOID             RomImage;

    //
    // AGP Support
    //

    AGP_BUS_INTERFACE_STANDARD     AgpInterface;

    //
    // Power management variables related to hardware reset
    //

    BOOLEAN             bGDIResetHardware;

    //
    // Index to be used for the registry path:
    //     CCS\Control\Video\[GUID]\000x
    // The index is used for dual-view and for legacy drivers 
    //

    ULONG RegistryIndex;

    //
    // Power management vaiable. If set to TRUE the device must
    // stay at D0 all the time during the system Shutdown (S5) and
    // Hibernation (S4) requests
    //

    BOOLEAN OnHibernationPath;

    //
    // Support for bugcheck reason callbacks
    //

    PVIDEO_BUGCHECK_CALLBACK BugcheckCallback;
    ULONG BugcheckDataSize;

} FDO_EXTENSION, *PFDO_EXTENSION;

#define MAXIMUM_MEM_LIMIT_K 64

//
// AGP Data Structures
//

typedef struct _REGION {
    ULONG Length;
    ULONG NumWords;     // number of USHORTs
    USHORT BitField[1];
} REGION, *PREGION;

typedef struct _PHYSICAL_RESERVE_CONTEXT
{
    ULONG Pages;
    VIDEO_PORT_CACHE_TYPE Caching;
    PVOID MapHandle;
    PHYSICAL_ADDRESS PhysicalAddress;
    PREGION Region;
    PREGION MapTable;
} PHYSICAL_RESERVE_CONTEXT, *PPHYSICAL_RESERVE_CONTEXT;

typedef struct _VIRTUAL_RESERVE_CONTEXT
{
    HANDLE ProcessHandle;
    PEPROCESS Process;
    PVOID VirtualAddress;
    PPHYSICAL_RESERVE_CONTEXT PhysicalReserveContext;
    PREGION Region;
    PREGION MapTable;
} VIRTUAL_RESERVE_CONTEXT, *PVIRTUAL_RESERVE_CONTEXT;

typedef struct _DEVICE_ADDRESS DEVICE_ADDRESS, *PDEVICE_ADDRESS;
typedef struct _DEVICE_ADDRESS
{
    ULONG BusNumber;
    ULONG Slot;
    PDEVICE_ADDRESS Next;
};

//
// Support for GetProcAddress
//

typedef struct _PROC_ADDRESS
{
    PUCHAR FunctionName;
    PVOID  FunctionAddress;
} PROC_ADDRESS, *PPROC_ADDRESS;

#define PROC(x) #x, x

//
// Power Request Context Block
//

typedef struct tagPOWER_BLOCK
{
    PKEVENT     Event;
    union {
        NTSTATUS    Status;
        ULONG       FinalFlag;
    } ;
    PIRP        Irp ;
} POWER_BLOCK, *PPOWER_BLOCK;

//
// PowerState work item
//

typedef struct _POWER_STATE_WORK_ITEM {

    WORK_QUEUE_ITEM WorkItem;
    PVOID Argument1;
    PVOID Argument2;

} POWER_STATE_WORK_ITEM, *PPOWER_STATE_WORK_ITEM;

//
// Support for backlight control
//

typedef struct _BACKLIGHT_STATUS {
    BOOLEAN bNewAPISupported;
    BOOLEAN bQuerySupportedBrightnessCalled;
    BOOLEAN bACBrightnessKnown;
    BOOLEAN bDCBrightnessKnown;
    BOOLEAN bACBrightnessInRegistry;
    BOOLEAN bDCBrightnessInRegistry;
    BOOLEAN bBIOSDefaultACKnown;
    BOOLEAN bBIOSDefaultDCKnown;
    UCHAR   ucACBrightness;
    UCHAR   ucDCBrightness;
    UCHAR   ucBIOSDefaultAC;
    UCHAR   ucBIOSDefaultDC;
    UCHAR   ucAmbientLightLevel;
} BACKLIGHT_STATUS, *PBACKLIGHT_STATUS;

//
// New registry key
//

#define SZ_GUID              L"VideoID"
#define SZ_LEGACY_KEY        L"LegacyKey"
#define SZ_VIDEO_DEVICES     L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Video"
#define SZ_USE_NEW_KEY       L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\GraphicsDrivers\\UseNewKey"
#define SZ_LIDCLOSE          L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\GraphicsDrivers\\LidCloseSetPower"
#define SZ_INITIAL_SETTINGS  L"Settings"
#define SZ_COMMON_SUBKEY     L"Video"
#define SZ_SERVICE           L"Service"


//
// Global Data
//

#if DBG
extern CHAR *BusType[];
#endif

extern ULONG VpSetupType;
extern ULONG VpSetupTypeAtBoot;
extern BOOLEAN VPFirstTime;
extern PVIDEO_WIN32K_CALLOUT Win32kCallout;
extern BOOLEAN EnableUSWC;
extern ULONG VideoDebugLevel;
extern ULONG VideoPortMaxDmaSize;
extern ULONG VideoDeviceNumber;
extern ULONG VideoChildDevices;
extern PWSTR VideoClassString;
extern UNICODE_STRING VideoClassName;
extern CONFIGURATION_TYPE VpQueryDeviceControllerType;
extern CONFIGURATION_TYPE VpQueryDevicePeripheralType;
extern ULONG VpQueryDeviceControllerNumber;
extern ULONG VpQueryDevicePeripheralNumber;
extern VP_RESET_HW HwResetHw[];
extern PFDO_EXTENSION FdoList[];
extern PFDO_EXTENSION FdoHead;
extern BOOLEAN VpBaseVideo;
extern PVOID PhysicalMemorySection;
extern PEPROCESS CsrProcess;
extern ULONG VpC0000Compatible;
extern PVOID VgaHwDeviceExtension;
extern PVIDEO_ACCESS_RANGE VgaAccessRanges;
extern ULONG NumVgaAccessRanges;
extern PDEVICE_OBJECT DeviceOwningVga;
extern PROC_ADDRESS VideoPortEntryPoints[];
extern VIDEO_ACCESS_RANGE VgaLegacyResources[];
extern PDEVICE_ADDRESS gDeviceAddressList;
extern ULONGLONG VpSystemMemorySize;
extern PDEVICE_OBJECT LCDPanelDevice;
extern KMUTEX LCDPanelMutex;
extern KMUTEX VpInt10Mutex;
extern PVOID PowerStateCallbackHandle;
extern PVOID DockCallbackHandle;
extern ULONG NumDevicesStarted;
extern BOOLEAN EnableNewRegistryKey;
extern BOOLEAN VpSetupAllowDriversToStart;
extern BOOLEAN VpSystemInitialized;

extern ULONG ServerBiosAddressSpaceInitialized;
extern BOOLEAN Int10BufferAllocated;

extern PKEVENT VpThreadStuckEvent;
extern HANDLE VpThreadStuckEventHandle;

extern PDEVICE_OBJECT VpBugcheckDeviceObject;
extern CONTEXT VpEaRecoveryContext;

extern KBUGCHECK_REASON_CALLBACK_RECORD VpCallbackRecord;
extern PVOID VpBugcheckData;
extern KMUTEX VpGlobalLock;

extern PVOID VpDump;

extern ULONG_PTR KiBugCheckData[5];  // bugcheck data exported from ntoskrnl

// {D00CE1F5-D60C-41c2-AF75-A4370C9976A3}
DEFINE_GUID(VpBugcheckGUID, 0xd00ce1f5, 0xd60c, 0x41c2, 0xaf, 0x75, 0xa4, 0x37, 0xc, 0x99, 0x76, 0xa3);

extern BACKLIGHT_STATUS VpBacklightStatus;
extern BOOLEAN VpRunningOnAC;
extern BOOLEAN VpLidCloseSetPower;

#if defined(_IA64_) || defined(_AMD64_)
PUCHAR BiosTransferArea;
#endif

typedef
BOOLEAN
(*PSYNCHRONIZE_ROUTINE) (
    PKINTERRUPT             pInterrupt,
    PKSYNCHRONIZE_ROUTINE   pkSyncronizeRoutine,
    PVOID                   pSynchContext
    );

//
// Number of legacy vga resources
//

#define NUM_VGA_LEGACY_RESOURCES 3

#define DMA_OPERATION(a) (VpDmaAdapter->DmaAdapterObject->DmaOperations->a)

//
// These macros are used to protect threads which will enter the
// miniport.  We need to guarantee that only one thread enters
// the miniport at a time.
//

#define ACQUIRE_DEVICE_LOCK(DeviceExtension)           \
    KeWaitForSingleObject(&DeviceExtension->SyncMutex, \
                          Executive,                   \
                          KernelMode,                  \
                          FALSE,                       \
                          (PTIME)NULL);

#define RELEASE_DEVICE_LOCK(DeviceExtension)           \
    KeReleaseMutex(&DeviceExtension->SyncMutex,        \
                   FALSE);

//
// Define macros to stall execution for given number of milli or micro seconds.
// Single call to KeStallExecutionProcessor() can be done for 50us max.
//

#define DELAY_MILLISECONDS(n)                               \
{                                                           \
    ULONG d_ulCount;                                        \
    ULONG d_ulTotal = 20 * (n);                             \
                                                            \
    for (d_ulCount = 0; d_ulCount < d_ulTotal; d_ulCount++) \
        KeStallExecutionProcessor(50);                      \
}

#define DELAY_MICROSECONDS(n)                               \
{                                                           \
    ULONG d_ulCount = (n);                                  \
                                                            \
    while (d_ulCount > 0)                                   \
    {                                                       \
        if (d_ulCount >= 50)                                \
        {                                                   \
            KeStallExecutionProcessor(50);                  \
            d_ulCount -= 50;                                \
        }                                                   \
        else                                                \
        {                                                   \
            KeStallExecutionProcessor(d_ulCount);           \
            d_ulCount = 0;                                  \
        }                                                   \
    }                                                       \
}

//
// Max size for secondary dump data
//

#define MAX_SECONDARY_DUMP_SIZE (0x1000 - sizeof(DUMP_BLOB_FILE_HEADER) - sizeof(DUMP_BLOB_HEADER))
//
// Private function declarations
//

//
// i386\porti386.c
// mips\portmips.c
// alpha\portalpha.c

VOID
pVideoPortInitializeInt10(
    IN PFDO_EXTENSION FdoExtension
    );

NTSTATUS
pVideoPortEnableVDM(
    IN PFDO_EXTENSION FdoExtension,
    IN BOOLEAN Enable,
    IN PVIDEO_VDM VdmInfo,
    IN ULONG VdmInfoSize
    );

NTSTATUS
pVideoPortRegisterVDM(
    IN PFDO_EXTENSION FdoExtension,
    IN PVIDEO_VDM VdmInfo,
    IN ULONG VdmInfoSize,
    OUT PVIDEO_REGISTER_VDM RegisterVdm,
    IN ULONG RegisterVdmSize,
    OUT PULONG_PTR OutputSize
    );

NTSTATUS
pVideoPortSetIOPM(
    IN ULONG NumAccessRanges,
    IN PVIDEO_ACCESS_RANGE AccessRange,
    IN BOOLEAN Enable,
    IN ULONG IOPMNumber
    );

VP_STATUS
pVideoPortGetVDMBiosData(
    IN PFDO_EXTENSION FdoExtension,
    PCHAR Buffer,
    ULONG Length
    );

NTSTATUS
pVideoPortPutVDMBiosData(
    IN PFDO_EXTENSION FdoExtension,
    PCHAR Buffer,
    ULONG Length
    );

//
// acpi.c
//

NTSTATUS
pVideoPortQueryACPIInterface(
    PDEVICE_SPECIFIC_EXTENSION FdoExtension
    );

NTSTATUS
pVideoPortDockEventCallback (
    PVOID NotificationStructure,
    PDEVICE_SPECIFIC_EXTENSION DoSpecificExtension
    );

VOID
pVideoPortACPIEventCallback(
    PDEVICE_SPECIFIC_EXTENSION pFdoObject,
    ULONG eventID
    );

VOID
pVideoPortACPIEventHandler(
    PVIDEO_ACPI_EVENT_CONTEXT EventContext
    );

NTSTATUS
pVideoPortACPIIoctl(
    IN  PDEVICE_OBJECT           DeviceObject,
    IN  ULONG                    MethodName,
    IN  PULONG                   InputParam1,
    IN  PULONG                   InputParam2,
    IN  ULONG                    OutputBufferSize,
    IN  PACPI_EVAL_OUTPUT_BUFFER pOutputBuffer
    );

VOID
VpRegisterLCDCallbacks(
    );

VOID
VpUnregisterLCDCallbacks(
    );

VOID
VpRegisterPowerStateCallback(
    VOID
    );

VOID
VpPowerStateCallback(
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    );

VOID
VpDelayedPowerStateCallback(
    IN PVOID Context
    );

NTSTATUS
VpSetLCDPowerUsage(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FullPower
    );

NTSTATUS
VpQueryBacklightLevels(
    IN  PDEVICE_OBJECT DeviceObject,
    OUT PUCHAR ucBacklightLevels,
    OUT PULONG pulNumberOfLevelsSupported
    );

//
// ddc.c
//

BOOLEAN
DDCReadEdidSegment(
    IN PVOID pHwDeviceExtension,
    IN PVIDEO_I2C_CONTROL pI2CControl,
    IN OUT PUCHAR pucEdidBuffer,
    IN ULONG ulEdidBufferSize,
    IN UCHAR ucEdidSegment,
    IN UCHAR ucEdidOffset,
    IN UCHAR ucSetOffsetAddress,
    IN UCHAR ucReadAddress,
    IN BOOLEAN bEnhancedDDC
    );

//
// dma.c
//

#if DBG

VOID
pDumpScatterGather(
    PVP_SCATTER_GATHER_LIST SGList
    );

#define DUMP_SCATTER_GATHER(SGList) pDumpScatterGather(SGList)

#else

#define DUMP_SCATTER_GATHER(SGList)

#endif

PVOID
VideoPortGetCommonBuffer(
    IN  PVOID                       HwDeviceExtension,
    IN  ULONG                       DesiredLength,
    IN  ULONG                       Alignment,
    OUT PPHYSICAL_ADDRESS           LogicalAddress,
    OUT PULONG                      ActualLength,
    IN  BOOLEAN                     CacheEnabled
    );

VOID
VideoPortFreeCommonBuffer(
    IN  PVOID                       HwDeviceExtension,
    IN  ULONG                       Length,
    IN  PVOID                       VirtualAddress,
    IN  PHYSICAL_ADDRESS            LogicalAddress,
    IN  BOOLEAN                     CacheEnabled
    );

PDMA
VideoPortDoDma(
    IN      PVOID       HwDeviceExtension,
    IN      PDMA        pDma,
    IN      DMA_FLAGS   DmaFlags
    );

BOOLEAN
VideoPortLockPages(
    IN      PVOID                   HwDeviceExtension,
    IN OUT  PVIDEO_REQUEST_PACKET   pVrp,
    IN      PEVENT                  pMappedUserEvent,
    IN      PEVENT                  pDisplayEvent,
    IN      DMA_FLAGS               DmaFlags
    );

BOOLEAN
VideoPortUnlockPages(
    PVOID   HwDeviceExtension,
    PDMA    pDma
    );

PVOID
VideoPortGetMdl(
    IN  PVOID   HwDeviceExtension,
    IN  PDMA    pDma
    );

VOID
pVideoPortListControl(
    IN PDEVICE_OBJECT        DeviceObject,
    IN PIRP                  pIrp,
    IN PSCATTER_GATHER_LIST  ScatterGather,
    IN PVOID                 Context
    );

//
// edid.c
//

BOOLEAN
pVideoPortIsValidEDID(
    PVOID Edid
    );


VOID
pVideoPortGetEDIDId(
    PVOID  pEdid,
    PWCHAR pwChar
    );

PVOID
pVideoPortGetMonitordescription(
    PVOID pEdid
    );

ULONG
pVideoPortGetEdidOemID(
    IN  PVOID   pEdid,
    OUT PUCHAR  pBuffer
    );

//
// enum.c
//

NTSTATUS
pVideoPnPCapabilities(
    IN  PCHILD_PDO_EXTENSION    PdoExtension,
    IN  PDEVICE_CAPABILITIES    Capabilities
    );

NTSTATUS
pVideoPnPResourceRequirements(
    IN  PCHILD_PDO_EXTENSION    PdoExtension,
    OUT PCM_RESOURCE_LIST *     ResourceList
    );

NTSTATUS
pVideoPnPQueryId(
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      BUS_QUERY_ID_TYPE   BusQueryIdType,
    IN  OUT PWSTR             * BusQueryId
    );

NTSTATUS
VpAddPdo(
    PDEVICE_OBJECT              DeviceObject,
    PVIDEO_CHILD_DESCRIPTOR     VideoChildDescriptor
    );

NTSTATUS
pVideoPortEnumerateChildren(
    PDEVICE_OBJECT      DeviceObject,
    PIRP                Irp
    );

NTSTATUS
pVideoPortQueryDeviceText(
    PDEVICE_OBJECT      ChildDevice,
    DEVICE_TEXT_TYPE    TextType,
    PWSTR *             ReturnValue
    );

NTSTATUS
pVideoPortCleanUpChildList(
    PFDO_EXTENSION FdoExtension,
    PDEVICE_OBJECT deviceObject
    );

//
// i2c.c
//

BOOLEAN
I2CStart(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks
    );

BOOLEAN
I2CStop(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks
    );

BOOLEAN
I2CWrite(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    IN PUCHAR pucBuffer,
    IN ULONG ulLength
    );

BOOLEAN
I2CRead(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    OUT PUCHAR pucBuffer,
    IN ULONG ulLength
    );

BOOLEAN
I2CWriteByte(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    IN UCHAR ucByte
    );

BOOLEAN
I2CReadByte(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    OUT PUCHAR pucByte,
    IN BOOLEAN bMore
    );

BOOLEAN
I2CWaitForClockLineHigh(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks
    );

//
// i2c2.c
//

BOOLEAN
I2CStart2(
    IN PVOID pHwDeviceExtension,
    IN PVIDEO_I2C_CONTROL pI2CControl
    );

BOOLEAN
I2CStop2(
    IN PVOID pHwDeviceExtension,
    IN PVIDEO_I2C_CONTROL pI2CControl
    );

BOOLEAN
I2CWrite2(
    IN PVOID pHwDeviceExtension,
    IN PVIDEO_I2C_CONTROL pI2CControl,
    IN PUCHAR pucBuffer,
    IN ULONG ulLength
    );

BOOLEAN
I2CRead2(
    IN PVOID pHwDeviceExtension,
    IN PVIDEO_I2C_CONTROL pI2CControl,
    OUT PUCHAR pucBuffer,
    IN ULONG ulLength,
    IN BOOLEAN bEndOfRead
    );

BOOLEAN
I2CWriteByte2(
    IN PVOID pHwDeviceExtension,
    IN PVIDEO_I2C_CONTROL pI2CControl,
    IN UCHAR ucByte
    );

BOOLEAN
I2CReadByte2(
    IN PVOID pHwDeviceExtension,
    IN PVIDEO_I2C_CONTROL pI2CControl,
    OUT PUCHAR pucByte,
    IN BOOLEAN bEndOfRead
    );

BOOLEAN
I2CWaitForClockLineHigh2(
    IN PVOID pHwDeviceExtension,
    IN PVIDEO_I2C_CONTROL pI2CControl
    );

//
// pnp.c
//

NTSTATUS
pVideoPortSendIrpToLowerDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
pVideoPortPowerCallDownIrpStack(
    PDEVICE_OBJECT AttachedDeviceObject,
    PIRP Irp
    );

VOID
pVideoPortHibernateNotify(
    IN PDEVICE_OBJECT Pdo,
    BOOLEAN IsVideoObject
    );

NTSTATUS
pVideoPortPnpDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
pVideoPortPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
pVideoPortPowerIrpComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
pVideoPortPowerUpComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

//
// registry.c
//

NTSTATUS
VpGetFlags(
    IN PUNICODE_STRING RegistryPath,
    PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    PULONG Flags
    );

BOOLEAN
IsMirrorDriver(
    PFDO_EXTENSION FdoExtension
    ); 

BOOLEAN
pOverrideConflict(
    PFDO_EXTENSION FdoExtension,
    BOOLEAN bSetResources
    );

NTSTATUS
pVideoPortReportResourceList(
    PDEVICE_SPECIFIC_EXTENSION DoSpecificExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges,
    PBOOLEAN Conflict,
    PDEVICE_OBJECT DeviceObject,
    BOOLEAN ClaimUnlistedResources
    );

VOID
VpReleaseResources(
    PFDO_EXTENSION FdoExtension
    );

BOOLEAN
VpIsDetection(
    PUNICODE_STRING RegistryPath
    );

NTSTATUS
VpSetEventCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

VOID
UpdateRegValue(
    IN PUNICODE_STRING RegistryPath,
    IN PWCHAR RegValue,
    IN ULONG Value
    );

//
// videoprt.c
//

NTSTATUS
pVideoPortCreateDeviceName(
    PWSTR           DeviceString,
    ULONG           DeviceNumber,
    PUNICODE_STRING UnicodeString,
    PWCHAR          UnicodeBuffer
    );

NTSTATUS
pVideoPortDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
pVideoPortSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PVOID
pVideoPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    );

PVOID
pVideoPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfUchars,
    IN UCHAR InIoSpace,
    IN BOOLEAN bLargePage
    );

NTSTATUS
pVideoPortGetDeviceDataRegistry(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

NTSTATUS
pVideoPortGetRegistryCallback(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

VOID
pVPInit(
    VOID
    );

NTSTATUS
VpInitializeBusCallback(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

NTSTATUS
VpCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    OUT PDEVICE_OBJECT *DeviceObject
    );

ULONG
VideoPortLegacyFindAdapter(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Argument2,
    IN PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext,
    IN ULONG PnpFlags
    );

NTSTATUS
VideoPortFindAdapter(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Argument2,
    IN PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext,
    PDEVICE_OBJECT DeviceObject,
    PUCHAR nextMiniport
    );

NTSTATUS
VideoPortFindAdapter2(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Argument2,
    IN PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext,
    PDEVICE_OBJECT DeviceObject,
    PUCHAR nextMiniport
    );

NTSTATUS
VpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

VOID
VpDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

VP_STATUS
VpRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

NTSTATUS
VpGetBusInterface(
    PFDO_EXTENSION FdoExtension
    );

PVOID
VpGetProcAddress(
    IN PVOID HwDeviceExtension,
    IN PUCHAR FunctionName
    );

BOOLEAN
pVideoPortInterrupt(
    IN PKINTERRUPT Interrupt,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
pVideoPortLogErrorEntry(
    IN PVOID Context
    );

VOID
pVideoPortLogErrorEntryDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
pVideoPortMapToNtStatus(
    IN PSTATUS_BLOCK StatusBlock
    );

NTSTATUS
pVideoPortMapUserPhysicalMem(
    IN PFDO_EXTENSION FdoExtension,
    IN HANDLE ProcessHandle OPTIONAL,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN OUT PULONG Length,
    IN OUT PULONG InIoSpace,
    IN OUT PVOID *VirtualAddress
    );

VOID
pVideoPortPowerCompletionIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

BOOLEAN
pVideoPortSynchronizeExecution(
    PVOID HwDeviceExtension,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE SynchronizeRoutine,
    PVOID Context
    );

VOID
pVideoPortHwTimer(
    IN PDEVICE_OBJECT DeviceObject,
    PVOID Context
    );

BOOLEAN
pVideoPortResetDisplay(
    IN ULONG Columns,
    IN ULONG Rows
    );

BOOLEAN
pVideoPortMapStoD(
    IN PVOID DeviceExtension,
    IN SYSTEM_POWER_STATE SystemState,
    OUT PDEVICE_POWER_STATE DeviceState
    );

//
// agp.c
//

BOOLEAN
VpQueryAgpInterface(
    PFDO_EXTENSION DeviceExtension,
    IN USHORT Version
    );

PHYSICAL_ADDRESS
AgpReservePhysical(
    IN PVOID Context,
    IN ULONG Pages,
    IN VIDEO_PORT_CACHE_TYPE Caching,
    OUT PVOID *PhysicalReserveContext
    );

VOID
AgpReleasePhysical(
    PVOID Context,
    PVOID PhysicalReserveContext
    );

BOOLEAN
AgpCommitPhysical(
    PVOID Context,
    PVOID PhysicalReserveContext,
    ULONG Pages,
    ULONG Offset
    );

VOID
AgpFreePhysical(
    IN PVOID Context,
    IN PVOID PhysicalReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

PVOID
AgpReserveVirtual(
    IN PVOID Context,
    IN HANDLE ProcessHandle,
    IN PVOID PhysicalReserveContext,
    OUT PVOID *VirtualReserveContext
    );

VOID
AgpReleaseVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext
    );

PVOID
AgpCommitVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

VOID
AgpFreeVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

BOOLEAN
AgpSetRate(
    IN PVOID Context,
    IN ULONG AgpRate
    );

VP_STATUS
VpGetAgpServices2(
    IN PVOID pHwDeviceExtension,
    OUT PVIDEO_PORT_AGP_INTERFACE_2 pAgpInterface
    );

//
// ???
//

BOOLEAN
CreateBitField(
    PREGION *Region,
    ULONG Length
    );

VOID
ModifyRegion(
    PREGION Region,
    ULONG Offset,
    ULONG Length,
    BOOLEAN Set
    );

BOOLEAN
FindFirstRun(
    PREGION Region,
    PULONG Offset,
    PULONG Length
    );

NTSTATUS
VpAppendToRequirementsList(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *RequirementsList,
    IN ULONG NumAccessRanges,
    IN PVIDEO_ACCESS_RANGE AccessRanges
    );

BOOLEAN
VpIsLegacyAccessRange(
    PFDO_EXTENSION fdoExtension,
    PVIDEO_ACCESS_RANGE AccessRange
    );

BOOLEAN
VpIsResourceInList(
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pResource,
    PCM_FULL_RESOURCE_DESCRIPTOR pFullResource,
    PCM_RESOURCE_LIST removeList
    );

PCM_RESOURCE_LIST
VpRemoveFromResourceList(
    PCM_RESOURCE_LIST OriginalList,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges
    );

VOID
VpEnableDisplay(
    PFDO_EXTENSION fdoExtension,
    BOOLEAN bState
    );

VOID
VpWin32kCallout(
    PVIDEO_WIN32K_CALLBACKS_PARAMS calloutParams
    );

BOOLEAN
pCheckActiveMonitor(
    PCHILD_PDO_EXTENSION pChildDeviceExtension
    );

BOOLEAN
VpAllowFindAdapter(
    PFDO_EXTENSION fdoExtension
    );

VOID
InitializePowerStruct(
    IN PIRP Irp,
    OUT PVIDEO_POWER_MANAGEMENT vpPower,
    OUT BOOLEAN * bWakeUp
    );

BOOLEAN
VpTranslateResource(
    IN PFDO_EXTENSION fdoExtension,
    IN PULONG InIoSpace,
    IN PPHYSICAL_ADDRESS PhysicalAddress,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

ULONG
GetCmResourceListSize(
    PCM_RESOURCE_LIST CmResourceList
    );

VOID
AddToResourceList(
    ULONG BusNumber,
    ULONG Slot
    );

BOOLEAN
CheckResourceList(
    ULONG BusNumber,
    ULONG Slot
    );

BOOLEAN
VpTranslateBusAddress(
    IN PFDO_EXTENSION fdoExtension,
    IN PPHYSICAL_ADDRESS IoAddress,
    IN OUT PULONG addressSpace,
    IN OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

VOID
pVideoPortDpcDispatcher(
    IN PKDPC Dpc,
    IN PVOID HwDeviceExtension,
    IN PMINIPORT_DPC_ROUTINE DpcRoutine,
    IN PVOID Context
    );

#if DBG
VOID
DumpRequirements(
    PIO_RESOURCE_REQUIREMENTS_LIST Requirements
    );

VOID
DumpResourceList(
    PCM_RESOURCE_LIST pcmResourceList
    );

PIO_RESOURCE_REQUIREMENTS_LIST
BuildRequirements(
    PCM_RESOURCE_LIST pcmResourceList
    );

VOID
DumpUnicodeString(
    IN PUNICODE_STRING p
    );
#endif

PCM_PARTIAL_RESOURCE_DESCRIPTOR
RtlUnpackPartialDesc(
    IN UCHAR Type,
    IN PCM_RESOURCE_LIST ResList,
    IN OUT PULONG Count
    );

NTSTATUS
pVideoMiniDeviceIoControl(
    IN PDEVICE_OBJECT hDevice,
    IN ULONG dwIoControlCode,
    IN PVOID lpInBuffer,
    IN ULONG nInBufferSize,
    OUT PVOID lpOutBuffer,
    IN ULONG nOutBufferSize
    );

ULONG
pVideoPortGetVgaStatusPci(
    PVOID HwDeviceExtension
    );

BOOLEAN
VpIsVgaResource(
    PVIDEO_ACCESS_RANGE AccessRange
    );

VOID
VpInterfaceDefaultReference(
    IN PVOID pContext
    );

VOID
VpInterfaceDefaultDereference(
    IN PVOID pContext
    );

BOOLEAN
VpEnableAdapterInterface(
    PDEVICE_SPECIFIC_EXTENSION DoSpecificExtension
    );

VOID
VpDisableAdapterInterface(
    PFDO_EXTENSION fdoExtension
    );

ULONG
VpGetDeviceCount(
    PVOID HwDeviceExtension
    );

VOID
VpEnableNewRegistryKey(
    PFDO_EXTENSION FdoExtension,
    PDEVICE_SPECIFIC_EXTENSION DoSpecificExtension,
    PUNICODE_STRING RegistryPath,
    ULONG RegistryIndex
    );

VOID
VpInitializeKey(
    PDEVICE_OBJECT PhysicalDeviceObject,
    PWSTR NewRegistryPath
    );
    
VOID
VpInitializeLegacyKey(
    PWSTR OldRegistryPath,
    PWSTR NewRegistryPath
    );

NTSTATUS
VpCopyRegistry(
    HANDLE hKeyRootSrc,
    HANDLE hKeyRootDst,
    PWSTR SrcKeyPath,
    PWSTR DstKeyPath 
    );

VP_STATUS
VPSetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength,
    PWSTR RegistryPath,
    ULONG RegistryPathLength
    );

VP_STATUS
VPGetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ParameterName,
    UCHAR IsParameterFileName,
    PMINIPORT_GET_REGISTRY_ROUTINE CallbackRoutine,
    PVOID Context,
    PWSTR RegistryPath,
    ULONG RegistryPathLength
    );

BOOLEAN
VpGetServiceSubkey(
    PUNICODE_STRING RegistryPath,
    HANDLE* pServiceSubKey
    );

VP_STATUS
VpInt10AllocateBuffer(
    IN PVOID Context,
    OUT PUSHORT Seg,
    OUT PUSHORT Off,
    IN OUT PULONG Length
    );

VP_STATUS
VpInt10FreeBuffer(
    IN PVOID Context,
    IN USHORT Seg,
    IN USHORT Off
    );

VP_STATUS
VpInt10ReadMemory(
    IN PVOID Context,
    IN USHORT Seg,
    IN USHORT Off,
    OUT PVOID Buffer,
    IN ULONG Length
    );

VP_STATUS
VpInt10WriteMemory(
    IN PVOID Context,
    IN USHORT Seg,
    IN USHORT Off,
    OUT PVOID Buffer,
    IN ULONG Length
    );

VP_STATUS
VpInt10CallBios(
    PVOID HwDeviceExtension,
    PINT10_BIOS_ARGUMENTS BiosArguments
    );

VOID
pVpBugcheckCallback(
    IN KBUGCHECK_CALLBACK_REASON Reason,
    IN PKBUGCHECK_REASON_CALLBACK_RECORD Record,
    IN OUT PVOID ReasonSpecificData,
    IN ULONG ReasonSpecificDataLength
    );

VOID
VpAcquireLock(
    VOID
    );

VOID
VpReleaseLock(
    VOID
    );

PVOID
VpAllocateNonPagedPoolPageAligned(
    ULONG Size
    );

VOID
pVpGeneralBugcheckHandler(
    PKBUGCHECK_SECONDARY_DUMP_DATA DumpData
    );

VOID
pVpSimulateBugcheckEA(
    VOID
    );

VOID
pVpWriteFile(
    PWSTR pwszFileName,
    PVOID pvBuffer,
    ULONG ulSize
    );

ULONG
pVpAppendSecondaryMinidumpData(
    PVOID pvSecondaryData,
    ULONG ulSecondaryDataSize,
    PVOID pvDump
    );
    
#endif // ifndef __VIDEOPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\port\amd64\portamd64.c ===
/*--

Copyright (c) 2000  Microsoft Corporation

Module Name:

    portamd64.c

Abstract:

    This is the AMD64 specific part of the video port driver.

Author:

    Andre Vachon (andreva) 10-Jan-1991

Environment:

    kernel mode only

--*/

#include "videoprt.h"
#include "emulate.h"

#define LOW_MEM_SEGMET 0

#define LOW_MEM_OFFSET 0

#define SIZE_OF_VECTOR_TABLE 0x400

#define SIZE_OF_BIOS_DATA_AREA 0x400

VOID
InitIoMemoryBase(
    VOID
    );

extern XM_STATUS x86BiosExecuteInterrupt (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL
    );

extern PVOID x86BiosTranslateAddress (
    IN USHORT Segment,
    IN USHORT Offset
    );

BOOLEAN
CallBiosEx (
    IN ULONG BiosCommand,
    IN OUT PULONG Eax,
    IN OUT PULONG Ebx,
    IN OUT PULONG Ecx,
    IN OUT PULONG Edx,
    IN OUT PULONG Esi,
    IN OUT PULONG Edi,
    IN OUT PULONG Ebp,
    IN OUT PUSHORT SegDs,
    IN OUT PUSHORT SegEs
    );

VOID
InitializeX86Int10CallEx(
    PUCHAR BiosTransferArea,
    ULONG BiosTransferLength
    );

VOID
InitializeX86Int10Call(
    PUCHAR BiosTransferArea,
    ULONG BiosTransferLength
    );

#pragma alloc_text(PAGE,InitIoMemoryBase)
#pragma alloc_text(PAGE,pVideoPortEnableVDM)
#pragma alloc_text(PAGE,VideoPortInt10)
#pragma alloc_text(PAGE,pVideoPortRegisterVDM)
#pragma alloc_text(PAGE,pVideoPortSetIOPM)
#pragma alloc_text(PAGE,VideoPortSetTrappedEmulatorPorts)
#pragma alloc_text(PAGE,pVideoPortInitializeInt10)
#pragma alloc_text(PAGE,CallBiosEx)
#pragma alloc_text(PAGE,InitializeX86Int10Call)
#pragma alloc_text(PAGE,VpInt10AllocateBuffer)
#pragma alloc_text(PAGE,VpInt10FreeBuffer)
#pragma alloc_text(PAGE,VpInt10ReadMemory)
#pragma alloc_text(PAGE,VpInt10WriteMemory)
#pragma alloc_text(PAGE,VpInt10CallBios)

//
// Initialize Default X86 bios spaces
//

PVOID IoControlBase = NULL;
PVOID IoMemoryBase =  NULL;

//
// Define global data.
//

ULONG X86BiosInitialized = FALSE;
ULONG EnableInt10Calls = FALSE;

VOID
InitIoMemoryBase(
    VOID
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/

{

    PHYSICAL_ADDRESS COMPATIBLE_PCI_PHYSICAL_BASE_ADDRESS = { 0x0};

    IoMemoryBase = (PUCHAR)MmMapIoSpace(COMPATIBLE_PCI_PHYSICAL_BASE_ADDRESS,
                                        0x100000,
                                        (MEMORY_CACHING_TYPE)MmNonCached);

    ASSERT(IoMemoryBase);

    return;
}

NTSTATUS
pVideoPortEnableVDM(
    IN PFDO_EXTENSION DeviceExtension,
    IN BOOLEAN Enable,
    IN PVIDEO_VDM VdmInfo,
    IN ULONG VdmInfoSize
    )

/*++

Routine Description:

    This routine allows the kernel video driver to unhook I/O ports or
    specific interrupts from the V86 fault handler. Operations on the
    specified ports will be forwarded back to the user-mode VDD once
    disconnection is completed.

Arguments:

    DeviceExtension - Pointer to the port driver's device extension.

    Enable - Determines if the VDM should be enabled (TRUE) or disabled
             (FALSE).

    VdmInfo - Pointer to the VdmInfo passed by the caller.

    VdmInfoSize - Size of the VdmInfo struct passed by the caller.

Return Value:

    STATUS_NOT_IMPLEMENTED

--*/

{

    return STATUS_NOT_IMPLEMENTED;

}

VP_STATUS
VideoPortInt10(
    PVOID HwDeviceExtension,
    PVIDEO_X86_BIOS_ARGUMENTS BiosArguments
    )

/*++

Routine Description:

    This function allows a miniport driver to call the kernel to perform
    an int10 operation.
    This will execute natively the BIOS ROM code on the device.

    THIS FUNCTION IS FOR X86 ONLY.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BiosArguments - Pointer to a structure containing the value of the
        basic x86 registers that should be set before calling the BIOS routine.
        0 should be used for unused registers.

Return Value:

    ERROR_INVALID_PARAMETER

--*/

{

    BOOLEAN bStatus;
    PFDO_EXTENSION deviceExtension = GET_FDO_EXT(HwDeviceExtension);
    ULONG inIoSpace = 0;
    PVOID virtualAddress;
    ULONG length;
    CONTEXT context;

    //
    // Must make sure the caller is a trusted subsystem with the
    // appropriate address space set up.
    //

    if (!SeSinglePrivilegeCheck(RtlConvertLongToLuid(SE_TCB_PRIVILEGE),
                                                     deviceExtension->CurrentIrpRequestorMode)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Now call the HAL to actually perform the int 10 operation.
    //

    pVideoDebugPrint((3, "VIDEOPRT: Int10: edi %x esi %x eax %x ebx %x \n\t ecx %x edx %x ebp %x\n",
                     BiosArguments->Edi,
                     BiosArguments->Esi,
                     BiosArguments->Eax,
                     BiosArguments->Ebx,
                     BiosArguments->Ecx,
                     BiosArguments->Edx,
                     BiosArguments->Ebp));

    //
    // Need to protect HalCallBios fro reentrance
    //

    KeWaitForSingleObject(&VpInt10Mutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          (PTIME)NULL);

    bStatus = HalCallBios(0x10,
                          &(BiosArguments->Eax),
                          &(BiosArguments->Ebx),
                          &(BiosArguments->Ecx),
                          &(BiosArguments->Edx),
                          &(BiosArguments->Esi),
                          &(BiosArguments->Edi),
                          &(BiosArguments->Ebp));

    KeReleaseMutex(&VpInt10Mutex, FALSE);
    if (bStatus) {
        pVideoDebugPrint ((3, "VIDEOPRT: Int10: Int 10 succeded properly\n"));
        return NO_ERROR;

    } else {

        pVideoDebugPrint ((0, "VIDEOPRT: Int10: Int 10 failed\n"));
        return ERROR_INVALID_PARAMETER;
    }

}

NTSTATUS
pVideoPortRegisterVDM(
    IN PFDO_EXTENSION DeviceExtension,
    IN PVIDEO_VDM VdmInfo,
    IN ULONG VdmInfoSize,
    OUT PVIDEO_REGISTER_VDM RegisterVdm,
    IN ULONG RegisterVdmSize,
    OUT PULONG_PTR OutputSize
    )

/*++

Routine Description:

    This routine is used to register a VDM when it is started up.

    What this routine does is map the VIDEO BIOS into the VDM address space
    so that DOS apps can use it directly. Since the BIOS is READ_ONLY, we
    have no problem in mapping it as many times as we want.

    It returns the size of the save state buffer that must be allocated by
    the caller.

Arguments:


Return Value:

    STATUS_NOT_IMPLEMENTED

--*/

{

    return STATUS_NOT_IMPLEMENTED;

}

NTSTATUS
pVideoPortSetIOPM(
    IN ULONG NumAccessRanges,
    IN PVIDEO_ACCESS_RANGE AccessRange,
    IN BOOLEAN Enable,
    IN ULONG IOPMNumber
    )

/*++

Routine Description:

    This routine is used to change the IOPM.
    This routine is x86 specific.

Arguments:


Return Value:

    STATUS_NOT_IMPLEMENTED

--*/

{

    return STATUS_NOT_IMPLEMENTED;

}

VP_STATUS
VideoPortSetTrappedEmulatorPorts(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRange
    )

/*++

Routine Description:

    VideoPortSetTrappedEmulatorPorts (x86 machines only) allows a miniport
    driver to dynamically change the list of I/O ports that are trapped when
    a VDM is running in full-screen mode. The default set of ports being
    trapped by the miniport driver is defined to be all ports in the
    EMULATOR_ACCESS_ENTRY structure of the miniport driver.
    I/O ports not listed in the EMULATOR_ACCESS_ENTRY structure are
    unavailable to the MS-DOS application.  Accessing those ports causes a
    trap to occur in the system, and the I/O operation to be reflected to a
    user-mode virtual device driver.

    The ports listed in the specified VIDEO_ACCESS_RANGE structure will be
    enabled in the I/O Permission Mask (IOPM) associated with the MS-DOS
    application.  This will enable the MS-DOS application to access those I/O
    ports directly, without having the IO instruction trap and be passed down
    to the miniport trap handling functions (for example EmulatorAccessEntry
    functions) for validation.  However, the subset of critical IO ports must
    always remain trapped for robustness.

    All MS-DOS applications use the same IOPM, and therefore the same set of
    enabled/disabled I/O ports.  Thus, on each switch of application, the
    set of trapped I/O ports is reinitialized to be the default set of ports
    (all ports in the EMULATOR_ACCESS_ENTRY structure).

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    NumAccessRanges - Specifies the number of entries in the VIDEO_ACCESS_RANGE
        structure specified in AccessRange.

    AccessRange - Points to an array of access ranges (VIDEO_ACCESS_RANGE)
        defining the ports that can be untrapped and accessed directly by
        the MS-DOS application.

Return Value:

    This function returns the final status of the operation.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{

    return ERROR_INVALID_PARAMETER;

}

VOID
VideoPortZeroDeviceMemory(
    IN PVOID Destination,
    IN ULONG Length
    )

/*++

Routine Description:

    VideoPortZeroDeviceMemory zeroes a block of device memory of a certain
    length (Length) located at the address specified in Destination.

Arguments:

    Destination - Specifies the starting address of the block of memory to be
        zeroed.

    Length - Specifies the length, in bytes, of the memory to be zeroed.

 Return Value:

    None.

--*/

{

    RtlZeroMemory(Destination,Length);
    return;
}

VOID
pVideoPortInitializeInt10(
    PFDO_EXTENSION FdoExtension
    )

{
    if (ServerBiosAddressSpaceInitialized) {
        return;
    }

    BiosTransferArea = ExAllocatePool(PagedPool, 0x1000 + 3);
    InitializeX86Int10Call(BiosTransferArea, 0x1000);

    ServerBiosAddressSpaceInitialized = TRUE;
    return;
}


BOOLEAN
CallBiosEx (
    IN ULONG BiosCommand,
    IN OUT PULONG Eax,
    IN OUT PULONG Ebx,
    IN OUT PULONG Ecx,
    IN OUT PULONG Edx,
    IN OUT PULONG Esi,
    IN OUT PULONG Edi,
    IN OUT PULONG Ebp,
    IN OUT PUSHORT SegDs,
    IN OUT PUSHORT SegEs
    )

/*++

Routine Description:

    This function provides the platform specific interface between a device
    driver and the execution of the x86 ROM bios code for the specified ROM
    bios command.

Arguments:

    BiosCommand - Supplies the ROM bios command to be emulated.

    Eax to Ebp - Supplies the x86 emulation context.

Return Value:

    A value of TRUE is returned if the specified function is executed.
    Otherwise, a value of FALSE is returned.

--*/

{

    XM86_CONTEXT Context;

    //
    // If the x86 BIOS Emulator has not been initialized, then return FALSE.
    //

    if (X86BiosInitialized == FALSE) {
        return FALSE;
    }

    //
    // If the Adapter BIOS initialization failed and an Int10 command is
    // specified, then return FALSE.
    //

    if ((BiosCommand == 0x10) && (EnableInt10Calls == FALSE)) {
        return FALSE;
    }

    //
    // Copy the x86 bios context and emulate the specified command.
    //

    Context.Eax = *Eax;
    Context.Ebx = *Ebx;
    Context.Ecx = *Ecx;
    Context.Edx = *Edx;
    Context.Esi = *Esi;
    Context.Edi = *Edi;
    Context.Ebp = *Ebp;
    Context.SegDs = *SegDs;
    Context.SegEs = *SegEs;
    if (x86BiosExecuteInterrupt((UCHAR)BiosCommand,
                                &Context,
                                (PVOID)IoControlBase,
                                (PVOID)IoMemoryBase) != XM_SUCCESS) {

        return FALSE;
    }

    //
    // Copy the x86 bios context and return TRUE.
    //

    *Eax = Context.Eax;
    *Ebx = Context.Ebx;
    *Ecx = Context.Ecx;
    *Edx = Context.Edx;
    *Esi = Context.Esi;
    *Edi = Context.Edi;
    *Ebp = Context.Ebp;
    *SegDs = Context.SegDs;
    *SegEs = Context.SegEs;
    return TRUE;
}

VOID
InitializeX86Int10Call(
    PUCHAR BiosTransferArea,
    ULONG BiosTransferLength
    )

/*++

Routine Description:

    This function initializes x86 bios emulator, display data area and
    interrupt vector area.


Arguments:

    None.

Return Value:

    None.

--*/

{

    XM86_CONTEXT State;
    PXM86_CONTEXT Context;
    PULONG x86BiosLowMemoryPtr, PhysicalMemoryPtr;

    //
    // Initialize the x86 bios emulator.
    //

    InitIoMemoryBase();
    x86BiosInitializeBiosEx(IoControlBase,
                            IoMemoryBase,
                            BiosTransferArea,
                            BiosTransferLength);

    x86BiosLowMemoryPtr = (PULONG)(x86BiosTranslateAddress(LOW_MEM_SEGMET, LOW_MEM_OFFSET));
    PhysicalMemoryPtr   = (PULONG) IoMemoryBase;

    //
    // Copy the VECTOR TABLE from 0 to 2k. This is because we are not executing
    // the initialization of Adapter since SAL takes care of it. However, the
    // emulation memory needs to be updated from the interrupt vector and BIOS
    // data area.
    //

    RtlCopyMemory(x86BiosLowMemoryPtr,
                  PhysicalMemoryPtr,
                  (SIZE_OF_VECTOR_TABLE+SIZE_OF_BIOS_DATA_AREA));


    X86BiosInitialized = TRUE;
    EnableInt10Calls = TRUE;
    return;
}

VP_STATUS
VpInt10AllocateBuffer(
    IN PVOID Context,
    OUT PUSHORT Seg,
    OUT PUSHORT Off,
    IN OUT PULONG Length
    )

{

    VP_STATUS Status = STATUS_INSUFFICIENT_RESOURCES;

    if (Int10BufferAllocated == FALSE) {
        if (*Length <= 0x1000) {
            *Seg = VDM_TRANSFER_SEGMENT;
            *Off = VDM_TRANSFER_OFFSET;
            Int10BufferAllocated = TRUE;
            Status = NO_ERROR;
        }
    }

    *Length = VDM_TRANSFER_LENGTH;
    return Status;
}

VP_STATUS
VpInt10FreeBuffer(
    IN PVOID Context,
    IN USHORT Seg,
    IN USHORT Off
    )

{

    VP_STATUS Status = STATUS_INVALID_PARAMETER;

    if ((Seg == VDM_TRANSFER_SEGMENT) && (Off = VDM_TRANSFER_OFFSET)) {
        if (Int10BufferAllocated == TRUE) {
            Int10BufferAllocated = FALSE;
            Status = NO_ERROR;
        }
    }

    return Status;
}

VP_STATUS
VpInt10ReadMemory(
    IN PVOID Context,
    IN USHORT Seg,
    IN USHORT Off,
    OUT PVOID Buffer,
    IN ULONG Length
    )

{

    ULONG_PTR Address = ((Seg << 4) + Off);

    if ((Address >= (VDM_TRANSFER_SEGMENT << 4)) &&
        ((Address + Length) <= ((VDM_TRANSFER_SEGMENT << 4) + VDM_TRANSFER_LENGTH))) {

        PUCHAR Memory = BiosTransferArea + Address - (VDM_TRANSFER_SEGMENT << 4);
        RtlCopyMemory(Buffer, Memory, Length);

    } else {

        RtlCopyMemory(Buffer, (PUCHAR)IoMemoryBase + Address, Length);
    }

    return NO_ERROR;
}

VP_STATUS
VpInt10WriteMemory(
    IN PVOID Context,
    IN USHORT Seg,
    IN USHORT Off,
    IN PVOID Buffer,
    IN ULONG Length
    )

{

    ULONG_PTR Address = ((Seg << 4) + Off);

    if ((Address >= (VDM_TRANSFER_SEGMENT << 4)) &&
        ((Address + Length) <= ((VDM_TRANSFER_SEGMENT << 4) + VDM_TRANSFER_LENGTH))) {

        PUCHAR Memory = BiosTransferArea + Address - (VDM_TRANSFER_SEGMENT << 4);

        RtlCopyMemory(Memory, Buffer, Length);

    } else {

        return STATUS_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

VP_STATUS
VpInt10CallBios(
    PVOID HwDeviceExtension,
    PINT10_BIOS_ARGUMENTS BiosArguments
    )

/*++

Routine Description:

    This function allows a miniport driver to call the kernel to perform
    an int10 operation.
    This will execute natively the BIOS ROM code on the device.

    THIS FUNCTION IS FOR X86 ONLY.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BiosArguments - Pointer to a structure containing the value of the
        basic x86 registers that should be set before calling the BIOS routine.
        0 should be used for unused registers.

Return Value:

    ERROR_INVALID_PARAMETER

--*/

{

    BOOLEAN bStatus;
    PFDO_EXTENSION deviceExtension = GET_FDO_EXT(HwDeviceExtension);
    ULONG inIoSpace = 0;
    PVOID virtualAddress;
    ULONG length;
    CONTEXT context;

    //
    // Must make sure the caller is a trusted subsystem with the
    // appropriate address space set up.
    //

    if (!SeSinglePrivilegeCheck(RtlConvertLongToLuid(
                                    SE_TCB_PRIVILEGE),
                                deviceExtension->CurrentIrpRequestorMode)) {

        return ERROR_INVALID_PARAMETER;

    }

    if (ServerBiosAddressSpaceInitialized == 0) {

        ASSERT(FALSE);

        return ERROR_INVALID_PARAMETER;
    }

    //
    // Now call the HAL to actually perform the int 10 operation.
    //

    pVideoDebugPrint((3, "VIDEOPRT: Int10: edi %x esi %x eax %x ebx %x \n\t ecx %x edx %x ebp %x ds %x es %x\n",
                     BiosArguments->Edi,
                     BiosArguments->Esi,
                     BiosArguments->Eax,
                     BiosArguments->Ebx,
                     BiosArguments->Ecx,
                     BiosArguments->Edx,
                     BiosArguments->Ebp,
                     BiosArguments->SegDs,
                     BiosArguments->SegEs ));

    KeWaitForSingleObject(&VpInt10Mutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          (PTIME)NULL);

    bStatus = CallBiosEx(0x10,
                         &(BiosArguments->Eax),
                         &(BiosArguments->Ebx),
                         &(BiosArguments->Ecx),
                         &(BiosArguments->Edx),
                         &(BiosArguments->Esi),
                         &(BiosArguments->Edi),
                         &(BiosArguments->Ebp),
                         &(BiosArguments->SegDs),
                         &(BiosArguments->SegEs));

    KeReleaseMutex(&VpInt10Mutex, FALSE);

    if (bStatus) {
        pVideoDebugPrint ((3, "VIDEOPRT: Int10: Int 10 succeded properly\n"));
        return NO_ERROR;

    } else {
        pVideoDebugPrint ((0, "VIDEOPRT: Int10: Int 10 failed\n"));
        return ERROR_INVALID_PARAMETER;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\port\vpdata.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

  vpdata.c

Abstract:

    Global data module for the video port

Author:

    Andre Vachon (andreva) 12-Jul-1997

Environment:

    kernel mode only

Notes:

    This module is a driver which implements OS dependant functions on the
    behalf of the video drivers

Revision History:

--*/

#include "videoprt.h"

//
//
// Data that is NOT pageable
//
//

//
// Globals to support HwResetHw function
//

VP_RESET_HW HwResetHw[6];

//
// Globals array of Fdos for debugging purpose
//

PFDO_EXTENSION FdoList[8];

//
// Head of Fdo list
//

PFDO_EXTENSION FdoHead = NULL;

//
// Debug Level for output routine (not pageable because VideoDebugPrint
// can be called at raised irql.
//

ULONG VideoDebugLevel = 0;

//
// Variable used to so int10 support.
//

PEPROCESS CsrProcess = NULL;

//
// Bugcheck Reason Callback support
//

KBUGCHECK_REASON_CALLBACK_RECORD VpCallbackRecord;

//
// Pointer to bugcheck data buffer
//

PVOID VpBugcheckData;

//
// Device Object for the device which caused the bugcheck EA
//

PDEVICE_OBJECT VpBugcheckDeviceObject;

//
//
// Data that IS pageable
//
//

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE_DATA")
#endif

//
// EA recovery event and event handle
//

PKEVENT VpThreadStuckEvent = NULL;
HANDLE  VpThreadStuckEventHandle = NULL;

//
// The dump buffer fro EA recovery
//

PVOID VpDump = NULL;

//
// Global videoprt lock
//

KMUTEX VpGlobalLock;

//
// Are we running setup ? This will never change once set.
//

ULONG VpSetupTypeAtBoot = 0;

//
// Are we running setup ? This may change when we start I/O.
//

ULONG VpSetupType = 0;

//
// Used to do first time initialization of the video port.
//

BOOLEAN VPFirstTime = TRUE;

//
// Callbacks to win32k
//

PVIDEO_WIN32K_CALLOUT Win32kCallout = NULL;

//
// Disable USWC is case the machine does not work properly with it.
//

BOOLEAN EnableUSWC = TRUE;

//
// Maximal total amount of memory we'll lock down.
//

ULONG VideoPortMaxDmaSize = 0;

//
// Count to determine the number of video devices
//

ULONG VideoDeviceNumber = 0;
ULONG VideoChildDevices = 0;

//
// Registry Class in which all video information is stored.
//

PWSTR VideoClassString = L"VIDEO";
UNICODE_STRING VideoClassName = {10,12,L"VIDEO"};

//
// Global variables used to keep track of where controllers or peripherals
// are found by IoQueryDeviceDescription
//

CONFIGURATION_TYPE VpQueryDeviceControllerType = DisplayController;
CONFIGURATION_TYPE VpQueryDevicePeripheralType = MonitorPeripheral;
ULONG VpQueryDeviceControllerNumber = 0;
ULONG VpQueryDevicePeripheralNumber = 0;

//
// Global used to determine if we are running in BASEVIDEO mode.
//
// If we are, we don't want to generate a conflict for the VGA driver resources
// if there is one.
// We also want to write a volatile key in the registry indicating we booted
// in beasevideo so the display driver loading code can handle it properly
//

BOOLEAN VpBaseVideo = FALSE;

//
// Pointer to physical memory. It is created during driver initialization
// and is only closed when the driver is closed.
//

PVOID PhysicalMemorySection = NULL;

//
// Variable to determine if there is a ROM at physical address C0000 on which
// we can do the int 10
//

ULONG VpC0000Compatible = 0;

//
// HwDeviceExtension of the VGA miniport driver, if it is loaded.
//

PVOID VgaHwDeviceExtension = NULL;

//
// Pointer to list of bus addresses for devices which have been assigned
// resources.
//

PDEVICE_ADDRESS gDeviceAddressList;

//
// Store the amount of physical memory in the machine.
//

ULONGLONG VpSystemMemorySize;

//
// Store the device object that is the LCD panel for dimming and for
// lid closure purposes.
//

PDEVICE_OBJECT LCDPanelDevice = NULL;

//
// LCD Panel Device Object Mutex
//

KMUTEX LCDPanelMutex;

//
// Int10 Mutex
//

KMUTEX VpInt10Mutex;

//
// Handle to PowerState callback
//

PVOID PowerStateCallbackHandle = NULL;

//
// Handle to Dock/Undock callback
//

PVOID DockCallbackHandle = NULL;

//
// Keep track of the number of devices which have started
//

ULONG NumDevicesStarted = 0;

//
// Use the new way of generating the registry path 
//

BOOLEAN EnableNewRegistryKey = FALSE;

//
// We want to use the VGA driver during setup.  We don't want any pre-installed
// driver to work until after the VGA driver has been initialized.  This way
// if there is a bad PNP driver which won't work on the current OS, we have
// time to replace it before trying to start it.
//

BOOLEAN VpSetupAllowDriversToStart = FALSE;

//
// Lets track whether or not any devices have had HwInitialize called on them
// so that we can force legacy drivers to start after the system is initialized.
//

BOOLEAN VpSystemInitialized = FALSE;

//
// Track whether we are running AC or DC.
//
// By default, this will be true.  If we are actually running on DC, when we boot,
//  VpPowerStateCallback will be called notifying us.  If we are running on AC, we
//  will not be called.  We will therefore assume AC and track the state in
//  VpSetLCDPowerUsage.
//

BOOLEAN VpRunningOnAC = TRUE;

//
// We track the state of the backlight in this structure.
//

BACKLIGHT_STATUS VpBacklightStatus;

//
// Most laptops respond incorrectly to HwSetPowerState calls
//  on lid close.  By default, we will support the XP behavior
//  and not notify the miniport on lid close.
//

BOOLEAN VpLidCloseSetPower = FALSE;

//
// This structure describes to which ports access is required.
//

#define MEM_VGA               0xA0000
#define MEM_VGA_SIZE          0x20000
#define VGA_BASE_IO_PORT      0x000003B0
#define VGA_START_BREAK_PORT  0x000003BB
#define VGA_END_BREAK_PORT    0x000003C0
#define VGA_MAX_IO_PORT       0x000003DF


PVIDEO_ACCESS_RANGE VgaAccessRanges = NULL;
ULONG               NumVgaAccessRanges = 0;
PDEVICE_OBJECT      DeviceOwningVga = NULL;


VIDEO_ACCESS_RANGE VgaLegacyResources[NUM_VGA_LEGACY_RESOURCES] = {
{
    VGA_BASE_IO_PORT, 0x00000000,
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT+ 1,
    1,
    1,
    1
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
    1
},
{
    MEM_VGA, 0x00000000,
    MEM_VGA_SIZE,
    0,
    1,
    1
}
};

//
// Control Whether or not the bottom MEG of the CSR address space has
// already been committed.
//

ULONG ServerBiosAddressSpaceInitialized = 0;
BOOLEAN Int10BufferAllocated = FALSE;

#if defined(_IA64_) || defined(_AMD64_)
PUCHAR BiosTransferArea = NULL;
#endif

#if DBG

CHAR *BusType[] = { "Internal",
                    "Isa",
                    "Eisa",
                    "MicroChannel",
                    "TurboChannel",
                    "PCIBus",
                    "VMEBus",
                    "NuBus",
                    "PCMCIABus",
                    "CBus",
                    "MPIBus",
                    "MPSABus",
                    "ProcessorInternal",
                    "InternalPowerBus",
                    "PNPISABus",
                    "MaximumInterfaceType"
                };
#endif

PROC_ADDRESS VideoPortEntryPoints[] =
{
    PROC(VideoPortDDCMonitorHelper),
    PROC(VideoPortDoDma),
    PROC(VideoPortGetCommonBuffer),
    PROC(VideoPortGetMdl),
    PROC(VideoPortLockPages),
    PROC(VideoPortSignalDmaComplete),
    PROC(VideoPortUnlockPages),
    PROC(VideoPortAssociateEventsWithDmaHandle),
    PROC(VideoPortGetBytesUsed),
    PROC(VideoPortSetBytesUsed),
    PROC(VideoPortGetDmaContext),
    PROC(VideoPortSetDmaContext),
    PROC(VideoPortMapDmaMemory),
    PROC(VideoPortUnmapDmaMemory),
    PROC(VideoPortGetAgpServices),
    PROC(VideoPortAllocateContiguousMemory),
    PROC(VideoPortGetRomImage),
    PROC(VideoPortGetAssociatedDeviceExtension),
    PROC(VideoPortGetAssociatedDeviceID),
    PROC(VideoPortAcquireDeviceLock),
    PROC(VideoPortReleaseDeviceLock),
    PROC(VideoPortAllocateBuffer),
    PROC(VideoPortFreeCommonBuffer),
    PROC(VideoPortMapDmaMemory),
    PROC(VideoPortReleaseBuffer),
    PROC(VideoPortInterlockedIncrement),
    PROC(VideoPortInterlockedDecrement),
    PROC(VideoPortInterlockedExchange),
    PROC(VideoPortGetVgaStatus),
    PROC(VideoPortQueueDpc),
    PROC(VideoPortEnumerateChildren),
    PROC(VideoPortQueryServices),
    PROC(VideoPortGetDmaAdapter),
    PROC(VideoPortPutDmaAdapter),
    PROC(VideoPortAllocateCommonBuffer),
    PROC(VideoPortReleaseCommonBuffer),
    PROC(VideoPortLockBuffer),
    PROC(VideoPortUnlockBuffer),
    PROC(VideoPortStartDma),
    PROC(VideoPortCompleteDma),
    PROC(VideoPortCreateEvent),
    PROC(VideoPortDeleteEvent),
    PROC(VideoPortSetEvent),
    PROC(VideoPortClearEvent),
    PROC(VideoPortReadStateEvent),
    PROC(VideoPortWaitForSingleObject),
    PROC(VideoPortAllocatePool),
    PROC(VideoPortFreePool),
    PROC(VideoPortCreateSpinLock),
    PROC(VideoPortDeleteSpinLock),
    PROC(VideoPortAcquireSpinLock),
    PROC(VideoPortAcquireSpinLockAtDpcLevel),
    PROC(VideoPortReleaseSpinLock),
    PROC(VideoPortReleaseSpinLockFromDpcLevel),
    PROC(VideoPortCheckForDeviceExistence),
    PROC(VideoPortCreateSecondaryDisplay),
    PROC(VideoPortFlushRegistry),
    PROC(VideoPortQueryPerformanceCounter),
    PROC(VideoPortGetVersion),
    PROC(VideoPortRegisterBugcheckCallback),
   {NULL, NULL}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\port\videoprt.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

  videoprt.c

Abstract:

    This is the NT Video port driver.

Author:

    Andre Vachon (andreva) 18-Dec-1991

Environment:

    kernel mode only

Notes:

    This module is a driver which implements OS dependant functions on the
    behalf of the video drivers

Revision History:

--*/

#define INITGUID

#include "videoprt.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,pVideoPortCreateDeviceName)
#pragma alloc_text(PAGE,pVideoPortDispatch)
#pragma alloc_text(PAGE,VideoPortFreeDeviceBase)
#pragma alloc_text(PAGE,pVideoPortFreeDeviceBase)
#pragma alloc_text(PAGE,pVideoPortGetDeviceBase)
#pragma alloc_text(PAGE,VideoPortGetDeviceBase)
#pragma alloc_text(PAGE,pVideoPortGetDeviceDataRegistry)
#pragma alloc_text(PAGE,VideoPortGetDeviceData)
#pragma alloc_text(PAGE,pVideoPortGetRegistryCallback)
#pragma alloc_text(PAGE,VideoPortGetRegistryParameters)
#pragma alloc_text(PAGE,pVPInit)
#pragma alloc_text(PAGE,VpInitializeBusCallback)
#pragma alloc_text(PAGE,VpDriverUnload)
#pragma alloc_text(PAGE,VpAddDevice)
#pragma alloc_text(PAGE,VpCreateDevice)
#pragma alloc_text(PAGE,VideoPortInitialize)
#pragma alloc_text(PAGE,UpdateRegValue)
#pragma alloc_text(PAGE,VideoPortLegacyFindAdapter)
#pragma alloc_text(PAGE,VideoPortFindAdapter2)
#pragma alloc_text(PAGE,VideoPortFindAdapter)
#pragma alloc_text(PAGE,pVideoPortMapToNtStatus)
#pragma alloc_text(PAGE,pVideoPortMapUserPhysicalMem)
#pragma alloc_text(PAGE,VideoPortMapMemory)
#pragma alloc_text(PAGE,VideoPortMapBankedMemory)
#pragma alloc_text(PAGE,VideoPortAllocateBuffer)
#pragma alloc_text(PAGE,VideoPortReleaseBuffer)
#pragma alloc_text(PAGE,VideoPortScanRom)
#pragma alloc_text(PAGE,VideoPortSetRegistryParameters)
#pragma alloc_text(PAGE,VideoPortUnmapMemory)
#pragma alloc_text(PAGE,VpEnableDisplay)
#pragma alloc_text(PAGE,VpWin32kCallout)
#pragma alloc_text(PAGE,VpAllowFindAdapter)
#pragma alloc_text(PAGE,VpTranslateBusAddress)
#if DBG
#pragma alloc_text(PAGE,BuildRequirements)
#pragma alloc_text(PAGE,DumpRequirements)
#pragma alloc_text(PAGE,DumpResourceList)
#pragma alloc_text(PAGE,DumpUnicodeString)
#endif
#pragma alloc_text(PAGE,VideoPortCreateSecondaryDisplay)
#pragma alloc_text(PAGE,VideoPortQueryServices)
#pragma alloc_text(PAGE,VpInterfaceDefaultReference)
#pragma alloc_text(PAGE,VpInterfaceDefaultDereference)
#pragma alloc_text(PAGE,VpEnableAdapterInterface)
#pragma alloc_text(PAGE,VpDisableAdapterInterface)

// 
// VideoPortQueryPerformanceCounter() cannot be pageable.
//

#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Temporary entry point needed to initialize the video port driver.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

Return Value:

   STATUS_SUCCESS

--*/

{
    UNREFERENCED_PARAMETER(DriverObject);
    ASSERT(0);

    //
    //
    //
    //     WARNING !!!
    //
    //     This function is never called because we are loaded as a DLL by other video drivers !
    //
    //
    //
    //
    //

    //
    // We always return STATUS_SUCCESS because otherwise no video miniport
    // driver will be able to call us.
    //

    return STATUS_SUCCESS;

} // end DriverEntry()



NTSTATUS
pVideoPortCreateDeviceName(
    PWSTR           DeviceString,
    ULONG           DeviceNumber,
    PUNICODE_STRING UnicodeString,
    PWCHAR          UnicodeBuffer
    )

/*++

Routine Description:

    Helper function that does string manipulation to create a device name

--*/

{
    WCHAR          ntNumberBuffer[STRING_LENGTH];
    UNICODE_STRING ntNumberUnicodeString;

    //
    // Create the name buffer
    //

    UnicodeString->Buffer = UnicodeBuffer;
    UnicodeString->Length = 0;
    UnicodeString->MaximumLength = STRING_LENGTH;

    //
    // Create the miniport driver object name.
    //

    ntNumberUnicodeString.Buffer = ntNumberBuffer;
    ntNumberUnicodeString.Length = 0;
    ntNumberUnicodeString.MaximumLength = STRING_LENGTH;

    if (NT_SUCCESS(RtlIntegerToUnicodeString(DeviceNumber,
                                             10,
                                             &ntNumberUnicodeString))) {

        if (NT_SUCCESS(RtlAppendUnicodeToString(UnicodeString,
                                                DeviceString))) {

            if (NT_SUCCESS(RtlAppendUnicodeStringToString(UnicodeString,
                                                          &ntNumberUnicodeString))) {

                UnicodeString->MaximumLength = (USHORT)
                    (UnicodeString->Length + sizeof(UNICODE_NULL));

                return STATUS_SUCCESS;
            }
        }
    }

    return STATUS_INSUFFICIENT_RESOURCES;

} // pVideoPortCreateDeviceName()




VOID
VideoPortDebugPrint(
    VIDEO_DEBUG_LEVEL DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    This routine allows the miniport drivers (as well as the port driver) to
    display error messages to the debug port when running in the debug
    environment.

    When running a non-debugged system, all references to this call are
    eliminated by the compiler.

Arguments:

    DebugPrintLevel - Debug print level being:
    0 = Error Level (always prints no matter what on a checked build)
    1 = Warning Level (prints only when VIDEO filter is on for this level or higher)
    2 = Trace Level (see above)
    3 = Info Level (see above)

Return Value:

    None.

--*/

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (VideoDebugLevel && (VideoDebugLevel >= (ULONG)DebugPrintLevel)) {

        vDbgPrintEx(DPFLTR_VIDEO_ID, 0, DebugMessage, ap);

    } else {

        vDbgPrintEx(DPFLTR_VIDEO_ID, DebugPrintLevel, DebugMessage, ap);
    }

    va_end(ap);

} // VideoPortDebugPrint()

VOID
VpEnableDisplay(
    PFDO_EXTENSION fdoExtension,
    BOOLEAN bState
    )

/*++

Routine Description:

    This routine enables/disables the current display so that we can execut
    the drivers FindAdapter code.

Arugments:

    bState - Should the display be enabled or disabled

Returns:

    none

Notes:

    The device lock for the passed in fdoExtension must be held
    before this routine is called!

--*/

{
    if (!InbvCheckDisplayOwnership()) {

        VIDEO_WIN32K_CALLBACKS_PARAMS calloutParams;

        //
        // The system is up and running.  Notify GDI to enable/disable
        // the current display.
        //

        calloutParams.CalloutType = VideoFindAdapterCallout;
        calloutParams.Param       = bState;

        RELEASE_DEVICE_LOCK(fdoExtension);
        VpWin32kCallout(&calloutParams);
        ACQUIRE_DEVICE_LOCK(fdoExtension);

    } else {

        //
        // The boot driver is still in control.  Modify the state of the
        // boot driver.
        //

        InbvEnableBootDriver(bState);
    }
}

VOID
VpWin32kCallout(
    PVIDEO_WIN32K_CALLBACKS_PARAMS calloutParams
    )

/*++

Routine Description:

    This routine makes a callout into win32k.  It attaches to csrss
    to guarantee that win32k is in the address space on hydra machines.

Arguments:

    calloutParams - a pointer to the callout struture.

Returns:

    none.

--*/

{

    if (Win32kCallout && CsrProcess) {

        KeAttachProcess(PEProcessToPKProcess(CsrProcess));
        (*Win32kCallout)(calloutParams);
        KeDetachProcess();
    }
}

BOOLEAN
VpAllowFindAdapter(
    PFDO_EXTENSION fdoExtension
    )

/*++

Routine Description:

    Determine if we allow this device to be used if part of a multi-function
    board.

Arguments;

    fdoExtension - The device extenstion for the object in question.

Returns:

    TRUE if the device is allowed as part of a multi-function board.
    FALSE otherwise.

--*/

{
    BOOLEAN bRet = TRUE;

    if ((fdoExtension->AdapterInterfaceType == PCIBus) &&
        ((fdoExtension->Flags & PNP_ENABLED) == PNP_ENABLED)) {

        PCI_COMMON_CONFIG ConfigSpace;

        if (PCI_COMMON_HDR_LENGTH ==
            VideoPortGetBusData(fdoExtension->HwDeviceExtension,
                                PCIConfiguration,
                                0,
                                &ConfigSpace,
                                0,
                                PCI_COMMON_HDR_LENGTH)) {


            if (PCI_MULTIFUNCTION_DEVICE(&ConfigSpace)) {

                ULONG MultiFunc = 0;

                //
                // This is a multi-function device.  So only allow
                // HwInitialize if the INF indicated we'd be multi-function.
                //

                VideoPortGetRegistryParameters(fdoExtension->HwDeviceExtension,
                                               L"MultiFunctionSupported",
                                               FALSE,
                                               VpRegistryCallback,
                                               &MultiFunc);

                if (MultiFunc == 0) {

                    pVideoDebugPrint((Warn, "VIDEOPRT: Multifunction board not allowed to start\n"));
                    bRet = FALSE;
                }
            }
        }
    }

    return bRet;
}

NTSTATUS
pVideoPortDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the video port driver.
    It accepts an I/O Request Packet, transforms it to a video Request
    Packet, and forwards it to the appropriate miniport dispatch routine.
    Upon returning, it completes the request and return the appropriate
    status value.

Arguments:

    DeviceObject - Pointer to the device object of the miniport driver to
        which the request must be sent.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value os the status of the operation.

--*/

{

    PFDO_EXTENSION combinedExtension;
    PFDO_EXTENSION fdoExtension;
    PVOID          HwDeviceExtension;
    PDEVICE_SPECIFIC_EXTENSION DoSpecificExtension;
    PCHILD_PDO_EXTENSION pdoExtension = NULL;
    PIO_STACK_LOCATION irpStack;
    PVOID ioBuffer;
    ULONG inputBufferLength;
    ULONG outputBufferLength;
    PSTATUS_BLOCK statusBlock;
    NTSTATUS finalStatus = -1;
    ULONG ioControlCode;
    VIDEO_REQUEST_PACKET vrp;
    NTSTATUS status;
    PBACKLIGHT_STATUS pVpBacklightStatus = &VpBacklightStatus;
    ULONG ulACPIMethodParam1;
    ULONG ulACPIMethodParam2;
    HANDLE hkRegistry;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
#if _X86_
    PUCHAR BiosDataBuffer;

#define BIOS_DATA_SIZE 256

#endif
    //
    // Get pointer to the port driver's device extension.
    //

    combinedExtension = DeviceObject->DeviceExtension;
    HwDeviceExtension = combinedExtension->HwDeviceExtension;

    //
    // Get pointer to the port driver's device extension.
    //

    if (IS_PDO(DeviceObject->DeviceExtension)) {

        pdoExtension = DeviceObject->DeviceExtension;
        fdoExtension = pdoExtension->pFdoExtension;
        DoSpecificExtension = (PDEVICE_SPECIFIC_EXTENSION)(fdoExtension + 1);

    } else if (IS_FDO(DeviceObject->DeviceExtension)) {

        fdoExtension = DeviceObject->DeviceExtension;
        DoSpecificExtension = (PDEVICE_SPECIFIC_EXTENSION)(fdoExtension + 1);

    } else {

        DoSpecificExtension = DeviceObject->DeviceExtension;
        fdoExtension = DoSpecificExtension->pFdoExtension;
        combinedExtension = fdoExtension;
    }

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the status buffer.
    // Assume SUCCESS for now.
    //

    statusBlock = (PSTATUS_BLOCK) &Irp->IoStatus;

    //
    // Synchronize execution of the dispatch routine by acquiring the device
    // event object. This ensures all request are serialized.
    // The synchronization must be done explicitly because the functions
    // executed in the dispatch routine use system services that cannot
    // be executed in the start I/O routine.
    //
    // The synchronization is done on the miniport's event so as not to
    // block commands coming in for another device.
    //

#if REMOVE_LOCK_ENABLED
    status = IoAcquireRemoveLock(&combinedExtension->RemoveLock, Irp);

    if (NT_SUCCESS(status) == FALSE) {

        ASSERT(FALSE);

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;

        IoCompleteRequest(Irp, IO_VIDEO_INCREMENT);
        return status;
    }
#endif

    ACQUIRE_DEVICE_LOCK(combinedExtension);

    //
    // Get the requestor mode.
    //

    combinedExtension->CurrentIrpRequestorMode = Irp->RequestorMode;

    ASSERT(irpStack->MajorFunction != IRP_MJ_PNP);
    ASSERT(irpStack->MajorFunction != IRP_MJ_POWER);

    //
    // Case on the function being requested.
    // If the function is operating specific, intercept the operation and
    // perform directly. Otherwise, pass it on to the appropriate miniport.
    //

    switch (irpStack->MajorFunction) {

    //
    // Called by the display driver *or a user-mode application*
    // to get exclusive access to the device.
    // This access is given by the I/O system (based on a bit set during the
    // IoCreateDevice() call).
    //

    case IRP_MJ_CREATE:

        pVideoDebugPrint((Trace, "VIDEOPRT: IRP_MJ_CREATE\n"));

        if (Irp->RequestorMode == UserMode)
        {
            statusBlock->Status = STATUS_SUCCESS;
            break;
        }

        //
        // Don't let an old driver start during the upgrade
        //

        if (fdoExtension->Flags & UPGRADE_FAIL_START)
        {
            statusBlock->Status = STATUS_ACCESS_DENIED;
            break;
        }

        //
        // Don't allow create's on children, unless they are a monitor
        // which will receive calls from the display driver
        //

        if (IS_PDO(pdoExtension)) {

            pVideoDebugPrint((Error, "VIDEOPRT: Create's on children devices not allowed.\n"));

            statusBlock->Status = STATUS_ACCESS_DENIED;
            break;
        }

        //
        // Special hack to succeed on Attach, but do nothing ...
        // If the device is already opened, do nothing.
        //

        if ((irpStack->Parameters.Create.SecurityContext->DesiredAccess ==
                 FILE_READ_ATTRIBUTES) ||
            (DoSpecificExtension->DeviceOpened)) {

            statusBlock->Information = FILE_OPEN;
            statusBlock->Status = STATUS_SUCCESS;

            break;
        }

        //
        // If we haven't already done so, create our watchdog recovery event
        //

        if (VpThreadStuckEvent == NULL) {

            UNICODE_STRING strName;

            RtlInitUnicodeString(&strName, L"\\BaseNamedObjects\\StuckThreadEvent");
            VpThreadStuckEvent = IoCreateNotificationEvent(&strName, &VpThreadStuckEventHandle);

            if (VpThreadStuckEvent) {
                KeClearEvent(VpThreadStuckEvent);
            }
        }

        //
        // Get out of the special setup mode that we may be in
        //

        VpSetupType = 0;

        //
        // If hwInitialize has been called then the system is done
        // initializing and we are transitioning into gui mode.
        //

        VpSystemInitialized = TRUE;

        //
        // Now perform basic initialization to allow the Windows display
        // driver to set up the device appropriately.
        //

        statusBlock->Information = FILE_OPEN;

        //
        // If the address space has not been set up in the server yet, do it now.
        //        NOTE: no need to map in IO ports since the server has IOPL
        //

        if (CsrProcess == NULL)
        {
            CsrProcess = PsGetCurrentProcess();
            ObReferenceObject(CsrProcess);
        }

        pVideoPortInitializeInt10(fdoExtension);

        if (!IsMirrorDriver(fdoExtension)) {

            //
            // Tell the kernel we are now taking ownership the display, but
            // only do so if this is not a mirroring driver.
            //

            InbvNotifyDisplayOwnershipLost(pVideoPortResetDisplay);
        }

        if ((fdoExtension->Flags & FINDADAPTER_SUCCEEDED) == 0) {

            statusBlock->Status = STATUS_DEVICE_CONFIGURATION_ERROR;

        } else if ((fdoExtension->HwInitStatus == HwInitNotCalled) &&
                   (fdoExtension->HwInitialize(fdoExtension->HwDeviceExtension) == FALSE))
        {
            statusBlock->Status = STATUS_DEVICE_CONFIGURATION_ERROR;
            fdoExtension->HwInitStatus = HwInitFailed;

        } else if (fdoExtension->HwInitStatus == HwInitFailed) {

            statusBlock->Status = STATUS_DEVICE_CONFIGURATION_ERROR;

        } else {

            fdoExtension->HwInitStatus = HwInitSucceeded;
            statusBlock->Status = STATUS_SUCCESS;
        }

        //
        // Mark the device as opened so we will fail future opens.
        //

        DoSpecificExtension->DeviceOpened = TRUE;

        //
        // We don't want GDI to use any drivers other than display
        // or boot drivers during upgrade setup.
        //

        if (fdoExtension->Flags & UPGRADE_FAIL_HWINIT) {

            statusBlock->Status = STATUS_ACCESS_DENIED;
        }

        break;

    //
    // Called when the display driver wishes to give up it's handle to the
    // device.
    //

    case IRP_MJ_CLOSE:

        pVideoDebugPrint((Trace, "VIDEOPRT: IRP_MJ_CLOSE\n"));

        statusBlock->Status = STATUS_SUCCESS;

        break;

    //
    // Device Controls are specific functions for the driver.
    // First check for calls that must be intercepted and hidden from the
    // miniport driver. These calls are hidden for simplicity.
    // The other control functions are passed down to the miniport after
    // the request structure has been filled out properly.
    //

    case IRP_MJ_DEVICE_CONTROL:

        //
        // Get the pointer to the input/output buffer and it's length
        //

        ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
        inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
        outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
        ioControlCode      = irpStack->Parameters.DeviceIoControl.IoControlCode;

        if (Irp->RequestorMode == UserMode)
        {
            statusBlock->Information = 0;

            if ((ioControlCode != IOCTL_VIDEO_QUERY_SUPPORTED_BRIGHTNESS) &&
                (ioControlCode != IOCTL_VIDEO_QUERY_DISPLAY_BRIGHTNESS) &&
                (ioControlCode != IOCTL_VIDEO_SET_DISPLAY_BRIGHTNESS))
            {
                statusBlock->Status = STATUS_ACCESS_DENIED;
                break;
            }
        }

#ifdef IOCTL_VIDEO_USE_DEVICE_IN_SESSION
        //
        // Validate session usage
        //
        //  Note: Some IOCTLs are acceptable to call from non-console sessions
        //   These include all private IOCTLs which is completely under 
        //   the drivers' control and may happen even when the device is
        //   disabled.  IOCTL_VIDEO_REGISTER_VDM is also allowed since
        //   it doesn't access any hardware.
        //

        if ((ioControlCode & CTL_CODE(0x8000, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)) == 0 &&
            ioControlCode != IOCTL_VIDEO_REGISTER_VDM)
        {
            if (DoSpecificExtension->SessionId != VIDEO_DEVICE_INVALID_SESSION &&
                PsGetCurrentProcessSessionId() != DoSpecificExtension->SessionId)
            {
                DbgPrint("VIDEOPRT: Trying to use display device in sessions %lu and %lu.\n",
                         DoSpecificExtension->SessionId,
                         PsGetCurrentProcessSessionId());

                //
                // We will also allow several other IOCTLs to be called from
                // a non-console session.
                //  For simplicity we allow all IOCTLs for which the driver
                //  provides support with the exception of
                //  IOCTL_VIDEO_ENABLE_VDM.
                //

                if ((ioControlCode & 
                     CTL_CODE(0x7fff, 0x7ff, METHOD_BUFFERED, FILE_ANY_ACCESS)) <=
                    IOCTL_VIDEO_USE_DEVICE_IN_SESSION)
                {
                    ASSERT(FALSE);
                }
                else
                {
                    DbgPrint("VIDEOPRT:   Cross session use is acceptable in this case.\n");
                }
            }
        }
#endif IOCTL_VIDEO_USE_DEVICE_IN_SESSION

        //
        // Enabling or disabling the VDM is done only by the port driver.
        //

        if (ioControlCode == IOCTL_VIDEO_REGISTER_VDM) {

            pVideoDebugPrint((Trace, "VIDEOPRT: IOCTL_VIDEO_REGISTER_VDM\n"));

            ASSERT(IS_PDO(pdoExtension) == FALSE);

            statusBlock->Status = pVideoPortRegisterVDM(fdoExtension,
                                                        (PVIDEO_VDM) ioBuffer,
                                                        inputBufferLength,
                                                        (PVIDEO_REGISTER_VDM) ioBuffer,
                                                        outputBufferLength,
                                                        &statusBlock->Information);

        } else if (ioControlCode == IOCTL_VIDEO_DISABLE_VDM) {

            pVideoDebugPrint((Trace, "VIDEOPRT: IOCTL_VIDEO_DISABLE_VDM"));

            ASSERT(IS_PDO(pdoExtension) == FALSE);

            statusBlock->Status = pVideoPortEnableVDM(fdoExtension,
                                                      FALSE,
                                                      (PVIDEO_VDM) ioBuffer,
                                                      inputBufferLength);

        } else if ((ioControlCode == IOCTL_VIDEO_SET_OUTPUT_DEVICE_POWER_STATE) ||
                   (ioControlCode == IOCTL_VIDEO_GET_OUTPUT_DEVICE_POWER_STATE)) {

            //
            //  This handles the case where ntuser has signalled that it wants
            //  to change or detect the power state.
            //

            PCHILD_PDO_EXTENSION pChild;
            PPOWER_BLOCK powerCtx = NULL;
            ULONG count = 0;

            UCHAR mFnc =
                (ioControlCode == IOCTL_VIDEO_SET_OUTPUT_DEVICE_POWER_STATE) ?
                    IRP_MN_SET_POWER : IRP_MN_QUERY_POWER ;

            pVideoDebugPrint((Trace, "VIDEOPRT: IOCTL_%s_OUTPUT_DEVICE_POWER_STATE\n",
                              ioControlCode == IOCTL_VIDEO_SET_OUTPUT_DEVICE_POWER_STATE ? "SET" : "GET"));

            //
            // USER wants to set the power on the monitor, not the card.
            // So let's find our child monitor and send it the power management
            // function.
            // If there is no power manageable monitor, then we can just fail
            // the request right here.
            //

            ASSERT(IS_PDO(pdoExtension) == FALSE);

            if (fdoExtension->ChildPdoList)
            {
                //
                // Count the number of monitor devices so that the IRP will
                // be completed properly after a power IRP has been requested
                // for each.
                //

                for (pChild = fdoExtension->ChildPdoList;
                     pChild;
                     pChild = pChild->NextChild) {

                     if (pChild->VideoChildDescriptor->Type == Monitor)
                         count++;
                }

                for (pChild = fdoExtension->ChildPdoList;
                     pChild;
                     pChild = pChild->NextChild)
                {
                    if (pChild->VideoChildDescriptor->Type == Monitor)
                    {

                        count--;

                        //
                        // Allocate memory for the IRP context.
                        //

                        powerCtx = ExAllocatePoolWithTag(NonPagedPool,
                                                         sizeof(POWER_BLOCK),
                                                         VP_TAG);

                        if (!powerCtx) {

                            pVideoDebugPrint ((Error, "VIDEOPRT: No memory for power context.\n"));
                            finalStatus = statusBlock->Status = STATUS_INSUFFICIENT_RESOURCES;
                            break;
                        }

                        powerCtx->Irp = Irp;
                        powerCtx->FinalFlag = FALSE;

                        //
                        // Since there is a least one monitor that a power IRP
                        // will be requested for, mark this IRP as pending as
                        // it will undoubtedly be returned with STATUS_PENDING.
                        //

                        IoMarkIrpPending(Irp);

                        if (count == 0) {
                            powerCtx->FinalFlag = TRUE;
                        }

                        //
                        // Since PoRequestPowerIrp always returns STATUS_PENDING
                        // if the IRP was sent, a double completion here is
                        // impossible as at the bottom of this function
                        // IoCompleteRequest will not be called if status is
                        // STATUS_PENDING
                        //


                        finalStatus =
                            PoRequestPowerIrp(pChild->ChildDeviceObject,
                                              mFnc,
                                              *(PPOWER_STATE)(ioBuffer),
                                              pVideoPortPowerCompletionIoctl,
                                              powerCtx,
                                              NULL);

                        if (finalStatus != STATUS_PENDING) {
                            break;
                        }
                    }
                }
            }

        } else if ((ioControlCode == IOCTL_VIDEO_SET_POWER_MANAGEMENT) ||
                   (ioControlCode == IOCTL_VIDEO_GET_POWER_MANAGEMENT)) {

            statusBlock->Status = STATUS_SUCCESS;

        } else if (ioControlCode == IOCTL_VIDEO_ENUM_MONITOR_PDO) {

            ULONG                 szMonitorDevices;
            PVIDEO_MONITOR_DEVICE pMonitorDevices = NULL, pMD;
            PCHILD_PDO_EXTENSION  pChildDeviceExtension;
            PDEVICE_OBJECT        pdo;

            pVideoDebugPrint((Trace, "VIDEOPRT: IOCTL_VIDEO_ENUM_MONITOR_PDO\n"));

            szMonitorDevices = (fdoExtension->ChildPdoNumber+1)*sizeof(VIDEO_MONITOR_DEVICE);

            pMonitorDevices = ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,
                                                    szMonitorDevices,
                                                    VP_TAG);

            if (pMonitorDevices == NULL) {

                statusBlock->Status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                RtlZeroMemory(pMonitorDevices, szMonitorDevices);

                //
                // Walk our chain of children, and store them in the relations array.
                //

                pChildDeviceExtension = fdoExtension->ChildPdoList;

                pMD = pMonitorDevices;
                while (pChildDeviceExtension) {

                    if (pChildDeviceExtension->bIsEnumerated &&
                        pChildDeviceExtension->VideoChildDescriptor->Type == Monitor
                       )
                    {
                        ULONG UId, flag = VIDEO_CHILD_ACTIVE;

                        //
                        //  Refcount the ChildDeviceObject.
                        //

                        ObReferenceObject(pChildDeviceExtension->ChildDeviceObject);

                        UId = pChildDeviceExtension->VideoChildDescriptor->UId;
                        if (!NT_SUCCESS
                            (pVideoMiniDeviceIoControl(DeviceObject,
                                                       IOCTL_VIDEO_GET_CHILD_STATE,
                                                       &UId,
                                                       sizeof(ULONG),
                                                       &flag,
                                                       sizeof(ULONG) ) )
                           )
                        {
                            //
                            // If driver driver doesn't handle IOCTL_VIDEO_GET_CHILD_STATE, set to default value
                            //
                            flag = pCheckActiveMonitor(pChildDeviceExtension) ? VIDEO_CHILD_ACTIVE : 0;
                        }

                        pMD->flag = flag;
                        pMD->pdo = pChildDeviceExtension->ChildDeviceObject;
                        pMD->HwID = pChildDeviceExtension->VideoChildDescriptor->UId;
                        pMD++;
                    }

                    pChildDeviceExtension = pChildDeviceExtension->NextChild;
                }

                //
                // Return the information to GDI.  The array terminated by a zero unit.
                //

                *((PVOID *)ioBuffer)     = pMonitorDevices;
                statusBlock->Status      = STATUS_SUCCESS;
                statusBlock->Information = sizeof(PVOID);
            }

        } else if (ioControlCode == IOCTL_VIDEO_INIT_WIN32K_CALLBACKS) {

            pVideoDebugPrint((Trace, "VIDEOPRT: IOCTL_VIDEO_INIT_WIN32K_CALLBACKS\n"));

            if (DoSpecificExtension->PhysDisp == NULL)
            {
                DoSpecificExtension->PhysDisp = ((PVIDEO_WIN32K_CALLBACKS)(ioBuffer))->PhysDisp;
            }

            if (Win32kCallout == NULL)
            {
                Win32kCallout = ((PVIDEO_WIN32K_CALLBACKS)(ioBuffer))->Callout;
            }

            ((PVIDEO_WIN32K_CALLBACKS)ioBuffer)->bACPI             = DoSpecificExtension->bACPI;

            ((PVIDEO_WIN32K_CALLBACKS)ioBuffer)->pPhysDeviceObject = fdoExtension->PhysicalDeviceObject;

            ((PVIDEO_WIN32K_CALLBACKS)ioBuffer)->DualviewFlags     = DoSpecificExtension->DualviewFlags;

            statusBlock->Status = STATUS_SUCCESS;
            statusBlock->Information = sizeof(VIDEO_WIN32K_CALLBACKS);

        } else if (ioControlCode == IOCTL_VIDEO_IS_VGA_DEVICE) {

            pVideoDebugPrint((Trace, "VIDEOPRT: IOCTL_VIDEO_IS_VGA_DEVICE\n"));

            *((PBOOLEAN)(ioBuffer)) = (BOOLEAN)(DeviceObject == DeviceOwningVga);

            statusBlock->Status = STATUS_SUCCESS;
            statusBlock->Information = sizeof(BOOLEAN);

        } else if (ioControlCode == IOCTL_VIDEO_PREPARE_FOR_EARECOVERY) {
        
            KBUGCHECK_SECONDARY_DUMP_DATA DumpData;
            ULONG ulDumpSize = 0;
            
            pVideoDebugPrint((Trace, "VIDEOPRT: IOCTL_VIDEO_PREPARE_FOR_EARECOVERY\n"));

            //
            // Save basic minidump on the disk (if we have any problem later 
            // during recovery we still will have something to work with)
            //
            if (VpDump) {
                ulDumpSize = min((ULONG)((PMEMORY_DUMP)VpDump)->Header.RequiredDumpSpace.QuadPart,
                                   TRIAGE_DUMP_SIZE);
                pVpWriteFile(L"\\SystemRoot\\MEMORY.DMP",
                             VpDump,
                             ulDumpSize);
            }
            
            //
            // As all the display devices to go into a mode where VGA works.
            //

            pVpGeneralBugcheckHandler(&DumpData);

            if (VpDump) {
                ULONG ulSize;
                ULONG BugcheckDataSize = (VpBugcheckDeviceObject) ? 
                                            ((PFDO_EXTENSION)VpBugcheckDeviceObject->DeviceExtension)->BugcheckDataSize :
                                            0;
                                            
                //
                // Dump file created already so just add driver specific data
                //

                ulSize = pVpAppendSecondaryMinidumpData(VpBugcheckData,
                                                        BugcheckDataSize,
                                                        VpDump);

                if (ulSize > ulDumpSize) {
                    //
                    // Write the data to disk
                    //
    
                    pVpWriteFile(L"\\SystemRoot\\MEMORY.DMP",
                                 VpDump,
                                 ulSize);
                }

                if (VpDump) {
                    ExFreePool(VpDump);
                    VpDump = NULL;
                }
            }

            pVideoPortResetDisplay(80,25);

            statusBlock->Status = STATUS_SUCCESS;
            statusBlock->Information = 0;

#ifdef IOCTL_VIDEO_USE_DEVICE_IN_SESSION
        } else if (ioControlCode == IOCTL_VIDEO_USE_DEVICE_IN_SESSION) {

            pVideoDebugPrint((Trace, "VIDEOPRT: IOCTL_VIDEO_USE_DEVICE_IN_SESSION\n"));

            if (((PVIDEO_DEVICE_SESSION_STATUS)ioBuffer)->bEnable)
            {
                if (DoSpecificExtension->SessionId == VIDEO_DEVICE_INVALID_SESSION)
                {
                    DoSpecificExtension->SessionId = PsGetCurrentProcessSessionId();
                    ((PVIDEO_DEVICE_SESSION_STATUS)ioBuffer)->bSuccess = TRUE;
                }
                else
                {
                    ((PVIDEO_DEVICE_SESSION_STATUS)ioBuffer)->bSuccess = FALSE;
                }
            }
            else
            {
                if (DoSpecificExtension->SessionId == PsGetCurrentProcessSessionId())
                {
                    DoSpecificExtension->SessionId = VIDEO_DEVICE_INVALID_SESSION;
                    ((PVIDEO_DEVICE_SESSION_STATUS)ioBuffer)->bSuccess = TRUE;
                }
                else
                {
                    ((PVIDEO_DEVICE_SESSION_STATUS)ioBuffer)->bSuccess = FALSE;
                }
            }

            statusBlock->Status = STATUS_SUCCESS;
            statusBlock->Information = sizeof(VIDEO_DEVICE_SESSION_STATUS);

#endif IOCTL_VIDEO_USE_DEVICE_IN_SESSION

        //
        // The following three IOCTLs support LCD backlight control.
        //

        } else if (ioControlCode == IOCTL_VIDEO_QUERY_SUPPORTED_BRIGHTNESS) {
        
            //
            // Note: this IOCTL must be called before:
            //  IOCTL_VIDEO_SET_DISPLAY_BRIGHTNESS
            //
            // This IOCTL will query the brightness capabilities
            //  of the BIOS.
            //

            //
            // We expect a buffer size of 256 bytes.
            //

            ULONG ulNumReturnedLevels = 0;
            PDEVICE_OBJECT AttachedDevice = NULL;

            if (outputBufferLength < 256)
            {
                statusBlock->Status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            //
            // Call VpQueryBacklightLevels to obtain the list of supported levels.
            //

            if (LCDPanelDevice) {
                AttachedDevice = IoGetAttachedDeviceReference(LCDPanelDevice);
            }

            if (AttachedDevice) {

                statusBlock->Status = VpQueryBacklightLevels(
                    AttachedDevice,
                    (PUCHAR) ioBuffer,
                    &ulNumReturnedLevels);

                ObDereferenceObject(AttachedDevice);
            }
            else {
                statusBlock->Status = ERROR_INVALID_PARAMETER;
            }
            
            if (!NT_SUCCESS(statusBlock->Status)) {
                break;
            }

            //
            // The new API is being used.  If we haven't already read the applicable
            //  levels from the registry (per pVpInit) then write the keys to the
            //  registry and update pVpBacklightStatus as necessary. 
            //

            if ((pVpBacklightStatus->bNewAPISupported == FALSE) ||
                (pVpBacklightStatus->bACBrightnessInRegistry == FALSE) ||
                (pVpBacklightStatus->bDCBrightnessInRegistry == FALSE)) {

                // ZwCreateKey                

                RtlInitUnicodeString(&UnicodeString,
                                   L"\\Registry\\Machine\\System\\CurrentControlSet\\"
                                   L"Control\\Backlight");

                InitializeObjectAttributes(&ObjectAttributes,
                                           &UnicodeString,
                                           OBJ_CASE_INSENSITIVE,
                                           NULL,
                                           NULL);

                statusBlock->Status = ZwCreateKey(&hkRegistry,
                                      GENERIC_READ | GENERIC_WRITE,
                                      &ObjectAttributes,
                                      0L,
                                      NULL,
                                      REG_OPTION_NON_VOLATILE,
                                      NULL);

                if (NT_SUCCESS(statusBlock->Status)) {

                    ULONG ulRegData = 1;
                    PVOID pvData;


                    // NewAPISupported

                    RtlInitUnicodeString(
                    &UnicodeString,
                    L"NewAPISupported"
                    );

                    pvData = &ulRegData;

                    statusBlock->Status = ZwSetValueKey(
                        hkRegistry,
                        &UnicodeString,
                        0,
                        REG_DWORD,
                        pvData,
                        4
                        );

                    if (NT_SUCCESS(statusBlock->Status)) {

                        pVpBacklightStatus->bNewAPISupported = TRUE;
                    }


                    // ACBacklightLevel, use BIOS default value

                    RtlInitUnicodeString(
                    &UnicodeString,
                    L"ACBacklightLevel"
                    );

                    pVpBacklightStatus->ucACBrightness = pVpBacklightStatus->ucBIOSDefaultAC;
                    ulRegData = (UCHAR) pVpBacklightStatus->ucACBrightness;
                    pvData = &ulRegData;

                    statusBlock->Status = ZwSetValueKey(
                        hkRegistry,
                        &UnicodeString,
                        0,
                        REG_DWORD,
                        pvData,
                        4
                        );

                    if (NT_SUCCESS(statusBlock->Status)) {

                        pVpBacklightStatus->bACBrightnessInRegistry = TRUE;
                    }


                    // DCBacklightLevel, use BIOS default value

                    RtlInitUnicodeString(
                    &UnicodeString,
                    L"DCBacklightLevel"
                    );

                    pVpBacklightStatus->ucDCBrightness = pVpBacklightStatus->ucBIOSDefaultDC;
                    ulRegData = (UCHAR) pVpBacklightStatus->ucDCBrightness;
                    pvData = &ulRegData;

                    statusBlock->Status = ZwSetValueKey(
                        hkRegistry,
                        &UnicodeString,
                        0,
                        REG_DWORD,
                        pvData,
                        4
                        );

                    if (NT_SUCCESS(statusBlock->Status)) {

                        pVpBacklightStatus->bDCBrightnessInRegistry = TRUE;
                    }

                    ZwClose(hkRegistry);

                    pVpBacklightStatus->bACBrightnessKnown = TRUE;
                    pVpBacklightStatus->bDCBrightnessKnown = TRUE;
                }
          
            }
        
            pVpBacklightStatus->bQuerySupportedBrightnessCalled = TRUE;
            statusBlock->Status = STATUS_SUCCESS;
            statusBlock->Information = ulNumReturnedLevels;
        
        } else if (ioControlCode == IOCTL_VIDEO_QUERY_DISPLAY_BRIGHTNESS) {

            //
            // If the backlight level is known for the display policy queried, 
            //  it will be reported.
            //
            // No ACPI methods are used here.  _BCL will be used in
            //  IOCTL_VIDEO_QUERY_SUPPORTED_BRIGHTNESS and _BCM will
            //  be used in IOCTL_VIDEO_SET_DISPLAY_BRIGHTNESS.
            //

            PDISPLAY_BRIGHTNESS pDisplayBrightness;

            if (outputBufferLength < sizeof(DISPLAY_BRIGHTNESS))
            {
                statusBlock->Status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            pDisplayBrightness = (PDISPLAY_BRIGHTNESS) ioBuffer;

            //
            // Report AC value if available.
            //
            // Note:  Value ~should~ be known, even if we need to use
            //         AC default.
            //

            if ((pVpBacklightStatus->bACBrightnessKnown == FALSE) &&
                (pVpBacklightStatus->bBIOSDefaultACKnown == FALSE))
            {
                statusBlock->Status = ERROR_INVALID_PARAMETER;
                break;
            }
                

            if (pVpBacklightStatus->bACBrightnessKnown == TRUE)
            {
                pDisplayBrightness->ucACBrightness = pVpBacklightStatus->ucACBrightness;
            }
            else
            {
                pDisplayBrightness->ucACBrightness = pVpBacklightStatus->ucBIOSDefaultAC;
            }

            //
            // Report DC value if available.
            //
            // Note:  Value ~should~ be known, even if we need to use
            //         DC default.
            //

            if ((pVpBacklightStatus->bDCBrightnessKnown == FALSE) &&
                (pVpBacklightStatus->bBIOSDefaultDCKnown == FALSE))
            {
                statusBlock->Status = ERROR_INVALID_PARAMETER;
                break;
            }

            if (pVpBacklightStatus->bDCBrightnessKnown == TRUE)
            {
                pDisplayBrightness->ucDCBrightness = pVpBacklightStatus->ucDCBrightness;
            }
            else
            {
                pDisplayBrightness->ucDCBrightness = pVpBacklightStatus->ucBIOSDefaultDC;
            }

            //
            // Report the current power policy.
            //

            if (VpRunningOnAC == TRUE)
            {
                pDisplayBrightness->ucDisplayPolicy = DISPLAYPOLICY_AC;
            }
            else
            {
                pDisplayBrightness->ucDisplayPolicy = DISPLAYPOLICY_DC;
            }
            
            //
            // No errors are expected here.
            //

            statusBlock->Status = STATUS_SUCCESS;
            statusBlock->Information = sizeof(DISPLAY_BRIGHTNESS);
            

        } else if (ioControlCode == IOCTL_VIDEO_SET_DISPLAY_BRIGHTNESS) {
        
            //
            // This IOCTL will set the current brightness level of
            //  the backlight.
            //
            // The _BCM ACPI method will be used.
            //

            PDISPLAY_BRIGHTNESS pDisplayBrightness;
            PDEVICE_OBJECT AttachedDevice = NULL;
            BOOLEAN bSetPanelBrightness = FALSE;

            //
            // Check buffer size and that Brightness capabilities
            //  have been queried.
            //
                        
            if (inputBufferLength < sizeof(DISPLAY_BRIGHTNESS))
            {
                statusBlock->Status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
            
            //
            // Videoprt insists that IOCTL_VIDEO_QUERY_SUPPORTED_BRIGHTNESS
            //  be called first.
            //

            if (pVpBacklightStatus->bQuerySupportedBrightnessCalled == FALSE)
            {
                statusBlock->Status = ERROR_INVALID_FUNCTION;
                break;
            }

            //
            // Videoprt will ensure no crashes, but caller should ensure
            //  they are setting a valid value.
            //
                        
            pDisplayBrightness = (PDISPLAY_BRIGHTNESS) ioBuffer;
            
            //
            // Set the AC/DC brightness level, if appropriate.
            //  The caller could conceivably ask us to set a value
            //  for a power policy that is not currenlty active.
            //

            ulACPIMethodParam2 = 0;

            if ((VpRunningOnAC == TRUE) &&
                ((pDisplayBrightness->ucDisplayPolicy) & DISPLAYPOLICY_AC))
            {
                bSetPanelBrightness = TRUE;
                ulACPIMethodParam1 = (ULONG) pDisplayBrightness->ucACBrightness;
            }    

            else if ((VpRunningOnAC == FALSE) &&
                ((pDisplayBrightness->ucDisplayPolicy) & DISPLAYPOLICY_DC))
            {
                bSetPanelBrightness = TRUE;
                ulACPIMethodParam1 = (ULONG) pDisplayBrightness->ucDCBrightness;
            }

            statusBlock->Status = STATUS_SUCCESS;

            if (bSetPanelBrightness == TRUE)
            {
                if (LCDPanelDevice) {
                    AttachedDevice = IoGetAttachedDeviceReference(LCDPanelDevice);
                }

                if (AttachedDevice) {

                    statusBlock->Status = pVideoPortACPIIoctl(
                        AttachedDevice,
                        (ULONG) ('MCB_'),
                        &ulACPIMethodParam1,
                        NULL,
                        0,
                        NULL);

                    ObDereferenceObject(AttachedDevice);
                }
                else {
                    statusBlock->Status = ERROR_INVALID_PARAMETER;
                }
            }

            if (!NT_SUCCESS(statusBlock->Status))
            {
                statusBlock->Status = ERROR_INVALID_PARAMETER;
                break;
            }

            //
            // Save the new brightness levels.
            //

            if ((pDisplayBrightness->ucDisplayPolicy) & DISPLAYPOLICY_DC)
            {
                pVpBacklightStatus->ucDCBrightness = pDisplayBrightness->ucDCBrightness;
                pVpBacklightStatus->bDCBrightnessKnown = TRUE;
            }

            if ((pDisplayBrightness->ucDisplayPolicy) & DISPLAYPOLICY_AC)
            {
                pVpBacklightStatus->ucACBrightness = pDisplayBrightness->ucACBrightness;
                pVpBacklightStatus->bACBrightnessKnown = TRUE;
            }

            //
            // Save the new AC / DC values in the Registry.
            //


            // ZwCreateKey

            RtlInitUnicodeString(&UnicodeString,
                               L"\\Registry\\Machine\\System\\CurrentControlSet\\"
                               L"Control\\Backlight");

            InitializeObjectAttributes(&ObjectAttributes,
                                       &UnicodeString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            statusBlock->Status = ZwCreateKey(&hkRegistry,
                                  GENERIC_READ | GENERIC_WRITE,
                                  &ObjectAttributes,
                                  0L,
                                  NULL,
                                  REG_OPTION_NON_VOLATILE,
                                  NULL);

            if (NT_SUCCESS(statusBlock->Status)) {

                ULONG ulRegData = 0;
                PVOID pvData;


                // ACBacklightLevel

                RtlInitUnicodeString(
                &UnicodeString,
                L"ACBacklightLevel"
                );

                ulRegData = (UCHAR) pVpBacklightStatus->ucACBrightness;
                pvData = &ulRegData;

                statusBlock->Status = ZwSetValueKey(
                    hkRegistry,
                    &UnicodeString,
                    0,
                    REG_DWORD,
                    pvData,
                    4
                    );

                if (NT_SUCCESS(statusBlock->Status)) {

                    pVpBacklightStatus->bACBrightnessInRegistry = TRUE;
                }



                // DCBacklightLevel

                RtlInitUnicodeString(
                &UnicodeString,
                L"DCBacklightLevel"
                );

                ulRegData = (UCHAR) pVpBacklightStatus->ucDCBrightness;
                pvData = &ulRegData;

                statusBlock->Status = ZwSetValueKey(
                    hkRegistry,
                    &UnicodeString,
                    0,
                    REG_DWORD,
                    pvData,
                    4
                    );

                if (NT_SUCCESS(statusBlock->Status)) {

                    pVpBacklightStatus->bDCBrightnessInRegistry = TRUE;
                }


                ZwClose(hkRegistry);
            }

            //
            // No errors are expected here unless the caller asked us to set a 
            //  level that is not available.
            //

            statusBlock->Status = STATUS_SUCCESS;
            statusBlock->Information = 0;

        } else {

            //
            // All other request need to be passed to the miniport driver.
            //

            statusBlock->Status = STATUS_SUCCESS;

            switch (ioControlCode) {

            case IOCTL_VIDEO_ENABLE_VDM:

                pVideoDebugPrint((Trace, "VIDEOPRT: IOCTL_VIDEO_ENABLE_VDM\n"));

                ASSERT(IS_PDO(pdoExtension) == FALSE);

                statusBlock->Status = pVideoPortEnableVDM(fdoExtension,
                                                          TRUE,
                                                          (PVIDEO_VDM) ioBuffer,
                                                          inputBufferLength);

#if DBG
                if (statusBlock->Status == STATUS_CONFLICTING_ADDRESSES) {

                    pVideoDebugPrint((Trace, "VIDEOPRT: pVideoPortEnableVDM failed\n"));

                }
#endif

                break;

#if _X86_
            case IOCTL_VIDEO_SAVE_HARDWARE_STATE:

                pVideoDebugPrint((Trace, "VIDEOPRT: IOCTL_VIDEO_SAVE_HARDWARE_STATE\n"));

                //
                // allocate the memory required by the miniport driver so it can
                // save its state to be returned to the caller.
                //

                ASSERT(IS_PDO(pdoExtension) == FALSE);

                if (fdoExtension->HardwareStateSize == 0) {

                    statusBlock->Status = STATUS_NOT_IMPLEMENTED;
                    break;

                }

                //
                // Must make sure the caller is a trusted subsystem with the
                // appropriate privilege level before executing this call.
                // If the calls returns FALSE we must return an error code.
                //

                if (!SeSinglePrivilegeCheck(RtlConvertLongToLuid(
                                                SE_TCB_PRIVILEGE),
                                            fdoExtension->CurrentIrpRequestorMode)) {

                    statusBlock->Status = STATUS_PRIVILEGE_NOT_HELD;
                    break;

                }

                ((PVIDEO_HARDWARE_STATE)(ioBuffer))->StateLength =
                    fdoExtension->HardwareStateSize;

                statusBlock->Status = 
                    ZwAllocateVirtualMemory(NtCurrentProcess(),
                                            (PVOID *) &(((PVIDEO_HARDWARE_STATE)(ioBuffer))->StateHeader),
                                            0L,
                                            &((PVIDEO_HARDWARE_STATE)(ioBuffer))->StateLength,
                                            MEM_COMMIT,
                                            PAGE_READWRITE);

                if(!NT_SUCCESS(statusBlock->Status))
                    break;

                BiosDataBuffer = ExAllocatePoolWithTag(PagedPool,
                                                       BIOS_DATA_SIZE,
                                                       VP_TAG);
                if (BiosDataBuffer == NULL) {

                    statusBlock->Status = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    statusBlock->Status =
                        pVideoPortGetVDMBiosData(fdoExtension, 
                                                 BiosDataBuffer, 
                                                 BIOS_DATA_SIZE);

                    if(!NT_SUCCESS(statusBlock->Status)) {

                        ExFreePool(BiosDataBuffer);
                    }
                }

                break;
#endif

            case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:

                pVideoDebugPrint((Trace, "VIDEOPRT: IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES\n"));

                //
                // Must make sure the caller is a trusted subsystem with the
                // appropriate privilege level before executing this call.
                // If the calls returns FALSE we must return an error code.
                //

                if (!SeSinglePrivilegeCheck(RtlConvertLongToLuid(
                                                SE_TCB_PRIVILEGE),
                                            fdoExtension->CurrentIrpRequestorMode)) {

                    statusBlock->Status = STATUS_PRIVILEGE_NOT_HELD;

                }

                break;

            case IOCTL_VIDEO_GET_CHILD_STATE:

                pVideoDebugPrint((Trace, "VIDEOPRT: IOCTL_VIDEO_GET_CHILD_STATE\n"));

                //
                // If it's PDO, set the ID of the child device before letting it go
                // to the miniports StartIo routine.
                //

                if (IS_PDO(pdoExtension)) {
                    if (outputBufferLength < sizeof (ULONG)) {
                        statusBlock->Status = STATUS_BUFFER_TOO_SMALL ;
                        break ;
                    }

                    *((PULONG)(ioBuffer)) = pdoExtension->ChildUId ;
                }

                break;


            //
            // The default case is when the port driver does not handle the
            // request. We must then call the miniport driver.
            //

            default:

                break;


            } // switch (ioControlCode)


            //
            // All above cases call the miniport driver.
            //
            // only process it if no errors happened in the port driver
            // processing.
            //

            if (NT_SUCCESS(statusBlock->Status)) {

                pVideoDebugPrint((Trace, "VIDEOPRT: IOCTL fallthrough\n"));

                vrp.IoControlCode      = ioControlCode;
                vrp.StatusBlock        = statusBlock;
                vrp.InputBuffer        = ioBuffer;
                vrp.InputBufferLength  = inputBufferLength;
                vrp.OutputBuffer       = ioBuffer;
                vrp.OutputBufferLength = outputBufferLength;

                //
                // Send the request to the miniport.
                //

                fdoExtension->HwStartIO(HwDeviceExtension, &vrp);

#if _X86_
                if(ioControlCode == IOCTL_VIDEO_SAVE_HARDWARE_STATE) {

                    pVideoPortPutVDMBiosData(fdoExtension,
                                             BiosDataBuffer, 
                                             BIOS_DATA_SIZE);
                       
                    ExFreePool(BiosDataBuffer);

                }

#endif
                if (statusBlock->Status != NO_ERROR) {

                    //
                    // Make sure we don't tell the IO system to copy data
                    // on a real error.
                    //

                    if (statusBlock->Status != ERROR_MORE_DATA) {

                        statusBlock->Information = 0;

                    }

                    pVideoPortMapToNtStatus(statusBlock);

                    //
                    // !!! Compatibility:
                    // Do not require a miniport to support the REGISTER_VDM
                    // IOCTL, so if we get an error in that case, just
                    // return success.
                    //
                    // Do put up a message so people fix this.
                    //

                    if (ioControlCode == IOCTL_VIDEO_ENABLE_VDM) {

                        statusBlock->Status = STATUS_SUCCESS;
                        pVideoDebugPrint((Warn, "VIDEOPRT: The miniport driver does not support IOCTL_VIDEO_ENABLE_VDM. The video miniport driver *should* be fixed.\n"));

                    }
                }
            }

        } // if (ioControlCode == ...

        break;

    case IRP_MJ_SHUTDOWN:

    {
        PEPROCESS csr;

        //
        // This little dance is just to make sure we never overdereference csr.
        //

        csr = InterlockedExchangePointer(&CsrProcess, NULL);

        if (csr != NULL) {

            ObDereferenceObject(csr);
        }

        //
        // TODO: This is a temporary hack only till we get Nt/ZwQueryLastShutdownType()
        // API implemented. On the next boot we need to know if the last shutdown was
        // successful, and if not and if we have a watchdog event registered from that
        // session we can assume the driver got stuck so we can notify user and
        // optionally send a problem report to MS.
        //
        // N.B. This doesn't work for non-PnP devices (e.g. VGA) but it's still good
        // enough, we're losing once piece of info but we'll still check for watchdog
        // events from the last session.
        //

        {
#define VP_KEY_WATCHDOG         L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Watchdog"
#define VP_KEY_WATCHDOG_DISPLAY L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Watchdog\\Display"

            static BOOLEAN shutdownRegistered = FALSE;

            if (FALSE == shutdownRegistered)
            {
                NTSTATUS ntStatus;

                shutdownRegistered = TRUE;

                //
                // Is Watchdog\Display key already there?
                //

                ntStatus = RtlCheckRegistryKey(RTL_REGISTRY_ABSOLUTE, VP_KEY_WATCHDOG_DISPLAY);

                if (!NT_SUCCESS(ntStatus)) {

                    //
                    // Is Watchdog key already there?
                    //

                    ntStatus = RtlCheckRegistryKey(RTL_REGISTRY_ABSOLUTE, VP_KEY_WATCHDOG);

                    if (!NT_SUCCESS(ntStatus)) {

                        //
                        // Create a new key.
                        //

                        ntStatus = RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE, VP_KEY_WATCHDOG);
                    }

                    if (NT_SUCCESS(ntStatus)) {

                        //
                        // Create a new key.
                        //

                        ntStatus = RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE, VP_KEY_WATCHDOG_DISPLAY);
                    }
                }

                if (NT_SUCCESS(ntStatus)) {

                    ULONG shutdownFlag = 1;
                    ULONG shutdownCount;
                    ULONG defaultShutdownCount = 0;
                    RTL_QUERY_REGISTRY_TABLE queryTable[] =
                    {
                        {NULL, RTL_QUERY_REGISTRY_DIRECT, L"ShutdownCount", &shutdownCount, REG_DWORD, &defaultShutdownCount, 4},
                        {NULL, 0, NULL}
                    };

                    //
                    // Get accumulated statistics from registry.
                    //

                    RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                           VP_KEY_WATCHDOG_DISPLAY,
                                           queryTable,
                                           NULL,
                                           NULL);

                    shutdownCount++;

                    //
                    // Update registry values.
                    //

                    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                          VP_KEY_WATCHDOG_DISPLAY,
                                          L"ShutdownCount",
                                          REG_DWORD,
                                          &shutdownCount,
                                          sizeof (ULONG));

                    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                          VP_KEY_WATCHDOG_DISPLAY,
                                          L"Shutdown",
                                          REG_DWORD,
                                          &shutdownFlag,
                                          sizeof (ULONG));
                }
            }
        }

        break;
    }

    //
    // Other major entry points in the dispatch routine are not supported.
    //

    default:

        statusBlock->Status = STATUS_SUCCESS;

        break;

    } // switch (irpStack->MajorFunction)

    //
    // save the final status so we can return it after the IRP is completed.
    //

    if (finalStatus == -1) {
        finalStatus = statusBlock->Status;
    }

    RELEASE_DEVICE_LOCK(combinedExtension);

#if REMOVE_LOCK_ENABLED
    IoReleaseRemoveLock(&combinedExtension->RemoveLock, Irp);
#endif

    if (finalStatus == STATUS_PENDING) {
        pVideoDebugPrint((Trace, "VIDEOPRT: Returned pending in pVideoPortDispatch.\n")) ;
        return STATUS_PENDING ;
    }

    pVideoDebugPrint((Trace, "VIDEOPRT: IoCompleteRequest with Irp %x\n", Irp));

    IoCompleteRequest(Irp,
                      IO_VIDEO_INCREMENT);

    //
    // We never have pending operation so always return the status code.
    //

    pVideoDebugPrint((Trace, "VIDEOPRT:  final IOCTL status: %08lx\n",
                     finalStatus));

    return finalStatus;

} // pVideoPortDispatch()


VOID
VideoPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    )

/*++

Routine Description:

    VideoPortFreeDeviceBase frees a block of I/O addresses or memory space
    previously mapped into the system address space by calling
    VideoPortGetDeviceBase.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    MappedAddress - Specifies the base address of the block to be freed. This
        value must be the same as the value returned by VideoPortGetDeviceBase.

Return Value:

    None.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    pVideoPortFreeDeviceBase(HwDeviceExtension, MappedAddress);
    return;
}


PVOID
pVideoPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    )
{
    PMAPPED_ADDRESS nextMappedAddress;
    PMAPPED_ADDRESS lastMappedAddress;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    pVideoDebugPrint((Info, "VPFreeDeviceBase at mapped address is %08lx\n",
                    MappedAddress));

    lastMappedAddress = NULL;
    nextMappedAddress = fdoExtension->MappedAddressList;

    while (nextMappedAddress) {

        if (nextMappedAddress->MappedAddress == MappedAddress) {

            //
            // Count up how much memory a miniport driver is really taking
            //

            if (nextMappedAddress->bNeedsUnmapping) {

                fdoExtension->MemoryPTEUsage -=
                    ADDRESS_AND_SIZE_TO_SPAN_PAGES(nextMappedAddress->MappedAddress,
                                          nextMappedAddress->NumberOfUchars);

            }

            if (!(--nextMappedAddress->RefCount)) {

                //
                // Unmap address, if necessary.
                //

                if (nextMappedAddress->bNeedsUnmapping) {

                    if (nextMappedAddress->bLargePageRequest) {

                        MmUnmapVideoDisplay(nextMappedAddress->MappedAddress,
                                            nextMappedAddress->NumberOfUchars);

                    } else {

                        MmUnmapIoSpace(nextMappedAddress->MappedAddress,
                                       nextMappedAddress->NumberOfUchars);
                    }
                }

                //
                // Remove mapped address from list.
                //

                if (lastMappedAddress == NULL) {

                    fdoExtension->MappedAddressList =
                    nextMappedAddress->NextMappedAddress;

                } else {

                    lastMappedAddress->NextMappedAddress =
                    nextMappedAddress->NextMappedAddress;

                }

                ExFreePool(nextMappedAddress);

            }

            //
            // We just return the value to show that the call succeeded.
            //

            return (nextMappedAddress);

        } else {

            lastMappedAddress = nextMappedAddress;
            nextMappedAddress = nextMappedAddress->NextMappedAddress;

        }
    }

    return NULL;

} // end VideoPortFreeDeviceBase()


PVOID
VideoPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfUchars,
    IN UCHAR InIoSpace
    )

/*++

Routine Description:

    VideoPortGetDeviceBase maps a memory or I/O address range into the
    system (kernel) address space.  Access to this mapped address space
    must follow these rules:

        If the input value for InIoSpace is 1 (the address IS in I/O space),
        the returned logical address should be used in conjunction with
        VideoPort[Read/Write]Port[Uchar/Ushort/Ulong] functions.
                             ^^^^

        If the input value for InIoSpace is 0 (the address IS NOT in I/O
        space), the returned logical address should be used in conjunction
        with VideoPort[Read/Write]Register[Uchar/Ushort/Ulong] functions.
                                  ^^^^^^^^

    Note that VideoPortFreeDeviceBase is used to unmap a previously mapped
    range from the system address space.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    IoAddress - Specifies the base physical address of the range to be
        mapped in the system address space.

    NumberOfUchars - Specifies the number of bytes, starting at the base
        address, to map in system space. The driver must not access
        addresses outside this range.

    InIoSpace - Specifies that the address is in the I/O space if 1.
        Otherwise, the address is assumed to be in memory space.

Return Value:

    This function returns a base address suitable for use by the hardware
    access functions. VideoPortGetDeviceBase may be called several times
    by the miniport driver.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    //
    // We specify large page as FALSE for the default since the miniport could
    // be using the address at raise IRQL in an ISR.
    //

    return pVideoPortGetDeviceBase(HwDeviceExtension,
                                   IoAddress,
                                   NumberOfUchars,
                                   InIoSpace,
                                   FALSE);

}

BOOLEAN
VpTranslateBusAddress(
    IN PFDO_EXTENSION fdoExtension,
    IN PPHYSICAL_ADDRESS IoAddress,
    IN OUT PULONG addressSpace,
    IN OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This routine finds the cpu relative address that matches the given
    bus relative address.

Arguments:

    fdoExtension - The device extension for the device in question.

    IoAddress - The address which we mean to translate.

    addressSpace - pointer to resource type (IO, memory, etc).

    TranslatedAddress - a pointer to the location in which to store the
        translated address.

Returns:

    TRUE if successful,
    FALSE otherwise.

--*/

{
    BOOLEAN bStatus;

    //
    // We need to find a way to translate dense space before we can
    // do this.
    //

#if 0
    if ((fdoExtension->Flags & LEGACY_DRIVER) != LEGACY_DRIVER) {

        bStatus = VpTranslateResource(
                      fdoExtension,
                      addressSpace,
                      IoAddress,
                      TranslatedAddress);

    } else {
#endif
        bStatus = HalTranslateBusAddress(
                      fdoExtension->AdapterInterfaceType,
                      fdoExtension->SystemIoBusNumber,
                      *IoAddress,
                      addressSpace,
                      TranslatedAddress);
#if 0
    }
#endif

    return bStatus;
}

PVOID
pVideoPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfUchars,
    IN UCHAR InIoSpace,
    IN BOOLEAN bLargePage
    )
{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    PHYSICAL_ADDRESS cardAddress = IoAddress;
    PVOID mappedAddress = NULL;
    PMAPPED_ADDRESS newMappedAddress;
    BOOLEAN bMapped;

    ULONG addressSpace;
    ULONG p6Caching = FALSE;

    pVideoDebugPrint((Info, "VPGetDeviceBase reqested %08lx mem type. address is %08lx %08lx, length of %08lx\n",
                     InIoSpace, IoAddress.HighPart, IoAddress.LowPart, NumberOfUchars));

    //
    // Properly configure the flags for translation
    //

    addressSpace = InIoSpace & 0xFF;

    p6Caching = addressSpace & VIDEO_MEMORY_SPACE_P6CACHE;

    addressSpace &= ~VIDEO_MEMORY_SPACE_P6CACHE;
    addressSpace &= ~VIDEO_MEMORY_SPACE_DENSE;

    if (addressSpace & VIDEO_MEMORY_SPACE_USER_MODE) {
        ASSERT(FALSE);
        return NULL;
    }

    if ((((cardAddress.QuadPart >= 0x000C0000) && (cardAddress.QuadPart < 0x000C8000)) &&
         (InIoSpace == 0) &&
         (VpC0000Compatible == 2)) ||
        VpTranslateBusAddress(fdoExtension,
                              &IoAddress,
                              &addressSpace,
                              &cardAddress)) {

        //
        // Use reference counting for addresses to support broken ATI !
        // Return the previously mapped address if we find the same physical
        // address.
        //

        PMAPPED_ADDRESS nextMappedAddress;

        pVideoDebugPrint((Info, "VPGetDeviceBase requested %08lx mem type. physical address is %08lx %08lx, length of %08lx\n",
                         addressSpace, cardAddress.HighPart, cardAddress.LowPart, NumberOfUchars));

        nextMappedAddress = fdoExtension->MappedAddressList;

        while (nextMappedAddress) {

            if ((nextMappedAddress->InIoSpace == InIoSpace) &&
                (nextMappedAddress->NumberOfUchars == NumberOfUchars) &&
                (nextMappedAddress->PhysicalAddress.QuadPart == cardAddress.QuadPart)) {


                pVideoDebugPrint((Info, "VPGetDeviceBase : refCount hit on address %08lx \n",
                                  nextMappedAddress->PhysicalAddress.LowPart));

                nextMappedAddress->RefCount++;

                //
                // Count up how much memory a miniport driver is really taking
                //

                if (nextMappedAddress->bNeedsUnmapping) {

                    fdoExtension->MemoryPTEUsage +=
                        ADDRESS_AND_SIZE_TO_SPAN_PAGES(nextMappedAddress->MappedAddress,
                                              nextMappedAddress->NumberOfUchars);

                }

                return (nextMappedAddress->MappedAddress);

            } else {

                nextMappedAddress = nextMappedAddress->NextMappedAddress;

            }
        }

        //
        // Allocate memory to store mapped address for unmap.
        //

        newMappedAddress = ExAllocatePoolWithTag(NonPagedPool,
                                                 sizeof(MAPPED_ADDRESS),
                                                 'trpV');

        if (!newMappedAddress) {

                pVideoDebugPrint((Error, "VIDEOPRT: Not enough memory to cache mapped address! \n"));
                return NULL;
        }

        //
        // If the address is in IO space, don't do anything.
        // If the address is in memory space, map it and save the information.
        //

        if (addressSpace & VIDEO_MEMORY_SPACE_IO) {

            mappedAddress = (PVOID) cardAddress.QuadPart;
            bMapped = FALSE;

        } else {

            //
            // Map the device base address into the virtual address space
            //
            // NOTE: This routine is order dependant, and changing flags like
            // bLargePage will affect the caching of address we do earlier
            // on in this routine.
            //

            if (p6Caching && EnableUSWC) {

                mappedAddress = MmMapIoSpace(cardAddress,
                                             NumberOfUchars,
                                             MmFrameBufferCached);

                if (mappedAddress == NULL) {

                    mappedAddress = MmMapIoSpace(cardAddress,
                                                 NumberOfUchars,
                                                 FALSE);
                }


            } else if (bLargePage) {

                mappedAddress = MmMapVideoDisplay(cardAddress,
                                                  NumberOfUchars,
                                                  0);

            } else {

                mappedAddress = MmMapIoSpace(cardAddress,
                                             NumberOfUchars,
                                             FALSE);
            }

            if (mappedAddress == NULL) {

                ExFreePool(newMappedAddress);
                pVideoDebugPrint((Error, "VIDEOPRT: MmMapIoSpace FAILED\n"));

                return NULL;
            }

            bMapped = TRUE;

            fdoExtension->MemoryPTEUsage +=
                ADDRESS_AND_SIZE_TO_SPAN_PAGES(mappedAddress,
                                      NumberOfUchars);
        }

        //
        // Save the reference
        //

        newMappedAddress->PhysicalAddress = cardAddress;
        newMappedAddress->RefCount = 1;
        newMappedAddress->MappedAddress = mappedAddress;
        newMappedAddress->NumberOfUchars = NumberOfUchars;
        newMappedAddress->InIoSpace = InIoSpace;
        newMappedAddress->bNeedsUnmapping = bMapped;
        newMappedAddress->bLargePageRequest = bLargePage;

        //
        // Link current list to new entry.
        //

        newMappedAddress->NextMappedAddress = fdoExtension->MappedAddressList;

        //
        // Point anchor at new list.
        //

        fdoExtension->MappedAddressList = newMappedAddress;

    } else {

        pVideoDebugPrint((Error, "VIDEOPRT: VpTranslateBusAddress failed\n"));

    }

    pVideoDebugPrint((Info, "VIDEOPRT: VideoPortGetDeviceBase mapped virtual address is %08lx\n",
                      mappedAddress));

    return mappedAddress;

} // end VideoPortGetDeviceBase()


NTSTATUS
pVideoPortGetDeviceDataRegistry(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )

/*++

Routine Description:


Arguments:



Return Value:


Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    //
    // This macro should be in the io system header file.
    //

#define GetIoQueryDeviceInfo(DeviceInfo, InfoType)                   \
    ((PVOID) ( ((PUCHAR) (*(DeviceInfo + InfoType))) +               \
               ((ULONG_PTR)  (*(DeviceInfo + InfoType))->DataOffset) ))

#define GetIoQueryDeviceInfoLength(DeviceInfo, InfoType)             \
    ((*(DeviceInfo + InfoType))->DataLength)

    PVP_QUERY_DEVICE queryDevice = Context;
    PKEY_VALUE_FULL_INFORMATION *deviceInformation;
    PCM_FULL_RESOURCE_DESCRIPTOR configurationData;

    switch (queryDevice->DeviceDataType) {

    case VpBusData:

        pVideoDebugPrint((Trace, "VIDEOPRT: VPGetDeviceDataCallback: BusData\n"));

        configurationData = (PCM_FULL_RESOURCE_DESCRIPTOR)
                            GetIoQueryDeviceInfo(BusInformation,
                                                 IoQueryDeviceConfigurationData);


        if (NO_ERROR == ((PMINIPORT_QUERY_DEVICE_ROUTINE)
                                queryDevice->CallbackRoutine)(
                                 queryDevice->MiniportHwDeviceExtension,
                                 queryDevice->MiniportContext,
                                 queryDevice->DeviceDataType,
                                 GetIoQueryDeviceInfo(BusInformation,
                                                      IoQueryDeviceIdentifier),
                                 GetIoQueryDeviceInfoLength(BusInformation,
                                                            IoQueryDeviceIdentifier),
                                 (PVOID) &(configurationData->PartialResourceList.PartialDescriptors[1]),
                                 configurationData->PartialResourceList.PartialDescriptors[0].u.DeviceSpecificData.DataSize,
                                 GetIoQueryDeviceInfo(BusInformation,
                                                      IoQueryDeviceComponentInformation),
                                 GetIoQueryDeviceInfoLength(BusInformation,
                                                            IoQueryDeviceComponentInformation)
                                 )) {

            return STATUS_SUCCESS;

        } else {

            return STATUS_DEVICE_DOES_NOT_EXIST;
        }

        break;

    case VpControllerData:

        deviceInformation = ControllerInformation;

        pVideoDebugPrint((Trace, "VIDEOPRT: VPGetDeviceDataCallback: ControllerData\n"));


        //
        // This data we are getting is actually a CM_FULL_RESOURCE_DESCRIPTOR.
        //

        if (NO_ERROR == ((PMINIPORT_QUERY_DEVICE_ROUTINE)
                             queryDevice->CallbackRoutine)(
                              queryDevice->MiniportHwDeviceExtension,
                              queryDevice->MiniportContext,
                              queryDevice->DeviceDataType,
                              GetIoQueryDeviceInfo(deviceInformation,
                                                   IoQueryDeviceIdentifier),
                              GetIoQueryDeviceInfoLength(deviceInformation,
                                                         IoQueryDeviceIdentifier),
                              GetIoQueryDeviceInfo(deviceInformation,
                                                   IoQueryDeviceConfigurationData),
                              GetIoQueryDeviceInfoLength(deviceInformation,
                                                         IoQueryDeviceConfigurationData),
                              GetIoQueryDeviceInfo(deviceInformation,
                                                   IoQueryDeviceComponentInformation),
                              GetIoQueryDeviceInfoLength(deviceInformation,
                                                         IoQueryDeviceComponentInformation)
                              )) {

            return STATUS_SUCCESS;

        } else {

            return STATUS_DEVICE_DOES_NOT_EXIST;
        }

        break;

    case VpMonitorData:

        deviceInformation = PeripheralInformation;

        pVideoDebugPrint((Trace, "VIDEOPRT: VPGetDeviceDataCallback: MonitorData\n"));


        //
        // This data we are getting is actually a CM_FULL_RESOURCE_DESCRIPTOR.
        //

        if (NO_ERROR == ((PMINIPORT_QUERY_DEVICE_ROUTINE)
                             queryDevice->CallbackRoutine)(
                              queryDevice->MiniportHwDeviceExtension,
                              queryDevice->MiniportContext,
                              queryDevice->DeviceDataType,
                              GetIoQueryDeviceInfo(deviceInformation,
                                                   IoQueryDeviceIdentifier),
                              GetIoQueryDeviceInfoLength(deviceInformation,
                                                         IoQueryDeviceIdentifier),
                              GetIoQueryDeviceInfo(deviceInformation,
                                                   IoQueryDeviceConfigurationData),
                              GetIoQueryDeviceInfoLength(deviceInformation,
                                                         IoQueryDeviceConfigurationData),
                              GetIoQueryDeviceInfo(deviceInformation,
                                                   IoQueryDeviceComponentInformation),
                              GetIoQueryDeviceInfoLength(deviceInformation,
                                                         IoQueryDeviceComponentInformation)
                              )) {

            return STATUS_SUCCESS;

        } else {

            return STATUS_DEVICE_DOES_NOT_EXIST;
        }

        break;

    default:

        ASSERT(FALSE);
        return STATUS_UNSUCCESSFUL;

    }

} // end pVideoPortGetDeviceDataRegistry()



VP_STATUS
VideoPortGetDeviceData(
    PVOID HwDeviceExtension,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PMINIPORT_QUERY_DEVICE_ROUTINE CallbackRoutine,
    PVOID Context
    )

/*++

Routine Description:

    VideoPortGetDeviceData retrieves information from the hardware hive in
    the registry.  The information retrieved from the registry is
    bus-specific or hardware-specific.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    DeviceDataType - Specifies the type of data being requested (as indicated
        in VIDEO_DEVICE_DATA_TYPE).

    CallbackRoutine - Points to a function that should be called back with
        the requested information.

    Context - Specifies a context parameter passed to the callback function.

Return Value:

    This function returns the final status of the operation.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
#define CMOS_MAX_DATA_SIZE 66000

    NTSTATUS ntStatus;
    VP_STATUS vpStatus;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    VP_QUERY_DEVICE queryDevice;
    PUCHAR cmosData = NULL;
    ULONG cmosDataSize;
    ULONG exCmosDataSize;
    UNICODE_STRING Identifier;
    PULONG pConfiguration = NULL;
    PULONG pComponent = NULL;

    queryDevice.MiniportHwDeviceExtension = HwDeviceExtension;
    queryDevice.DeviceDataType = DeviceDataType;
    queryDevice.CallbackRoutine = CallbackRoutine;
    queryDevice.MiniportStatus = NO_ERROR;
    queryDevice.MiniportContext = Context;

    switch (DeviceDataType) {

    case VpMachineData:

        pVideoDebugPrint((Trace, "VIDEOPRT: VPGetDeviceData: MachineData\n"));

        ntStatus = STATUS_UNSUCCESSFUL;

        pConfiguration = ExAllocatePoolWithTag(PagedPool,
                                               0x1000,
                                               VP_TAG);

        pComponent     = ExAllocatePoolWithTag(PagedPool,
                                               0x1000,
                                               VP_TAG);

        if (pConfiguration && pComponent)
        {
            RTL_QUERY_REGISTRY_TABLE QueryTable[] = {
                { NULL,
                  RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED,
                  L"Identifier",
                  &Identifier,
                  REG_NONE,
                  NULL,
                  0
                },
                { NULL,
                  RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED,
                  L"Configuration Data",
                  pConfiguration,
                  REG_NONE,
                  NULL,
                  0
                },
                { NULL,
                  RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED,
                  L"Component Information",
                  pComponent,
                  REG_NONE,
                  NULL,
                  0
                },

                // Null entry to mark the end

                { 0, 0, 0, 0, 0, 0, 0 }
            };

            //
            // The first DWORD of the buffer contains the size of the buffer.
            // Upon return, the first return contains the size of the data in the buffer.
            //
            // A NULL bufferint he UNICODE_STRING means the unicode string will be set up automatically
            //

            *pConfiguration = 0x1000 - 4;
            *pComponent     = 0x1000 - 4;
            Identifier.Buffer = NULL;

            if (NT_SUCCESS(RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                                  L"\\Registry\\Machine\\Hardware\\Description\\System",
                                                  QueryTable,
                                                  NULL,
                                                  NULL)))
            {

                vpStatus = ((PMINIPORT_QUERY_DEVICE_ROUTINE) CallbackRoutine)(
                                 HwDeviceExtension,
                                 Context,
                                 DeviceDataType,
                                 Identifier.Buffer,
                                 Identifier.Length,
                                 pConfiguration + 1,
                                 *pConfiguration,
                                 pComponent + 1,
                                 *pComponent);

                if (vpStatus == NO_ERROR)
                {
                    ntStatus = STATUS_SUCCESS;
                }
            }

            if (Identifier.Buffer)
            {
                ExFreePool(Identifier.Buffer);
            }
        }

        //
        // Free up the resources
        //

        if (pConfiguration)
        {
            ExFreePool(pConfiguration);
        }

        if (pComponent)
        {
            ExFreePool(pComponent);
        }

        break;

    case VpCmosData:

        pVideoDebugPrint((Trace, "VIDEOPRT: VPGetDeviceData: CmosData - not implemented\n"));


#if !defined(NO_LEGACY_DRIVERS)
        cmosData = ExAllocatePoolWithTag(PagedPool,
                                         CMOS_MAX_DATA_SIZE,
                                         VP_TAG);

        //
        // Allocate enough pool to store all the CMOS data.
        //

        if (!cmosData) {

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;

        }

        cmosDataSize = HalGetBusData(Cmos,
                                     0, // bus 0 returns standard Cmos info
                                     0, // no slot number
                                     cmosData,
                                     CMOS_MAX_DATA_SIZE);

        exCmosDataSize = HalGetBusData(Cmos,
                                       1, // bus 1 returns extended Cmos info
                                       0, // no slot number
                                       cmosData + cmosDataSize,
                                       CMOS_MAX_DATA_SIZE - cmosDataSize);

        //
        // Call the miniport driver callback routine
        //

        if (NO_ERROR == CallbackRoutine(HwDeviceExtension,
                                        Context,
                                        DeviceDataType,
                                        NULL,
                                        0,
                                        cmosData,
                                        cmosDataSize + exCmosDataSize,
                                        NULL,
                                        0)) {

            ntStatus = STATUS_SUCCESS;

        } else {

            ntStatus = STATUS_DEVICE_DOES_NOT_EXIST;
        }
#endif // NO_LEGACY_DRIVERS
        break;

        break;

    case VpBusData:

        pVideoDebugPrint((Trace, "VIDEOPRT: VPGetDeviceData: BusData\n"));

        ntStatus = IoQueryDeviceDescription(&fdoExtension->AdapterInterfaceType,
                                            &fdoExtension->SystemIoBusNumber,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &pVideoPortGetDeviceDataRegistry,
                                            (PVOID)(&queryDevice));

        break;

    case VpControllerData:

        pVideoDebugPrint((Trace, "VIDEOPRT: VPGetDeviceData: ControllerData\n"));

        //
        // Increment the controller number since we want to get info on the
        // new controller.
        // We do a pre-increment since the number must remain the same for
        // monitor queries.
        //

        VpQueryDeviceControllerNumber++;

        ntStatus = IoQueryDeviceDescription(&fdoExtension->AdapterInterfaceType,
                                            &fdoExtension->SystemIoBusNumber,
                                            &VpQueryDeviceControllerType,
                                            &VpQueryDeviceControllerNumber,
                                            NULL,
                                            NULL,
                                            &pVideoPortGetDeviceDataRegistry,
                                            (PVOID)(&queryDevice));

        //
        // Reset the Peripheral number to zero since we are working on a new
        // Controller.
        //

        VpQueryDevicePeripheralNumber = 0;

        break;

    case VpMonitorData:

        pVideoDebugPrint((Trace, "VIDEOPRT: VPGetDeviceData: MonitorData\n"));

        ntStatus = IoQueryDeviceDescription(&fdoExtension->AdapterInterfaceType,
                                            &fdoExtension->SystemIoBusNumber,
                                            &VpQueryDeviceControllerType,
                                            &VpQueryDeviceControllerNumber,
                                            &VpQueryDevicePeripheralType,
                                            &VpQueryDevicePeripheralNumber,
                                            &pVideoPortGetDeviceDataRegistry,
                                            (PVOID)(&queryDevice));

        //
        // Increment the peripheral number since we have the info on this
        // monitor already.
        //

        VpQueryDevicePeripheralNumber++;

        break;

    default:

        pVideoDebugPrint((Warn, "VIDEOPRT: VPGetDeviceData: invalid Data type\n"));

        ASSERT(FALSE);

        ntStatus = STATUS_UNSUCCESSFUL;

    }

    //
    // Free the pool we may have allocated
    //

    if (cmosData) {

        ExFreePool(cmosData);

    }

    if (NT_SUCCESS(ntStatus)) {

        return NO_ERROR;

    } else {


        pVideoDebugPrint((Warn, "VPGetDeviceData failed: return status is %08lx\n", ntStatus));

        return ERROR_INVALID_PARAMETER;

    }

} // end VideoPortGetDeviceData()



NTSTATUS
pVideoPortGetRegistryCallback(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
)

/*++

Routine Description:

    This routine gets information from the system hive, user-specified
    registry (as opposed to the information gathered by ntdetect.

Arguments:


    ValueName - Pointer to a unicode String containing the name of the data
        value being searched for.

    ValueType - Type of the data value.

    ValueData - Pointer to a buffer containing the information to be written
        out to the registry.

    ValueLength - Size of the data being written to the registry.

    Context - Specifies a context parameter passed to the callback routine.

    EntryContext - Specifies a second context parameter passed with the
        request.

Return Value:

    STATUS_SUCCESS

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    PVP_QUERY_DEVICE queryDevice = Context;
    UNICODE_STRING unicodeString;
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    HANDLE fileHandle = NULL;
    IO_STATUS_BLOCK ioStatusBlock;
    FILE_STANDARD_INFORMATION fileStandardInfo;
    PVOID fileBuffer = NULL;
    LARGE_INTEGER byteOffset;

    //
    // If the parameter was a file to be opened, perform the operation
    // here. Otherwise just return the data.
    //

    if (queryDevice->DeviceDataType == VP_GET_REGISTRY_FILE) {

        //
        // For the name of the file to be valid, we must first append
        // \DosDevices in front of it.
        //

        RtlInitUnicodeString(&unicodeString,
                             ValueData);

        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   (HANDLE) NULL,
                                   (PSECURITY_DESCRIPTOR) NULL);

        ntStatus = ZwOpenFile(&fileHandle,
                              FILE_GENERIC_READ | SYNCHRONIZE,
                              &objectAttributes,
                              &ioStatusBlock,
                              0,
                              FILE_SYNCHRONOUS_IO_ALERT);

        if (!NT_SUCCESS(ntStatus)) {

            pVideoDebugPrint((Error, "VIDEOPRT: VideoPortGetRegistryParameters: Could not open file\n"));
            goto EndRegistryCallback;

        }

        ntStatus = ZwQueryInformationFile(fileHandle,
                                          &ioStatusBlock,
                                          &fileStandardInfo,
                                          sizeof(FILE_STANDARD_INFORMATION),
                                          FileStandardInformation);

        if (!NT_SUCCESS(ntStatus)) {

            pVideoDebugPrint((Error, "VIDEOPRT: VideoPortGetRegistryParameters: Could not get size of file\n"));
            goto EndRegistryCallback;

        }

        if (fileStandardInfo.EndOfFile.HighPart) {

            //
            // If file is too big, do not try to go further.
            //

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto EndRegistryCallback;

        }

        ValueLength = fileStandardInfo.EndOfFile.LowPart;

        fileBuffer = ExAllocatePoolWithTag(PagedPool,
                                           ValueLength,
                                           VP_TAG);

        if (!fileBuffer) {

            pVideoDebugPrint((Error, "VideoPortGetRegistryParameters: Could not allocate buffer to read file\n"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

            goto EndRegistryCallback;

        }

        ValueData = fileBuffer;

        //
        // Read the entire file for the beginning.
        //

        byteOffset.QuadPart = 0;

        ntStatus = ZwReadFile(fileHandle,
                              NULL,
                              NULL,
                              NULL,
                              &ioStatusBlock,
                              ValueData,
                              ValueLength,
                              &byteOffset,
                              NULL);

        if (!NT_SUCCESS(ntStatus)) {

            pVideoDebugPrint((Error, "VIDEOPRT: VideoPortGetRegistryParameters: Could not read file\n"));
            goto EndRegistryCallback;

        }

    }

    //
    // Call the miniport with the appropriate information.
    //

    queryDevice->MiniportStatus = ((PMINIPORT_GET_REGISTRY_ROUTINE)
               queryDevice->CallbackRoutine) (queryDevice->MiniportHwDeviceExtension,
                                              queryDevice->MiniportContext,
                                              ValueName,
                                              ValueData,
                                              ValueLength);

EndRegistryCallback:

    if (fileHandle) {

        ZwClose(fileHandle);

    }

    if (fileBuffer) {

        ExFreePool(fileBuffer);

    }

    return ntStatus;

} // end pVideoPortGetRegistryCallback()



VP_STATUS
VideoPortGetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ParameterName,
    UCHAR IsParameterFileName,
    PMINIPORT_GET_REGISTRY_ROUTINE CallbackRoutine,
    PVOID Context
    )

/*++

Routine Description:

    VideoPortGetRegistryParameters retrieves information from the
    CurrentControlSet in the registry.  The function automatically searches
    for the specified parameter name under the \Devicexxx key for the
    current driver.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    ParameterName - Points to a Unicode string that contains the name of the
        data value being searched for in the registry.

    IsParameterFileName - If 1, the data retrieved from the requested
        parameter name is treated as a file name.  The contents of the file are
        returned, instead of the parameter itself.

    CallbackRoutine - Points to a function that should be called back with
        the requested information.

    Context - Specifies a context parameter passed to the callback routine.

Return Value:

    This function returns the final status of the operation.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    VP_STATUS vpStatus = ERROR_INVALID_PARAMETER;
    PDEVICE_SPECIFIC_EXTENSION DoSpecificExtension = GET_DSP_EXT(HwDeviceExtension);
    
    if (DoSpecificExtension->DriverNewRegistryPath != NULL) {
    
        vpStatus = VPGetRegistryParameters(HwDeviceExtension,
                                           ParameterName,
                                           IsParameterFileName,
                                           CallbackRoutine,
                                           Context,
                                           DoSpecificExtension->DriverNewRegistryPath,
                                           DoSpecificExtension->DriverNewRegistryPathLength);
    } else {

        vpStatus = VPGetRegistryParameters(HwDeviceExtension,
                                           ParameterName,
                                           IsParameterFileName,
                                           CallbackRoutine,
                                           Context,
                                           DoSpecificExtension->DriverOldRegistryPath,
                                           DoSpecificExtension->DriverOldRegistryPathLength);
    }

    return vpStatus;
}


VP_STATUS
VPGetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ParameterName,
    UCHAR IsParameterFileName,
    PMINIPORT_GET_REGISTRY_ROUTINE CallbackRoutine,
    PVOID Context,
    PWSTR RegistryPath,
    ULONG RegistryPathLength
    )
{
    RTL_QUERY_REGISTRY_TABLE   queryTable[2];
    NTSTATUS                   ntStatus;
    VP_QUERY_DEVICE            queryDevice;
    LPWSTR                     RegPath;
    LPWSTR                     lpstrStart, lpstrEnd;

    ASSERT (ParameterName != NULL);
    
    //
    // Check if there are subkeys to be entered
    //

    RegPath = (LPWSTR) ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,
                                             RegistryPathLength +
                                                 2 * (wcslen(ParameterName) + sizeof(WCHAR)),
                                             VP_TAG);
    if (RegPath == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    wcscpy(RegPath, RegistryPath);

    if (!IsParameterFileName)
    {
        lpstrStart = RegPath + (RegistryPathLength / 2);

        while (lpstrEnd = wcschr(ParameterName, L'\\'))
        {
            //
            // Concat the string
            //
            *(lpstrStart++) = L'\\';
            while (ParameterName != lpstrEnd) {
                *(lpstrStart++) = *(ParameterName++);
            }
            *lpstrStart = UNICODE_NULL;

            ParameterName++;
        }
    }


    queryDevice.MiniportHwDeviceExtension = HwDeviceExtension;
    queryDevice.DeviceDataType = IsParameterFileName ? VP_GET_REGISTRY_FILE : VP_GET_REGISTRY_DATA;
    queryDevice.CallbackRoutine = CallbackRoutine;
    queryDevice.MiniportStatus = NO_ERROR;
    queryDevice.MiniportContext = Context;

    //
    // Can be simplified now since we don't have to go down a directory.
    // It can be just one call.
    //

    queryTable[0].QueryRoutine = pVideoPortGetRegistryCallback;
    queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = ParameterName;
    queryTable[0].EntryContext = NULL;
    queryTable[0].DefaultType = REG_NONE;
    queryTable[0].DefaultData = 0;
    queryTable[0].DefaultLength = 0;

    queryTable[1].QueryRoutine = NULL;
    queryTable[1].Flags = 0;
    queryTable[1].Name = NULL;
    queryTable[1].EntryContext = NULL;
    queryTable[1].DefaultType = REG_NONE;
    queryTable[1].DefaultData = 0;
    queryTable[1].DefaultLength = 0;

    ntStatus = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                      RegPath,
                                      queryTable,
                                      &queryDevice,
                                      NULL);

    if (!NT_SUCCESS(ntStatus)) {

        queryDevice.MiniportStatus = ERROR_INVALID_PARAMETER;

    }

    ExFreePool(RegPath);

    return queryDevice.MiniportStatus;

} // end VideoPortGetRegistryParameters()


VOID
pVPInit(
    VOID
    )

/*++

Routine Description:

    First time initialization of the video port.

    Normally, this is the stuff we should put in the DriverEntry routine.
    However, the video port is being loaded as a DLL, and the DriverEntry
    is never called.  It would just be too much work to add it back to the hive
    and setup.

    This little routine works just as well.

--*/

{

    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS ntStatus;
    HANDLE hkRegistry;
    UCHAR OptionsData[512];
    HANDLE physicalMemoryHandle = NULL;
    PBACKLIGHT_STATUS pVpBacklightStatus = &VpBacklightStatus;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = NULL;

    HAL_DISPLAY_BIOS_INFORMATION HalBiosInfo;
    ULONG HalBiosInfoLen = sizeof(ULONG);

    SYSTEM_BASIC_INFORMATION basicInfo;

    //
    // Check for USWC disabling
    //

    RtlInitUnicodeString(&UnicodeString,
                         L"\\Registry\\Machine\\System\\CurrentControlSet"
                         L"\\Control\\GraphicsDrivers\\DisableUSWC");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    ntStatus = ZwOpenKey(&hkRegistry,
                       GENERIC_READ | GENERIC_WRITE,
                       &ObjectAttributes);


    if (NT_SUCCESS(ntStatus)) {

        EnableUSWC = FALSE;
        ZwClose(hkRegistry);
    }

    //
    // Check for setup running
    //

    {
        ULONG defaultValue = 0;
        ULONG UpgradeInProgress = 0, SystemSetupInProgress = 0, MiniSetupInProgress = 0;
        RTL_QUERY_REGISTRY_TABLE QueryTable[] = {
            {NULL, RTL_QUERY_REGISTRY_DIRECT, L"SystemSetupInProgress",
             &SystemSetupInProgress, REG_DWORD, &defaultValue, 4},
            {NULL, RTL_QUERY_REGISTRY_DIRECT, L"UpgradeInProgress",
             &UpgradeInProgress, REG_DWORD, &defaultValue, 4},
            {NULL, RTL_QUERY_REGISTRY_DIRECT, L"MiniSetupInProgress",
             &MiniSetupInProgress, REG_DWORD, &defaultValue, 4},
            {NULL, 0, NULL}
        };

        RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                               L"\\Registry\\Machine\\System\\Setup",
                               &QueryTable[0],
                               NULL,
                               NULL);

        // System is doing an upgrade.
        if (UpgradeInProgress)
        {
            ASSERT(SystemSetupInProgress);
            VpSetupType = SETUPTYPE_UPGRADE;
        }
        // System is doing a clean install.
        else if (SystemSetupInProgress && !MiniSetupInProgress)
        {
            VpSetupType = SETUPTYPE_FULL;
        }
        else
        {
            VpSetupType = SETUPTYPE_NONE;
        }
        VpSetupTypeAtBoot = VpSetupType;
    }

    //
    // Check for basevideo from the start options
    //

    RtlInitUnicodeString(&UnicodeString,
                         L"\\Registry\\Machine\\System\\CurrentControlSet"
                         L"\\Control");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    ntStatus = ZwOpenKey(&hkRegistry,
                         GENERIC_READ | GENERIC_WRITE,
                         &ObjectAttributes);

    if (NT_SUCCESS(ntStatus)) {

        PVOID pwszOptions;
        ULONG returnSize;

        RtlInitUnicodeString(&UnicodeString,
                             L"SystemStartOptions");

        ntStatus = ZwQueryValueKey(hkRegistry,
                                 &UnicodeString,
                                 KeyValueFullInformation,
                                 OptionsData,
                                 sizeof(OptionsData),
                                 &returnSize);

        if ((NT_SUCCESS(ntStatus)) &&
            (((PKEY_VALUE_FULL_INFORMATION)OptionsData)->DataLength) &&
            (((PKEY_VALUE_FULL_INFORMATION)OptionsData)->DataOffset)) {

            pwszOptions = ((PUCHAR)OptionsData) +
                ((PKEY_VALUE_FULL_INFORMATION)OptionsData)->DataOffset;

            if (wcsstr(pwszOptions, L"BASEVIDEO")) {

                VpBaseVideo = TRUE;
            }
        }

        ZwClose(hkRegistry);
    }

    if (VpBaseVideo == TRUE)
    {
        //
        // If we are in Basevideo mode, then create a key and value in the
        // currentcontrolset part of the hardware profile that USER will
        // read to determine if the vga driver should be used or not.
        //

        RtlInitUnicodeString(&UnicodeString,
                             L"\\Registry\\Machine\\System\\CurrentControlSet\\"
                             L"Control\\GraphicsDrivers\\BaseVideo");

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        ntStatus = ZwCreateKey(&hkRegistry,
                             GENERIC_READ | GENERIC_WRITE,
                             &ObjectAttributes,
                             0L,
                             NULL,
                             REG_OPTION_VOLATILE,
                             NULL);

        if (NT_SUCCESS(ntStatus)) {

            ZwClose(hkRegistry);

        } else {

            ASSERT(FALSE);
        }
    }

    //
    // Determine if we have a VGA compatible machine
    //

    ntStatus = HalQuerySystemInformation(HalDisplayBiosInformation,
                                         HalBiosInfoLen,
                                         &HalBiosInfo,
                                         &HalBiosInfoLen);


    if (NT_SUCCESS(ntStatus)) {

        if (HalBiosInfo == HalDisplayInt10Bios) {

            VpC0000Compatible = 2;

        } else {

            // == HalDisplayEmulatedBios,
            // == HalDisplayNoBios

            VpC0000Compatible = 0;
        }

    } else {

        //
        // In case of an error in the API call, we just assume it's an old HAL
        // and use the old behaviour of the video port which is to assume
        // there is a BIOS at C000
        //

        VpC0000Compatible = 1;
    }


    //
    // Lets open the physical memory section just once, for all drivers.
    //

    //
    // Get a pointer to physical memory so we can map the
    // video frame buffer (and possibly video registers) into
    // the caller's address space whenever he needs it.
    //
    // - Create the name
    // - Initialize the data to find the object
    // - Open a handle to the oject and check the status
    // - Get a pointer to the object
    // - Free the handle
    //

    RtlInitUnicodeString(&UnicodeString,
                         L"\\Device\\PhysicalMemory");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               (HANDLE) NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    ntStatus = ZwOpenSection(&physicalMemoryHandle,
                             SECTION_ALL_ACCESS,
                             &ObjectAttributes);

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = ObReferenceObjectByHandle(physicalMemoryHandle,
                                             SECTION_ALL_ACCESS,
                                             (POBJECT_TYPE) NULL,
                                             KernelMode,
                                             &PhysicalMemorySection,
                                             (POBJECT_HANDLE_INFORMATION) NULL);

        if (!NT_SUCCESS(ntStatus)) {

        pVideoDebugPrint((Warn, "VIDEOPRT: VPInit: Could not reference physical memory\n"));
            ASSERT(PhysicalMemorySection == NULL);

        }

        ZwClose(physicalMemoryHandle);
    }

    VpSystemMemorySize = 0;

    ntStatus = ZwQuerySystemInformation(SystemBasicInformation,
                                        &basicInfo,
                                        sizeof(basicInfo),
                                        NULL);

    if (NT_SUCCESS(ntStatus)) {

        VpSystemMemorySize
            = (ULONGLONG)basicInfo.NumberOfPhysicalPages * (ULONGLONG)basicInfo.PageSize;
    }

    //
    // Initialize the fast mutex to protect the LCD Panel information
    // Initialize the fast mutex to protect INT10
    //

    KeInitializeMutex (&LCDPanelMutex, 0);
    KeInitializeMutex (&VpInt10Mutex, 0);

    //
    // Check if we should use the new way of generating the registry path 
    //

    RtlInitUnicodeString(&UnicodeString, 
                         SZ_USE_NEW_KEY);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    ntStatus = ZwOpenKey(&hkRegistry,
                         GENERIC_READ | GENERIC_WRITE,
                         &ObjectAttributes);
    
    if (NT_SUCCESS(ntStatus)) {

        EnableNewRegistryKey = TRUE;
        ZwClose(hkRegistry);
    }
    
    //
    // Initialize our structure which tracks the state of
    //  a backlight for the LCD (when present)
    //
    
    pVpBacklightStatus->bQuerySupportedBrightnessCalled = FALSE;
    pVpBacklightStatus->bACBrightnessKnown = FALSE;
    pVpBacklightStatus->bDCBrightnessKnown = FALSE;
    pVpBacklightStatus->bBIOSDefaultACKnown = FALSE;
    pVpBacklightStatus->bBIOSDefaultDCKnown = FALSE;
    pVpBacklightStatus->bNewAPISupported   = FALSE;
    pVpBacklightStatus->bACBrightnessInRegistry = FALSE;
    pVpBacklightStatus->bACBrightnessInRegistry = FALSE;

    //
    // Read the registry to find out if the new API is supported.
    //  If so, retreive the AC/DC brightness values and set the
    //  brightness as applicable (depending upon VpRunningOnAC).
    //
    // Note: We will store the Backlight info in the following
    //  location in the registry:
    //
    // HKLM\System\CurrentControlSet\Control\Backlight
    //
    //  The values there will be:
    //
    //  NewAPISupported     REG_DWORD   0 Not Supported
    //                                  1 Supported
    //
    //
    //  ACBacklightLevel    REG_DWORD   0-255
    //
    //  DCBacklightLevel    REG_DWORD   0-255
    //

    pKeyValueInfo = ExAllocatePoolWithTag(PagedPool,
                                          sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 3,
                                          VP_TAG);

    if (pKeyValueInfo == NULL) {
        return;
    }

    RtlInitUnicodeString(&UnicodeString,
                         L"\\Registry\\Machine\\System\\CurrentControlSet"
                         L"\\Control\\Backlight");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    ntStatus = ZwOpenKey(&hkRegistry,
                       GENERIC_READ | GENERIC_WRITE,
                       &ObjectAttributes);

    if (NT_SUCCESS(ntStatus)) {

        // 
        // The key is there, read the 3 values listed above
        //

        ULONG ulReturnSize;

        // NewAPISupported

        RtlInitUnicodeString(&UnicodeString,
                             L"NewAPISupported");

        ntStatus = ZwQueryValueKey(hkRegistry,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 (PVOID) pKeyValueInfo,
                                 sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 3,
                                 &ulReturnSize);

        if (NT_SUCCESS(ntStatus)) {

            if ((UCHAR) *pKeyValueInfo->Data) {

                pVpBacklightStatus->bNewAPISupported = TRUE;
            } 

            // ACBacklightLevel

            RtlInitUnicodeString(&UnicodeString,
                                 L"ACBacklightLevel");

            ntStatus = ZwQueryValueKey(hkRegistry,
                                     &UnicodeString,
                                     KeyValuePartialInformation,
                                     (PVOID) pKeyValueInfo,
                                     sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 3,
                                     &ulReturnSize);

            if (NT_SUCCESS(ntStatus)) {

                pVpBacklightStatus->bACBrightnessInRegistry = TRUE;
                pVpBacklightStatus->bACBrightnessKnown = TRUE;
                pVpBacklightStatus->ucACBrightness = (UCHAR) *pKeyValueInfo->Data;
            }

            // DCBacklightLevel

            RtlInitUnicodeString(&UnicodeString,
                                 L"DCBacklightLevel");

            ntStatus = ZwQueryValueKey(hkRegistry,
                                     &UnicodeString,
                                     KeyValuePartialInformation,
                                     (PVOID) pKeyValueInfo,
                                     sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 3,
                                     &ulReturnSize);

            if (NT_SUCCESS(ntStatus)) {

                pVpBacklightStatus->bDCBrightnessInRegistry = TRUE;
                pVpBacklightStatus->bDCBrightnessKnown = TRUE;
                pVpBacklightStatus->ucDCBrightness = (UCHAR) *pKeyValueInfo->Data;
            }

        }

        ZwClose(hkRegistry);
    }

    if (pKeyValueInfo) {
        ExFreePool(pKeyValueInfo);
    }

    //
    // Most laptops respond incorrectly to HwSetPowerState calls
    //  on lid close.  By default, we will support the XP behavior
    //  and not notify the miniport on lid close.
    //
    // The driver will be called if the following registry key
    //  is present:
    //
    // HKLM\System\CurrentControlSet\Control\GraphicsDrivers\LidCloseSetPower"
    //

    RtlInitUnicodeString(&UnicodeString,
                         SZ_LIDCLOSE);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    ntStatus = ZwOpenKey(&hkRegistry,
                       GENERIC_READ | GENERIC_WRITE,
                       &ObjectAttributes);

    if (NT_SUCCESS(ntStatus)) {

        VpLidCloseSetPower = TRUE;
        ZwClose(hkRegistry);
    }

    //
    // Initialize the bugcheck callback record
    //

    KeInitializeCallbackRecord(&VpCallbackRecord);

    //
    // Regiter for bugcheck callbacks.
    //

    KeRegisterBugCheckReasonCallback(&VpCallbackRecord,
                                     pVpBugcheckCallback,
                                     KbCallbackSecondaryDumpData,
                                     "Videoprt");

    //
    // Initialize the global video port mutex.
    //

    KeInitializeMutex(&VpGlobalLock, 0);
}

VOID
VpDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    ULONG_PTR        emptyList = 0;
    BOOLEAN         conflict;

    //ULONG           iReset;
    //PDEVICE_OBJECT  DeviceObject = DriverObject->DeviceObject;

    //
    // Release the resource we put in the resourcemap (if any).
    //

    IoReportResourceUsage(&VideoClassName,
                          DriverObject,
                          NULL,
                          0L,
                          NULL,
                          (PCM_RESOURCE_LIST) &emptyList,
                          sizeof(ULONG_PTR),
                          FALSE,
                          &conflict);

    //
    // Unregister LCD callbacks.
    //

    VpUnregisterLCDCallbacks();
        
    //
    // Unregister Dock/Undock callbacks.
    //
    if (DockCallbackHandle)
    {
        IoUnregisterPlugPlayNotification(DockCallbackHandle);
    }

    //
    // Make absolutely certain there are no HwResetHw routines left
    // for this devices controlled by this DriverObject.
    //

    //while (DeviceObject) {
    //
    //    for (iReset=0; iReset<6; iReset++) {
    //
    //        if (HwResetHw[iReset].HwDeviceExtension ==
    //            ((PDEVICE_EXTENSION)
    //            DeviceObject->DeviceExtension)->HwDeviceExtension) {
    //
    //            HwResetHw[iReset].ResetFunction = NULL;
    //            break;
    //        }
    //    }
    //
    //    DeviceObject = DeviceObject->NextDevice;
    //}

    // This is causing us to lose video on a number of systems
    //  during setup.  This code can be used when the necessary
    //  additional checks are determined.
    //
    //if (CsrProcess) {
    //    ObDereferenceObject(CsrProcess);
    //    CsrProcess = NULL;
    //}

    //
    // Unregister bugcheck callbacks
    //

    KeDeregisterBugCheckReasonCallback(&VpCallbackRecord);

    return;
}



NTSTATUS
VpInitializeBusCallback(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )
{
    return STATUS_SUCCESS;

} // end VpInitializeBusCallback()


VP_STATUS
VpRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

{
    if (ValueLength && ValueData) {

        *((PULONG)Context) = *((PULONG)ValueData);

        return NO_ERROR;

    } else {

        return ERROR_INVALID_PARAMETER;
    }
}

NTSTATUS
VpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
)
{
    NTSTATUS            ntStatus;
    PDEVICE_OBJECT      functionalDeviceObject;
    PDEVICE_OBJECT      attachedTo;
    PFDO_EXTENSION      fdoExtension;
    ULONG               extensionAllocationSize;
    PVIDEO_PORT_DRIVER_EXTENSION DriverObjectExtension;
    PVIDEO_HW_INITIALIZATION_DATA HwInitializationData;

    pVideoDebugPrint((Trace, "VIDEOPRT: VpAddDevice\n"));

    DriverObjectExtension = (PVIDEO_PORT_DRIVER_EXTENSION)
                      IoGetDriverObjectExtension(DriverObject,
                                                 DriverObject);

    HwInitializationData = &DriverObjectExtension->HwInitData;

    extensionAllocationSize = HwInitializationData->HwDeviceExtensionSize +
                                  sizeof(FDO_EXTENSION) +
                                  sizeof(DEVICE_SPECIFIC_EXTENSION);

    ntStatus = VpCreateDevice(DriverObject,
                              extensionAllocationSize,
                              &functionalDeviceObject);

    if (NT_SUCCESS(ntStatus)) {

        PCHILD_PDO_EXTENSION PdoExtension = PhysicalDeviceObject->DeviceExtension;

        VideoDeviceNumber++;
        fdoExtension = (PFDO_EXTENSION)functionalDeviceObject->DeviceExtension;

        //
        // Set any deviceExtension fields here that are PnP specific
        //

        fdoExtension->ChildPdoNumber = 0;
        fdoExtension->ChildPdoList   = NULL;
        fdoExtension->PhysicalDeviceObject = PhysicalDeviceObject;

        //
        // Since the pnp system is notifying us of our device, this is
        // not a legacy device.
        //

        fdoExtension->Flags = PNP_ENABLED;

        //
        // Now attach to the PDO we were given.
        //

        attachedTo = IoAttachDeviceToDeviceStack(functionalDeviceObject,
                                                 PhysicalDeviceObject);

        if (attachedTo == NULL) {

            pVideoDebugPrint((Error, "VIDEOPRT: Could not attach in AddDevice.\n"));
                ASSERT(attachedTo != NULL);
    
            //
            // Couldn't attach.  Delete the FDO, and tear down anything that has
            // been allocated so far.
            //
    
            VideoDeviceNumber--;
            IoDeleteDevice (functionalDeviceObject);
            return STATUS_NO_SUCH_DEVICE;
        }

        //
        // Initialize the remove lock.
        //

        IoInitializeRemoveLock(&fdoExtension->RemoveLock, 0, 0, 256);

        fdoExtension->AttachedDeviceObject = attachedTo;

        fdoExtension->VpDmaAdapterHead = NULL ;

        //
        // Set the power management flag indicating that device mapping
        // has not been done yet.
        //

        fdoExtension->IsMappingReady = FALSE ;

        //
        // Clear DO_DEVICE_INITIALIZING flag.
        //

        functionalDeviceObject->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;
        functionalDeviceObject->Flags &= ~(DO_DEVICE_INITIALIZING | DO_POWER_INRUSH);

        //
        // Save the function pointers to the new 5.0 miniport driver callbacks.
        //

        if (HwInitializationData->HwInitDataSize >
            FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwQueryInterface)) {

            fdoExtension->HwSetPowerState  = HwInitializationData->HwSetPowerState;
            fdoExtension->HwGetPowerState  = HwInitializationData->HwGetPowerState;
            fdoExtension->HwQueryInterface = HwInitializationData->HwQueryInterface;
            fdoExtension->HwGetVideoChildDescriptor = HwInitializationData->HwGetVideoChildDescriptor;
        }

    }

    pVideoDebugPrint((Trace, "VIDEOPRT: VpAddDevice returned: 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
VpCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    OUT PDEVICE_OBJECT *FunctionalDeviceObject
)
{
    WCHAR deviceNameBuffer[STRING_LENGTH];
    UNICODE_STRING deviceNameUnicodeString;
    NTSTATUS ntStatus;
    PFDO_EXTENSION fdoExtension;
    PDEVICE_SPECIFIC_EXTENSION DoSpecificExtension;

    ntStatus = pVideoPortCreateDeviceName(L"\\Device\\Video",
                                          VideoDeviceNumber,
                                          &deviceNameUnicodeString,
                                          deviceNameBuffer);

    //
    // Create a device object to represent the Video Adapter.
    //

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = IoCreateDevice(DriverObject,
                                  DeviceExtensionSize,
                                  &deviceNameUnicodeString,
                                  FILE_DEVICE_VIDEO,
                                  0,
                                  TRUE,
                                  FunctionalDeviceObject);

        if (NT_SUCCESS(ntStatus)) {

            ntStatus = IoRegisterShutdownNotification(*FunctionalDeviceObject);
            if (!NT_SUCCESS(ntStatus)) {

                IoDeleteDevice(*FunctionalDeviceObject);
                *FunctionalDeviceObject = NULL;

            } else {

                (*FunctionalDeviceObject)->DeviceType = FILE_DEVICE_VIDEO;
                fdoExtension = (*FunctionalDeviceObject)->DeviceExtension;

                //
                // Set any deviceExtension fields here
                //

                DoSpecificExtension = (PVOID)(fdoExtension + 1);

                DoSpecificExtension->DeviceNumber = VideoDeviceNumber;
                DoSpecificExtension->pFdoExtension = fdoExtension;
                DoSpecificExtension->Signature = VP_TAG;
                DoSpecificExtension->ExtensionType = TypeDeviceSpecificExtension;
                DoSpecificExtension->HwDeviceExtension = (PVOID)(DoSpecificExtension + 1);
                DoSpecificExtension->DualviewFlags = 0;
#ifdef IOCTL_VIDEO_USE_DEVICE_IN_SESSION
                DoSpecificExtension->SessionId = VIDEO_DEVICE_INVALID_SESSION;
#endif IOCTL_VIDEO_USE_DEVICE_IN_SESSION

                fdoExtension->pFdoExtension = fdoExtension;
                fdoExtension->Signature = VP_TAG;
                fdoExtension->ExtensionType = TypeFdoExtension;
                fdoExtension->FunctionalDeviceObject = *FunctionalDeviceObject;
                fdoExtension->DriverObject = DriverObject;

                KeInitializeMutex(&fdoExtension->SyncMutex,
                                  0);
            }
        }
    }

    return ntStatus;
}

ULONG
VideoPortInitialize(
    IN PVOID Argument1,  // DriverObject
    IN PVOID Argument2,  // RegistryPath
    IN PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext
    )
{
    PDRIVER_OBJECT driverObject = Argument1;
    NTSTATUS ntStatus;
    PUNICODE_STRING   registryPath = (PUNICODE_STRING) Argument2;
    ULONG PnpFlags;

    if (VPFirstTime)
    {
        VPFirstTime = FALSE;
        pVPInit();
    }

    //
    // Check if the size of the pointer, or the size of the data passed in
    // are OK.
    //

    ASSERT(HwInitializationData != NULL);

    if (HwInitializationData->HwInitDataSize >
        sizeof(VIDEO_HW_INITIALIZATION_DATA) ) {

        pVideoDebugPrint((Error, "VIDEOPRT: Invalid initialization data size\n"));
        return ((ULONG) STATUS_REVISION_MISMATCH);

    }

    //
    // Check that each required entry is not NULL.
    //

    if ((!HwInitializationData->HwFindAdapter) ||
        (!HwInitializationData->HwInitialize) ||
        (!HwInitializationData->HwStartIO)) {

        pVideoDebugPrint((Error, "VIDEOPRT: Miniport missing required entry\n"));
        return ((ULONG)STATUS_REVISION_MISMATCH);

    }

    //
    // Check the registry for PnP Flags.  Currently we recongnize the
    // following values:
    //
    // PnPEnabled -   If this value is set with a non-zero value, we
    //                will treat behave like a PnP driver.
    //
    // LegacyDetect - If this value is non-zero, we will report
    //                a non-pci device to the system via
    //                IoReportDetectedDevice.
    //
    // If we don't get the flags, we don't know how to run this driver.
    // return failure
    //

    if (!(NT_SUCCESS(VpGetFlags(registryPath,
                                HwInitializationData,
                                &PnpFlags))))
    {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // During an upgrade don't allow a driver to start unless it was written
    // for this version of Windows.
    //

    if ((VpSetupTypeAtBoot == SETUPTYPE_UPGRADE) &&
        (HwInitializationData->HwInitDataSize < sizeof(VIDEO_HW_INITIALIZATION_DATA)))
    {
        pVideoDebugPrint((0, "We don't allow pre WinXP drivers to start during upgrade.\n"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Set up the device driver entry points.
    //

    driverObject->DriverUnload                         = VpDriverUnload;
    driverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = pVideoPortDispatch;
    driverObject->MajorFunction[IRP_MJ_CREATE]         = pVideoPortDispatch;
    driverObject->MajorFunction[IRP_MJ_CLOSE]          = pVideoPortDispatch;
    driverObject->MajorFunction[IRP_MJ_SHUTDOWN]       = pVideoPortDispatch;

    //
    // Check that the device extension size is reasonable.
    //

#if DBG
    if (HwInitializationData->HwDeviceExtensionSize > 0x4000) {
        pVideoDebugPrint((Warn, "VIDEOPRT: VideoPortInitialize:\n"
                          "Warning: Device Extension is stored in non-paged pool\n"
                          "         Do you need a 0x%x byte device extension?\n",
                          HwInitializationData->HwDeviceExtensionSize));
    }
#endif

    //
    // PnP drivers have new rules.
    //

    if (PnpFlags & PNP_ENABLED)
    {
        pVideoDebugPrint((Trace, "VIDEOPRT: VideoPortInitialize with PNP_ENABLED\n"));

        //
        // We also can't be plug and play compatible if the driver passes
        // info in HwContext.  This is because we can't store this.
        //

        if ((PnpFlags & VGA_DRIVER) ||
            (HwContext != NULL))
        {
            pVideoDebugPrint((Error, "VIDEOPRT: This video driver can not be "
                                 "PNP due to passing info in HwContext.\n"));
            ASSERT(FALSE);
            return STATUS_INVALID_PARAMETER;
        }

    } else {

        //
        // Don't allow a non PnP driver to start after the system is up and
        // running.  Instead require a reboot first.
        //

        if (VpSystemInitialized) {

#if defined STATUS_REBOOT_REQUIRED
            return STATUS_REBOOT_REQUIRED;
#else
            return STATUS_INVALID_PARAMETER;
#endif
        }
    }

    //
    // Never do legacy detection of PnP drivers on the PCI Bus.
    //

    if (HwInitializationData->AdapterInterfaceType == PCIBus) {

        pVideoDebugPrint((Trace, "VIDEOPRT: VideoPortInitialize on PCI Bus\n"));

        if ( (PnpFlags & PNP_ENABLED) &&
             ((PnpFlags & LEGACY_DETECT) ||
              (PnpFlags & REPORT_DEVICE)) ) {

            pVideoDebugPrint((Error, "VIDEOPRT: Trying to detect PnP driver on PCI - fail\n"));
            return STATUS_INVALID_PARAMETER;
        }
    }


    //
    // Set this information for all PnP Drivers
    //
    // Special !!! - we cannot do this in the LEGACY_DETECT because the system
    // will think we failed to load and return a failure code.
    //

    if ( (PnpFlags & PNP_ENABLED) &&
         (!(PnpFlags & LEGACY_DETECT)) )
    {
        PVIDEO_PORT_DRIVER_EXTENSION DriverObjectExtension;

        pVideoDebugPrint((Info, "VIDEOPRT: We have a PnP Device.\n"));

        //
        // Fill in the new PnP entry points.
        //

        driverObject->DriverExtension->AddDevice  = VpAddDevice;
        driverObject->MajorFunction[IRP_MJ_PNP]   = pVideoPortPnpDispatch;
        driverObject->MajorFunction[IRP_MJ_POWER] = pVideoPortPowerDispatch;
        driverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = pVideoPortSystemControl;

        //
        // we'll do findadapter during the START_DEVICE irp
        //
        // Store away arguments, so we can retrieve them when we need them.
        //
        // Try to create a DriverObjectExtension
        //

        if (DriverObjectExtension = (PVIDEO_PORT_DRIVER_EXTENSION)
                      IoGetDriverObjectExtension(driverObject,
                                                 driverObject))
        {
            DriverObjectExtension->HwInitData = *HwInitializationData;
            ntStatus = STATUS_SUCCESS;
        }
        else if (NT_SUCCESS(IoAllocateDriverObjectExtension(
                                driverObject,
                                driverObject,
                                sizeof(VIDEO_PORT_DRIVER_EXTENSION),
                                &DriverObjectExtension)))
        {

            DriverObjectExtension->RegistryPath = *registryPath;
            DriverObjectExtension->RegistryPath.MaximumLength += sizeof(WCHAR);
            DriverObjectExtension->RegistryPath.Buffer =
                ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,
                                      DriverObjectExtension->RegistryPath.MaximumLength,
                                      'trpV');

            ASSERT(DriverObjectExtension->RegistryPath.Buffer);

            RtlCopyUnicodeString(&(DriverObjectExtension->RegistryPath),
                                 registryPath);

            DriverObjectExtension->HwInitData = *HwInitializationData;
            ntStatus = STATUS_SUCCESS;
        }
        else
        {
            //
            // Something went wrong.  We should have a
            // DriverObjectExtension by now.
            //

            pVideoDebugPrint((Error, "VIDEOPRT: IoAllocateDriverExtensionObject failed!\n"));

            ASSERT(FALSE);

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }


    //
    // If we are doing legacy detection or reporting, create the FDO
    // right now ...
    //

    if ((!(PnpFlags & PNP_ENABLED))  ||
         (PnpFlags & LEGACY_DETECT)  ||
         (PnpFlags & VGA_DRIVER)     ||
         (PnpFlags & REPORT_DEVICE)  ||
         (HwContext != NULL)) {

        pVideoDebugPrint((Trace, "VIDEOPRT: VideoPortInitialize on PCI Bus\n"));

        pVideoDebugPrint((Info, "Legacy FindAdapter Interface %s\n",
                          BusType[HwInitializationData->AdapterInterfaceType]));

        ntStatus = VideoPortLegacyFindAdapter(Argument1,
                                              Argument2,
                                              HwInitializationData,
                                              HwContext,
                                              PnpFlags);
    }

    return ntStatus;
}

VOID
UpdateRegValue(
    IN PUNICODE_STRING RegistryPath,
    IN PWCHAR RegValue,
    IN ULONG Value
    )

{
    PWSTR Path;

    Path = ExAllocatePoolWithTag(PagedPool,
                                 RegistryPath->Length + sizeof(UNICODE_NULL),
                                 VP_TAG);

    if (Path) {

        RtlCopyMemory(Path,
                      RegistryPath->Buffer,
                      RegistryPath->Length);

        *(Path + (RegistryPath->Length / sizeof(UNICODE_NULL))) = UNICODE_NULL;

        RtlWriteRegistryValue(
            RTL_REGISTRY_ABSOLUTE,
            Path,
            RegValue,
            REG_DWORD,
            &Value,
            sizeof(ULONG));

        ExFreePool(Path);
    }
}

ULONG
VideoPortLegacyFindAdapter(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Argument2,
    IN PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext,
    IN ULONG PnpFlags
    )

{
    ULONG busNumber = 0;
    ULONG extensionAllocationSize;
    NTSTATUS ntStatus;
    UCHAR nextMiniport;
    ULONG registryIndex = 0;


    //
    // Reset the controller number used in IoQueryDeviceDescription to zero
    // since we are restarting on a new type of bus.
    // Note: PeripheralNumber is reset only when we find a new controller.
    //

    VpQueryDeviceControllerNumber = 0xFFFFFFFF;

    //
    // Determine size of the device extension to allocate.
    //


    extensionAllocationSize = sizeof(FDO_EXTENSION) +
        sizeof(DEVICE_SPECIFIC_EXTENSION) +
        HwInitializationData->HwDeviceExtensionSize;

    //
    // Check if we are on the right Bus Adapter type.
    // If we are not, then return immediately.
    //

    ASSERT (HwInitializationData->AdapterInterfaceType < MaximumInterfaceType);

    //
    // Assume we are going to fail this the IoQueryDeviceDescription call
    // and that no device is found.
    //

    ntStatus = STATUS_NO_SUCH_DEVICE;

    pVideoDebugPrint((Trace, "Legacy FindAdapter Interface %s, Bus %d\n",
                     BusType[HwInitializationData->AdapterInterfaceType],
                     busNumber));

    while (NT_SUCCESS(IoQueryDeviceDescription(
                          &HwInitializationData->AdapterInterfaceType,
                          &busNumber,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          &VpInitializeBusCallback,
                          NULL))) {

        //
        // This is to support the multiple initialization as described by the
        // again paramter in HwFindAdapter.
        // We must repeat almost everything in this function until FALSE is
        // returned by the miniport. This is why we test for the condition at
        // the end. Freeing of data structure has to be done also since we want
        // to delete a device object for a device that did not load properly.
        //

        do {

            PDEVICE_OBJECT deviceObject = NULL;
            PDEVICE_OBJECT PnPDeviceObject = NULL;
            PFDO_EXTENSION fdoExtension;
            UNICODE_STRING tmpString;

            nextMiniport = FALSE;

            //
            // Allocate the buffer in which the miniport driver will store all the
            // configuration information.
            //

            ntStatus = VpCreateDevice(DriverObject,
                                      extensionAllocationSize,
                                      &deviceObject);

            if (!NT_SUCCESS(ntStatus)) {

                pVideoDebugPrint((Error, "VIDEOPRT: VideoPortLegacyFindAdapter: Could not create device object\n"));

                return (ULONG)ntStatus;

            }

            fdoExtension = deviceObject->DeviceExtension;
            fdoExtension->SystemIoBusNumber = busNumber;
            fdoExtension->AdapterInterfaceType =
                HwInitializationData->AdapterInterfaceType;
            fdoExtension->RegistryIndex = registryIndex;

            //
            // Initialize the remove lock.
            //

            IoInitializeRemoveLock(&fdoExtension->RemoveLock, 0, 0, 256);

            //
            // If we came through this code path, we are a legacy device
            //

            fdoExtension->Flags = PnpFlags | LEGACY_DRIVER;

            fdoExtension->VpDmaAdapterHead = NULL ;

            //
            // Make the VGA driver report resources "for detection" during
            // FindAdapter.  Later we'll remove the "LEGACY_DETECT" flag and
            // try to claim the resources for real.
            //

            if (fdoExtension->Flags & VGA_DRIVER) {
                fdoExtension->Flags |= VGA_DETECT;
            }

            ntStatus = VideoPortFindAdapter(DriverObject,
                                            Argument2,
                                            HwInitializationData,
                                            HwContext,
                                            deviceObject,
                                            &nextMiniport);

            if (fdoExtension->Flags & VGA_DRIVER) {
                fdoExtension->Flags &= ~VGA_DETECT;
            }

            pVideoDebugPrint((Info, "VIDEOPRT: Legacy VideoPortFindAdapter status = %08lx\n", ntStatus));
            pVideoDebugPrint((Info, "VIDEOPRT: Legacy VideoPortFindAdapter nextMiniport = %d\n", nextMiniport));

            if ((NT_SUCCESS(ntStatus) == FALSE) || (PnpFlags & LEGACY_DETECT))
            {
                pVideoDebugPrint((1, "Deleting Device Object.\n"));
                IoDeleteDevice(deviceObject);
            }

            if (NT_SUCCESS(ntStatus))
            {
                //
                // We use this variable to know if at least one of the tries at
                // loading the device succeded.
                //

                registryIndex++;
            }
            else
            {
                continue;
            }

            //
            // If this is the VGA driver, store this device extension for
            // us to play around with the resources later on (so we can release
            // the resources if we install a driver on the fly).
            //
            // Otherwise, determine if we want to report it to the IO system
            // so it can be used as a PNP device later on.
            // ... Never report a device found on the PCI bus.
            //

            if (PnpFlags & VGA_DRIVER)
            {
                VgaHwDeviceExtension = fdoExtension->HwDeviceExtension;

                if (NT_SUCCESS(ntStatus)) {

                    //
                    // Claim the VGA resources again without the
                    // VGA_DETECT flag.
                    //

                    VideoPortVerifyAccessRanges(VgaHwDeviceExtension,
                                                NumVgaAccessRanges,
                                                VgaAccessRanges);
                }
            }
            else if (PnpFlags & REPORT_DEVICE)
            {
                ULONG_PTR       emptyList = 0;
                BOOLEAN         conflict;
                PDEVICE_OBJECT  attachedTo;

                ASSERT (HwInitializationData->AdapterInterfaceType != PCIBus);

                //
                // Release the resource we put in the resourcemap (if any).
                //

                IoReportResourceUsage(&VideoClassName,
                                      DriverObject,
                                      NULL,
                                      0L,
                                      deviceObject,
                                      (PCM_RESOURCE_LIST) &emptyList,
                                      sizeof(ULONG_PTR),
                                      FALSE,
                                      &conflict);


                pVideoDebugPrint((Info, "VIDEOPRT: Reporting new device to the system.\n"));
                pVideoDebugPrint((Info, "VIDEOPRT: ResourceList...\n"));

                if (fdoExtension->ResourceList) {
#if DBG
                    DumpResourceList(fdoExtension->ResourceList);
#endif
                } else {

                    pVideoDebugPrint((Info, "\tnone.\n"));
                }

                ntStatus = IoReportDetectedDevice(
                               DriverObject,
                               InterfaceTypeUndefined,
                               -1,
                               -1,
                               fdoExtension->ResourceList,
                               NULL,
                               FALSE,
                               &PnPDeviceObject);

                pVideoDebugPrint((Info, "VIDEOPRT: New device reported ntStatus %08lx\n", ntStatus));

                ASSERT(NT_SUCCESS(ntStatus));

                //
                // Now we can release the memory used to hold
                // the resources pointed to by ResourceList.
                //

                if (fdoExtension->ResourceList) {
                    ExFreePool(fdoExtension->ResourceList);
                    fdoExtension->ResourceList = NULL;
                }

                attachedTo = IoAttachDeviceToDeviceStack(deviceObject,
                                                         PnPDeviceObject);

                ASSERT(attachedTo != NULL);

                fdoExtension->AttachedDeviceObject = attachedTo;
                fdoExtension->PhysicalDeviceObject = PnPDeviceObject;

                //
                // Clear the ReportDevice value in the registry so
                // that we don't try to report the device again in
                // the future.
                //

                UpdateRegValue(Argument2, L"ReportDevice", FALSE);
            }

        } while (nextMiniport);

        //
        // We finished finding all the device on the current bus
        // Go on to the next bus.
        //

        busNumber++;
    }

    //
    // If at least one device loaded, then return success, otherwise return
    // the last available error message.
    //

    if (registryIndex > 0) {

        return STATUS_SUCCESS;

    } else {

        return ((ULONG)ntStatus);

    }

}


NTSTATUS
VideoPortFindAdapter(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Argument2,
    IN PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext,
    PDEVICE_OBJECT DeviceObject,
    PUCHAR nextMiniport
    )
{
    NTSTATUS status;
    PVOID vgaDE = VgaHwDeviceExtension;
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    POWER_STATE state;

    //
    // During boot of upgrade install, only let VGA,
    // boot video drivers start.  Other types of drivers don't get
    // a chance to start until after the vga or a boot driver tries'
    // to start.
    //
    // The logic relies on the fact that today PNP drivers try to
    // start before legacy drivers (including our system vga driver).a3844
    //
    // All other drivers are disabled so we have a chance of
    // 1) booting the machine
    // 2) installing the PnP drivers
    //

    if ((VpSetupType == SETUPTYPE_UPGRADE) &&
        ((fdoExtension->Flags & (BOOT_DRIVER | VGA_DRIVER)) == 0) &&
        (VpSetupAllowDriversToStart == FALSE))
    {
        status = STATUS_NO_SUCH_DEVICE;
    }
    else
    {
        //
        // If we get here during setup we may be trying to start the
        // vga driver.  As soon as it is started we will allow othere
        // devices to start.
        //

        VpSetupAllowDriversToStart = TRUE;

        //
        // Allow PNP adapters to start so that we can enumerate their
        // children.  But don't let IRP_MJ_CREATE succeed, so GDI
        // won't try to use the device during gui mode setup.
        //

        if ((VpSetupType == SETUPTYPE_UPGRADE) &&
            (fdoExtension->Flags & PNP_ENABLED)) {

            fdoExtension->Flags |= UPGRADE_FAIL_HWINIT;
        }

        //
        // If the VGA driver has the VGA resources, unclaim them temporarily
        //

        if (vgaDE) {

            pVideoDebugPrint((Info, "VIDEOPRT: Freeing VGA resources\n"));
            VpReleaseResources(GET_FDO_EXT(vgaDE));
        }

        status = VideoPortFindAdapter2(DriverObject,
                                       Argument2,
                                       HwInitializationData,
                                       HwContext,
                                       DeviceObject,
                                       nextMiniport);

        //
        // Try to reclaim the vga ports.  FYI, may not get them
        // back if the new driver claimed them.
        //

        if (vgaDE) {

            pVideoDebugPrint((Info, "VIDEOPRT: Try to allocate back vga resources.\n"));

            if (((DeviceObject == DeviceOwningVga) && NT_SUCCESS(status)) ||
                VideoPortVerifyAccessRanges(vgaDE,
                                            NumVgaAccessRanges,
                                            VgaAccessRanges) != NO_ERROR) {
                //
                // We couldn't reclaim the vga resources, so another driver
                // must have claimed them.  Lets release our resources.
                //

                if (VgaAccessRanges) {
                    ExFreePool(VgaAccessRanges);
                }

                VgaHwDeviceExtension = NULL;
                VgaAccessRanges      = NULL;
                NumVgaAccessRanges   = 0;

                pVideoDebugPrint((Warn, "VIDEOPRT: Resource re-allocation failed.\n"));
            }
        }
    }

    if (NT_SUCCESS(status))
    {
        //
        // Initialize Power stuff.
        // Set the devices current power state.
        // NOTE - we assume the device is on at this point in time ...
        //

        fdoExtension->DevicePowerState = PowerDeviceD0;

        state.DeviceState = fdoExtension->DevicePowerState;

        state = PoSetPowerState(DeviceObject,
                            DevicePowerState,
                            state);

        //
        // Register and enable the interface
        //

        VpEnableAdapterInterface((PDEVICE_SPECIFIC_EXTENSION)
                                 (fdoExtension + 1));

        //
        // Mark this object as supporting buffered I/O so that the I/O system
        // will only supply simple buffers in IRPs.
        //
        // Set and clear the two power fields to ensure we only get called
        // as passive level to do power management operations.
        //
        // Finally, tell the system we are done with Device Initialization
        //

        DeviceObject->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;
        DeviceObject->Flags &= ~(DO_DEVICE_INITIALIZING | DO_POWER_INRUSH);

        fdoExtension->Flags |= FINDADAPTER_SUCCEEDED;

        //
        // Track the number of started devices (don't count mirroring drivers)
        //

        if (!IsMirrorDriver(fdoExtension)) {
            NumDevicesStarted++;
        }
    }

    return status;
}

NTSTATUS
VideoPortFindAdapter2(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Argument2,
    IN PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext,
    PDEVICE_OBJECT DeviceObject,
    PUCHAR nextMiniport
    )

{
    WCHAR deviceNameBuffer[STRING_LENGTH];
    POBJECT_NAME_INFORMATION deviceName;
    ULONG strLength;

    NTSTATUS ntStatus;
    WCHAR deviceSubpathBuffer[STRING_LENGTH];
    UNICODE_STRING deviceSubpathUnicodeString;
    WCHAR deviceLinkBuffer[STRING_LENGTH];
    UNICODE_STRING deviceLinkUnicodeString;
    KAFFINITY affinity;

    PVIDEO_PORT_CONFIG_INFO miniportConfigInfo = NULL;
    PDEVICE_OBJECT deviceObject;
    PFDO_EXTENSION fdoExtension;
    VP_STATUS findAdapterStatus = ERROR_DEV_NOT_EXIST;
    ULONG driverKeySize;
    PWSTR driverKeyName = NULL;
    BOOLEAN symbolicLinkCreated = FALSE;
    ULONG MaxObjectNumber;

    PDEVICE_OBJECT pdo;
    BOOLEAN ChildObject=FALSE;

    PDEVICE_SPECIFIC_EXTENSION DoSpecificExtension;

    ntStatus = STATUS_NO_SUCH_DEVICE;

    deviceObject = DeviceObject;
    fdoExtension = deviceObject->DeviceExtension;
    DoSpecificExtension = (PVOID)(fdoExtension + 1);

    pdo = fdoExtension->PhysicalDeviceObject;

    deviceName = (POBJECT_NAME_INFORMATION) deviceNameBuffer;

    ObQueryNameString(deviceObject,
                      deviceName,
                      STRING_LENGTH * sizeof(WCHAR),
                      &strLength);

    //
    // Allocate the buffer in which the miniport driver will store all the
    // configuration information.
    //

    miniportConfigInfo = (PVIDEO_PORT_CONFIG_INFO)
                             ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,
                                                   sizeof(VIDEO_PORT_CONFIG_INFO),
                                                   VP_TAG);

    if (miniportConfigInfo == NULL) {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto EndOfInitialization;
    }

    RtlZeroMemory((PVOID) miniportConfigInfo,
                  sizeof(VIDEO_PORT_CONFIG_INFO));

    miniportConfigInfo->Length = sizeof(VIDEO_PORT_CONFIG_INFO);

    //
    // Put in the BusType specified within the HW_INITIALIZATION_DATA
    // structure by the miniport and the bus number inthe miniport config info.
    //

    miniportConfigInfo->SystemIoBusNumber = fdoExtension->SystemIoBusNumber;
    miniportConfigInfo->AdapterInterfaceType = fdoExtension->AdapterInterfaceType;

    //
    // Initialize the pointer to VpGetProcAddress.
    //

    miniportConfigInfo->VideoPortGetProcAddress = VpGetProcAddress;

    //
    // Initialize the type of interrupt based on the bus type.
    //

    switch (miniportConfigInfo->AdapterInterfaceType) {

    case Internal:
    case MicroChannel:
    case PCIBus:

        miniportConfigInfo->InterruptMode = LevelSensitive;
        break;

    default:

        miniportConfigInfo->InterruptMode = Latched;
        break;

    }

    //
    // Set up device extension pointers and sizes
    //

    fdoExtension->HwDeviceExtension = (PVOID)((ULONG_PTR)(fdoExtension) +
        sizeof(FDO_EXTENSION) + sizeof(DEVICE_SPECIFIC_EXTENSION));
    fdoExtension->HwDeviceExtensionSize =
        HwInitializationData->HwDeviceExtensionSize;
    fdoExtension->MiniportConfigInfo = miniportConfigInfo;

    //
    // Save the dependent driver routines in the device extension.
    //

    fdoExtension->HwFindAdapter = HwInitializationData->HwFindAdapter;
    fdoExtension->HwInitialize = HwInitializationData->HwInitialize;
    fdoExtension->HwInterrupt = HwInitializationData->HwInterrupt;
    fdoExtension->HwStartIO = HwInitializationData->HwStartIO;

    if (HwInitializationData->HwInitDataSize >
        FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwLegacyResourceCount)) {

        fdoExtension->HwLegacyResourceList = HwInitializationData->HwLegacyResourceList;
        fdoExtension->HwLegacyResourceCount = HwInitializationData->HwLegacyResourceCount;
    }

    if (HwInitializationData->HwInitDataSize >
        FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, AllowEarlyEnumeration)) {

        fdoExtension->AllowEarlyEnumeration = HwInitializationData->AllowEarlyEnumeration;
    }

    //
    // Create the name we will be storing in the \DeviceMap.
    // This name is a PWSTR, not a unicode string
    // This is the name of the driver with an appended device number
    //

    if (!NT_SUCCESS(pVideoPortCreateDeviceName(L"\\Device",
                                               HwInitializationData->StartingDeviceNumber,
                                               &deviceSubpathUnicodeString,
                                               deviceSubpathBuffer))) {

        pVideoDebugPrint((Error, "VIDEOPRT: VideoPortFindAdapter: Could not create device subpath number\n"));
        goto EndOfInitialization;

    }

    DoSpecificExtension->DriverOldRegistryPathLength =
        ((PUNICODE_STRING)Argument2)->Length +
        deviceSubpathUnicodeString.Length;

    driverKeySize =
        DoSpecificExtension->DriverOldRegistryPathLength +
        2 * sizeof(UNICODE_NULL);

    if ( (driverKeyName = (PWSTR) ExAllocatePoolWithTag(PagedPool,
                                                        driverKeySize,
                                                        VP_TAG) ) == NULL) {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto EndOfInitialization;
    }

    RtlMoveMemory(driverKeyName,
                  ((PUNICODE_STRING)Argument2)->Buffer,
                  ((PUNICODE_STRING)Argument2)->Length);

    RtlMoveMemory((PWSTR)( (ULONG_PTR)driverKeyName +
                           ((PUNICODE_STRING)Argument2)->Length ),
                  deviceSubpathBuffer,
                  deviceSubpathUnicodeString.Length);

    //
    // Put two NULLs at the end so we can play around with the string later.
    //

    *((PWSTR) ((ULONG_PTR)driverKeyName +
        DoSpecificExtension->DriverOldRegistryPathLength))
        = UNICODE_NULL;
    *((PWSTR) ((ULONG_PTR)driverKeyName +
        DoSpecificExtension->DriverOldRegistryPathLength
        + sizeof(UNICODE_NULL))) = UNICODE_NULL;

    //
    // There is a bug in Lotus Screen Cam where it will only work if our
    // reg path is \REGISTRY\Machine\System not \REGISTRY\MACHINE\SYSTEM.
    // so replace the appropriate strings.
    //

    if (wcsstr(driverKeyName, L"MACHINE")) {
        wcsncpy(wcsstr(driverKeyName, L"MACHINE"), L"Machine", sizeof("Machine")-1);
    }

    if (wcsstr(driverKeyName, L"SYSTEM")) {
        wcsncpy(wcsstr(driverKeyName, L"SYSTEM"), L"System", sizeof("System")-1);
    }

    //
    // Store the old key
    //

    DoSpecificExtension->DriverOldRegistryPath = driverKeyName;
    
    //
    // Store the new key
    // If this is not a Whistler driver, then use the old key.
    //

    if (EnableNewRegistryKey) {

#if _X86_
        if (HwInitializationData->HwInitDataSize > SIZE_OF_W2K_VIDEO_HW_INITIALIZATION_DATA) 
#endif // _X86_

            VpEnableNewRegistryKey(fdoExtension, 
                                   DoSpecificExtension,
                                   (PUNICODE_STRING)Argument2,
                                   fdoExtension->RegistryIndex);
    }

    //
    // Store the path name of the location of the driver in the registry.
    //

    if (DoSpecificExtension->DriverNewRegistryPath != NULL) {
        
        DoSpecificExtension->DriverRegistryPath = 
            DoSpecificExtension->DriverNewRegistryPath;
        DoSpecificExtension->DriverRegistryPathLength = 
            DoSpecificExtension->DriverNewRegistryPathLength;
    
    } else {

        DoSpecificExtension->DriverRegistryPath = 
            DoSpecificExtension->DriverOldRegistryPath;
        DoSpecificExtension->DriverRegistryPathLength = 
            DoSpecificExtension->DriverOldRegistryPathLength;
    }

    miniportConfigInfo->DriverRegistryPath = DoSpecificExtension->DriverRegistryPath;

    //
    // Let the driver know how much system memory is present.
    //

    miniportConfigInfo->SystemMemorySize = VpSystemMemorySize;

    //
    // Initialize the DPC object used for error logging.
    //

    KeInitializeDpc(&fdoExtension->ErrorLogDpc,
                    pVideoPortLogErrorEntryDPC,
                    deviceObject);

    //
    // If the machine is using a Intel 450NX PCIset with a
    // 82451NX Memory & I/O Controller (MIOC) then we must
    // disable write combining to work around a bug in the
    // chipset.
    //
    // We also want to disable USWC on the Compaq fiat
    // chipset.
    //

    if (EnableUSWC) {

        if ((VideoPortCheckForDeviceExistence(fdoExtension->HwDeviceExtension, 0x8086, 0x84CA, 0, 0, 0, 0)) ||
            (VideoPortCheckForDeviceExistence(fdoExtension->HwDeviceExtension, 0x0E11, 0x6010, 0, 0, 0, 0)) ||
            (VideoPortCheckForDeviceExistence(fdoExtension->HwDeviceExtension, 0x1166, 0x0009, 0, 0, 0, 0))) {

            pVideoDebugPrint((Warn, "VIDEOPRT: USWC disabled due to to MIOC bug.\n"));
            EnableUSWC = FALSE;
        }

        //
        // Disable USWC on HPs 6 way box.
        //

        if (VideoPortCheckForDeviceExistence(fdoExtension->HwDeviceExtension, 0x1166, 0x0008, 0, 0, 0, 0) &&
            (VideoPortCheckForDeviceExistence(fdoExtension->HwDeviceExtension, 0x103C, 0x1219, 0, 0, 0, 0) ||
             VideoPortCheckForDeviceExistence(fdoExtension->HwDeviceExtension, 0x103C, 0x121A, 0, 0, 0, 0))) {

            pVideoDebugPrint((Warn, "USWC disabled due to to RCC USWC bug on HP 6-way system.\n"));
            EnableUSWC = FALSE;
        }
    }

    //
    // Turn on the debug level based on the miniport driver entry
    //

    VideoPortGetRegistryParameters(fdoExtension->HwDeviceExtension,
                                   L"VideoDebugLevel",
                                   FALSE,
                                   VpRegistryCallback,
                                   &VideoDebugLevel);

    if (VpAllowFindAdapter(fdoExtension)) {

        ACQUIRE_DEVICE_LOCK(fdoExtension);

        //
        // Notify the boot driver that we will be accessing the display
        // hardware.
        //

        VpEnableDisplay(fdoExtension, FALSE);

        findAdapterStatus =
            fdoExtension->HwFindAdapter(fdoExtension->HwDeviceExtension,
                                        HwContext,
                                        NULL,
                                        miniportConfigInfo,
                                        nextMiniport);

        VpEnableDisplay(fdoExtension, TRUE);

        RELEASE_DEVICE_LOCK(fdoExtension);
    }

    //
    // If the adapter is not found, display an error.
    //

    if (findAdapterStatus != NO_ERROR) {

        pVideoDebugPrint((Warn, "VIDEOPRT: VideoPortFindAdapter: Find adapter failed\n"));

        ntStatus = STATUS_UNSUCCESSFUL;
        goto EndOfInitialization;

    }

    //
    // Store the emulator data in the device extension so we can use it
    // later.
    //

    fdoExtension->NumEmulatorAccessEntries =
        miniportConfigInfo->NumEmulatorAccessEntries;

    fdoExtension->EmulatorAccessEntries =
        miniportConfigInfo->EmulatorAccessEntries;

    fdoExtension->EmulatorAccessEntriesContext =
        miniportConfigInfo->EmulatorAccessEntriesContext;

    fdoExtension->VdmPhysicalVideoMemoryAddress =
        miniportConfigInfo->VdmPhysicalVideoMemoryAddress;

    fdoExtension->VdmPhysicalVideoMemoryLength =
        miniportConfigInfo->VdmPhysicalVideoMemoryLength;

    //
    // Store the required information in the device extension for later use.
    //

    fdoExtension->HardwareStateSize =
        miniportConfigInfo->HardwareStateSize;

    //
    // If the device supplies an interrupt service routine, we must
    // set up all the structures to support interrupts. Otherwise,
    // they can be ignored.
    //

    if (fdoExtension->HwInterrupt) {

        if ((miniportConfigInfo->BusInterruptLevel != 0) ||
            (miniportConfigInfo->BusInterruptVector != 0)) {

#if defined(NO_LEGACY_DRIVERS)

            affinity = fdoExtension->InterruptAffinity;

#else
            if (fdoExtension->Flags & LEGACY_DRIVER) {

                //
                // Note: the spinlock for the interrupt object is created
                // internally by the IoConnectInterrupt() call. It is also
                // used internally by KeSynchronizeExecution.
                //

                fdoExtension->InterruptVector =
                    HalGetInterruptVector(fdoExtension->AdapterInterfaceType,
                                          fdoExtension->SystemIoBusNumber,
                                          miniportConfigInfo->BusInterruptLevel,
                                          miniportConfigInfo->BusInterruptVector,
                                          &fdoExtension->InterruptIrql,
                                          &affinity);

            } else {

                affinity = fdoExtension->InterruptAffinity;

            }

#endif

            fdoExtension->InterruptMode = miniportConfigInfo->InterruptMode;

            fdoExtension->InterruptsEnabled = TRUE;

            ntStatus = IoConnectInterrupt(&fdoExtension->InterruptObject,
                                          (PKSERVICE_ROUTINE) pVideoPortInterrupt,
                                          deviceObject,
                                          NULL,
                                          fdoExtension->InterruptVector,
                                          fdoExtension->InterruptIrql,
                                          fdoExtension->InterruptIrql,
                                          fdoExtension->InterruptMode,
                                          (BOOLEAN) ((miniportConfigInfo->InterruptMode ==
                                              LevelSensitive) ? TRUE : FALSE),
                                          affinity,
                                          FALSE);

            if (!NT_SUCCESS(ntStatus)) {

                pVideoDebugPrint((Error, "VIDEOPRT: VideoPortFindAdapter: Can't connect interrupt\n"));
                goto EndOfInitialization;
            }

        } else {

            pVideoDebugPrint((Warn, "VIDEOPRT: Warning: No interrupt resources assigned to this device.\n"));
        }

    } else {

        fdoExtension->HwInterrupt = NULL;

    }

    //
    // Initialize DPC Support
    //

    KeInitializeDpc(&fdoExtension->Dpc,
                    pVideoPortDpcDispatcher,
                    fdoExtension->HwDeviceExtension);

    //
    // DMA support
    //

    if (HwInitializationData->HwInitDataSize >
        FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwStartDma)) {

        fdoExtension->HwStartDma          = HwInitializationData->HwStartDma;

        //
        // Determine if a Dma Adapter must be allocated.
        //

        if (fdoExtension->DmaAdapterObject == NULL &&
            (miniportConfigInfo->Master ||
             miniportConfigInfo->DmaChannel != 0)) {

            DEVICE_DESCRIPTION      deviceDescription;
            ULONG                   numberOfMapRegisters;

            //
            // Get the adapter object for this card.
            //

            RtlZeroMemory(&deviceDescription, sizeof(deviceDescription));
            deviceDescription.Version         = DEVICE_DESCRIPTION_VERSION;
            deviceDescription.DmaChannel      = miniportConfigInfo->DmaChannel;
            deviceDescription.BusNumber       = miniportConfigInfo->SystemIoBusNumber;
            deviceDescription.DmaWidth        = miniportConfigInfo->DmaWidth;
            deviceDescription.DmaSpeed        = miniportConfigInfo->DmaSpeed;
            deviceDescription.ScatterGather   = miniportConfigInfo->ScatterGather;
            deviceDescription.Master          = miniportConfigInfo->Master;
            deviceDescription.DmaPort         = miniportConfigInfo->DmaPort;
            deviceDescription.AutoInitialize  = FALSE;
            deviceDescription.DemandMode      = miniportConfigInfo->DemandMode;
            deviceDescription.MaximumLength   = miniportConfigInfo->MaximumTransferLength;
            deviceDescription.InterfaceType   = fdoExtension->AdapterInterfaceType;

            fdoExtension->DmaAdapterObject    =

            IoGetDmaAdapter(fdoExtension->PhysicalDeviceObject,
                            &deviceDescription,
                            &numberOfMapRegisters);

            ASSERT(fdoExtension->DmaAdapterObject);

        }

    }   // end if HW_DATA_SIZE > ... HWStartDma

    //
    // New, Optional.
    // Setup the timer if it is specified by a driver.
    //

    if (HwInitializationData->HwInitDataSize >
        FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwTimer)){

        fdoExtension->HwTimer = HwInitializationData->HwTimer;

        if (fdoExtension->HwTimer) {
            ntStatus = IoInitializeTimer(deviceObject,
                                         pVideoPortHwTimer,
                                         NULL);

            //
            // If we fail forget about the timer !
            //

            if (!NT_SUCCESS(ntStatus)) {

                ASSERT(FALSE);
                fdoExtension->HwTimer = NULL;

            }
        }
    }

    //
    // New, Optional.
    // Reset Hw function.
    //

    if (HwInitializationData->HwInitDataSize >
        FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwResetHw)) {

        ULONG iReset;

        for (iReset=0; iReset<6; iReset++) {

            if (HwResetHw[iReset].ResetFunction == NULL) {

                HwResetHw[iReset].ResetFunction = HwInitializationData->HwResetHw;
                HwResetHw[iReset].HwDeviceExtension = fdoExtension->HwDeviceExtension;

                break;
            }
        }
    }

    //
    // The FdoList is for debugging purpose
    //

    {
        ULONG i;

        for(i = 0; i < 8; i++) {

            if(FdoList[i] == NULL) {
                FdoList[i] = fdoExtension;
                break;
            }
        }
    }

    fdoExtension->NextFdoExtension = FdoHead;
    FdoHead = fdoExtension;

    //
    // NOTE:
    //
    // We only want to reinitialize the device once the Boot sequence has
    // been completed and the HAL does not need to access the device again.
    // So the initialization entry point will be called when the device is
    // opened.
    //


    if (!NT_SUCCESS(pVideoPortCreateDeviceName(L"\\DosDevices\\DISPLAY",
                                               DoSpecificExtension->DeviceNumber + 1,
                                               &deviceLinkUnicodeString,
                                               deviceLinkBuffer))) {

        pVideoDebugPrint((Error, "VIDEOPRT: VideoPortFindAdapter: Could not create device subpath number\n"));
        goto EndOfInitialization;

    }

    ntStatus = IoCreateSymbolicLink(&deviceLinkUnicodeString,
                                    &deviceName->Name);


    if (!NT_SUCCESS(ntStatus)) {

        pVideoDebugPrint((Error, "VIDEOPRT: VideoPortFindAdapter: SymbolicLink Creation failed\n"));
        goto EndOfInitialization;

    }

    symbolicLinkCreated = TRUE;


    //
    // Once initialization is finished, load the required information in the
    // registry so that the appropriate display drivers can be loaded.
    //

    ntStatus = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP,
                                     VideoClassString,
                                     deviceName->Name.Buffer,
                                     REG_SZ,
                                     DoSpecificExtension->DriverRegistryPath,
                                     DoSpecificExtension->DriverRegistryPathLength +
                                        sizeof(UNICODE_NULL));

    if (!NT_SUCCESS(ntStatus)) {

        pVideoDebugPrint((Error, "VIDEOPRT: VideoPortFindAdapter: Could not store name in DeviceMap\n"));

    }

    if (fdoExtension->Flags & LEGACY_DRIVER) {

        //
        // If we successfully found a legacy driver, increment the
        // global device number.
        //

        VideoDeviceNumber++;
    }

    //
    // Tell win32k how many objects to try to open
    //

    MaxObjectNumber = VideoDeviceNumber - 1;

    ntStatus = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP,
                                     VideoClassString,
                                     L"MaxObjectNumber",
                                     REG_DWORD,
                                     &MaxObjectNumber,
                                     sizeof(ULONG));

    if (!NT_SUCCESS(ntStatus)) {

        pVideoDebugPrint((Error, "VIDEOPRT: VideoPortFindAdapter: Could not store name in DeviceMap\n"));

    } else {

        pVideoDebugPrint((Info, "VIDEOPRT: VideoPortFindAdapter: %d is stored in MaxObjectNumber of DeviceMap\n",
                             MaxObjectNumber));
    }

    //
    // Save the function pointers to the new 5.0 miniport driver callbacks.
    //

    if (HwInitializationData->HwInitDataSize >
        FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwQueryInterface)) {

        fdoExtension->HwSetPowerState  = HwInitializationData->HwSetPowerState;
        fdoExtension->HwGetPowerState  = HwInitializationData->HwGetPowerState;
        fdoExtension->HwQueryInterface = HwInitializationData->HwQueryInterface;

        if (!ChildObject)
        {
            fdoExtension->HwGetVideoChildDescriptor = HwInitializationData->HwGetVideoChildDescriptor;
        }
    }

    //
    // Check if the minitor should always be D0 or D3
    //
    {
    ULONG OverrideMonitorPower = 0;
    VideoPortGetRegistryParameters(fdoExtension->HwDeviceExtension,
                                   L"OverrideMonitorPower",
                                   FALSE,
                                   VpRegistryCallback,
                                   &OverrideMonitorPower);
    fdoExtension->OverrideMonitorPower = (OverrideMonitorPower != 0);
    }

EndOfInitialization:

    //
    // If we are doing detection, then don't save all of these objects.
    // We just want to see if the driver would load or not
    //

    if ( (fdoExtension->Flags & LEGACY_DETECT) ||
         (!NT_SUCCESS(ntStatus)) )
    {

        //
        // Free the miniport config info buffer.
        //

        if (miniportConfigInfo) {
            ExFreePool(miniportConfigInfo);
        }

        //
        // Free the rom image if we grabbed one.
        //

        if (fdoExtension->RomImage) {
            ExFreePool(fdoExtension->RomImage);
            fdoExtension->RomImage = NULL;
        }

        //
        // Release the resource we put in the resourcemap (if any).
        //

        if ((fdoExtension->Flags & LEGACY_DETECT) ||
            (findAdapterStatus != NO_ERROR)) {

            ULONG_PTR emptyList = 0;
            BOOLEAN conflict;

            IoReportResourceUsage(&VideoClassName,
                                  DriverObject,
                                  NULL,
                                  0L,
                                  deviceObject,
                                  (PCM_RESOURCE_LIST) &emptyList, // an empty resource list
                                  sizeof(ULONG_PTR),
                                  FALSE,
                                  &conflict);

        }

        //
        // These are the things we want to delete if they were created and
        // the initialization *FAILED* at a later time.
        //

        if (fdoExtension->InterruptObject) {
            IoDisconnectInterrupt(fdoExtension->InterruptObject);
        }

        if (driverKeyName) {

            ExFreePool(driverKeyName);
            DoSpecificExtension->DriverOldRegistryPath = NULL;
        }

        if (DoSpecificExtension->DriverNewRegistryPath) {
            
            ExFreePool(DoSpecificExtension->DriverNewRegistryPath);
            DoSpecificExtension->DriverNewRegistryPath = NULL;
        }

        DoSpecificExtension->DriverRegistryPath = NULL;

        if (symbolicLinkCreated) {
            IoDeleteSymbolicLink(&deviceLinkUnicodeString);
        }

        //
        // Free up any memory mapped in by the miniport using
        // VideoPort GetDeviceBase.
        //

        while (fdoExtension->MappedAddressList != NULL)
        {
            pVideoDebugPrint((Warn, "VIDEOPRT: VideoPortFindAdapter: unfreed address %08lx, physical %08lx, size %08lx\n",
                              fdoExtension->MappedAddressList->MappedAddress,
                              fdoExtension->MappedAddressList->PhysicalAddress.LowPart,
                              fdoExtension->MappedAddressList->NumberOfUchars));

            pVideoDebugPrint((Warn, "VIDEOPRT: VideoPortFindAdapter: unfreed refcount %d, unmapping %d\n\n",
                              fdoExtension->MappedAddressList->RefCount,
                              fdoExtension->MappedAddressList->bNeedsUnmapping));

            VideoPortFreeDeviceBase(fdoExtension->HwDeviceExtension,
                                    fdoExtension->MappedAddressList->MappedAddress);
        }

        //
        // Remove any HwResetHw function we may have added for this device.
        //

        if (HwInitializationData->HwInitDataSize >
            FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwResetHw)) {

            ULONG iReset;

            for (iReset=0; iReset<6; iReset++) {

                if (HwResetHw[iReset].HwDeviceExtension ==
                    fdoExtension->HwDeviceExtension) {

                    HwResetHw[iReset].ResetFunction = NULL;
                    break;
                }
            }
        }

    } else {

        HwInitializationData->StartingDeviceNumber++;

    }

    return ntStatus;
}


BOOLEAN
pVideoPortInterrupt(
    IN PKINTERRUPT Interrupt,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This function is the main interrupt service routine. If finds which
    miniport driver the interrupt was for and forwards it.

Arguments:

    Interrupt -

    DeviceObject -

Return Value:

    Returns TRUE if the interrupt was expected.

--*/

{
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    BOOLEAN bRet;

    UNREFERENCED_PARAMETER(Interrupt);

    //
    // If there is no interrupt routine, fail the assertion
    //

    ASSERT (fdoExtension->HwInterrupt);

    if (fdoExtension->InterruptsEnabled) {
        bRet = fdoExtension->HwInterrupt(fdoExtension->HwDeviceExtension);
    } else {
        bRet = FALSE;  // this device did not handle the interrupt
    }

    return bRet;

} // pVideoPortInterrupt()


VOID
VideoPortLogError(
    IN PVOID HwDeviceExtension,
    IN PVIDEO_REQUEST_PACKET Vrp OPTIONAL,
    IN VP_STATUS ErrorCode,
    IN ULONG UniqueId
    )

/*++

Routine Description:

    This routine saves the error log information so it can be processed at
    any IRQL.

Arguments:

    HwDeviceExtension - Supplies the HBA miniport driver's adapter data storage.

    Vrp - Supplies an optional pointer to a video request packet if there is
        one.

    ErrorCode - Supplies an error code indicating the type of error.

    UniqueId - Supplies a unique identifier for the error.

Return Value:

    None.

--*/

{
    VP_ERROR_LOG_ENTRY errorLogEntry;

    //
    // Save the information in a local errorLogEntry structure.
    //

    errorLogEntry.DeviceExtension = GET_FDO_EXT(HwDeviceExtension);

    if (Vrp != NULL) {

        errorLogEntry.IoControlCode = Vrp->IoControlCode;

    } else {

        errorLogEntry.IoControlCode = 0;

    }

    errorLogEntry.ErrorCode = ErrorCode;
    errorLogEntry.UniqueId = UniqueId;


    //
    // Call the sync routine so we are synchronized when writting in
    // the device extension.
    //

    pVideoPortSynchronizeExecution(HwDeviceExtension,
                                   VpMediumPriority,
                                   pVideoPortLogErrorEntry,
                                   &errorLogEntry);

    return;

} // end VideoPortLogError()



BOOLEAN
pVideoPortLogErrorEntry(
    IN PVOID Context
    )

/*++

Routine Description:

    This function is the synchronized LogError functions.

Arguments:

    Context - Context value used here as the VP_ERROR_LOG_ENTRY for this
        particular error

Return Value:

    None.

--*/
{
    PVP_ERROR_LOG_ENTRY logEntry = Context;
    PFDO_EXTENSION fdoExtension = logEntry->DeviceExtension;

    //
    // If the error log entry is already full, then dump the error.
    //

    if (fdoExtension->InterruptFlags & VP_ERROR_LOGGED) {

        pVideoDebugPrint((Trace, "VIDEOPRT: VideoPortLogError: Dumping video error log packet.\n"));
        pVideoDebugPrint((Info, "\tControlCode = %x, ErrorCode = %x, UniqueId = %x.\n",
                         logEntry->IoControlCode, logEntry->ErrorCode,
                         logEntry->UniqueId));

        return TRUE;
    }

    //
    // Indicate that the error log entry is in use.
    //

    fdoExtension->InterruptFlags |= VP_ERROR_LOGGED;

    fdoExtension->ErrorLogEntry = *logEntry;

    //
    // Now queue a DPC so we can process the error.
    //

    KeInsertQueueDpc(&fdoExtension->ErrorLogDpc,
                     NULL,
                     NULL);

    return TRUE;

} // end pVideoPortLogErrorEntry();



VOID
pVideoPortLogErrorEntryDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.

Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext - Context parameter that was passed to the DPC
        initialization routine. It contains a pointer to the deviceObject.

    SystemArgument1 - Unused.

    SystemArgument2 - Unused.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT DeviceObject = DeferredContext;
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;

    PIO_ERROR_LOG_PACKET errorLogPacket;

    errorLogPacket = (PIO_ERROR_LOG_PACKET)
        IoAllocateErrorLogEntry(DeviceObject,
                                sizeof(IO_ERROR_LOG_PACKET) + sizeof(ULONG));

    if (errorLogPacket != NULL) {

        errorLogPacket->MajorFunctionCode = IRP_MJ_DEVICE_CONTROL;
        errorLogPacket->RetryCount = 0;
        errorLogPacket->NumberOfStrings = 0;
        errorLogPacket->StringOffset = 0;
        errorLogPacket->EventCategory = 0;

        //
        // Translate the miniport error code into the NT I\O driver.
        //

        switch (fdoExtension->ErrorLogEntry.ErrorCode) {

        case ERROR_INVALID_FUNCTION:
        case ERROR_INVALID_PARAMETER:

            errorLogPacket->ErrorCode = IO_ERR_INVALID_REQUEST;
            break;

        case ERROR_NOT_ENOUGH_MEMORY:
        case ERROR_INSUFFICIENT_BUFFER:

            errorLogPacket->ErrorCode = IO_ERR_INSUFFICIENT_RESOURCES;
            break;

        case ERROR_DEV_NOT_EXIST:

            errorLogPacket->ErrorCode = IO_ERR_CONFIGURATION_ERROR;
            break;

        case ERROR_IO_PENDING:
            ASSERT(FALSE);

        case ERROR_MORE_DATA:
        case NO_ERROR:

            errorLogPacket->ErrorCode = 0;
            break;

        //
        // If it is another error code, than assume it is private to the
        // driver and just pass as-is.
        //

        default:

            errorLogPacket->ErrorCode =
                fdoExtension->ErrorLogEntry.ErrorCode;
            break;

        }

        errorLogPacket->UniqueErrorValue =
                                fdoExtension->ErrorLogEntry.UniqueId;
        errorLogPacket->FinalStatus = STATUS_SUCCESS;
        errorLogPacket->SequenceNumber = 0;
        errorLogPacket->IoControlCode =
                                fdoExtension->ErrorLogEntry.IoControlCode;
        errorLogPacket->DumpDataSize = sizeof(ULONG);
        errorLogPacket->DumpData[0] =
                                fdoExtension->ErrorLogEntry.ErrorCode;

        IoWriteErrorLogEntry(errorLogPacket);

    }

    fdoExtension->InterruptFlags &= ~VP_ERROR_LOGGED;

} // end pVideoPortLogErrorEntry();



VOID
pVideoPortMapToNtStatus(
    IN PSTATUS_BLOCK StatusBlock
    )

/*++

Routine Description:

    This function maps a Win32 error code to an NT error code, making sure
    the inverse translation will map back to the original status code.

Arguments:

    StatusBlock - Pointer to the status block

Return Value:

    None.

--*/

{
    PNTSTATUS status = &StatusBlock->Status;

    switch (*status) {

    case ERROR_INVALID_FUNCTION:
        *status = STATUS_NOT_IMPLEMENTED;
        break;

    case ERROR_NOT_ENOUGH_MEMORY:
        *status = STATUS_INSUFFICIENT_RESOURCES;
        break;

    case ERROR_INVALID_PARAMETER:
        *status = STATUS_INVALID_PARAMETER;
        break;

    case ERROR_INSUFFICIENT_BUFFER:
        *status = STATUS_BUFFER_TOO_SMALL;

        //
        // Make sure we zero out the information block if we get an
        // insufficient buffer.
        //

        StatusBlock->Information = 0;
        break;

    case ERROR_MORE_DATA:
        *status = STATUS_BUFFER_OVERFLOW;
        break;

    case ERROR_DEV_NOT_EXIST:
        *status = STATUS_DEVICE_DOES_NOT_EXIST;
        break;

    case ERROR_IO_PENDING:
        ASSERT(FALSE);
        // Fall through.

    case NO_ERROR:
        *status = STATUS_SUCCESS;
        break;

    default:

        pVideoDebugPrint((Error, "VIDEOPRT: Invalid return value from HwStartIo!\n"));
        ASSERT(FALSE);

        //
        // Since the driver did not see fit to follow the
        // rules about returning correct error codes. Videoprt will do it for
        // them.
        //

        *status = STATUS_UNSUCCESSFUL;

        break;

    }

    return;

} // end pVideoPortMapToNtStatus()


NTSTATUS
pVideoPortMapUserPhysicalMem(
    IN PFDO_EXTENSION FdoExtension,
    IN HANDLE ProcessHandle OPTIONAL,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN OUT PULONG Length,
    IN OUT PULONG InIoSpace,
    IN OUT PVOID *VirtualAddress
    )

/*++

Routine Description:

    This function maps a view of a block of physical memory into a process'
    virtual address space.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ProcessHandle - Optional handle to the process into which the memory must
        be mapped.

    PhysicalAddress - Offset from the beginning of physical memory, in bytes.

    Length - Pointer to a variable that will receive that actual size in
        bytes of the view. The length is rounded to a page boundary. THe
        length may not be zero.

    InIoSpace - Specifies if the address is in the IO space if TRUE; otherwise,
        the address is assumed to be in memory space.

    VirtualAddress - Pointer to a variable that will receive the base
        address of the view. If the initial value is not NULL, then the view
        will be allocated starting at teh specified virtual address rounded
        down to the next 64kb addess boundary.

Return Value:

    STATUS_UNSUCCESSFUL if the length was zero.
    STATUS_SUCCESS otherwise.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    NTSTATUS ntStatus;
    HANDLE physicalMemoryHandle;
    PHYSICAL_ADDRESS physicalAddressBase;
    PHYSICAL_ADDRESS physicalAddressEnd;
    PHYSICAL_ADDRESS viewBase;
    PHYSICAL_ADDRESS mappedLength;
    HANDLE processHandle;
    BOOLEAN translateBaseAddress;
    BOOLEAN translateEndAddress;
    ULONG inIoSpace2;
    ULONG inIoSpace1;
    ULONG MapViewFlags;

    //
    // Check for a length of zero. If it is, the entire physical memory
    // would be mapped into the process' address space. An error is returned
    // in this case.
    //

    if (!*Length) {

        return STATUS_INVALID_PARAMETER_4;

    }

    if (!(*InIoSpace & VIDEO_MEMORY_SPACE_USER_MODE)) {

        return STATUS_INVALID_PARAMETER_5;

    }

    //
    // Get a handle to the physical memory section using our pointer.
    // If this fails, return.
    //

    ntStatus = ObOpenObjectByPointer(PhysicalMemorySection,
                                     0L,
                                     (PACCESS_STATE) NULL,
                                     SECTION_ALL_ACCESS,
                                     (POBJECT_TYPE) NULL,
                                     KernelMode,
                                     &physicalMemoryHandle);

    if (!NT_SUCCESS(ntStatus)) {

        return ntStatus;

    }

    //
    // No flags are used in translation
    //

    inIoSpace1 = *InIoSpace & VIDEO_MEMORY_SPACE_IO;
    inIoSpace2 = *InIoSpace & VIDEO_MEMORY_SPACE_IO;

    //
    // Initialize the physical addresses that will be translated
    //

    physicalAddressEnd.QuadPart = PhysicalAddress.QuadPart + (*Length - 1);

    //
    // Translate the physical addresses.
    //

    translateBaseAddress =
        VpTranslateBusAddress(FdoExtension,
                              &PhysicalAddress,
                              &inIoSpace1,
                              &physicalAddressBase);

    translateEndAddress =
        VpTranslateBusAddress(FdoExtension,
                              &physicalAddressEnd,
                              &inIoSpace2,
                              &physicalAddressEnd);

    if ( !(translateBaseAddress && translateEndAddress) ) {

        ZwClose(physicalMemoryHandle);

        return STATUS_DEVICE_CONFIGURATION_ERROR;

    }

    ASSERT(inIoSpace1 == inIoSpace2);

    //
    // Calcualte the length of the memory to be mapped
    //

    mappedLength.QuadPart = physicalAddressEnd.QuadPart -
                            physicalAddressBase.QuadPart + 1;

    //
    // If the mappedlength is zero, somthing very weird happened in the HAL
    // since the Length was checked against zero.
    //

    ASSERT (mappedLength.QuadPart != 0);

    //
    // If the address is in io space, just return the address, otherwise
    // go through the mapping mechanism
    //

    if ( (*InIoSpace) & (ULONG)0x01 ) {

        (ULONG_PTR) *VirtualAddress = (ULONG_PTR) physicalAddressBase.QuadPart;

    } else {


        //
        // If no process handle was passed, get the handle to the current
        // process.
        //

        if (ProcessHandle) {

            processHandle = ProcessHandle;

        } else {

            processHandle = NtCurrentProcess();

        }

        //
        // initialize view base that will receive the physical mapped
        // address after the MapViewOfSection call.
        //

        viewBase = physicalAddressBase;

        //
        // Map the section
        //

        if ((*InIoSpace) & VIDEO_MEMORY_SPACE_P6CACHE) {
            MapViewFlags = PAGE_READWRITE | PAGE_WRITECOMBINE;
        } else {
            MapViewFlags = PAGE_READWRITE | PAGE_NOCACHE;
        }

        ntStatus = ZwMapViewOfSection(physicalMemoryHandle,
                                      processHandle,
                                      VirtualAddress,
                                      0L,
                                      (ULONG_PTR) mappedLength.QuadPart,
                                      &viewBase,
                                      (PULONG_PTR) (&(mappedLength.QuadPart)),
                                      ViewUnmap,
                                      0,
                                      MapViewFlags);

        //
        // Close the handle since we only keep the pointer reference to the
        // section.
        //

        ZwClose(physicalMemoryHandle);

        //
        // Mapping the section above rounded the physical address down to the
        // nearest 64 K boundary. Now return a virtual address that sits where
        // we wnat by adding in the offset from the beginning of the section.
        //


        (ULONG_PTR) *VirtualAddress += (ULONG_PTR) (physicalAddressBase.QuadPart -
                                                  viewBase.QuadPart);
    }

    //
    // Restore all the other FLAGS
    //

    *InIoSpace = inIoSpace1 | *InIoSpace & ~VIDEO_MEMORY_SPACE_IO;

    *Length = mappedLength.LowPart;

    return ntStatus;

} // end pVideoPortMapUserPhysicalMem()

PVOID
VideoPortAllocatePool(
    IN PVOID HwDeviceExtension,
    IN VP_POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag)

/*++

Routine Description:

    Allocates Memory

Arguments:

    HwDeviceExtension - pointer to the miniports device extension

    VpPoolType - The type of pool to allocate:

        VpNonPagedPool
        VpPagedPool
        VpNonPagedPoolCacheAligned
        VpPagedPoolCacheAligned

    NumberOfBytes - Supplies the number of bytes to allocate.

    Tag - Supplies the caller's identifying tag.

Return Value:

    NULL - The memory allocation failed.

    NON-NULL - Returns a pointer to the allocated pool.

--*/

{
    ASSERT(HwDeviceExtension != NULL);

    return ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
}

VOID
VideoPortFreePool(
    IN PVOID HwDeviceExtension,
    IN PVOID Ptr
    )

/*++

Routine Description:

    Free's allocated memory

Arguments:

    HwDeviceExtension - pointer to the miniports device extension

    Ptr - pointer to the memory to free

Return Value:

    none

--*/

{
    ASSERT(HwDeviceExtension != NULL);
    ASSERT(Ptr != NULL);

    ExFreePool(Ptr);
}

VP_STATUS
VideoPortAllocateBuffer(
    IN PVOID HwDeviceExtension,
    IN ULONG Size,
    OUT PVOID *Buffer
    )
{
    pVideoDebugPrint((1, "Obsolete function: Please use VideoPortAllocatePool instead\n"));

    *Buffer = VideoPortAllocatePool(HwDeviceExtension, VpPagedPool, Size, ' pmV');

    if (*Buffer) {
        return NO_ERROR;
    } else {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
}

VOID
VideoPortReleaseBuffer(
    IN PVOID HwDeviceExtension,
    IN PVOID Buffer
    )
{
    pVideoDebugPrint((1, "Obsolete function: Please use VideoPortFreePool instead\n"));

    VideoPortFreePool(HwDeviceExtension, Buffer);
}


VP_STATUS
VideoPortMapBankedMemory(
    PVOID HwDeviceExtension,
    PHYSICAL_ADDRESS PhysicalAddress,
    PULONG Length,
    PULONG InIoSpace,
    PVOID *VirtualAddress,
    ULONG BankLength,
    UCHAR ReadWriteBank,
    PBANKED_SECTION_ROUTINE BankRoutine,
    PVOID Context
    )

/*++

Routine Description:

    VideoPortMapMemory allows the miniport driver to map a section of
    physical memory (either memory or registers) into the calling process'
    address space (eventhough we are in kernel mode, this function is
    executed within the same context as the user-mode process that initiated
    the call).

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    PhysicalAddress - Specifies the physical address to be mapped.

    Length - Points to the number of bytes of physical memory to be mapped.
        This argument returns the actual amount of memory mapped.

    InIoSpace - Points to a variable that is 1 if the address is in I/O
        space.  Otherwise, the address is assumed to be in memory space.

    VirtualAddress - A pointer to a location containing:

        on input: An optional handle to the process in which the memory must
            be mapped. 0 must be used to map the memory for the display
            driver (in the context of the windows server process).

        on output:  The return value is the virtual address at which the
            physical address has been mapped.

    BankLength - Size of the bank on the device.

    ReadWriteBank - TRUE is the bank is READ\WRITE, FALSE if there are
                    two independent READ and WRITE banks.

    BankRoutine - Pointer to the banking routine.

    Context - Context parameter passed in by the miniport supplied on
        each callback to the miniport.

Return Value:

    VideoPortMapBankedMemory returns the status of the operation.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    VP_STATUS status;
    HANDLE processHandle;

    //
    // Save the process ID, but don't change it since MapMemory relies
    // on it also
    //

    if (*VirtualAddress == NULL) {

        processHandle = NtCurrentProcess();

    } else {

        processHandle = (HANDLE) *VirtualAddress;

    }

    status = VideoPortMapMemory(HwDeviceExtension,
                                PhysicalAddress,
                                Length,
                                InIoSpace,
                                VirtualAddress);

    if (status == NO_ERROR) {

        NTSTATUS ntstatus;

        ntstatus = MmSetBankedSection(processHandle,
                                      *VirtualAddress,
                                      BankLength,
                                      ReadWriteBank,
                                      BankRoutine,
                                      Context);

        if (!NT_SUCCESS(ntstatus)) {

            ASSERT (FALSE);
            status = ERROR_INVALID_PARAMETER;

        }
    }

    return status;

} // end VideoPortMapBankedMemory()


VP_STATUS
VideoPortMapMemory(
    PVOID HwDeviceExtension,
    PHYSICAL_ADDRESS PhysicalAddress,
    PULONG Length,
    PULONG InIoSpace,
    PVOID *VirtualAddress
    )

/*++

Routine Description:

    VideoPortMapMemory allows the miniport driver to map a section of
    physical memory (either memory or registers) into the calling process'
    address space (eventhough we are in kernel mode, this function is
    executed within the same context as the user-mode process that initiated
    the call).

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    PhysicalAddress - Specifies the physical address to be mapped.

    Length - Points to the number of bytes of physical memory to be mapped.
        This argument returns the actual amount of memory mapped.

    InIoSpace - Points to a variable that is 1 if the address is in I/O
        space.  Otherwise, the address is assumed to be in memory space.

    VirtualAddress - A pointer to a location containing:

        on input: An optional handle to the process in which the memory must
            be mapped. 0 must be used to map the memory for the display
            driver (in the context of the windows server process).

        on output:  The return value is the virtual address at which the
            physical address has been mapped.

Return Value:

    VideoPortMapMemory returns the status of the operation.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{

    NTSTATUS ntStatus;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    HANDLE processHandle;

    //
    // Check for valid pointers.
    //

    if (!(ARGUMENT_PRESENT(Length)) ||
        !(ARGUMENT_PRESENT(InIoSpace)) ||
        !(ARGUMENT_PRESENT(VirtualAddress)) ) {

        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;

    }

    //
    // Let's handle the special memory types here.
    //
    // NOTE
    // Large pages is automatic - the caller need not specify this attribute
    // since it does not affect the device.

    //
    // Save the process handle and zero out the Virtual address field
    //

    if (*VirtualAddress == NULL) {

        if (*InIoSpace & VIDEO_MEMORY_SPACE_USER_MODE)
        {
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
        }

        ntStatus = STATUS_SUCCESS;

        //
        // We specify TRUE for large pages since we know the addrses will only
        // be used in the context of the display driver, at normal IRQL.
        //

        *VirtualAddress = pVideoPortGetDeviceBase(HwDeviceExtension,
                                                  PhysicalAddress,
                                                  *Length,
                                                  (UCHAR) (*InIoSpace),
                                                  TRUE);

        //
        // Zero can only be success if the driver is calling to MAP
        // address 0.  Otherwise, it is an error.
        //

        if (*VirtualAddress == NULL) {

            //
            // Only on X86 can the logical address also be 0.
            //

#if defined (_X86_) || defined(_IA64_)
            if (PhysicalAddress.QuadPart != 0)
#endif
                ntStatus = STATUS_INVALID_PARAMETER;
        }

    } else {

        if (!(*InIoSpace & VIDEO_MEMORY_SPACE_USER_MODE))
        {
            //
            // We can not assert since this is an existing path and old
            // drivers will not have this flag set.
            //
            // ASSERT(FALSE);
            // return ERROR_INVALID_PARAMETER;
            //

            *InIoSpace |= VIDEO_MEMORY_SPACE_USER_MODE;
        }

        processHandle = (HANDLE) *VirtualAddress;
        *VirtualAddress = NULL;

        ntStatus = pVideoPortMapUserPhysicalMem(fdoExtension,
                                                processHandle,
                                                PhysicalAddress,
                                                Length,
                                                InIoSpace,
                                                VirtualAddress);

    }

    if (!NT_SUCCESS(ntStatus)) {

        pVideoDebugPrint((Error, 
             "VIDEOPRT: VideoPortMapMemory failed with NtStatus = %08lx\n",
                                                                 ntStatus));

        pVideoDebugPrint((Error, "*VirtualAddress = 0x%x\n", *VirtualAddress));
        pVideoDebugPrint((Error, "Length = 0x%x\n", *Length));

        pVideoDebugPrint((Error, 
               "PhysicalAddress.LowPart = 0x%08lx, PhysicalAddress.HighPart = 0x%08lx\n", 
                 PhysicalAddress.LowPart, PhysicalAddress.HighPart));

        *VirtualAddress = NULL;

        return ERROR_INVALID_PARAMETER;

    } else {

        return NO_ERROR;

    }

} // end VideoPortMapMemory()



VOID
pVideoPortPowerCompletionIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    Completion routine that is called when one of our power irps has been
    comeplted.  This allows us to fill out the status code for the request.

Arguments:

    DeviceObject  - Pointer to the device object

    MinorFunction - Minor function of the IRP

    PowerState    - Power state that was set

    Context       - Context paramter

    IoStatus      - Status block for that IRP

Return Value:

    VOID

Environment:

--*/

{
    PPOWER_BLOCK powerContext = (PPOWER_BLOCK) Context;

    if (powerContext->FinalFlag == TRUE) {
        powerContext->Irp->IoStatus.Status = IoStatus->Status;
        IoCompleteRequest (powerContext->Irp, IO_VIDEO_INCREMENT);
    }

    ExFreePool(Context);

    return;
}





BOOLEAN
pVideoPortResetDisplay(
    IN ULONG Columns,
    IN ULONG Rows
    )

/*++

Routine Description:

    Callback for the HAL that calls the miniport driver.

Arguments:

    Columns - The number of columns of the video mode.

    Rows - The number of rows for the video mode.

Return Value:

    We always return FALSE so the HAL will always reste the mode afterwards.

Environment:

    Non-paged only.
    Used in BugCheck and soft-reset calls.

--*/

{

    ULONG iReset;
    BOOLEAN bRetVal = FALSE;

    for (iReset=0;
         (iReset < 6) && (HwResetHw[iReset].HwDeviceExtension);
         iReset++) {

        PFDO_EXTENSION fdoExtension =
            GET_FDO_EXT(HwResetHw[iReset].HwDeviceExtension);

        //
        // We can only reset devices which are on the hibernation path, otherwise
        // we are running into the risk that IO / MMIO decode has been disabled
        // by PCI.SYS for that device during power management cycle.
        //

        if (HwResetHw[iReset].ResetFunction &&
            (fdoExtension->HwInitStatus == HwInitSucceeded) &&
            (fdoExtension->OnHibernationPath == TRUE)) {

            bRetVal &= HwResetHw[iReset].ResetFunction(HwResetHw[iReset].HwDeviceExtension,
                                                       Columns,
                                                       Rows);
        }
    }

    return bRetVal;

} // end pVideoPortResetDisplay()



BOOLEAN
VideoPortScanRom(
    PVOID HwDeviceExtension,
    PUCHAR RomBase,
    ULONG RomLength,
    PUCHAR String
    )

/*++

Routine Description:

    Does a case *SENSITIVE* search for a string in the ROM.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    RomBase - Base address at which the search should start.

    RomLength - Size, in bytes, of the ROM area in which to perform the
        search.

    String - String to search for

Return Value:

    Returns TRUE if the string was found.
    Returns FALSE if it was not found.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    ULONG stringLength, length;
    ULONG_PTR startOffset;
    PUCHAR string1, string2;
    BOOLEAN match;

    UNREFERENCED_PARAMETER(HwDeviceExtension);

    stringLength = strlen(String);

    for (startOffset = 0;
         startOffset < RomLength - stringLength + 1;
         startOffset++) {

        length = stringLength;
        string1 = RomBase + startOffset;
        string2 = String;
        match = TRUE;

        while (length--) {

            if (READ_REGISTER_UCHAR(string1++) - (*string2++)) {

                match = FALSE;
                break;

            }
        }

        if (match) {

            return TRUE;
        }
    }

    return FALSE;

} // end VideoPortScanRom()



VP_STATUS
VideoPortSetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

/*++

Routine Description:

    VideoPortSetRegistryParameters writes information to the CurrentControlSet
    in the registry.  The function automatically searches for or creates the
    specified parameter name under the parameter key of the current driver.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    ValueName - Points to a Unicode string that contains the name of the
        data value being written in the registry.

    ValueData - Points to a buffer containing the information to be written
        to the registry.

    ValueLength - Specifies the size of the data being written to the registry.

Return Value:

    This function returns the final status of the operation.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    PDEVICE_SPECIFIC_EXTENSION DoSpecificExtension;
    VP_STATUS vpStatus;

    ASSERT (ValueName != NULL);
    
    DoSpecificExtension = GET_DSP_EXT(HwDeviceExtension);

    if (DoSpecificExtension->DriverNewRegistryPath != NULL) {

        vpStatus = VPSetRegistryParameters(HwDeviceExtension,
                                           ValueName,
                                           ValueData,
                                           ValueLength,
                                           DoSpecificExtension->DriverNewRegistryPath,
                                           DoSpecificExtension->DriverNewRegistryPathLength);
    } else {

        vpStatus = VPSetRegistryParameters(HwDeviceExtension,
                                           ValueName,
                                           ValueData,
                                           ValueLength,
                                           DoSpecificExtension->DriverOldRegistryPath,
                                           DoSpecificExtension->DriverOldRegistryPathLength);
    }

    return vpStatus;
}


VP_STATUS
VPSetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength,
    PWSTR RegistryPath,
    ULONG RegistryPathLength
    )
{
    NTSTATUS                   ntStatus;
    LPWSTR                     RegPath;
    LPWSTR                     lpstrStart, lpstrEnd;

    //
    // Check if there are subkeys need to be created
    //
    RegPath = (LPWSTR) ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,
                                             RegistryPathLength +
                                                 2 * (wcslen(ValueName) + sizeof(WCHAR)),
                                             VP_TAG);
    if (RegPath == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(RegPath, RegistryPath);
    lpstrStart = RegPath + (RegistryPathLength / 2);

    while (lpstrEnd = wcschr(ValueName, L'\\'))
    {
        //
        // Concat the string
        //
        *(lpstrStart++) = L'\\';
        while (ValueName != lpstrEnd) {
            *(lpstrStart++) = *(ValueName++);
        }
        *lpstrStart = UNICODE_NULL;

        //
        // Create the Key.
        //

        ntStatus = RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE, RegPath);
        if (!NT_SUCCESS(ntStatus)) {
            ExFreePool(RegPath);
            return ERROR_INVALID_PARAMETER;
        }

        ValueName++;
    }


    //
    // Don't let people store as DefaultSettings anymore ...
    // Must still work for older drivers through.
    //

    if (wcsncmp(ValueName,
                L"DefaultSettings.",
                sizeof(L"DefaultSettings.")) == 0) {

        ASSERT(FALSE);

        //
        // check for NT 5.0
        //

        if (GET_FDO_EXT(HwDeviceExtension)->Flags & PNP_ENABLED) {

            ExFreePool(RegPath);
            return ERROR_INVALID_PARAMETER;
        }
    }

    ntStatus = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                     RegPath,
                                     ValueName,
                                     REG_BINARY,
                                     ValueData,
                                     ValueLength);

    ExFreePool(RegPath);

    if (!NT_SUCCESS(ntStatus)) {

        return ERROR_INVALID_PARAMETER;

    }

    return NO_ERROR;

} // end VideoPortSetRegistryParamaters()


VP_STATUS
VideoPortFlushRegistry(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine will flush the registry keys and values associated with
    the given miniport driver.

Arguments:

    HwDeviceExtension  - Pointer to the miniport device extension.

Return Value:

    Status Code.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyName;
    HANDLE RegKey;
    NTSTATUS Status;
    PDEVICE_SPECIFIC_EXTENSION DoSpecificExtension;

    DoSpecificExtension = GET_DSP_EXT(HwDeviceExtension);

    if (DoSpecificExtension->DriverNewRegistryPath != NULL) {

        KeyName.Length = (USHORT)DoSpecificExtension->DriverNewRegistryPathLength;
        KeyName.MaximumLength = (USHORT)DoSpecificExtension->DriverNewRegistryPathLength;
        KeyName.Buffer = DoSpecificExtension->DriverNewRegistryPath;

    } else {

        KeyName.Length = (USHORT)DoSpecificExtension->DriverOldRegistryPathLength;
        KeyName.MaximumLength = (USHORT)DoSpecificExtension->DriverOldRegistryPathLength;
        KeyName.Buffer = DoSpecificExtension->DriverOldRegistryPath;
    }

    //
    // Flush the registry key
    //

    InitializeObjectAttributes(&ObjectAttributes,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&RegKey,
                       KEY_READ | KEY_WRITE,
                       &ObjectAttributes);

    if (NT_SUCCESS(Status)) {

        ZwFlushKey(RegKey);
        ZwClose(RegKey);
    }

    return NO_ERROR;
}

VOID
pVideoPortHwTimer(
    IN PDEVICE_OBJECT DeviceObject,
    PVOID Context
    )

/*++

Routine Description:

    This function is the main entry point for the timer routine that we then
    forward to the miniport driver.

Arguments:

    DeviceObject -

    Context - Not needed

Return Value:

    None.

--*/

{
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;

    UNREFERENCED_PARAMETER(Context);

    fdoExtension->HwTimer(fdoExtension->HwDeviceExtension);

    return;

} // pVideoPortInterrupt()



VOID
VideoPortStartTimer(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    Enables the timer specified in the HW_INITIALIZATION_DATA structure
    passed to the video port driver at init time.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

Return Value:

    None

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    if (fdoExtension->HwTimer == NULL) {

        ASSERT(fdoExtension->HwTimer != NULL);

    } else {

        IoStartTimer(fdoExtension->FunctionalDeviceObject);

    }

    return;
}



VOID
VideoPortStopTimer(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    Disables the timer specified in the HW_INITIALIZATION_DATA structure
    passed to the video port driver at init time.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

Return Value:

    None

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    if (fdoExtension->HwTimer == NULL) {

        ASSERT(fdoExtension->HwTimer != NULL);

    } else {

        IoStopTimer(fdoExtension->FunctionalDeviceObject);

    }

    return;
}



BOOLEAN
VideoPortSynchronizeExecution(
    PVOID HwDeviceExtension,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE SynchronizeRoutine,
    PVOID Context
    )

/*++

    Stub so we can allow the miniports to link directly

--*/

{
    return pVideoPortSynchronizeExecution(HwDeviceExtension,
                                          Priority,
                                          SynchronizeRoutine,
                                          Context);
} // end VideoPortSynchronizeExecution()

BOOLEAN
pVideoPortSynchronizeExecution(
    PVOID HwDeviceExtension,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE SynchronizeRoutine,
    PVOID Context
    )

/*++

Routine Description:

    VideoPortSynchronizeExecution synchronizes the execution of a miniport
    driver function in the following manner:

        - If Priority is equal to VpLowPriority, the current thread is
          raised to the highest non-interrupt-masking priority.  In
          other words, the current thread can only be pre-empted by an ISR.

        - If Priority is equal to VpMediumPriority and there is an
          ISR associated with the video device, then the function specified
          by SynchronizeRoutine is synchronized with the ISR.

          If no ISR is connected, synchronization is made at VpHighPriority
          level.

        - If Priority is equal to VpHighPriority, the current IRQL is
          raised to HIGH_LEVEL, which effectively masks out ALL interrupts
          in the system. This should be done sparingly and for very short
          periods -- it will completely freeze up the entire system.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    Priority - Specifies the type of priority at which the SynchronizeRoutine
        must be executed (found in VIDEO_SYNCHRONIZE_PRIORITY).

    SynchronizeRoutine - Points to the miniport driver function to be
        synchronized.

    Context - Specifies a context parameter to be passed to the miniport's
        SynchronizeRoutine.

Return Value:

    This function returns TRUE if the operation is successful.  Otherwise, it
    returns FALSE.

--*/

{
    BOOLEAN status;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    KIRQL oldIrql;

    //
    // Switch on which type of priority.
    //

    switch (Priority) {

    case VpMediumPriority:
    case VpHighPriority:


        //
        // This is synchronized with the interrupt object
        //

        if (fdoExtension->InterruptObject) {

            status = KeSynchronizeExecution(fdoExtension->InterruptObject,
                                            (PKSYNCHRONIZE_ROUTINE)
                                            SynchronizeRoutine,
                                            Context);

            return status;
        }

        //
        // Fall through for Medium Priority
        //

    case VpLowPriority:

        //
        // Just normal level
        //

        status = SynchronizeRoutine(Context);

        return status;

    default:

        return FALSE;

    }
}



VP_STATUS
VideoPortUnmapMemory(
    PVOID HwDeviceExtension,
    PVOID VirtualAddress,
    HANDLE ProcessHandle
    )

/*++

Routine Description:

    VideoPortUnmapMemory allows the miniport driver to unmap a physical
    address range previously mapped into the calling process' address space
    using the VideoPortMapMemory function.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    VirtualAddress - Points to the virtual address to unmap from the
        address space of the caller.

    // InIoSpace - Specifies whether the address is in I/O space (1) or memory
    //     space (0).

    ProcessHandle - Handle to the process from which memory must be unmapped.

Return Value:

    This function returns a status code of NO_ERROR if the operation succeeds.
    It returns ERROR_INVALID_PARAMETER if an error occurs.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    NTSTATUS ntstatus;
    VP_STATUS vpStatus = NO_ERROR;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // Backwards compatibility to when the ProcessHandle was actually
    // ULONG InIoSpace.
    //

    if (((ULONG_PTR)(ProcessHandle)) == 1) {

        pVideoDebugPrint((Warn,"VIDEOPRT: VideoPortUnmapMemory - interface change, must pass in process handle\n\n"));
        ASSERT(FALSE);

        return NO_ERROR;

    }

    if (((ULONG_PTR)(ProcessHandle)) == 0) {

        //
        // If the process handle is zero, it means it was mapped by the display
        // driver and is therefore in kernel mode address space.
        //

        if (!pVideoPortFreeDeviceBase(HwDeviceExtension, VirtualAddress)) {

            ASSERT(FALSE);

            vpStatus = ERROR_INVALID_PARAMETER;

        }

    } else {

        //
        // A process handle is passed in.
        // This ms it was mapped for use by an application (DCI \ DirectDraw).
        //

        ntstatus = ZwUnmapViewOfSection ( ProcessHandle,
            (PVOID) ( ((ULONG_PTR)VirtualAddress) & (~(PAGE_SIZE - 1)) ) );

        if ( (!NT_SUCCESS(ntstatus)) &&
             (ntstatus != STATUS_PROCESS_IS_TERMINATING) ) {

            ASSERT(FALSE);

            vpStatus = ERROR_INVALID_PARAMETER;

        }
    }

    return NO_ERROR;

} // end VideoPortUnmapMemory()


BOOLEAN
VideoPortSignalDmaComplete(
    IN  PVOID               HwDeviceExtension,
    IN  PDMA                pDmaHandle
    )
/*++

Routine Description:

    This function is obsolete. 

--*/
{
    return FALSE;
}

VP_STATUS
VideoPortCreateSecondaryDisplay(
    IN PVOID HwDeviceExtension,
    IN OUT PVOID *SecondaryDeviceExtension,
    IN ULONG ulFlag
    )

/*++

Routine Description:

    This routine creates a secondary device object for the given device.  This
    will allow for dual-view support.


Arguments:

    HwDeviceExtension - The HwDeviceExtension for the device which wants to
        create additional output devices.

    SecondaryDeviceExtension - The location in which to store the
        HwDeviceExtension for the secondary display.

Returns:

    VP_STATUS

--*/

{
    WCHAR deviceNameBuffer[STRING_LENGTH];
    POBJECT_NAME_INFORMATION deviceName;
    ULONG strLength;
    UNICODE_STRING deviceNameUnicodeString;
    PDEVICE_OBJECT DeviceObject;
    NTSTATUS ntStatus;
    PDEVICE_SPECIFIC_EXTENSION DoSpecificExtension;
    PFDO_EXTENSION FdoExtension = GET_FDO_EXT(HwDeviceExtension);
    PVIDEO_PORT_DRIVER_EXTENSION DriverObjectExtension;
    PUNICODE_STRING RegistryPath;
    WCHAR deviceSubpathBuffer[STRING_LENGTH];
    UNICODE_STRING deviceSubpathUnicodeString;
    WCHAR deviceLinkBuffer[STRING_LENGTH];
    UNICODE_STRING deviceLinkUnicodeString;
    ULONG driverKeySize;
    PWSTR driverKeyName = NULL;
    ULONG MaxObjectNumber;

    //
    // Retrieve the data we cached away during VideoPortInitialize.
    //

    DriverObjectExtension = (PVIDEO_PORT_DRIVER_EXTENSION)
                            IoGetDriverObjectExtension(
                                FdoExtension->DriverObject,
                                FdoExtension->DriverObject);

    ASSERT(DriverObjectExtension);
    ASSERT(SecondaryDeviceExtension != NULL);

    RegistryPath = &DriverObjectExtension->RegistryPath;

    ntStatus = pVideoPortCreateDeviceName(L"\\Device\\Video",
                                          VideoDeviceNumber,
                                          &deviceNameUnicodeString,
                                          deviceNameBuffer);

    //
    // Create a device object to represent the Video Adapter.
    //

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = IoCreateDevice(FdoExtension->DriverObject,
                                  sizeof(DEVICE_SPECIFIC_EXTENSION) +
                                  FdoExtension->HwDeviceExtensionSize,
                                  &deviceNameUnicodeString,
                                  FILE_DEVICE_VIDEO,
                                  0,
                                  TRUE,
                                  &DeviceObject);

        if (NT_SUCCESS(ntStatus)) {

            DeviceObject->DeviceType = FILE_DEVICE_VIDEO;
            DoSpecificExtension = DeviceObject->DeviceExtension;

            //
            // Initialize DeviceSpecificExtension
            //

            DoSpecificExtension->DeviceNumber = VideoDeviceNumber;
            DoSpecificExtension->pFdoExtension = FdoExtension;
            DoSpecificExtension->Signature = VP_TAG;
            DoSpecificExtension->ExtensionType = TypeDeviceSpecificExtension;
            DoSpecificExtension->HwDeviceExtension = (PVOID)(DoSpecificExtension + 1);
            DoSpecificExtension->DualviewFlags = ulFlag | VIDEO_DUALVIEW_SECONDARY;
#ifdef IOCTL_VIDEO_USE_DEVICE_IN_SESSION
            DoSpecificExtension->SessionId = VIDEO_DEVICE_INVALID_SESSION;
#endif IOCTL_VIDEO_USE_DEVICE_IN_SESSION

            deviceName = (POBJECT_NAME_INFORMATION) deviceNameBuffer;

            ObQueryNameString(DeviceObject,
                              deviceName,
                              STRING_LENGTH * sizeof(WCHAR),
                              &strLength);

            //
            // Create the name we will be storing in the \DeviceMap.
            // This name is a PWSTR, not a unicode string
            // This is the name of the driver with an appended device number
            //

            if (!NT_SUCCESS(pVideoPortCreateDeviceName(
                                L"\\Device",
                                DriverObjectExtension->HwInitData.StartingDeviceNumber + 1,
                                &deviceSubpathUnicodeString,
                                deviceSubpathBuffer)))
            {
                pVideoDebugPrint((Error, "VIDEOPRT: VideoPortCreateSecondaryDisplay: Could not create device subpath number\n"));

                IoDeleteDevice(DeviceObject);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            DoSpecificExtension->DriverOldRegistryPathLength =
                RegistryPath->Length +
                deviceSubpathUnicodeString.Length;

            driverKeySize =
                DoSpecificExtension->DriverOldRegistryPathLength +
                2 * sizeof(UNICODE_NULL);

            if ( (driverKeyName = (PWSTR) ExAllocatePoolWithTag(PagedPool,
                                                                driverKeySize,
                                                                VP_TAG) ) == NULL)
            {
                pVideoDebugPrint((Error, "VIDEOPRT: VideoPortCreateSecondaryDisplay: Fail to allocate driverKeyName\n"));

                IoDeleteDevice(DeviceObject);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            RtlMoveMemory(driverKeyName,
                          RegistryPath->Buffer,
                          RegistryPath->Length);

            RtlMoveMemory((PWSTR)((ULONG_PTR)driverKeyName +
                          RegistryPath->Length),
                          deviceSubpathBuffer,
                          deviceSubpathUnicodeString.Length);

            //
            // Put two NULLs at the end so we can play around with the string later.
            //

            *((PWSTR) ((ULONG_PTR)driverKeyName +
                DoSpecificExtension->DriverOldRegistryPathLength))
                = UNICODE_NULL;
            *((PWSTR) ((ULONG_PTR)driverKeyName +
                (DoSpecificExtension->DriverOldRegistryPathLength
                + sizeof(UNICODE_NULL)))) = UNICODE_NULL;

            //
            // There is a bug in Lotus Screen Cam where it will only work if our
            // reg path is \REGISTRY\Machine\System not \REGISTRY\MACHINE\SYSTEM.
            // so replace the appropriate strings.
            //

            if (wcsstr(driverKeyName, L"MACHINE")) {
                wcsncpy(wcsstr(driverKeyName, L"MACHINE"), L"Machine", sizeof("Machine")-1);
            }

            if (wcsstr(driverKeyName, L"SYSTEM")) {
                wcsncpy(wcsstr(driverKeyName, L"SYSTEM"), L"System", sizeof("System")-1);
            }

            //
            // Store the old key
            //

            DoSpecificExtension->DriverOldRegistryPath = driverKeyName;

            //
            // Store the new key
            // If this is not a Whistler driver, then use the old key.
            //



            if (EnableNewRegistryKey) {

#if _X86_
                if (DriverObjectExtension->HwInitData.HwInitDataSize > SIZE_OF_W2K_VIDEO_HW_INITIALIZATION_DATA) 
#endif // _X86_

                    VpEnableNewRegistryKey(FdoExtension,
                                           DoSpecificExtension,
                                           RegistryPath,
                                           FdoExtension->RegistryIndex + 1);
            }

            //
            // Store the path name of the location of the driver in the registry.
            //

            if (DoSpecificExtension->DriverNewRegistryPath != NULL) {

                DoSpecificExtension->DriverRegistryPath = 
                    DoSpecificExtension->DriverNewRegistryPath;
                DoSpecificExtension->DriverRegistryPathLength = 
                    DoSpecificExtension->DriverNewRegistryPathLength;

            } else {

                DoSpecificExtension->DriverRegistryPath = 
                    DoSpecificExtension->DriverOldRegistryPath;
                DoSpecificExtension->DriverRegistryPathLength = 
                    DoSpecificExtension->DriverOldRegistryPathLength;
            }
            
            //
            // NOTE:
            //
            // We only want to reinitialize the device once the Boot sequence has
            // been completed and the HAL does not need to access the device again.
            // So the initialization entry point will be called when the device is
            // opened.
            //


            if (!NT_SUCCESS(pVideoPortCreateDeviceName(L"\\DosDevices\\DISPLAY",
                                                       DoSpecificExtension->DeviceNumber + 1,
                                                       &deviceLinkUnicodeString,
                                                       deviceLinkBuffer)))
            {
                pVideoDebugPrint((Error, "VIDEOPRT: VideoPortCreateSecondaryDisplay: Could not create device subpath number\n"));

                ExFreePool(driverKeyName);
                IoDeleteDevice(DeviceObject);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            ntStatus = IoCreateSymbolicLink(&deviceLinkUnicodeString,
                                            &deviceName->Name);


            if (!NT_SUCCESS(ntStatus)) {

                pVideoDebugPrint((Error, "VIDEOPRT: VideoPortCreateSecondaryDisplay: SymbolicLink Creation failed\n"));

                ExFreePool(driverKeyName);
                IoDeleteDevice(DeviceObject);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            //
            // Once initialization is finished, load the required information in the
            // registry so that the appropriate display drivers can be loaded.
            //

            ntStatus = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP,
                                             VideoClassString,
                                             deviceName->Name.Buffer,
                                             REG_SZ,
                                             DoSpecificExtension->DriverRegistryPath,
                                             DoSpecificExtension->DriverRegistryPathLength +
                                                 sizeof(UNICODE_NULL));

            if (!NT_SUCCESS(ntStatus)) {

                pVideoDebugPrint((Error, "VIDEOPRT: VideoPortCreateSecondaryDisplay: Could not store name in DeviceMap\n"));

            }


            //
            // Tell win32k how many objects to try to open
            //

            MaxObjectNumber = VideoDeviceNumber - 1;

            ntStatus = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP,
                                             VideoClassString,
                                             L"MaxObjectNumber",
                                             REG_DWORD,
                                             &MaxObjectNumber,
                                             sizeof(ULONG));

            if (!NT_SUCCESS(ntStatus)) {

                pVideoDebugPrint((Error, "VIDEOPRT: VideoPortCreateSecondaryDisplay: Could not store name in DeviceMap\n"));

            }

            //
            // Register and enable the interface
            //

            VpEnableAdapterInterface(DoSpecificExtension);

            //
            // Finally, tell the system we are done with Device Initialization
            //

            DeviceObject->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;
            DeviceObject->Flags &= ~(DO_DEVICE_INITIALIZING | DO_POWER_INRUSH);

            VideoDeviceNumber++;
            FdoExtension->RegistryIndex++;
        }
    }

    if (NT_SUCCESS(ntStatus)) {

        *SecondaryDeviceExtension = (PVOID)(DoSpecificExtension + 1);

        DriverObjectExtension->HwInitData.StartingDeviceNumber++;
        //
        // Mark the primary view
        //

        ((PDEVICE_SPECIFIC_EXTENSION)(FdoExtension + 1))->DualviewFlags = VIDEO_DUALVIEW_PRIMARY;

    }

    return ntStatus;
}

#if DBG

PIO_RESOURCE_REQUIREMENTS_LIST
BuildRequirements(
    PCM_RESOURCE_LIST pcmResourceList
    )
{
    ULONG i;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pcmDescript;

    PIO_RESOURCE_REQUIREMENTS_LIST Requirements;
    PIO_RESOURCE_DESCRIPTOR pioDescript;

    ULONG RequirementsListSize;
    ULONG RequirementCount;

    pVideoDebugPrint((Trace, "VIDEOPRT: BuildRequirements()\n"));

    RequirementCount = pcmResourceList->List[0].PartialResourceList.Count;

    RequirementsListSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
                              ((RequirementCount - 1) *
                              sizeof(IO_RESOURCE_DESCRIPTOR));

    Requirements = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(
                                                        PagedPool,
                                                        RequirementsListSize);

    Requirements->ListSize         = RequirementsListSize;
    Requirements->InterfaceType    = pcmResourceList->List[0].InterfaceType;
    Requirements->BusNumber        = pcmResourceList->List[0].BusNumber;
    Requirements->SlotNumber       = -1; // ???
    Requirements->AlternativeLists = 0; // ???

    Requirements->List[0].Version  = pcmResourceList->List[0].PartialResourceList.Version;
    Requirements->List[0].Revision = pcmResourceList->List[0].PartialResourceList.Revision;
    Requirements->List[0].Count    = RequirementCount;

    pcmDescript = &(pcmResourceList->List[0].PartialResourceList.PartialDescriptors[0]);
    pioDescript = &(Requirements->List[0].Descriptors[0]);

    for (i=0; i<RequirementCount; i++) {

        pioDescript->Option = IO_RESOURCE_PREFERRED;
        pioDescript->Type   = pcmDescript->Type;
        pioDescript->ShareDisposition = pcmDescript->ShareDisposition;
        pioDescript->Flags  = pcmDescript->Flags;

        switch (pcmDescript->Type) {
        case CmResourceTypePort:
            pioDescript->u.Port.Length = pcmDescript->u.Port.Length;
            pioDescript->u.Port.Alignment = 1;
            pioDescript->u.Port.MinimumAddress =
            pioDescript->u.Port.MaximumAddress = pcmDescript->u.Port.Start;
            break;

        case CmResourceTypeMemory:
            pioDescript->u.Memory.Length = pcmDescript->u.Memory.Length;
            pioDescript->u.Memory.Alignment = 1;
            pioDescript->u.Memory.MinimumAddress =
            pioDescript->u.Memory.MaximumAddress = pcmDescript->u.Memory.Start;
            break;

        default:

            //
            // We don't have to handle the other stuff, because we only
            // want to report Ports and Memory to the system.
            //

            break;
        }

        pioDescript++;
        pcmDescript++;
    }

    return Requirements;
}

VOID
DumpRequirements(
    PIO_RESOURCE_REQUIREMENTS_LIST Requirements
    )
{
    ULONG i;

    PIO_RESOURCE_DESCRIPTOR pioDescript;

    ULONG RequirementsListSize;
    ULONG RequirementCount = Requirements->List[0].Count;

    char *Table[] = { "Internal",
                      "Isa",
                      "Eisa",
                      "MicroChannel",
                      "TurboChannel",
                      "PCIBus",
                      "VMEBus",
                      "NuBus",
                      "PCMCIABus",
                      "CBus",
                      "MPIBus",
                      "MPSABus",
                      "ProcessorInternal",
                      "InternalPowerBus",
                      "PNPISABus",
                      "MaximumInterfaceType"
                    };

    pVideoDebugPrint((Info, "VIDEOPRT: Beginning dump of requirements list:\n"));
    pVideoDebugPrint((Info, "ListSize:         0x%x\n"
                         "InterfaceType:    %s\n"
                         "BusNumber:        0x%x\n"
                         "SlotNumber:       0x%x\n"
                         "AlternativeLists: 0x%x\n",
                         Requirements->ListSize,
                         Table[Requirements->InterfaceType],
                         Requirements->BusNumber,
                         Requirements->SlotNumber,
                         Requirements->AlternativeLists));

    pVideoDebugPrint((Info, "List[0].Version:  0x%x\n"
                         "List[0].Revision: 0x%x\n"
                         "List[0].Count:    0x%x\n",
                         Requirements->List[0].Version,
                         Requirements->List[0].Revision,
                         Requirements->List[0].Count));

    pioDescript = &(Requirements->List[0].Descriptors[0]);

    for (i=0; i<RequirementCount; i++) {

        pVideoDebugPrint((Info, "\n"
                             "Option:           0x%x\n"
                             "Type:             0x%x\n"
                             "ShareDisposition: 0x%x\n"
                             "Flags:            0x%x\n",
                             pioDescript->Option,
                             pioDescript->Type,
                             pioDescript->ShareDisposition,
                             pioDescript->Flags));

        switch (pioDescript->Type) {
        case CmResourceTypePort:

            pVideoDebugPrint((Info, "\nPort...\n"
                                 "\tLength:         0x%x\n"
                                 "\tAlignment:      0x%x\n"
                                 "\tMinimumAddress: 0x%x\n"
                                 "\tMaximumAddress: 0x%x\n",
                                 pioDescript->u.Port.Length,
                                 pioDescript->u.Port.Alignment,
                                 pioDescript->u.Port.MinimumAddress,
                                 pioDescript->u.Port.MaximumAddress));

            break;

        case CmResourceTypeMemory:

            pVideoDebugPrint((Info, "\nMemory...\n"
                                 "\tLength:         0x%x\n"
                                 "\tAlignment:      0x%x\n"
                                 "\tMinimumAddress: 0x%x\n"
                                 "\tMaximumAddress: 0x%x\n",
                                 pioDescript->u.Memory.Length,
                                 pioDescript->u.Memory.Alignment,
                                 pioDescript->u.Memory.MinimumAddress,
                                 pioDescript->u.Memory.MaximumAddress));
            break;

        case CmResourceTypeInterrupt:

            pVideoDebugPrint((Info, "\nInterrupt...\n"
                                 "\tMinimum Vector: 0x%x\n"
                                 "\tMaximum Vector: 0x%x\n",
                                 pioDescript->u.Interrupt.MinimumVector,
                                 pioDescript->u.Interrupt.MaximumVector));

            break;

        default:

            //
            // We don't have to handle the other stuff, because we only
            // want to report Ports and Memory to the system.
            //

            break;
        }

        pioDescript++;
    }

    return;
}

VOID
DumpResourceList(
    PCM_RESOURCE_LIST pcmResourceList)
{
    ULONG i, j;
    PCM_FULL_RESOURCE_DESCRIPTOR    pcmFull;
    PCM_PARTIAL_RESOURCE_LIST       pcmPartial;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pcmDescript;

    pVideoDebugPrint((Trace, "VIDEOPRT: Beginning dump of resource list:\n"));

    pcmFull = &(pcmResourceList->List[0]);
    for (i=0; i<pcmResourceList->Count; i++) {

        pVideoDebugPrint((Info, "List[%d]\n", i));

        pVideoDebugPrint((Info, "InterfaceType = 0x%x\n", pcmFull->InterfaceType));
        pVideoDebugPrint((Info, "BusNumber = 0x%x\n", pcmFull->BusNumber));

        pcmPartial = &(pcmFull->PartialResourceList);

        pVideoDebugPrint((Info, "Version = 0x%x\n", pcmPartial->Version));
        pVideoDebugPrint((Info, "Revision = 0x%x\n", pcmPartial->Revision));

        pcmDescript = &(pcmPartial->PartialDescriptors[0]);

        for (j=0; j<pcmPartial->Count; j++) {

            switch (pcmDescript->Type) {
            case CmResourceTypePort:
                pVideoDebugPrint((Info, "Port: 0x%x Length: 0x%x\n",
                                  pcmDescript->u.Port.Start.LowPart,
                                  pcmDescript->u.Port.Length));

                break;

            case CmResourceTypeInterrupt:
                pVideoDebugPrint((Info, "Interrupt: 0x%x Level: 0x%x\n",
                                  pcmDescript->u.Interrupt.Vector,
                                  pcmDescript->u.Interrupt.Level));
                break;

            case CmResourceTypeMemory:
                pVideoDebugPrint((Info, "Start: 0x%x Length: 0x%x\n",
                                  pcmDescript->u.Memory.Start.LowPart,
                                  pcmDescript->u.Memory.Length));
                break;

            case CmResourceTypeDma:
                pVideoDebugPrint((Info, "Dma Channel: 0x%x Port: 0x%x\n",
                                  pcmDescript->u.Dma.Channel,
                                  pcmDescript->u.Dma.Port));
                break;
            }

            pcmDescript++;
        }

        pcmFull = (PCM_FULL_RESOURCE_DESCRIPTOR) pcmDescript;
    }

    pVideoDebugPrint((Info, "VIDEOPRT: EndResourceList\n"));
}

VOID
DumpUnicodeString(
    IN PUNICODE_STRING p
    )
{
    PUSHORT pus = p->Buffer;
    UCHAR buffer[256];       // the string better not be longer than 255 chars!
    PUCHAR puc = buffer;
    ULONG i;

    for (i = 0; i < p->Length; i++) {

        *puc++ = (UCHAR) *pus++;

    }

    *puc = 0;  // null terminate the string

    pVideoDebugPrint((Info, "VIDEOPRT: UNICODE STRING: %s\n", buffer));
}

#endif

VP_STATUS
VideoPortEnumerateChildren(
    IN PVOID HwDeviceExtension,
    IN PVOID Reserved
    )

/*++

Routine Description:

    Allows a miniport to force a re-enumeration of it's children.

Arguments:

    HwDeviceExtension - The miniports device extension

    Reserved - Not currently used, should be NULL.

Returns:

    Status
--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT (HwDeviceExtension);
    PDEVICE_OBJECT pFDO = fdoExtension->FunctionalDeviceObject;
    PDEVICE_OBJECT pPDO = fdoExtension->PhysicalDeviceObject;

    ASSERT(Reserved == NULL);

    IoInvalidateDeviceRelations(pPDO, BusRelations);
    return NO_ERROR;
}

VIDEOPORT_API
VP_STATUS
VideoPortQueryServices(
    IN PVOID pHwDeviceExtension,
    IN VIDEO_PORT_SERVICES servicesType,
    IN OUT PINTERFACE pInterface
    )

/*++

Routine Description:

    This routine exposes interfaces to services supported by the videoprt.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    servicesType       - Requested services type.
    pInterface         - Points to services interface structure.

Returns:

    NO_ERROR   - Valid interface in the pInterface.
    Error code - Unsupported / unavailable services.

--*/

{
    VP_STATUS vpStatus;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pInterface);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    if (VideoPortServicesAGP == servicesType)
    {
        if ((pInterface->Version == VIDEO_PORT_AGP_INTERFACE_VERSION_2) &&
            (pInterface->Size == sizeof (VIDEO_PORT_AGP_INTERFACE_2)))
        {
            PVIDEO_PORT_AGP_INTERFACE_2 pAgpInterface = (PVIDEO_PORT_AGP_INTERFACE_2)pInterface;

            vpStatus = VpGetAgpServices2(pHwDeviceExtension, pAgpInterface);
        }
        else if ((pInterface->Version == VIDEO_PORT_AGP_INTERFACE_VERSION_1) &&
            (pInterface->Size == sizeof (VIDEO_PORT_AGP_INTERFACE)))
        {
            PVIDEO_PORT_AGP_INTERFACE pAgpInterface = (PVIDEO_PORT_AGP_INTERFACE)pInterface;

            pAgpInterface->Context = pHwDeviceExtension;
            pAgpInterface->InterfaceReference = VpInterfaceDefaultReference;
            pAgpInterface->InterfaceDereference = VpInterfaceDefaultDereference;

            if (VideoPortGetAgpServices(pHwDeviceExtension,
                (PVIDEO_PORT_AGP_SERVICES)&(pAgpInterface->AgpReservePhysical)) == TRUE)
            {
                //
                // Reference the interface before handing it out.
                //

                pAgpInterface->InterfaceReference(pAgpInterface->Context);
                vpStatus = NO_ERROR;
            }
            else
            {
                vpStatus = ERROR_DEV_NOT_EXIST;
            }
        }
        else
        {
            pVideoDebugPrint((Warn, "VIDEOPRT: VideoPortQueryServices: Unsupported interface version\n"));
            vpStatus = ERROR_INVALID_PARAMETER;
        }
    }
    else if (VideoPortServicesI2C == servicesType)
    {
        if ((pInterface->Version == VIDEO_PORT_I2C_INTERFACE_VERSION_2) &&
            (pInterface->Size == sizeof (VIDEO_PORT_I2C_INTERFACE_2)))
        {
            PVIDEO_PORT_I2C_INTERFACE_2 pI2CInterface = (PVIDEO_PORT_I2C_INTERFACE_2)pInterface;

            pI2CInterface->Context = pHwDeviceExtension;
            pI2CInterface->InterfaceReference = VpInterfaceDefaultReference;
            pI2CInterface->InterfaceDereference = VpInterfaceDefaultDereference;
            pI2CInterface->I2CStart = I2CStart2;
            pI2CInterface->I2CStop = I2CStop2;
            pI2CInterface->I2CWrite = I2CWrite2;
            pI2CInterface->I2CRead = I2CRead2;

            //
            // Reference the interface before handing it out.
            //

            pI2CInterface->InterfaceReference(pI2CInterface->Context);
            vpStatus = NO_ERROR;
        }
        else if ((pInterface->Version == VIDEO_PORT_I2C_INTERFACE_VERSION_1) &&
            (pInterface->Size == sizeof (VIDEO_PORT_I2C_INTERFACE)))
        {
            PVIDEO_PORT_I2C_INTERFACE pI2CInterface = (PVIDEO_PORT_I2C_INTERFACE)pInterface;

            pI2CInterface->Context = pHwDeviceExtension;
            pI2CInterface->InterfaceReference = VpInterfaceDefaultReference;
            pI2CInterface->InterfaceDereference = VpInterfaceDefaultDereference;
            pI2CInterface->I2CStart = I2CStart;
            pI2CInterface->I2CStop = I2CStop;
            pI2CInterface->I2CWrite = I2CWrite;
            pI2CInterface->I2CRead = I2CRead;

            //
            // Reference the interface before handing it out.
            //

            pI2CInterface->InterfaceReference(pI2CInterface->Context);
            vpStatus = NO_ERROR;
        }
        else
        {
            pVideoDebugPrint((Warn, "VIDEOPRT: VideoPortQueryServices: Unsupported interface version\n"));
            vpStatus = ERROR_INVALID_PARAMETER;
        }
    }
    else if (VideoPortServicesInt10 == servicesType)
    {
        if ((pInterface->Version == VIDEO_PORT_INT10_INTERFACE_VERSION_1) &&
            (pInterface->Size == sizeof(VIDEO_PORT_INT10_INTERFACE)))
        {
            PVIDEO_PORT_INT10_INTERFACE pInt10 = (PVIDEO_PORT_INT10_INTERFACE)pInterface;

            pInt10->Context = pHwDeviceExtension;
            pInt10->InterfaceReference = VpInterfaceDefaultReference;
            pInt10->InterfaceDereference = VpInterfaceDefaultDereference;
            pInt10->Int10AllocateBuffer = VpInt10AllocateBuffer;
            pInt10->Int10FreeBuffer = VpInt10FreeBuffer;
            pInt10->Int10ReadMemory = VpInt10ReadMemory;
            pInt10->Int10WriteMemory = VpInt10WriteMemory;
            pInt10->Int10CallBios = VpInt10CallBios;

            //
            // Reference the interface before handing it out.
            //

            pInt10->InterfaceReference(pInt10->Context);
            vpStatus = NO_ERROR;
        }
        else
        {
            pVideoDebugPrint((Warn, "VIDEOPRT: VideoPortQueryServices: Unsupported interface version\n"));
            vpStatus = ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        pVideoDebugPrint((Warn, "VIDEOPRT: VideoPortQueryServices: Unsupported service type\n"));
        vpStatus = ERROR_INVALID_PARAMETER;
    }

    return vpStatus;
}   // VideoPortQueryServices()

VIDEOPORT_API
LONGLONG
VideoPortQueryPerformanceCounter(
    IN PVOID pHwDeviceExtension,
    OUT PLONGLONG pllPerformanceFrequency OPTIONAL
    )

/*++

Routine Description:

    This routine provides the finest grained running count available in the system.

    Use this routine as infrequently as possible. Depending on the platform,
    VideoPortQueryPerformanceCounter can disable system-wide interrupts for a minimal interval.
    Consequently, calling this routine frequently or repeatedly, as in an iteration, defeats its
    purpose of returning very fine-grained, running time-stamp information. Calling this routine
    too frequently can degrade I/O performance for the calling driver and for the system as a whole.

Arguments:

    pHwDeviceExtension      - Points to per-adapter device extension.
    pllPerformanceFrequency - Specifies an optional pointer to a variable that is to receive the
                              performance counter frequency.

Returns:

    The performance counter value in units of ticks.

--*/

{
    LARGE_INTEGER li;

    //
    // No ASSERT() allowed - nonpagable code.
    //

    li = KeQueryPerformanceCounter((PLARGE_INTEGER)pllPerformanceFrequency);
    return *((PLONGLONG) &li);
}   // VideoPortQueryPerformanceCounter()

VOID
VpInterfaceDefaultReference(
    IN PVOID pContext
    )

/*++

Routine Description:

    This routine is default callback for interfaces exposed from the videoprt.
    Should be called by the client before it starts using an interface.

Arguments:

    pContext - Context returned by the VideoPortQueryServices() in the
               pInterface->Context field.

--*/

{
    UNREFERENCED_PARAMETER(pContext);
    PAGED_CODE();
}   // VpInterfaceDefaultReference()

VOID
VpInterfaceDefaultDereference(
    IN PVOID pContext
    )

/*++

Routine Description:

    This routine is default callback for interfaces exposed from the videoprt.
    Should be called by the client when it stops using an interface.

Arguments:

    pContext - Context returned by the VideoPortQueryServices() in the
               pInterface->Context field.

--*/

{
    UNREFERENCED_PARAMETER(pContext);
    PAGED_CODE();
}   // VpInterfaceDefaultDereference()


BOOLEAN
VpEnableAdapterInterface(
    PDEVICE_SPECIFIC_EXTENSION DoSpecificExtension
    )

/*++

Routine Description:

    This routine registers and enables a display adapter interface.
    It also writes the interface name to the registry.
    
Arguments:

    DoSpecificExtension - Pointer to the functional device object 
                          specific extension.

--*/

{
    PFDO_EXTENSION fdoExtension = NULL;
    UNICODE_STRING SymbolicLinkName;
    BOOLEAN Success = FALSE;
    UNICODE_STRING VolatileSettingsString;
    OBJECT_ATTRIBUTES VolatileSettingsAttributes;
    HANDLE VolatileSettingsKey;

    PAGED_CODE();
    ASSERT ((DoSpecificExtension != NULL) && 
        (DoSpecificExtension->ExtensionType == TypeDeviceSpecificExtension));
    
    VolatileSettingsString.Buffer = NULL;

    fdoExtension = DoSpecificExtension->pFdoExtension;
    ASSERT (IS_FDO(fdoExtension));

    if (fdoExtension->PhysicalDeviceObject == NULL) {
    
        //
        // This fdo doesn't have a physical device object (e.g. vga).
        // In this case, we can't create an interface.
        //

        goto Fallout;
    }

    //
    // Register the interface
    //

    if (IoRegisterDeviceInterface(fdoExtension->PhysicalDeviceObject,
        &GUID_DISPLAY_ADAPTER_INTERFACE,
        NULL,
        &SymbolicLinkName) != STATUS_SUCCESS) {

        goto Fallout;
    }

    //
    // Enable the interface 
    //

    if (IoSetDeviceInterfaceState(&SymbolicLinkName, TRUE) != STATUS_SUCCESS) {

        goto Cleanup;
    }

    //
    // Write the interface name to registry
    //

    ASSERT (DoSpecificExtension->DriverRegistryPath != NULL);

    VolatileSettingsString.Length = 0;
    VolatileSettingsString.MaximumLength = 
        (USHORT)DoSpecificExtension->DriverRegistryPathLength + 40;
    VolatileSettingsString.Buffer = ExAllocatePoolWithTag(
        PagedPool | POOL_COLD_ALLOCATION,
        VolatileSettingsString.MaximumLength,
        VP_TAG);

    if (VolatileSettingsString.Buffer == NULL) {

        goto Cleanup;
    }

    if (RtlAppendUnicodeToString(&VolatileSettingsString, 
        DoSpecificExtension->DriverRegistryPath) != STATUS_SUCCESS) {
        
        goto Cleanup;
    }
    
    if (RtlAppendUnicodeToString(&VolatileSettingsString, 
        L"\\VolatileSettings") != STATUS_SUCCESS) {
        
        goto Cleanup;
    }

    InitializeObjectAttributes(&VolatileSettingsAttributes,
                               &VolatileSettingsString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    if (ZwCreateKey(&VolatileSettingsKey,
        GENERIC_READ | GENERIC_WRITE,
        &VolatileSettingsAttributes,
        0L,
        NULL,
        REG_OPTION_VOLATILE,
        NULL) != STATUS_SUCCESS) {
    
        goto Cleanup;
    }

    if (RtlWriteRegistryValue(
        RTL_REGISTRY_ABSOLUTE,
        VolatileSettingsString.Buffer,
        L"{5b45201d-f2f2-4f3b-85bb-30ff1f953599}",
        REG_BINARY,
        (PVOID)SymbolicLinkName.Buffer,
        SymbolicLinkName.Length) == STATUS_SUCCESS) {

        Success = TRUE;
    }

Cleanup:

    if (VolatileSettingsString.Buffer != NULL) {
    
        ExFreePool(VolatileSettingsString.Buffer);
    }

    RtlFreeUnicodeString(&SymbolicLinkName);

Fallout:

    if (Success) {

        pVideoDebugPrint((Trace, "VideoPort - Device interface ok.\n"));

    } else {
    
        pVideoDebugPrint((Warn, 
            "VideoPort - Couldn't register, enable or save the device interface.\n"));
    }

    return Success;

} //  VpEnableAdapterInterface


VOID
VpDisableAdapterInterface(
    PFDO_EXTENSION fdoExtension
    )

/*++

Routine Description:

    This routine disables the display adapter interface.
    
Arguments:

    fdoExtension - Pointer to the functional device object extension.

--*/

{
    PWSTR SymbolicLinkList = NULL;
    UNICODE_STRING SymbolicLinkName;

    PAGED_CODE();
    ASSERT ((fdoExtension != NULL) && IS_FDO(fdoExtension));

    if (fdoExtension->PhysicalDeviceObject == NULL) {
        
        //
        // This fdo doesn't have a physical device object (e.g. vga ...).
        // In this case, we didn't create any interface so there is 
        // nothing to disable.
        //

        return;
    }

    //
    // There is no need to remove the InterfaceName from the registry
    // as the parent key is volatile.
    //
    
    //
    // Disable the interface
    //

    if (IoGetDeviceInterfaces(&GUID_DISPLAY_ADAPTER_INTERFACE,
        fdoExtension->PhysicalDeviceObject,
        0,
        &SymbolicLinkList) != STATUS_SUCCESS) {

        pVideoDebugPrint((Warn, 
            "VideoPort - Could not find any enabled device interfaces.\n"));
        
        return;
    }
    
    RtlInitUnicodeString(&SymbolicLinkName, SymbolicLinkList);
    
    if (SymbolicLinkName.Length > 0) {

        if (IoSetDeviceInterfaceState(&SymbolicLinkName, 
            FALSE) != STATUS_SUCCESS) {
    
            pVideoDebugPrint((Warn, 
                "VideoPort - Could not disable the device interface.\n"));
        }
    }

    ExFreePool((PVOID)SymbolicLinkList);

} // VpDisableAdapterInterface


VOID
VpEnableNewRegistryKey(
    PFDO_EXTENSION FdoExtension,
    PDEVICE_SPECIFIC_EXTENSION DoSpecificExtension,
    PUNICODE_STRING RegistryPath,
    ULONG RegistryIndex
    )
{
    PKEY_VALUE_PARTIAL_INFORMATION GUIDBuffer = NULL;
    ULONG GUIDLength = 0;
    LPWSTR Buffer = NULL;
    HANDLE GuidKey = NULL;
    HANDLE NewDeviceKey = NULL;
    HANDLE ServiceSubKey = NULL;
    UNICODE_STRING UnicodeString, newGuidStr;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG Len;
    GUID newGuid;
    BOOLEAN IsLegacy = FALSE;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    BOOLEAN IsNewKey = FALSE;
    PWSTR pService = NULL;
    ULONG ServiceLen = 0;

    ASSERT((DoSpecificExtension->DriverNewRegistryPath == NULL) &&
           (DoSpecificExtension->DriverNewRegistryPathLength == 0));

    ASSERT(DoSpecificExtension->DriverOldRegistryPath != NULL);

    ASSERT(EnableNewRegistryKey);

    newGuidStr.Buffer = NULL;

    //
    // Get the service name
    //
    
    pService = RegistryPath->Buffer + 
               (RegistryPath->Length / sizeof(WCHAR)) - 1;

    while ((pService > RegistryPath->Buffer) &&
           (*pService != L'\\')) {
        
        pService--;
        ServiceLen++;
    }

    ASSERT (*pService == L'\\');
    pService++;

    Buffer = (LPWSTR)ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION, 
                                           (ServiceLen + 1) * sizeof(WCHAR), 
                                           VP_TAG);

    if (Buffer == NULL) {

        pVideoDebugPrint((Error, 
            "VIDEOPRT: VpEnableNewRegistryKey: failed to allocate memory.\n"));
        goto Fallout;
    }

    RtlZeroMemory(Buffer, (ServiceLen + 1) * sizeof(WCHAR));

    wcsncpy(Buffer, pService, ServiceLen);

    pService = Buffer;
    Buffer = NULL;

    //
    // Try to open the PnP device key
    //

    if ((FdoExtension->PhysicalDeviceObject == NULL) ||
        (IoOpenDeviceRegistryKey(FdoExtension->PhysicalDeviceObject,
                                 PLUGPLAY_REGKEY_DEVICE, 
                                 KEY_READ | KEY_WRITE,
                                 &GuidKey) != STATUS_SUCCESS)) {
    
        //
        // We failed to open the PnP device key.
        // Try to open the service subkey instead.
        //

        if (!VpGetServiceSubkey(RegistryPath,
                                &GuidKey)) {
        
            GuidKey = NULL;
            goto Fallout;
        }

        IsLegacy = TRUE;
    } 
        
    //
    // Is the GUID there?
    //

    RtlInitUnicodeString(&UnicodeString, SZ_GUID);

    ntStatus = ZwQueryValueKey(GuidKey,
                               &UnicodeString,
                               KeyValuePartialInformation,
                               (PVOID)NULL,
                               0,
                               &GUIDLength);

    if ((ntStatus == STATUS_BUFFER_OVERFLOW) ||
        (ntStatus == STATUS_BUFFER_TOO_SMALL)) {

        //
        // The GUID is there.
        // Allocate a buffer large enough to contain the entire key data value.
        //
    
        GUIDBuffer = ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION, 
                                           GUIDLength,
                                           VP_TAG);
        
        if (GUIDBuffer == NULL) {
            
            pVideoDebugPrint((Error, 
                "VIDEOPRT: VpEnableNewRegistryKey: failed to allocate memory.\n"));
            goto Fallout;
        }
    
        //
        // Get the GUID from the registry
        //
    
        ntStatus = ZwQueryValueKey(GuidKey,
                                   &UnicodeString,
                                   KeyValuePartialInformation,
                                   GUIDBuffer,
                                   GUIDLength,
                                   &GUIDLength);

        if (!NT_SUCCESS(ntStatus)) {
            
            pVideoDebugPrint((Error, 
                "VIDEOPRT: VpEnableNewRegistryKey: failed to get the GUID from the registry.\n"));
            goto Fallout;
        }

        //
        // Build the new registry path
        //

        Len = (wcslen(SZ_VIDEO_DEVICES) + 8) * sizeof(WCHAR) + GUIDBuffer->DataLength;
        
        Buffer = (LPWSTR)ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION, 
                                               Len, 
                                               VP_TAG);

        if (Buffer == NULL) {

            pVideoDebugPrint((Error, 
                "VIDEOPRT: VpEnableNewRegistryKey: failed to allocate memory.\n"));
            goto Fallout;
        }

        RtlZeroMemory(Buffer, Len);
        
        wcscpy(Buffer, SZ_VIDEO_DEVICES);
        wcscat(Buffer, L"\\");
        wcsncpy(Buffer + wcslen(Buffer), 
                (LPWSTR)GUIDBuffer->Data,
                GUIDBuffer->DataLength / sizeof(WCHAR));
        
        ASSERT (RegistryIndex <= 9999);
        swprintf(Buffer + wcslen(Buffer), L"\\%04d", RegistryIndex);

        //
        // Is the key already there?
        //
        
        if (RtlCheckRegistryKey(RTL_REGISTRY_ABSOLUTE, 
                                Buffer) != STATUS_SUCCESS) {
        
            //
            // Create the new key
            //

            if (RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE, 
                                     Buffer) != STATUS_SUCCESS) {

                pVideoDebugPrint((Error, 
                    "VIDEOPRT: VpEnableNewRegistryKey: failed to create the new key.\n"));
                goto Fallout;
            }

            //
            // Initialize the key
            //

            if (IsLegacy) {
            
                VpInitializeLegacyKey(DoSpecificExtension->DriverOldRegistryPath,
                                      Buffer);
            } else {
            
                VpInitializeKey(FdoExtension->PhysicalDeviceObject, 
                                Buffer);
            }
        }

    } else {
    
        //
        // The GUID is not there so allocate a new one
        //
        // !!! Add special case for VGA, MNMDD & RDPCDD 
        //

        ntStatus = ExUuidCreate(&newGuid);

        if ((ntStatus != STATUS_SUCCESS) && 
            (ntStatus != RPC_NT_UUID_LOCAL_ONLY)) {

            pVideoDebugPrint((Error, 
                "VIDEOPRT: VpEnableNewRegistryKey: failed to create a new GUID.\n"));
            goto Fallout;
        }

        if (RtlStringFromGUID(&newGuid, &newGuidStr) != STATUS_SUCCESS) {

            pVideoDebugPrint((Error, 
                "VIDEOPRT: VpEnableNewRegistryKey: failed to convert the GUID to a string.\n"));
            newGuidStr.Buffer = NULL;
            goto Fallout;
        }

        //
        // Upcase the string
        //

        RtlUpcaseUnicodeString(&newGuidStr, &newGuidStr, FALSE);

        //
        // Build the new registry path
        //

        Len = (wcslen(SZ_VIDEO_DEVICES) + 
               wcslen(newGuidStr.Buffer) + 
               wcslen(SZ_COMMON_SUBKEY) + 8) * sizeof(WCHAR);
        
        Buffer = (LPWSTR)ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION, 
                                               Len, 
                                               VP_TAG);

        if (Buffer == NULL) {

            pVideoDebugPrint((Error, 
                "VIDEOPRT: VpEnableNewRegistryKey: failed to allocate memory.\n"));
            goto Fallout;
        }

        RtlZeroMemory(Buffer, Len);
        
        wcscpy(Buffer, SZ_VIDEO_DEVICES);
        
        if (RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE, 
                                 Buffer) != STATUS_SUCCESS) {
        
            pVideoDebugPrint((Error, 
                "VIDEOPRT: VpEnableNewRegistryKey: failed to create the new key.\n"));
            goto Fallout;
        }

        wcscat(Buffer, L"\\");
        wcscat(Buffer, newGuidStr.Buffer);
        
        if (RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE, 
                                 Buffer) != STATUS_SUCCESS) {
        
            pVideoDebugPrint((Error, 
                "VIDEOPRT: VpEnableNewRegistryKey: failed to create the new key.\n"));
            goto Fallout;
        }

        //
        // Save the service name
        //

        Len = wcslen(Buffer);
        
        wcscat(Buffer, L"\\");
        wcscat(Buffer, SZ_COMMON_SUBKEY);

        if (RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE, 
                                 Buffer) != STATUS_SUCCESS) {
        
            pVideoDebugPrint((Error, 
                "VIDEOPRT: VpEnableNewRegistryKey: failed to create the new key.\n"));
            goto Fallout;
        }

        if (RtlWriteRegistryValue(
                RTL_REGISTRY_ABSOLUTE,
                Buffer,
                SZ_SERVICE,
                REG_SZ,
                (PVOID)pService,
                (ServiceLen + 1) * sizeof(WCHAR)) != STATUS_SUCCESS) {
            
            pVideoDebugPrint((Error, 
                "VIDEOPRT: VpEnableNewRegistryKey: failed to save the service name.\n"));
            goto Fallout;
        }

        if (IsLegacy) {

            ServiceSubKey = GuidKey;
        
        } else {
        
            if (!VpGetServiceSubkey(RegistryPath,
                                    &ServiceSubKey)) {
                
                ServiceSubKey = NULL;
            }
        }

        if (ServiceSubKey != NULL) {
        
            if (RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                      ServiceSubKey,
                                      SZ_SERVICE,
                                      REG_SZ,
                                      (PVOID)pService,
                                      (ServiceLen + 1) * sizeof(WCHAR)) != STATUS_SUCCESS) {

                pVideoDebugPrint((Error, 
                    "VIDEOPRT: VpEnableNewRegistryKey: failed to save the service name.\n"));
                goto Fallout;
            }
        }

        //
        // Create the 000X subkey
        //

        Buffer[Len] = 0;

        ASSERT (RegistryIndex == 0);
        wcscat(Buffer, L"\\0000");

        if (RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE, 
                                 Buffer) != STATUS_SUCCESS) {
        
            pVideoDebugPrint((Error, 
                "VIDEOPRT: VpEnableNewRegistryKey: failed to create the new key.\n"));
            goto Fallout;
        }

        //
        // Save the new key under the PnP device key or the service subkey
        //

        if (RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                  GuidKey,
                                  SZ_GUID,
                                  REG_SZ,
                                  (PVOID)newGuidStr.Buffer,
                                  (wcslen(newGuidStr.Buffer) + 1) * sizeof(WCHAR)) != STATUS_SUCCESS) {

            pVideoDebugPrint((Error, 
                "VIDEOPRT: VpEnableNewRegistryKey: failed to write the new GUID to the registry.\n"));
            goto Fallout;
        }

        //
        // The key was not there, so initialize it.
        //

        if (IsLegacy) {

            VpInitializeLegacyKey(DoSpecificExtension->DriverOldRegistryPath,
                                  Buffer);
        } else {

            VpInitializeKey(FdoExtension->PhysicalDeviceObject, 
                            Buffer);
        }
    }

    pVideoDebugPrint((Info, "VIDEOPRT: VpEnableNewRegistryKey: %ws\n", Buffer));

    //
    // Initialize the new registry path fields
    //

    DoSpecificExtension->DriverNewRegistryPath = Buffer;
    DoSpecificExtension->DriverNewRegistryPathLength = wcslen(Buffer) * sizeof(WCHAR);

Fallout:
    
    //
    // Cleanup
    //

    if (GUIDBuffer != NULL) {
        ExFreePool(GUIDBuffer);
    }

    if (newGuidStr.Buffer != NULL) {
        RtlFreeUnicodeString(&newGuidStr);
    }
    
    if ((DoSpecificExtension->DriverNewRegistryPath == NULL) && 
        (Buffer != NULL)) {
        ExFreePool(Buffer);
    }
    
    if (GuidKey != NULL) {
        ZwClose(GuidKey);
    }

    if (!IsLegacy && (ServiceSubKey != NULL)) {
        ZwClose(ServiceSubKey);
    }

    if (pService != NULL) {
        ExFreePool(pService);
    }

    return;

} // VpEnableNewRegistryKey


VOID
VpInitializeKey(
    PDEVICE_OBJECT PhysicalDeviceObject,
    PWSTR NewRegistryPath
    )
{
    HANDLE NewDeviceKey = NULL;
    HANDLE DriverKey = NULL;
    HANDLE DriverSettingsKey = NULL;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;

    ASSERT (PhysicalDeviceObject != NULL);
    ASSERT (NewRegistryPath != NULL);

    //
    // Open the new key
    //

    RtlInitUnicodeString(&UnicodeString, NewRegistryPath);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    if (ZwOpenKey(&NewDeviceKey,
                  KEY_ALL_ACCESS,
                  &ObjectAttributes) != STATUS_SUCCESS) {

        pVideoDebugPrint((Error, 
            "VIDEOPRT: VpInitializeKey: failed to open the new key.\n"));
        NewDeviceKey = NULL;
        goto Fallout;
    }

    //
    // Open the PnP driver key
    //

    if (IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                PLUGPLAY_REGKEY_DRIVER, 
                                KEY_READ | KEY_WRITE,
                                &DriverKey) != STATUS_SUCCESS) {

        pVideoDebugPrint((Error, 
            "VIDEOPRT: VpInitializeKey: could not open the driver key.\n"));
        
        DriverKey = NULL;
        goto Fallout;
    }

    RtlInitUnicodeString(&UnicodeString, SZ_INITIAL_SETTINGS);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               DriverKey,
                               NULL);

    //
    // Open the "Settings" key.
    // The class installer saved the initial settings there.
    //

    if (ZwOpenKey(&DriverSettingsKey,
                  GENERIC_READ | GENERIC_WRITE,
                  &ObjectAttributes) != STATUS_SUCCESS) {
        
        pVideoDebugPrint((Error, 
            "VIDEOPRT: VpInitializeKey: failed to open the driver settings key.\n"));
        
        DriverSettingsKey = NULL;
        goto Fallout;
    }

    //
    // Copy the settings
    //

    VpCopyRegistry(DriverSettingsKey, 
                   NewDeviceKey,
                   NULL,
                   NULL);

Fallout:

    if (DriverSettingsKey != NULL) {
        ZwClose(DriverSettingsKey);
    }

    if (DriverKey != NULL) {
        ZwClose(DriverKey);
    }

    if (NewDeviceKey != NULL) {
        ZwClose(NewDeviceKey);
    }

} // VpInitializeKey


VOID
VpInitializeLegacyKey(
    PWSTR OldRegistryPath,
    PWSTR NewRegistryPath
    )
{
    HANDLE NewDeviceKey = NULL;
    HANDLE OldDeviceKey = NULL;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;

    ASSERT (NewRegistryPath != NULL);

    //
    // Open the new key
    //

    RtlInitUnicodeString(&UnicodeString, NewRegistryPath);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    if (ZwOpenKey(&NewDeviceKey,
                  KEY_ALL_ACCESS,
                  &ObjectAttributes) != STATUS_SUCCESS) {

        pVideoDebugPrint((Error, 
            "VIDEOPRT: VpInitializeLegacyKey: failed to open the new key.\n"));
        NewDeviceKey = NULL;
        goto Fallout;
    }

    //
    // Open the old key
    //

    RtlInitUnicodeString(&UnicodeString, 
                         OldRegistryPath);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    if (ZwOpenKey(&OldDeviceKey,
                  GENERIC_READ | GENERIC_WRITE,
                  &ObjectAttributes) != STATUS_SUCCESS) {
        
        pVideoDebugPrint((Error, 
            "VIDEOPRT: VpInitializeLegacyKey: failed to open the old key.\n"));
        OldDeviceKey = NULL;
        goto Fallout;
    }

    //
    // Copy the settings
    //

    VpCopyRegistry(OldDeviceKey, 
                   NewDeviceKey,
                   NULL,
                   NULL);

Fallout:

    if (NewDeviceKey != NULL) {
        ZwClose(NewDeviceKey);
    }

    if (OldDeviceKey != NULL) {
        ZwClose(OldDeviceKey);
    }

} // VpInitializeLegacyKey


NTSTATUS
VpCopyRegistry(
    HANDLE hKeyRootSrc,
    HANDLE hKeyRootDst,
    PWSTR SrcKeyPath,
    PWSTR DstKeyPath 
    )

/*++

Routine Description:

    This routine recursively copies a src key to a destination key.  
    
Arguments:

    hKeyRootSrc: Handle to root src key

    hKeyRootDst: Handle to root dst key

    SrcKeyPath:  src root key relative path to the subkey which needs to be
                 recursively copied. if this is null SourceKey is the key
                 from which the recursive copy is to be done.

    DstKeyPath:  dst root key relative path to the subkey which needs to be
                 recursively copied.  if this is null DestinationKey is the key
                 from which the recursive copy is to be done.

Return Value:

    Status is returned.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    HANDLE hKeySrc = NULL, hKeyDst = NULL;
    ULONG ResultLength, Index;
    PKEY_BASIC_INFORMATION KeyInfo;
    PKEY_VALUE_FULL_INFORMATION ValueInfo;
    PWSTR ValueName;
    ULONG BufferSize = 512;
    PVOID Buffer = NULL;

    //
    // Get a handle to the source key
    //

    if(SrcKeyPath == NULL) {
        
        hKeySrc = hKeyRootSrc;
    
    } else {
        
        //
        // Open the Src key
        //

        RtlInitUnicodeString(&UnicodeString, SrcKeyPath);
                                                            
        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeString,    
                                   OBJ_CASE_INSENSITIVE,
                                   hKeyRootSrc,
                                   NULL);
        
        Status = ZwOpenKey(&hKeySrc,
                           KEY_READ,
                           &ObjectAttributes);

        if(!NT_SUCCESS(Status)) {
            
            pVideoDebugPrint((Error, 
                "VIDEOPRT: VpCopyRegistry: failed to open the source key.\n"));
            
            hKeySrc = NULL;
            goto Fallout;
        }
    }

    //
    // Get a handle to the destination key
    //

    if(DstKeyPath == NULL) {

        hKeyDst = hKeyRootDst;

    } else {

        //
        // Create the destination key.
        //

        RtlInitUnicodeString(&UnicodeString, DstKeyPath);
                                                            
        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeString,    
                                   OBJ_CASE_INSENSITIVE,
                                   hKeyRootDst,
                                   NULL);

        Status = ZwCreateKey(&hKeyDst,
                             GENERIC_READ | GENERIC_WRITE,
                             &ObjectAttributes,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             NULL);

        if (!NT_SUCCESS(Status)) {

            pVideoDebugPrint((Error, 
                "VIDEOPRT: VpCopyRegistry: failed to create the destination key.\n"));
            
            hKeyDst = NULL;
            goto Fallout;
        }
    }

    //
    // Enumerate all keys in the source key and recursively 
    // create all subkeys
    //

    for (Index = 0; ;Index++) {

        do {
            
            if (Buffer == NULL) {

                Buffer = ExAllocatePoolWithTag(PagedPool,
                                               BufferSize,
                                               VP_TAG);

                if (Buffer == NULL) {

                    pVideoDebugPrint((Error, 
                        "VIDEOPRT: VpCopyRegistry: failed to allocate memory.\n"));
                    goto Fallout;
                }
            }

            Status = ZwEnumerateKey(hKeySrc,
                                    Index,
                                    KeyBasicInformation,
                                    Buffer,
                                    BufferSize - sizeof(WCHAR),
                                    &ResultLength);

            if (Status == STATUS_BUFFER_TOO_SMALL) {

                ExFreePool(Buffer);
                Buffer = NULL; 
                BufferSize = ResultLength + sizeof(WCHAR); 
            }

        } while (Status == STATUS_BUFFER_TOO_SMALL);

        KeyInfo = (PKEY_BASIC_INFORMATION)Buffer;

        if (!NT_SUCCESS(Status)) {

            if(Status == STATUS_NO_MORE_ENTRIES) {
    
                Status = STATUS_SUCCESS;
    
            } else {
    
                pVideoDebugPrint((Error, 
                    "VIDEOPRT: VpCopyRegistry: failed to enumerate the subkeys.\n"));
            }
    
            break;
        }

        //
        // Zero-terminate the subkey name 
        //

        KeyInfo->Name[KeyInfo->NameLength / sizeof(WCHAR)] = 0;

        //
        // Copy the subkey
        //

        Status = VpCopyRegistry(hKeySrc,
                                hKeyDst,
                                KeyInfo->Name,
                                KeyInfo->Name);
    }

    //
    // Enumerate all values in the source key and create all the values
    // in the destination key
    //

    for(Index = 0; ;Index++) {

        do {
            
            if (Buffer == NULL) {

                Buffer = ExAllocatePoolWithTag(PagedPool,
                                               BufferSize,
                                               VP_TAG);

                if (Buffer == NULL) {

                    pVideoDebugPrint((Error, 
                        "VIDEOPRT: VpCopyRegistry: failed to allocate memory.\n"));
                    goto Fallout;
                }
            }

            Status = ZwEnumerateValueKey(hKeySrc,
                                         Index,
                                         KeyValueFullInformation,
                                         Buffer,
                                         BufferSize,
                                         &ResultLength);

            if (Status == STATUS_BUFFER_TOO_SMALL) {

                ExFreePool(Buffer);
                Buffer = NULL; 
                BufferSize = ResultLength; 
            }

        } while (Status == STATUS_BUFFER_TOO_SMALL);

        ValueInfo = (PKEY_VALUE_FULL_INFORMATION)Buffer;

        if(!NT_SUCCESS(Status)) {
            
            if(Status == STATUS_NO_MORE_ENTRIES) {

                Status = STATUS_SUCCESS;

            } else {

                pVideoDebugPrint((Error, 
                    "VIDEOPRT: VpCopyRegistry: failed to enumerate the values.\n"));
            }
            
            break;
        }

        //
        // Process the value found and create the value in the destination key
        //

        ValueName = (PWSTR)
            ExAllocatePoolWithTag(PagedPool,
                                  ValueInfo->NameLength + sizeof(WCHAR),
                                  VP_TAG);

        if (ValueName == NULL) {
        
            pVideoDebugPrint((Error, 
                "VIDEOPRT: VpCopyRegistry: failed to allocate memory.\n"));
            goto Fallout;
        }

        wcsncpy(ValueName, 
                ValueInfo->Name, 
                (ValueInfo->NameLength)/sizeof(WCHAR));

        ValueName[(ValueInfo->NameLength)/sizeof(WCHAR)] = 0;

        RtlInitUnicodeString(&UnicodeString, ValueName);
    
        Status = ZwSetValueKey(hKeyDst,
                               &UnicodeString,
                               ValueInfo->TitleIndex,
                               ValueInfo->Type,
                               (PVOID)((PUCHAR)ValueInfo + ValueInfo->DataOffset),
                               ValueInfo->DataLength);
    
        if(!NT_SUCCESS(Status)) {

            pVideoDebugPrint((Error, 
                "VIDEOPRT: VpCopyRegistry: failed to set the value.\n"));
        }
    
        ExFreePool(ValueName);
    }

Fallout:

    //
    // Cleanup
    //

    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }

    if ((hKeySrc != NULL) && (hKeySrc != hKeyRootSrc)) {
        ZwClose(hKeySrc);
    }
    
    if ((hKeyDst != NULL) && (hKeyDst != hKeyRootDst)) {
        ZwClose(hKeyDst);
    }
    
    return(Status);

} // VpCopyRegistry


BOOLEAN
VpGetServiceSubkey(
    PUNICODE_STRING RegistryPath,
    HANDLE* pServiceSubKey
    )
{
    LPWSTR Buffer = NULL;
    USHORT Len = 0;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    BOOLEAN bSuccess = FALSE;

    Len = RegistryPath->Length + (wcslen(SZ_COMMON_SUBKEY) + 2) * sizeof(WCHAR);

    Buffer = (LPWSTR)ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION, Len, VP_TAG);

    if (Buffer == NULL) {

        pVideoDebugPrint((Error, 
            "VIDEOPRT: VpGetServiceSubkey: failed to allocate memory.\n"));
        goto Fallout;
    }

    RtlZeroMemory(Buffer, Len);
    
    wcsncpy(Buffer, 
            RegistryPath->Buffer,
            RegistryPath->Length / sizeof(WCHAR));
    
    wcscat(Buffer, L"\\");
    wcscat(Buffer, SZ_COMMON_SUBKEY);

    RtlInitUnicodeString(&UnicodeString, Buffer);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    if (ZwCreateKey(pServiceSubKey,
                    GENERIC_READ | GENERIC_WRITE,
                    &ObjectAttributes,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    NULL) != STATUS_SUCCESS) {

        pVideoDebugPrint((Error, 
            "VIDEOPRT: VpGetServiceSubkey: could not create the service subkey.\n"));
        goto Fallout;
    }

    bSuccess = TRUE;

Fallout:

    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }

    return bSuccess;

} // VpGetServiceSubkey

VP_STATUS
VideoPortGetVersion(
    PVOID HwDeviceExtension,
    PVPOSVERSIONINFO pVpOsVersionInfo
    )
{
    RTL_OSVERSIONINFOEXW VersionInformation;

    UNREFERENCED_PARAMETER(HwDeviceExtension);

    if(pVpOsVersionInfo->Size < sizeof(VPOSVERSIONINFO)) {

        return ERROR_INVALID_PARAMETER;
    }

    RtlZeroMemory ((PVOID)(&VersionInformation), sizeof(RTL_OSVERSIONINFOEXW));
    VersionInformation.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOEXW);

    if ( STATUS_SUCCESS !=  
         RtlGetVersion( (PRTL_OSVERSIONINFOW) (&VersionInformation)) ) {

        return ERROR_INVALID_PARAMETER;
    }

    pVpOsVersionInfo->MajorVersion = VersionInformation.dwMajorVersion;
    pVpOsVersionInfo->MinorVersion = VersionInformation.dwMinorVersion;
    pVpOsVersionInfo->BuildNumber = VersionInformation.dwBuildNumber;
    pVpOsVersionInfo->ServicePackMajor = VersionInformation.wServicePackMajor;
    pVpOsVersionInfo->ServicePackMinor = VersionInformation.wServicePackMinor;
   
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\bank.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: bank.c
*
* Contains all the banking code for the display driver.
*
* It's helpful not to have to implement all the DDI drawing functionality
* in a driver (who wants to write the code to support true ROP4's with
* arbitrary sized patterns?).  Fortunately, we can punt to GDI for any
* drawing we don't want to do.  And if GDI can write directly on the frame
* buffer bits, performance won't even be toooo bad.
*
* NT's GDI can draw on any standard format frame buffer.  When the entire
* frame buffer can be mapped into main memory, it's very simple to set up:
* the display driver tells GDI the frame buffer format and location, and
* GDI can then just draw directly.
*
* When only one bank of the frame buffer can be mapped into main memory
* at one time (e.g., there is a moveable 64k aperture) things are not
* nearly so easy.  For every bank spanned by a drawing operation, we have
* to set the hardware to the bank, and call back to GDI.  We tell GDI
* to draw only on the mapped-in bank by mucking with the drawing call's
* CLIPOBJ.
*
* This module contains the code for doing all banking support.
*
* This code supports 8, 16 and 32bpp colour depths, arbitrary bank
* sizes, and handles 'broken rasters' (which happens when the bank size
* is not a multiple of the scan length; some scans will end up being
* split over two separate banks).
*
* Note:  If you mess with this code and break it, you can expect to get
*        random access violations on call-backs in internal GDI routines
*        that are very hard to debug.
*
* Copyright (c) 1993-1998 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

////////////////////////////////////////////////////////////////////////////
// Old 911/924 Banking
//
// NOTE: It is the caller's responsibility to acquire the CRTC crtical
//       section before calling these routines, in all cases!

VOID vOldBankSelectMode(        // Note: If this function changes, must
PDEV*        ppdev,             //   change Asm routines!
BANKDATA*    pbd,
BANK_MODE    bankm)
{
    BYTE    jMemCfg;

    if (bankm == BANK_ON)
    {
        // Make sure the processor graphics engine is idle before we start
        // drawing:

        while (INPW(ppdev->pjIoBase, pbd->ulGp_stat_cmd) & 0x0200)
            ;
    }
    else if (bankm == BANK_ENABLE)
    {
        // Enable the memory aperture after exiting full-screen:

        OUTP(ppdev->pjIoBase, CRTC_INDEX, S3R1);
        jMemCfg = INP(ppdev->pjIoBase, CRTC_DATA);
        OUTP(ppdev->pjIoBase, CRTC_DATA, jMemCfg | CPUA_BASE);
    }
}

VOID vOldBankMap(
PDEV*       ppdev,
BANKDATA*   pbd,
LONG        iBank)
{
    OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulRegisterLock_35 | ((iBank & 0x0F) << 8));

    // Supposedly, there's a chip bug and we have to read this back in:

    INP(ppdev->pjIoBase, CRTC_DATA);
}

VOID vOldBankInitialize(
PDEV*       ppdev,
BANKDATA*   pbd,
BOOL        bMmIo)
{
    BYTE jMemCfg;

    // Enable the memory aperture:

    OUTP(ppdev->pjIoBase, CRTC_INDEX, S3R1);
    jMemCfg = INP(ppdev->pjIoBase, CRTC_DATA);
    OUTP(ppdev->pjIoBase, CRTC_DATA, jMemCfg | CPUA_BASE);

    // Read the default values of the registers that we'll be using:

    OUTP(ppdev->pjIoBase, CRTC_INDEX, 0x35);
    pbd->ulRegisterLock_35
        = ((INP(ppdev->pjIoBase, CRTC_DATA) << 8) | 0x35) & ~0x0F00;

    pbd->ulGp_stat_cmd = 0x9ae8;
}

////////////////////////////////////////////////////////////////////////////
// New 801/805/805i/928/928PCI Banking
//
// NOTE: It is the caller's responsibility to acquire the CRTC crtical
//       section before calling these routines, in all cases!

VOID vNewBankSelectMode(        // Note: If this function changes, must
PDEV*        ppdev,             //   change Asm routines!
BANKDATA*    pbd,
BANK_MODE    bankm)
{
    BYTE jMemCfg;

    if ((bankm == BANK_ON) || (bankm == BANK_ON_NO_WAIT))
    {
        //////////////////////////////////////////////////////////////////
        // Enable Banking
        //
        // Make sure the processor graphics engine is idle before we start
        // drawing:

        if (bankm != BANK_ON_NO_WAIT)
        {
            do {;} while (INPW(ppdev->pjIoBase, pbd->ulGp_stat_cmd) & 0x0200);
        }

        // Disable memory mapped I/O:

        OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulExtendedMemoryControl_53);

        // Disable enhanced register access and enable fast write buffer:

        OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulSystemConfiguration_40 | 0x0800);

        // Enable linear addressing:

        OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulLinearAddressWindowControl_58 | 0x1000);
    }
    else
    {
        //////////////////////////////////////////////////////////////////
        // Disable Banking
        //
        // Be it BANK_OFF, BANK_ENABLE, or BANK_DISABLE, we'll turn off
        // direct access to the frame buffer.

        if (bankm == BANK_ENABLE)
        {
            // Enable the memory aperture:

            OUTP(ppdev->pjIoBase, CRTC_INDEX, S3R1);
            jMemCfg = INP(ppdev->pjIoBase, CRTC_DATA);
            OUTP(ppdev->pjIoBase, CRTC_DATA, jMemCfg | CPUA_BASE);
        }

        // Disable linear addressing:

        OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulLinearAddressWindowControl_58);

        // Enable enhanced register access and disable fast write buffer:

        OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulSystemConfiguration_40 | 0x0100);

        // Enable memory mapped I/O:

        OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulExtendedMemoryControl_53 |
                          pbd->ulEnableMemoryMappedIo);
    }
}

VOID vNewBankMap(
PDEV*       ppdev,
BANKDATA*   pbd,
LONG        iBank)
{
    OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulRegisterLock_35 | ((iBank & 0x0F) << 8));

    // The 801/805/928 chipsets have a timing bug where a word OUT cannot
    // be used to set register 0x51:

    OUTP(ppdev->pjIoBase, CRTC_INDEX, pbd->ulExtendedSystemControl2_51);

    OUTP(ppdev->pjIoBase, CRTC_DATA, ((pbd->ulExtendedSystemControl2_51) >> 8) |
                    ((iBank & 0x30) >> 2));

    // Supposedly, there's another S3 chip bug and we have to read this
    // back in:

    INP(ppdev->pjIoBase, CRTC_DATA);

    CP_EIEIO();
}

VOID vNewBankInitialize(
PDEV*       ppdev,
BANKDATA*   pbd,
BOOL        bMmIo)
{
    // Read the default values of the registers that we'll be using:

    OUTP(ppdev->pjIoBase, CRTC_INDEX, 0x35);
    pbd->ulRegisterLock_35
        = ((INP(ppdev->pjIoBase, CRTC_DATA) << 8) | 0x35) & ~0x0F00;

    OUTP(ppdev->pjIoBase, CRTC_INDEX, 0x51);
    pbd->ulExtendedSystemControl2_51
        = ((INP(ppdev->pjIoBase, CRTC_DATA) << 8) | 0x51) & ~0x0C00;

    OUTP(ppdev->pjIoBase, CRTC_INDEX, 0x53);
    pbd->ulExtendedMemoryControl_53
        = ((INP(ppdev->pjIoBase, CRTC_DATA) << 8) | 0x53) & ~0x1000;

    OUTP(ppdev->pjIoBase, CRTC_INDEX, 0x40);
    pbd->ulSystemConfiguration_40
        = ((INP(ppdev->pjIoBase, CRTC_DATA) << 8) | 0x40) & ~0x0900;

    // Only enable memory-mapped I/O if we're really going to use it
    // (some cards would crash when memory-mapped I/O was enabled):

    pbd->ulEnableMemoryMappedIo = (bMmIo) ? 0x1000 : 0x0000;

    // Make sure we use the current window size:

    OUTP(ppdev->pjIoBase, CRTC_INDEX, 0x58);
    pbd->ulLinearAddressWindowControl_58
        = ((INP(ppdev->pjIoBase, CRTC_DATA) << 8) | 0x58) & ~0x1000;

    pbd->ulGp_stat_cmd = 0x9ae8;
}

////////////////////////////////////////////////////////////////////////////
// Newer 864/964 Banking
//
// NOTE: It is the caller's responsibility to acquire the CRTC crtical
//       section before calling these routines, in all cases!

VOID vNewerBankSelectMode(      // Note: If this function changes, must
PDEV*        ppdev,             //   change Asm routines!
BANKDATA*    pbd,
BANK_MODE    bankm)
{
    BYTE jMemCfg;

    if ((bankm == BANK_ON) || (bankm == BANK_ON_NO_WAIT))
    {
        //////////////////////////////////////////////////////////////////
        // Enable Banking
        //
        // Make sure the processor graphics engine is idle before we start
        // drawing:

        if (bankm != BANK_ON_NO_WAIT)
        {
            do {;} while (INPW(ppdev->pjIoBase, pbd->ulGp_stat_cmd) & 0x0200);
        }

        // Disable memory mapped I/O:

        OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulExtendedMemoryControl_53);

        // Disable enhanced register access and enable fast write buffer:

        OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulSystemConfiguration_40 | 0x0800);

        // Enable linear addressing:

        OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulLinearAddressWindowControl_58 | 0x1000);
    }
    else
    {
        //////////////////////////////////////////////////////////////////
        // Disable Banking
        //
        // Be it BANK_OFF, BANK_ENABLE, or BANK_DISABLE, we'll turn off
        // direct access to the frame buffer.

        if (bankm == BANK_ENABLE)
        {
            // Enable the memory aperture:

            OUTP(ppdev->pjIoBase, CRTC_INDEX, S3R1);
            jMemCfg = INP(ppdev->pjIoBase, CRTC_DATA);
            OUTP(ppdev->pjIoBase, CRTC_DATA, jMemCfg | CPUA_BASE);

            // Since a zero in 'CR6A' causes 'CR31' and 'CR51' to be used
            // as the bank index, we have to make sure they map to bank zero:

            OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulRegisterLock_35);

            OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulExtendedSystemControl2_51);
        }

        // Disable linear addressing:

        OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulLinearAddressWindowControl_58);

        // Enable enhanced register access:

        OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulSystemConfiguration_40 | 0x0100);

        // Enable memory mapped I/O:

        OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulExtendedMemoryControl_53 | 0x1000);
    }
}

VOID vNewerBankMap(
PDEV*       ppdev,
BANKDATA*   pbd,
LONG        iBank)
{
    OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulExtendedSystemControl4_6a | (iBank << 8));
}

VOID vNewerBankInitialize(
PDEV*       ppdev,
BANKDATA*   pbd,
BOOL        bMmIo)
{
    // Read the default values of the registers that we'll be using:

    pbd->ulExtendedSystemControl4_6a = 0x6a;

    OUTP(ppdev->pjIoBase, CRTC_INDEX, 0x35);
    pbd->ulRegisterLock_35
        = ((INP(ppdev->pjIoBase, CRTC_DATA) << 8) | 0x35) & ~0x0F00;

    OUTP(ppdev->pjIoBase, CRTC_INDEX, 0x51);
    pbd->ulExtendedSystemControl2_51
        = ((INP(ppdev->pjIoBase, CRTC_DATA) << 8) | 0x51) & ~0x0C00;

    OUTP(ppdev->pjIoBase, CRTC_INDEX, 0x53);
    pbd->ulExtendedMemoryControl_53
        = ((INP(ppdev->pjIoBase, CRTC_DATA) << 8) | 0x53) & ~0x1000;

    OUTP(ppdev->pjIoBase, CRTC_INDEX, 0x40);
    pbd->ulSystemConfiguration_40
        = ((INP(ppdev->pjIoBase, CRTC_DATA) << 8) | 0x40) & ~0x0100;

    // Make sure we select the current window size:

    OUTP(ppdev->pjIoBase, CRTC_INDEX, 0x58);
    pbd->ulLinearAddressWindowControl_58
        = ((INP(ppdev->pjIoBase, CRTC_DATA) << 8) | 0x58) & ~0x1000;

    pbd->ulGp_stat_cmd = 0x9ae8;
}

////////////////////////////////////////////////////////////////////////////
// New MM I/O Banking
//
// NOTE: It is the caller's responsibility to acquire the CRTC crtical
//       section before calling these routines, in all cases!

VOID vNwBankSelectMode(
PDEV*        ppdev,
BANKDATA*    pbd,
BANK_MODE    bankm)
{
    BYTE jMemCfg;

    if (bankm == BANK_ON)
    {
        do {;} while (INPW(ppdev->pjIoBase, pbd->ulGp_stat_cmd) & 0x0200);
    }
    else if (bankm == BANK_ENABLE)
    {
        // Enable the memory aperture:

        OUTP(ppdev->pjIoBase, CRTC_INDEX, S3R1);
        jMemCfg = INP(ppdev->pjIoBase, CRTC_DATA);
        OUTP(ppdev->pjIoBase, CRTC_DATA, jMemCfg | CPUA_BASE);

        // Since a zero in 'CR6A' causes 'CR31' and 'CR51' to be used
        // as the bank index, we have to make sure they map to bank zero:

        OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulRegisterLock_35);

        OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulExtendedSystemControl2_51);

        // Enable linear addressing:

        OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulLinearAddressWindowControl_58 | 0x1000);

        // Enable enhanced register access:

        OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulSystemConfiguration_40 | 0x0100);

        // Enable memory-mapped I/O:

        OUTPW(ppdev->pjIoBase, CRTC_INDEX, pbd->ulExtendedMemoryControl_53 | 0x1000);
    }
}

VOID vNwBankMap(
PDEV*       ppdev,
BANKDATA*   pbd,
LONG        iBank)
{
}

VOID vNwBankInitialize(
PDEV*       ppdev,
BANKDATA*   pbd,
BOOL        bMmIo)
{
    // Read the default values of the registers that we'll be using:

    pbd->ulExtendedSystemControl4_6a = 0x6a;

    OUTP(ppdev->pjIoBase, CRTC_INDEX, 0x35);
    pbd->ulRegisterLock_35
        = ((INP(ppdev->pjIoBase, CRTC_DATA) << 8) | 0x35) & ~0x0F00;

    OUTP(ppdev->pjIoBase, CRTC_INDEX, 0x51);
    pbd->ulExtendedSystemControl2_51
        = ((INP(ppdev->pjIoBase, CRTC_DATA) << 8) | 0x51) & ~0x0C00;

    OUTP(ppdev->pjIoBase, CRTC_INDEX, 0x53);
    pbd->ulExtendedMemoryControl_53
        = ((INP(ppdev->pjIoBase, CRTC_DATA) << 8) | 0x53) & ~0x1000;

    OUTP(ppdev->pjIoBase, CRTC_INDEX, 0x40);
    pbd->ulSystemConfiguration_40
        = ((INP(ppdev->pjIoBase, CRTC_DATA) << 8) | 0x40);

    // Make sure we select the current window size:

    OUTP(ppdev->pjIoBase, CRTC_INDEX, 0x58);
    pbd->ulLinearAddressWindowControl_58
        = ((INP(ppdev->pjIoBase, CRTC_DATA) << 8) | 0x58) & ~0x1000;

    pbd->ulGp_stat_cmd = 0x9ae8;
}

/******************************Public*Routine******************************\
* BOOL bEnableBanking
*
\**************************************************************************/

BOOL bEnableBanking(
PDEV*   ppdev)
{
    CLIPOBJ*            pcoBank;
    SURFOBJ*            psoBank;
    SIZEL               sizl;
    HSURF               hsurf;
    FNBANKINITIALIZE*   pfnBankInitialize;
    LONG                lDelta;
    LONG                cjBank;
    LONG                cPower2;

    // Create a temporary clip object that we'll use for the bank
    // when we're given a Null or DC_TRIVIAL clip object:

    pcoBank = EngCreateClip();
    if (pcoBank == NULL)
        goto ReturnFalse;

    // We break every per-bank GDI call-back into simple rectangles:

    pcoBank->iDComplexity = DC_RECT;
    pcoBank->fjOptions    = OC_BANK_CLIP;

    // Create a GDI surface that we'll wrap around our bank in
    // call-backs:

    sizl.cx = ppdev->cxMemory;
    sizl.cy = ppdev->cyMemory;

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    ppdev->lDelta,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    ppdev->pjScreen);

    // Note that we hook zero calls -- after all, the entire point
    // of all this is to have GDI do all the drawing on the bank.
    // Once we're done the association, we can leave the surface
    // permanently locked:

    if ((hsurf == 0)                                        ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0))    ||
        (!(psoBank = EngLockSurface(hsurf))))
    {
        DISPDBG((0, "Failed wrapper surface creation"));

        EngDeleteSurface(hsurf);
        EngDeleteClip(pcoBank);

        goto ReturnFalse;
    }

    ppdev->pcoBank    = pcoBank;
    ppdev->psoBank    = psoBank;
    ppdev->pvBankData = &ppdev->aulBankData[0];

    if (ppdev->flCaps & CAPS_NEW_MMIO)
    {
        ppdev->bankmOnOverlapped = BANK_ON;
        ppdev->pfnBankMap        = vNwBankMap;
        ppdev->pfnBankSelectMode = vNwBankSelectMode;
        pfnBankInitialize        = vNwBankInitialize;
    }
    else if (ppdev->flCaps & CAPS_NEWER_BANK_CONTROL)
    {
        ppdev->bankmOnOverlapped = BANK_ON;
        ppdev->pfnBankMap        = vNewerBankMap;
        ppdev->pfnBankSelectMode = vNewerBankSelectMode;
        pfnBankInitialize        = vNewerBankInitialize;
    }
    else if (ppdev->flCaps & CAPS_NEW_BANK_CONTROL)
    {
        ppdev->bankmOnOverlapped = BANK_ON;
        ppdev->pfnBankMap        = vNewBankMap;
        ppdev->pfnBankSelectMode = vNewBankSelectMode;
        pfnBankInitialize        = vNewBankInitialize;
    }
    else
    {
        ppdev->bankmOnOverlapped = BANK_ON;
        ppdev->pfnBankMap        = vOldBankMap;
        ppdev->pfnBankSelectMode = vOldBankSelectMode;
        pfnBankInitialize        = vOldBankInitialize;
    }

    lDelta = ppdev->lDelta;
    cjBank = ppdev->cjBank;

    ASSERTDD(lDelta > 0, "Bad things happen with negative lDeltas");
    ASSERTDD(cjBank > lDelta, "Worse things happen with bad bank sizes");

    if (((lDelta & (lDelta - 1)) != 0) || ((cjBank & (cjBank - 1)) != 0))
    {
        // When either the screen stride or the bank size is not a power
        // of two, we have to use the slower 'bBankComputeNonPower2'
        // function for bank calculations, 'cause there can be broken
        // rasters and stuff:

        ppdev->pfnBankCompute = bBankComputeNonPower2;
    }
    else
    {
        // We can use the super duper fast bank calculator.  Yippie,
        // yahoo!  (I am easily amused.)

        cPower2 = 0;
        while (cjBank != lDelta)
        {
            cjBank >>= 1;
            cPower2++;
        }

        // We've just calculated that cjBank / lDelta = 2 ^ cPower2:

        ppdev->cPower2ScansPerBank = cPower2;

        while (cjBank != 1)
        {
            cjBank >>= 1;
            cPower2++;
        }

        // Continuing on, we've calculated that cjBank = 2 ^ cPower2:

        ppdev->cPower2BankSizeInBytes = cPower2;

        ppdev->pfnBankCompute = bBankComputePower2;
    }

    // Warm up the hardware:

    ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

    pfnBankInitialize(ppdev, ppdev->pvBankData,
                      ppdev->flCaps & (CAPS_MM_TRANSFER | CAPS_MM_IO));
    ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_ENABLE);

    RELEASE_CRTC_CRITICAL_SECTION(ppdev);

    DISPDBG((5, "Passed bEnableBanking"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableBanking!"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDisableBanking
*
\**************************************************************************/

VOID vDisableBanking(PDEV* ppdev)
{
    HSURF hsurf;

    if (ppdev->psoBank != NULL)
    {
        hsurf = ppdev->psoBank->hsurf;
        EngUnlockSurface(ppdev->psoBank);
        EngDeleteSurface(hsurf);
    }

    if (ppdev->pcoBank != NULL)
        EngDeleteClip(ppdev->pcoBank);
}

/******************************Public*Routine******************************\
* VOID vAssertModeBanking
*
\**************************************************************************/

VOID vAssertModeBanking(
PDEV*   ppdev,
BOOL    bEnable)
{
    // Inform the miniport bank code about the change in state:

    ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

    ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData,
                             bEnable ? BANK_ENABLE : BANK_DISABLE);

    RELEASE_CRTC_CRITICAL_SECTION(ppdev);
}

/******************************Public*Routine******************************\
* BOOL bBankComputeNonPower2
*
* Given the bounds of the drawing operation described by 'prclDraw',
* computes the bank number and rectangle bounds for the first engine
* call back.
*
* Returns the bank number, 'prclBank' is the bounds for the first
* call-back, and 'pcjOffset' is the adjustment for 'pvScan0'.
*
* This routine does a couple of divides for the bank calculation.  We
* don't use a look-up table for banks because it's not straight forward
* to use with broken rasters, and with large amounts of video memory
* and small banks, the tables could get large.  We'd probably use it
* infrequently enough that the memory manager would be swapping it
* in and out whenever we touched it.
*
* Returns TRUE if prclDraw is entirely contained in one bank; FALSE if
* prclDraw spans multiple banks.
*
\**************************************************************************/

BOOL bBankComputeNonPower2( // Type FNBANKCOMPUTE
PDEV*       ppdev,
RECTL*      prclDraw,       // Extents of drawing operation, in absolute
                            //  coordinates
RECTL*      prclBank,       // Returns bounds of drawing operation for this
                            //  bank, in absolute coordinates
LONG*       pcjOffset,      // Returns the byte offset for this bank
LONG*       piBank)         // Returns the bank number
{
    LONG cjBufferOffset;
    LONG iBank;
    LONG cjBank;
    LONG cjBankOffset;
    LONG cjBankRemainder;
    LONG cjScan;
    LONG cScansInBank;
    LONG cjScanRemainder;
    LONG lDelta;
    BOOL bOneBank;

    bOneBank = FALSE;
    lDelta   = ppdev->lDelta;

    cjBufferOffset  = prclDraw->top * lDelta
                    + CONVERT_TO_BYTES(prclDraw->left, ppdev);

    cjBank          = ppdev->cjBank;

    // iBank        = cjBufferOffset / cjBank;
    // cjBankOffset = cjBufferOffset % cjBank;

    QUOTIENT_REMAINDER(cjBufferOffset, cjBank, iBank, cjBankOffset);

    *piBank         = iBank;
    *pcjOffset      = iBank * cjBank;
    cjBankRemainder = cjBank - cjBankOffset;
    cjScan          = CONVERT_TO_BYTES((prclDraw->right - prclDraw->left),
                                        ppdev);

    if (cjBankRemainder < cjScan)
    {
        // Oh no, we've got a broken raster!

        prclBank->left   = prclDraw->left;
        prclBank->right  = prclDraw->left +
                           CONVERT_FROM_BYTES(cjBankRemainder, ppdev);
        prclBank->top    = prclDraw->top;
        prclBank->bottom = prclDraw->top + 1;
    }
    else
    {
        // cScansInBank    = cjBankRemainder / lDelta;
        // cjScanRemainder = cjBankRemainder % lDelta;

        ASSERTDD(lDelta > 0, "We assume positive lDelta here");

        QUOTIENT_REMAINDER(cjBankRemainder, lDelta,
                           cScansInBank, cjScanRemainder);

        if (cjScanRemainder >= cjScan)
        {
            // The bottom scan of the bank may be broken, but it breaks after
            // any drawing we'll be doing on that scan.  So we can simply
            // add the scan to this bank:

            cScansInBank++;
        }

        prclBank->left   = prclDraw->left;
        prclBank->right  = prclDraw->right;
        prclBank->top    = prclDraw->top;
        prclBank->bottom = prclDraw->top + cScansInBank;

        if (prclBank->bottom >= prclDraw->bottom)
        {
            prclBank->bottom  = prclDraw->bottom;
            bOneBank          = TRUE;
        }
    }

    return(bOneBank);
}

/******************************Public*Routine******************************\
* BOOL bBankComputePower2
*
* Functions the same as 'bBankComputeNonPower2', except that it is
* an accelerated special case for when both the screen stride and bank
* size are powers of 2.
*
\**************************************************************************/

BOOL bBankComputePower2(    // Type FNBANKCOMPUTE
PDEV*       ppdev,
RECTL*      prclDraw,       // Extents of drawing operation, in absolute
                            //  coordinates
RECTL*      prclBank,       // Returns bounds of drawing operation for this
                            //  bank, in absolute coordinates
LONG*       pcjOffset,      // Returns the byte offset for this bank
LONG*       piBank)         // Returns the bank number
{
    LONG iBank;
    LONG yTopNextBank;
    BOOL bOneBank;

    iBank        = prclDraw->top >> ppdev->cPower2ScansPerBank;
    yTopNextBank = (iBank + 1) << ppdev->cPower2ScansPerBank;
    *piBank      = iBank;
    *pcjOffset   = iBank << ppdev->cPower2BankSizeInBytes;

    prclBank->left   = prclDraw->left;
    prclBank->right  = prclDraw->right;
    prclBank->top    = prclDraw->top;
    prclBank->bottom = yTopNextBank;

    bOneBank = FALSE;
    if (prclBank->bottom >= prclDraw->bottom)
    {
        prclBank->bottom  = prclDraw->bottom;
        bOneBank          = TRUE;
    }

    return(bOneBank);
}

/******************************Public*Routine******************************\
* VOID vBankStart
*
* Given the bounds of the drawing operation described by 'prclDraw' and
* the original clip object, maps in the first bank and returns in
* 'pbnk->pco' and 'pbnk->pso' the CLIPOBJ and SURFOBJ to be passed to the
* engine for the first banked call-back.
*
* Note: This routine only supports the screen being the destination, and
*       not the source.  We have a separate, faster routine for doing
*       SRCCOPY reads from the screen, so it isn't worth the extra code
*       size to implement.
*
\**************************************************************************/

VOID vBankStart(
PDEV*       ppdev,      // Physical device information.
RECTL*      prclDraw,   // Rectangle bounding the draw area, in relative
                        //  coordinates.  Note that 'left' and 'right'
                        //  should be set for correct handling with broken
                        //  rasters.
CLIPOBJ*    pco,        // Original drawing clip object (may be modified).
BANK*       pbnk)       // Resulting bank information.
{
    LONG cjOffset;
    LONG xOffset;
    LONG yOffset;

    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        pco = ppdev->pcoBank;

        // Reset the clipping flag to trivial because we may have left
        // it as rectangular in a previous call:

        pco->iDComplexity = DC_TRIVIAL;

        // At the same time we convert to absolute coordinates, make sure
        // we won't try to enumerate past the bounds of the screen:

        pbnk->rclDraw.left       = prclDraw->left   + xOffset;
        pbnk->rclDraw.right      = prclDraw->right  + xOffset;

        pbnk->rclDraw.top
            = max(0,               prclDraw->top    + yOffset);
        pbnk->rclDraw.bottom
            = min(ppdev->cyMemory, prclDraw->bottom + yOffset);
    }
    else
    {
        pbnk->rclSaveBounds    = pco->rclBounds;
        pbnk->iSaveDComplexity = pco->iDComplexity;
        pbnk->fjSaveOptions    = pco->fjOptions;

        // Let GDI know that it has to pay attention to the clip object:

        pco->fjOptions |= OC_BANK_CLIP;

        // We have to honour the original clip object's rclBounds, so
        // intersect the drawing region with it, then convert to absolute
        // coordinates:

        pbnk->rclDraw.left
            = max(prclDraw->left,   pco->rclBounds.left)   + xOffset;
        pbnk->rclDraw.right
            = min(prclDraw->right,  pco->rclBounds.right)  + xOffset;
        pbnk->rclDraw.top
            = max(prclDraw->top,    pco->rclBounds.top)    + yOffset;
        pbnk->rclDraw.bottom
            = min(prclDraw->bottom, pco->rclBounds.bottom) + yOffset;
    }

    if ((pbnk->rclDraw.left > pbnk->rclDraw.right)
     || (pbnk->rclDraw.top  > pbnk->rclDraw.bottom))
    {
        // It's conceivable that we could get a situation where we have
        // an empty draw rectangle.

        pbnk->rclDraw.left   = 0;
        pbnk->rclDraw.right  = 0;
        pbnk->rclDraw.top    = 0;
        pbnk->rclDraw.bottom = 0;
    }

    if (!ppdev->pfnBankCompute(ppdev, &pbnk->rclDraw, &pco->rclBounds,
                               &cjOffset, &pbnk->iBank))
    {
        // The drawing operation spans multiple banks.  If the original
        // clip object was marked as trivial, we have to make sure to
        // change it to rectangular so that GDI knows to pay attention
        // to the bounds of the bank:

        if (pco->iDComplexity == DC_TRIVIAL)
            pco->iDComplexity = DC_RECT;
    }

    pbnk->ppdev = ppdev;
    pbnk->pco   = pco;
    pbnk->pso   = ppdev->psoBank;

    // Convert rclBounds and pvScan0 from absolute coordinates back to
    // relative.  When GDI calculates where to start drawing, it computes
    // pjDst = pso->pvScan0 + y * pso->lDelta + CONVERT_TO_BYTES(x, ppdev), where 'x'
    // and 'y' are relative coordinates.  We'll muck with pvScan0 to get
    // it pointing to the correct spot in the bank:

    pbnk->pso->pvScan0 = ppdev->pjScreen - cjOffset
                       + yOffset * ppdev->lDelta
                       + CONVERT_TO_BYTES(xOffset, ppdev);

    pbnk->pso->lDelta = ppdev->lDelta;  // Other functions muck with this value

    ASSERTDD((((ULONG_PTR) pbnk->pso->pvScan0) & 3) == 0,
             "Off-screen bitmaps must be dword aligned");

    pco->rclBounds.left   -= xOffset;
    pco->rclBounds.right  -= xOffset;
    pco->rclBounds.top    -= yOffset;
    pco->rclBounds.bottom -= yOffset;

    // Enable banking and map in bank iBank:

    ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

    ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_ON);
    ppdev->pfnBankMap(ppdev, ppdev->pvBankData, pbnk->iBank);

    RELEASE_CRTC_CRITICAL_SECTION(ppdev);
}

/******************************Public*Routine******************************\
* BOOL bBankEnum
*
* If there is another bank to be drawn on, maps in the bank and returns
* TRUE and the CLIPOBJ and SURFOBJ to be passed in the banked call-back.
*
* If there were no more banks to be drawn, returns FALSE.
*
\**************************************************************************/

BOOL bBankEnum(
BANK* pbnk)
{
    LONG     iBank;
    LONG     cjOffset;
    PDEV*    ppdev;
    CLIPOBJ* pco;
    LONG     xOffset;
    LONG     yOffset;

    ppdev   = pbnk->ppdev;
    pco     = pbnk->pco;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    // We check here to see if we have to handle the second part of
    // a broken raster.  Recall that pbnk->rclDraw is in absolute
    // coordinates, but pco->rclBounds is in relative coordinates:

    if (pbnk->rclDraw.right - xOffset != pco->rclBounds.right)
    {
        // The clip object's 'top' and 'bottom' are already correct:

        pco->rclBounds.left  = pco->rclBounds.right;
        pco->rclBounds.right = pbnk->rclDraw.right - xOffset;

        pbnk->pso->pvScan0 = (BYTE*) pbnk->pso->pvScan0 - ppdev->cjBank;
        pbnk->iBank++;

        ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

        ppdev->pfnBankMap(ppdev, ppdev->pvBankData, pbnk->iBank);

        RELEASE_CRTC_CRITICAL_SECTION(ppdev);

        return(TRUE);
    }

    if (pbnk->rclDraw.bottom > pco->rclBounds.bottom + yOffset)
    {
        // Advance the drawing area 'top' to account for the bank we've
        // just finished, and map in the new bank:

        pbnk->rclDraw.top = pco->rclBounds.bottom + yOffset;

        ppdev->pfnBankCompute(ppdev, &pbnk->rclDraw, &pco->rclBounds,
                              &cjOffset, &iBank);

        // Convert rclBounds back from absolute to relative coordinates:

        pco->rclBounds.left   -= xOffset;
        pco->rclBounds.right  -= xOffset;
        pco->rclBounds.top    -= yOffset;
        pco->rclBounds.bottom -= yOffset;

        // If we just finished handling a broken raster, we've already
        // got the bank mapped in:

        if (iBank != pbnk->iBank)
        {
            pbnk->iBank = iBank;
            pbnk->pso->pvScan0 = (BYTE*) pbnk->pso->pvScan0 - ppdev->cjBank;

            ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

            ppdev->pfnBankMap(ppdev, ppdev->pvBankData, iBank);

            RELEASE_CRTC_CRITICAL_SECTION(ppdev);
        }

        return(TRUE);
    }

    // We're done!  Turn off banking and reset the clip object if necessary:

    ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

    ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_OFF);

    RELEASE_CRTC_CRITICAL_SECTION(ppdev);

    if (pco != ppdev->pcoBank)
    {
        pco->rclBounds    = pbnk->rclSaveBounds;
        pco->iDComplexity = pbnk->iSaveDComplexity;
        pco->fjOptions    = pbnk->fjSaveOptions;
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vAlignedCopy
*
* Copies the given portion of a bitmap, using dword alignment for the
* screen.  Note that this routine has no notion of banking.
*
* Updates ppjDst and ppjSrc to point to the beginning of the next scan.
*
\**************************************************************************/

VOID vAlignedCopy(
PDEV*   ppdev,
BYTE**  ppjDst,
LONG    lDstDelta,
BYTE**  ppjSrc,
LONG    lSrcDelta,
LONG    cjScan,
LONG    cyScan,
BOOL    bDstIsScreen)
{
    BYTE* pjDst;
    BYTE* pjSrc;
    LONG  cjMiddle;
    LONG  culMiddle;
    LONG  cjStartPhase;
    LONG  cjEndPhase;

    pjSrc = *ppjSrc;
    pjDst = *ppjDst;

    cjStartPhase = (LONG)((0 - ((bDstIsScreen) ? (ULONG_PTR) pjDst
                                        : (ULONG_PTR) pjSrc)) & 3);
    cjMiddle     = cjScan - cjStartPhase;

    if (cjMiddle < 0)
    {
        cjStartPhase = 0;
        cjMiddle     = cjScan;
    }

    lSrcDelta -= cjScan;
    lDstDelta -= cjScan;            // Account for middle

    cjEndPhase = cjMiddle & 3;
    culMiddle  = cjMiddle >> 2;

    if (DIRECT_ACCESS(ppdev))
    {
        LONG i;

        ///////////////////////////////////////////////////////////////////
        // Portable bus-aligned copy
        //
        // 'memcpy' usually aligns to the destination, so we could call
        // it for that case, but unfortunately we can't be sure.  We
        // always want to align to the frame buffer:

        CP_MEMORY_BARRIER();

        if (bDstIsScreen)
        {
            // Align to the destination (implying that the source may be
            // unaligned):

            for (; cyScan > 0; cyScan--)
            {
                for (i = cjStartPhase; i > 0; i--)
                {
                    *pjDst++ = *pjSrc++;
                }

                for (i = culMiddle; i > 0; i--)
                {
                    *((ULONG*) pjDst) = *((ULONG UNALIGNED *) pjSrc);
                    pjSrc += sizeof(ULONG);
                    pjDst += sizeof(ULONG);
                }

                for (i = cjEndPhase; i > 0; i--)
                {
                    *pjDst++ = *pjSrc++;
                }

                pjSrc += lSrcDelta;
                pjDst += lDstDelta;
            }
        }
        else
        {
            // Align to the source (implying that the destination may be
            // unaligned):

            for (; cyScan > 0; cyScan--)
            {
                for (i = cjStartPhase; i > 0; i--)
                {
                    *pjDst++ = *pjSrc++;
                }
                if (ppdev->flCaps & CAPS_BAD_DWORD_READS)
                {
                    // #9 and Diamond 764 boards randomly fail in different
                    // spots on the HCTs, unless we do byte reads:

                    for (i = culMiddle; i > 0; i--)
                    {
                        *(pjDst)     = *(pjSrc);
                        *(pjDst + 1) = *(pjSrc + 1);
                        *(pjDst + 2) = *(pjSrc + 2);
                        *(pjDst + 3) = *(pjSrc + 3);

                        pjSrc += sizeof(ULONG);
                        pjDst += sizeof(ULONG);
                    }
                }
                else
                {
                    for (i = culMiddle; i > 0; i--)
                    {
                        if (ppdev->flCaps & CAPS_FORCE_DWORD_REREADS)
                            {
                                //
                                // On fast MIPS machines, the cpu overdrives
                                // the card, so this code slows it down as
                                // little as possible while checking for
                                // consistency.
                                //

                                ULONG cnt = 4;

                                while (cnt)
                                {
                                    ULONG   tmp = *((volatile ULONG*) (pjSrc));

                                    *((ULONG UNALIGNED *) pjDst) =
                                        *((volatile ULONG*) (pjSrc));

                                    if (tmp == *((volatile ULONG UNALIGNED *) pjDst))
                                        break;

                                    --cnt;
                                }
                            }
                        else
                            {
                                *((ULONG UNALIGNED *) pjDst) = *((ULONG*) (pjSrc));
                            }

                        pjSrc += sizeof(ULONG);
                        pjDst += sizeof(ULONG);
                    }
                }
                for (i = cjEndPhase; i > 0; i--)
                {
                    *pjDst++ = *pjSrc++;
                }

                pjSrc += lSrcDelta;
                pjDst += lDstDelta;
            }
        }

        *ppjSrc = pjSrc;            // Save the updated pointers
        *ppjDst = pjDst;
    }
    else
    {
        LONG i;

        ///////////////////////////////////////////////////////////////////
        // No direct dword reads bus-aligned copy
        //
        // Because we support the S3 on ancient Jensen Alpha's, we also
        // have to support a sparse view of the frame buffer -- which
        // means using the 'ioaccess.h' macros.
        //
        // We also go through this code path if doing dword reads would
        // crash a non-x86 system.

        MEMORY_BARRIER();

        if (bDstIsScreen)
        {
            // Align to the destination (implying that the source may be
            // unaligned):

            for (; cyScan > 0; cyScan--)
            {
                for (i = cjStartPhase; i > 0; i--)
                {
                    WRITE_REGISTER_UCHAR(pjDst, *pjSrc);
                    pjSrc++;
                    pjDst++;
                }

                for (i = culMiddle; i > 0; i--)
                {
                    WRITE_REGISTER_ULONG(pjDst, *((ULONG UNALIGNED *) pjSrc));
                    pjSrc += sizeof(ULONG);
                    pjDst += sizeof(ULONG);
                }

                for (i = cjEndPhase; i > 0; i--)
                {
                    WRITE_REGISTER_UCHAR(pjDst, *pjSrc);
                    pjSrc++;
                    pjDst++;
                }

                pjSrc += lSrcDelta;
                pjDst += lDstDelta;
            }
        }
        else
        {
            // Align to the source (implying that the destination may be
            // unaligned):

            for (; cyScan > 0; cyScan--)
            {
                for (i = cjStartPhase; i > 0; i--)
                {
                    *pjDst = READ_REGISTER_UCHAR(pjSrc);
                    pjSrc++;
                    pjDst++;
                }

                for (i = culMiddle; i > 0; i--)
                {
                    // There are some board 864/964 boards where we can't
                    // do dword reads from the frame buffer without
                    // crashing the system.

                    *((ULONG UNALIGNED *) pjDst) =
                     ((ULONG) READ_REGISTER_UCHAR(pjSrc + 3) << 24) |
                     ((ULONG) READ_REGISTER_UCHAR(pjSrc + 2) << 16) |
                     ((ULONG) READ_REGISTER_UCHAR(pjSrc + 1) << 8)  |
                     ((ULONG) READ_REGISTER_UCHAR(pjSrc));

                    pjSrc += sizeof(ULONG);
                    pjDst += sizeof(ULONG);
                }

                for (i = cjEndPhase; i > 0; i--)
                {
                    *pjDst = READ_REGISTER_UCHAR(pjSrc);
                    pjSrc++;
                    pjDst++;
                }

                pjSrc += lSrcDelta;
                pjDst += lDstDelta;
            }
        }

        *ppjSrc = pjSrc;            // Save the updated pointers
        *ppjDst = pjDst;
    }

}

/******************************Public*Routine******************************\
* VOID vPutBits
*
* Copies the bits from the given surface to the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vPutBits(
PDEV*       ppdev,
SURFOBJ*    psoSrc,
RECTL*      prclDst,            // Absolute coordinates!
POINTL*     pptlSrc)            // Absolute coordinates!
{
    RECTL   rclDraw;
    RECTL   rclBank;
    LONG    iBank;
    LONG    cjOffset;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;
    LONG    iNewBank;
    LONG    cjRemainder;

    // We need a local copy of 'rclDraw' because we'll be iteratively
    // modifying 'top' and passing the modified rectangle back into
    // bBankComputeNonPower2:

    rclDraw = *prclDst;

    ASSERTDD((rclDraw.left   >= 0) &&
             (rclDraw.top    >= 0) &&
             (rclDraw.right  <= ppdev->cxMemory) &&
             (rclDraw.bottom <= ppdev->cyMemory),
             "Rectangle wasn't fully clipped");

    //
    // Wait for engine idle.
    //

    IO_GP_WAIT(ppdev);

    // Compute the first bank, enable banking, then map in iBank:

    ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

    ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset, &iBank);
    ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_ON);
    ppdev->pfnBankMap(ppdev, ppdev->pvBankData, iBank);

    RELEASE_CRTC_CRITICAL_SECTION(ppdev);

    // Calculate the pointer to the upper-left corner of both rectangles:

    lDstDelta = ppdev->lDelta;
    pjDst     = ppdev->pjScreen + rclDraw.top  * lDstDelta
                                + CONVERT_TO_BYTES(rclDraw.left, ppdev)
                                - cjOffset;

    lSrcDelta = psoSrc->lDelta;
    pjSrc     = (BYTE*) psoSrc->pvScan0 + pptlSrc->y * lSrcDelta
                                        + CONVERT_TO_BYTES(pptlSrc->x, ppdev);

    while (TRUE)
    {
        cjScan = CONVERT_TO_BYTES((rclBank.right  - rclBank.left), ppdev);
        cyScan = (rclBank.bottom - rclBank.top);

        vAlignedCopy(ppdev, &pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                     TRUE);             // Screen is the destination

        if (rclDraw.right != rclBank.right)
        {
            // Handle the second part of the broken raster:

            iBank++;

            ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

            ppdev->pfnBankMap(ppdev, ppdev->pvBankData, iBank);

            RELEASE_CRTC_CRITICAL_SECTION(ppdev);

            // Number of bytes we've yet to do on the broken scan:

            cjRemainder = CONVERT_TO_BYTES((rclDraw.right - rclBank.right),
                                           ppdev);

            // Account for the fact that we're now one bank lower in the
            // destination:

            pjDst -= ppdev->cjBank;

            // Implicitly back up the source and destination pointers to the
            // unfinished portion of the scan:

            if (DIRECT_ACCESS(ppdev))
            {
                memcpy(pjDst + (cjScan - lDstDelta),
                       pjSrc + (cjScan - lSrcDelta),
                       cjRemainder);
            }
            else
            {
                BYTE* pjTmpDst = pjDst + (cjScan - lDstDelta);
                BYTE* pjTmpSrc = pjSrc + (cjScan - lSrcDelta);

                vAlignedCopy(ppdev, &pjTmpDst, 0, &pjTmpSrc, 0, cjRemainder, 1,
                             TRUE);    // Screen is the destination
            }
        }

        if (rclDraw.bottom > rclBank.bottom)
        {
            rclDraw.top = rclBank.bottom;
            ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset,
                                  &iNewBank);

            // If we just handled the second part of a broken raster,
            // then we've already got the bank correctly mapped in:

            if (iNewBank != iBank)
            {
                pjDst -= ppdev->cjBank;
                iBank = iNewBank;

                ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

                ppdev->pfnBankMap(ppdev, ppdev->pvBankData, iBank);

                RELEASE_CRTC_CRITICAL_SECTION(ppdev);
            }
        }
        else
        {
            // We're done!  Turn off banking and leave:

            ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

            ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_OFF);

            RELEASE_CRTC_CRITICAL_SECTION(ppdev);

            return;
        }
    }

}

/******************************Public*Routine******************************\
* VOID vGetBits
*
* Copies the bits to the given surface from the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vGetBits(
PDEV*       ppdev,
SURFOBJ*    psoDst,
RECTL*      prclDst,        // Absolute coordinates!
POINTL*     pptlSrc)        // Absolute coordinates!
{
    RECTL   rclDraw;
    RECTL   rclBank;
    LONG    iBank;
    LONG    cjOffset;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;
    LONG    iNewBank;
    LONG    cjRemainder;

    rclDraw.left   = pptlSrc->x;
    rclDraw.top    = pptlSrc->y;
    rclDraw.right  = rclDraw.left + (prclDst->right  - prclDst->left);
    rclDraw.bottom = rclDraw.top  + (prclDst->bottom - prclDst->top);

    ASSERTDD((rclDraw.left   >= 0) &&
             (rclDraw.top    >= 0) &&
             (rclDraw.right  <= ppdev->cxMemory) &&
             (rclDraw.bottom <= ppdev->cyMemory),
             "Rectangle wasn't fully clipped");

    //
    // Wait for engine idle.
    //

    IO_GP_WAIT(ppdev);

    // Compute the first bank, enable banking, then map in iBank.

    ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

    ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset, &iBank);
    ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_ON);
    ppdev->pfnBankMap(ppdev, ppdev->pvBankData, iBank);

    RELEASE_CRTC_CRITICAL_SECTION(ppdev);

    // Calculate the pointer to the upper-left corner of both rectangles:

    lSrcDelta = ppdev->lDelta;
    pjSrc     = ppdev->pjScreen + rclDraw.top  * lSrcDelta
                                + CONVERT_TO_BYTES(rclDraw.left, ppdev)
                                - cjOffset;

    lDstDelta = psoDst->lDelta;
    pjDst     = (BYTE*) psoDst->pvScan0 + prclDst->top  * lDstDelta
                                        + CONVERT_TO_BYTES(prclDst->left, ppdev);

    while (TRUE)
    {
        cjScan = CONVERT_TO_BYTES((rclBank.right  - rclBank.left), ppdev);
        cyScan = (rclBank.bottom - rclBank.top);

        vAlignedCopy(ppdev, &pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                     FALSE);            // Screen is the source

        if (rclDraw.right != rclBank.right)
        {
            // Handle the second part of the broken raster:

            iBank++;

            ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

            ppdev->pfnBankMap(ppdev, ppdev->pvBankData, iBank);

            RELEASE_CRTC_CRITICAL_SECTION(ppdev);

            // Number of bytes we've yet to do on the broken scan:

            cjRemainder = CONVERT_TO_BYTES((rclDraw.right - rclBank.right),
                                           ppdev);

            // Account for the fact that we're now one bank lower in the
            // source:

            pjSrc -= ppdev->cjBank;

            // Implicitly back up the source and destination pointers to the
            // unfinished portion of the scan.  Note that we don't have to
            // advance the pointers because they're already pointing to the
            // beginning of the next scan:

            if (DIRECT_ACCESS(ppdev))
            {
                memcpy(pjDst + (cjScan - lDstDelta),
                       pjSrc + (cjScan - lSrcDelta),
                       cjRemainder);
            }
            else
            {
                BYTE* pjTmpDst = pjDst + (cjScan - lDstDelta);
                BYTE* pjTmpSrc = pjSrc + (cjScan - lSrcDelta);

                vAlignedCopy(ppdev, &pjTmpDst, 0, &pjTmpSrc, 0, cjRemainder, 1,
                             FALSE);    // Screen is the source
            }
        }

        if (rclDraw.bottom > rclBank.bottom)
        {
            rclDraw.top = rclBank.bottom;
            ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset,
                                  &iNewBank);

            // If we just handled the second part of a broken raster,
            // then we've already got the bank correctly mapped in:

            if (iNewBank != iBank)
            {
                pjSrc -= ppdev->cjBank;
                iBank = iNewBank;

                ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

                ppdev->pfnBankMap(ppdev, ppdev->pvBankData, iBank);

                RELEASE_CRTC_CRITICAL_SECTION(ppdev);
            }
        }
        else
        {
            // We're done!  Turn off banking and leave:

            ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

            ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_OFF);

            RELEASE_CRTC_CRITICAL_SECTION(ppdev);

            return;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\bitblt.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: bitblt.c
*
* Contains the high-level DrvBitBlt and DrvCopyBits functions.  The low-
* level stuff lives in the 'blt??.c' files.
*
* Note: The way we've implemented device-bitmaps has changed in NT5, with
*       the advent of 'EngModifySurface' and 'DrvDeriveSurface'.  Now,
*       off-screen bitmaps will always have an iType of STYPE_BITMAP 
*       (meaning that GDI can draw directly on the bits if it needs to).
*       Additionally, former off-screen bitmaps that have been converted
*       by us to system-memory DIBs will still have an iType of STYPE_BITMAP.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vXferNativeSrccopy
*
* Does a SRCCOPY transfer of a bitmap to the screen using the frame
* buffer, because with USWC write-combining it's significantly faster
* than using the data transfer register.
*
\**************************************************************************/

VOID vXferNativeSrccopy(        // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // List of destination rectangles, in relative
                                //   coordinates
ULONG       rop4,               // Not used
SURFOBJ*    psoSrc,             // Source surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo)               // Not used
{
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx;
    LONG    dy;
    RECTL   rclDst;
    POINTL  ptlSrc;

    ASSERTDD((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL),
            "Can handle trivial xlate only");
    ASSERTDD(psoSrc->iBitmapFormat == ppdev->iBitmapFormat,
            "Source must be same colour depth as screen");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(rop4 == 0xcccc, "Must be a SRCCOPY rop");

    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    while (TRUE)
    {
        ptlSrc.x      = prcl->left   + dx;
        ptlSrc.y      = prcl->top    + dy;

        // 'vPutBits' takes only absolute coordinates, so add in the
        // off-screen bitmap offset here:

        rclDst.left   = prcl->left   + xOffset;
        rclDst.right  = prcl->right  + xOffset;
        rclDst.top    = prcl->top    + yOffset;
        rclDst.bottom = prcl->bottom + yOffset;

        vPutBits(ppdev, psoSrc, &rclDst, &ptlSrc);

        if (--c == 0)
            return;

        prcl++;
    }
}

/******************************Public*Routine******************************\
* VOID vReadNativeSrccopy
*
* Does a SRCCOPY read from the screen to a system-memory bitmap.  The only
* reason we do this here instead of punting to GDI is to ensure that we
* do dword reads that are aligned to the video-memory source and not the
* system-memory destination.
*
\**************************************************************************/

VOID vReadNativeSrccopy(        // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // List of destination rectangles, in relative
                                //   coordinates
ULONG       rop4,               // Not used
SURFOBJ*    psoDst,             // Destination surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo)               // Not used
{
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx;
    LONG    dy;
    RECTL   rclDst;
    POINTL  ptlSrc;

    ASSERTDD((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL),
            "Can handle trivial xlate only");
    ASSERTDD(psoDst->iBitmapFormat == ppdev->iBitmapFormat,
            "Source must be same colour depth as screen");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(rop4 == 0xcccc, "Must be a SRCCOPY rop");

    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    while (TRUE)
    {
        // 'vGetBits' takes only absolute coordinates, so add in the
        // off-screen bitmap offset here:

        ptlSrc.x = prcl->left + dx + xOffset;
        ptlSrc.y = prcl->top  + dy + yOffset;

        vGetBits(ppdev, psoDst, prcl, &ptlSrc);

        if (--c == 0)
            return;

        prcl++;
    }
}

/******************************Public*Routine******************************\
* BOOL bPuntBlt
*
* Has GDI do any drawing operations that we don't specifically handle
* in the driver.
*
\**************************************************************************/

BOOL bPuntBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    PDEV*    ppdev;

    if (psoDst->dhsurf != NULL)
        ppdev = (PDEV*) psoDst->dhpdev;
    else
        ppdev = (PDEV*) psoSrc->dhpdev;

    #if DBG
    {
        //////////////////////////////////////////////////////////////////////
        // Diagnostics
        //
        // Since calling the engine to do any drawing can be rather painful,
        // particularly when the source is an off-screen DFB (since GDI will
        // have to allocate a DIB and call us to make a temporary copy before
        // it can even start drawing), we'll try to avoid it as much as
        // possible.
        //
        // Here we simply spew out information describing the blt whenever
        // this routine gets called (checked builds only, of course):

        ULONG ulClip;
        PDEV* ppdev;

        if (psoDst->dhsurf != NULL)
            ppdev = (PDEV*) psoDst->dhpdev;
        else
            ppdev = (PDEV*) psoSrc->dhpdev;

        ulClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

        DISPDBG((2, ">> Punt << Dst format: %li Dst type: %li Clip: %li Rop: %lx",
            psoDst->iBitmapFormat, psoDst->iType, ulClip, rop4));

        if (psoSrc != NULL)
        {
            DISPDBG((2, "        << Src format: %li Src type: %li",
                psoSrc->iBitmapFormat, psoSrc->iType));

            if (psoSrc->iBitmapFormat == BMF_1BPP)
            {
                DISPDBG((2, "        << Foreground: %lx  Background: %lx",
                    pxlo->pulXlate[1], pxlo->pulXlate[0]));
            }
        }

        if ((pxlo != NULL) && !(pxlo->flXlate & XO_TRIVIAL) && (psoSrc != NULL))
        {
            if (((psoSrc->dhsurf == NULL) &&
                 (psoSrc->iBitmapFormat != ppdev->iBitmapFormat)) ||
                ((psoDst->dhsurf == NULL) &&
                 (psoDst->iBitmapFormat != ppdev->iBitmapFormat)))
            {
                // Don't bother printing the 'xlate' message when the source
                // is a different bitmap format from the destination -- in
                // those cases we know there always has to be a translate.
            }
            else
            {
                DISPDBG((2, "        << With xlate"));
            }
        }

        // If the rop4 requires a pattern, and it's a non-solid brush...

        if (((((rop4 >> 4) ^ (rop4)) & 0x0f0f) != 0) &&
            (pbo->iSolidColor == -1))
        {
            if (pbo->pvRbrush == NULL)
                DISPDBG((2, "        << With brush -- Not created"));
            else
                DISPDBG((2, "        << With brush -- Created Ok"));
        }
    }
    #endif

    if (DIRECT_ACCESS(ppdev))
    {
        //////////////////////////////////////////////////////////////////////
        // Banked Framebuffer bPuntBlt
        //
        // This section of code handles a PuntBlt when GDI can directly draw
        // on the framebuffer, but the drawing has to be done in banks:

        BANK     bnk;
        BOOL     b;
        HSURF    hsurfTmp;
        SURFOBJ* psoTmp;
        SIZEL    sizl;
        POINTL   ptlSrc;
        RECTL    rclTmp;
        RECTL    rclDst;
        DSURF*   pdsurfDst;
        DSURF*   pdsurfSrc;

        // We copy the original destination rectangle, and use that in every
        // GDI call-back instead of the original because sometimes GDI is
        // sneaky and points 'prclDst' to '&pco->rclBounds'.  Because we
        // modify 'rclBounds', that would affect 'prclDst', which we don't
        // want to happen:

        rclDst = *prclDst;

        pdsurfDst = (DSURF*) psoDst->dhsurf;
        pdsurfSrc = (psoSrc == NULL) ? NULL : (DSURF*) psoSrc->dhsurf;

        if ((pdsurfSrc == NULL) || (pdsurfSrc->dt & DT_DIB))
        {
            // Do a memory-to-screen blt:

            vBankStart(ppdev, &rclDst, pco, &bnk);

            b = TRUE;
            do {
                b &= EngBitBlt(bnk.pso, psoSrc, psoMsk, bnk.pco, pxlo,
                               &rclDst, pptlSrc, pptlMsk, pbo, pptlBrush,
                               rop4);

            } while (bBankEnum(&bnk));
        }
        else
        {
            b = FALSE;  // Assume failure

            // The screen is the source (it may be the destination too...)

            ptlSrc.x = pptlSrc->x + ppdev->xOffset;
            ptlSrc.y = pptlSrc->y + ppdev->yOffset;

            if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
            {
                // We have to intersect the destination rectangle with
                // the clip bounds if there is one (consider the case
                // where the app asked to blt a really, really big
                // rectangle from the screen -- prclDst would be really,
                // really big but pco->rclBounds would be the actual
                // area of interest):

                rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
                rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
                rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
                rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);

                // Correspondingly, we have to offset the source point:

                ptlSrc.x += (rclDst.left - prclDst->left);
                ptlSrc.y += (rclDst.top - prclDst->top);
            }

            // We're now either going to do a screen-to-screen or screen-to-DIB
            // blt.  In either case, we're going to create a temporary copy of
            // the source.  (Why do we do this when GDI could do it for us?
            // GDI would create a temporary copy of the DIB for every bank
            // call-back!)

            sizl.cx = rclDst.right  - rclDst.left;
            sizl.cy = rclDst.bottom - rclDst.top;

            // Don't forget to convert from relative to absolute coordinates
            // on the source!  (vBankStart takes care of that for the
            // destination.)

            rclTmp.right  = sizl.cx;
            rclTmp.bottom = sizl.cy;
            rclTmp.left   = 0;
            rclTmp.top    = 0;

            // GDI does guarantee us that the blt extents have already been
            // clipped to the surface boundaries (we don't have to worry
            // here about trying to read where there isn't video memory).
            // Let's just assert to make sure:

            ASSERTDD((ptlSrc.x >= 0) &&
                     (ptlSrc.y >= 0) &&
                     (ptlSrc.x + sizl.cx <= ppdev->cxMemory) &&
                     (ptlSrc.y + sizl.cy <= ppdev->cyMemory),
                     "Source rectangle out of bounds!");

            hsurfTmp = (HSURF) EngCreateBitmap(sizl,
                                               0,    // Let GDI choose ulWidth
                                               ppdev->iBitmapFormat,
                                               0,    // Don't need any options
                                               NULL);// Let GDI allocate

            if (hsurfTmp != 0)
            {
                psoTmp = EngLockSurface(hsurfTmp);

                if (psoTmp != NULL)
                {
                    vGetBits(ppdev, psoTmp, &rclTmp, &ptlSrc);

                    if ((pdsurfDst == NULL) || (pdsurfDst->dt & DT_DIB))
                    {
                        // It was a Screen-to-DIB blt; now it's a DIB-to-DIB
                        // blt.  Note that the source point is (0, 0) in our
                        // temporary surface:

                        b = EngBitBlt(psoDst, psoTmp, psoMsk, pco, pxlo,
                                      &rclDst, (POINTL*) &rclTmp, pptlMsk,
                                      pbo, pptlBrush, rop4);
                    }
                    else
                    {
                        // It was a Screen-to-Screen blt; now it's a DIB-to-
                        // screen blt.  Note that the source point is (0, 0)
                        // in our temporary surface:

                        vBankStart(ppdev, &rclDst, pco, &bnk);

                        b = TRUE;
                        do {
                            b &= EngBitBlt(bnk.pso, psoTmp, psoMsk, bnk.pco,
                                           pxlo, &rclDst, (POINTL*) &rclTmp,
                                           pptlMsk, pbo, pptlBrush, rop4);

                        } while (bBankEnum(&bnk));
                    }

                    EngUnlockSurface(psoTmp);
                }

                EngDeleteSurface(hsurfTmp);
            }
        }

        return(b);
    }

#if !defined(_X86_)

    else
    {
        //////////////////////////////////////////////////////////////////////
        // Really Slow bPuntBlt
        //
        // Here we handle a PuntBlt when GDI can't draw directly on the
        // framebuffer (as on the Alpha, which can't do it because of its
        // 32 bit bus).  If you thought the banked version was slow, just
        // look at this one.  Guaranteed, there will be at least one bitmap
        // allocation and extra copy involved; there could be two if it's a
        // screen-to-screen operation.

        POINTL  ptlSrc;
        RECTL   rclDst;
        SIZEL   sizl;
        BOOL    bSrcIsScreen;
        HSURF   hsurfSrc;
        RECTL   rclTmp;
        BOOL    b;
        LONG    lDelta;
        BYTE*   pjBits;
        BYTE*   pjScan0;
        HSURF   hsurfDst;
        RECTL   rclScreen;

        b = FALSE;          // For error cases, assume we'll fail

        rclDst = *prclDst;
        if (pptlSrc != NULL)
            ptlSrc = *pptlSrc;

        if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
        {
            // We have to intersect the destination rectangle with
            // the clip bounds if there is one (consider the case
            // where the app asked to blt a really, really big
            // rectangle from the screen -- prclDst would be really,
            // really big but pco->rclBounds would be the actual
            // area of interest):

            rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
            rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
            rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
            rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);

            ptlSrc.x += (rclDst.left - prclDst->left);
            ptlSrc.y += (rclDst.top  - prclDst->top);
        }

        sizl.cx = rclDst.right  - rclDst.left;
        sizl.cy = rclDst.bottom - rclDst.top;

        // We only need to make a copy from the screen if the source is
        // the screen, and the source is involved in the rop.  Note that
        // we have to check the rop before dereferencing 'psoSrc'
        // (because 'psoSrc' may be NULL if the source isn't involved):

        bSrcIsScreen = (((((rop4 >> 2) ^ (rop4)) & 0x3333) != 0) &&
                        (psoSrc->dhsurf != NULL));

        if (bSrcIsScreen)
        {
            // We need to create a copy of the source rectangle:

            hsurfSrc = (HSURF) EngCreateBitmap(sizl, 0, ppdev->iBitmapFormat,
                                               0, NULL);
            if (hsurfSrc == 0)
                goto Error_0;

            psoSrc = EngLockSurface(hsurfSrc);
            if (psoSrc == NULL)
                goto Error_1;

            rclTmp.left   = 0;
            rclTmp.top    = 0;
            rclTmp.right  = sizl.cx;
            rclTmp.bottom = sizl.cy;

            // vGetBits takes absolute coordinates for the source point:

            ptlSrc.x += ppdev->xOffset;
            ptlSrc.y += ppdev->yOffset;

            vGetBits(ppdev, psoSrc, &rclTmp, &ptlSrc);

            // The source will now come from (0, 0) of our temporary source
            // surface:

            ptlSrc.x = 0;
            ptlSrc.y = 0;
        }

        if (psoDst->dhsurf == NULL)
        {
            b = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, &rclDst, &ptlSrc,
                          pptlMsk, pbo, pptlBrush, rop4);
        }
        else
        {
            // We need to create a temporary work buffer.  We have to do
            // some fudging with the offsets so that the upper-left corner
            // of the (relative coordinates) clip object bounds passed to
            // GDI will be transformed to the upper-left corner of our
            // temporary bitmap.

            // The alignment doesn't have to be as tight as this at 16bpp
            // and 32bpp, but it won't hurt:

            lDelta = CONVERT_TO_BYTES((((rclDst.right + 3) & ~3L) -
              (rclDst.left & ~3L)),
              ppdev);

            // We're actually only allocating a bitmap that is 'sizl.cx' x
            // 'sizl.cy' in size:

            pjBits = EngAllocMem(0, lDelta * sizl.cy, ALLOC_TAG);
            if (pjBits == NULL)
                goto Error_2;

            // We now adjust the surface's 'pvScan0' so that when GDI thinks
            // it's writing to pixel (rclDst.top, rclDst.left), it will
            // actually be writing to the upper-left pixel of our temporary
            // bitmap:

            pjScan0 = pjBits - (rclDst.top * lDelta)
                        - CONVERT_TO_BYTES((rclDst.left & ~3L), ppdev);

            ASSERTDD((((ULONG_PTR) pjScan0) & 3) == 0,
                    "pvScan0 must be dword aligned!");

            // The checked build of GDI sometimes checks on blts that
            // prclDst->right <= pso->sizl.cx, so we lie to it about
            // the size of our bitmap:

            sizl.cx = rclDst.right;
            sizl.cy = rclDst.bottom;

            hsurfDst = (HSURF) EngCreateBitmap(
                        sizl,                   // Bitmap covers rectangle
                        lDelta,                 // Use this delta
                        ppdev->iBitmapFormat,   // Same colour depth
                        BMF_TOPDOWN,            // Must have a positive delta
                        pjScan0);               // Where (0, 0) would be

            if ((hsurfDst == 0) ||
                (!EngAssociateSurface(hsurfDst, ppdev->hdevEng, 0)))
                goto Error_3;

            psoDst = EngLockSurface(hsurfDst);
            if (psoDst == NULL)
                goto Error_4;

            // Make sure that the rectangle we Get/Put from/to the screen
            // is in absolute coordinates:

            rclScreen.left   = rclDst.left   + ppdev->xOffset;
            rclScreen.right  = rclDst.right  + ppdev->xOffset;
            rclScreen.top    = rclDst.top    + ppdev->yOffset;
            rclScreen.bottom = rclDst.bottom + ppdev->yOffset;

            // It would be nice to get a copy of the destination rectangle
            // only when the ROP involves the destination (or when the source
            // is an RLE), but we can't do that.  If the brush is truly NULL,
            // GDI will immediately return TRUE from EngBitBlt, without
            // modifying the temporary bitmap -- and we would proceed to
            // copy the uninitialized temporary bitmap back to the screen.

            vGetBits(ppdev, psoDst, &rclDst, (POINTL*) &rclScreen);

            b = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, &rclDst, &ptlSrc,
                          pptlMsk, pbo, pptlBrush, rop4);

            vPutBits(ppdev, psoDst, &rclScreen, (POINTL*) &rclDst);

            EngUnlockSurface(psoDst);

        Error_4:

            EngDeleteSurface(hsurfDst);

        Error_3:

            EngFreeMem(pjBits);
        }

        Error_2:

        if (bSrcIsScreen)
        {
            EngUnlockSurface(psoSrc);

        Error_1:

            EngDeleteSurface(hsurfSrc);
        }

        Error_0:

        return(b);
    }

#endif

}

/******************************Public*Routine******************************\
* BOOL DrvBitBlt
*
* Implements the workhorse routine of a display driver.
*
\**************************************************************************/

BOOL DrvBitBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    PDEV*           ppdev;
    DSURF*          pdsurfDst;
    DSURF*          pdsurfSrc;
    POINTL          ptlSrc;
    BOOL            bMore;
    CLIPENUM        ce;
    LONG            c;
    RECTL           rcl;
    BYTE            rop3;
    FNFILL*         pfnFill;
    RBRUSH_COLOR    rbc;        // Realized brush or solid colour
    FNXFER*         pfnXfer;
    ULONG           iSrcBitmapFormat;
    ULONG           iDir;
    BOOL            bRet;

    bRet = TRUE;                            // Assume success

    pdsurfDst = (DSURF*) psoDst->dhsurf;    // May be NULL

    if (psoSrc == NULL)
    {
        pdsurfSrc = NULL;

        if (!(pdsurfDst->dt & DT_DIB))
        {
            ///////////////////////////////////////////////////////////////////
            // Fills
            ///////////////////////////////////////////////////////////////////
    
            // Fills are this function's "raison d'etre", so we handle them
            // as quickly as possible:

            ppdev = (PDEV*) psoDst->dhpdev;

            ppdev->xOffset = pdsurfDst->x;
            ppdev->yOffset = pdsurfDst->y;

            // Make sure it doesn't involve a mask (i.e., it's really a
            // Rop3):

            rop3 = (BYTE) rop4;

            if ((BYTE) (rop4 >> 8) == rop3)
            {
                // Since 'psoSrc' is NULL, the rop3 had better not indicate
                // that we need a source.

                ASSERTDD((((rop4 >> 2) ^ (rop4)) & 0x33) == 0,
                         "Need source but GDI gave us a NULL 'psoSrc'");

            Fill_It:

                pfnFill = ppdev->pfnFillSolid;   // Default to solid fill

                if ((((rop3 >> 4) ^ (rop3)) & 0xf) != 0)
                {
                    // The rop says that a pattern is truly required
                    // (blackness, for instance, doesn't need one):

                    rbc.iSolidColor = pbo->iSolidColor;
                    if (rbc.iSolidColor == -1)
                    {
                        // Try and realize the pattern brush; by doing
                        // this call-back, GDI will eventually call us
                        // again through DrvRealizeBrush:

                        rbc.prb = pbo->pvRbrush;
                        if (rbc.prb == NULL)
                        {
                            rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                            if (rbc.prb == NULL)
                            {
                                // If we couldn't realize the brush, punt
                                // the call (it may have been a non 8x8
                                // brush or something, which we can't be
                                // bothered to handle, so let GDI do the
                                // drawing):

                                goto Punt_It;
                            }
                        }

                        if ((ppdev->iBitmapFormat == BMF_24BPP) && ((BYTE) (rop4 >> 8) != rop3)) {
                            goto Punt_It;
                        }
                        pfnFill = ppdev->pfnFillPat;
                    }
                }

                // Note that these 2 'if's are more efficient than
                // a switch statement:

                if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                {
                    pfnFill(ppdev, 1, prclDst, rop4, rbc, pptlBrush);
                    goto All_Done;
                }
                else if (pco->iDComplexity == DC_RECT)
                {
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                        pfnFill(ppdev, 1, &rcl, rop4, rbc, pptlBrush);
                    goto All_Done;
                }
                else
                {
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                    do {
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                        c = cIntersect(prclDst, ce.arcl, ce.c);

                        if (c != 0)
                            pfnFill(ppdev, c, ce.arcl, rop4, rbc, pptlBrush);

                    } while (bMore);
                    goto All_Done;
                }
            }
        }
        else
        {
            // Thanks to EngModifySurface, the destination is really a
            // plane old DIB, so we can forget about our DSURF structure
            // (this will simplify checks later in this routine):
    
            pdsurfDst = NULL;
        }
    }
    else
    {
        pdsurfDst = (DSURF*) psoDst->dhsurf;
        if ((pdsurfDst != NULL) && (pdsurfDst->dt & DT_DIB))
        {
            // The destination is really a plane old DIB.

            pdsurfDst = NULL;
        }

        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        if ((pdsurfSrc != NULL) && (pdsurfSrc->dt & DT_DIB))
        {
            // Here we consider putting a DIB DFB back into off-screen
            // memory.  If there's a translate, it's probably not worth
            // moving since we won't be able to use the hardware to do
            // the blt (a similar argument could be made for weird rops
            // and stuff that we'll only end up having GDI simulate, but
            // those should happen infrequently enough that I don't care).
            //
            // This is only worth doing if the destination is in off-
            // screen memory, though!

            if ((pdsurfDst != NULL) &&
                ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
            {
                ppdev = pdsurfSrc->ppdev;

                // See 'DrvCopyBits' for some more comments on how this
                // moving-it-back-into-off-screen-memory thing works:

                if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
                {
                    if (--pdsurfSrc->cBlt == 0)
                    {
                        if (bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfSrc))
                            goto Continue_It;
                    }
                }
                else
                {
                    // Some space was freed up in off-screen memory,
                    // so reset the counter for this DFB:

                    pdsurfSrc->iUniq = ppdev->iHeapUniq;
                    pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
                }
            }

            // The source is really a plane old DIB.

            pdsurfSrc = NULL;
        }
    }

Continue_It:
    
    ASSERTDD((pdsurfSrc == NULL) || !(pdsurfSrc->dt & DT_DIB),
        "pdsurfSrc should be non-NULL only if in off-screen memory");
    ASSERTDD((pdsurfDst == NULL) || !(pdsurfDst->dt & DT_DIB),
        "pdsurfDst should be non-NULL only if in off-screen memory");

    if (pdsurfDst != NULL)
    {
        // The destination is in video memory.

        if (pdsurfSrc != NULL)
        {
            // The source is also in video memory.  This is effectively
            // a screen-to-screen blt, so adjust the source point:

            ptlSrc.x = pptlSrc->x - (pdsurfDst->x - pdsurfSrc->x);
            ptlSrc.y = pptlSrc->y - (pdsurfDst->y - pdsurfSrc->y);
    
            pptlSrc  = &ptlSrc;
        }

        ppdev = pdsurfDst->ppdev;

        ppdev->xOffset = pdsurfDst->x;
        ppdev->yOffset = pdsurfDst->y;
    }
    else
    {
        // The destination is a DIB.

        if (pdsurfSrc == NULL)
        {
            // The source is a DIB, too.  Let GDI handle it.

            goto EngBitBlt_It;
        }

        ppdev = pdsurfSrc->ppdev;

        ppdev->xOffset = pdsurfSrc->x;
        ppdev->yOffset = pdsurfSrc->y;
    }

    if (((rop4 >> 8) & 0xff) == (rop4 & 0xff))
    {
        // Since we've already handled the cases where the ROP4 is really
        // a ROP3 and no source is required, we can assert...

        ASSERTDD((psoSrc != NULL) && (pptlSrc != NULL),
                 "Expected no-source case to already have been handled");

        ///////////////////////////////////////////////////////////////////
        // Bitmap transfers
        ///////////////////////////////////////////////////////////////////

        // Since the foreground and background ROPs are the same, we
        // don't have to worry about no stinking masks (it's a simple
        // Rop3).

        rop3 = (BYTE) rop4;     // Make it into a Rop3 (we keep the rop4
                                //  around in case we decide to punt)

        if (pdsurfDst != NULL)
        {
            // The destination is the screen.  See if the ROP3 requires a
            // pattern:

            if ((rop3 >> 4) == (rop3 & 0xf))
            {
                // Nope, the ROP3 doesn't require a pattern.

                if (pdsurfSrc == NULL)
                {
                    //////////////////////////////////////////////////
                    // DIB-to-screen blt

                    iSrcBitmapFormat = psoSrc->iBitmapFormat;
                    if (iSrcBitmapFormat == BMF_1BPP)
                    {
                        pfnXfer = ppdev->pfnXfer1bpp;
                        goto Xfer_It;
                    }
                    else if ((iSrcBitmapFormat == ppdev->iBitmapFormat) &&
                             ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
                    {
                        if ((rop3 & 0xf) != 0xc)
                        {
                            pfnXfer = ppdev->pfnXferNative;
                        }
                        else
                        {
                            // Thanks to USWC write-combining, for SRCCOPY
                            // blts it will be much stupendously faster to copy 
                            // directly to the frame buffer than to use the
                            // transfer register.  Note that this is true for
                            // almost any video adapter (including yours).

                            pfnXfer = vXferNativeSrccopy;
                        }
                        goto Xfer_It;
                    }

                    // Expansions from 4bpp are pretty frequent with a ROP, and 
                    // should really be done for all color depths, not just 4bpp.
                    //
                    // Note, though, that USWC means it's faster to punt to GDI
                    // for all SRCCOPY cases.

                    else if ((iSrcBitmapFormat == BMF_4BPP) &&
                             (ppdev->iBitmapFormat == BMF_8BPP) &&
                             (rop4 != 0xcccc))
                    {
                        pfnXfer = ppdev->pfnXfer4bpp;
                        goto Xfer_It;
                    }
                }
                else // pdsurfSrc != NULL
                {
                    if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
                    {
                        //////////////////////////////////////////////////
                        // Screen-to-screen blt with no translate

                        if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                        {
                            (ppdev->pfnCopyBlt)(ppdev, 1, prclDst, rop4,
                                                pptlSrc, prclDst);
                            goto All_Done;
                        }
                        else if (pco->iDComplexity == DC_RECT)
                        {
                            if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                            {
                                (ppdev->pfnCopyBlt)(ppdev, 1, &rcl, rop4,
                                                    pptlSrc, prclDst);
                            }
                            goto All_Done;
                        }
                        else
                        {
                            // Don't forget that we'll have to draw the
                            // rectangles in the correct direction:

                            if (pptlSrc->y >= prclDst->top)
                            {
                                if (pptlSrc->x >= prclDst->left)
                                    iDir = CD_RIGHTDOWN;
                                else
                                    iDir = CD_LEFTDOWN;
                            }
                            else
                            {
                                if (pptlSrc->x >= prclDst->left)
                                    iDir = CD_RIGHTUP;
                                else
                                    iDir = CD_LEFTUP;
                            }

                            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                               iDir, 0);

                            do {
                                bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                                      (ULONG*) &ce);

                                c = cIntersect(prclDst, ce.arcl, ce.c);

                                if (c != 0)
                                {
                                    (ppdev->pfnCopyBlt)(ppdev, c, ce.arcl,
                                            rop4, pptlSrc, prclDst);
                                }

                            } while (bMore);
                            goto All_Done;
                        }
                    }
                }
            }
        }
        else if (((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)) &&
                 (rop4 == 0xcccc) &&
                 (psoDst->iBitmapFormat == ppdev->iBitmapFormat))
        {
            //////////////////////////////////////////////////
            // Screen-to-DIB SRCCOPY blt with no translate
            //
            // The only way to read bits from video memory on the S3 is to
            // have the CPU read directly from the frame-buffer.  Unfortunately,
            // reads from video memory are pathetically slow.  
            //
            // Have you ever benchmarked reads?  On a Pentium II with USWC 
            // enabled, consecutive writes to the frame buffer via PCI on a 
            // typical video card is typically on the order of 80 to 100 MB/s.
            // Dword reads max out at 6 MB/s!  Byte reads (or worse, unaligned
            // Dword reads) max out at a very small 1.5 MB/s!
            //
            // The problem is that if we just punt to GDI, GDI doesn't realize
            // that the source is video-memory and the destination is system-
            // memory.  It will proceed to align its copy to the destination,
            // which means that it may do misaligned dword reads from video
            // memory.  So we just dropped our throughput by a factor of 4!
            //
            // So the net-result is that we special-case reads here simply so
            // that we can do aligned dword reads from video memory.

            pfnXfer = vReadNativeSrccopy;

            // The Xfer_It routine expects the system-memory surface to come
            // in as 'psoSrc'.

            psoSrc = psoDst;

            // It might also be a thought to convert an off-screen DFB to a 
            // DIB at this point.

            goto Xfer_It;
        }
    }

    else if ((psoMsk == NULL) && (rop4 == 0xaaf0))
    {
        // The only time GDI will ask us to do a true rop4 using the brush
        // mask is when the brush is 1bpp, and the background rop is AA
        // (meaning it's a NOP):
    
        rop3 = (BYTE) rop4;
    
        goto Fill_It;
    }

    // Just fall through to Punt_It...

Punt_It:

    bRet = bPuntBlt(psoDst,
                    psoSrc,
                    psoMsk,
                    pco,
                    pxlo,
                    prclDst,
                    pptlSrc,
                    pptlMsk,
                    pbo,
                    pptlBrush,
                    rop4);
    goto All_Done;

//////////////////////////////////////////////////////////////////////
// Common bitmap transfer

Xfer_It:
    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        pfnXfer(ppdev, 1, prclDst, rop4, psoSrc, pptlSrc, prclDst, pxlo);
        goto All_Done;
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
            pfnXfer(ppdev, 1, &rcl, rop4, psoSrc, pptlSrc, prclDst, pxlo);
        goto All_Done;
    }
    else
    {
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                           CD_ANY, 0);

        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                  (ULONG*) &ce);

            c = cIntersect(prclDst, ce.arcl, ce.c);

            if (c != 0)
            {
                pfnXfer(ppdev, c, ce.arcl, rop4, psoSrc,
                        pptlSrc, prclDst, pxlo);
            }

        } while (bMore);
        goto All_Done;
    }

////////////////////////////////////////////////////////////////////////
// Common DIB blt

EngBitBlt_It:

    // Our driver doesn't handle any blt's between two DIBs.  Normally
    // a driver doesn't have to worry about this, but we do because
    // we have DFBs that may get moved from off-screen memory to a DIB,
    // where we have GDI do all the drawing.  GDI does DIB drawing at
    // a reasonable speed (unless one of the surfaces is a device-
    // managed surface...)
    //
    // If either the source or destination surface in an EngBitBlt
    // call-back is a device-managed surface (meaning it's not a DIB
    // that GDI can draw with), GDI will automatically allocate memory
    // and call the driver's DrvCopyBits routine to create a DIB copy
    // that it can use.  So this means that this could handle all 'punts',
    // and we could conceivably get rid of bPuntBlt.  But this would have
    // a bad performance impact because of the extra memory allocations
    // and bitmap copies -- you really don't want to do this unless you
    // have to (or your surface was created such that GDI can draw
    // directly onto it) -- I've been burned by this because it's not
    // obvious that the performance impact is so bad.
    //
    // That being said, we only call EngBitBlt when all the surfaces
    // are DIBs:

    bRet = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst,
                     pptlSrc, pptlMsk, pbo, pptlBrush, rop4);

All_Done:
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL DrvCopyBits
*
* Do fast bitmap copies.
*
* DrvCopyBits is just a special-case of DrvBitBlt.  Since DrvBitBlt is
* plenty fast, we let DrvBitBlt handle all the cases.
*
* (I used to have a bunch of extra code here to optimize the SRCCOPY
* cases, but the performance win was immeasurable.  There's no point in
* the adding code complexity or the working set hit.)
*
\**************************************************************************/

BOOL DrvCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    return(DrvBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc, NULL,
                     NULL, NULL, 0x0000CCCC));
}

/******************************Public*Routine******************************\
* BOOL DrvTransparentBlt
*
* Do blt using a source color-key.
*
\**************************************************************************/

BOOL DrvTransparentBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
RECTL*    prclSrc,
ULONG     iTransparentColor,
ULONG     ulReserved)
{
    DSURF*      pdsurfSrc;
    DSURF*      pdsurfDst;
    PDEV*       ppdev;
    ULONG       c;
    BOOL        bMore;
    POINTL      ptlSrc;
    RECTL       rcl;
    CLIPENUM    ce;

    pdsurfSrc = (DSURF*) psoSrc->dhsurf;
    pdsurfDst = (DSURF*) psoDst->dhsurf;

    // We only handle the case when both surfaces are in video memory
    // and when no stretching is involved.  (GDI using USWC write-
    // combining is perfectly fast for the case where the source is
    // a DIB and the destination is video memory.)

    if (((pdsurfSrc == NULL) || (pdsurfSrc->dt & DT_DIB))                      || 
        ((pdsurfDst == NULL) || (pdsurfDst->dt & DT_DIB))                      ||
        ((pxlo != NULL) && !(pxlo->flXlate & XO_TRIVIAL))                      ||
        ((prclSrc->right - prclSrc->left) != (prclDst->right - prclDst->left)) ||
        ((prclSrc->bottom - prclSrc->top) != (prclDst->bottom - prclDst->top)))
    {
        return(EngTransparentBlt(psoDst, psoSrc, pco, pxlo, prclDst, prclSrc,
                                 iTransparentColor, ulReserved));
    }

    ppdev = (PDEV*) psoDst->dhpdev;

    ppdev->xOffset = pdsurfDst->x;
    ppdev->yOffset = pdsurfDst->y;

    ptlSrc.x = prclSrc->left - (pdsurfDst->x - pdsurfSrc->x);
    ptlSrc.y = prclSrc->top  - (pdsurfDst->y - pdsurfSrc->y);

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        ppdev->pfnCopyTransparent(ppdev, 1, prclDst, &ptlSrc, 
                                  prclDst, iTransparentColor);
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
            ppdev->pfnCopyTransparent(ppdev, 1, &rcl, &ptlSrc, 
                                      prclDst, iTransparentColor);
    }
    else
    {
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

            c = cIntersect(prclDst, ce.arcl, ce.c);

            if (c != 0)
            {
                ppdev->pfnCopyTransparent(ppdev, c, ce.arcl, &ptlSrc, 
                                          prclDst, iTransparentColor);
            }

        } while (bMore);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\port\i386\porti386.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    porti386.c

Abstract:

    This is the x86 specific part of the video port driver.

Author:

    Andre Vachon (andreva) 10-Jan-1991

Environment:

    kernel mode only

Notes:

    This module is a driver which implements OS dependant functions on the
    behalf of the video drivers

Revision History:

--*/

#include "videoprt.h"
#include "vdm.h"

//#include "..\..\..\nthals\x86new\xm86.h"
//#include "..\..\..\nthals\x86new\x86new.h"

VP_STATUS
SymmetryDeviceDataCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PVOID Identifier,
    ULONG IdentifierLength,
    PVOID ConfigurationData,
    ULONG ConfigurationDataLength,
    PVOID ComponentInformation,
    ULONG ComponentInformationLength
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,pVideoPortEnableVDM)
#pragma alloc_text(PAGE,pVideoPortInitializeInt10)
#pragma alloc_text(PAGE,VideoPortInt10)
#pragma alloc_text(PAGE,SymmetryDeviceDataCallback)
#pragma alloc_text(PAGE,pVideoPortRegisterVDM)
#pragma alloc_text(PAGE,pVideoPortSetIOPM)
#pragma alloc_text(PAGE,VideoPortSetTrappedEmulatorPorts)
#pragma alloc_text(PAGE,VpInt10AllocateBuffer)
#pragma alloc_text(PAGE,VpInt10FreeBuffer)
#pragma alloc_text(PAGE,VpInt10ReadMemory)
#pragma alloc_text(PAGE,VpInt10WriteMemory)
#pragma alloc_text(PAGE,VpInt10CallBios)
#pragma alloc_text(PAGE,pVideoPortGetVDMBiosData)
#pragma alloc_text(PAGE,pVideoPortPutVDMBiosData)
#endif


VP_STATUS
SymmetryDeviceDataCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PVOID Identifier,
    ULONG IdentifierLength,
    PVOID ConfigurationData,
    ULONG ConfigurationDataLength,
    PVOID ComponentInformation,
    ULONG ComponentInformationLength
    )
{

    if (RtlCompareMemory(L"SEQUENT Symmetry",
                         Identifier,
                         sizeof(L"SEQUENT Symmetry")) ==
                         sizeof(L"SEQUENT Symmetry"))
    {
        return NO_ERROR;
    }

    return ERROR_INVALID_PARAMETER;
}


NTSTATUS
pVideoPortEnableVDM(
    IN PFDO_EXTENSION FdoExtension,
    IN BOOLEAN Enable,
    IN PVIDEO_VDM VdmInfo,
    IN ULONG VdmInfoSize
    )

/*++

Routine Description:

    This routine allows the kernel video driver to hook out I/O ports or
    specific interrupts from the V86 fault handler. Operations on the
    specified ports which are intercepted by the V86 fault handler will be
    forwarded to the kernel driver directly.

Arguments:

    DeviceExtension - Pointer to the port driver's device extension.

    Enable - Determines if the VDM should be enabled (TRUE) or disabled
        (FALSE).

    VdmInfo - Pointer to the VdmInfo passed by the caller.

    VdmInfoSize - Size of the VdmInfo struct passed by the caller.

Return Value:

    Return the value returned by ZwSetInformationProcess().

--*/

{

    PROCESS_IO_PORT_HANDLER_INFORMATION processHandlerInfo;
    NTSTATUS ntStatus;
    PEPROCESS process;
    PVOID virtualAddress;
    ULONG length;
    ULONG defaultMask = 0;
    ULONG inIoSpace = VIDEO_MEMORY_SPACE_MEMORY |
                      VIDEO_MEMORY_SPACE_USER_MODE;

    //
    // Must make sure the caller is a trusted subsystem with the
    // appropriate privilege level before executing this call.
    // If the calls returns FALSE we must return an error code.
    //

    if (!SeSinglePrivilegeCheck(RtlConvertLongToLuid(
                                    SE_TCB_PRIVILEGE),
                                FdoExtension->CurrentIrpRequestorMode)) {

        return STATUS_PRIVILEGE_NOT_HELD;

    }

    //
    // Test to see if the parameter size is valid
    //

    if (VdmInfoSize < sizeof(VIDEO_VDM) ) {

        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    // Set the enable flag in the process struct and put in the length and
    // pointer to the emulator info struct.
    //

    if (Enable) {

        processHandlerInfo.Install = TRUE;

    } else {

        processHandlerInfo.Install = FALSE;

    }

    processHandlerInfo.NumEntries =
        FdoExtension->NumEmulatorAccessEntries;
    processHandlerInfo.EmulatorAccessEntries =
        FdoExtension->EmulatorAccessEntries;
    processHandlerInfo.Context = FdoExtension->EmulatorAccessEntriesContext;


    //
    // Call SetInformationProcess
    //

    ntStatus = ZwSetInformationProcess(VdmInfo->ProcessHandle,
                                       ProcessIoPortHandlers,
                                       &processHandlerInfo,
                                       sizeof(PROCESS_IO_PORT_HANDLER_INFORMATION));

    if (!NT_SUCCESS(ntStatus)) {

        return ntStatus;

    }

    //
    // If we are disabling the DOS application, give it the original IOPM
    // it had (which is mask zero.
    // If we are enabling it, then wait for the miniport to call to set it up
    // appropriately.
    //

    ntStatus = ObReferenceObjectByHandle(VdmInfo->ProcessHandle,
                                         0,
                                         *(PVOID *)PsProcessType,
                                         FdoExtension->CurrentIrpRequestorMode,
                                         (PVOID *)&process,
                                         NULL);

    if (NT_SUCCESS(ntStatus)) {

        if (Enable) {

            defaultMask = 1;

            //
            // This will be used later while saving the hardware state
            //

            FdoExtension->VdmProcess = process;

        } // otherwise we are disabling and the mask number is 0;

        if (!Ke386IoSetAccessProcess(PEProcessToPKProcess(process),
                                     defaultMask)) {

            ntStatus = STATUS_IO_PRIVILEGE_FAILED;

        }

        ObDereferenceObject(process);
    }


    if (!NT_SUCCESS(ntStatus)) {

        return ntStatus;

    }

    //
    // We can now map (or unmap) the video frame buffer into the VDM's
    // address space.
    //

    virtualAddress = (PVOID) FdoExtension->VdmPhysicalVideoMemoryAddress.LowPart;

    //
    // Override this with A0000 for the Sequent Symmetry machine.
    //

    if (VideoPortGetDeviceData(FdoExtension->HwDeviceExtension,
                               VpMachineData,
                               &SymmetryDeviceDataCallback,
                               NULL) == NO_ERROR)
    {
        virtualAddress = (PVOID) 0xA0000;
    }

    length = FdoExtension->VdmPhysicalVideoMemoryLength;

    if (Enable) {

        return pVideoPortMapUserPhysicalMem(FdoExtension,
                                            VdmInfo->ProcessHandle,
                                            FdoExtension->VdmPhysicalVideoMemoryAddress,
                                            &length,
                                            &inIoSpace,
                                            (PVOID *) &virtualAddress);

    } else {

        return ZwUnmapViewOfSection(VdmInfo->ProcessHandle,
                    (PVOID)( ((ULONG)virtualAddress) & (~(PAGE_SIZE - 1))) );

    }
} // pVideoPortEnableVDM()

VP_STATUS
VpInt10AllocateBuffer(
    IN PVOID Context,
    OUT PUSHORT Seg,
    OUT PUSHORT Off,
    IN OUT PULONG Length
    )

{
    VP_STATUS Status = STATUS_INSUFFICIENT_RESOURCES;

    if (Int10BufferAllocated == FALSE) {

        if (*Length <= 0x1000) {

            *Seg = VDM_TRANSFER_SEGMENT;
            *Off = VDM_TRANSFER_OFFSET;

            Int10BufferAllocated = TRUE;

            Status = NO_ERROR;
        }
    }

    *Length = VDM_TRANSFER_LENGTH;
    return Status;
}

VP_STATUS
VpInt10FreeBuffer(
    IN PVOID Context,
    IN USHORT Seg,
    IN USHORT Off
    )

{
    VP_STATUS Status = STATUS_INVALID_PARAMETER;

    if ((VDM_TRANSFER_SEGMENT == Seg) && (VDM_TRANSFER_OFFSET == Off)) {

        if (Int10BufferAllocated == TRUE) {

            Int10BufferAllocated = FALSE;
            Status = NO_ERROR;
        }
    }

    return Status;
}

VP_STATUS
VpInt10ReadMemory(
    IN PVOID Context,
    IN USHORT Seg,
    IN USHORT Off,
    OUT PVOID Buffer,
    IN ULONG Length
    )

{
    BOOLEAN bAttachProcess = FALSE;
    PVOID Memory = (PVOID)((Seg << 4) + Off);
    VP_STATUS Status = NO_ERROR;

    if(!CsrProcess) return STATUS_INVALID_PARAMETER;

    if (PsGetCurrentProcess() != CsrProcess)
    {
        bAttachProcess = TRUE;
        KeAttachProcess(PEProcessToPKProcess(CsrProcess));
    }

    try {
        RtlCopyMemory(Buffer, Memory, Length);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INVALID_PARAMETER;
    }

    if (bAttachProcess) {
        KeDetachProcess();
    }

    return Status;
}

VP_STATUS
VpInt10WriteMemory(
    IN PVOID Context,
    IN USHORT Seg,
    IN USHORT Off,
    IN PVOID Buffer,
    IN ULONG Length
    )

{
    BOOLEAN bAttachProcess = FALSE;
    PVOID Memory = (PVOID)((Seg << 4) + Off);
    VP_STATUS Status = NO_ERROR;

    if(!CsrProcess) return STATUS_INVALID_PARAMETER;

    if (PsGetCurrentProcess() != CsrProcess)
    {
        bAttachProcess = TRUE;
        KeAttachProcess(PEProcessToPKProcess(CsrProcess));
    }

    try {
        RtlCopyMemory(Memory, Buffer, Length);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INVALID_PARAMETER;
    }

    if (bAttachProcess) {
        KeDetachProcess();
    }

    return Status;
}

#define BAD_BIOS_SIGNATURE 0xB105

VP_STATUS
VpInt10CallBios(
    PVOID HwDeviceExtension,
    PINT10_BIOS_ARGUMENTS BiosArguments
    )

/*++

Routine Description:

    This function allows a miniport driver to call the kernel to perform
    an int10 operation.
    This will execute natively the BIOS ROM code on the device.

    THIS FUNCTION IS FOR X86 ONLY.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BiosArguments - Pointer to a structure containing the value of the
        basic x86 registers that should be set before calling the BIOS routine.
        0 should be used for unused registers.

Return Value:

Restrictions:

    Device uses IO ports ONLY.

--*/

{
    NTSTATUS ntStatus;
    CONTEXT context;
    BOOLEAN bAttachProcess = FALSE;

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // Must make sure the caller is a trusted subsystem with the
    // appropriate address space set up.
    //

    if (!SeSinglePrivilegeCheck(RtlConvertLongToLuid(
                                    SE_TCB_PRIVILEGE),
                                fdoExtension->CurrentIrpRequestorMode)) {

        return ERROR_INVALID_PARAMETER;
    }

    if (ServerBiosAddressSpaceInitialized == 0) {

	pVideoDebugPrint((0, "Warning: Attempt to call VideoPortInt10 before Int10 support is initialized.\n"));

        return ERROR_INVALID_PARAMETER;
    }

    if (CsrProcess == 0) {

        // This might happen if we're shutting down the system.

        return NO_ERROR;
    }
    
    if (PsGetCurrentProcess() != CsrProcess)
    {
        bAttachProcess = TRUE;
        KeAttachProcess(PEProcessToPKProcess(CsrProcess));
    }

    //
    // Zero out the context and initialize the required values with the
    // miniport's requested register values.
    //

    RtlZeroMemory(&context, sizeof(CONTEXT));

    context.Edi = BiosArguments->Edi;
    context.Esi = BiosArguments->Esi;
    context.Eax = BiosArguments->Eax;
    context.Ebx = BiosArguments->Ebx;
    context.Ecx = BiosArguments->Ecx;
    context.Edx = BiosArguments->Edx;
    context.Ebp = BiosArguments->Ebp;
    context.SegDs = BiosArguments->SegDs;
    context.SegEs = BiosArguments->SegEs;

    //
    // Now call the kernel to actually perform the int 10 operation.
    // We wrap thiw with a try/except in case csrss is gone.
    //

    KeWaitForSingleObject(&VpInt10Mutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          (PTIME)NULL);

    try {
        ntStatus = Ke386CallBios(0x10, &context);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        ntStatus = GetExceptionCode();
    }

    KeReleaseMutex(&VpInt10Mutex, FALSE);
    if (bAttachProcess) {
        KeDetachProcess();
    }

    //
    // fill in struct with any return values from the context
    //

    BiosArguments->Edi = context.Edi;
    BiosArguments->Esi = context.Esi;
    BiosArguments->Eax = context.Eax;
    BiosArguments->Ebx = context.Ebx;
    BiosArguments->Ecx = context.Ecx;
    BiosArguments->Edx = context.Edx;
    BiosArguments->Ebp = context.Ebp;
    BiosArguments->SegDs = (USHORT)context.SegDs;
    BiosArguments->SegEs = (USHORT)context.SegEs;

    //
    // Return that status we got when calling the BIOS (writting to the
    // is secondary at best).
    //

    if (NT_SUCCESS(ntStatus)) {

        pVideoDebugPrint ((2, "VIDEOPRT: Int10: Int 10 succeded properly\n"));

    } else {

        pVideoDebugPrint ((0, "VIDEOPRT: Int10 failed - status %08lx\n", ntStatus));

    }

    if (((BiosArguments->Eax & 0xffff) == 0x014f) &&
        ((BiosArguments->Ebx & 0xffff) == BAD_BIOS_SIGNATURE) ) {
       
        pVideoDebugPrint ((0, "VIDEOPRT: Video bios error detected at CS:IP = %4x:%4x\n", 
                              (USHORT) BiosArguments->Ecx, (USHORT) BiosArguments->Edx));

        ASSERT(FALSE);

        return ERROR_INVALID_PARAMETER;
    }


    return ntStatus;

}

VP_STATUS
VideoPortInt10(
    PVOID HwDeviceExtension,
    PVIDEO_X86_BIOS_ARGUMENTS BiosArguments
    )

/*++

Routine Description:

    This function allows a miniport driver to call the kernel to perform
    an int10 operation.
    This will execute natively the BIOS ROM code on the device.

    THIS FUNCTION IS FOR X86 ONLY.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BiosArguments - Pointer to a structure containing the value of the
        basic x86 registers that should be set before calling the BIOS routine.
        0 should be used for unused registers.

Return Value:


Restrictions:

    Device uses IO ports ONLY.


--*/

{
    NTSTATUS ntStatus;
    CONTEXT context;
    BOOLEAN bAttachProcess = FALSE;

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // Must make sure the caller is a trusted subsystem with the
    // appropriate address space set up.
    //

    if (!SeSinglePrivilegeCheck(RtlConvertLongToLuid(
                                    SE_TCB_PRIVILEGE),
                                fdoExtension->CurrentIrpRequestorMode)) {

        return ERROR_INVALID_PARAMETER;
    }

    if (ServerBiosAddressSpaceInitialized == 0) {

	pVideoDebugPrint((0, "Warning: Attempt to call VideoPortInt10 before Int10 support is initialized.\n"));

        return ERROR_INVALID_PARAMETER;
    }

    if (CsrProcess == 0) {

        // This might happen if we're shutting down the system.

        return NO_ERROR;
    }
    
    if (PsGetCurrentProcess() != CsrProcess)
    {
        bAttachProcess = TRUE;
        KeAttachProcess(PEProcessToPKProcess(CsrProcess));
    }

    //
    // Zero out the context and initialize the required values with the
    // miniport's requested register values.
    //

    RtlZeroMemory(&context, sizeof(CONTEXT));

    context.Edi = BiosArguments->Edi;
    context.Esi = BiosArguments->Esi;
    context.Eax = BiosArguments->Eax;
    context.Ebx = BiosArguments->Ebx;
    context.Ecx = BiosArguments->Ecx;
    context.Edx = BiosArguments->Edx;
    context.Ebp = BiosArguments->Ebp;

    //
    // Now call the kernel to actually perform the int 10 operation.
    // We wrap thiw with a try/except in case csrss is gone.
    // And we need to protect Ke386CallBios from reentrance.
    //

    KeWaitForSingleObject(&VpInt10Mutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          (PTIME)NULL);

    try {
        ntStatus = Ke386CallBios(0x10, &context);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        ntStatus = GetExceptionCode();
    }

    KeReleaseMutex(&VpInt10Mutex, FALSE);

    if (bAttachProcess) {
        KeDetachProcess();
    }

    //
    // fill in struct with any return values from the context
    //

    BiosArguments->Edi = context.Edi;
    BiosArguments->Esi = context.Esi;
    BiosArguments->Eax = context.Eax;
    BiosArguments->Ebx = context.Ebx;
    BiosArguments->Ecx = context.Ecx;
    BiosArguments->Edx = context.Edx;
    BiosArguments->Ebp = context.Ebp;

    //
    // Return that status we got when calling the BIOS (writting to the
    // is secondary at best).
    //

    if (NT_SUCCESS(ntStatus)) {

        pVideoDebugPrint ((2, "VIDEOPRT: Int10: Int 10 succeded properly\n"));

    } else {

        pVideoDebugPrint ((0, "VIDEOPRT: Int10 failed - status %08lx\n", ntStatus));

    }

    if (((BiosArguments->Eax & 0xffff) == 0x014f) &&
        ((BiosArguments->Ebx & 0xffff) == BAD_BIOS_SIGNATURE) ) {
       
        pVideoDebugPrint ((0, "VIDEOPRT: Video bios error detected at CS:IP = %4x:%4x\n", 
                              (USHORT) BiosArguments->Ecx, (USHORT) BiosArguments->Edx));

        ASSERT(FALSE);

        return ERROR_INVALID_PARAMETER;
    }

    // We have to return NO_ERROR even when we failed the int10,
    // because some drivers expect us to always return NO_ERROR.
    return NO_ERROR;

} // end VideoPortInt10()

//
// Internal definitions
//

#define KEY_VALUE_BUFFER_SIZE  1024
#define ONE_MEG                0x100000
#define ROM_BIOS_START         0xC0000
#define VIDEO_BUFFER_START     0xA0000
#define DOS_LOADED_ADDRESS     0x700
#define EBIOS_AREA_INFORMATION 0x40
#define INT00_VECTOR_ADDRESS   (0x00*4)
#define INTCD_VECTOR_ADDRESS   (0xCD*4)
#define INT1A_VECTOR_ADDRESS   (0x1A*4)
#define ERROR_HANDLER_SEGMENT  0x3000
#define ERROR_HANDLER_OFFSET   0x0

typedef struct _EBIOS_INFORMATION {
    ULONG EBiosAddress;
    ULONG EBiosSize;
} EBIOS_INFORMATION, *PEBIOS_INFORMATION;

UCHAR ErrorHandler[] = {
    0x89, 0xe5,        // mov bp, sp
    0xb8, 0x4f, 0x01,  // mov ax, 0x014f     
    0xbb, 0x05, 0xb1,  // mov bx, BAD_BIOS_SIGNATURE
    0x8b, 0x56, 0x00,  // mov dx,[bp]
    0x8b, 0x4e, 0x02,  // mov cx,[bp+0x2]
    0xc4, 0xc4, 0xfe,  // BOP 0xfe
    0xcf               // iret
    };

VOID
pVideoPortInitializeInt10(
    PFDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    Initializes the CSR address space so we can do an int 10.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:


Restrictions:

    THIS FUNCTION IS FOR X86 ONLY.

    THIS FUNCTION MUST BE RUN IN THE CONTEXT OF CSR

    This function goes thru ROM BIOS area to map in all the ROM blocks and
    allocates memory for the holes inside the BIOS area.  The reason we
    allocate memory for the holes in BIOS area is because some int 10 BIOS
    code touches the nonexisting memory.  Under Nt, this triggers page fault
    and the int 10 is terminated.

    Note: the code is adapted from VdmpInitialize().



--*/

{
    NTSTATUS ntStatus;

    ULONG inIoSpace = VIDEO_MEMORY_SPACE_MEMORY |
                      VIDEO_MEMORY_SPACE_USER_MODE;
    PVOID virtualAddress;
    ULONG length;
    ULONG size;
    PVOID baseAddress;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING SectionName;
    UNICODE_STRING WorkString;
    ULONG ViewSize;
    LARGE_INTEGER ViewBase;
    PVOID BaseAddress;
    PVOID destination;
    HANDLE SectionHandle, RegistryHandle;
    ULONG ResultLength, EndingAddress;
    ULONG Index;
    PCM_FULL_RESOURCE_DESCRIPTOR ResourceDescriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor;
    PKEY_VALUE_FULL_INFORMATION KeyValueBuffer;
    CM_ROM_BLOCK RomBlock;
    PCM_ROM_BLOCK BiosBlock;
    ULONG LastMappedAddress;
    PHYSICAL_ADDRESS PhysicalAddress;
    PHYSICAL_ADDRESS PhysicalAddressLow, PhysicalAddressHigh, BoundaryAddress;
    ULONG AddressSpace = VIDEO_MEMORY_SPACE_MEMORY;
    ULONG dwCrc = 0xFFFFFFFF;
    PULONG ExtendedBiosLocationInfo;
    ULONG ExtendedBiosAddress, ExtendedBiosSize, *IntVectorAddress;
    ULONG Int1ACodeAddress;
    BOOLEAN Int1AIsValid = FALSE;

    //
    // NOTE   Due to the way compiler optimization code works, I have
    //        to declare EBiosInformation to be volatile.  Otherwise, no
    //        code will be generated for the EBiosInformation.
    //        It should be removed once the C compiler is fixed.
    //
    volatile PEBIOS_INFORMATION EBiosInformation = (PEBIOS_INFORMATION)
                           (DOS_LOADED_ADDRESS + EBIOS_AREA_INFORMATION);
    BOOLEAN EBiosInitialized = FALSE;

    //
    // If we have already initialized, or for some reason can not, return
    // right here.
    //

    if ((ServerBiosAddressSpaceInitialized == 1) ||
        (VpC0000Compatible == 0)                 ||
        (FdoExtension->VdmPhysicalVideoMemoryAddress.LowPart == 0) ||
        (CsrProcess == 0))
    {
        return;
    }

    //
    // It is possible that this routine will end up failing below if
    // the 0xA0000 memory range isn't visible to the current display device.
    // However, failing half way through the routine is bad because we've
    // already done the MEM_COMMIT in csrss.  So a subsequent call will
    // also fail.  So lets try to determine now if we are going to fail.
    // This is easier than backing out changes if we do fail!
    //

    if (!HalTranslateBusAddress(FdoExtension->AdapterInterfaceType,
                                FdoExtension->SystemIoBusNumber,
                                FdoExtension->VdmPhysicalVideoMemoryAddress,
                                &AddressSpace,
                                &PhysicalAddress)) {

        pVideoDebugPrint((1, "This device isn't the VGA.\n"));
        return;
    }

    size = 0x00100000 - 1;        // 1 MEG

    //
    // We pass an address of 1, so Memory Management will round it down to 0.
    // if we passed in 0, memory management would think the argument was
    // not present.
    //

    baseAddress = (PVOID) 0x00000001;

    // N.B.        We expect that process creation has reserved the first 16 MB
    //        for us already. If not, then this won't work worth a darn

    ntStatus = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                        &baseAddress,
                                        0L,
                                        &size,
                                        MEM_COMMIT,
                                        PAGE_READWRITE );

    if (!NT_SUCCESS(ntStatus)) {

        pVideoDebugPrint ((1, "VIDEOPRT: Int10: Failed to allocate 1MEG of memory for the VDM\n"));
        return;

    }

    //
    // Map in the physical memory into the caller's address space so that
    // any memory references from the BIOS will work properly.
    //

    virtualAddress = (PVOID) FdoExtension->VdmPhysicalVideoMemoryAddress.LowPart;
    length = FdoExtension->VdmPhysicalVideoMemoryLength;

    ntStatus = ZwFreeVirtualMemory(NtCurrentProcess(),
                                   &virtualAddress,
                                   &length,
                                   MEM_RELEASE);

    if (!NT_SUCCESS(ntStatus)) {

        pVideoDebugPrint ((1, "VIDEOPRT: Int10: Failed to free memory space for video memory to be mapped\n"));
        return;

    }

    virtualAddress = (PVOID) FdoExtension->VdmPhysicalVideoMemoryAddress.LowPart;
    length = FdoExtension->VdmPhysicalVideoMemoryLength;

    ntStatus = pVideoPortMapUserPhysicalMem(FdoExtension,
                                            NtCurrentProcess(),
                                            FdoExtension->VdmPhysicalVideoMemoryAddress,
                                            &length,
                                            &inIoSpace,
                                            &virtualAddress);

    if (!NT_SUCCESS(ntStatus)) {

        pVideoDebugPrint ((1, "VIDEOPRT: Int10: Failed to Map video memory in address space\n"));
        return;

    }

    //
    // Initialize the default bios block which will be used if we can NOT
    // find any valid bios block.
    //

    RomBlock.Address = ROM_BIOS_START;
    RomBlock.Size = 0x40000;
    BiosBlock = &RomBlock;
    Index = 1;

    RtlInitUnicodeString(
        &SectionName,
        L"\\Device\\PhysicalMemory"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &SectionName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    ntStatus = ZwOpenSection(
        &SectionHandle,
        SECTION_ALL_ACCESS,
        &ObjectAttributes
        );

    if (!NT_SUCCESS(ntStatus)) {

        return;

    }

    //
    // Initialize the first unused memory with "int cd" so we will catch
    // a bios that starts executing from this region by hooking up our 
    // own int cd code.
    //

    memset(0, 0xCD, 0xa0000);

    //
    // Copy the first page of physical memory into the CSR's address space
    //

    BaseAddress = 0;
    destination = 0;
    ViewSize = 0x1000;
    ViewBase.LowPart = 0;
    ViewBase.HighPart = 0;

    ntStatus =ZwMapViewOfSection(
        SectionHandle,
        NtCurrentProcess(),
        &BaseAddress,
        0,
        ViewSize,
        &ViewBase,
        &ViewSize,
        ViewUnmap,
        0,
        PAGE_READWRITE
        );

    if (!NT_SUCCESS(ntStatus)) {

        ZwClose(SectionHandle);
        return;

    }

    //
    // Make PREfast happy - we ARE using a NULL pointer here.
    //

    ((PUCHAR)destination)++;
    ((PUCHAR)destination)--;


    RtlMoveMemory(
        destination,
        BaseAddress,
        ViewSize
        );

    //
    // Copy the info from 0x700 to 0x717 into the registry.
    // These correspond to the 6 font pointers needed for
    //  vdm support.
    //
    // Note: Will not return if registry calls fail.  This
    //  function needs to continue; it would be bad if we
    //  could not perform an int 0x10.
    //
    
    RtlInitUnicodeString(
        &WorkString,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Wow"
        );
    
    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        NULL
        );

    ntStatus = ZwOpenKey(
        &RegistryHandle,
        KEY_ALL_ACCESS,
        &ObjectAttributes
        );

    if (NT_SUCCESS(ntStatus)) {
    
        RtlInitUnicodeString(
            &WorkString,
            L"RomFontPointers"
            );

        destination = (PVOID) 0x700;
        
        ntStatus = ZwSetValueKey(
            RegistryHandle,
            &WorkString,
            0,
            REG_BINARY,
            destination,
            24
            );
    
        //
        // We won't return here if this fails.  The function should 
        //  continue in order to enable int 0x10 support.
        //
        
        ZwClose(RegistryHandle);
        
    }

    ntStatus = ZwUnmapViewOfSection(
        NtCurrentProcess(),
        BaseAddress
        );

    if (!NT_SUCCESS(ntStatus)) {

        ZwClose(SectionHandle);
        return;

    }

    //
    // Hook error handler to int 0
    //
     
    IntVectorAddress = (ULONG *) (INT00_VECTOR_ADDRESS);

    if(*IntVectorAddress >= 0xF0000000) {

        //
        // Only replace the int0 handler if it is pointing to F000 segment
        // where system bios lives
        //

        RtlMoveMemory((PVOID)((ERROR_HANDLER_SEGMENT << 4) | ERROR_HANDLER_OFFSET),
                      ErrorHandler,
                      sizeof(ErrorHandler)
                      );

        *IntVectorAddress = 
              (ERROR_HANDLER_SEGMENT << 16) | ERROR_HANDLER_OFFSET;
    }

    //
    // Hook error handler to int cd
    //
     
    IntVectorAddress = (ULONG *) (INTCD_VECTOR_ADDRESS);

    if(*IntVectorAddress == 0) {

        RtlMoveMemory((PVOID)((ERROR_HANDLER_SEGMENT << 4) | ERROR_HANDLER_OFFSET),
                      ErrorHandler,
                      sizeof(ErrorHandler)
                      );

        *IntVectorAddress = 
              (ERROR_HANDLER_SEGMENT << 16) | ERROR_HANDLER_OFFSET;
    }

    {
       USHORT seg, offset;

       offset = *(USHORT *)(INT1A_VECTOR_ADDRESS); 
       seg = *(USHORT *)(INT1A_VECTOR_ADDRESS + 2);

       Int1ACodeAddress = (seg << 4) + offset;
       Int1AIsValid = FALSE;
    }


    //
    // Copy the exteneded Bios region into the CSR's address space 
    //

    ExtendedBiosLocationInfo = (PVOID) EXTENDED_BIOS_INFO_LOCATION; 
    ExtendedBiosAddress = *ExtendedBiosLocationInfo++;
    ExtendedBiosSize = *ExtendedBiosLocationInfo;

    //
    // Round to page boundary
    //

    ExtendedBiosSize += (ExtendedBiosAddress & (PAGE_SIZE - 1));
    ExtendedBiosAddress &= ~(PAGE_SIZE - 1);
    
    if (ExtendedBiosSize) {

        BaseAddress = 0;
        destination = (PVOID) ExtendedBiosAddress;
        ViewSize = ExtendedBiosSize;
        ViewBase.LowPart = ExtendedBiosAddress;
        ViewBase.HighPart = 0;

        ntStatus = ZwMapViewOfSection(SectionHandle,
                                      NtCurrentProcess(),
                                      &BaseAddress,
                                      0,
                                      ViewSize,
                                      &ViewBase,
                                      &ViewSize,
                                      ViewUnmap,
                                      0,
                                      PAGE_READWRITE);
                                  

        if (!NT_SUCCESS(ntStatus)) {

            ZwClose(SectionHandle);
            return;
        }

        RtlMoveMemory(destination, BaseAddress, ViewSize);

        ntStatus = ZwUnmapViewOfSection(NtCurrentProcess(), BaseAddress); 

        if (!NT_SUCCESS(ntStatus)) {

            ZwClose(SectionHandle);
            return;
        }

        if(Int1ACodeAddress >= ExtendedBiosAddress &&
           Int1ACodeAddress < ExtendedBiosAddress + ExtendedBiosSize) {
            Int1AIsValid = TRUE;
        }
    }

    //
    // Copy the e000:0000 segment of physical memory into the CSR's address space
    // This is because some bios code can live in the e000:0000 segment.
    //
    // We are doing a copy instead of mapping the physical e000:0000 segment
    // because we don't know how the real e000:0000 segment will be used in
    // all machines.
    //
    // See bugbug comment in \nt\base\hals\x86new\x86bios.c.  we are adding
    // this to be consisten with that code.  JeffHa added that code.
    //
    // Should we just copy the whole 640K?
    //

    BaseAddress = 0;
    destination = (PVOID) 0xe0000;
    ViewSize = 0x10000;
    ViewBase.LowPart = 0xe0000;
    ViewBase.HighPart = 0;

    ntStatus =ZwMapViewOfSection(
        SectionHandle,
        NtCurrentProcess(),
        &BaseAddress,
        0,
        ViewSize,
        &ViewBase,
        &ViewSize,
        ViewUnmap,
        0,
        PAGE_READWRITE
        );

    if (!NT_SUCCESS(ntStatus)) {

        ZwClose(SectionHandle);
        return;

    }

    RtlMoveMemory(
        destination,
        BaseAddress,
        ViewSize
        );

    ntStatus = ZwUnmapViewOfSection(
        NtCurrentProcess(),
        BaseAddress
        );

    if (!NT_SUCCESS(ntStatus)) {

        ZwClose(SectionHandle);
        return;
    }

    if(Int1ACodeAddress >= (ULONG)destination &&
       Int1ACodeAddress < (ULONG)destination + ViewSize) {
        Int1AIsValid = TRUE;
    }

    //
    // Set up and open KeyPath
    //
    RtlInitUnicodeString(
        &WorkString,
        L"\\Registry\\Machine\\Hardware\\Description\\System"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        NULL
        );

    ntStatus = ZwOpenKey(
        &RegistryHandle,
        KEY_READ,
        &ObjectAttributes
        );

    if (!NT_SUCCESS(ntStatus)) {
        ZwClose(SectionHandle);
        return;
    }

    //
    // Allocate space for the data
    //

    KeyValueBuffer = ExAllocatePoolWithTag(
        PagedPool,
        KEY_VALUE_BUFFER_SIZE,
        VP_TAG
        );

    if (KeyValueBuffer == NULL) {
        ZwClose(SectionHandle);
        ZwClose(RegistryHandle);
        return;
    }

    //
    // Get the data for the rom information
    //

    RtlInitUnicodeString(
        &WorkString,
        L"Configuration Data"
        );

    ntStatus = ZwQueryValueKey(
        RegistryHandle,
        &WorkString,
        KeyValueFullInformation,
        KeyValueBuffer,
        KEY_VALUE_BUFFER_SIZE,
        &ResultLength
        );

    if (!NT_SUCCESS(ntStatus)) {
        ZwClose(SectionHandle);
        ZwClose(RegistryHandle);
        ExFreePool(KeyValueBuffer);
        return;
    }

    ResourceDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR)
        ((PUCHAR) KeyValueBuffer + KeyValueBuffer->DataOffset);

    if ((KeyValueBuffer->DataLength >= sizeof(CM_FULL_RESOURCE_DESCRIPTOR)) &&
        (ResourceDescriptor->PartialResourceList.Count >= 2) ) {

        PartialResourceDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
            ((PUCHAR)ResourceDescriptor +
            sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +
            ResourceDescriptor->PartialResourceList.PartialDescriptors[0]
                .u.DeviceSpecificData.DataSize);

        if (KeyValueBuffer->DataLength >= ((PUCHAR)PartialResourceDescriptor -
            (PUCHAR)ResourceDescriptor + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
            + sizeof(CM_ROM_BLOCK))) {
            BiosBlock = (PCM_ROM_BLOCK)((PUCHAR)PartialResourceDescriptor +
                sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

            Index = PartialResourceDescriptor->u.DeviceSpecificData.DataSize /
                sizeof(CM_ROM_BLOCK);
        }
    }

    //
    // First check if there is any Extended BIOS Data area.  If yes, we need
    // to map in the physical memory and copy the content to our virtual addr.
    //

    LastMappedAddress = 0;
    while (Index && BiosBlock->Address < ROM_BIOS_START) {
        EBiosInitialized = TRUE;
        destination = (PVOID)(BiosBlock->Address & ~(PAGE_SIZE - 1));
        BaseAddress = (PVOID)0;
        EndingAddress = (BiosBlock->Address + BiosBlock->Size + PAGE_SIZE - 1) &
                        ~(PAGE_SIZE - 1);
        ViewSize = EndingAddress - (ULONG)destination;

        if ((ULONG)destination < LastMappedAddress) {
            if (ViewSize > (LastMappedAddress - (ULONG)destination)) {
                ViewSize = ViewSize - (LastMappedAddress - (ULONG)destination);
                destination = (PVOID)LastMappedAddress;
            } else {
                ViewSize = 0;
            }
        }
        if (ViewSize > 0) {
            ViewBase.LowPart = (ULONG)destination;
            ViewBase.HighPart = 0;

            ntStatus =ZwMapViewOfSection(
                SectionHandle,
                NtCurrentProcess(),
                &BaseAddress,
                0,
                ViewSize,
                &ViewBase,
                &ViewSize,
                ViewUnmap,
                MEM_DOS_LIM,
                PAGE_READWRITE
                );

            if (NT_SUCCESS(ntStatus)) {
                ViewSize = EndingAddress - (ULONG)destination;  // only copy what we need
                LastMappedAddress = (ULONG)destination + ViewSize;
                RtlMoveMemory(destination, BaseAddress, ViewSize);
                ZwUnmapViewOfSection(NtCurrentProcess(), BaseAddress);

                if(Int1ACodeAddress >= (ULONG)destination &&
                   Int1ACodeAddress < (ULONG)destination + ViewSize) {
                    Int1AIsValid = TRUE;
                }
            }
        }
        BiosBlock++;
        Index--;
    }

    //
    // NOTE - The code should be removed after product 1.
    //    Due to some problem in VDM initialization, if we pass EBIOS data
    //    area information thru ROM block list, vdm init will fail and our
    //    subsequential int10 mode set will fail.  This prevents new ntdetect
    //    from working with beta versions of NT.  To solve this problem, the
    //    EBIOS information is passed to VDM with fonts information thru DOS
    //    loaded area.
    //
    //    We've shipped two products (about to be 3) and this works fine,
    //    don't mess with it.
    //

    if (EBiosInitialized == FALSE &&
        EBiosInformation->EBiosAddress != 0 &&
        EBiosInformation->EBiosAddress <= VIDEO_BUFFER_START &&
        EBiosInformation->EBiosSize != 0 &&
        (EBiosInformation->EBiosSize & 0x3ff) == 0 &&
        EBiosInformation->EBiosSize < 0x40000) {
        EndingAddress = EBiosInformation->EBiosAddress +
                                EBiosInformation->EBiosSize;
        if (EndingAddress <= VIDEO_BUFFER_START &&
            (EndingAddress & 0x3FF) == 0) {
            destination = (PVOID)(EBiosInformation->EBiosAddress & ~(PAGE_SIZE - 1));
            BaseAddress = (PVOID)0;
            EndingAddress = (EndingAddress + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);
            ViewSize = EndingAddress - (ULONG)destination;

            ViewBase.LowPart = (ULONG)destination;
            ViewBase.HighPart = 0;

            ntStatus =ZwMapViewOfSection(
                SectionHandle,
                NtCurrentProcess(),
                &BaseAddress,
                0,
                ViewSize,
                &ViewBase,
                &ViewSize,
                ViewUnmap,
                MEM_DOS_LIM,
                PAGE_READWRITE
                );

            if (NT_SUCCESS(ntStatus)) {
                ViewSize = EndingAddress - (ULONG)destination;  // only copy what we need
                RtlMoveMemory(destination, BaseAddress, ViewSize);
                ZwUnmapViewOfSection(NtCurrentProcess(), BaseAddress);

                if(Int1ACodeAddress >= (ULONG)destination &&
                   Int1ACodeAddress < (ULONG)destination + ViewSize) {
                    Int1AIsValid = TRUE;
                }
            }
        }
    }

    //
    // N.B.  Rom blocks begin on 2K (not necessarily page) boundaries
    //       They end on 512 byte boundaries.  This means that we have
    //       to keep track of the last page mapped, and round the next
    //       Rom block up to the next page boundary if necessary.
    //

    LastMappedAddress = ROM_BIOS_START;

    while (Index) {
        if ((Index > 1) &&
            ((BiosBlock->Address + BiosBlock->Size) == BiosBlock[1].Address)) {

            //
            // Coalesce adjacent blocks
            //

            BiosBlock[1].Address = BiosBlock[0].Address;
            BiosBlock[1].Size += BiosBlock[0].Size;
            Index--;
            BiosBlock++;
            continue;
        }

        BaseAddress = (PVOID)(BiosBlock->Address & ~(PAGE_SIZE - 1));
        EndingAddress = (BiosBlock->Address + BiosBlock->Size + PAGE_SIZE - 1) &
                        ~(PAGE_SIZE - 1);
        ViewSize = EndingAddress - (ULONG)BaseAddress;

        if ((ULONG)BaseAddress < LastMappedAddress) {
            if (ViewSize > (LastMappedAddress - (ULONG)BaseAddress)) {
                ViewSize = ViewSize - (LastMappedAddress - (ULONG)BaseAddress);
                BaseAddress = (PVOID)LastMappedAddress;
            } else {
                ViewSize = 0;
            }
        }
        ViewBase.LowPart = (ULONG)BaseAddress;

        if (ViewSize > 0) {

            //
            // Move FF to the non-ROM area to make it like nonexisting memory
            //

#if 0
            if ((ULONG)BaseAddress - LastMappedAddress > 0) {
                RtlFillMemory((PVOID)LastMappedAddress,
                              (ULONG)BaseAddress - LastMappedAddress,
                              0xFF
                              );
            }
#endif

            //
            // First unmap the reserved memory.  This must be done here to prevent
            // the virtual memory in question from being consumed by some other
            // alloc vm call.
            //

            ntStatus = ZwFreeVirtualMemory(
                NtCurrentProcess(),
                &BaseAddress,
                &ViewSize,
                MEM_RELEASE
                );

            // N.B.  This should probably take into account the fact that there are
            // a handfull of error conditions that are ok.  (such as no memory to
            // release.)

            if (!NT_SUCCESS(ntStatus)) {

                ZwClose(SectionHandle);
                ZwClose(RegistryHandle);
                ExFreePool(KeyValueBuffer);
                return;

            }

            ntStatus = ZwMapViewOfSection(
                SectionHandle,
                NtCurrentProcess(),
                &BaseAddress,
                0,
                ViewSize,
                &ViewBase,
                &ViewSize,
                ViewUnmap,
                MEM_DOS_LIM,
                PAGE_READWRITE
                );

            if (!NT_SUCCESS(ntStatus)) {
                break;
            }

            if(Int1ACodeAddress >= (ULONG)ViewBase.LowPart &&
               Int1ACodeAddress < (ULONG)ViewBase.LowPart + ViewSize) {

                Int1AIsValid = TRUE;
            }

            LastMappedAddress = (ULONG)BaseAddress + ViewSize;
        }

        Index--;
        BiosBlock++;
    }

    //
    // If some one hooked int1a but didn't report the hooked code as 
    // extended bios, we have to set int1a vector to its original value.
    // We've seen many instance of this problem in RIS setup. 
    // 

    if(!Int1AIsValid) {
        IntVectorAddress = (ULONG *) INT1A_VECTOR_ADDRESS;
        *IntVectorAddress = 0xF000FE6E;
    }

#if 0
    if (LastMappedAddress < ONE_MEG) {
        RtlFillMemory((PVOID)LastMappedAddress,
                      (ULONG)ONE_MEG - LastMappedAddress,
                      0xFF
                      );
    }
#endif

//#if DBG
//    BaseAddress = 0;
//    RegionSize = 0x1000;
//    ZwProtectVirtualMemory ( NtCurrentProcess(),
//                             &BaseAddress,
//                             &RegionSize,
//                             PAGE_NOACCESS,
//                             &OldProtect
//                             );
//#endif

    //
    // Free up the handles
    //

    ZwClose(SectionHandle);
    ZwClose(RegistryHandle);
    ExFreePool(KeyValueBuffer);

    KeAttachProcess(PEProcessToPKProcess(CsrProcess));

    // Crc324 - Calculate the Crc32 value of a string in 4 bit nibbles.
    //
    // dwCrc  - initial value of CRC
    // cbBuffer - count in bytes of length of buffer
    // pbBuffer - pointer to buffer to checksum
    //
    // returns: value of crc32
    //
    // this table is derived from the 256 element CRCTable in
    // \\orville\razzle\src\net\svcdlls\ntlmssp\client\crc32.c
    // This table contains every 16th element since we do 4 bits
    // at a time, not 8
    //

    {
        ULONG CRCTable4[16] = {
            0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,
            0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
            0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,
            0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c,
            };

        UCHAR byte;
        UCHAR index;
        ULONG cBuffer = 0x1000;
        PUCHAR pBuffer = (PUCHAR) 0x000C0000;

        while (cBuffer-- != 0)
        {
            byte = *pBuffer++;

            index = (byte ^ (UCHAR)(dwCrc) ) & 0xf;
            dwCrc = (dwCrc >> 4) ^ CRCTable4[index];

            byte  = byte >> 4;
            index = (byte ^ (UCHAR)(dwCrc) ) & 0xf;
            dwCrc = (dwCrc >> 4) ^ CRCTable4[index];
        }

        dwCrc ^= 0xFFFFFFFF;
    }

    KeDetachProcess();

    //
    // Write the Crc value into the registry.
    //

    VideoPortSetRegistryParameters(FdoExtension->HwDeviceExtension,
                                   L"HardwareInformation.Crc32",
                                   &dwCrc,
                                   sizeof(ULONG));

    //
    // Everything worked !
    //

    ServerBiosAddressSpaceInitialized = 1;

    return;
}


NTSTATUS
pVideoPortRegisterVDM(
    IN PFDO_EXTENSION FdoExtension,
    IN PVIDEO_VDM VdmInfo,
    IN ULONG VdmInfoSize,
    OUT PVIDEO_REGISTER_VDM RegisterVdm,
    IN ULONG RegisterVdmSize,
    OUT PULONG_PTR OutputSize
    )

/*++

Routine Description:

    This routine is used to register a VDM when it is started up.

    What this routine does is map the VIDEO BIOS into the VDM address space
    so that DOS apps can use it directly. Since the BIOS is READ_ONLY, we
    have no problem in mapping it as many times as we want.

    It returns the size of the save state buffer that must be allocated by
    the caller.

Arguments:

    DeviceExtension - Pointer to the port driver's device extension.

    VdmInfo - Pointer to the VDM information necessary to perform the
        operation.

    VdmInfoSize - Length of the information buffer.

    RegisterVdm - Pointer to the output buffer into which the save state
        size is stored.

    RegisterVdmSize - Length of the passed in output buffer.

    OutputSize - Pointer to the size of the data stored in the output buffer.
        Can also be the minimum required size of the output buffer is the
        passed in buffer was too small.

Return Value:

    STATUS_SUCCESS if the call completed successfully.

--*/

{

    //
    // Must make sure the caller is a trusted subsystem with the
    // appropriate privilege level before executing this call.
    // If the calls returns FALSE we must return an error code.
    //

    if (!SeSinglePrivilegeCheck(RtlConvertLongToLuid(
                                    SE_TCB_PRIVILEGE),
                                FdoExtension->CurrentIrpRequestorMode)) {

        return STATUS_PRIVILEGE_NOT_HELD;

    }

    //
    // Check the size of the output buffer.
    //

    if (RegisterVdmSize < sizeof(VIDEO_REGISTER_VDM)) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Return the size required for the save/restore state call.
    //

    *OutputSize = sizeof(VIDEO_REGISTER_VDM);
    RegisterVdm->MinimumStateSize = FdoExtension->HardwareStateSize;

    return STATUS_SUCCESS;

} // end pVideoPortRegisterVDM()

NTSTATUS
pVideoPortSetIOPM(
    IN ULONG NumAccessRanges,
    IN PVIDEO_ACCESS_RANGE AccessRange,
    IN BOOLEAN Enable,
    IN ULONG IOPMNumber
    )

/*++

Routine Description:

    This routine is used to change the IOPM. It modifies the IOPM based on
    the valid IO ports for the particular device.
    It retrieves the video IOPM mask, changes the access to the I/O ports of
    the specified device and stores the updated mask.

    -- This call can only be performed if the requesting process has the
    appropriate privileges, as determined by the security subsystem. --

Arguments:

    NumAccessRanges - Number of entries in the array of access ranges.

    AccessRange - Pointer to the array of access ranges.

    Enable - Determine if the port listed must be enabled or disabled in the
        mask.

    IOPMNumber - Number of the mask being manipulated.

Return Value:

    STATUS_SUCCESS if the call completed successfully.
    The status from the VideoPortQueryIOPM call if it failed.
    ...

    The return value is also stored in the StatusBlock.

--*/

{

    NTSTATUS ntStatus;
    PKIO_ACCESS_MAP accessMap;
    ULONG port;
    ULONG entries;

    //
    // Retrieve the existing permission mask. If this fails, return
    // immediately.
    //

    if ((accessMap = (PKIO_ACCESS_MAP)ExAllocatePoolWithTag(NonPagedPool,
                                                            IOPM_SIZE,
                                                            VP_TAG)) == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Get the kernel map copied into our buffer.
    //

    if (!Ke386QueryIoAccessMap(IOPMNumber,
                               accessMap)) {

        //
        // An error occured while *accessing* the map in the
        // kernel. Return an error and exit normally.
        //

        ExFreePool(accessMap);

        return STATUS_IO_PRIVILEGE_FAILED;

    }

    //
    // Give the calling process access to all the IO ports enabled by the
    // miniport driver in the access range.
    //

    for (entries = 0; entries < NumAccessRanges; entries++) {

        for (port = AccessRange[entries].RangeStart.LowPart;
             (AccessRange[entries].RangeInIoSpace) &&
                 (port < AccessRange[entries].RangeStart.LowPart +
                 AccessRange[entries].RangeLength);
             port++) {

            //
            // Change the port access in the mask:
            // Shift the port address by three to get the index in bytes into
            // the mask. Then take the bottom three bits of the port address
            // and shift 0x01 by that amount to get the right bit in that
            // byte. the bit values are:
            //      0 - access to the port
            //      1 - no access to the port
            //

            if (Enable && AccessRange[entries].RangeVisible) {

                //
                // To give access to a port, NAND 1 with the original port.
                // ex:  11111111 ~& 00001000 = 11110111
                // which gives you  access to the port who's bit was 1.
                // If the port we are enabling is in the current IOPM mask,
                // return an error instead.
                //

                (*accessMap)[port >> 3] &= ~(0x01 << (port & 0x07));

            } else {  // disable mask

                //
                // To remove access to a port, OR 1 with the original port.
                // ex:  11110100 | 00001000 = 11111100
                // which removes access to the port who's bit was 1.
                // If the port we are disabling is not in the current IOPM mask,
                // return an error instead.
                //

                (*accessMap)[port >> 3] |= (0x01 << (port &0x07));

            } // if (Enable) ... else

        } // for (port == ...

    } // for (entries = 0; ...

    //
    // If the mask was updated properly, with no errors, set the new mask.
    // Otherwise, leave the existing one.
    //

    if (Ke386SetIoAccessMap(IOPMNumber,
                                accessMap)) {

        //
        // If the map was created correctly, associate the map to the
        // requesting process. We only need to do this once when the
        // IOPM is first assigned. But we don't know when the first time
        // is.
        //

        if (Ke386IoSetAccessProcess(PEProcessToPKProcess(PsGetCurrentProcess()),
                                    IOPMNumber)) {

            ntStatus = STATUS_SUCCESS;

        } else {

            //
            // An error occured while *assigning* the map to
            // the process. Return an error and exit normally.
            //

            ntStatus = STATUS_IO_PRIVILEGE_FAILED;

        }

    } else {

        //
        // An error occured while *creating* the map in the
        // kernel. Return an error and exit normally.
        //

        ntStatus = STATUS_IO_PRIVILEGE_FAILED;

    } // if (Ke386Set ...) ... else

    //
    // Free the memory allocated for the map by the VideoPortQueryIOPM call
    // since the mask has been copied in the kernel TSS.
    //

    ExFreePool(accessMap);

    return ntStatus;

} // end pVideoPortSetIOPM();

VP_STATUS
VideoPortSetTrappedEmulatorPorts(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRange
    )

/*++

    VideoPortSetTrappedEmulatorPorts (x86 machines only) allows a miniport
    driver to dynamically change the list of I/O ports that are trapped when
    a VDM is running in full-screen mode. The default set of ports being
    trapped by the miniport driver is defined to be all ports in the
    EMULATOR_ACCESS_ENTRY structure of the miniport driver.
    I/O ports not listed in the EMULATOR_ACCESS_ENTRY structure are
    unavailable to the MS-DOS application.  Accessing those ports causes a
    trap to occur in the system, and the I/O operation to be reflected to a
    user-mode virtual device driver.

    The ports listed in the specified VIDEO_ACCESS_RANGE structure will be
    enabled in the I/O Permission Mask (IOPM) associated with the MS-DOS
    application.  This will enable the MS-DOS application to access those I/O
    ports directly, without having the IO instruction trap and be passed down
    to the miniport trap handling functions (for example EmulatorAccessEntry
    functions) for validation.  However, the subset of critical IO ports must
    always remain trapped for robustness.

    All MS-DOS applications use the same IOPM, and therefore the same set of
    enabled/disabled I/O ports.  Thus, on each switch of application, the
    set of trapped I/O ports is reinitialized to be the default set of ports
    (all ports in the EMULATOR_ACCESS_ENTRY structure).

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    NumAccessRanges - Specifies the number of entries in the VIDEO_ACCESS_RANGE
        structure specified in AccessRange.

    AccessRange - Points to an array of access ranges (VIDEO_ACCESS_RANGE)
        defining the ports that can be untrapped and accessed directly by
        the MS-DOS application.

Return Value:

    This function returns the final status of the operation.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{

    if (NT_SUCCESS(pVideoPortSetIOPM(NumAccessRanges,
                                     AccessRange,
                                     TRUE,
                                     1))) {

        return NO_ERROR;

    } else {

        return ERROR_INVALID_PARAMETER;

    }

} // end VideoPortSetTrappedEmulatorPorts()

NTSTATUS
pVideoPortGetVDMBiosData(
    PFDO_EXTENSION FdoExtension,
    PCHAR Buffer,
    ULONG Length
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN bAttachProcess = FALSE;
    PCHAR Memory;
    ULONG i;
    UCHAR uchar;

    if(!CsrProcess) return STATUS_INVALID_PARAMETER;

    ObReferenceObject(FdoExtension->VdmProcess);

    if (PsGetCurrentProcess() != FdoExtension->VdmProcess) {
   
        bAttachProcess = TRUE;
        KeAttachProcess(PEProcessToPKProcess(FdoExtension->VdmProcess));
    }

    //
    // Copy over Length bytes from VDM's Bios data area 
    //

    Memory = (PCHAR) 0x400; 

    try {
        RtlCopyMemory(Buffer, Memory, Length);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        NtStatus = GetExceptionCode();
    }

    if (bAttachProcess) {
        KeDetachProcess();
    }

    ObDereferenceObject(FdoExtension->VdmProcess);

    if (NtStatus != STATUS_SUCCESS) 
        return NtStatus;

    if (PsGetCurrentProcess() != CsrProcess)
    {
        bAttachProcess = TRUE;
        KeAttachProcess(PEProcessToPKProcess(CsrProcess));
    }

    //
    // Replace the Bios data area in CSRSS with that from VDM. At the
    // same time we save the original bios data in CSRSS.  The 
    // subsequent int10 calls from the driver could get the status 
    // of the hardware in VDM environment. 
    //
    // We'll improve this when we have a better approach
    //

    try {

        for (i = 0; i < Length; i++) {
            uchar = *Memory;
            *Memory++ = Buffer[i];
            Buffer[i] = uchar;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        NtStatus = GetExceptionCode();
    }

    if (bAttachProcess) {
        KeDetachProcess();
    }

    return NtStatus;
}

NTSTATUS
pVideoPortPutVDMBiosData(
    PFDO_EXTENSION FdoExtension,
    PCHAR Buffer,
    ULONG Length
    )
{

    BOOLEAN bAttachProcess = FALSE;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PCHAR Memory;

    if(!CsrProcess) return STATUS_INVALID_PARAMETER;

    if (PsGetCurrentProcess() != CsrProcess) {
   
        bAttachProcess = TRUE;
        KeAttachProcess(PEProcessToPKProcess(CsrProcess));
    }

    //
    // Copy over Length bytes from VDM's Bios data area 
    //

    Memory = (PCHAR) 0x400; 

    try {
        RtlCopyMemory(Memory, Buffer, Length);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        NtStatus = GetExceptionCode();
    }

    if (bAttachProcess) {
        KeDetachProcess();
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\port\ia64\portia64.c ===
/*--

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    portia64.c

Abstract:

    This is the IA64 specific part of the video port driver.

Author:

    William K. Cheung (wcheung)

    based on Andre Vachon (andreva) 10-Jan-1991

Environment:

    kernel mode only

Notes:

    This module is a driver which implements OS dependant functions on the
    behalf of the video drivers

Revision History:

--*/

#include "videoprt.h"
#include "emulate.h"

#define LOW_MEM_SEGMET 0

#define LOW_MEM_OFFSET 0

#define SIZE_OF_VECTOR_TABLE 0x400

#define SIZE_OF_BIOS_DATA_AREA 0x400

VOID
InitIoMemoryBase(
    VOID
    );

extern XM_STATUS x86BiosExecuteInterrupt (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL
    );

extern PVOID x86BiosTranslateAddress (
    IN USHORT Segment,
    IN USHORT Offset
    );

BOOLEAN
CallBiosEx (
    IN ULONG BiosCommand,
    IN OUT PULONG Eax,
    IN OUT PULONG Ebx,
    IN OUT PULONG Ecx,
    IN OUT PULONG Edx,
    IN OUT PULONG Esi,
    IN OUT PULONG Edi,
    IN OUT PULONG Ebp,
    IN OUT PUSHORT SegDs,
    IN OUT PUSHORT SegEs
    );

VOID
InitializeX86Int10CallEx(
    PUCHAR BiosTransferArea,
    ULONG BiosTransferLength
    );

VOID
InitializeX86Int10Call(
    PUCHAR BiosTransferArea,
    ULONG BiosTransferLength
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,InitIoMemoryBase)
#pragma alloc_text(PAGE,pVideoPortEnableVDM)
#pragma alloc_text(PAGE,VideoPortInt10)
#pragma alloc_text(PAGE,pVideoPortRegisterVDM)
#pragma alloc_text(PAGE,pVideoPortSetIOPM)
#pragma alloc_text(PAGE,VideoPortSetTrappedEmulatorPorts)
#pragma alloc_text(PAGE,pVideoPortInitializeInt10)
#pragma alloc_text(PAGE,CallBiosEx)
#pragma alloc_text(PAGE,InitializeX86Int10Call)
#pragma alloc_text(PAGE,VpInt10AllocateBuffer)
#pragma alloc_text(PAGE,VpInt10FreeBuffer)
#pragma alloc_text(PAGE,VpInt10ReadMemory)
#pragma alloc_text(PAGE,VpInt10WriteMemory)
#pragma alloc_text(PAGE,VpInt10CallBios)
#endif

//
// Initialize Default X86 bios spaces
//

PVOID IoControlBase = NULL;
PVOID IoMemoryBase =  NULL;


//
// Define global data.
//



ULONG X86BiosInitialized = FALSE;
ULONG EnableInt10Calls = FALSE;


VOID
InitIoMemoryBase(
    VOID
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/
{
    PHYSICAL_ADDRESS COMPATIBLE_PCI_PHYSICAL_BASE_ADDRESS = { 0x0};

    IoMemoryBase = (PUCHAR)MmMapIoSpace (
        COMPATIBLE_PCI_PHYSICAL_BASE_ADDRESS,
        0x100000,
        (MEMORY_CACHING_TYPE)MmNonCached
        );
    ASSERT(IoMemoryBase);
}


NTSTATUS
pVideoPortEnableVDM(
    IN PFDO_EXTENSION DeviceExtension,
    IN BOOLEAN Enable,
    IN PVIDEO_VDM VdmInfo,
    IN ULONG VdmInfoSize
    )

/*++

Routine Description:

    This routine allows the kernel video driver to unhook I/O ports or
    specific interrupts from the V86 fault handler. Operations on the
    specified ports will be forwarded back to the user-mode VDD once
    disconnection is completed.

Arguments:

    DeviceExtension - Pointer to the port driver's device extension.

    Enable - Determines if the VDM should be enabled (TRUE) or disabled
             (FALSE).

    VdmInfo - Pointer to the VdmInfo passed by the caller.

    VdmInfoSize - Size of the VdmInfo struct passed by the caller.

Return Value:

    STATUS_NOT_IMPLEMENTED

--*/

{

    UNREFERENCED_PARAMETER(DeviceExtension);
    UNREFERENCED_PARAMETER(VdmInfo);
    UNREFERENCED_PARAMETER(VdmInfoSize);

    return STATUS_NOT_IMPLEMENTED;

} // pVideoPortEnableVDM()

VP_STATUS
VideoPortInt10(
    PVOID HwDeviceExtension,
    PVIDEO_X86_BIOS_ARGUMENTS BiosArguments
    )

/*++

Routine Description:

    This function allows a miniport driver to call the kernel to perform
    an int10 operation.
    This will execute natively the BIOS ROM code on the device.

    THIS FUNCTION IS FOR X86 ONLY.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BiosArguments - Pointer to a structure containing the value of the
        basic x86 registers that should be set before calling the BIOS routine.
        0 should be used for unused registers.

Return Value:

    ERROR_INVALID_PARAMETER

--*/

{
    BOOLEAN bStatus;
    PFDO_EXTENSION deviceExtension = GET_FDO_EXT(HwDeviceExtension);
    ULONG inIoSpace = 0;
    PVOID virtualAddress;
    ULONG length;
    CONTEXT context;

    //
    // Must make sure the caller is a trusted subsystem with the
    // appropriate address space set up.
    //

    if (!SeSinglePrivilegeCheck(RtlConvertLongToLuid(
                                    SE_TCB_PRIVILEGE),
                                deviceExtension->CurrentIrpRequestorMode)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Now call the HAL to actually perform the int 10 operation.
    //

    pVideoDebugPrint 
    ((3, "VIDEOPRT: Int10: edi %x esi %x eax %x ebx %x \n\t ecx %x edx %x ebp %x\n",
       BiosArguments->Edi,
       BiosArguments->Esi,
       BiosArguments->Eax,
       BiosArguments->Ebx,
       BiosArguments->Ecx,
       BiosArguments->Edx,
       BiosArguments->Ebp ));

    //
    // Need to protect HalCallBios fro reentrance
    //
    KeWaitForSingleObject(&VpInt10Mutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          (PTIME)NULL);

    bStatus = HalCallBios (0x10,
                &(BiosArguments->Eax),
                &(BiosArguments->Ebx),
                &(BiosArguments->Ecx),
                &(BiosArguments->Edx),
                &(BiosArguments->Esi),
                &(BiosArguments->Edi),
                &(BiosArguments->Ebp));

    KeReleaseMutex(&VpInt10Mutex, FALSE);

    if (bStatus) {

        pVideoDebugPrint ((3, "VIDEOPRT: Int10: Int 10 succeded properly\n"));
        return NO_ERROR;

    } else {

        pVideoDebugPrint ((0, "VIDEOPRT: Int10: Int 10 failed\n"));
        return ERROR_INVALID_PARAMETER;

    }

} // end VideoPortInt10()


NTSTATUS
pVideoPortRegisterVDM(
    IN PFDO_EXTENSION DeviceExtension,
    IN PVIDEO_VDM VdmInfo,
    IN ULONG VdmInfoSize,
    OUT PVIDEO_REGISTER_VDM RegisterVdm,
    IN ULONG RegisterVdmSize,
    OUT PULONG_PTR OutputSize
    )

/*++

Routine Description:

    This routine is used to register a VDM when it is started up.

    What this routine does is map the VIDEO BIOS into the VDM address space
    so that DOS apps can use it directly. Since the BIOS is READ_ONLY, we
    have no problem in mapping it as many times as we want.

    It returns the size of the save state buffer that must be allocated by
    the caller.

Arguments:


Return Value:

    STATUS_NOT_IMPLEMENTED

--*/

{
    UNREFERENCED_PARAMETER(DeviceExtension);
    UNREFERENCED_PARAMETER(VdmInfo);
    UNREFERENCED_PARAMETER(VdmInfoSize);
    UNREFERENCED_PARAMETER(RegisterVdm);
    UNREFERENCED_PARAMETER(RegisterVdmSize);
    UNREFERENCED_PARAMETER(OutputSize);

    return STATUS_NOT_IMPLEMENTED;

} // end pVideoPortRegisterVDM()

NTSTATUS
pVideoPortSetIOPM(
    IN ULONG NumAccessRanges,
    IN PVIDEO_ACCESS_RANGE AccessRange,
    IN BOOLEAN Enable,
    IN ULONG IOPMNumber
    )

/*++

Routine Description:

    This routine is used to change the IOPM.
    This routine is x86 specific.

Arguments:


Return Value:

    STATUS_NOT_IMPLEMENTED

--*/

{

    UNREFERENCED_PARAMETER(NumAccessRanges);
    UNREFERENCED_PARAMETER(AccessRange);
    UNREFERENCED_PARAMETER(Enable);
    UNREFERENCED_PARAMETER(IOPMNumber);

    return STATUS_NOT_IMPLEMENTED;

} // end pVideoPortSetIOPM()


VP_STATUS
VideoPortSetTrappedEmulatorPorts(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRange
    )

/*++

Routine Description:

    VideoPortSetTrappedEmulatorPorts (x86 machines only) allows a miniport
    driver to dynamically change the list of I/O ports that are trapped when
    a VDM is running in full-screen mode. The default set of ports being
    trapped by the miniport driver is defined to be all ports in the
    EMULATOR_ACCESS_ENTRY structure of the miniport driver.
    I/O ports not listed in the EMULATOR_ACCESS_ENTRY structure are
    unavailable to the MS-DOS application.  Accessing those ports causes a
    trap to occur in the system, and the I/O operation to be reflected to a
    user-mode virtual device driver.
         
    The ports listed in the specified VIDEO_ACCESS_RANGE structure will be
    enabled in the I/O Permission Mask (IOPM) associated with the MS-DOS
    application.  This will enable the MS-DOS application to access those I/O
    ports directly, without having the IO instruction trap and be passed down
    to the miniport trap handling functions (for example EmulatorAccessEntry
    functions) for validation.  However, the subset of critical IO ports must
    always remain trapped for robustness.

    All MS-DOS applications use the same IOPM, and therefore the same set of
    enabled/disabled I/O ports.  Thus, on each switch of application, the
    set of trapped I/O ports is reinitialized to be the default set of ports
    (all ports in the EMULATOR_ACCESS_ENTRY structure).

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    NumAccessRanges - Specifies the number of entries in the VIDEO_ACCESS_RANGE
        structure specified in AccessRange.

    AccessRange - Points to an array of access ranges (VIDEO_ACCESS_RANGE)
        defining the ports that can be untrapped and accessed directly by
        the MS-DOS application.

Return Value:

    This function returns the final status of the operation.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{

    UNREFERENCED_PARAMETER(HwDeviceExtension);
    UNREFERENCED_PARAMETER(NumAccessRanges);
    UNREFERENCED_PARAMETER(AccessRange);
         
    return ERROR_INVALID_PARAMETER;

} // end VideoPortSetTrappedEmulatorPorts()

VOID
VideoPortZeroDeviceMemory(
    IN PVOID Destination,
    IN ULONG Length
    )

/*++

Routine Description:

    VideoPortZeroDeviceMemory zeroes a block of device memory of a certain
    length (Length) located at the address specified in Destination.

Arguments:

    Destination - Specifies the starting address of the block of memory to be
        zeroed.

    Length - Specifies the length, in bytes, of the memory to be zeroed.

 Return Value:

    None.

--*/

{

    RtlZeroMemory(Destination,Length);

}

VOID
pVideoPortInitializeInt10(
    PFDO_EXTENSION FdoExtension
    )

{
    if (ServerBiosAddressSpaceInitialized) {
        return;
    }

    BiosTransferArea = ExAllocatePool(PagedPool, 0x1000 + 3);
    InitializeX86Int10Call(BiosTransferArea, 0x1000);

    ServerBiosAddressSpaceInitialized = TRUE;
}


BOOLEAN
CallBiosEx (
    IN ULONG BiosCommand,
    IN OUT PULONG Eax,
    IN OUT PULONG Ebx,
    IN OUT PULONG Ecx,
    IN OUT PULONG Edx,
    IN OUT PULONG Esi,
    IN OUT PULONG Edi,
    IN OUT PULONG Ebp,
    IN OUT PUSHORT SegDs,
    IN OUT PUSHORT SegEs
    )

/*++

Routine Description:

    This function provides the platform specific interface between a device
    driver and the execution of the x86 ROM bios code for the specified ROM
    bios command.

Arguments:

    BiosCommand - Supplies the ROM bios command to be emulated.

    Eax to Ebp - Supplies the x86 emulation context.

Return Value:

    A value of TRUE is returned if the specified function is executed.
    Otherwise, a value of FALSE is returned.

--*/

{

    XM86_CONTEXT Context;

    //
    // If the x86 BIOS Emulator has not been initialized, then return FALSE.
    //

    if (X86BiosInitialized == FALSE) {
        return FALSE;
    }

    //
    // If the Adapter BIOS initialization failed and an Int10 command is
    // specified, then return FALSE.
    //

    if ((BiosCommand == 0x10) && (EnableInt10Calls == FALSE)) {
        return FALSE;
    }

    //
    // Copy the x86 bios context and emulate the specified command.
    //

    Context.Eax = *Eax;
    Context.Ebx = *Ebx;
    Context.Ecx = *Ecx;
    Context.Edx = *Edx;
    Context.Esi = *Esi;
    Context.Edi = *Edi;
    Context.Ebp = *Ebp;
    Context.SegDs = *SegDs;
    Context.SegEs = *SegEs;


    if (x86BiosExecuteInterrupt((UCHAR)BiosCommand,
        &Context,
        (PVOID)IoControlBase,
        (PVOID)IoMemoryBase) != XM_SUCCESS) {

    return FALSE;

    }

    //
    // Copy the x86 bios context and return TRUE.
    //

    *Eax = Context.Eax;
    *Ebx = Context.Ebx;
    *Ecx = Context.Ecx;
    *Edx = Context.Edx;
    *Esi = Context.Esi;
    *Edi = Context.Edi;
    *Ebp = Context.Ebp;
    *SegDs = Context.SegDs;
    *SegEs = Context.SegEs;
    return TRUE;
}

VOID
InitializeX86Int10Call(
    PUCHAR BiosTransferArea,
    ULONG BiosTransferLength
    )

/*++

Routine Description:

    This function initializes x86 bios emulator, display data area and
    interrupt vector area.


Arguments:

    None.

Return Value:

    None.

--*/

{
    XM86_CONTEXT State;
    PXM86_CONTEXT Context;
    PULONG x86BiosLowMemoryPtr, PhysicalMemoryPtr;

    InitIoMemoryBase();

    //
    // Initialize the x86 bios emulator.
    //

    x86BiosInitializeBiosEx(IoControlBase,
                            IoMemoryBase,
                            BiosTransferArea,
                            BiosTransferLength);

    x86BiosLowMemoryPtr = (PULONG)(x86BiosTranslateAddress(LOW_MEM_SEGMET, LOW_MEM_OFFSET));
    PhysicalMemoryPtr   = (PULONG) IoMemoryBase;

    //
    // Copy the VECTOR TABLE from 0 to 2k. This is because we are not executing
    // the initialization of Adapter since SAL takes care of it. However, the
    // emulation memory needs to be updated from the interrupt vector and BIOS
    // data area.
    //

    RtlCopyMemory(x86BiosLowMemoryPtr,
                  PhysicalMemoryPtr,
                  (SIZE_OF_VECTOR_TABLE+SIZE_OF_BIOS_DATA_AREA)
                  );


    X86BiosInitialized = TRUE;
    EnableInt10Calls = TRUE;
    return;
}

VP_STATUS
VpInt10AllocateBuffer(
    IN PVOID Context,
    OUT PUSHORT Seg,
    OUT PUSHORT Off,
    IN OUT PULONG Length
    )

{
    VP_STATUS Status = STATUS_INSUFFICIENT_RESOURCES;

    if (Int10BufferAllocated == FALSE) {

        if (*Length <= 0x1000) {

            *Seg = VDM_TRANSFER_SEGMENT;
            *Off = VDM_TRANSFER_OFFSET;

            Int10BufferAllocated = TRUE;

            Status = NO_ERROR;
        }
    }

    *Length = VDM_TRANSFER_LENGTH;
    return Status;
}

VP_STATUS
VpInt10FreeBuffer(
    IN PVOID Context,
    IN USHORT Seg,
    IN USHORT Off
    )

{
    VP_STATUS Status = STATUS_INVALID_PARAMETER;

    if ((Seg == VDM_TRANSFER_SEGMENT) && (Off = VDM_TRANSFER_OFFSET)) {

        if (Int10BufferAllocated == TRUE) {

            Int10BufferAllocated = FALSE;
            Status = NO_ERROR;
        }
    }

    return Status;
}

VP_STATUS
VpInt10ReadMemory(
    IN PVOID Context,
    IN USHORT Seg,
    IN USHORT Off,
    OUT PVOID Buffer,
    IN ULONG Length
    )

{
    ULONG_PTR Address = ((Seg << 4) + Off);

    if ((Address >= (VDM_TRANSFER_SEGMENT << 4)) &&
        ((Address + Length) <= ((VDM_TRANSFER_SEGMENT << 4) + VDM_TRANSFER_LENGTH))) {

        PUCHAR Memory = BiosTransferArea + Address - (VDM_TRANSFER_SEGMENT << 4);

        RtlCopyMemory(Buffer, Memory, Length);

    } else {

        RtlCopyMemory(Buffer, (PUCHAR)IoMemoryBase + Address, Length);
    }

    return NO_ERROR;

}

VP_STATUS
VpInt10WriteMemory(
    IN PVOID Context,
    IN USHORT Seg,
    IN USHORT Off,
    IN PVOID Buffer,
    IN ULONG Length
    )

{
    ULONG_PTR Address = ((Seg << 4) + Off);

    if ((Address >= (VDM_TRANSFER_SEGMENT << 4)) &&
        ((Address + Length) <= ((VDM_TRANSFER_SEGMENT << 4) + VDM_TRANSFER_LENGTH))) {

        PUCHAR Memory = BiosTransferArea + Address - (VDM_TRANSFER_SEGMENT << 4);

        RtlCopyMemory(Memory, Buffer, Length);

    } else {

        return STATUS_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

VP_STATUS
VpInt10CallBios(
    PVOID HwDeviceExtension,
    PINT10_BIOS_ARGUMENTS BiosArguments
    )

/*++

Routine Description:

    This function allows a miniport driver to call the kernel to perform
    an int10 operation.
    This will execute natively the BIOS ROM code on the device.

    THIS FUNCTION IS FOR X86 ONLY.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BiosArguments - Pointer to a structure containing the value of the
        basic x86 registers that should be set before calling the BIOS routine.
        0 should be used for unused registers.

Return Value:

    ERROR_INVALID_PARAMETER

--*/

{
    BOOLEAN bStatus;
    PFDO_EXTENSION deviceExtension = GET_FDO_EXT(HwDeviceExtension);
    ULONG inIoSpace = 0;
    PVOID virtualAddress;
    ULONG length;
    CONTEXT context;

    //
    // Must make sure the caller is a trusted subsystem with the
    // appropriate address space set up.
    //

    if (!SeSinglePrivilegeCheck(RtlConvertLongToLuid(
                                    SE_TCB_PRIVILEGE),
                                deviceExtension->CurrentIrpRequestorMode)) {

        return ERROR_INVALID_PARAMETER;

    }

    if (ServerBiosAddressSpaceInitialized == 0) {

        ASSERT(FALSE);

        return ERROR_INVALID_PARAMETER;
    }

    //
    // Now call the HAL to actually perform the int 10 operation.
    //

    pVideoDebugPrint 
    ((3, "VIDEOPRT: Int10: edi %x esi %x eax %x ebx %x \n\t ecx %x edx %x ebp %x ds %x es %x\n",
       BiosArguments->Edi,
       BiosArguments->Esi,
       BiosArguments->Eax,
       BiosArguments->Ebx,
       BiosArguments->Ecx,
       BiosArguments->Edx,
       BiosArguments->Ebp,
       BiosArguments->SegDs,
       BiosArguments->SegEs ));

    KeWaitForSingleObject(&VpInt10Mutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          (PTIME)NULL);

    bStatus = CallBiosEx (0x10,
                &(BiosArguments->Eax),
                &(BiosArguments->Ebx),
                &(BiosArguments->Ecx),
                &(BiosArguments->Edx),
                &(BiosArguments->Esi),
                &(BiosArguments->Edi),
                &(BiosArguments->Ebp),
                &(BiosArguments->SegDs),
                &(BiosArguments->SegEs));

    KeReleaseMutex(&VpInt10Mutex, FALSE);

    if (bStatus) {

        pVideoDebugPrint ((3, "VIDEOPRT: Int10: Int 10 succeded properly\n"));
        return NO_ERROR;

    } else {

        pVideoDebugPrint ((0, "VIDEOPRT: Int10: Int 10 failed\n"));
        return ERROR_INVALID_PARAMETER;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\brush.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: Brush.c
*
* Handles all brush/pattern initialization and realization.
*
* Copyright (c) 1992-1998 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vRealizeDitherPattern
*
* Generates an 8x8 dither pattern, in our internal realization format, for
* the colour ulRGBToDither.  Note that the high byte of ulRGBToDither does
* not need to be set to zero, because EngDitherColor ignores it.
\**************************************************************************/

VOID vRealizeDitherPattern(
HDEV        hdev,
RBRUSH*     prb,
ULONG       ulRGBToDither)
{
    // Do the actual dithering:

    EngDitherColor(hdev, DM_DEFAULT, ulRGBToDither, &prb->aulPattern[0]);

    // Initialize the fields we need:

    prb->ptlBrushOrg.x = LONG_MIN;
    prb->fl            = 0;
    prb->pbe           = NULL;
}

/******************************Public*Routine******************************\
* BOOL DrvRealizeBrush
*
* This function allows us to convert GDI brushes into an internal form
* we can use.  It may be called directly by GDI at SelectObject time, or
* it may be called by GDI as a result of us calling BRUSHOBJ_pvGetRbrush
* to create a realized brush in a function like DrvBitBlt.
*
* Note that we have no way of determining what the current Rop or brush
* alignment are at this point.
*
\**************************************************************************/

BOOL DrvRealizeBrush(
BRUSHOBJ*   pbo,
SURFOBJ*    psoDst,
SURFOBJ*    psoPattern,
SURFOBJ*    psoMask,
XLATEOBJ*   pxlo,
ULONG       iHatch)
{
    PDEV*       ppdev;
    ULONG       iPatternFormat;
    BYTE*       pjSrc;
    BYTE*       pjDst;
    LONG        lSrcDelta;
    LONG        cj;
    LONG        i;
    LONG        j;
    RBRUSH*     prb;
    ULONG*      pulXlate;
    SURFOBJ*    psoPunt;
    RECTL       rclDst;
    BOOL        b;

    ppdev = (PDEV*) psoDst->dhpdev;

    // We only handle brushes if we have an off-screen brush cache
    // available.  If there isn't one, we can simply fail the realization,
    // and eventually GDI will do the drawing for us (although a lot
    // slower than we could have done it):

    if (!(ppdev->flStatus & STAT_BRUSH_CACHE))
        goto ReturnFalse;

    // We have a fast path for dithers when we set GCAPS_DITHERONREALIZE:

    if (iHatch & RB_DITHERCOLOR)
    {
        // Implementing DITHERONREALIZE increased our score on a certain
        // unmentionable benchmark by 0.4 million 'megapixels'.  Too bad
        // this didn't work in the first version of NT.

        prb = BRUSHOBJ_pvAllocRbrush(pbo,
               sizeof(RBRUSH) + CONVERT_TO_BYTES(TOTAL_BRUSH_SIZE, ppdev));
        if (prb == NULL)
            goto ReturnFalse;

        vRealizeDitherPattern(psoDst->hdev, prb, iHatch);
        goto ReturnTrue;
    }

    // We only accelerate 8x8 patterns.  Since Win3.1 and Chicago don't
    // support patterns of any other size, it's a safe bet that 99.9%
    // of the patterns we'll ever get will be 8x8:

    if ((psoPattern->sizlBitmap.cx != 8) ||
        (psoPattern->sizlBitmap.cy != 8))
        goto ReturnFalse;

    iPatternFormat = psoPattern->iBitmapFormat;

    prb = BRUSHOBJ_pvAllocRbrush(pbo,
          sizeof(RBRUSH) + CONVERT_TO_BYTES(TOTAL_BRUSH_SIZE, ppdev));
    if (prb == NULL)
        goto ReturnFalse;

    // Initialize the fields we need:

    prb->ptlBrushOrg.x = LONG_MIN;
    prb->fl            = 0;
    prb->pbe           = NULL;

    lSrcDelta = psoPattern->lDelta;
    pjSrc     = (BYTE*) psoPattern->pvScan0;
    pjDst     = (BYTE*) &prb->aulPattern[0];

    if ((ppdev->iBitmapFormat == iPatternFormat) &&
        ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
    {
        DISPDBG((1, "Realizing un-translated brush"));

        // The pattern is the same colour depth as the screen, and
        // there's no translation to be done:

       cj = CONVERT_TO_BYTES(8, ppdev);  // Every pattern is 8 pels wide

        for (i = 8; i != 0; i--)
        {
            RtlCopyMemory(pjDst, pjSrc, cj);

            pjSrc += lSrcDelta;
            pjDst += cj;
        }
    }
    // Don't do monochrome expansion on 24 bpp due to s3 968 feature.
    else if ((iPatternFormat == BMF_1BPP) && (ppdev->iBitmapFormat != BMF_24BPP))
    {
        DISPDBG((1, "Realizing 1bpp brush"));

        // We word align the monochrome bitmap so that every row starts
        // on a new word (so that we can do word writes later to transfer
        // the bitmap):

        for (i = 8; i != 0; i--)
        {
            *pjDst = *pjSrc;
            pjDst += sizeof(WORD);
            pjSrc += lSrcDelta;
        }

        pulXlate         = pxlo->pulXlate;
        prb->fl         |= RBRUSH_2COLOR;
        prb->ulForeColor = pulXlate[1];
        prb->ulBackColor = pulXlate[0];
    }
    else if ((iPatternFormat == BMF_4BPP) && (ppdev->iBitmapFormat == BMF_8BPP))
    {
        DISPDBG((1, "Realizing 4bpp brush"));

        // The screen is 8bpp and the pattern is 4bpp:

        ASSERTDD((ppdev->iBitmapFormat == BMF_8BPP) &&
                 (iPatternFormat == BMF_4BPP),
                 "Messed up brush logic");

        pulXlate = pxlo->pulXlate;

        for (i = 8; i != 0; i--)
        {
            // Inner loop is repeated only 4 times because each loop
            // handles 2 pixels:

            for (j = 4; j != 0; j--)
            {
                *pjDst++ = (BYTE) pulXlate[*pjSrc >> 4];
                *pjDst++ = (BYTE) pulXlate[*pjSrc & 15];
                pjSrc++;
            }

            pjSrc += lSrcDelta - 4;
        }
    }
    else
    {
        // We've got a brush whose format we haven't special cased.  No
        // problem, we can have GDI convert it to our device's format.
        // We simply use a temporary surface object that was created with
        // the same format as the display, and point it to our brush
        // realization:

        DISPDBG((5, "Realizing funky brush"));

        psoPunt          = ppdev->psoBank;
        psoPunt->pvScan0 = pjDst;
        psoPunt->lDelta  = CONVERT_TO_BYTES(8, ppdev);

        rclDst.left      = 0;
        rclDst.top       = 0;
        rclDst.right     = 8;
        rclDst.bottom    = 8;

        b = EngCopyBits(psoPunt, psoPattern, NULL, pxlo,
                        &rclDst, (POINTL*) &rclDst);

        if (!b)
        {
            goto ReturnFalse;
        }
    }

ReturnTrue:

    if (!(ppdev->flCaps & CAPS_HW_PATTERNS))
    {
        // The last time I checked, GDI took some 500 odd instructions to
        // get from here back to whereever we called 'BRUSHOBJ_pvGetRbrush'.
        // We can at least use this time to get some overlap between the
        // CPU and the display hardware: we'll initialize the 72x72 off-
        // screen cache entry now, which will keep the accelerator busy for
        // a while.
        //
        // We don't do this if we have hardware patterns because:
        //
        //   a) S3 hardware patterns require that the off-screen cached
        //      brush be correctly aligned, and at this point we don't have
        //      access to the 'pptlBrush' brush origin (although we could
        //      have copied it into the PDEV before calling
        //      BRUSHOBJ_pvGetRbrush).
        //
        //   b) S3 hardware patterns require only an 8x8 copy of the
        //      pattern; it is not expanded to 72x72, so there isn't even
        //      any opportunity for CPU/accelerator processing overlap.

        vIoSlowPatRealize(ppdev, prb, FALSE);
    }

    return(TRUE);

ReturnFalse:

    if (psoPattern != NULL)
    {
        DISPDBG((1, "Failed realization -- Type: %li Format: %li cx: %li cy: %li",
                    psoPattern->iType, psoPattern->iBitmapFormat,
                    psoPattern->sizlBitmap.cx, psoPattern->sizlBitmap.cy));
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bEnableBrushCache
*
* Allocates off-screen memory for storing the brush cache.
\**************************************************************************/

BOOL bEnableBrushCache(
PDEV*   ppdev)
{
    DSURF*      pdsurf;
    BRUSHENTRY* pbe;            // Pointer to the brush-cache entry
    LONG        i;
    LONG        j;
    LONG        x;
    LONG        y;

    // Since the DirectDraw heap isn't enabled yet, we allocate memory
    // simply by chopping a row off the bottom of memory.

    pbe = &ppdev->abe[0];       // Points to where we'll put the first brush
                                //   cache entry

    if (ppdev->flCaps & CAPS_HW_PATTERNS)
    {
        if (ppdev->cyScreen > ppdev->cyHeap - FAST_BRUSH_ALLOCATION)
            goto ReturnTrue;
        
        ppdev->cyHeap -= FAST_BRUSH_ALLOCATION;

        x = 0;
        y = ppdev->cyHeap;

        ppdev->cBrushCache = FAST_BRUSH_COUNT;

        // Hardware brushes require that the x-coordinate start on an 8
        // pixel boundary.  The heap manager doesn't guarantee us any such
        // alignment, so we allocate a bit of extra room so that we can
        // do the alignment ourselves:

        for (i = FAST_BRUSH_COUNT; i != 0; i--)
        {
            // If we hadn't allocated 'ppdev' so that it was zero initialized,
            // we would have to initialize pbe->prbVerify too...

            pbe->x = x;
            pbe->y = y;

            x += FAST_BRUSH_ALLOCATION;
            pbe++;
        }

        // Remember the location of our 1x8 work area, which will be at
        // the right end of our brush array:

        ppdev->ptlReRealize.x = x;
        ppdev->ptlReRealize.y = y;
    }
    else
    {
        ppdev->pfnFillPat = vIoFillPatSlow;           // Override FillPatFast

        if (ppdev->cyScreen > ppdev->cyHeap - SLOW_BRUSH_CACHE_DIM 
                                            * SLOW_BRUSH_ALLOCATION)
            goto ReturnTrue;

        ppdev->cyHeap -= SLOW_BRUSH_CACHE_DIM * SLOW_BRUSH_ALLOCATION;

        x = 0;
        y = ppdev->cyHeap;

        ppdev->cBrushCache = SLOW_BRUSH_COUNT;

        for (i = 0; i < SLOW_BRUSH_CACHE_DIM; i++)
        {
            for (j = 0; j < SLOW_BRUSH_CACHE_DIM; j++)
            {
                pbe->x = x + (i * SLOW_BRUSH_ALLOCATION);
                pbe->y = y + (j * SLOW_BRUSH_ALLOCATION);
                pbe++;
            }
        }
    }

    // We successfully allocated the brush cache, so let's turn
    // on the switch showing that we can use it:

    ppdev->flStatus |= STAT_BRUSH_CACHE;

ReturnTrue:

    // If we couldn't allocate a brush cache, it's not a catastrophic
    // failure; patterns will still work, although they'll be a bit
    // slower since they'll go through GDI.  As a result we don't
    // actually have to fail this call:

    DISPDBG((5, "Passed bEnableBrushCache"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableBrushCache
*
* Cleans up anything done in bEnableBrushCache.
\**************************************************************************/

VOID vDisableBrushCache(PDEV* ppdev)
{
}

/******************************Public*Routine******************************\
* VOID vAssertModeBrushCache
*
* Resets the brush cache when we exit out of full-screen.
\**************************************************************************/

VOID vAssertModeBrushCache(
PDEV*   ppdev,
BOOL    bEnable)
{
    BRUSHENTRY* pbe;
    LONG        i;

    if (bEnable)
    {
        // Invalidate the brush cache:

        pbe = &ppdev->abe[0];

        for (i = ppdev->cBrushCache; i != 0; i--)
        {
            pbe->prbVerify = NULL;
            pbe++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\bltio.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: bltio.c
*
* Contains the low-level in/out blt functions.  This module mirrors
* 'bltmm.c'.
*
* Hopefully, if you're basing your display driver on this code, to
* support all of DrvBitBlt and DrvCopyBits, you'll only have to implement
* the following routines.  You shouldn't have to modify much in
* 'bitblt.c'.  I've tried to make these routines as few, modular, simple,
* and efficient as I could, while still accelerating as many calls as
* possible that would be cost-effective in terms of performance wins
* versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates
*       that haven't yet had the offscreen bitmap (DFB) offset applied.
*       'Absolute' coordinates have had the offset applied.  For example,
*       we may be told to blt to (1, 1) of the bitmap, but the bitmap may
*       be sitting in offscreen memory starting at coordinate (0, 768) --
*       (1, 1) would be the 'relative' start coordinate, and (1, 769)
*       would be the 'absolute' start coordinate'.
*
* Copyright (c) 1992-1998 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vIoImageTransferMm16
*
* Low-level routine for transferring a bitmap image via the data transfer
* register using 16 bit writes and memory-mapped I/O for the transfer,
* but I/O for the setup.
*
* NOTE: Upon entry, there must be 1 guaranteed free empty FIFO!
*
\**************************************************************************/

VOID vIoImageTransferMm16(  // Type FNIMAGETRANSFER
PDEV*   ppdev,
BYTE*   pjSrc,              // Source pointer
LONG    lDelta,             // Delta from start of scan to start of next
LONG    cjSrc,              // Number of bytes to be output on every scan
LONG    cScans,             // Number of scans
ULONG   ulCmd)              // Accelerator command - shouldn't include bus size
{
    BYTE*   pjMmBase;
    LONG    cwSrc;

    ASSERTDD(cScans > 0, "Can't handle non-positive count of scans");
    ASSERTDD((ulCmd & (BUS_SIZE_8 | BUS_SIZE_16 | BUS_SIZE_32)) == 0,
             "Shouldn't specify bus size in command -- we handle that");

    IO_GP_WAIT(ppdev);

    IO_CMD(ppdev, ulCmd | BUS_SIZE_16);

    CHECK_DATA_READY(ppdev);

    pjMmBase = ppdev->pjMmBase;

    cwSrc = (cjSrc) >> 1;               // Floor

    if (cjSrc & 1)
    {
        do {
            if (cwSrc > 0)
            {
                MM_TRANSFER_WORD(ppdev, pjMmBase, pjSrc, cwSrc);
            }

            // Make sure we do only a byte read of the last odd byte
            // in the scan so that we'll never read past the end of
            // the bitmap:

            MM_PIX_TRANS(ppdev, pjMmBase, *(pjSrc + cjSrc - 1));
            pjSrc += lDelta;

        } while (--cScans != 0);
    }
    else
    {
        do {
            MM_TRANSFER_WORD(ppdev, pjMmBase, pjSrc, cwSrc);
            pjSrc += lDelta;

        } while (--cScans != 0);
    }

    CHECK_DATA_COMPLETE(ppdev);
}

/******************************Public*Routine******************************\
* VOID vIoImageTransferIo16
*
* Low-level routine for transferring a bitmap image via the data transfer
* register using entirely normal I/O.
*
* NOTE: Upon entry, there must be 1 guaranteed free empty FIFO!
*
\**************************************************************************/

VOID vIoImageTransferIo16(  // Type FNIMAGETRANSFER
PDEV*   ppdev,
BYTE*   pjSrc,              // Source pointer
LONG    lDelta,             // Delta from start of scan to start of next
LONG    cjSrc,              // Number of bytes to be output on every scan
LONG    cScans,             // Number of scans
ULONG   ulCmd)              // Accelerator command - shouldn't include bus size
{
    LONG             cWait;
    LONG             cwSrc;
    volatile LONG    i;

    ASSERTDD(cScans > 0, "Can't handle non-positive count of scans");
    ASSERTDD((ulCmd & (BUS_SIZE_8 | BUS_SIZE_16 | BUS_SIZE_32)) == 0,
             "Shouldn't specify bus size in command -- we handle that");

    IO_GP_WAIT(ppdev);

    IO_CMD(ppdev, ulCmd | BUS_SIZE_16);

    CHECK_DATA_READY(ppdev);

    cwSrc = (cjSrc) >> 1;               // Floor

    // Old S3's in fast machines will drop data on monochrome transfers
    // unless we insert a busy loop.  '185' was the minimum value for which
    // my DEC AXP 150 with an ISA 911 S3 stopped dropping data:

    cWait = 0;
    if ((ulCmd & MULTIPLE_PIXELS) &&
        (ppdev->flCaps & CAPS_SLOW_MONO_EXPANDS))
    {
        cWait = 200;                // Add some time to be safe
    }

    if (cjSrc & 1)
    {
        do {
            if (cwSrc > 0)
            {
                IO_TRANSFER_WORD(ppdev, pjSrc, cwSrc);
            }

            // Make sure we do only a byte read of the last odd byte
            // in the scan so that we'll never read past the end of
            // the bitmap:

            IO_PIX_TRANS(ppdev, *(pjSrc + cjSrc - 1));
            pjSrc += lDelta;

            for (i = cWait; i != 0; i--)
                ;
        } while (--cScans != 0);
    }
    else
    {
        do {
            IO_TRANSFER_WORD(ppdev, pjSrc, cwSrc);
            pjSrc += lDelta;

            for (i = cWait; i != 0; i--)
                ;
        } while (--cScans != 0);
    }

    CHECK_DATA_COMPLETE(ppdev);
}

/******************************Public*Routine******************************\
* VOID vIoFillSolid
*
* Fills a list of rectangles with a solid colour.
*
\**************************************************************************/

VOID vIoFillSolid(              // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
POINTL*         pptlBrush)      // Not used
{
    ULONG   ulHwForeMix;

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    ulHwForeMix = gaulHwMixFromRop2[(rop4 >> 2) & 0xf];

    // It's quite likely that we've just been called from GDI, so it's
    // even more likely that the accelerator's graphics engine has been
    // sitting around idle.  Rather than doing a FIFO_WAIT(3) here and
    // then a FIFO_WAIT(5) before outputing the actual rectangle,
    // we can avoid an 'in' (which can be quite expensive, depending on
    // the card) by doing a single FIFO_WAIT(8) right off the bat:

    if (DEPTH32(ppdev))
    {
        IO_FIFO_WAIT(ppdev, 4);
        IO_PIX_CNTL(ppdev, ALL_ONES);
        IO_FRGD_MIX(ppdev, FOREGROUND_COLOR | ulHwForeMix);
        IO_FRGD_COLOR32(ppdev, rbc.iSolidColor);
        IO_FIFO_WAIT(ppdev, 5);
    }
    else
    {
        IO_FIFO_WAIT(ppdev, 8);
        IO_PIX_CNTL(ppdev, ALL_ONES);
        IO_FRGD_MIX(ppdev, FOREGROUND_COLOR | ulHwForeMix);
        IO_FRGD_COLOR(ppdev, rbc.iSolidColor);
    }

    while(TRUE)
    {
        IO_CUR_X(ppdev, prcl->left);
        IO_CUR_Y(ppdev, prcl->top);
        IO_MAJ_AXIS_PCNT(ppdev, prcl->right  - prcl->left - 1);
        IO_MIN_AXIS_PCNT(ppdev, prcl->bottom - prcl->top  - 1);

        IO_CMD(ppdev, RECTANGLE_FILL | DRAWING_DIR_TBLRXM |
                      DRAW           | DIR_TYPE_XY        |
                      LAST_PIXEL_ON  | MULTIPLE_PIXELS    |
                      WRITE);

        if (--c == 0)
            return;

        prcl++;
        IO_FIFO_WAIT(ppdev, 5);
    }
}

/******************************Public*Routine******************************\
* VOID vIoSlowPatRealize
*
* This routine transfers an 8x8 pattern to off-screen display memory, and
* duplicates it to make a 64x64 cached realization which is then used by
* vIoFillPatSlow as the basic building block for doing 'slow' pattern output
* via repeated screen-to-screen blts.
*
\**************************************************************************/

VOID vIoSlowPatRealize(
PDEV*   ppdev,
RBRUSH* prb,                    // Points to brush realization structure
BOOL    bTransparent)           // FALSE for normal patterns; TRUE for
                                //   patterns with a mask when the background
                                //   mix is LEAVE_ALONE.
{
    BRUSHENTRY* pbe;
    LONG        iBrushCache;
    LONG        x;
    LONG        y;
    BYTE*       pjPattern;
    LONG        cwPattern;

    pbe = prb->pbe;
    if ((pbe == NULL) || (pbe->prbVerify != prb))
    {
        // We have to allocate a new off-screen cache brush entry for
        // the brush:

        iBrushCache = ppdev->iBrushCache;
        pbe         = &ppdev->abe[iBrushCache];

        iBrushCache++;
        if (iBrushCache >= ppdev->cBrushCache)
            iBrushCache = 0;

        ppdev->iBrushCache = iBrushCache;

        // Update our links:

        pbe->prbVerify           = prb;
        prb->pbe                 = pbe;
    }

    // Load some pointer variables onto the stack, so that we don't have
    // to keep dereferencing their pointers:

    x = pbe->x;
    y = pbe->y;

    prb->bTransparent = bTransparent;

    // I considered doing the colour expansion for 1bpp brushes in
    // software, but by letting the hardware do it, we don't have
    // to do as many OUTs to transfer the pattern.

    if (prb->fl & RBRUSH_2COLOR)
    {
        // We're going to do a colour-expansion ('across the plane')
        // bitblt of the 1bpp 8x8 pattern to the screen.

        if (!bTransparent)
        {
            IO_FIFO_WAIT(ppdev, 4);

            IO_FRGD_MIX(ppdev, FOREGROUND_COLOR | OVERPAINT);
            IO_BKGD_MIX(ppdev, BACKGROUND_COLOR | OVERPAINT);
            IO_FRGD_COLOR(ppdev, prb->ulForeColor);
            IO_BKGD_COLOR(ppdev, prb->ulBackColor);

            IO_FIFO_WAIT(ppdev, 5);
        }
        else
        {
            IO_FIFO_WAIT(ppdev, 7);

            IO_FRGD_MIX(ppdev, LOGICAL_1);
            IO_BKGD_MIX(ppdev, LOGICAL_0);
        }

        IO_PIX_CNTL(ppdev, CPU_DATA);
        IO_ABS_CUR_X(ppdev, x);
        IO_ABS_CUR_Y(ppdev, y);
        IO_MAJ_AXIS_PCNT(ppdev, 7); // Brush is 8 wide
        IO_MIN_AXIS_PCNT(ppdev, 7); // Brush is 8 high

        IO_GP_WAIT(ppdev);

        IO_CMD(ppdev, RECTANGLE_FILL     | BUS_SIZE_16 | WAIT          |
                      DRAWING_DIR_TBLRXM | DRAW        | LAST_PIXEL_ON |
                      MULTIPLE_PIXELS    | WRITE       | BYTE_SWAP);

        CHECK_DATA_READY(ppdev);

        pjPattern = (BYTE*) &prb->aulPattern[0];
        IO_TRANSFER_WORD_ALIGNED(ppdev, pjPattern, 8);
                // Each word transferred comprises one row of the
                //   pattern, and there are 8 rows in the pattern

        CHECK_DATA_COMPLETE(ppdev);
    }
    else
    {
        ASSERTDD(!bTransparent,
            "Shouldn't have been asked for transparency with a non-1bpp brush");

        IO_FIFO_WAIT(ppdev, 6);

        IO_PIX_CNTL(ppdev, ALL_ONES);
        IO_FRGD_MIX(ppdev, SRC_CPU_DATA | OVERPAINT);
        IO_ABS_CUR_X(ppdev, x);
        IO_ABS_CUR_Y(ppdev, y);
        IO_MAJ_AXIS_PCNT(ppdev, 7);     // Brush is 8 wide
        IO_MIN_AXIS_PCNT(ppdev, 7);     // Brush is 8 high

        IO_GP_WAIT(ppdev);

        IO_CMD(ppdev, RECTANGLE_FILL     | BUS_SIZE_16| WAIT          |
                      DRAWING_DIR_TBLRXM | DRAW       | LAST_PIXEL_ON |
                      SINGLE_PIXEL       | WRITE      | BYTE_SWAP);

        CHECK_DATA_READY(ppdev);

        pjPattern = (BYTE*) &prb->aulPattern[0];
        cwPattern = CONVERT_TO_BYTES((TOTAL_BRUSH_SIZE / 2), ppdev);
        IO_TRANSFER_WORD_ALIGNED(ppdev, pjPattern, cwPattern);

        CHECK_DATA_COMPLETE(ppdev);
    }

    // Ŀ
    // 023  4      1 We now have an 8x8 colour-expanded copy of
    // Ĵ the pattern sitting in off-screen memory,
    // 5                 represented here by square '0'.
    //                  
    //                   We're now going to expand the pattern to
    //                   72x72 by repeatedly copying larger rectangles
    //                   in the indicated order, and doing a 'rolling'
    //                   blt to copy vertically.
    //                  
    // 

    // Copy '1':

    IO_FIFO_WAIT(ppdev, 6);

    IO_PIX_CNTL(ppdev, ALL_ONES);
    IO_FRGD_MIX(ppdev, SRC_DISPLAY_MEMORY | OVERPAINT);

    // Note that 'cur_x', 'maj_axis_pcnt' and 'min_axis_pcnt' are already
    // correct.

    IO_ABS_CUR_Y(ppdev, y);
    IO_ABS_DEST_X(ppdev, x + 64);
    IO_ABS_DEST_Y(ppdev, y);
    IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                  MULTIPLE_PIXELS | DRAWING_DIR_TBLRXM);

    // Copy '2':

    IO_FIFO_WAIT(ppdev, 7);

    IO_ABS_DEST_X(ppdev, x + 8);
    IO_ABS_DEST_Y(ppdev, y);
    IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                  MULTIPLE_PIXELS | DRAWING_DIR_TBLRXM);

    // Copy '3':

    IO_ABS_DEST_X(ppdev, x + 16);
    IO_ABS_DEST_Y(ppdev, y);
    IO_MAJ_AXIS_PCNT(ppdev, 15);
    IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                  MULTIPLE_PIXELS | DRAWING_DIR_TBLRXM);

    // Copy '4':

    IO_FIFO_WAIT(ppdev, 8);

    IO_ABS_DEST_X(ppdev, x + 32);
    IO_ABS_DEST_Y(ppdev, y);
    IO_MAJ_AXIS_PCNT(ppdev, 31);
    IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                  MULTIPLE_PIXELS | DRAWING_DIR_TBLRXM);

    // Copy '5':

    IO_ABS_DEST_X(ppdev, x);
    IO_MAJ_AXIS_PCNT(ppdev, 71);
    IO_MIN_AXIS_PCNT(ppdev, 63);
    IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                  MULTIPLE_PIXELS | DRAWING_DIR_TBLRXM);
}

/******************************Public*Routine******************************\
* VOID vIoFillPatSlow
*
* Uses the screen-to-screen blting ability of the accelerator to fill a
* list of rectangles with a specified pattern.  This routine is 'slow'
* merely in the sense that it doesn't use any built-in hardware pattern
* support that may be built into the accelerator.
*
\**************************************************************************/

VOID vIoFillPatSlow(            // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BOOL        bTransparent;
    ULONG       ulHwForeMix;
    BOOL        bExponential;
    LONG        x;
    LONG        y;
    LONG        cxToGo;
    LONG        cyToGo;
    LONG        cxThis;
    LONG        cyThis;
    LONG        xOrg;
    LONG        yOrg;
    LONG        xBrush;
    LONG        yBrush;
    LONG        cyOriginal;
    BRUSHENTRY* pbe;        // Pointer to brush entry data, which is used
                            //   for keeping track of the location and status
                            //   of the pattern bits cached in off-screen
                            //   memory

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(rbc.prb->pbe != NULL,
             "Unexpected Null pbe in vIoFillPatSlow");
    ASSERTDD(!(ppdev->flCaps & CAPS_HW_PATTERNS),
             "Shouldn't use slow patterns when can do hw patterns");

    bTransparent = (((rop4 >> 8) & 0xff) != (rop4 & 0xff));

    if ((rbc.prb->pbe->prbVerify != rbc.prb) ||
        (rbc.prb->bTransparent != bTransparent))
    {
        vIoSlowPatRealize(ppdev, rbc.prb, bTransparent);
    }

    ASSERTDD(rbc.prb->bTransparent == bTransparent,
             "Not realized with correct transparency");

    ulHwForeMix = gaulHwMixFromRop2[(rop4 >> 2) & 0xf];

    if (!bTransparent)
    {
        IO_FIFO_WAIT(ppdev, 2);
        IO_PIX_CNTL(ppdev, ALL_ONES);
        IO_FRGD_MIX(ppdev, SRC_DISPLAY_MEMORY | ulHwForeMix);

        // We special case OVERPAINT mixes because we can implement
        // an exponential fill: every blt will double the size of
        // the current rectangle by using the portion of the pattern
        // that has already been done for this rectangle as the source.
        //
        // Note that there's no point in also checking for LOGICAL_0
        // or LOGICAL_1 because those will be taken care of by the
        // solid fill routines, and I can't be bothered to check for
        // NOTNEW:

        bExponential = (ulHwForeMix == OVERPAINT);
    }
    else
    {
        IO_FIFO_WAIT(ppdev, 5);

        IO_PIX_CNTL(ppdev, DISPLAY_MEMORY);
        IO_FRGD_MIX(ppdev, FOREGROUND_COLOR | ulHwForeMix);
        IO_BKGD_MIX(ppdev, BACKGROUND_COLOR | LEAVE_ALONE);
        IO_FRGD_COLOR(ppdev, rbc.prb->ulForeColor);
        IO_RD_MASK(ppdev, 1);           // Pick a plane, any plane

        bExponential = FALSE;
    }

    // Note that since we do our brush alignment calculations in
    // relative coordinates, we should keep the brush origin in
    // relative coordinates as well:

    xOrg = pptlBrush->x;
    yOrg = pptlBrush->y;

    pbe    = rbc.prb->pbe;
    xBrush = pbe->x;
    yBrush = pbe->y;

    do {
        x = prcl->left;
        y = prcl->top;

        cxToGo = prcl->right  - x;
        cyToGo = prcl->bottom - y;

        if ((cxToGo <= SLOW_BRUSH_DIMENSION) &&
            (cyToGo <= SLOW_BRUSH_DIMENSION))
        {
            IO_FIFO_WAIT(ppdev, 7);
            IO_ABS_CUR_X(ppdev, ((x - xOrg) & 7) + xBrush);
            IO_ABS_CUR_Y(ppdev, ((y - yOrg) & 7) + yBrush);
            IO_DEST_X(ppdev, x);
            IO_DEST_Y(ppdev, y);
            IO_MAJ_AXIS_PCNT(ppdev, cxToGo - 1);
            IO_MIN_AXIS_PCNT(ppdev, cyToGo - 1);
            IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                          MULTIPLE_PIXELS | DRAWING_DIR_TBLRXM);
        }

        else if (bExponential)
        {
            cyThis  = SLOW_BRUSH_DIMENSION;
            cyToGo -= cyThis;
            if (cyToGo < 0)
                cyThis += cyToGo;

            cxThis  = SLOW_BRUSH_DIMENSION;
            cxToGo -= cxThis;
            if (cxToGo < 0)
                cxThis += cxToGo;

            IO_FIFO_WAIT(ppdev, 7);
            IO_MAJ_AXIS_PCNT(ppdev, cxThis - 1);
            IO_MIN_AXIS_PCNT(ppdev, cyThis - 1);
            IO_DEST_X(ppdev, x);
            IO_DEST_Y(ppdev, y);
            IO_ABS_CUR_X(ppdev, ((x - xOrg) & 7) + xBrush);
            IO_ABS_CUR_Y(ppdev, ((y - yOrg) & 7) + yBrush);
            IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                          MULTIPLE_PIXELS | DRAWING_DIR_TBLRXM);

            IO_FIFO_WAIT(ppdev, 2);
            IO_CUR_X(ppdev, x);
            IO_CUR_Y(ppdev, y);

            x += cxThis;

            while (cxToGo > 0)
            {
                // First, expand out to the right, doubling our size
                // each time:

                cxToGo -= cxThis;
                if (cxToGo < 0)
                    cxThis += cxToGo;

                IO_FIFO_WAIT(ppdev, 4);
                IO_MAJ_AXIS_PCNT(ppdev, cxThis - 1);
                IO_DEST_X(ppdev, x);
                IO_DEST_Y(ppdev, y);
                IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                              MULTIPLE_PIXELS | DRAWING_DIR_TBLRXM);

                x      += cxThis;
                cxThis *= 2;
            }

            if (cyToGo > 0)
            {
                // Now do a 'rolling blt' to pattern the rest vertically:

                IO_FIFO_WAIT(ppdev, 4);
                IO_DEST_X(ppdev, prcl->left);
                IO_MAJ_AXIS_PCNT(ppdev, prcl->right - prcl->left - 1);
                IO_MIN_AXIS_PCNT(ppdev, cyToGo - 1);
                IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                              MULTIPLE_PIXELS | DRAWING_DIR_TBLRXM);
            }
        }
        else
        {
            // We handle arbitrary mixes simply by repeatedly tiling
            // our cached pattern over the entire rectangle:

            IO_FIFO_WAIT(ppdev, 2);
            IO_ABS_CUR_X(ppdev, ((x - xOrg) & 7) + xBrush);
            IO_ABS_CUR_Y(ppdev, ((y - yOrg) & 7) + yBrush);

            cyOriginal = cyToGo;        // Have to remember for later...

            do {
                cxThis  = SLOW_BRUSH_DIMENSION;
                cxToGo -= cxThis;
                if (cxToGo < 0)
                    cxThis += cxToGo;

                IO_FIFO_WAIT(ppdev, 3);
                IO_MAJ_AXIS_PCNT(ppdev, cxThis - 1);
                IO_DEST_Y(ppdev, y);
                IO_DEST_X(ppdev, x);

                x     += cxThis;        // Get ready for next column
                cyToGo = cyOriginal;    // Have to reset for each new column

                do {
                    cyThis  = SLOW_BRUSH_DIMENSION;
                    cyToGo -= cyThis;
                    if (cyToGo < 0)
                        cyThis += cyToGo;

                    IO_FIFO_WAIT(ppdev, 2);
                    IO_MIN_AXIS_PCNT(ppdev, cyThis - 1);
                    IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                                  MULTIPLE_PIXELS | DRAWING_DIR_TBLRXM);

                } while (cyToGo > 0);
            } while (cxToGo > 0);
        }
        prcl++;
    } while (--c != 0);
}

/******************************Public*Routine******************************\
* VOID vIoFastPatRealize
*
* This routine transfers an 8x8 pattern to off-screen display memory,
* so that it can be used by the S3 pattern hardware.
*
\**************************************************************************/

VOID vIoFastPatRealize(         // Type FNFASTPATREALIZE
PDEV*   ppdev,
RBRUSH* prb,                    // Points to brush realization structure
POINTL* pptlBrush,              // Brush origin for aligning realization
BOOL    bTransparent)           // FALSE for normal patterns; TRUE for
                                //   patterns with a mask when the background
                                //   mix is LEAVE_ALONE.
{
    BRUSHENTRY* pbe;
    LONG        iBrushCache;
    LONG        x;
    LONG        y;
    LONG        i;
    LONG        xShift;
    LONG        yShift;
    BYTE*       pjSrc;
    BYTE*       pjDst;
    LONG        cjLeft;
    LONG        cjRight;
    BYTE*       pjPattern;
    LONG        cwPattern;

    ULONG       aulBrush[TOTAL_BRUSH_SIZE];
                    // Temporary buffer for aligning brush.  Declared
                    //   as an array of ULONGs to get proper dword
                    //   alignment.  Also leaves room for brushes that
                    //   are up to 32bpp.  Note: this takes up 1/4k!

    pbe = prb->pbe;
    if ((pbe == NULL) || (pbe->prbVerify != prb))
    {
        // We have to allocate a new off-screen cache brush entry for
        // the brush:

        iBrushCache = ppdev->iBrushCache;
        pbe         = &ppdev->abe[iBrushCache];

        iBrushCache++;
        if (iBrushCache >= ppdev->cBrushCache)
            iBrushCache = 0;

        ppdev->iBrushCache = iBrushCache;

        // Update our links:

        pbe->prbVerify           = prb;
        prb->pbe                 = pbe;
    }

    // Load some variables onto the stack, so that we don't have to keep
    // dereferencing their pointers:

    x = pbe->x;
    y = pbe->y;

    // Because we handle only 8x8 brushes, it is easy to compute the
    // number of pels by which we have to rotate the brush pattern
    // right and down.  Note that if we were to handle arbitrary sized
    // patterns, this calculation would require a modulus operation.
    //
    // The brush is aligned in absolute coordinates, so we have to add
    // in the surface offset:

    xShift = pptlBrush->x + ppdev->xOffset;
    yShift = pptlBrush->y + ppdev->yOffset;

    prb->ptlBrushOrg.x = xShift;    // We have to remember the alignment
    prb->ptlBrushOrg.y = yShift;    //   that we used for caching (we check
                                    //   this when we go to see if a brush's
                                    //   cache entry is still valid)

    xShift &= 7;                    // Rotate pattern 'xShift' pels right
    yShift &= 7;                    // Rotate pattern 'yShift' pels down

    prb->bTransparent = bTransparent;

    // I considered doing the colour expansion for 1bpp brushes in
    // software, but by letting the hardware do it, we don't have
    // to do as many OUTs to transfer the pattern.

    if (prb->fl & RBRUSH_2COLOR)
    {
        // We're going to do a colour-expansion ('across the plane')
        // bitblt of the 1bpp 8x8 pattern to the screen.  But first
        // we'll align it properly by copying it to a temporary buffer
        // (which we'll conveniently pack word aligned so that we can do a
        // REP OUTSW...)

        pjSrc = (BYTE*) &prb->aulPattern[0];    // Copy from the start of the
                                                //   brush buffer
        pjDst = (BYTE*) &aulBrush[0];           // Copy to our temp buffer
        pjDst += yShift * sizeof(WORD);         //   starting yShift rows down
        i = 8 - yShift;                         //   for 8 - yShift rows

        do {
            *pjDst = (*pjSrc >> xShift) | (*pjSrc << (8 - xShift));
            pjDst += sizeof(WORD);  // Destination is word packed
            pjSrc += sizeof(WORD);  // Source is word aligned too

        } while (--i != 0);

        pjDst -= 8 * sizeof(WORD);  // Move to the beginning of the source

        ASSERTDD(pjDst == (BYTE*) &aulBrush[0], "pjDst not back at start");

        for (; yShift != 0; yShift--)
        {
            *pjDst = (*pjSrc >> xShift) | (*pjSrc << (8 - xShift));
            pjDst += sizeof(WORD);  // Destination is word packed
            pjSrc += sizeof(WORD);  // Source is word aligned too
        }

        if (bTransparent)
        {
            IO_FIFO_WAIT(ppdev, 3);

            IO_PIX_CNTL(ppdev, CPU_DATA);
            IO_FRGD_MIX(ppdev, LOGICAL_1);
            IO_BKGD_MIX(ppdev, LOGICAL_0);
        }
        else
        {
            if (DEPTH32(ppdev))
            {
                IO_FIFO_WAIT(ppdev, 7);

                IO_PIX_CNTL(ppdev, CPU_DATA);
                IO_FRGD_MIX(ppdev, FOREGROUND_COLOR | OVERPAINT);
                IO_BKGD_MIX(ppdev, BACKGROUND_COLOR | OVERPAINT);
                IO_FRGD_COLOR32(ppdev, prb->ulForeColor);
                IO_BKGD_COLOR32(ppdev, prb->ulBackColor);
            }
            else
            {
                IO_FIFO_WAIT(ppdev, 5);

                IO_PIX_CNTL(ppdev, CPU_DATA);
                IO_FRGD_MIX(ppdev, FOREGROUND_COLOR | OVERPAINT);
                IO_BKGD_MIX(ppdev, BACKGROUND_COLOR | OVERPAINT);
                IO_FRGD_COLOR(ppdev, prb->ulForeColor);
                IO_BKGD_COLOR(ppdev, prb->ulBackColor);
            }
        }

        IO_FIFO_WAIT(ppdev, 4);

        IO_ABS_CUR_X(ppdev, x);
        IO_ABS_CUR_Y(ppdev, y);
        IO_MAJ_AXIS_PCNT(ppdev, 7); // Brush is 8 wide
        IO_MIN_AXIS_PCNT(ppdev, 7); // Brush is 8 high

        IO_GP_WAIT(ppdev);

        IO_CMD(ppdev, RECTANGLE_FILL     | BUS_SIZE_16 | WAIT          |
                      DRAWING_DIR_TBLRXM | DRAW        | LAST_PIXEL_ON |
                      MULTIPLE_PIXELS    | WRITE       | BYTE_SWAP);

        CHECK_DATA_READY(ppdev);

        pjPattern = (BYTE*) &aulBrush[0];
        IO_TRANSFER_WORD_ALIGNED(ppdev, pjPattern, 8);
                                                // Each word transferred
                                                //   comprises one row of the
                                                //   pattern, and there are
                                                //   8 rows in the pattern

        CHECK_DATA_COMPLETE(ppdev);
    }
    else
    {
        ASSERTDD(!bTransparent,
            "Shouldn't have been asked for transparency with a non-1bpp brush");

        // We're going to do a straight ('through the plane') bitblt
        // of the Xbpp 8x8 pattern to the screen.  But first we'll align
        // it properly by copying it to a temporary buffer:

        cjLeft  = CONVERT_TO_BYTES(xShift, ppdev);     // Number of bytes pattern
                                                       //   is shifted to the right
        cjRight = CONVERT_TO_BYTES(8, ppdev) - cjLeft; // Number of bytes pattern
                                                       //   is shifted to the left

        pjSrc = (BYTE*) &prb->aulPattern[0];           // Copy from brush buffer
        pjDst = (BYTE*) &aulBrush[0];                  // Copy to our temp buffer
        pjDst += yShift * CONVERT_TO_BYTES(8, ppdev);  //   starting yShift rows
        i = 8 - yShift;                                //   down for 8 - yShift rows

        do {
            RtlCopyMemory(pjDst + cjLeft, pjSrc,           cjRight);
            RtlCopyMemory(pjDst,          pjSrc + cjRight, cjLeft);

            pjDst += cjLeft + cjRight;
            pjSrc += cjLeft + cjRight;

        } while (--i != 0);

        pjDst = (BYTE*) &aulBrush[0];   // Move to the beginning of destination

        for (; yShift != 0; yShift--)
        {
            RtlCopyMemory(pjDst + cjLeft, pjSrc,           cjRight);
            RtlCopyMemory(pjDst,          pjSrc + cjRight, cjLeft);

            pjDst += cjLeft + cjRight;
            pjSrc += cjLeft + cjRight;

        }

        IO_FIFO_WAIT(ppdev, 6);

        IO_PIX_CNTL(ppdev, ALL_ONES);
        IO_FRGD_MIX(ppdev, SRC_CPU_DATA | OVERPAINT);

        IO_ABS_CUR_X(ppdev, x);
        IO_ABS_CUR_Y(ppdev, y);
        IO_MAJ_AXIS_PCNT(ppdev, 7);     // Brush is 8 wide
        IO_MIN_AXIS_PCNT(ppdev, 7);     // Brush is 8 high

        IO_GP_WAIT(ppdev);

        IO_CMD(ppdev, RECTANGLE_FILL     | BUS_SIZE_16| WAIT          |
                      DRAWING_DIR_TBLRXM | DRAW       | LAST_PIXEL_ON |
                      SINGLE_PIXEL       | WRITE      | BYTE_SWAP);

        CHECK_DATA_READY(ppdev);

        pjPattern = (BYTE*) &aulBrush[0];
        cwPattern = CONVERT_TO_BYTES((TOTAL_BRUSH_SIZE / 2), ppdev);
        IO_TRANSFER_WORD_ALIGNED(ppdev, pjPattern, cwPattern);

        CHECK_DATA_COMPLETE(ppdev);
    }
}

/******************************Public*Routine******************************\
* VOID vIoFillPatFast
*
* This routine uses the S3 pattern hardware to draw a patterned list of
* rectangles.
*
\**************************************************************************/

VOID vIoFillPatFast(            // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BOOL        bTransparent;
    ULONG       ulHwForeMix;
    BRUSHENTRY* pbe;        // Pointer to brush entry data, which is used
                            //   for keeping track of the location and status
                            //   of the pattern bits cached in off-screen
                            //   memory

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ppdev->flCaps & CAPS_HW_PATTERNS,
             "Shouldn't use fast patterns when can't do hw patterns");

    bTransparent = (((rop4 >> 8) & 0xff) != (rop4 & 0xff));

    // The S3's pattern hardware requires that we keep an aligned copy
    // of the brush in off-screen memory.  We have to update this
    // realization if any of the following are true:
    //
    //   1) The brush alignment has changed;
    //   2) The off-screen location we thought we had reserved for our
    //      realization got overwritten by a different pattern;
    //   3) We had realized the pattern to do transparent hatches, but
    //      we're now being asked to do an opaque pattern, or vice
    //      versa (since we use different realizations for transparent
    //      vs. opaque patterns).
    //
    // To handle the initial realization of a pattern, we're a little
    // tricky in order to save an 'if' in the following expression.  In
    // DrvRealizeBrush, we set 'prb->ptlBrushOrg.x' to be 0x80000000 (a
    // very negative number), which is guaranteed not to equal 'pptlBrush->x
    // + ppdev->xOffset'.  So our check for brush alignment will also
    // handle the initialization case (note that this check must occur
    // *before* dereferencing 'prb->pbe' because that pointer will be
    // NULL for a new pattern).

    if ((rbc.prb->ptlBrushOrg.x != pptlBrush->x + ppdev->xOffset) ||
        (rbc.prb->ptlBrushOrg.y != pptlBrush->y + ppdev->yOffset) ||
        (rbc.prb->pbe->prbVerify != rbc.prb)                      ||
        (rbc.prb->bTransparent != bTransparent))
    {
        vIoFastPatRealize(ppdev, rbc.prb, pptlBrush, bTransparent);
    }
    else if (ppdev->flCaps & CAPS_RE_REALIZE_PATTERN)
    {
        // The initial revs of the Vision chips have a bug where, if
        // we have not just drawn the pattern to off-screen memory,
        // we have to draw some sort of 1x8 rectangle before using
        // the pattern hardware (note that a LEAVE_ALONE rop will not
        // work).

        IO_FIFO_WAIT(ppdev, 7);

        IO_PIX_CNTL(ppdev, ALL_ONES);
        IO_FRGD_MIX(ppdev, SRC_DISPLAY_MEMORY | OVERPAINT);
        IO_ABS_CUR_X(ppdev, ppdev->ptlReRealize.x);
        IO_ABS_CUR_Y(ppdev, ppdev->ptlReRealize.y);
        IO_MAJ_AXIS_PCNT(ppdev, 0);
        IO_MIN_AXIS_PCNT(ppdev, 7);
        IO_CMD(ppdev, RECTANGLE_FILL | DRAWING_DIR_TBLRXM |
                      DRAW           | DIR_TYPE_XY        |
                      LAST_PIXEL_ON  | MULTIPLE_PIXELS    |
                      WRITE);
    }

    ASSERTDD(rbc.prb->bTransparent == bTransparent,
             "Not realized with correct transparency");

    pbe = rbc.prb->pbe;

    ulHwForeMix = gaulHwMixFromRop2[(rop4 >> 2) & 0xf];

    if (!bTransparent)
    {
        IO_FIFO_WAIT(ppdev, 4);

        IO_ABS_CUR_X(ppdev, pbe->x);
        IO_ABS_CUR_Y(ppdev, pbe->y);
        IO_PIX_CNTL(ppdev, ALL_ONES);
        IO_FRGD_MIX(ppdev, SRC_DISPLAY_MEMORY | ulHwForeMix);
    }
    else
    {
        if (DEPTH32(ppdev))
        {
            IO_FIFO_WAIT(ppdev, 4);
            IO_FRGD_COLOR32(ppdev, rbc.prb->ulForeColor);
            IO_RD_MASK32(ppdev, 1);   // Pick a plane, any plane
            IO_FIFO_WAIT(ppdev, 5);
        }
        else
        {
            IO_FIFO_WAIT(ppdev, 7);
            IO_FRGD_COLOR(ppdev, rbc.prb->ulForeColor);
            IO_RD_MASK(ppdev, 1);     // Pick a plane, any plane
        }

        IO_ABS_CUR_X(ppdev, pbe->x);
        IO_ABS_CUR_Y(ppdev, pbe->y);
        IO_PIX_CNTL(ppdev, DISPLAY_MEMORY);
        IO_FRGD_MIX(ppdev, FOREGROUND_COLOR | ulHwForeMix);
        IO_BKGD_MIX(ppdev, BACKGROUND_COLOR | LEAVE_ALONE);
    }

    do {
        IO_FIFO_WAIT(ppdev, 5);

        IO_DEST_X(ppdev, prcl->left);
        IO_DEST_Y(ppdev, prcl->top);
        IO_MAJ_AXIS_PCNT(ppdev, prcl->right  - prcl->left - 1);
        IO_MIN_AXIS_PCNT(ppdev, prcl->bottom - prcl->top  - 1);
        IO_CMD(ppdev, PATTERN_FILL | BYTE_SWAP | DRAWING_DIR_TBLRXM |
                      DRAW | WRITE);

        prcl++;
    } while (--c != 0);
}

/******************************Public*Routine******************************\
* VOID vIoXfer1bpp
*
* This routine colour expands a monochrome bitmap, possibly with different
* Rop2's for the foreground and background.  It will be called in the
* following cases:
*
* 1) To colour-expand the monochrome text buffer for the vFastText routine.
* 2) To blt a 1bpp source with a simple Rop2 between the source and
*    destination.
* 3) To blt a true Rop3 when the source is a 1bpp bitmap that expands to
*    white and black, and the pattern is a solid colour.
* 4) To handle a true Rop4 that works out to be Rop2's between the pattern
*    and destination.
*
* Needless to say, making this routine fast can leverage a lot of
* performance.
*
\**************************************************************************/

VOID vIoXfer1bpp(       // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ROP4        rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    ULONG   ulHwForeMix;
    ULONG   ulHwBackMix;
    LONG    dxSrc;
    LONG    dySrc;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    LONG    cjSrc;
    LONG    xLeft;
    LONG    yTop;
    LONG    xBias;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(pptlSrc != NULL && psoSrc != NULL, "Can't have NULL sources");
    ASSERTDD(((((rop4 & 0xff00) >> 8) == (rop4 & 0xff)) || (rop4 == 0xaacc)),
             "Expect weird rops only when opaquing");

    // Note that only our text routine calls us with a '0xaacc' rop:

    ulHwForeMix = gaulHwMixFromRop2[rop4 & 0xf];
    ulHwBackMix = (rop4 != 0xaacc) ? ulHwForeMix : LEAVE_ALONE;

    if (DEPTH32(ppdev))
    {
        IO_FIFO_WAIT(ppdev, 7);

        IO_PIX_CNTL(ppdev, CPU_DATA);
        IO_FRGD_MIX(ppdev, FOREGROUND_COLOR | ulHwForeMix);
        IO_BKGD_MIX(ppdev, BACKGROUND_COLOR | ulHwBackMix);
        IO_FRGD_COLOR32(ppdev, pxlo->pulXlate[1]);
        IO_BKGD_COLOR32(ppdev, pxlo->pulXlate[0]);
    }
    else
    {
        IO_FIFO_WAIT(ppdev, 5);

        IO_PIX_CNTL(ppdev, CPU_DATA);
        IO_FRGD_MIX(ppdev, FOREGROUND_COLOR | ulHwForeMix);
        IO_BKGD_MIX(ppdev, BACKGROUND_COLOR | ulHwBackMix);
        IO_FRGD_COLOR(ppdev, pxlo->pulXlate[1]);
        IO_BKGD_COLOR(ppdev, pxlo->pulXlate[0]);
    }

    dxSrc = pptlSrc->x - prclDst->left;
    dySrc = pptlSrc->y - prclDst->top;      // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    do {
        IO_FIFO_WAIT(ppdev, 5);

        // We'll byte align to the source, but do word transfers
        // (implying that we may be doing unaligned reads from the
        // source).  We do this because it may reduce the total
        // number of word outs/writes that we'll have to do to the
        // display:

        yTop  = prcl->top;
        xLeft = prcl->left;

        xBias = (xLeft + dxSrc) & 7;        // This is the byte-align bias
        if (xBias != 0)
        {
            // We could either align in software or use the hardware to do
            // it.  We'll use the hardware; the cost we pay is the time spent
            // setting and resetting one scissors register:

            IO_SCISSORS_L(ppdev, xLeft);
            xLeft -= xBias;
        }

        cx = prcl->right  - xLeft;
        cy = prcl->bottom - yTop;

        IO_CUR_X(ppdev, xLeft);
        IO_CUR_Y(ppdev, yTop);
        IO_MAJ_AXIS_PCNT(ppdev, cx - 1);
        IO_MIN_AXIS_PCNT(ppdev, cy - 1);

        cjSrc = (cx + 7) / 8;               // # bytes to transfer
        pjSrc = pjSrcScan0 + (yTop  + dySrc) * lSrcDelta
                           + (xLeft + dxSrc) / 8;
                                            // Start is byte aligned (note
                                            //   that we don't have to add
                                            //   xBias)

        ppdev->pfnImageTransfer(ppdev, pjSrc, lSrcDelta, cjSrc, cy,
                      (RECTANGLE_FILL  | WAIT          | DRAWING_DIR_TBLRXM |
                       DRAW            | LAST_PIXEL_ON | MULTIPLE_PIXELS    |
                       WRITE           | BYTE_SWAP));

        if (xBias != 0)
        {
            IO_FIFO_WAIT(ppdev, 1);
            IO_ABS_SCISSORS_L(ppdev, 0);    // Reset the clipping if we used it
        }

        prcl++;
    } while (--c != 0);
}

/******************************Public*Routine******************************\
* VOID vIoXfer4bpp
*
* Does a 4bpp transfer from a bitmap to the screen.
*
* NOTE: The screen must be 8bpp for this function to be called!
*
* The reason we implement this is that a lot of resources are kept as 4bpp,
* and used to initialize DFBs, some of which we of course keep off-screen.
*
\**************************************************************************/

// XLATE_BUFFER_SIZE defines the size of the stack-based buffer we use
// for doing the translate.  Note that in general stack buffers should
// be kept as small as possible.  The OS guarantees us only 8k for stack
// from GDI down to the display driver in low memory situations; if we
// ask for more, we'll access violate.  Note also that at any time the
// stack buffer cannot be larger than a page (4k) -- otherwise we may
// miss touching the 'guard page' and access violate then too.

#define XLATE_BUFFER_SIZE 256

VOID vIoXfer4bpp(       // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjScan;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    cxThis;
    LONG    cxToGo;
    LONG    xSrc;
    LONG    iLoop;
    BYTE    jSrc;
    ULONG*  pulXlate;
    LONG    cwThis;
    BYTE*   pjBuf;
    BYTE    ajBuf[XLATE_BUFFER_SIZE];

    ASSERTDD(ppdev->iBitmapFormat == BMF_8BPP, "Screen must be 8bpp");
    ASSERTDD(psoSrc->iBitmapFormat == BMF_4BPP, "Source must be 4bpp");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    IO_FIFO_WAIT(ppdev, 6);
    IO_PIX_CNTL(ppdev, ALL_ONES);
    IO_FRGD_MIX(ppdev, SRC_CPU_DATA | gaulHwMixFromRop2[rop4 & 0xf]);

    while(TRUE)
    {
        cx = prcl->right  - prcl->left;
        cy = prcl->bottom - prcl->top;

        IO_CUR_X(ppdev, prcl->left);
        IO_CUR_Y(ppdev, prcl->top);
        IO_MAJ_AXIS_PCNT(ppdev, cx - 1);
        IO_MIN_AXIS_PCNT(ppdev, cy - 1);

        pulXlate  =  pxlo->pulXlate;
        xSrc      =  prcl->left + dx;
        pjScan    =  pjSrcScan0 + (prcl->top + dy) * lSrcDelta + (xSrc >> 1);

        IO_GP_WAIT(ppdev);
        IO_CMD(ppdev, RECTANGLE_FILL     | BUS_SIZE_16| WAIT          |
                      DRAWING_DIR_TBLRXM | DRAW       | LAST_PIXEL_ON |
                      SINGLE_PIXEL       | WRITE      | BYTE_SWAP);
        CHECK_DATA_READY(ppdev);

        do {
            pjSrc  = pjScan;
            cxToGo = cx;            // # of pels per scan in 4bpp source
            do {
                cxThis  = XLATE_BUFFER_SIZE;
                                    // We can handle XLATE_BUFFER_SIZE number
                                    //   of pels in this xlate batch
                cxToGo -= cxThis;   // cxThis will be the actual number of
                                    //   pels we'll do in this xlate batch
                if (cxToGo < 0)
                    cxThis += cxToGo;

                pjDst = ajBuf;      // Points to our temporary batch buffer

                // We handle alignment ourselves because it's easy to
                // do, rather than pay the cost of setting/resetting
                // the scissors register:

                if (xSrc & 1)
                {
                    // When unaligned, we have to be careful not to read
                    // past the end of the 4bpp bitmap (that could
                    // potentially cause us to access violate):

                    iLoop = cxThis >> 1;        // Each loop handles 2 pels;
                                                //   we'll handle odd pel
                                                //   separately
                    jSrc  = *pjSrc;
                    while (iLoop-- != 0)
                    {
                        *pjDst++ = (BYTE) pulXlate[jSrc & 0xf];
                        jSrc = *(++pjSrc);
                        *pjDst++ = (BYTE) pulXlate[jSrc >> 4];
                    }

                    if (cxThis & 1)
                        *pjDst = (BYTE) pulXlate[jSrc & 0xf];
                }
                else
                {
                    iLoop = (cxThis + 1) >> 1;  // Each loop handles 2 pels
                    do {
                        jSrc = *pjSrc++;

                        *pjDst++ = (BYTE) pulXlate[jSrc >> 4];
                        *pjDst++ = (BYTE) pulXlate[jSrc & 0xf];

                    } while (--iLoop != 0);
                }

                // The number of bytes we'll transfer is equal to the number
                // of pels we've processed in the batch.  Since we're
                // transferring words, we have to round up to get the word
                // count:

                cwThis = (cxThis + 1) >> 1;
                pjBuf  = ajBuf;
                IO_TRANSFER_WORD_ALIGNED(ppdev, pjBuf, cwThis);

            } while (cxToGo > 0);

            pjScan += lSrcDelta;        // Advance to next source scan.  Note
                                        //   that we could have computed the
                                        //   value to advance 'pjSrc' directly,
                                        //   but this method is less
                                        //   error-prone.

        } while (--cy != 0);

        CHECK_DATA_COMPLETE(ppdev);

        if (--c == 0)
            return;

        prcl++;
        IO_FIFO_WAIT(ppdev, 4);
    }
}

/******************************Public*Routine******************************\
* VOID vIoXferNative
*
* Transfers a bitmap that is the same colour depth as the display to
* the screen via the data transfer register, with no translation.
*
\**************************************************************************/

VOID vIoXferNative(     // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ULONG       rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Not used
{
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    LONG    cjSrc;

    ASSERTDD((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL),
            "Can handle trivial xlate only");
    ASSERTDD(psoSrc->iBitmapFormat == ppdev->iBitmapFormat,
            "Source must be same colour depth as screen");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    IO_FIFO_WAIT(ppdev, 6);
    IO_PIX_CNTL(ppdev, ALL_ONES);
    IO_FRGD_MIX(ppdev, SRC_CPU_DATA | gaulHwMixFromRop2[rop4 & 0xf]);

    while(TRUE)
    {
        IO_CUR_X(ppdev, prcl->left);
        IO_CUR_Y(ppdev, prcl->top);

        cx = prcl->right  - prcl->left;
        IO_MAJ_AXIS_PCNT(ppdev, cx - 1);

        cy = prcl->bottom - prcl->top;
        IO_MIN_AXIS_PCNT(ppdev, cy - 1);

        cjSrc = CONVERT_TO_BYTES(cx, ppdev);
        pjSrc = pjSrcScan0 + (prcl->top  + dy) * lSrcDelta
                  + CONVERT_TO_BYTES((prcl->left + dx), ppdev);

        ppdev->pfnImageTransfer(ppdev, pjSrc, lSrcDelta, cjSrc, cy,
                      (RECTANGLE_FILL | WAIT          | DRAWING_DIR_TBLRXM |
                       DRAW           | LAST_PIXEL_ON | SINGLE_PIXEL       |
                       WRITE          | BYTE_SWAP));

        if (--c == 0)
            return;

        prcl++;
        IO_FIFO_WAIT(ppdev, 4);
    }
}

/******************************Public*Routine******************************\
* VOID vIoCopyBlt
*
* Does a screen-to-screen blt of a list of rectangles.
*
\**************************************************************************/

VOID vIoCopyBlt(    // Type FNCOPY
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ULONG   rop4,       // rop4
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    LONG dx;
    LONG dy;        // Add delta to destination to get source
    LONG cx;
    LONG cy;        // Size of current rectangle - 1

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    IO_FIFO_WAIT(ppdev, 2);
    IO_FRGD_MIX(ppdev, SRC_DISPLAY_MEMORY | gaulHwMixFromRop2[rop4 & 0xf]);
    IO_PIX_CNTL(ppdev, ALL_ONES);

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    // The accelerator may not be as fast at doing right-to-left copies, so
    // only do them when the rectangles truly overlap:

    if (!OVERLAP(prclDst, pptlSrc))
        goto Top_Down_Left_To_Right;

    if (prclDst->top <= pptlSrc->y)
    {
        if (prclDst->left <= pptlSrc->x)
        {

Top_Down_Left_To_Right:

            do {
                IO_FIFO_WAIT(ppdev, 7);

                cx = prcl->right - prcl->left - 1;
                IO_MAJ_AXIS_PCNT(ppdev, cx);
                IO_DEST_X(ppdev, prcl->left);
                IO_CUR_X(ppdev,  prcl->left + dx);

                cy = prcl->bottom - prcl->top - 1;
                IO_MIN_AXIS_PCNT(ppdev, cy);
                IO_DEST_Y(ppdev, prcl->top);
                IO_CUR_Y(ppdev,  prcl->top + dy);

                IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                              DRAWING_DIR_TBLRXM);
                prcl++;

            } while (--c != 0);
        }
        else
        {
            do {
                IO_FIFO_WAIT(ppdev, 7);

                cx = prcl->right - prcl->left - 1;
                IO_MAJ_AXIS_PCNT(ppdev, cx);
                IO_DEST_X(ppdev, prcl->left + cx);
                IO_CUR_X(ppdev,  prcl->left + cx + dx);

                cy = prcl->bottom - prcl->top - 1;
                IO_MIN_AXIS_PCNT(ppdev, cy);
                IO_DEST_Y(ppdev, prcl->top);
                IO_CUR_Y(ppdev,  prcl->top + dy);

                IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                              DRAWING_DIR_TBRLXM);
                prcl++;

            } while (--c != 0);
        }
    }
    else
    {
        if (prclDst->left <= pptlSrc->x)
        {
            do {
                IO_FIFO_WAIT(ppdev, 7);

                cx = prcl->right - prcl->left - 1;
                IO_MAJ_AXIS_PCNT(ppdev, cx);
                IO_DEST_X(ppdev, prcl->left);
                IO_CUR_X(ppdev,  prcl->left + dx);

                cy = prcl->bottom - prcl->top - 1;
                IO_MIN_AXIS_PCNT(ppdev, cy);
                IO_DEST_Y(ppdev, prcl->top + cy);
                IO_CUR_Y(ppdev,  prcl->top + cy + dy);

                IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                              DRAWING_DIR_BTLRXM);
                prcl++;

            } while (--c != 0);
        }
        else
        {
            do {
                IO_FIFO_WAIT(ppdev, 7);

                cx = prcl->right - prcl->left - 1;
                IO_MAJ_AXIS_PCNT(ppdev, cx);
                IO_DEST_X(ppdev, prcl->left + cx);
                IO_CUR_X(ppdev,  prcl->left + cx + dx);

                cy = prcl->bottom - prcl->top - 1;
                IO_MIN_AXIS_PCNT(ppdev, cy);
                IO_DEST_Y(ppdev, prcl->top + cy);
                IO_CUR_Y(ppdev,  prcl->top + cy + dy);

                IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                              DRAWING_DIR_BTRLXM);
                prcl++;

            } while (--c != 0);
        }
    }
}

/******************************Public*Routine******************************\
* VOID vIoCopyTransparent
*
* Does a screen-to-screen blt of a list of rectangles using a source
* colorkey for transparency.
*
\**************************************************************************/

VOID vIoCopyTransparent(    // Type FNCOPYTRANSPARENT
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst,    // Original unclipped destination rectangle
ULONG   iColor)
{
    LONG    dx;
    LONG    dy;     // Add delta to destination to get source

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    if (DEPTH32(ppdev))
    {
        IO_FIFO_WAIT(ppdev, 5);
        IO_COLOR_CMP32(ppdev, iColor);
    }
    else
    {
        IO_FIFO_WAIT(ppdev, 4);
        IO_COLOR_CMP(ppdev, iColor);
    }

    IO_MULTIFUNC_CNTL(ppdev, ppdev->ulMiscState
                                     | MULT_MISC_COLOR_COMPARE);
    IO_FRGD_MIX(ppdev, SRC_DISPLAY_MEMORY | OVERPAINT);
    IO_PIX_CNTL(ppdev, ALL_ONES);

    while (TRUE)
    {
        IO_FIFO_WAIT(ppdev, 7);
        IO_CUR_X(ppdev, prcl->left + dx);
        IO_CUR_Y(ppdev, prcl->top + dy);
        IO_DEST_X(ppdev, prcl->left);
        IO_DEST_Y(ppdev, prcl->top);
        IO_MAJ_AXIS_PCNT(ppdev, prcl->right - prcl->left - 1);
        IO_MIN_AXIS_PCNT(ppdev, prcl->bottom - prcl->top - 1);
        IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY |
                                WRITE | DRAWING_DIR_TBLRXM);

        if (--c == 0)
        {
            IO_FIFO_WAIT(ppdev, 1);
            IO_MULTIFUNC_CNTL(ppdev, ppdev->ulMiscState);
            return;
        }

        prcl++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\bltmm.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: bltmm.c
*
* Contains the low-level memory-mapped IO blt functions.  This module
* mirrors 'bltio.c'.
*
* Hopefully, if you're basing your display driver on this code, to
* support all of DrvBitBlt and DrvCopyBits, you'll only have to implement
* the following routines.  You shouldn't have to modify much in
* 'bitblt.c'.  I've tried to make these routines as few, modular, simple,
* and efficient as I could, while still accelerating as many calls as
* possible that would be cost-effective in terms of performance wins
* versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates
*       that haven't yet had the offscreen bitmap (DFB) offset applied.
*       'Absolute' coordinates have had the offset applied.  For example,
*       we may be told to blt to (1, 1) of the bitmap, but the bitmap may
*       be sitting in offscreen memory starting at coordinate (0, 768) --
*       (1, 1) would be the 'relative' start coordinate, and (1, 769)
*       would be the 'absolute' start coordinate'.
*
* Copyright (c) 1992-1998 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vMmImageTransferMm16
*
* Low-level routine for transferring a bitmap image via the data transfer
* register using 16 bit writes and entirely memory-mapped I/O.
*
* NOTE: Upon entry, there must be 1 guaranteed free empty FIFO!
*
\**************************************************************************/

VOID vMmImageTransferMm16(  // Type FNIMAGETRANSFER
PDEV*   ppdev,
BYTE*   pjSrc,              // Source pointer
LONG    lDelta,             // Delta from start of scan to start of next
LONG    cjSrc,              // Number of bytes to be output on every scan
LONG    cScans,             // Number of scans
ULONG   ulCmd)              // Accelerator command - shouldn't include bus size
{
    BYTE* pjMmBase;
    LONG  cwSrc;

    ASSERTDD(cScans > 0, "Can't handle non-positive count of scans");
    ASSERTDD((ulCmd & (BUS_SIZE_8 | BUS_SIZE_16 | BUS_SIZE_32)) == 0,
             "Shouldn't specify bus size in command -- we handle that");

    IO_GP_WAIT(ppdev);

    pjMmBase = ppdev->pjMmBase;

    MM_CMD(ppdev, pjMmBase, ulCmd | BUS_SIZE_16);

    CHECK_DATA_READY(ppdev);

    cwSrc = (cjSrc) >> 1;               // Floor

    if (cjSrc & 1)
    {
        do {
            if (cwSrc > 0)
            {
                MM_TRANSFER_WORD(ppdev, pjMmBase, pjSrc, cwSrc);
            }

            // Make sure we do only a byte read of the last odd byte
            // in the scan so that we'll never read past the end of
            // the bitmap:

            MM_PIX_TRANS(ppdev, pjMmBase, *(pjSrc + cjSrc - 1));
            pjSrc += lDelta;

        } while (--cScans != 0);
    }
    else
    {
        do {
            MM_TRANSFER_WORD(ppdev, pjMmBase, pjSrc, cwSrc);
            pjSrc += lDelta;

        } while (--cScans != 0);
    }

    CHECK_DATA_COMPLETE(ppdev);
}

/******************************Public*Routine******************************\
* VOID vMmImageTransferMm32
*
* Low-level routine for transferring a bitmap image via the data transfer
* register using 32 bit writes and entirely memory-mapped I/O.
*
* NOTE: Upon entry, there must be 1 guaranteed free empty FIFO!
*
\**************************************************************************/


VOID vMmImageTransferMm32(  // Type FNIMAGETRANSFER
PDEV*   ppdev,
BYTE*   pjSrc,              // Source pointer
LONG    lDelta,             // Delta from start of scan to start of next
LONG    cjSrc,              // Number of bytes to be output on every scan
LONG    cScans,             // Number of scans
ULONG   ulCmd)              // Accelerator command - shouldn't include bus size
{
    BYTE*   pjMmBase;
    LONG    cdSrc;
    LONG    cjEnd;
    ULONG   d;

    ASSERTDD(cScans > 0, "Can't handle non-positive count of scans");
    ASSERTDD((ulCmd & (BUS_SIZE_8 | BUS_SIZE_16 | BUS_SIZE_32)) == 0,
             "Shouldn't specify bus size in command -- we handle that");

    IO_GP_WAIT(ppdev);

    pjMmBase = ppdev->pjMmBase;

    MM_CMD(ppdev, pjMmBase, ulCmd | BUS_SIZE_32);

    CHECK_DATA_READY(ppdev);

    cdSrc = cjSrc >> 2;
    cjEnd = cdSrc << 2;

    switch (cjSrc & 3)
    {
    case 3:
        do {
            if (cdSrc > 0)
                MM_TRANSFER_DWORD(ppdev, pjMmBase, pjSrc, cdSrc);

            d = (ULONG) (*(pjSrc + cjEnd))          |
                        (*(pjSrc + cjEnd + 1) << 8) |
                        (*(pjSrc + cjEnd + 2) << 16);
            MM_TRANSFER_DWORD(ppdev, pjMmBase, &d, 1);
            pjSrc += lDelta;

        } while (--cScans != 0);
        break;

    case 2:
        do {
            if (cdSrc > 0)
                MM_TRANSFER_DWORD(ppdev, pjMmBase, pjSrc, cdSrc);

            d = (ULONG) (*(pjSrc + cjEnd))          |
                        (*(pjSrc + cjEnd + 1) << 8);
            MM_TRANSFER_DWORD(ppdev, pjMmBase, &d, 1);
            pjSrc += lDelta;

        } while (--cScans != 0);
        break;

    case 1:
        do {
            if (cdSrc > 0)
                MM_TRANSFER_DWORD(ppdev, pjMmBase, pjSrc, cdSrc);

            d = (ULONG) (*(pjSrc + cjEnd));
            MM_TRANSFER_DWORD(ppdev, pjMmBase, &d, 1);
            pjSrc += lDelta;

        } while (--cScans != 0);
        break;

    case 0:
        do {
            MM_TRANSFER_DWORD(ppdev, pjMmBase, pjSrc, cdSrc);
            pjSrc += lDelta;

        } while (--cScans != 0);
        break;
    }

    CHECK_DATA_COMPLETE(ppdev);
}

/******************************Public*Routine******************************\
* VOID vMmFillSolid
*
* Fills a list of rectangles with a solid colour.
*
\**************************************************************************/

VOID vMmFillSolid(              // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
POINTL*         pptlBrush)      // Not used
{
    BYTE*   pjMmBase = ppdev->pjMmBase;
    ULONG   ulHwForeMix;

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    ulHwForeMix = gaulHwMixFromRop2[(rop4 >> 2) & 0xf];

    // It's quite likely that we've just been called from GDI, so it's
    // even more likely that the accelerator's graphics engine has been
    // sitting around idle.  Rather than doing a FIFO_WAIT(3) here and
    // then a FIFO_WAIT(5) before outputing the actual rectangle,
    // we can avoid an 'in' (which can be quite expensive, depending on
    // the card) by doing a single FIFO_WAIT(8) right off the bat:

    IO_FIFO_WAIT(ppdev, 8);
    MM_PIX_CNTL(ppdev, pjMmBase, ALL_ONES);
    MM_FRGD_MIX(ppdev, pjMmBase, FOREGROUND_COLOR | ulHwForeMix);
    MM_FRGD_COLOR(ppdev, pjMmBase, rbc.iSolidColor);

    while(TRUE)
    {
        MM_CUR_X(ppdev, pjMmBase, prcl->left);
        MM_CUR_Y(ppdev, pjMmBase, prcl->top);
        MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, prcl->right  - prcl->left - 1);
        MM_MIN_AXIS_PCNT(ppdev, pjMmBase, prcl->bottom - prcl->top  - 1);

        MM_CMD(ppdev, pjMmBase, RECTANGLE_FILL | DRAWING_DIR_TBLRXM |
                                DRAW           | DIR_TYPE_XY        |
                                LAST_PIXEL_ON  | MULTIPLE_PIXELS    |
                                WRITE);

        if (--c == 0)
            return;

        prcl++;
        IO_FIFO_WAIT(ppdev, 5);
    }
}

/******************************Public*Routine******************************\
* VOID vMmFastPatRealize
*
* This routine transfers an 8x8 pattern to off-screen display memory,
* so that it can be used by the S3 pattern hardware.
*
\**************************************************************************/

VOID vMmFastPatRealize(         // Type FNFASTPATREALIZE
PDEV*   ppdev,
RBRUSH* prb,                    // Points to brush realization structure
POINTL* pptlBrush,              // Brush origin for aligning realization
BOOL    bTransparent)           // FALSE for normal patterns; TRUE for
                                //   patterns with a mask when the background
                                //   mix is LEAVE_ALONE.
{
    BRUSHENTRY* pbe;
    LONG        iBrushCache;
    LONG        x;
    LONG        y;
    LONG        i;
    LONG        xShift;
    LONG        yShift;
    BYTE*       pjSrc;
    BYTE*       pjDst;
    LONG        cjLeft;
    LONG        cjRight;
    BYTE*       pjPattern;
    LONG        cwPattern;

    ULONG       aulBrush[TOTAL_BRUSH_SIZE];
                    // Temporary buffer for aligning brush.  Declared
                    //   as an array of ULONGs to get proper dword
                    //   alignment.  Also leaves room for brushes that
                    //   are up to 32bpp.  Note: this takes up 1/4k!

    BYTE*       pjMmBase = ppdev->pjMmBase;

    ASSERTDD(!(bTransparent && ppdev->iBitmapFormat == BMF_24BPP),
             "s3 diamond 968 at 24bpp doesn't support transparent FastPatRealize");

    pbe = prb->pbe;
    if ((pbe == NULL) || (pbe->prbVerify != prb))
    {
        // We have to allocate a new off-screen cache brush entry for
        // the brush:

        iBrushCache = ppdev->iBrushCache;
        pbe         = &ppdev->abe[iBrushCache];

        iBrushCache++;
        if (iBrushCache >= ppdev->cBrushCache)
            iBrushCache = 0;

        ppdev->iBrushCache = iBrushCache;

        // Update our links:

        pbe->prbVerify           = prb;
        prb->pbe                 = pbe;
    }

    // Load some variables onto the stack, so that we don't have to keep
    // dereferencing their pointers:

    x = pbe->x;
    y = pbe->y;

    // Because we handle only 8x8 brushes, it is easy to compute the
    // number of pels by which we have to rotate the brush pattern
    // right and down.  Note that if we were to handle arbitrary sized
    // patterns, this calculation would require a modulus operation.
    //
    // The brush is aligned in absolute coordinates, so we have to add
    // in the surface offset:

    xShift = pptlBrush->x + ppdev->xOffset;
    yShift = pptlBrush->y + ppdev->yOffset;

    prb->ptlBrushOrg.x = xShift;    // We have to remember the alignment
    prb->ptlBrushOrg.y = yShift;    //   that we used for caching (we check
                                    //   this when we go to see if a brush's
                                    //   cache entry is still valid)

    xShift &= 7;                    // Rotate pattern 'xShift' pels right
    yShift &= 7;                    // Rotate pattern 'yShift' pels down

    prb->bTransparent = bTransparent;

    // I considered doing the colour expansion for 1bpp brushes in
    // software, but by letting the hardware do it, we don't have
    // to do as many OUTs to transfer the pattern.

    if (prb->fl & RBRUSH_2COLOR)
    {
        // We're going to do a colour-expansion ('across the plane')
        // bitblt of the 1bpp 8x8 pattern to the screen.  But first
        // we'll align it properly by copying it to a temporary buffer
        // (which we'll conveniently pack word aligned so that we can do a
        // REP OUTSW...)

        pjSrc = (BYTE*) &prb->aulPattern[0];    // Copy from the start of the
                                                //   brush buffer
        pjDst = (BYTE*) &aulBrush[0];           // Copy to our temp buffer
        pjDst += yShift * sizeof(WORD);         //   starting yShift rows down
        i = 8 - yShift;                         //   for 8 - yShift rows

        do {
            *pjDst = (*pjSrc >> xShift) | (*pjSrc << (8 - xShift));
            pjDst += sizeof(WORD);  // Destination is word packed
            pjSrc += sizeof(WORD);  // Source is word aligned too

        } while (--i != 0);

        pjDst -= 8 * sizeof(WORD);  // Move to the beginning of the source

        ASSERTDD(pjDst == (BYTE*) &aulBrush[0], "pjDst not back at start");

        for (; yShift != 0; yShift--)
        {
            *pjDst = (*pjSrc >> xShift) | (*pjSrc << (8 - xShift));
            pjDst += sizeof(WORD);  // Destination is word packed
            pjSrc += sizeof(WORD);  // Source is word aligned too
        }

        if (bTransparent)
        {
            IO_FIFO_WAIT(ppdev, 3);

            MM_PIX_CNTL(ppdev, pjMmBase, CPU_DATA);
            MM_FRGD_MIX(ppdev, pjMmBase, LOGICAL_1);
            MM_BKGD_MIX(ppdev, pjMmBase, LOGICAL_0);
        }
        else
        {
            IO_FIFO_WAIT(ppdev, 5);

            MM_PIX_CNTL(ppdev, pjMmBase, CPU_DATA);
            MM_FRGD_MIX(ppdev, pjMmBase, FOREGROUND_COLOR | OVERPAINT);
            MM_BKGD_MIX(ppdev, pjMmBase, BACKGROUND_COLOR | OVERPAINT);
            MM_FRGD_COLOR(ppdev, pjMmBase, prb->ulForeColor);
            MM_BKGD_COLOR(ppdev, pjMmBase, prb->ulBackColor);
        }

        IO_FIFO_WAIT(ppdev, 4);

        MM_ABS_CUR_X(ppdev, pjMmBase, x);
        MM_ABS_CUR_Y(ppdev, pjMmBase, y);
        MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, 7); // Brush is 8 wide
        MM_MIN_AXIS_PCNT(ppdev, pjMmBase, 7); // Brush is 8 high

        IO_GP_WAIT(ppdev);

        MM_CMD(ppdev, pjMmBase, RECTANGLE_FILL     | BUS_SIZE_16 | WAIT          |
                                DRAWING_DIR_TBLRXM | DRAW        | LAST_PIXEL_ON |
                                MULTIPLE_PIXELS    | WRITE       | BYTE_SWAP);

        CHECK_DATA_READY(ppdev);

        pjPattern = (BYTE*) &aulBrush[0];
        MM_TRANSFER_WORD_ALIGNED(ppdev, pjMmBase, pjPattern, 8);
                                                // Each word transferred
                                                //   comprises one row of the
                                                //   pattern, and there are
                                                //   8 rows in the pattern

        CHECK_DATA_COMPLETE(ppdev);
    }
    else
    {
        ASSERTDD(!bTransparent,
            "Shouldn't have been asked for transparency with a non-1bpp brush");

        // We're going to do a straight ('through the plane') bitblt
        // of the Xbpp 8x8 pattern to the screen.  But first we'll align
        // it properly by copying it to a temporary buffer:

        cjLeft  = CONVERT_TO_BYTES(xShift, ppdev);  // Number of bytes pattern
                                                    //   is shifted to the right
        cjRight = CONVERT_TO_BYTES(8, ppdev) -      // Number of bytes pattern
                  cjLeft;                           // is shifted to the left

        pjSrc = (BYTE*) &prb->aulPattern[0];        // Copy from brush buffer
        pjDst = (BYTE*) &aulBrush[0];               // Copy to our temp buffer
        pjDst += yShift * CONVERT_TO_BYTES(8, ppdev); //  starting yShift rows
        i = 8 - yShift;                             //  down for 8 - yShift rows

        do {
            RtlCopyMemory(pjDst + cjLeft, pjSrc,           cjRight);
            RtlCopyMemory(pjDst,          pjSrc + cjRight, cjLeft);

            pjDst += cjLeft + cjRight;
            pjSrc += cjLeft + cjRight;

        } while (--i != 0);

        pjDst = (BYTE*) &aulBrush[0];   // Move to the beginning of destination

        for (; yShift != 0; yShift--)
        {
            RtlCopyMemory(pjDst + cjLeft, pjSrc,           cjRight);
            RtlCopyMemory(pjDst,          pjSrc + cjRight, cjLeft);

            pjDst += cjLeft + cjRight;
            pjSrc += cjLeft + cjRight;

        }

        IO_FIFO_WAIT(ppdev, 6);

        MM_PIX_CNTL(ppdev, pjMmBase, ALL_ONES);
        MM_FRGD_MIX(ppdev, pjMmBase, SRC_CPU_DATA | OVERPAINT);

        MM_ABS_CUR_X(ppdev, pjMmBase, x);
        MM_ABS_CUR_Y(ppdev, pjMmBase, y);
        MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, 7);     // Brush is 8 wide
        MM_MIN_AXIS_PCNT(ppdev, pjMmBase, 7);     // Brush is 8 high

        IO_GP_WAIT(ppdev);

        MM_CMD(ppdev, pjMmBase, RECTANGLE_FILL     | BUS_SIZE_16| WAIT          |
                                DRAWING_DIR_TBLRXM | DRAW       | LAST_PIXEL_ON |
                                SINGLE_PIXEL       | WRITE      | BYTE_SWAP);

        CHECK_DATA_READY(ppdev);

        pjPattern = (BYTE*) &aulBrush[0];
        cwPattern = CONVERT_TO_BYTES((TOTAL_BRUSH_SIZE / 2), ppdev);
        MM_TRANSFER_WORD_ALIGNED(ppdev, pjMmBase, pjPattern, cwPattern);

        CHECK_DATA_COMPLETE(ppdev);
    }
}

/******************************Public*Routine******************************\
* VOID vMmFillPatFast
*
* This routine uses the S3 pattern hardware to draw a patterned list of
* rectangles.
*
\**************************************************************************/

VOID vMmFillPatFast(            // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BOOL        bTransparent;
    ULONG       ulHwForeMix;
    BRUSHENTRY* pbe;        // Pointer to brush entry data, which is used
                            //   for keeping track of the location and status
                            //   of the pattern bits cached in off-screen
                            //   memory

    BYTE*       pjMmBase = ppdev->pjMmBase;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ppdev->flCaps & CAPS_HW_PATTERNS,
             "Shouldn't use fast patterns when can't do hw patterns");

    bTransparent = (((rop4 >> 8) & 0xff) != (rop4 & 0xff));

    // The S3's pattern hardware requires that we keep an aligned copy
    // of the brush in off-screen memory.  We have to update this
    // realization if any of the following are true:
    //
    //   1) The brush alignment has changed;
    //   2) The off-screen location we thought we had reserved for our
    //      realization got overwritten by a different pattern;
    //   3) We had realized the pattern to do transparent hatches, but
    //      we're now being asked to do an opaque pattern, or vice
    //      versa (since we use different realizations for transparent
    //      vs. opaque patterns).
    //
    // To handle the initial realization of a pattern, we're a little
    // tricky in order to save an 'if' in the following expression.  In
    // DrvRealizeBrush, we set 'prb->ptlBrushOrg.x' to be 0x80000000 (a
    // very negative number), which is guaranteed not to equal 'pptlBrush->x
    // + ppdev->xOffset'.  So our check for brush alignment will also
    // handle the initialization case (note that this check must occur
    // *before* dereferencing 'prb->pbe' because that pointer will be
    // NULL for a new pattern).

    if ((rbc.prb->ptlBrushOrg.x != pptlBrush->x + ppdev->xOffset) ||
        (rbc.prb->ptlBrushOrg.y != pptlBrush->y + ppdev->yOffset) ||
        (rbc.prb->pbe->prbVerify != rbc.prb)                      ||
        (rbc.prb->bTransparent != bTransparent))
    {
        vMmFastPatRealize(ppdev, rbc.prb, pptlBrush, bTransparent);
    }
    else if (ppdev->flCaps & CAPS_RE_REALIZE_PATTERN)
    {
        // The initial revs of the Vision chips have a bug where, if
        // we have not just drawn the pattern to off-screen memory,
        // we have to draw some sort of 1x8 rectangle before using
        // the pattern hardware (note that a LEAVE_ALONE rop will not
        // work).

        IO_FIFO_WAIT(ppdev, 7);

        MM_PIX_CNTL(ppdev, pjMmBase, ALL_ONES);
        MM_FRGD_MIX(ppdev, pjMmBase, SRC_DISPLAY_MEMORY | OVERPAINT);
        MM_ABS_CUR_X(ppdev, pjMmBase, ppdev->ptlReRealize.x);
        MM_ABS_CUR_Y(ppdev, pjMmBase, ppdev->ptlReRealize.y);
        MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, 0);
        MM_MIN_AXIS_PCNT(ppdev, pjMmBase, 7);
        MM_CMD(ppdev, pjMmBase, RECTANGLE_FILL | DRAWING_DIR_TBLRXM |
                                DRAW           | DIR_TYPE_XY        |
                                LAST_PIXEL_ON  | MULTIPLE_PIXELS    |
                                WRITE);
    }

    ASSERTDD(rbc.prb->bTransparent == bTransparent,
             "Not realized with correct transparency");

    pbe = rbc.prb->pbe;

    ulHwForeMix = gaulHwMixFromRop2[(rop4 >> 2) & 0xf];

    if (!bTransparent)
    {
        IO_FIFO_WAIT(ppdev, 4);

        MM_ABS_CUR_X(ppdev, pjMmBase, pbe->x);
        MM_ABS_CUR_Y(ppdev, pjMmBase, pbe->y);
        MM_PIX_CNTL(ppdev, pjMmBase, ALL_ONES);
        MM_FRGD_MIX(ppdev, pjMmBase, SRC_DISPLAY_MEMORY | ulHwForeMix);
    }
    else
    {
        IO_FIFO_WAIT(ppdev, 7);
        MM_FRGD_COLOR(ppdev, pjMmBase, rbc.prb->ulForeColor);
        MM_RD_MASK(ppdev, pjMmBase, 1);     // Pick a plane, any plane
        MM_ABS_CUR_X(ppdev, pjMmBase, pbe->x);
        MM_ABS_CUR_Y(ppdev, pjMmBase, pbe->y);
        MM_PIX_CNTL(ppdev, pjMmBase, DISPLAY_MEMORY);
        MM_FRGD_MIX(ppdev, pjMmBase, FOREGROUND_COLOR | ulHwForeMix);
        MM_BKGD_MIX(ppdev, pjMmBase, BACKGROUND_COLOR | LEAVE_ALONE);
    }

    do {
        IO_FIFO_WAIT(ppdev, 5);

        MM_DEST_X(ppdev, pjMmBase, prcl->left);
        MM_DEST_Y(ppdev, pjMmBase, prcl->top);
        MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, prcl->right  - prcl->left - 1);
        MM_MIN_AXIS_PCNT(ppdev, pjMmBase, prcl->bottom - prcl->top  - 1);
        MM_CMD(ppdev, pjMmBase, PATTERN_FILL | BYTE_SWAP | DRAWING_DIR_TBLRXM |
                                DRAW | WRITE);

        prcl++;
    } while (--c != 0);
}

/******************************Public*Routine******************************\
* VOID vMmXfer1bpp
*
* This routine colour expands a monochrome bitmap, possibly with different
* Rop2's for the foreground and background.  It will be called in the
* following cases:
*
* 1) To colour-expand the monochrome text buffer for the vFastText routine.
* 2) To blt a 1bpp source with a simple Rop2 between the source and
*    destination.
* 3) To blt a true Rop3 when the source is a 1bpp bitmap that expands to
*    white and black, and the pattern is a solid colour.
* 4) To handle a true Rop4 that works out to be two Rop2's between the
*    pattern and destination.
*
* Needless to say, making this routine fast can leverage a lot of
* performance.
*
\**************************************************************************/

VOID vMmXfer1bpp(       // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ROP4        rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    ULONG   ulHwForeMix;
    ULONG   ulHwBackMix;
    LONG    dxSrc;
    LONG    dySrc;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    LONG    cjSrc;
    LONG    xLeft;
    LONG    yTop;
    LONG    xBias;
    BYTE*   pjMmBase = ppdev->pjMmBase;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(pptlSrc != NULL && psoSrc != NULL, "Can't have NULL sources");
    ASSERTDD(((((rop4 & 0xff00) >> 8) == (rop4 & 0xff)) || (rop4 == 0xaacc)),
             "Expect weird rops only when opaquing");

    // Note that only our text routine calls us with a '0xaacc' rop:

    ulHwForeMix = gaulHwMixFromRop2[rop4 & 0xf];
    ulHwBackMix = (rop4 != 0xaacc) ? ulHwForeMix : LEAVE_ALONE;

    IO_FIFO_WAIT(ppdev, 5);

    MM_PIX_CNTL(ppdev, pjMmBase, CPU_DATA);
    MM_FRGD_MIX(ppdev, pjMmBase, FOREGROUND_COLOR | ulHwForeMix);
    MM_BKGD_MIX(ppdev, pjMmBase, BACKGROUND_COLOR | ulHwBackMix);
    MM_FRGD_COLOR(ppdev, pjMmBase, pxlo->pulXlate[1]);
    MM_BKGD_COLOR(ppdev, pjMmBase, pxlo->pulXlate[0]);

    dxSrc = pptlSrc->x - prclDst->left;
    dySrc = pptlSrc->y - prclDst->top;      // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    do {
        IO_FIFO_WAIT(ppdev, 5);

        // We'll byte align to the source, but do word transfers
        // (implying that we may be doing unaligned reads from the
        // source).  We do this because it may reduce the total
        // number of word outs/writes that we'll have to do to the
        // display:

        yTop  = prcl->top;
        xLeft = prcl->left;

        xBias = (xLeft + dxSrc) & 7;        // This is the byte-align bias
        if (xBias != 0)
        {
            // We could either align in software or use the hardware to do
            // it.  We'll use the hardware; the cost we pay is the time spent
            // setting and resetting one scissors register:

            MM_SCISSORS_L(ppdev, pjMmBase, xLeft);
            xLeft -= xBias;
        }

        cx = prcl->right  - xLeft;
        cy = prcl->bottom - yTop;

        MM_CUR_X(ppdev, pjMmBase, xLeft);
        MM_CUR_Y(ppdev, pjMmBase, yTop);
        MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, cx - 1);
        MM_MIN_AXIS_PCNT(ppdev, pjMmBase, cy - 1);

        cjSrc = (cx + 7) >> 3;              // # bytes to transfer
        pjSrc = pjSrcScan0 + (yTop  + dySrc) * lSrcDelta
                           + ((xLeft + dxSrc) >> 3);
                                            // Start is byte aligned (note
                                            //   that we don't have to add
                                            //   xBias)

        ppdev->pfnImageTransfer(ppdev, pjSrc, lSrcDelta, cjSrc, cy,
                      (RECTANGLE_FILL  | WAIT          | DRAWING_DIR_TBLRXM |
                       DRAW            | LAST_PIXEL_ON | MULTIPLE_PIXELS    |
                       WRITE           | BYTE_SWAP));

        if (xBias != 0)
        {
            IO_FIFO_WAIT(ppdev, 1);         // Reset the clipping if we used it
            MM_ABS_SCISSORS_L(ppdev, pjMmBase, 0);
        }

        prcl++;
    } while (--c != 0);
}

/******************************Public*Routine******************************\
* VOID vMmXfer4bpp
*
* Does a 4bpp transfer from a bitmap to the screen.
*
* NOTE: The screen must be 8bpp for this function to be called!
*
* The reason we implement this is that a lot of resources are kept as 4bpp,
* and used to initialize DFBs, some of which we of course keep off-screen.
*
\**************************************************************************/

// XLATE_BUFFER_SIZE defines the size of the stack-based buffer we use
// for doing the translate.  Note that in general stack buffers should
// be kept as small as possible.  The OS guarantees us only 8k for stack
// from GDI down to the display driver in low memory situations; if we
// ask for more, we'll access violate.  Note also that at any time the
// stack buffer cannot be larger than a page (4k) -- otherwise we may
// miss touching the 'guard page' and access violate then too.

#define XLATE_BUFFER_SIZE 256

VOID vMmXfer4bpp(       // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjScan;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    cxThis;
    LONG    cxToGo;
    LONG    xSrc;
    LONG    iLoop;
    BYTE    jSrc;
    ULONG*  pulXlate;
    LONG    cwThis;
    BYTE*   pjBuf;
    BYTE    ajBuf[XLATE_BUFFER_SIZE];
    BYTE*   pjMmBase = ppdev->pjMmBase;

    ASSERTDD(ppdev->iBitmapFormat == BMF_8BPP, "Screen must be 8bpp");
    ASSERTDD(psoSrc->iBitmapFormat == BMF_4BPP, "Source must be 4bpp");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    IO_FIFO_WAIT(ppdev, 6);
    MM_PIX_CNTL(ppdev, pjMmBase, ALL_ONES);
    MM_FRGD_MIX(ppdev, pjMmBase, SRC_CPU_DATA | gaulHwMixFromRop2[rop4 & 0xf]);

    while(TRUE)
    {
        cx = prcl->right  - prcl->left;
        cy = prcl->bottom - prcl->top;

        MM_CUR_X(ppdev, pjMmBase, prcl->left);
        MM_CUR_Y(ppdev, pjMmBase, prcl->top);
        MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, cx - 1);
        MM_MIN_AXIS_PCNT(ppdev, pjMmBase, cy - 1);

        pulXlate  =  pxlo->pulXlate;
        xSrc      =  prcl->left + dx;
        pjScan    =  pjSrcScan0 + (prcl->top + dy) * lSrcDelta + (xSrc >> 1);

        IO_GP_WAIT(ppdev);
        MM_CMD(ppdev, pjMmBase, RECTANGLE_FILL     | BUS_SIZE_16| WAIT          |
                                DRAWING_DIR_TBLRXM | DRAW       | LAST_PIXEL_ON |
                                SINGLE_PIXEL       | WRITE      | BYTE_SWAP);
        CHECK_DATA_READY(ppdev);

        do {
            pjSrc  = pjScan;
            cxToGo = cx;            // # of pels per scan in 4bpp source
            do {
                cxThis  = XLATE_BUFFER_SIZE;
                                    // We can handle XLATE_BUFFER_SIZE number
                                    //   of pels in this xlate batch
                cxToGo -= cxThis;   // cxThis will be the actual number of
                                    //   pels we'll do in this xlate batch
                if (cxToGo < 0)
                    cxThis += cxToGo;

                pjDst = ajBuf;      // Points to our temporary batch buffer

                // We handle alignment ourselves because it's easy to
                // do, rather than pay the cost of setting/resetting
                // the scissors register:

                if (xSrc & 1)
                {
                    // When unaligned, we have to be careful not to read
                    // past the end of the 4bpp bitmap (that could
                    // potentially cause us to access violate):

                    iLoop = cxThis >> 1;        // Each loop handles 2 pels;
                                                //   we'll handle odd pel
                                                //   separately
                    jSrc  = *pjSrc;

                    while (iLoop-- != 0)
                    {
                        *pjDst++ = (BYTE) pulXlate[jSrc & 0xf];
                        jSrc = *(++pjSrc);
                        *pjDst++ = (BYTE) pulXlate[jSrc >> 4];
                    }

                    if (cxThis & 1)
                    {
                        *pjDst++ = (BYTE) pulXlate[jSrc & 0xf];
                        *pjDst = 0;
                    }
                }
                else
                {
                    iLoop = (cxThis + 1) >> 1;  // Each loop handles 2 pels
                    do {
                        jSrc = *pjSrc++;

                        *pjDst++ = (BYTE) pulXlate[jSrc >> 4];
                        *pjDst++ = (BYTE) pulXlate[jSrc & 0xf];

                    } while (--iLoop != 0);
                }

                // The number of bytes we'll transfer is equal to the number
                // of pels we've processed in the batch.  Since we're
                // transferring words, we have to round up to get the word
                // count:

                cwThis = (cxThis + 1) >> 1;
                pjBuf  = ajBuf;
                MM_TRANSFER_WORD_ALIGNED(ppdev, pjMmBase, pjBuf, cwThis);

            } while (cxToGo > 0);

            pjScan += lSrcDelta;        // Advance to next source scan.  Note
                                        //   that we could have computed the
                                        //   value to advance 'pjSrc' directly,
                                        //   but this method is less
                                        //   error-prone.

        } while (--cy != 0);

        CHECK_DATA_COMPLETE(ppdev);

        if (--c == 0)
            return;

        prcl++;
        IO_FIFO_WAIT(ppdev, 4);
    }
}

/******************************Public*Routine******************************\
* VOID vMmXferNative
*
* Transfers a bitmap that is the same colour depth as the display to
* the screen via the data transfer register, with no translation.
*
\**************************************************************************/

VOID vMmXferNative(     // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ROP4        rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Not used
{
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    LONG    cjSrc;
    BYTE*   pjMmBase = ppdev->pjMmBase;

    ASSERTDD((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL),
            "Can handle trivial xlate only");
    ASSERTDD(psoSrc->iBitmapFormat == ppdev->iBitmapFormat,
            "Source must be same colour depth as screen");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    IO_FIFO_WAIT(ppdev, 6);
    MM_PIX_CNTL(ppdev, pjMmBase, ALL_ONES);
    MM_FRGD_MIX(ppdev, pjMmBase, SRC_CPU_DATA | gaulHwMixFromRop2[rop4 & 0xf]);

    while(TRUE)
    {
        MM_CUR_X(ppdev, pjMmBase, prcl->left);
        MM_CUR_Y(ppdev, pjMmBase, prcl->top);

        cx = prcl->right  - prcl->left;
        MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, cx - 1);

        cy = prcl->bottom - prcl->top;
        MM_MIN_AXIS_PCNT(ppdev, pjMmBase, cy - 1);

        cjSrc = CONVERT_TO_BYTES(cx, ppdev);
        pjSrc = pjSrcScan0 + (prcl->top  + dy) * lSrcDelta
                + CONVERT_TO_BYTES((prcl->left + dx), ppdev);

        ppdev->pfnImageTransfer(ppdev, pjSrc, lSrcDelta, cjSrc, cy,
                      (RECTANGLE_FILL | WAIT          | DRAWING_DIR_TBLRXM |
                       DRAW           | LAST_PIXEL_ON | SINGLE_PIXEL       |
                       WRITE          | BYTE_SWAP));

        if (--c == 0)
            return;

        prcl++;
        IO_FIFO_WAIT(ppdev, 4);
    }
}

/******************************Public*Routine******************************\
* VOID vMmCopyBlt
*
* Does a screen-to-screen blt of a list of rectangles.
*
\**************************************************************************/

VOID vMmCopyBlt(    // Type FNCOPY
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ULONG   rop4,       // rop4
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    LONG    dx;
    LONG    dy;     // Add delta to destination to get source
    LONG    cx;
    LONG    cy;     // Size of current rectangle - 1
    BYTE*   pjMmBase = ppdev->pjMmBase;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    IO_FIFO_WAIT(ppdev, 2);
    MM_FRGD_MIX(ppdev, pjMmBase, SRC_DISPLAY_MEMORY | gaulHwMixFromRop2[rop4 & 0xf]);
    MM_PIX_CNTL(ppdev, pjMmBase, ALL_ONES);

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    // The accelerator may not be as fast at doing right-to-left copies, so
    // only do them when the rectangles truly overlap:

    if (!OVERLAP(prclDst, pptlSrc))
        goto Top_Down_Left_To_Right;

    if (prclDst->top <= pptlSrc->y)
    {
        if (prclDst->left <= pptlSrc->x)
        {

Top_Down_Left_To_Right:

            do {
                IO_FIFO_WAIT(ppdev, 7);

                cx = prcl->right - prcl->left - 1;
                MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, cx);
                MM_DEST_X(ppdev, pjMmBase, prcl->left);
                MM_CUR_X(ppdev,  pjMmBase, prcl->left + dx);

                cy = prcl->bottom - prcl->top - 1;
                MM_MIN_AXIS_PCNT(ppdev, pjMmBase, cy);
                MM_DEST_Y(ppdev, pjMmBase, prcl->top);
                MM_CUR_Y(ppdev,  pjMmBase, prcl->top + dy);

                MM_CMD(ppdev, pjMmBase, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                                        DRAWING_DIR_TBLRXM);
                prcl++;

            } while (--c != 0);
        }
        else
        {
            do {
                IO_FIFO_WAIT(ppdev, 7);

                cx = prcl->right - prcl->left - 1;
                MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, cx);
                MM_DEST_X(ppdev, pjMmBase, prcl->left + cx);
                MM_CUR_X(ppdev,  pjMmBase, prcl->left + cx + dx);

                cy = prcl->bottom - prcl->top - 1;
                MM_MIN_AXIS_PCNT(ppdev, pjMmBase, cy);
                MM_DEST_Y(ppdev, pjMmBase, prcl->top);
                MM_CUR_Y(ppdev,  pjMmBase, prcl->top + dy);

                MM_CMD(ppdev, pjMmBase, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                                        DRAWING_DIR_TBRLXM);
                prcl++;

            } while (--c != 0);
        }
    }
    else
    {
        if (prclDst->left <= pptlSrc->x)
        {
            do {
                IO_FIFO_WAIT(ppdev, 7);

                cx = prcl->right - prcl->left - 1;
                MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, cx);
                MM_DEST_X(ppdev, pjMmBase, prcl->left);
                MM_CUR_X(ppdev,  pjMmBase, prcl->left + dx);

                cy = prcl->bottom - prcl->top - 1;
                MM_MIN_AXIS_PCNT(ppdev, pjMmBase, cy);
                MM_DEST_Y(ppdev, pjMmBase, prcl->top + cy);
                MM_CUR_Y(ppdev,  pjMmBase, prcl->top + cy + dy);

                MM_CMD(ppdev, pjMmBase, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                                        DRAWING_DIR_BTLRXM);
                prcl++;

            } while (--c != 0);
        }
        else
        {
            do {
                IO_FIFO_WAIT(ppdev, 7);

                cx = prcl->right - prcl->left - 1;
                MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, cx);
                MM_DEST_X(ppdev, pjMmBase, prcl->left + cx);
                MM_CUR_X(ppdev,  pjMmBase, prcl->left + cx + dx);

                cy = prcl->bottom - prcl->top - 1;
                MM_MIN_AXIS_PCNT(ppdev, pjMmBase, cy);
                MM_DEST_Y(ppdev, pjMmBase, prcl->top + cy);
                MM_CUR_Y(ppdev,  pjMmBase, prcl->top + cy + dy);

                MM_CMD(ppdev, pjMmBase, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                                        DRAWING_DIR_BTRLXM);
                prcl++;

            } while (--c != 0);
        }
    }
}

/******************************Public*Routine******************************\
* VOID vMmCopyTransparent
*
* Does a screen-to-screen blt of a list of rectangles using a source
* colorkey for transparency.
*
\**************************************************************************/

VOID vMmCopyTransparent(    // Type FNCOPYTRANSPARENT
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst,    // Original unclipped destination rectangle
ULONG   iColor)
{
    LONG    dx;
    LONG    dy;     // Add delta to destination to get source
    BYTE*   pjMmBase = ppdev->pjMmBase;

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    // Note that we don't have to worry about overlapping blts, since GDI
    // will never allow those down to us.

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    IO_FIFO_WAIT(ppdev, 4);
    MM_COLOR_CMP(ppdev, pjMmBase, iColor);
    MM_MULTIFUNC_CNTL(ppdev, pjMmBase, ppdev->ulMiscState
                                     | MULT_MISC_COLOR_COMPARE);
    MM_FRGD_MIX(ppdev, pjMmBase, SRC_DISPLAY_MEMORY | OVERPAINT);
    MM_PIX_CNTL(ppdev, pjMmBase, ALL_ONES);

    while (TRUE)
    {
        IO_FIFO_WAIT(ppdev, 7);
        MM_CUR_X(ppdev, pjMmBase, prcl->left + dx);
        MM_CUR_Y(ppdev, pjMmBase, prcl->top + dy);
        MM_DEST_X(ppdev, pjMmBase, prcl->left);
        MM_DEST_Y(ppdev, pjMmBase, prcl->top);
        MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, prcl->right - prcl->left - 1);
        MM_MIN_AXIS_PCNT(ppdev, pjMmBase, prcl->bottom - prcl->top - 1);
        MM_CMD(ppdev, pjMmBase, BITBLT | DRAW | DIR_TYPE_XY |
                                WRITE | DRAWING_DIR_TBLRXM);

        if (--c == 0)
        {
            IO_FIFO_WAIT(ppdev, 1);
            MM_MULTIFUNC_CNTL(ppdev, pjMmBase, ppdev->ulMiscState);
            return;
        }

        prcl++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\ddraw.c ===
/******************************Module*Header*******************************\
*      
*                         **************************
*                         * DirectDraw SAMPLE CODE *
*                         **************************
*
* Module Name: ddraw.c
*
* Implements all the DirectDraw components for the driver.
*
* Copyright (c) 1995-1998 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// Defines we'll use in the surface's 'dwReserved1' field:

#define DD_RESERVED_DIFFERENTPIXELFORMAT    0x0001

// Worst-case possible number of FIFO entries we'll have to wait for in
// DdBlt for any operation:

#define DDBLT_FIFO_COUNT    9

// NT is kind enough to pre-calculate the 2-d surface offset as a 'hint' so
// that we don't have to do the following, which would be 6 DIVs per blt:
//
//    y += (offset / pitch)
//    x += (offset % pitch) / bytes_per_pixel

#define convertToGlobalCord(x, y, surf) \
{                                       \
    y += surf->yHint;                   \
    x += surf->xHint;                   \
}

/******************************Public*Routine******************************\
* VOID vFixMissingPixels
*
* Trio64V+ work-around.
*
* On 1024x768x8 and 800x600x8 modes, switching from K2 to stream processor
* results in 1 character clock pixels on the right handed side of the screen
* missing. This problem can be worked-around by adjusting CR2 register.
*
\**************************************************************************/

VOID vFixMissingPixels(
PDEV*   ppdev)
{
    BYTE*   pjIoBase;
    BYTE    jVerticalRetraceEnd;

    ASSERTDD(ppdev->flCaps & CAPS_STREAMS_CAPABLE, "Must be streams capable");

    pjIoBase = ppdev->pjIoBase;

    // Unlock CRTC control registers:

    OUTP(pjIoBase, CRTC_INDEX, 0x11);
    jVerticalRetraceEnd = INP(pjIoBase, CRTC_DATA);
    OUTP(pjIoBase, CRTC_DATA, jVerticalRetraceEnd & 0x7f);

    // Add one character clock:

    OUTP(pjIoBase, CRTC_INDEX, 0x2);
    ppdev->jSavedCR2 = INP(pjIoBase, CRTC_DATA);
    OUTP(pjIoBase, CRTC_DATA, ppdev->jSavedCR2 + 1);

    // Lock CRTC control registers again:

    OUTP(pjIoBase, CRTC_INDEX, 0x11);
    OUTP(pjIoBase, CRTC_DATA, jVerticalRetraceEnd | 0x80);
}

/******************************Public*Routine******************************\
* VOID vUnfixMissingPixels
*
* Trio64V+ work-around.
*
\**************************************************************************/

VOID vUnfixMissingPixels(
PDEV*   ppdev)
{
    BYTE*   pjIoBase;
    BYTE    jVerticalRetraceEnd;

    pjIoBase = ppdev->pjIoBase;

    // Unlock CRTC control registers:

    OUTP(pjIoBase, CRTC_INDEX, 0x11);
    jVerticalRetraceEnd = INP(pjIoBase, CRTC_DATA);
    OUTP(pjIoBase, CRTC_DATA, jVerticalRetraceEnd & 0x7f);

    // Restore original register value:

    OUTP(pjIoBase, CRTC_INDEX, 0x2);
    OUTP(pjIoBase, CRTC_DATA, ppdev->jSavedCR2);

    // Lock CRTC control registers again:

    OUTP(pjIoBase, CRTC_INDEX, 0x11);
    OUTP(pjIoBase, CRTC_DATA, jVerticalRetraceEnd | 0x80);
}

/******************************Public*Routine******************************\
* VOID vStreamsDelay()
*
* This tries to work around a hardware timing bug.  Supposedly, consecutive
* writes to the streams processor in fast CPUs such as P120 and P133's
* have problems.  I haven't seen this problem, but this work-around exists
* in the Windows 95 driver, and at this point don't want to chance not
* having it.  Note that writes to the streams processor are not performance
* critical, so this is not a performance hit.
*
\**************************************************************************/

VOID vStreamsDelay()
{
    volatile LONG i;

    for (i = 32; i != 0; i--)
        ;
}

/******************************Public*Routine******************************\
* VOID vTurnOnStreamsProcessorMode
*
\**************************************************************************/

VOID vTurnOnStreamsProcessorMode(
PDEV*   ppdev)
{
    BYTE*   pjMmBase;
    BYTE*   pjIoBase;
    BYTE    jStreamsProcessorModeSelect;
    DWORD   dwPFormat;

    ASSERTDD(ppdev->flCaps & CAPS_STREAMS_CAPABLE, "Must be streams capable");

    ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

    pjMmBase = ppdev->pjMmBase;
    pjIoBase = ppdev->pjIoBase;

    NW_GP_WAIT(ppdev, pjMmBase);

    while (!(VBLANK_IS_ACTIVE(pjIoBase)))
        ;

    // Full streams processor operation:

    OUTP(pjIoBase, CRTC_INDEX, 0x67);
    jStreamsProcessorModeSelect = INP(pjIoBase, CRTC_DATA);
    OUTP(pjIoBase, CRTC_DATA, jStreamsProcessorModeSelect | 0x0c);

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        vFixMissingPixels(ppdev);
    }

    switch(ppdev->iBitmapFormat)
    {
    case BMF_8BPP:
        dwPFormat = P_RGB8;
        break;

    case BMF_16BPP:
        if (IS_RGB15_R(ppdev->flRed))
            dwPFormat = P_RGB15;
        else
            dwPFormat = P_RGB16;
        break;

    case BMF_32BPP:
        dwPFormat = P_RGB32;
        break;

    default:
        RIP("Unexpected bitmap format");
    }

    WRITE_STREAM_D(pjMmBase, P_CONTROL,      dwPFormat );
    WRITE_STREAM_D(pjMmBase, FIFO_CONTROL,   ((0xcL << FifoAlloc_Shift)|
                                              (4L << P_FifoThresh_Shift) |
                                              (4L << S_FifoThresh_Shift)));
    WRITE_STREAM_D(pjMmBase, P_0,            0);
    WRITE_STREAM_D(pjMmBase, P_STRIDE,       ppdev->lDelta);
    WRITE_STREAM_D(pjMmBase, P_XY,           0x010001L);
    WRITE_STREAM_D(pjMmBase, P_WH,           WH(ppdev->cxScreen, ppdev->cyScreen));
    WRITE_STREAM_D(pjMmBase, S_WH,           WH(10, 2));
    WRITE_STREAM_D(pjMmBase, CKEY_LOW,       ppdev->ulColorKey | 
                                              CompareBits0t7 |
                                              KeyFromCompare);
    WRITE_STREAM_D(pjMmBase, CKEY_HI,        ppdev->ulColorKey);
    WRITE_STREAM_D(pjMmBase, BLEND_CONTROL,  POnS);
    WRITE_STREAM_D(pjMmBase, OPAQUE_CONTROL, 0);
    WRITE_STREAM_D(pjMmBase, FIFO_CONTROL,   ppdev->ulFifoValue);

    RELEASE_CRTC_CRITICAL_SECTION(ppdev);
}

/******************************Public*Routine******************************\
* VOID vTurnOffStreamsProcessorMode
*
\**************************************************************************/

VOID vTurnOffStreamsProcessorMode(
PDEV*   ppdev)
{
    BYTE*   pjMmBase;
    BYTE*   pjIoBase;
    BYTE    jStreamsProcessorModeSelect;

    ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

    pjMmBase = ppdev->pjMmBase;
    pjIoBase = ppdev->pjIoBase;

    NW_GP_WAIT(ppdev, pjMmBase);

    while (!(VBLANK_IS_ACTIVE(pjIoBase)))
        ;

    WRITE_STREAM_D(pjMmBase, FIFO_CONTROL, 0x3000L);

    OUTP(pjIoBase, CRTC_INDEX, 0x67);
    jStreamsProcessorModeSelect = INP(pjIoBase, CRTC_DATA);
    OUTP(pjIoBase, CRTC_DATA, jStreamsProcessorModeSelect & ~0x0C);

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        vUnfixMissingPixels(ppdev);
    }

    RELEASE_CRTC_CRITICAL_SECTION(ppdev);
}

/******************************Public*Routine******************************\
* DWORD dwGetPaletteEntry
*
\**************************************************************************/

DWORD dwGetPaletteEntry(
PDEV* ppdev,
DWORD iIndex)
{
    BYTE*   pjIoBase;
    DWORD   dwRed;
    DWORD   dwGreen;
    DWORD   dwBlue;

    pjIoBase = ppdev->pjIoBase;

    OUTP(pjIoBase, 0x3c7, iIndex);

    dwRed   = INP(pjIoBase, 0x3c9) << 2;
    dwGreen = INP(pjIoBase, 0x3c9) << 2;
    dwBlue  = INP(pjIoBase, 0x3c9) << 2;

    return((dwRed << 16) | (dwGreen << 8) | (dwBlue));
}

/******************************Public*Routine******************************\
* VOID vGetDisplayDuration
*
* Get the length, in EngQueryPerformanceCounter() ticks, of a refresh cycle.
*
* If we could trust the miniport to return back and accurate value for
* the refresh rate, we could use that.  Unfortunately, our miniport doesn't
* ensure that it's an accurate value.
*
\**************************************************************************/

#define NUM_VBLANKS_TO_MEASURE      1
#define NUM_MEASUREMENTS_TO_TAKE    8

VOID vGetDisplayDuration(
PDEV* ppdev)
{
    BYTE*       pjIoBase;
    LONG        i;
    LONG        j;
    LONGLONG    li;
    LONGLONG    liFrequency;
    LONGLONG    liMin;
    LONGLONG    aliMeasurement[NUM_MEASUREMENTS_TO_TAKE + 1];

    pjIoBase = ppdev->pjIoBase;

    memset(&ppdev->flipRecord, 0, sizeof(ppdev->flipRecord));

    // Warm up EngQUeryPerformanceCounter to make sure it's in the working
    // set:

    EngQueryPerformanceCounter(&li);

    // Unfortunately, since NT is a proper multitasking system, we can't
    // just disable interrupts to take an accurate reading.  We also can't
    // do anything so goofy as dynamically change our thread's priority to
    // real-time.
    //
    // So we just do a bunch of short measurements and take the minimum.
    //
    // It would be 'okay' if we got a result that's longer than the actual
    // VBlank cycle time -- nothing bad would happen except that the app
    // would run a little slower.  We don't want to get a result that's
    // shorter than the actual VBlank cycle time -- that could cause us
    // to start drawing over a frame before the Flip has occured.
    //
    // Skip a couple of vertical blanks to allow the hardware to settle
    // down after the mode change, to make our readings accurate:

    for (i = 2; i != 0; i--)
    {
        while (VBLANK_IS_ACTIVE(pjIoBase))
            ;
        while (!(VBLANK_IS_ACTIVE(pjIoBase)))
            ;
    }

    for (i = 0; i < NUM_MEASUREMENTS_TO_TAKE; i++)
    {
        // We're at the start of the VBlank active cycle!

        EngQueryPerformanceCounter(&aliMeasurement[i]);

        // Okay, so life in a multi-tasking environment isn't all that
        // simple.  What if we had taken a context switch just before
        // the above EngQueryPerformanceCounter call, and now were half
        // way through the VBlank inactive cycle?  Then we would measure
        // only half a VBlank cycle, which is obviously bad.  The worst
        // thing we can do is get a time shorter than the actual VBlank
        // cycle time.
        //
        // So we solve this by making sure we're in the VBlank active
        // time before and after we query the time.  If it's not, we'll
        // sync up to the next VBlank (it's okay to measure this period --
        // it will be guaranteed to be longer than the VBlank cycle and
        // will likely be thrown out when we select the minimum sample).
        // There's a chance that we'll take a context switch and return
        // just before the end of the active VBlank time -- meaning that
        // the actual measured time would be less than the true amount --
        // but since the VBlank is active less than 1% of the time, this
        // means that we would have a maximum of 1% error approximately
        // 1% of the times we take a context switch.  An acceptable risk.
        //
        // This next line will cause us wait if we're no longer in the
        // VBlank active cycle as we should be at this point:

        while (!(VBLANK_IS_ACTIVE(pjIoBase)))
            ;

        for (j = 0; j < NUM_VBLANKS_TO_MEASURE; j++)
        {
            while (VBLANK_IS_ACTIVE(pjIoBase))
                ;
            while (!(VBLANK_IS_ACTIVE(pjIoBase)))
                ;
        }
    }

    EngQueryPerformanceCounter(&aliMeasurement[NUM_MEASUREMENTS_TO_TAKE]);

    // Use the minimum:

    liMin = aliMeasurement[1] - aliMeasurement[0];

    DISPDBG((1, "Refresh count: %li - %li", 1, (ULONG) liMin));

    for (i = 2; i <= NUM_MEASUREMENTS_TO_TAKE; i++)
    {
        li = aliMeasurement[i] - aliMeasurement[i - 1];

        DISPDBG((1, "               %li - %li", i, (ULONG) li));

        if (li < liMin)
            liMin = li;
    }


    // Round the result:

    ppdev->flipRecord.liFlipDuration
        = (DWORD) (liMin + (NUM_VBLANKS_TO_MEASURE / 2)) / NUM_VBLANKS_TO_MEASURE;
    ppdev->flipRecord.bFlipFlag  = FALSE;
    ppdev->flipRecord.fpFlipFrom = 0;

    // We need the refresh rate in Hz to query the S3 miniport about the
    // streams parameters:

    EngQueryPerformanceFrequency(&liFrequency);

    ppdev->ulRefreshRate
        = (ULONG) ((liFrequency + (ppdev->flipRecord.liFlipDuration / 2))
                    / ppdev->flipRecord.liFlipDuration);

    DISPDBG((1, "Frequency: %li Hz", ppdev->ulRefreshRate));
}

/******************************Public*Routine******************************\
* HRESULT ddrvalUpdateFlipStatus
*
* Checks and sees if the most recent flip has occurred.
*
* Unfortunately, the hardware has no ability to tell us whether a vertical
* retrace has occured since the flip command was given other than by
* sampling the vertical-blank-active and display-active status bits.
*
\**************************************************************************/

HRESULT ddrvalUpdateFlipStatus(
PDEV*   ppdev,
FLATPTR fpVidMem)
{
    BYTE*       pjIoBase;
    LONGLONG    liTime;

    pjIoBase = ppdev->pjIoBase;

    if ((ppdev->flipRecord.bFlipFlag) &&
        ((fpVidMem == (FLATPTR) -1) ||
         (fpVidMem == ppdev->flipRecord.fpFlipFrom)))
    {
        if (VBLANK_IS_ACTIVE(pjIoBase))
        {
            if (ppdev->flipRecord.bWasEverInDisplay)
            {
                ppdev->flipRecord.bHaveEverCrossedVBlank = TRUE;
            }
        }
        else if (DISPLAY_IS_ACTIVE(pjIoBase))
        {
            if (ppdev->flipRecord.bHaveEverCrossedVBlank)
            {
                ppdev->flipRecord.bFlipFlag = FALSE;
                return(DD_OK);
            }
            ppdev->flipRecord.bWasEverInDisplay = TRUE;
        }

        // It's pretty unlikely that we'll happen to sample the vertical-
        // blank-active at the first vertical blank after the flip command
        // has been given.  So to provide better results, we also check the
        // time elapsed since the flip.  If it's more than the duration of
        // one entire refresh of the display, then we know for sure it has
        // happened:

        EngQueryPerformanceCounter(&liTime);

        if (liTime - ppdev->flipRecord.liFlipTime
                                <= ppdev->flipRecord.liFlipDuration)
        {
            return(DDERR_WASSTILLDRAWING);
        }

        ppdev->flipRecord.bFlipFlag = FALSE;
    }

    return(DD_OK);
}

/******************************Public*Routine******************************\
* DWORD DdBlt
*
\**************************************************************************/

DWORD DdBlt(
PDD_BLTDATA lpBlt)
{
    PDD_SURFACE_GLOBAL  srcSurf;
    PDD_SURFACE_LOCAL   dstSurfx;
    PDD_SURFACE_GLOBAL  dstSurf;
    PDEV*               ppdev;
    BYTE*               pjMmBase;
    HRESULT             ddrval;
    DWORD               dstX;
    DWORD               dstY;
    DWORD               dwFlags;
    DWORD               dstWidth;
    DWORD               dstHeight;
    DWORD               srcWidth;
    DWORD               srcHeight;
    DWORD               dwError;
    LONG                dstPitch;
    LONG                srcPitch;
    DWORD               srcX;
    DWORD               srcY;
    ULONG               ulBltCmd;
    DWORD               dwVEctrl;
    DWORD               dwVEdda;
    DWORD               dwVEcrop;
    DWORD               dwVEdstAddr;
    DWORD               dwVEsrcAddr;
    DWORD               dwDstByteCount;
    DWORD               dwSrcByteCount;
    DWORD               dwSrcBytes;
    DWORD               dwCropSkip;
    LONG                i;
    FLATPTR             fp;

    ppdev    = (PDEV*) lpBlt->lpDD->dhpdev;
    pjMmBase = ppdev->pjMmBase;

    dstSurfx = lpBlt->lpDDDestSurface;
    dstSurf  = dstSurfx->lpGbl;

    // Is a flip in progress?

    ddrval = ddrvalUpdateFlipStatus(ppdev, dstSurf->fpVidMem);
    if (ddrval != DD_OK)
    {
        lpBlt->ddRVal = ddrval;
        return(DDHAL_DRIVER_HANDLED);
    }

    dwFlags = lpBlt->dwFlags;
    if (dwFlags & DDBLT_ASYNC)
    {
        // If async, then only work if we won't have to wait on the
        // accelerator to start the command.
        //
        // The FIFO wait should account for the worst-case possible
        // blt that we would do:

        if (MM_FIFO_BUSY(ppdev, pjMmBase, DDBLT_FIFO_COUNT))
        {
            lpBlt->ddRVal = DDERR_WASSTILLDRAWING;
            return(DDHAL_DRIVER_HANDLED);
        }
    }

    // Copy src/dst rects:

    dstX      = lpBlt->rDest.left;
    dstY      = lpBlt->rDest.top;
    dstWidth  = lpBlt->rDest.right - lpBlt->rDest.left;
    dstHeight = lpBlt->rDest.bottom - lpBlt->rDest.top;

    if (dwFlags & DDBLT_COLORFILL)
    {
        // The S3 can't easily do colour fills for off-screen surfaces that
        // are a different pixel format than that of the primary display:

        if (dstSurf->dwReserved1 & DD_RESERVED_DIFFERENTPIXELFORMAT)
        {
            DISPDBG((0, "Can't do colorfill to odd pixel format"));
            return(DDHAL_DRIVER_NOTHANDLED);
        }
        else
        {
            convertToGlobalCord(dstX, dstY, dstSurf);

            NW_FIFO_WAIT(ppdev, pjMmBase, 6);

            NW_PIX_CNTL(ppdev, pjMmBase, ALL_ONES);
            NW_ALT_MIX(ppdev, pjMmBase, FOREGROUND_COLOR | OVERPAINT, 0);
            NW_FRGD_COLOR(ppdev, pjMmBase, lpBlt->bltFX.dwFillColor);
            NW_ABS_CURXY_FAST(ppdev, pjMmBase, dstX, dstY);
            NW_ALT_PCNT(ppdev, pjMmBase, dstWidth - 1, dstHeight - 1);
            NW_ALT_CMD(ppdev, pjMmBase, RECTANGLE_FILL | DRAWING_DIR_TBLRXM |
                                        DRAW           | DIR_TYPE_XY        |
                                        LAST_PIXEL_ON  | MULTIPLE_PIXELS    |
                                        WRITE);

            lpBlt->ddRVal = DD_OK;
            return(DDHAL_DRIVER_HANDLED);
        }
    }

    // We specified with Our ddCaps.dwCaps that we handle a limited number
    // of commands, and by this point in our routine we've handled everything
    // except DDBLT_ROP.  DirectDraw and GDI shouldn't pass us anything
    // else; we'll assert on debug builds to prove this:

    ASSERTDD((dwFlags & DDBLT_ROP) && (lpBlt->lpDDSrcSurface),
        "Expected dwFlags commands of only DDBLT_ASYNC and DDBLT_COLORFILL");

    // Get offset, dstWidth, and dstHeight for source:

    srcSurf      = lpBlt->lpDDSrcSurface->lpGbl;
    srcX         = lpBlt->rSrc.left;
    srcY         = lpBlt->rSrc.top;
    srcWidth     = lpBlt->rSrc.right - lpBlt->rSrc.left;
    srcHeight    = lpBlt->rSrc.bottom - lpBlt->rSrc.top;

    // If a stretch or a funky pixel format blt are involved, we'll have to
    // defer to the overlay or pixel formatter routines:

    if ((srcWidth  == dstWidth)  &&
        (srcHeight == dstHeight) &&
        !(srcSurf->dwReserved1 & DD_RESERVED_DIFFERENTPIXELFORMAT) &&
        !(dstSurf->dwReserved1 & DD_RESERVED_DIFFERENTPIXELFORMAT))
    {
        // Assume we can do the blt top-to-bottom, left-to-right:

        ulBltCmd = BITBLT | DRAW | DIR_TYPE_XY | WRITE | DRAWING_DIR_TBLRXM;

        if ((dstSurf == srcSurf) && (srcX + dstWidth  > dstX) &&
            (srcY + dstHeight > dstY) && (dstX + dstWidth > srcX) &&
            (dstY + dstHeight > srcY) &&
            (((srcY == dstY) && (dstX > srcX) )
                 || ((srcY != dstY) && (dstY > srcY))))
        {
            // Okay, we have to do the blt bottom-to-top, right-to-left:

            ulBltCmd = BITBLT | DRAW | DIR_TYPE_XY | WRITE | DRAWING_DIR_BTRLXM;
            srcX = lpBlt->rSrc.right - 1;
            srcY = lpBlt->rSrc.bottom - 1;
            dstX = lpBlt->rDest.right - 1;
            dstY = lpBlt->rDest.bottom - 1;
        }

        // NT only ever gives us SRCCOPY rops, so don't even both checking
        // for anything else.

        convertToGlobalCord(srcX, srcY, srcSurf);
        convertToGlobalCord(dstX, dstY, dstSurf);

        if (dwFlags & DDBLT_KEYSRCOVERRIDE)
        {
            NW_FIFO_WAIT(ppdev, pjMmBase, 9);

            NW_MULT_MISC_READ_SEL(ppdev, pjMmBase, ppdev->ulMiscState
                                                 | MULT_MISC_COLOR_COMPARE, 0);
            NW_COLOR_CMP(ppdev, pjMmBase,
                                lpBlt->bltFX.ddckSrcColorkey.dwColorSpaceLowValue);
            NW_ALT_MIX(ppdev, pjMmBase, SRC_DISPLAY_MEMORY | OVERPAINT, 0);
            NW_PIX_CNTL(ppdev, pjMmBase, ALL_ONES);
            NW_ABS_CURXY_FAST(ppdev, pjMmBase, srcX, srcY);
            NW_ABS_DESTXY_FAST(ppdev, pjMmBase, dstX, dstY);
            NW_ALT_PCNT(ppdev, pjMmBase, dstWidth - 1, dstHeight - 1);
            NW_ALT_CMD(ppdev, pjMmBase, ulBltCmd);
            NW_MULT_MISC_READ_SEL(ppdev, pjMmBase, ppdev->ulMiscState, 0);
        }
        else
        {
            NW_FIFO_WAIT(ppdev, pjMmBase, 6);

            NW_ALT_MIX(ppdev, pjMmBase, SRC_DISPLAY_MEMORY | OVERPAINT, 0);
            NW_PIX_CNTL(ppdev, pjMmBase, ALL_ONES);
            NW_ABS_CURXY_FAST(ppdev, pjMmBase, srcX, srcY);
            NW_ABS_DESTXY_FAST(ppdev, pjMmBase, dstX, dstY);
            NW_ALT_PCNT(ppdev, pjMmBase, dstWidth - 1, dstHeight - 1);
            NW_ALT_CMD(ppdev, pjMmBase, ulBltCmd);
        }
    }

    //////////////////////////////////////////////////////////////////////
    // Pixel Formatter Blts
    //
    // We can do stretches or funky pixel format blts only if a pixel
    // formatter is present.  Plus, we set our 'ddCaps' such that we
    // shouldn't have to handle any shrinks.
    //
    // (We check to make sure we weren't asked to do a shrink, because we
    // would probably hang if the application ignored what we told them
    // and asked for a shrink):

    else if ((ppdev->flCaps & CAPS_PIXEL_FORMATTER) &&
             (srcWidth  <= dstWidth)  &&
             (srcHeight <= dstHeight))
    {
        if ((dwFlags & DDBLT_KEYSRCOVERRIDE) ||
            (dstWidth >= 4 * srcWidth))
        {
            // Contrary to what we're indicating in our capabilities, we
            // can't colour key on stretches or pixel format conversions.
            // The S3 hardware also can't do stretches of four times or
            // more.

            return(DDHAL_DRIVER_NOTHANDLED);
        }

        dwVEctrl = ~dstWidth & 0x00000FFF;          // Initial accumulator

        dwVEdda = 0x10000000                        // Some reserved bit?
                | (STRETCH | SCREEN)                // Scale from video memory
                | (srcWidth << 16)                  // K1
                | ((srcWidth - dstWidth) & 0x7FF);  // K2

        // We'll be doing the vertical stretching in software, so calculate
        // the DDA terms here.  We have the luxury of not worrying about
        // overflow because DirectDraw limits our coordinate space to 15
        // bits.
        //
        // Note that dwRGBBitCount is overloaded with dwYUVBitCount:

        dwSrcByteCount = srcSurf->ddpfSurface.dwRGBBitCount >> 3;
        if (srcSurf->ddpfSurface.dwFlags & DDPF_FOURCC)
        {
            dwVEctrl |= INPUT_YCrCb422 | CSCENABLE; // Not INPUT_YUV422!
        }
        else if (srcSurf->ddpfSurface.dwFlags & DDPF_RGB)
        {
            switch (dwSrcByteCount)
            {
            case 1:
                dwVEctrl |= INPUT_RGB8;
                break;

            case 2:
                if (IS_RGB15_R(srcSurf->ddpfSurface.dwRBitMask))
                    dwVEctrl |= INPUT_RGB15;
                else
                    dwVEctrl |= INPUT_RGB16;
                break;

            default:
                dwVEctrl |= INPUT_RGB32;
                break;
            }
        }

        dwDstByteCount = dstSurf->ddpfSurface.dwRGBBitCount >> 3;
        switch (dwDstByteCount)
        {
        case 1:
            dwVEctrl |= OUTPUT_RGB8;
            break;

        case 2:
            if (IS_RGB15_R(dstSurf->ddpfSurface.dwRBitMask))
                dwVEctrl |= OUTPUT_RGB15;
            else
                dwVEctrl |= OUTPUT_RGB16;
            break;

        default:
            dwVEctrl |=OUTPUT_RGB32;
            break;
        }

        if (dwDstByteCount > 1)
        {
            dwVEctrl |= FILTERENABLE;

            if (dstWidth > 2 * srcWidth)
                dwVEdda |= LINEAR12221;     // linear, 1-2-2-2-1, >2X stretch

            else if (dstWidth > srcWidth)
                dwVEdda |= LINEAR02420;     // linear, 0-2-4-2-0, 1-2X stretch

            else
                dwVEdda |= BILINEAR;        // bi-linear, <1X stretch
        }

        dwVEsrcAddr = (DWORD)(srcSurf->fpVidMem + (srcY * srcSurf->lPitch)
                                                + (srcX * dwSrcByteCount));
        dwVEdstAddr = (DWORD)(dstSurf->fpVidMem + (dstY * dstSurf->lPitch)
                                                + (dstX * dwDstByteCount));

        srcPitch = srcSurf->lPitch;
        dstPitch = dstSurf->lPitch;

        // The S3's source alignment within the dword must be done using the
        // crop register:

        dwVEcrop = dstWidth;

        if (dwVEsrcAddr & 3)
        {
            dwSrcBytes = (srcWidth * dwSrcByteCount);

            // Transform the number of source pixels to the number of
            // corresponding destination pixels, and round the result:

            dwCropSkip = ((dwVEsrcAddr & 3) * dstWidth + (dwSrcBytes >> 1))
                         / dwSrcBytes;

            dwVEcrop += (dwCropSkip << 16);

            dwVEsrcAddr &= ~3;
        }

        // We have to run the vertical DDA ourselves:

        dwError = srcHeight >> 1;
        i       = dstHeight;

        // Watch out for a hardware bug the destination will be 32 pixels
        // or less:
        //
        // We'll use 40 as our minimum width to guarantee we shouldn't
        // crash.

        if (dstWidth >= 40)
        {
            // The S3 will sometimes hang when using the video engine with
            // certain end-byte alignments.  We'll simply lengthen the blt in
            // this case and hope that no-one notices:

            if (((dwVEdstAddr + (dstWidth * dwDstByteCount)) & 7) == 4)
            {
                dwVEcrop++;
            }

            // We have to execute a graphics engine NOP before using the
            // pixel formatter video engine:

            NW_FIFO_WAIT(ppdev, pjMmBase, 1);
            NW_ALT_CMD(ppdev, pjMmBase, 0);
            NW_GP_WAIT(ppdev, pjMmBase);

            // Set up some non-variant registers:

            NW_FIFO_WAIT(ppdev, pjMmBase, 4);
            WRITE_FORMATTER_D(pjMmBase, PF_CONTROL, dwVEctrl);
            WRITE_FORMATTER_D(pjMmBase, PF_DDA,     dwVEdda);
            WRITE_FORMATTER_D(pjMmBase, PF_STEP,    ppdev->dwVEstep);
            WRITE_FORMATTER_D(pjMmBase, PF_CROP,    dwVEcrop);

            do {
                NW_FIFO_WAIT(ppdev, pjMmBase, 3);
                WRITE_FORMATTER_D(pjMmBase, PF_SRCADDR, dwVEsrcAddr);
                WRITE_FORMATTER_D(pjMmBase, PF_DSTADDR, dwVEdstAddr);
                WRITE_FORMATTER_D(pjMmBase, PF_NOP, 0);
                NW_FORMATTER_WAIT(ppdev, pjMmBase);

                dwVEdstAddr += dstPitch;
                dwError     += srcHeight;
                if (dwError >= dstHeight)
                {
                    dwError     -= dstHeight;
                    dwVEsrcAddr += srcPitch;
                }
            } while (--i != 0);
        }
        else if (dwDstByteCount != (DWORD) ppdev->cjPelSize)
        {
            // Because for narrow video engine blts we have to copy the
            // result using the normal graphics accelerator on a pixel
            // basis, we can't handle funky destination colour depths.
            // I expect zero applications to ask for narrow blts that
            // hit this case, so we will simply fail the call should it
            // ever actually occur:

            return(DDHAL_DRIVER_NOTHANDLED);
        }
        else
        {
            // The S3 will hang if we blt less than 32 pixels via the
            // pixel formatter.  Unfortunately, we can't simply return
            // DDHAL_DRIVER_NOTHANDLED for this case.  We said we'd do
            // hardware stretches, so we have to handle all hardware
            // stretches.
            //
            // We work around the problem by doing a 32 pixel stretch to
            // a piece of off-screen memory, then blting the appropriate
            // subset to the correct position on the screen.
            //
            // 32 isn't big enough.  We still hang.  Lets make it 40.

            dwVEcrop = 32 + 8;

            convertToGlobalCord(dstX, dstY, dstSurf);
            srcX = ppdev->pdsurfVideoEngineScratch->x;
            srcY = ppdev->pdsurfVideoEngineScratch->y;
            dwVEdstAddr = (srcY * ppdev->lDelta) + (srcX * ppdev->cjPelSize);

            ASSERTDD(((dwVEdstAddr + (dwVEcrop * dwDstByteCount)) & 7) != 4,
                "Must account for S3 end-alignment bug");

            do {
                // Use the pixel formatter to blt to our scratch area:

                NW_FIFO_WAIT(ppdev, pjMmBase, 1);
                NW_ALT_CMD(ppdev, pjMmBase, 0);
                NW_GP_WAIT(ppdev, pjMmBase);

                NW_FIFO_WAIT(ppdev, pjMmBase, 7);
                WRITE_FORMATTER_D(pjMmBase, PF_CONTROL, dwVEctrl);
                WRITE_FORMATTER_D(pjMmBase, PF_DDA,     dwVEdda);
                WRITE_FORMATTER_D(pjMmBase, PF_STEP,    ppdev->dwVEstep);
                WRITE_FORMATTER_D(pjMmBase, PF_CROP,    dwVEcrop);
                WRITE_FORMATTER_D(pjMmBase, PF_SRCADDR, dwVEsrcAddr);
                WRITE_FORMATTER_D(pjMmBase, PF_DSTADDR, dwVEdstAddr);
                WRITE_FORMATTER_D(pjMmBase, PF_NOP, 0);
                NW_FORMATTER_WAIT(ppdev, pjMmBase);

                dwError += srcHeight;
                if (dwError >= dstHeight)
                {
                    dwError     -= dstHeight;
                    dwVEsrcAddr += srcPitch;
                }

                // Now copy from the scratch area to the final destination:

                NW_FIFO_WAIT(ppdev, pjMmBase, 6);
                NW_ALT_MIX(ppdev, pjMmBase, SRC_DISPLAY_MEMORY | OVERPAINT, 0);
                NW_PIX_CNTL(ppdev, pjMmBase, ALL_ONES);
                NW_ABS_CURXY_FAST(ppdev, pjMmBase, srcX, srcY);
                NW_ABS_DESTXY_FAST(ppdev, pjMmBase, dstX, dstY);
                NW_ALT_PCNT(ppdev, pjMmBase, dstWidth - 1, 0);
                NW_ALT_CMD(ppdev, pjMmBase, BITBLT | DRAW | DIR_TYPE_XY |
                                            WRITE | DRAWING_DIR_TBLRXM);

                dstY++;

            } while (--i != 0);
        }
    }
    else
    {
        //////////////////////////////////////////////////////////////////////
        // Overlay Blts
        //
        // Here we have to take care of cases where the destination is a
        // funky pixel format.

        // In order to make ActiveMovie and DirectVideo work, we have
        // to support blting between funky pixel format surfaces of the
        // same type.  This is used to copy the current frame to the
        // next overlay surface in line.
        //
        // Unfortunately, it's not easy to switch the S3 graphics
        // processor out of its current pixel depth, so we'll only support
        // the minimal functionality required:

        if (!(dwFlags & DDBLT_ROP)                     ||
            (srcX != 0)                                ||
            (srcY != 0)                                ||
            (dstX != 0)                                ||
            (dstY != 0)                                ||
            (dstWidth  != dstSurf->wWidth)             ||
            (dstHeight != dstSurf->wHeight)            ||
            (dstSurf->lPitch != srcSurf->lPitch)       ||
            (dstSurf->ddpfSurface.dwRGBBitCount
                != srcSurf->ddpfSurface.dwRGBBitCount))
        {
            DISPDBG((0, "Sorry, we do only full-surface blts between same-type"));
            DISPDBG((0, "surfaces that have a funky pixel format."));
            return(DDHAL_DRIVER_NOTHANDLED);
        }
        else
        {
            // Convert the dimensions to the current pixel format.  This
            // is pretty easy because we created the bitmap linearly, so
            // it takes the entire width of the screen:

            dstWidth  = ppdev->cxMemory;
            dstHeight = dstSurf->dwBlockSizeY;

            convertToGlobalCord(dstX, dstY, dstSurf);
            convertToGlobalCord(srcX, srcY, srcSurf);

            NW_FIFO_WAIT(ppdev, pjMmBase, 6);
            NW_ALT_MIX(ppdev, pjMmBase, SRC_DISPLAY_MEMORY | OVERPAINT, 0);
            NW_PIX_CNTL(ppdev, pjMmBase, ALL_ONES);
            NW_ABS_CURXY_FAST(ppdev, pjMmBase, srcX, srcY);
            NW_ABS_DESTXY_FAST(ppdev, pjMmBase, dstX, dstY);
            NW_ALT_PCNT(ppdev, pjMmBase, dstWidth - 1, dstHeight - 1);
            NW_ALT_CMD(ppdev, pjMmBase, BITBLT | DRAW | DIR_TYPE_XY |
                                        WRITE | DRAWING_DIR_TBLRXM);
        }
    }

    lpBlt->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdFlip
*
* Note that lpSurfCurr may not necessarily be valid.
*
\**************************************************************************/

DWORD DdFlip(
PDD_FLIPDATA lpFlip)
{
    PDEV*       ppdev;
    BYTE*       pjIoBase;
    BYTE*       pjMmBase;
    HRESULT     ddrval;
    ULONG       ulMemoryOffset;
    ULONG       ulLowOffset;
    ULONG       ulMiddleOffset;
    ULONG       ulHighOffset;

    ppdev    = (PDEV*) lpFlip->lpDD->dhpdev;
    pjIoBase = ppdev->pjIoBase;
    pjMmBase = ppdev->pjMmBase;

    // Is the current flip still in progress?
    //
    // Don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status and ignore the vmem.

    ddrval = ddrvalUpdateFlipStatus(ppdev, (FLATPTR) -1);
    if ((ddrval != DD_OK) || (NW_GP_BUSY(ppdev, pjMmBase)))
    {
        lpFlip->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    ulMemoryOffset = (ULONG)(lpFlip->lpSurfTarg->lpGbl->fpVidMem);

    // Make sure that the border/blanking period isn't active; wait if
    // it is.  We could return DDERR_WASSTILLDRAWING in this case, but
    // that will increase the odds that we can't flip the next time:

    while (!(DISPLAY_IS_ACTIVE(pjIoBase)))
        ;

    if (ppdev->flStatus & STAT_STREAMS_ENABLED)
    {
        // When using the streams processor, we have to do the flip via the
        // streams registers:

        if (lpFlip->lpSurfCurr->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
        {
            WRITE_STREAM_D(pjMmBase, P_0, ulMemoryOffset);
        }
        else if (lpFlip->lpSurfCurr->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
        {
            // Make sure that the overlay surface we're flipping from is
            // currently visible.  If you don't do this check, you'll get
            // really weird results when someone starts up two ActiveMovie
            // or DirectVideo movies simultaneously!

            if (lpFlip->lpSurfCurr->lpGbl->fpVidMem == ppdev->fpVisibleOverlay)
            {
                ppdev->fpVisibleOverlay = ulMemoryOffset;

                WRITE_STREAM_D(pjMmBase, S_0, ulMemoryOffset +
                                              ppdev->dwOverlayFlipOffset);
            }
        }
    }
    else
    {
        // Do the old way, via the CRTC registers:

        ulMemoryOffset >>= 2;

        ulLowOffset    = 0x0d | ((ulMemoryOffset & 0x0000ff) << 8);
        ulMiddleOffset = 0x0c | ((ulMemoryOffset & 0x00ff00));
        ulHighOffset   = 0x69 | ((ulMemoryOffset & 0x1f0000) >> 8)
                              | ppdev->ulExtendedSystemControl3Register_69;

        // Don't let the cursor thread touch the CRT registers while we're
        // using them:

        ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

        // Too bad that the S3's flip can't be done in a single atomic register
        // write; as it is, we stand a small chance of being context-switched
        // out and exactly hitting the vertical blank in the middle of doing
        // these outs, possibly causing the screen to momentarily jump.
        //
        // There are some hoops we could jump through to minimize the chances
        // of this happening; we could try to align the flip buffer such that
        // the minor registers are ensured to be identical for either flip
        // position, and so that only the high address need be written, an
        // obviously atomic operation.
        //
        // However, I'm simply not going to worry about it.

        OUTPW(pjIoBase, CRTC_INDEX, ulLowOffset);
        OUTPW(pjIoBase, CRTC_INDEX, ulMiddleOffset);
        OUTPW(pjIoBase, CRTC_INDEX, ulHighOffset);

        RELEASE_CRTC_CRITICAL_SECTION(ppdev);
    }

    // Remember where and when we were when we did the flip:

    EngQueryPerformanceCounter(&ppdev->flipRecord.liFlipTime);

    ppdev->flipRecord.bFlipFlag              = TRUE;
    ppdev->flipRecord.bHaveEverCrossedVBlank = FALSE;
    ppdev->flipRecord.bWasEverInDisplay      = FALSE;

    ppdev->flipRecord.fpFlipFrom = lpFlip->lpSurfCurr->lpGbl->fpVidMem;

    lpFlip->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdLock
*
\**************************************************************************/

DWORD DdLock(
PDD_LOCKDATA lpLock)
{
    PDEV*   ppdev;
    BYTE*   pjMmBase;
    HRESULT ddrval;

    ppdev = (PDEV*) lpLock->lpDD->dhpdev;
    pjMmBase = ppdev->pjMmBase;

    // Check to see if any pending physical flip has occurred.  Don't allow
    // a lock if a blt is in progress:

    ddrval = ddrvalUpdateFlipStatus(ppdev, lpLock->lpDDSurface->lpGbl->fpVidMem);
    if (ddrval != DD_OK)
    {
        lpLock->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    // Here's one of the places where the Windows 95 and Windows NT DirectDraw
    // implementations differ: on Windows NT, you should watch for
    // DDLOCK_WAIT and loop in the driver while the accelerator is busy.
    // On Windows 95, it doesn't really matter.
    //
    // (The reason is that Windows NT allows applications to draw directly
    // to the frame buffer even while the accelerator is running, and does
    // not synchronize everything on the Win16Lock.  Note that on Windows NT,
    // it is even possible for multiple threads to be holding different
    // DirectDraw surface locks at the same time.)

    if (lpLock->dwFlags & DDLOCK_WAIT)
    {
        NW_GP_WAIT(ppdev, pjMmBase);
    }
    else if (NW_GP_BUSY(ppdev, pjMmBase))
    {
        lpLock->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdGetBltStatus
*
* Doesn't currently really care what surface is specified, just checks
* and goes.
*
\**************************************************************************/

DWORD DdGetBltStatus(
PDD_GETBLTSTATUSDATA lpGetBltStatus)
{
    PDEV*   ppdev;
    BYTE*   pjMmBase;
    HRESULT ddRVal;

    ppdev    = (PDEV*) lpGetBltStatus->lpDD->dhpdev;
    pjMmBase = ppdev->pjMmBase;

    ddRVal = DD_OK;
    if (lpGetBltStatus->dwFlags == DDGBS_CANBLT)
    {
        // DDGBS_CANBLT case: can we add a blt?

        ddRVal = ddrvalUpdateFlipStatus(ppdev,
                        lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem);

        if (ddRVal == DD_OK)
        {
            // There was no flip going on, so is there room in the FIFO
            // to add a blt?

            if (MM_FIFO_BUSY(ppdev, pjMmBase, DDBLT_FIFO_COUNT))
            {
                ddRVal = DDERR_WASSTILLDRAWING;
            }
        }
    }
    else
    {
        // DDGBS_ISBLTDONE case: is a blt in progress?

        if (NW_GP_BUSY(ppdev, pjMmBase))
        {
            ddRVal = DDERR_WASSTILLDRAWING;
        }
    }

    lpGetBltStatus->ddRVal = ddRVal;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdMapMemory
*
* This is a new DDI call specific to Windows NT that is used to map
* or unmap all the application modifiable portions of the frame buffer
* into the specified process's address space.
*
\**************************************************************************/

DWORD DdMapMemory(
PDD_MAPMEMORYDATA lpMapMemory)
{
    PDEV*                           ppdev;
    VIDEO_SHARE_MEMORY              ShareMemory;
    VIDEO_SHARE_MEMORY_INFORMATION  ShareMemoryInformation;
    DWORD                           ReturnedDataLength;

    ppdev = (PDEV*) lpMapMemory->lpDD->dhpdev;

    if (lpMapMemory->bMap)
    {
        ShareMemory.ProcessHandle = lpMapMemory->hProcess;

        // 'RequestedVirtualAddress' isn't actually used for the SHARE IOCTL:

        ShareMemory.RequestedVirtualAddress = 0;

        // We map in starting at the top of the frame buffer:

        ShareMemory.ViewOffset = 0;

        // We map down to the end of the frame buffer.
        //
        // Note: There is a 64k granularity on the mapping (meaning that
        //       we have to round up to 64k).
        //
        // Note: If there is any portion of the frame buffer that must
        //       not be modified by an application, that portion of memory
        //       MUST NOT be mapped in by this call.  This would include
        //       any data that, if modified by a malicious application,
        //       would cause the driver to crash.  This could include, for
        //       example, any DSP code that is kept in off-screen memory.

        ShareMemory.ViewSize
            = ROUND_UP_TO_64K(ppdev->cyMemory * ppdev->lDelta);

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SHARE_VIDEO_MEMORY,
                               &ShareMemory,
                               sizeof(VIDEO_SHARE_MEMORY),
                               &ShareMemoryInformation,
                               sizeof(VIDEO_SHARE_MEMORY_INFORMATION),
                               &ReturnedDataLength))
        {
            DISPDBG((0, "Failed IOCTL_VIDEO_SHARE_MEMORY"));

            lpMapMemory->ddRVal = DDERR_GENERIC;
            return(DDHAL_DRIVER_HANDLED);
        }

        lpMapMemory->fpProcess = (FLATPTR)ShareMemoryInformation.VirtualAddress;
    }
    else
    {
        ShareMemory.ProcessHandle           = lpMapMemory->hProcess;
        ShareMemory.ViewOffset              = 0;
        ShareMemory.ViewSize                = 0;
        ShareMemory.RequestedVirtualAddress = (VOID*) lpMapMemory->fpProcess;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY,
                               &ShareMemory,
                               sizeof(VIDEO_SHARE_MEMORY),
                               NULL,
                               0,
                               &ReturnedDataLength))
        {
            RIP("Failed IOCTL_VIDEO_UNSHARE_MEMORY");
        }
    }

    lpMapMemory->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdGetFlipStatus
*
* If the display has gone through one refresh cycle since the flip
* occurred, we return DD_OK.  If it has not gone through one refresh
* cycle we return DDERR_WASSTILLDRAWING to indicate that this surface
* is still busy "drawing" the flipped page.   We also return
* DDERR_WASSTILLDRAWING if the bltter is busy and the caller wanted
* to know if they could flip yet.
*
\**************************************************************************/

DWORD DdGetFlipStatus(
PDD_GETFLIPSTATUSDATA lpGetFlipStatus)
{
    PDEV*   ppdev;
    BYTE*   pjMmBase;

    ppdev    = (PDEV*) lpGetFlipStatus->lpDD->dhpdev;
    pjMmBase = ppdev->pjMmBase;

    // We don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status and ignore the vmem:

    lpGetFlipStatus->ddRVal = ddrvalUpdateFlipStatus(ppdev, (FLATPTR) -1);

    // Check if the bltter is busy if someone wants to know if they can
    // flip:

    if (lpGetFlipStatus->dwFlags == DDGFS_CANFLIP)
    {
        if ((lpGetFlipStatus->ddRVal == DD_OK) && (NW_GP_BUSY(ppdev, pjMmBase)))
        {
            lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
        }
    }

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdWaitForVerticalBlank
*
\**************************************************************************/

DWORD DdWaitForVerticalBlank(
PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank)
{
    PDEV*   ppdev;
    BYTE*   pjIoBase;

    ppdev    = (PDEV*) lpWaitForVerticalBlank->lpDD->dhpdev;
    pjIoBase = ppdev->pjIoBase;

    switch (lpWaitForVerticalBlank->dwFlags)
    {
    case DDWAITVB_I_TESTVB:

        // If TESTVB, it's just a request for the current vertical blank
        // status:

        if (VBLANK_IS_ACTIVE(pjIoBase))
            lpWaitForVerticalBlank->bIsInVB = TRUE;
        else
            lpWaitForVerticalBlank->bIsInVB = FALSE;

        lpWaitForVerticalBlank->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKBEGIN:

        // If BLOCKBEGIN is requested, we wait until the vertical blank
        // is over, and then wait for the display period to end:

        while (VBLANK_IS_ACTIVE(pjIoBase))
            ;
        while (!(VBLANK_IS_ACTIVE(pjIoBase)))
            ;

        lpWaitForVerticalBlank->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);

    case DDWAITVB_BLOCKEND:

        // If BLOCKEND is requested, we wait for the vblank interval to end:

        while (!(VBLANK_IS_ACTIVE(pjIoBase)))
            ;
        while (VBLANK_IS_ACTIVE(pjIoBase))
            ;

        lpWaitForVerticalBlank->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdCanCreateSurface
*
\**************************************************************************/

DWORD DdCanCreateSurface(
PDD_CANCREATESURFACEDATA lpCanCreateSurface)
{
    PDEV*           ppdev;
    DWORD           dwRet;
    LPDDSURFACEDESC lpSurfaceDesc;

    ppdev = (PDEV*) lpCanCreateSurface->lpDD->dhpdev;
    lpSurfaceDesc = lpCanCreateSurface->lpDDSurfaceDesc;

    dwRet = DDHAL_DRIVER_NOTHANDLED;

    if (!lpCanCreateSurface->bIsDifferentPixelFormat)
    {
        // It's trivially easy to create plain surfaces that are the same
        // type as the primary surface:

        dwRet = DDHAL_DRIVER_HANDLED;
    }

    // If the streams processor is capable, we can handle overlays:

    else if (ppdev->flCaps & CAPS_STREAMS_CAPABLE)
    {
        // When using the Streams processor, we handle only overlays of
        // different pixel formats -- not any off-screen memory:

        if (lpSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
        {
            // We handle two types of YUV overlay surfaces:

            if (lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_FOURCC)
            {
                // Check first for a supported YUV type:

                if (lpSurfaceDesc->ddpfPixelFormat.dwFourCC == FOURCC_YUY2)
                {
                    lpSurfaceDesc->ddpfPixelFormat.dwYUVBitCount = 16;
                    dwRet = DDHAL_DRIVER_HANDLED;
                }
            }

            // We handle 16bpp and 32bpp RGB overlay surfaces:

            else if ((lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_RGB) &&
                    !(lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8))
            {
                if (lpSurfaceDesc->ddpfPixelFormat.dwRGBBitCount == 16)
                {
                    if (IS_RGB15(&lpSurfaceDesc->ddpfPixelFormat) ||
                        IS_RGB16(&lpSurfaceDesc->ddpfPixelFormat))
                    {
                        dwRet = DDHAL_DRIVER_HANDLED;
                    }
                }

                // We don't handle 24bpp overlay surfaces because they are
                // undocumented and don't seem to work on the Trio64V+.
                //
                // We don't handle 32bpp overlay surfaces because our streams
                // minimum-stretch-ratio tables were obviously created for
                // 16bpp overlay surfaces; 32bpp overlay surfaces create a lot
                // of noise when close to the minimum stretch ratio.
            }
        }
    }

    // If the pixel formatter is enabled, we can handle funky format off-
    // screen surfaces, but not at 8bpp because of palette issues:

    else if ((ppdev->flCaps & CAPS_PIXEL_FORMATTER) &&
             (ppdev->iBitmapFormat > BMF_8BPP))
    {
        if (lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_FOURCC)
        {
            if (lpSurfaceDesc->ddpfPixelFormat.dwFourCC == FOURCC_YUY2)
            {
                lpSurfaceDesc->ddpfPixelFormat.dwYUVBitCount = 16;
                dwRet = DDHAL_DRIVER_HANDLED;
            }
        }

        // We handle 16bpp and 32bpp RGB off-screen surfaces:

        else if ((lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_RGB) &&
                !(lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8))
        {
            if (lpSurfaceDesc->ddpfPixelFormat.dwRGBBitCount == 16)
            {
                if (IS_RGB15(&lpSurfaceDesc->ddpfPixelFormat) ||
                    IS_RGB16(&lpSurfaceDesc->ddpfPixelFormat))
                {
                    dwRet = DDHAL_DRIVER_HANDLED;
                }
            }
            else if (lpSurfaceDesc->ddpfPixelFormat.dwRGBBitCount == 32)
            {
                if (IS_RGB32(&lpSurfaceDesc->ddpfPixelFormat))
                {
                    dwRet = DDHAL_DRIVER_HANDLED;
                }
            }
        }
    }

    // Print some spew if this was a surface we refused to create:

    if (dwRet == DDHAL_DRIVER_NOTHANDLED)
    {
        if (lpSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_RGB)
        {
            DISPDBG((0, "Failed creation of %libpp RGB surface %lx %lx %lx",
                lpSurfaceDesc->ddpfPixelFormat.dwRGBBitCount,
                lpSurfaceDesc->ddpfPixelFormat.dwRBitMask,
                lpSurfaceDesc->ddpfPixelFormat.dwGBitMask,
                lpSurfaceDesc->ddpfPixelFormat.dwBBitMask));
        }
        else
        {
            DISPDBG((0, "Failed creation of type 0x%lx YUV 0x%lx surface",
                lpSurfaceDesc->ddpfPixelFormat.dwFlags,
                lpSurfaceDesc->ddpfPixelFormat.dwFourCC));
        }
    }

    lpCanCreateSurface->ddRVal = DD_OK;
    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DdCreateSurface
*
\**************************************************************************/

DWORD DdCreateSurface(
PDD_CREATESURFACEDATA lpCreateSurface)
{
    PDEV*               ppdev;
    DD_SURFACE_LOCAL*   lpSurfaceLocal;
    DD_SURFACE_GLOBAL*  lpSurfaceGlobal;
    LPDDSURFACEDESC     lpSurfaceDesc;
    DWORD               dwByteCount;
    LONG                lLinearPitch;
    DWORD               dwHeight;

    ppdev = (PDEV*) lpCreateSurface->lpDD->dhpdev;

    // On Windows NT, dwSCnt will always be 1, so there will only ever
    // be one entry in the 'lplpSList' array:

    lpSurfaceLocal  = lpCreateSurface->lplpSList[0];
    lpSurfaceGlobal = lpSurfaceLocal->lpGbl;
    lpSurfaceDesc   = lpCreateSurface->lpDDSurfaceDesc;

    // We repeat the same checks we did in 'DdCanCreateSurface' because
    // it's possible that an application doesn't call 'DdCanCreateSurface'
    // before calling 'DdCreateSurface'.

    ASSERTDD(lpSurfaceGlobal->ddpfSurface.dwSize == sizeof(DDPIXELFORMAT),
        "NT is supposed to guarantee that ddpfSurface.dwSize is valid");

    // DdCanCreateSurface already validated whether the hardware supports
    // the surface, so we don't need to do any validation here.  We'll
    // just go ahead and allocate it.
    //
    // Note that we don't do anything special for RGB surfaces that are
    // the same pixel format as the display -- by returning DDHAL_DRIVER_
    // NOTHANDLED, DirectDraw will automatically handle the allocation
    // for us.
    //
    // Also, since we'll be making linear surfaces, make sure the width
    // isn't unreasonably large.
    //
    // Note that on NT, an overlay can be created only if the driver
    // okay's it here in this routine.  Under Win95, the overlay will be
    // created automatically if it's the same pixel format as the primary
    // display.

    if ((lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY)   ||
        (lpSurfaceGlobal->ddpfSurface.dwFlags & DDPF_FOURCC) ||
        (lpSurfaceGlobal->ddpfSurface.dwYUVBitCount
            != (DWORD) 8 * ppdev->cjPelSize)                 ||
        (lpSurfaceGlobal->ddpfSurface.dwRBitMask != ppdev->flRed))
    {
        if (lpSurfaceGlobal->wWidth <= (DWORD) ppdev->cxMemory)
        {
            // The S3 cannot easily draw to YUV surfaces or surfaces that are
            // a different RGB format than the display.  So we'll make them
            // linear surfaces to save some space:

            if (lpSurfaceGlobal->ddpfSurface.dwFlags & DDPF_FOURCC)
            {
                ASSERTDD((lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_YUY2),
                        "Expected our DdCanCreateSurface to allow only YUY2 or Y211");

                dwByteCount = (lpSurfaceGlobal->ddpfSurface.dwFourCC == FOURCC_YUY2)
                    ? 2 : 1;

                // We have to fill in the bit-count for FourCC surfaces:

                lpSurfaceGlobal->ddpfSurface.dwYUVBitCount = 8 * dwByteCount;

                DISPDBG((0, "Created YUV: %li x %li",
                    lpSurfaceGlobal->wWidth, lpSurfaceGlobal->wHeight));
            }
            else
            {
                dwByteCount = lpSurfaceGlobal->ddpfSurface.dwRGBBitCount >> 3;

                DISPDBG((0, "Created RGB %libpp: %li x %li Red: %lx",
                    8 * dwByteCount, lpSurfaceGlobal->wWidth, lpSurfaceGlobal->wHeight,
                    lpSurfaceGlobal->ddpfSurface.dwRBitMask));

                // The S3 can't handle palettized or 32bpp overlays.  Note that
                // we sometimes don't get a chance to say no to these surfaces
                // in CanCreateSurface, because DirectDraw won't call
                // CanCreateSurface if the surface to be created is the same
                // pixel format as the primary display:

                if ((dwByteCount != 2) &&
                    (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_OVERLAY))
                {
                    lpCreateSurface->ddRVal = DDERR_INVALIDPIXELFORMAT;
                    return(DDHAL_DRIVER_HANDLED);
                }
            }

            // We want to allocate a linear surface to store the FourCC
            // surface, but DirectDraw is using a 2-D heap-manager because
            // the rest of our surfaces have to be 2-D.  So here we have to
            // convert the linear size to a 2-D size.
            //
            // The stride has to be a dword multiple:

            lLinearPitch = (lpSurfaceGlobal->wWidth * dwByteCount + 3) & ~3;
            dwHeight = (lpSurfaceGlobal->wHeight * lLinearPitch
                     + ppdev->lDelta - 1) / ppdev->lDelta;

            // Now fill in enough stuff to have the DirectDraw heap-manager
            // do the allocation for us:

            lpSurfaceGlobal->fpVidMem     = DDHAL_PLEASEALLOC_BLOCKSIZE;
            lpSurfaceGlobal->dwBlockSizeX = ppdev->lDelta; // Specified in bytes
            lpSurfaceGlobal->dwBlockSizeY = dwHeight;
            lpSurfaceGlobal->lPitch       = lLinearPitch;
            lpSurfaceGlobal->dwReserved1  = DD_RESERVED_DIFFERENTPIXELFORMAT;

            lpSurfaceDesc->lPitch   = lLinearPitch;
            lpSurfaceDesc->dwFlags |= DDSD_PITCH;
        }
        else
        {
            DISPDBG((0, "Refused to create surface with large width"));
        }
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdFreeDriverMemory
*
* This function called by DirectDraw when it's running low on memory in
* our heap.  You only need to implement this function if you use the
* DirectDraw 'HeapVidMemAllocAligned' function in your driver, and you
* can boot those allocations out of memory to make room for DirectDraw.
*
* We implement this function in the S3 driver because we have DirectDraw
* entirely manage our off-screen heap, and we use HeapVidMemAllocAligned
* to put GDI device-bitmaps in off-screen memory.  DirectDraw applications
* have a higher priority for getting stuff into video memory, though, and
* so this function is used to boot those GDI surfaces out of memory in 
* order to make room for DirectDraw.
*
\**************************************************************************/

DWORD DdFreeDriverMemory(
PDD_FREEDRIVERMEMORYDATA lpFreeDriverMemory)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) lpFreeDriverMemory->lpDD->dhpdev;

    lpFreeDriverMemory->ddRVal = DDERR_OUTOFMEMORY;

    // If we successfully freed up some memory, set the return value to
    // 'DD_OK'.  DirectDraw will try again to do its allocation, and
    // will call us again if there's still not enough room.  (It will
    // call us until either there's enough room for its alocation to
    // succeed, or until we return something other than DD_OK.)

    if (bMoveOldestOffscreenDfbToDib(ppdev))
    {
        lpFreeDriverMemory->ddRVal = DD_OK;
    }

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdSetColorKey
*
\**************************************************************************/

DWORD DdSetColorKey(
PDD_SETCOLORKEYDATA lpSetColorKey)
{
    PDEV*               ppdev;
    BYTE*               pjIoBase;
    BYTE*               pjMmBase;
    DD_SURFACE_GLOBAL*  lpSurface;
    DWORD               dwKeyLow;
    DWORD               dwKeyHigh;

    ppdev = (PDEV*) lpSetColorKey->lpDD->dhpdev;

    ASSERTDD(ppdev->flCaps & CAPS_STREAMS_CAPABLE, "Shouldn't have hooked call");

    pjIoBase  = ppdev->pjIoBase;
    pjMmBase  = ppdev->pjMmBase;
    lpSurface = lpSetColorKey->lpDDSurface->lpGbl;

    // We don't have to do anything for normal blt source colour keys:

    if (lpSetColorKey->dwFlags & DDCKEY_SRCBLT)
    {
        lpSetColorKey->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }
    else if (lpSetColorKey->dwFlags & DDCKEY_DESTOVERLAY)
    {
        dwKeyLow = lpSetColorKey->ckNew.dwColorSpaceLowValue;

        if (lpSurface->ddpfSurface.dwFlags & DDPF_PALETTEINDEXED8)
        {
            dwKeyLow = dwGetPaletteEntry(ppdev, dwKeyLow);
        }
        else
        {
            ASSERTDD(lpSurface->ddpfSurface.dwFlags & DDPF_RGB,
                "Expected only RGB cases here");

            // We have to transform the colour key from its native format
            // to 8-8-8:

            if (lpSurface->ddpfSurface.dwRGBBitCount == 16)
            {
                if (IS_RGB15_R(lpSurface->ddpfSurface.dwRBitMask))
                    dwKeyLow = RGB15to32(dwKeyLow);
                else
                    dwKeyLow = RGB16to32(dwKeyLow);
            }
            else
            {
                ASSERTDD((lpSurface->ddpfSurface.dwRGBBitCount == 32),
                    "Expected the primary surface to be either 8, 16, or 32bpp");
            }
        }

        dwKeyHigh = dwKeyLow;
        dwKeyLow |= CompareBits0t7 | KeyFromCompare;

        // Check for stream processor enabled before setting registers
        if(ppdev->flStatus & STAT_STREAMS_ENABLED)
        {
            WAIT_FOR_VBLANK(pjIoBase);
        
            WRITE_STREAM_D(pjMmBase, CKEY_LOW, dwKeyLow);
            WRITE_STREAM_D(pjMmBase, CKEY_HI,  dwKeyHigh);
        }
        else
        {
            // Save away the color key to be set when streams
            // processor is turned on.
            ppdev->ulColorKey = dwKeyHigh;
        }
             
        lpSetColorKey->ddRVal = DD_OK;
        
        return(DDHAL_DRIVER_HANDLED);
    }

    DISPDBG((0, "DdSetColorKey: Invalid command"));
    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdUpdateOverlay
*
\**************************************************************************/

DWORD DdUpdateOverlay(
PDD_UPDATEOVERLAYDATA lpUpdateOverlay)
{
    PDEV*               ppdev;
    BYTE*               pjIoBase;
    BYTE*               pjMmBase;
    DD_SURFACE_GLOBAL*  lpSource;
    DD_SURFACE_GLOBAL*  lpDestination;
    DWORD               dwStride;
    LONG                srcWidth;
    LONG                srcHeight;
    LONG                dstWidth;
    LONG                dstHeight;
    DWORD               dwBitCount;
    DWORD               dwStart;
    DWORD               dwTmp;
    BOOL                bColorKey;
    DWORD               dwKeyLow;
    DWORD               dwKeyHigh;
    DWORD               dwBytesPerPixel;

    DWORD               dwSecCtrl;
    DWORD               dwBlendCtrl;

    ppdev = (PDEV*) lpUpdateOverlay->lpDD->dhpdev;

    ASSERTDD(ppdev->flCaps & CAPS_STREAMS_CAPABLE, "Shouldn't have hooked call");

    pjIoBase = ppdev->pjIoBase;
    pjMmBase = ppdev->pjMmBase;

    // 'Source' is the overlay surface, 'destination' is the surface to
    // be overlayed:

    lpSource = lpUpdateOverlay->lpDDSrcSurface->lpGbl;

    if (lpUpdateOverlay->dwFlags & DDOVER_HIDE)
    {
        if (lpSource->fpVidMem == ppdev->fpVisibleOverlay)
        {
            WAIT_FOR_VBLANK(pjIoBase);

            WRITE_STREAM_D(pjMmBase, BLEND_CONTROL, POnS);
            WRITE_STREAM_D(pjMmBase, S_WH, WH(10, 2));  // Set to 10x2 rectangle
            WRITE_STREAM_D(pjMmBase, OPAQUE_CONTROL, 0);// Disable opaque control

            ppdev->fpVisibleOverlay = 0;

            ASSERTDD(ppdev->flStatus & STAT_STREAMS_ENABLED,
                "Expected streams to be enabled");

            ppdev->flStatus &= ~STAT_STREAMS_ENABLED;
            vTurnOffStreamsProcessorMode(ppdev);
        }

        lpUpdateOverlay->ddRVal = DD_OK;
        return(DDHAL_DRIVER_HANDLED);
    }

    // Dereference 'lpDDDestSurface' only after checking for the DDOVER_HIDE
    // case:

    lpDestination = lpUpdateOverlay->lpDDDestSurface->lpGbl;

    if (lpSource->fpVidMem != ppdev->fpVisibleOverlay)
    {
        if (lpUpdateOverlay->dwFlags & DDOVER_SHOW)
        {
            if (ppdev->fpVisibleOverlay != 0)
            {
                // Some other overlay is already visible:

                DISPDBG((0, "DdUpdateOverlay: An overlay is already visible"));

                lpUpdateOverlay->ddRVal = DDERR_OUTOFCAPS;
                return(DDHAL_DRIVER_HANDLED);
            }
            else
            {
                // We're going to make the overlay visible, so mark it as
                // such:

                ppdev->fpVisibleOverlay = lpSource->fpVidMem;
            }
        }
        else
        {
            // The overlay isn't visible, and we haven't been asked to make
            // it visible, so this call is trivially easy:

            lpUpdateOverlay->ddRVal = DD_OK;
            return(DDHAL_DRIVER_HANDLED);
        }
    }

    if (!(ppdev->flStatus & STAT_STREAMS_ENABLED))
    {
        ppdev->flStatus |= STAT_STREAMS_ENABLED;
        vTurnOnStreamsProcessorMode(ppdev);
    }

    dwStride =  lpSource->lPitch;
    srcWidth =  lpUpdateOverlay->rSrc.right   - lpUpdateOverlay->rSrc.left;
    srcHeight = lpUpdateOverlay->rSrc.bottom  - lpUpdateOverlay->rSrc.top;
    dstWidth =  lpUpdateOverlay->rDest.right  - lpUpdateOverlay->rDest.left;
    dstHeight = lpUpdateOverlay->rDest.bottom - lpUpdateOverlay->rDest.top;

    // Calculate DDA horizonal accumulator initial value:

    dwSecCtrl = HDDA(srcWidth, dstWidth);

    // Overlay input data format:

    if (lpSource->ddpfSurface.dwFlags & DDPF_FOURCC)
    {
        dwBitCount = lpSource->ddpfSurface.dwYUVBitCount;

        switch (lpSource->ddpfSurface.dwFourCC)
        {
        case FOURCC_YUY2:
            dwSecCtrl |= S_YCrCb422;    // Not S_YUV422!  Dunno why...
            break;

        default:
            RIP("Unexpected FourCC");
        }
    }
    else
    {
        ASSERTDD(lpSource->ddpfSurface.dwFlags & DDPF_RGB,
            "Expected us to have created only RGB or YUV overlays");

        // The overlay surface is in RGB format:

        dwBitCount = lpSource->ddpfSurface.dwRGBBitCount;

        ASSERTDD(dwBitCount == 16,
            "Expected us to have created 16bpp RGB surfaces only");

        if (IS_RGB15_R(lpSource->ddpfSurface.dwRBitMask))
            dwSecCtrl |= S_RGB15;
        else
            dwSecCtrl |= S_RGB16;
    }

    // Calculate start of video memory in QWORD boundary

    dwBytesPerPixel = dwBitCount >> 3;

    dwStart = (lpUpdateOverlay->rSrc.top * dwStride)
            + (lpUpdateOverlay->rSrc.left * dwBytesPerPixel);

    // Note that since we're shifting the source's edge to the left, we
    // should really increase the source width to compensate.  However,
    // doing so when running at 1 to 1 would cause us to request a
    // shrinking overlay -- something the S3 can't do.

    dwStart = dwStart - (dwStart & 0x7);

    ppdev->dwOverlayFlipOffset = dwStart;     // Save for flip
    dwStart += (DWORD)lpSource->fpVidMem;

    // Set overlay filter characteristics:

    if ((dstWidth != srcWidth) || (dstHeight != srcHeight))
    {
        if (dstWidth >= (srcWidth << 2))
        {
            dwSecCtrl |= S_Beyond4x;    // Linear, 1-2-2-2-1, for >4X stretch
        }
        else if (dstWidth >= (srcWidth << 1))
        {
            dwSecCtrl |= S_2xTo4x;      // Bi-linear, for 2X to 4X stretch
        }
        else
        {
            dwSecCtrl |= S_Upto2x;      // Linear, 0-2-4-2-0, for X stretch
        }
    }

    // Extract colour key:

    bColorKey   = FALSE;
    dwBlendCtrl = 0;

    if (lpUpdateOverlay->dwFlags & DDOVER_KEYDEST)
    {
        bColorKey = TRUE;
        dwKeyLow  = lpUpdateOverlay->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue;
        dwBlendCtrl |= KeyOnP;
    }
    else if (lpUpdateOverlay->dwFlags & DDOVER_KEYDESTOVERRIDE)
    {
        bColorKey = TRUE;
        dwKeyLow  = lpUpdateOverlay->overlayFX.dckDestColorkey.dwColorSpaceLowValue;
        dwBlendCtrl |= KeyOnP;
    }

    if (bColorKey)
    {
        // We support only destination colour keys:

        if (lpDestination->ddpfSurface.dwFlags & DDPF_PALETTEINDEXED8)
        {
            dwKeyLow = dwGetPaletteEntry(ppdev, dwKeyLow);
        }
        else if (lpDestination->ddpfSurface.dwFlags & DDPF_RGB)
        {
            ASSERTDD(lpDestination->ddpfSurface.dwFlags & DDPF_RGB,
                "Expected only RGB cases here");

            // We have to transform the colour key from its native format
            // to 8-8-8:

            if (lpDestination->ddpfSurface.dwRGBBitCount == 16)
            {
                if (IS_RGB15_R(lpDestination->ddpfSurface.dwRBitMask))
                    dwKeyLow = RGB15to32(dwKeyLow);
                else
                    dwKeyLow = RGB16to32(dwKeyLow);
            }
            else
            {
                ASSERTDD((lpDestination->ddpfSurface.dwRGBBitCount == 32),
                    "Expected the primary surface to be either 8, 16, or 32bpp");
            }
        }

        dwKeyHigh = dwKeyLow;
        dwKeyLow |= CompareBits0t7 | KeyFromCompare;
    }

    // Update and show:

    NW_GP_WAIT(ppdev, pjMmBase);

    WAIT_FOR_VBLANK(pjIoBase);

    WRITE_STREAM_D(pjMmBase, S_0,           dwStart);
    WRITE_STREAM_D(pjMmBase, S_XY,          XY(lpUpdateOverlay->rDest.left,
                                               lpUpdateOverlay->rDest.top));
    WRITE_STREAM_D(pjMmBase, S_WH,          WH(dstWidth, dstHeight));
    WRITE_STREAM_D(pjMmBase, S_STRIDE,      dwStride);
    WRITE_STREAM_D(pjMmBase, S_CONTROL,     dwSecCtrl);
    WRITE_STREAM_D(pjMmBase, S_HK1K2,       HK1K2(srcWidth, dstWidth));
    WRITE_STREAM_D(pjMmBase, S_VK1,         VK1(srcHeight));
    WRITE_STREAM_D(pjMmBase, S_VK2,         VK2(srcHeight, dstHeight));
    WRITE_STREAM_D(pjMmBase, S_VDDA,        VDDA(dstHeight));

    if (bColorKey)
    {
        WRITE_STREAM_D(pjMmBase, CKEY_LOW,  dwKeyLow);
        WRITE_STREAM_D(pjMmBase, CKEY_HI,   dwKeyHigh);
    }

    WRITE_STREAM_D(pjMmBase, BLEND_CONTROL, dwBlendCtrl);
    WRITE_STREAM_D(pjMmBase, FIFO_CONTROL,  ppdev->ulFifoValue);

    lpUpdateOverlay->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdSetOverlayPosition
*
\**************************************************************************/

DWORD DdSetOverlayPosition(
PDD_SETOVERLAYPOSITIONDATA lpSetOverlayPosition)
{
    PDEV*   ppdev;
    BYTE*   pjIoBase;
    BYTE*   pjMmBase;

    ppdev = (PDEV*) lpSetOverlayPosition->lpDD->dhpdev;
    pjIoBase = ppdev->pjIoBase;
    pjMmBase = ppdev->pjMmBase;

    ASSERTDD(ppdev->flCaps & CAPS_STREAMS_CAPABLE, "Shouldn't have hooked call");

    // Check that streams processor is enabled before settting registers
    if(ppdev->flStatus & STAT_STREAMS_ENABLED)
    {
       WAIT_FOR_VBLANK(pjIoBase);

       WRITE_STREAM_D(pjMmBase, S_XY, XY(lpSetOverlayPosition->lXPos,
                                         lpSetOverlayPosition->lYPos));
    }

    lpSetOverlayPosition->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdGetDriverInfo
*
* This function is an extensible method for returning DirectDraw 
* capabilities and methods.
*
\**************************************************************************/

DWORD DdGetDriverInfo(
PDD_GETDRIVERINFODATA lpGetDriverInfo)
{
    DWORD dwSize;

    lpGetDriverInfo->ddRVal = DDERR_CURRENTLYNOTAVAIL;

    if (IsEqualIID(&lpGetDriverInfo->guidInfo, &GUID_NTCallbacks))
    {
        DD_NTCALLBACKS NtCallbacks;

        memset(&NtCallbacks, 0, sizeof(NtCallbacks));

        dwSize = min(lpGetDriverInfo->dwExpectedSize, sizeof(DD_NTCALLBACKS));

        NtCallbacks.dwSize           = dwSize;
        NtCallbacks.dwFlags          = DDHAL_NTCB32_FREEDRIVERMEMORY;
        NtCallbacks.FreeDriverMemory = DdFreeDriverMemory;

        memcpy(lpGetDriverInfo->lpvData, &NtCallbacks, dwSize);

        lpGetDriverInfo->ddRVal = DD_OK;
    }

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* VOID vAssertModeDirectDraw
*
* This function is called by enable.c when entering or leaving the
* DOS full-screen character mode.
*
\**************************************************************************/

VOID vAssertModeDirectDraw(
PDEV*   ppdev,
BOOL    bEnable)
{
}

/******************************Public*Routine******************************\
* BOOL bEnableDirectDraw
*
* This function is called by enable.c when the mode is first initialized,
* right after the miniport does the mode-set.
*
\**************************************************************************/

BOOL bEnableDirectDraw(
PDEV*   ppdev)
{
    BYTE*                           pjIoBase;
    VIDEO_QUERY_STREAMS_MODE        VideoQueryStreamsMode;
    VIDEO_QUERY_STREAMS_PARAMETERS  VideoQueryStreamsParameters;
    DWORD                           ReturnedDataLength;
    BOOL                            bDDrawEnabled=TRUE;

    // We're not going to bother to support accelerated DirectDraw on
    // those S3s that can't support memory-mapped I/O, simply because
    // they're old cards and it's not worth the effort.  We also
    // require DIRECT_ACCESS to the frame buffer.
    //
    // We also don't support 864/964 cards because writing to the frame
    // buffer can hang the entire system if an accelerated operation is
    // going on at the same time.
    //
    // The 765 (Trio64V+) has a bug such that writing to the frame
    // buffer during an accelerator operation may cause a hang if
    // you do the write soon enough after starting the blt.  (There is
    // a small window of opportunity.)  On UP machines, the context
    // switch time seems to be enough to avoid the problem.  However,
    // on MP machines, we'll have to disable direct draw.
    //
    // NOTE: We can identify the 765 since it is the only chip with
    //       the CAPS_STREAMS_CAPABLE flag.

    if (ppdev->flCaps & CAPS_STREAMS_CAPABLE) 
    {
        DWORD numProcessors;

        if (EngQuerySystemAttribute(EngNumberOfProcessors, &numProcessors)) 
        {
            if (numProcessors != 1) 
            {
                DISPDBG((1, "Disabling DDraw for MP 765 box.\n"));
                bDDrawEnabled = FALSE;
            }

        } 
        else 
        {
            DISPDBG((1, "Can't determine number of processors, so play it "
                        "safe and disable DDraw for 765.\n"));

            bDDrawEnabled = FALSE;
        }
    }

    // The stretch and YUV bltter capabilities of the S3 868 and 968 were 
    // disabled to account for bug 135541. 

    ppdev->flCaps &= ~CAPS_PIXEL_FORMATTER;

    if ((ppdev->flCaps & CAPS_NEW_MMIO) &&
        !(ppdev->flCaps & CAPS_NO_DIRECT_ACCESS) &&
        (bDDrawEnabled))
    {
        pjIoBase = ppdev->pjIoBase;

        // We have to preserve the contents of register 0x69 on the S3's page
        // flip:

        ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

        OUTP(pjIoBase, CRTC_INDEX, 0x69);
        ppdev->ulExtendedSystemControl3Register_69
            = (INP(pjIoBase, CRTC_DATA) & 0xe0) << 8;

        RELEASE_CRTC_CRITICAL_SECTION(ppdev);

        // Accurately measure the refresh rate for later:

        vGetDisplayDuration(ppdev);

        if (ppdev->flCaps & CAPS_STREAMS_CAPABLE)
        {
            // Query the miniport to get the correct streams parameters
            // for this mode:

            VideoQueryStreamsMode.ScreenWidth = ppdev->cxScreen;
            VideoQueryStreamsMode.BitsPerPel  = ppdev->cBitsPerPel;
            VideoQueryStreamsMode.RefreshRate = ppdev->ulRefreshRate;

            if (EngDeviceIoControl(ppdev->hDriver,
                                   IOCTL_VIDEO_S3_QUERY_STREAMS_PARAMETERS,
                                   &VideoQueryStreamsMode,
                                   sizeof(VideoQueryStreamsMode),
                                   &VideoQueryStreamsParameters,
                                   sizeof(VideoQueryStreamsParameters),
                                   &ReturnedDataLength))
            {
                DISPDBG((0, "Miniport reported no streams parameters"));

                ppdev->flCaps &= ~CAPS_STREAMS_CAPABLE;
            }
            else
            {
                ppdev->ulMinOverlayStretch
                    = VideoQueryStreamsParameters.MinOverlayStretch;
                ppdev->ulFifoValue
                    = VideoQueryStreamsParameters.FifoValue;

                DISPDBG((0, "Refresh rate: %li Minimum overlay stretch: %li.%03li Fifo value: %lx",
                    ppdev->ulRefreshRate,
                    ppdev->ulMinOverlayStretch / 1000,
                    ppdev->ulMinOverlayStretch % 1000,
                    ppdev->ulFifoValue));
            }
        }
        else if (ppdev->flCaps & CAPS_PIXEL_FORMATTER)
        {
            // The pixel formatter doesn't work at 24bpp:

            if (ppdev->iBitmapFormat != BMF_24BPP)
            {
                // We'll need a pixel-high scratch area to work around a
                // hardware bug for thin stretches:

                ppdev->pdsurfVideoEngineScratch = pVidMemAllocate(ppdev,
                                                                  ppdev->cxMemory,
                                                                  1);
                if (ppdev->pdsurfVideoEngineScratch)
                {
                    if (ppdev->cyMemory * ppdev->lDelta <= 0x100000)
                        ppdev->dwVEstep = 0x00040004;   // If 1MB, 4 bytes/write
                    else
                        ppdev->dwVEstep = 0x00080008;   // If 2MB, 8 bytes/write

                    ppdev->flCaps |= CAPS_PIXEL_FORMATTER;
                }
            }
        }
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableDirectDraw
*
* This function is called by enable.c when the driver is shutting down.
*
\**************************************************************************/

VOID vDisableDirectDraw(
PDEV*   ppdev)
{
    if (ppdev->pdsurfVideoEngineScratch)
    {
        vVidMemFree(ppdev->pdsurfVideoEngineScratch);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\debug.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: debug.c
*
* Debug helper routines.
*
* Copyright (c) 1992-1998 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

#if DBG

////////////////////////////////////////////////////////////////////////////
// DEBUGGING INITIALIZATION CODE
//
// When you're bringing up your display for the first time, you can
// recompile with 'DebugLevel' set to 100.  That will cause absolutely
// all DISPDBG messages to be displayed on the kernel debugger (this
// is known as the "PrintF Approach to Debugging" and is about the only
// viable method for debugging driver initialization code).

LONG DebugLevel = 0;            // Set to '100' to debug initialization code
                                //   (the default is '0')

////////////////////////////////////////////////////////////////////////////

LONG gcFifo = 0;                // Number of currently free FIFO entries

BOOL gbCrtcCriticalSection = FALSE;
                                // Have we acquired the CRTC register
                                //   critical section?

#define LARGE_LOOP_COUNT  10000000

////////////////////////////////////////////////////////////////////////////
// Miscellaneous Driver Debug Routines
////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    LONG  DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )
{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
        EngDebugPrint("", "\n", ap);
    }

    va_end(ap);

} // DebugPrint()

/******************************Public*Routine******************************\
* VOID vCheckDataComplete
\**************************************************************************/

VOID vCheckDataReady(
PDEV*   ppdev)
{
    ASSERTDD((IO_GP_STAT(ppdev) & HARDWARE_BUSY),
             "Not ready for data transfer.");
}

/******************************Public*Routine******************************\
* VOID vCheckDataComplete
\**************************************************************************/

VOID vCheckDataComplete(
PDEV*   ppdev)
{
    LONG i;

    // We loop because it may take a while for the hardware to finish
    // digesting all the data we transferred:

    for (i = LARGE_LOOP_COUNT; i > 0; i--)
    {
        if (!(IO_GP_STAT(ppdev) & HARDWARE_BUSY))
            return;
    }

    RIP("Data transfer not complete.");
}

/******************************Public*Routine******************************\
* VOID vOutFifoW
\**************************************************************************/

VOID vOutFifoW(
VOID*   p,
ULONG   v)
{
    gcFifo--;
    if (gcFifo < 0)
    {
        gcFifo = 0;
        RIP("Incorrect FIFO wait count");
    }

    WRITE_PORT_USHORT(p, (USHORT)v);
}

/******************************Public*Routine******************************\
* VOID vOutFifoPseudoD
\**************************************************************************/

VOID vOutFifoPseudoD(
PDEV*   ppdev,
VOID*   p,
ULONG   v)
{
    ULONG ulMiscState;

    ASSERTDD(!(ppdev->flCaps & CAPS_MM_IO),
        "No pseudo 32-bit writes when using memory-mapped I/O");
    ASSERTDD(ppdev->iBitmapFormat == BMF_32BPP,
        "We're trying to do 32bpp output while not in 32bpp mode");

    IO_GP_WAIT(ppdev);                  // Wait so we don't interfere with any
                                        //   pending commands waiting on the
                                        //   FIFO
    IO_READ_SEL(ppdev, 6);              // We'll be reading index 0xE
    IO_GP_WAIT(ppdev);                  // Wait until that's processed
    IO_RD_REG_DT(ppdev, ulMiscState);   // Read ulMiscState

    ASSERTDD((ulMiscState & 0x10) == 0,
            "Register select flag is out of sync");

    gcFifo -= 2;
    if (gcFifo < 0)
    {
        gcFifo = 0;
        RIP("Incorrect FIFO wait count");
    }

    OUT_PSEUDO_DWORD(p, v);
}

/******************************Public*Routine******************************\
* VOID vWriteFifoW
\**************************************************************************/

VOID vWriteFifoW(
VOID*   p,
ULONG   v)
{
    gcFifo--;
    if (gcFifo < 0)
    {
        gcFifo = 0;
        RIP("Incorrect FIFO wait count");
    }

    WRITE_REGISTER_USHORT(p, (USHORT) v);
}

/******************************Public*Routine******************************\
* VOID vWriteFifoD
\**************************************************************************/

VOID vWriteFifoD(
VOID*   p,
ULONG   v)
{
    gcFifo--;
    if (gcFifo < 0)
    {
        gcFifo = 0;
        RIP("Incorrect FIFO wait count");
    }

    WRITE_REGISTER_ULONG(p, v);
}

/******************************Public*Routine******************************\
* VOID vIoFifoWait
\**************************************************************************/

VOID vIoFifoWait(
PDEV*   ppdev,
LONG    level)
{
    LONG    i;

    ASSERTDD((level > 0) && (level <= 8), "Illegal wait level");

    gcFifo = level;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
        if (!(IO_FIFO_BUSY(ppdev, level)))
            return;
    }

    RIP("vIoFifoWait timeout -- The hardware is in a funky state.");
}

/******************************Public*Routine******************************\
* VOID vMmFifoWait
\**************************************************************************/

VOID vMmFifoWait(
PDEV*   ppdev,
BYTE*   pjMmBase,
LONG    level)
{
    LONG    i;

    // We only enabled MM I/O on the 864/964 and newer, so we can wait
    // for up to 13 FIFO slots:

    ASSERTDD((level > 0) && (level <= 13), "Illegal wait level");

    gcFifo = level;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
        if (!(MM_FIFO_BUSY(ppdev, pjMmBase, level)))
            return;
    }

    RIP("vMmFifoWait timeout -- The hardware is in a funky state.");
}

/******************************Public*Routine******************************\
* VOID vNwFifoWait
\**************************************************************************/

VOID vNwFifoWait(
PDEV*   ppdev,
BYTE*   pjMmBase,
LONG    level)
{
    LONG    i;

    ASSERTDD((level > 0) && (level <= 13), "Illegal wait level");

    gcFifo = level;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
        if (!(NW_FIFO_BUSY(ppdev, pjMmBase, level)))
            return;
    }

    RIP("vNwFifoWait timeout -- The hardware is in a funky state.");
}

/******************************Public*Routine******************************\
* VOID vDbgFakeWait
\**************************************************************************/

VOID vDbgFakeWait(
PDEV*   ppdev,
BYTE*   pjMmBase,
LONG    level)
{
    gcFifo = level;
}

/******************************Public*Routine******************************\
* VOID vIoGpWait
\**************************************************************************/

VOID vIoGpWait(
PDEV*   ppdev)
{
    LONG    i;

    gcFifo = (ppdev->flCaps & CAPS_16_ENTRY_FIFO) ? 16 : 8;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
        if (!(IO_GP_STAT(ppdev) & HARDWARE_BUSY))
            return;         // It isn't busy
    }

    RIP("vIoGpWait timeout -- The hardware is in a funky state.");
}

/******************************Public*Routine******************************\
* VOID vNwGpWait
\**************************************************************************/

VOID vNwGpWait(
PDEV*   ppdev,
BYTE*   pjMmBase)
{
    LONG    i;

    gcFifo = 16;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
        if (!NW_GP_BUSY(ppdev, pjMmBase))
            return;         // It isn't busy
    }

    RIP("vNwGpWait timeout -- The hardware is in a funky state.");
}

/******************************Public*Routine******************************\
* VOID vIoAllEmpty
\**************************************************************************/

VOID vIoAllEmpty(
PDEV*   ppdev)
{
    LONG    i;

    ASSERTDD(ppdev->flCaps & CAPS_16_ENTRY_FIFO,
             "Can't call ALL_EMPTY on chips with 8-deep FIFOs");

    gcFifo = 16;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
        if (IO_GP_STAT(ppdev) & GP_ALL_EMPTY)   // Not implemented on 911/924s
            return;
    }

    RIP("ALL_EMPTY timeout -- The hardware is in a funky state.");
}

/******************************Public*Routines*****************************\
* UCHAR  jInp()     - INP()
* USHORT wInpW()    - INPW()
* VOID   vOutp()    - OUTP()
* VOID   vOutpW()   - OUTPW()
*
* Debug thunks for general I/O routines.  This is used primarily to verify
* that any code accessing the CRTC register has grabbed the CRTC critical
* section (necessary because with GCAPS_ASYNCMOVE, DrvMovePointer calls
* may happen at any time, and they need to access the CRTC register).
*
\**************************************************************************/

UCHAR jInp(BYTE* pjIoBase, ULONG p)
{
    if (((p == CRTC_INDEX) || (p == CRTC_DATA)) &&
        (!gbCrtcCriticalSection))
    {
        RIP("Must have acquired CRTC critical section to access CRTC register");
    }

    CP_EIEIO();
    return((UCHAR) READ_PORT_UCHAR(pjIoBase + (p)));
}

USHORT wInpW(BYTE* pjIoBase, ULONG p)
{
    if (((p == CRTC_INDEX) || (p == CRTC_DATA)) &&
        (!gbCrtcCriticalSection))
    {
        RIP("Must have acquired CRTC critical section to access CRTC register");
    }

    CP_EIEIO();
    return(READ_PORT_USHORT(pjIoBase + (p)));
}

VOID vOutp(BYTE* pjIoBase, ULONG p, ULONG v)
{
    if (((p == CRTC_INDEX) || (p == CRTC_DATA)) &&
        (!gbCrtcCriticalSection))
    {
        RIP("Must have acquired CRTC critical section to access CRTC register");
    }

    CP_EIEIO();
    WRITE_PORT_UCHAR((PUCHAR)((ULONG_PTR)(pjIoBase + p)), (UCHAR)(v));
    CP_EIEIO();
}

VOID vOutpW(BYTE* pjIoBase, ULONG p, ULONG v)
{
    if (((p == CRTC_INDEX) || (p == CRTC_DATA)) &&
        (!gbCrtcCriticalSection))
    {
        RIP("Must have acquired CRTC critical section to access CRTC register");
    }

    CP_EIEIO();
    WRITE_PORT_USHORT(pjIoBase + (p), (USHORT)(v));
    CP_EIEIO();
}

/******************************Public*Routine******************************\
* VOID vAcquireCrtc()
* VOID vReleaseCrtc()
*
* Debug thunks for grabbing the CRTC register critical section.
*
\**************************************************************************/

VOID vAcquireCrtc(PDEV* ppdev)
{
    EngAcquireSemaphore(ppdev->csCrtc);

    if (gbCrtcCriticalSection)
        RIP("Had already acquired Critical Section");
    gbCrtcCriticalSection = TRUE;
}

VOID vReleaseCrtc(PDEV* ppdev)
{
    // 80x/805i/928 and 928PCI chips have a bug where if I/O registers
    // are left unlocked after accessing them, writes to memory with
    // similar addresses can cause writes to I/O registers.  The problem
    // registers are 0x40, 0x58, 0x59 and 0x5c.  We will simply always
    // leave the index set to an innocuous register (namely, the text
    // mode cursor start scan line):

    OUTP(ppdev->pjIoBase, CRTC_INDEX, 0xa);

    if (!gbCrtcCriticalSection)
        RIP("Hadn't yet acquired Critical Section");
    gbCrtcCriticalSection = FALSE;
    EngReleaseSemaphore(ppdev->csCrtc);
}


////////////////////////////////////////////////////////////////////////////

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\driver.h ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: driver.h
*
* Contains prototypes for the display driver.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

//////////////////////////////////////////////////////////////////////
// Put all the conditional-compile constants here.  There had better
// not be many!

//////////////////////////////////////////////////////////////////////
// Miscellaneous shared stuff

#define DLL_NAME                L"s3"       // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "S3: "      // All debug output is prefixed
                                            //   by this string
#define ALLOC_TAG               '  3S'      // Four byte tag used for tracking
                                            //   memory allocations (characters
                                            //   are in reverse order)

#define CLIP_LIMIT          50  // We'll be taking 800 bytes of stack space

#define DRIVER_EXTRA_SIZE   0   // Size of the DriverExtra information in the
                                //   DEVMODE structure

#define TMP_BUFFER_SIZE     8192  // Size in bytes of 'pvTmpBuffer'.  Has to
                                  //   be at least enough to store an entire
                                  //   scan line (i.e., 6400 for 1600x1200x32).

#if defined(_ALPHA_)
    #define XFER_BUFFERS    16  // Defines the maximum number of write buffers
                                //   possible on any Alpha.  Must be a power
#else                           //   of two.
    #define XFER_BUFFERS    1   // On non-alpha systems, we don't have to
                                //   worry about the chip caching our bus
#endif                          //   writes.

#define XFER_MASK           (XFER_BUFFERS - 1)

typedef struct _CLIPENUM {
    LONG    c;
    RECTL   arcl[CLIP_LIMIT];   // Space for enumerating complex clipping

} CLIPENUM;                         /* ce, pce */

typedef struct _PDEV PDEV;      // Handy forward declaration

VOID vSetClipping(PDEV*, RECTL*);
VOID vResetClipping(PDEV*);

//////////////////////////////////////////////////////////////////////
// Text stuff

#define GLYPH_CACHE_HEIGHT  48  // Number of scans to allocate for glyph cache,
                                //   divided by pel size

#define GLYPH_CACHE_CX      64  // Maximal width of glyphs that we'll consider
                                //   caching

#define GLYPH_CACHE_CY      64  // Maximum height of glyphs that we'll consider
                                //   caching

#define MAX_GLYPH_SIZE      ((GLYPH_CACHE_CX * GLYPH_CACHE_CY + 31) / 8)
                                // Maximum amount of off-screen memory required
                                //   to cache a glyph, in bytes

#define GLYPH_ALLOC_SIZE    8100
                                // Do all cached glyph memory allocations
                                //   in 8k chunks

#define HGLYPH_SENTINEL     ((ULONG) -1)
                                // GDI will never give us a glyph with a
                                //   handle value of 0xffffffff, so we can
                                //   use this as a sentinel for the end of
                                //   our linked lists

#define GLYPH_HASH_SIZE     256

#define GLYPH_HASH_FUNC(x)  ((x) & (GLYPH_HASH_SIZE - 1))

typedef struct _CACHEDGLYPH CACHEDGLYPH;
typedef struct _CACHEDGLYPH
{
    CACHEDGLYPH*    pcgNext;    // Points to next glyph that was assigned
                                //   to the same hash table bucket
    HGLYPH          hg;         // Handles in the bucket-list are kept in
                                //   increasing order
    POINTL          ptlOrigin;  // Origin of glyph bits

    // Device specific fields below here:

    LONG            cxLessOne;  // Glyph width less one
    LONG            cyLessOne;  // Glyph height less one
    LONG            cxcyLessOne;// Packed width and height, less one
    LONG            cw;         // Number of words to be transferred
    LONG            cd;         // Number of dwords to be transferred
    ULONG           ad[1];      // Start of glyph bits
} CACHEDGLYPH;  /* cg, pcg */

typedef struct _GLYPHALLOC GLYPHALLOC;
typedef struct _GLYPHALLOC
{
    GLYPHALLOC*     pgaNext;    // Points to next glyph structure that
                                //   was allocated for this font
    CACHEDGLYPH     acg[1];     // This array is a bit misleading, because
                                //   the CACHEDGLYPH structures are actually
                                //   variable sized
} GLYPHAALLOC;  /* ga, pga */

typedef struct _CACHEDFONT CACHEDFONT;
typedef struct _CACHEDFONT
{
    CACHEDFONT*     pcfNext;    // Points to next entry in CACHEDFONT list
    CACHEDFONT*     pcfPrev;    // Points to previous entry in CACHEDFONT list
    GLYPHALLOC*     pgaChain;   // Points to start of allocated memory list
    CACHEDGLYPH*    pcgNew;     // Points to where in the current glyph
                                //   allocation structure a new glyph should
                                //   be placed
    LONG            cjAlloc;    // Bytes remaining in current glyph allocation
                                //   structure
    CACHEDGLYPH     cgSentinel; // Sentinel entry of the end of our bucket
                                //   lists, with a handle of HGLYPH_SENTINEL
    CACHEDGLYPH*    apcg[GLYPH_HASH_SIZE];
                                // Hash table for glyphs

} CACHEDFONT;   /* cf, pcf */

typedef struct _XLATECOLORS {       // Specifies foreground and background
ULONG   iBackColor;                 //   colours for faking a 1bpp XLATEOBJ
ULONG   iForeColor;
} XLATECOLORS;                          /* xlc, pxlc */

BOOL bEnableText(PDEV*);
VOID vDisableText(PDEV*);
VOID vAssertModeText(PDEV*, BOOL);

VOID vFastText(GLYPHPOS*, ULONG, BYTE*, ULONG, ULONG, RECTL*, RECTL*,
               FLONG, RECTL*, RECTL*);
VOID vClearMemDword(ULONG*, ULONG);

//////////////////////////////////////////////////////////////////////
// Brush stuff

// 'Slow' brushes are used when we don't have hardware pattern capability,
// and we have to handle patterns using screen-to-screen blts:

#define SLOW_BRUSH_CACHE_DIM    3   // Controls the number of brushes cached
                                    //   in off-screen memory, when we don't
                                    //   have the S3 hardware pattern support.
                                    //   We allocate 3 x 3 brushes, so we can
                                    //   cache a total of 9 brushes:
#define SLOW_BRUSH_COUNT        (SLOW_BRUSH_CACHE_DIM * SLOW_BRUSH_CACHE_DIM)
#define SLOW_BRUSH_DIMENSION    64  // After alignment is taken care of,
                                    //   every off-screen brush cache entry
                                    //   will be 64 pels in both dimensions
#define SLOW_BRUSH_ALLOCATION   (SLOW_BRUSH_DIMENSION + 8)
                                    // Actually allocate 72x72 pels for each
                                    //   pattern, using the 8 extra for brush
                                    //   alignment

// 'Fast' brushes are used when we have hardware pattern capability:

#define FAST_BRUSH_COUNT        16  // Total number of non-hardware brushes
                                    //   cached off-screen
#define FAST_BRUSH_DIMENSION    8   // Every off-screen brush cache entry
                                    //   is 8 pels in both dimensions
#define FAST_BRUSH_ALLOCATION   16  // We have to align ourselves, so this is
                                    //   the dimension of each brush allocation

// Common to both implementations:

#define RBRUSH_2COLOR           1   // For RBRUSH flags

#define TOTAL_BRUSH_COUNT       max(FAST_BRUSH_COUNT, SLOW_BRUSH_COUNT)
                                    // This is the maximum number of brushes
                                    //   we can possibly have cached off-screen
#define TOTAL_BRUSH_SIZE        64  // We'll only ever handle 8x8 patterns,
                                    //   and this is the number of pels

typedef struct _BRUSHENTRY BRUSHENTRY;

// NOTE: Changes to the RBRUSH or BRUSHENTRY structures must be reflected
//       in strucs.inc!

typedef struct _RBRUSH {
    FLONG       fl;             // Type flags
    BOOL        bTransparent;   // TRUE if brush was realized for a transparent
                                //   blt (meaning colours are white and black),
                                //   FALSE if not (meaning it's already been
                                //   colour-expanded to the correct colours).
                                //   Value is undefined if the brush isn't
                                //   2 colour.
    ULONG       ulForeColor;    // Foreground colour if 1bpp
    ULONG       ulBackColor;    // Background colour if 1bpp
    POINTL      ptlBrushOrg;    // Brush origin of cached pattern.  Initial
                                //   value should be -1
    BRUSHENTRY* pbe;            // Points to brush-entry that keeps track
                                //   of the cached off-screen brush bits
    ULONG       aulPattern[1];  // Open-ended array for keeping copy of the
      // Don't put anything     //   actual pattern bits in case the brush
      //   after here, or       //   origin changes, or someone else steals
      //   you'll be sorry!     //   our brush entry (declared as a ULONG
                                //   for proper dword alignment)

} RBRUSH;                           /* rb, prb */

typedef struct _BRUSHENTRY {
    RBRUSH*     prbVerify;      // We never dereference this pointer to
                                //   find a brush realization; it is only
                                //   ever used in a compare to verify
                                //   that for a given realized brush, our
                                //   off-screen brush entry is still valid.
    LONG        x;              // x-position of cached pattern
    LONG        y;              // y-position of cached pattern

} BRUSHENTRY;                       /* be, pbe */

typedef union _RBRUSH_COLOR {
    RBRUSH*     prb;
    ULONG       iSolidColor;
} RBRUSH_COLOR;                     /* rbc, prbc */

BOOL bEnableBrushCache(PDEV*);
VOID vDisableBrushCache(PDEV*);
VOID vAssertModeBrushCache(PDEV*, BOOL);

//////////////////////////////////////////////////////////////////////
// Stretch stuff

typedef struct _STR_BLT {
    PDEV*   ppdev;
    PBYTE   pjSrcScan;
    LONG    lDeltaSrc;
    LONG    XSrcStart;
    PBYTE   pjDstScan;
    LONG    lDeltaDst;
    LONG    XDstStart;
    LONG    XDstEnd;
    LONG    YDstStart;
    LONG    YDstCount;
    ULONG   ulXDstToSrcIntCeil;
    ULONG   ulXDstToSrcFracCeil;
    ULONG   ulYDstToSrcIntCeil;
    ULONG   ulYDstToSrcFracCeil;
    ULONG   ulXFracAccumulator;
    ULONG   ulYFracAccumulator;
} STR_BLT;

typedef VOID (*PFN_DIRSTRETCH)(STR_BLT*);

VOID vDirectStretch8Narrow(STR_BLT*);
VOID vDirectStretch8(STR_BLT*);
VOID vDirectStretch16(STR_BLT*);
VOID vDirectStretch32(STR_BLT*);

/////////////////////////////////////////////////////////////////////////
// Heap stuff

typedef struct _DSURF DSURF;

typedef enum {
    DT_DIB          = 0x1,  // Surface is really a DIB, not in off-screen
                            //   memory
    DT_DIRECTDRAW   = 0x2,  // Surface is really a DirectDraw surface

} DSURFTYPE;                    /* dt, pdt */

typedef struct _DSURF
{
    DSURFTYPE dt;           // DSURF status flags
    PDEV*     ppdev;        // Points to our PDEV
    LONG      x;            // x pixel coordinate of left edge of allocation 
                            //   if not DT_DIB
    LONG      y;            // y pixel coordinate of right edge of allocation 
                            //   if not DT_DIB
    LONG      cx;           // Bitmap width in pixels
    LONG      cy;           // Bitmap height in pixels
    union {
        FLATPTR   fpVidMem; // Offset from start of video-memory if not DT_DIB
        VOID*     pvScan0;  // Bits location in system-memory if DT_DIB
    };
    VIDEOMEMORY*  pvmHeap;  // DirectDraw heap this was allocated from if 
                            //   not DT_DIB and not DT_DIRECTDRAW
    DSURF*    pdsurfDiscardableNext;   
                            // Linked list of discardable surface allocations.
                            //   This list is traversed from the start to
                            //   throw out any allocations
    HSURF     hsurf;        // Handle to associated GDI surface (if any)

    // The following are used for DT_DIB only...

    ULONG     cBlt;         // Counts down the number of blts necessary at
                            //   the current uniqueness before we'll consider
                            //   putting the DIB back into off-screen memory
    ULONG     iUniq;        // Tells us whether there have been any heap
                            //   'free's since the last time we looked at
                            //   this DIB

} DSURF;                          /* dsurf, pdsurf */

// Number of blts necessary before we'll consider putting a DIB DFB back
// into off-screen memory:

#define HEAP_COUNT_DOWN     6

DSURF* pVidMemAllocate(PDEV*, LONG, LONG);
VOID vVidMemFree(DSURF*);
BOOL bMoveDibToOffscreenDfbIfRoom(PDEV*, DSURF*);
BOOL bMoveOldestOffscreenDfbToDib(PDEV*);

BOOL bEnableOffscreenHeap(PDEV*);
VOID vDisableOffscreenHeap(PDEV*);
BOOL bAssertModeOffscreenHeap(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Bank manager stuff

#define BANK_DATA_SIZE  80      // Number of bytes to allocate for the
                                //   miniport down-loaded bank code working
                                //   space

typedef struct _BANK
{
    // Private data:

    RECTL    rclDraw;           // Rectangle describing the remaining undrawn
                                //   portion of the drawing operation
    RECTL    rclSaveBounds;     // Saved from original CLIPOBJ for restoration
    BYTE     iSaveDComplexity;  // Saved from original CLIPOBJ for restoration
    BYTE     fjSaveOptions;     // Saved from original CLIPOBJ for restoration
    LONG     iBank;             // Current bank
    PDEV*    ppdev;             // Saved copy

    // Public data:

    SURFOBJ* pso;               // Surface wrapped around the bank.  Has to be
                                //   passed as the surface in any banked call-
                                //   back.
    CLIPOBJ* pco;               // Clip object that is the intersection of the
                                //   original clip object with the bounds of the
                                //   current bank.  Has to be passed as the clip
                                //   object in any banked call-back.

} BANK;                         /* bnk, pbnk */

// Note: BANK_MODE is duplicated in i386\strucs.inc!

typedef enum {
    BANK_OFF = 0,       // We've finished using the memory aperture
    BANK_ON,            // We're about to use the memory aperture
    BANK_ON_NO_WAIT,    // We're about to use the memory aperture, and are
                        //   doing our own hardware synchronization
    BANK_DISABLE,       // We're about to enter full-screen; shut down banking
    BANK_ENABLE,        // We've exited full-screen; re-enable banking

} BANK_MODE;                    /* bankm, pbankm */

typedef struct _BANKDATA {

// Common to both old and new bank schemes:

ULONG   ulGp_stat_cmd;                   // Port number of status register
ULONG   ulRegisterLock_35;               // Default for index 35

// Only applies to new bank schemes:

ULONG   ulSystemConfiguration_40;        // Default for index 40
ULONG   ulExtendedSystemControl2_51;     // Default for index 51
ULONG   ulExtendedMemoryControl_53;      // Default for index 53
ULONG   ulLinearAddressWindowControl_58; // Default for index 58
ULONG   ulExtendedSystemControl4_6a;     // Default for index 6a

ULONG   ulEnableMemoryMappedIo;          // Bit mask to enable MM IO

} BANKDATA;                      /* bd, pbd */

typedef VOID (FNBANKMAP)(PDEV*, BANKDATA*, LONG);
typedef VOID (FNBANKSELECTMODE)(PDEV*, BANKDATA*, BANK_MODE);
typedef VOID (FNBANKINITIALIZE)(PDEV*, BANKDATA*, BOOL);
typedef BOOL (FNBANKCOMPUTE)(PDEV*, RECTL*, RECTL*, LONG*, LONG*);

VOID vBankStart(PDEV*, RECTL*, CLIPOBJ*, BANK*);
BOOL bBankEnum(BANK*);

FNBANKCOMPUTE bBankComputeNonPower2;
FNBANKCOMPUTE bBankComputePower2;

BOOL bEnableBanking(PDEV*);
VOID vDisableBanking(PDEV*);
VOID vAssertModeBanking(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Pointer stuff

#define POINTER_DATA_SIZE       40      // Number of bytes to allocate for the
                                        //   miniport down-loaded pointer code
                                        //   working space
#define HW_INVISIBLE_OFFSET     2       // Offset from 'ppdev->yPointerBuffer'
                                        //   to the invisible pointer
#define HW_POINTER_DIMENSION    64      // Maximum dimension of default
                                        //   (built-in) hardware pointer
#define HW_POINTER_HIDE         63      // Hardware pointer start pixel
                                        //   position used to hide the pointer
#define HW_POINTER_TOTAL_SIZE   1024    // Total size in bytes required
                                        //   to define the hardware pointer
                                        //   (must be a power of 2 for
                                        //   allocating space for the shape)

typedef VOID (FNSHOWPOINTER)(PDEV*, VOID*, BOOL);
typedef VOID (FNMOVEPOINTER)(PDEV*, VOID*, LONG, LONG);
typedef BOOL (FNSETPOINTERSHAPE)(PDEV*, VOID*, LONG, LONG, LONG, LONG, LONG,
                                 LONG, BYTE*);
typedef VOID (FNENABLEPOINTER)(PDEV*, VOID*, BOOL);

BOOL bEnablePointer(PDEV*);
VOID vDisablePointer(PDEV*);
VOID vAssertModePointer(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Palette stuff

BOOL bEnablePalette(PDEV*);
VOID vDisablePalette(PDEV*);
VOID vAssertModePalette(PDEV*, BOOL);

BOOL bInitializePalette(PDEV*, DEVINFO*);
VOID vUninitializePalette(PDEV*);

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))

/////////////////////////////////////////////////////////////////////////
// DirectDraw stuff

DWORD DdBlt(PDD_BLTDATA);
DWORD DdFlip(PDD_FLIPDATA);
DWORD DdLock(PDD_LOCKDATA);
DWORD DdGetBltStatus(PDD_GETBLTSTATUSDATA);
DWORD DdMapMemory(PDD_MAPMEMORYDATA);
DWORD DdGetFlipStatus(PDD_GETFLIPSTATUSDATA);
DWORD DdWaitForVerticalBlank(PDD_WAITFORVERTICALBLANKDATA);
DWORD DdCanCreateSurface(PDD_CANCREATESURFACEDATA);
DWORD DdCreateSurface(PDD_CREATESURFACEDATA);
DWORD DdSetColorKey(PDD_SETCOLORKEYDATA);
DWORD DdUpdateOverlay(PDD_UPDATEOVERLAYDATA);
DWORD DdSetOverlayPosition(PDD_SETOVERLAYPOSITIONDATA);
DWORD DdGetDriverInfo(PDD_GETDRIVERINFODATA);

// FourCC formats are encoded in reverse because we're little endian:

#define FOURCC_YUY2         '2YUY'  // Encoded in reverse because we're little

// There's a 64K granularity that applies to the mapping of the frame
// buffer into the application's address space:

#define ROUND_UP_TO_64K(x)  (((ULONG)(x) + 0x10000 - 1) & ~(0x10000 - 1))

typedef struct _FLIPRECORD
{
    FLATPTR         fpFlipFrom;             // Surface we last flipped from
    LONGLONG        liFlipTime;             // Time at which last flip
                                            //   occured
    LONGLONG        liFlipDuration;         // Precise amount of time it
                                            //   takes from vblank to vblank
    BOOL            bHaveEverCrossedVBlank; // True if we noticed that we
                                            //   switched from inactive to
                                            //   vblank
    BOOL            bWasEverInDisplay;      // True if we ever noticed that
                                            //   we were inactive
    BOOL            bFlipFlag;              // True if we think a flip is
                                            //   still pending
} FLIPRECORD;

BOOL bEnableDirectDraw(PDEV*);
VOID vDisableDirectDraw(PDEV*);
VOID vAssertModeDirectDraw(PDEV*, BOOL);

//////////////////////////////////////////////////////////////////////
// Low-level blt function prototypes

typedef VOID (FNFILL)(PDEV*, LONG, RECTL*, ULONG, RBRUSH_COLOR, POINTL*);
typedef VOID (FNXFER)(PDEV*, LONG, RECTL*, ULONG, SURFOBJ*, POINTL*,
                      RECTL*, XLATEOBJ*);
typedef VOID (FNCOPY)(PDEV*, LONG, RECTL*, ULONG, POINTL*, RECTL*);
typedef VOID (FNFASTPATREALIZE)(PDEV*, RBRUSH*, POINTL*, BOOL);
typedef VOID (FNIMAGETRANSFER)(PDEV*, BYTE*, LONG, LONG, LONG, ULONG);
typedef BOOL (FNTEXTOUT)(SURFOBJ*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*,
                         BRUSHOBJ*, BRUSHOBJ*);
typedef VOID (FNLINETOTRIVIAL)(PDEV*, LONG, LONG, LONG, LONG, ULONG, MIX);
typedef VOID (FNLINETOCLIPPED)(PDEV*, LONG, LONG, LONG, LONG, ULONG, MIX, RECTL*);
typedef VOID (FNCOPYTRANSPARENT)(PDEV*, LONG, RECTL*, POINTL*, RECTL*, ULONG);

FNFILL              vIoFillPatFast;
FNFILL              vIoFillPatSlow;
FNFILL              vIoFillSolid;
FNXFER              vIoXfer1bpp;
FNXFER              vIoXfer4bpp;
FNXFER              vIoXferNative;
FNXFER              vXferNativeSrccopy;
FNCOPY              vIoCopyBlt;
FNFASTPATREALIZE    vIoFastPatRealize;
FNIMAGETRANSFER     vIoImageTransferIo16;
FNIMAGETRANSFER     vIoImageTransferMm16;
FNTEXTOUT           bIoTextOut;
FNLINETOTRIVIAL     vIoLineToTrivial;
FNLINETOCLIPPED     vIoLineToClipped;
FNCOPYTRANSPARENT   vIoCopyTransparent;

FNFILL              vMmFillPatFast;
FNFILL              vMmFillPatSlow;
FNFILL              vMmFillSolid;
FNXFER              vMmXfer1bpp;
FNXFER              vMmXfer4bpp;
FNXFER              vMmXferNative;
FNCOPY              vMmCopyBlt;
FNFASTPATREALIZE    vMmFastPatRealize;
FNIMAGETRANSFER     vMmImageTransferMm16;
FNIMAGETRANSFER     vMmImageTransferMm32;
FNTEXTOUT           bMmTextOut;
FNLINETOTRIVIAL     vMmLineToTrivial;
FNLINETOCLIPPED     vMmLineToClipped;
FNCOPYTRANSPARENT   vMmCopyTransparent;

FNTEXTOUT           bNwTextOut;
FNLINETOTRIVIAL     vNwLineToTrivial;
FNLINETOCLIPPED     vNwLineToClipped;

VOID vPutBits(PDEV*, SURFOBJ*, RECTL*, POINTL*);
VOID vGetBits(PDEV*, SURFOBJ*, RECTL*, POINTL*);
VOID vIoSlowPatRealize(PDEV*, RBRUSH*, BOOL);

////////////////////////////////////////////////////////////////////////
// Capabilities flags
//
// These are private flags passed to us from the S3 miniport.  They
// come from the 'DriverSpecificAttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to us via an 'VIDEO_QUERY_AVAIL_MODES' or 'VIDEO_QUERY_CURRENT_MODE'
// IOCTL.
//
// NOTE: These definitions must match those in the S3 miniport's 's3.h'!

typedef enum {
    CAPS_STREAMS_CAPABLE    = 0x00000040,   // Has overlay streams processor
    CAPS_FORCE_DWORD_REREADS= 0x00000080,   // Dword reads occasionally return
                                            //   an incorrect result, so always
                                            //   retry the reads
    CAPS_NEW_MMIO           = 0x00000100,   // Can use 'new memory-mapped
                                            //   I/O' scheme introduced with
                                            //   868/968
    CAPS_POLYGON            = 0x00000200,   // Can do polygons in hardware
    CAPS_24BPP              = 0x00000400,   // Has 24bpp capability
    CAPS_BAD_24BPP          = 0x00000800,   // Has 868/968 early rev chip bugs
                                            //   when at 24bpp
    CAPS_PACKED_EXPANDS     = 0x00001000,   // Can do 'new 32-bit transfers'
    CAPS_PIXEL_FORMATTER    = 0x00002000,   // Can do colour space conversions,
                                            //   and one-dimensional hardware
                                            //   stretches
    CAPS_BAD_DWORD_READS    = 0x00004000,   // Dword or word reads from the
                                            //   frame buffer will occasionally
                                            //   return an incorrect result,
                                            //   so always do byte reads
    CAPS_NO_DIRECT_ACCESS   = 0x00008000,   // Frame buffer can't be directly
                                            //   accessed by GDI or DCI --
                                            //   because dword or word reads
                                            //   would crash system, or Alpha
                                            //   is running in sparse space

    CAPS_HW_PATTERNS        = 0x00010000,   // 8x8 hardware pattern support
    CAPS_MM_TRANSFER        = 0x00020000,   // Memory-mapped image transfers
    CAPS_MM_IO              = 0x00040000,   // Memory-mapped I/O
    CAPS_MM_32BIT_TRANSFER  = 0x00080000,   // Can do 32bit bus size transfers
    CAPS_16_ENTRY_FIFO      = 0x00100000,   // At least 16 entries in FIFO
    CAPS_SW_POINTER         = 0x00200000,   // No hardware pointer; use software
                                            //   simulation
    CAPS_BT485_POINTER      = 0x00400000,   // Use Brooktree 485 pointer
    CAPS_TI025_POINTER      = 0x00800000,   // Use TI TVP3020/3025 pointer
    CAPS_SCALE_POINTER      = 0x01000000,   // Set if the S3 hardware pointer
                                            //   x position has to be scaled by
                                            //   two
    CAPS_SPARSE_SPACE       = 0x02000000,   // Frame buffer is mapped in sparse
                                            //   space on the Alpha
    CAPS_NEW_BANK_CONTROL   = 0x04000000,   // Set if 801/805/928 style banking
    CAPS_NEWER_BANK_CONTROL = 0x08000000,   // Set if 864/964 style banking
    CAPS_RE_REALIZE_PATTERN = 0x10000000,   // Set if we have to work around the
                                            //   864/964 hardware pattern bug
    CAPS_SLOW_MONO_EXPANDS  = 0x20000000,   // Set if we have to slow down
                                            //   monochrome expansions
    CAPS_MM_GLYPH_EXPAND    = 0x40000000,   // Use memory-mapped I/O glyph-
                                            //   expand method of drawing text
} CAPS;

#define CAPS_DAC_POINTER        (CAPS_BT485_POINTER | CAPS_TI025_POINTER)

#define CAPS_LINEAR_FRAMEBUFFER CAPS_NEW_MMIO
                                            // For now, we're linear only
                                            //   when using with 'New MM I/O'

// DIRECT_ACCESS(ppdev) returns TRUE if GDI and DCI can directly access
// the frame buffer.  It returns FALSE if there are hardware bugs
// when reading words or dwords from the frame buffer that cause non-x86
// systems to crash.  It will also return FALSE is the Alpha frame buffer
// is mapped in using 'sparse space'.

#if defined(_X86_)
    #define DIRECT_ACCESS(ppdev)    1
#else
    #define DIRECT_ACCESS(ppdev)    \
        (!(ppdev->flCaps & (CAPS_NO_DIRECT_ACCESS | CAPS_SPARSE_SPACE)))
#endif

// DENSE(ppdev) returns TRUE if the normal 'dense space' mapping of the
// frame buffer is being used.  It returns FALSE only on the Alpha when
// the frame buffer is mapped in using 'sparse space,' meaning that all
// reads and writes to and from the frame buffer must be done through the
// funky 'ioaccess.h' macros.

#if defined(_ALPHA_)
    #define DENSE(ppdev)        (!(ppdev->flCaps & CAPS_SPARSE_SPACE))
#else
    #define DENSE(ppdev)        1
#endif

////////////////////////////////////////////////////////////////////////
// Status flags

typedef enum {
    STAT_GLYPH_CACHE          = 0x0001, // Glyph cache successfully allocated
    STAT_BRUSH_CACHE          = 0x0002, // Brush cache successfully allocated
    STAT_DIRECTDRAW_CAPABLE   = 0x0004, // Card is DirectDraw capable
    STAT_STREAMS_ENABLED      = 0x0010, // Streams processor is enabled
} STATUS;

////////////////////////////////////////////////////////////////////////
// The Physical Device data structure

typedef struct  _PDEV
{
    // -------------------------------------------------------------------
    // NOTE: Changes between here and NOTE1 in the PDEV structure must be
    // reflected in i386\strucs.inc (assuming you're on an x86, of course)!

    LONG        xOffset;                // Pixel offset from (0, 0) to current
    LONG        yOffset;                //   DFB located in off-screen memory
    BYTE*       pjMmBase;               // Start of memory mapped I/O
    BYTE*       pjScreen;               // Points to base screen address
    LONG        lDelta;                 // Distance from one scan to the next.
    LONG        cjPelSize;              // 1 if 8bpp, 2 if 16bpp, 3 if 24bpp,
                                        //   4 if 32bpp
    ULONG       iBitmapFormat;          // BMF_8BPP or BMF_16BPP or BMF_32BPP
                                        //   (our current colour depth)

    // Enhanced mode register addresses.

    VOID*       ioCur_y;
    VOID*       ioCur_x;
    VOID*       ioDesty_axstp;
    VOID*       ioDestx_diastp;
    VOID*       ioErr_term;
    VOID*       ioMaj_axis_pcnt;
    VOID*       ioGp_stat_cmd;
    VOID*       ioShort_stroke;
    VOID*       ioBkgd_color;
    VOID*       ioFrgd_color;
    VOID*       ioWrt_mask;
    VOID*       ioRd_mask;
    VOID*       ioColor_cmp;
    VOID*       ioBkgd_mix;
    VOID*       ioFrgd_mix;
    VOID*       ioMulti_function;
    VOID*       ioPix_trans;

    // Important data for accessing the frame buffer.

    VOID*               pvBankData;         // Points to aulBankData[0]
    FNBANKSELECTMODE*   pfnBankSelectMode;  // Routine to enable or disable
                                            //   direct frame buffer access
    BANK_MODE           bankmOnOverlapped;  // BANK_ON or BANK_ON_NO_WAIT,
                                            //   depending on whether card
                                            //   can handle simulataneous
                                            //   frame buffer and accelerator
                                            //   access
    BOOL                bMmIo;              // Can do CAPS_MM_IO

    // -------------------------------------------------------------------
    // NOTE1: Changes up to here in the PDEV structure must be reflected in
    // i386\strucs.inc (assuming you're on an x86, of course)!

    CAPS        flCaps;                 // Capabilities flags
    STATUS      flStatus;               // Status flags
    BOOL        bEnabled;               // In graphics mode (not full-screen)

    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfScreen;            // Engine's handle to screen surface

    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height
    LONG        cxMemory;               // Width of Video RAM
    LONG        cyHeap;                 // Height of Video RAM available to
                                        //   DirectDraw heap (cyScreen
                                        //   <= cyHeap <= cyMemory),
                                        //   including primary surface
    LONG        cxHeap;                 // Width of Video RAM available to
                                        //   DirectDraw heap, including
                                        //   primary surface
    LONG        cyMemory;               // Height of Video RAM
    LONG        cBitsPerPel;            // Bits per pel (8, 15, 16, 24 or 32)
    ULONG       ulMode;                 // Mode the mini-port driver is in.
    FLONG       flHooks;                // What we're hooking from GDI
    UCHAR*      pjIoBase;               // Mapped IO port base for this PDEV
    VOID*       pvTmpBuffer;            // General purpose temporary buffer,
                                        //   TMP_BUFFER_SIZE bytes in size
                                        //   (Remember to synchronize if you
                                        //   use this for device bitmaps or
                                        //   async pointers)
    USHORT*     apwMmXfer[XFER_BUFFERS];// Pre-computed array of unique
    ULONG*      apdMmXfer[XFER_BUFFERS];//   addresses for doing memory-mapped
                                        //   transfers without memory barriers
                                        // Note that the 868/968 chips have a
                                        //   hardware bug and can't do byte
                                        //   transfers
    HSEMAPHORE  csCrtc;                 // Used for synchronizing access to
                                        //   the CRTC register
    DSURF       dsurfScreen;            // We stash here our private surface 
                                        //   structure that represents the 
                                        //   primary GDI surface

    ////////// Low-level blt function pointers:

    FNFILL*             pfnFillSolid;
    FNFILL*             pfnFillPat;
    FNXFER*             pfnXfer1bpp;
    FNXFER*             pfnXfer4bpp;
    FNXFER*             pfnXferNative;
    FNCOPY*             pfnCopyBlt;
    FNFASTPATREALIZE*   pfnFastPatRealize;
    FNIMAGETRANSFER*    pfnImageTransfer;
    FNTEXTOUT*          pfnTextOut;
    FNLINETOTRIVIAL*    pfnLineToTrivial;
    FNLINETOCLIPPED*    pfnLineToClipped;
    FNCOPYTRANSPARENT*  pfnCopyTransparent;

    ////////// Palette stuff:

    PALETTEENTRY* pPal;                 // The palette if palette managed
    HPALETTE    hpalDefault;            // GDI handle to the default palette.
    FLONG       flRed;                  // Red mask for 16/32bpp bitfields
    FLONG       flGreen;                // Green mask for 16/32bpp bitfields
    FLONG       flBlue;                 // Blue mask for 16/32bpp bitfields
    ULONG       cPaletteShift;          // number of bits the 8-8-8 palette must
                                        // be shifted by to fit in the hardware
                                        // palette.
    ////////// Heap stuff:

    VIDEOMEMORY* pvmList;               // Points to the video-memory heap list 
                                        //   as supplied by DirectDraw, needed
                                        //   for heap allocations
    ULONG       cHeaps;                 // Count of video-memory heaps
    ULONG       iHeapUniq;              // Incremented every time room is freed
                                        //   in the off-screen heap
    SURFOBJ*    psoPunt;                // Wrapper surface for having GDI draw
                                        //   on off-screen bitmaps
    SURFOBJ*    psoPunt2;               // Another one for off-screen to off-
                                        //   screen blts
    DSURF*      pdsurfDiscardableList;  // Linked list of discardable bitmaps, 
                                        //   in order of oldest to newest

    ////////// Banking stuff:

    LONG        cjBank;                 // Size of a bank, in bytes
    LONG        cPower2ScansPerBank;    // Used by 'bBankComputePower2'
    LONG        cPower2BankSizeInBytes; // Used by 'bBankComputePower2'
    CLIPOBJ*    pcoBank;                // Clip object for banked call backs
    SURFOBJ*    psoBank;                // Surface object for banked call backs
    ULONG       aulBankData[BANK_DATA_SIZE / 4];
                                        // Private work area for downloaded
                                        //   miniport banking code

    FNBANKMAP*          pfnBankMap;
    FNBANKCOMPUTE*      pfnBankCompute;

    ////////// Pointer stuff:

    BOOL        bHwPointerActive;       // Currently using the h/w pointer?
    LONG        xPointerHot;            // xHot of current hardware pointer
    LONG        yPointerHot;            // yHot of current hardware pointer

    LONG        cjPointerOffset;        // Byte offset from start of frame
                                        //   buffer to off-screen memory where
                                        //   we stored the pointer shape
    LONG        xPointerShape;          // x-coordinate
    LONG        yPointerShape;          // y-coordinate
    LONG        iPointerBank;           // Bank containing pointer shape
    VOID*       pvPointerShape;         // Points to pointer shape when bank
                                        //   is mapped in
    LONG        xPointer;               // Start x-position for the current
                                        //   S3 pointer
    LONG        yPointer;               // Start y-position for the current
                                        //   S3 pointer
    LONG        dxPointer;              // Start x-pixel position for the
                                        //   current S3 pointer
    LONG        dyPointer;              // Start y-pixel position for the
                                        //   current S3 pointer
    LONG        cPointerShift;          // Horizontal scaling factor for
                                        //   hardware pointer position

    ULONG       ulHwGraphicsCursorModeRegister_45;
                                        // Default value for index 45
    VOID*       pvPointerData;          // Points to ajPointerData[0]
    BYTE        ajPointerData[POINTER_DATA_SIZE];
                                        // Private work area for downloaded
                                        //   miniport pointer code

    FNSHOWPOINTER*      pfnShowPointer;
    FNMOVEPOINTER*      pfnMovePointer;
    FNSETPOINTERSHAPE*  pfnSetPointerShape;
    FNENABLEPOINTER*    pfnEnablePointer;

    ////////// Brush stuff:

    LONG        iBrushCache;            // Index for next brush to be allocated
    LONG        cBrushCache;            // Total number of brushes cached
    BRUSHENTRY  abe[TOTAL_BRUSH_COUNT]; // Keeps track of brush cache
    POINTL      ptlReRealize;           // Work area for 864/964 pattern
                                        //   hardware bug work-around

    ////////// Text stuff:

    SURFOBJ*    psoText;                // 1bpp surface to which we will have
                                        //   GDI draw our glyphs for us

    /////////// DirectDraw stuff:

    FLIPRECORD  flipRecord;             // Used to track vertical blank status
    ULONG       ulRefreshRate;          // Refresh rate in Hz
    ULONG       ulMinOverlayStretch;    // Minimum stretch ratio for this mode,
                                        //   expressed as a multiple of 1000
    ULONG       ulFifoValue;            // Optimial FIFO value for this mode
    ULONG       ulExtendedSystemControl3Register_69;
                                        // Masked original contents of
                                        //   S3 register 0x69, in high byte
    ULONG       ulMiscState;            // Default state of the MULT_MISC
                                        //   register
    DSURF*      pdsurfVideoEngineScratch;// Location of one entire scan line that
                                        //   can be used for temporary memory
                                        //   by the 868/968 pixel formatter
    BYTE        jSavedCR2;              // Saved contents of register CR2
    FLATPTR     fpVisibleOverlay;       // Frame buffer offset to currently
                                        //   visible overlay; will be zero if
                                        //   no overlay is visible
    DWORD       dwOverlayFlipOffset;    // Overlay flip offset
    DWORD       dwVEstep;               // 868 video engine step value
    DWORD       ulColorKey;             // color key value to be set when streams
                                        // processor is enabled
} PDEV;

/////////////////////////////////////////////////////////////////////////
// Miscellaneous prototypes:

BOOL bIntersect(RECTL*, RECTL*, RECTL*);
LONG cIntersect(RECTL*, RECTL*, LONG);
DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION*, DWORD*);

BOOL bInitializeModeFields(PDEV*, GDIINFO*, DEVINFO*, DEVMODEW*);
BOOL bFastFill(PDEV*, LONG, POINTFIX*, ULONG, ULONG, RBRUSH*, POINTL*, RECTL*);

BOOL bEnableHardware(PDEV*);
VOID vDisableHardware(PDEV*);
BOOL bAssertModeHardware(PDEV*, BOOL);

extern BYTE gajHwMixFromMix[];
extern BYTE gaRop3FromMix[];
extern ULONG gaulHwMixFromRop2[];

/////////////////////////////////////////////////////////////////////////
// The x86 C compiler insists on making a divide and modulus operation
// into two DIVs, when it can in fact be done in one.  So we use this
// macro.
//
// Note: QUOTIENT_REMAINDER implicitly takes unsigned arguments.

#if defined(_X86_)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}

#endif

/////////////////////////////////////////////////////////////////////////
// OVERLAP - Returns TRUE if the same-size lower-right exclusive
//           rectangles defined by 'pptl' and 'prcl' overlap:

#define OVERLAP(prcl, pptl)                                             \
    (((prcl)->right  > (pptl)->x)                                   &&  \
     ((prcl)->bottom > (pptl)->y)                                   &&  \
     ((prcl)->left   < ((pptl)->x + (prcl)->right - (prcl)->left))  &&  \
     ((prcl)->top    < ((pptl)->y + (prcl)->bottom - (prcl)->top)))

/////////////////////////////////////////////////////////////////////////
// SWAP - Swaps the value of two variables, using a temporary variable

#define SWAP(a, b, tmp) { (tmp) = (a); (a) = (b); (b) = (tmp); }

/////////////////////////////////////////////////////////////////////////
// CONVERT_TO_BYTES - Converts to byte count.

#define CONVERT_TO_BYTES(x, pdev)   ( (x) * pdev->cjPelSize)

/////////////////////////////////////////////////////////////////////////
// CONVERT_FROM_BYTES - Converts to byte count.

#define CONVERT_FROM_BYTES(x, pdev)	( (x) / pdev->cjPelSize)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\debug.h ===
/***************************************************************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\***************************************************************************/

extern
VOID
DebugPrint(
    LONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#if DBG

VOID DebugLog(LONG, CHAR*, ...);

#define DISPDBG(arg) DebugPrint arg
#define STATEDBG(level) DebugState(level)
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}
#define ASSERTDD(x, y) if (!(x)) RIP (y)

// If we are not in a debug environment, we want all of the debug
// information to be stripped out.

#else

#define DISPDBG(arg)
#define STATEDBG(level)
#define LOGDBG(arg)
#define RIP(x)
#define ASSERTDD(x, y)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\heap.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: heap.c
*
* This module contains the routines for an off-screen video heap manager.
* It is used primarily for allocating space for device-format-bitmaps in
* off-screen memory.
*
* Off-screen bitmaps are a big deal on NT because:
*
*    1) It reduces the working set.  Any bitmap stored in off-screen
*       memory is a bitmap that isn't taking up space in main memory.
*
*    2) There is a speed win by using the accelerator hardware for
*       drawing, in place of NT's GDI code.  NT's GDI is written entirely
*       in 'C++' and perhaps isn't as fast as it could be.
*
*    3) It raises your Winbench score.
*
* Copyright (c) 1993-1998 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* DSURF* pVidMemAllocate
*
\**************************************************************************/

DSURF* pVidMemAllocate(
PDEV*       ppdev,
LONG        cx,
LONG        cy)
{
    ULONG               iHeap;
    VIDEOMEMORY*        pvmHeap;
    FLATPTR             fpVidMem;
    DSURF*              pdsurf;
    LONG                lDelta;
    SURFACEALIGNMENT    Alignment;

    memset(&Alignment, 0, sizeof(Alignment));

    // Ensure quadword x-alignment in video memory:

    Alignment.Rectangular.dwXAlignment = 8;
    Alignment.Rectangular.dwFlags |= SURFACEALIGN_DISCARDABLE;

    for (iHeap = 0; iHeap < ppdev->cHeaps; iHeap++)
    {
        pvmHeap = &ppdev->pvmList[iHeap];

        // AGP memory could be potentially used for device-bitmaps, with
        // two very large caveats:
        //
        // 1. No kernel-mode view is made for the AGP memory (would take
        //    up too many PTEs and too much virtual address space).
        //    No user-mode view is made either unless a DirectDraw
        //    application happens to be running.  Consequently, neither
        //    GDI nor the driver can use the CPU to directly access the
        //    bits.  (It can be done through the accelerator, however.)
        //
        // 2. AGP heaps never shrink their committed allocations.  The
        //    only time AGP memory gets de-committed is when the entire
        //    heap is empty.  And don't forget that committed AGP memory
        //    is non-pageable.  Consequently, if you were to enable a
        //    50 MB AGP heap for DirectDraw, and were sharing that heap
        //    for device bitmap allocations, after running a D3D game
        //    the system would never be able to free that 50 MB of non-
        //    pageable memory until every single device bitmap was deleted!
        //    Just watch your Winstone scores plummet if someone plays
        //    a D3D game first.

        if (!(pvmHeap->dwFlags & VIDMEM_ISNONLOCAL))
        {
            fpVidMem = HeapVidMemAllocAligned(pvmHeap,
                                              cx * ppdev->cjPelSize,
                                              cy,
                                              &Alignment,
                                              &lDelta);
            if (fpVidMem != 0)
            {
                pdsurf = EngAllocMem(FL_ZERO_MEMORY, sizeof(DSURF), ALLOC_TAG);
                if (pdsurf != NULL)
                {
                    pdsurf->dt       = 0;
                    pdsurf->ppdev    = ppdev;
                    pdsurf->x        = (LONG)(fpVidMem % ppdev->lDelta)
                                     / ppdev->cjPelSize;
                    pdsurf->y        = (LONG)(fpVidMem / ppdev->lDelta);
                    pdsurf->cx       = cx;
                    pdsurf->cy       = cy;
                    pdsurf->fpVidMem = fpVidMem;
                    pdsurf->pvmHeap  = pvmHeap;

                    return(pdsurf);
                }

                VidMemFree(pvmHeap->lpHeap, fpVidMem);
            }
        }
    }

    return(NULL);
}

/******************************Public*Routine******************************\
* VOID vVidMemFree
*
\**************************************************************************/

VOID vVidMemFree(
DSURF*  pdsurf)
{
    DSURF*  pTmp;

    if (pdsurf == NULL)
        return;

    if (!(pdsurf->dt & DT_DIRECTDRAW))
    {
        if (pdsurf->dt & DT_DIB)
        {
            EngFreeMem(pdsurf->pvScan0);
        }
        else
        {
            // Update the uniqueness to show that space has been freed, so
            // that we may decide to see if some DIBs can be moved back into
            // off-screen memory:

            pdsurf->ppdev->iHeapUniq++;

            VidMemFree(pdsurf->pvmHeap->lpHeap, pdsurf->fpVidMem);
        }
    }

    EngFreeMem(pdsurf);
}

/******************************Public*Routine******************************\
* BOOL bMoveOldestOffscreenDfbToDib
*
\**************************************************************************/

BOOL bMoveOldestOffscreenDfbToDib(
PDEV*   ppdev)
{
    DSURF*      pdsurf;
    LONG        lDelta;
    VOID*       pvScan0;
    RECTL       rclDst;
    POINTL      ptlSrc;
    SURFOBJ     soTmp;

    pdsurf = ppdev->pdsurfDiscardableList;
    if (pdsurf != NULL)
    {
        // Make the system-memory scans quadword aligned:

        lDelta = (pdsurf->cx * ppdev->cjPelSize + 7) & ~7;

        // Note that there's no point in zero-initializing this memory:

        pvScan0 = EngAllocMem(0, lDelta * pdsurf->cy, ALLOC_TAG);

        if (pvScan0 != NULL)
        {
            // The following 'EngModifySurface' call tells GDI to
            // modify the surface to point to system-memory for
            // the bits, and changes what Drv calls we want to
            // hook for the surface.
            //
            // By specifying the surface address, GDI will convert the
            // surface to an STYPE_BITMAP surface (if necessary) and
            // point the bits to the memory we just allocated.  The
            // next time we see it in a DrvBitBlt call, the 'dhsurf'
            // field will still point to our 'pdsurf' structure.
            //
            // Note that we hook only CopyBits and BitBlt when we
            // convert the device-bitmap to a system-memory surface.
            // This is so that we don't have to worry about getting
            // DrvTextOut, DrvLineTo, etc. calls on bitmaps that
            // we've converted to system-memory -- GDI will just
            // automatically do the drawing for us.
            //
            // However, we are still interested in seeing DrvCopyBits
            // and DrvBitBlt calls involving this surface, because
            // in those calls we take the opportunity to see if it's
            // worth putting the device-bitmap back into video memory
            // (if some room has been freed up).

            if (EngModifySurface(pdsurf->hsurf,
                                 ppdev->hdevEng,
                                 HOOK_COPYBITS | HOOK_BITBLT,
                                 0,         // It's system-memory
                                 (DHSURF) pdsurf,
                                 pvScan0,
                                 lDelta,
                                 NULL))
            {
                // First, copy the bits from off-screen memory to the DIB:

                rclDst.left   = 0;
                rclDst.top    = 0;
                rclDst.right  = pdsurf->cx;
                rclDst.bottom = pdsurf->cy;


                ptlSrc.x = pdsurf->x;
                ptlSrc.y = pdsurf->y;

                soTmp.lDelta  = lDelta;
                soTmp.pvScan0 = pvScan0;

                vGetBits(ppdev, &soTmp, &rclDst, &ptlSrc);

                // Now free the off-screen memory:

                VidMemFree(pdsurf->pvmHeap->lpHeap, pdsurf->fpVidMem);

                // Remove this node from the discardable list:

                ASSERTDD(ppdev->pdsurfDiscardableList == pdsurf,
                    "Expected node to be head of the list");

                ppdev->pdsurfDiscardableList  = pdsurf->pdsurfDiscardableNext;

                pdsurf->pdsurfDiscardableNext = NULL;
                pdsurf->dt                    = DT_DIB;
                pdsurf->pvScan0               = pvScan0;

                return(TRUE);
            }

            EngFreeMem(pvScan0);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bMoveEverythingFromOffscreenToDibs
*
* This function is used when we're about to enter full-screen mode, which
* would wipe all our off-screen bitmaps.  GDI can ask us to draw on
* device bitmaps even when we're in full-screen mode, and we do NOT have
* the option of stalling the call until we switch out of full-screen.
* We have no choice but to move all the off-screen DFBs to DIBs.
*
* Returns TRUE if all DSURFs have been successfully moved.
*
\**************************************************************************/

BOOL bMoveAllDfbsFromOffscreenToDibs(
PDEV*   ppdev)
{
    do {} while (bMoveOldestOffscreenDfbToDib(ppdev));

    return(ppdev->pdsurfDiscardableList == NULL);
}

/******************************Public*Routine******************************\
* BOOL bMoveDibToOffscreenDfbIfRoom
*
\**************************************************************************/

BOOL bMoveDibToOffscreenDfbIfRoom(
PDEV*   ppdev,
DSURF*  psurf)
{
    return(FALSE);
}

/******************************Public*Routine******************************\
* HBITMAP DrvCreateDeviceBitmap
*
* Function called by GDI to create a device-format-bitmap (DFB).  We will
* always try to allocate the bitmap in off-screen; if we can't, we simply
* fail the call and GDI will create and manage the bitmap itself.
*
* Note: We do not have to zero the bitmap bits.  GDI will automatically
*       call us via DrvBitBlt to zero the bits (which is a security
*       consideration).
*
\**************************************************************************/

HBITMAP DrvCreateDeviceBitmap(
DHPDEV  dhpdev,
SIZEL   sizl,
ULONG   iFormat)
{
    PDEV*   ppdev;
    DSURF*  pdsurf;
    HBITMAP hbmDevice;
    BYTE*   pjSurface;
    LONG    lDelta;
    FLONG   flHooks;
    DSURF*  pTmp;

    ppdev = (PDEV*) dhpdev;

    // If we're in full-screen mode, we hardly have any off-screen memory
    // in which to allocate a DFB.

    if (!ppdev->bEnabled)
        return(0);

    // We only support device bitmaps that are the same colour depth
    // as our display.
    //
    // Actually, those are the only kind GDI will ever call us with,
    // but we may as well check.  Note that this implies you'll never
    // get a crack at 1bpp bitmaps.
    // Note: we can't create a device bitmap when the color depth is 24
    // BPP. Otherwise, we will have problem in vBankStart when we hack the
    // pbnk->pso->pvScan0 = ppdev->pjScreen - cjOffset
    //             + yOffset * ppdev->lDelta
    //             + CONVERT_TO_BYTES(xOffset, ppdev);
    // this pvScan0 is not guaranteed be DWORD aligned

    if ( (iFormat != ppdev->iBitmapFormat)
       ||(iFormat == BMF_24BPP) )
        return(0);

    // We don't want anything 8x8 or smaller -- they're typically brush
    // patterns which we don't particularly want to stash in off-screen
    // memory.
    //
    // Note if you're tempted to extend this philosophy to surfaces
    // larger than 8x8: in NT5, software cursors will use device-bitmaps
    // when possible, which is a big win when they're in video-memory
    // because we avoid the horrendous reads from video memory whenever
    // the cursor has to be redrawn.  But the problem is that these
    // are small!  (Typically 16x16 to 32x32.)

    if ((sizl.cx <= 8) && (sizl.cy <= 8))
        return(0);

    do {
        pdsurf = pVidMemAllocate(ppdev, sizl.cx, sizl.cy);
        if (pdsurf != NULL)
        {
            hbmDevice = EngCreateDeviceBitmap((DHSURF) pdsurf, sizl, iFormat);
            if (hbmDevice != NULL)
            {
                // If we're running on a card that can map all of off-screen
                // video-memory, give a pointer to the bits to GDI so that
                // it can draw directly on the bits when it wants to.
                //
                // Note that this requires that we hook DrvSynchronize and
                // set HOOK_SYNCHRONIZE.

                if ((ppdev->flCaps & CAPS_NEW_MMIO) &&
                    !(ppdev->flCaps & CAPS_NO_DIRECT_ACCESS))
                {
                    pjSurface = pdsurf->fpVidMem + ppdev->pjScreen;
                    lDelta    = ppdev->lDelta;
                    flHooks   = ppdev->flHooks | HOOK_SYNCHRONIZE;
                }
                else
                {
                    pjSurface = NULL;
                    lDelta    = 0;
                    flHooks   = ppdev->flHooks;
                }

                if (EngModifySurface((HSURF) hbmDevice,
                                     ppdev->hdevEng,
                                     flHooks,
                                     MS_NOTSYSTEMMEMORY,    // It's video-memory
                                     (DHSURF) pdsurf,
                                     pjSurface,
                                     lDelta,
                                     NULL))
                {
                    pdsurf->hsurf = (HSURF) hbmDevice;

                    // Add this to the tail of the discardable surface list:

                    if (ppdev->pdsurfDiscardableList == NULL)
                        ppdev->pdsurfDiscardableList = pdsurf;
                    else
                    {
                        for (pTmp = ppdev->pdsurfDiscardableList;
                             pTmp->pdsurfDiscardableNext != NULL;
                             pTmp = pTmp->pdsurfDiscardableNext)
                            ;

                        pTmp->pdsurfDiscardableNext = pdsurf;
                    }

                    return(hbmDevice);
                }

                EngDeleteSurface((HSURF) hbmDevice);
            }

            vVidMemFree(pdsurf);

            return(0);
        }
    } while (bMoveOldestOffscreenDfbToDib(ppdev));

    return(0);
}

/******************************Public*Routine******************************\
* HBITMAP DrvDeriveSurface
*
* This function is new to NT5, and allows the driver to accelerate any
* GDI drawing to a DirectDraw surface.
*
* Note the similarity of this function to DrvCreateDeviceBitmap.
*
\**************************************************************************/

HBITMAP DrvDeriveSurface(
DD_DIRECTDRAW_GLOBAL*   lpDirectDraw,
DD_SURFACE_LOCAL*       lpLocal)
{
    PDEV*               ppdev;
    DSURF*              pdsurf;
    HBITMAP             hbmDevice;
    DD_SURFACE_GLOBAL*  lpSurface;
    SIZEL               sizl;

    ppdev = (PDEV*) lpDirectDraw->dhpdev;

    lpSurface = lpLocal->lpGbl;

    // GDI should never call us for a non-RGB surface, but let's assert just
    // to make sure they're doing their job properly.

    ASSERTDD(!(lpSurface->ddpfSurface.dwFlags & DDPF_FOURCC),
        "GDI called us with a non-RGB surface!");

    // The rest of our driver expects GDI calls to come in with the same
    // format as the primary surface.  So we'd better not wrap a device
    // bitmap around an RGB format that the rest of our driver doesn't
    // understand.  Also, we must check to see that it is not a surface
    // whose pitch does not match the primary surface.

    // NOTE: Most surfaces created by this driver are allocated as 2D surfaces
    // whose lPitch's are equal to the screen pitch.  However, overlay surfaces
    // are allocated such that there lPitch's are usually different then the 
    // screen pitch.  The hardware can not accelerate drawing operations to 
    // these surfaces and thus we fail to derive these surfaces.


    if (lpSurface->ddpfSurface.dwRGBBitCount == (DWORD) ppdev->cjPelSize * 8 &&
        lpSurface->lPitch == ppdev->lDelta)
    {
        pdsurf = EngAllocMem(FL_ZERO_MEMORY, sizeof(DSURF), ALLOC_TAG);
        if (pdsurf != NULL)
        {
            sizl.cx = lpSurface->wWidth;
            sizl.cy = lpSurface->wHeight;

            hbmDevice = EngCreateDeviceBitmap((DHSURF) pdsurf,
                                              sizl,
                                              ppdev->iBitmapFormat);
            if (hbmDevice != NULL)
            {
                // Note that HOOK_SYNCHRONIZE must always be hooked when
                // we give GDI a pointer to the bitmap bits.

                if (EngModifySurface((HSURF) hbmDevice,
                                     ppdev->hdevEng,
                                     ppdev->flHooks | HOOK_SYNCHRONIZE,
                                     MS_NOTSYSTEMMEMORY,    // It's video-memory
                                     (DHSURF) pdsurf,
                                     ppdev->pjScreen + lpSurface->fpVidMem,
                                     lpSurface->lPitch,
                                     NULL))
                {
                    pdsurf->dt          = DT_DIRECTDRAW;
                    pdsurf->ppdev       = ppdev;
                    pdsurf->x           = lpSurface->xHint;
                    pdsurf->y           = lpSurface->yHint;
                    pdsurf->cx          = lpSurface->wWidth;
                    pdsurf->cy          = lpSurface->wHeight;
                    pdsurf->fpVidMem    = lpSurface->fpVidMem;

                    return(hbmDevice);
                }

                EngDeleteSurface((HSURF) hbmDevice);
            }

            EngFreeMem(pdsurf);
        }
    }

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDeleteDeviceBitmap
*
* Deletes a DFB.
*
\**************************************************************************/

VOID DrvDeleteDeviceBitmap(
DHSURF  dhsurf)
{
    DSURF*  pdsurf;
    PDEV*   ppdev;
    DSURF*  pTmp;

    pdsurf = (DSURF*) dhsurf;

    ppdev = pdsurf->ppdev;

    if ((pdsurf->dt & (DT_DIB | DT_DIRECTDRAW)) == 0)
    {
        // It's a surface stashed in video memory, so we have to remove
        // it from the discardable surface list:

        if (ppdev->pdsurfDiscardableList == pdsurf)
            ppdev->pdsurfDiscardableList = pdsurf->pdsurfDiscardableNext;
        else
        {
            for (pTmp = ppdev->pdsurfDiscardableList;
                 pTmp->pdsurfDiscardableNext != pdsurf;
                 pTmp = pTmp->pdsurfDiscardableNext)
                ;

            pTmp->pdsurfDiscardableNext = pdsurf->pdsurfDiscardableNext;
        }
    }

    vVidMemFree(pdsurf);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeOffscreenHeap
*
* This function is called whenever we switch in or out of full-screen
* mode.  We have to convert all the off-screen bitmaps to DIBs when
* we switch to full-screen (because we may be asked to draw on them even
* when in full-screen, and the mode switch would probably nuke the video
* memory contents anyway).
*
\**************************************************************************/

BOOL bAssertModeOffscreenHeap(
PDEV*   ppdev,
BOOL    bEnable)
{
    BOOL b;

    b = TRUE;

    if (!bEnable)
    {
        b = bMoveAllDfbsFromOffscreenToDibs(ppdev);
    }

    return(b);
}

/******************************Public*Routine******************************\
* VOID vDisableOffscreenHeap
*
* Frees any resources allocated by the off-screen heap.
*
\**************************************************************************/

VOID vDisableOffscreenHeap(
PDEV*   ppdev)
{
    SURFOBJ* psoPunt;
    HSURF    hsurf;

    psoPunt = ppdev->psoPunt;
    if (psoPunt != NULL)
    {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
    }

    psoPunt = ppdev->psoPunt2;
    if (psoPunt != NULL)
    {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
    }
}

/******************************Public*Routine******************************\
* BOOL bEnableOffscreenHeap
*
* Initializes the off-screen heap using all available video memory,
* accounting for the portion taken by the visible screen.
*
\**************************************************************************/

BOOL bEnableOffscreenHeap(
PDEV*   ppdev)
{
    SIZEL   sizl;
    HSURF   hsurf;

    // Allocate a 'punt' SURFOBJ we'll use when the device-bitmap is in
    // off-screen memory, but we want GDI to draw to it directly as an
    // engine-managed surface:

    sizl.cx = ppdev->cxMemory;
    sizl.cy = ppdev->cyMemory;

    // We want to create it with exactly the same hooks and capabilities
    // as our primary surface.  We will override the 'lDelta' and 'pvScan0'
    // fields later:

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    0xbadf00d,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    (VOID*) 0xbadf00d);

    // We don't want GDI to turn around and call any of our Drv drawing
    // functions when drawing to these surfaces, so always set the hooks
    // to '0':

    if ((hsurf == 0)                                     ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0)) ||
        (!(ppdev->psoPunt = EngLockSurface(hsurf))))
    {
        DISPDBG((1, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
    }

    // We don't want GDI to turn around and call any of our Drv drawing
    // functions when drawing to these surfaces, so always set the hooks
    // to '0':

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    0xbadf00d,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    (VOID*) 0xbadf00d);

    // We don't want GDI to call us back when drawing to these surfaces,
    // so always set the hooks to '0':

    if ((hsurf == 0)                                     ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0)) ||
        (!(ppdev->psoPunt2 = EngLockSurface(hsurf))))
    {
        DISPDBG((1, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
    }

    DISPDBG((5, "Passed bEnableOffscreenHeap"));

    return(TRUE);

ReturnFalse:

    DISPDBG((1, "Failed bEnableOffscreenHeap"));

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\fillpath.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: fillpath.c
*
* Contains the DrvFillPath routine.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// Int32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit LONGs to produce a 64-bit LONGLONG result.
//      I use it because it is much faster than 64x64 multiplies.

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define TAKING_ALLOC_STATS  0

#define NUM_BUFFER_POINTS   96      // Maximum number of points in a path
                                    //   for which we'll attempt to join
                                    //   all the path records so that the
                                    //   path may still be drawn by FastFill

#if TAKING_ALLOC_STATS
    ULONG BufferHitInFillpath = 0;
    ULONG BufferMissInFillpath = 0;
#endif

// Describe a single non-horizontal edge of a path to fill.
typedef struct _EDGE {
    PVOID pNext;
    INT iScansLeft;
    INT X;
    INT Y;
    INT iErrorTerm;
    INT iErrorAdjustUp;
    INT iErrorAdjustDown;
    INT iXWhole;
    INT iXDirection;
    INT iWindingDirection;
} EDGE, *PEDGE;

// Maximum number of rects we'll fill per call to
// the fill code
#define MAX_PATH_RECTS  50
#define RECT_BYTES      (MAX_PATH_RECTS * sizeof(RECTL))
#define EDGE_BYTES      (TMP_BUFFER_SIZE - RECT_BYTES)
#define MAX_EDGES       (EDGE_BYTES/sizeof(EDGE))

VOID AdvanceAETEdges(EDGE *pAETHead);
VOID XSortAETEdges(EDGE *pAETHead);
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY);
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge, POINTFIX *ppfxEdgeStart,
        POINTFIX *ppfxEdgeEnd, RECTL *pClipRect);
BOOL ConstructGET(EDGE *pGETHead, EDGE *pFreeEdges, PATHOBJ *ppo,
        PATHDATA *pd, BOOL bMore, RECTL *pClipRect);
void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection);

/******************************Public*Routine******************************\
* DrvFillPath
*
* Fill the specified path with the specified brush and ROP.  This routine
* detects single convex polygons, and will call to separate faster convex
* polygon code for those cases.  This routine also detects polygons that
* are really rectangles, and handles those separately as well.
*
* Note: Multiple polygons in a path cannot be treated as being disjoint;
*       the fill must consider all the points in the path.  That is, if the
*       path contains multiple polygons, you cannot simply draw one polygon
*       after the other (unless they don't overlap).
*
* Note: This function is optional, but is recommended for good performance.
*       To get GDI to call this function, not only do you have to
*       HOOK_FILLPATH, you have to set GCAPS_ALTERNATEFILL and/or
*       GCAPS_WINDINGFILL.
*
\**************************************************************************/

BOOL DrvFillPath(
SURFOBJ*    pso,
PATHOBJ*    ppo,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
MIX         mix,
FLONG       flOptions)
{
    BYTE jClipping;     // clipping type
    EDGE *pCurrentEdge;
    EDGE AETHead;       // dummy head/tail node & sentinel for Active Edge Table
    EDGE *pAETHead;     // pointer to AETHead
    EDGE GETHead;       // dummy head/tail node & sentinel for Global Edge Table
    EDGE *pGETHead;     // pointer to GETHead
    EDGE *pFreeEdges;   // pointer to memory free for use to store edges
    ULONG ulNumRects;   // # of rectangles to draw currently in rectangle list
    RECTL *prclRects;   // pointer to start of rectangle draw list
    INT iCurrentY;      // scan line for which we're currently scanning out the
                        //  fill

    ULONG        rop4;              // rop4 for brush
    RBRUSH_COLOR rbc;               // Realized brush or solid color
    ULONG        iSolidColor;       // Copy of pbo->iSolidColor
    FNFILL      *pfnFill;           // Points to appropriate fill routine
    BOOL         bRealizeTransparent; // Need a transparent realization for Rop

    BOOL         bMore;
    PATHDATA     pd;
    RECTL        ClipRect;
    PDEV        *ppdev;
    DSURF       *pdsurf;
    RECTL*       prclClip;

    BOOL         bRetVal=FALSE;     // FALSE until proven TRUE
    BOOL         bMemAlloced=FALSE; // FALSE until proven TRUE

    FLONG        flFirstRecord;
    POINTFIX*    pptfxTmp;
    ULONG        cptfxTmp;
    RECTFX       rcfxBounds;
    POINTFIX     aptfxBuf[NUM_BUFFER_POINTS];

    // Set up the clipping
    if (pco == (CLIPOBJ *) NULL) {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    } else {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    if (jClipping != DC_TRIVIAL) {
        if (jClipping != DC_RECT) {
            goto ReturnFalse;  // there is complex clipping; let GDI fill the path
        }
        // Clip to the clip rectangle
        ClipRect = pco->rclBounds;
    } else {
        // So the y-clipping code doesn't do any clipping
        // /16 so we don't blow the values out when we scale up to GIQ
        ClipRect.top = (LONG_MIN + 1) / 16; // +1 to avoid compiler problem
        ClipRect.bottom = LONG_MAX / 16;
    }

    // There's nothing to do if there are only one or two points
    if (ppo->cCurves <= 2) {
        goto ReturnTrue;
    }

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;
    ppdev  = (PDEV*) pso->dhpdev;

    ASSERTDD(!(pdsurf->dt & DT_DIB), "Didn't expect DT_DIB");

    // We'll be drawing to the screen or an off-screen DFB; copy the surface's
    // offset now so that we won't need to refer to the DSURF again:

    ppdev->xOffset = pdsurf->x;
    ppdev->yOffset = pdsurf->y;

    pfnFill = ppdev->pfnFillSolid;
    iSolidColor = 0;                            // Assume we won't need a pattern
    bRealizeTransparent = FALSE;

    rop4 = (gaRop3FromMix[mix >> 8] << 8) | gaRop3FromMix[mix & 0xff];

    if ((((rop4 & 0xff00) >> 8) != (rop4 & 0x00ff)) ||
        ((((rop4 >> 4) ^ (rop4)) & 0xf0f) != 0))  // Only do if we need a pattern
    {
        // Prevent 24bpp and transparent from calling vMmFastPatRealize.
        // This supports s3 968 workaround.
        bRealizeTransparent = (((rop4 >> 8) & 0xff) != (rop4 & 0xff));

        if ((ppdev->iBitmapFormat == BMF_24BPP) && bRealizeTransparent)
            return FALSE;

        iSolidColor     = pbo->iSolidColor;
        rbc.iSolidColor = iSolidColor;
        if (iSolidColor == -1)
        {
            rbc.prb = pbo->pvRbrush;
            if (rbc.prb == NULL)
            {
                rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                if (rbc.prb == NULL)
                    return(FALSE);
            }
            pfnFill = ppdev->pfnFillPat;
        }
    }

    // Enumerate path here first time to check for special
    // cases (rectangles and monotone polygons)

    // It is too difficult to determine interaction between
    // multiple paths, if there is more than one, skip this

    PATHOBJ_vEnumStart(ppo);
    bMore = PATHOBJ_bEnum(ppo, &pd);

    {
        prclClip = NULL;
        if (jClipping == DC_RECT)
        {
            prclClip = &ClipRect;

            // Our FastFill routine does cross products and intersection
            // calculations assuming it can use 32 bit math and not
            // overflow.  As such, we have to ensure that the bounds of
            // the polygon fit in a 15 bit space, including the 4 bit fix
            // point fraction.  Note that we don't have to do this check
            // for trivial clipping, because we'll assume the screen
            // dimensions are 2048 x 2048 or smaller.  Plus, since we're
            // using hardware clipping to handle 'x' clipping, we have to
            // ensure that the 'x' coordinates are within reasonable bounds:

            PATHOBJ_vGetBounds(ppo, &rcfxBounds);

            // Don't forget that coordinates are in 28.4 format, so multiply
            // constants by 16:

            if ((rcfxBounds.xLeft   < F * MIN_INTEGER_BOUND) ||
                (rcfxBounds.yTop    < F * MIN_INTEGER_BOUND) ||
                (rcfxBounds.xRight  > F * MAX_INTEGER_BOUND) ||
                (rcfxBounds.yBottom > F * MAX_INTEGER_BOUND))
                goto SkipFastFill;
        }

        // Try going through the fast non-complex fill code.  We'll have
        // to realize the brush first if we're going to handle a pattern:

        if (iSolidColor == -1)
        {
            // We handle patterns in 'pfnFastFill' only if we can use the S3
            // hardware patterns.

            if (!(ppdev->flCaps & CAPS_HW_PATTERNS))
                goto SkipFastFill;

            // Note: prb->pbe will be NULL and prb->ptlBrushOrg.x will be -1 the
            //       first time an RBRUSH is used.  So we have to check the
            //       alignment *before* dereferencing prb->pbe...

            if ((rbc.prb->ptlBrushOrg.x != pptlBrush->x + ppdev->xOffset) ||
                (rbc.prb->ptlBrushOrg.y != pptlBrush->y + ppdev->yOffset) ||
                (rbc.prb->pbe->prbVerify != rbc.prb)                      ||
                (rbc.prb->bTransparent != bRealizeTransparent)            ||
                (ppdev->flCaps & CAPS_RE_REALIZE_PATTERN))
            {
                ppdev->pfnFastPatRealize(ppdev, rbc.prb, pptlBrush,
                                         bRealizeTransparent);
            }
        }

        if (bMore)
        {
            // FastFill only knows how to take a single contiguous buffer
            // of points.  Unfortunately, GDI sometimes hands us paths
            // that are split over multiple path data records.  Convex
            // figures such as Ellipses, Pies and RoundRects are almost
            // always given in multiple records.  Since probably 90% of
            // multiple record paths could still be done by FastFill, for
            // those cases we simply copy the points into a contiguous
            // buffer...

            // First make sure that the entire path would fit in the
            // temporary buffer, and make sure the path isn't comprised
            // of more than one subpath:

            if ((ppo->cCurves >= NUM_BUFFER_POINTS) ||
                (pd.flags & PD_ENDSUBPATH))
                goto SkipFastFill;

            pptfxTmp = &aptfxBuf[0];

            RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);

            pptfxTmp     += pd.count;
            cptfxTmp      = pd.count;
            flFirstRecord = pd.flags;       // Remember PD_BEGINSUBPATH flag

            do {
                bMore = PATHOBJ_bEnum(ppo, &pd);

                RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);
                cptfxTmp += pd.count;
                pptfxTmp += pd.count;
            } while (!(pd.flags & PD_ENDSUBPATH));

            // Fake up the path data record:

            pd.pptfx  = &aptfxBuf[0];
            pd.count  = cptfxTmp;
            pd.flags |= flFirstRecord;

            // If there's more than one subpath, we can't call FastFill:

            if (bMore)
                goto SkipFastFill;
        }

        if (bFastFill(ppdev, pd.count, pd.pptfx, rop4, iSolidColor, rbc.prb,
                      pptlBrush, prclClip))
        {
            return(TRUE);
        }
    }

SkipFastFill:

    // Set up working storage in the temporary buffer

    prclRects = (RECTL*) ppdev->pvTmpBuffer; // storage for list of rectangles to draw

    if (!bMore) {

        RECTL *rectangle;
        INT cPoints = pd.count;

        // The count can't be less than three, because we got all the edges
        // in this subpath, and above we checked that there were at least
        // three edges

        // If the count is four, check to see if the polygon is really a
        // rectangle since we can really speed that up. We'll also check for
        // five with the first and last points the same, because under Win 3.1,
        // it was required to close polygons

        if ((cPoints == 4) ||
           ((cPoints == 5) &&
            (pd.pptfx[0].x == pd.pptfx[4].x) &&
            (pd.pptfx[0].y == pd.pptfx[4].y))) {

            rectangle = prclRects;

      /* we have to start somewhere so assume that most
         applications specify the top left point  first

         we want to check that the first two points are
         either vertically or horizontally aligned.  if
         they are then we check that the last point [3]
         is either horizontally or  vertically  aligned,
         and finally that the 3rd point [2] is  aligned
         with both the first point and the  last  point */

#define FIX_SHIFT 4L
#define FIX_MASK (- (1 << FIX_SHIFT))

         rectangle->top   = pd.pptfx[0].y - 1 & FIX_MASK;
         rectangle->left  = pd.pptfx[0].x - 1 & FIX_MASK;
         rectangle->right = pd.pptfx[1].x - 1 & FIX_MASK;

         if (rectangle->left ^ rectangle->right) {
            if (rectangle->top  ^ (pd.pptfx[1].y - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->left ^ (pd.pptfx[3].x - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->right ^ (pd.pptfx[2].x - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[2].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;
         }
         else {
            if (rectangle->top ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[1].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[2].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->right = pd.pptfx[2].x - 1 & FIX_MASK;
            if (rectangle->right ^ (pd.pptfx[3].x - 1 & FIX_MASK))
                goto not_rectangle;
         }

      /* if the left is greater than the right then
         swap them so the blt code doesn't wig  out */

         if (rectangle->left > rectangle->right) {
            FIX temp;

            temp = rectangle->left;
            rectangle->left = rectangle->right;
            rectangle->right = temp;
         }
         else {

         /* if left == right there's nothing to draw */

            if (rectangle->left == rectangle->right) {
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->left  = (rectangle->left  >> FIX_SHIFT) + 1;
         rectangle->right = (rectangle->right >> FIX_SHIFT) + 1;

         if (rectangle->top > rectangle->bottom) {
            FIX temp;

            temp = rectangle->top;
            rectangle->top = rectangle->bottom;
            rectangle->bottom = temp;
         }
         else {
            if (rectangle->top == rectangle->bottom) {
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->top    = (rectangle->top    >> FIX_SHIFT) + 1;
         rectangle->bottom = (rectangle->bottom >> FIX_SHIFT) + 1;

         // Finally, check for clipping
         if (jClipping == DC_RECT) {
            // Clip to the clip rectangle
            if (!bIntersect(rectangle, &ClipRect, rectangle)) {
                // Totally clipped, nothing to do
                goto ReturnTrue;
            }
         }

      /* if we get here then the polygon is a rectangle,
         set count to 1 and  goto  bottom  to  draw  it */

         ulNumRects = 1;
         goto draw_remaining_rectangles;
      }

not_rectangle:

        ;

    }

    // Do we have enough memory for all the edges?
    // LATER does cCurves include closure?
    if (ppo->cCurves > MAX_EDGES) {
#if TAKING_ALLOC_STATS
            BufferMissInFillpath++;
#endif
        //
        // try to allocate enough memory
        //
        pFreeEdges = EngAllocMem(0, ppo->cCurves * sizeof(EDGE), ALLOC_TAG);

        if (pFreeEdges == NULL)
        {
            goto ReturnFalse;  // too many edges; let GDI fill the path
        }
        else
        {
            bMemAlloced = TRUE;
        }
    }
    else {
#if TAKING_ALLOC_STATS
            BufferHitInFillpath++;
#endif
        pFreeEdges = (EDGE*) ((BYTE*) ppdev->pvTmpBuffer + RECT_BYTES);
            // use our handy temporary buffer (it's big enough)
    }

    // Initialize an empty list of rectangles to fill
    ulNumRects = 0;

    // Enumerate the path edges and build a Global Edge Table (GET) from them
    // in YX-sorted order.
    pGETHead = &GETHead;
    if (!ConstructGET(pGETHead, pFreeEdges, ppo, &pd, bMore, &ClipRect)) {
        goto ReturnFalse;  // outside GDI's 2**27 range
    }

    // Create an empty AET with the head node also a tail sentinel
    pAETHead = &AETHead;
    AETHead.pNext = pAETHead;  // mark that the AET is empty
    AETHead.X = 0x7FFFFFFF;    // this is greater than any valid X value, so
                               //  searches will always terminate

    // Top scan of polygon is the top of the first edge we come to
    iCurrentY = ((EDGE *)GETHead.pNext)->Y;

    // Loop through all the scans in the polygon, adding edges from the GET to
    // the Active Edge Table (AET) as we come to their starts, and scanning out
    // the AET at each scan into a rectangle list. Each time it fills up, the
    // rectangle list is passed to the filling routine, and then once again at
    // the end if any rectangles remain undrawn. We continue so long as there
    // are edges to be scanned out
    while (1) {

        // Advance the edges in the AET one scan, discarding any that have
        // reached the end (if there are any edges in the AET)
        if (AETHead.pNext != pAETHead) {
            AdvanceAETEdges(pAETHead);
        }

        // If the AET is empty, done if the GET is empty, else jump ahead to
        // the next edge in the GET; if the AET isn't empty, re-sort the AET
        if (AETHead.pNext == pAETHead) {
            if (GETHead.pNext == pGETHead) {
                // Done if there are no edges in either the AET or the GET
                break;
            }
            // There are no edges in the AET, so jump ahead to the next edge in
            // the GET
            iCurrentY = ((EDGE *)GETHead.pNext)->Y;
        } else {
            // Re-sort the edges in the AET by X coordinate, if there are at
            // least two edges in the AET (there could be one edge if the
            // balancing edge hasn't yet been added from the GET)
            if (((EDGE *)AETHead.pNext)->pNext != pAETHead) {
                XSortAETEdges(pAETHead);
            }
        }

        // Move any new edges that start on this scan from the GET to the AET;
        // bother calling only if there's at least one edge to add
        if (((EDGE *)GETHead.pNext)->Y == iCurrentY) {
            MoveNewEdges(pGETHead, pAETHead, iCurrentY);
        }

        // Scan the AET into rectangles to fill (there's always at least one
        // edge pair in the AET)
        pCurrentEdge = AETHead.pNext;   // point to the first edge
        do {

            INT iLeftEdge;

            // The left edge of any given edge pair is easy to find; it's just
            // wherever we happen to be currently
            iLeftEdge = pCurrentEdge->X;

            // Find the matching right edge according to the current fill rule
            if ((flOptions & FP_WINDINGMODE) != 0) {

                INT iWindingCount;

                // Do winding fill; scan across until we've found equal numbers
                // of up and down edges
                iWindingCount = pCurrentEdge->iWindingDirection;
                do {
                    pCurrentEdge = pCurrentEdge->pNext;
                    iWindingCount += pCurrentEdge->iWindingDirection;
                } while (iWindingCount != 0);
            } else {
                // Odd-even fill; the next edge is the matching right edge
                pCurrentEdge = pCurrentEdge->pNext;
            }

            // See if the resulting span encompasses at least one pixel, and
            // add it to the list of rectangles to draw if so
            if (iLeftEdge < pCurrentEdge->X) {

                // We've got an edge pair to add to the list to be filled; see
                // if there's room for one more rectangle
                if (ulNumRects >= MAX_PATH_RECTS) {
                    // No more room; draw the rectangles in the list and reset
                    // it to empty

                    (*pfnFill)(ppdev, ulNumRects, prclRects, rop4, rbc,
                               pptlBrush);

                    // Reset the list to empty
                    ulNumRects = 0;
                }

                // Add the rectangle representing the current edge pair
                if (jClipping == DC_RECT) {
                    // Clipped
                    // Clip to left
                    prclRects[ulNumRects].left = max(iLeftEdge, ClipRect.left);
                    // Clip to right
                    prclRects[ulNumRects].right =
                            min(pCurrentEdge->X, ClipRect.right);
                    // Draw only if not fully clipped
                    if (prclRects[ulNumRects].left <
                            prclRects[ulNumRects].right) {
                        prclRects[ulNumRects].top = iCurrentY;
                        prclRects[ulNumRects].bottom = iCurrentY+1;
                        ulNumRects++;
                    }
                }
                else
                {
                    // Unclipped
                    prclRects[ulNumRects].top = iCurrentY;
                    prclRects[ulNumRects].bottom = iCurrentY+1;
                    prclRects[ulNumRects].left = iLeftEdge;
                    prclRects[ulNumRects].right = pCurrentEdge->X;
                    ulNumRects++;
                }
            }
        } while ((pCurrentEdge = pCurrentEdge->pNext) != pAETHead);

        iCurrentY++;    // next scan
    }

/* draw the remaining rectangles,  if there are any */

draw_remaining_rectangles:

    if (ulNumRects > 0) {
        (*pfnFill)(ppdev, ulNumRects, prclRects, rop4, rbc, pptlBrush);
    }

ReturnTrue:
    bRetVal = TRUE; // done successfully

ReturnFalse:

    // bRetVal is originally false.  If you jumped to ReturnFalse from somewhere,
    // then it will remain false, and be returned.

    if (bMemAlloced)
    {
        //
        // we did allocate memory, so release it
        //
        EngFreeMem (pFreeEdges);
    }

    return(bRetVal);
}

// Advance the edges in the AET to the next scan, dropping any for which we've
// done all scans. Assumes there is at least one edge in the AET.
VOID AdvanceAETEdges(EDGE *pAETHead)
{
    EDGE *pLastEdge, *pCurrentEdge;

    pLastEdge = pAETHead;
    pCurrentEdge = pLastEdge->pNext;
    do {

        // Count down this edge's remaining scans
        if (--pCurrentEdge->iScansLeft == 0) {
            // We've done all scans for this edge; drop this edge from the AET
            pLastEdge->pNext = pCurrentEdge->pNext;
        } else {
            // Advance the edge's X coordinate for a 1-scan Y advance
            // Advance by the minimum amount
            pCurrentEdge->X += pCurrentEdge->iXWhole;
            // Advance the error term and see if we got one extra pixel this
            // time
            pCurrentEdge->iErrorTerm += pCurrentEdge->iErrorAdjustUp;
            if (pCurrentEdge->iErrorTerm >= 0) {
                // The error term turned over, so adjust the error term and
                // advance the extra pixel
                pCurrentEdge->iErrorTerm -= pCurrentEdge->iErrorAdjustDown;
                pCurrentEdge->X += pCurrentEdge->iXDirection;
            }

            pLastEdge = pCurrentEdge;
        }
    } while ((pCurrentEdge = pLastEdge->pNext) != pAETHead);
}

// X-sort the AET, because the edges may have moved around relative to
// one another when we advanced them. We'll use a multipass bubble
// sort, which is actually okay for this application because edges
// rarely move relative to one another, so we usually do just one pass.
// Also, this makes it easy to keep just a singly-linked list. Assumes there
// are at least two edges in the AET.
VOID XSortAETEdges(EDGE *pAETHead)
{
    BOOL bEdgesSwapped;
    EDGE *pLastEdge, *pCurrentEdge, *pNextEdge;

    do {

        bEdgesSwapped = FALSE;
        pLastEdge = pAETHead;
        pCurrentEdge = pLastEdge->pNext;
        pNextEdge = pCurrentEdge->pNext;

        do {
            if (pNextEdge->X < pCurrentEdge->X) {

                // Next edge is to the left of the current edge; swap them
                pLastEdge->pNext = pNextEdge;
                pCurrentEdge->pNext = pNextEdge->pNext;
                pNextEdge->pNext = pCurrentEdge;
                bEdgesSwapped = TRUE;
                pCurrentEdge = pNextEdge;   // continue sorting before the edge
                                            //  we just swapped; it might move
                                            //  farther yet
            }
            pLastEdge = pCurrentEdge;
            pCurrentEdge = pLastEdge->pNext;
        } while ((pNextEdge = pCurrentEdge->pNext) != pAETHead);
    } while (bEdgesSwapped);
}

// Moves all edges that start on the current scan from the GET to the AET in
// X-sorted order. Parameters are pointer to head of GET and pointer to dummy
// edge at head of AET, plus current scan line. Assumes there's at least one
// edge to be moved.
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY)
{
    EDGE *pCurrentEdge = pAETHead;
    EDGE *pGETNext = pGETHead->pNext;

    do {

        // Scan through the AET until the X-sorted insertion point for this
        // edge is found. We can continue from where the last search left
        // off because the edges in the GET are in X sorted order, as is
        // the AET. The search always terminates because the AET sentinel
        // is greater than any valid X
        while (pGETNext->X > ((EDGE *)pCurrentEdge->pNext)->X) {
            pCurrentEdge = pCurrentEdge->pNext;
        }

        // We've found the insertion point; add the GET edge to the AET, and
        // remove it from the GET
        pGETHead->pNext = pGETNext->pNext;
        pGETNext->pNext = pCurrentEdge->pNext;
        pCurrentEdge->pNext = pGETNext;
        pCurrentEdge = pGETNext;    // continue insertion search for the next
                                    //  GET edge after the edge we just added
        pGETNext = pGETHead->pNext;

    } while (pGETNext->Y == iCurrentY);
}





// Build the Global Edge Table from the path. There must be enough memory in
// the free edge area to hold all edges. The GET is constructed in Y-X order,
// and has a head/tail/sentinel node at pGETHead.

BOOL ConstructGET(
   EDGE     *pGETHead,
   EDGE     *pFreeEdges,
   PATHOBJ  *ppo,
   PATHDATA *pd,
   BOOL      bMore,
   RECTL    *pClipRect)
{
   POINTFIX pfxPathStart;    // point that started the current subpath
   POINTFIX pfxPathPrevious; // point before the current point in a subpath;
                              //  starts the current edge

/* Create an empty GET with the head node also a tail sentinel */

   pGETHead->pNext = pGETHead; // mark that the GET is empty
   pGETHead->Y = 0x7FFFFFFF;   // this is greater than any valid Y value, so
                                //  searches will always terminate

/* PATHOBJ_vEnumStart is implicitly  performed  by  engine
   already and first path  is  enumerated  by  the  caller */

next_subpath:

/* Make sure the PATHDATA is not empty (is this necessary) */

   if (pd->count != 0) {

   /* If first point starts a subpath, remember it as such
      and go on to the next point,   so we can get an edge */

      if (pd->flags & PD_BEGINSUBPATH) {

      /* the first point starts the subpath;   remember it */


         pfxPathStart    = *pd->pptfx; /* the subpath starts here          */
         pfxPathPrevious = *pd->pptfx; /* this points starts the next edge */
         pd->pptfx++;                  /* advance to the next point        */
         pd->count--;                  /* count off this point             */
      }


   /* add edges in PATHDATA to GET,  in Y-X  sorted  order */

      while (pd->count--) {
        if ((pFreeEdges =
            AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious, pd->pptfx,
                         pClipRect)) == NULL) {
            goto ReturnFalse;
        }
        pfxPathPrevious = *pd->pptfx; /* current point becomes previous   */
        pd->pptfx++;                  /* advance to the next point        */
      }


   /* If last point ends the subpath, insert the edge that
      connects to first point  (is this built in already?) */

      if (pd->flags & PD_ENDSUBPATH) {
         if ((pFreeEdges = AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious,
                                   &pfxPathStart, pClipRect)) == NULL) {
            goto ReturnFalse;
        }
      }
   }

/* the initial loop conditions preclude a do, while or for */

   if (bMore) {
       bMore = PATHOBJ_bEnum(ppo, pd);
       goto next_subpath;
   }

    return(TRUE);   // done successfully

ReturnFalse:
    return(FALSE);  // failed
}

// Adds the edge described by the two passed-in points to the Global Edge
// Table, if the edge spans at least one pixel vertically.
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge,
        POINTFIX *ppfxEdgeStart, POINTFIX *ppfxEdgeEnd, RECTL *pClipRect)
{
    INT iYStart, iYEnd, iXStart, iXEnd, iYHeight, iXWidth;
    INT yJump, yTop;

    // Set the winding-rule direction of the edge, and put the endpoints in
    // top-to-bottom order
    iYHeight = ppfxEdgeEnd->y - ppfxEdgeStart->y;
    if (iYHeight == 0) {
        return(pFreeEdge);  // zero height; ignore this edge
    } else if (iYHeight >= 0) {
        iXStart = ppfxEdgeStart->x;
        iYStart = ppfxEdgeStart->y;
        iXEnd = ppfxEdgeEnd->x;
        iYEnd = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = 1;
    } else {
        iYHeight = -iYHeight;
        iXEnd = ppfxEdgeStart->x;
        iYEnd = ppfxEdgeStart->y;
        iXStart = ppfxEdgeEnd->x;
        iYStart = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = -1;
    }

    if (iYHeight & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    // Set the error term and adjustment factors, all in GIQ coordinates for
    // now
    iXWidth = iXEnd - iXStart;
    if (iXWidth >= 0) {
        // Left to right, so we change X as soon as we move at all
        pFreeEdge->iXDirection = 1;
        pFreeEdge->iErrorTerm = -1;
    } else {
        // Right to left, so we don't change X until we've moved a full GIQ
        // coordinate
        iXWidth = -iXWidth;
        pFreeEdge->iXDirection = -1;
        pFreeEdge->iErrorTerm = -iYHeight;
    }

    if (iXWidth & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    if (iXWidth >= iYHeight) {
        // Calculate base run length (minimum distance advanced in X for a 1-
        // scan advance in Y)
        pFreeEdge->iXWhole = iXWidth / iYHeight;
        // Add sign back into base run length if going right to left
        if (pFreeEdge->iXDirection == -1) {
            pFreeEdge->iXWhole = -pFreeEdge->iXWhole;
        }
        pFreeEdge->iErrorAdjustUp = iXWidth % iYHeight;
    } else {
        // Base run length is 0, because line is closer to vertical than
        // horizontal
        pFreeEdge->iXWhole = 0;
        pFreeEdge->iErrorAdjustUp = iXWidth;
    }
    pFreeEdge->iErrorAdjustDown = iYHeight;

    // Calculate the number of pixels spanned by this edge, accounting for
    // clipping

    // Top true pixel scan in GIQ coordinates
    // Shifting to divide and multiply by 16 is okay because the clip rect
    // always contains positive numbers
    yTop = max(pClipRect->top << 4, (iYStart + 15) & ~0x0F);
    pFreeEdge->Y = yTop >> 4;    // initial scan line on which to fill edge

    // Calculate # of scans to actually fill, accounting for clipping
    if ((pFreeEdge->iScansLeft = min(pClipRect->bottom, ((iYEnd + 15) >> 4))
            - pFreeEdge->Y) <= 0) {

        return(pFreeEdge);  // no pixels at all are spanned, so we can
                            // ignore this edge
    }

    // If the edge doesn't start on a pixel scan (that is, it starts at a
    // fractional GIQ coordinate), advance it to the first pixel scan it
    // intersects. Ditto if there's top clipping. Also clip to the bottom if
    // needed

    if (iYStart != yTop) {
        // Jump ahead by the Y distance in GIQ coordinates to the first pixel
        // to draw
        yJump = yTop - iYStart;

        // Advance x the minimum amount for the number of scans traversed
        iXStart += pFreeEdge->iXWhole * yJump;

        AdjustErrorTerm(&pFreeEdge->iErrorTerm, pFreeEdge->iErrorAdjustUp,
                        pFreeEdge->iErrorAdjustDown, yJump, &iXStart,
                        pFreeEdge->iXDirection);
    }
    // Turn the calculations into pixel rather than GIQ calculations

    // Move the X coordinate to the nearest pixel, and adjust the error term
    // accordingly
    // Dividing by 16 with a shift is okay because X is always positive
    pFreeEdge->X = (iXStart + 15) >> 4; // convert from GIQ to pixel coordinates

    // LATER adjust only if needed (if prestepped above)?
    if (pFreeEdge->iXDirection == 1) {
        // Left to right
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                (((iXStart + 15) & ~0x0F) - iXStart);
    } else {
        // Right to left
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                ((iXStart - 1) & 0x0F);
    }

    // Scale the error term down 16 times to switch from GIQ to pixels.
    // Shifts work to do the multiplying because these values are always
    // non-negative
    pFreeEdge->iErrorTerm >>= 4;

    // Insert the edge into the GET in YX-sorted order. The search always ends
    // because the GET has a sentinel with a greater-than-possible Y value
    while ((pFreeEdge->Y > ((EDGE *)pGETHead->pNext)->Y) ||
            ((pFreeEdge->Y == ((EDGE *)pGETHead->pNext)->Y) &&
            (pFreeEdge->X > ((EDGE *)pGETHead->pNext)->X))) {
        pGETHead = pGETHead->pNext;
    }

    pFreeEdge->pNext = pGETHead->pNext; // link the edge into the GET
    pGETHead->pNext = pFreeEdge;

    return(++pFreeEdge);    // point to the next edge storage location for next
                            //  time
}

// Adjust the error term for a skip ahead in y. This is in ASM because there's
// a multiply/divide that may involve a larger than 32-bit value.

void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection)
{
#if defined(_X86_) || defined(_X86_)
    // Adjust the error term up by the number of y coordinates we'll skip
    //*pErrorTerm += iErrorAdjustUp * yJump;
    _asm    mov ebx,pErrorTerm
    _asm    mov eax,iErrorAdjustUp
    _asm    mul yJump
    _asm    add eax,[ebx]
    _asm    adc edx,-1      // the error term starts out negative

    // See if the error term turned over even once while skipping
    //if (*pErrorTerm >= 0) {
    _asm    js  short NoErrorTurnover

        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        // NumAdjustDowns = (*pErrorTerm / iErrorAdjustDown) + 1;
        _asm    div iErrorAdjustDown
        _asm    inc eax
        // Note that EDX is the remainder; (EDX - iErrorAdjustDown) is where
        // the error term ends up ultimately

        // Advance x appropriately for the # of times the error term
        // turned over
        // if (iXDirection == 1) {
        //     *pXStart += NumAdjustDowns;
        // } else {
        //     *pXStart -= NumAdjustDowns;
        // }
        _asm    mov ecx,pXStart
        _asm    cmp iXDirection,1
        _asm    jz  short GoingRight
        _asm    neg eax
GoingRight:
        _asm    add [ecx],eax

        // Adjust the error term down to its proper post-skip value
        // *pErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
        _asm    sub edx,iErrorAdjustDown
        _asm    mov eax,edx     // put into EAX for storing to pErrorTerm next
        // }
NoErrorTurnover:
        _asm    mov [ebx],eax
#else
    LONGLONG llErrorTerm;
    INT NumAdjustDowns;

    llErrorTerm = *pErrorTerm;

    // Adjust the error term up by the number of y coordinates we'll skip
    llErrorTerm += Int32x32To64(iErrorAdjustUp,yJump);

    // See if the error term turned over even once while skipping
    if (llErrorTerm >= 0) {
        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        NumAdjustDowns = (UInt64Div32To32(llErrorTerm,iErrorAdjustDown)) + 1;

        // Advance x appropriately for the # of times the error term
        // turned over
        if (iXDirection == 1) {
            *pXStart += NumAdjustDowns;
        } else {
            *pXStart -= NumAdjustDowns;
        }

        // Adjust the error term down to its proper post-skip value
        llErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
    }

    *pErrorTerm = (INT) llErrorTerm;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\enable.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: enable.c
*
* This module contains the functions that enable and disable the
* driver, the pdev, and the surface.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// Useful for visualizing the off-screen heap when set to '1':

#define DEBUG_HEAP 0

/******************************Public*Structure****************************\
* GDIINFO ggdiDefault
*
* This contains the default GDIINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

GDIINFO ggdiDefault = {
    GDI_DRIVER_VERSION,
    DT_RASDISPLAY,          // ulTechnology
    0,                      // ulHorzSize (filled in later)
    0,                      // ulVertSize (filled in later)
    0,                      // ulHorzRes (filled in later)
    0,                      // ulVertRes (filled in later)
    0,                      // cBitsPixel (filled in later)
    0,                      // cPlanes (filled in later)
    20,                     // ulNumColors (palette managed)
    0,                      // flRaster (DDI reserved field)

    0,                      // ulLogPixelsX (filled in later)
    0,                      // ulLogPixelsY (filled in later)

    TC_RA_ABLE,             // flTextCaps -- If we had wanted console windows
                            //   to scroll by repainting the entire window,
                            //   instead of doing a screen-to-screen blt, we
                            //   would have set TC_SCROLLBLT (yes, the flag is
                            //   bass-ackwards).

    0,                      // ulDACRed (filled in later)
    0,                      // ulDACGreen (filled in later)
    0,                      // ulDACBlue (filled in later)

    0x0024,                 // ulAspectX
    0x0024,                 // ulAspectY
    0x0033,                 // ulAspectXY (one-to-one aspect ratio)

    1,                      // xStyleStep
    1,                      // yStyleSte;
    3,                      // denStyleStep -- Styles have a one-to-one aspect
                            //   ratio, and every 'dot' is 3 pixels long

    { 0, 0 },               // ptlPhysOffset
    { 0, 0 },               // szlPhysSize

    256,                    // ulNumPalReg

    // These fields are for halftone initialization.  The actual values are
    // a bit magic, but seem to work well on our display.

    {                       // ciDevice
       { 6700, 3300, 0 },   //      Red
       { 2100, 7100, 0 },   //      Green
       { 1400,  800, 0 },   //      Blue
       { 1750, 3950, 0 },   //      Cyan
       { 4050, 2050, 0 },   //      Magenta
       { 4400, 5200, 0 },   //      Yellow
       { 3127, 3290, 0 },   //      AlignmentWhite
       20000,               //      RedGamma
       20000,               //      GreenGamma
       20000,               //      BlueGamma
       0, 0, 0, 0, 0, 0     //      No dye correction for raster displays
    },

    0,                       // ulDevicePelsDPI (for printers only)
    PRIMARY_ORDER_CBA,       // ulPrimaryOrder
    HT_PATSIZE_4x4_M,        // ulHTPatternSize
    HT_FORMAT_8BPP,          // ulHTOutputFormat
    HT_FLAG_ADDITIVE_PRIMS,  // flHTFlags
    0,                       // ulVRefresh
    0,                       // ulPanningHorzRes
    0,                       // ulPanningVertRes
    0,                       // ulBltAlignment
};

/******************************Public*Structure****************************\
* DEVINFO gdevinfoDefault
*
* This contains the default DEVINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       FIXED_PITCH | FF_DONTCARE, L"Courier"}

DEVINFO gdevinfoDefault = {
    (GCAPS_OPAQUERECT       |
     GCAPS_DITHERONREALIZE  |
     GCAPS_PALMANAGED       |
     GCAPS_ALTERNATEFILL    |
     GCAPS_WINDINGFILL      |
     GCAPS_MONO_DITHER      |
     GCAPS_COLOR_DITHER     |
     GCAPS_DIRECTDRAW       |
     GCAPS_ASYNCMOVE),          // NOTE: Only enable ASYNCMOVE if your code
                                //   and hardware can handle DrvMovePointer
                                //   calls at any time, even while another
                                //   thread is in the middle of a drawing
                                //   call such as DrvBitBlt.

                                                // flGraphicsFlags
    SYSTM_LOGFONT,                              // lfDefaultFont
    HELVE_LOGFONT,                              // lfAnsiVarFont
    COURI_LOGFONT,                              // lfAnsiFixFont
    0,                                          // cFonts
    BMF_8BPP,                                   // iDitherFormat
    8,                                          // cxDither
    8,                                          // cyDither
    0                                           // hpalDefault (filled in later)
};

/******************************Public*Structure****************************\
* DFVFN gadrvfn[]
*
* Build the driver function table gadrvfn with function index/address
* pairs.  This table tells GDI which DDI calls we support, and their
* location (GDI does an indirect call through this table to call us).
*
* Why haven't we implemented DrvSaveScreenBits?  To save code.
*
* When the driver doesn't hook DrvSaveScreenBits, USER simulates on-
* the-fly by creating a temporary device-format-bitmap, and explicitly
* calling DrvCopyBits to save/restore the bits.  Since we already hook
* DrvCreateDeviceBitmap, we'll end up using off-screen memory to store
* the bits anyway (which would have been the main reason for implementing
* DrvSaveScreenBits).  So we may as well save some working set.
\**************************************************************************/

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV            },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV          },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV           },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface         },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface        },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode            },
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer           },
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape       },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette            },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits              },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt                },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut               },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes              },
    {   INDEX_DrvLineTo,                (PFN) DrvLineTo                },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath            },
    {   INDEX_DrvFillPath,              (PFN) DrvFillPath              },
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush          },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap    },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap    },
    {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt            },
    {   INDEX_DrvDestroyFont,           (PFN) DrvDestroyFont           },
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DrvGetDirectDrawInfo     },
    {   INDEX_DrvEnableDirectDraw,      (PFN) DrvEnableDirectDraw      },
    {   INDEX_DrvDisableDirectDraw,     (PFN) DrvDisableDirectDraw     },
    {   INDEX_DrvSynchronize,           (PFN) DrvSynchronize           },
    {   INDEX_DrvTransparentBlt,        (PFN) DrvTransparentBlt        },
    {   INDEX_DrvDeriveSurface,         (PFN) DrvDeriveSurface         },
    {   INDEX_DrvIcmSetDeviceGammaRamp, (PFN) DrvIcmSetDeviceGammaRamp },
};

ULONG gcdrvfn = sizeof(gadrvfn) / sizeof(DRVFN);

/******************************Public*Routine******************************\
* BOOL DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    // Engine Version is passed down so future drivers can support previous
    // engine versions.  A next generation driver can support both the old
    // and new engine conventions if told what version of engine it is
    // working with.  For the first version the driver does nothing with it.

    // Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = gcdrvfn;

    // DDI version this driver was targeted for is passed back to engine.
    // Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    return;
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI, based on the mode we've been asked
* to do.  This is the first thing called after DrvEnableDriver, when GDI
* wants to get some information about us.
*
* (This function mostly returns back information; DrvEnableSurface is used
* for initializing the hardware and driver components.)
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW*   pdm,            // Contains data pertaining to requested mode
PWSTR       pwszLogAddr,    // Logical address
ULONG       cPat,           // Count of standard patterns
HSURF*      phsurfPatterns, // Buffer for standard patterns
ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
DEVINFO*    pdi,            // Device information
HDEV        hdev,           // HDEV, used for callbacks
PWSTR       pwszDeviceName, // Device name
HANDLE      hDriver)        // Kernel driver handle
{
    PDEV*   ppdev;

    // Future versions of NT had better supply 'devcaps' and 'devinfo'
    // structures that are the same size or larger than the current
    // structures:

    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
    {
        DISPDBG((0, "DrvEnablePDEV - Buffer size too small"));
        goto ReturnFailure0;
    }

    // Allocate a physical device structure.  Note that we definitely
    // rely on the zero initialization:

    ppdev = EngAllocMem(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG);
    if (ppdev == NULL)
    {
        DISPDBG((0, "DrvEnablePDEV - Failed EngAllocMem"));
        goto ReturnFailure0;
    }

    ppdev->hDriver = hDriver;

    // Get the current screen mode information.  Set up device caps and
    // devinfo:

    if (!bInitializeModeFields(ppdev, (GDIINFO*) pdevcaps, pdi, pdm))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializeModeFields"));
        goto ReturnFailure1;
    }

    // Initialize palette information.

    if (!bInitializePalette(ppdev, pdi))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializePalette"));
        goto ReturnFailure1;
    }

    return((DHPDEV) ppdev);

ReturnFailure1:
    DrvDisablePDEV((DHPDEV) ppdev);

ReturnFailure0:
    DISPDBG((0, "Failed DrvEnablePDEV"));

    return(0);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
* Note that this function will be called when previewing modes in the
* Display Applet, but not at system shutdown.  If you need to reset the
* hardware at shutdown, you can do it in the miniport by providing a
* 'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
*
* Note: In an error, we may call this before DrvEnablePDEV is done.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV  dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    vUninitializePalette(ppdev);
    EngFreeMem(ppdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    ((PDEV*) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* HSURF DrvEnableSurface
*
* Creates the drawing surface, initializes the hardware, and initializes
* driver components.  This function is called after DrvEnablePDEV, and
* performs the final device initialization.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;
    HSURF   hsurf;
    SIZEL   sizl;
    DSURF*  pdsurf;
    VOID*   pvTmpBuffer;
    BYTE*   pjScreen;
    LONG    lDelta;
    FLONG   flHooks;

    ppdev = (PDEV*) dhpdev;

    /////////////////////////////////////////////////////////////////////
    // First enable all the subcomponents.
    //
    // Note that the order in which these 'Enable' functions are called
    // may be significant in low off-screen memory conditions, because
    // the off-screen heap manager may fail some of the later
    // allocations...

    if (!bEnableHardware(ppdev))
        goto ReturnFailure;

    if (!bEnableBanking(ppdev))
        goto ReturnFailure;

    if (!bEnableOffscreenHeap(ppdev))
        goto ReturnFailure;

    if (!bEnablePointer(ppdev))
        goto ReturnFailure;

    if (!bEnableText(ppdev))
        goto ReturnFailure;

    if (!bEnableBrushCache(ppdev))
        goto ReturnFailure;

    if (!bEnablePalette(ppdev))
        goto ReturnFailure;

    if (!bEnableDirectDraw(ppdev))
        goto ReturnFailure;

    /////////////////////////////////////////////////////////////////////
    // Now create our private surface structure.
    //
    // Whenever we get a call to draw directly to the screen, we'll get
    // passed a pointer to a SURFOBJ whose 'dhpdev' field will point
    // to our PDEV structure, and whose 'dhsurf' field will point to the
    // following DSURF structure.
    //
    // Every device bitmap we create in DrvCreateDeviceBitmap will also
    // have its own unique DSURF structure allocated (but will share the
    // same PDEV).  To make our code more polymorphic for handling drawing
    // to either the screen or an off-screen bitmap, we have the same
    // structure for both.

    pdsurf = &ppdev->dsurfScreen;

    pdsurf->dt       = 0; 
    pdsurf->x        = 0;
    pdsurf->y        = 0;
    pdsurf->fpVidMem = 0;
    pdsurf->ppdev    = ppdev;

    /////////////////////////////////////////////////////////////////////
    // Next, have GDI create the actual surface SURFOBJ structure.

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    // Create the primary surface.  This defaults to a 'device-managed'
    // surface, but EngModifySurface can change that.

    hsurf = EngCreateDeviceSurface((DHSURF) pdsurf, 
                                   sizl, 
                                   ppdev->iBitmapFormat);
    if (hsurf == 0)
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngCreateDeviceSurface"));
        goto ReturnFailure;
    }

    if ((ppdev->flCaps & CAPS_NEW_MMIO) &&
        !(ppdev->flCaps & CAPS_NO_DIRECT_ACCESS))
    {
        // On all cards where we linearly map the frame buffer, create our 
        // drawing surface as a GDI-managed surface, meaning that we give
        // GDI a pointer to the framebuffer and GDI can draw on the bits
        // directly.  This will allow us good performance with drawing such 
        // as GradientFills, even though our hardware can't accelerate the 
        // drawing and so we don't hook DrvGradientFill.  This way GDI can 
        // do write-combined writes directly to the framebuffer and still be 
        // very fast.
        //
        // Note that this requires that we hook DrvSynchronize and
        // set HOOK_SYNCHRONIZE.

        pjScreen = ppdev->pjScreen;
        lDelta   = ppdev->lDelta;
        flHooks  = ppdev->flHooks | HOOK_SYNCHRONIZE;
    }
    else
    {
        // Ugh, we're running on an ancient S3 card where we can't completely
        // map the entire frame buffer into memory.  We have to create the
        // primary surface as a 'GDI-opaque' device-managed surface, and GDI
        // will be forced to go through only Drv calls that we've hooked.
        // (In this case, drawing such as GradientFills will be pathetically
        // slow.)

        pjScreen = NULL;
        lDelta   = 0;
        flHooks  = ppdev->flHooks;
    }

    // Note that this call is new to NT5, and takes the place of
    // EngAssociateSurface. 

    if (!EngModifySurface(hsurf, 
                          ppdev->hdevEng, 
                          flHooks,
                          MS_NOTSYSTEMMEMORY,    // It's in video memory
                          (DHSURF) pdsurf,
                          pjScreen,
                          lDelta,
                          NULL))
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngModifySurface"));
        goto ReturnFailure;
    }

    ppdev->hsurfScreen = hsurf;             // Remember it for clean-up
    ppdev->bEnabled = TRUE;                 // We'll soon be in graphics mode

    // Create our generic temporary buffer, which may be used by any
    // component.

    pvTmpBuffer = EngAllocMem(0, TMP_BUFFER_SIZE, ALLOC_TAG);
    if (pvTmpBuffer == NULL)
    {
        DISPDBG((0, "DrvEnableSurface - Failed VirtualAlloc"));
        goto ReturnFailure;
    }

    ppdev->pvTmpBuffer = pvTmpBuffer;

    DISPDBG((5, "Passed DrvEnableSurface"));

    return(hsurf);

ReturnFailure:
    DrvDisableSurface((DHPDEV) ppdev);

    DISPDBG((0, "Failed DrvEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
* Note that this function will be called when previewing modes in the
* Display Applet, but not at system shutdown.  If you need to reset the
* hardware at shutdown, you can do it in the miniport by providing a
* 'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
*
* Note: In an error case, we may call this before DrvEnableSurface is
*       completely done.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    // Note: In an error case, some of the following relies on the
    //       fact that the PDEV is zero-initialized, so fields like
    //       'hsurfScreen' will be zero unless the surface has been
    //       sucessfully initialized, and makes the assumption that
    //       EngDeleteSurface can take '0' as a parameter.

    vDisableDirectDraw(ppdev);
    vDisablePalette(ppdev);
    vDisableBrushCache(ppdev);
    vDisableText(ppdev);
    vDisablePointer(ppdev);
    vDisableOffscreenHeap(ppdev);
    vDisableBanking(ppdev);
    vDisableHardware(ppdev);

    EngFreeMem(ppdev->pvTmpBuffer);
    EngDeleteSurface(ppdev->hsurfScreen);
}

/******************************Public*Routine******************************\
* BOOL DrvGetDirectDrawInfo
*
* Will be called after DrvEnablesurface.  Will be called twice before 
* DrvEnableDirectDraw is called.
*
\**************************************************************************/

BOOL DrvGetDirectDrawInfo(
DHPDEV          dhpdev,
DD_HALINFO*     pHalInfo,
DWORD*          pdwNumHeaps,
VIDEOMEMORY*    pvmList,            // Will be NULL on first call
DWORD*          pdwNumFourCC,
DWORD*          pdwFourCC)          // Will be NULL on first call
{
    PDEV*       ppdev;
    LONGLONG    li;
    DWORD       cProcessors;
    DWORD       cHeaps;

    ppdev = (PDEV*) dhpdev;

    *pdwNumFourCC = 0;
    *pdwNumHeaps = 0;

    // We may not support DirectDraw on this card.
    //
    // The 765 (Trio64V+) has a bug such that writing to the frame
    // buffer during an accelerator operation may cause a hang if
    // you do the write soon enough after starting the blt.  (There is
    // a small window of opportunity.)  On UP machines, the context
    // switch time seems to be enough to avoid the problem.  However,
    // on MP machines, we'll have to disable direct draw.
    //
    // NOTE: We can identify the 765 since it is the only chip with
    //       the CAPS_STREAMS_CAPABLE flag.

    if (ppdev->flCaps & CAPS_STREAMS_CAPABLE) 
    {
        if (!EngQuerySystemAttribute(EngNumberOfProcessors, &cProcessors) ||
            (cProcessors != 1))
        {
            return(FALSE);
        }
    }

    if (!(ppdev->flCaps & CAPS_NEW_MMIO) ||
        (ppdev->flCaps & CAPS_NO_DIRECT_ACCESS))
    {
        return(FALSE);
    }

    pHalInfo->dwSize = sizeof(*pHalInfo);

    // Current primary surface attributes.  Since HalInfo is zero-initialized
    // by GDI, we only have to fill in the fields which should be non-zero:

    pHalInfo->vmiData.pvPrimary       = ppdev->pjScreen;
    pHalInfo->vmiData.dwDisplayWidth  = ppdev->cxScreen;
    pHalInfo->vmiData.dwDisplayHeight = ppdev->cyScreen;
    pHalInfo->vmiData.lDisplayPitch   = ppdev->lDelta;

    pHalInfo->vmiData.ddpfDisplay.dwSize  = sizeof(DDPIXELFORMAT);
    pHalInfo->vmiData.ddpfDisplay.dwFlags = DDPF_RGB;

    pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = 8 * ppdev->cjPelSize;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;
    }

    // These masks will be zero at 8bpp:

    pHalInfo->vmiData.ddpfDisplay.dwRBitMask = ppdev->flRed;
    pHalInfo->vmiData.ddpfDisplay.dwGBitMask = ppdev->flGreen;
    pHalInfo->vmiData.ddpfDisplay.dwBBitMask = ppdev->flBlue;

    // The S3 has to do everything using 'rectangular' memory, because
    // the accelerator doesn't know how to set arbitrary strides.

    cHeaps = 0;

    // Snag a pointer to the video-memory list so that we can use it to
    // call back to DirectDraw to allocate video memory:

    ppdev->pvmList = pvmList;

    // Create one heap to describe the unused portion of video
    // memory to the right of the visible screen (if any):

    if (ppdev->cxScreen < ppdev->cxHeap)
    {
        cHeaps++;

        if (pvmList != NULL)
        {
            pvmList->dwFlags        = VIDMEM_ISRECTANGULAR;
            pvmList->fpStart        = ppdev->cxScreen * ppdev->cjPelSize;
            pvmList->dwWidth        = (ppdev->cxHeap - ppdev->cxScreen) 
                                    * ppdev->cjPelSize;
            pvmList->dwHeight       = ppdev->cyScreen;
            pvmList->ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
            pvmList++;
        }
    }

    // Create another heap to describe the unused portion of video
    // memory below the visible screen (if any):

    if (ppdev->cyScreen < ppdev->cyHeap)
    {
        cHeaps++;

        if (pvmList != NULL)
        {
            pvmList->dwFlags        = VIDMEM_ISRECTANGULAR;
            pvmList->fpStart        = ppdev->cyScreen * ppdev->lDelta;
            pvmList->dwWidth        = ppdev->cxHeap * ppdev->cjPelSize;
            pvmList->dwHeight       = ppdev->cyHeap - ppdev->cyScreen;
            pvmList->ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
            pvmList++;
        }
    }

    // Update the number of heaps:

    ppdev->cHeaps = cHeaps;
    *pdwNumHeaps  = cHeaps;

    // dword alignment must be guaranteed for off-screen surfaces:

    pHalInfo->vmiData.dwOffscreenAlign = 4;

    // Capabilities supported:

    pHalInfo->ddCaps.dwCaps = DDCAPS_BLT
                            | DDCAPS_BLTCOLORFILL
                            | DDCAPS_COLORKEY;

    pHalInfo->ddCaps.dwCKeyCaps = DDCKEYCAPS_SRCBLT;

    pHalInfo->ddCaps.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN
                                    | DDSCAPS_PRIMARYSURFACE
                                    | DDSCAPS_FLIP;

    // The Trio 64V+ has overlay streams capabilities which are a superset
    // of the above:

    if (ppdev->flCaps & CAPS_STREAMS_CAPABLE)
    {
        // Overlays need 8-byte alignment.  Note that if 24bpp overlays are
        // ever supported, this will have to change to compensate:

        pHalInfo->vmiData.dwOverlayAlign = 8;

        pHalInfo->ddCaps.dwCaps |= DDCAPS_OVERLAY
                                 | DDCAPS_OVERLAYSTRETCH
                                 | DDCAPS_OVERLAYFOURCC
                                 | DDCAPS_OVERLAYCANTCLIP;

        pHalInfo->ddCaps.dwFXCaps |= DDFXCAPS_OVERLAYSTRETCHX
                                   | DDFXCAPS_OVERLAYSTRETCHY;

        // We support only destination colour keying because that's the
        // only permutation we've had a chance to test.

        pHalInfo->ddCaps.dwCKeyCaps |= DDCKEYCAPS_DESTOVERLAY;

        pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_OVERLAY;

        *pdwNumFourCC = 1;
        if (pdwFourCC)
        {
            pdwFourCC[0] = FOURCC_YUY2;
        }

        pHalInfo->ddCaps.dwMaxVisibleOverlays = 1;

        pHalInfo->ddCaps.dwMinOverlayStretch   = ppdev->ulMinOverlayStretch;
        pHalInfo->ddCaps.dwMinLiveVideoStretch = ppdev->ulMinOverlayStretch;
        pHalInfo->ddCaps.dwMinHwCodecStretch   = ppdev->ulMinOverlayStretch;

        pHalInfo->ddCaps.dwMaxOverlayStretch   = 9999;
        pHalInfo->ddCaps.dwMaxLiveVideoStretch = 9999;
        pHalInfo->ddCaps.dwMaxHwCodecStretch   = 9999;
    }

    // The 868 and 968 have a pixel formatter which is capable of doing
    // colour space conversions and hardware stretching from off-screen
    // surfaces:

    else if (ppdev->flCaps & CAPS_PIXEL_FORMATTER)
    {
        pHalInfo->ddCaps.dwCaps |= DDCAPS_BLTSTRETCH;

        pHalInfo->ddCaps.dwFXCaps |= DDFXCAPS_BLTSTRETCHX
                                   | DDFXCAPS_BLTSTRETCHY;

        // YUV is supported only above 8bpp:

        if (ppdev->iBitmapFormat != BMF_8BPP)
        {
            pHalInfo->ddCaps.dwCaps |= DDCAPS_BLTFOURCC;

            *pdwNumFourCC = 1;
            if (pdwFourCC)
            {
                *pdwFourCC = FOURCC_YUY2;
            }
        }
    }

    // Tell DirectDraw that we support additional callbacks via 
    // DdGetDriverInfo:

    pHalInfo->GetDriverInfo = DdGetDriverInfo;
    pHalInfo->dwFlags |= DDHALINFO_GETDRIVERINFOSET;

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL DrvEnableDirectDraw
*
* This function is called by GDI when a new mode is set, immediately after
* it calls our DrvEnableSurface and DrvGetDirectDrawInfo.
*
\**************************************************************************/

BOOL DrvEnableDirectDraw(
DHPDEV                  dhpdev,
DD_CALLBACKS*           pCallBacks,
DD_SURFACECALLBACKS*    pSurfaceCallBacks,
DD_PALETTECALLBACKS*    pPaletteCallBacks)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    pCallBacks->WaitForVerticalBlank = DdWaitForVerticalBlank;
    pCallBacks->MapMemory            = DdMapMemory;
    pCallBacks->dwFlags              = DDHAL_CB32_WAITFORVERTICALBLANK
                                     | DDHAL_CB32_MAPMEMORY;

    pSurfaceCallBacks->Blt           = DdBlt;
    pSurfaceCallBacks->Flip          = DdFlip;
    pSurfaceCallBacks->Lock          = DdLock;
    pSurfaceCallBacks->GetBltStatus  = DdGetBltStatus;
    pSurfaceCallBacks->GetFlipStatus = DdGetFlipStatus;
    pSurfaceCallBacks->dwFlags       = DDHAL_SURFCB32_BLT
                                     | DDHAL_SURFCB32_FLIP
                                     | DDHAL_SURFCB32_LOCK
                                     | DDHAL_SURFCB32_GETBLTSTATUS
                                     | DDHAL_SURFCB32_GETFLIPSTATUS;

    // We can do overlays only when the Streams processor is enabled:

    if (ppdev->flCaps & CAPS_STREAMS_CAPABLE)
    {
        pCallBacks->CreateSurface             = DdCreateSurface;
        pCallBacks->CanCreateSurface          = DdCanCreateSurface;
        pCallBacks->dwFlags                  |= DDHAL_CB32_CREATESURFACE
                                              | DDHAL_CB32_CANCREATESURFACE;

        pSurfaceCallBacks->SetColorKey        = DdSetColorKey;
        pSurfaceCallBacks->UpdateOverlay      = DdUpdateOverlay;
        pSurfaceCallBacks->SetOverlayPosition = DdSetOverlayPosition;
        pSurfaceCallBacks->dwFlags           |= DDHAL_SURFCB32_SETCOLORKEY
                                              | DDHAL_SURFCB32_UPDATEOVERLAY
                                              | DDHAL_SURFCB32_SETOVERLAYPOSITION;
        ppdev->ulColorKey                     = 0;
    }

    // We can do blts with funky surface formats only when the pixel
    // formatter is enabled:

    else if (ppdev->flCaps & CAPS_PIXEL_FORMATTER)
    {
        pCallBacks->CreateSurface     = DdCreateSurface;
        pCallBacks->CanCreateSurface  = DdCanCreateSurface;
        pCallBacks->dwFlags          |= DDHAL_CB32_CREATESURFACE
                                      | DDHAL_CB32_CANCREATESURFACE;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDisableDirectDraw
*
* This function is called by GDI when the driver is to be disabled, just
* before it calls DrvDisableSurface. 
*
\**************************************************************************/

VOID DrvDisableDirectDraw(
DHPDEV      dhpdev)
{
}

/******************************Public*Routine******************************\
* VOID DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL DrvAssertMode(
DHPDEV  dhpdev,
BOOL    bEnable)
{
    PDEV* ppdev;

    ppdev = (PDEV*) dhpdev;

    if (!bEnable)
    {
        //////////////////////////////////////////////////////////////
        // Disable - Switch to full-screen mode

        vAssertModeDirectDraw(ppdev, FALSE);

        vAssertModePalette(ppdev, FALSE);

        vAssertModeBrushCache(ppdev, FALSE);

        vAssertModeText(ppdev, FALSE);

        vAssertModePointer(ppdev, FALSE);

        if (bAssertModeOffscreenHeap(ppdev, FALSE))
        {
            vAssertModeBanking(ppdev, FALSE);

            if (bAssertModeHardware(ppdev, FALSE))
            {
                ppdev->bEnabled = FALSE;

                return(TRUE);
            }

            //////////////////////////////////////////////////////////
            // We failed to switch to full-screen.  So undo everything:

            vAssertModeBanking(ppdev, TRUE);

            bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
        }                                           //   return code with TRUE

        // there is HW setup in bEnablePointer that needs to be done at assert time too
        // coming back from full-screen DOS or hibernate so call enablepointer which
        // then calls vAssertModePointer itself.  In 8bpp, the DAC resolution was not
        // being set correctly after FSdos or Hib. causing screen to be dim

        bEnablePointer(ppdev);

        vAssertModeText(ppdev, TRUE);

        vAssertModeBrushCache(ppdev, TRUE);

        vAssertModePalette(ppdev, TRUE);

        vAssertModeDirectDraw(ppdev, TRUE);
    }
    else
    {
        //////////////////////////////////////////////////////////////
        // Enable - Switch back to graphics mode

        // We have to enable every subcomponent in the reverse order
        // in which it was disabled:

        if (bAssertModeHardware(ppdev, TRUE))
        {
            vAssertModeBanking(ppdev, TRUE);

            bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
                                                    //   return code with TRUE
            bEnablePointer(ppdev);

            vAssertModeText(ppdev, TRUE);

            vAssertModeBrushCache(ppdev, TRUE);

            vAssertModePalette(ppdev, TRUE);

            vAssertModeDirectDraw(ppdev, TRUE);

            ppdev->bEnabled = TRUE;

            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* ULONG DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE      hDriver,
ULONG       cjSize,
DEVMODEW*   pdm)
{
    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    cModes = getAvailableModes(hDriver,
                            (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                            &cbModeSize);
    if (cModes == 0)
    {
        DISPDBG((0, "DrvGetModes failed to get mode information"));
        return(0);
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the
        // output buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG_PTR)pdm) + sizeof(DEVMODEW) +
                                                   DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);


        } while (--cModes);
    }

    EngFreeMem(pVideoModeInformation);

    return(cbOutputSize);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeHardware
*
* Sets the appropriate hardware state for graphics mode or full-screen.
*
\**************************************************************************/

BOOL bAssertModeHardware(
PDEV* ppdev,
BOOL  bEnable)
{
    BYTE*                   pjIoBase;
    BYTE*                   pjMmBase;
    DWORD                   ReturnedDataLength;
    ULONG                   ulReturn;
    BYTE                    jExtendedMemoryControl;
    VIDEO_MODE_INFORMATION  VideoModeInfo;
    LONG                    cjEndOfFrameBuffer;
    LONG                    cjPointerOffset;
    LONG                    lDelta;
    ULONG                   ulMiscState;

    pjIoBase = ppdev->pjIoBase;
    pjMmBase = ppdev->pjMmBase;

    if (bEnable)
    {
        // Call the miniport via an IOCTL to set the graphics mode.

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_CURRENT_MODE,
                               &ppdev->ulMode,  // input buffer
                               sizeof(DWORD),
                               NULL,
                               0,
                               &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - Failed VIDEO_SET_CURRENT_MODE"));
            goto ReturnFalse;
        }

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_QUERY_CURRENT_MODE,
                               NULL,
                               0,
                               &VideoModeInfo,
                               sizeof(VideoModeInfo),
                               &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - failed VIDEO_QUERY_CURRENT_MODE"));
            goto ReturnFalse;
        }

        #if DEBUG_HEAP
            VideoModeInfo.VideoMemoryBitmapWidth  = VideoModeInfo.VisScreenWidth;
            VideoModeInfo.VideoMemoryBitmapHeight = VideoModeInfo.VisScreenHeight;
        #endif

        // The following variables are determined only after the initial
        // modeset:

        ppdev->lDelta   = VideoModeInfo.ScreenStride;
        ppdev->flCaps   = VideoModeInfo.DriverSpecificAttributeFlags;
        ppdev->cxMemory = VideoModeInfo.VideoMemoryBitmapWidth;
        ppdev->cxHeap   = VideoModeInfo.VideoMemoryBitmapWidth;
        ppdev->cyMemory = VideoModeInfo.VideoMemoryBitmapHeight;
        ppdev->cyHeap   = VideoModeInfo.VideoMemoryBitmapHeight;

        ppdev->bMmIo = ((ppdev->flCaps & CAPS_MM_IO) > 0);

        // If we're using the S3 hardware pointer, reserve the last 1k of
        // the frame buffer to store the pointer shape:

        if (!(ppdev->flCaps & (CAPS_SW_POINTER | CAPS_DAC_POINTER)))
        {
            // Byte offset from start of frame buffer to end:

            cjEndOfFrameBuffer = ppdev->cyMemory * ppdev->lDelta;

            // We'll reserve the end of off-screen memory for the hardware
            // pointer shape.  Unfortunately, the S3 chips have a bug
            // where the shape has to be stored on a 1K multiple,
            // regardless of what the current screen stride is.

            cjPointerOffset = (cjEndOfFrameBuffer - HW_POINTER_TOTAL_SIZE)
                            & ~(HW_POINTER_TOTAL_SIZE - 1);

            // Figure out the coordinate where the pointer shape starts:

            lDelta = ppdev->lDelta;

            ppdev->cjPointerOffset = cjPointerOffset;
            ppdev->yPointerShape   = (cjPointerOffset / lDelta);
            ppdev->xPointerShape   =
              CONVERT_FROM_BYTES((cjPointerOffset % lDelta), ppdev);

            if (ppdev->yPointerShape >= ppdev->cyScreen)
            {
                // There's enough room for the pointer shape at the
                // bottom of off-screen memory; reserve its room by
                // lying about how much off-screen memory there is:

                ppdev->cyMemory = ppdev->yPointerShape;
            }
            else
            {
                // There's not enough room for the pointer shape in
                // off-screen memory; we'll have to simulate:

                ppdev->flCaps |= CAPS_SW_POINTER;
            }
        }

        // Do some parameter checking on the values that the miniport
        // returned to us:

        ASSERTDD(ppdev->cxMemory >= ppdev->cxScreen, "Invalid cxMemory");
        ASSERTDD(ppdev->cyMemory >= ppdev->cyScreen, "Invalid cyMemory");
        ASSERTDD((ppdev->flCaps &
                 (CAPS_NEW_BANK_CONTROL | CAPS_NEWER_BANK_CONTROL)) ||
                 ((ppdev->cxMemory <= 1024) && (ppdev->cyMemory <= 1024)),
                 "Have to have new bank control if more than 1meg memory");
        ASSERTDD((ppdev->flCaps & (CAPS_SW_POINTER | CAPS_DAC_POINTER)) !=
                 (CAPS_SW_POINTER | CAPS_DAC_POINTER),
                 "Should not set both Software and DAC cursor flags");
        ASSERTDD(!(ppdev->flCaps & CAPS_MM_IO) ||
                 (ppdev->flCaps & (CAPS_MM_TRANSFER | CAPS_MM_32BIT_TRANSFER)),
                 "Must enable memory-mapped transfer if memory-mapped I/O");

        // First thing we do is unlock the accelerator registers:

        ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

        OUTPW(pjIoBase, CRTC_INDEX, ((SYSCTL_UNLOCK << 8) | CR39));
        OUTPW(pjIoBase, CRTC_INDEX, ((REG_UNLOCK_1 << 8) | S3R8));

        // Enable memory-mapped IO.  Note that ulMiscState should not be
        // read on non-memory mapped I/O S3's because it does not exist
        // on 911/924's.

        if (ppdev->flCaps & CAPS_MM_IO)
        {
            OUTP(pjIoBase, CRTC_INDEX, 0x53);

            jExtendedMemoryControl = INP(pjIoBase, CRTC_DATA);

            OUTP(pjIoBase, CRTC_DATA, jExtendedMemoryControl | 0x10);

            // Read the default MULTI_MISC register state.

            IO_GP_WAIT(ppdev);                  // Wait so we don't interfere with any
                                                //   pending commands waiting on the
                                                //   FIFO
            IO_READ_SEL(ppdev, 6);              // We'll be reading index 0xE
            IO_GP_WAIT(ppdev);                  // Wait until that's processed
            IO_RD_REG_DT(ppdev, ulMiscState);   // Read ulMiscState

            // Make the colour and mask registers '32-bit'.
            //
            // NOTE: This is what precludes enabling MM I/O on 928 boards.

            ulMiscState |= 0x0200;
            IO_MULT_MISC(ppdev, ulMiscState);

            ppdev->ulMiscState = ulMiscState;
        }

        RELEASE_CRTC_CRITICAL_SECTION(ppdev);

        // Then set the rest of the default registers:

        vResetClipping(ppdev);

        if (ppdev->flCaps & CAPS_MM_IO)
        {
            IO_FIFO_WAIT(ppdev, 1);
            MM_WRT_MASK(ppdev, pjMmBase, -1);
        }
        else
        {
            if (DEPTH32(ppdev))
            {
                IO_FIFO_WAIT(ppdev, 2);
                IO_WRT_MASK32(ppdev, -1);
            }
            else
            {
                IO_FIFO_WAIT(ppdev, 1);
                IO_WRT_MASK(ppdev, -1);
            }
        }
    }
    else
    {
        // Call the kernel driver to reset the device to a known state.
        // NTVDM will take things from there:

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_RESET_DEVICE,
                               NULL,
                               0,
                               NULL,
                               0,
                               &ulReturn))
        {
            DISPDBG((0, "bAssertModeHardware - Failed reset IOCTL"));
            goto ReturnFalse;
        }
    }

    DISPDBG((5, "Passed bAssertModeHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bAssertModeHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bEnableHardware
*
* Puts the hardware in the requested mode and initializes it.
*
* Note: Should be called before any access is done to the hardware from
*       the display driver.
*
\**************************************************************************/

BOOL bEnableHardware(
PDEV*   ppdev)
{
    BYTE*                       pjIoBase;
    VIDEO_PUBLIC_ACCESS_RANGES  VideoAccessRange[2];
    VIDEO_MEMORY                VideoMemory;
    VIDEO_MEMORY_INFORMATION    VideoMemoryInfo;
    DWORD                       ReturnedDataLength;
    UCHAR*                      pj;
    USHORT*                     pw;
    ULONG*                      pd;
    ULONG                       i;

    // We need a critical section merely because of some S3 weirdness:
    // both the bank control registers and the cursor registers have
    // to be accessed through the shared CRTC registers.  We want to
    // set the GCAPS_ASYNCMOVE flag to allow the cursor to move even
    // while we're using the bank registers for a blt -- so we have to
    // synchronize all accesses to the CRTC registers.
    //
    // (Note that in the case of GCAPS_ASYNCMOVE, GDI automatically
    // synchronizes with DrvSetPalette, so you don't have to worry
    // about overlap between asynchronous cursor moves and the palette
    // registers.)

    ppdev->csCrtc = EngCreateSemaphore();
    if (ppdev->csCrtc == 0)
    {
        DISPDBG((0, "bEnableHardware - Error creating CRTC semaphore"));
        goto ReturnFalse;
    }

    // Map io ports into virtual memory:

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                           NULL,                      // input buffer
                           0,
                           &VideoAccessRange,         // output buffer
                           sizeof(VideoAccessRange),
                           &ReturnedDataLength))
    {
        DISPDBG((0, "bEnableHardware - Initialization error mapping IO port base"));
        goto ReturnFalse;
    }

    ppdev->pjIoBase = (UCHAR*) VideoAccessRange[0].VirtualAddress;
    ppdev->pjMmBase = (BYTE*)  VideoAccessRange[1].VirtualAddress;

    pjIoBase = ppdev->pjIoBase;

    // Get the linear memory address range.

    VideoMemory.RequestedVirtualAddress = NULL;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                           &VideoMemory,      // input buffer
                           sizeof(VIDEO_MEMORY),
                           &VideoMemoryInfo,  // output buffer
                           sizeof(VideoMemoryInfo),
                           &ReturnedDataLength))
    {
        DISPDBG((0, "bEnableHardware - Error mapping buffer address"));
        goto ReturnFalse;
    }

    // Record the Frame Buffer Linear Address.

    ppdev->pjScreen = (BYTE*) VideoMemoryInfo.FrameBufferBase;
    ppdev->cjBank   =         VideoMemoryInfo.FrameBufferLength;

    DISPDBG((1, "pjScreen: %lx  pjMmBase: %lx", ppdev->pjScreen, ppdev->pjMmBase));

    // Set all the register addresses.

    ppdev->ioCur_y          = pjIoBase + CUR_Y;
    ppdev->ioCur_x          = pjIoBase + CUR_X;
    ppdev->ioDesty_axstp    = pjIoBase + DEST_Y;
    ppdev->ioDestx_diastp   = pjIoBase + DEST_X;
    ppdev->ioErr_term       = pjIoBase + ERR_TERM;
    ppdev->ioMaj_axis_pcnt  = pjIoBase + MAJ_AXIS_PCNT;
    ppdev->ioGp_stat_cmd    = pjIoBase + CMD;
    ppdev->ioShort_stroke   = pjIoBase + SHORT_STROKE;
    ppdev->ioBkgd_color     = pjIoBase + BKGD_COLOR;
    ppdev->ioFrgd_color     = pjIoBase + FRGD_COLOR;
    ppdev->ioWrt_mask       = pjIoBase + WRT_MASK;
    ppdev->ioRd_mask        = pjIoBase + RD_MASK;
    ppdev->ioColor_cmp      = pjIoBase + COLOR_CMP;
    ppdev->ioBkgd_mix       = pjIoBase + BKGD_MIX;
    ppdev->ioFrgd_mix       = pjIoBase + FRGD_MIX;
    ppdev->ioMulti_function = pjIoBase + MULTIFUNC_CNTL;
    ppdev->ioPix_trans      = pjIoBase + PIX_TRANS;

    for (pw = (USHORT*) ppdev->pjMmBase, i = 0; i < XFER_BUFFERS; i++, pw += 2)
    {
        ppdev->apwMmXfer[i] = pw;
    }
    for (pd = (ULONG*) ppdev->pjMmBase, i = 0; i < XFER_BUFFERS; i++, pd++)
    {
        ppdev->apdMmXfer[i] = pd;
    }

    // Now we can set the mode, unlock the accelerator, and reset the
    // clipping:

    if (!bAssertModeHardware(ppdev, TRUE))
        goto ReturnFalse;

    if (ppdev->flCaps & CAPS_MM_IO)
    {
        // Can do memory-mapped IO:

        ppdev->pfnFillSolid         = vMmFillSolid;
        ppdev->pfnFillPat           = vMmFillPatFast;
        ppdev->pfnXfer1bpp          = vMmXfer1bpp;
        ppdev->pfnXfer4bpp          = vMmXfer4bpp;
        ppdev->pfnXferNative        = vMmXferNative;
        ppdev->pfnCopyBlt           = vMmCopyBlt;
        ppdev->pfnFastPatRealize    = vMmFastPatRealize;
        ppdev->pfnTextOut           = bMmTextOut;
        ppdev->pfnLineToTrivial     = vMmLineToTrivial;
        ppdev->pfnLineToClipped     = vMmLineToClipped;
        ppdev->pfnCopyTransparent   = vMmCopyTransparent;

        if (ppdev->flCaps & CAPS_MM_32BIT_TRANSFER)
            ppdev->pfnImageTransfer = vMmImageTransferMm32;
        else
            ppdev->pfnImageTransfer = vMmImageTransferMm16;

        // On some cards, it may be faster to use the old I/O based
        // glyph routine, which uses the CPU to draw all the glyphs
        // to a monochrome buffer, and then uses the video hardware
        // to colour expand the result:

        if (!(ppdev->flCaps & CAPS_MM_GLYPH_EXPAND))
            ppdev->pfnTextOut = bIoTextOut;

        if (ppdev->flCaps & CAPS_NEW_MMIO)
        {
            ppdev->pfnTextOut       = bNwTextOut;
            ppdev->pfnLineToTrivial = vNwLineToTrivial;
            ppdev->pfnLineToClipped = vNwLineToClipped;
        }
    }
    else
    {
        // Have to do IN/OUTs:

        ppdev->pfnFillSolid         = vIoFillSolid;
        ppdev->pfnFillPat           = vIoFillPatFast;
                            // bEnableBrushCache may override this value

        ppdev->pfnXfer1bpp          = vIoXfer1bpp;
        ppdev->pfnXfer4bpp          = vIoXfer4bpp;
        ppdev->pfnXferNative        = vIoXferNative;
        ppdev->pfnCopyBlt           = vIoCopyBlt;
        ppdev->pfnFastPatRealize    = vIoFastPatRealize;
        ppdev->pfnTextOut           = bIoTextOut;
        ppdev->pfnLineToTrivial     = vIoLineToTrivial;
        ppdev->pfnLineToClipped     = vIoLineToClipped;
        ppdev->pfnCopyTransparent   = vIoCopyTransparent;

        if (ppdev->flCaps & CAPS_MM_TRANSFER)
            ppdev->pfnImageTransfer = vIoImageTransferMm16;
        else
            ppdev->pfnImageTransfer = vIoImageTransferIo16;
    }

    #if DBG
    {
        ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

        OUTP(pjIoBase, CRTC_INDEX, 0x30);

        DISPDBG((0, "Chip: %lx Bank: %lx Width: %li Height: %li Stride: %li Flags: %08lx",
                (ULONG) INP(pjIoBase, CRTC_DATA), ppdev->cjBank, ppdev->cxMemory, ppdev->cyMemory,
                ppdev->lDelta, ppdev->flCaps));

        RELEASE_CRTC_CRITICAL_SECTION(ppdev);
    }
    #endif

    DISPDBG((5, "Passed bEnableHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDisableHardware
*
* Undoes anything done in bEnableHardware.
*
* Note: In an error case, we may call this before bEnableHardware is
*       completely done.
*
\**************************************************************************/

VOID vDisableHardware(
PDEV*   ppdev)
{
    DWORD        ReturnedDataLength;
    VIDEO_MEMORY VideoMemory[2];

    VideoMemory[0].RequestedVirtualAddress = ppdev->pjScreen;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                           VideoMemory,
                           sizeof(VIDEO_MEMORY),
                           NULL,
                           0,
                           &ReturnedDataLength))
    {
        DISPDBG((0, "vDisableHardware failed IOCTL_VIDEO_UNMAP_VIDEO"));
    }

    VideoMemory[0].RequestedVirtualAddress = ppdev->pjIoBase;
    VideoMemory[1].RequestedVirtualAddress = ppdev->pjMmBase;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES,
                           VideoMemory,
                           sizeof(VideoMemory),
                           NULL,
                           0,
                           &ReturnedDataLength))
    {
        DISPDBG((0, "vDisableHardware failed IOCTL_VIDEO_FREE_PUBLIC_ACCESS"));
    }

    EngDeleteSemaphore(ppdev->csCrtc);
}

/******************************Public*Routine******************************\
* BOOL bInitializeModeFields
*
* Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
* devinfo based on the requested mode.
*
\**************************************************************************/

BOOL bInitializeModeFields(
PDEV*     ppdev,
GDIINFO*  pgdi,
DEVINFO*  pdi,
DEVMODEW* pdm)
{
    ULONG                   cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer;
    PVIDEO_MODE_INFORMATION pVideoModeSelected;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    BOOL                    bSelectDefault;
    VIDEO_MODE_INFORMATION  VideoModeInformation;
    ULONG                   cbModeSize;

    // Call the miniport to get mode information

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);
    if (cModes == 0)
        goto ReturnFalse;

    // Now see if the requested mode has a match in that table.

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pdm->dmPelsWidth        == 0) &&
        (pdm->dmPelsHeight       == 0) &&
        (pdm->dmBitsPerPel       == 0) &&
        (pdm->dmDisplayFrequency == 0))
    {
        DISPDBG((1, "Default mode requested"));
        bSelectDefault = TRUE;
    }
    else
    {
        DISPDBG((1, "Requested mode..."));
        DISPDBG((1, "   Screen width  -- %li", pdm->dmPelsWidth));
        DISPDBG((1, "   Screen height -- %li", pdm->dmPelsHeight));
        DISPDBG((1, "   Bits per pel  -- %li", pdm->dmBitsPerPel));
        DISPDBG((1, "   Frequency     -- %li", pdm->dmDisplayFrequency));

        bSelectDefault = FALSE;
    }

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            DISPDBG((8, "   Checking against miniport mode:"));
            DISPDBG((8, "      Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((8, "      Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((8, "      Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                      pVideoTemp->NumberOfPlanes));
            DISPDBG((8, "      Frequency     -- %li", pVideoTemp->Frequency));

            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pdm->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pdm->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pdm->dmBitsPerPel) &&
                 (pVideoTemp->Frequency       == pdm->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((1, "...Found a mode match!"));
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);

    }

    // If no mode has been found, return an error

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((1, "...Couldn't find a mode match!"));
        EngFreeMem(pVideoBuffer);
        goto ReturnFalse;
    }

    // We have chosen the one we want.  Save it in a stack buffer and
    // get rid of allocated memory before we forget to free it.

    VideoModeInformation = *pVideoModeSelected;
    EngFreeMem(pVideoBuffer);

    #if DEBUG_HEAP
        VideoModeInformation.VisScreenWidth  = 640;
        VideoModeInformation.VisScreenHeight = 480;
        pdm->dmPelsWidth = 640;
        pdm->dmPelsHeight = 480;
    #endif

    // Set up screen information from the mini-port:

    ppdev->ulMode           = VideoModeInformation.ModeIndex;
    ppdev->cxScreen         = VideoModeInformation.VisScreenWidth;
    ppdev->cyScreen         = VideoModeInformation.VisScreenHeight;
    ppdev->cBitsPerPel      = VideoModeInformation.BitsPerPlane;

    DISPDBG((1, "ScreenStride: %lx", VideoModeInformation.ScreenStride));

    // We handle HOOK_SYNCHRONIZE separately at surface creation time:

    ppdev->flHooks          = (HOOK_BITBLT         |
                               HOOK_TEXTOUT        |
                               HOOK_FILLPATH       |
                               HOOK_COPYBITS       |
                               HOOK_STROKEPATH     |
                               HOOK_LINETO         |
                               HOOK_STRETCHBLT     |
                               HOOK_TRANSPARENTBLT);

    // Fill in the GDIINFO data structure with the default 8bpp values:

    *pgdi = ggdiDefault;

    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:

    pgdi->ulHorzSize        = VideoModeInformation.XMillimeter;
    pgdi->ulVertSize        = VideoModeInformation.YMillimeter;

    pgdi->ulHorzRes         = VideoModeInformation.VisScreenWidth;
    pgdi->ulVertRes         = VideoModeInformation.VisScreenHeight;
    pgdi->ulPanningHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulPanningVertRes  = VideoModeInformation.VisScreenHeight;

    pgdi->cBitsPixel        = VideoModeInformation.BitsPerPlane;
    pgdi->cPlanes           = VideoModeInformation.NumberOfPlanes;
    pgdi->ulVRefresh        = VideoModeInformation.Frequency;

    pgdi->ulDACRed          = VideoModeInformation.NumberRedBits;
    pgdi->ulDACGreen        = VideoModeInformation.NumberGreenBits;
    pgdi->ulDACBlue         = VideoModeInformation.NumberBlueBits;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

    // Fill in the devinfo structure with the default 8bpp values:

    *pdi = gdevinfoDefault;

    if (VideoModeInformation.BitsPerPlane == 8)
    {
        ppdev->cjPelSize       = 1;
        ppdev->iBitmapFormat   = BMF_8BPP;

        // Assuming palette is orthogonal - all colors are same size.

        ppdev->cPaletteShift   = 8 - pgdi->ulDACRed;
        DISPDBG((3, "palette shift = %d\n", ppdev->cPaletteShift));
    }
    else if ((VideoModeInformation.BitsPerPlane == 16) ||
             (VideoModeInformation.BitsPerPlane == 15))
    {
        ppdev->cjPelSize       = 2;
        ppdev->iBitmapFormat   = BMF_16BPP;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_16BPP;

        pdi->iDitherFormat     = BMF_16BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }
    else if (VideoModeInformation.BitsPerPlane == 24)
    {
        ppdev->cjPelSize       = 3;
        ppdev->iBitmapFormat   = BMF_24BPP;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_24BPP;

        pdi->iDitherFormat     = BMF_24BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }
    else
    {
        ASSERTDD(VideoModeInformation.BitsPerPlane == 32,
         "This driver supports only 8, 16, 24 and 32bpp");

        ppdev->cjPelSize       = 4;
        ppdev->iBitmapFormat   = BMF_32BPP;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_32BPP;

        pdi->iDitherFormat     = BMF_32BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }

    DISPDBG((5, "Passed bInitializeModeFields"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializeModeFields"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* DWORD getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE                   hDriver,
PVIDEO_MODE_INFORMATION* modeInformation,       // Must be freed by caller
DWORD*                   cbModeSize)
{
    ULONG                   ulTemp;
    VIDEO_NUM_MODES         modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //

    if (EngDeviceIoControl(hDriver,
                           IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
                           NULL,
                           0,
                           &modes,
                           sizeof(VIDEO_NUM_MODES),
                           &ulTemp))
    {
        DISPDBG((0, "getAvailableModes - Failed VIDEO_QUERY_NUM_AVAIL_MODES"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = EngAllocMem(FL_ZERO_MEMORY,
                                   modes.NumModes * modes.ModeInformationLength,
                                   ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "getAvailableModes - Failed EngAllocMem"));
        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (EngDeviceIoControl(hDriver,
                           IOCTL_VIDEO_QUERY_AVAIL_MODES,
                           NULL,
                           0,
                           *modeInformation,
                           modes.NumModes * modes.ModeInformationLength,
                           &ulTemp))
    {

        DISPDBG((0, "getAvailableModes - Failed VIDEO_QUERY_AVAIL_MODES"));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 8, 15, 16, 24 or 32 bits per pel.
    //

    while (ulTemp--)
    {
        if ((pVideoTemp->NumberOfPlanes != 1 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
            ((pVideoTemp->BitsPerPlane != 8) &&
             (pVideoTemp->BitsPerPlane != 15) &&
             (pVideoTemp->BitsPerPlane != 16) &&
             (pVideoTemp->BitsPerPlane != 24) &&
             (pVideoTemp->BitsPerPlane != 32)))
        {
            DISPDBG((2, "Rejecting miniport mode:"));
            DISPDBG((2, "   Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((2, "   Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((2, "   Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                   pVideoTemp->NumberOfPlanes));
            DISPDBG((2, "   Frequency     -- %li", pVideoTemp->Frequency));

            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return(modes.NumModes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\fastfill.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: fastfill.c
*
* Fast routine for drawing polygons that aren't complex in shape.
*
* Copyright (c) 1993-1998 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define RIGHT 0
#define LEFT  1

typedef struct _TRAPEZOIDDATA TRAPEZOIDDATA;    // Handy forward declaration

typedef VOID (FNTRAPEZOID)(TRAPEZOIDDATA*, LONG, LONG);
                                                // Prototype for trapezoid
                                                //   drawing routines

typedef struct _EDGEDATA {
LONG      x;                // Current x position
LONG      dx;               // # pixels to advance x on each scan
LONG      lError;           // Current DDA error
LONG      lErrorUp;         // DDA error increment on each scan
LONG      dN;               // Signed delta-y in fixed point form (also known
                            //   as the DDA error adjustment, and used to be
                            //   called 'lErrorDown')
LONG      dM;               // Signed delta-x in fixed point form
POINTFIX* pptfx;            // Points to start of current edge
LONG      dptfx;            // Delta (in bytes) from pptfx to next point
LONG      cy;               // Number of scans to go for this edge
LONG      bNew;             // Set to TRUE when a new DDA must be started
                            //   for the edge.
} EDGEDATA;                         /* ed, ped */

typedef struct _TRAPEZOIDDATA {
FNTRAPEZOID*    pfnTrap;    // Pointer to appropriate trapezoid drawing routine,
                            //   or trapezoid clip routine
FNTRAPEZOID*    pfnTrapClip;// Pointer to appropriate trapezoid drawing routine
                            //   if doing clipping
PDEV*           ppdev;      // Pointer to PDEV
EDGEDATA        aed[2];     // DDA information for both edges
POINTL          ptlBrush;   // Brush alignment
LONG            yClipTop;   // Top of clip rectangle
LONG            yClipBottom;// Bottom of clip rectangle

} TRAPEZOIDDATA;                    /* td, ptd */

/******************************Public*Routine******************************\
* VOID vClipTrapezoid
*
* Clips a trapezoid.
*
* NOTE: This routine assumes that the polygon's dimensions are small
*       enough that its QUOTIENT_REMAINDER calculations won't overflow.
*       This means that large polygons must never make it here.
*
\**************************************************************************/

VOID vClipTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapTop,
LONG            cyTrapezoid)
{
    LONG    yTrapBottom;
    LONG    dN;
    LONG    lNum;
    LONG    xDelta;
    LONG    lError;

    yTrapBottom = yTrapTop + cyTrapezoid;

    if (yTrapTop < ptd->yClipTop)
    {
        if ((ptd->aed[LEFT].bNew) &&
            (yTrapBottom + ptd->aed[LEFT].cy > ptd->yClipTop))
        {
            dN   = ptd->aed[LEFT].dN;
            lNum = ptd->aed[LEFT].dM * (ptd->yClipTop - yTrapTop)
                 + (ptd->aed[LEFT].lError + dN);

            if (lNum >= 0)
            {
                QUOTIENT_REMAINDER(lNum, dN, xDelta, lError);
            }
            else
            {
                lNum = -lNum;

                QUOTIENT_REMAINDER(lNum, dN, xDelta, lError);

                xDelta = -xDelta;
                if (lError != 0)
                {
                    xDelta--;
                    lError = dN - lError;
                }
            }

            ptd->aed[LEFT].x     += xDelta;
            ptd->aed[LEFT].lError = lError - dN;
        }

        if ((ptd->aed[RIGHT].bNew) &&
            (yTrapBottom + ptd->aed[RIGHT].cy > ptd->yClipTop))
        {
            dN   = ptd->aed[RIGHT].dN;
            lNum = ptd->aed[RIGHT].dM * (ptd->yClipTop - yTrapTop)
                 + (ptd->aed[RIGHT].lError + dN);

            if (lNum >= 0)
            {
                QUOTIENT_REMAINDER(lNum, dN, xDelta, lError);
            }
            else
            {
                lNum = -lNum;

                QUOTIENT_REMAINDER(lNum, dN, xDelta, lError);

                xDelta = -xDelta;
                if (lError != 0)
                {
                    xDelta--;
                    lError = dN - lError;
                }
            }

            ptd->aed[RIGHT].x     += xDelta;
            ptd->aed[RIGHT].lError = lError - dN;
        }
    }

    // If this trapezoid vertically intersects our clip rectangle, draw it:

    if ((yTrapBottom > ptd->yClipTop) &&
        (yTrapTop    < ptd->yClipBottom))
    {
        if (yTrapTop <= ptd->yClipTop)
        {
            yTrapTop = ptd->yClipTop;

            // Have to let trapezoid drawer know that it has to load
            // its DDAs for very first trapezoid drawn:

            ptd->aed[RIGHT].bNew = TRUE;
            ptd->aed[LEFT].bNew  = TRUE;
        }

        if (yTrapBottom >= ptd->yClipBottom)
        {
            yTrapBottom = ptd->yClipBottom;
        }

        ptd->pfnTrapClip(ptd, yTrapTop, yTrapBottom - yTrapTop);
    }
}

/******************************Public*Routine******************************\
* VOID vIoSolidTrapezoid
*
* Draws a solid trapezoid using a software DDA.
*
\**************************************************************************/

VOID vIoSolidTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapezoid,
LONG            cyTrapezoid)
{
    PDEV*       ppdev;
    LONG        xOffset;
    LONG        lLeftError;
    LONG        xLeft;
    LONG        lRightError;
    LONG        xRight;
    LONG        lTmp;
    EDGEDATA    edTmp;

    ppdev = ptd->ppdev;

    xOffset     = ppdev->xOffset;
    yTrapezoid += ppdev->yOffset;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0))
    {
        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

        xLeft  = ptd->aed[LEFT].x + xOffset;
        xRight = ptd->aed[RIGHT].x + xOffset;
        if (xLeft > xRight)
        {
            SWAP(xLeft,          xRight,          lTmp);
            SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
        }

        if (xLeft < xRight)
        {
            IO_FIFO_WAIT(ppdev, 6);

            IO_MAJ_AXIS_PCNT(ppdev, xRight - xLeft - 1);
            IO_MIN_AXIS_PCNT(ppdev, cyTrapezoid - 1);
            IO_ABS_CUR_Y(ppdev, yTrapezoid);
            IO_ABS_CUR_X(ppdev, xLeft);             // Already absolute
            IO_CMD(ppdev, (RECTANGLE_FILL | DRAWING_DIR_TBLRXM |
                           DRAW           | DIR_TYPE_XY        |
                           LAST_PIXEL_ON  | MULTIPLE_PIXELS    |
                           WRITE));
            IO_MIN_AXIS_PCNT(ppdev, 0);
        }
    }
    else
    {
        IO_FIFO_WAIT(ppdev, 1);
        IO_ABS_CUR_Y(ppdev, yTrapezoid);

        yTrapezoid += cyTrapezoid + 1; // One past end scan

        lLeftError  = ptd->aed[LEFT].lError;
        xLeft       = ptd->aed[LEFT].x + xOffset;
        lRightError = ptd->aed[RIGHT].lError;
        xRight      = ptd->aed[RIGHT].x + xOffset;

        while (TRUE)
        {
            /////////////////////////////////////////////////////////////////
            // Run the DDAs

            if (xLeft < xRight)
            {
                IO_FIFO_WAIT(ppdev, 3);
                IO_MAJ_AXIS_PCNT(ppdev, xRight - xLeft - 1);
                IO_ABS_CUR_X(ppdev, xLeft);
                IO_CMD(ppdev, (RECTANGLE_FILL | DRAWING_DIR_TBLRXM |
                               DRAW           | DIR_TYPE_XY        |
                               LAST_PIXEL_ON  | MULTIPLE_PIXELS    |
                               WRITE));
            }
            else if (xLeft > xRight)
            {
                // We don't bother optimizing this case because we should
                // rarely get self-intersecting polygons (if we're slow,
                // the app gets what it deserves).

                SWAP(xLeft,          xRight,          lTmp);
                SWAP(lLeftError,     lRightError,     lTmp);
                SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
                continue;
            }
            else
            {
                IO_FIFO_WAIT(ppdev, 1);
                IO_ABS_CUR_Y(ppdev, yTrapezoid - cyTrapezoid);
            }

            // Advance the right wall:

            xRight      += ptd->aed[RIGHT].dx;
            lRightError += ptd->aed[RIGHT].lErrorUp;

            if (lRightError >= 0)
            {
                lRightError -= ptd->aed[RIGHT].dN;
                xRight++;
            }

            // Advance the left wall:

            xLeft      += ptd->aed[LEFT].dx;
            lLeftError += ptd->aed[LEFT].lErrorUp;

            if (lLeftError >= 0)
            {
                lLeftError -= ptd->aed[LEFT].dN;
                xLeft++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                break;
        }

        ptd->aed[LEFT].lError  = lLeftError;
        ptd->aed[LEFT].x       = xLeft - xOffset;
        ptd->aed[RIGHT].lError = lRightError;
        ptd->aed[RIGHT].x      = xRight - xOffset;
    }
}

/******************************Public*Routine******************************\
* VOID vIoPatternTrapezoid
*
* Draws a patterned trapezoid using a software DDA.
*
\**************************************************************************/

VOID vIoPatternTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapezoid,
LONG            cyTrapezoid)
{
    PDEV*       ppdev;
    LONG        xOffset;
    LONG        lLeftError;
    LONG        xLeft;
    LONG        lRightError;
    LONG        xRight;
    LONG        lTmp;
    EDGEDATA    edTmp;

    ppdev = ptd->ppdev;

    xOffset     = ppdev->xOffset;
    yTrapezoid += ppdev->yOffset;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0))
    {
        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

        xLeft  = ptd->aed[LEFT].x + xOffset;
        xRight = ptd->aed[RIGHT].x + xOffset;
        if (xLeft > xRight)
        {
            SWAP(xLeft,          xRight,          lTmp);
            SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
        }

        if (xLeft < xRight)
        {
            IO_FIFO_WAIT(ppdev, 6);

            IO_MAJ_AXIS_PCNT(ppdev, xRight - xLeft - 1);
            IO_MIN_AXIS_PCNT(ppdev, cyTrapezoid - 1);
            IO_ABS_DEST_Y(ppdev, yTrapezoid);
            IO_ABS_DEST_X(ppdev, xLeft);            // Already absolute
            IO_CMD(ppdev, (PATTERN_FILL | DRAWING_DIR_TBLRXM |
                           DRAW         | WRITE));
            IO_MIN_AXIS_PCNT(ppdev, 0);
        }
    }
    else
    {
        IO_FIFO_WAIT(ppdev, 1);
        IO_ABS_DEST_Y(ppdev, yTrapezoid);

        yTrapezoid += cyTrapezoid + 1; // One past end scan

        lLeftError  = ptd->aed[LEFT].lError;
        xLeft       = ptd->aed[LEFT].x + xOffset;
        lRightError = ptd->aed[RIGHT].lError;
        xRight      = ptd->aed[RIGHT].x + xOffset;

        while (TRUE)
        {
            /////////////////////////////////////////////////////////////////
            // Run the DDAs

            if (xLeft < xRight)
            {
                IO_FIFO_WAIT(ppdev, 3);
                IO_MAJ_AXIS_PCNT(ppdev, xRight - xLeft - 1);
                IO_ABS_DEST_X(ppdev, xLeft);
                IO_CMD(ppdev, (PATTERN_FILL | DRAWING_DIR_TBLRXM |
                               DRAW         | WRITE));
            }
            else if (xLeft > xRight)
            {
                // We don't bother optimizing this case because we should
                // rarely get self-intersecting polygons (if we're slow,
                // the app gets what it deserves).

                SWAP(xLeft,          xRight,          lTmp);
                SWAP(lLeftError,     lRightError,     lTmp);
                SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
                continue;
            }
            else
            {
                IO_FIFO_WAIT(ppdev, 1);
                IO_ABS_DEST_Y(ppdev, yTrapezoid - cyTrapezoid);
            }

            // Advance the right wall:

            xRight      += ptd->aed[RIGHT].dx;
            lRightError += ptd->aed[RIGHT].lErrorUp;

            if (lRightError >= 0)
            {
                lRightError -= ptd->aed[RIGHT].dN;
                xRight++;
            }

            // Advance the left wall:

            xLeft      += ptd->aed[LEFT].dx;
            lLeftError += ptd->aed[LEFT].lErrorUp;

            if (lLeftError >= 0)
            {
                lLeftError -= ptd->aed[LEFT].dN;
                xLeft++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                break;
        }

        ptd->aed[LEFT].lError  = lLeftError;
        ptd->aed[LEFT].x       = xLeft - xOffset;
        ptd->aed[RIGHT].lError = lRightError;
        ptd->aed[RIGHT].x      = xRight - xOffset;
    }
}

/******************************Public*Routine******************************\
* VOID vIoTrapezoidSetup
*
* Initialize the hardware and some state for doing trapezoids.
*
\**************************************************************************/

VOID vIoTrapezoidSetup(
PDEV*           ppdev,
ULONG           rop4,
ULONG           iSolidColor,
RBRUSH*         prb,
POINTL*         pptlBrush,
TRAPEZOIDDATA*  ptd,
RECTL*          prclClip)       // NULL if no clipping
{
    ULONG       ulHwForeMix;
    BRUSHENTRY* pbe;

    ptd->ppdev = ppdev;

    ulHwForeMix = gaulHwMixFromRop2[(rop4 >> 2) & 0xf];

    if (iSolidColor != -1)
    {
        /////////////////////////////////////////////////////////////////
        // Setup the hardware for solid colours

        ptd->pfnTrap = vIoSolidTrapezoid;

        // We initialize the hardware for the colour, mix, pixel operation,
        // rectangle height of one, and the y position for the first scan:

        if (DEPTH32(ppdev))
        {
            IO_FIFO_WAIT(ppdev, 5);
            IO_FRGD_COLOR32(ppdev, iSolidColor);
        }
        else
        {
            IO_FIFO_WAIT(ppdev, 4);
            IO_FRGD_COLOR(ppdev, iSolidColor);
        }

        IO_FRGD_MIX(ppdev, FOREGROUND_COLOR | ulHwForeMix);
        IO_PIX_CNTL(ppdev, ALL_ONES);
        IO_MIN_AXIS_PCNT(ppdev, 0);
    }
    else
    {
        /////////////////////////////////////////////////////////////////
        // Setup for patterns

        BOOL bNotTransparent = (((rop4 >> 8) & 0xff) == (rop4 & 0xff));

        ptd->pfnTrap = vIoPatternTrapezoid;

        pbe = prb->pbe;
        if (bNotTransparent)
        {
            // Force normal brush at 24bpp on s3 968
            // Normal brush:

            IO_FIFO_WAIT(ppdev, 5);

            IO_ABS_CUR_X(ppdev, pbe->x);
            IO_ABS_CUR_Y(ppdev, pbe->y);
            IO_PIX_CNTL(ppdev, ALL_ONES);
            IO_FRGD_MIX(ppdev, SRC_DISPLAY_MEMORY | ulHwForeMix);
            IO_MIN_AXIS_PCNT(ppdev, 0);
        }
        else
        {
            // Transparent brush:

            if (DEPTH32(ppdev))
            {
                IO_FIFO_WAIT(ppdev, 4);
                IO_FRGD_COLOR32(ppdev, prb->ulForeColor);
                IO_RD_MASK32(ppdev, 1);     // Pick a plane, any plane
                IO_FIFO_WAIT(ppdev, 6);
            }
            else
            {
                IO_FIFO_WAIT(ppdev, 8);
                IO_FRGD_COLOR(ppdev, prb->ulForeColor);
                IO_RD_MASK(ppdev, 1);       // Pick a plane, any plane
            }

            IO_ABS_CUR_X(ppdev, pbe->x);
            IO_ABS_CUR_Y(ppdev, pbe->y);
            IO_PIX_CNTL(ppdev, DISPLAY_MEMORY);
            IO_FRGD_MIX(ppdev, FOREGROUND_COLOR | ulHwForeMix);
            IO_BKGD_MIX(ppdev, BACKGROUND_COLOR | LEAVE_ALONE);
            IO_MIN_AXIS_PCNT(ppdev, 0);
        }
    }

    if (prclClip != NULL)
    {
        ptd->pfnTrapClip = ptd->pfnTrap;
        ptd->pfnTrap     = vClipTrapezoid;
        ptd->yClipTop    = prclClip->top;
        ptd->yClipBottom = prclClip->bottom;

        IO_FIFO_WAIT(ppdev, 2);
        IO_ABS_SCISSORS_L(ppdev, ppdev->xOffset + prclClip->left);
        IO_ABS_SCISSORS_R(ppdev, ppdev->xOffset + prclClip->right - 1);
    }
}

/******************************Public*Routine******************************\
* VOID vMmSolidTrapezoid
*
* Draws a solid trapezoid using a software DDA.
*
\**************************************************************************/

VOID vMmSolidTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapezoid,
LONG            cyTrapezoid)
{
    PDEV*       ppdev;
    BYTE*       pjMmBase;
    LONG        xOffset;
    LONG        lLeftError;
    LONG        xLeft;
    LONG        lRightError;
    LONG        xRight;
    LONG        lTmp;
    EDGEDATA    edTmp;
    LONG        cFifo;

    ppdev = ptd->ppdev;
    pjMmBase = ppdev->pjMmBase;

    xOffset     = ppdev->xOffset;
    yTrapezoid += ppdev->yOffset;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0))
    {
        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

        xLeft  = ptd->aed[LEFT].x + xOffset;
        xRight = ptd->aed[RIGHT].x + xOffset;
        if (xLeft > xRight)
        {
            SWAP(xLeft,          xRight,          lTmp);
            SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
        }

        if (xLeft < xRight)
        {

            // Bliter doesn't handle negative X's with clipping
            // (at least at 24BPP on the 968).
            // So do SW clipping at X=0

            if (xRight > 0)
            {
                IO_FIFO_WAIT(ppdev, 6);
                if (xLeft <= 0)
                {
                    MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, xRight - 1);
                    MM_ABS_CUR_X(ppdev, pjMmBase, 0);
                }
                else
                {
                    MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, xRight - xLeft - 1);
                    MM_ABS_CUR_X(ppdev, pjMmBase, xLeft);       // Already absolute
                }
                MM_MIN_AXIS_PCNT(ppdev, pjMmBase, cyTrapezoid - 1);
                MM_ABS_CUR_Y(ppdev, pjMmBase, yTrapezoid);
                MM_CMD(ppdev, pjMmBase, (RECTANGLE_FILL | DRAWING_DIR_TBLRXM |
                            DRAW           | DIR_TYPE_XY        |
                            LAST_PIXEL_ON  | MULTIPLE_PIXELS    |
                            WRITE));
                MM_MIN_AXIS_PCNT(ppdev, pjMmBase, 0);
            }
        }
    }
    else
    {
        IO_ALL_EMPTY(ppdev);
        MM_ABS_CUR_Y(ppdev, pjMmBase, yTrapezoid);

        cFifo = MM_ALL_EMPTY_FIFO_COUNT - 1;
        yTrapezoid += cyTrapezoid + 1; // One past end scan

        lLeftError  = ptd->aed[LEFT].lError;
        xLeft       = ptd->aed[LEFT].x + xOffset;
        lRightError = ptd->aed[RIGHT].lError;
        xRight      = ptd->aed[RIGHT].x + xOffset;

        while (TRUE)
        {
            /////////////////////////////////////////////////////////////////
            // Run the DDAs

            if (xLeft < xRight)
            {
                // Bliter doesn't handle negative X's with clipping
                // (at least at 24BPP on the 968).
                // So do SW clipping at X=0

                if (xRight > 0)
                {
                    // We get a little tricky here and try to amortize the cost
                    // of the read for checking the FIFO count on the S3.

                    cFifo -= 3;
                    if (cFifo < 0)
                    {
                        IO_ALL_EMPTY(ppdev);
                        cFifo = MM_ALL_EMPTY_FIFO_COUNT - 3;
                    }

                    if (xLeft <= 0)
                    {
                        MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, xRight - 1);
                        MM_ABS_CUR_X(ppdev, pjMmBase, 0);
                    }
                    else
                    {
                        MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, xRight - xLeft - 1);
                        MM_ABS_CUR_X(ppdev, pjMmBase, xLeft);       // Already absolute
                    }
                    MM_CMD(ppdev, pjMmBase, (RECTANGLE_FILL | DRAWING_DIR_TBLRXM |
                                DRAW           | DIR_TYPE_XY        |
                                LAST_PIXEL_ON  | MULTIPLE_PIXELS    |
                                WRITE));
                }
                else
                {
                    // SW clipping at X==0 skipped the blit completely but
                    // the Y value must still be updated
                    cFifo -= 1;
                    if (cFifo < 0)
                    {
                        IO_ALL_EMPTY(ppdev);
                        cFifo = MM_ALL_EMPTY_FIFO_COUNT - 1;
                    }
                    MM_ABS_CUR_Y(ppdev, pjMmBase, yTrapezoid - cyTrapezoid);
                }
            }
            else if (xLeft > xRight)
            {
                // We don't bother optimizing this case because we should
                // rarely get self-intersecting polygons (if we're slow,
                // the app gets what it deserves).

                SWAP(xLeft,          xRight,          lTmp);
                SWAP(lLeftError,     lRightError,     lTmp);
                SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
                continue;
            }
            else
            {
                cFifo -= 1;
                if (cFifo < 0)
                {
                    IO_ALL_EMPTY(ppdev);
                    cFifo = MM_ALL_EMPTY_FIFO_COUNT - 1;
                }
                MM_ABS_CUR_Y(ppdev, pjMmBase, yTrapezoid - cyTrapezoid);
            }

            // Advance the right wall:

            xRight      += ptd->aed[RIGHT].dx;
            lRightError += ptd->aed[RIGHT].lErrorUp;

            if (lRightError >= 0)
            {
                lRightError -= ptd->aed[RIGHT].dN;
                xRight++;
            }

            // Advance the left wall:

            xLeft      += ptd->aed[LEFT].dx;
            lLeftError += ptd->aed[LEFT].lErrorUp;

            if (lLeftError >= 0)
            {
                lLeftError -= ptd->aed[LEFT].dN;
                xLeft++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                break;
        }

        ptd->aed[LEFT].lError  = lLeftError;
        ptd->aed[LEFT].x       = xLeft - xOffset;
        ptd->aed[RIGHT].lError = lRightError;
        ptd->aed[RIGHT].x      = xRight - xOffset;
    }
}

/******************************Public*Routine******************************\
* VOID vMmPatternTrapezoid
*
* Draws a patterned trapezoid using a software DDA.
*
\**************************************************************************/

VOID vMmPatternTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapezoid,
LONG            cyTrapezoid)
{
    PDEV*       ppdev;
    BYTE*       pjMmBase;
    LONG        xOffset;
    LONG        lLeftError;
    LONG        xLeft;
    LONG        lRightError;
    LONG        xRight;
    LONG        lTmp;
    EDGEDATA    edTmp;
    LONG        cFifo;

    ppdev = ptd->ppdev;
    pjMmBase = ppdev->pjMmBase;

    xOffset     = ppdev->xOffset;
    yTrapezoid += ppdev->yOffset;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0))
    {
        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

        xLeft  = ptd->aed[LEFT].x + xOffset;
        xRight = ptd->aed[RIGHT].x + xOffset;
        if (xLeft > xRight)
        {
            SWAP(xLeft,          xRight,          lTmp);
            SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
        }

        if (xLeft < xRight)
        {

            // Bliter doesn't handle negative X's with clipping
            // (at least at 24BPP on the 968).
            // So do SW clipping at X=0

            if (xRight > 0)
            {
                IO_FIFO_WAIT(ppdev, 6);
                if (xLeft <= 0)
                {
                    MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, xRight - 1);
                    MM_ABS_DEST_X(ppdev, pjMmBase, 0);
                }
                else
                {
                    MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, xRight - xLeft - 1);
                    MM_ABS_DEST_X(ppdev, pjMmBase, xLeft);      // Already absolute
                }
                MM_MIN_AXIS_PCNT(ppdev, pjMmBase, cyTrapezoid - 1);
                MM_ABS_DEST_Y(ppdev, pjMmBase, yTrapezoid);
                MM_CMD(ppdev, pjMmBase, (PATTERN_FILL | DRAWING_DIR_TBLRXM |
                                        DRAW         | WRITE));
                MM_MIN_AXIS_PCNT(ppdev, pjMmBase, 0);
            }
        }
    }
    else
    {
        IO_ALL_EMPTY(ppdev);
        MM_ABS_DEST_Y(ppdev, pjMmBase, yTrapezoid);

        cFifo = MM_ALL_EMPTY_FIFO_COUNT - 1;
        yTrapezoid += cyTrapezoid + 1; // One past end scan

        lLeftError  = ptd->aed[LEFT].lError;
        xLeft       = ptd->aed[LEFT].x + xOffset;
        lRightError = ptd->aed[RIGHT].lError;
        xRight      = ptd->aed[RIGHT].x + xOffset;

        while (TRUE)
        {
            /////////////////////////////////////////////////////////////////
            // Run the DDAs

            if (xLeft < xRight)
            {
                // Bliter doesn't handle negative X's with clipping
                // (at least at 24BPP on the 968).
                // So do SW clipping at X=0

                if (xRight > 0)
                {
                    // We get a little tricky here and try to amortize the cost
                    // of the read for checking the FIFO count on the S3.

                    cFifo -= 3;
                    if (cFifo < 0)
                    {
                        IO_ALL_EMPTY(ppdev);
                        cFifo = MM_ALL_EMPTY_FIFO_COUNT - 3;
                    }

                    if (xLeft <= 0)
                    {
                        MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, xRight - 1);
                        MM_ABS_DEST_X(ppdev, pjMmBase, 0);
                    }
                    else
                    {
                        MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, xRight - xLeft - 1);
                        MM_ABS_DEST_X(ppdev, pjMmBase, xLeft);
                    }
                    MM_CMD(ppdev, pjMmBase, (PATTERN_FILL | DRAWING_DIR_TBLRXM |
                                            DRAW         | WRITE));
                }
                else
                {
                    // SW clipping at X==0 skipped the blit completely but
                    // the Y value must still be updated
                    cFifo -= 1;
                    if (cFifo < 0)
                    {
                        IO_ALL_EMPTY(ppdev);
                        cFifo = MM_ALL_EMPTY_FIFO_COUNT - 1;
                    }
                    MM_ABS_DEST_Y(ppdev, pjMmBase, yTrapezoid - cyTrapezoid);
                }
            }
            else if (xLeft > xRight)
            {
                // We don't bother optimizing this case because we should
                // rarely get self-intersecting polygons (if we're slow,
                // the app gets what it deserves).

                SWAP(xLeft,          xRight,          lTmp);
                SWAP(lLeftError,     lRightError,     lTmp);
                SWAP(ptd->aed[LEFT], ptd->aed[RIGHT], edTmp);
                continue;
            }
            else
            {
                cFifo -= 1;
                if (cFifo < 0)
                {
                    IO_ALL_EMPTY(ppdev);
                    cFifo = MM_ALL_EMPTY_FIFO_COUNT - 1;
                }
                MM_ABS_DEST_Y(ppdev, pjMmBase, yTrapezoid - cyTrapezoid);
            }

            // Advance the right wall:

            xRight      += ptd->aed[RIGHT].dx;
            lRightError += ptd->aed[RIGHT].lErrorUp;

            if (lRightError >= 0)
            {
                lRightError -= ptd->aed[RIGHT].dN;
                xRight++;
            }

            // Advance the left wall:

            xLeft      += ptd->aed[LEFT].dx;
            lLeftError += ptd->aed[LEFT].lErrorUp;

            if (lLeftError >= 0)
            {
                lLeftError -= ptd->aed[LEFT].dN;
                xLeft++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                break;
        }

        ptd->aed[LEFT].lError  = lLeftError;
        ptd->aed[LEFT].x       = xLeft - xOffset;
        ptd->aed[RIGHT].lError = lRightError;
        ptd->aed[RIGHT].x      = xRight - xOffset;
    }
}

/******************************Public*Routine******************************\
* VOID vMmTrapezoidSetup
*
* Initialize the hardware and some state for doing trapezoids.
*
\**************************************************************************/

VOID vMmTrapezoidSetup(
PDEV*           ppdev,
ULONG           rop4,
ULONG           iSolidColor,
RBRUSH*         prb,
POINTL*         pptlBrush,
TRAPEZOIDDATA*  ptd,
RECTL*          prclClip)       // NULL if no clipping
{
    BYTE*       pjMmBase;
    ULONG       ulHwForeMix;
    BRUSHENTRY* pbe;

    ptd->ppdev = ppdev;

    pjMmBase    = ppdev->pjMmBase;
    ulHwForeMix = gaulHwMixFromRop2[(rop4 >> 2) & 0xf];

    if (iSolidColor != -1)
    {
        /////////////////////////////////////////////////////////////////
        // Setup the hardware for solid colours

        ptd->pfnTrap = vMmSolidTrapezoid;

        // We initialize the hardware for the colour, mix, pixel operation,
        // rectangle height of one, and the y position for the first scan:

        IO_FIFO_WAIT(ppdev, 4);
        MM_FRGD_COLOR(ppdev, pjMmBase, iSolidColor);
        MM_FRGD_MIX(ppdev, pjMmBase, FOREGROUND_COLOR | ulHwForeMix);
        MM_PIX_CNTL(ppdev, pjMmBase, ALL_ONES);
        MM_MIN_AXIS_PCNT(ppdev, pjMmBase, 0);
    }
    else
    {
        /////////////////////////////////////////////////////////////////
        // Setup for patterns

        ptd->pfnTrap = vMmPatternTrapezoid;

        pbe = prb->pbe;
        if (((rop4 >> 8) & 0xff) == (rop4 & 0xff))
        {
            // Normal brush:

            IO_FIFO_WAIT(ppdev, 5);

            MM_ABS_CUR_X(ppdev, pjMmBase, pbe->x);
            MM_ABS_CUR_Y(ppdev, pjMmBase, pbe->y);
            MM_PIX_CNTL(ppdev, pjMmBase, ALL_ONES);
            MM_FRGD_MIX(ppdev, pjMmBase, SRC_DISPLAY_MEMORY | ulHwForeMix);
            MM_MIN_AXIS_PCNT(ppdev, pjMmBase, 0);
        }
        else
        {
            // Transparent brush:

            IO_FIFO_WAIT(ppdev, 8);
            MM_FRGD_COLOR(ppdev, pjMmBase, prb->ulForeColor);
            MM_RD_MASK(ppdev, pjMmBase, 1);   // Pick a plane, any plane
            MM_ABS_CUR_X(ppdev, pjMmBase, pbe->x);
            MM_ABS_CUR_Y(ppdev, pjMmBase, pbe->y);
            MM_PIX_CNTL(ppdev, pjMmBase, DISPLAY_MEMORY);
            MM_FRGD_MIX(ppdev, pjMmBase, FOREGROUND_COLOR | ulHwForeMix);
            MM_BKGD_MIX(ppdev, pjMmBase, BACKGROUND_COLOR | LEAVE_ALONE);
            MM_MIN_AXIS_PCNT(ppdev, pjMmBase, 0);
        }
    }

    if (prclClip != NULL)
    {
        ptd->pfnTrapClip = ptd->pfnTrap;
        ptd->pfnTrap     = vClipTrapezoid;
        ptd->yClipTop    = prclClip->top;
        ptd->yClipBottom = prclClip->bottom;

        IO_FIFO_WAIT(ppdev, 2);
        MM_ABS_SCISSORS_L(ppdev, pjMmBase, ppdev->xOffset + prclClip->left);
        MM_ABS_SCISSORS_R(ppdev, pjMmBase, ppdev->xOffset + prclClip->right - 1);
    }
}

/******************************Public*Routine******************************\
* BOOL bFastFill
*
* Draws a non-complex, unclipped polygon.  'Non-complex' is defined as
* having only two edges that are monotonic increasing in 'y'.  That is,
* the polygon cannot have more than one disconnected segment on any given
* scan.  Note that the edges of the polygon can self-intersect, so hourglass
* shapes are permissible.  This restriction permits this routine to run two
* simultaneous DDAs, and no sorting of the edges is required.
*
* Note that NT's fill convention is different from that of Win 3.1 or Win95.
* With the additional complication of fractional end-points, our convention
* is the same as in 'X-Windows'.  But a DDA is a DDA is a DDA, so once you
* figure out how we compute the DDA terms for NT, you're golden.
*
* This routine handles patterns only when the S3 hardware patterns can be
* used.  The reason for this is that once the S3 pattern initialization is
* done, pattern fills appear to the programmer exactly the same as solid
* fills (with the slight difference that different registers and commands
* are used).  Handling 'vIoFillPatSlow' style patterns in this routine
* would be non-trivial...
*
* We take advantage of the fact that the S3 automatically advances the
* current 'y' to the following scan whenever a rectangle is output so that
* we have to write to the accelerator three times for every scan: one for
* the new 'x', one for the new 'width', and one for the drawing command.
*
* Returns TRUE if the polygon was drawn; FALSE if the polygon was complex.
*
\**************************************************************************/

BOOL bFastFill(
PDEV*       ppdev,
LONG        cEdges,         // Includes close figure edge
POINTFIX*   pptfxFirst,
ULONG       rop4,
ULONG       iSolidColor,
RBRUSH*     prb,
POINTL*     pptlBrush,
RECTL*      prclClip)       // NULL if no clipping
{
    LONG      yTrapezoid;   // Top scan for next trapezoid
    LONG      cyTrapezoid;  // Number of scans in current trapezoid
    LONG      yStart;       // y-position of start point in current edge
    LONG      dM;           // Edge delta in FIX units in x direction
    LONG      dN;           // Edge delta in FIX units in y direction
    LONG      i;
    POINTFIX* pptfxLast;    // Points to the last point in the polygon array
    POINTFIX* pptfxTop;     // Points to the top-most point in the polygon
    POINTFIX* pptfxOld;     // Start point in current edge
    POINTFIX* pptfxScan;    // Current edge pointer for finding pptfxTop
    LONG      cScanEdges;   // Number of edges scanned to find pptfxTop
                            //  (doesn't include the closefigure edge)
    LONG      iEdge;
    LONG      lQuotient;
    LONG      lRemainder;
    BYTE*     pjBase;

    TRAPEZOIDDATA   td;     // Edge data and stuff
    EDGEDATA*       ped;    // Points to current edge being processed

    /////////////////////////////////////////////////////////////////
    // See if the polygon is convex

    pptfxScan = pptfxFirst;
    pptfxTop  = pptfxFirst;                 // Assume for now that the first
                                            //  point in path is the topmost
    pptfxLast = pptfxFirst + cEdges - 1;

    if (cEdges <= 2)
        goto ReturnTrue;

    // 'pptfxScan' will always point to the first point in the current
    // edge, and 'cScanEdges' will the number of edges remaining, including
    // the current one:

    cScanEdges = cEdges - 1;     // The number of edges, not counting close figure

    if ((pptfxScan + 1)->y > pptfxScan->y)
    {
        // Collect all downs:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFillingCheck;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        // Collect all downs:

        pptfxTop = pptfxScan;

        do {
            if ((pptfxScan + 1)->y > pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        goto ReturnFalse;
    }
    else
    {
        // Collect all ups:

        do {
            pptfxTop++;                 // We increment this now because we
                                        //  want it to point to the very last
                                        //  point if we early out in the next
                                        //  statement...
            if (--cScanEdges == 0)
                goto SetUpForFilling;
        } while ((pptfxTop + 1)->y <= pptfxTop->y);

        // Collect all downs:

        pptfxScan = pptfxTop;
        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if ((pptfxScan + 1)->y < pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        goto ReturnFalse;
    }

SetUpForFillingCheck:

    // We check to see if the end of the current edge is higher
    // than the top edge we've found so far:

    if ((pptfxScan + 1)->y < pptfxTop->y)
        pptfxTop = pptfxScan + 1;

SetUpForFilling:

    /////////////////////////////////////////////////////////////////
    // Some Initialization

    td.aed[LEFT].pptfx  = pptfxTop;
    td.aed[RIGHT].pptfx = pptfxTop;

    yTrapezoid = (pptfxTop->y + 15) >> 4;

    // Make sure we initialize the DDAs appropriately:

    td.aed[LEFT].cy  = 0;
    td.aed[RIGHT].cy = 0;

    // Guess as to the ordering of the points:

    td.aed[LEFT].dptfx  = sizeof(POINTFIX);
    td.aed[RIGHT].dptfx = -(LONG) sizeof(POINTFIX);

    if ((ppdev->flCaps & (CAPS_MM_IO | CAPS_16_ENTRY_FIFO))
                      == (CAPS_MM_IO | CAPS_16_ENTRY_FIFO))
    {
        vMmTrapezoidSetup(ppdev, rop4, iSolidColor, prb, pptlBrush, &td,
                          prclClip);
    }
    else
    {
        vIoTrapezoidSetup(ppdev, rop4, iSolidColor, prb, pptlBrush, &td,
                          prclClip);
    }

NewTrapezoid:

    /////////////////////////////////////////////////////////////////
    // DDA initialization

    for (iEdge = 1; iEdge >= 0; iEdge--)
    {
        ped       = &td.aed[iEdge];
        ped->bNew = FALSE;
        if (ped->cy == 0)
        {
            // Our trapezoid drawing routine may want to be notified when
            // it will have to reset its DDA to start a new edge:

            ped->bNew = TRUE;

            // Need a new DDA:

            do {
                cEdges--;
                if (cEdges < 0)
                    goto ResetClippingAndReturnTrue;

                // Find the next left edge, accounting for wrapping:

                pptfxOld = ped->pptfx;
                ped->pptfx = (POINTFIX*) ((BYTE*) ped->pptfx + ped->dptfx);

                if (ped->pptfx < pptfxFirst)
                    ped->pptfx = pptfxLast;
                else if (ped->pptfx > pptfxLast)
                    ped->pptfx = pptfxFirst;

                // Have to find the edge that spans yTrapezoid:

                ped->cy = ((ped->pptfx->y + 15) >> 4) - yTrapezoid;

                // With fractional coordinate end points, we may get edges
                // that don't cross any scans, in which case we try the
                // next one:

            } while (ped->cy <= 0);

            // 'pptfx' now points to the end point of the edge spanning
            // the scan 'yTrapezoid'.

            dN = ped->pptfx->y - pptfxOld->y;
            dM = ped->pptfx->x - pptfxOld->x;

            ASSERTDD(dN > 0, "Should be going down only");

            // Compute the DDA increment terms:

            ped->dM = dM;                   // Not used for software trapezoid

            if (dM < 0)
            {
                dM = -dM;
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = -1;
                    ped->lErrorUp = dN - dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = -lQuotient;     // - dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                    if (ped->lErrorUp > 0)
                    {
                        ped->dx--;
                        ped->lErrorUp = dN - ped->lErrorUp;
                    }
                }
            }
            else
            {
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = 0;
                    ped->lErrorUp = dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = lQuotient;      // dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                }
            }

            ped->dN = dN; // DDA limit
            ped->lError     = -1; // Error is initially zero (add dN - 1 for
                                  //  the ceiling, but subtract off dN so that
                                  //  we can check the sign instead of comparing
                                  //  to dN)

            ped->x = pptfxOld->x;
            yStart = pptfxOld->y;

            if ((yStart & 15) != 0)
            {
                // Advance to the next integer y coordinate

                for (i = 16 - (yStart & 15); i != 0; i--)
                {
                    ped->x      += ped->dx;
                    ped->lError += ped->lErrorUp;
                    if (ped->lError >= 0)
                    {
                        ped->lError -= ped->dN;
                        ped->x++;
                    }
                }
            }

            if ((ped->x & 15) != 0)
            {
                ped->lError -= ped->dN * (16 - (ped->x & 15));
                ped->x += 15;       // We'll want the ceiling in just a bit...
            }

            // Chop off those fractional bits:

            ped->x      >>= 4;
            ped->lError >>= 4;
        }
    }

    cyTrapezoid = min(td.aed[LEFT].cy, td.aed[RIGHT].cy); // # of scans in this trap
    td.aed[LEFT].cy  -= cyTrapezoid;
    td.aed[RIGHT].cy -= cyTrapezoid;

    td.pfnTrap(&td, yTrapezoid, cyTrapezoid);

    yTrapezoid += cyTrapezoid;

    goto NewTrapezoid;

ResetClippingAndReturnTrue:

    if (prclClip != NULL)
    {
        vResetClipping(ppdev);
    }

ReturnTrue:

    return(TRUE);

ReturnFalse:

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\hw.h ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: hw.h
*
* All the hardware specific driver file stuff.  Parts are mirrored in
* 'hw.inc'.
*
* Copyright (c) 1992-1998 Microsoft Corporation
*
\**************************************************************************/

////////////////////////////////////////////////////////////////////////
// Chip equates:

#define STATUS_1                        0x03DA
#define DISPLAY_MODE_INACTIVE           0x001
#define VBLANK_ACTIVE                   0x008

#define CRTC_INDEX                      0x03D4
#define CRTC_DATA                       0x03D5

#define S3R8                            0x038
#define S3R9                            0x039
#define S3R1                            0x031
#define S3R5                            0x035

#define CR39                            0x039
#define CR4C                            0x04C
#define CR4D                            0x04D

#define HGC_MODE                        0x045
#define HGC_ENABLE                      0x001
#define HGC_DISABLE                     0x000

#define HGC_ORGX_LSB                    0x047
#define HGC_ORGX_MSB                    0x046
#define HGC_ORGY_LSB                    0x049
#define HGC_ORGY_MSB                    0x048

#define HGC_DX                          0x04E
#define HGC_DY                          0x04F

#define REG_UNLOCK_1                    0x048
#define CPUA_BASE                       0x001

#define SYSCTL_UNLOCK                   0x0A0
#define SYSCTL_LOCK                     0x000

#define SYS_CNFG                        0x040
#define LAW_CTL                         0x058
#define EX_SCTL_2                       0x051
#define EX_DAC_CT                       0x055

#define MISC_1                          0x03A

///////////////////////////////////////////////////////////////////////
// Brooktree 485 stuff:

#define BT485_ADDR_CMD_REG0             0x03c6
#define BT485_ADDR_CMD_REG1             0x03c8
#define BT485_ADDR_CMD_REG2             0x03c9
#define BT485_ADDR_CMD_REG3             0x03c6

#define BT485_CMD_REG_3_ACCESS          0x080

#define BT485_ADDR_CUR_COLOR_WRITE      0x03c8
#define BT485_CUR_COLOR_DATA            0x03c9
#define BT485_ADDR_CUR_RAM_WRITE        0x03c8
#define BT485_CUR_RAM_ARRAY_DATA        0x03c7

#define BT485_CURSOR_COLOR_1            0x01
#define BT485_CURSOR_COLOR_2            0x02

#define BT485_CURSOR_X_LOW              0x03c8
#define BT485_CURSOR_X_HIGH             0x03c9

#define BT485_CURSOR_Y_LOW              0x03c6
#define BT485_CURSOR_Y_HIGH             0x03c7

#define BT485_CURSOR_DISABLE            (~0x03)
#define BT485_CURSOR_MODE2              0x02

#define BT485_64X64_CURSOR              0x04

// Command types:

#define DRAW_LINE                       0x02000
#define RECTANGLE_FILL                  0x04000
#define POLYGON_SOLID                   0x06000
#define FOUR_POINT_TRAPEZOID_SOLID      0x08000
#define BRESENHAM_TRAPEZOID_SOLID       0x0A000
#define BITBLT                          0x0C000
#define PATTERN_FILL                    0x0E000
#define POLYLINE                        0x02800
#define POLYGON_PATTERN                 0x06800
#define FOUR_POINT_TRAPEZOID_PATTERN    0x08800
#define BRESENHAM_TRAPEZOID_PATTERN     0x0A800
#define ROPBLT                          0x0C800

#define BYTE_SWAP                       0x01000
#define BUS_SIZE_NEW_32                 0x00600
#define BUS_SIZE_32                     0x00400
#define BUS_SIZE_16                     0x00200
#define BUS_SIZE_8                      0x00000
#define WAIT                            0x00100

// Drawing directions (radial):

#define DRAWING_DIRECTION_0             0x0000
#define DRAWING_DIRECTION_45            0x0020
#define DRAWING_DIRECTION_90            0x0040
#define DRAWING_DIRECTION_135           0x0060
#define DRAWING_DIRECTION_180           0x0080
#define DRAWING_DIRECTION_225           0x00A0
#define DRAWING_DIRECTION_270           0x00C0
#define DRAWING_DIRECTION_315           0x00E0

// Drawing directions (x/y):

#define DRAWING_DIR_BTRLXM              0x0000
#define DRAWING_DIR_BTLRXM              0x0020
#define DRAWING_DIR_BTRLYM              0x0040
#define DRAWING_DIR_BTLRYM              0x0060
#define DRAWING_DIR_TBRLXM              0x0080
#define DRAWING_DIR_TBLRXM              0x00A0
#define DRAWING_DIR_TBRLYM              0x00C0
#define DRAWING_DIR_TBLRYM              0x00E0

// Drawing direction bits:

#define PLUS_X                          0x0020
#define PLUS_Y                          0x0080
#define MAJOR_Y                         0x0040

// Draw:

#define DRAW                            0x0010

// Direction type:

#define DIR_TYPE_RADIAL                 0x0008
#define DIR_TYPE_XY                     0x0000

// Last pixel:

#define LAST_PIXEL_OFF                  0x0004
#define LAST_PIXEL_ON                   0x0000

// Pixel mode:

#define MULTIPLE_PIXELS                 0x0002
#define SINGLE_PIXEL                    0x0000

// Read/write:

#define READ                            0x0000
#define WRITE                           0x0001

// Graphics processor status:

#define HARDWARE_BUSY                   0x0200
#define READ_DATA_AVAILABLE             0x0100
#define GP_ALL_EMPTY                    0x0400

// S3 chips that support MM I/O and ALL_EMPTY have 16 FIFO slots:

#define MM_ALL_EMPTY_FIFO_COUNT         16
#define IO_ALL_EMPTY_FIFO_COUNT         8

#define MULT_MISC_COLOR_COMPARE         0x0100

// Fifo status in terms of empty entries:

#define FIFO_1_EMPTY                    0x080
#define FIFO_2_EMPTY                    0x040
#define FIFO_3_EMPTY                    0x020
#define FIFO_4_EMPTY                    0x010
#define FIFO_5_EMPTY                    0x008
#define FIFO_6_EMPTY                    0x004
#define FIFO_7_EMPTY                    0x002
#define FIFO_8_EMPTY                    0x001

// These are the defines for the multifunction control register.
// The 4 MSBs define the function of the register.

#define RECT_HEIGHT                     0x00000

#define CLIP_TOP                        0x01000
#define CLIP_LEFT                       0x02000
#define CLIP_BOTTOM                     0x03000
#define CLIP_RIGHT                      0x04000

#define DATA_EXTENSION                  0x0A000
#define MULT_MISC_INDEX                 0x0E000
#define READ_SEL_INDEX                  0x0F000

#define ALL_ONES                        0x00000
#define CPU_DATA                        0x00080
#define DISPLAY_MEMORY                  0x000C0

// Colour source:

#define BACKGROUND_COLOR                0x000
#define FOREGROUND_COLOR                0x020
#define SRC_CPU_DATA                    0x040
#define SRC_DISPLAY_MEMORY              0x060

// Mix modes:

#define NOT_SCREEN                      0x00
#define LOGICAL_0                       0x01
#define LOGICAL_1                       0x02
#define LEAVE_ALONE                     0x03
#define NOT_NEW                         0x04
#define SCREEN_XOR_NEW                  0x05
#define NOT_SCREEN_XOR_NEW              0x06
#define OVERPAINT                       0x07
#define NOT_SCREEN_OR_NOT_NEW           0x08
#define SCREEN_OR_NOT_NEW               0x09
#define NOT_SCREEN_OR_NEW               0x0A
#define SCREEN_OR_NEW                   0x0B
#define SCREEN_AND_NEW                  0x0C
#define NOT_SCREEN_AND_NEW              0x0D
#define SCREEN_AND_NOT_NEW              0x0E
#define NOT_SCREEN_AND_NOT_NEW          0x0F

////////////////////////////////////////////////////////////////////
// S3 port control
////////////////////////////////////////////////////////////////////

// Accelerator port addresses:

#define CUR_Y                           0x082E8
#define CUR_X                           0x086E8
#define DEST_Y                          0x08AE8
#define DEST_X                          0x08EE8
#define AXSTP                           0x08AE8
#define DIASTP                          0x08EE8
#define ERR_TERM                        0x092E8
#define MAJ_AXIS_PCNT                   0x096E8
#define CMD                             0x09AE8
#define SHORT_STROKE                    0x09EE8
#define BKGD_COLOR                      0x0A2E8
#define FRGD_COLOR                      0x0A6E8
#define WRT_MASK                        0x0AAE8
#define RD_MASK                         0x0AEE8
#define COLOR_CMP                       0x0B2E8
#define BKGD_MIX                        0x0B6E8
#define FRGD_MIX                        0x0BAE8
#define MULTIFUNC_CNTL                  0x0BEE8
#define MIN_AXIS_PCNT                   0x0BEE8
#define SCISSORS                        0x0BEE8
#define PIX_CNTL                        0x0BEE8
#define PIX_TRANS                       0x0E2E8

// Packed addresses, for Trio64 or newer:

#define ALT_CURXY                       0x08100
#define ALT_CURXY2                      0x08104
#define ALT_STEP                        0x08108
#define ALT_STEP2                       0x0810C
#define ALT_ERR                         0x08110
#define ALT_CMD                         0x08118
#define ALT_MIX                         0x08134
#define ALT_PCNT                        0x08148
#define ALT_PAT                         0x08168
#define SCISSORS_T                      0x08138
#define SCISSORS_L                      0x0813A
#define SCISSORS_B                      0x0813C
#define SCISSORS_R                      0x0813E
#define MULT_MISC_READ_SEL              0x08144

////////////////////////////////////////////////////////////////////
// S3 streams processor
////////////////////////////////////////////////////////////////////

// Stream processor register definitions

#define	P_CONTROL		0x8180	// Primary Stream Control register
#define	  CKEY_LOW		0x8184	// Color/Chroma Key Control
#define	S_CONTROL		0x8190	// Secondary Stream Control
#define	  CKEY_HI		0x8194	// Chroma Key Upper Bound
#define	S_HK1K2			0x8198	// Secondary Stream Stretch/Filter const
#define	  BLEND_CONTROL		0x81a0	// Blend Control
#define	P_0			0x81c0	// Primary Stream Frame Buffer Address 0
#define	P_1			0x81c4	// Primary Stream Frame Buffer Address 1
#define	P_STRIDE		0x81c8	// Primary Stream Stride
#define	  LPB_DB		0x81cc	// Double buffer and LPB Support
#define	S_0			0x81d0	// Secondary Stream Frame Buffer Addr 0
#define	S_1			0x81d4	// Secondary Stream Frame Buffer Addr 1
#define	S_STRIDE		0x81d8	// Secondary Stream Stride
#define	  OPAQUE_CONTROL	0x81dc	// Opaque Overlay Control
#define	S_VK1			0x81e0	// K1 Vertical Scale Factor	
#define	S_VK2			0x81e4	// K2 Vertical Scale Factor
#define	S_VDDA			0x81e8	// DDA Vertical Accumulator Init Value
#define	  FIFO_CONTROL		0x81ec	// Stream FIFO and RAS Controls
#define	P_XY			0x81f0	// Primary Stream Window Start Coord
#define	P_WH			0x81f4	// Primary Stream Window Size
#define	S_XY			0x81f8	// Secondary Stream Window Start Coord
#define	S_WH			0x81fc	// Secondary Stream Window Size

#define P_Format_Shift		24
#define P_Format_Mask		(7L << P_Format_Shift)
#define P_RGB8			(0L << P_Format_Shift)
#define P_RGB15			(3L << P_Format_Shift)
#define P_RGB16			(5L << P_Format_Shift)
#define P_RGB24			(6L << P_Format_Shift)
#define P_RGB32			(7L << P_Format_Shift)
#define P_Filter_Shift		28
#define P_Filter_Mask		(7L << P_Filter_Shift)
#define P_1x			(0L << P_Filter_Shift)
#define P_2x			(1L << P_Filter_Shift)
#define P_2xBiLinear		(2L << P_Filter_Shift)

#define BVCr_Shift		0
#define BVCr_Mask		(255L << BVCr_Shift)
#define GUCb_Shift		8
#define GUCb_Mask		(255L << GUCb_Shift)
#define RY_Shift		16
#define RY_Mask			(255L << RY_Shift)
#define Compare_Shift		24
#define Compare_Mask		(255L << Compare_Shift)
#define CompareBits7		(0L  << Compare_Shift)
#define CompareBits6t7		(1L  << Compare_Shift)
#define CompareBits5t7		(2L  << Compare_Shift)
#define CompareBits4t7		(3L  << Compare_Shift)
#define CompareBits3t7		(4L  << Compare_Shift)
#define CompareBits2t7		(5L  << Compare_Shift)
#define CompareBits1t7		(6L  << Compare_Shift)
#define CompareBits0t7		(7L  << Compare_Shift)
#define KeyFrom_Shift		28
#define KeyFrom_Mask		(1L << KeyFrom_Shift)
#define KeyFromStream		(0L << KeyFrom_Shift)
#define KeyFromCompare		(1L << KeyFrom_Shift)

#define HDDA_Shift		0
#define HDDA_Mask		(((1L << 12)-1) << HDDA_Shift)
#define S_Format_Shift		24
#define S_Format_Mask		(7L << S_Format_Shift)
#define S_YCrCb422		(1L << S_Format_Shift)
#define S_YUV422		(2L << S_Format_Shift)
#define S_RGB15			(3L << S_Format_Shift)
#define S_YUV211		(4L << S_Format_Shift)
#define S_RGB16			(5L << S_Format_Shift)
#define S_RGB24			(6L << S_Format_Shift)
#define S_RGB32			(7L << S_Format_Shift)
#define S_Filter_Shift		28
#define S_Filter_Mask		(7L << S_Filter_Shift)
#define S_1x			(0L << S_Filter_Shift)
#define S_Upto2x		(1L << S_Filter_Shift)
#define S_2xTo4x		(2L << S_Filter_Shift)
#define S_Beyond4x		(3L << S_Filter_Shift)

#define HighVCr_Shift		0
#define HighVCr_Mask		(255L << HighVCr_Shift)
#define HighUCb_Shift		8
#define HighUCb_Mask		(255L << HighUCb_Shift)
#define HighY_Shift		16
#define HighY_Mask		(255L << HighY_Shift)

#define HK1_Shift		0
#define HK1_Mask		(((1L << 11) - 1) << HK1_Shift)
#define HK2_Shift		16
#define HK2_Mask		(((1L << 11) - 1) << HK2_Shift)
#define VK1_Shift		0
#define VK1_Mask		(((1L << 11) - 1) << VK1_Shift)
#define VK2_Shift		0
#define VK2_Mask		(((1L << 11) - 1) << VK2_Shift)
#define VDDA_Shift		0
#define VDDA_Mask		(((1L << 12) - 1) << VDDA_Shift)

#define Ks_Shift		2
#define Ks_Mask			(7L << Ks_Shift)
#define Kp_Shift		10
#define Kp_Mask			(7L << Kp_Shift)
#define Compose_Shift		24
#define Compose_Mask		(7L << Compose_Shift)
#define SOnP			(0L << Compose_Shift)
#define POnS			(1L << Compose_Shift)
#define Dissolve		(2L << Compose_Shift)
#define Fade			(3L << Compose_Shift)
#define KeyOnP			(5L << Compose_Shift)
#define KeyOnS			(6L << Compose_Shift)

#define FifoAlloc_Shift		0
#define FifoAlloc_Mask		(31L << StrFifoAlloc_Shift)
#define FifoAlloc24_0		(0L  << StrFifoAlloc_Shift)
#define FifoAlloc16_8		(8L  << StrFifoAlloc_Shift)
#define FifoAlloc12_12		(12L << StrFifoAlloc_Shift)
#define FifoAlloc8_16		(16L << StrFifoAlloc_Shift)
#define FifoAlloc0_24		(24L << StrFifoAlloc_Shift)

#define S_FifoThresh_Shift	5
#define S_FifoThresh_Mask	(31L << S_FifoThresh_Shift)

#define P_FifoThresh_Shift	10
#define P_FifoThresh_Mask	(31L << P_FifoThresh_Shift)

#define RASLowTime_Shift	15
#define RASLowTime_Mask		(1L << RASLowTime_Shift)
#define RASLowTimeFromCR68	(0L << RASLowTime_Shift)
#define RASLowTime2_5		(1L << RASLowTime_Shift)

#define RASPreCharge_Shift	16
#define RASPreCharge_Mask	(1L << RASPreCharge_Shift)
#define RASPreChargeFromCR68	(0L << RASPreCharge_Shift)
#define RASPreCharge1_5		(1L << RASPreCharge_Shift)

#define RASInactive_Shift	17
#define RASInactive_Mask	(1L << RASInactive_Shift)
#define RASInactiveLow		(0L << RASInactive_Shift)
#define RASInactiveHigh		(1L << RASInactive_Shift)

#define MemoryCycle_Shift	18
#define MemoryCycle_Mask	(1L << MemoryCycle_Shift)
#define MemoryCycle2		(0L << MemoryCycle_Shift)
#define MemoryCycle1		(1L << MemoryCycle_Shift)

#define H_Shift			0
#define H_Mask			(0x07ffL << H_Shift)
#define W_Shift			16
#define W_Mask			(0x07ffL << W_Shift)
				
#define Y_Shift			0
#define Y_Mask			(0x07ffL << Y_Shift)
#define X_Shift			16
#define X_Mask			(0x07ffL << X_Shift)

#define P_Select_Shift		0
#define P_Select_Mask		(1L << P_Select_Shift)
#define P_Select0		(0L << P_Select_Shift)
#define P_Select1		(1L << P_Select_Shift)
#define S_Select_Shift		1
#define S_Select_Mask		(3L << S_Select_Shift)
#define S_Select0		(0L << S_Select_Shift)
#define S_Select1		(1L << S_Select_Shift)
#define S_Select00Or11		(2L << S_Select_Shift)
#define S_Select01Or10		(3L << S_Select_Shift)
#define L_Select_Shift		4
#define L_Select_Mask		(1L << L_Select_Shift)
#define L_Select0		(0L << L_Select_Shift)
#define L_Select1		(1L << L_Select_Shift)
#define L_SelWait_Shift		5
#define L_SelWait_Mask		(1L << L_SelWait_Shift)
#define L_SelWaitNo		(0L << L_SelWait_Shift)
#define L_SelWaitYes		(1L << L_SelWait_Shift)
#define L_SelAutoToggle_Shift	6
#define L_SelAutoToggle_Mask	(1L << L_SelAutoToggle_Shift)
#define L_SelAutoToggleNo	(0L << L_SelAutoToggle_Shift)
#define L_SelAutoToggleYes	(1L << L_SelAutoToggle_Shift)
#define L_FramesToDrop_Shift	8
#define L_FramesToDrop_Mask	(3L << L_FramesToDrop_Shift)

#define OpqStart_Shift		3
#define OpqStart_Mask		(((1L << 10) - 1) << OpqStart_Shift)
#define OpqEnd_Shift		19
#define OpqEnd_Mask		(((1L << 10) - 1) << OpqEnd_Shift)
#define OpqTopSel_Shift		30
#define OpqTopSel_Mask		(1L << OpqTopSel_Shift)
#define OpqTopSelS_		(0L << OpqTopSel_Shift)
#define OpqTopSelP_		(1L << OpqTopSel_Shift)
#define OpqCtrl_Shift		31
#define OpqCtrl_Mask		(1L << OpqCtrl_Shift)
#define OpqDisabled		(0L << OpqCtrl_Shift)
#define OpqEnabled		(1L << OpqCtrl_Shift)

// The following defines are for VL and PCI system configuration
#define	K2V_SRD_LPB_MASK	0x03
#define	K2V_SRD_LPB		0x00
#define	K2V_SRD_FC		K2V_SRD_LPB_MASK
#define	K2V_SRD_COMP		0x02

#define	K2V_CR5C_SRC_MASK	0x03
#define	K2V_CR5C_SRC_DIGITIZER	0x02	
#define	K2V_CR5C_SRC_MPEG	0x01	

#define	K2V_SR1C_MASK		0x03
#define	K2V_SR1C_VL		0x01
#define	K2V_SR1C_PCI		0x02

// Useful macros

#define HDDA(w0,w1)  (((2*(w0-1)-(w1-1)) << HDDA_Shift) & HDDA_Mask )
#define VDDA(h1)     (((1-h1)            << VDDA_Shift) & VDDA_Mask )
#define HK1(w0)      (((w0 - 1)          << HK1_Shift)  & HK1_Mask  )
#define HK2(w0,w1)   (((w0 - w1)         << HK2_Shift)  & HK2_Mask  )
#define HK1K2(w0,w1) (HK1(w0) | HK2(w0, w1))
#define VK1(h0)      (((h0 - 1)          << VK1_Shift)  & VK1_Mask  )
#define VK2(h0,h1)   (((h0 - h1)         << VK2_Shift)  & VK2_Mask  )
#define XY(x,y)      ((((x+1)<<X_Shift)&X_Mask) | (((y+1)<<Y_Shift)&Y_Mask))
#define WH(w,h)      ((((w-1)<<W_Shift)&W_Mask) | (((h)<<H_Shift)&H_Mask))

#define HWCODEC          0
#define SWCODEC          1
#define DIGITIZER        2
#define MAX_DEVICE       3
#define DSTWIN_SIZES     5

////////////////////////////////////////////////////////////////////
// S3 pixel formatter
////////////////////////////////////////////////////////////////////

// Equates for Pixel Formatter (Video Engine) 868/968

#define INPUT_RGB8      0x00000000
#define INPUT_RGB15     0x00600000
#define INPUT_RGB16     0x00700000
#define INPUT_RGB32     0x00300000
#define INPUT_YUV422    0x00480000
#define INPUT_YCrCb422  0x00400000
#define INPUT_RAW       0x00500000
#define OUTPUT_RGB8     0x00000000
#define OUTPUT_RGB15    0x00060000
#define OUTPUT_RGB16    0x00070000
#define OUTPUT_RGB32    0x00030000
#define OUTPUT_YUY2     0x000C0000
#define OUTPUT_RAW      0x00050000

#define CSCENABLE       0x40000000
#define STRETCH         0x00000000
#define SHRINK          0x80000000
#define SCREEN          0x00000000
#define HOST            0x40000000
#define FILTERENABLE    0x80000000
#define BILINEAR        0x00000000
#define LINEAR02420     0x00004000
#define LINEAR12221     0x00008000

#define PF_BUSY         0x80000000

#define PF_NOP          0x00018080
#define PF_CONTROL      0x00018088
#define PF_DDA          0x0001808C
#define PF_STEP         0x00018090
#define PF_CROP         0x00018094
#define PF_SRCADDR      0x00018098
#define PF_DSTADDR      0x0001809C

//////////////////////////////////////////////////////////////////////
// RISC considerations
//
// CP_EIEIO() 'Ensure In-order Execution of I/O'
//    - Used to flush any pending I/O in situations where we wish to
//      avoid out-of-order execution of I/O to separate addresses.
//
// CP_MEMORY_BARRIER()
//    - Used to flush any pending I/O in situations where we wish to
//      avoid out-of-order execution or 'collapsing' of I/O to
//      the same address.  We used to have to do this separately for
//      the Alpha because unlike the PowerPC it did not guarantee that
//      output to the same address will be exectued in order.  However,
//      with the move to kernel-mode, on Alpha we are now calling HAL
//      routines for every port I/O which ensure that this is not a
//      problem.

#if defined(_ALPHA_)

    // On Alpha, since we must do all non-frame-buffer I/O through HAL
    // routines, which automatically do memory-barriers, we don't have
    // to do memory barriers ourselves (and should not, because it's a
    // performance hit).

    #define CP_EIEIO()
    #define CP_MEMORY_BARRIER()

#else

    // On other systems, both CP_EIEIO and CP_MEMORY_BARRIER don't do anything.

    #define CP_EIEIO()          MEMORY_BARRIER()
    #define CP_MEMORY_BARRIER() MEMORY_BARRIER()

#endif

////////////////////////////////////////////////////////////////////
// Macros for accessing accelerator registers:

/////////////////////////////////////////////////////////////////////////
// 32bpp Support
//
// The S3 has only 16 bit register operations.  When running at 32bpp,
// depth-related registers are written twice in succession in order to
// convey 32 bit values.

#define OUT_PSEUDO_DWORD(p, x)                      \
{                                                   \
    WRITE_PORT_USHORT((p), (USHORT)(x));            \
    CP_MEMORY_BARRIER();                            \
    WRITE_PORT_USHORT((p), (USHORT)((x) >> 16));    \
}

#define WRITE_PSEUDO_DWORD(p, x)                    \
{                                                   \
    WRITE_REGISTER_USHORT((p), (USHORT) (x));       \
    CP_MEMORY_BARRIER();                            \
    WRITE_REGISTER_USHORT((p), (USHORT) ((x) >> 16)); \
}

// DEPTH32(ppdev) returns TRUE if running at 32bpp, meaning that DEPTH32
// macros must be used, and returns FALSE if running at 8 or 16bpp,
// meaning that DEPTH macros must be used:

#define DEPTH32(ppdev)      (ppdev->iBitmapFormat == BMF_32BPP)

#define IO_GP_BUSY(ppdev)   (IO_GP_STAT(ppdev) & HARDWARE_BUSY)

#define IO_FIFO_BUSY(ppdev, level)                                  \
    (IO_GP_STAT(ppdev) & ((FIFO_1_EMPTY << 1) >> (level)))

#if DBG

    /////////////////////////////////////////////////////////////////////////
    // Checked Build
    //
    // We hook some of the accelerator macros on checked (debug) builds
    // for sanity checking.

    VOID    vOutFifoW(VOID*, ULONG);
    VOID    vOutDepth(PDEV*, VOID*, ULONG);
    VOID    vOutFifoPseudoD(PDEV*, VOID*, ULONG);
    VOID    vWriteFifoW(VOID*, ULONG);
    VOID    vWriteFifoD(VOID*, ULONG);
    VOID    vWriteFifoPseudoD(PDEV*, VOID*, ULONG);

    VOID    vIoFifoWait(PDEV*, LONG);
    VOID    vIoGpWait(PDEV*);
    VOID    vIoAllEmpty(PDEV*);

    VOID    vCheckDataReady(PDEV*);
    VOID    vCheckDataComplete(PDEV*);

    UCHAR   jInp(BYTE*, ULONG);
    USHORT  wInpW(BYTE*, ULONG);
    VOID    vOutp(BYTE*, ULONG, ULONG);
    VOID    vOutpW(BYTE*, ULONG, ULONG);

    VOID    vAcquireCrtc(PDEV*);
    VOID    vReleaseCrtc(PDEV*);

    #define OUT_FIFO_W(p, v)                vOutFifoW((p), (ULONG) (v))
    #define OUT_FIFO_PSEUDO_D(ppdev, p, v)  vOutFifoPseudoD((ppdev), (p), (ULONG) (v))
    #define WRITE_FIFO_W(p, v)              vWriteFifoW((p), (ULONG) (v))
    #define WRITE_FIFO_D(p, v)              vWriteFifoD((p), (ULONG) (v))

    #define IO_FIFO_WAIT(ppdev, level)      vIoFifoWait((ppdev), (level))
    #define IO_GP_WAIT(ppdev)               vIoGpWait(ppdev)
    #define IO_ALL_EMPTY(ppdev)             vIoAllEmpty(ppdev)

    #define CHECK_DATA_READY(ppdev)         vCheckDataReady(ppdev)
    #define CHECK_DATA_COMPLETE(ppdev)      vCheckDataComplete(ppdev)

    #define OUTPW(pjIoBase, p, v)           vOutpW((pjIoBase), (p), (ULONG) (v))
    #define OUTP(pjIoBase, p, v)            vOutp((pjIoBase), (p), (ULONG) (v))
    #define INPW(pjIoBase, p)               wInpW((pjIoBase), (p))
    #define INP(pjIoBase, p)                jInp((pjIoBase), (p))

    // The CRTC register critical section must be acquired before
    // touching the CRTC register (because of async pointers):

    #define ACQUIRE_CRTC_CRITICAL_SECTION(ppdev)    vAcquireCrtc(ppdev)
    #define RELEASE_CRTC_CRITICAL_SECTION(ppdev)    vReleaseCrtc(ppdev)

#else

    /////////////////////////////////////////////////////////////////////////
    // Free Build
    //
    // For a free (non-debug build), we make everything in-line.

    // Safe port access macros -- these macros automatically do memory
    // -----------------------    barriers, so you don't have to worry
    //                            about them:

    #if defined(_X86_)

        // x86 doesn't need 'pjIoBase' added in, so save some code space:

        #define OUTPW(pjIoBase, p, v)   WRITE_PORT_USHORT((p), (v))
        #define OUTP(pjIoBase, p, v)    WRITE_PORT_UCHAR((p), (v))
        #define INPW(pjIoBase, p)       ((USHORT)READ_PORT_USHORT((p)))
        #define INP(pjIoBase, p)        ((UCHAR)READ_PORT_UCHAR((p)))

    #else

        // Non-x86 platforms have the I/O range starting at 'pjIoBase':

        #define OUTPW(pjIoBase, p, v)                       \
        {                                                   \
            CP_EIEIO();                                     \
            WRITE_PORT_USHORT((pjIoBase) + (p), (USHORT)(v)); \
            CP_EIEIO();                                     \
        }
        #define OUTP(pjIoBase, p, v)                        \
        {                                                   \
            CP_EIEIO();                                     \
            WRITE_PORT_UCHAR((pjIoBase) + (p), (UCHAR)(v)); \
            CP_EIEIO();                                     \
        }

        __inline USHORT INPW(BYTE* pjIoBase, ULONG p)
        {
            CP_EIEIO();
            return(READ_PORT_USHORT(pjIoBase + p));
        }

        __inline UCHAR INP(BYTE* pjIoBase, ULONG p)
        {
            CP_EIEIO();
            return(READ_PORT_UCHAR(pjIoBase + p));
        }

    #endif

    // Not-so-safe port access macros -- for performance, the following macros
    // ------------------------------    do not automatically do memory
    //                                   barriers, so you must do them yourself:

    #define OUT_FIFO_W(p, v)                WRITE_PORT_USHORT((p), (USHORT) (v))
    #define OUT_FIFO_PSEUDO_D(ppdev, p, x)  OUT_PSEUDO_DWORD((p), (ULONG) (x))

    #define WRITE_FIFO_W(p, v)                    \
    {                                             \
        VPBYTE foo = (p);                         \
        WRITE_REGISTER_USHORT(foo, (USHORT) (v)); \
    }

    #define WRITE_FIFO_D(p, v)                    \
    {                                             \
        VPBYTE foo = (p);                         \
        WRITE_REGISTER_ULONG((p), (ULONG) (v));   \
    }

    #define IO_FIFO_WAIT(ppdev, level)          \
        do {;} while (IO_FIFO_BUSY(ppdev, (level)))

    #define IO_GP_WAIT(ppdev)                   \
        do {;} while (IO_GP_BUSY(ppdev))

    #define IO_ALL_EMPTY(ppdev)                 \
        do {;} while (!(IO_GP_STAT(ppdev) & GP_ALL_EMPTY))

    #define CHECK_DATA_READY(ppdev)     // Expands to nothing
    #define CHECK_DATA_COMPLETE(ppdev)  // Expands to nothing

    // The CRTC register critical section must be acquired before
    // touching the CRTC register (because of async pointers):

    #define ACQUIRE_CRTC_CRITICAL_SECTION(ppdev)                \
        EngAcquireSemaphore(ppdev->csCrtc);

    // 80x/805i/928 and 928PCI chips have a bug where if I/O registers
    // are left unlocked after accessing them, writes to memory with
    // similar addresses can cause writes to I/O registers.  The problem
    // registers are 0x40, 0x58, 0x59 and 0x5c.  We will simply always
    // leave the index set to an innocuous register (namely, the text
    // mode cursor start scan line):

    #define RELEASE_CRTC_CRITICAL_SECTION(ppdev)                \
    {                                                           \
        OUTP(ppdev->pjIoBase, CRTC_INDEX, 0xa);                 \
        EngReleaseSemaphore(ppdev->csCrtc);                     \
    }

#endif

////////////////////////////////////////////////////////////////////
// Port access using I/O

// The following are ABSOLUTE positioning macros.  They do NOT take
// the surface's offset into account (for off-screen device-format
// bitmaps):

#define IO_ABS_CUR_Y(ppdev, y)              \
    OUT_FIFO_W(ppdev->ioCur_y, (y))

#define IO_ABS_CUR_X(ppdev, x)              \
    OUT_FIFO_W(ppdev->ioCur_x, (x))

#define IO_ABS_DEST_Y(ppdev, y)             \
    OUT_FIFO_W(ppdev->ioDesty_axstp, (y))

#define IO_ABS_DEST_X(ppdev, x)             \
    OUT_FIFO_W(ppdev->ioDestx_diastp, (x))

#define IO_ABS_SCISSORS_T(ppdev, y)         \
{                                           \
    CP_MEMORY_BARRIER();                    \
    OUT_FIFO_W(ppdev->ioMulti_function, (y) | CLIP_TOP);     \
}

#define IO_ABS_SCISSORS_L(ppdev, x)         \
{                                           \
    CP_MEMORY_BARRIER();                    \
    OUT_FIFO_W(ppdev->ioMulti_function, (x) | CLIP_LEFT);    \
}

#define IO_ABS_SCISSORS_B(ppdev, y)         \
{                                           \
    CP_MEMORY_BARRIER();                    \
    OUT_FIFO_W(ppdev->ioMulti_function, (y) | CLIP_BOTTOM);  \
}

#define IO_ABS_SCISSORS_R(ppdev, x)         \
{                                           \
    CP_MEMORY_BARRIER();                    \
    OUT_FIFO_W(ppdev->ioMulti_function, (x) | CLIP_RIGHT);   \
}

// The following are RELATIVE positioning macros.  They DO take
// the surface's offset into account:

#define IO_CUR_Y(ppdev, y)                  \
    IO_ABS_CUR_Y(ppdev, (y) + ppdev->yOffset)

#define IO_CUR_X(ppdev, x)                  \
    IO_ABS_CUR_X(ppdev, (x) + ppdev->xOffset)

#define IO_DEST_Y(ppdev, y)                 \
    IO_ABS_DEST_Y(ppdev, (y) + ppdev->yOffset)

#define IO_DEST_X(ppdev, x)                 \
    IO_ABS_DEST_X(ppdev, (x) + ppdev->xOffset)

#define IO_SCISSORS_T(ppdev, y)             \
    IO_ABS_SCISSORS_T(ppdev, (y) + ppdev->yOffset)

#define IO_SCISSORS_L(ppdev, x)             \
    IO_ABS_SCISSORS_L(ppdev, (x) + ppdev->xOffset)

#define IO_SCISSORS_B(ppdev, y)             \
    IO_ABS_SCISSORS_B(ppdev, (y) + ppdev->yOffset)

#define IO_SCISSORS_R(ppdev, x)             \
    IO_ABS_SCISSORS_R(ppdev, (x) + ppdev->xOffset)

// The following are the rest of the S3 registers we use:

#define IO_AXSTP(ppdev, x)                  \
    OUT_FIFO_W(ppdev->ioDesty_axstp, (x))

#define IO_DIASTP(ppdev, x)                 \
    OUT_FIFO_W(ppdev->ioDestx_diastp, (x))

#define IO_ERR_TERM(ppdev, x)               \
    OUT_FIFO_W(ppdev->ioErr_term, (x))

#define IO_MAJ_AXIS_PCNT(ppdev, x)          \
    OUT_FIFO_W(ppdev->ioMaj_axis_pcnt, (x))

__inline USHORT IO_GP_STAT(PDEV* ppdev)
{
    CP_EIEIO();
    return(READ_PORT_USHORT(ppdev->ioGp_stat_cmd));
}

// Note that we have to put memory barriers before and after the
// command output.  The first memory barrier ensures that all the
// settings registers have been set before the command is executed,
// and the second ensures that no subsequent changes to the settings
// registers will mess up the current command:

#define IO_CMD(ppdev, x)                    \
{                                           \
    CP_EIEIO();                             \
    OUT_FIFO_W(ppdev->ioGp_stat_cmd, (x));  \
    CP_EIEIO();                             \
}

#define IO_SHORT_STROKE(ppdev, x)           \
{                                           \
    CP_EIEIO();                             \
    OUT_FIFO_W(ppdev->ioShort_stroke, (x)); \
    CP_EIEIO();                             \
}

#define IO_BKGD_MIX(ppdev, x)               \
    OUT_FIFO_W(ppdev->ioBkgd_mix, (x))

#define IO_FRGD_MIX(ppdev, x)               \
    OUT_FIFO_W(ppdev->ioFrgd_mix, (x))

#define IO_MIN_AXIS_PCNT(ppdev, x)          \
{                                           \
    CP_MEMORY_BARRIER();                    \
    OUT_FIFO_W(ppdev->ioMulti_function, (x) | RECT_HEIGHT);      \
}

#define IO_MULTIFUNC_CNTL(ppdev, x)         \
{                                           \
    CP_MEMORY_BARRIER();                    \
    OUT_FIFO_W(ppdev->ioMulti_function, (x) | MULT_MISC_INDEX);   \
}

#define IO_PIX_CNTL(ppdev, x)               \
{                                           \
    CP_MEMORY_BARRIER();                    \
    OUT_FIFO_W(ppdev->ioMulti_function, (x) | DATA_EXTENSION);   \
}

#define IO_READ_SEL(ppdev, x)               \
{                                           \
    CP_MEMORY_BARRIER();                    \
    OUT_FIFO_W(ppdev->ioMulti_function, (x) | READ_SEL_INDEX);   \
}

#define IO_MULT_MISC(ppdev, x)              \
{                                           \
    CP_MEMORY_BARRIER();                    \
    OUT_FIFO_W(ppdev->ioMulti_function, (x) | MULT_MISC_INDEX);  \
}

#define IO_RD_REG_DT(ppdev, x)              \
{                                           \
    CP_EIEIO();                             \
    x = READ_PORT_USHORT(ppdev->ioMulti_function);  \
    CP_EIEIO();                             \
}

#define IO_PIX_TRANS(ppdev, x)              \
{                                           \
    CP_MEMORY_BARRIER();                    \
    /* Can't use OUT_FIFO_W: */             \
    WRITE_PORT_USHORT(ppdev->ioPix_trans, (x)); \
}

// Macros for outputing colour-depth dependent values at 8bpp and 16bpp:

#define IO_BKGD_COLOR(ppdev, x)             \
    OUT_FIFO_W(ppdev->ioBkgd_color, (x))

#define IO_FRGD_COLOR(ppdev, x)             \
    OUT_FIFO_W(ppdev->ioFrgd_color, (x))

#define IO_WRT_MASK(ppdev, x)               \
    OUT_FIFO_W(ppdev->ioWrt_mask, (x))

#define IO_RD_MASK(ppdev, x)                \
    OUT_FIFO_W(ppdev->ioRd_mask, (x))

#define IO_COLOR_CMP(ppdev, x)              \
    OUT_FIFO_W(ppdev->ioColor_cmp, (x))

// Macros for outputing colour-depth dependent values at 32bpp:

#define IO_BKGD_COLOR32(ppdev, x)           \
    OUT_FIFO_PSEUDO_D(ppdev, ppdev->ioBkgd_color, (x))

#define IO_FRGD_COLOR32(ppdev, x)           \
    OUT_FIFO_PSEUDO_D(ppdev, ppdev->ioFrgd_color, (x))

#define IO_WRT_MASK32(ppdev, x)             \
    OUT_FIFO_PSEUDO_D(ppdev, ppdev->ioWrt_mask, (x))

#define IO_RD_MASK32(ppdev, x)              \
    OUT_FIFO_PSEUDO_D(ppdev, ppdev->ioRd_mask, (x))

#define IO_COLOR_CMP32(ppdev, x)            \
    OUT_FIFO_PSEUDO_D(ppdev, ppdev->ioColor_cmp, (x))

////////////////////////////////////////////////////////////////////
// Port access using memory-mapped I/O:

// The following are ABSOLUTE positioning macros.  They do NOT take
// the surface's offset into account:

#define MM_ABS_CUR_Y(ppdev, pjMmBase, y)              \
    WRITE_FIFO_W((BYTE*) (pjMmBase) + CUR_Y, (y))

#define MM_ABS_CUR_X(ppdev, pjMmBase, x)              \
    WRITE_FIFO_W((BYTE*) (pjMmBase) + CUR_X, (x))

#define MM_ABS_DEST_Y(ppdev, pjMmBase, y)             \
    WRITE_FIFO_W((BYTE*) (pjMmBase) + DEST_Y, (y))

#define MM_ABS_DEST_X(ppdev, pjMmBase, x)             \
    WRITE_FIFO_W((BYTE*) (pjMmBase) + DEST_X, (x))

#define MM_ABS_SCISSORS_T(ppdev, pjMmBase, y)         \
{                                                     \
    CP_MEMORY_BARRIER();                              \
    WRITE_FIFO_W((BYTE*) (pjMmBase) + SCISSORS, (y) | CLIP_TOP);    \
}

#define MM_ABS_SCISSORS_L(ppdev, pjMmBase, x)         \
{                                                     \
    CP_MEMORY_BARRIER();                              \
    WRITE_FIFO_W((BYTE*) (pjMmBase) + SCISSORS, (x) | CLIP_LEFT);   \
}

#define MM_ABS_SCISSORS_B(ppdev, pjMmBase, y)         \
{                                                     \
    CP_MEMORY_BARRIER();                              \
    WRITE_FIFO_W((BYTE*) (pjMmBase) + SCISSORS, (y) | CLIP_BOTTOM); \
}

#define MM_ABS_SCISSORS_R(ppdev, pjMmBase, x)         \
{                                                     \
    CP_MEMORY_BARRIER();                              \
    WRITE_FIFO_W((BYTE*) (pjMmBase) + SCISSORS, (x) | CLIP_RIGHT);  \
}

// The following are RELATIVE positioning macros.  They DO take
// the surface's offset into account:

#define MM_CUR_Y(ppdev, pjMmBase, y)                  \
    MM_ABS_CUR_Y(ppdev, pjMmBase, (y) + ppdev->yOffset)

#define MM_CUR_X(ppdev, pjMmBase, x)                  \
    MM_ABS_CUR_X(ppdev, pjMmBase, (x) + ppdev->xOffset)

#define MM_DEST_Y(ppdev, pjMmBase, y)                 \
    MM_ABS_DEST_Y(ppdev, pjMmBase, (y) + ppdev->yOffset)

#define MM_DEST_X(ppdev, pjMmBase, x)                 \
    MM_ABS_DEST_X(ppdev, pjMmBase, (x) + ppdev->xOffset)

#define MM_SCISSORS_T(ppdev, pjMmBase, y)             \
    MM_ABS_SCISSORS_T(ppdev, pjMmBase, (y) + ppdev->yOffset)

#define MM_SCISSORS_L(ppdev, pjMmBase, x)             \
    MM_ABS_SCISSORS_L(ppdev, pjMmBase, (x) + ppdev->xOffset)

#define MM_SCISSORS_B(ppdev, pjMmBase, y)             \
    MM_ABS_SCISSORS_B(ppdev, pjMmBase, (y) + ppdev->yOffset)

#define MM_SCISSORS_R(ppdev, pjMmBase, x)             \
    MM_ABS_SCISSORS_R(ppdev, pjMmBase, (x) + ppdev->xOffset)

// The following are the rest of the S3 registers we use:

#define MM_AXSTP(ppdev, pjMmBase, x)                  \
    WRITE_FIFO_W((BYTE*) (pjMmBase) + AXSTP, (x))

#define MM_DIASTP(ppdev, pjMmBase, x)                 \
    WRITE_FIFO_W((BYTE*) (pjMmBase) + DIASTP, (x))

#define MM_ERR_TERM(ppdev, pjMmBase, x)               \
    WRITE_FIFO_W((BYTE*) (pjMmBase) + ERR_TERM, (x))

#define MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, x)          \
    WRITE_FIFO_W((BYTE*) (pjMmBase) + MAJ_AXIS_PCNT, (x))

#define MM_CMD(ppdev, pjMmBase, x)                    \
{                                                     \
    CP_EIEIO();                                       \
    WRITE_FIFO_W((BYTE*) (pjMmBase) + CMD, (x));      \
    CP_EIEIO();                                       \
}

#define MM_SHORT_STROKE(ppdev, pjMmBase, x)           \
{                                                     \
    CP_EIEIO();                                       \
    WRITE_FIFO_W((BYTE*) (pjMmBase) + SHORT_STROKE, (x));   \
    CP_EIEIO();                                       \
}

#define MM_BKGD_MIX(ppdev, pjMmBase, x)               \
    WRITE_FIFO_W((BYTE*) (pjMmBase) + BKGD_MIX, (x))

#define MM_FRGD_MIX(ppdev, pjMmBase, x)               \
    WRITE_FIFO_W((BYTE*) (pjMmBase) + FRGD_MIX, (x))

#define MM_MIN_AXIS_PCNT(ppdev, pjMmBase, x)          \
{                                                     \
    CP_MEMORY_BARRIER();                              \
    WRITE_FIFO_W((BYTE*) (pjMmBase) + MIN_AXIS_PCNT, (x) | RECT_HEIGHT);    \
}

#define MM_MULTIFUNC_CNTL(ppdev, pjMmBase, x)         \
{                                                     \
    CP_MEMORY_BARRIER();                              \
    WRITE_FIFO_W((BYTE*) (pjMmBase) + MULTIFUNC_CNTL, (x) | MULT_MISC_INDEX);   \
}

#define MM_PIX_CNTL(ppdev, pjMmBase, x)               \
{                                                     \
    CP_MEMORY_BARRIER();                              \
    WRITE_FIFO_W((BYTE*) (pjMmBase) + PIX_CNTL, (x) | DATA_EXTENSION);  \
}

#define MM_PIX_TRANS(ppdev, pjMmBase, x)              \
{                                                     \
    CP_MEMORY_BARRIER();                              \
    /* Can't use WRITE_FIFO_W: */                     \
    WRITE_REGISTER_USHORT((BYTE*) (pjMmBase) + PIX_TRANS, (x)); \
}

// Macros for outputing colour-depth dependent values at any colour depth:

#define MM_BKGD_COLOR(ppdev, pjMmBase, x)             \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + BKGD_COLOR, (x))

#define MM_FRGD_COLOR(ppdev, pjMmBase, x)             \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + FRGD_COLOR, (x))

#define MM_WRT_MASK(ppdev, pjMmBase, x)               \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + WRT_MASK, (x))

#define MM_RD_MASK(ppdev, pjMmBase, x)                \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + RD_MASK, (x))

#define MM_COLOR_CMP(ppdev, pjMmBase, x)              \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + COLOR_CMP, (x))

#define MM_FIFO_BUSY(ppdev, pjMmBase, level)          \
    (((level) <= 8) ? IO_GP_STAT(ppdev) & (0x0080 >> ((level) - 1)) \
                    : IO_GP_STAT(ppdev) & (0x8000 >> ((level) - 9)))

#if DBG

    VOID vMmFifoWait(PDEV*, BYTE*, LONG);

    #define MM_FIFO_WAIT(ppdev, pjMmBase, level)      \
        vMmFifoWait((ppdev), (pjMmBase), (level))

#else

    #define MM_FIFO_WAIT(ppdev, pjMmBase, level)      \
        do {;} while (MM_FIFO_BUSY(ppdev, pjMmBase, (level)))

#endif

//////////////////////////////////////////////////////////////////////

// Note: The PACKXY_FAST macro is unsafe with negative coordinates

#define PACKXY(x, y)        (((x) << 16) | ((y) & 0xffff))
#define PACKXY_FAST(x, y)   (((x) << 16) | (y))

#define NW_ABS_CURXY(ppdev, pjMmBase, x, y)             \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + ALT_CURXY, PACKXY((x), (y)))

#define NW_ABS_CURXY_FAST(ppdev, pjMmBase, x, y)        \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + ALT_CURXY, PACKXY_FAST((x), (y)))

#define NW_ABS_CURXY2(ppdev, pjMmBase, x, y)            \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + ALT_CURXY2, PACKXY((x), (y)))

#define NW_ABS_STEPXY(ppdev, pjMmBase, x, y)            \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + ALT_STEP, PACKXY((x), (y)))

#define NW_ALT_STEP(ppdev, pjMmBase, diastp, axstp)     \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + ALT_STEP, PACKXY((diastp), (axstp)))

#define NW_ABS_DESTXY_FAST(ppdev, pjMmBase, x, y)       \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + ALT_STEP, PACKXY((x), (y)))

#define NW_ALT_PCNT(ppdev, pjMmBase, cx, cy)            \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + ALT_PCNT, PACKXY_FAST((cx), (cy)))

#define NW_ALT_PCNT_PACKED(ppdev, pjMmBase, cxcy)       \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + ALT_PCNT, cxcy)

#define NW_ALT_CMD(ppdev, pjMmBase, x)                  \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + ALT_CMD, (x))

#define NW_ALT_MIX(ppdev, pjMmBase, fore, back)         \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + ALT_MIX, PACKXY((fore), (back)))

#define NW_ALT_ERR(ppdev, pjMmBase, err2, err)          \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + ALT_ERR, PACKXY((err2), (err)))

#define NW_FRGD_COLOR(ppdev, pjMmBase, x)               \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + FRGD_COLOR, (x))

#define NW_BKGD_COLOR(ppdev, pjMmBase, x)               \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + BKGD_COLOR, (x))

#define NW_ABS_SCISSORS_LT(ppdev, pjMmBase, x, y)       \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + SCISSORS_T, PACKXY((x), (y)))

#define NW_ABS_SCISSORS_RB(ppdev, pjMmBase, x, y)       \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + SCISSORS_B, PACKXY((x), (y)))

#define NW_MULT_MISC_READ_SEL(ppdev, pjMmBase, mult, read) \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + MULT_MISC_READ_SEL, PACKXY((read), (mult)))

__inline BOOL NW_FIFO_BUSY(PDEV* ppdev, BYTE* pjMmBase, ULONG level)
{
    CP_EIEIO();
    return(((level) <= 8) ? (READ_REGISTER_USHORT((BYTE*) (pjMmBase) + CMD)
                                  & (0x0080 >> ((level) - 1)))
                          : (READ_REGISTER_USHORT((BYTE*) (pjMmBase) + CMD)
                                  & (0x8000 >> ((level) - 9))));
}

__inline BOOL NW_GP_BUSY(PDEV* ppdev, BYTE* pjMmBase)
{
    CP_EIEIO();
    return(READ_REGISTER_USHORT((BYTE*) (pjMmBase) + CMD) & HARDWARE_BUSY);
}

#define NW_PIX_CNTL     MM_PIX_CNTL
#define NW_COLOR_CMP    MM_COLOR_CMP

#if DBG

    VOID vNwGpWait(PDEV*, BYTE*);
    VOID vNwFifoWait(PDEV*, BYTE*, LONG);
    VOID vDbgFakeWait(PDEV*, BYTE*, LONG);

    #define NW_GP_WAIT(ppdev, pjMmBase)                 \
        vNwGpWait((ppdev), (pjMmBase))

    #define NW_FIFO_WAIT(ppdev, pjMmBase, level)        \
        vNwFifoWait((ppdev), (pjMmBase), (level))

    // DBG_FAKE_WAIT is only relevant on checked builds, and updates the
    // current debug-only fifo-empty count to allow us to do FIFO writes
    // without waiting for FIFO empty, when we (hopefully) know what we're
    // doing:

    #define DBG_FAKE_WAIT(ppdev, pjMmBase, level)       \
        vDbgFakeWait((ppdev), (pjMmBase), (level))

#else

    #define NW_GP_WAIT(ppdev, pjMmBase)                     \
        do {;} while (NW_GP_BUSY(ppdev, pjMmBase))

    #define NW_FIFO_WAIT(ppdev, pjMmBase, level)            \
        do {;} while (NW_FIFO_BUSY(ppdev, pjMmBase, (level)))

    #define DBG_FAKE_WAIT(ppdev, pjMmBase, level)

#endif

/////////////////////////////////////////////////////////////////////////////
// MM_TRANSFER routines

#define MM(pjMmBase, pjMmAlpha) (pjMmBase)

#if defined(_X86_)
#define VPBYTE BYTE volatile * volatile
#else
#define VPBYTE BYTE *
#endif

//////////////////////////
// MM_TRANSFER_BYTE  - Byte transfers using memory-mapped I/O transfers.
//
// NOTE: The first versions of the 868/968 have a bug where they can't do
//       byte-sized memory-mapped transfers.  Consequently, we always do
//       word transfers.

#define MM_TRANSFER_BYTE(ppdev, pjMmBase, p, c)                             \
{                                                                           \
             ULONG    mcw        = (c) >> 1;                                \
             BYTE*    mpjSrc     = (BYTE*) (p);                             \
             USHORT** mapwMmXfer = ppdev->apwMmXfer;                        \
             VPBYTE foo = pjMmBase;                       \
                                                                            \
    ASSERTDD((c) > 0, "Can't have a zero transfer count");                  \
    CP_MEMORY_BARRIER();                                                    \
    while (mcw-- != 0)                                                      \
    {                                                                       \
        WRITE_REGISTER_USHORT(MM(foo, mapwMmXfer[mcw & XFER_MASK]),    \
                              *((USHORT UNALIGNED *) mpjSrc));              \
        mpjSrc += 2;                                                        \
    }                                                                       \
    if ((c) & 1)                                                            \
    {                                                                       \
        WRITE_REGISTER_USHORT(MM(foo, mapwMmXfer[XFER_MASK]),          \
                          (USHORT) (*mpjSrc));                              \
    }                                                                       \
}

//////////////////////////
// MM_TRANSFER_BYTE_THIN  - Glyph transfers using memory-mapped I/O transfers.
//
// NOTE: The first versions of the 868/968 have a bug where they can't do
//       byte-sized memory-mapped transfers.  Consequently, we always do
//       word transfers.

#define MM_TRANSFER_BYTE_THIN(ppdev, pjMmBase, p, c)                        \
{                                                                           \
             ULONG    mcj        = (c);                                     \
             BYTE*    mpjSrc     = (BYTE*) (p);                             \
             USHORT** mapwMmXfer = ppdev->apwMmXfer;                        \
             VPBYTE foo = pjMmBase;                       \
                                                                            \
    ASSERTDD((c) > 0, "Can't have a zero transfer count");                  \
    CP_MEMORY_BARRIER();                                                    \
    do {                                                                    \
        WRITE_REGISTER_USHORT(MM(foo, mapwMmXfer[mcj & XFER_MASK]),    \
                          (USHORT) (*mpjSrc));                              \
        mpjSrc++;                                                           \
    } while (--mcj);                                                        \
}

//////////////////////////
// MM_TRANSFER_WORD_ALIGNED  - Word transfers using memory-mapped transfers.
//
// Source must be dword aligned!

#define MM_TRANSFER_WORD_ALIGNED(ppdev, pjMmBase, p, c)                     \
{                                                                           \
             ULONG   mcd          = (c) >> 1;                               \
             ULONG*  mpdSrc       = (ULONG*) (p);                           \
             ULONG** mapdMmXfer   = ppdev->apdMmXfer;                       \
             VPBYTE foo = pjMmBase;                       \
    ASSERTDD((((ULONG_PTR) p) & 3) == 0, "Transfer not dword aligned");      \
    ASSERTDD((c) > 0, "Can't have a zero transfer count");                  \
    CP_MEMORY_BARRIER();                                                    \
    while (mcd-- != 0)                                                      \
    {                                                                       \
        WRITE_REGISTER_ULONG(MM(foo, mapdMmXfer[mcd & XFER_MASK]), *mpdSrc++); \
    }                                                                       \
    if ((c) & 1)                                                            \
    {                                                                       \
        WRITE_REGISTER_USHORT(ppdev->apwMmXfer[XFER_MASK],                  \
                              *((USHORT*) mpdSrc));                         \
    }                                                                       \
}

//////////////////////////
// MM_TRANSFER_WORD  - Word transfers using memory-mapped transfers.
//
// Source does not have to be dword aligned.

#define MM_TRANSFER_WORD(ppdev, pjMmBase, p, c)                             \
{                                                                           \
             ULONG UNALIGNED * mpdSrc     = (ULONG*) (p);                   \
             ULONG             mcd        = (c) >> 1;                       \
             VPBYTE foo = pjMmBase;                       \
             ULONG**           mapdMmXfer = ppdev->apdMmXfer;               \
    ASSERTDD((c) > 0, "Can't have a zero transfer count");                  \
    CP_MEMORY_BARRIER();                                                    \
    while (mcd-- != 0)                                                      \
    {                                                                       \
        WRITE_REGISTER_ULONG(MM(foo, mapdMmXfer[mcd & XFER_MASK]),     \
                         *mpdSrc++);                                        \
    }                                                                       \
    if ((c) & 1)                                                            \
    {                                                                       \
        WRITE_REGISTER_USHORT(ppdev->apwMmXfer[XFER_MASK],                  \
                              *((USHORT UNALIGNED *) mpdSrc));              \
    }                                                                       \
}

//////////////////////////
// MM_TRANSFER_DWORD_ALIGNED - Dword transfers using memory-mapped transfers.
//
// Source must be dword aligned!

#define MM_TRANSFER_DWORD_ALIGNED(ppdev, pjMmBase, p, c)                    \
{                                                                           \
             ULONG   mcd          = (c);                                    \
             ULONG*  mpdSrc       = (ULONG*) (p);                           \
             VPBYTE foo = pjMmBase;                       \
             ULONG** mapdMmXfer   = ppdev->apdMmXfer;                       \
    ASSERTDD((((ULONG_PTR) p) & 3) == 0, "Transfer not dword aligned");         \
    ASSERTDD(ppdev->flCaps & CAPS_MM_TRANSFER, "Must be MM I/O");           \
    ASSERTDD((c) > 0, "Can't have a zero transfer count");                  \
                                                                            \
    CP_MEMORY_BARRIER();                                                    \
    do {                                                                    \
        WRITE_REGISTER_ULONG(MM(foo, mapdMmXfer[mcd & XFER_MASK]),     \
                         *mpdSrc++);                                        \
    } while (--mcd);                                                        \
}

//////////////////////////
// MM_TRANSFER_DWORD - Dword transfers using memory-mapped transfers.
//
// Source does not have to be dword aligned.

#define MM_TRANSFER_DWORD(ppdev, pjMmBase, p, c)                            \
{                                                                           \
             ULONG   mcd             = (c);                                 \
             ULONG UNALIGNED* mpdSrc = (ULONG*) (p);                        \
             VPBYTE foo = pjMmBase;                       \
             ULONG** mapdMmXfer      = ppdev->apdMmXfer;                    \
    ASSERTDD((c) > 0, "Can't have a zero transfer count");                  \
                                                                            \
    CP_MEMORY_BARRIER();                                                    \
    do {                                                                    \
        WRITE_REGISTER_ULONG(MM(foo, mapdMmXfer[mcd & XFER_MASK]),     \
                         *mpdSrc++);                                        \
    } while (--mcd);                                                        \
}

//////////////////////////
// MM_TRANSFER_WORD_ODD - Word transfers for glyphs of odd byte length
//                        and more than one byte wide.
//
// Source must be word aligned.

#define MM_TRANSFER_WORD_ODD(ppdev, pjMmBase, p, cjWidth, cy)               \
{                                                                           \
             BYTE*    mpjSrc     = (BYTE*) (p);                             \
             USHORT** mapwMmXfer = ppdev->apwMmXfer;                        \
             LONG     mi         = 0;                                       \
             LONG     mcy        = (cy);                                    \
             LONG     mcw        = ((cjWidth) >> 1);                        \
             LONG     mc;                                                   \
             VPBYTE foo = pjMmBase;                       \
                                                                            \
    ASSERTDD(((cjWidth) > 0) && ((cy) > 0), "Can't have a zero transfer count");\
    ASSERTDD((cjWidth) & 1, "Must be odd byte width");                      \
    ASSERTDD((cjWidth) > 2, "Must be more than 2 bytes wide");              \
                                                                            \
    CP_MEMORY_BARRIER();                                                    \
    do {                                                                    \
        mc = mcw;                                                           \
        do {                                                                \
            WRITE_REGISTER_USHORT(MM(foo, mapwMmXfer[(mi++) & XFER_MASK]), \
                                  *((USHORT UNALIGNED *) mpjSrc));          \
            mpjSrc += 2;                                                    \
        } while (--mc != 0);                                                \
                                                                            \
        WRITE_REGISTER_USHORT(MM(foo, mapwMmXfer[(mi++) & XFER_MASK]), \
                              (USHORT) (*(mpjSrc)));                        \
        mpjSrc++;                                                           \
    } while (--mcy != 0);                                                   \
}

//////////////////////////
// IO_TRANSFER_WORD_ALIGNED  - Word transfers using normal I/O.

#define IO_TRANSFER_WORD_ALIGNED(ppdev, p, c)                               \
{                                                                           \
             ULONG   mcw    = (c);                                          \
             USHORT* mpwSrc = (USHORT*) (p);                                \
    ASSERTDD((((ULONG_PTR) p) & 3) == 0, "Transfer not dword aligned");         \
    ASSERTDD((c) > 0, "Can't have a zero transfer count");                  \
    do {                                                                    \
        IO_PIX_TRANS(ppdev, *mpwSrc++);                                     \
    } while (--mcw);                                                        \
}

//////////////////////////
// IO_TRANSFER_WORD  - Word transfers using normal I/O.
//
// Source does not have to be dword aligned.

#define IO_TRANSFER_WORD(ppdev, p, c)                                       \
{                                                                           \
             ULONG              mcw    = (c);                               \
             USHORT UNALIGNED * mpwSrc = (USHORT*) (p);                     \
    ASSERTDD((c) > 0, "Can't have a zero transfer count");                  \
    do {                                                                    \
        IO_PIX_TRANS(ppdev, *mpwSrc++);                                     \
    } while (--mcw);                                                        \
}

/////////////////////////////////////////////////////////////////////////////
// DirectDraw stuff

#define IS_RGB15_R(flRed) \
        (flRed == 0x7c00)

#define IS_RGB15(this) \
	(((this)->dwRBitMask == 0x7c00) && \
	 ((this)->dwGBitMask == 0x03e0) && \
	 ((this)->dwBBitMask == 0x001f))

#define IS_RGB16(this) \
	(((this)->dwRBitMask == 0xf800) && \
	 ((this)->dwGBitMask == 0x07e0) && \
	 ((this)->dwBBitMask == 0x001f))

#define IS_RGB24(this) \
	(((this)->dwRBitMask == 0x00ff0000) && \
	 ((this)->dwGBitMask == 0x0000ff00) && \
	 ((this)->dwBBitMask == 0x000000ff))

#define IS_RGB32(this) \
	(((this)->dwRBitMask == 0x00ff0000) && \
	 ((this)->dwGBitMask == 0x0000ff00) && \
	 ((this)->dwBBitMask == 0x000000ff))

#define RGB15to32(c) \
	(((c & 0x7c00) << 9) | \
	 ((c & 0x03e0) << 6) | \
	 ((c & 0x001f) << 3))

#define RGB16to32(c) \
	(((c & 0xf800) << 8) | \
	 ((c & 0x07e0) << 5) | \
	 ((c & 0x001f) << 3))

#define VBLANK_IS_ACTIVE(pjIoBase) \
    (INP(pjIoBase, STATUS_1) & VBLANK_ACTIVE)

#define DISPLAY_IS_ACTIVE(pjIoBase) \
    (!(INP(pjIoBase, STATUS_1) & DISPLAY_MODE_INACTIVE))

#define WAIT_FOR_VBLANK(pjIoBase) \
    do {} while (!(VBLANK_IS_ACTIVE(pjIoBase)));

extern VOID vStreamsDelay();        // Work around 765 timing bug

#define WRITE_STREAM_D(pjMmBase, Register, x)                   \
{                                                               \
    WRITE_REGISTER_ULONG((BYTE*) (pjMmBase) + Register, (x));   \
    CP_EIEIO();                                                 \
    vStreamsDelay();                                            \
}

#define WRITE_FORMATTER_D(pjMmBase, Register, x)                \
{                                                               \
    if (Register == PF_NOP)                                     \
        CP_EIEIO();                                             \
    WRITE_FIFO_D((BYTE*) (pjMmBase) + Register, (x));           \
}

#define NW_FORMATTER_WAIT(ppdev, pjMmBase)                      \
{                                                               \
    CP_EIEIO();                                                 \
    do {} while (READ_REGISTER_ULONG((BYTE*) (pjMmBase) + PF_DSTADDR) & PF_BUSY); \
}

/////////////////////////////////////////////////////////////////////////////
// Private IOCTL for communicating S3 streams parameters.  These definitions
// must match those in the miniport!

#define IOCTL_VIDEO_S3_QUERY_STREAMS_PARAMETERS                        \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _VIDEO_QUERY_STREAMS_MODE {
    ULONG ScreenWidth;
    ULONG BitsPerPel;
    ULONG RefreshRate;
} VIDEO_QUERY_STREAMS_MODE;

typedef struct _VIDEO_QUERY_STREAMS_PARAMETERS {
    ULONG MinOverlayStretch;
    ULONG FifoValue;
} VIDEO_QUERY_STREAMS_PARAMETERS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\lines.c ===
/*************************************************************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: Lines.c
*
* Contains most of the required GDI line support.  Supports drawing
* lines in short 'strips' when clipping is complex or coordinates
* are too large to be drawn by the line hardware.
*
* Copyright (c) 1990-1998 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vLinesSimple
*
* Historically, NT has used funky 'GIQ' coordinates that have 4 bits of
* fraction, and is very picky about which pixels are lit even for lines
* whose coordinates are all integers.  But as of NT 4.0 Service-Pack 1,
* NT now informs us when all the coordinates in a path are integers (via
* the PO_ALL_INTEGERS flag), and what's more it allows us to request that
* the path coordinates before returned as integers instead of the funky
* 28.4 (by setting the PO_ENUM_AS_INTEGERS flag).
*
* But the best part is that GDI now allows us to choose which pixel we'll
* light for tie-breaker cases, when the error term is exactly 0.5 (the
* lines must still be last-pixel exclusive, of course).
*
* So we can now use the hardware's auto-Bresenham-setup (point-to-point
* lines) capability!  And that's exactly what we do here...
*
* Unfortunately, this code is complicated by the funky format for the MGA's
* auto-line mechanism -- we have to send down batches composed of a 1 dword
* flag, followed by 32 vertices.  The dword flag indicates which of the
* following vertices should be considered the disjoint from the rest (i.e.,
* indicates PD_BEGINSUBPATH to the hardware).
*
\**************************************************************************/

VOID vLinesSimple(
PDEV*       ppdev,
PATHOBJ*    ppo,
LONG        cFifo)      // Number of S3 FIFO slots we know are free
{
    BYTE*       pjMmBase;
    LONG        xOffset;
    LONG        yOffset;
    BOOL        bMore;
    PATHDATA    pd;
    LONG        cLines;
    POINTFIX*   pptfx;
    POINTFIX    ptfxStartFigure;

    // Notify GDI that we want the path enumerated as integers instead of
    // fixed coordinates.  Note that we can only do this when GDI has set
    // the PO_ALL_INTEGERS flag:

    ppo->fl |= PO_ENUM_AS_INTEGERS;

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    do {
        bMore  = PATHOBJ_bEnum(ppo, &pd);
        cLines = pd.count;
        pptfx  = pd.pptfx;

        if (pd.flags & PD_BEGINSUBPATH)
        {
            cLines--;
            ptfxStartFigure.x = pptfx->x;
            ptfxStartFigure.y = pptfx->y;

            cFifo--;
            if (cFifo < 0)
            {
                IO_ALL_EMPTY(ppdev);
                cFifo = MM_ALL_EMPTY_FIFO_COUNT - 1;
            }

            NW_ABS_CURXY(ppdev, pjMmBase, pptfx->x + xOffset, pptfx->y + yOffset);
            pptfx++;
            cFifo--;
        }

PolylineSegments:

        while (cLines-- > 0)
        {
            cFifo -= 2;
            if (cFifo < 0)
            {
                IO_ALL_EMPTY(ppdev);
                cFifo = MM_ALL_EMPTY_FIFO_COUNT - 2;
            }

            NW_ABS_STEPXY(ppdev, pjMmBase, pptfx->x + xOffset, pptfx->y + yOffset);
            NW_ALT_CMD(ppdev, pjMmBase, POLYLINE | WRITE | DRAW);
            pptfx++;
        }

        if (pd.flags & PD_CLOSEFIGURE)
        {
            pd.flags &= ~PD_CLOSEFIGURE;
            pptfx = &ptfxStartFigure;
            goto PolylineSegments;
        }

    } while (bMore);
}

///////////////////////////////////////////////////////////////////////

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// UUInt32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit ULONGs to produce a 64-bit DWORDLONG result.
//
// UInt64By32To32 is our own macro to divide a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// UInt64Mod32To32 is our own macro to modulus a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// 64 bit divides are usually very expensive.  Since it's very rare
// that we'll get lines where the upper 32 bits of the 64 bit result
// are used, we can almost always use 32-bit ULONG divides.  We still
// must correctly handle the larger cases:

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define UInt64Mod32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) % (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) % (ULONG)(b)))

#define SWAPL(x,y,t)        {t = x; x = y; y = t;}

FLONG gaflRound[] = {
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // no flips
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_V
    FL_V_ROUND_DOWN,                   // FL_FLIP_V | FL_FLIP_D
    FL_V_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE
    0xbaadf00d,                        // FL_FLIP_SLOPE_ONE | FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE | FL_FLIP_V
    0xbaadf00d                         // FL_FLIP_SLOPE_ONE | FL_FLIP_V | FL_FLIP_D
};

BOOL bHardwareLine(PDEV*, POINTFIX*, POINTFIX*);

/******************************Public*Routine******************************\
* BOOL bLines(ppdev, pptfxFirst, pptfxBuf, cptfx, pls,
*                   prclClip, apfn[], flStart)
*
* Computes the DDA for the line and gets ready to draw it.  Puts the
* pixel data into an array of strips, and calls a strip routine to
* do the actual drawing.
*
* Doing NT Lines Right
* --------------------
*
* In NT, all lines are given to the device driver in fractional
* coordinates, in a 28.4 fixed point format.  The lower 4 bits are
* fractional for sub-pixel positioning.
*
* Note that you CANNOT! just round the coordinates to integers
* and pass the results to your favorite integer Bresenham routine!!
* (Unless, of course, you have such a high resolution device that
* nobody will notice -- not likely for a display device.)  The
* fractions give a more accurate rendering of the line -- this is
* important for things like our Bezier curves, which would have 'kinks'
* if the points in its polyline approximation were rounded to integers.
*
* Unfortunately, for fractional lines there is more setup work to do
* a DDA than for integer lines.  However, the main loop is exactly
* the same (and can be done entirely with 32 bit math).
*
* If You've Got Hardware That Does Bresenham
* ------------------------------------------
*
* A lot of hardware limits DDA error terms to 'n' bits.  With fractional
* coordinates, 4 bits are given to the fractional part, letting
* you draw in hardware only those lines that lie entirely in a 2^(n-4)
* by 2^(n-4) pixel space.
*
* And you still have to correctly draw those lines with coordinates
* outside that space!  Remember that the screen is only a viewport
* onto a 28.4 by 28.4 space -- if any part of the line is visible
* you MUST render it precisely, regardless of where the end points lie.
* So even if you do it in software, somewhere you'll have to have a
* 32 bit DDA routine.
*
* Our Implementation
* ------------------
*
* We employ a run length slice algorithm: our DDA calculates the
* number of pixels that are in each row (or 'strip') of pixels.
*
* We've separated the running of the DDA and the drawing of pixels:
* we run the DDA for several iterations and store the results in
* a 'strip' buffer (which are the lengths of consecutive pixel rows of
* the line), then we crank up a 'strip drawer' that will draw all the
* strips in the buffer.
*
* We also employ a 'half-flip' to reduce the number of strip
* iterations we need to do in the DDA and strip drawing loops: when a
* (normalized) line's slope is more than 1/2, we do a final flip
* about the line y = (1/2)x.  So now, instead of each strip being
* consecutive horizontal or vertical pixel rows, each strip is composed
* of those pixels aligned in 45 degree rows.  So a line like (0, 0) to
* (128, 128) would generate only one strip.
*
* We also always draw only left-to-right.
*
* Styled lines may have arbitrary style patterns.  We specially
* optimize the default patterns (and call them 'masked' styles).
*
* The DDA Derivation
* ------------------
*
* Here is how I like to think of the DDA calculation.
*
* We employ Knuth's "diamond rule": rendering a one-pixel-wide line
* can be thought of as dragging a one-pixel-wide by one-pixel-high
* diamond along the true line.  Pixel centers lie on the integer
* coordinates, and so we light any pixel whose center gets covered
* by the "drag" region (John D. Hobby, Journal of the Association
* for Computing Machinery, Vol. 36, No. 2, April 1989, pp. 209-229).
*
* We must define which pixel gets lit when the true line falls
* exactly half-way between two pixels.  In this case, we follow
* the rule: when two pels are equidistant, the upper or left pel
* is illuminated, unless the slope is exactly one, in which case
* the upper or right pel is illuminated.  (So we make the edges
* of the diamond exclusive, except for the top and left vertices,
* which are inclusive, unless we have slope one.)
*
* This metric decides what pixels should be on any line BEFORE it is
* flipped around for our calculation.  Having a consistent metric
* this way will let our lines blend nicely with our curves.  The
* metric also dictates that we will never have one pixel turned on
* directly above another that's turned on.  We will also never have
* a gap; i.e., there will be exactly one pixel turned on for each
* column between the start and end points.  All that remains to be
* done is to decide how many pixels should be turned on for each row.
*
* So lines we draw will consist of varying numbers of pixels on
* successive rows, for example:
*
*       ******
*             *****
*                  ******
*                        *****
*
* We'll call each set of pixels on a row a "strip".
*
* (Please remember that our coordinate space has the origin as the
* upper left pixel on the screen; postive y is down and positive x
* is right.)
*
* Device coordinates are specified as fixed point 28.4 numbers,
* where the first 28 bits are the integer coordinate, and the last
* 4 bits are the fraction.  So coordinates may be thought of as
* having the form (x, y) = (M/F, N/F) where F is the constant scaling
* factor F = 2^4 = 16, and M and N are 32 bit integers.
*
* Consider the line from (M0/F, N0/F) to (M1/F, N1/F) which runs
* left-to-right and whose slope is in the first octant, and let
* dM = M1 - M0 and dN = N1 - N0.  Then dM >= 0, dN >= 0 and dM >= dN.
*
* Since the slope of the line is less than 1, the edges of the
* drag region are created by the top and bottom vertices of the
* diamond.  At any given pixel row y of the line, we light those
* pixels whose centers are between the left and right edges.
*
* Let mL(n) denote the line representing the left edge of the drag
* region.  On pixel row j, the column of the first pixel to be
* lit is
*
*       iL(j) = ceiling( mL(j * F) / F)
*
* Since the line's slope is less than one:
*
*       iL(j) = ceiling( mL([j + 1/2] F) / F )
*
* Recall the formula for our line:
*
*       n(m) = (dN / dM) (m - M0) + N0
*
*       m(n) = (dM / dN) (n - N0) + M0
*
* Since the line's slope is less than one, the line representing
* the left edge of the drag region is the original line offset
* by 1/2 pixel in the y direction:
*
*       mL(n) = (dM / dN) (n - F/2 - N0) + M0
*
* From this we can figure out the column of the first pixel that
* will be lit on row j, being careful of rounding (if the left
* edge lands exactly on an integer point, the pixel at that
* point is not lit because of our rounding convention):
*
*       iL(j) = floor( mL(j F) / F ) + 1
*
*             = floor( ((dM / dN) (j F - F/2 - N0) + M0) / F ) + 1
*
*             = floor( F dM j - F/2 dM - N0 dM + dN M0) / F dN ) + 1
*
*                      F dM j - [ dM (N0 + F/2) - dN M0 ]
*             = floor( ---------------------------------- ) + 1
*                                   F dN
*
*                      dM j - [ dM (N0 + F/2) - dN M0 ] / F
*             = floor( ------------------------------------ ) + 1       (1)
*                                     dN
*
*             = floor( (dM j + alpha) / dN ) + 1
*
* where
*
*       alpha = - [ dM (N0 + F/2) - dN M0 ] / F
*
* We use equation (1) to calculate the DDA: there are iL(j+1) - iL(j)
* pixels in row j.  Because we are always calculating iL(j) for
* integer quantities of j, we note that the only fractional term
* is constant, and so we can 'throw away' the fractional bits of
* alpha:
*
*       beta = floor( - [ dM (N0 + F/2) - dN M0 ] / F )                 (2)
*
* so
*
*       iL(j) = floor( (dM j + beta) / dN ) + 1                         (3)
*
* for integers j.
*
* Note if iR(j) is the line's rightmost pixel on row j, that
* iR(j) = iL(j + 1) - 1.
*
* Similarly, rewriting equation (1) as a function of column i,
* we can determine, given column i, on which pixel row j is the line
* lit:
*
*                       dN i + [ dM (N0 + F/2) - dN M0 ] / F
*       j(i) = ceiling( ------------------------------------ ) - 1
*                                       dM
*
* Floors are easier to compute, so we can rewrite this:
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F
*       j(i) = floor( ----------------------------------------------- ) - 1
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F - dM
*            = floor( ---------------------------------------------------- )
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 - 1 ] / F
*            = floor( ---------------------------------------- )
*                                       dM
*
* We can once again wave our hands and throw away the fractional bits
* of the remainder term:
*
*       j(i) = floor( (dN i + gamma) / dM )                             (4)
*
* where
*
*       gamma = floor( [ dM (N0 + F/2) - dN M0 - 1 ] / F )              (5)
*
* We now note that
*
*       beta = -gamma - 1 = ~gamma                                      (6)
*
* To draw the pixels of the line, we could evaluate (3) on every scan
* line to determine where the strip starts.  Of course, we don't want
* to do that because that would involve a multiply and divide for every
* scan.  So we do everything incrementally.
*
* We would like to easily compute c , the number of pixels on scan j:
*                                  j
*
*    c  = iL(j + 1) - iL(j)
*     j
*
*       = floor((dM (j + 1) + beta) / dN) - floor((dM j + beta) / dN)   (7)
*
* This may be rewritten as
*
*    c  = floor(i    + r    / dN) - floor(i  + r  / dN)                 (8)
*     j          j+1    j+1                j    j
*
* where i , i    are integers and r  < dN, r    < dN.
*        j   j+1                   j        j+1
*
* Rewriting (7) again:
*
*    c  = floor(i  + r  / dN + dM / dN) - floor(i  + r  / dN)
*     j          j    j                          j    j
*
*
*       = floor((r  + dM) / dN) - floor(r  / dN)
*                 j                      j
*
* This may be rewritten as
*
*    c  = dI + floor((r  + dR) / dN) - floor(r  / dN)
*     j                j                      j
*
* where dI + dR / dN = dM / dN, dI is an integer and dR < dN.
*
* r  is the remainder (or "error") term in the DDA loop: r  / dN
*  j                                                      j
* is the exact fraction of a pixel at which the strip ends.  To go
* on to the next scan and compute c    we need to know r   .
*                                  j+1                  j+1
*
* So in the main loop of the DDA:
*
*    c  = dI + floor((r  + dR) / dN) and r    = (r  + dR) % dN
*     j                j                  j+1     j
*
* and we know r  < dN, r    < dN, and dR < dN.
*              j        j+1
*
* We have derived the DDA only for lines in the first octant; to
* handle other octants we do the common trick of flipping the line
* to the first octant by first making the line left-to-right by
* exchanging the end-points, then flipping about the lines y = 0 and
* y = x, as necessary.  We must record the transformation so we can
* undo them later.
*
* We must also be careful of how the flips affect our rounding.  If
* to get the line to the first octant we flipped about x = 0, we now
* have to be careful to round a y value of 1/2 up instead of down as
* we would for a line originally in the first octant (recall that
* "In the case where two pels are equidistant, the upper or left
* pel is illuminated...").
*
* To account for this rounding when running the DDA, we shift the line
* (or not) in the y direction by the smallest amount possible.  That
* takes care of rounding for the DDA, but we still have to be careful
* about the rounding when determining the first and last pixels to be
* lit in the line.
*
* Determining The First And Last Pixels In The Line
* -------------------------------------------------
*
* Fractional coordinates also make it harder to determine which pixels
* will be the first and last ones in the line.  We've already taken
* the fractional coordinates into account in calculating the DDA, but
* the DDA cannot tell us which are the end pixels because it is quite
* happy to calculate pixels on the line from minus infinity to positive
* infinity.
*
* The diamond rule determines the start and end pixels.  (Recall that
* the sides are exclusive except for the left and top vertices.)
* This convention can be thought of in another way: there are diamonds
* around the pixels, and wherever the true line crosses a diamond,
* that pel is illuminated.
*
* Consider a line where we've done the flips to the first octant, and the
* floor of the start coordinates is the origin:
*
*        +-----------------------> +x
*        |
*        | 0                     1
*        |     0123456789abcdef
*        |
*        |   0 00000000?1111111
*        |   1 00000000 1111111
*        |   2 0000000   111111
*        |   3 000000     11111
*        |   4 00000    ** 1111
*        |   5 0000       ****1
*        |   6 000           1***
*        |   7 00             1  ****
*        |   8 ?                     ***
*        |   9 22             3         ****
*        |   a 222           33             ***
*        |   b 2222         333                ****
*        |   c 22222       3333                    **
*        |   d 222222     33333
*        |   e 2222222   333333
*        |   f 22222222 3333333
*        |
*        | 2                     3
*        v
*        +y
*
* If the start of the line lands on the diamond around pixel 0 (shown by
* the '0' region here), pixel 0 is the first pel in the line.  The same
* is true for the other pels.
*
* A little more work has to be done if the line starts in the
* 'nether-land' between the diamonds (as illustrated by the '*' line):
* the first pel lit is the first diamond crossed by the line (pixel 1 in
* our example).  This calculation is determined by the DDA or slope of
* the line.
*
* If the line starts exactly half way between two adjacent pixels
* (denoted here by the '?' spots), the first pixel is determined by our
* round-down convention (and is dependent on the flips done to
* normalize the line).
*
* Last Pel Exclusive
* ------------------
*
* To eliminate repeatedly lit pels between continuous connected lines,
* we employ a last-pel exclusive convention: if the line ends exactly on
* the diamond around a pel, that pel is not lit.  (This eliminates the
* checks we had in the old code to see if we were re-lighting pels.)
*
* The Half Flip
* -------------
*
* To make our run length algorithm more efficient, we employ a "half
* flip".  If after normalizing to the first octant, the slope is more
* than 1/2, we subtract the y coordinate from the x coordinate.  This
* has the effect of reflecting the coordinates through the line of slope
* 1/2.  Note that the diagonal gets mapped into the x-axis after a half
* flip.
*
* How Many Bits Do We Need, Anyway?
* ---------------------------------
*
* Note that if the line is visible on your screen, you must light up
* exactly the correct pixels, no matter where in the 28.4 x 28.4 device
* space the end points of the line lie (meaning you must handle 32 bit
* DDAs, you can certainly have optimized cases for lesser DDAs).
*
* We move the origin to (floor(M0 / F), floor(N0 / F)), so when we
* calculate gamma from (5), we know that 0 <= M0, N0 < F.  And we
* are in the first octant, so dM >= dN.  Then we know that gamma can
* be in the range [(-1/2)dM, (3/2)dM].  The DDI guarantees us that
* valid lines will have dM and dN values at most 31 bits (unsigned)
* of significance.  So gamma requires 33 bits of significance (we store
* this as a 64 bit number for convenience).
*
* When running through the DDA loop, r  + dR can have a value in the
*                                     j
* range 0 <= r  < 2 dN; thus the result must be a 32 bit unsigned value.
*             j
*
* Testing Lines
* -------------
*
* To be NT compliant, a display driver must exactly adhere to GIQ,
* which means that for any given line, the driver must light exactly
* the same pels as does GDI.  This can be tested using the Guiman tool
* provided elsewhere in the DDK, and 'ZTest', which draws random lines
* on the screen and to a bitmap, and compares the results.
*
* If You've Got Line Hardware
* ---------------------------
*
* If your hardware already adheres to GIQ, you're all set.  Otherwise
* you'll want to look at the sample code and read the following:
*
* 1) You'll want to special case integer-only lines, since they require
*    less processing time and are more common (CAD programs will probably
*    only ever give integer lines).  GDI does not provide a flag saying
*    that all lines in a path are integer lines; consequently, you will
*    have to explicitly check every line.
*
* 2) You are required to correctly draw any line in the 28.4 device
*    space that intersects the viewport.  If you have less than 32 bits
*    of significance in the hardware for the Bresenham terms, extremely
*    long lines would overflow the hardware.  For such (rare) cases, you
*    can fall back to strip-drawing code (or if your display is a frame
*    buffer, fall back to the engine).
*
* 3) If you can explicitly set the Bresenham terms in your hardware, you
*    can draw non-integer lines using the hardware.  If your hardware has
*    'n' bits of precision, you can draw GIQ lines that are up to 2^(n-5)
*    pels long (4 bits are required for the fractional part, and one bit is
*    used as a sign bit).  Note that integer lines don't require the 4
*    fractional bits, so if you special case them as in 1), you can do
*    integer lines that are up to 2^(n - 1) pels long.  See the
*    'bHardwareLine' routine for an example.
*
\**************************************************************************/

BOOL bLines(
PDEV*	   ppdev,
POINTFIX*  pptfxFirst,  // Start of first line
POINTFIX*  pptfxBuf,    // Pointer to buffer of all remaining lines
RUN*       prun,        // Pointer to runs if doing complex clipping
ULONG      cptfx,       // Number of points in pptfxBuf or number of runs
                        // in prun
LINESTATE* pls,         // Colour and style info
RECTL*     prclClip,    // Pointer to clip rectangle if doing simple clipping
PFNSTRIP   apfn[],      // Array of strip functions
FLONG      flStart)     // Flags for each line, which is a combination of:
                        //      FL_SIMPLE_CLIP
                        //      FL_COMPLEX_CLIP
                        //      FL_STYLED
                        //      FL_LAST_PEL_INCLUSIVE
                        //        - Should be set only for all integer lines,
                        //          and can't be used with FL_COMPLEX_CLIP
{
    ULONG     M0;
    ULONG     dM;
    ULONG     N0;
    ULONG     dN;
    ULONG     dN_Original;
    FLONG     fl;
    LONG      x;
    LONG      y;

    LONGLONG  llBeta;
    LONGLONG  llGamma;
    LONGLONG  dl;
    LONGLONG  ll;

    ULONG     ulDelta;

    ULONG     x0;
    ULONG     y0;
    ULONG     x1;
    ULONG     cStylePels;    // Major length of line in pixels for styling
    ULONG     xStart;
    POINTL    ptlStart;
    STRIP     strip;
    PFNSTRIP  pfn;
    LONG      cPels;
    LONG*     plStrip;
    LONG*     plStripEnd;
    LONG      cStripsInNextRun;

    POINTFIX* pptfxBufEnd = pptfxBuf + cptfx; // Last point in path record
    STYLEPOS  spThis;                         // Style pos for this line

    do {

/***********************************************************************\
* Start the DDA calculations.                                           *
\***********************************************************************/

        M0 = (LONG) pptfxFirst->x;
        dM = (LONG) pptfxBuf->x;

        N0 = (LONG) pptfxFirst->y;
        dN = (LONG) pptfxBuf->y;

        fl = flStart;

	// Check for non-clipped, non-styled integer endpoint lines:

        if ((fl & (FL_CLIP | FL_STYLED)) == 0)
        {
            // Special-case integer end-point lines:

	    if (((M0 | dM | N0 | dN) & (F - 1)) == 0)
            {
                // -1 for 'iSolidColor' denotes that the currently set
                // colour and mix should be kept:

                ppdev->pfnLineToTrivial(ppdev,
                                        (M0 >> 4) + ppdev->xOffset,
                                        (N0 >> 4) + ppdev->yOffset,
                                        (dM >> 4) + ppdev->xOffset,
                                        (dN >> 4) + ppdev->yOffset,
                                        (ULONG) -1,
                                        0);
                goto Next_Line;
            }

            // Check for fractional endpoint lines that are small enough
            // to use the hardware DDA:

            if (bHardwareLine(ppdev, pptfxFirst, pptfxBuf))
                goto Next_Line;
        }
	
        if ((LONG) M0 > (LONG) dM)
        {
        // Ensure that we run left-to-right:

            register ULONG ulTmp;
            SWAPL(M0, dM, ulTmp);
            SWAPL(N0, dN, ulTmp);
            fl |= FL_FLIP_H;
        }

    // Compute the delta dx.  The DDI says we can never have a valid delta
    // with a magnitued more than 2^31 - 1, but GDI never actually checks
    // its transforms.  So we have to check for this case to avoid overflow:

        dM -= M0;
        if ((LONG) dM < 0)
        {
            goto Next_Line;
        }

        if ((LONG) dN < (LONG) N0)
        {
        // Line runs from bottom to top, so flip across y = 0:

            N0 = -(LONG) N0;
            dN = -(LONG) dN;
            fl |= FL_FLIP_V;
        }

        dN -= N0;

        if ((LONG) dN < 0)
        {
            goto Next_Line;
        }

    // We now have a line running left-to-right, top-to-bottom from (M0, N0)
    // to (M0 + dM, N0 + dN):

        if (dN >= dM)
        {
            if (dN == dM)
            {
            // Have to special case slopes of one:

                fl |= FL_FLIP_SLOPE_ONE;
            }
            else
            {
            // Since line has slope greater than 1, flip across x = y:

                register ULONG ulTmp;
                SWAPL(dM, dN, ulTmp);
                SWAPL(M0, N0, ulTmp);
                fl |= FL_FLIP_D;
            }
        }

        fl |= gaflRound[(fl & FL_ROUND_MASK) >> FL_ROUND_SHIFT];

        x = LFLOOR((LONG) M0);
        y = LFLOOR((LONG) N0);

        M0 = FXFRAC(M0);
        N0 = FXFRAC(N0);

    // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ]:

        llGamma = UInt32x32To64(dM, N0 + F/2) - UInt32x32To64(M0, dN);
        if (fl & FL_V_ROUND_DOWN)   // Adjust so y = 1/2 rounds down
        {
            llGamma--;
        }

        llGamma >>= FLOG2;
        llBeta = ~llGamma;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.                  *
\***********************************************************************/

    // The toughest part of GIQ is determining the start and end pels.
    //
    // Our approach here is to calculate x0 and x1 (the inclusive start
    // and end columns of the line respectively, relative to our normalized
    // origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
    // start point is easily calculated by plugging x0 into our line equation
    // (which takes care of whether y = 1/2 rounds up or down in value)
    // getting y0, and then undoing the normalizing flips to get back
    // into device space.
    //
    // We look at the fractional parts of the coordinates of the start and
    // end points, and call them (M0, N0) and (M1, N1) respectively, where
    // 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
    // to determine x0:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 ........?xxxxxxx
    //   |   1 ..........xxxxxx
    //   |   2 ...........xxxxx
    //   |   3 ............xxxx
    //   |   4 .............xxx
    //   |   5 ..............xx
    //   |   6 ...............x
    //   |   7 ................
    //   |   8 ................
    //   |   9 ......**........
    //   |   a ........****...x
    //   |   b ............****
    //   |   c .............xxx****
    //   |   d ............xxxx    ****
    //   |   e ...........xxxxx        ****
    //   |   f ..........xxxxxx
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one require a special case for both the start
    // and end.  For example, if the line ends such that (M1, N1) is (9, 1),
    // the line has gone exactly through (8, 0) -- which may be considered
    // to be part of 'x' because of rounding!  So slopes of exactly slope
    // one going through (8, 0) must also be considered as belonging in 'x'.
    //
    // For lines that go left-to-right, we have the following grid:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 xxxxxxxx?.......
    //   |   1 xxxxxxx.........
    //   |   2 xxxxxx..........
    //   |   3 xxxxx...........
    //   |   4 xxxx............
    //   |   5 xxx.............
    //   |   6 xx..............
    //   |   7 x...............
    //   |   8 x...............
    //   |   9 x.....**........
    //   |   a xx......****....
    //   |   b xxx.........****
    //   |   c xxxx............****
    //   |   d xxxxx...........    ****
    //   |   e xxxxxx..........        ****
    //   |   f xxxxxxx.........
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 0.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) - 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one must be handled similarly to the right-to-
    // left case.

        {

        // Calculate x0, x1

            ULONG N1 = FXFRAC(N0 + dN);
	    ULONG M1 = FXFRAC(M0 + dM);

	    x1 = LFLOOR(M0 + dM);

            if (fl & FL_LAST_PEL_INCLUSIVE)
            {
            // It sure is easy to compute the first pel when lines have only
            // integer coordinates and are last-pel inclusive:

                x0 = 0;
                y0 = 0;

            // Last-pel inclusive lines that are exactly one pixel long
            // have a 'delta-x' and 'delta-y' equal to zero.  The problem is
            // that our clip code assumes that 'delta-x' is always non-zero
            // (since it never happens with last-pel exclusive lines).  As
            // an inelegant solution, we simply modify 'delta-x' in this
            // case -- because the line is exactly one pixel long, changing
            // the slope will obviously have no effect on rasterization.

                if (x1 == 0)
                {
                    dM      = 1;
                    llGamma = 0;
                    llBeta  = ~llGamma;
                }
            }
            else
            {
                if (fl & FL_FLIP_H)
                {
                // ---------------------------------------------------------------
                // Line runs right-to-left:  <----

                // Compute x1:

                    if (N1 == 0)
                    {
                        if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                        {
                            x1++;
                        }
                    }
                    else if (abs((LONG) (N1 - F/2)) + M1 > F)
                    {
                        x1++;
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((N1 > 0) && (M1 == N1 + 8))
                            x1++;

                    // Don't you love special cases?  Is this a rhetorical question?

                        if ((N0 > 0) && (M0 == N0 + 8))
                        {
                            x0      = 2;
                            ulDelta = dN;
                            goto right_to_left_compute_y0;
                        }
                    }

                // Compute x0:

                    x0      = 1;
                    ulDelta = 0;
                    if (N0 == 0)
                    {
                        if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                        {
                            x0      = 2;
                            ulDelta = dN;
                        }
                    }
                    else if (abs((LONG) (N0 - F/2)) + M0 > F)
                    {
                        x0      = 2;
                        ulDelta = dN;
                    }


                // Compute y0:

                right_to_left_compute_y0:

                    y0 = 0;
                    ll = llGamma + (LONGLONG) ulDelta;

                    if (ll >= (LONGLONG) (2 * dM - dN))
                        y0 = 2;
                    else if (ll >= (LONGLONG) (dM - dN))
                        y0 = 1;
                }
                else
                {
                // ---------------------------------------------------------------
                // Line runs left-to-right:  ---->

                // Compute x1:

                    if (!(fl & FL_LAST_PEL_INCLUSIVE))
                        x1--;

                    if (M1 > 0)
                    {
                        if (N1 == 0)
                        {
                            if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                                x1++;
                        }
                        else if (abs((LONG) (N1 - F/2)) <= (LONG) M1)
                        {
                            x1++;
                        }
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((M1 > 0) && (N1 == M1 + 8))
                            x1--;

                        if ((M0 > 0) && (N0 == M0 + 8))
                        {
                            x0 = 0;
                            goto left_to_right_compute_y0;
                        }
                    }

                // Compute x0:

                    x0 = 0;
                    if (M0 > 0)
                    {
                        if (N0 == 0)
                        {
                            if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                                x0 = 1;
                        }
                        else if (abs((LONG) (N0 - F/2)) <= (LONG) M0)
                        {
                            x0 = 1;
                        }
                    }

                // Compute y0:

                left_to_right_compute_y0:

                    y0 = 0;
                    if (llGamma >= (LONGLONG) (dM - (dN & (-(LONG) x0))))
                    {
                        y0 = 1;
                    }
                }
            }
        }

        cStylePels = x1 - x0 + 1;
        if ((LONG) cStylePels <= 0)
            goto Next_Line;

        xStart = x0;

/***********************************************************************\
* Complex clipping.                                                     *
\***********************************************************************/

        if (fl & FL_COMPLEX_CLIP)
        {
            dN_Original = dN;

        Continue_Complex_Clipping:

            if (fl & FL_FLIP_H)
            {
            // Line runs right-to-left <-----

                x0 = xStart + cStylePels - prun->iStop - 1;
                x1 = xStart + cStylePels - prun->iStart - 1;
            }
            else
            {
            // Line runs left-to-right ----->

                x0 = xStart + prun->iStart;
                x1 = xStart + prun->iStop;
            }

            prun++;

        // Reset some variables we'll nuke a little later:

            dN          = dN_Original;
            pls->spNext = pls->spComplex;

        // No overflow since large integer math is used.  Both values
        // will be positive:

            dl = UInt32x32To64(x0, dN) + llGamma;

        // y0 = dl / dM:

            y0 = UInt64Div32To32(dl, dM);

            ASSERTDD((LONG) y0 >= 0, "y0 weird: Goofed up end pel calc?");
        }

/***********************************************************************\
* Simple rectangular clipping.                                          *
\***********************************************************************/

        if (fl & FL_SIMPLE_CLIP)
        {
            ULONG y1;
            LONG  xRight;
            LONG  xLeft;
            LONG  yBottom;
            LONG  yTop;

        // Note that y0 and y1 are actually the lower and upper bounds,
        // respectively, of the y coordinates of the line (the line may
        // have actually shrunk due to first/last pel clipping).
        //
        // Also note that x0, y0 are not necessarily zero.

            RECTL* prcl = &prclClip[(fl & FL_RECTLCLIP_MASK) >>
                                    FL_RECTLCLIP_SHIFT];

        // Normalize to the same point we've normalized for the DDA
        // calculations:

            xRight  = prcl->right  - x;
            xLeft   = prcl->left   - x;
            yBottom = prcl->bottom - y;
            yTop    = prcl->top    - y;

            if (yBottom <= (LONG) y0 ||
                xRight  <= (LONG) x0 ||
                xLeft   >  (LONG) x1)
            {
            Totally_Clipped:

                if (fl & FL_STYLED)
                {
                    pls->spNext += cStylePels;
                    if (pls->spNext >= pls->spTotal2)
                        pls->spNext %= pls->spTotal2;
                }

                goto Next_Line;
            }

            if ((LONG) x1 >= xRight)
                x1 = xRight - 1;

        // We have to know the correct y1, which we haven't bothered to
        // calculate up until now.  This multiply and divide is quite
        // expensive; we could replace it with code similar to that which
        // we used for computing y0.
        //
        // The reason why we need the actual value, and not an upper
        // bounds guess like y1 = LFLOOR(dM) + 2 is that we have to be
        // careful when calculating x(y) that y0 <= y <= y1, otherwise
        // we can overflow on the divide (which, needless to say, is very
        // bad).

            dl = UInt32x32To64(x1, dN) + llGamma;

        // y1 = dl / dM:

            y1 = UInt64Div32To32(dl, dM);

            if (yTop > (LONG) y1)
                goto Totally_Clipped;

            if (yBottom <= (LONG) y1)
            {
                y1 = yBottom;
                dl = UInt32x32To64(y1, dM) + llBeta;

            // x1 = dl / dN:

                x1 = UInt64Div32To32(dl, dN);
            }

        // At this point, we've taken care of calculating the intercepts
        // with the right and bottom edges.  Now we work on the left and
        // top edges:

            if (xLeft > (LONG) x0)
            {
                x0 = xLeft;
                dl = UInt32x32To64(x0, dN) + llGamma;

            // y0 = dl / dM;

                y0 = UInt64Div32To32(dl, dM);

                if (yBottom <= (LONG) y0)
                    goto Totally_Clipped;
            }

            if (yTop > (LONG) y0)
            {
                y0 = yTop;
                dl = UInt32x32To64(y0, dM) + llBeta;

            // x0 = dl / dN + 1;

                x0 = UInt64Div32To32(dl, dN) + 1;

                if (xRight <= (LONG) x0)
                    goto Totally_Clipped;
            }

            ASSERTDD(x0 <= x1, "Improper rectangle clip");
        }

/***********************************************************************\
* Done clipping.  Unflip if necessary.                                 *
\***********************************************************************/

        ptlStart.x = x + x0;
        ptlStart.y = y + y0;

        if (fl & FL_FLIP_D)
        {
            register LONG lTmp;
            SWAPL(ptlStart.x, ptlStart.y, lTmp);
        }


        if (fl & FL_FLIP_V)
        {
            ptlStart.y = -ptlStart.y;
        }

        cPels = x1 - x0 + 1;

/***********************************************************************\
* Style calculations.                                                   *
\***********************************************************************/

        if (fl & FL_STYLED)
        {
            STYLEPOS sp;

            spThis       = pls->spNext;
            pls->spNext += cStylePels;

            {
                if (pls->spNext >= pls->spTotal2)
                    pls->spNext %= pls->spTotal2;

                if (fl & FL_FLIP_H)
                    sp = pls->spNext - x0 + xStart;
                else
                    sp = spThis + x0 - xStart;

                ASSERTDD(fl & FL_STYLED, "Oops");

            // Normalize our target style position:

                if ((sp < 0) || (sp >= pls->spTotal2))
                {
                    sp %= pls->spTotal2;

                // The modulus of a negative number is not well-defined
                // in C -- if it's negative we'll adjust it so that it's
                // back in the range [0, spTotal2):

                    if (sp < 0)
                        sp += pls->spTotal2;
                }

            // Since we always draw the line left-to-right, but styling is
            // always done in the direction of the original line, we have
            // to figure out where we are in the style array for the left
            // edge of this line.

                if (fl & FL_FLIP_H)
                {
                // Line originally ran right-to-left:

                    sp = -sp;
                    if (sp < 0)
                        sp += pls->spTotal2;

                    pls->ulStyleMask = ~pls->ulStartMask;
                    pls->pspStart    = &pls->aspRtoL[0];
                    pls->pspEnd      = &pls->aspRtoL[pls->cStyle - 1];
                }
                else
                {
                // Line originally ran left-to-right:

                    pls->ulStyleMask = pls->ulStartMask;
                    pls->pspStart    = &pls->aspLtoR[0];
                    pls->pspEnd      = &pls->aspLtoR[pls->cStyle - 1];
                }

                if (sp >= pls->spTotal)
                {
                    sp -= pls->spTotal;
                    if (pls->cStyle & 1)
                        pls->ulStyleMask = ~pls->ulStyleMask;
                }

                pls->psp = pls->pspStart;
                while (sp >= *pls->psp)
                    sp -= *pls->psp++;

                ASSERTDD(pls->psp <= pls->pspEnd,
                        "Flew off into NeverNeverLand");

                pls->spRemaining = *pls->psp - sp;
                if ((pls->psp - pls->pspStart) & 1)
                    pls->ulStyleMask = ~pls->ulStyleMask;
            }
        }

        plStrip    = &strip.alStrips[0];
        plStripEnd = &strip.alStrips[STRIP_MAX];    // Is exclusive
        cStripsInNextRun   = 0x7fffffff;

	strip.ptlStart = ptlStart;

        if (2 * dN > dM &&
            !(fl & FL_STYLED))
        {
        // Do a half flip!  Remember that we may doing this on the
        // same line multiple times for complex clipping (meaning the
        // affected variables should be reset for every clip run):

            fl |= FL_FLIP_HALF;

            llBeta  = llGamma - (LONGLONG) ((LONG) dM);
            dN = dM - dN;
            y0 = x0 - y0;       // Note this may overflow, but that's okay
        }

    // Now, run the DDA starting at (ptlStart.x, ptlStart.y)!

        strip.flFlips = fl;
        pfn           = apfn[(fl & FL_STRIP_MASK) >> FL_STRIP_SHIFT];

    // Now calculate the DDA variables needed to figure out how many pixels
    // go in the very first strip:

        {
            register LONG  i;
            register ULONG dI;
            register ULONG dR;
                     ULONG r;

            if (dN == 0)
                i = 0x7fffffff;
            else
            {
                dl = UInt32x32To64(y0 + 1, dM) + llBeta;

                ASSERTDD(dl >= 0, "Oops!");

            // i = (dl / dN) - x0 + 1;
            // r = (dl % dN);

                i = UInt64Div32To32(dl, dN);
                r = UInt64Mod32To32(dl, dN);
                i = i - x0 + 1;

                dI = dM / dN;
                dR = dM % dN;               // 0 <= dR < dN

                ASSERTDD(dI > 0, "Weird dI");
            }

            ASSERTDD(i > 0 && i <= 0x7fffffff, "Weird initial strip length");
            ASSERTDD(cPels > 0, "Zero pel line");

/***********************************************************************\
* Run the DDA!                                                          *
\***********************************************************************/

            while(TRUE)
            {
                cPels -= i;
                if (cPels <= 0)
                    break;

                *plStrip++ = i;

                if (plStrip == plStripEnd)
                {
                    strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
                    (*pfn)(ppdev, &strip, pls);
                    plStrip = &strip.alStrips[0];
                }

                i = dI;
                r += dR;

                if (r >= dN)
                {
                    r -= dN;
                    i++;
                }
            }

            *plStrip++ = cPels + i;

            strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
            (*pfn)(ppdev, &strip, pls);


        }

    Next_Line:

        if (fl & FL_COMPLEX_CLIP)
        {
            cptfx--;
            if (cptfx != 0)
                goto Continue_Complex_Clipping;

            break;
        }
        else
        {
            pptfxFirst = pptfxBuf;
            pptfxBuf++;
        }

    } while (pptfxBuf < pptfxBufEnd);

    return(TRUE);

}

//////////////////////////////////////////////////////////////////////////
// General defines for bHardwareLine

#define HW_FLIP_D           0x0001L     // Diagonal flip
#define HW_FLIP_V           0x0002L     // Vertical flip
#define HW_FLIP_H           0x0004L     // Horizontal flip
#define HW_FLIP_SLOPE_ONE   0x0008L     // Normalized line has exactly slope one
#define HW_FLIP_MASK        (HW_FLIP_D | HW_FLIP_V | HW_FLIP_H)

#define HW_X_ROUND_DOWN     0x0100L     // x = 1/2 rounds down in value
#define HW_Y_ROUND_DOWN     0x0200L     // y = 1/2 rounds down in value

LONG gaiDir[] = { 0, 1, 7, 6, 3, 2, 4, 5 };

FLONG gaflHardwareRound[] = {
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        |
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    //           |        | FLIP_V |
    HW_Y_ROUND_DOWN,                    //           |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    //           | FLIP_H |        |
    HW_X_ROUND_DOWN,                    //           | FLIP_H |        | FLIP_D
    0,                                  //           | FLIP_H | FLIP_V |
    0,                                  //           | FLIP_H | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE |        |        |
    0xffffffff,                         // SLOPE_ONE |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE |        | FLIP_V |
    0xffffffff,                         // SLOPE_ONE |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H |        |
    0xffffffff,                         // SLOPE_ONE | FLIP_H |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H | FLIP_V |
    0xffffffff                          // SLOPE_ONE | FLIP_H | FLIP_V | FLIP_D
};

//////////////////////////////////////////////////////////////////////////
// S3 specific defines

#define DEFAULT_DRAW_CMD (DRAW_LINE | DRAW | DIR_TYPE_XY | MULTIPLE_PIXELS | \
                          WRITE | LAST_PIXEL_OFF)

LONG gaiDrawCmd[] = {
    DEFAULT_DRAW_CMD | PLUS_X | PLUS_Y |       0,   // Octant 0
    DEFAULT_DRAW_CMD | PLUS_X | PLUS_Y | MAJOR_Y,   // Octant 1
    DEFAULT_DRAW_CMD | PLUS_X |      0 |       0,   // Octant 7
    DEFAULT_DRAW_CMD | PLUS_X |      0 | MAJOR_Y,   // Octant 6
    DEFAULT_DRAW_CMD | 0      | PLUS_Y |       0,   // Octant 3
    DEFAULT_DRAW_CMD | 0      | PLUS_Y | MAJOR_Y,   // Octant 2
    DEFAULT_DRAW_CMD | 0      |      0 |       0,   // Octant 4
    DEFAULT_DRAW_CMD | 0      |      0 | MAJOR_Y,   // Octant 5
};

// The S3's hardware can have 13 bits of significance for the error and
// step terms:

#define NUM_DDA_BITS 13

/******************************Public*Routine******************************\
* BOOL bHardwareLine(ppdev, pptfxStart, pptfxEnd)
*
* This routine is useful for folks who have line drawing hardware where
* they can explicitly set the Bresenham terms -- they can use this routine
* to draw fractional coordinate GIQ lines with the hardware.
*
* Fractional coordinate lines require an extra 4 bits of precision in the
* Bresenham terms.  For example, if your hardware has 13 bits of precision
* for the terms, you can only draw GIQ lines up to 255 pels long using this
* routine.
*
* Input:
*   pptfxStart  - Points to GIQ coordinate of start of line
*   pptfxEnd    - Points to GIQ coordinate of end of line
*   NUM_DDA_BITS- The number of bits of precision your hardware can support.
*
* Output:
*   returns     - TRUE if the line was drawn.
*                 FALSE if the line is too long, and the strips code must be
*                 used.
*
* DDALINE:
*   iDir        - Direction of the line, as an octant numbered as follows:
*
*                    \ 5 | 6 /
*                     \  |  /
*                    4 \ | / 7
*                       \ /
*                   -----+-----
*                       /|\
*                    3 / | \ 0
*                     /  |  \
*                    / 2 | 1 \
*
*   ptlStart    - Start pixel of line.
*   cPels       - # of pels in line.  *NOTE* You must check if this is <= 0!
*   dMajor      - Major axis delta.
*   dMinor      - Minor axis delta.
*   lErrorTerm  - Error term.
*
* What you do with the last 3 terms may be a little tricky.  They are
* actually the terms for the formula of the normalized line
*
*                     dMinor * x + (lErrorTerm + dMajor)
*       y(x) = floor( ---------------------------------- )
*                                  dMajor
*
* where y(x) is the y coordinate of the pixel to be lit as a function of
* the x-coordinate.
*
* Every time the line advances one in the major direction 'x', dMinor
* gets added to the current error term.  If the resulting value is >= 0,
* we know we have to move one pixel in the minor direction 'y', and
* dMajor must be subtracted from the current error term.
*
* If you're trying to figure out what this means for your hardware, you can
* think of the DDALINE terms as having been computed equivalently as
* follows:
*
*     dMinor     = 2 * (minor axis delta)
*     dMajor     = 2 * (major axis delta)
*     lErrorTerm = - (major axis delta) - fixup
*
* That is, if your documentation tells you that for integer lines, a
* register is supposed to be initialized with the value
* '2 * (minor axis delta)', you'll actually use dMinor.
*
* Example: Setting up the 8514
*
*     AXSTPSIGN is supposed to be the axial step constant register, defined
*     as 2 * (minor axis delta).  You set:
*
*           AXSTPSIGN = dMinor
*
*     DGSTPSIGN is supposed to be the diagonal step constant register,
*     defined as 2 * (minor axis delta) - 2 * (major axis delta).  You set:
*
*           DGSTPSIGN = dMinor - dMajor
*
*     ERR_TERM is supposed to be the adjusted error term, defined as
*     2 * (minor axis delta) - (major axis delta) - fixup.  You set:
*
*           ERR_TERM = lErrorTerm + dMinor
*
* Implementation:
*
*     You'll want to special case integer lines before calling this routine
*     (since they're very common, take less time to the computation of line
*     terms, and can handle longer lines than this routine because 4 bits
*     aren't being given to the fraction).
*
*     If a GIQ line is too long to be handled by this routine, you can just
*     use the slower strip routines for that line.  Note that you cannot
*     just fail the call -- you must be able to accurately draw any line
*     in the 28.4 device space when it intersects the viewport.
*
* Testing:
*
*     Use Guiman, or some other test that draws random fractional coordinate
*     lines and compares them to what GDI itself draws to a bitmap.
*
\**************************************************************************/

BOOL bHardwareLine(
PDEV*     ppdev,
POINTFIX* pptfxStart,       // Start of line
POINTFIX* pptfxEnd)         // End of line
{
    FLONG fl;    // Various flags
    ULONG M0;    // Normalized fractional unit x start coordinate (0 <= M0 < F)
    ULONG N0;    // Normalized fractional unit y start coordinate (0 <= N0 < F)
    ULONG M1;    // Normalized fractional unit x end coordinate (0 <= M1 < F)
    ULONG N1;    // Normalized fractional unit x end coordinate (0 <= N1 < F)
    ULONG dM;    // Normalized fractional unit x-delta (0 <= dM)
    ULONG dN;    // Normalized fractional unit y-delta (0 <= dN <= dM)
    LONG  x;     // Normalized x coordinate of origin
    LONG  y;     // Normalized y coordinate of origin
    LONG  x0;    // Normalized x offset from origin to start pixel (inclusive)
    LONG  y0;    // Normalized y offset from origin to start pixel (inclusive)
    LONG  x1;    // Normalized x offset from origin to end pixel (inclusive)
    LONG  lGamma;// Bresenham error term at origin
    LONG  cPels; // Number of pixels in line

/***********************************************************************\
* Normalize line to the first octant.
\***********************************************************************/

    fl = 0;

    M0 = pptfxStart->x;
    dM = pptfxEnd->x;

    if ((LONG) dM < (LONG) M0)
    {
    // Line runs from right to left, so flip across x = 0:

        M0 = -(LONG) M0;
        dM = -(LONG) dM;
        fl |= HW_FLIP_H;
    }

    // Compute the delta.  The DDI says we can never have a valid delta
    // with a magnitude more than 2^31 - 1, but the engine never actually
    // checks its transforms. So we check for that case and simply refuse
    // to draw the line:

    dM -= M0;
    if ((LONG) dM < 0)
        return(FALSE);

    N0 = pptfxStart->y;
    dN = pptfxEnd->y;

    if ((LONG) dN < (LONG) N0)
    {
    // Line runs from bottom to top, so flip across y = 0:

        N0 = -(LONG) N0;
        dN = -(LONG) dN;
        fl |= HW_FLIP_V;
    }

    // Compute another delta:

    dN -= N0;
    if ((LONG) dN < 0)
        return(FALSE);

    if (dN >= dM)
    {
        if (dN == dM)
        {
        // Have to special case slopes of one:

            fl |= HW_FLIP_SLOPE_ONE;
        }
        else
        {
        // Since line has slope greater than 1, flip across x = y:

            register ULONG ulTmp;
            ulTmp = dM; dM = dN; dN = ulTmp;
            ulTmp = M0; M0 = N0; N0 = ulTmp;
            fl |= HW_FLIP_D;
        }
    }

// Figure out if we can do the line in hardware, given that we have a
// limited number of bits of precision for the Bresenham terms.
//
// Remember that one bit has to be kept as a sign bit:

    if ((LONG) dM >= (1L << (NUM_DDA_BITS - 1)))
        return(FALSE);

    fl |= gaflHardwareRound[fl];

/***********************************************************************\
* Calculate the error term at pixel 0.
\***********************************************************************/

    x = LFLOOR((LONG) M0);
    y = LFLOOR((LONG) N0);

    M0 = FXFRAC(M0);
    N0 = FXFRAC(N0);

// NOTE NOTE NOTE: If this routine were to handle any line in the 28.4
// space, it will overflow its math (the following part requires 36 bits
// of precision)!  But we get here for lines that the hardware can handle
// (see the expression (dM >= (1L << (NUM_DDA_BITS - 1))) above?), so if
// cBits is less than 28, we're safe.
//
// If you're going to use this routine to handle all lines in the 28.4
// device space, you will HAVE to make sure the math doesn't overflow,
// otherwise you won't be NT compliant!  (See 'bHardwareLine' for an example
// how to do that.  You don't have to worry about this if you simply
// default to the strips code for long lines, because those routines
// already do the math correctly.)

// Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ].  Note
// that M0 and N0 have at most 4 bits of significance (and if the
// arguments are properly ordered, on a 486 each multiply would be no
// more than 13 cycles):

    lGamma = (N0 + F/2) * dM - M0 * dN;

    if (fl & HW_Y_ROUND_DOWN)
        lGamma--;

    lGamma >>= FLOG2;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.
\***********************************************************************/

// The toughest part of GIQ is determining the start and end pels.
//
// Our approach here is to calculate x0 and x1 (the inclusive start
// and end columns of the line respectively, relative to our normalized
// origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
// start point is easily calculated by plugging x0 into our line equation
// (which takes care of whether y = 1/2 rounds up or down in value)
// getting y0, and then undoing the normalizing flips to get back
// into device space.
//
// We look at the fractional parts of the coordinates of the start and
// end points, and call them (M0, N0) and (M1, N1) respectively, where
// 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
// to determine x0:
//
//   +-----------------------> +x
//   |
//   | 0                     1
//   |     0123456789abcdef
//   |
//   |   0 ........?xxxxxxx
//   |   1 ..........xxxxxx
//   |   2 ...........xxxxx
//   |   3 ............xxxx
//   |   4 .............xxx
//   |   5 ..............xx
//   |   6 ...............x
//   |   7 ................
//   |   8 ................
//   |   9 ......**........
//   |   a ........****...x
//   |   b ............****
//   |   c .............xxx****
//   |   d ............xxxx    ****
//   |   e ...........xxxxx        ****
//   |   f ..........xxxxxx
//   |
//   | 2                     3
//   v
//
//   +y
//
// This grid accounts for the appropriate rounding of GIQ and last-pel
// exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
// on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
// depending on what flips have been done to normalize the line.
//
// For the end point, if (M1, N1) lands on an 'x', x1 =
// floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
// floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
// depending on what flips have been done to normalize the line.
//
// Lines of exactly slope one require a special case for both the start
// and end.  For example, if the line ends such that (M1, N1) is (9, 1),
// the line has gone exactly through (8, 0) -- which may be considered
// to be part of 'x' because of rounding!  So slopes of exactly slope
// one going through (8, 0) must also be considered as belonging in 'x'
// when an x value of 1/2 is supposed to round up in value.

// Calculate x0, x1:

    N1 = FXFRAC(N0 + dN);
    M1 = FXFRAC(M0 + dM);

    x1 = LFLOOR(M0 + dM);

// Line runs left-to-right:

// Compute x1:

    x1--;
    if (M1 > 0)
    {
        if (N1 == 0)
        {
            if (LROUND(M1, fl & HW_X_ROUND_DOWN))
                x1++;
        }
        else if (abs((LONG) (N1 - F/2)) <= (LONG) M1)
        {
            x1++;
        }
    }

    if ((fl & (HW_FLIP_SLOPE_ONE | HW_X_ROUND_DOWN))
           == (HW_FLIP_SLOPE_ONE | HW_X_ROUND_DOWN))
    {
    // Have to special-case diagonal lines going through our
    // the point exactly equidistant between two horizontal
    // pixels, if we're supposed to round x=1/2 down:

        if ((M1 > 0) && (N1 == M1 + 8))
            x1--;

        if ((M0 > 0) && (N0 == M0 + 8))
        {
            x0 = 0;
            goto left_to_right_compute_y0;
        }
    }

// Compute x0:

    x0 = 0;
    if (M0 > 0)
    {
        if (N0 == 0)
        {
            if (LROUND(M0, fl & HW_X_ROUND_DOWN))
                x0 = 1;
        }
        else if (abs((LONG) (N0 - F/2)) <= (LONG) M0)
        {
            x0 = 1;
        }
    }

left_to_right_compute_y0:

/***********************************************************************\
* Calculate the start pixel.
\***********************************************************************/

// We now compute y0 and adjust the error term.  We know x0, and we know
// the current formula for the pixels to be lit on the line:
//
//                     dN * x + lGamma
//       y(x) = floor( --------------- )
//                           dM
//
// The remainder of this expression is the new error term at (x0, y0).
// Since x0 is going to be either 0 or 1, we don't actually have to do a
// multiply or divide to compute y0.  Finally, we subtract dM from the
// new error term so that it is in the range [-dM, 0).

    y0      = 0;
    lGamma += (dN & (-x0));
    lGamma -= dM;
    if (lGamma >= 0)
    {
        y0      = 1;
        lGamma -= dM;
    }

// Undo our flips to get the start coordinate:

    x += x0;
    y += y0;

    if (fl & HW_FLIP_D)
    {
        register LONG lTmp;
        lTmp = x; x = y; y = lTmp;
    }

    if (fl & HW_FLIP_V)
    {
        y = -y;
    }

    if (fl & HW_FLIP_H)
    {
        x = -x;
    }

/***********************************************************************\
* Return the Bresenham terms:
\***********************************************************************/

    // iDir       = gaiDir[fl & HW_FLIP_MASK];
    // ptlStart.x = x;
    // ptlStart.y = y;
    // cPels      = x1 - x0 + 1;  // NOTE: You'll have to check if cPels <= 0!
    // dMajor     = dM;
    // dMinor     = dN;
    // lErrorTerm = lGamma;

/***********************************************************************\
* Draw the line.  S3 specific code follows:
\***********************************************************************/

    cPels = x1 - x0 + 1;
    if (cPels > 0)
    {
        IO_FIFO_WAIT(ppdev, 7);

        IO_CUR_X(ppdev, x);
        IO_CUR_Y(ppdev, y);
        IO_MAJ_AXIS_PCNT(ppdev, cPels);
        IO_AXSTP(ppdev, dN);
        IO_DIASTP(ppdev, dN - dM);
        IO_ERR_TERM(ppdev, dN + lGamma);
        IO_CMD(ppdev, gaiDrawCmd[fl & HW_FLIP_MASK]);
    }

    return(TRUE);
}

/*******************************Public*Table*******************************\
* gapfnStrip
*
* Look-up table for DrvStrokePath to find which strip routines to call.
*
\**************************************************************************/

VOID (*gapfnStrip[])(PDEV*, STRIP*, LINESTATE*) = {
    vrlSolidHorizontal,
    vrlSolidVertical,
    vrlSolidDiagonalHorizontal,
    vrlSolidDiagonalVertical,

// Should be NUM_STRIP_DRAW_DIRECTIONS = 4 strip drawers in every group

    vssSolidHorizontal,
    vssSolidVertical,
    vssSolidDiagonalHorizontal,
    vssSolidDiagonalVertical,

// Should be NUM_STRIP_DRAW_STYLES = 8 strip drawers in total for doing
// solid lines, and the same number for non-solid lines:

    vStripStyledHorizontal,
    vStripStyledVertical,
    vStripStyledVertical,       // Diagonal goes here
    vStripStyledVertical,       // Diagonal goes here

    vStripStyledHorizontal,
    vStripStyledVertical,
    vStripStyledVertical,       // Diagonal goes here
    vStripStyledVertical,       // Diagonal goes here
};

// Style array for alternate style (alternates one pixel on, one pixel off):

STYLEPOS gaspAlternateStyle[] = { 1 };

/******************************Public*Routine******************************\
* BOOL DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix)
*
* Strokes the path.
*
\**************************************************************************/

BOOL DrvStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    STYLEPOS  aspLtoR[STYLE_MAX_COUNT];
    STYLEPOS  aspRtoL[STYLE_MAX_COUNT];
    LINESTATE ls;
    PFNSTRIP* apfn;
    FLONG     fl;
    PDEV*     ppdev;
    DSURF*    pdsurf;
    RECTL     arclClip[4];                  // For rectangular clipping
    BYTE*     pjMmBase;
    RECTL*    prclClip;
    ULONG     ulHwMix;
    RECTFX    rcfxBounds;
    BOOL      bMore;
    CLIPENUM  ce;
    LONG      i;
    ULONG     iSolidColor;
    LONG      cFifo;

    ASSERTDD(((mix >> 8) & 0xff) == (mix & 0xff),
             "GDI gave us an improper mix");

    pdsurf = (DSURF*) pso->dhsurf;
    ASSERTDD(!(pdsurf->dt & DT_DIB), "Didn't expect DT_DIB");

// We'll be drawing to the screen or an off-screen DFB; copy the surface's
// offset now so that we won't need to refer to the DSURF again:

    ppdev = (PDEV*) pso->dhpdev;
    ppdev->xOffset = pdsurf->x;
    ppdev->yOffset = pdsurf->y;

    pjMmBase = ppdev->pjMmBase;

//////////////////////////////////////////////////////////////////////
// Special case solid integer lines:

    if ((ppdev->flCaps & CAPS_POLYGON) &&   // S3 must be capable of polylines
        (ppo->fl & PO_ALL_INTEGERS) &&      // Points must be integer
        !(pla->fl & LA_STYLED))             // Solid lines, no styles
    {
    // As of NT 4.0 SP2, the rasterization convention has been loosened
    // for paths that have the PO_ALL_INTEGERS flag set.  For those paths,
    // you may do the 'tie-breaker' pixels anyway you like, which usually
    // means that you can use the point-to-point line drawing capabilities
    // of the hardware.
    //
    // HOWEVER: Your implementation must be invariant, regardless of clipping!
    //          This means that if you choose to deviate from the standard NT
    //          line convention, you MUST draw the same thing for DC_TRIVIAL,
    //          DC_RECT, *and* DC_COMPLEX clipping.

    // First, do the common setup:

        IO_ALL_EMPTY(ppdev);

        cFifo = MM_ALL_EMPTY_FIFO_COUNT - 3;
        NW_FRGD_COLOR(ppdev, pjMmBase, pbo->iSolidColor);
        NW_PIX_CNTL(ppdev, pjMmBase, ALL_ONES); 
        NW_ALT_MIX(ppdev, pjMmBase, FOREGROUND_COLOR | gajHwMixFromMix[mix & 0xf], 0);

    // Now, do the drawing:

        if (pco->iDComplexity == DC_TRIVIAL)
        {
            vLinesSimple(ppdev, ppo, cFifo);
            return(TRUE);
        }
        else
        {
        // We have to make sure that the path coordinates would not
        // overflow our hardware precision!  Note that the path's
        // bounds are still expressed as 28.4 coordinates even if
        // PO_ALL_INTEGERS or PO_ENUM_AS_INTEGERS is set:

            PATHOBJ_vGetBounds(ppo, &rcfxBounds);
            if ((rcfxBounds.xLeft   >= 16 * MIN_INTEGER_BOUND) &&
                (rcfxBounds.yTop    >= 16 * MIN_INTEGER_BOUND) &&
                (rcfxBounds.xRight  <= 16 * MAX_INTEGER_BOUND) &&
                (rcfxBounds.yBottom <= 16 * MAX_INTEGER_BOUND))
            {
                // NOTE that if you deviate from the standard NT line
                // convention for PO_ALL_INTEGERS flags, you must support
                // all clipping types!

                if (pco->iDComplexity == DC_RECT)
                {
                    vSetClipping(ppdev, &pco->rclBounds);
                    vLinesSimple(ppdev, ppo, 0);
                }
                else
                {
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN,
                                       0);

                    do {
                        // Get a batch of region rectangles:

                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*) &ce);
                        for (i = 0; i < ce.c; i++)
                        {
                            vSetClipping(ppdev, &ce.arcl[i]);
                            vLinesSimple(ppdev, ppo, 0);
                        }
                    } while (bMore);
                }

                vResetClipping(ppdev);
                return(TRUE);
            }
        }
    }

    prclClip = NULL;
    fl       = 0;

// Look after styling initialization:

    if (pla->fl & LA_ALTERNATE)
    {
        ls.cStyle      = 1;
        ls.spTotal     = 1;
        ls.spTotal2    = 2;
        ls.spRemaining = 1;
        ls.aspRtoL     = &gaspAlternateStyle[0];
        ls.aspLtoR     = &gaspAlternateStyle[0];
        ls.spNext      = HIWORD(pla->elStyleState.l);
        ls.xyDensity   = 1;
        fl            |= FL_STYLED;
        ls.ulStartMask = 0L;
    }
    else if (pla->pstyle != (FLOAT_LONG*) NULL)
    {
        PFLOAT_LONG pstyle;
        STYLEPOS*   pspDown;
        STYLEPOS*   pspUp;

        pstyle = &pla->pstyle[pla->cstyle];

        ls.xyDensity = STYLE_DENSITY;
        ls.spTotal   = 0;
        while (pstyle-- > pla->pstyle)
        {
            ls.spTotal += pstyle->l;
        }
        ls.spTotal *= STYLE_DENSITY;
        ls.spTotal2 = 2 * ls.spTotal;

    // Compute starting style position (this is guaranteed not to overflow):

        ls.spNext = HIWORD(pla->elStyleState.l) * STYLE_DENSITY +
                    LOWORD(pla->elStyleState.l);

        fl        |= FL_STYLED;
        ls.cStyle  = pla->cstyle;
        ls.aspRtoL = aspRtoL;
        ls.aspLtoR = aspLtoR;

        if (pla->fl & LA_STARTGAP)
            ls.ulStartMask = 0xffffffffL;
        else
            ls.ulStartMask = 0L;

        pstyle  = pla->pstyle;
        pspDown = &ls.aspRtoL[ls.cStyle - 1];
        pspUp   = &ls.aspLtoR[0];

        while (pspDown >= &ls.aspRtoL[0])
        {
            *pspDown = pstyle->l * STYLE_DENSITY;
            *pspUp   = *pspDown;

            pspUp++;
            pspDown--;
            pstyle++;
        }
    }

    if (pco->iDComplexity == DC_RECT)
    {
        fl |= FL_SIMPLE_CLIP;

        arclClip[0]        =  pco->rclBounds;

    // FL_FLIP_D:

        arclClip[1].top    =  pco->rclBounds.left;
        arclClip[1].left   =  pco->rclBounds.top;
        arclClip[1].bottom =  pco->rclBounds.right;
        arclClip[1].right  =  pco->rclBounds.bottom;

    // FL_FLIP_V:

        arclClip[2].top    = -pco->rclBounds.bottom + 1;
        arclClip[2].left   =  pco->rclBounds.left;
        arclClip[2].bottom = -pco->rclBounds.top + 1;
        arclClip[2].right  =  pco->rclBounds.right;

    // FL_FLIP_V | FL_FLIP_D:

        arclClip[3].top    =  pco->rclBounds.left;
        arclClip[3].left   = -pco->rclBounds.bottom + 1;
        arclClip[3].bottom =  pco->rclBounds.right;
        arclClip[3].right  = -pco->rclBounds.top + 1;

        prclClip = arclClip;
    }

    apfn = &gapfnStrip[NUM_STRIP_DRAW_STYLES *
                            ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];

//////////////////////////////////////////////////////////////////////
// S3 specific initialization:

    ulHwMix = gajHwMixFromMix[mix & 0xf];

// Get the device ready:

    if (ppdev->flCaps & CAPS_MM_IO)
    {
        IO_FIFO_WAIT(ppdev, 3);
        MM_FRGD_MIX(ppdev, pjMmBase, FOREGROUND_COLOR | ulHwMix);
        MM_PIX_CNTL(ppdev, pjMmBase, ALL_ONES);
        MM_FRGD_COLOR(ppdev, pjMmBase, pbo->iSolidColor);
    }
    else
    {
        IO_FIFO_WAIT(ppdev, 4);
        IO_FRGD_MIX(ppdev, FOREGROUND_COLOR | ulHwMix);
        IO_PIX_CNTL(ppdev, ALL_ONES);

        if (DEPTH32(ppdev))
        {
            IO_FRGD_COLOR32(ppdev, pbo->iSolidColor);
        }
        else
        {
            IO_FRGD_COLOR(ppdev, pbo->iSolidColor);
        }
    }

//////////////////////////////////////////////////////////////////////
// Set up to enumerate the path:

    if (pco->iDComplexity != DC_COMPLEX)
    {
        PATHDATA  pd;
        BOOL      bMore;
        ULONG     cptfx;
        POINTFIX  ptfxStartFigure;
        POINTFIX  ptfxLast;
        POINTFIX* pptfxFirst;
        POINTFIX* pptfxBuf;


        pd.flags = 0;
        PATHOBJ_vEnumStart(ppo);

        do {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            cptfx = pd.count;
            if (cptfx == 0)
                break;

            if (pd.flags & PD_BEGINSUBPATH)
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                cptfx--;
            }
            else
            {
                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;
            }

            if (pd.flags & PD_RESETSTYLE)
                ls.spNext = 0;

            if (cptfx > 0)
            {
                if (!bLines(ppdev,
                            pptfxFirst,
                            pptfxBuf,
                            (RUN*) NULL,
                            cptfx,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                    return(FALSE);
            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if (pd.flags & PD_CLOSEFIGURE)
            {
                if (!bLines(ppdev,
                            &ptfxLast,
                            &ptfxStartFigure,
                            (RUN*) NULL,
                            1,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                    return(FALSE);
            }
        } while (bMore);

        if (fl & FL_STYLED)
        {
        // Save the style state:

            ULONG ulHigh;
            ULONG ulLow;

        // Masked styles don't normalize the style state.  It's a good
        // thing to do, so let's do it now:

            if ((ULONG) ls.spNext >= (ULONG) ls.spTotal2)
                ls.spNext = (ULONG) ls.spNext % (ULONG) ls.spTotal2;

            ulHigh = ls.spNext / ls.xyDensity;
            ulLow  = ls.spNext % ls.xyDensity;

            pla->elStyleState.l = MAKELONG(ulLow, ulHigh);
        }
    }
    else
    {
    // Local state for path enumeration:

        BOOL bMore;
        union {
            BYTE     aj[offsetof(CLIPLINE, arun) + RUN_MAX * sizeof(RUN)];
            CLIPLINE cl;
        } cl;

        fl |= FL_COMPLEX_CLIP;

    // We use the clip object when non-simple clipping is involved:

        PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pla);

        do {
            bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(cl), &cl.cl);
            if (cl.cl.c != 0)
            {
                if (fl & FL_STYLED)
                {
                    ls.spComplex = HIWORD(cl.cl.lStyleState) * ls.xyDensity
                                 + LOWORD(cl.cl.lStyleState);
                }
                if (!bLines(ppdev,
                            &cl.cl.ptfxA,
                            &cl.cl.ptfxB,
                            &cl.cl.arun[0],
                            cl.cl.c,
                            &ls,
                            (RECTL*) NULL,
                            apfn,
                            fl))
                    return(FALSE);
            }
        } while (bMore);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\lineto.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: Lineto.c
*
* DrvLineTo for S3 driver
*
* Copyright (c) 1995-1998 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// For the S3, we use the following flags to denote the quadrant, and
// we use this as an index into 'gaiLineBias' to determine the Bresenham
// error bias:

#define QUAD_PLUS_X         1
#define QUAD_MAJOR_Y        2
#define QUAD_PLUS_Y         4

LONG gaiLineBias[] = { 0, 0, 0, 1, 1, 1, 0, 1 };

// We shift these flags by 'QUADRANT_SHIFT' to send the actual
// command to the S3:

#define QUADRANT_SHIFT      5

/******************************Public*Routine******************************\
* VOID vNwLineToTrivial
*
* Draws a single solid integer-only unclipped cosmetic line using
* 'New MM I/O'.
*
* We can't use the point-to-point capabilities of the S3 because its
* tie-breaker convention doesn't match that of NT's in two octants,
* and would cause us to fail HCTs.
*
\**************************************************************************/

VOID vNwLineToTrivial(
PDEV*       ppdev,
LONG        x,              // Passed in x1
LONG        y,              // Passed in y1
LONG        dx,             // Passed in x2
LONG        dy,             // Passed in y2
ULONG       iSolidColor,    // -1 means hardware is already set up
MIX         mix)
{
    BYTE*   pjMmBase;
    FLONG   flQuadrant;

    pjMmBase = ppdev->pjMmBase;

    NW_FIFO_WAIT(ppdev, pjMmBase, 8);

    if (iSolidColor != (ULONG) -1)
    {
        NW_FRGD_COLOR(ppdev, pjMmBase, iSolidColor);
        NW_ALT_MIX(ppdev, pjMmBase, FOREGROUND_COLOR |
                                    gajHwMixFromMix[mix & 0xf], 0);
        MM_PIX_CNTL(ppdev, pjMmBase, ALL_ONES);
    }

    NW_ABS_CURXY(ppdev, pjMmBase, x, y);

    flQuadrant = (QUAD_PLUS_X | QUAD_PLUS_Y);

    dx -= x;
    if (dx < 0)
    {
        dx = -dx;
        flQuadrant &= ~QUAD_PLUS_X;
    }

    dy -= y;
    if (dy < 0)
    {
        dy = -dy;
        flQuadrant &= ~QUAD_PLUS_Y;
    }

    if (dy > dx)
    {
        register LONG l;

        l  = dy;
        dy = dx;
        dx = l;                     // Swap 'dx' and 'dy'
        flQuadrant |= QUAD_MAJOR_Y;
    }

    NW_ALT_PCNT(ppdev, pjMmBase, dx, 0);
    NW_ALT_STEP(ppdev, pjMmBase, dy - dx, dy);
    NW_ALT_ERR(ppdev, pjMmBase, 0,
                                (dy + dy - dx - gaiLineBias[flQuadrant]) >> 1);
    NW_ALT_CMD(ppdev, pjMmBase, (flQuadrant << QUADRANT_SHIFT) |
                                (DRAW_LINE | DRAW | DIR_TYPE_XY |
                                 MULTIPLE_PIXELS | WRITE | LAST_PIXEL_OFF));
}

/******************************Public*Routine******************************\
* VOID vNwLineToClipped
*
* Draws a single solid integer-only clipped cosmetic line using
* 'New MM I/O'.
*
\**************************************************************************/

VOID vNwLineToClipped(
PDEV*       ppdev,
LONG        x1,
LONG        y1,
LONG        x2,
LONG        y2,
ULONG       iSolidColor,
MIX         mix,
RECTL*      prclClip)
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    NW_FIFO_WAIT(ppdev, pjMmBase, 2);

    NW_ABS_SCISSORS_LT(ppdev, pjMmBase,
                       prclClip->left    + xOffset,
                       prclClip->top     + yOffset);
    NW_ABS_SCISSORS_RB(ppdev, pjMmBase,
                       prclClip->right   + xOffset - 1,
                       prclClip->bottom  + yOffset - 1);

    vNwLineToTrivial(ppdev, x1, y1, x2, y2, iSolidColor, mix);

    NW_FIFO_WAIT(ppdev, pjMmBase, 2);

    NW_ABS_SCISSORS_LT(ppdev, pjMmBase, 0, 0);
    NW_ABS_SCISSORS_RB(ppdev, pjMmBase,
                       ppdev->cxMemory - 1,
                       ppdev->cyMemory - 1);
}

/******************************Public*Routine******************************\
* VOID vMmLineToTrivial
*
* Draws a single solid integer-only unclipped cosmetic line using
* 'Old MM I/O'.
*
\**************************************************************************/

VOID vMmLineToTrivial(
PDEV*       ppdev,
LONG        x,              // Passed in x1
LONG        y,              // Passed in y1
LONG        dx,             // Passed in x2
LONG        dy,             // Passed in y2
ULONG       iSolidColor,    // -1 means hardware is already set up
MIX         mix)
{
    BYTE*   pjMmBase;
    FLONG   flQuadrant;

    pjMmBase = ppdev->pjMmBase;

    if (iSolidColor != (ULONG) -1)
    {
        IO_FIFO_WAIT(ppdev, 3);

        MM_FRGD_COLOR(ppdev, pjMmBase, iSolidColor);
        MM_FRGD_MIX(ppdev, pjMmBase, FOREGROUND_COLOR | gajHwMixFromMix[mix & 0xf]);
        MM_PIX_CNTL(ppdev, pjMmBase, ALL_ONES);
    }

    IO_FIFO_WAIT(ppdev, 7);
    MM_ABS_CUR_X(ppdev, pjMmBase, x);
    MM_ABS_CUR_Y(ppdev, pjMmBase, y);

    flQuadrant = (QUAD_PLUS_X | QUAD_PLUS_Y);

    dx -= x;
    if (dx < 0)
    {
        dx = -dx;
        flQuadrant &= ~QUAD_PLUS_X;
    }

    dy -= y;
    if (dy < 0)
    {
        dy = -dy;
        flQuadrant &= ~QUAD_PLUS_Y;
    }

    if (dy > dx)
    {
        register LONG l;

        l  = dy;
        dy = dx;
        dx = l;                     // Swap 'dx' and 'dy'
        flQuadrant |= QUAD_MAJOR_Y;
    }

    MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, dx);
    MM_AXSTP(ppdev, pjMmBase, dy);
    MM_DIASTP(ppdev, pjMmBase, dy - dx);
    MM_ERR_TERM(ppdev, pjMmBase,
                (dy + dy - dx - gaiLineBias[flQuadrant]) >> 1);
    MM_CMD(ppdev, pjMmBase, (flQuadrant << QUADRANT_SHIFT) |
                                (DRAW_LINE | DRAW | DIR_TYPE_XY |
                                 MULTIPLE_PIXELS | WRITE | LAST_PIXEL_OFF));
}

/******************************Public*Routine******************************\
* VOID vMmLineToClipped
*
* Draws a single solid integer-only clipped cosmetic line using
* 'Old MM I/O'.
*
\**************************************************************************/

VOID vMmLineToClipped(
PDEV*       ppdev,
LONG        x1,
LONG        y1,
LONG        x2,
LONG        y2,
ULONG       iSolidColor,
MIX         mix,
RECTL*      prclClip)
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    IO_FIFO_WAIT(ppdev, 4);

    MM_ABS_SCISSORS_L(ppdev, pjMmBase, prclClip->left   + xOffset);
    MM_ABS_SCISSORS_R(ppdev, pjMmBase, prclClip->right  + xOffset - 1);
    MM_ABS_SCISSORS_T(ppdev, pjMmBase, prclClip->top    + yOffset);
    MM_ABS_SCISSORS_B(ppdev, pjMmBase, prclClip->bottom + yOffset - 1);

    vMmLineToTrivial(ppdev, x1, y1, x2, y2, iSolidColor, mix);

    IO_FIFO_WAIT(ppdev, 4);

    MM_ABS_SCISSORS_L(ppdev, pjMmBase, 0);
    MM_ABS_SCISSORS_T(ppdev, pjMmBase, 0);
    MM_ABS_SCISSORS_R(ppdev, pjMmBase, ppdev->cxMemory - 1);
    MM_ABS_SCISSORS_B(ppdev, pjMmBase, ppdev->cyMemory - 1);
}

/******************************Public*Routine******************************\
* VOID vIoLineToTrivial
*
* Draws a single solid integer-only unclipped cosmetic line using
* 'Old I/O'.
*
\**************************************************************************/

VOID vIoLineToTrivial(
PDEV*       ppdev,
LONG        x,              // Passed in x1
LONG        y,              // Passed in y1
LONG        dx,             // Passed in x2
LONG        dy,             // Passed in y2
ULONG       iSolidColor,    // -1 means hardware is already set up
MIX         mix)
{
    BYTE*   pjMmBase;
    FLONG   flQuadrant;

    pjMmBase = ppdev->pjMmBase;

    if (iSolidColor != (ULONG) -1)
    {
        IO_FIFO_WAIT(ppdev, 4);

        if (DEPTH32(ppdev))
        {
            IO_FRGD_COLOR32(ppdev, iSolidColor);
        }
        else
        {
            IO_FRGD_COLOR(ppdev, iSolidColor);
        }

        IO_FRGD_MIX(ppdev, FOREGROUND_COLOR | gajHwMixFromMix[mix & 0xf]);
        IO_PIX_CNTL(ppdev, ALL_ONES);
    }

    IO_FIFO_WAIT(ppdev, 7);
    IO_ABS_CUR_X(ppdev, x);
    IO_ABS_CUR_Y(ppdev, y);

    flQuadrant = (QUAD_PLUS_X | QUAD_PLUS_Y);

    dx -= x;
    if (dx < 0)
    {
        dx = -dx;
        flQuadrant &= ~QUAD_PLUS_X;
    }

    dy -= y;
    if (dy < 0)
    {
        dy = -dy;
        flQuadrant &= ~QUAD_PLUS_Y;
    }

    if (dy > dx)
    {
        register LONG l;

        l  = dy;
        dy = dx;
        dx = l;                     // Swap 'dx' and 'dy'
        flQuadrant |= QUAD_MAJOR_Y;
    }

    IO_MAJ_AXIS_PCNT(ppdev, dx);
    IO_AXSTP(ppdev, dy);
    IO_DIASTP(ppdev, dy - dx);
    IO_ERR_TERM(ppdev, (dy + dy - dx - gaiLineBias[flQuadrant]) >> 1);
    IO_CMD(ppdev, (flQuadrant << QUADRANT_SHIFT) |
                                (DRAW_LINE | DRAW | DIR_TYPE_XY |
                                 MULTIPLE_PIXELS | WRITE | LAST_PIXEL_OFF));
}

/******************************Public*Routine******************************\
* VOID vIoLineToClipped
*
* Draws a single solid integer-only clipped cosmetic line using
* 'Old I/O'.
*
\**************************************************************************/

VOID vIoLineToClipped(
PDEV*       ppdev,
LONG        x1,
LONG        y1,
LONG        x2,
LONG        y2,
ULONG       iSolidColor,
MIX         mix,
RECTL*      prclClip)
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    IO_FIFO_WAIT(ppdev, 4);

    IO_ABS_SCISSORS_L(ppdev, prclClip->left   + xOffset);
    IO_ABS_SCISSORS_R(ppdev, prclClip->right  + xOffset - 1);
    IO_ABS_SCISSORS_T(ppdev, prclClip->top    + yOffset);
    IO_ABS_SCISSORS_B(ppdev, prclClip->bottom + yOffset - 1);

    vIoLineToTrivial(ppdev, x1, y1, x2, y2, iSolidColor, mix);

    IO_FIFO_WAIT(ppdev, 4);

    IO_ABS_SCISSORS_L(ppdev, 0);
    IO_ABS_SCISSORS_T(ppdev, 0);
    IO_ABS_SCISSORS_R(ppdev, ppdev->cxMemory - 1);
    IO_ABS_SCISSORS_B(ppdev, ppdev->cyMemory - 1);
}

/******************************Public*Routine******************************\
* BOOL DrvLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix)
*
* Draws a single solid integer-only cosmetic line.
*
\**************************************************************************/

BOOL DrvLineTo(
SURFOBJ*    pso,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
LONG        x1,
LONG        y1,
LONG        x2,
LONG        y2,
RECTL*      prclBounds,
MIX         mix)
{
    PDEV*   ppdev;
    DSURF*  pdsurf;
    LONG    xOffset;
    LONG    yOffset;
    BOOL    bRet;

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;
    ASSERTDD(!(pdsurf->dt & DT_DIB), "Didn't expect DT_DIB");

    // We'll be drawing to the screen or an off-screen DFB; copy the surface's
    // offset now so that we won't need to refer to the DSURF again:

    ppdev = (PDEV*) pso->dhpdev;

    xOffset = pdsurf->x;
    yOffset = pdsurf->y;

    x1 += xOffset;
    x2 += xOffset;
    y1 += yOffset;
    y2 += yOffset;

    bRet = TRUE;

    if (pco == NULL)
    {
        ppdev->pfnLineToTrivial(ppdev, x1, y1, x2, y2, pbo->iSolidColor, mix);
    }
    else if ((pco->iDComplexity <= DC_RECT) &&
             (prclBounds->left >= MIN_INTEGER_BOUND) &&
             (prclBounds->top    >= MIN_INTEGER_BOUND) &&
             (prclBounds->right  <= MAX_INTEGER_BOUND) &&
             (prclBounds->bottom <= MAX_INTEGER_BOUND))
    {
        // s3 diamond 968 doesn't like negative x coordinates.
        if ((ppdev->iBitmapFormat == BMF_24BPP) && (prclBounds->left < 0))
            return FALSE;

        ppdev->xOffset = xOffset;
        ppdev->yOffset = yOffset;

        ppdev->pfnLineToClipped(ppdev, x1, y1, x2, y2, pbo->iSolidColor, mix,
                                  &pco->rclBounds);
    }
    else
    {
        bRet = FALSE;
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\lines.h ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: lines.h
*
* Line drawing constants and structures.
*
* NOTE: This file mirrors LINES.INC.  Changes here must be reflected in
* the .inc file!
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

typedef struct _PDEV PDEV;      // Handy forward declaration

// We have to be careful that we don't overflow any registers when using
// the hardware to draw lines (as opposed to going through the strips
// routines, which will never overflow).  We accomplish this by simply
// checking the bounds of the path; if it is so large that any of the
// hardware terms may overflow, we punt the entire path to the strips
// code (should be pretty rare).

#define MAX_INTEGER_BOUND  (1535)   // S3's line length term is limited to
#define MIN_INTEGER_BOUND  (-512)   //   a maximum value of 2047

// We have special strip routines when all strips have at most this many
// pixels:

#define MAX_SHORT_STROKE_LENGTH 15

// # of strip drawers in every group:

#define NUM_STRIP_DRAW_DIRECTIONS 4

// # of strip drawers for doing either solid lines or styled lines:

#define NUM_STRIP_DRAW_STYLES 8

typedef LONG STYLEPOS;

#define STYLE_MAX_COUNT     16
#define STYLE_MAX_VALUE     0x3fffL
#define RUN_MAX             20
#define STRIP_MAX           100
#define STYLE_DENSITY       3

// Flip and round flags:

#define FL_H_ROUND_DOWN         0x00000080L     // .... .... 1... ....
#define FL_V_ROUND_DOWN         0x00008000L     // 1... .... .... ....

#define FL_FLIP_D               0x00000005L     // .... .... .... .1.1
#define FL_FLIP_V               0x00000008L     // .... .... .... 1...
#define FL_FLIP_SLOPE_ONE       0x00000010L     // .... .... ...1 ....
#define FL_FLIP_HALF            0x00000002L     // .... .... .... ..1.
#define FL_FLIP_H               0x00000200L     // .... ..1. .... ....

#define FL_ROUND_MASK           0x0000001CL     // .... .... ...1 11..
#define FL_ROUND_SHIFT          2

#define FL_RECTLCLIP_MASK       0x0000000CL     // .... .... .... 11..
#define FL_RECTLCLIP_SHIFT      2

#define FL_STRIP_MASK           0x00000003L     // .... .... .... ..11
#define FL_STRIP_SHIFT          0

#define FL_SIMPLE_CLIP          0x00000020      // .... .... ..1. ....
#define FL_COMPLEX_CLIP         0x00000040      // .... .... .1.. ....
#define FL_CLIP                (FL_SIMPLE_CLIP | FL_COMPLEX_CLIP)

#define FL_STYLED               0x00000400L     // .... .1.. .... ....
#define FL_ALTERNATESTYLED      0x00001000L     // ...1 .... .... ....

#define FL_STYLE_MASK           0x00000400L
#define FL_STYLE_SHIFT          10

#define FL_LAST_PEL_INCLUSIVE   0x00002000L     // ..1. .... .... ....

// Miscellaneous DDA defines:

#define LROUND(x, flRoundDown) (((x) + F/2 - ((flRoundDown) > 0)) >> 4)
#define F                     16
#define FLOG2                 4
#define LFLOOR(x)             ((x) >> 4)
#define FXFRAC(x)             ((x) & (F - 1))

////////////////////////////////////////////////////////////////////////////
// NOTE: The following structures must exactly match those declared in
//       lines.inc!

typedef struct _STRIP {
    LONG   cStrips;               // # of strips in array
    LONG   flFlips;               // Indicates if line goes up or down
    POINTL ptlStart;             // first point
    LONG   alStrips[STRIP_MAX];   // Array of strips
} STRIP;

typedef struct _LINESTATE {
    STYLEPOS*       pspStart;       // Pointer to start of style array
    STYLEPOS*       pspEnd;         // Pointer to end of style array
    STYLEPOS*       psp;            // Pointer to current style entry

    STYLEPOS        spRemaining;    // To go in current style
    STYLEPOS        spTotal;        // Sum of style array
    STYLEPOS        spTotal2;       // Twice sum of style array
    STYLEPOS        spNext;         // Style state at start of next line
    STYLEPOS        spComplex;      // Style state at start of complex clip line

    STYLEPOS*       aspRtoL;        // Style array in right-to-left order
    STYLEPOS*       aspLtoR;        // Style array in left-to-right order

    ULONG           ulStyleMask;    // Are we working on a gap in the style?
                                    // 0xff if yes, 0x0 if not
    ULONG           xyDensity;      // Density of style
    ULONG           cStyle;         // Size of style array

    ULONG           ulStyleMaskLtoR;// Original style mask, left-to-right order
    ULONG           ulStyleMaskRtoL;// Original style mask, right-to-left order

    BOOL            ulStartMask;    // Determines if first element in style
                                    // array is for a gap or a dash

} LINESTATE;                        /* ls */

// Strip drawer prototype:

typedef VOID (*PFNSTRIP)(PDEV*, STRIP*, LINESTATE*);
extern PFNSTRIP gapfnStrip[];

// Strip drawers:

VOID vssSolidHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vssSolidVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vssSolidDiagonalHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidDiagonalHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vssSolidDiagonalVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidDiagonalVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vStripStyledHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vStripStyledVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

// External calls:

BOOL bLines(PDEV*, POINTFIX*, POINTFIX*, RUN* prun, ULONG,
            LINESTATE*, RECTL*, PFNSTRIP apfn[], FLONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\misc.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: misc.c
*
* Miscellaneous common routines.
*
* Copyright (c) 1992-1998 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Table********************************\
* BYTE gaulHwMixFromRop2[]
*
* Table to convert from a Source and Destination Rop2 to the hardware's
* mix.
\**************************************************************************/

ULONG gaulHwMixFromRop2[] = {
    LOGICAL_0,                      // 00 -- 0      BLACKNESS
    NOT_SCREEN_AND_NOT_NEW,         // 11 -- DSon   NOTSRCERASE
    SCREEN_AND_NOT_NEW,             // 22 -- DSna
    NOT_NEW,                        // 33 -- Sn     NOSRCCOPY
    NOT_SCREEN_AND_NEW,             // 44 -- SDna   SRCERASE
    NOT_SCREEN,                     // 55 -- Dn     DSTINVERT
    SCREEN_XOR_NEW,                 // 66 -- DSx    SRCINVERT
    NOT_SCREEN_OR_NOT_NEW,          // 77 -- DSan
    SCREEN_AND_NEW,                 // 88 -- DSa    SRCAND
    NOT_SCREEN_XOR_NEW,             // 99 -- DSxn
    LEAVE_ALONE,                    // AA -- D
    SCREEN_OR_NOT_NEW,              // BB -- DSno   MERGEPAINT
    OVERPAINT,                      // CC -- S      SRCCOPY
    NOT_SCREEN_OR_NEW,              // DD -- SDno
    SCREEN_OR_NEW,                  // EE -- DSo    SRCPAINT
    LOGICAL_1                       // FF -- 1      WHITENESS
};

/******************************Public*Table********************************\
* BYTE gajHwMixFromMix[]
*
* Table to convert from a GDI mix value to the hardware's mix.
*
* Ordered so that the mix may be calculated from gajHwMixFromMix[mix & 0xf]
* or gajHwMixFromMix[mix & 0xff].
\**************************************************************************/

BYTE gajHwMixFromMix[] = {
    LOGICAL_1,                      // 0  -- 1
    LOGICAL_0,                      // 1  -- 0
    NOT_SCREEN_AND_NOT_NEW,         // 2  -- DPon
    SCREEN_AND_NOT_NEW,             // 3  -- DPna
    NOT_NEW,                        // 4  -- Pn
    NOT_SCREEN_AND_NEW,             // 5  -- PDna
    NOT_SCREEN,                     // 6  -- Dn
    SCREEN_XOR_NEW,                 // 7  -- DPx
    NOT_SCREEN_OR_NOT_NEW,          // 8  -- DPan
    SCREEN_AND_NEW,                 // 9  -- DPa
    NOT_SCREEN_XOR_NEW,             // 10 -- DPxn
    LEAVE_ALONE,                    // 11 -- D
    SCREEN_OR_NOT_NEW,              // 12 -- DPno
    OVERPAINT,                      // 13 -- P
    NOT_SCREEN_OR_NEW,              // 14 -- PDno
    SCREEN_OR_NEW,                  // 15 -- DPo
    LOGICAL_1                       // 16 -- 1
};

/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
\**************************************************************************/

BYTE gaRop3FromMix[] =
{
    0xFF,  // R2_WHITE          - Allow rop = gaRop3FromMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE          - Allow rop = gaRop3FromMix[mix & 0xFF]
};

/******************************Public*Routine******************************\
* BOOL bIntersect
*
* If 'prcl1' and 'prcl2' intersect, has a return value of TRUE and returns
* the intersection in 'prclResult'.  If they don't intersect, has a return
* value of FALSE, and 'prclResult' is undefined.
*
\**************************************************************************/

BOOL bIntersect(
RECTL*  prcl1,
RECTL*  prcl2,
RECTL*  prclResult)
{
    prclResult->left  = max(prcl1->left,  prcl2->left);
    prclResult->right = min(prcl1->right, prcl2->right);

    if (prclResult->left < prclResult->right)
    {
        prclResult->top    = max(prcl1->top,    prcl2->top);
        prclResult->bottom = min(prcl1->bottom, prcl2->bottom);

        if (prclResult->top < prclResult->bottom)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* LONG cIntersect
*
* This routine takes a list of rectangles from 'prclIn' and clips them
* in-place to the rectangle 'prclClip'.  The input rectangles don't
* have to intersect 'prclClip'; the return value will reflect the
* number of input rectangles that did intersect, and the intersecting
* rectangles will be densely packed.
*
\**************************************************************************/

LONG cIntersect(
RECTL*  prclClip,
RECTL*  prclIn,         // List of rectangles
LONG    c)              // Can be zero
{
    LONG    cIntersections;
    RECTL*  prclOut;

    cIntersections = 0;
    prclOut        = prclIn;

    for (; c != 0; prclIn++, c--)
    {
        prclOut->left  = max(prclIn->left,  prclClip->left);
        prclOut->right = min(prclIn->right, prclClip->right);

        if (prclOut->left < prclOut->right)
        {
            prclOut->top    = max(prclIn->top,    prclClip->top);
            prclOut->bottom = min(prclIn->bottom, prclClip->bottom);

            if (prclOut->top < prclOut->bottom)
            {
                prclOut++;
                cIntersections++;
            }
        }
    }

    return(cIntersections);
}

/******************************Public*Routine******************************\
* VOID vResetClipping
\**************************************************************************/

VOID vResetClipping(
PDEV*   ppdev)
{
    IO_FIFO_WAIT(ppdev, 4);

    IO_ABS_SCISSORS_L(ppdev, 0);
    IO_ABS_SCISSORS_T(ppdev, 0);
    IO_ABS_SCISSORS_R(ppdev, ppdev->cxMemory - 1);
    IO_ABS_SCISSORS_B(ppdev, ppdev->cyMemory - 1);
}

/******************************Public*Routine******************************\
* VOID vSetClipping
\**************************************************************************/

VOID vSetClipping(
PDEV*   ppdev,
RECTL*  prclClip)           // In relative coordinates
{
    LONG xOffset;
    LONG yOffset;

    ASSERTDD(prclClip->left + ppdev->xOffset >= 0,
                    "Can't have a negative left!");
    ASSERTDD(prclClip->top + ppdev->yOffset >= 0,
                    "Can't have a negative top!");

    IO_FIFO_WAIT(ppdev, 4);

    xOffset = ppdev->xOffset;
    IO_ABS_SCISSORS_L(ppdev, prclClip->left      + xOffset);
    IO_ABS_SCISSORS_R(ppdev, prclClip->right - 1 + xOffset);

    yOffset = ppdev->yOffset;
    IO_ABS_SCISSORS_T(ppdev, prclClip->top        + yOffset);
    IO_ABS_SCISSORS_B(ppdev, prclClip->bottom - 1 + yOffset);
}

/******************************Public*Routine******************************\
* VOID DrvSynchronize
*
* This routine is called by GDI to synchronize on the accelerator before
* it draws directly to the driver's surface.  This function must be hooked
* by the driver when:
*
*   1. The primary surface is a GDI-managed surface, which simply means 
*      that GDI can directly draw on the primary surface.  This happens
*      when DrvEnableSurface returns a handle created by EngCreateBitmap
*      instead of EngCreateDeviceSurface.
*
*   2. A device-bitmap is made into a GDI-managed surface by calling
*      EngModifySurface with a pointer directly to the bits.
*
\**************************************************************************/

VOID DrvSynchronize(
IN DHPDEV dhpdev,
IN RECTL *prcl)
{
    PDEV *ppdev = (PDEV *)dhpdev;

    IO_GP_WAIT(ppdev);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\pointer.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: pointer.c
*
* This module contains the hardware pointer support for the display
* driver.  This supports both the built-in S3 hardware pointer and
* some common DAC hardware pointers.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

typedef struct BT485_POINTER_DATA {

LONG    xHot;
LONG    yHot;
ULONG   ulExtendedDacControl;
BYTE    jCommandRegister0;
BYTE    jCommandRegister1;
BYTE    jCommandRegister2;
BYTE    jCommandRegister3;

} BT485_POINTER_DATA;

typedef struct TI025_POINTER_DATA {

ULONG   ulExtendedDacControl;

} TI025_POINTER_DATA;

ULONG NewMmIoSetPointerShape(
    PDEV*       ppdev,
    SURFOBJ*    psoMsk,
    SURFOBJ*    psoColor,
    XLATEOBJ*   pxlo,
    LONG        xHot,
    LONG        yHot,
    LONG        x,
    LONG        y,
    RECTL*      prcl,
    FLONG       fl,
    BYTE*       pBuf
    );

/******************************Public*Routine******************************\
* VOID vShowPointerBt485
*
* Show or hide the Brooktree 485 hardware pointer.
*
\**************************************************************************/

VOID vShowPointerBt485(
PDEV*               ppdev,
BT485_POINTER_DATA* pbp,
BOOL                bShow)
{
    BYTE* pjIoBase = ppdev->pjIoBase;

    OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl | 0x0200);

    OUTP(pjIoBase, BT485_ADDR_CMD_REG2, (bShow) ?
                              (pbp->jCommandRegister2 | BT485_CURSOR_MODE2) :
                              pbp->jCommandRegister2);

    if (!bShow)
    {
        // Move the hardware pointer off-screen so that it doesn't flash
        // in the old position when we finally turn it back on:

        OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl | 0x0300);

        OUTP(pjIoBase, BT485_CURSOR_X_LOW,  0);
        OUTP(pjIoBase, BT485_CURSOR_X_HIGH, 0);

        // A 'y' value of 1600 should be enough...

        OUTP(pjIoBase, BT485_CURSOR_Y_LOW,  1663);
        OUTP(pjIoBase, BT485_CURSOR_Y_HIGH, (1663 >> 8));
    }

    OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl);
}

/******************************Public*Routine******************************\
* VOID vMovePointerBt485
*
* Move the Brooktree 485 hardware pointer.
*
\**************************************************************************/

VOID vMovePointerBt485(
PDEV*               ppdev,
BT485_POINTER_DATA* pbp,
LONG                x,
LONG                y)
{
    BYTE* pjIoBase = ppdev->pjIoBase;

    x -= pbp->xHot;
    y -= pbp->yHot;

    x += 64;
    y += 64;

    OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl | 0x0300);

    OUTP(pjIoBase, BT485_CURSOR_X_LOW,  (x));
    OUTP(pjIoBase, BT485_CURSOR_X_HIGH, (x >> 8));

    OUTP(pjIoBase, BT485_CURSOR_Y_LOW,  (y));
    OUTP(pjIoBase, BT485_CURSOR_Y_HIGH, (y >> 8));

    OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl);
}

/******************************Public*Routine******************************\
* BOOL bSetPointerShapeBt485
*
* Set the Brooktree 485 hardware pointer shape.
*
\**************************************************************************/

BOOL bSetPointerShapeBt485(
PDEV*               ppdev,
BT485_POINTER_DATA* pbp,
LONG                x,          // If -1, pointer should be created hidden
LONG                y,
LONG                xHot,
LONG                yHot,
LONG                cx,
LONG                cy,
BYTE*               pjShape)
{
    BYTE*   pjIoBase = ppdev->pjIoBase;
    BYTE*   pjSrc;
    LONG    i;

    // Get access to command register 3:

    OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl | 0x0100);
    OUTP(pjIoBase, BT485_ADDR_CMD_REG0, pbp->jCommandRegister0 | BT485_CMD_REG_3_ACCESS);

    OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl);
    OUTP(pjIoBase, BT485_ADDR_CMD_REG1, 0x01);

    OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl | 0x0200);
    OUTP(pjIoBase, BT485_ADDR_CMD_REG3, pbp->jCommandRegister3);

    // Disable the pointer:

    OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl | 0x0200);
    OUTP(pjIoBase, BT485_ADDR_CMD_REG2, pbp->jCommandRegister2);

    OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl);
    OUTP(pjIoBase, BT485_ADDR_CUR_RAM_WRITE, 0x0);

    OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl | 0x0200);

    // Point to first XOR word:

    pjSrc = pjShape + 2;

    // Download the XOR mask:

    for (i = 256; i > 0; i--)
    {
        OUTP(pjIoBase, BT485_CUR_RAM_ARRAY_DATA, *(pjSrc));
        OUTP(pjIoBase, BT485_CUR_RAM_ARRAY_DATA, *(pjSrc + 1));

        // Skip over AND word:

        pjSrc += 4;
    }

    // Pointer to first AND word:

    pjSrc = pjShape;

    // Download the AND mask:

    for (i = 256; i > 0; i--)
    {
        OUTP(pjIoBase, BT485_CUR_RAM_ARRAY_DATA, *(pjSrc));
        OUTP(pjIoBase, BT485_CUR_RAM_ARRAY_DATA, *(pjSrc + 1));

        // Skip over XOR word:

        pjSrc += 4;
    }

    pbp->xHot = xHot;
    pbp->yHot = yHot;

    // Set the position of the pointer:

    if (x != -1)
    {
        x -= xHot;
        y -= yHot;

        x += 64;
        y += 64;

        OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl | 0x0300);

        OUTP(pjIoBase, BT485_CURSOR_X_LOW,  (x));
        OUTP(pjIoBase, BT485_CURSOR_X_HIGH, (x >> 8));

        OUTP(pjIoBase, BT485_CURSOR_Y_LOW,  (y));
        OUTP(pjIoBase, BT485_CURSOR_Y_HIGH, (y >> 8));

        // Enable the pointer:

        OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl | 0x0200);
        OUTP(pjIoBase, BT485_ADDR_CMD_REG2, pbp->jCommandRegister2 | BT485_CURSOR_MODE2);
    }
    else
    {
        // Move the hardware pointer off-screen so that it doesn't flash
        // in the old position when we finally turn it back on:

        OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl | 0x0300);

        OUTP(pjIoBase, BT485_CURSOR_X_LOW,  0);
        OUTP(pjIoBase, BT485_CURSOR_X_HIGH, 0);

        // A 'y' value of 1600 should be enough...

        OUTP(pjIoBase, BT485_CURSOR_Y_LOW,  1663);
        OUTP(pjIoBase, BT485_CURSOR_Y_HIGH, (1663 >> 8));
    }

    // Reset the DAC extended register:

    OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl);

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vEnablePointerBt485
*
* Get the hardware ready to use the Brooktree 485 hardware pointer.
*
\**************************************************************************/

VOID vEnablePointerBt485(
PDEV*               ppdev,
BT485_POINTER_DATA* pbp,
BOOL                bFirst)
{
    BYTE* pjIoBase = ppdev->pjIoBase;

    if (bFirst)
    {
        // Make a copy of the extended DAC control register:

        OUTP(pjIoBase, CRTC_INDEX, EX_DAC_CT);

        pbp->ulExtendedDacControl = ((INP(pjIoBase, CRTC_DATA) << 8) | EX_DAC_CT) & ~0x0300;

        // Make copies of command registers 1 and 2:

        OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl | 0x0100);
        pbp->jCommandRegister0 = INP(pjIoBase, BT485_ADDR_CMD_REG0);

        OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl | 0x0200);
        pbp->jCommandRegister1 = INP(pjIoBase, BT485_ADDR_CMD_REG1);

        // Make a copy of command register 2 and mask off the pointer control bits:

        pbp->jCommandRegister2 = INP(pjIoBase, BT485_ADDR_CMD_REG2) & BT485_CURSOR_DISABLE;

        // Disable the pointer:

        OUTP(pjIoBase, BT485_ADDR_CMD_REG2, pbp->jCommandRegister2);

        // To access command register 3, we do the following:

        // 1. Set the command register access bit in command register 0.

        OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl | 0x0100);
        OUTP(pjIoBase, BT485_ADDR_CMD_REG0, pbp->jCommandRegister0 | BT485_CMD_REG_3_ACCESS);

        // 2. Set the index to 1.

        OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl);
        OUTP(pjIoBase, BT485_ADDR_CMD_REG1, 0x01);

        // 3. Now read command register 3.

        OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl | 0x0200);
        pbp->jCommandRegister3 = INP(pjIoBase, BT485_ADDR_CMD_REG3);

        // Set command register 3 for a 64 X 64 pointer:

        pbp->jCommandRegister3 |= BT485_64X64_CURSOR;
        OUTP(pjIoBase, BT485_ADDR_CMD_REG3, pbp->jCommandRegister3);

        // Disable access to command register 3:

        OUTPW(pjIoBase, CRTC_INDEX, (pbp->ulExtendedDacControl | 0x0100));
        OUTP(pjIoBase, BT485_ADDR_CMD_REG0, pbp->jCommandRegister0);

        // Set the colour 1 and colour 2 for the pointer.  Select address
        // register; pointer/overscan color write on the Bt485.

        OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl | 0x0100);
        OUTP(pjIoBase, BT485_ADDR_CUR_COLOR_WRITE, BT485_CURSOR_COLOR_1);

        // Output the RGB for pointer colour 1 (black):

        OUTP(pjIoBase, BT485_CUR_COLOR_DATA, 0x00);
        OUTP(pjIoBase, BT485_CUR_COLOR_DATA, 0x00);
        OUTP(pjIoBase, BT485_CUR_COLOR_DATA, 0x00);

        // Output the RGB for pointer colour 2 (white):

        OUTP(pjIoBase, BT485_CUR_COLOR_DATA, 0xff);
        OUTP(pjIoBase, BT485_CUR_COLOR_DATA, 0xff);
        OUTP(pjIoBase, BT485_CUR_COLOR_DATA, 0xff);

        // Reset the DAC control register:

        OUTPW(pjIoBase, CRTC_INDEX, pbp->ulExtendedDacControl);
    }
}

/******************************Public*Routine******************************\
* VOID vShowPointerTi025
*
* Show or hide the TI 025 hardware pointer.
*
\**************************************************************************/

VOID vShowPointerTi025(
PDEV*               ppdev,
TI025_POINTER_DATA* ptp,
BOOL                bShow)
{
    BYTE* pjIoBase = ppdev->pjIoBase;
    BYTE  jDacControl;

    OUTPW(pjIoBase, CRTC_INDEX, ptp->ulExtendedDacControl | 0x0100);

    OUTP(pjIoBase, 0x3c6, 6);

    jDacControl = INP(pjIoBase, 0x3c7);

    if (bShow)
        jDacControl |=  0x40;
    else
    {
        jDacControl &= ~0x40;

        // Move the hardware pointer off-screen so that it doesn't flash
        // in the old position when we finally turn it back on:

        OUTP(pjIoBase, 0x3c6, 0);
        OUTP(pjIoBase, 0x3c7, 0);

        OUTP(pjIoBase, 0x3c6, 1);
        OUTP(pjIoBase, 0x3c7, 0);

        OUTP(pjIoBase, 0x3c6, 2);
        OUTP(pjIoBase, 0x3c7, 1663);          // A 'y' value of 1600 should be enough...

        OUTP(pjIoBase, 0x3c6, 3);
        OUTP(pjIoBase, 0x3c7, (1663 >> 8));
    }

    OUTP(pjIoBase, 0x3c6, 6);
    OUTP(pjIoBase, 0x3c7, jDacControl);

    OUTPW(pjIoBase, CRTC_INDEX, ptp->ulExtendedDacControl);
}

/******************************Public*Routine******************************\
* VOID vMovePointerTi025
*
* Move the TI 025 hardware pointer.
*
\**************************************************************************/

VOID vMovePointerTi025(
PDEV*               ppdev,
TI025_POINTER_DATA* ptp,
LONG                x,
LONG                y)
{
    BYTE* pjIoBase = ppdev->pjIoBase;

    OUTPW(pjIoBase, CRTC_INDEX, ptp->ulExtendedDacControl | 0x0100);

    OUTP(pjIoBase, 0x3c6, 0);
    OUTP(pjIoBase, 0x3c7, (x));

    OUTP(pjIoBase, 0x3c6, 1);
    OUTP(pjIoBase, 0x3c7, (x >> 8));

    OUTP(pjIoBase, 0x3c6, 2);
    OUTP(pjIoBase, 0x3c7, (y));

    OUTP(pjIoBase, 0x3c6, 3);
    OUTP(pjIoBase, 0x3c7, (y >> 8));

    OUTPW(pjIoBase, CRTC_INDEX, ptp->ulExtendedDacControl);
}

/******************************Public*Routine******************************\
* BOOL bSetPointerShapeTi025
*
* Set the TI 025 hardware pointer shape.
*
* Don't do word outs to the DAC because they may not be performed correctly
* on some ISA machines.
*
\**************************************************************************/

BOOL bSetPointerShapeTi025(
PDEV*               ppdev,
TI025_POINTER_DATA* ptp,
LONG                x,          // If -1, pointer should be created hidden
LONG                y,
LONG                xHot,
LONG                yHot,
LONG                cx,
LONG                cy,
BYTE*               pjShape)
{
    BYTE*   pjIoBase = ppdev->pjIoBase;
    LONG    i;
    DWORD   dwShape;
    LONG    cShift;
    WORD    wMask;
    WORD    wAnd;
    WORD    wXor;
    BYTE    jDacControl;

    OUTPW(pjIoBase, CRTC_INDEX, ptp->ulExtendedDacControl | 0x0100);

    // Hide the pointer, otherwise it will show random garbage when
    // animating cursors on the TI 020 DAC.

    OUTP(pjIoBase, 0x3c6, 6);

    jDacControl = INP(pjIoBase, 0x3c7);

    jDacControl &= ~0x40;

    OUTP(pjIoBase, 0x3c7, jDacControl);

    // Set the pointer hot-spot offset:

    OUTP(pjIoBase, 0x3c6, 4);
    OUTP(pjIoBase, 0x3c7, xHot);
    OUTP(pjIoBase, 0x3c6, 5);
    OUTP(pjIoBase, 0x3c7, yHot);

    // Download the pointer shape.  Do the OUTs for downloading the
    // pointer data slowly -- don't use REP OUTSB.

    OUTP(pjIoBase, 0x3c6, 8);
    OUTP(pjIoBase, 0x3c7, 0);
    OUTP(pjIoBase, 0x3c6, 9);
    OUTP(pjIoBase, 0x3c7, 0);                     // Start with pixel 0 of the pointer

    OUTP(pjIoBase, 0x3c6, 10);                    // Get ready for downloading

    for (i = 256; i != 0; i--)
    {
        // Every time through this loop we'll handle one AND word and one
        // XOR word of the pointer data (which is good because the S3
        // display driver gives us the pointer shape in 'pjShape' such that
        // it starts with the first AND word, followed by the first XOR
        // word, followed by the second AND word, etc.)

        dwShape = 0;

        // The AND word is first.  Don't forget about endianness...

        wAnd = (*(pjShape) << 8) | *(pjShape + 1);
        for (wMask = 0x8000, cShift = 16; wMask != 0; wMask >>= 1, cShift--)
        {
            dwShape |= ((wAnd & wMask) << cShift);
        }

        // The XOR word is next.  Don't forget about endianness...

        wXor = (*(pjShape + 2) << 8) | *(pjShape + 3);
        for (wMask = 0x8000, cShift = 15; wMask != 0; wMask >>= 1, cShift--)
        {
            dwShape |= ((wXor & wMask) << cShift);
        }

        // We've now interleaved the AND and XOR words into a dword such
        // that if the AND word bits are ABC... and the XOR word bits are
        // 123..., the resulting dword will be A1B2C3...

        OUTP(pjIoBase, 0x3c7, (dwShape >> 24));
        OUTP(pjIoBase, 0x3c7, (dwShape >> 16));
        OUTP(pjIoBase, 0x3c7, (dwShape >> 8));
        OUTP(pjIoBase, 0x3c7, (dwShape));

        // Advance to next AND/XOR word pair:

        pjShape += 4;
    }

    if (x != -1)
    {
        // Set the position of the pointer:

        OUTP(pjIoBase, 0x3c6, 0);
        OUTP(pjIoBase, 0x3c7, (x));

        OUTP(pjIoBase, 0x3c6, 1);
        OUTP(pjIoBase, 0x3c7, (x >> 8));

        OUTP(pjIoBase, 0x3c6, 2);
        OUTP(pjIoBase, 0x3c7, (y));

        OUTP(pjIoBase, 0x3c6, 3);
        OUTP(pjIoBase, 0x3c7, (y >> 8));

        // Show the pointer:

        OUTP(pjIoBase, 0x3c6, 6);

        OUTP(pjIoBase, 0x3c7, jDacControl | 0x40);
    }
    else
    {
        // Move the hardware pointer off-screen so that it doesn't flash
        // in the old position when we finally turn it back on:

        OUTP(pjIoBase, 0x3c6, 0);
        OUTP(pjIoBase, 0x3c7, 0);

        OUTP(pjIoBase, 0x3c6, 1);
        OUTP(pjIoBase, 0x3c7, 0);

        OUTP(pjIoBase, 0x3c6, 2);
        OUTP(pjIoBase, 0x3c7, 1663);          // A 'y' value of 1600 should be enough...

        OUTP(pjIoBase, 0x3c6, 3);
        OUTP(pjIoBase, 0x3c7, (1663 >> 8));
    }

    OUTPW(pjIoBase, CRTC_INDEX, ptp->ulExtendedDacControl);

    // Reset DAC read mask to 0xff:

    OUTP(pjIoBase, 0x3c6, 0xff);

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vEnablePointerTi025
*
* Get the hardware ready to use the TI 025 hardware pointer.
*
* Don't do word outs to the DAC because they may not be performed correctly
* on some ISA machines.
*
\**************************************************************************/

VOID vEnablePointerTi025(
PDEV*               ppdev,
TI025_POINTER_DATA* ptp,
BOOL                bFirst)
{
    BYTE* pjIoBase = ppdev->pjIoBase;
    BYTE  jMode;
    BYTE  jDacControl;

    // Make a copy of the extended DAC control register:

    OUTP(pjIoBase, CRTC_INDEX, EX_DAC_CT);

    ptp->ulExtendedDacControl = ((INP(pjIoBase, CRTC_DATA) << 8) | EX_DAC_CT) & ~0x0300;

    // Disable the DAC's Bt485 emulation so that we can use the TI hardware
    // pointer.

    OUTP(pjIoBase, CRTC_INDEX, 0x5C);

    jMode = INP(pjIoBase, CRTC_DATA);

    OUTP(pjIoBase, CRTC_DATA, jMode & ~0x20);         // Select TI mode in the DAC

    OUTPW(pjIoBase, CRTC_INDEX, ptp->ulExtendedDacControl | 0x0100);

    OUTP(pjIoBase, 0x3c6, 6);

    jDacControl = INP(pjIoBase, 0x3c7);

    OUTP(pjIoBase, 0x3c7, jDacControl & 0x7f);        // Set to TI mode (non planar)

    // Set the pointer colours to black and white.

    OUTP(pjIoBase, 0x3c6, 0x26);
    OUTP(pjIoBase, 0x3c7, 0xff);                      // Foreground red component
    OUTP(pjIoBase, 0x3c6, 0x27);
    OUTP(pjIoBase, 0x3c7, 0xff);                      // Foreground green component
    OUTP(pjIoBase, 0x3c6, 0x28);
    OUTP(pjIoBase, 0x3c7, 0xff);                      // Foreground blue component

    OUTP(pjIoBase, 0x3c6, 0x23);
    OUTP(pjIoBase, 0x3c7, 0x00);                      // Background red component
    OUTP(pjIoBase, 0x3c6, 0x24);
    OUTP(pjIoBase, 0x3c7, 0x00);                      // Background green component
    OUTP(pjIoBase, 0x3c6, 0x25);
    OUTP(pjIoBase, 0x3c7, 0x00);                      // Background blue component

    OUTPW(pjIoBase, CRTC_INDEX, ptp->ulExtendedDacControl);

    OUTP(pjIoBase, 0x3c6, 0xff);                      // Reset DAC read mask to 0xff

    // Note that we don't have to bother hiding the pointer, because
    // vShowPointer will be called immediately...
}

/******************************Public*Routine******************************\
* VOID vShowPointerS3
*
* Show or hide the S3 hardware pointer.
*
* We hide the pointer by making it only one row high (we always reserve
* the bottom scan of the pointer shape to be invisible).  We do it this
* way because we ran into problems doing it with any other method:
*
*   1. Disabling the hardware pointer via register CR45 will hang
*      80x/928/864 chips if it is done at exactly the wrong time during
*      the horizontal retrace.  It's is not safe to wait for vertical
*      blank and do it then, because we're a user mode process and
*      could get context switched after doing the wait but before setting
*      the bit.
*
*   2. Simply changing the pointer position to move it off-screen works,
*      but is not a good solution because the pointer position is latched
*      by the hardware, and it usually takes a couple of frames for the
*      new position to take effect (which causes the pointer to jump even
*      more than it currently does).
*
*   3. Using registers CR4C and CR4D to switch to a pre-defined 'invisible'
*      pointer also worked, but still caused machines to crash with the
*      same symptoms as from solution 1 (although it was somewhat more
*      rare).
*
\**************************************************************************/

VOID vShowPointerS3(
PDEV*   ppdev,
BOOL    bShow)      // If TRUE, show the pointer.  If FALSE, hide the pointer.
{
    BYTE*   pjIoBase = ppdev->pjIoBase;
    LONG    x;
    LONG    y;
    LONG    dx;
    LONG    dy;

    // If we don't wait for vertical retrace here, the S3 sometimes ignores
    // the setting of the new pointer position:

    while (INP(pjIoBase, STATUS_1) & VBLANK_ACTIVE)
        ;                               // Wait for bit 3 to become 0
    while (!(INP(pjIoBase, STATUS_1) & VBLANK_ACTIVE))
        ;                               // Wait for bit 3 to become 1

    if (bShow)
    {
        // Make the hardware pointer visible:

        x  = ppdev->xPointer;
        y  = ppdev->yPointer;
        dx = ppdev->dxPointer;
        dy = ppdev->dyPointer;
    }
    else
    {
        // Move the hardware pointer off-screen so that it doesn't flash
        // in the old position when we finally turn it back on:

        x  = ppdev->cxScreen + 64;
        y  = ppdev->cyScreen + 64;
        dx = 0;
        dy = HW_POINTER_HIDE;
    }

    // Note that due to register shadowing, these OUTs should be done
    // in a specific order, otherwise you may get a flashing pointer:

    OUTPW(pjIoBase, CRTC_INDEX, HGC_ORGX_MSB | ((x >> 8)   << 8));
    OUTPW(pjIoBase, CRTC_INDEX, HGC_ORGX_LSB | ((x & 0xff) << 8));
    OUTPW(pjIoBase, CRTC_INDEX, HGC_ORGY_LSB | ((y & 0xff) << 8));
    OUTPW(pjIoBase, CRTC_INDEX, HGC_DX       | ((dx)       << 8));
    OUTPW(pjIoBase, CRTC_INDEX, HGC_DY       | ((dy)       << 8));
    OUTPW(pjIoBase, CRTC_INDEX, HGC_ORGY_MSB | ((y >> 8)   << 8));
}

/******************************Public*Routine******************************\
* VOID vMovePointerS3
*
* Move the S3 hardware pointer.
*
\**************************************************************************/

VOID vMovePointerS3(
PDEV*   ppdev,
LONG    x,
LONG    y)
{
    BYTE*   pjIoBase = ppdev->pjIoBase;
    LONG    dx;
    LONG    dy;

    // 'dx' and 'dy' are the offsets into the pointer bitmap at which
    // the hardware is supposed to start drawing, when the pointer is
    // along the left or top edge and needs to be clipped:

    x -= ppdev->xPointerHot;
    y -= ppdev->yPointerHot;

    dx = 0;
    dy = 0;

    if (x <= 0)
    {
        dx = -x;
        x  = 0;
    }

    if (y <= 0)
    {
        dy = -y;
        y  = 0;
    }

    // Account for pointer position scaling in high-colour modes:

    x <<= ppdev->cPointerShift;

    ppdev->dxPointer = dx;
    ppdev->dyPointer = dy;
    ppdev->xPointer  = x;
    ppdev->yPointer  = y;

    // Note that due to register shadowing, these OUTs should be done
    // in a specific order, otherwise you may get a flashing pointer:

    OUTPW(pjIoBase, CRTC_INDEX, HGC_ORGX_MSB | ((x >> 8)   << 8));
    OUTPW(pjIoBase, CRTC_INDEX, HGC_ORGX_LSB | ((x & 0xff) << 8));
    OUTPW(pjIoBase, CRTC_INDEX, HGC_ORGY_LSB | ((y & 0xff) << 8));
    OUTPW(pjIoBase, CRTC_INDEX, HGC_DX       | ((dx)       << 8));
    OUTPW(pjIoBase, CRTC_INDEX, HGC_DY       | ((dy)       << 8));
    OUTPW(pjIoBase, CRTC_INDEX, HGC_ORGY_MSB | ((y >> 8)   << 8));
}

/******************************Public*Routine******************************\
* VOID vSetPointerShapeS3
*
\**************************************************************************/

VOID vSetPointerShapeS3(
SURFOBJ*    pso,
LONG        x,              // Relative coordinates
LONG        y,              // Relative coordinates
LONG        xHot,
LONG        yHot,
BYTE*       pjShape,
FLONG       fl)
{
    BYTE*   pjIoBase;
    PDEV*   ppdev;
    ULONG*  pulSrc;
    ULONG*  pulDst;
    LONG    i;

    ppdev    = (PDEV*) pso->dhpdev;
    pjIoBase = ppdev->pjIoBase;

    // 1. Hide the current pointer.

    if (!(fl & SPS_ANIMATEUPDATE))
    {
        // Hide the pointer to try and lessen the jumpiness when the
        // new shape has a different hot spot.  We don't hide the
        // pointer while animating, because that definitely causes
        // flashing:

        ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);
        OUTPW(pjIoBase, CRTC_INDEX, HGC_DY | (HW_POINTER_HIDE << 8));
        RELEASE_CRTC_CRITICAL_SECTION(ppdev);
    }

    // 2. Wait until the vertical retrace is done.
    // --
    //
    // If we don't wait for vertical retrace here, the S3 sometimes ignores
    // the setting of the new pointer position:

    while (INP(pjIoBase, STATUS_1) & VBLANK_ACTIVE)
        ;                               // Wait for bit 3 to become 0
    while (!(INP(pjIoBase, STATUS_1) & VBLANK_ACTIVE))
        ;                               // Wait for bit 3 to become 1

    // 3. Set the new pointer position.
    // --

    ppdev->xPointerHot = xHot;
    ppdev->yPointerHot = yHot;

    DrvMovePointer(pso, x, y, NULL);    // Note: Must pass relative coordinates!

    // 4. Download the new pointer shape.

    ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

    ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_ON);
    ppdev->pfnBankMap(ppdev, ppdev->pvBankData, ppdev->iPointerBank);

    pulSrc = (ULONG*) pjShape;
    pulDst = (ULONG*) ppdev->pvPointerShape;

    if (DIRECT_ACCESS(ppdev))
    {
        for (i = HW_POINTER_TOTAL_SIZE / sizeof(ULONG); i != 0; i--)
        {
            *pulDst++ = *pulSrc++;
        }
    }
    else
    {
        for (i = HW_POINTER_TOTAL_SIZE / sizeof(ULONG); i != 0; i--)
        {
            WRITE_REGISTER_ULONG(pulDst, *pulSrc);
            pulSrc++;
            pulDst++;
        }
    }

    ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_OFF);

    RELEASE_CRTC_CRITICAL_SECTION(ppdev);
}

/******************************Public*Routine******************************\
* VOID DrvMovePointer
*
* NOTE: Because we have set GCAPS_ASYNCMOVE, this call may occur at any
*       time, even while we're executing another drawing call!
*
*       Consequently, we have to explicitly synchronize any shared
*       resources.  In our case, since we touch the CRTC register here
*       and in the banking code, we synchronize access using a critical
*       section.
*
\**************************************************************************/

VOID DrvMovePointer(
SURFOBJ*    pso,
LONG        x,
LONG        y,
RECTL*      prcl)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) pso->dhpdev;

    ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

    if (x != -1)
    {
        if (ppdev->flCaps & CAPS_DAC_POINTER)
        {
            ppdev->pfnMovePointer(ppdev, ppdev->pvPointerData, x, y);
        }
        else
        {
            vMovePointerS3(ppdev, x, y);
        }

        if (!ppdev->bHwPointerActive)
        {
            // We have to make the pointer visible:

            ppdev->bHwPointerActive = TRUE;

            if (ppdev->flCaps & CAPS_DAC_POINTER)
            {
                ppdev->pfnShowPointer(ppdev, ppdev->pvPointerData, TRUE);
            }
            else
            {
                vShowPointerS3(ppdev, TRUE);
            }
        }
    }
    else
    {
        if (ppdev->bHwPointerActive)
        {
            // The pointer is visible, and we've been asked to hide it:

            ppdev->bHwPointerActive = FALSE;

            if (ppdev->flCaps & CAPS_DAC_POINTER)
            {
                ppdev->pfnShowPointer(ppdev, ppdev->pvPointerData, FALSE);
            }
            else
            {
                vShowPointerS3(ppdev, FALSE);
            }
        }
    }

    RELEASE_CRTC_CRITICAL_SECTION(ppdev);

    // Note that we don't have to modify 'prcl', since we have a
    // NOEXCLUDE pointer...
}

/******************************Public*Routine******************************\
* VOID DrvSetPointerShape
*
* Sets the new pointer shape.
*
\**************************************************************************/

ULONG DrvSetPointerShape(
SURFOBJ*    pso,
SURFOBJ*    psoMsk,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL*      prcl,
FLONG       fl)
{
    PDEV*   ppdev;
    DWORD*  pul;
    ULONG   cx;
    ULONG   cy;
    LONG    i;
    LONG    j;
    BYTE*   pjSrcScan;
    BYTE*   pjDstScan;
    LONG    lSrcDelta;
    LONG    lDstDelta;
    WORD*   pwSrc;
    WORD*   pwDst;
    LONG    cwWhole;
    BOOL    bAccept;
    BYTE    ajBuf[HW_POINTER_TOTAL_SIZE];

    ppdev = (PDEV*) pso->dhpdev;

    // When CAPS_SW_POINTER is set, we have no hardware pointer available,
    // so we always ask GDI to simulate the pointer for us, using
    // DrvCopyBits calls:

    if (ppdev->flCaps & CAPS_SW_POINTER)
        return(SPS_DECLINE);

    // We're not going to handle any colour pointers, pointers that
    // are larger than our hardware allows, or flags that we don't
    // understand.
    //
    // (Note that the spec says we should decline any flags we don't
    // understand, but we'll actually be declining if we don't see
    // the only flag we *do* understand...)
    //
    // Our old documentation says that 'psoMsk' may be NULL, which means
    // that the pointer is transparent.  Well, trust me, that's wrong.
    // I've checked GDI's code, and it will never pass us a NULL psoMsk:

    cx = psoMsk->sizlBitmap.cx;         // Note that 'sizlBitmap.cy' accounts
    cy = psoMsk->sizlBitmap.cy >> 1;    //   for the double height due to the
                                        //   inclusion of both the AND masks
                                        //   and the XOR masks.  For now, we're
                                        //   only interested in the true
                                        //   pointer dimensions, so we divide
                                        //   by 2.

    // We reserve the bottom scan of the pointer shape and keep it
    // empty so that we can hide the pointer by changing the S3's
    // display start y-pixel position register to show only the bottom
    // scan of the pointer shape:

    if ((cx > HW_POINTER_DIMENSION)       ||
        (cy > (HW_POINTER_DIMENSION - 1)) ||
        (psoColor != NULL)                ||
        !(fl & SPS_CHANGE)                ||
        (cx & 0x7))     // make sure cx is a multiple of 8 (byte aligned).
    {
        goto HideAndDecline;
    }

    ASSERTDD(psoMsk != NULL, "GDI gave us a NULL psoMsk.  It can't do that!");
    //ASSERTDD(pso->iType == STYPE_DEVICE, "GDI gave us a weird surface");

    if ((cx <= (HW_POINTER_DIMENSION / 2)) &&
        !(ppdev->flCaps & CAPS_DAC_POINTER) &&
        (ppdev->flCaps & CAPS_NEW_MMIO))
    {
        return( NewMmIoSetPointerShape(
            ppdev,
            psoMsk,
            psoColor,
            pxlo,
            xHot,
            yHot,
            x,
            y,
            prcl,
            fl,
            ajBuf
            ));
    }

    pul = (ULONG*) &ajBuf[0];
    for (i = HW_POINTER_TOTAL_SIZE / sizeof(ULONG); i != 0; i--)
    {
        // Here we initialize the entire pointer work buffer to be
        // transparent (the S3 has no means of specifying a pointer size
        // other than 64 x 64 -- so if we're asked to draw a 32 x 32
        // pointer, we want the unused portion to be transparent).
        //
        // The S3's hardware pointer is defined by an interleaved pattern
        // of AND words and XOR words.  So a totally transparent pointer
        // starts off with the word 0xffff, followed by the word 0x0000,
        // followed by 0xffff, etc..  Since we're a little endian system,
        // this is simply the repeating dword '0x0000ffff'.
        //
        // The compiler is nice enough to optimize this into a REP STOSD
        // for us:

        *pul++ = 0x0000ffff;
    }

    // Now we're going to take the requested pointer AND masks and XOR
    // masks and combine them into our work buffer, being careful of
    // the edges so that we don't disturb the transparency when the
    // requested pointer size is not a multiple of 16.
    //
    // 'psoMsk' is actually cy * 2 scans high; the first 'cy' scans
    // define the AND mask.  So we start with that:

    pjSrcScan    = psoMsk->pvScan0;
    lSrcDelta    = psoMsk->lDelta;
    pjDstScan    = &ajBuf[0];               // Start with first AND word
    lDstDelta    = HW_POINTER_DIMENSION / 4;// Every 8 pels is one AND/XOR word

    cwWhole      = cx / 16;                 // Each word accounts for 16 pels

    for (i = cy; i != 0; i--)
    {
        pwSrc = (WORD*) pjSrcScan;
        pwDst = (WORD*) pjDstScan;

        for (j = cwWhole; j != 0; j--)
        {
            *pwDst = *pwSrc;
            pwSrc += 1;             // Go to next word in source mask
            pwDst += 2;             // Skip over the XOR word in the dest mask
        }

        pjSrcScan += lSrcDelta;
        pjDstScan += lDstDelta;
    }

    // Now handle the XOR mask:

    pjDstScan = &ajBuf[2];          // Start with first XOR word
    for (i = cy; i != 0; i--)
    {
        pwSrc = (WORD*) pjSrcScan;
        pwDst = (WORD*) pjDstScan;

        for (j = cwWhole; j != 0; j--)
        {
            *pwDst = *pwSrc;
            pwSrc += 1;             // Go to next word in source mask
            pwDst += 2;             // Skip over the AND word in the dest mask
        }

        pjSrcScan += lSrcDelta;
        pjDstScan += lDstDelta;
    }

    // Okay, I admit it -- I'm wildly inconsistent here.  I pass
    // absolute (x, y) coordinates to pfnSetPointerShape, but pass
    // relative (x, y) coordinates to vSetPointerShapeS3.  I would
    // clean this all up, but we're too close to shipping.  LATER!

    if (ppdev->flCaps & CAPS_DAC_POINTER)
    {
        ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

        bAccept = ppdev->pfnSetPointerShape(ppdev, ppdev->pvPointerData, x, y,
                                            xHot, yHot, cx, cy, &ajBuf[0]);

        RELEASE_CRTC_CRITICAL_SECTION(ppdev);

        ppdev->bHwPointerActive = (x != -1);

        if (!bAccept)
            goto HideAndDecline;
    }
    else
    {
        vSetPointerShapeS3(pso, x, y, xHot, yHot, &ajBuf[0], fl);
    }

    // Since it's a hardware pointer, GDI doesn't have to worry about
    // overwriting the pointer on drawing operations (meaning that it
    // doesn't have to exclude the pointer), so we return 'NOEXCLUDE'.
    // Since we're returning 'NOEXCLUDE', we also don't have to update
    // the 'prcl' that GDI passed us.

    return(SPS_ACCEPT_NOEXCLUDE);

HideAndDecline:

    // Since we're declining the new pointer, GDI will simulate it via
    // DrvCopyBits calls.  So we should really hide the old hardware
    // pointer if it's visible.  We can get DrvMovePointer to do this
    // for us:

    DrvMovePointer(pso, -1, -1, NULL);

    return(SPS_DECLINE);
}

/******************************Public*Routine******************************\
* VOID vDisablePointer
*
\**************************************************************************/

VOID vDisablePointer(
PDEV*   ppdev)
{
    // Nothing to do, really
}

/******************************Public*Routine******************************\
* VOID vAssertModePointer
*
\**************************************************************************/

VOID vAssertModePointer(
PDEV*   ppdev,
BOOL    bEnable)
{
    ULONG*  pulDst;
    LONG    i;
    LONG    lPointerShape;

    // We will turn any hardware pointer -- either in the S3 or in the
    // DAC -- off to begin with:

    ppdev->bHwPointerActive = FALSE;

    if (ppdev->flCaps & CAPS_SW_POINTER)
    {
        // With a software pointer, we don't have to do anything.
    }
    else if (ppdev->flCaps & CAPS_DAC_POINTER)
    {
        // Hide the DAC pointer:

        ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

        // hide the pointer by moving offscreen

        ppdev->pfnShowPointer(ppdev, ppdev->pvPointerData, FALSE);

        // but enable the pointer registers

        ppdev->pfnEnablePointer(ppdev, ppdev->pvPointerData, TRUE);

        RELEASE_CRTC_CRITICAL_SECTION(ppdev);
    }
    else
    {
        // We're using the built-in hardware pointer:

        if (bEnable)
        {
            ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

            ppdev->cPointerShift = 0;

            if (ppdev->iBitmapFormat > BMF_8BPP)
            {
                // Initializing the pointer colours is a bit different
                // for high-colour modes:

                if (ppdev->flCaps & CAPS_SCALE_POINTER)
                {
                    ppdev->cPointerShift = 1;
                    ppdev->ulHwGraphicsCursorModeRegister_45 |= (0x4 << 8);
                }
            }

            // We download an invisible pointer shape because we're about
            // to enable the hardware pointer, but we still want the
            // pointer hidden until we get the first DrvSetPointerShape
            // call:

            ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_ON);

            ppdev->pfnBankMap(ppdev, ppdev->pvBankData, ppdev->iPointerBank);

            pulDst = (ULONG*) ppdev->pvPointerShape;

            if (DIRECT_ACCESS(ppdev))
            {
                for (i = HW_POINTER_TOTAL_SIZE / sizeof(ULONG); i != 0; i--)
                {
                    *pulDst++ = 0x0000ffff;
                }
            }
            else
            {
                for (i = HW_POINTER_TOTAL_SIZE / sizeof(ULONG); i != 0; i--)
                {
                    WRITE_REGISTER_ULONG(pulDst, 0x0000ffff);
                    pulDst++;
                }
            }

            ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_OFF);

            // Point the S3 to where we're storing the pointer shape.
            // The location is specified as a multiple of 1024:

            lPointerShape = ppdev->cjPointerOffset / 1024;

            OUTPW(ppdev->pjIoBase, CRTC_INDEX, CR4C | ((lPointerShape >> 8)   << 8));
            OUTPW(ppdev->pjIoBase, CRTC_INDEX, CR4D | ((lPointerShape & 0xff) << 8));

            // Now hide it by moving it off-screen:

            vShowPointerS3(ppdev, FALSE);

            // Enable the hardware pointer.  As per the 8/31/93 Design
            // Alert from S3 Incorporated, there's a goofy bug in all
            // S3 chips up to the 928 where writing to this register
            // at the same time as a horizontal sync may cause the
            // chip to crash.  So we wait for the vertical sync to be safe.
            //
            // Note that since we're a preemptive multitasking
            // operating system, the following code is not guaranteed
            // to be safe.  To do that, we would have to put this in
            // the miniport, where we could disable all interrupts while
            // we wait for the vertical sync.
            //
            // However, this is only ever executed once at initialization
            // and every time full-screen is executed, so I would expect
            // the chances of there still being a problem to be extremely
            // small:

            while (INP(ppdev->pjIoBase, STATUS_1) & VBLANK_ACTIVE)
                ;                               // Wait for bit 3 to become 0
            while (!(INP(ppdev->pjIoBase, STATUS_1) & VBLANK_ACTIVE))
                ;                               // Wait for bit 3 to become 1

            OUTPW(ppdev->pjIoBase, CRTC_INDEX,
                ppdev->ulHwGraphicsCursorModeRegister_45 | (HGC_ENABLE << 8));

            RELEASE_CRTC_CRITICAL_SECTION(ppdev);
        }
    }
}

/******************************Public*Routine******************************\
* BOOL bEnablePointer
*
\**************************************************************************/

BOOL bEnablePointer(
PDEV*   ppdev)
{
    RECTL       rclDraw;
    RECTL       rclBank;
    LONG        iBank;
    LONG        cjOffset;
    LONG        cjOffsetInBank;

    if (ppdev->flCaps & CAPS_SW_POINTER)
    {
        // With a software pointer, we don't have to do anything.
    }
    else if (ppdev->flCaps & CAPS_DAC_POINTER)
    {
        // Initialize the DAC pointer:

        if (ppdev->flCaps & CAPS_BT485_POINTER)
        {
            ppdev->pfnShowPointer     = vShowPointerBt485;
            ppdev->pfnMovePointer     = vMovePointerBt485;
            ppdev->pfnSetPointerShape = bSetPointerShapeBt485;
            ppdev->pfnEnablePointer   = vEnablePointerBt485;
        }
        else
        {
            ASSERTDD(ppdev->flCaps & CAPS_TI025_POINTER,
                     "A new DAC type was added?");

            ppdev->pfnShowPointer     = vShowPointerTi025;
            ppdev->pfnMovePointer     = vMovePointerTi025;
            ppdev->pfnSetPointerShape = bSetPointerShapeTi025;
            ppdev->pfnEnablePointer   = vEnablePointerTi025;
        }

        ppdev->pvPointerData = &ppdev->ajPointerData[0];

        ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

        ppdev->pfnEnablePointer(ppdev, ppdev->pvPointerData, TRUE);

        RELEASE_CRTC_CRITICAL_SECTION(ppdev);
    }
    else
    {
        // Enable the S3 hardware pointer.

        // We're going to assume that the pointer shape doesn't span
        // more than one bank.  We have to figure out what bank that
        // will be, and so we call 'pfnBankCompute' with the start
        // point:

        rclDraw.left = rclDraw.right  = ppdev->xPointerShape;
        rclDraw.top  = rclDraw.bottom = ppdev->yPointerShape;

        ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset, &iBank);

        cjOffsetInBank = ppdev->cjPointerOffset - cjOffset;

        ASSERTDD(cjOffsetInBank + HW_POINTER_TOTAL_SIZE <= ppdev->cjBank,
                 "SetPointerShape assumes pointer shape doesn't span banks");

        // When bank 'iPointerBank' is mapped in, 'pvPointerShape' is the
        // actual pointer to be the beginning of the pointer shape bits
        // in off-screen memory:

        ppdev->pvPointerShape = ppdev->pjScreen + cjOffsetInBank;
        ppdev->iPointerBank   = iBank;

        // Get a copy of the current register '45' state, so that whenever
        // we enable or disable the S3 hardware pointer, we don't have to
        // do a read-modify-write on this register:

        ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

        OUTP(ppdev->pjIoBase, CRTC_INDEX, HGC_MODE);
        ppdev->ulHwGraphicsCursorModeRegister_45
            = ((INP(ppdev->pjIoBase, CRTC_DATA) << 8) | HGC_MODE) & ~(HGC_ENABLE << 8);

        RELEASE_CRTC_CRITICAL_SECTION(ppdev);
    }

    // Actually turn on the pointer:

    vAssertModePointer(ppdev, TRUE);

    DISPDBG((5, "Passed bEnablePointer"));

    return(TRUE);
}

/******************************Public*Routine******************************\
*
* Sets the new pointer shape.
*
\**************************************************************************/


ULONG NewMmIoSetPointerShape(
PDEV*       ppdev,
SURFOBJ*    psoMsk,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL*      prcl,
FLONG       fl,
BYTE*       pBuf)
{
    ULONG   cx;
    ULONG   cy;
    LONG    i;
    LONG    j;
    BYTE*   pjSrcScan;
    BYTE*   pjDstScan;
    LONG    lSrcDelta;
    LONG    lDstDelta;
    WORD*   pwSrc;
    WORD*   pwDst;
    BYTE*   pbSrc;
    BYTE*   pbDst;

    ULONG*  pulDst;
    ULONG*  pulSrc;

    LONG    cxWhole;
    LONG    xHotWordBnd;

    ULONG   ulTransp = 0xFFFF0000L;
    ULONG   ulData, ulPreviousData;

    UCHAR ucTemp;
            


    // We're not going to handle any colour pointers, pointers that
    // are larger than our hardware allows, or flags that we don't
    // understand.
    //
    // (Note that the spec says we should decline any flags we don't
    // understand, but we'll actually be declining if we don't see
    // the only flag we *do* understand...)
    //
    // Our old documentation says that 'psoMsk' may be NULL, which means
    // that the pointer is transparent.  Well, trust me, that's wrong.
    // I've checked GDI's code, and it will never pass us a NULL psoMsk:

    cx = psoMsk->sizlBitmap.cx;         // Note that 'sizlBitmap.cy' accounts
    cy = psoMsk->sizlBitmap.cy >> 1;    //   for the double height due to the
                                        //   inclusion of both the AND masks
                                        //   and the XOR masks.  For now, we're
                                        //   only interested in the true
                                        //   pointer dimensions, so we divide
                                        //   by 2.


    //
    // 'psoMsk' is actually cy * 2 scans high; the first 'cy' scans
    // define the AND mask.  So we start with that:

    pjSrcScan    = psoMsk->pvScan0;
    lSrcDelta    = psoMsk->lDelta;
    lDstDelta    = HW_POINTER_DIMENSION / 4; // Every 8 pels is one AND/XOR word

    cxWhole      = cx / 16;                 // Each word accounts for 16 pels

    // caculating pointer checksum whether update the pointer or not
    pulSrc = (ULONG*) pjSrcScan;
    ulData = 0L;

    ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

    if (!(fl & SPS_ANIMATEUPDATE))
    {
        OUTPW(ppdev->pjIoBase, CRTC_INDEX, HGC_DY | (HW_POINTER_HIDE << 8));
    }

    if(x >= 0)
    {
        vMovePointerS3(ppdev, x, y);
    }

    RELEASE_CRTC_CRITICAL_SECTION(ppdev);


    // Now we're going to take the requested pointer AND masks and XOR
    // masks and combine them into our work buffer, being careful of
    // the edges so that we don't disturb the transparency when the
    // requested pointer size is not a multiple of 16.


    pulDst = (ULONG*) pBuf;

    for (i = 0; i < HW_POINTER_TOTAL_SIZE / sizeof(ULONG); i++)
    {
        // Here we initialize the entire pointer work buffer to be
        // transparent (the S3 has no means of specifying a pointer size
        // other than 64 x 64 -- so if we're asked to draw a 32 x 32
        // pointer, we want the unused portion to be transparent).
        //
        // The S3's hardware pointer is defined by an interleaved pattern
        // of AND words and XOR words.  So a totally transparent pointer
        // starts off with the word 0xffff, followed by the word 0x0000,
        // followed by 0xffff, etc..  Since we're a little endian system,
        // this is simply the repeating dword '0x0000ffff'.
        //
        // The compiler is nice enough to optimize this into a REP STOSD
        // for us:

        *pulDst++ = 0x0000ffff;
    }

    // ekl - take care word bnd. 
    // Start with first AND word
    pjDstScan = (BYTE *) pBuf;

    pjDstScan +=  ((HW_POINTER_DIMENSION / 2 - yHot) * lDstDelta + 
        (HW_POINTER_DIMENSION / 2 - ((xHot+15) & 0xFFFFFFF0L)) / 4); 

    cxWhole      = cx / 16;                 // Each word accounts for 16 pels


    xHotWordBnd = xHot % 16;

    if(xHotWordBnd)
    {
        ulTransp >>= (16 - xHotWordBnd);
        cxWhole *= 2;
            
        for (i = cy; i != 0; i--)
        {
            pbSrc = pjSrcScan;
            pbDst = pjDstScan;

            ulPreviousData = ulTransp << 16;

            for (j = 0;  j < cxWhole; j++, pbSrc++)
            {
                ulData = (ULONG) (*pbSrc);
                ulData <<= (8 + xHotWordBnd);
                ulData |= ulPreviousData;

                ucTemp = (UCHAR)(ulData >> 24);
                *pbDst = ucTemp;

                pbDst += (j % 2 ? 3 : 1);

                // next byte
                ulData <<= 8; 
                ulPreviousData = ulData;

            }

            // last word
            ulData |= ulTransp;     
            ucTemp = (UCHAR)(ulData >> 24);
            *pbDst = ucTemp;

            pbDst += (2*j + 1);
            ucTemp = (UCHAR)(ulData >> 16);
            *pbDst = ucTemp;

            pjSrcScan += lSrcDelta;
            pjDstScan += lDstDelta;
        }

    }
    else
    {
        for (i = cy; i != 0; i--)
        {
            pwSrc = (WORD*) pjSrcScan;
            pwDst = (WORD*) pjDstScan;

            for (j = cxWhole; j != 0; j--)
            {
                *pwDst = *pwSrc;
                pwSrc += 1;             // Go to next word in source mask
                pwDst += 2;             // Skip over the XOR word in the dest mask
            }

            pjSrcScan += lSrcDelta;
            pjDstScan += lDstDelta;
        }
    }


    // Now handle the XOR mask:

    pjDstScan = (BYTE *) pBuf;
    pjDstScan +=  (2 + (HW_POINTER_DIMENSION / 2 - yHot) * lDstDelta + 
        (HW_POINTER_DIMENSION / 2 - ((xHot+15) & 0xFFFFFFF0L)) / 4); 

    if(xHotWordBnd)
    {
        for (i = cy; i != 0; i--)
        {
            pbSrc = pjSrcScan;
            pbDst = pjDstScan;

            ulPreviousData = 0;

            for (j = 0;  j < cxWhole; j++, pbSrc++)
            {
                ulData = (ULONG) (*pbSrc);
                ulData <<= (8 + xHotWordBnd);
                ulData |= ulPreviousData;

                ucTemp = (UCHAR)(ulData >> 24);
                *pbDst = ucTemp;

                pbDst += (j % 2 ? 3 : 1);

                // Next byte
                ulData <<= 8; 
                ulPreviousData = ulData;

            }

            ucTemp = (UCHAR)(ulData >> 24);
            *pbDst = ucTemp;

            pbDst += (2*j + 1);
            ucTemp = (UCHAR)(ulData >> 16);
            *pbDst = ucTemp;

            pjSrcScan += lSrcDelta;
            pjDstScan += lDstDelta;
        }
    }
    else
    {

        for (i = cy; i != 0; i--)
        {
            pwSrc = (WORD*) pjSrcScan;
            pwDst = (WORD*) pjDstScan;

            for (j = cxWhole; j != 0; j--)
            {
                *pwDst = *pwSrc;
                pwSrc += 1;             // Go to next word in source mask
                pwDst += 2;             // Skip over the AND word in the dest mask
            }

            pjSrcScan += lSrcDelta;
            pjDstScan += lDstDelta;
        }
    }


    ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

    pulSrc = (ULONG*) pBuf;
    pulDst = (ULONG*) ppdev->pvPointerShape;

    if (DIRECT_ACCESS(ppdev))
    {
        for (i = HW_POINTER_TOTAL_SIZE / sizeof(ULONG); i != 0; i--)
        {
            *pulDst++ = *pulSrc++;
        }
    }
    else
    {
        for (i = HW_POINTER_TOTAL_SIZE / sizeof(ULONG); i != 0; i--)
        {
            WRITE_REGISTER_ULONG(pulDst, *pulSrc);
            pulSrc++;
            pulDst++;
        }
    }

    if(x >= 0)
    {
        if (!ppdev->bHwPointerActive) {
            ppdev->bHwPointerActive = TRUE;
            vShowPointerS3(ppdev, TRUE);
        }
    }
    else
    {
        if (ppdev->bHwPointerActive) {
            ppdev->bHwPointerActive = FALSE;
            vShowPointerS3(ppdev, FALSE);
        }
    }

    RELEASE_CRTC_CRITICAL_SECTION(ppdev);

    // fix the hot spot at the center of the HW cursor
    ppdev->xPointerHot = HW_POINTER_DIMENSION / 2;        
    ppdev->yPointerHot = HW_POINTER_DIMENSION / 2;


    return(SPS_ACCEPT_NOEXCLUDE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\palette.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: palette.c
*
* Palette support.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// Global Table defining the 20 Window default colours.  For 256 colour
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

PALETTEENTRY gapalBase[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

/******************************Public*Routine******************************\
* BOOL bInitializePalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitializePalette(
PDEV*    ppdev,
DEVINFO* pdi)
{
    PALETTEENTRY*   ppal;
    PALETTEENTRY*   ppalTmp;
    ULONG           ulLoop;
    HPALETTE        hpal;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // Allocate our palette:

        ppal = EngAllocMem(FL_ZERO_MEMORY, sizeof(PALETTEENTRY) * 256, ALLOC_TAG);
        if (ppal == NULL)
            goto ReturnFalse;

        ppdev->pPal = ppal;

        // Fill in Windows reserved colours from the WIN 3.0 DDK
        // The Window Manager reserved the first and last 10 colours for
        // painting windows borders and for non-palette managed applications.

        for (ulLoop = 0; ulLoop < 10; ulLoop++)
        {
            // First 10

            ppal[ulLoop]       = gapalBase[ulLoop];

            // Last 10

            ppal[246 + ulLoop] = gapalBase[ulLoop+10];
        }

        // Create handle for palette.

        hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*) ppal, 0, 0, 0);
    }
    else
    {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
         (ppdev->iBitmapFormat == BMF_24BPP) ||
         (ppdev->iBitmapFormat == BMF_32BPP),
         "This case handles only 16, 24 or 32bpp");

        hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                                ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
    }

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    if (hpal == 0)
        goto ReturnFalse;

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializePalette"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vUninitializePalette
*
* Frees resources allocated by bInitializePalette.
*
* Note: In an error case, this may be called before bInitializePalette.
*
\**************************************************************************/

VOID vUninitializePalette(PDEV* ppdev)
{
    // Delete the default palette if we created one:

    if (ppdev->hpalDefault != 0)
        EngDeletePalette(ppdev->hpalDefault);

    if (ppdev->pPal != (PALETTEENTRY*) NULL)
        EngFreeMem(ppdev->pPal);
}

/******************************Public*Routine******************************\
* BOOL bEnablePalette
*
* Initialize the hardware's 8bpp palette registers.
*
\**************************************************************************/

BOOL bEnablePalette(PDEV* ppdev)
{
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    ULONG       cColors;
    PVIDEO_CLUTDATA pScreenClutData;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // Fill in pScreenClut header info:

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        // Copy colours in:

        cColors = 256;
        pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

        while(cColors--)
        {
            pScreenClutData[cColors].Red =    ppdev->pPal[cColors].peRed >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Green =  ppdev->pPal[cColors].peGreen >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue =   ppdev->pPal[cColors].peBlue >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }

        // Set palette registers:

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_COLOR_REGISTERS,
                               pScreenClut,
                               MAX_CLUT_SIZE,
                               NULL,
                               0,
                               &ulReturnedDataLength))
        {
            DISPDBG((0, "Failed bEnablePalette"));
            return(FALSE);
        }
    }

    DISPDBG((5, "Passed bEnablePalette"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisablePalette
*
* Undoes anything done in bEnablePalette.
*
\**************************************************************************/

VOID vDisablePalette(
PDEV*   ppdev)
{
    // Nothin' to do
}

/******************************Public*Routine******************************\
* VOID vAssertModePalette
*
* Sets/resets the palette in preparation for full-screen/graphics mode.
*
\**************************************************************************/

VOID vAssertModePalette(
PDEV*   ppdev,
BOOL    bEnable)
{
    // USER immediately calls DrvSetPalette after switching out of
    // full-screen, so we don't have to worry about resetting the
    // palette here.
}

/******************************Public*Routine******************************\
* BOOL DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PVIDEO_CLUTDATA pScreenClutData;
    PDEV*           ppdev;

    UNREFERENCED_PARAMETER(fl);

    ppdev = (PDEV*) dhpdev;

    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                     (ULONG*) pScreenClutData))
    {
        DISPDBG((0, "DrvSetPalette failed PALOBJ_cGetColors"));
        return (FALSE);
    }

    // Set the high reserved byte in each palette entry to 0.
    // Do the appropriate palette shifting to fit in the DAC.

    if (ppdev->cPaletteShift)
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Red >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Green >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }
    }
    else
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Unused = 0;
        }
    }

    // Set palette registers

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SET_COLOR_REGISTERS,
                           pScreenClut,
                           MAX_CLUT_SIZE,
                           NULL,
                           0,
                           &cColors))
    {
        DISPDBG((0, "DrvSetPalette failed SET_COLOR_REGISTERS"));
        return (FALSE);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL DrvIcmSetDeviceGammaRamp
*
* DDI entry point for manipulating the device gamma ramp.
*
* Note that GCAPS2_CHANGEGAMMARAMP has to be set for this to be called.
* Don't set GCAPS2_CHANGEGAMMARAMP when running 8bpp, though!
*
* (Note that we currently aren't hooking this call because none of the
* S3 hardware supports it!)
*
\**************************************************************************/

BOOL DrvIcmSetDeviceGammaRamp(
DHPDEV  dhpdev,
ULONG   iFormat,
PVOID   lpRamp)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PVIDEO_CLUTDATA pScreenClutData;
    PGAMMARAMP      pGammaRamp;
    PDEV*           ppdev;
    ULONG           i;
    DWORD           cColors;
    BYTE*           pjIoBase;
    BYTE            jMode;
    BYTE            jDacControl;

    ppdev = (PDEV*) dhpdev;

    pjIoBase = ppdev->pjIoBase;

    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) 256;
    pScreenClut->FirstEntry = (USHORT) 0;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    pGammaRamp = lpRamp;

    if (iFormat == IGRF_RGB_256WORDS)
    {
        for (i = 0; i < 256; i++)
        {
            // The gamma-ramp colors are given to us in an 8.8 fixed
            // point format.  Since our DAC has only 8 bits of color
            // precision, we get rid of the fractional part by simple
            // truncation.

            pScreenClutData[i].Red = pGammaRamp->Red[i] >> 8;
            pScreenClutData[i].Green = pGammaRamp->Green[i] >> 8;
            pScreenClutData[i].Blue = pGammaRamp->Blue[i] >> 8;
            pScreenClutData[i].Unused = 0;
        }
    
        // Set palette registers:
    
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_COLOR_REGISTERS,
                               pScreenClut,
                               MAX_CLUT_SIZE,
                               NULL,
                               0,
                               &cColors))
        {
            DISPDBG((0, "DrvIcmSetDeviceGammaRamp failed SET_COLOR_REGISTERS"));
            return (FALSE);
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\precomp.h ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: precomp.h
*
* Common headers used throughout the display driver.  This entire include
* file will typically be pre-compiled.
*
* Copyright (c) 1993-1998 Microsoft Corporation
\**************************************************************************/

#define __NTDDKCOMP__

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>
#include <winerror.h>
#include <wingdi.h>
#include <winddi.h>
#include <dmemmgr.h>
#include <devioctl.h>
#include <ntddvdeo.h>
#include <ioaccess.h>
#include <math.h>

#include "lines.h"
#include "driver.h"
#include "hw.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\str.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: str.c
*
* Contains the 'C' versions of some inner-loop routines for the
* partially hardware accelerated StretchBlt.
*
* Copyright (c) 1993-1998 Microsoft Corporation
\**************************************************************************/
#include "precomp.h"

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch8
*
* Routine Description:
*
*   Stretch blt 8->8
*
* NOTE: This routine doesn't handle cases where the blt stretch starts
*       and ends in the same destination dword!  vDirectStretchNarrow
*       is expected to have been called for that case.
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch8(
STR_BLT* pStrBlt)
{
    BYTE*   pjSrc;
    BYTE*   pjDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    BYTE*   pjOldScan;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc;
    BYTE*   pjDst       = pStrBlt->pjDstScan + xDst;
    LONG    yDst        = pStrBlt->YDstStart + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = (ULONG)((ULONG_PTR)pjDst & 0x03);
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)((ULONG_PTR)(pjDst + WidthX) & 0x03);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    ULONG   yInt        = 0;
    LONG    lDstStride  = pStrBlt->lDeltaDst - WidthX;

    WidthXAln = WidthX - EndAln - ((- (LONG) StartAln) & 0x03);

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    //
    // loop drawing each scan line
    //
    //
    // at least 7 wide (DST) blt
    //

    do {
        BYTE    jSrc0,jSrc1,jSrc2,jSrc3;
        ULONG   yTmp;

        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        //
        // a single src scan line is being written
        //

        switch (StartAln) {
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt;
            if (xTmp < xAccum)
                pjSrc++;

            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt;
            if (xTmp < xAccum)
                pjSrc++;

            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt;
            if (xTmp < xAccum)
                pjSrc++;

            *pjDst++ = jSrc0;
            xAccum = xTmp;
        }

        pjDstEnd  = pjDst + WidthXAln;

        while (pjDst != pjDstEnd)
        {
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt;
            if (xTmp < xAccum)
                pjSrc++;

            jSrc1 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt;
            if (xAccum < xTmp)
                pjSrc++;

            jSrc2 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt;
            if (xTmp < xAccum)
                pjSrc++;

            jSrc3 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt;
            if (xAccum < xTmp)
                pjSrc++;

            ulDst = (jSrc3 << 24) | (jSrc2 << 16) | (jSrc1 << 8) | jSrc0;

            *(PULONG)pjDst = ulDst;
            pjDst += 4;
        }

        switch (EndAln) {
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt;
            if (xTmp < xAccum)
                pjSrc++;

            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt;
            if (xTmp < xAccum)
                pjSrc++;

            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt;
            if (xTmp < xAccum)
                pjSrc++;

            *pjDst++ = jSrc0;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pjDst = (pjDst + lDstStride);
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pjDst = (pjDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.  On the S3, we have to turn off frame-buffer
            // access before touching the accelerator registers:

            ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_OFF);

            IO_FIFO_WAIT(ppdev, 4);
            IO_MIN_AXIS_PCNT(ppdev, cyDuplicate - 1);
            IO_ABS_DEST_Y(ppdev, yDst);
            IO_ABS_CUR_Y(ppdev, yDst - 1);
            IO_CMD(ppdev, (BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                           DRAWING_DIR_TBLRXM));

            yDst += cyDuplicate;

            ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, ppdev->bankmOnOverlapped);
        }
    } while (yCount != 0);
}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch16
*
* Routine Description:
*
*   Stretch blt 16->16
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch16(
STR_BLT* pStrBlt)
{
    BYTE*   pjOldScan;
    USHORT* pusSrc;
    USHORT* pusDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = (pStrBlt->pjSrcScan) + xSrc * 2;
    USHORT* pusDst      = (USHORT*)(pStrBlt->pjDstScan) + xDst;
    LONG    yDst        = pStrBlt->YDstStart + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = (ULONG)(((ULONG_PTR)pusDst & 0x02) >> 1);
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)(((ULONG_PTR)(pusDst + WidthX) & 0x02) >> 1);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - 2 * WidthX;
    ULONG   yInt        = 0;

    WidthXAln = WidthX - EndAln - StartAln;

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    // Loop stretching each scan line

    do {
        USHORT  usSrc0,usSrc1;
        ULONG   yTmp;

        pusSrc  = (USHORT*) pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        // A single source scan line is being written:

        if (StartAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt;
            if (xTmp < xAccum)
                pusSrc++;

            *pusDst++ = usSrc0;
            xAccum    = xTmp;
        }

        pusDstEnd  = pusDst + WidthXAln;

        while (pusDst != pusDstEnd)
        {

            usSrc0 = *pusSrc;
            xTmp   = xAccum + xFrac;
            pusSrc = pusSrc + xInt;
            if (xTmp < xAccum)
                pusSrc++;

            usSrc1 = *pusSrc;
            xAccum = xTmp + xFrac;
            pusSrc = pusSrc + xInt;
            if (xAccum < xTmp)
                pusSrc++;

            ulDst = (ULONG)((usSrc1 << 16) | usSrc0);

            *(ULONG*)pusDst = ulDst;
            pusDst+=2;
        }

        if (EndAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt;  // Is this really needed?
            if (xTmp < xAccum)
                pusSrc++;

            *pusDst++ = usSrc0;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pusDst = (USHORT*) ((BYTE*) pusDst + lDstStride);
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pusDst = (USHORT*) ((BYTE*) pusDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.  On the S3, we have to turn off frame-buffer
            // access before touching the accelerator registers:

            ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_OFF);

            IO_FIFO_WAIT(ppdev, 4);
            IO_MIN_AXIS_PCNT(ppdev, cyDuplicate - 1);
            IO_ABS_DEST_Y(ppdev, yDst);
            IO_ABS_CUR_Y(ppdev, yDst - 1);
            IO_CMD(ppdev, (BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                           DRAWING_DIR_TBLRXM));

            yDst += cyDuplicate;

            ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, ppdev->bankmOnOverlapped);
        }
    } while (yCount != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\textout.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: textout.c
*
* On every TextOut, GDI provides an array of 'GLYPHPOS' structures
* for every glyph to be drawn.  Each GLYPHPOS structure contains a
* glyph handle and a pointer to a monochrome bitmap that describes
* the glyph.  (Note that unlike Windows 3.1, which provides a column-
* major glyph bitmap, Windows NT always provides a row-major glyph
* bitmap.)  As such, there are three basic methods for drawing text
* with hardware acceleration:
*
* 1) Glyph caching -- Glyph bitmaps are cached by the accelerator
*       (probably in off-screen memory), and text is drawn by
*       referring the hardware to the cached glyph locations.
*
* 2) Glyph expansion -- Each individual glyph is colour-expanded
*       directly to the screen from the monochrome glyph bitmap
*       supplied by GDI.
*
* 3) Buffer expansion -- The CPU is used to draw all the glyphs into
*       a 1bpp monochrome bitmap, and the hardware is then used
*       to colour-expand the result.
*
* In addition, 2) and 3) can each have two permutations:
*
* a) Glyphs are bit-packed -- The fastest method, where no bits
*       are used as padding between scans of the glyph.
*
* b) Glyphs are byte-, word-, or dword-packed -- The slower method,
*       where the hardware requires that each scan be padded with
*       unused bits to fill out to the end of the byte, word, or
*       dword.
*
* The fastest method depends on a number of variables, such as the
* colour expansion speed, bus speed, CPU speed, average glyph size,
* and average string length.
*
* For the S3 with normal sized glyphs, I've found that caching the
* glyphs in off-screen memory is typically the slowest method.
* Buffer expansion is typically fastest on the slow ISA bus (or when
* memory-mapped I/O isn't available on the x86), and glyph expansion
* is best on fast buses such as VL and PCI.
*
* This driver implements glyph expansion and buffer expansion --
* methods 2) and 3).  Depending on the hardware capabilities at
* run-time, we'll use whichever one will be faster.
*
* Copyright (c) 1992-1998 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

RECTL grclMax = { 0, 0, 0x8000, 0x8000 };
                                // Maximal clip rectangle for trivial clipping

BYTE gajBit[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };
                                // Converts bit index to set bit

#define     FIFTEEN_BITS        ((1 << 15)-1)

/******************************Public*Routine******************************\
* VOID vClipSolid
*
* Fills the specified rectangles with the specified colour, honouring
* the requested clipping.  No more than four rectangles should be passed in.
* Intended for drawing the areas of the opaquing rectangle that extend
* beyond the text box.  The rectangles must be in left to right, top to
* bottom order.  Assumes there is at least one rectangle in the list.
*
\**************************************************************************/

VOID vClipSolid(
PDEV*       ppdev,
LONG        crcl,
RECTL*      prcl,
ULONG       iColor,
CLIPOBJ*    pco)
{
    BOOL            bMore;              // Flag for clip enumeration
    CLIPENUM        ce;                 // Clip enumeration object
    ULONG           i;
    ULONG           j;
    RECTL           arclTmp[4];
    ULONG           crclTmp;
    RECTL*          prclTmp;
    RECTL*          prclClipTmp;
    LONG            iLastBottom;
    RECTL*          prclClip;
    RBRUSH_COLOR    rbc;

    ASSERTDD((crcl > 0) && (crcl <= 4), "Expected 1 to 4 rectangles");
    ASSERTDD((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL),
                       "Expected a non-null clip object");

    rbc.iSolidColor = iColor;
    if (pco->iDComplexity == DC_RECT)
    {
        crcl = cIntersect(&pco->rclBounds, prcl, crcl);
        if (crcl != 0)
        {
            (ppdev->pfnFillSolid)(ppdev, crcl, prcl, 0xf0f0, rbc, NULL);
        }
    }
    else // iDComplexity == DC_COMPLEX
    {
        // Bottom of last rectangle to fill

        iLastBottom = prcl[crcl - 1].bottom;

        // Initialize the clip rectangle enumeration to right-down so we can
        // take advantage of the rectangle list being right-down:

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN, 0);

        // Scan through all the clip rectangles, looking for intersects
        // of fill areas with region rectangles:

        do {
            // Get a batch of region rectangles:

            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*)&ce);

            // Clip the rect list to each region rect:

            for (j = ce.c, prclClip = ce.arcl; j-- > 0; prclClip++)
            {
                // Since the rectangles and the region enumeration are both
                // right-down, we can zip through the region until we reach
                // the first fill rect, and are done when we've passed the
                // last fill rect.

                if (prclClip->top >= iLastBottom)
                {
                    // Past last fill rectangle; nothing left to do:

                    return;
                }

                // Do intersection tests only if we've reached the top of
                // the first rectangle to fill:

                if (prclClip->bottom > prcl->top)
                {
                    // We've reached the top Y scan of the first rect, so
                    // it's worth bothering checking for intersection.

                    // Generate a list of the rects clipped to this region
                    // rect:

                    prclTmp     = prcl;
                    prclClipTmp = arclTmp;

                    for (i = crcl, crclTmp = 0; i-- != 0; prclTmp++)
                    {
                        // Intersect fill and clip rectangles

                        if (bIntersect(prclTmp, prclClip, prclClipTmp))
                        {
                            // Add to list if anything's left to draw:

                            crclTmp++;
                            prclClipTmp++;
                        }
                    }

                    // Draw the clipped rects

                    if (crclTmp != 0)
                    {
                        (ppdev->pfnFillSolid)(ppdev, crclTmp, &arclTmp[0],
                                              0xf0f0, rbc, NULL);
                    }
                }
            }
        } while (bMore);
    }
}

/******************************Public*Routine******************************\
* BOOL bIoTextOut
*
* Outputs text using the 'buffer expansion' method.  We call GDI to draw
* all the glyphs to a single monochrome buffer, and then we use the
* hardware to colour expand the result to the screen.
*
\**************************************************************************/

BOOL bIoTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque)
{
    PDEV*           ppdev;
    RECTL*          prclBounds;
    LONG            lDelta;
    ULONG           ulBufferHeight;
    ULONG           ulBufferBytes;
    BOOL            bTmpAlloc;
    VOID*           pvTmp;
    SURFOBJ*        psoTmp;
    BOOL            bOpaque;
    BRUSHOBJ        boFore;
    BRUSHOBJ        boOpaque;
    BOOL            bRet;
    XLATECOLORS     xlc;                // Temporary for keeping colours
    XLATEOBJ        xlo;                // Temporary for passing colours
    CLIPENUM        ce;                 // Clip enumeration object
    RBRUSH_COLOR    rbc;
    RECTL*          prclClip;
    RECTL           rclClip;
    BOOL            bMore;
    ROP4            rop4;

    ppdev = (PDEV*) pso->dhpdev;

    // If asked to do an opaque TextOut, we'll set it up so that the
    // 1bpp blt we do will automatically opaque the 'rclBkGround'
    // rectangle.  But we have to handle here the case if 'prclOpaque'
    // is bigger than 'rclBkGround':

    if ((prclOpaque != NULL) &&
        ((prclOpaque->left   != pstro->rclBkGround.left)  ||
         (prclOpaque->top    != pstro->rclBkGround.top)   ||
         (prclOpaque->right  != pstro->rclBkGround.right) ||
         (prclOpaque->bottom != pstro->rclBkGround.bottom)))
    {
        rbc.iSolidColor = pboOpaque->iSolidColor;
        prclClip        = prclOpaque;

        if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        {

        Output_Opaque:

            ppdev->pfnFillSolid(ppdev,
                                1,
                                prclClip,
                                0xf0f0,
                                rbc,
                                NULL);
        }
        else if (pco->iDComplexity == DC_RECT)
        {
            if (bIntersect(&pco->rclBounds, prclOpaque, &rclClip))
            {
                prclClip = &rclClip;

                // Save some code size by jumping to the common
                // functions calls:

                goto Output_Opaque;
            }
        }
        else // pco->iDComplexity == DC_COMPLEX
        {
            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

            do
            {
                bMore = CLIPOBJ_bEnum(pco,
                                sizeof(ce) - sizeof(RECTL),
                                (ULONG*) &ce);

                ce.c = cIntersect(prclOpaque, ce.arcl, ce.c);

                if (ce.c != 0)
                {
                    ppdev->pfnFillSolid(ppdev,
                                        ce.c,
                                        &ce.arcl[0],
                                        0xf0f0,
                                        rbc,
                                        NULL);
                }
            } while (bMore);
        }
    }

    // If there is an opaque rectangle then it will be bigger than the
    // background rectangle.  We want to test with whichever is bigger.

    prclBounds = prclOpaque;
    if (prclBounds == NULL)
    {
        prclBounds = &pstro->rclBkGround;
    }

    if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
    {
        // I'm not entirely sure why, but GDI will occasionally send
        // us TextOut's where the opaquing rectangle does not intersect
        // with the clip object bounds -- meaning that the text out
        // should have already been trivially rejected.  We will do so
        // here because the blt code usually assumes that all trivial
        // rejections will have already been performed, and we will be
        // passing this call on to the blt code:

        if ((pco->rclBounds.top    >= pstro->rclBkGround.bottom) ||
            (pco->rclBounds.left   >= pstro->rclBkGround.right)  ||
            (pco->rclBounds.right  <= pstro->rclBkGround.left)   ||
            (pco->rclBounds.bottom <= pstro->rclBkGround.top))
        {
            // The entire operation was trivially rejected:

            return(TRUE);
        }
    }

    // See if the temporary buffer is big enough for the text; if
    // not, try to allocate enough memory.  We round up to the
    // nearest dword multiple:

    lDelta = ((((pstro->rclBkGround.right + 31) & ~31) -
                (pstro->rclBkGround.left & ~31)) >> 3);

    ulBufferHeight = pstro->rclBkGround.bottom - pstro->rclBkGround.top;
    ulBufferBytes  = lDelta * ulBufferHeight;

    if (((ULONG) lDelta > FIFTEEN_BITS) ||
        (ulBufferHeight > FIFTEEN_BITS))
    {
        // Fail if the math will have overflowed:

        return(FALSE);
    }

    // Use our temporary buffer if it's big enough, otherwise
    // allocate a buffer on the fly:

    if (ulBufferBytes >= TMP_BUFFER_SIZE)
    {
        // The textout is so big that I doubt this allocation will
        // cost a significant amount in performance:

        bTmpAlloc = TRUE;
        pvTmp     = EngAllocUserMem(ulBufferBytes, ALLOC_TAG);
        if (pvTmp == NULL)
            return(FALSE);
    }
    else
    {
        bTmpAlloc  = FALSE;
        pvTmp      = ppdev->pvTmpBuffer;
    }

    psoTmp = ppdev->psoText;

    // Adjust 'lDelta' and 'pvScan0' of our temporary 1bpp surface object
    // so that when GDI starts drawing the text, it will begin in the
    // first dword

    psoTmp->pvScan0 = (BYTE*) pvTmp - (pstro->rclBkGround.top * lDelta)
                                    - ((pstro->rclBkGround.left & ~31) >> 3);
    psoTmp->lDelta  = lDelta;

    ASSERTDD(((ULONG_PTR)psoTmp->pvScan0 &3)==0,"pvScan0 must be dword aligned");
    ASSERTDD((lDelta & 3) == 0, "lDelta must be dword aligned");

    // Get GDI to draw the text for us into a 1bpp buffer:

    boFore.iSolidColor = 1;
    boOpaque.iSolidColor = 0;

    bRet = EngTextOut(psoTmp,
                      pstro,
                      pfo,
                      pco,
                      NULL,
                      &pstro->rclBkGround,
                      &boFore,
                      &boOpaque,
                      NULL,
                      0x0d0d);

    if (bRet)
    {
        // Transparently blt the 1bpp buffer to the screen:

        xlc.iForeColor = pboFore->iSolidColor;
        xlc.iBackColor = pboOpaque->iSolidColor;
        xlo.pulXlate   = (ULONG*) &xlc;
        prclClip       = &pstro->rclBkGround;

        // Rop 'aacc' works out to a transparent blt, while 'cccc' works
        // out to an opaque blt:

        rop4 = (prclOpaque != NULL) ? 0xcccc : 0xaacc;

        if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        {

        Output_Text:

            ppdev->pfnXfer1bpp(ppdev,
                               1,
                               prclClip,
                               rop4,
                               psoTmp,
                               (POINTL*) &pstro->rclBkGround,
                               &pstro->rclBkGround,
                               &xlo);
        }
        else if (pco->iDComplexity == DC_RECT)
        {
            if (bIntersect(&pco->rclBounds, &pstro->rclBkGround, &rclClip))
            {
                prclClip = &rclClip;

                // Save some code size by jumping to the common
                // functions calls:

                goto Output_Text;
            }
        }
        else // pco->iDComplexity == DC_COMPLEX
        {
            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

            do
            {
                bMore = CLIPOBJ_bEnum(pco,
                                sizeof(ce) - sizeof(RECTL),
                                (ULONG*) &ce);

                ce.c = cIntersect(&pstro->rclBkGround, ce.arcl, ce.c);

                if (ce.c != 0)
                {
                    ppdev->pfnXfer1bpp(ppdev,
                                       ce.c,
                                       &ce.arcl[0],
                                       rop4,
                                       psoTmp,
                                       (POINTL*) &pstro->rclBkGround,
                                       &pstro->rclBkGround,
                                       &xlo);
                }
            } while (bMore);
        }
    }

    // Free up any memory we allocated for the temp buffer:

    if (bTmpAlloc)
    {
        EngFreeUserMem(pvTmp);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vMmGeneralText
*
* Handles any strings that need to be clipped, using the 'glyph
* expansion' method.
*
\**************************************************************************/

VOID vMmGeneralText(
PDEV*     ppdev,
STROBJ*   pstro,
CLIPOBJ*  pco)
{
    BYTE*       pjMmBase;
    BOOL        bMoreGlyphs;
    ULONG       cGlyphOriginal;
    ULONG       cGlyph;
    GLYPHPOS*   pgpOriginal;
    GLYPHPOS*   pgp;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL*      prclClip;
    ULONG       ulCharInc;
    LONG        cxGlyph;
    LONG        cyGlyph;
    BYTE*       pjGlyph;
    LONG        cj;
    LONG        cw;
    LONG        xLeft;
    LONG        yTop;
    LONG        xRight;
    LONG        yBottom;
    LONG        xBias;
    LONG        lDelta;
    LONG        cx;
    LONG        cy;
    BYTE        iDComplexity;

    ASSERTDD(pco != NULL, "Don't expect NULL clip objects here");

    pjMmBase = ppdev->pjMmBase;

    do {
      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        ulCharInc = pstro->ulCharInc;

        iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

        if (iDComplexity != DC_COMPLEX)
        {
            // We could call 'cEnumStart' and 'bEnum' when the clipping is
            // DC_RECT, but the last time I checked, those two calls took
            // more than 150 instructions to go through GDI.  Since
            // 'rclBounds' already contains the DC_RECT clip rectangle,
            // and since it's such a common case, we'll special case it:

            bMore = FALSE;
            ce.c  = 1;

            if (iDComplexity == DC_TRIVIAL)
                prclClip = &grclMax;
            else
                prclClip = &pco->rclBounds;

            goto SingleRectangle;
        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {
          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;
            pgb    = pgp->pgdf->pgb;

            ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
            ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              cxGlyph = pgb->sizlBitmap.cx;
              cyGlyph = pgb->sizlBitmap.cy;

              pjGlyph = pgb->aj;

              if ((prclClip->left   <= ptlOrigin.x) &&
                  (prclClip->top    <= ptlOrigin.y) &&
                  (prclClip->right  >= ptlOrigin.x + cxGlyph) &&
                  (prclClip->bottom >= ptlOrigin.y + cyGlyph))
              {
                //-----------------------------------------------------
                // Unclipped glyph

                IO_FIFO_WAIT(ppdev, 4);

                MM_CUR_X(ppdev, pjMmBase, ptlOrigin.x);
                MM_CUR_Y(ppdev, pjMmBase, ptlOrigin.y);
                MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, cxGlyph - 1);
                MM_MIN_AXIS_PCNT(ppdev, pjMmBase, cyGlyph - 1);

                IO_GP_WAIT(ppdev);

                if (cxGlyph <= 8)
                {
                  //-----------------------------------------------------
                  // 1 to 8 pels in width

                  MM_CMD(ppdev, pjMmBase,
                    (RECTANGLE_FILL  | WAIT          | DRAWING_DIR_TBLRXM |
                     DRAW            | LAST_PIXEL_ON | MULTIPLE_PIXELS    |
                     WRITE           | BYTE_SWAP     | BUS_SIZE_16));

                  CHECK_DATA_READY(ppdev);

                  MM_TRANSFER_BYTE_THIN(ppdev, pjMmBase, pjGlyph, cyGlyph);

                  CHECK_DATA_COMPLETE(ppdev);
                }
                else if (cxGlyph <= 16)
                {
                  //-----------------------------------------------------
                  // 9 to 16 pels in width

                  MM_CMD(ppdev, pjMmBase,
                    (RECTANGLE_FILL  | WAIT          | DRAWING_DIR_TBLRXM |
                     DRAW            | LAST_PIXEL_ON | MULTIPLE_PIXELS    |
                     WRITE           | BYTE_SWAP     | BUS_SIZE_16));

                  CHECK_DATA_READY(ppdev);

                  MM_TRANSFER_WORD_ALIGNED(ppdev, pjMmBase, pjGlyph, cyGlyph);

                  CHECK_DATA_COMPLETE(ppdev);
                }
                else
                {
                  lDelta = (cxGlyph + 7) >> 3;

                  if (!(lDelta & 1))
                  {
                    //-----------------------------------------------------
                    // Even number of bytes in width

                    MM_CMD(ppdev, pjMmBase,
                      (RECTANGLE_FILL  | WAIT          | DRAWING_DIR_TBLRXM |
                       DRAW            | LAST_PIXEL_ON | MULTIPLE_PIXELS    |
                       WRITE           | BYTE_SWAP     | BUS_SIZE_16));

                    CHECK_DATA_READY(ppdev);

                    MM_TRANSFER_WORD_ALIGNED(ppdev, pjMmBase, pjGlyph,
                                              ((lDelta * cyGlyph) >> 1));

                    CHECK_DATA_COMPLETE(ppdev);
                  }
                  else
                  {
                    //-----------------------------------------------------
                    // Odd number of bytes in width

                    // We revert to byte transfers instead of word transfers
                    // because word transfers would cause us to do unaligned
                    // reads for every second scan, which could cause us to
                    // read past the end of the glyph bitmap, and access
                    // violate.

                    MM_CMD(ppdev, pjMmBase,
                      (RECTANGLE_FILL  | WAIT          | DRAWING_DIR_TBLRXM |
                       DRAW            | LAST_PIXEL_ON | MULTIPLE_PIXELS    |
                       WRITE           | BYTE_SWAP     | BUS_SIZE_16));

                    CHECK_DATA_READY(ppdev);

                    MM_TRANSFER_WORD_ODD(ppdev, pjMmBase, pjGlyph, lDelta,
                                          cyGlyph);

                    CHECK_DATA_COMPLETE(ppdev);
                  }
                }
              }
              else
              {
                //-----------------------------------------------------
                // Clipped glyph

                // Find the intersection of the glyph rectangle
                // and the clip rectangle:

                xLeft   = max(prclClip->left,   ptlOrigin.x);
                yTop    = max(prclClip->top,    ptlOrigin.y);
                xRight  = min(prclClip->right,  ptlOrigin.x + cxGlyph);
                yBottom = min(prclClip->bottom, ptlOrigin.y + cyGlyph);

                // Check for trivial rejection:

                if (((cx = xRight - xLeft) > 0) &&
                    ((cy = yBottom - yTop) > 0))
                {
                  IO_FIFO_WAIT(ppdev, 5);

                  xBias = (xLeft - ptlOrigin.x) & 7;
                  if (xBias != 0)
                  {
                    // 'xBias' is the bit position in the monochrome glyph
                    // bitmap of the first pixel to be lit, relative to
                    // the start of the byte.  That is, if 'xBias' is 2,
                    // then the first unclipped pixel is represented by bit
                    // 2 of the corresponding bitmap byte.
                    //
                    // Normally, the accelerator expects bit 0 to be the
                    // first lit byte.  We use the scissors so that the
                    // first 'xBias' bits of the byte will not be displayed.
                    //
                    // (What we're doing is simply aligning the monochrome
                    // blt using the hardware clipping.)

                    MM_SCISSORS_L(ppdev, pjMmBase, xLeft);
                    xLeft -= xBias;
                    cx    += xBias;
                  }

                  MM_CUR_X(ppdev, pjMmBase, xLeft);
                  MM_CUR_Y(ppdev, pjMmBase, yTop);
                  MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, cx - 1);
                  MM_MIN_AXIS_PCNT(ppdev, pjMmBase, cy - 1);

                  lDelta   = (cxGlyph + 7) >> 3;
                  pjGlyph += (yTop - ptlOrigin.y) * lDelta
                           + ((xLeft - ptlOrigin.x) >> 3);
                  cj       = (cx + 7) >> 3;

                  IO_GP_WAIT(ppdev);

                  MM_CMD(ppdev, pjMmBase,
                    (RECTANGLE_FILL  | WAIT          | DRAWING_DIR_TBLRXM |
                     DRAW            | LAST_PIXEL_ON | MULTIPLE_PIXELS    |
                     WRITE           | BYTE_SWAP     | BUS_SIZE_16));

                  CHECK_DATA_READY(ppdev);

                  // We use byte transfers because I don't expect we'll be
                  // asked to clip many large glyphs where it would be
                  // worth the overhead of setting up for word transfers:

                  do {
                    MM_TRANSFER_BYTE(ppdev, pjMmBase, pjGlyph, cj);
                    pjGlyph += lDelta;

                  } while (--cy != 0);

                  CHECK_DATA_COMPLETE(ppdev);

                  if (xBias != 0)
                  {
                    // Reset the scissors if we used it:

                    IO_FIFO_WAIT(ppdev, 1);
                    MM_ABS_SCISSORS_L(ppdev, pjMmBase, 0);
                  }
                }
              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;
              pgb = pgp->pgdf->pgb;

              if (ulCharInc == 0)
              {
                ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
                ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
              }
              else
              {
                ptlOrigin.x += ulCharInc;
              }
            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);
}

/******************************Public*Routine******************************\
* CACHEDFONT* pcfAllocateCachedFont()
*
* Initializes our font data structure.
*
\**************************************************************************/

CACHEDFONT* pcfAllocateCachedFont(
PDEV*   ppdev)
{
    CACHEDFONT*     pcf;
    CACHEDGLYPH**   ppcg;
    LONG            i;

    pcf = EngAllocMem(FL_ZERO_MEMORY, sizeof(CACHEDFONT), ALLOC_TAG);

    if (pcf != NULL)
    {
        // Note that we rely on FL_ZERO_MEMORY to zero 'pgaChain' and
        // 'cjAlloc':

        pcf->cgSentinel.hg = HGLYPH_SENTINEL;

        // Initialize the hash table entries to all point to our sentinel:

        for (ppcg = &pcf->apcg[0], i = GLYPH_HASH_SIZE; i != 0; i--, ppcg++)
        {
            *ppcg = &pcf->cgSentinel;
        }
    }

    return(pcf);
}

/******************************Public*Routine******************************\
* VOID vFreeCachedFont()
*
* Frees all memory associated with the cache we kept for this font.
*
\**************************************************************************/

VOID vFreeCachedFont(
CACHEDFONT* pcf)
{
    GLYPHALLOC* pga;
    GLYPHALLOC* pgaNext;


    pga = pcf->pgaChain;
    while (pga != NULL)
    {
        pgaNext = pga->pgaNext;
        EngFreeMem(pga);
        pga = pgaNext;
    }

    EngFreeMem(pcf);
}

/******************************Public*Routine******************************\
* VOID vTrimAndBitpackGlyph
*
* This routine takes a GDI byte-aligned glyphbits definition, trims off
* any unused pixels on the sides, and creates a bit-packed result that
* is a natural for the S3's monochrome expansion capabilities.  
* "Bit-packed" is where a small monochrome bitmap is packed with no 
* unused bits between strides.  So if GDI gives us a 16x16 bitmap to 
* represent '.' that really only has a 2x2 array of lit pixels, we would
* trim the result to give a single byte value of 0xf0.
*
* Use this routine if your monochrome expansion hardware can do bit-packed
* expansion (this is the fastest method).  If your hardware requires byte-,
* word-, or dword-alignment on monochrome expansions, use 
* vTrimAndPackGlyph().
*
* (This driver doesn't use this routine only because the hardware can't do
* bit-packing!)
*
\**************************************************************************/

VOID vTrimAndBitpackGlyph(
BYTE*   pjBuf,          // Note: Routine may touch preceding byte!
BYTE*   pjGlyph,
LONG*   pcxGlyph,
LONG*   pcyGlyph,
POINTL* pptlOrigin,
LONG*   pcj)            // For returning the count of bytes of the result
{
    LONG    cxGlyph;
    LONG    cyGlyph;
    POINTL  ptlOrigin;
    LONG    cAlign;
    LONG    lDelta;
    BYTE*   pj;
    BYTE    jBit;
    LONG    cjSrcWidth;
    LONG    lSrcSkip;
    LONG    lDstSkip;
    LONG    cRem;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    i;
    LONG    j;
    BYTE    jSrc;

    ///////////////////////////////////////////////////////////////
    // Trim the glyph

    cyGlyph   = *pcyGlyph;
    cxGlyph   = *pcxGlyph;
    ptlOrigin = *pptlOrigin;
    cAlign    = 0;

    lDelta = (cxGlyph + 7) >> 3;

    // Trim off any zero rows at the bottom of the glyph:

    pj = pjGlyph + cyGlyph * lDelta;    // One past last byte in glyph
    while (cyGlyph > 0)
    {
        i = lDelta;
        do {
            if (*(--pj) != 0)
                goto Done_Bottom_Trim;
        } while (--i != 0);

        // The entire last row has no lit pixels, so simply skip it:

        cyGlyph--;
    }

    ASSERTDD(cyGlyph == 0, "cyGlyph should only be zero here");

    // We found a space character.  Set both dimensions to zero, so
    // that it's easy to special-case later:

    cxGlyph = 0;

Done_Bottom_Trim:

    // If cxGlyph != 0, we know that the glyph has at least one non-zero
    // row and column.  By exploiting this knowledge, we can simplify our
    // end-of-loop tests, because we don't have to check to see if we've
    // decremented either 'cyGlyph' or 'cxGlyph' to zero:

    if (cxGlyph != 0)
    {
        // Trim off any zero rows at the top of the glyph:

        pj = pjGlyph;                       // First byte in glyph
        while (TRUE)
        {
            i = lDelta;
            do {
                if (*(pj++) != 0)
                    goto Done_Top_Trim;
            } while (--i != 0);

            // The entire first row has no lit pixels, so simply skip it:

            cyGlyph--;
            ptlOrigin.y++;
            pjGlyph = pj;
        }

Done_Top_Trim:

        // Trim off any zero columns at the right edge of the glyph:

        while (TRUE)
        {
            j    = cxGlyph - 1;

            pj   = pjGlyph + (j >> 3);      // Last byte in first row of glyph
            jBit = gajBit[j & 0x7];
            i    = cyGlyph;

            do {
                if ((*pj & jBit) != 0)
                    goto Done_Right_Trim;

                pj += lDelta;
            } while (--i != 0);

            // The entire last column has no lit pixels, so simply skip it:

            cxGlyph--;
        }

Done_Right_Trim:

        // Trim off any zero columns at the left edge of the glyph:

        while (TRUE)
        {
            pj   = pjGlyph;                 // First byte in first row of glyph
            jBit = gajBit[cAlign];
            i    = cyGlyph;

            do {
                if ((*pj & jBit) != 0)
                    goto Done_Left_Trim;

                pj += lDelta;
            } while (--i != 0);

            // The entire first column has no lit pixels, so simply skip it:

            ptlOrigin.x++;
            cxGlyph--;
            cAlign++;
            if (cAlign >= 8)
            {
                cAlign = 0;
                pjGlyph++;
            }
        }
    }

Done_Left_Trim:

    ///////////////////////////////////////////////////////////////
    // Pack the glyph

    cjSrcWidth  = (cxGlyph + cAlign + 7) >> 3;
    lSrcSkip    = lDelta - cjSrcWidth;
    lDstSkip    = ((cxGlyph + 7) >> 3) - cjSrcWidth - 1;
    cRem        = ((cxGlyph - 1) & 7) + 1;   // 0 -> 8

    pjSrc       = pjGlyph;
    pjDst       = pjBuf;

    // Zero the buffer, because we're going to 'or' stuff into it:

    memset(pjBuf, 0, (cxGlyph * cyGlyph + 7) >> 3);

    // cAlign used to indicate which bit in the first byte of the unpacked
    // glyph was the first non-zero pixel column.  Now, we flip it to
    // indicate which bit in the packed byte will receive the next non-zero
    // glyph bit:

    cAlign = (-cAlign) & 0x7;
    if (cAlign > 0)
    {
        // It would be bad if our trimming calculations were wrong, because
        // we assume any bits to the left of the 'cAlign' bit will be zero.
        // As a result of this decrement, we will 'or' those zero bits into
        // whatever byte precedes the glyph bits array:

        pjDst--;

        ASSERTDD((*pjSrc >> cAlign) == 0, "Trimmed off too many bits");
    }

    for (i = cyGlyph; i != 0; i--)
    {
        for (j = cjSrcWidth; j != 0; j--)
        {
            // Note that we may modify a byte past the end of our
            // destination buffer, which is why we reserved an
            // extra byte:

            jSrc = *pjSrc;
            *(pjDst)     |= (jSrc >> (cAlign));
            *(pjDst + 1) |= (jSrc << (8 - cAlign));
            pjSrc++;
            pjDst++;
        }

        pjSrc  += lSrcSkip;
        pjDst  += lDstSkip;
        cAlign += cRem;

        if (cAlign >= 8)
        {
            cAlign -= 8;
            pjDst++;
        }
    }

    ///////////////////////////////////////////////////////////////
    // Return results

    *pcxGlyph   = cxGlyph;
    *pcyGlyph   = cyGlyph;
    *pptlOrigin = ptlOrigin;
    *pcj        = ((cxGlyph * cyGlyph) + 7) >> 3;
}

/******************************Public*Routine******************************\
* VOID vTrimAndPackGlyph
*
* This routine takes a GDI byte-aligned glyphbits definition, trims off
* any unused pixels on the sides, and creates a word-algined result that
* is a natural for the S3's monochrome expansion capabilities.  
* So if GDI gives us a 16x16 bitmap to represent '.' that really only 
* has a 2x2 array of lit pixels, we would trim the result to give 2 words
* of 0xc000 and 0xc000.
*
* Use this routine if your monochrome expansion hardware requires byte-,
* word-, or dword-alignment on monochrome expansions.  If your hardware
* can do bit-packed expansions, please use vTrimAndBitpackGlyph(), since
* it will be faster.
*
\**************************************************************************/

VOID vTrimAndPackGlyph(
PDEV*   ppdev,
BYTE*   pjBuf,          // Note: Routine may touch preceding byte!
BYTE*   pjGlyph,
LONG*   pcxGlyph,
LONG*   pcyGlyph,
POINTL* pptlOrigin,
LONG*   pcj)            // For returning the count of bytes of the result
{
    LONG    cxGlyph;
    LONG    cyGlyph;
    POINTL  ptlOrigin;
    LONG    cAlign;
    LONG    lDelta;
    BYTE*   pj;
    BYTE    jBit;
    LONG    cjSrcWidth;
    LONG    lSrcSkip;
    LONG    lDstSkip;
    LONG    lDstDelta;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    i;
    LONG    j;
    BYTE    jSrc;

    ///////////////////////////////////////////////////////////////
    // Trim the glyph

    cyGlyph   = *pcyGlyph;
    cxGlyph   = *pcxGlyph;
    ptlOrigin = *pptlOrigin;
    cAlign    = 0;

    // let [x] denote the least integer greater than or equal to x
    // Set lDelta to be [cxGlyph/8]. This is the number of bytes occupied
    // by the pixels in the horizontal direction of the monochrome glyph.

    lDelta = (cxGlyph + 7) >> 3;

    // Trim off any zero rows at the bottom of the glyph:

    pj = pjGlyph + cyGlyph * lDelta;    // One past last byte in glyph
    while (cyGlyph > 0)
    {
        i = lDelta;
        do {
            if (*(--pj) != 0)
                goto Done_Bottom_Trim;
        } while (--i != 0);

        // The entire last row has no lit pixels, so simply skip it:

        cyGlyph--;
    }

    ASSERTDD(cyGlyph == 0, "cyGlyph should only be zero here");

    // We found a space character.  Set both dimensions to zero, so
    // that it's easy to special-case later:

    cxGlyph = 0;

Done_Bottom_Trim:

    // If cxGlyph != 0, we know that the glyph has at least one non-zero
    // row and column.  By exploiting this knowledge, we can simplify our
    // end-of-loop tests, because we don't have to check to see if we've
    // decremented either 'cyGlyph' or 'cxGlyph' to zero:

    if (cxGlyph != 0)
    {
        // Trim off any zero rows at the top of the glyph:

        pj = pjGlyph;                       // First byte in glyph
        while (TRUE)
        {
            i = lDelta;
            do {
                if (*(pj++) != 0)
                    goto Done_Top_Trim;
            } while (--i != 0);

            // The entire first row has no lit pixels, so simply skip it:

            cyGlyph--;
            ptlOrigin.y++;
            pjGlyph = pj;
        }

Done_Top_Trim:

        // Trim off any zero columns at the right edge of the glyph:

        while (TRUE)
        {
            j    = cxGlyph - 1;

            pj   = pjGlyph + (j >> 3);      // Last byte in first row of glyph
            jBit = gajBit[j & 0x7];
            i    = cyGlyph;

            do {
                if ((*pj & jBit) != 0)
                    goto Done_Right_Trim;

                pj += lDelta;
            } while (--i != 0);

            // The entire last column has no lit pixels, so simply skip it:

            cxGlyph--;
        }

Done_Right_Trim:

        // Trim off any zero columns at the left edge of the glyph:

        while (TRUE)
        {
            pj   = pjGlyph;                 // First byte in first row of glyph
            jBit = gajBit[cAlign];
            i    = cyGlyph;

            do {
                if ((*pj & jBit) != 0)
                    goto Done_Left_Trim;

                pj += lDelta;
            } while (--i != 0);

            // The entire first column has no lit pixels, so simply skip it:

            ptlOrigin.x++;
            cxGlyph--;
            cAlign++;
            if (cAlign >= 8)
            {
                cAlign = 0;
                pjGlyph++;
            }
        }
    }

Done_Left_Trim:

    ///////////////////////////////////////////////////////////////
    // Pack the glyph

    // byte count of cell size (trimmed width + blank left columns).

    cjSrcWidth  = (cxGlyph + cAlign + 7) >> 3;

    // difference between cell width and trimmed glyph width.

    lSrcSkip    = lDelta - cjSrcWidth;

    // trimmed glyph width in bytes.

    lDstDelta   = (cxGlyph + 7) >> 3;

    // Make the glyphs 'word-packed' (i.e., every scan is word aligned)
    // unless in 24bpp mode, in which case we have to use 32 bit bus size,
    // which in turn requires dword packing.

    if (ppdev->iBitmapFormat == BMF_24BPP)
        lDstDelta = (lDstDelta + 3) & ~3;
    else
        lDstDelta = (lDstDelta + 1) & ~1;

    lDstSkip  = lDstDelta - cjSrcWidth;

    pjSrc     = pjGlyph;    // Start of trimmed glyph, not including empty left columns.
    pjDst     = pjBuf;

    // Zero the first byte of the buffer, because we're going to 'or' stuff
    // into it:

    *pjDst = 0;

    // cAlign used to indicate which bit in the first byte of the unpacked
    // glyph was the first non-zero pixel column.  Now, we flip it to
    // indicate which bit in the packed byte will receive the next non-zero
    // glyph bit:

    cAlign = (-cAlign) & 0x7;
    if (cAlign > 0)
    {
        // It would be bad if our trimming calculations were wrong, because
        // we assume any bits to the left of the 'cAlign' bit will be zero.
        // As a result of this decrement, we will 'or' those zero bits into
        // whatever byte precedes the glyph bits array:

        pjDst--;

        ASSERTDD((*pjSrc >> cAlign) == 0, "Trimmed off too many bits");
    }

    for (i = cyGlyph; i != 0; i--)
    {
        for (j = cjSrcWidth; j != 0; j--)
        {
            // Note that we may modify a byte past the end of our
            // destination buffer, which is why we reserved an
            // extra byte:
            jSrc = *pjSrc;
            *(pjDst)     |= (jSrc >> (cAlign));
            *(pjDst + 1)  = (jSrc << (8 - cAlign));
            pjSrc++;
            pjDst++;

        }
        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }

    ///////////////////////////////////////////////////////////////
    // Return results

    *pcxGlyph   = cxGlyph;
    *pcyGlyph   = cyGlyph;
    *pptlOrigin = ptlOrigin;
    *pcj        = lDstDelta * cyGlyph;
}

/******************************Public*Routine******************************\
* LONG cjPutGlyphInCache
*
* Figures out where to be a glyph in off-screen memory, copies it
* there, and fills in any other data we'll need to display the glyph.
*
* This routine is rather device-specific, and will have to be extensively
* modified for other display adapters.
*
* Returns the number of bytes taken by the cached glyph bits.
*
\**************************************************************************/

LONG cjPutGlyphInCache(
PDEV*           ppdev,
CACHEDGLYPH*    pcg,
GLYPHBITS*      pgb)
{
    BYTE*   pjGlyph;
    LONG    cxGlyph;
    LONG    cyGlyph;
    POINTL  ptlOrigin;
    BYTE*   pjSrc;
    ULONG*  pulDst;
    LONG    i;
    LONG    cPels;
    ULONG   ulGlyphThis;
    ULONG   ulGlyphNext;
    ULONG   ul;
    ULONG   ulStart;
    LONG    cj;

    pjGlyph   = pgb->aj;
    cyGlyph   = pgb->sizlBitmap.cy;
    cxGlyph   = pgb->sizlBitmap.cx;
    ptlOrigin = pgb->ptlOrigin;

    vTrimAndPackGlyph(ppdev, (BYTE*) &pcg->ad, pjGlyph, &cxGlyph, &cyGlyph,
                      &ptlOrigin, &cj);

    ///////////////////////////////////////////////////////////////
    // Initialize the glyph fields

    pcg->ptlOrigin   = ptlOrigin;
    pcg->cxLessOne   = cxGlyph - 1;
    pcg->cyLessOne   = cyGlyph - 1;
    pcg->cxcyLessOne = PACKXY(cxGlyph - 1, cyGlyph - 1);
    pcg->cw          = (cj + 1) >> 1;
    pcg->cd          = (cj + 3) >> 2;

    return(cj);
}

/******************************Public*Routine******************************\
* CACHEDGLYPH* pcgNew()
*
* Creates a new CACHEDGLYPH structure for keeping track of the glyph in
* off-screen memory.  bPutGlyphInCache is called to actually put the glyph
* in off-screen memory.
*
* This routine should be reasonably device-independent, as bPutGlyphInCache
* will contain most of the code that will have to be modified for other
* display adapters.
*
\**************************************************************************/

CACHEDGLYPH* pcgNew(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp)
{
    GLYPHBITS*      pgb;
    GLYPHALLOC*     pga;
    CACHEDGLYPH*    pcg;
    LONG            cjCachedGlyph;
    HGLYPH          hg;
    LONG            iHash;
    CACHEDGLYPH*    pcgFind;
    LONG            cjGlyphRow;
    LONG            cj;

    // First, calculate the amount of storage we'll need for this glyph:

    pgb = pgp->pgdf->pgb;

    // The glyphs are 'word-packed':

    cjGlyphRow    = ((pgb->sizlBitmap.cx + 15) & ~15) >> 3;
    cjCachedGlyph = sizeof(CACHEDGLYPH) + (pgb->sizlBitmap.cy * cjGlyphRow);

    // Reserve an extra byte at the end for temporary usage by our pack
    // routine:

    cjCachedGlyph++;

    if (cjCachedGlyph > pcf->cjAlloc)
    {
        // Have to allocate a new glyph allocation structure:

        pga = EngAllocMem(FL_ZERO_MEMORY, GLYPH_ALLOC_SIZE, ALLOC_TAG);
        if (pga == NULL)
        {
            // It's safe to return at this time because we haven't
            // fatally altered any of our data structures:

            return(NULL);
        }

        // Add this allocation to the front of the allocation linked list,
        // so that we can free it later:

        pga->pgaNext  = pcf->pgaChain;
        pcf->pgaChain = pga;

        // Now we've got a chunk of memory where we can store our cached
        // glyphs:

        pcf->pcgNew  = &pga->acg[0];
        pcf->cjAlloc = GLYPH_ALLOC_SIZE - (sizeof(*pga) - sizeof(pga->acg[0]));

        // It would be bad if we let in any glyphs that would be bigger
        // than our basic allocation size:

        ASSERTDD(cjCachedGlyph <= GLYPH_ALLOC_SIZE, "Woah, this is one big glyph!");
    }

    pcg = pcf->pcgNew;

    ///////////////////////////////////////////////////////////////
    // Insert the glyph, in-order, into the list hanging off our hash
    // bucket:

    hg = pgp->hg;

    pcg->hg = hg;
    iHash   = GLYPH_HASH_FUNC(hg);
    pcgFind = pcf->apcg[iHash];

    if (pcgFind->hg > hg)
    {
        pcf->apcg[iHash] = pcg;
        pcg->pcgNext     = pcgFind;
    }
    else
    {
        // The sentinel will ensure that we never fall off the end of
        // this list:

        while (pcgFind->pcgNext->hg < hg)
            pcgFind = pcgFind->pcgNext;

        // 'pcgFind' now points to the entry to the entry after which
        // we want to insert our new node:

        pcg->pcgNext     = pcgFind->pcgNext;
        pcgFind->pcgNext = pcg;
    }

    cj = cjPutGlyphInCache(ppdev, pcg, pgp->pgdf->pgb);

    ///////////////////////////////////////////////////////////////
    // We now know the size taken up by the packed and trimmed glyph;
    // adjust the pointer to the next glyph accordingly.  We only need
    // to ensure 'dword' alignment:

    cjCachedGlyph = sizeof(CACHEDGLYPH) + ((cj + 7) & ~7);

    pcf->pcgNew   = (CACHEDGLYPH*) ((BYTE*) pcg + cjCachedGlyph);
    pcf->cjAlloc -= cjCachedGlyph;

    return(pcg);
}

/******************************Public*Routine******************************\
* BOOL bMmCachedProportionalText
*
* Draws proportionally spaced glyphs via glyph caching.
*
\**************************************************************************/

BOOL bMmCachedProportionalText(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp,
LONG        cGlyph)
{
    BYTE*           pjMmBase;
    LONG            xOffset;
    LONG            yOffset;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    LONG            cyLessOne;
    LONG            x;
    LONG            y;

    pjMmBase  = ppdev->pjMmBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;

    // Ensure that there is enough room in the FIFO for the
    // coordinate and dimensions of the first glyph, so that we
    // don't accidentally hold the bus for a long to while a
    // previous big operation, such as a screen-to-screen blt,
    // is done.

    IO_FIFO_WAIT(ppdev, 4);

    do {
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg)
            pcg = pcg->pcgNext;         // Traverse collision list, if any

        if (pcg->hg > hg)
        {
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.

            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
                return(FALSE);
        }

        // Space glyphs are trimmed to a height of zero, and we don't
        // even have to touch the hardware for them:

        cyLessOne = pcg->cyLessOne;

        if (cyLessOne >= 0)
        {
            x = pgp->ptl.x + pcg->ptlOrigin.x + xOffset;
            y = pgp->ptl.y + pcg->ptlOrigin.y + yOffset;

            DBG_FAKE_WAIT(ppdev, pjMmBase, 4);  // For debug builds only

            MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, pcg->cxLessOne);
            MM_MIN_AXIS_PCNT(ppdev, pjMmBase, cyLessOne);

            MM_ABS_CUR_X(ppdev, pjMmBase, x);
            MM_ABS_CUR_Y(ppdev, pjMmBase, y);
            IO_GP_WAIT(ppdev);

            MM_CMD(ppdev, pjMmBase,
              (RECTANGLE_FILL  | WAIT          | DRAWING_DIR_TBLRXM |
               DRAW            | LAST_PIXEL_ON | MULTIPLE_PIXELS    |
               WRITE           | BYTE_SWAP     | BUS_SIZE_16));

            CHECK_DATA_READY(ppdev);

            MM_TRANSFER_WORD_ALIGNED(ppdev, pjMmBase, &pcg->ad[0], pcg->cw);

            CHECK_DATA_COMPLETE(ppdev);
        }
    } while (pgp++, --cGlyph != 0);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bMmCachedClippedText
*
* Draws clipped text via glyph caching.
*
\**************************************************************************/

BOOL bMmCachedClippedText(
PDEV*       ppdev,
CACHEDFONT* pcf,
STROBJ*     pstro,
CLIPOBJ*    pco)
{
    BOOL            bRet;
    BYTE*           pjMmBase;
    LONG            xOffset;
    LONG            yOffset;
    BOOL            bMoreGlyphs;
    ULONG           cGlyphOriginal;
    ULONG           cGlyph;
    BOOL            bClippingSet;
    GLYPHPOS*       pgpOriginal;
    GLYPHPOS*       pgp;
    LONG            xGlyph;
    LONG            yGlyph;
    LONG            x;
    LONG            y;
    LONG            xRight;
    LONG            cyLessOne;
    BOOL            bMore;
    CLIPENUM        ce;
    RECTL*          prclClip;
    ULONG           ulCharInc;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    BYTE            iDComplexity;

    bRet      = TRUE;
    pjMmBase  = ppdev->pjMmBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;
    ulCharInc = pstro->ulCharInc;

    // Ensure that there is enough room in the FIFO for the
    // coordinate and dimensions of the first glyph, so that we
    // don't accidentally hold the bus for a long to while a
    // previous big operation, such as a screen-to-screen blt,
    // is done.

    IO_FIFO_WAIT(ppdev, 4);

    do {
      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

      if (cGlyphOriginal > 0)
      {
        if (iDComplexity != DC_COMPLEX)
        {
          // We could call 'cEnumStart' and 'bEnum' when the clipping is
          // DC_RECT, but the last time I checked, those two calls took
          // more than 150 instructions to go through GDI.  Since
          // 'rclBounds' already contains the DC_RECT clip rectangle,
          // and since it's such a common case, we'll special case it:

          bMore = FALSE;
          ce.c  = 1;

          if (iDComplexity == DC_TRIVIAL)
              prclClip = &grclMax;
          else
              prclClip = &pco->rclBounds;

          goto SingleRectangle;
        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {
          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            // We don't always simply set the clipping rectangle here
            // because it may actually end up that no text intersects
            // this clip rectangle, so it would be for naught.  This
            // actually happens a lot when using NT's analog clock set
            // to always-on-top, with a round shape:

            bClippingSet = FALSE;

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;

            // We can't yet convert to absolute coordinates by adding
            // in 'xOffset' or 'yOffset' here because we have yet to
            // compare the coordinates to 'prclClip':

            xGlyph = pgp->ptl.x;
            yGlyph = pgp->ptl.y;

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              hg  = pgp->hg;
              pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

              while (pcg->hg < hg)
                pcg = pcg->pcgNext;

              if (pcg->hg > hg)
              {
                // This will hopefully not be the common case (that is,
                // we will have a high cache hit rate), so if I were
                // writing this in Asm I would have this out-of-line
                // to avoid the jump around for the common case.
                // But the Pentium has branch prediction, so what the
                // heck.

                pcg = pcgNew(ppdev, pcf, pgp);
                if (pcg == NULL)
                {
                  bRet = FALSE;
                  goto AllDone;
                }
              }

              // Space glyphs are trimmed to a height of zero, and we don't
              // even have to touch the hardware for them:

              cyLessOne = pcg->cyLessOne;
              if (cyLessOne >= 0)
              {
                y      = pcg->ptlOrigin.y + yGlyph;
                x      = pcg->ptlOrigin.x + xGlyph;
                xRight = pcg->cxLessOne + x;

                // Do trivial rejection:

                if ((prclClip->right  > x) &&
                    (prclClip->bottom > y) &&
                    (prclClip->left   <= xRight) &&
                    (prclClip->top    <= y + cyLessOne))
                {
                  // Lazily set the hardware clipping:

                  if ((iDComplexity != DC_TRIVIAL) && (!bClippingSet))
                  {
                    bClippingSet = TRUE;
                    vSetClipping(ppdev, prclClip);

                    // Wait here for same reason we do IO_FIFO_WAIT(4) above...

                    IO_FIFO_WAIT(ppdev, 4);
                  }

                  DBG_FAKE_WAIT(ppdev, pjMmBase, 4);  // For debug builds only

                  MM_MAJ_AXIS_PCNT(ppdev, pjMmBase, pcg->cxLessOne);
                  MM_MIN_AXIS_PCNT(ppdev, pjMmBase, cyLessOne);

                  MM_ABS_CUR_X(ppdev, pjMmBase, xOffset + x);
                  MM_ABS_CUR_Y(ppdev, pjMmBase, yOffset + y);

                  IO_GP_WAIT(ppdev);

                  MM_CMD(ppdev, pjMmBase,
                    (RECTANGLE_FILL  | WAIT          | DRAWING_DIR_TBLRXM |
                     DRAW            | LAST_PIXEL_ON | MULTIPLE_PIXELS    |
                     WRITE           | BYTE_SWAP     | BUS_SIZE_16));

                  CHECK_DATA_READY(ppdev);

                  MM_TRANSFER_WORD_ALIGNED(ppdev, pjMmBase, &pcg->ad[0], pcg->cw);

                  CHECK_DATA_COMPLETE(ppdev);
                }
              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;

              if (ulCharInc == 0)
              {
                xGlyph = pgp->ptl.x;
                yGlyph = pgp->ptl.y;
              }
              else
              {
                xGlyph += ulCharInc;
              }
            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);

AllDone:

    if (iDComplexity != DC_TRIVIAL)
    {
        vResetClipping(ppdev);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL bMmTextOut
*
* Outputs text using the 'buffer expansion' method.  The CPU draws to a
* 1bpp buffer, and the result is colour-expanded to the screen using the
* hardware.
*
* Note that this is x86 only ('vFastText', which draws the glyphs to the
* 1bpp buffer, is writen in Asm).
*
* If you're just getting your driver working, this is the fastest way to
* bring up working accelerated text.  All you have to do is write the
* 'Xfer1bpp' function that's also used by the blt code.  This
* 'bBufferExpansion' routine shouldn't need to be modified at all.
*
\**************************************************************************/

BOOL bMmTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque)
{
    PDEV*           ppdev;
    DSURF*          pdsurf;
    BYTE*           pjMmBase;
    BOOL            bGlyphExpand;
    BOOL            bTextPerfectFit;
    ULONG           cGlyph;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgp;
    GLYPHBITS*      pgb;
    BYTE*           pjGlyph;
    LONG            cyGlyph;
    POINTL          ptlOrigin;
    LONG            ulCharInc;
    BYTE            iDComplexity;
    LONG            lDelta;
    LONG            cw;
    RECTL           rclOpaque;
    CACHEDFONT*     pcf;

    ppdev = (PDEV*) pso->dhpdev;

    pjMmBase = ppdev->pjMmBase;

    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (prclOpaque != NULL)
    {
      ////////////////////////////////////////////////////////////
      // Opaque Initialization
      ////////////////////////////////////////////////////////////

      if (iDComplexity == DC_TRIVIAL)
      {

      DrawOpaqueRect:

        IO_FIFO_WAIT(ppdev, 8);
        MM_FRGD_COLOR(ppdev, pjMmBase, pboOpaque->iSolidColor);
        MM_PIX_CNTL(ppdev, pjMmBase, ALL_ONES);
        MM_FRGD_MIX(ppdev, pjMmBase, FOREGROUND_COLOR | OVERPAINT);
        MM_CUR_X(ppdev, pjMmBase, prclOpaque->left);
        MM_CUR_Y(ppdev, pjMmBase, prclOpaque->top);
        MM_MAJ_AXIS_PCNT(ppdev, pjMmBase,
                         prclOpaque->right  - prclOpaque->left - 1);
        MM_MIN_AXIS_PCNT(ppdev, pjMmBase,
                         prclOpaque->bottom - prclOpaque->top  - 1);

        MM_CMD(ppdev, pjMmBase, RECTANGLE_FILL | DRAWING_DIR_TBLRXM |
                                DRAW           | DIR_TYPE_XY        |
                                LAST_PIXEL_ON  | MULTIPLE_PIXELS    |
                                WRITE);
      }
      else if (iDComplexity == DC_RECT)
      {
        if (bIntersect(prclOpaque, &pco->rclBounds, &rclOpaque))
        {
          prclOpaque = &rclOpaque;
          goto DrawOpaqueRect;
        }
      }
      else
      {
        vClipSolid(ppdev, 1, prclOpaque, pboOpaque->iSolidColor, pco);
      }

      // If we paint the glyphs in 'opaque' mode, we may not actually
      // have to draw the opaquing rectangle up-front -- the process
      // of laying down all the glyphs will automatically cover all
      // of the pixels in the opaquing rectangle.
      //
      // The condition that must be satisfied is that the text must
      // fit 'perfectly' such that the entire background rectangle is
      // covered, and none of the glyphs overlap (if the glyphs
      // overlap, such as for italics, they have to be drawn in
      // transparent mode after the opaquing rectangle is cleared).

      bTextPerfectFit = (pstro->flAccel & (SO_ZERO_BEARINGS |
              SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE |
              SO_CHAR_INC_EQUAL_BM_BASE)) ==
              (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
              SO_MAXEXT_EQUAL_BM_SIDE | SO_CHAR_INC_EQUAL_BM_BASE);

      if (bTextPerfectFit)
      {
        // If the glyphs don't overlap, we can lay the glyphs down
        // in 'opaque' mode, which on the S3 I've found to be faster
        // than opaque mode:

        IO_FIFO_WAIT(ppdev, 7);

        MM_PIX_CNTL(ppdev, pjMmBase, CPU_DATA);
        MM_FRGD_MIX(ppdev, pjMmBase, FOREGROUND_COLOR | OVERPAINT);
        MM_BKGD_MIX(ppdev, pjMmBase, BACKGROUND_COLOR | OVERPAINT);
        MM_FRGD_COLOR(ppdev, pjMmBase, pboFore->iSolidColor);
        MM_BKGD_COLOR(ppdev, pjMmBase, pboOpaque->iSolidColor);
        goto SkipTransparentInitialization;
      }
    }

    ////////////////////////////////////////////////////////////
    // Transparent Initialization
    ////////////////////////////////////////////////////////////

    // Initialize the hardware for transparent text:

    IO_FIFO_WAIT(ppdev, 4);

    MM_PIX_CNTL(ppdev, pjMmBase, CPU_DATA);
    MM_FRGD_MIX(ppdev, pjMmBase, FOREGROUND_COLOR | OVERPAINT);
    MM_BKGD_MIX(ppdev, pjMmBase, BACKGROUND_COLOR | LEAVE_ALONE);
    MM_FRGD_COLOR(ppdev, pjMmBase, pboFore->iSolidColor);

  SkipTransparentInitialization:

    if ((pfo->cxMax <= GLYPH_CACHE_CX) &&
        ((pstro->rclBkGround.bottom - pstro->rclBkGround.top) <= GLYPH_CACHE_CY))
    {
      pcf = (CACHEDFONT*) pfo->pvConsumer;

      if (pcf == NULL)
      {
        pcf = pcfAllocateCachedFont(ppdev);
        if (pcf == NULL)
          return(FALSE);

        pfo->pvConsumer = pcf;
      }

      // Use our glyph cache:

      if ((iDComplexity == DC_TRIVIAL) && (pstro->ulCharInc == 0))
      {
        do {
          if (pstro->pgp != NULL)
          {
            // There's only the one batch of glyphs, so save ourselves
            // a call:

            pgp         = pstro->pgp;
            cGlyph      = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
          }
          else
          {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
          }

          if (cGlyph > 0)
          {
            if (!bMmCachedProportionalText(ppdev, pcf, pgp, cGlyph))
              return(FALSE);
          }
        } while (bMoreGlyphs);
      }
      else
      {
        if (!bMmCachedClippedText(ppdev, pcf, pstro, pco))
          return(FALSE);
      }
    }
    else
    {
      DISPDBG((4, "Text too big to cache: %li x %li",
          pfo->cxMax, pstro->rclBkGround.bottom - pstro->rclBkGround.top));

      vMmGeneralText(ppdev, pstro, pco);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bNwCachedProportionalText
*
* Draws proportionally spaced glyphs via glyph caching.
*
\**************************************************************************/

BOOL bNwCachedProportionalText(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp,
LONG        cGlyph)
{
    BYTE*           pjMmBase;
    LONG            xOffset;
    LONG            yOffset;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    LONG            cxcyLessOne;
    LONG            x;
    LONG            y;
    USHORT          busmode = BUS_SIZE_16;

    pjMmBase  = ppdev->pjMmBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;

    // Ensure that there is enough room in the FIFO for the
    // coordinate and dimensions of the first glyph, so that we
    // don't accidentally hold the bus for a long to while a
    // previous big operation, such as a screen-to-screen blt,
    // is done.

    NW_FIFO_WAIT(ppdev, pjMmBase, 2);

    if (ppdev->iBitmapFormat == BMF_24BPP)
        busmode = BUS_SIZE_32;

    do {
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg)
            pcg = pcg->pcgNext;         // Traverse collision list, if any

        if (pcg->hg > hg)
        {
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.

            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
                return(FALSE);
        }

        // Space glyphs are trimmed to a height of zero, and we don't
        // even have to touch the hardware for them:

        cxcyLessOne = pcg->cxcyLessOne;

        if (cxcyLessOne >= 0)
        {
            x = pgp->ptl.x + pcg->ptlOrigin.x + xOffset;
            y = pgp->ptl.y + pcg->ptlOrigin.y + yOffset;

            DBG_FAKE_WAIT(ppdev, pjMmBase, 2);  // For debug builds only

            NW_ABS_CURXY_FAST(ppdev, pjMmBase, x, y);
            NW_ALT_PCNT_PACKED(ppdev, pjMmBase, cxcyLessOne);

            NW_GP_WAIT(ppdev, pjMmBase);

            NW_ALT_CMD(ppdev, pjMmBase,
              (RECTANGLE_FILL  | WAIT          | DRAWING_DIR_TBLRXM |
               DRAW            | LAST_PIXEL_ON | MULTIPLE_PIXELS    |
               WRITE           | BYTE_SWAP     | busmode));

            CHECK_DATA_READY(ppdev);

            #if defined(_X86_)

                memcpy(pjMmBase, &pcg->ad[0], pcg->cd << 2);

            #else

                // Non-x86 platforms may be required to call the HAL to
                // the I/O, or to do memory barriers:

                MM_TRANSFER_DWORD_ALIGNED(ppdev, pjMmBase, &pcg->ad[0], pcg->cd);

            #endif

            CHECK_DATA_COMPLETE(ppdev);
        }
    } while (pgp++, --cGlyph != 0);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bNwCachedClippedText
*
* Draws clipped text via glyph caching.
*
\**************************************************************************/

BOOL bNwCachedClippedText(
PDEV*       ppdev,
CACHEDFONT* pcf,
STROBJ*     pstro,
CLIPOBJ*    pco)
{
    BOOL            bRet;
    BYTE*           pjMmBase;
    LONG            xOffset;
    LONG            yOffset;
    BOOL            bMoreGlyphs;
    ULONG           cGlyphOriginal;
    ULONG           cGlyph;
    BOOL            bClippingSet;
    GLYPHPOS*       pgpOriginal;
    GLYPHPOS*       pgp;
    LONG            xGlyph;
    LONG            yGlyph;
    LONG            x;
    LONG            y;
    LONG            xRight;
    LONG            cyLessOne;
    BOOL            bMore;
    CLIPENUM        ce;
    RECTL*          prclClip;
    ULONG           ulCharInc;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    BYTE            iDComplexity;
    USHORT          busmode = BUS_SIZE_16;

    bRet      = TRUE;
    pjMmBase  = ppdev->pjMmBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;
    ulCharInc = pstro->ulCharInc;

    // Ensure that there is enough room in the FIFO for the
    // coordinate and dimensions of the first glyph, so that we
    // don't accidentally hold the bus for a long to while a
    // previous big operation, such as a screen-to-screen blt,
    // is done.

    NW_FIFO_WAIT(ppdev, pjMmBase, 2);

    if (ppdev->iBitmapFormat == BMF_24BPP)
        busmode = BUS_SIZE_32;

    do {
      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

      if (cGlyphOriginal > 0)
      {
        if (iDComplexity != DC_COMPLEX)
        {
          // We could call 'cEnumStart' and 'bEnum' when the clipping is
          // DC_RECT, but the last time I checked, those two calls took
          // more than 150 instructions to go through GDI.  Since
          // 'rclBounds' already contains the DC_RECT clip rectangle,
          // and since it's such a common case, we'll special case it:

          bMore = FALSE;
          ce.c  = 1;

          if (iDComplexity == DC_TRIVIAL)
              prclClip = &grclMax;
          else
              prclClip = &pco->rclBounds;

          goto SingleRectangle;
        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {
          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            // We don't always simply set the clipping rectangle here
            // because it may actually end up that no text intersects
            // this clip rectangle, so it would be for naught.  This
            // actually happens a lot when using NT's analog clock set
            // to always-on-top, with a round shape:

            bClippingSet = FALSE;

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;

            // We can't yet convert to absolute coordinates by adding
            // in 'xOffset' or 'yOffset' here because we have yet to
            // compare the coordinates to 'prclClip':

            xGlyph = pgp->ptl.x;
            yGlyph = pgp->ptl.y;

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              hg  = pgp->hg;
              pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

              while (pcg->hg < hg)
                pcg = pcg->pcgNext;

              if (pcg->hg > hg)
              {
                // This will hopefully not be the common case (that is,
                // we will have a high cache hit rate), so if I were
                // writing this in Asm I would have this out-of-line
                // to avoid the jump around for the common case.
                // But the Pentium has branch prediction, so what the
                // heck.

                pcg = pcgNew(ppdev, pcf, pgp);
                if (pcg == NULL)
                {
                  bRet = FALSE;
                  goto AllDone;
                }
              }

              // Space glyphs are trimmed to a height of zero, and we don't
              // even have to touch the hardware for them:

              cyLessOne = pcg->cyLessOne;
              if (cyLessOne >= 0)
              {
                y      = pcg->ptlOrigin.y + yGlyph;
                x      = pcg->ptlOrigin.x + xGlyph;
                xRight = pcg->cxLessOne + x;

                // Do trivial rejection:

                if ((prclClip->right  > x) &&
                    (prclClip->bottom > y) &&
                    (prclClip->left   <= xRight) &&
                    (prclClip->top    <= y + cyLessOne))
                {
                  // Lazily set the hardware clipping:

                  if ((iDComplexity != DC_TRIVIAL) && (!bClippingSet))
                  {
                    bClippingSet = TRUE;
                    vSetClipping(ppdev, prclClip);

                    // Wait here for same reason we do NW_FIFO_WAIT(2) above...

                    NW_FIFO_WAIT(ppdev, pjMmBase, 2);
                  }

                  DBG_FAKE_WAIT(ppdev, pjMmBase, 2);  // For debug builds only

                  NW_ABS_CURXY(ppdev, pjMmBase, xOffset + x, yOffset + y);
                  NW_ALT_PCNT_PACKED(ppdev, pjMmBase, pcg->cxcyLessOne);

                  NW_GP_WAIT(ppdev, pjMmBase);

                  NW_ALT_CMD(ppdev, pjMmBase,
                    (RECTANGLE_FILL  | WAIT          | DRAWING_DIR_TBLRXM |
                     DRAW            | LAST_PIXEL_ON | MULTIPLE_PIXELS    |
                     WRITE           | BYTE_SWAP     | busmode));

                  CHECK_DATA_READY(ppdev);

                  MM_TRANSFER_DWORD_ALIGNED(ppdev, pjMmBase, &pcg->ad[0], pcg->cd);

                  CHECK_DATA_COMPLETE(ppdev);
                }
              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;

              if (ulCharInc == 0)
              {
                xGlyph = pgp->ptl.x;
                yGlyph = pgp->ptl.y;
              }
              else
              {
                xGlyph += ulCharInc;
              }
            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);

AllDone:

    if (iDComplexity != DC_TRIVIAL)
    {
        vResetClipping(ppdev);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL bNwTextOut
*
* Outputs text using the 'buffer expansion' method.  The CPU draws to a
* 1bpp buffer, and the result is colour-expanded to the screen using the
* hardware.
*
* Note that this is x86 only ('vFastText', which draws the glyphs to the
* 1bpp buffer, is writen in Asm).
*
* If you're just getting your driver working, this is the fastest way to
* bring up working accelerated text.  All you have to do is write the
* 'Xfer1bpp' function that's also used by the blt code.  This
* 'bBufferExpansion' routine shouldn't need to be modified at all.
*
\**************************************************************************/

BOOL bNwTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque)
{
    PDEV*           ppdev;
    DSURF*          pdsurf;
    BYTE*           pjMmBase;
    BOOL            bGlyphExpand;
    BOOL            bTextPerfectFit;
    ULONG           cGlyph;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgp;
    GLYPHBITS*      pgb;
    BYTE*           pjGlyph;
    LONG            cyGlyph;
    POINTL          ptlOrigin;
    LONG            ulCharInc;
    BYTE            iDComplexity;
    LONG            lDelta;
    LONG            cw;
    RECTL           rclOpaque;
    CACHEDFONT*     pcf;
    LONG            xOffset;
    LONG            yOffset;

    ppdev = (PDEV*) pso->dhpdev;

    pjMmBase = ppdev->pjMmBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (prclOpaque != NULL)
    {
      ////////////////////////////////////////////////////////////
      // Opaque Initialization
      ////////////////////////////////////////////////////////////

      if (iDComplexity == DC_TRIVIAL)
      {

      DrawOpaqueRect:

        NW_FIFO_WAIT(ppdev, pjMmBase, 6);
        NW_FRGD_COLOR(ppdev, pjMmBase, pboOpaque->iSolidColor);
        MM_PIX_CNTL(ppdev, pjMmBase, ALL_ONES);
        MM_FRGD_MIX(ppdev, pjMmBase, FOREGROUND_COLOR | OVERPAINT);
        NW_ABS_CURXY_FAST(ppdev, pjMmBase, prclOpaque->left + xOffset,
                                           prclOpaque->top + yOffset);
        NW_ALT_PCNT(ppdev, pjMmBase,
                           prclOpaque->right  - prclOpaque->left - 1,
                           prclOpaque->bottom - prclOpaque->top  - 1);

        NW_ALT_CMD(ppdev, pjMmBase, RECTANGLE_FILL | DRAWING_DIR_TBLRXM |
                                    DRAW           | DIR_TYPE_XY        |
                                    LAST_PIXEL_ON  | MULTIPLE_PIXELS    |
                                    WRITE);
      }
      else if (iDComplexity == DC_RECT)
      {
        if (bIntersect(prclOpaque, &pco->rclBounds, &rclOpaque))
        {
          prclOpaque = &rclOpaque;
          goto DrawOpaqueRect;
        }
      }
      else
      {
        vClipSolid(ppdev, 1, prclOpaque, pboOpaque->iSolidColor, pco);
      }

      // If we paint the glyphs in 'opaque' mode, we may not actually
      // have to draw the opaquing rectangle up-front -- the process
      // of laying down all the glyphs will automatically cover all
      // of the pixels in the opaquing rectangle.
      //
      // The condition that must be satisfied is that the text must
      // fit 'perfectly' such that the entire background rectangle is
      // covered, and none of the glyphs overlap (if the glyphs
      // overlap, such as for italics, they have to be drawn in
      // transparent mode after the opaquing rectangle is cleared).

      bTextPerfectFit = (pstro->flAccel & (SO_ZERO_BEARINGS |
              SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE |
              SO_CHAR_INC_EQUAL_BM_BASE)) ==
              (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
              SO_MAXEXT_EQUAL_BM_SIDE | SO_CHAR_INC_EQUAL_BM_BASE);

      if (bTextPerfectFit)
      {
        // If the glyphs don't overlap, we can lay the glyphs down
        // in 'opaque' mode, which on the S3 I've found to be faster
        // than opaque mode:

        NW_FIFO_WAIT(ppdev, pjMmBase, 4);

        MM_PIX_CNTL(ppdev, pjMmBase, CPU_DATA);
        NW_ALT_MIX(ppdev, pjMmBase,  FOREGROUND_COLOR | OVERPAINT,
                                     BACKGROUND_COLOR | OVERPAINT);
        NW_FRGD_COLOR(ppdev, pjMmBase, pboFore->iSolidColor);
        NW_BKGD_COLOR(ppdev, pjMmBase, pboOpaque->iSolidColor);
        goto SkipTransparentInitialization;
      }
    }

    ////////////////////////////////////////////////////////////
    // Transparent Initialization
    ////////////////////////////////////////////////////////////

    // Initialize the hardware for transparent text:

    NW_FIFO_WAIT(ppdev, pjMmBase, 3);

    MM_PIX_CNTL(ppdev, pjMmBase, CPU_DATA);
    NW_ALT_MIX(ppdev, pjMmBase, FOREGROUND_COLOR | OVERPAINT,
                                BACKGROUND_COLOR | LEAVE_ALONE);
    NW_FRGD_COLOR(ppdev, pjMmBase, pboFore->iSolidColor);

  SkipTransparentInitialization:

    if ((pfo->cxMax <= GLYPH_CACHE_CX) &&
        ((pstro->rclBkGround.bottom - pstro->rclBkGround.top) <= GLYPH_CACHE_CY))
    {
      pcf = (CACHEDFONT*) pfo->pvConsumer;

      if (pcf == NULL)
      {
        pcf = pcfAllocateCachedFont(ppdev);
        if (pcf == NULL)
          return(FALSE);

        pfo->pvConsumer = pcf;
      }

      // Use our glyph cache:

      if ((iDComplexity == DC_TRIVIAL) && (pstro->ulCharInc == 0))
      {
        do {
          if (pstro->pgp != NULL)
          {
            // There's only the one batch of glyphs, so save ourselves
            // a call:

            pgp         = pstro->pgp;
            cGlyph      = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
          }
          else
          {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
          }

          if (cGlyph > 0)
          {
            if (!bNwCachedProportionalText(ppdev, pcf, pgp, cGlyph))
              return(FALSE);
          }
        } while (bMoreGlyphs);
      }
      else
      {
        if (!bNwCachedClippedText(ppdev, pcf, pstro, pco))
          return(FALSE);
      }
    }
    else
    {
      DISPDBG((4, "Text too big to cache: %li x %li",
        pfo->cxMax, pstro->rclBkGround.bottom - pstro->rclBkGround.top));

      // Can't do large glyphs via accelerator at 24bpp:

      if (ppdev->iBitmapFormat == BMF_24BPP)
      {
          BANK    bnk;
          BOOL    b = TRUE;

          vBankStart(ppdev,
                     (prclOpaque!= NULL) ? prclOpaque : &pstro->rclBkGround,
                     pco,
                     &bnk);
          do  {
              b &= EngTextOut(bnk.pso,
                              pstro,
                              pfo,
                              bnk.pco,
                              NULL,
                              prclOpaque,
                              pboFore,
                              pboOpaque,
                              NULL,
                              0x0d0d);

          } while (bBankEnum(&bnk));

          return b;
      }

      vMmGeneralText(ppdev, pstro, pco);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL DrvTextOut
*
* Calls the appropriate text drawing routine.
*
\**************************************************************************/

BOOL DrvTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,    // If we had set GCAPS_HORIZSTRIKE, we would have
                        //   to fill these extra rectangles (it is used
                        //   largely for underlines).  It's not a big
                        //   performance win (GDI will call our DrvBitBlt
                        //   to draw the extra rectangles).
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlBrush,    // Always unused, unless GCAPS_ARBRUSHOPAQUE set
MIX       mix)          // Always a copy mix -- 0x0d0d
{
    PDEV*           ppdev;
    DSURF*          pdsurf;

    pdsurf = (DSURF*) pso->dhsurf;
    ppdev  = (PDEV*) pso->dhpdev;

    ASSERTDD(!(pdsurf->dt & DT_DIB), "Didn't expect DT_DIB");

    ppdev->xOffset = pdsurf->x;
    ppdev->yOffset = pdsurf->y;
    
    // There seems to be a problem with 24 bpp accelerated large text
    // on s3 diamond 968 so for now, punt to GDI
    
    // The DDI spec says we'll only ever get foreground and background
    // mixes of R2_COPYPEN:
    
    ASSERTDD(mix == 0x0d0d, "GDI should only give us a copy mix");

    return(ppdev->pfnTextOut(pso, pstro, pfo, pco, prclOpaque, pboFore,
                             pboOpaque));
}

/******************************Public*Routine******************************\
* BOOL bEnableText
*
* Performs the necessary setup for the text drawing subcomponent.
*
\**************************************************************************/

BOOL bEnableText(
PDEV*   ppdev)
{
    SIZEL   sizl;
    HBITMAP hbm;

    if (ppdev->pfnTextOut == bIoTextOut)
    {
        // We need to allocate a temporary 1bpp surface object if we're
        // going to have GDI draw the glyphs for us:

        sizl.cx = ppdev->cxMemory;
        sizl.cy = ppdev->cyMemory;

        // We will be mucking with the surface's 'pvScan0' value, so we
        // simply must pass in a non-NULL 'pvBits' value to EngCreateBitmap:

        hbm = EngCreateBitmap(sizl, sizl.cx, BMF_1BPP, 0, ppdev->pvTmpBuffer);
        if (hbm == 0)
            return(FALSE);

        ppdev->psoText = EngLockSurface((HSURF) hbm);
        if (ppdev->psoText == NULL)
        {
            EngDeleteSurface((HSURF) hbm);
            return(FALSE);
        }
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableText
*
* Performs the necessary clean-up for the text drawing subcomponent.
*
\**************************************************************************/

VOID vDisableText(PDEV* ppdev)
{
    HSURF       hsurf;
    SURFOBJ*    psoText;

    // Here we free any stuff allocated in 'bEnableText'.

    psoText = ppdev->psoText;

    if (psoText != NULL)
    {
        hsurf = psoText->hsurf;

        EngUnlockSurface(psoText);
        EngDeleteSurface(hsurf);
    }
}

/******************************Public*Routine******************************\
* VOID vAssertModeText
*
* Disables or re-enables the text drawing subcomponent in preparation for
* full-screen entry/exit.
*
\**************************************************************************/

VOID vAssertModeText(
PDEV*   ppdev,
BOOL    bEnable)
{
    // If we were to do off-screen glyph caching, we would probably want
    // to invalidate our cache here, because it will get destroyed when
    // we switch to full-screen.
}

/******************************Public*Routine******************************\
* VOID DrvDestroyFont
*
* Note: Don't forget to export this call in 'enable.c', otherwise you'll
*       get some pretty big memory leaks!
*
* We're being notified that the given font is being deallocated; clean up
* anything we've stashed in the 'pvConsumer' field of the 'pfo'.
*
\**************************************************************************/

VOID DrvDestroyFont(
FONTOBJ*    pfo)
{
    CACHEDFONT* pcf;

    pcf = pfo->pvConsumer;
    if (pcf != NULL)
    {
        vFreeCachedFont(pcf);
        pfo->pvConsumer = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\stretch.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: stretch.c
*
* Copyright (c) 1993-1998 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define STRETCH_MAX_EXTENT 32767

typedef DWORDLONG ULONGLONG;

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch8Narrow
*
* Routine Description:
*
*   Stretch blt 8->8 when the width is 7 or less
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch8Narrow(
STR_BLT* pStrBlt)
{
    BYTE*   pjSrc;
    BYTE*   pjDstEnd;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;

    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc;
    BYTE*   pjDst       = pStrBlt->pjDstScan + xDst;
    LONG    yCount      = pStrBlt->YDstCount;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - WidthX;
    ULONG   yInt        = 0;

    yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;

    //
    // Narrow blt
    //

    do {

        ULONG  yTmp = yAccum + yFrac;
        BYTE   jSrc0;
        BYTE*  pjDstEndNarrow = pjDst + WidthX;

        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        do {
            jSrc0    = *pjSrc;
            xTmp     = xAccum + xFrac;
            pjSrc    = pjSrc + xInt;
            if (xTmp < xAccum)
                pjSrc++;

            *pjDst++ = jSrc0;
            xAccum   = xTmp;
        } while (pjDst != pjDstEndNarrow);

        pjSrcScan += yInt;

        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }

        yAccum = yTmp;
        pjDst += lDstStride;

    } while (--yCount);

}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch32
*
* Routine Description:
*
*   Stretch blt 32->32
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch32(
STR_BLT* pStrBlt)
{
    BYTE*   pjOldScan;
    ULONG*  pulSrc;
    ULONG*  pulDstEnd;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc * 4;
    ULONG*  pulDst      = (ULONG*)(pStrBlt->pjDstScan) + xDst;
    LONG    yDst        = pStrBlt->YDstStart + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - 4*WidthX;
    ULONG   yInt        = 0;

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    do {

        ULONG   ulSrc;
        ULONG   yTmp;

        pulSrc  = (ULONG*) pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        //
        // a single src scan line is being written
        //

        pulDstEnd  = pulDst + WidthX;

        while (pulDst != pulDstEnd)
        {

            ulSrc  = *pulSrc;
            xTmp   = xAccum + xFrac;
            pulSrc = pulSrc + xInt;
            if (xTmp < xAccum)
                pulSrc++;

            *(ULONG*)pulDst = ulSrc;
            pulDst++;
            xAccum = xTmp;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pulDst = (ULONG*) ((BYTE*) pulDst + lDstStride);
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pulDst = (ULONG*) ((BYTE*) pulDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.  On the S3, we have to turn off frame-buffer
            // access before touching the accelerator registers:

            ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_OFF);

            IO_FIFO_WAIT(ppdev, 4);
            IO_MIN_AXIS_PCNT(ppdev, cyDuplicate - 1);
            IO_ABS_DEST_Y(ppdev, yDst);
            IO_ABS_CUR_Y(ppdev, yDst - 1);
            IO_CMD(ppdev, (BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                           DRAWING_DIR_TBLRXM));

            yDst += cyDuplicate;

            ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, ppdev->bankmOnOverlapped);
        }
    } while (yCount != 0);
}

/******************************Public*Routine******************************\
*
* Routine Description:
*
*   StretchBlt using integer math. Must be from one surface to another
*   surface of the same format.
*
* Arguments:
*
*   ppdev           -   PDEV for device
*   pvDst           -   Pointer to start of dst bitmap
*   lDeltaDst       -   Bytes from start of dst scan line to start of next
*   DstCx           -   Width of Dst Bitmap in pixels
*   DstCy           -   Height of Dst Bitmap in pixels
*   prclDst         -   Pointer to rectangle of Dst extents
*   pvSrc           -   Pointer to start of Src bitmap
*   lDeltaSrc       -   Bytes from start of Src scan line to start of next
*   SrcCx           -   Width of Src Bitmap in pixels
*   SrcCy           -   Height of Src Bitmap in pixels
*   prclSrc         -   Pointer to rectangle of Src extents
*   prclSClip       -   Clip Dest to this rect
*
* Return Value:
*
*   Status
*
\**************************************************************************/

BOOL bStretchDIB(
PDEV*   ppdev,
VOID*   pvDst,
LONG    lDeltaDst,
RECTL*  prclDst,
VOID*   pvSrc,
LONG    lDeltaSrc,
RECTL*  prclSrc,
RECTL*  prclClip)
{
    STR_BLT StrBlt;
    ULONG   XSrcToDstIntFloor;
    ULONG   XSrcToDstFracFloor;
    ULONG   ulXDstToSrcIntCeil;
    ULONG   ulXDstToSrcFracCeil;
    ULONG   YSrcToDstIntFloor;
    ULONG   YSrcToDstFracFloor;
    ULONG   ulYDstToSrcIntCeil;
    ULONG   ulYDstToSrcFracCeil;
    LONG    SrcIntScan;
    LONG    DstDeltaScanEnd;
    ULONG   ulXFracAccumulator;
    ULONG   ulYFracAccumulator;
    LONG    LeftClipDistance;
    LONG    TopClipDistance;
    BOOL    bStretch;

    union {
        LARGE_INTEGER   large;
        ULONGLONG       li;
    } liInit;

    PFN_DIRSTRETCH      pfnStr;

    //
    // Calculate exclusive start and end points:
    //

    LONG    WidthDst  = prclDst->right  - prclDst->left;
    LONG    HeightDst = prclDst->bottom - prclDst->top;
    LONG    WidthSrc  = prclSrc->right  - prclSrc->left;
    LONG    HeightSrc = prclSrc->bottom - prclSrc->top;

    LONG    XSrcStart = prclSrc->left;
    LONG    XSrcEnd   = prclSrc->right;
    LONG    XDstStart = prclDst->left;
    LONG    XDstEnd   = prclDst->right;
    LONG    YSrcStart = prclSrc->top;
    LONG    YSrcEnd   = prclSrc->bottom;
    LONG    YDstStart = prclDst->top;
    LONG    YDstEnd   = prclDst->bottom;

    //
    // Validate parameters:
    //

    ASSERTDD(pvDst != (VOID*)NULL, "Bad destination bitmap pointer");
    ASSERTDD(pvSrc != (VOID*)NULL, "Bad source bitmap pointer");
    ASSERTDD(prclDst != (RECTL*)NULL, "Bad destination rectangle");
    ASSERTDD(prclSrc != (RECTL*)NULL, "Bad source rectangle");
    ASSERTDD((WidthDst > 0) && (HeightDst > 0) &&
             (WidthSrc > 0) && (HeightSrc > 0),
             "Can't do mirroring or empty rectangles here");
    ASSERTDD((WidthDst  <= STRETCH_MAX_EXTENT) &&
             (HeightDst <= STRETCH_MAX_EXTENT) &&
             (WidthSrc  <= STRETCH_MAX_EXTENT) &&
             (HeightSrc <= STRETCH_MAX_EXTENT), "Stretch exceeds limits");
    ASSERTDD(prclClip != NULL, "Bad clip rectangle");

    //
    // Calculate X Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*WidthSrc)/WidthDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*WidthSrc -1) / WidthDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {
        ULONGLONG   liWidthSrc;
        ULONGLONG   liQuo;
        ULONG       ulTemp;

        //
        // Work around a compiler bug dealing with the assignment
        // 'liHeightSrc = (((LONGLONG)HeightSrc) << 32) - 1':
        //

        liInit.large.LowPart = (ULONG) -1;
        liInit.large.HighPart = WidthSrc - 1;
        liWidthSrc = liInit.li;

        liQuo = liWidthSrc / (ULONGLONG) WidthDst;

        ulXDstToSrcIntCeil  = (ULONG)(liQuo >> 32);
        ulXDstToSrcFracCeil = (ULONG)liQuo;

        //
        // Now add 1, use fake carry:
        //

        ulTemp = ulXDstToSrcFracCeil + 1;

        ulXDstToSrcIntCeil += (ulTemp < ulXDstToSrcFracCeil);
        ulXDstToSrcFracCeil = ulTemp;
    }

    //
    // Calculate Y Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*HeightSrc)/HeightDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*HeightSrc -1) / HeightDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {
        ULONGLONG   liHeightSrc;
        ULONGLONG   liQuo;
        ULONG       ulTemp;

        //
        // Work around a compiler bug dealing with the assignment
        // 'liHeightSrc = (((LONGLONG)HeightSrc) << 32) - 1':
        //

        liInit.large.LowPart = (ULONG) -1;
        liInit.large.HighPart = HeightSrc - 1;
        liHeightSrc = liInit.li;

        liQuo = liHeightSrc / (ULONGLONG) HeightDst;

        ulYDstToSrcIntCeil  = (ULONG)(liQuo >> 32);
        ulYDstToSrcFracCeil = (ULONG)liQuo;

        //
        // Now add 1, use fake carry:
        //

        ulTemp = ulYDstToSrcFracCeil + 1;

        ulYDstToSrcIntCeil += (ulTemp < ulYDstToSrcFracCeil);
        ulYDstToSrcFracCeil = ulTemp;
    }

    //
    // Now clip Dst in X, and/or calc src clipping effect on dst
    //
    // adjust left and right edges if needed, record
    // distance adjusted for fixing the src
    //

    if (XDstStart < prclClip->left)
    {
        XDstStart = prclClip->left;
    }

    if (XDstEnd > prclClip->right)
    {
        XDstEnd = prclClip->right;
    }

    //
    // Check for totally clipped out destination:
    //

    if (XDstEnd <= XDstStart)
    {
        return(TRUE);
    }

    LeftClipDistance = XDstStart - prclDst->left;

    {
        ULONG   ulTempInt;
        ULONG   ulTempFrac;

        //
        // Calculate displacement for .5 in destination and add:
        //

        ulTempFrac = (ulXDstToSrcFracCeil >> 1) | (ulXDstToSrcIntCeil << 31);
        ulTempInt  = (ulXDstToSrcIntCeil >> 1);

        XSrcStart += ulTempInt;
        ulXFracAccumulator = ulTempFrac;

        if (LeftClipDistance != 0)
        {
            ULONGLONG ullFraction;
            ULONG     ulTmp;

            ullFraction = UInt32x32To64(ulXDstToSrcFracCeil, LeftClipDistance);

            ulTmp = ulXFracAccumulator;
            ulXFracAccumulator += (ULONG) (ullFraction);
            if (ulXFracAccumulator < ulTmp)
                XSrcStart++;

            XSrcStart += (ulXDstToSrcIntCeil * LeftClipDistance)
                       + (ULONG) (ullFraction >> 32);
        }
    }

    //
    // Now clip Dst in Y, and/or calc src clipping effect on dst
    //
    // adjust top and bottom edges if needed, record
    // distance adjusted for fixing the src
    //

    if (YDstStart < prclClip->top)
    {
        YDstStart = prclClip->top;
    }

    if (YDstEnd > prclClip->bottom)
    {
        YDstEnd = prclClip->bottom;
    }

    //
    // Check for totally clipped out destination:
    //

    if (YDstEnd <= YDstStart)
    {
        return(TRUE);
    }

    TopClipDistance = YDstStart - prclDst->top;

    {
        ULONG   ulTempInt;
        ULONG   ulTempFrac;

        //
        // Calculate displacement for .5 in destination and add:
        //

        ulTempFrac = (ulYDstToSrcFracCeil >> 1) | (ulYDstToSrcIntCeil << 31);
        ulTempInt  = ulYDstToSrcIntCeil >> 1;

        YSrcStart += (LONG)ulTempInt;
        ulYFracAccumulator = ulTempFrac;

        if (TopClipDistance != 0)
        {
            ULONGLONG ullFraction;
            ULONG     ulTmp;

            ullFraction = UInt32x32To64(ulYDstToSrcFracCeil, TopClipDistance);

            ulTmp = ulYFracAccumulator;
            ulYFracAccumulator += (ULONG) (ullFraction);
            if (ulYFracAccumulator < ulTmp)
                YSrcStart++;

            YSrcStart += (ulYDstToSrcIntCeil * TopClipDistance)
                       + (ULONG) (ullFraction >> 32);
        }
    }

    //
    // Warm up the hardware if doing an expanding stretch in 'y':
    //

    bStretch = (HeightDst > HeightSrc);
    if (bStretch)
    {
        LONG x;

        //
        // We'll be banging on the CRTC registers whenever we enable
        // and disable direct frame buffer access; we can't have the
        // cursor thread banging on them at the same.  So we grab the
        // CRTC critical section for the duration of the StretchBlt.
        //
        // Note that this CRTC critical section problem and the bank
        // mode selection logic are rather S3 specific -- other video
        // cards shouldn't have to worry about this.
        //

        ACQUIRE_CRTC_CRITICAL_SECTION(ppdev);

        //
        // Set up the left and right blt edges, since they never change
        // during the StretchBlt
        //

        ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_OFF);

        IO_FIFO_WAIT(ppdev, 5);
        IO_FRGD_MIX(ppdev, SRC_DISPLAY_MEMORY | OVERPAINT);
        IO_PIX_CNTL(ppdev, ALL_ONES);
        IO_CUR_X(ppdev, XDstStart);
        IO_DEST_X(ppdev, XDstStart);
        IO_MAJ_AXIS_PCNT(ppdev, XDstEnd - XDstStart - 1);

        ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, ppdev->bankmOnOverlapped);
    }

    //
    // Fill out blt structure, then call format-specific stretch code
    //

    StrBlt.ppdev     = ppdev;
    StrBlt.XDstEnd   = XDstEnd;
    StrBlt.YDstStart = YDstStart;
    StrBlt.YDstCount = YDstEnd - YDstStart;

    if (StrBlt.YDstCount > 0)
    {
        //
        // Caclulate starting scan line address.  Since the inner loop
        // routines are format dependent, they must add XDstStart/XSrcStart
        // to pjDstScan/pjSrcScan to get the actual starting pixel address.
        //

        StrBlt.pjSrcScan           = (BYTE*) pvSrc + (YSrcStart * lDeltaSrc);
        StrBlt.pjDstScan           = (BYTE*) pvDst + (YDstStart * lDeltaDst);

        StrBlt.lDeltaSrc           = lDeltaSrc;
        StrBlt.XSrcStart           = XSrcStart;
        StrBlt.XDstStart           = XDstStart;
        StrBlt.lDeltaDst           = lDeltaDst;
        StrBlt.ulXDstToSrcIntCeil  = ulXDstToSrcIntCeil;
        StrBlt.ulXDstToSrcFracCeil = ulXDstToSrcFracCeil;
        StrBlt.ulYDstToSrcIntCeil  = ulYDstToSrcIntCeil;
        StrBlt.ulYDstToSrcFracCeil = ulYDstToSrcFracCeil;
        StrBlt.ulXFracAccumulator  = ulXFracAccumulator;
        StrBlt.ulYFracAccumulator  = ulYFracAccumulator;

        if (ppdev->iBitmapFormat == BMF_8BPP)
        {
            if ((XDstEnd - XDstStart) < 7)
                pfnStr = vDirectStretch8Narrow;
            else
                pfnStr = vDirectStretch8;
        }
        else if (ppdev->iBitmapFormat == BMF_16BPP)
        {
            pfnStr = vDirectStretch16;
        }
        else
        {
            ASSERTDD(ppdev->iBitmapFormat == BMF_32BPP,
                    "Only handle stretchs at 8, 16 and 32bpp");

            pfnStr = vDirectStretch32;
        }

        (*pfnStr)(&StrBlt);
    }

    if (bStretch)
    {
        RELEASE_CRTC_CRITICAL_SECTION(ppdev);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bBankedStretch
*
\**************************************************************************/

BOOL bBankedStretch(
PDEV*   ppdev,
VOID*   pvDst,
LONG    lDeltaDst,
RECTL*  prclDst,
VOID*   pvSrc,
LONG    lDeltaSrc,
RECTL*  prclSrc,
RECTL*  prclClip)
{
    BANK    bnk;
    BOOL    b;
    RECTL   rclDst;

    b = TRUE;
    if (bIntersect(prclDst, prclClip, &rclDst))
    {
        vBankStart(ppdev, &rclDst, NULL, &bnk);

        do {
            b &= bStretchDIB(ppdev,
                             bnk.pso->pvScan0,
                             lDeltaDst,
                             prclDst,
                             pvSrc,
                             lDeltaSrc,
                             prclSrc,
                             &bnk.pco->rclBounds);

        } while (bBankEnum(&bnk));
    }

    return(b);
}

/******************************Public*Routine******************************\
* BOOL DrvStretchBlt
*
\**************************************************************************/

BOOL DrvStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMsk,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMsk,
ULONG               iMode)
{
    DSURF*  pdsurfSrc;
    DSURF*  pdsurfDst;
    PDEV*   ppdev;

    // GDI guarantees us that for a StretchBlt the destination surface
    // will always be a device surface, and not a DIB:

    ppdev = (PDEV*) psoDst->dhpdev;

    // It's quicker for GDI to do a StretchBlt when the source surface
    // is not a device-managed surface, because then it can directly
    // read the source bits without having to allocate a temporary
    // buffer and call DrvCopyBits to get a copy that it can use.

    if (psoSrc->iType == STYPE_DEVBITMAP)
    {
        goto Punt_It;
    }

    pdsurfDst = (DSURF*) psoDst->dhsurf;
    ASSERTDD(!(pdsurfDst->dt & DT_DIB), "Didn't expect DT_DIB");

    ppdev->xOffset = pdsurfDst->x;
    ppdev->yOffset = pdsurfDst->y;

    // Our special-case StretchBlt code assumes a dense frame buffer
    // space, so this code can't be executed when using sparse space
    // on the Alpha.  Note that since we don't read from the frame
    // buffer, we can allow this to go through even when
    // CAPS_NO_DIRECT_ACCESS is set on the PPC.

    if (DENSE(ppdev))
    {
        RECTL       rclClip;
        RECTL*      prclClip;
        ULONG       cxDst;
        ULONG       cyDst;
        ULONG       cxSrc;
        ULONG       cySrc;
        BOOL        bMore;
        CLIPENUM    ce;
        LONG        c;
        LONG        i;

        if ((psoSrc->iType == STYPE_BITMAP) &&
            (psoMsk == NULL) &&
            ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)) &&
            ((psoSrc->iBitmapFormat == ppdev->iBitmapFormat)) &&
            (ppdev->iBitmapFormat != BMF_24BPP))
        {
            cxDst = prclDst->right - prclDst->left;
            cyDst = prclDst->bottom - prclDst->top;
            cxSrc = prclSrc->right - prclSrc->left;
            cySrc = prclSrc->bottom - prclSrc->top;

            // Our 'bStretchDIB' routine requires that the stretch be
            // non-inverting, within a certain size, to have no source
            // clipping, and to have no empty rectangles (the latter is the
            // reason for the '- 1' on the unsigned compare here):

            if (((cxSrc - 1) < STRETCH_MAX_EXTENT)         &&
                ((cySrc - 1) < STRETCH_MAX_EXTENT)         &&
                ((cxDst - 1) < STRETCH_MAX_EXTENT)         &&
                ((cyDst - 1) < STRETCH_MAX_EXTENT)         &&
                (prclSrc->left   >= 0)                     &&
                (prclSrc->top    >= 0)                     &&
                (prclSrc->right  <= psoSrc->sizlBitmap.cx) &&
                (prclSrc->bottom <= psoSrc->sizlBitmap.cy))
            {
                // Our snazzy routine only does COLORONCOLOR.  But for
                // stretching blts, BLACKONWHITE and WHITEONBLACK are also
                // equivalent to COLORONCOLOR:

                if ((iMode == COLORONCOLOR) ||
                    ((iMode < COLORONCOLOR) && (cxSrc <= cxDst) && (cySrc <= cyDst)))
                {
                    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                    {
                        rclClip.left   = LONG_MIN;
                        rclClip.top    = LONG_MIN;
                        rclClip.right  = LONG_MAX;
                        rclClip.bottom = LONG_MAX;
                        prclClip = &rclClip;

                    StretchSingleClipRect:

                        if (bBankedStretch(ppdev,
                                        NULL,
                                        ppdev->lDelta,
                                        prclDst,
                                        psoSrc->pvScan0,
                                        psoSrc->lDelta,
                                        prclSrc,
                                        prclClip))
                        {
                            return(TRUE);
                        }
                    }
                    else if (pco->iDComplexity == DC_RECT)
                    {
                        prclClip = &pco->rclBounds;
                        goto StretchSingleClipRect;
                    }
                    else
                    {
                        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                        do {
                            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                            c = cIntersect(prclDst, ce.arcl, ce.c);

                            if (c != 0)
                            {
                                for (i = 0; i < c; i++)
                                {
                                    if (!bBankedStretch(ppdev,
                                                     NULL,
                                                     ppdev->lDelta,
                                                     prclDst,
                                                     psoSrc->pvScan0,
                                                     psoSrc->lDelta,
                                                     prclSrc,
                                                     &ce.arcl[i]))
                                    {
                                        goto Punt_It;
                                    }
                                }
                            }

                        } while (bMore);

                        return(TRUE);
                    }
                }
            }
        }
    }

Punt_It:

    // GDI is nice enough to handle the cases where 'psoDst' and/or 'psoSrc'
    // are device-managed surfaces, but it ain't gonna be fast...

    return(EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                         prclDst, prclSrc, pptlMsk, iMode));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\disp\strips.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: Strips.c
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vssSolidHorizontal
*
* Draws left-to-right x-major near-horizontal lines using short-stroke
* vectors.  Is faster than using the radial-line routine, but only works
* when every strip is 15 pels in length or less.
*
\**************************************************************************/

VOID vssSolidHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    LONG    i, cStrips;
    PLONG   pStrips;
    LONG    xPels, xSumPels, yDir;
    USHORT  Cmd, ssCmd, dirDraw, dirSkip;

    Cmd = DRAW | WRITE | MULTIPLE_PIXELS |
          DIR_TYPE_RADIAL | LAST_PIXEL_OFF |
          BUS_SIZE_16 | BYTE_SWAP;

    cStrips = pStrip->cStrips;

    IO_FIFO_WAIT(ppdev, 3);

    IO_CUR_X(ppdev, pStrip->ptlStart.x);
    IO_CUR_Y(ppdev, pStrip->ptlStart.y);
    IO_CMD(ppdev, Cmd);

    // Setup the drawing direction and the skip direction.

    dirDraw = 0x10;

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        yDir = 1;
        dirSkip = 0xC100;
    }
    else
    {
        dirSkip = 0x4100;
        yDir = -1;
    }

    // Output the short stroke commands.

    xSumPels = 0;
    pStrips = pStrip->alStrips;
    for (i = 0; i < cStrips; i++)
    {
        xPels = *pStrips++;
        xSumPels += xPels;
        ssCmd = (USHORT) (dirSkip | dirDraw | xPels);
        IO_FIFO_WAIT(ppdev, 4);
        IO_SHORT_STROKE(ppdev, ssCmd);
    }

    pStrip->ptlStart.x += xSumPels;
    pStrip->ptlStart.y += cStrips * yDir;

}

/******************************Public*Routine******************************\
* VOID vrlSolidHorizontal
*
* Draws left-to-right x-major near-horizontal lines using radial lines.
*
\**************************************************************************/

VOID vrlSolidHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    LONG    cStrips;
    USHORT  Cmd;
    LONG    i, yInc, x, y;
    PLONG   pStrips;


    Cmd = DRAW_LINE      | DRAW            | DIR_TYPE_RADIAL |
          LAST_PIXEL_OFF | MULTIPLE_PIXELS | DRAWING_DIRECTION_0 |
          WRITE;

    cStrips = pStrip->cStrips;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    yInc = 1;
    if (pStrip->flFlips & FL_FLIP_V)
        yInc = -1;

    pStrips = pStrip->alStrips;

    for (i = 0; i < cStrips; i++)
    {
        IO_FIFO_WAIT(ppdev, 4);

        IO_CUR_X(ppdev, x);
        IO_CUR_Y(ppdev, y);
        IO_MAJ_AXIS_PCNT(ppdev, *pStrips);
        IO_CMD(ppdev, Cmd);

        x += *pStrips++;
        y += yInc;
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

}

/******************************Public*Routine******************************\
* VOID vssSolidVertical
*
* Draws left-to-right y-major near-vertical lines using short-stroke
* vectors.  Is faster than using the radial-line routine, but only works
* when every strip is 15 pels in length or less.
*
\**************************************************************************/

VOID vssSolidVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    LONG    i, cStrips;
    PLONG   pStrips;
    LONG    yPels, ySumPels, yDir;
    USHORT  Cmd, ssCmd, dirDraw, dirSkip;

    Cmd = DRAW | WRITE | MULTIPLE_PIXELS |
          DIR_TYPE_RADIAL | LAST_PIXEL_OFF |
          BUS_SIZE_16 | BYTE_SWAP;

    cStrips = pStrip->cStrips;

    IO_FIFO_WAIT(ppdev, 3);

    IO_CUR_X(ppdev, pStrip->ptlStart.x);
    IO_CUR_Y(ppdev, pStrip->ptlStart.y);
    IO_CMD(ppdev, Cmd);

    // Setup the drawing direction and the skip direction.

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        yDir = 1;
        dirDraw = 0xD0;
    }
    else
    {
        yDir = -1;
        dirDraw = 0x50;
    }

    dirSkip = 0x0100;

    // Output the short stroke commands.

    ySumPels = 0;
    pStrips = pStrip->alStrips;
    for (i = 0; i < cStrips; i++)
    {
        yPels = *pStrips++;
        ySumPels += yPels;
        ssCmd = (USHORT) (dirSkip | dirDraw | yPels);
        IO_FIFO_WAIT(ppdev, 4);
        IO_SHORT_STROKE(ppdev, ssCmd);
    }

    pStrip->ptlStart.x += cStrips;
    pStrip->ptlStart.y += ySumPels * yDir;

}

/******************************Public*Routine******************************\
* VOID vrlSolidVertical
*
* Draws left-to-right y-major near-vertical lines using radial lines.
*
\**************************************************************************/

VOID vrlSolidVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    LONG    cStrips;
    USHORT  Cmd;
    LONG    i, x, y;
    PLONG   pStrips;

    cStrips = pStrip->cStrips;
    pStrips = pStrip->alStrips;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        Cmd = DRAW_LINE      | DRAW            | DIR_TYPE_RADIAL |
              LAST_PIXEL_OFF | MULTIPLE_PIXELS | DRAWING_DIRECTION_270 |
              WRITE;

        for (i = 0; i < cStrips; i++)
        {
            IO_FIFO_WAIT(ppdev, 4);

            IO_CUR_X(ppdev, x);
            IO_CUR_Y(ppdev, y);
            IO_MAJ_AXIS_PCNT(ppdev, *pStrips);
            IO_CMD(ppdev, Cmd);

            y += *pStrips++;
            x++;
        }

    }
    else
    {
        Cmd = DRAW_LINE      | DRAW            | DIR_TYPE_RADIAL |
              LAST_PIXEL_OFF | MULTIPLE_PIXELS | DRAWING_DIRECTION_90 |
              WRITE;

        for (i = 0; i < cStrips; i++)
        {
            IO_FIFO_WAIT(ppdev, 4);

            IO_CUR_X(ppdev, x);
            IO_CUR_Y(ppdev, y);
            IO_MAJ_AXIS_PCNT(ppdev, *pStrips);
            IO_CMD(ppdev, Cmd);

            y -= *pStrips++;
            x++;
        }
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

}

/******************************Public*Routine******************************\
* VOID vssSolidDiagonalHorizontal
*
* Draws left-to-right x-major near-diagonal lines using short-stroke
* vectors.  Is faster than using the radial-line routine, but only
* works when every strip is 15 pels in length or less.
*
\**************************************************************************/

VOID vssSolidDiagonalHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    LONG    i, cStrips;
    PLONG   pStrips;
    LONG    Pels, SumPels, yDir;
    USHORT  Cmd, ssCmd, dirDraw, dirSkip;

    Cmd = DRAW | WRITE | MULTIPLE_PIXELS |
          DIR_TYPE_RADIAL | LAST_PIXEL_OFF |
          BUS_SIZE_16 | BYTE_SWAP;

    cStrips = pStrip->cStrips;

    IO_FIFO_WAIT(ppdev, 3);

    IO_CUR_X(ppdev, pStrip->ptlStart.x);
    IO_CUR_Y(ppdev, pStrip->ptlStart.y);
    IO_CMD(ppdev, Cmd);

    // Setup the drawing direction and the skip direction.

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        yDir = 1;
        dirDraw = 0xF0;
        dirSkip = 0x4100;

    }
    else
    {
        yDir = -1;
        dirDraw = 0x30;
        dirSkip = 0xC100;

    }

    // Output the short stroke commands.

    SumPels = 0;
    pStrips = pStrip->alStrips;
    for (i = 0; i < cStrips; i++)
    {
        Pels = *pStrips++;
        SumPels += Pels;
        ssCmd = (USHORT)(dirSkip | dirDraw | Pels);
        IO_FIFO_WAIT(ppdev, 4);
        IO_SHORT_STROKE(ppdev, ssCmd);
    }

    pStrip->ptlStart.x += SumPels;
    pStrip->ptlStart.y += (SumPels - cStrips) * yDir;

}

/******************************Public*Routine******************************\
* VOID vrlSolidDiagonalHorizontal
*
* Draws left-to-right x-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID vrlSolidDiagonalHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    LONG    cStrips;
    USHORT  Cmd;
    LONG    i, x, y;
    PLONG   pStrips;

    cStrips = pStrip->cStrips;
    pStrips = pStrip->alStrips;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        Cmd = DRAW_LINE      | DRAW            | DIR_TYPE_RADIAL |
              LAST_PIXEL_OFF | MULTIPLE_PIXELS | DRAWING_DIRECTION_315 |
              WRITE;

        for (i = 0; i < cStrips; i++)
        {
            IO_FIFO_WAIT(ppdev, 4);

            IO_CUR_X(ppdev, x);
            IO_CUR_Y(ppdev, y);
            IO_MAJ_AXIS_PCNT(ppdev, *pStrips);
            IO_CMD(ppdev, Cmd);

            y += *pStrips - 1;
            x += *pStrips++;
        }

    }
    else
    {
        Cmd = DRAW_LINE      | DRAW            | DIR_TYPE_RADIAL |
              LAST_PIXEL_OFF | MULTIPLE_PIXELS | DRAWING_DIRECTION_45 |
              WRITE;

        for (i = 0; i < cStrips; i++)
        {
            IO_FIFO_WAIT(ppdev, 4);

            IO_CUR_X(ppdev, x);
            IO_CUR_Y(ppdev, y);
            IO_MAJ_AXIS_PCNT(ppdev, *pStrips);
            IO_CMD(ppdev, Cmd);

            y -= *pStrips - 1;
            x += *pStrips++;
        }
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

}

/******************************Public*Routine******************************\
* VOID vssSolidDiagonalVertical
*
* Draws left-to-right y-major near-diagonal lines using short-stroke
* vectors.  Is faster than using the radial-line routine, but only
* works when every strip is 15 pels in length or less.
*
\**************************************************************************/

VOID vssSolidDiagonalVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    LONG    i, cStrips;
    PLONG   pStrips;
    LONG    Pels, SumPels, yDir;
    USHORT  Cmd, ssCmd, dirDraw, dirSkip;

    Cmd = DRAW | WRITE | MULTIPLE_PIXELS |
          DIR_TYPE_RADIAL | LAST_PIXEL_OFF |
          BUS_SIZE_16 | BYTE_SWAP;

    cStrips = pStrip->cStrips;

    IO_FIFO_WAIT(ppdev, 3);

    IO_CUR_X(ppdev, pStrip->ptlStart.x);
    IO_CUR_Y(ppdev, pStrip->ptlStart.y);
    IO_CMD(ppdev, Cmd);

    // Setup the drawing direction and the skip direction.

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        yDir = 1;
        dirDraw = 0xF0;
    }
    else
    {
        yDir = -1;
        dirDraw = 0x30;
    }

    dirSkip = 0x8100;

    // Output the short stroke commands.

    SumPels = 0;
    pStrips = pStrip->alStrips;
    for (i = 0; i < cStrips; i++)
    {
        Pels = *pStrips++;
        SumPels += Pels;
        ssCmd = (USHORT)(dirSkip | dirDraw | Pels);
        IO_FIFO_WAIT(ppdev, 4);
        IO_SHORT_STROKE(ppdev, ssCmd);
    }

    pStrip->ptlStart.x += SumPels - cStrips;
    pStrip->ptlStart.y += SumPels * yDir;

}

/******************************Public*Routine******************************\
* VOID vrlSolidDiagonalVertical
*
* Draws left-to-right y-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID vrlSolidDiagonalVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    LONG    cStrips;
    USHORT  Cmd;
    LONG    i, x, y;
    PLONG   pStrips;

    cStrips = pStrip->cStrips;
    pStrips = pStrip->alStrips;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        Cmd = DRAW_LINE      | DRAW            | DIR_TYPE_RADIAL |
              LAST_PIXEL_OFF | MULTIPLE_PIXELS | DRAWING_DIRECTION_315 |
              WRITE;

        for (i = 0; i < cStrips; i++)
        {
            IO_FIFO_WAIT(ppdev, 4);

            IO_CUR_X(ppdev, x);
            IO_CUR_Y(ppdev, y);
            IO_MAJ_AXIS_PCNT(ppdev, *pStrips);
            IO_CMD(ppdev, Cmd);

            y += *pStrips;
            x += *pStrips++ - 1;
        }

    }
    else
    {
        Cmd = DRAW_LINE      | DRAW            | DIR_TYPE_RADIAL |
              LAST_PIXEL_OFF | MULTIPLE_PIXELS | DRAWING_DIRECTION_45 |
              WRITE;

        for (i = 0; i < cStrips; i++)
        {
            IO_FIFO_WAIT(ppdev, 4);

            IO_CUR_X(ppdev, x);
            IO_CUR_Y(ppdev, y);
            IO_MAJ_AXIS_PCNT(ppdev, *pStrips);
            IO_CMD(ppdev, Cmd);

            y -= *pStrips;
            x += *pStrips++ - 1;
        }
    }


    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vStripStyledHorizontal
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles x-major lines that run left-to-right,
* and are comprised of horizontal strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vStripStyledHorizontal(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    LONG    x;
    LONG    y;
    ULONG   dirSkip;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 90 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going up):

        dirSkip = 0x4110;
        dy      = -1;
    }
    else
    {
        // The minor direction of the line is 270 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going down):

        dirSkip = 0xc110;
        dy      = 1;
    }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip
    x       = pstrip->ptlStart.x;   // x position of start of first strip
    y       = pstrip->ptlStart.y;   // y position of start of first strip

    // Warm up the hardware so that it will know we'll be outputing
    // short-stroke vectors, and so that it will have the current position
    // correctly set if we're starting in the middle of a 'dash':

    IO_FIFO_WAIT(ppdev, 3);
    IO_CUR_X(ppdev, x);
    IO_CUR_Y(ppdev, y);
    IO_CMD(ppdev, DRAW              | WRITE             | MULTIPLE_PIXELS |
                  DIR_TYPE_RADIAL   | LAST_PIXEL_OFF    | BUS_SIZE_16     |
                  BYTE_SWAP);

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // We're gonna need the current position to be correct when we
    // start outputing short-stroke vectors:

    IO_FIFO_WAIT(ppdev, 2);
    IO_CUR_X(ppdev, x);

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip, so set 'y'
        // to be the current scan:

        IO_CUR_Y(ppdev, y);
        goto OutputADash;
    }

    // Set 'y' to be the scan we're about to move to, because we've
    // finished with the current strip:

    IO_CUR_Y(ppdev, y + dy);

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;

        // Short stroke vectors can handle lines that are a maximum of
        // 15 pels long.  When we have to draw a longer consecutive
        // segment than that, we simply break it into 16 pel portions:

        while (cThis > 15)
        {
            // Draw two horizontal strokes together to make up one 16 pel
            // segment:

            IO_FIFO_WAIT(ppdev, 1);
            IO_SHORT_STROKE(ppdev, 0x1f11);
            cThis -= 16;
        }

        // Draw the remaining lit part of the strip:

        IO_FIFO_WAIT(ppdev, 1);
        IO_SHORT_STROKE(ppdev, dirSkip | cThis);

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vStripStyledVertical
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles y-major lines that run left-to-right,
* and are comprised of vertical strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vStripStyledVertical(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    LONG    x;
    LONG    y;
    ULONG   dirSkip;
    ULONG   dirSkip16;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 90 (it's a left-to-right y-major line going up):

        dirSkip   = 0x0150;
        dirSkip16 = 0x5f51;         // For drawing 16 pels straight up
        dy        = -1;
    }
    else
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 270 (it's a left-to-right y-major line going down):

        dirSkip   = 0x01d0;
        dirSkip16 = 0xdfd1;         // For drawing 16 pels straight down
        dy        = 1;
    }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip
    x       = pstrip->ptlStart.x;   // x position of start of first strip
    y       = pstrip->ptlStart.y;   // y position of start of first strip

    // Warm up the hardware so that it will know we'll be outputing
    // short-stroke vectors, and so that it will have the current position
    // correctly set if we're starting in the middle of a 'dash':

    IO_FIFO_WAIT(ppdev, 3);
    IO_CUR_X(ppdev, x);
    IO_CUR_Y(ppdev, y);
    IO_CMD(ppdev, DRAW              | WRITE             | MULTIPLE_PIXELS |
                  DIR_TYPE_RADIAL   | LAST_PIXEL_OFF    | BUS_SIZE_16     |
                  BYTE_SWAP);

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        y += (dy > 0) ? cThis : -cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // We're gonna need the current position to be correct when we
    // start outputing short-stroke vectors:

    IO_FIFO_WAIT(ppdev, 2);
    IO_CUR_Y(ppdev, y);

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip, so set 'x'
        // to be the current column:

        IO_CUR_X(ppdev, x);
        goto OutputADash;
    }

    // Set 'x' to be the column we're about to move to, because we've
    // finished with the current strip:

    IO_CUR_X(ppdev, x + 1);

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        y += (dy > 0) ? cThis : -cThis;

        // Short stroke vectors can handle lines that are a maximum of
        // 15 pels long.  When we have to draw a longer consecutive
        // segment than that, we simply break it into 16 pel portions:

        while (cThis > 15)
        {
            // Draw two vertical strokes together to make up one 16 pel
            // segment:

            IO_FIFO_WAIT(ppdev, 1);
            IO_SHORT_STROKE(ppdev, dirSkip16);
            cThis -= 16;
        }

        // Draw the remaining lit part of the strip:

        IO_FIFO_WAIT(ppdev, 1);
        IO_SHORT_STROKE(ppdev, dirSkip | cThis);

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\mini\ddc.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ddc.c

Abstract:

    This module contains the code that support DDC querying..

Environment:

    Kernel mode

Revision History:

--*/

#include "s3.h"
#include "s3ddc.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,GetDdcInformation)
#endif

VOID    WriteClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData);
VOID    WriteDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData);

BOOLEAN ReadClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension);
BOOLEAN ReadDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension);

VOID    WaitForVsyncActive(PHW_DEVICE_EXTENSION HwDeviceExtension);

/****************************************************************
;       DDC register
;
;       Controls the individual toggling of bits in MMFF20 to produce
;       clock and data pulses, and in the end provides a delay.
;
; MMIO FF20h is defined as follows:
;
;      ...  3   2   1   0    SCW = CLK  Write
; --------|---|---|---|---|  SDW = DATA Write
;      ...|SDR|SCR|SDW|SCW|  SCR = CLK  Read
; -------------------------  SDR = DATA Read
;
;       Input:  
;               Using MMIO Base in PHW_DEVICE_EXTENSION 
;               UCHAR ucData
;                   Bit 7:2 = 0
;                   Bit 1   = SDA
;                   Bit 0   = SCL
;       Output:
;
;****************************************************************/


VOID WriteClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData)
{
    UCHAR ucPortData;

    //
    //  read the current value and reset the clock line.
    //
        
    ucPortData = (VideoPortReadRegisterUchar(MMFF20) & 0xFE) | ucData;

    VideoPortWriteRegisterUchar(MMFF20, ucPortData);

}

VOID WriteDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData)
{
    UCHAR ucPortData;

    //
    //  read the current value and reset the data line.
    //
        
    ucPortData = (VideoPortReadRegisterUchar(MMFF20) & 0xFD) | (ucData << 1);

    VideoPortWriteRegisterUchar(MMFF20, ucPortData);
}

BOOLEAN ReadClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    return ((VideoPortReadRegisterUchar(MMFF20) & 0x04) >> 2);
}


BOOLEAN ReadDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    return ((VideoPortReadRegisterUchar(MMFF20) & 0x08) >> 3);
}

VOID WaitForVsyncActive(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    PUCHAR InStatPort = SYSTEM_CONTROL_REG;

    while ((VideoPortReadPortUchar(InStatPort) & VSYNC_ACTIVE) != 0) ;
    while ((VideoPortReadPortUchar(InStatPort) & VSYNC_ACTIVE) == 0) ;
}






BOOLEAN
GetDdcInformation(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR QueryBuffer,
    ULONG BufferSize)

/*++

Routine Description:

    Reads the basic EDID structure from the monitor using DDC2.

Arguments:

    HwDeviceExtension - Points to per-adapter device extension.

    QueryBuffer       - Buffer where information will be stored.

    BufferSize        - Size of the buffer to fill.

Return Value:

    Whether the call succeeded or not.

--*/

{
    ULONG ulKey;
    UCHAR ucOldCr40;
    UCHAR ucOldCr53;
    UCHAR ucOldCr55;
    UCHAR ucOldCr5C;
    UCHAR ucOldSr0D;
    UCHAR ucOldSr08;
    UCHAR ucOldSeqIdx;
    UCHAR ucOldMMFF20;
    UCHAR ucData;

    BOOLEAN       bRet = FALSE;
    I2C_FNC_TABLE i2c;
    ULONG         i;

    //
    // Right now we only support DDC querying for newer than 732
    //

    if (HwDeviceExtension->SubTypeID == SUBTYPE_765) {

        //
        //  unlock the Extended registers
        //

        ulKey = UnlockExtendedRegs(HwDeviceExtension);

        //
        //  save the Sequencer index register
        //

        ucOldSeqIdx = VideoPortReadPortUchar (SEQ_ADDRESS_REG);

        //
        //  unlock the Sequencer registers
        //

        VideoPortWritePortUchar (SEQ_ADDRESS_REG, UNLOCK_SEQREG);
        ucOldSr08 = VideoPortReadPortUchar (SEQ_DATA_REG);
        VideoPortWritePortUchar (SEQ_DATA_REG, UNLOCK_SEQ);


        VideoPortWritePortUchar (SEQ_ADDRESS_REG, SRD_SEQREG);
        ucOldSr0D = ucData = VideoPortReadPortUchar (SEQ_DATA_REG);
        ucData &= DISAB_FEATURE_BITS;    // Disable feature connector
        VideoPortWritePortUchar (SEQ_DATA_REG, ucData);

        //
        //  Enable access to the enhanced registers
        //

        VideoPortWritePortUchar (CRT_ADDRESS_REG, SYS_CONFIG_S3EXTREG);
        ucOldCr40 = ucData = VideoPortReadPortUchar (CRT_DATA_REG);
        ucData |= ENABLE_ENH_REG_ACCESS;
        VideoPortWritePortUchar (CRT_DATA_REG, ucData);

        //
        // Enable MMIO
        //

        VideoPortWritePortUchar (CRT_ADDRESS_REG, EXT_MEM_CTRL1_S3EXTREG);
        ucOldCr53 = ucData = VideoPortReadPortUchar (CRT_DATA_REG);
        ucData &= ~ENABLE_OLDMMIO;
        ucData |= ENABLE_NEWMMIO;
        VideoPortWritePortUchar (CRT_DATA_REG, ucData);

        //
        // GOP_1:0=00b, select MUX channel 0
        //

        VideoPortWritePortUchar (CRT_ADDRESS_REG, GENERAL_OUT_S3EXTREG);
        ucOldCr5C = ucData = VideoPortReadPortUchar (CRT_DATA_REG);
        ucData |= 0x03;
        VideoPortWritePortUchar (CRT_DATA_REG, ucData);

        //
        //  enable general input port
        //

        VideoPortWritePortUchar (CRT_ADDRESS_REG, EXT_DAC_S3EXTREG);
        ucOldCr55 = VideoPortReadPortUchar (CRT_DATA_REG);

        //
        // Map the MmIoSpace so that we can use it in DDC detectin.
        //

        HwDeviceExtension->MmIoBase =
            VideoPortGetDeviceBase(HwDeviceExtension,
                                   HwDeviceExtension->PhysicalMmIoAddress,
                                   HwDeviceExtension->MmIoLength,
                                   0);

        if (HwDeviceExtension->MmIoBase) {

            //
            //  enable the serial port
            //

            ucOldMMFF20 = VideoPortReadRegisterUchar (MMFF20);
            VideoPortWriteRegisterUchar (MMFF20, 0x13);

            //
            // Get DDC Information if all the registers are setup properly.
            //

            i2c.WriteClockLine = WriteClockLine;
            i2c.WriteDataLine  = WriteDataLine;
            i2c.ReadClockLine  = ReadClockLine;
            i2c.ReadDataLine   = ReadDataLine;
            i2c.WaitVsync      = WaitForVsyncActive;

            i2c.Size = sizeof(I2C_FNC_TABLE);

            bRet = VideoPortDDCMonitorHelper(HwDeviceExtension,
                                             &i2c,
                                             QueryBuffer,
                                             BufferSize);

            //
            // restore the original register values
            //

            VideoPortWriteRegisterUchar (MMFF20, ucOldMMFF20);

            VideoPortFreeDeviceBase(HwDeviceExtension,
                                    HwDeviceExtension->MmIoBase);
        }

        VideoPortWritePortUchar (CRT_ADDRESS_REG, EXT_DAC_S3EXTREG);
        VideoPortWritePortUchar (CRT_DATA_REG, ucOldCr55);

        VideoPortWritePortUchar (CRT_ADDRESS_REG, GENERAL_OUT_S3EXTREG);
        VideoPortWritePortUchar (CRT_DATA_REG, ucOldCr5C);

        VideoPortWritePortUchar (CRT_ADDRESS_REG, EXT_MEM_CTRL1_S3EXTREG);
        VideoPortWritePortUchar (CRT_DATA_REG, ucOldCr53);

        VideoPortWritePortUchar (CRT_ADDRESS_REG, SYS_CONFIG_S3EXTREG);
        VideoPortWritePortUchar (CRT_DATA_REG, ucOldCr40);

        VideoPortWritePortUchar (SEQ_ADDRESS_REG, SRD_SEQREG);
        VideoPortWritePortUchar (SEQ_DATA_REG, ucOldSr0D);

        VideoPortWritePortUchar (SEQ_ADDRESS_REG, UNLOCK_SEQREG);
        VideoPortWritePortUchar (SEQ_DATA_REG, ucOldSr08);

        VideoPortWritePortUchar (SEQ_ADDRESS_REG, ucOldSeqIdx);

        LockExtendedRegs(HwDeviceExtension, ulKey);
    }

    return (bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\mini\cmdcnst.h ===
/*++

Copyright (c) 1992-1995  Microsoft Corporation

Module Name:

    cmdcnst.h

Abstract:

    This is the command string interpreter definitions

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//--------------------------------------------------------------------------
//   Definition of the set/clear mode command language.
//
//   Each command is composed of a major portion and a minor portion.
//   The major portion of a command can be found in the most significant
//   nibble of a command byte, while the minor portion is in the least
//   significant portion of a command byte.
//
//   maj  minor      Description
//   ---- -----      --------------------------------------------
//   00              End of data
//
//   10              in and out type commands as described by flags
//        flags:
//
//        xxxx
//        ||||
//        |||+-------- unused
//        ||+--------- 0/1 single/multiple values to output
//        |+---------- 0/1 8/16 bit operation
//        +----------- 0/1 out/in instruction
//
//       Outs
//       ----------------------------------------------
//       0           reg:W val:B
//       2           reg:W cnt:W val1:B val2:B...valN:B
//       4           reg:W val:W
//       6           reg:W cnt:W val1:W val2:W...valN:W
//
//       Ins
//       ----------------------------------------------
//       8           reg:W
//       a           reg:W cnt:W
//       c           reg:W
//       e           reg:W cnt:W
//
//   20              Special purpose outs
//       00          do indexed outs for seq, crtc, and gdc
//                   indexreg:W cnt:B startindex:B val1:B val2:B...valN:B
//       01          do indexed outs for atc
//                   index-data_reg:W cnt:B startindex:B val1:B val2:B...valN:B
//       02          do masked outs
//                   indexreg:W andmask:B xormask:B
//
//   40              Select Access Range
//       00            Registers is range 3c0-3cf
//       01            Registers in range 3d4-3df
//       02            Registers in range 4ae8-4ae9
//
//   50              Misc.
//       00            Reset CRTC 5C register to POST value
//
//   F0              Nop
//
//---------------------------------------------------------------------------

// some useful equates - major commands

#define EOD                 0x000       // end of data
#define INOUT               0x010       // do ins or outs
#define METAOUT             0x020       // do special types of outs
#define SELECTACCESSRANGE   0x040       // select access range
#define NCMD                0x0f0       // Nop command


// flags for INOUT major command

//#define UNUSED    0x01                    // reserved
#define MULTI   0x02                    // multiple or single ins/outs
#define BW      0x04                    // byte/word size of operation
#define IO      0x08                    // out/in instruction

// minor commands for metout

#define INDXOUT 0x00                    // do indexed outs
#define ATCOUT  0x01                    // do indexed outs for atc
#define MASKOUT 0x02                    // do masked outs using and-xor masks
#define VBLANK  0x03                    // Wait for Vertical Blank Interval
#define SETCLK  0x04                    // Set the OEM Clock.
#define SETCRTC 0x05                    // Set the OEM CRTC values.
#define BUSTEST 0x06                    // 928 bus test
#define DELAY   0x07                    // delay in microseconds

// Register ranges for the select access range command

#define VARIOUSVGA              0x00    // registers in range 3c0-3cf
#define SYSTEMCONTROL           0x01    // registers in range 3d4-3df
#define ADVANCEDFUNCTIONCONTROL 0x02    // registers in range 4ae8-4ae9

// composite inout type commands

#define OB      (INOUT)                 // output 8 bit value
#define OBM     (INOUT+MULTI)           // output multiple bytes
#define OW      (INOUT+BW)              // output single word value
#define OWM     (INOUT+BW+MULTI)        // output multiple words

#define IB      (INOUT+IO)              // input byte
#define IBM     (INOUT+IO+MULTI)        // input multiple bytes
#define IW      (INOUT+IO+BW)           // input word
#define IWM     (INOUT+IO+BW+MULTI)     // input multiple words

// Misc

#define RESET_CR5C 0x50                 // reset CR5C value to POST value
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\mini\nnclk.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    nnclk.c

Abstract:

    This module contains the code to set the number nine clock.

Environment:

    Kernel mode

Revision History:

--*/

#include "s3.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, calc_clock)
#pragma alloc_text(PAGE, gcd)
#pragma alloc_text(PAGE, set_clock)
#endif

#define PROM_WRITE_INDEX        0x51
#define PROM_WRITE_BIT          0x80
#define SSW_READ_ENBL_INDEX     0x55
#define SSW_READ_ENBL_BIT       0x04
#define SSW_READ_PORT           0x03C8
#define SSW_WRITE_INDEX         0x5C
#define LOCK_INDEX              0x39
#define UNLOCK_PATTERN          0xA0
#define LOCK_INDEX2             0x38
#define UNLOCK_PATTERN2         0x48
#define BIOS_32K_INDEX          0x31
#define BIOS_32K_BIT            0x80
#define MODE_CTRL_INDEX         0x42

#define GOPA_FLSEL              0x40
#define GOPB_ENABLE             0x80
#define GOPB_SLED               0x40
#define GOPB_FLSEL              0x20
#define GOPB_BURN               0x10


#undef  MIN
#define MIN(a, b)               (((a) < (b)) ? (a) : (b))
#undef  MAX
#define MAX(a, b)               (((a) > (b)) ? (a) : (b))
#define CRYSTAL_FREQUENCY       (14318180 * 2)
#define MIN_VCO_FREQUENCY       50000000
#define MAX_NUMERATOR           130
#define MAX_DENOMINATOR         MIN(129, CRYSTAL_FREQUENCY / 400000)
#define MIN_DENOMINATOR         MAX(3, CRYSTAL_FREQUENCY / 2000000)

  /* Set up the softswitch write value */

#define CLOCK(x) VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR)(iotemp | (x)))
#define C_DATA  2
#define C_CLK   1
#define C_BOTH  3
#define C_NONE  0

/****************************************************************************
 * calc_clock
 *
 * Usage: clock frequency [set]
 *      frequency is specified in MHz
 *
 ***************************************************************************/
long calc_clock(frequency, select)

register long   frequency;               /* in Hz */
int select;
{
  register long         index;
  long                  temp;
  long                  min_m, min_n, min_diff;
  long                  diff;

  int clock_m;
  int clock_n;
  int clock_p;

  min_diff = 0xFFFFFFF;
  min_n = 1;
  min_m = 1;

  /* Calculate 18 bit clock value */

  clock_p = 0;
  if (frequency < MIN_VCO_FREQUENCY)
    clock_p = 1;
  if (frequency < MIN_VCO_FREQUENCY / 2)
    clock_p = 2;
  if (frequency < MIN_VCO_FREQUENCY / 4)
    clock_p = 3;

  frequency <<= clock_p;

  for (clock_n = 4; clock_n <= MAX_NUMERATOR; clock_n++)
    {
      index = CRYSTAL_FREQUENCY / (frequency / clock_n);

      if (index > MAX_DENOMINATOR)
        index = MAX_DENOMINATOR;
      if (index < MIN_DENOMINATOR)
        index = MIN_DENOMINATOR;

      for (clock_m = index - 3; clock_m < index + 4; clock_m++)
        if (clock_m >= MIN_DENOMINATOR && clock_m <= MAX_DENOMINATOR)
          {
            diff = (CRYSTAL_FREQUENCY / clock_m) * clock_n - frequency;

            if (diff < 0)
              diff = -diff;

            if (min_m * gcd(clock_m, clock_n) / gcd(min_m, min_n) == clock_m &&
              min_n * gcd(clock_m, clock_n) / gcd(min_m, min_n) == clock_n)

            if (diff > min_diff)
              diff = min_diff;

            if (diff <= min_diff)
              {
                min_diff = diff;
                min_m = clock_m;
                min_n = clock_n;
              }
          }
    }

  clock_m = min_m;
  clock_n = min_n;

  /* Calculate the index */

  temp = (((CRYSTAL_FREQUENCY / 2) * clock_n) / clock_m) << 1;
  for (index = 0; vclk_range[index + 1] < temp && index < 15; index++)
    ;

  /* Pack the clock value for the frequency snthesizer */

  temp = (((long)clock_n - 3) << 11) + ((clock_m - 2) << 1)
                + (clock_p << 8) + (index << 18) + ((long)select << 22);

  return temp;

}

/******************************************************************************
 *
 *****************************************************************************/
VOID set_clock(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    LONG clock_value)                   /* 7bits M, 7bits N, 2bits P */
{
  register long         index;
  register char         iotemp;
  int select;

  select = (clock_value >> 22) & 3;

  /* Unlock the S3 registers */

  VideoPortWritePortUchar(CRT_ADDRESS_REG, LOCK_INDEX);
  VideoPortWritePortUchar(CRT_DATA_REG, UNLOCK_PATTERN);

  /* Shut off screen */

  VideoPortWritePortUchar(SEQ_ADDRESS_REG, 0x01);
  iotemp = VideoPortReadPortUchar(SEQ_DATA_REG);
  VideoPortWritePortUchar(SEQ_DATA_REG, (UCHAR)(iotemp | 0x20));

  /* set clock input to 11 binary */

  iotemp = VideoPortReadPortUchar(MISC_OUTPUT_REG_READ);
  VideoPortWritePortUchar(MISC_OUTPUT_REG_WRITE, (UCHAR)(iotemp | 0x0C));

  VideoPortWritePortUchar(CRT_ADDRESS_REG, SSW_WRITE_INDEX);
  VideoPortWritePortUchar(CRT_DATA_REG, 0);

  VideoPortWritePortUchar(CRT_ADDRESS_REG, MODE_CTRL_INDEX);
  iotemp = VideoPortReadPortUchar(CRT_DATA_REG) & 0xF0;


  /* Program the IC Designs 2061A frequency generator */

  CLOCK(C_NONE);

  /* Unlock sequence */

  CLOCK(C_DATA);
  for (index = 0; index < 6; index++)
    {
      CLOCK(C_BOTH);
      CLOCK(C_DATA);
    }
  CLOCK(C_NONE);
  CLOCK(C_CLK);
  CLOCK(C_NONE);
  CLOCK(C_CLK);

  /* Program the 24 bit value into REG0 */

  for (index = 0; index < 24; index++)
    {
      /* Clock in the next bit */
      clock_value >>= 1;
      if (clock_value & 1)
        {
          CLOCK(C_CLK);
          CLOCK(C_NONE);
          CLOCK(C_DATA);
          CLOCK(C_BOTH);
        }
      else
        {
          CLOCK(C_BOTH);
          CLOCK(C_DATA);
          CLOCK(C_NONE);
          CLOCK(C_CLK);
        }
    }

  CLOCK(C_BOTH);
  CLOCK(C_DATA);
  CLOCK(C_BOTH);

  /* If necessary, reprogram other ICD2061A registers to defaults */

  /* Select the CLOCK in the frequency synthesizer */

  CLOCK(C_NONE | select);

  /* Turn screen back on */

  VideoPortWritePortUchar(SEQ_ADDRESS_REG, 0x01);
  iotemp = VideoPortReadPortUchar(SEQ_DATA_REG);
  VideoPortWritePortUchar(SEQ_DATA_REG, (UCHAR) (iotemp & 0xDF));

}

/******************************************************************************
 * Number theoretic function - GCD (Greatest Common Divisor)
 *****************************************************************************/
long gcd(a, b)
register long a, b;
{
  register long c = a % b;
  while (c)
    a = b, b = c, c = a % b;
  return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\mini\s3data.c ===
/*++

Copyright (c) 1992-1995  Microsoft Corporation

Module Name:

    s3data.c

Abstract:

    This module contains all the global data used by the S3 driver.

Environment:

    Kernel mode

Revision History:


--*/


#include "s3.h"
#include "cmdcnst.h"

/*****************************************************************************
 *
 * NON-PAGED DATA
 *
 *
 * The following data is accessed during system shutdown while paging
 * is disabled.  Because of this, the data must be available in memory
 * at shutdown.  The data is needed because it is used by S3ResetHw
 * to reset the S3 card immediately prior to rebooting.
 *
 ****************************************************************************/

/*****************************************************************************
 * Command table to get ready for VGA mode
 * this is only used for the 911/924 chips
 ****************************************************************************/
USHORT s3_set_vga_mode[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the SC regs
    0x3d4, 0xa539,

    OB,                                 // Enable the S3 graphics engine
    0x3d4, 0x40,

    METAOUT+MASKOUT,
    0x3d5, 0xfe, 0x01,

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OB,                                 // reset to normal VGA operation
    0x4ae8, 0x02,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OB,                                 // Disable the S3 graphics engine
    0x3d4, 0x40,

    METAOUT+MASKOUT,
    0x3d5, 0xfe, 0x00,

    OB,                                 // Memory Control
    0x3d4, 0x31,

    METAOUT+MASKOUT,
    0x3d5, 0x75, 0x85,

    OB,                                 // Backward Compat 1
    0x3d4, 0x32,

    METAOUT+MASKOUT,
    0x3d5, 0x40, 0x00,

    OW,                                 // Backward Compat 2
    0x3d4, 0x0033,

    OW,                                 // Backward Compat 3
    0x3d4, 0x0034,

    OW,                                 // CRTC Lock
    0x3d4, 0x0035,

    OB,                                 // S3 Misc 1
    0x3d4, 0x3a,

    METAOUT+MASKOUT,
    0x3d5, 0x88, 0x05,

    OW,                                 // Data Transfer Exec Pos
    0x3d4, 0x5a3b,

    OW,                                 // Interlace Retrace start
    0x3d4, 0x103c,

    OW,                                 // Extended Mode
    0x3d4, 0x0043,

    OW,                                 // HW graphics Cursor Mode
    0x3d4, 0x0045,

    OW,                                 // HW graphics Cursor Orig x
    0x3d4, 0x0046,

    OW,                                 // HW graphics Cursor Orig x
    0x3d4, 0xff47,

    OW,                                 // HW graphics Cursor Orig y
    0x3d4, 0xfc48,

    OW,                                 // HW graphics Cursor Orig y
    0x3d4, 0xff49,

    OW,                                 // HW graphics Cursor Orig y
    0x3d4, 0xff4a,

    OW,                                 // HW graphics Cursor Orig y
    0x3d4, 0xff4b,

    OW,                                 // HW graphics Cursor Orig y
    0x3d4, 0xff4c,

    OW,                                 // HW graphics Cursor Orig y
    0x3d4, 0xff4d,

    OW,                                 // Dsp Start x pixel pos
    0x3d4, 0xff4e,

    OW,                                 // Dsp Start y pixel pos
    0x3d4, 0xdf4d,

    OB,                                 // MODE-CNTL
    0x3d4, 0x42,

    METAOUT+MASKOUT,
    0x3d5, 0xdf, 0x00,

    EOD

};

USHORT s3_set_vga_mode_no_bios[] = {

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,
    0x3c4, 0x01,

    METAOUT+MASKOUT,
    0x3c5, 0xdf, 0x20,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the SC regs
    0x3d4, 0xa039,

    OB,                                 // Enable the S3 graphics engine
    0x3d4, 0x40,

    METAOUT+MASKOUT,
    0x3d5, 0xfe, 0x01,

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OB,                                 // reset to normal VGA operation
    0x4ae8, 0x02,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OB,                                 // Disable the S3 graphics engine
    0x3d4, 0x40,

    METAOUT+MASKOUT,
    0x3d5, 0xfe, 0x00,

    OB,                                 // Memory Control
    0x3d4, 0x31,

    METAOUT+MASKOUT,
    0x3d5, 0x30, 0x85,

    OWM,
    0x3d4,
    5,
    0x0050, 0x0051, 0x0053, 0x3854,
    0x0055,

    OB,
    0x3d4, 0x58,

    METAOUT+MASKOUT,
    0x3d5, 0x0c, 0xc0,

    RESET_CR5C,

    OWM,
    0x3d4,
    8,
    0x005d, 0x005e, 0x0760, 0x8061,
    0xa162, 0x0063, 0x0064, 0x0865,

    OB,                                 // Backward Compat 1
    0x3d4, 0x32,

    METAOUT+MASKOUT,
    0x3d5, 0x40, 0x00,

    OW,                                 // Backward Compat 2
    0x3d4, 0x0033,

    OW,                                 // Backward Compat 3
    0x3d4, 0x0034,

    OW,                                 // CRTC Lock
    0x3d4, 0x0035,

    OB,                                 // S3 Misc 1
    0x3d4, 0x3a,

    METAOUT+MASKOUT,
    0x3d5, 0x88, 0x05,

    OWM,
    0x3d4,
    14,
    0x5a3b, 0x103c, 0x0043, 0x0045,
    0x0046, 0xff47, 0xfc48, 0xff49,
    0xff4a, 0xff4b, 0xff4c, 0xff4d,
    0xff4e, 0xdf4f,

    OB,
    0x3d4, 0x40,

    METAOUT+MASKOUT,
    0x3d5, 0xf6, 0x08,

    OB,                                 // MODE-CNTL
    0x3d4, 0x42,

    METAOUT+MASKOUT,
    0x3d5, 0xdf, 0x00,

    EOD

};

/*****************************************************************************
 *
 * START OF PAGED DATA
 *
 * All of the data listed below is pageable.  Therefore the system can
 * swap the data out to disk when it needs to free some physical memory.
 *
 * Any data accessed while paging is unavailable should be placed above.
 *
 ****************************************************************************/

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE_DATA")
#endif

//
//              RangeStart        RangeLength
//              |                 |      RangeInIoSpace
//              |                 |      |  RangeVisible
//        +-----+-----+           |      |  |  RangeShareable
//        |           |           |      |  |  |  RangePassive
//        v           v           v      v  v  v  v

VIDEO_ACCESS_RANGE S3AccessRanges[] = {
    {0x000C0000, 0x00000000, 0x00008000, 0, 0, 0, 0}, // 0 ROM location
    {0x000A0000, 0x00000000, 0x00010000, 0, 0, 1, 0}, // 1 Frame buf
    {0x000003C0, 0x00000000, 0x00000010, 1, 1, 1, 0}, // 2 Various VGA regs
    {0x000003D4, 0x00000000, 0x00000008, 1, 1, 1, 0}, // 3 System Control Registers
    {0x000042E8, 0x00000000, 0x00000002, 1, 1, 0, 0}, // 4 SubSys-Stat/Cntl
    {0x00004AE8, 0x00000000, 0x00000002, 1, 1, 0, 0}, // 5 AdvFunc-Cntl
    {0x000082E8, 0x00000000, 0x00000004, 1, 1, 0, 0}, // 6 Cur-Y
    {0x000086E8, 0x00000000, 0x00000004, 1, 1, 0, 0}, // 7 Cur-X
    {0x00008AE8, 0x00000000, 0x00000004, 1, 1, 0, 0}, // 8 DestY-AxStp
    {0x00008EE8, 0x00000000, 0x00000004, 1, 1, 0, 0}, // 9 DestX-SiaStp
    {0x000092E8, 0x00000000, 0x00000004, 1, 1, 0, 0}, // 10 Err-Term
    {0x000096E8, 0x00000000, 0x00000004, 1, 1, 0, 0}, // 11 Maj-Axis-Pcnt(Rec-Width)
    {0x00009AE8, 0x00000000, 0x00000004, 1, 1, 0, 0}, // 12 Gp-Stat/Cmd
    {0x00009EE8, 0x00000000, 0x00000004, 1, 1, 0, 0}, // 13 Short-Stroke
    {0x0000A2E8, 0x00000000, 0x00000004, 1, 1, 0, 0}, // 14 Bkgd-Color
    {0x0000A6E8, 0x00000000, 0x00000004, 1, 1, 0, 0}, // 15 Frgd-Color
    {0x0000AAE8, 0x00000000, 0x00000004, 1, 1, 0, 0}, // 16 Wrt_Mask
    {0x0000AEE8, 0x00000000, 0x00000004, 1, 1, 0, 0}, // 17 Rd-Mask
    {0x0000B6E8, 0x00000000, 0x00000004, 1, 1, 0, 0}, // 18 Bkgd-Mix
    {0x0000BAE8, 0x00000000, 0x00000004, 1, 1, 0, 0}, // 19 Frgd-Mix
    {0x0000BEE8, 0x00000000, 0x00000004, 1, 1, 0, 0}, // 20 Mulitfucn_Cntl
    {0x0000E2E8, 0x00000000, 0x00000004, 1, 1, 0, 0}, // 21 Pix-Trans

    //
    // All S3 boards decode more ports than are documented.  If we
    // don't reserve these extra ports, the PCI arbitrator may grant
    // one to a PCI device, and thus clobber the S3.
    //
    // The aliased ports seem to be any ports where bit 15 is set;
    // for these, the state of bit 14 is effectively ignored.
    //

    {0x0000C2E8, 0x00000000, 0x00000004, 1, 1, 0, 1}, // 22 Alt Cur-Y
    {0x0000C6E8, 0x00000000, 0x00000004, 1, 1, 0, 1}, // 23 Alt Cur-X
    {0x0000CAE8, 0x00000000, 0x00000004, 1, 1, 0, 1}, // 24 Alt DestY-AxStp
    {0x0000CEE8, 0x00000000, 0x00000004, 1, 1, 0, 1}, // 25 Alt DestX-SiaStp
    {0x0000D2E8, 0x00000000, 0x00000004, 1, 1, 0, 1}, // 26 Alt Err-Term
    {0x0000D6E8, 0x00000000, 0x00000004, 1, 1, 0, 1}, // 27 Alt Maj-Axis-Pcnt(Rec-Width)
    {0x0000DAE8, 0x00000000, 0x00000004, 1, 1, 0, 1}, // 28 Alt Gp-Stat/Cmd
    {0x0000DEE8, 0x00000000, 0x00000004, 1, 1, 0, 1}, // 29 Alt Short-Stroke
    {0x0000E6E8, 0x00000000, 0x00000004, 1, 1, 0, 1}, // 30 Alt Frgd-Color
    {0x0000EAE8, 0x00000000, 0x00000004, 1, 1, 0, 1}, // 31 Alt Wrt_Mask
    {0x0000EEE8, 0x00000000, 0x00000004, 1, 1, 0, 1}, // 32 Alt Rd-Mask
    {0x0000F6E8, 0x00000000, 0x00000004, 1, 1, 0, 1}, // 33 Alt Bkgd-Mix
    {0x0000FAE8, 0x00000000, 0x00000004, 1, 1, 0, 1}, // 34 Alt Frgd-Mix
    {0x0000FEE8, 0x00000000, 0x00000004, 1, 1, 0, 1}, // 35 Alt Mulitfucn_Cntl

    //
    // This is an extra entry to store the location of the linear
    // frame buffer and IO ports.
    //

    {0x00000000, 0x00000000, 0x00000000, 0, 0, 0, 0}, // 36 Linear range
    {0x00000000, 0x00000000, 0x00000000, 0, 0, 0, 0}  // 37 ROM
};

/*****************************************************************************
 * Memory Size Table
 ****************************************************************************/

//
// Table for computing the display's amount of memory.
//

ULONG gacjMemorySize[] = { 0x400000,    // 0 = 4mb
                           0x100000,    // 1 = default
                           0x300000,    // 2 = 3mb
                           0x800000,    // 3 = 8mb
                           0x200000,    // 4 = 2mb
                           0x600000,    // 5 = 6mb
                           0x100000,    // 6 = 1mb
                           0x080000 };  // 7 = 0.5mb


/*****************************************************************************
 * 864 Memory Timing Table(s)
 ****************************************************************************/

//
//  M parameter values, used in Set864MemoryTiming()
//
//  access to this table is controlled by constants in Set864MemoryTiming()
//  if you change the table make sure you change the constants
//

UCHAR MParameterTable[] = {
//  8 bit color   16 bit color
//  60Hz  72Hz    60Hz  72Hz

    0xd8, 0xa8,   0x58, 0x38,   //  640 x 480, 1 Mb frame buffer
    0x78, 0x58,   0x20, 0x08,   //  800 x 600, 1 Mb frame buffer
    0x38, 0x28,   0x00, 0x00,   // 1024 x 768, 1 Mb frame buffer

    0xf8, 0xf8,   0xf8, 0xe0,   //  640 x 480, 2 Mb or greater frame buffer
    0xf8, 0xf8,   0xa8, 0x68,   //  800 x 600, 2 Mb or greater frame buffer
    0xd8, 0xa0,   0x40, 0x20    // 1024 x 768, 2 Mb or greater frame buffer

    };

/*****************************************************************************
 * SDAC data
 ****************************************************************************/

SDAC_PLL_PARMS SdacTable[SDAC_TABLE_SIZE] = {
    { 0x00, 0x00 }, // 00  VGA 0  ( !programmable )
    { 0x00, 0x00 }, // 01  VGA 1  ( !programmable )
    { 0x41, 0x61 }, // 02
    { 0x00, 0x00 }, // 03
    { 0x44, 0x43 }, // 04
    { 0x7f, 0x44 }, // 05
    { 0x00, 0x00 }, // 06
    { 0x00, 0x00 }, // 07

    { 0x00, 0x00 }, // 08
    { 0x00, 0x00 }, // 09
    { 0x00, 0x00 }, // 0a
    { 0x56, 0x63 }, // 0b
    { 0x00, 0x00 }, // 0c
    { 0x6b, 0x44 }, // 0d
    { 0x41, 0x41 }, // 0e
    { 0x00, 0x00 }, // 0f
};

//
// With nnlck.c code
//
// Index register frequency ranges for ICD2061A chip
//

long vclk_range[16] = {
    0,            // should be MIN_VCO_FREQUENCY, but that causes problems.
    51000000,
    53200000,
    58500000,
    60700000,
    64400000,
    66800000,
    73500000,
    75600000,
    80900000,
    83200000,
    91500000,
    100000000,
    120000000,
    285000000,
    0,
};


//
// Mode tables for architectures where int10 may fail
//

/*****************************************************************************
 * S3 - 911 Enhanced mode init.
 ****************************************************************************/
USHORT  S3_911_Enhanced_Mode[] = {
    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Make the screen dark
    0x3c6, 0x00,

    OW,                                 // Turn off the screen
    0x3c4, 0x2101,

    METAOUT+VBLANK,                     // Wait for the 911 to settle down.
    METAOUT+VBLANK,

    OW,                                 // Async Reset
    0x3c4, 0x0100,

    OWM,                                // Sequencer Registers
    0x3c4,
    4,
    0x2101, 0x0F02, 0x0003, 0x0e04,

    METAOUT+SETCRTC,                    // Program the CRTC regs

    SELECTACCESSRANGE + SYSTEMCONTROL,

    IB,                                 // Prepare to prgram the ACT
    0x3da,

    SELECTACCESSRANGE + VARIOUSVGA,

    METAOUT+ATCOUT,                     // Program the ATC
    0x3c0,
    21, 0,
    0x00, 0x01, 0x02, 0x03, 0x04,
    0x05, 0x06, 0x07, 0x08, 0x09,
    0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
    0x0f, 0x41, 0x00, 0x0f, 0x00,
    0x00,

    OW,                                 // Start the sequencer
    0x3c4, 0x300,

    OWM,                                // Program the GDC
    0x3ce,
    9,
    0x0000, 0x0001, 0x0002, 0x0003, 0x0004,
    0x0005, 0x0506, 0x0f07, 0xff08,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    IB,                                 // Set ATC FF to index
    0x3da,

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Enable the palette
    0x3c0, 0x20,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock S3 SC regs
    0x3d4, 0xa039,

    OB,                                 // Enable 8514/a reg access
    0x3d4, 0x40,

    METAOUT+MASKOUT,
    0x3d5, 0xfe, 0x01,

    OB,                                 // Turn off H/W Graphics Cursor
    0x3d4, 0x45,

    METAOUT+MASKOUT,
    0x3d5, 0xfe, 0x0,

    OW,                                 // Set the graphic cursor fg color
    0x3d4, 0xff0e,

    OW,                                 // Set the graphic cursor bg color
    0x3d4, 0x000f,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OB,                                 // Set the Misc 1 reg
    0x3d4, 0x3a,

    METAOUT+MASKOUT,
    0x3d5, 0xe2, 0x15,

    OB,                                 // Disable 2K X 1K X 4 plane
    0x3d4, 0x31,

    METAOUT+MASKOUT,
    0x3d5, 0xe4, 0x08,

    OB,                                 // Disable multiple pages
    0x3d4, 0x32,

    METAOUT+MASKOUT,
    0x3d5, 0xbf, 0x0,

    OW,                                 // Lock S3 specific regs
    0x3d4, 0x0038,

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,                                 // Set either 800X600 or 1024X768
    0x4ae8, 0x07,                       // hi-res mode.

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Set Misc out reg for external clock
    0x3c2, 0x2f,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the SC regs
    0x3d4, 0xa039,

    METAOUT+SETCLK,                     // Set the clock for 65 Mhz

    METAOUT+VBLANK,                     // Wait for the clock to settle down
    METAOUT+VBLANK,                     // S3 product alert Synchronization &
    METAOUT+VBLANK,                     // Clock Skew.
    METAOUT+VBLANK,
    METAOUT+VBLANK,
    METAOUT+VBLANK,

    OW,                                 // Lock the SC regs
    0x3d4, 0x0039,

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Turn on the screen - in the sequencer
    0x3c4, 0x01,

    METAOUT+MASKOUT,
    0x3c5, 0xdf, 0x0,

    METAOUT+VBLANK,                     // Wait the monitor to settle down
    METAOUT+VBLANK,

    OW,                                 // Enable all the planes through the DAC
    0x3c6, 0xff,

    EOD

};

/*****************************************************************************
 * S3 - 801 Enhanced mode init.
 ****************************************************************************/
USHORT  S3_801_Enhanced_Mode[] = {

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Make the screen dark
    0x3c6, 0x00,

    OW,                                 // Turn off the screen
    0x3c4, 0x2101,

    METAOUT+VBLANK,                     // Wait for the 911 to settle down.
    METAOUT+VBLANK,

    OW,                                 // Async Reset
    0x3c4, 0x0100,

    OWM,                                // Sequencer Registers
    0x3c4,
    4,
    0x2101, 0x0F02, 0x0003, 0x0e04,

    METAOUT+SETCRTC,                    // Program the CRTC regs

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OWM,
    0x3d4,
    17,
    0xA039, 0x0e42, 0x403c, 0x8931, 0x153a,
    0x0050, 0x4854, 0x2f60, 0x8161, 0x0062,
    0x0058, 0x0033, 0x0043, 0x8013, 0x0051,
    0x005c, 0x1034,

    OW,
    0x3d4, 0x0a5a,                      // Set the low byte of the LAW

    OW,
    0x3d4, 0x0059,                      // Set the high byte of the LAW

    OW,                                 // Lock S3 specific regs
    0x3d4, 0x0038,

    OW,                                 // Lock more S3 specific regs
    0x3d4, 0x0039,

    IB,                                 // Prepare to prgram the ACT
    0x3da,

    SELECTACCESSRANGE + VARIOUSVGA,

    METAOUT+ATCOUT,                     // Program the ATC
    0x3c0,
    21, 0,
    0x00, 0x01, 0x02, 0x03, 0x04,
    0x05, 0x06, 0x07, 0x08, 0x09,
    0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
    0x0f, 0x41, 0x00, 0x0f, 0x00,
    0x00,

    OW,                                 // Start the sequencer
    0x3c4, 0x300,

    OWM,                                // Program the GDC
    0x3ce,
    9,
    0x0000, 0x0001, 0x0002, 0x0003, 0x0004,
    0x0005, 0x0506, 0x0f07, 0xff08,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    IB,                                 // Set ATC FF to index
    0x3da,

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Enable the palette
    0x3c0, 0x20,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock S3 SC regs
    0x3d4, 0xa039,

    OB,                                 // Enable 8514/a reg access
    0x3d4, 0x40,

    METAOUT+MASKOUT,
    0x3d5, 0xfe, 0x01,

    OB,                                 // Turn off H/W Graphics Cursor
    0x3d4, 0x45,

    METAOUT+MASKOUT,
    0x3d5, 0xfe, 0x0,

    OW,                                 // Set the graphic cursor fg color
    0x3d4, 0xff0e,

    OW,                                 // Set the graphic cursor bg color
    0x3d4, 0x000f,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OB,                                 // Set the Misc 1 reg
    0x3d4, 0x3a,

    METAOUT+MASKOUT,
    0x3d5, 0xe2, 0x15,

    OB,                                 // Disable 2K X 1K X 4 plane
    0x3d4, 0x31,

    METAOUT+MASKOUT,
    0x3d5, 0xe4, 0x08,

    OB,                                 // Disable multiple pages
    0x3d4, 0x32,

    METAOUT+MASKOUT,
    0x3d5, 0xbf, 0x0,

    OW,                                 // Lock S3 specific regs
    0x3d4, 0x0038,

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,                                 // Set either 800X600 or 1024X768
    0x4ae8, 0x07,                       // hi-res mode.

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Set Misc out reg for external clock
    0x3c2, 0xef,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the SC regs
    0x3d4, 0xa039,

    METAOUT+SETCLK,                     // Set the clock for 65 Mhz

    METAOUT+VBLANK,                     // Wait for the clock to settle down
    METAOUT+VBLANK,                     // S3 product alert Synchronization &
    METAOUT+VBLANK,                     // Clock Skew.
    METAOUT+VBLANK,
    METAOUT+VBLANK,
    METAOUT+VBLANK,

    OW,                                 // Lock the SC regs
    0x3d4, 0x0039,

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Turn on the screen - in the sequencer
    0x3c4, 0x01,

    METAOUT+MASKOUT,
    0x3c5, 0xdf, 0x0,

    METAOUT+VBLANK,                     // Wait the monitor to settle down
    METAOUT+VBLANK,

    OW,                                 // Enable all the planes through the DAC
    0x3c6, 0xff,

    EOD

};

/*****************************************************************************
 * S3 - 928 1024 X 768, 800 X 600, & 640 X 480 Enhanced mode init.
 ****************************************************************************/
USHORT  S3_928_Enhanced_Mode[] = {

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Make the screen dark
    0x3c6, 0x00,

    OW,                                 // Async Reset
    0x3c4, 0x0100,

    //
    // Wait for vertical sync to make sure that bit 3 of SR1
    // is not changed to a different value during an active video
    // period as suggested by S3 errata sheet.
    //

    METAOUT+VBLANK,

    OWM,                                // Sequencer Registers
    0x3c4, 5,
    0x0300, 0x0101, 0x0F02, 0x0003, 0x0e04,

    METAOUT+INDXOUT,                    // Program the GDC
    0x3ce,
    9, 0,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x05, 0x0f, 0xff,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    METAOUT+SETCRTC,                    // Program the CRTC regs

    //
    // The Homestake errata sheet says that CR42 should be 0x00 when
    // it is enabled as a clock select source by writing 11 to bits
    // 3:2 of the Miscellaneous Output Register at 0x3c2; this has
    // been changed to set CR42 to 0x00, the write to 0x3c2 is near
    // the end of the command stream after which CR42 gets its final
    // value with a METAOUT+SETCLK operation.
    //

    OW,                                 // make sure that CR42 is 0 before it
    0X3D4, 0x0042,                      // is enabled as a clock select source

    OW,                                 // memory configuration reg
    0X3D4, 0x8D31,

    OW,                                 // extended system control reg
    0X3D4, 0x0050,

    OW,                                 // backward compatibility 2 reg
    0X3D4, 0x2033,

    OB,                                 // extended mode reg
    0x3D4, 0x43,

    METAOUT+MASKOUT,
    0x3D5, 0x10, 0x00,

    OW,                                 // extended system control reg 2
    0X3D4, 0x4051,

    OW,                                 // general output port
    0X3D4, 0x025c,

    OW,
    0x3d4, 0x0a5a,                      // Set the low byte of the LAW

    OW,
    0x3d4, 0x0059,                      // Set the high byte of the LAW

    IB,                                 // Prepare to prgram the ACT
    0x3da,

    SELECTACCESSRANGE + VARIOUSVGA,

    METAOUT+ATCOUT,                     // Program the ATC
    0x3c0,
    21, 0,
    0x00, 0x01, 0x02, 0x03, 0x04,
    0x05, 0x06, 0x07, 0x08, 0x09,
    0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
    0x0f, 0x41, 0x00, 0x0f, 0x00,
    0x00,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    IB,                                 // Set ATC FF to index
    0x3da,

    SELECTACCESSRANGE + VARIOUSVGA,

    //
    // Wait for vertical sync to make sure that the display
    // is not reactivated in the middle of a line/frame as suggested
    // by the S3 errata sheet; not doing this causes the screen to
    // flash momentarily.
    //

    METAOUT+VBLANK,

    OB,                                 // Enable the palette
    0x3c0, 0x20,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Enable 8514/a reg access
    0x3d4, 0x0140,

    OB,                                 // Turn off H/W Graphics Cursor
    0x3d4, 0x45,

    METAOUT+MASKOUT,
    0x3d5, 0xfe, 0x0,

    OW,                                 // Set the graphic cursor fg color
    0x3d4, 0xff0e,

    OW,                                 // Set the graphic cursor bg color
    0x3d4, 0x000f,

    OB,                                 // Set the Misc 1 reg
    0x3d4, 0x3a,

    METAOUT+MASKOUT,
    0x3d5, 0x62, 0x15,

    OB,                                 // Disable 2K X 1K X 4 plane
    0x3d4, 0x31,

    METAOUT+MASKOUT,
    0x3d5, 0xe4, 0x08,

    OB,                                 // Disable multiple pages
    0x3d4, 0x32,

    METAOUT+MASKOUT,
    0x3d5, 0xbf, 0x0,

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,                                 // Set either 800X600 or 1024X768
    0x4ae8, 0x07,                       // hi-res mode.

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Set Misc out reg for external clock
    0x3c2, 0xef,

    METAOUT+SETCLK,                     // Set the clock

    METAOUT+DELAY,                      // Wait for the clock to settle down
    0x400,                              // S3 product alert Synchronization &
                                        // Clock Skew.
    METAOUT+VBLANK,
    METAOUT+VBLANK,

    METAOUT+MASKOUT,
    0x3c5, 0xdf, 0x0,

    METAOUT+DELAY,                      // Wait for about 1 millisecond
    0x400,                              // for the monitor to settle down

    OW,                                 // Enable all the planes through the DAC
    0x3c6, 0xff,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Lock S3 specific regs
    0x3d4, 0x0038,

    OW,                                 // Lock more S3 specific regs
    0x3d4, 0x0039,

    EOD

};


/*****************************************************************************
 * S3 - 928 1280 X 1024 Enhanced mode init.
 ****************************************************************************/
USHORT  S3_928_1280_Enhanced_Mode[] = {

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Make the screen dark
    0x3c6, 0x00,

    OW,                                 // Async Reset
    0x3c4, 0x0100,

    OWM,                                // Sequencer Registers
    0x3c4,
    5,
    0x0300, 0x0101, 0x0F02, 0x0003, 0x0e04,

    METAOUT+INDXOUT,                    // Program the GDC
    0x3ce,
    9, 0,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x05, 0x0f, 0xff,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    METAOUT+SETCRTC,                    // Program the CRTC regs

    // Set the Bt 485 DAC.

    OW,                                 // hardware graphics cursor mode reg
    0X3D4, 0x2045,

    OW,                                 // Enable access to Bt 485 CmdReg3
    0x3D4, 0x2955,                      // disable the DAC

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,
    0x3C6, 0x80,                        // Bt 485 - CR0

    METAOUT+DELAY,
    0x400,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // S3 extended video DAC control reg
    0x3D4, 0x2A55,

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,
    0x3C8, 0x40,                        // Bt 485 - CR1

    METAOUT+DELAY,
    0x400,

    OB,
    0x3C9, 0x30,                        // Bt 485 - CR2

    METAOUT+DELAY,
    0x400,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // S3 extened video DAC control reg
    0x3D4, 0x2855,

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Bt 485
    0x3c8, 0x01,

    METAOUT+DELAY,
    0x400,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // S3 extened video DAC control reg
    0x3D4, 0x2A55,

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Bt 485 - CR3
    0x3c6, 0x08,

    METAOUT+DELAY,
    0x400,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Reset the palette index
    0x3d4, 0x2855,

    OW,                                 // Set mode control
    0X3D4, 0x0242,                      // dot clock select

    METAOUT+DELAY,
    0x400,

    OW,                                 // memory configuration
    0X3D4, 0x8f31,

    OW,
    0X3D4, 0x153a,

    OW,                                 // extended system control reg
    0X3D4, 0x0050,

    OW,                                 // backward compatibility reg
    0X3D4, 0x2033,

    OB,                                 // extended mode reg
    0x3D4, 0x43,

    METAOUT+MASKOUT,
    0x3D5, 0x10, 0x00,

    OW,                                 // extended system control reg 2
    0X3D4, 0x5051,

    OW,
    0X3D4, 0x025c,                      // flash bits, 20 packed mode.

    OW,
    0x3d4, 0x0a5a,                      // Set the low byte of the LAW

    OW,
    0x3d4, 0x0059,                      // Set the high byte of the LAW

    IB,                                 // Prepare to prgram the ATC
    0x3da,

    SELECTACCESSRANGE + VARIOUSVGA,

    METAOUT+ATCOUT,                     // Program the ATC
    0x3c0,
    21, 0,
    0x00, 0x01, 0x02, 0x03, 0x04,
    0x05, 0x06, 0x07, 0x08, 0x09,
    0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
    0x0f, 0x41, 0x00, 0x0f, 0x00,
    0x00,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    IB,                                 // Set ATC FF to index
    0x3da,

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Enable the palette
    0x3c0, 0x20,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Enable 8514/a reg access
    0x3d4, 0x0140,

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,                                 // Galen said set to 0
    0x4ae8, 0x03,                       //

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Set Misc out reg for external clock
    0x3c2, 0xef,

    METAOUT+SETCLK,                     // Set the clock

    METAOUT+DELAY,                      // Wait for the clock to settle down
    0x400,                              // S3 product alert Synchronization &
                                        // Clock Skew.
    METAOUT+VBLANK,
    METAOUT+VBLANK,

    METAOUT+MASKOUT,
    0x3c5, 0xdf, 0x0,

    METAOUT+DELAY,                      // Wait for about 1 millisecond
    0x400,                              // for the monitor to settle down

    OW,                                 // Enable all the planes through the DAC
    0x3c6, 0xff,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Lock S3 specific regs
    0x3d4, 0x0038,

    OW,                                 // Lock more S3 specific regs
    0x3d4, 0x0039,

    EOD

};

/*****************************************************************************
 * S3 - 864 1024 X 768, 800 X 600, & 640 X 480 Enhanced mode init.
 ****************************************************************************/
USHORT  S3_864_Enhanced_Mode[] = {

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Make the screen dark
    0x3c6, 0x00,

    OW,                                 // Async Reset
    0x3c4, 0x0100,

    //
    // Wait for vertical sync to make sure that bit 3 of SR1
    // is not changed to a different value during an active video
    // period as suggested by S3 errata sheet.
    //

    METAOUT+VBLANK,

    OWM,                                // Sequencer Registers
    0x3c4, 5,
    0x0300, 0x0101, 0x0F02, 0x0003, 0x0e04,

    METAOUT+INDXOUT,                    // Program the GDC
    0x3ce,
    9, 0,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x05, 0x0f, 0xff,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    // do this before SETCRTC because CRTC streams have to write to 0x4ae8
    OW,                                 // Enable 8514/a reg access
    0x3d4, 0x0140,

    METAOUT+SETCRTC,                    // Program the CRTC regs

    //
    // The Homestake errata sheet says that CR42 should be 0x00 when
    // it is enabled as a clock select source by writing 11 to bits
    // 3:2 of the Miscellaneous Output Register at 0x3c2; this has
    // been changed to set CR42 to 0x00, the write to 0x3c2 is near
    // the end of the command stream after which CR42 gets its final
    // value with a METAOUT+SETCLK operation.
    //

    OW,                                 // make sure that CR42 is 0 before it
    0X3D4, 0x0042,                      // is enabled as a clock select source

    OW,                                 // memory configuration reg
    0X3D4, 0x8D31,

    OW,                                 // backward compatibility 2 reg
    0X3D4, 0x2033,

    OB,                                 // extended mode reg
    0x3D4, 0x43,

    METAOUT+MASKOUT,
    0x3D5, 0x10, 0x00,

    OB,                                 // extended system control reg 2
    0x3D4, 0x51,                        // use MASKOUT operation to prevent
                                        // wiping out the extension bits of
    METAOUT+MASKOUT,                    // CR13 (logical line width) in 16
    0x3D5, 0x30, 0x00,                  // bit per pixel color mode

    OW,                                 // general output port
    0X3D4, 0x025c,

    OW,
    0x3d4, 0x0a5a,                      // Set the low byte of the LAW

    OW,
    0x3d4, 0x0059,                      // Set the high byte of the LAW

    IB,                                 // Prepare to prgram the ACT
    0x3da,

    SELECTACCESSRANGE + VARIOUSVGA,

    METAOUT+ATCOUT,                     // Program the ATC
    0x3c0,
    21, 0,
    0x00, 0x01, 0x02, 0x03, 0x04,
    0x05, 0x06, 0x07, 0x08, 0x09,
    0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
    0x0f, 0x41, 0x00, 0x0f, 0x00,
    0x00,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    IB,                                 // Set ATC FF to index
    0x3da,

    SELECTACCESSRANGE + VARIOUSVGA,

    //
    // Wait for vertical sync to make sure that the display
    // is not reactivated in the middle of a line/frame as suggested
    // by the S3 errata sheet; not doing this causes the screen to
    // flash momentarily.
    //

    METAOUT+VBLANK,

    OB,                                 // Enable the palette
    0x3c0, 0x20,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OB,                                 // Turn off H/W Graphics Cursor
    0x3d4, 0x45,

    METAOUT+MASKOUT,
    0x3d5, 0xfe, 0x0,

    OW,                                 // Set the graphic cursor fg color
    0x3d4, 0xff0e,

    OW,                                 // Set the graphic cursor bg color
    0x3d4, 0x000f,

    OB,                                 // Set the Misc 1 reg
    0x3d4, 0x3a,

    METAOUT+MASKOUT,
    0x3d5, 0x62, 0x15,

    OB,                                 // Disable 2K X 1K X 4 plane
    0x3d4, 0x31,

    METAOUT+MASKOUT,
    0x3d5, 0xe4, 0x08,

    OB,                                 // Disable multiple pages
    0x3d4, 0x32,

    METAOUT+MASKOUT,
    0x3d5, 0xbf, 0x0,

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Set Misc out reg for external clock
    0x3c2, 0xef,

    METAOUT+SETCLK,                     // Set the clock

    METAOUT+DELAY,                      // Wait for the clock to settle down
    0x400,                              // S3 product alert Synchronization &
                                        // Clock Skew.
    METAOUT+VBLANK,
    METAOUT+VBLANK,

    METAOUT+MASKOUT,
    0x3c5, 0xdf, 0x0,

    METAOUT+DELAY,                      // Wait for about 1 millisecond
    0x400,                              // for the monitor to settle down

    OW,                                 // Enable all the planes through the DAC
    0x3c6, 0xff,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Lock S3 specific regs
    0x3d4, 0x0038,

    OW,                                 // Lock more S3 specific regs
    0x3d4, 0x0039,

    EOD

};


/*****************************************************************************
 * S3 - 864 1280 X 1024 Enhanced mode init.
 ****************************************************************************/
USHORT  S3_864_1280_Enhanced_Mode[] = {

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Make the screen dark
    0x3c6, 0x00,

    OW,                                 // Async Reset
    0x3c4, 0x0100,

    OWM,                                // Sequencer Registers
    0x3c4,
    5,
    0x0300, 0x0101, 0x0F02, 0x0003, 0x0e04,

    METAOUT+INDXOUT,                    // Program the GDC
    0x3ce,
    9, 0,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x05, 0x0f, 0xff,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    METAOUT+SETCRTC,                    // Program the CRTC regs

    // Set the Bt 485 DAC.

    OW,                                 // hardware graphics cursor mode reg
    0X3D4, 0x2045,

    OW,                                 // Enable access to Bt 485 CmdReg3
    0x3D4, 0x2955,                      // disable the DAC

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,
    0x3C6, 0x80,                        // Bt 485 - CR0

    METAOUT+DELAY,
    0x400,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // S3 extended video DAC control reg
    0x3D4, 0x2A55,

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,
    0x3C8, 0x40,                        // Bt 485 - CR1

    METAOUT+DELAY,
    0x400,

    OB,
    0x3C9, 0x30,                        // Bt 485 - CR2

    METAOUT+DELAY,
    0x400,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // S3 extened video DAC control reg
    0x3D4, 0x2855,

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Bt 485
    0x3c8, 0x01,

    METAOUT+DELAY,
    0x400,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // S3 extened video DAC control reg
    0x3D4, 0x2A55,

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Bt 485 - CR3
    0x3c6, 0x08,

    METAOUT+DELAY,
    0x400,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Reset the palette index
    0x3d4, 0x2855,

    OW,                                 // Set mode control
    0X3D4, 0x0242,                      // dot clock select

    METAOUT+DELAY,
    0x400,

    OW,                                 // memory configuration
    0X3D4, 0x8f31,

    OW,
    0X3D4, 0x153a,

    OW,                                 // extended system control reg
    0X3D4, 0x0050,

    OW,                                 // backward compatibility reg
    0X3D4, 0x2033,

    OB,                                 // extended mode reg
    0x3D4, 0x43,

    METAOUT+MASKOUT,
    0x3D5, 0x10, 0x00,

    OW,                                 // extended system control reg 2
    0X3D4, 0x5051,

    OW,
    0X3D4, 0x025c,                      // flash bits, 20 packed mode.

    OW,
    0x3d4, 0x0a5a,                      // Set the low byte of the LAW

    OW,
    0x3d4, 0x0059,                      // Set the high byte of the LAW

    IB,                                 // Prepare to prgram the ATC
    0x3da,

    SELECTACCESSRANGE + VARIOUSVGA,

    METAOUT+ATCOUT,                     // Program the ATC
    0x3c0,
    21, 0,
    0x00, 0x01, 0x02, 0x03, 0x04,
    0x05, 0x06, 0x07, 0x08, 0x09,
    0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
    0x0f, 0x41, 0x00, 0x0f, 0x00,
    0x00,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    IB,                                 // Set ATC FF to index
    0x3da,

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Enable the palette
    0x3c0, 0x20,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Enable 8514/a reg access
    0x3d4, 0x0140,

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,                                 // Galen said set to 0
    0x4ae8, 0x03,                       //

    SELECTACCESSRANGE + VARIOUSVGA,

    OB,                                 // Set Misc out reg for external clock
    0x3c2, 0xef,

    METAOUT+SETCLK,                     // Set the clock

    METAOUT+DELAY,                      // Wait for the clock to settle down
    0x400,                              // S3 product alert Synchronization &
                                        // Clock Skew.
    METAOUT+VBLANK,
    METAOUT+VBLANK,

    METAOUT+MASKOUT,
    0x3c5, 0xdf, 0x0,

    METAOUT+DELAY,                      // Wait for about 1 millisecond
    0x400,                              // for the monitor to settle down

    OW,                                 // Enable all the planes through the DAC
    0x3c6, 0xff,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Lock S3 specific regs
    0x3d4, 0x0038,

    OW,                                 // Lock more S3 specific regs
    0x3d4, 0x0039,

    EOD

};


/******************************************************************************
 * 911/924 CRTC Values
 *****************************************************************************/

USHORT crtc911_640x60Hz[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0x5a3b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Lock S3 specific regs
    0x3d4, 0x0038,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x5f, 0x4f, 0x50, 0x82, 0x54,
    0x80, 0x0b, 0x3e, 0x00, 0x40,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xea, 0x8c, 0xdf, 0x80,
    0x60, 0xe7, 0x04, 0xab, 0xff,

    EOD
};

USHORT crtc911_800x60Hz[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0x7a3b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Lock S3 specific regs
    0x3d4, 0x0038,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x7f, 0x63, 0x64, 0x82, 0x6a,
    0x1a, 0x74, 0xf0, 0x00, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x58, 0x8c, 0x57, 0x80,
    0x00, 0x57, 0x73, 0xe3, 0xff,


    EOD
};

USHORT crtc911_1024x60Hz[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0x9f3b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Lock S3 specific regs
    0x3d4, 0x0038,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC
    0x3d4,
    25, 0,
    0xa4, 0x7f, 0x80, 0x87, 0x84,
    0x95, 0x25, 0xf5, 0x00, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x87, 0xff, 0x80,
    0x60, 0xff, 0x21, 0xab, 0xff,

    EOD
};



USHORT crtc911_640x70Hz[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0x5e3b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Lock S3 specific regs
    0x3d4, 0x0038,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x63, 0x4f, 0x50, 0x86, 0x53,
    0x97, 0x07, 0x3e, 0x00, 0x40,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xe8, 0x8b, 0xdf, 0x80,
    0x60, 0xdf, 0x07, 0xab, 0xff,


    EOD
};

USHORT crtc911_800x70Hz[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0x783b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Lock S3 specific regs
    0x3d4, 0x0038,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x7d, 0x63, 0x64, 0x80, 0x69,
    0x1a, 0x98, 0xf0, 0x00, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x7c, 0xa2, 0x57, 0x80,
    0x00, 0x57, 0x98, 0xe3, 0xff,



    EOD
};

USHORT crtc911_1024x70Hz[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0x9d3b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Lock S3 specific regs
    0x3d4, 0x0038,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0xa2, 0x7f, 0x80, 0x85, 0x84,
    0x95, 0x24, 0xf5, 0x00, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x88, 0xff, 0x80,
    0x60, 0xff, 0x24, 0xab, 0xff,

    EOD
};

/*****************************************************************************
 * 801 / 805 CRTC values
 ****************************************************************************/

USHORT crtc801_640x60Hz[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0x5a3b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x5f, 0x4f, 0x50, 0x82, 0x54,
    0x80, 0x0b, 0x3e, 0x00, 0x40,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xea, 0x8c, 0xdf, 0x80,
    0x60, 0xe7, 0x04, 0xab, 0xff,

    OW,
    0X3D4, 0x005d,

    OW,
    0X3D4, 0x005e,

    EOD
};

USHORT crtc801_640x70Hz[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0x5e3b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x63, 0x4f, 0x50, 0x86, 0x53,
    0x97, 0x07, 0x3e, 0x00, 0x40,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xe8, 0x8b, 0xdf, 0x80,
    0x60, 0xdf, 0x07, 0xab, 0xff,

    OW,
    0X3D4, 0x005d,

    OW,
    0X3D4, 0x005e,

    EOD
};



USHORT crtc801_800x60Hz[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0x7a3b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x7f, 0x63, 0x64, 0x82,
    0x6a, 0x1a, 0x74, 0xf0,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0xff, 0x00,
    0x58, 0x8c, 0x57, 0x80,
    0x00, 0x57, 0x73, 0xe3,
    0xff,

    OW,
    0X3D4, 0x005d,

    OW,
    0X3D4, 0x005e,

    EOD
};

USHORT crtc801_800x70Hz[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0x783b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x7d, 0x63, 0x64, 0x80,
    0x6c, 0x1b, 0x98, 0xf0,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0xff, 0x00,
    0x7c, 0xa2, 0x57, 0x80,
    0x00, 0x57, 0x98, 0xe3,
    0xff,

    OW,
    0X3D4, 0x005d,

    OW,
    0X3D4, 0x005e,

    EOD
};




USHORT crtc801_1024x60Hz[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0x9d3b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0xa3, 0x7f, 0x80, 0x86,
    0x84, 0x95, 0x25, 0xf5,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0xff, 0x00,
    0x02, 0x87, 0xff, 0x80,
    0x60, 0xff, 0x21, 0xeb,
    0xff,

    OW,
    0X3D4, 0x005d,

    OW,
    0X3D4, 0x005e,

    EOD
};

USHORT crtc801_1024x70Hz[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0x9d3b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0xa1, 0x7f, 0x80, 0x84,
    0x84, 0x95, 0x24, 0xf5,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0x0b, 0x00,
    0x02, 0x88, 0xff, 0x80,
    0x60, 0xff, 0x24, 0xeb,
    0xff,

    OW,
    0X3D4, 0x005d,

    OW,
    0X3D4, 0x005e,

    EOD
};

/*****************************************************************************
 * 928 CRTC values
 ****************************************************************************/

USHORT crtc928_640x60Hz[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0x5a3b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x5f, 0x4f, 0x50, 0x82, 0x54,
    0x80, 0x0b, 0x3e, 0x00, 0x40,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xea, 0x8c, 0xdf, 0x80,
    0x60, 0xe7, 0x04, 0xab, 0xff,

    OW,
    0X3D4, 0x005d,

    OW,
    0X3D4, 0x005e,

    EOD
};

USHORT crtc928_640x70Hz[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0x5e3b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x63, 0x4f, 0x50, 0x86, 0x53,
    0x97, 0x07, 0x3e, 0x00, 0x40,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xe8, 0x8b, 0xdf, 0x80,
    0x60, 0xdf, 0x07, 0xab, 0xff,

    OW,
    0X3D4, 0x005d,

    OW,
    0X3D4, 0x005e,

    EOD
};



USHORT crtc928_800x60Hz[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0x7a3b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x7f, 0x63, 0x64, 0x82,
    0x6a, 0x1a, 0x74, 0xf0,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0xff, 0x00,
    0x58, 0x8c, 0x57, 0x80,
    0x00, 0x57, 0x73, 0xe3,
    0xff,

    OW,
    0X3D4, 0x005d,

    OW,
    0X3D4, 0x005e,

    EOD
};

USHORT crtc928_800x70Hz[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0x783b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x7d, 0x63, 0x64, 0x80,
    0x6c, 0x1b, 0x98, 0xf0,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0xff, 0x00,
    0x7c, 0xa2, 0x57, 0x80,
    0x00, 0x57, 0x98, 0xe3,
    0xff,

    OW,
    0X3D4, 0x005d,

    OW,
    0X3D4, 0x005e,

    EOD
};



/******************************************************************************
 * CRTC values for S3-928 in 1024x768 @ 60Hz
 *****************************************************************************/
USHORT crtc928_1024x60Hz[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x0034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0xa3, 0x7f, 0x80, 0x86,
    0x84, 0x95, 0x25, 0xf5,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0xff, 0x00,
    0x02, 0x07, 0xff, 0x80,
    0x60, 0xff, 0x21, 0xeb,
    0xff,

    OW,                                 // overlfow regs
    0X3D4, 0x005d,

    OW,                                 // more overflow regs
    0X3D4, 0x005e,

    EOD
};

/******************************************************************************
 * CRTC values for S3-928 in 1024x768 @ 70Hz
 *****************************************************************************/
USHORT crtc928_1024x70Hz[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x0034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0xa1, 0x7f, 0x80, 0x84,
    0x84, 0x95, 0x24, 0xf5,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0x0b, 0x00,
    0x02, 0x88, 0xff, 0x80,
    0x60, 0xff, 0x24, 0xeb,
    0xff,

    OW,                                 // overflow regs
    0X3D4, 0x005d,

    OW,                                 // more overflow regs
    0X3D4, 0x405e,

    EOD
};


/******************************************************************************
 * CRTC values for S3-928 in 1280X1024 @ 60Hz
 *****************************************************************************/
USHORT crtc928_1280x60Hz[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x0034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x30, 0x27, 0x29, 0x96,
    0x29, 0x8d, 0x28, 0x5a,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0xff, 0x00,
    0x05, 0x09, 0xff, 0x00,             // reg 19 == 50 for packed
    0x00, 0xff, 0x29, 0xe3,
    0xff,

    OW,                                 // overflow regs
    0X3D4, 0x005d,

    OW,                                 // more overflow regs
    0X3D4, 0x515e,

    EOD
};


/******************************************************************************
 * CRTC values for S3-928 in 1280X1024 @ 70Hz
 *****************************************************************************/
USHORT crtc928_1280x70Hz[] = {

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x0034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x2f, 0x27, 0x29, 0x95,
    0x29, 0x8d, 0x28, 0x5a,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0xff, 0x00,
    0x05, 0x09, 0xff, 0x00,             // reg 19 == 50 for packed
    0x00, 0xff, 0x29, 0xe3,
    0xff,

    OW,                                 // overflow regs
    0X3D4, 0x005d,

    OW,                                 // more overflow regs
    0X3D4, 0x515e,

    EOD

};

/*****************************************************************************
 * 864 CRTC values
 ****************************************************************************/

USHORT crtc864_640x60Hz[] = {

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,
    0x4ae8, 0x05,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0x5a3b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x5f, 0x4f, 0x50, 0x82, 0x54,
    0x80, 0x0b, 0x3e, 0x00, 0x40,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xea, 0x8c, 0xdf, 0x80,
    0x60, 0xe7, 0x04, 0xab, 0xff,

    OB,                                 // Overflow bits for CR13
    0x3d4, 0x51,

    METAOUT+MASKOUT,
    0x3d5, 0x0f, 0x00,

    OW,
    0X3D4, 0x005d,

    OW,
    0X3D4, 0x005e,

    OW,
    0x3d4, 0x0050,          // 8 bit pixel length

    OW,
    0x3d4, 0x0067,          // mode 0: 8 bit color, 1 VCLK/pixel

    OW,
    0x3d4, 0x006d,          // do not delay BLANK#

    EOD
};

USHORT crtc864_640x70Hz[] = {

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,
    0x4ae8, 0x05,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0x5e3b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x63, 0x4f, 0x50, 0x86, 0x53,
    0x97, 0x07, 0x3e, 0x00, 0x40,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xe8, 0x8b, 0xdf, 0x80,
    0x60, 0xdf, 0x07, 0xab, 0xff,

    OB,                                 // overflow bits for CR13
    0x3d4, 0x51,

    METAOUT+MASKOUT,
    0x3d5, 0x0f, 0x00,

    OW,
    0X3D4, 0x005d,

    OW,
    0X3D4, 0x005e,

    OW,
    0x3d4, 0x0050,          // 8 bit pixel length

    OW,
    0x3d4, 0x0067,          // mode 0: 8 bit color, 1 VCLK/pixel

    OW,
    0x3d4, 0x006d,          // do not delay BLANK#

    EOD
};



USHORT crtc864_800x60Hz[] = {

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,
    0x4ae8, 0x05,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0x7a3b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x7f, 0x63, 0x64, 0x82,
    0x6a, 0x1a, 0x74, 0xf0,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0xff, 0x00,
    0x58, 0x8c, 0x57, 0x80,
    0x00, 0x57, 0x73, 0xe3,
    0xff,

    OB,                                 // overflow bits for CR13
    0x3d4, 0x51,

    METAOUT+MASKOUT,
    0x3d5, 0x0f, 0x00,

    OW,
    0X3D4, 0x005d,

    OW,
    0X3D4, 0x005e,

    OW,
    0x3d4, 0x0050,          // 8 bit pixel length

    OW,
    0x3d4, 0x0067,          // mode 0: 8 bit color, 1 VCLK/pixel

    OW,
    0x3d4, 0x006d,          // do not delay BLANK#

    EOD
};

USHORT crtc864_800x70Hz[] = {

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,
    0x4ae8, 0x05,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0x783b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x7d, 0x63, 0x64, 0x80,
    0x6c, 0x1b, 0x98, 0xf0,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0xff, 0x00,
    0x7c, 0xa2, 0x57, 0x80,
    0x00, 0x57, 0x98, 0xe3,
    0xff,

    OB,                                 // overflow bits for CR13
    0x3d4, 0x51,

    METAOUT+MASKOUT,
    0x3d5, 0x0f, 0x00,

    OW,
    0X3D4, 0x005d,

    OW,
    0X3D4, 0x005e,

    OW,
    0x3d4, 0x0050,          // 8 bit pixel length

    OW,
    0x3d4, 0x0067,          // mode 0: 8 bit color, 1 VCLK/pixel

    OW,
    0x3d4, 0x006d,          // do not delay BLANK#

    EOD
};



/******************************************************************************
 * CRTC values for S3-864 in 1024x768 @ 60Hz
 *****************************************************************************/
USHORT crtc864_1024x60Hz[] = {

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,
    0x4ae8, 0x05,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x0034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0xa3, 0x7f, 0x80, 0x86,
    0x84, 0x95, 0x25, 0xf5,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0xff, 0x00,
    0x02, 0x07, 0xff, 0x80,
    0x60, 0xff, 0x21, 0xeb,
    0xff,

    OB,                                 // overflow bits for CR13
    0x3d4, 0x51,

    METAOUT+MASKOUT,
    0x3d5, 0x0f, 0x00,

    OW,                                 // overflow regs
    0X3D4, 0x005d,

    OW,                                 // more overflow regs
    0X3D4, 0x005e,

    OW,
    0x3d4, 0x0050,          // 8 bit pixel length

    OW,
    0x3d4, 0x0067,          // mode 0: 8 bit color, 1 VCLK/pixel

    OW,
    0x3d4, 0x006d,          // do not delay BLANK#

    EOD
};

/******************************************************************************
 * CRTC values for S3-864 in 1024x768 @ 70Hz
 *****************************************************************************/
USHORT crtc864_1024x70Hz[] = {

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,
    0x4ae8, 0x05,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x0034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0xa1, 0x7f, 0x80, 0x84,
    0x84, 0x95, 0x24, 0xf5,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0x0b, 0x00,
    0x02, 0x88, 0xff, 0x80,
    0x60, 0xff, 0x24, 0xeb,
    0xff,

    OB,                                 // overflow bits for CR13
    0x3d4, 0x51,

    METAOUT+MASKOUT,
    0x3d5, 0x0f, 0x00,

    OW,                                 // overflow regs
    0X3D4, 0x005d,

    OW,                                 // more overflow regs
    0X3D4, 0x405e,

    OW,
    0x3d4, 0x0050,          // 8 bit pixel length

    OW,
    0x3d4, 0x0067,          // mode 0: 8 bit color, 1 VCLK/pixel

    OW,
    0x3d4, 0x006d,          // do not delay BLANK#

    EOD
};


/******************************************************************************
 * CRTC values for S3-864 in 1280X1024 @ 60Hz
 *****************************************************************************/
USHORT crtc864_1280x60Hz[] = {

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,
    0x4ae8, 0x05,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x0034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x30, 0x27, 0x29, 0x96,
    0x29, 0x8d, 0x28, 0x5a,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0xff, 0x00,
    0x05, 0x09, 0xff, 0x00,             // reg 19 == 50 for packed
    0x00, 0xff, 0x29, 0xe3,
    0xff,

    OW,                                 // overflow regs
    0X3D4, 0x005d,

    OW,                                 // more overflow regs
    0X3D4, 0x515e,

    OW,
    0x3d4, 0x0050,          // 8 bit pixel length

    OW,
    0x3d4, 0x0067,          // mode 0: 8 bit color, 1 VCLK/pixel

    OW,
    0x3d4, 0x006d,          // do not delay BLANK#

    EOD
};


/******************************************************************************
 * CRTC values for S3-864 in 1280X1024 @ 70Hz
 *****************************************************************************/
USHORT crtc864_1280x70Hz[] = {

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,
    0x4ae8, 0x05,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x0034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x2f, 0x27, 0x29, 0x95,
    0x29, 0x8d, 0x28, 0x5a,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0xff, 0x00,
    0x05, 0x09, 0xff, 0x00,             // reg 19 == 50 for packed
    0x00, 0xff, 0x29, 0xe3,
    0xff,

    OW,                                 // overflow regs
    0X3D4, 0x005d,

    OW,                                 // more overflow regs
    0X3D4, 0x515e,

    OW,
    0x3d4, 0x0050,          // 8 bit pixel length

    OW,
    0x3d4, 0x0067,          // mode 0: 8 bit color, 1 VCLK/pixel

    OW,
    0x3d4, 0x006d,          // do not delay BLANK#

    EOD

};

/*****************************************************************************
 * 864 CRTC values
 ****************************************************************************/

USHORT crtc864_640x60Hz_16bpp[] = {

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,
    0x4ae8, 0x01,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0xbe3b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,

    0xc3, 0x9f, 0xa0, 0x04, 0xa8,   // 04
    0x80, 0x0b, 0x3e, 0x00, 0x40,   // 09
    0x00, 0x00, 0x00, 0x00, 0x00,   // 0e
    0x00, 0xea, 0x8c, 0xdf, 0x00,   // 13
    0x60, 0xe7, 0x04, 0xab, 0xff,   // 18

    OB,                                 // overflow bits for CR13
    0x3d4, 0x51,

    METAOUT+MASKOUT,
    0x3d5, 0x0f, 0x10,

    OW,
    0X3D4, 0x005d,

    OW,
    0X3D4, 0x005e,

    OW,
    0x3d4, 0x1050,          // 16 bit pixel length

    OW,
    0x3d4, 0x5067,          // mode 10: 16 bit color, 1 VCLK/pixel

    OW,
    0x3d4, 0x026d,          // recover pixel on right hand edge in 16 bpp mode

    EOD
};

USHORT crtc864_640x70Hz_16bpp[] = {

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,
    0x4ae8, 0x01,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0xc03b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,

    0xc5, 0x9f, 0xa0, 0x0c, 0xa9,   // 04
    0x00, 0x07, 0x3e, 0x00, 0x40,   // 09
    0x00, 0x00, 0x00, 0x00, 0x00,   // 0e
    0x00, 0xe8, 0x8b, 0xdf, 0x00,   // 13
    0x60, 0xdf, 0x07, 0xab, 0xff,   // 18

    OB,                                 // overflow bits for CR13
    0x3d4, 0x51,

    METAOUT+MASKOUT,
    0x3d5, 0x0f, 0x10,

    OW,
    0X3D4, 0x085d,

    OW,
    0X3D4, 0x005e,

    OW,
    0x3d4, 0x1050,          // 16 bit pixel length

    OW,
    0x3d4, 0x5067,          // mode 10: 16 bit color, 1 VCLK/pixel

    OW,
    0x3d4, 0x026d,          // recover pixel on right hand edge in 16 bpp mode

    EOD
};



USHORT crtc864_800x60Hz_16bpp[] = {

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,
    0x4ae8, 0x01,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0xfe3b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,

    0x03, 0xc7, 0xc8, 0x84,
    0xd4, 0x14, 0x74, 0xf0,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0xff, 0x00,
    0x58, 0x8c, 0x57, 0xc8,
    0x00, 0x57, 0x73, 0xe3,
    0xff,

    OB,                                 // overflow bits for CR13
    0x3d4, 0x51,

    METAOUT+MASKOUT,
    0x3d5, 0x0f, 0x00,

    OW,
    0X3D4, 0x015d,

    OW,
    0X3D4, 0x005e,

    OW,
    0x3d4, 0x9050,          // 16 bit pixel length, 800 pixel stride

    OW,
    0x3d4, 0x5067,          // mode 10: 16 bit color, 1 VCLK/pixel

    OW,
    0x3d4, 0x026d,          // recover pixel on right hand edge in 16 bpp mode

    EOD
};

USHORT crtc864_800x70Hz_16bpp[] = {

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,
    0x4ae8, 0x01,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // Unlock the S3 specific regs
    0x3d4, 0x4838,

    OW,                                 // Unlock the more S3 specific regs
    0x3d4, 0xA039,

    OW,                                 // Data Xfer Execution Position reg
    0x3d4, 0xfa3b,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x1034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,

    0xff, 0xc7, 0xc8, 0x80,
    0xd8, 0x16, 0x98, 0xf0,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0xff, 0x00,
    0x7c, 0xa2, 0x57, 0xc8,
    0x00, 0x57, 0x98, 0xe3,
    0xff,

    OB,                                 // overflow bits for CR13
    0x3d4, 0x51,

    METAOUT+MASKOUT,
    0x3d5, 0x0f, 0x00,

    OW,
    0X3D4, 0x005d,

    OW,
    0X3D4, 0x005e,

    OW,
    0x3d4, 0x9050,          // 16 bit pixel length, 800 pixel stride

    OW,
    0x3d4, 0x5067,          // mode 10: 16 bit color, 1 VCLK/pixel

    OW,
    0x3d4, 0x026d,          // recover pixel on right hand edge in 16 bpp mode

    EOD
};



/******************************************************************************
 * CRTC values for S3-864 in 1024x768 @ 60Hz
 *****************************************************************************/

USHORT crtc864_1024x60Hz_16bpp[] = {

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,
    0x4ae8, 0x01,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x0034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,

    0x4b, 0xff, 0x00, 0x8c,
    0x08, 0x8a, 0x25, 0xf5,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0xff, 0x00,
    0x02, 0x0f, 0xff, 0x00,
    0x60, 0xff, 0x21, 0xeb,
    0xff,

    OB,                                 // overflow bits for CR13
    0x3d4, 0x51,

    METAOUT+MASKOUT,
    0x3d5, 0x0f, 0x10,

    OW,                                 // overflow regs
    0X3D4, 0x355d,

    OW,                                 // more overflow regs
    0X3D4, 0x005e,

    OW,
    0x3d4, 0x1050,          // 16 bit pixel length

    OW,
    0x3d4, 0x5067,          // mode 10: 16 bit color, 1 VCLK/pixel

    OW,
    0x3d4, 0x026d,          // recover pixel on right hand edge in 16 bpp mode

    EOD
};

/******************************************************************************
 * CRTC values for S3-864 in 1024x768 @ 70Hz
 *****************************************************************************/
USHORT crtc864_1024x70Hz_16bpp[] = {

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,
    0x4ae8, 0x01,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x0034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,

    0x47, 0xff, 0x00, 0x88,
    0x08, 0x8a, 0x24, 0xf5,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0x0b, 0x00,
    0x02, 0x88, 0xff, 0x00,
    0x60, 0xff, 0x24, 0xeb,
    0xff,

    OB,                                 // overflow bits for CR13
    0x3d4, 0x51,

    METAOUT+MASKOUT,
    0x3d5, 0x0f, 0x10,

    OW,                                 // overflow regs
    0X3D4, 0x355d,

    OW,                                 // more overflow regs
    0X3D4, 0x405e,

    OW,
    0x3d4, 0x1050,          // 16 bit pixel length

    OW,
    0x3d4, 0x5067,          // mode 10: 16 bit color, 1 VCLK/pixel

    OW,
    0x3d4, 0x026d,          // recover pixel on right hand edge in 16 bpp mode

    EOD
};


/******************************************************************************
 * CRTC values for S3-864 in 1280X1024 @ 60Hz
 *****************************************************************************/
USHORT crtc864_1280x60Hz_16bpp[] = {

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,
    0x4ae8, 0x01,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x0034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x30, 0x27, 0x29, 0x96,
    0x29, 0x8d, 0x28, 0x5a,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0xff, 0x00,
    0x05, 0x09, 0xff, 0x00,             // reg 19 == 50 for packed
    0x00, 0xff, 0x29, 0xe3,
    0xff,

    OW,                                 // overflow regs
    0X3D4, 0x005d,

    OW,                                 // more overflow regs
    0X3D4, 0x515e,

    OW,
    0x3d4, 0x1050,          // 16 bit pixel length

    OW,
    0x3d4, 0x5067,          // mode 10: 16 bit color, 1 VCLK/pixel

    OW,
    0x3d4, 0x026d,          // recover pixel on right hand edge in 16 bpp mode

    EOD
};


/******************************************************************************
 * CRTC values for S3-864 in 1280X1024 @ 70Hz
 *****************************************************************************/
USHORT crtc864_1280x70Hz_16bpp[] = {

    SELECTACCESSRANGE + ADVANCEDFUNCTIONCONTROL,

    OW,
    0x4ae8, 0x01,

    SELECTACCESSRANGE + SYSTEMCONTROL,

    OW,                                 // S3R4 - Backwards Compatibility 3
    0x3d4, 0x0034,

    OW,                                 // Unprotect CRTC regs
    0x3d4, 0x0011,

    METAOUT+INDXOUT,                    // Program the CRTC regs
    0x3d4,
    25, 0,
    0x2f, 0x27, 0x29, 0x95,
    0x29, 0x8d, 0x28, 0x5a,
    0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0xff, 0x00,
    0x05, 0x09, 0xff, 0x00,             // reg 19 == 50 for packed
    0x00, 0xff, 0x29, 0xe3,
    0xff,

    OW,                                 // overflow regs
    0X3D4, 0x005d,

    OW,                                 // more overflow regs
    0X3D4, 0x515e,

    OW,
    0x3d4, 0x1050,          // 16 bit pixel length

    OW,
    0x3d4, 0x5067,          // mode 10: 16 bit color, 1 VCLK/pixel

    OW,
    0x3d4, 0x026d,          // recover pixel on right hand edge in 16 bpp mode

    EOD

};

///////////////////////////////////////////////////////////////////////////
// Video mode table - Lists the information about each individual mode.
//
// Note that any new modes should be added here and to the appropriate
// S3_VIDEO_FREQUENCIES tables.
//

S3_VIDEO_MODES S3Modes[] = {
    {                           // 640x480x8bpp

      0x0101,           // 'Contiguous' Int 10 mode number (for high-colour)
      0x0201,           // 'Noncontiguous' Int 10 mode number
      1024,             // 'Contiguous' screen stride (it's '1024' here merely
                        // because we don't do 640x480 in contiguous mode)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          640,                            // X Resolution, in pixels
          480,                            // Y Resolution, in pixels
          1024,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          8,                              // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          6,                              // Number Red pixels in DAC
          6,                              // Number Green pixels in DAC
          6,                              // Number Blue pixels in DAC
          0x00000000,                     // Mask for Red Pixels in non-palette modes
          0x00000000,                     // Mask for Green Pixels in non-palette modes
          0x00000000,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
              VIDEO_MODE_MANAGED_PALETTE, // Mode description flags.
          0,                              // Video Memory Bitmap Width (filled
                                          // in later)
          0,                              // Video Memory Bitmap Height (filled
                                          // in later)
          0                               // DriverSpecificAttributeFlags (filled
                                          // in later)
        },
    },

    {                           // 800x600x8bpp
      0x0103,
      0x0203,
      800,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          1024,
          1,
          8,
          1,
          320,
          240,
          6,
          6,
          6,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                           // 1024x768x8bpp
      0x0105,
      0x0205,                   // 868 doesn't support 0x205 any more...
      1024,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          1024,
          1,
          8,
          1,
          320,
          240,
          6,
          6,
          6,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                           // 1152x864x8bpp
      0x0207,
      0x0207,
      1152,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          864,
          1152,
          1,
          8,
          1,
          320,
          240,
          6,
          6,
          6,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                           // 1280x1024x8bpp
      0x0107,
      0x0107,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          1280,
          1,
          8,
          1,
          320,
          240,
          6,
          6,
          6,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                           // 1600x1200x8bpp
      0x0120,
      0x0120,
      1600,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          1600,
          1,
          8,
          1,
          320,
          240,
          6,
          6,
          6,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                           // 640x480x16bpp
      0x0111,
      0x0211,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          480,
          2048,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // RGB 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 800x600x16bpp
      0x0114,
      0x0214,
      1600,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          1600,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // RGB 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1024x768x16bpp
      0x0117,
      0x0117,
      2048,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          2048,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // RGB 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1152x864x16bpp
      0x020A,                   // Diamond int 10
      0x020A,
      2304,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          864,
          2304,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // RGB 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1280x1024x16bpp
      0x011A,
      0x021A,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          4096,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // RGB 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1600x1200x16bpp
      0x0122,
      0x0122,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          3200,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // RGB 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 640x480x15bpp
      0x0111,
      0x0211,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          480,
          2048,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // RGB 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 800x600x15bpp
      0x0114,
      0x0214,
      1600,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          2048,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // RGB 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1024x768x15bpp
      0x0117,
      0x0117,
      2048,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          2048,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // RGB 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1280x1024x15bpp
      0x011A,
      0x021A,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          4096,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // RGB 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1600x1200x15bpp
      0x0121,
      0x0121,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          3200,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // RGB 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1280x1024x24bpp
      0x011B,                   // Diamond && NumberNine int 10 1280 x 1024
      0x011B,
      3840,                     // 1280 * 3 bytes
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,                 // x pixres
          1024,                 // y pixres
          3840,                 // bytestride
          1,                    // # vidmem planes
          24,                   // bits per plane
          1,                    // default screen freq.
          320,                  // x mm sz
          240,                  // y mm sz
          8,                    // Red DAC pixels
          8,                    // Grn DAC pixels
          8,                    // Blu DAC pixels
          0x00ff0000,           // RGB 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 640x480x32bpp
      0x0112,
      0x0220,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          480,
          4096,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // RGB 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 800x600x32bpp
      0x0115,
      0x0221,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          4096,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // RGB 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1024x768x32bpp
      0x0118,
      0x0222,
      4096,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          4096,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // RGB 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1152x864x32bpp
      0x020B,                   // Diamond int 10
      0x020B,
      4608,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          864,
          4608,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // RGB 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1280x1024x32bpp
      0x011B,
      0x011B,
      5120,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          5120,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // RGB 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1600x1200x32bpp
      0x0123,
      0x0123,
      6400,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          6400,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // RGB 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },
};


ULONG NumS3VideoModes = sizeof(S3Modes) / sizeof(S3_VIDEO_MODES);


/*****************************************************************************
 * Generic S3 mode set bits table
 *
 *  Uses the hardware refresh setting for all the listed modes.
 *
 *  Note that any new modes should be added here and to the S3_VIDEO_MODES
 *  table.
 *
 ****************************************************************************/

S3_VIDEO_FREQUENCIES GenericFrequencyTable[] = {

    { 8,   640, 1, 0x00, 0x00, 0x00, 0x00 },
    { 8,   800, 1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1024, 1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1280, 1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1600, 1, 0x00, 0x00, 0x00, 0x00 },

    { 15,  640, 1, 0x00, 0x00, 0x00, 0x00 },
    { 15,  800, 1, 0x00, 0x00, 0x00, 0x00 },
    { 15, 1024, 1, 0x00, 0x00, 0x00, 0x00 },
    { 15, 1280, 1, 0x00, 0x00, 0x00, 0x00 },
    { 15, 1600, 1, 0x00, 0x00, 0x00, 0x00 },

    { 16,  640, 1, 0x00, 0x00, 0x00, 0x00 },
    { 16,  800, 1, 0x00, 0x00, 0x00, 0x00 },
    { 16, 1024, 1, 0x00, 0x00, 0x00, 0x00 },
    { 16, 1280, 1, 0x00, 0x00, 0x00, 0x00 },
    { 16, 1600, 1, 0x00, 0x00, 0x00, 0x00 },

    { 32,  640, 1, 0x00, 0x00, 0x00, 0x00 },
    { 32,  800, 1, 0x00, 0x00, 0x00, 0x00 },
    { 32, 1024, 1, 0x00, 0x00, 0x00, 0x00 },
    { 32, 1280, 1, 0x00, 0x00, 0x00, 0x00 },
    { 32, 1600, 1, 0x00, 0x00, 0x00, 0x00 },

    { 0 }   // Mark the end
};

/*****************************************************************************
 * Generic S3 using old 864/964 standard -- Uses register 0x52
 *
 *  S3 came out with a new frequency standard for the 864/964 products,
 *  and a bunch of BIOSes were made according to this standard.
 *  Unfortunately, S3 later changed their minds and revised it again...
 *
 ****************************************************************************/

S3_VIDEO_FREQUENCIES Generic64OldFrequencyTable[] = {

    { 8,   640, 60, 0x00, 0xff, 0x00, 0x00 }, // 640x480x8x60 is the default
    { 8,   640, 72, 0x01, 0xff, 0x00, 0x00 },
    { 8,   640, 75, 0x02, 0xff, 0x00, 0x00 },
    { 8,   640,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,   800, 56, 0x00, 0xff, 0x00, 0x00 },
    { 8,   800, 60, 0x01, 0xff, 0x00, 0x00 },
    { 8,   800, 72, 0x02, 0xff, 0x00, 0x00 },
    { 8,   800, 75, 0x03, 0xff, 0x00, 0x00 },
    { 8,   800,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1024, 60, 0x02, 0xff, 0x00, 0x00 },
    { 8,  1024, 70, 0x03, 0xff, 0x00, 0x00 },
    { 8,  1024, 75, 0x04, 0xff, 0x00, 0x00 },
    { 8,  1024,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1152, 60, 0x00, 0xff, 0x00, 0x00 },
    { 8,  1152,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1280, 60, 0x04, 0xff, 0x00, 0x00 },
    { 8,  1280, 72, 0x05, 0xff, 0x00, 0x00 },
    { 8,  1280, 75, 0x06, 0xff, 0x00, 0x00 },
    { 8,  1280,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1600, 60, 0x00, 0xff, 0x00, 0x00 },
    { 8,  1600,  1, 0x00, 0x00, 0x00, 0x00 },

    { 16,  640, 60, 0x00, 0xff, 0x00, 0x00 },
    { 16,  640, 72, 0x01, 0xff, 0x00, 0x00 },
    { 16,  640, 75, 0x02, 0xff, 0x00, 0x00 },
    { 16,  640,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16,  800, 56, 0x00, 0xff, 0x00, 0x00 },
    { 16,  800, 60, 0x01, 0xff, 0x00, 0x00 },
    { 16,  800, 72, 0x02, 0xff, 0x00, 0x00 },
    { 16,  800, 75, 0x03, 0xff, 0x00, 0x00 },
    { 16,  800,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16, 1024, 60, 0x02, 0xff, 0x00, 0x00 },
    { 16, 1024, 70, 0x03, 0xff, 0x00, 0x00 },
    { 16, 1024, 75, 0x04, 0xff, 0x00, 0x00 },
    { 16, 1024,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16, 1280, 60, 0x04, 0xff, 0x00, 0x00 },
    { 16, 1280, 72, 0x05, 0xff, 0x00, 0x00 },
    { 16, 1280, 75, 0x06, 0xff, 0x00, 0x00 },
    { 16, 1280,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16, 1600, 60, 0x00, 0xff, 0x00, 0x00 },
    { 16, 1600,  1, 0x00, 0x00, 0x00, 0x00 },

    { 32,  640, 60, 0x00, 0xff, 0x00, 0x00 },
    { 32,  640, 72, 0x01, 0xff, 0x00, 0x00 },
    { 32,  640, 75, 0x02, 0xff, 0x00, 0x00 },
    { 32,  640,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32,  800, 56, 0x00, 0xff, 0x00, 0x00 },
    { 32,  800, 60, 0x01, 0xff, 0x00, 0x00 },
    { 32,  800, 72, 0x02, 0xff, 0x00, 0x00 },
    { 32,  800, 75, 0x03, 0xff, 0x00, 0x00 },
    { 32,  800,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32, 1024, 60, 0x02, 0xff, 0x00, 0x00 },
    { 32, 1024, 70, 0x03, 0xff, 0x00, 0x00 },
    { 32, 1024, 75, 0x04, 0xff, 0x00, 0x00 },
    { 32, 1024,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32, 1280, 60, 0x04, 0xff, 0x00, 0x00 },
    { 32, 1280, 72, 0x05, 0xff, 0x00, 0x00 },
    { 32, 1280, 75, 0x06, 0xff, 0x00, 0x00 },
    { 32, 1280,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32, 1600, 60, 0x00, 0xff, 0x00, 0x00 },
    { 32, 1600,  1, 0x00, 0x00, 0x00, 0x00 },

    { 0 }   // Mark the end
};

/*****************************************************************************
 * Generic S3 using old 864/964 standard -- Uses registers 0x52 and 0x5B
 *
 *  This is the 'new revised' S3 standard for Vision products.
 *
 ****************************************************************************/

S3_VIDEO_FREQUENCIES Generic64NewFrequencyTable[] = {

    { 8,   640, 60, 0x00, 0x70, 0x00, 0x00 }, // 640x480x8x60 is the default
    { 8,   640, 72, 0x10, 0x70, 0x00, 0x00 },
    { 8,   640, 75, 0x20, 0x70, 0x00, 0x00 },
    { 8,   640,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,   800, 56, 0x00, 0x80, 0x00, 0x03 },
    { 8,   800, 60, 0x80, 0x80, 0x00, 0x03 },
    { 8,   800, 72, 0x00, 0x80, 0x01, 0x03 },
    { 8,   800, 75, 0x80, 0x80, 0x01, 0x03 },
    { 8,   800,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1024, 60, 0x02, 0x00, 0x08, 0x1C },
    { 8,  1024, 70, 0x03, 0x00, 0x0C, 0x1C },
    { 8,  1024, 75, 0x04, 0x00, 0x10, 0x1C },
    { 8,  1024,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1152, 60, 0x00, 0x00, 0x00, 0xE0 },
    { 8,  1152,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1280, 60, 0x04, 0x00, 0x80, 0xE0 },
    { 8,  1280, 72, 0x05, 0x00, 0xA0, 0xE0 },
    { 8,  1280, 75, 0x06, 0x00, 0xC0, 0xE0 },
    { 8,  1280,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1600, 60, 0x00, 0x00, 0x00, 0xE0 },
    { 8,  1600,  1, 0x00, 0x00, 0x00, 0x00 },

    { 16,  640, 60, 0x00, 0x70, 0x00, 0x00 },
    { 16,  640, 72, 0x10, 0x70, 0x00, 0x00 },
    { 16,  640, 75, 0x20, 0x70, 0x00, 0x00 },
    { 16,  640,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16,  800, 56, 0x00, 0x80, 0x00, 0x03 },
    { 16,  800, 60, 0x80, 0x80, 0x00, 0x03 },
    { 16,  800, 72, 0x00, 0x80, 0x01, 0x03 },
    { 16,  800, 75, 0x80, 0x80, 0x01, 0x03 },
    { 16,  800,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16, 1024, 60, 0x02, 0x00, 0x08, 0x1C },
    { 16, 1024, 70, 0x03, 0x00, 0x0C, 0x1C },
    { 16, 1024, 75, 0x04, 0x00, 0x10, 0x1C },
    { 16, 1024,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16, 1280, 60, 0x04, 0x00, 0x80, 0xE0 },
    { 16, 1280, 72, 0x05, 0x00, 0xA0, 0xE0 },
    { 16, 1280, 75, 0x06, 0x00, 0xC0, 0xE0 },
    { 16, 1280,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16, 1600, 60, 0x00, 0x00, 0x00, 0xE0 },
    { 16, 1600,  1, 0x00, 0x00, 0x00, 0x00 },

    { 32,  640, 60, 0x00, 0x70, 0x00, 0x00 },
    { 32,  640, 72, 0x10, 0x70, 0x00, 0x00 },
    { 32,  640, 75, 0x20, 0x70, 0x00, 0x00 },
    { 32,  640,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32,  800, 56, 0x00, 0x80, 0x00, 0x03 },
    { 32,  800, 60, 0x80, 0x80, 0x00, 0x03 },
    { 32,  800, 72, 0x00, 0x80, 0x01, 0x03 },
    { 32,  800, 75, 0x80, 0x80, 0x01, 0x03 },
    { 32,  800,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32, 1024, 60, 0x02, 0x00, 0x08, 0x1C },
    { 32, 1024, 70, 0x03, 0x00, 0x0C, 0x1C },
    { 32, 1024, 75, 0x04, 0x00, 0x10, 0x1C },
    { 32, 1024,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32, 1280, 60, 0x04, 0x00, 0x80, 0xE0 },
    { 32, 1280, 72, 0x05, 0x00, 0xA0, 0xE0 },
    { 32, 1280, 75, 0x06, 0x00, 0xC0, 0xE0 },
    { 32, 1280,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32, 1600, 60, 0x00, 0x00, 0x00, 0xE0 },
    { 32, 1600,  1, 0x00, 0x00, 0x00, 0x00 },

    { 0 }   // Mark the end
};

/*****************************************************************************
 * Looks like we need yet another frequency table.  This table
 * works for Hercules 732/764/765 based S3's.
 *
 ****************************************************************************/

S3_VIDEO_FREQUENCIES HerculesFrequencyTable[] = {

    { 8,   640, 60, 0x00, 0x70, 0x00, 0x00 }, // 640x480x8x60 is the default
    { 8,   640, 72, 0x10, 0x70, 0x00, 0x00 },
    { 8,   640, 75, 0x20, 0x70, 0x00, 0x00 },
    { 8,   640,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,   800, 56, 0x00, 0x80, 0x00, 0x03 },
    { 8,   800, 60, 0x80, 0x80, 0x00, 0x03 },
    { 8,   800, 72, 0x00, 0x80, 0x01, 0x03 },
    { 8,   800, 75, 0x80, 0x80, 0x01, 0x03 },
    { 8,   800,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1024, 60, 0x00, 0x00, 0x04, 0x1C },
    { 8,  1024, 70, 0x00, 0x00, 0x08, 0x1C },
    { 8,  1024, 75, 0x00, 0x00, 0x0C, 0x1C },
    { 8,  1024,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1280, 60, 0x00, 0x00, 0x20, 0xE0 },
    { 8,  1280, 72, 0x00, 0x00, 0x40, 0xE0 },
    { 8,  1280, 75, 0x00, 0x00, 0x60, 0xE0 },
    { 8,  1280,  1, 0x00, 0x00, 0x00, 0x00 },

    { 16,  640, 60, 0x00, 0x70, 0x00, 0x00 },
    { 16,  640, 72, 0x10, 0x70, 0x00, 0x00 },
    { 16,  640, 75, 0x20, 0x70, 0x00, 0x00 },
    { 16,  640,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16,  800, 56, 0x00, 0x80, 0x00, 0x03 },
    { 16,  800, 60, 0x80, 0x80, 0x00, 0x03 },
    { 16,  800, 72, 0x00, 0x80, 0x01, 0x03 },
    { 16,  800, 75, 0x80, 0x80, 0x01, 0x03 },
    { 16,  800,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16, 1024, 60, 0x00, 0x00, 0x04, 0x1C },
    { 16, 1024, 70, 0x00, 0x00, 0x08, 0x1C },
    { 16, 1024, 75, 0x00, 0x00, 0x0C, 0x1C },
    { 16, 1024,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16, 1280, 60, 0x00, 0x00, 0x20, 0xE0 },
    { 16, 1280, 72, 0x00, 0x00, 0x40, 0xE0 },
    { 16, 1280, 75, 0x00, 0x00, 0x60, 0xE0 },
    { 16, 1280,  1, 0x00, 0x00, 0x00, 0x00 },

    { 32,  640, 60, 0x00, 0x70, 0x00, 0x00 },
    { 32,  640, 72, 0x10, 0x70, 0x00, 0x00 },
    { 32,  640, 75, 0x20, 0x70, 0x00, 0x00 },
    { 32,  640,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32,  800, 56, 0x00, 0x80, 0x00, 0x03 },
    { 32,  800, 60, 0x80, 0x80, 0x00, 0x03 },
    { 32,  800, 72, 0x00, 0x80, 0x01, 0x03 },
    { 32,  800, 75, 0x80, 0x80, 0x01, 0x03 },
    { 32,  800,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32, 1024, 60, 0x00, 0x00, 0x04, 0x1C },
    { 32, 1024, 70, 0x00, 0x00, 0x08, 0x1C },
    { 32, 1024, 75, 0x00, 0x00, 0x0C, 0x1C },
    { 32, 1024,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32, 1280, 60, 0x00, 0x00, 0x20, 0xE0 },
    { 32, 1280, 72, 0x00, 0x00, 0x40, 0xE0 },
    { 32, 1280, 75, 0x00, 0x00, 0x60, 0xE0 },
    { 32, 1280,  1, 0x00, 0x00, 0x00, 0x00 },

    { 0 }   // Mark the end
};

S3_VIDEO_FREQUENCIES Hercules64FrequencyTable[] = {

    { 8,   640, 60, 0x00, 0x70, 0x00, 0x00 }, // 640x480x8x60 is the default
    { 8,   640, 72, 0x10, 0x70, 0x00, 0x00 },
    { 8,   640, 75, 0x20, 0x70, 0x00, 0x00 },
    { 8,   640,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,   800, 56, 0x00, 0x80, 0x00, 0x03 },
    { 8,   800, 60, 0x80, 0x80, 0x00, 0x03 },
    { 8,   800, 72, 0x00, 0x80, 0x01, 0x03 },
    { 8,   800, 75, 0x80, 0x80, 0x01, 0x03 },
    { 8,   800,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1024, 60, 0x00, 0x00, 0x00, 0x1C },
    { 8,  1024, 70, 0x00, 0x00, 0x04, 0x1C },
    { 8,  1024, 75, 0x00, 0x00, 0x08, 0x1C },
    { 8,  1024,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1280, 60, 0x00, 0x00, 0x20, 0xE0 },
    { 8,  1280, 72, 0x00, 0x00, 0x40, 0xE0 },
    { 8,  1280, 75, 0x00, 0x00, 0x60, 0xE0 },
    { 8,  1280,  1, 0x00, 0x00, 0x00, 0x00 },

    { 16,  640, 60, 0x00, 0x70, 0x00, 0x00 },
    { 16,  640, 72, 0x10, 0x70, 0x00, 0x00 },
    { 16,  640, 75, 0x20, 0x70, 0x00, 0x00 },
    { 16,  640,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16,  800, 56, 0x00, 0x80, 0x00, 0x03 },
    { 16,  800, 60, 0x80, 0x80, 0x00, 0x03 },
    { 16,  800, 72, 0x00, 0x80, 0x01, 0x03 },
    { 16,  800, 75, 0x80, 0x80, 0x01, 0x03 },
    { 16,  800,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16, 1024, 60, 0x00, 0x00, 0x00, 0x1C },
    { 16, 1024, 70, 0x00, 0x00, 0x04, 0x1C },
    { 16, 1024, 75, 0x00, 0x00, 0x08, 0x1C },
    { 16, 1024,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16, 1280, 60, 0x00, 0x00, 0x20, 0xE0 },
    { 16, 1280, 72, 0x00, 0x00, 0x40, 0xE0 },
    { 16, 1280, 75, 0x00, 0x00, 0x60, 0xE0 },
    { 16, 1280,  1, 0x00, 0x00, 0x00, 0x00 },

    { 32,  640, 60, 0x00, 0x70, 0x00, 0x00 },
    { 32,  640, 72, 0x10, 0x70, 0x00, 0x00 },
    { 32,  640, 75, 0x20, 0x70, 0x00, 0x00 },
    { 32,  640,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32,  800, 56, 0x00, 0x80, 0x00, 0x03 },
    { 32,  800, 60, 0x80, 0x80, 0x00, 0x03 },
    { 32,  800, 72, 0x00, 0x80, 0x01, 0x03 },
    { 32,  800, 75, 0x80, 0x80, 0x01, 0x03 },
    { 32,  800,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32, 1024, 60, 0x00, 0x00, 0x00, 0x1C },
    { 32, 1024, 70, 0x00, 0x00, 0x04, 0x1C },
    { 32, 1024, 75, 0x00, 0x00, 0x08, 0x1C },
    { 32, 1024,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32, 1280, 60, 0x00, 0x00, 0x20, 0xE0 },
    { 32, 1280, 72, 0x00, 0x00, 0x40, 0xE0 },
    { 32, 1280, 75, 0x00, 0x00, 0x60, 0xE0 },
    { 32, 1280,  1, 0x00, 0x00, 0x00, 0x00 },

    { 0 }   // Mark the end
};

S3_VIDEO_FREQUENCIES Hercules68FrequencyTable[] = {

    { 8,   640, 60, 0x00, 0x70, 0x00, 0x00 }, // 640x480x8x60 is the default
    { 8,   640, 72, 0x10, 0x70, 0x00, 0x00 },
    { 8,   640, 75, 0x20, 0x70, 0x00, 0x00 },
    { 8,   640,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,   800, 56, 0x00, 0x80, 0x00, 0x03 },
    { 8,   800, 60, 0x80, 0x80, 0x00, 0x03 },
    { 8,   800, 72, 0x00, 0x80, 0x01, 0x03 },
    { 8,   800, 75, 0x80, 0x80, 0x01, 0x03 },
    { 8,   800,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1024, 60, 0x00, 0x00, 0x00, 0x1C },
    { 8,  1024, 70, 0x00, 0x00, 0x04, 0x1C },
    { 8,  1024, 75, 0x00, 0x00, 0x08, 0x1C },
    { 8,  1024,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1280, 60, 0x00, 0x00, 0x20, 0xE0 },
    { 8,  1280, 72, 0x00, 0x00, 0x40, 0xE0 },
    { 8,  1280, 75, 0x00, 0x00, 0x60, 0xE0 },
    { 8,  1280,  1, 0x00, 0x00, 0x00, 0x00 },

    { 16,  640, 60, 0x00, 0x70, 0x00, 0x00 },
    { 16,  640, 72, 0x10, 0x70, 0x00, 0x00 },
    { 16,  640, 75, 0x20, 0x70, 0x00, 0x00 },
    { 16,  640,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16,  800, 56, 0x00, 0x80, 0x00, 0x03 },
    { 16,  800, 60, 0x80, 0x80, 0x00, 0x03 },
    { 16,  800, 72, 0x00, 0x80, 0x01, 0x03 },
    { 16,  800, 75, 0x80, 0x80, 0x01, 0x03 },
    { 16,  800,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16, 1024, 60, 0x00, 0x00, 0x00, 0x1C },
    { 16, 1024, 70, 0x00, 0x00, 0x04, 0x1C },
    { 16, 1024, 75, 0x00, 0x00, 0x08, 0x1C },
    { 16, 1024,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16, 1280, 60, 0x00, 0x00, 0x20, 0xE0 },
    { 16, 1280, 72, 0x00, 0x00, 0x40, 0xE0 },
    { 16, 1280, 75, 0x00, 0x00, 0x60, 0xE0 },
    { 16, 1280,  1, 0x00, 0x00, 0x00, 0x00 },

    { 32,  640, 60, 0x00, 0x70, 0x00, 0x00 },
    { 32,  640, 72, 0x10, 0x70, 0x00, 0x00 },
    { 32,  640, 75, 0x20, 0x70, 0x00, 0x00 },
    { 32,  640,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32,  800, 56, 0x00, 0x80, 0x00, 0x03 },
    { 32,  800, 60, 0x80, 0x80, 0x00, 0x03 },
    { 32,  800, 72, 0x00, 0x80, 0x01, 0x03 },
    { 32,  800, 75, 0x80, 0x80, 0x01, 0x03 },
    { 32,  800,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32, 1024, 60, 0x00, 0x00, 0x00, 0x1C },
    { 32, 1024, 70, 0x00, 0x00, 0x04, 0x1C },
    { 32, 1024, 75, 0x00, 0x00, 0x08, 0x1C },
    { 32, 1024,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32, 1280, 60, 0x00, 0x00, 0x20, 0xE0 },
    { 32, 1280, 72, 0x00, 0x00, 0x40, 0xE0 },
    { 32, 1280, 75, 0x00, 0x00, 0x60, 0xE0 },
    { 32, 1280,  1, 0x00, 0x00, 0x00, 0x00 },

    { 0 }   // Mark the end
};

/*****************************************************************************
 * Number Nine GXE 64 -- Uses registers 0x52 and 0x5B
 *
 *  This is close to the new 'generic' standard, except for the change
 *  to 76 Hz and the addition of 1152 x 870 modes.
 *
 ****************************************************************************/

S3_VIDEO_FREQUENCIES NumberNine64FrequencyTable[] = {

    { 8,   640, 60, 0x00, 0x70, 0x00, 0x00 }, // 640x480x8x60 is the default
    { 8,   640, 72, 0x10, 0x70, 0x00, 0x00 },
    { 8,   640, 76, 0x20, 0x70, 0x00, 0x00 },
    { 8,   800, 56, 0x00, 0x80, 0x00, 0x03 },
    { 8,   800, 60, 0x80, 0x80, 0x00, 0x03 },
    { 8,   800, 72, 0x00, 0x80, 0x01, 0x03 },
    { 8,   800, 76, 0x80, 0x80, 0x01, 0x03 },
    { 8,  1024, 60, 0x02, 0x00, 0x08, 0x1C },
    { 8,  1024, 70, 0x03, 0x00, 0x0C, 0x1C },
    { 8,  1024, 76, 0x04, 0x00, 0x10, 0x1C },
    { 8,  1152, 60, 0x04, 0x00, 0x80, 0xE0 },
    { 8,  1152, 72, 0x05, 0x00, 0xA0, 0xE0 },
    { 8,  1152, 76, 0x06, 0x00, 0xC0, 0xE0 },
    { 8,  1280, 60, 0x04, 0x00, 0x80, 0xE0 },
    { 8,  1280, 72, 0x05, 0x00, 0xA0, 0xE0 },
    { 8,  1280, 76, 0x06, 0x00, 0xC0, 0xE0 },
    { 8,  1600, 60, 0x00, 0x00, 0x00, 0xE0 },

    { 16,  640, 60, 0x00, 0x70, 0x00, 0x00 },
    { 16,  640, 72, 0x10, 0x70, 0x00, 0x00 },
    { 16,  640, 76, 0x20, 0x70, 0x00, 0x00 },
    { 16,  800, 56, 0x00, 0x80, 0x00, 0x03 },
    { 16,  800, 60, 0x80, 0x80, 0x00, 0x03 },
    { 16,  800, 72, 0x00, 0x80, 0x01, 0x03 },
    { 16,  800, 76, 0x80, 0x80, 0x01, 0x03 },
    { 16, 1024, 60, 0x02, 0x00, 0x08, 0x1C },
    { 16, 1024, 70, 0x03, 0x00, 0x0C, 0x1C },
    { 16, 1024, 76, 0x04, 0x00, 0x10, 0x1C },
    { 16, 1152, 60, 0x04, 0x00, 0x80, 0xE0 },
    { 16, 1152, 72, 0x05, 0x00, 0xA0, 0xE0 },
    { 16, 1152, 76, 0x06, 0x00, 0xC0, 0xE0 },
    { 16, 1280, 60, 0x04, 0x00, 0x80, 0xE0 },
    { 16, 1280, 72, 0x05, 0x00, 0xA0, 0xE0 },
    { 16, 1280, 76, 0x06, 0x00, 0xC0, 0xE0 },
    { 16, 1600, 60, 0x00, 0x00, 0x00, 0xE0 },

    { 24, 1280, 60, 0x04, 0x00, 0x80, 0xE0 },   //24bpp
    { 24, 1280, 72, 0x05, 0x00, 0xA0, 0xE0 },   //24bpp

    { 32,  640, 60, 0x00, 0x70, 0x00, 0x00 },
    { 32,  640, 72, 0x10, 0x70, 0x00, 0x00 },
    { 32,  640, 76, 0x20, 0x70, 0x00, 0x00 },
    { 32,  800, 56, 0x00, 0x80, 0x00, 0x03 },
    { 32,  800, 60, 0x80, 0x80, 0x00, 0x03 },
    { 32,  800, 72, 0x00, 0x80, 0x01, 0x03 },
    { 32,  800, 76, 0x80, 0x80, 0x01, 0x03 },
    { 32, 1024, 60, 0x02, 0x00, 0x08, 0x1C },
    { 32, 1024, 70, 0x03, 0x00, 0x0C, 0x1C },
    { 32, 1024, 76, 0x04, 0x00, 0x10, 0x1C },
    { 32, 1152, 60, 0x04, 0x00, 0x80, 0xE0 },
    { 32, 1152, 72, 0x05, 0x00, 0xA0, 0xE0 },
    { 32, 1152, 76, 0x06, 0x00, 0xC0, 0xE0 },
    { 32, 1280, 60, 0x04, 0x00, 0x80, 0xE0 },
    { 32, 1280, 72, 0x05, 0x00, 0xA0, 0xE0 },
    { 32, 1280, 76, 0x06, 0x00, 0xC0, 0xE0 },
    { 32, 1600, 60, 0x00, 0x00, 0x00, 0xE0 },

    { 0 }   // Mark the end
};

/*****************************************************************************
 * Diamond Stealth 64 -- Uses register 0x5B
 *
 *  We keep 'hardware default refresh' around just in case Diamond decides
 *  to change their convention on us.
 *
 ****************************************************************************/

S3_VIDEO_FREQUENCIES Diamond64FrequencyTable[] = {

    { 8,   640, 60, 0x00, 0x00, 0x08, 0xff }, // 640x480x8x60 is the default
    { 8,   640, 72, 0x00, 0x00, 0x00, 0xff },
    { 8,   640, 75, 0x00, 0x00, 0x02, 0xff },
    { 8,   640, 90, 0x00, 0x00, 0x04, 0xff },
    { 8,   640,100, 0x00, 0x00, 0x0D, 0xff },
    { 8,   640,120, 0x00, 0x00, 0x0E, 0xff },
    { 8,   640,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,   800, 56, 0x00, 0x00, 0x08, 0xff },
    { 8,   800, 60, 0x00, 0x00, 0x00, 0xff },
    { 8,   800, 72, 0x00, 0x00, 0x06, 0xff },
    { 8,   800, 75, 0x00, 0x00, 0x02, 0xff },
    { 8,   800, 90, 0x00, 0x00, 0x04, 0xff },
    { 8,   800,100, 0x00, 0x00, 0x0D, 0xff },
    { 8,   800,120, 0x00, 0x00, 0x0E, 0xff },
    { 8,   800,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1024, 60, 0x00, 0x00, 0x06, 0xff },
    { 8,  1024, 70, 0x00, 0x00, 0x0A, 0xff },
    { 8,  1024, 72, 0x00, 0x00, 0x04, 0xff },
    { 8,  1024, 75, 0x00, 0x00, 0x02, 0xff },
    { 8,  1024, 80, 0x00, 0x00, 0x0D, 0xff },
    { 8,  1024,100, 0x00, 0x00, 0x0E, 0xff },
    { 8,  1024,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1152, 60, 0x00, 0x00, 0x00, 0xff },
    { 8,  1152, 70, 0x00, 0x00, 0x0D, 0xff },
    { 8,  1152, 75, 0x00, 0x00, 0x02, 0xff },
    { 8,  1152,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1280, 60, 0x00, 0x00, 0x07, 0xff },
    { 8,  1280, 72, 0x00, 0x00, 0x04, 0xff },
    { 8,  1280, 75, 0x00, 0x00, 0x02, 0xff },
    { 8,  1280,  1, 0x00, 0x00, 0x00, 0x00 },
    { 8,  1600, 60, 0x00, 0x00, 0x00, 0xff },
    { 8,  1600,  1, 0x00, 0x00, 0x00, 0x00 },

    { 16,  640, 60, 0x00, 0x00, 0x08, 0xff },
    { 16,  640, 72, 0x00, 0x00, 0x00, 0xff },
    { 16,  640, 75, 0x00, 0x00, 0x02, 0xff },
    { 16,  640, 90, 0x00, 0x00, 0x04, 0xff },
    { 16,  640,100, 0x00, 0x00, 0x0D, 0xff },
    { 16,  640,120, 0x00, 0x00, 0x0E, 0xff },
    { 16,  640,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16,  800, 56, 0x00, 0x00, 0x08, 0xff },
    { 16,  800, 60, 0x00, 0x00, 0x00, 0xff },
    { 16,  800, 72, 0x00, 0x00, 0x06, 0xff },
    { 16,  800, 75, 0x00, 0x00, 0x02, 0xff },
    { 16,  800, 90, 0x00, 0x00, 0x04, 0xff },
    { 16,  800,100, 0x00, 0x00, 0x0D, 0xff },
    { 16,  800,120, 0x00, 0x00, 0x0E, 0xff },
    { 16,  800,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16, 1024, 60, 0x00, 0x00, 0x06, 0xff },
    { 16, 1024, 70, 0x00, 0x00, 0x0A, 0xff },
    { 16, 1024, 72, 0x00, 0x00, 0x04, 0xff },
    { 16, 1024, 75, 0x00, 0x00, 0x02, 0xff },
    { 16, 1024, 80, 0x00, 0x00, 0x0D, 0xff },
    { 16, 1024,100, 0x00, 0x00, 0x0E, 0xff },
    { 16, 1024,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16, 1152, 60, 0x00, 0x00, 0x00, 0xff },
    { 16, 1152, 70, 0x00, 0x00, 0x0D, 0xff },
    { 16, 1152, 75, 0x00, 0x00, 0x02, 0xff },
    { 16, 1152,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16, 1280, 60, 0x00, 0x00, 0x07, 0xff },
    { 16, 1280, 72, 0x00, 0x00, 0x04, 0xff },
    { 16, 1280, 75, 0x00, 0x00, 0x02, 0xff },
    { 16, 1280,  1, 0x00, 0x00, 0x00, 0x00 },
    { 16, 1600, 60, 0x00, 0x00, 0x00, 0xff },
    { 16, 1600,  1, 0x00, 0x00, 0x00, 0x00 },

    { 24, 1280, 60, 0x00, 0x00, 0x07, 0xff },   //24bpp
    { 24, 1280, 72, 0x00, 0x00, 0x04, 0xff },   //24bpp
    { 24, 1280, 75, 0x00, 0x00, 0x02, 0xff },   //24bpp
    { 24, 1280,  1, 0x00, 0x00, 0x00, 0x00 },   //24bpp

    { 32,  640, 60, 0x00, 0x00, 0x08, 0xff },
    { 32,  640, 72, 0x00, 0x00, 0x00, 0xff },
    { 32,  640, 75, 0x00, 0x00, 0x02, 0xff },
    { 32,  640, 90, 0x00, 0x00, 0x04, 0xff },
    { 32,  640,100, 0x00, 0x00, 0x0D, 0xff },
    { 32,  640,120, 0x00, 0x00, 0x0E, 0xff },
    { 32,  640,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32,  800, 56, 0x00, 0x00, 0x08, 0xff },
    { 32,  800, 60, 0x00, 0x00, 0x00, 0xff },
    { 32,  800, 72, 0x00, 0x00, 0x06, 0xff },
    { 32,  800, 75, 0x00, 0x00, 0x02, 0xff },
    { 32,  800, 90, 0x00, 0x00, 0x04, 0xff },
    { 32,  800,100, 0x00, 0x00, 0x0D, 0xff },
    { 32,  800,120, 0x00, 0x00, 0x0E, 0xff },
    { 32,  800,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32, 1024, 60, 0x00, 0x00, 0x06, 0xff },
    { 32, 1024, 70, 0x00, 0x00, 0x0A, 0xff },
    { 32, 1024, 72, 0x00, 0x00, 0x04, 0xff },
    { 32, 1024, 75, 0x00, 0x00, 0x02, 0xff },
    { 32, 1024, 80, 0x00, 0x00, 0x0D, 0xff },
    { 32, 1024,100, 0x00, 0x00, 0x0E, 0xff },
    { 32, 1024,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32, 1152, 60, 0x00, 0x00, 0x00, 0xff },
    { 32, 1152, 70, 0x00, 0x00, 0x0D, 0xff },
    { 32, 1152, 75, 0x00, 0x00, 0x02, 0xff },
    { 32, 1152,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32, 1280, 60, 0x00, 0x00, 0x07, 0xff },
    { 32, 1280, 72, 0x00, 0x00, 0x04, 0xff },
    { 32, 1280, 75, 0x00, 0x00, 0x02, 0xff },
    { 32, 1280,  1, 0x00, 0x00, 0x00, 0x00 },
    { 32, 1600, 60, 0x00, 0x00, 0x00, 0xff },
    { 32, 1600,  1, 0x00, 0x00, 0x00, 0x00 },

    { 0 }   // Mark the end
};

/*****************************************************************************
 * DELL 805 mode set bits table
 *
 *  Dell has a different mapping for each resolution.
 *
 *  index   registry    640     800     1024    1280
 *    0         43       60      56      43      43
 *    1         56       72      60      60      --
 *    2         60       --      72      70      --
 *    3         72       56      56      72      --
 *
 ****************************************************************************/

S3_VIDEO_FREQUENCIES Dell805FrequencyTable[] = {

    { 8, 640,  60, 0x00, 0x03, 0x00, 0x00 }, // 640x480x8x60 is the default
    { 8, 640,  72, 0x01, 0x03, 0x00, 0x00 },
    { 8, 800,  56, 0x00, 0x0C, 0x00, 0x00 },
    { 8, 800,  60, 0x04, 0x0C, 0x00, 0x00 },
    { 8, 800,  72, 0x08, 0x0C, 0x00, 0x00 },
    { 8, 1024, 60, 0x10, 0x30, 0x00, 0x00 },
    { 8, 1024, 70, 0x20, 0x30, 0x00, 0x00 },
    { 8, 1024, 72, 0x30, 0x30, 0x00, 0x00 },

    // The Dell doesn't use standard mode-set numbers for 16bpp, so we
    // simply won't do any 16bpp modes.

    { 0 }   // Mark the end
};

/*****************************************************************************
 * Old Number Nine Computer 928 mode set bits table
 *
 *  BIOS versions before 1.10.04 have the following refresh index to
 *  vertical refresh rate association:
 *
 *      0   60 Hz (56 Hz if 800x600)
 *      1   70 Hz
 *      2   72 Hz
 *      3   76 Hz
 *
 ****************************************************************************/

S3_VIDEO_FREQUENCIES NumberNine928OldFrequencyTable[] = {

    { 8,  640,  60, 0x00, 0x03, 0x00, 0x00 }, // 640x480x8x60 is the default
    { 8,  640,  70, 0x01, 0x03, 0x00, 0x00 },
    { 8,  640,  72, 0x02, 0x03, 0x00, 0x00 },
    { 8,  640,  76, 0x03, 0x03, 0x00, 0x00 },
    { 8,  800,  56, 0x00, 0x0C, 0x00, 0x00 },
    { 8,  800,  70, 0x04, 0x0C, 0x00, 0x00 },
    { 8,  800,  72, 0x08, 0x0C, 0x00, 0x00 },
    { 8,  800,  76, 0x0C, 0x0C, 0x00, 0x00 },
    { 8,  1024, 60, 0x00, 0x30, 0x00, 0x00 },
    { 8,  1024, 70, 0x10, 0x30, 0x00, 0x00 },
    { 8,  1024, 72, 0x20, 0x30, 0x00, 0x00 },
    { 8,  1024, 76, 0x30, 0x30, 0x00, 0x00 },
    { 8,  1280, 60, 0x00, 0xC0, 0x00, 0x00 },
    { 8,  1280, 70, 0x40, 0xC0, 0x00, 0x00 },
    { 8,  1280, 72, 0x80, 0xC0, 0x00, 0x00 },
    { 8,  1280, 76, 0xC0, 0xC0, 0x00, 0x00 },
    { 8,  1600, 60, 0x00, 0xC0, 0x00, 0x00 },
    { 8,  1600, 70, 0x40, 0xC0, 0x00, 0x00 },
    { 8,  1600, 72, 0x80, 0xC0, 0x00, 0x00 },
    { 8,  1600, 76, 0xC0, 0xC0, 0x00, 0x00 },

    { 15, 640,  60, 0x00, 0x03, 0x00, 0x00 },
    { 15, 640,  70, 0x01, 0x03, 0x00, 0x00 },
    { 15, 640,  72, 0x02, 0x03, 0x00, 0x00 },
    { 15, 640,  76, 0x03, 0x03, 0x00, 0x00 },
    { 15, 800,  56, 0x00, 0x0C, 0x00, 0x00 },
    { 15, 800,  70, 0x04, 0x0C, 0x00, 0x00 },
    { 15, 800,  72, 0x08, 0x0C, 0x00, 0x00 },
    { 15, 800,  76, 0x0C, 0x0C, 0x00, 0x00 },
    { 15, 1024, 60, 0x00, 0x30, 0x00, 0x00 },
    { 15, 1024, 70, 0x10, 0x30, 0x00, 0x00 },
    { 15, 1024, 72, 0x20, 0x30, 0x00, 0x00 },
    { 15, 1024, 76, 0x30, 0x30, 0x00, 0x00 },
    { 15, 1280, 60, 0x00, 0xC0, 0x00, 0x00 },
    { 15, 1280, 70, 0x40, 0xC0, 0x00, 0x00 },
    { 15, 1280, 72, 0x80, 0xC0, 0x00, 0x00 },
    { 15, 1280, 76, 0xC0, 0xC0, 0x00, 0x00 },

    { 16, 640,  60, 0x00, 0x03, 0x00, 0x00 },
    { 16, 640,  70, 0x01, 0x03, 0x00, 0x00 },
    { 16, 640,  72, 0x02, 0x03, 0x00, 0x00 },
    { 16, 640,  76, 0x03, 0x03, 0x00, 0x00 },
    { 16, 800,  56, 0x00, 0x0C, 0x00, 0x00 },
    { 16, 800,  70, 0x04, 0x0C, 0x00, 0x00 },
    { 16, 800,  72, 0x08, 0x0C, 0x00, 0x00 },
    { 16, 800,  76, 0x0C, 0x0C, 0x00, 0x00 },
    { 16, 1024, 60, 0x00, 0x30, 0x00, 0x00 },
    { 16, 1024, 70, 0x10, 0x30, 0x00, 0x00 },
    { 16, 1024, 72, 0x20, 0x30, 0x00, 0x00 },
    { 16, 1024, 76, 0x30, 0x30, 0x00, 0x00 },
    { 16, 1280, 60, 0x00, 0xC0, 0x00, 0x00 },
    { 16, 1280, 70, 0x40, 0xC0, 0x00, 0x00 },
    { 16, 1280, 72, 0x80, 0xC0, 0x00, 0x00 },
    { 16, 1280, 76, 0xC0, 0xC0, 0x00, 0x00 },

    { 32, 640,  60, 0x00, 0x03, 0x00, 0x00 },
    { 32, 640,  70, 0x01, 0x03, 0x00, 0x00 },
    { 32, 640,  72, 0x02, 0x03, 0x00, 0x00 },
    { 32, 640,  76, 0x03, 0x03, 0x00, 0x00 },
    { 32, 800,  56, 0x00, 0x0C, 0x00, 0x00 },
    { 32, 800,  70, 0x04, 0x0C, 0x00, 0x00 },
    { 32, 800,  72, 0x08, 0x0C, 0x00, 0x00 },
    { 32, 800,  76, 0x0C, 0x0C, 0x00, 0x00 },
    { 32, 1024, 60, 0x00, 0x30, 0x00, 0x00 },
    { 32, 1024, 70, 0x10, 0x30, 0x00, 0x00 },
    { 32, 1024, 72, 0x20, 0x30, 0x00, 0x00 },
    { 32, 1024, 76, 0x30, 0x30, 0x00, 0x00 },
    { 32, 1280, 60, 0x00, 0xC0, 0x00, 0x00 },
    { 32, 1280, 70, 0x40, 0xC0, 0x00, 0x00 },
    { 32, 1280, 72, 0x80, 0xC0, 0x00, 0x00 },
    { 32, 1280, 76, 0xC0, 0xC0, 0x00, 0x00 },

    { 0 }   // Mark the end
};

/*****************************************************************************
 * New Number Nine Computer 928 mode set bits table
 *
 *  BIOS versions after 1.10.04 have the following refresh index to
 *  vertical refresh rate association:
 *
 *      0   70 Hz
 *      1   76 Hz
 *      2   60 Hz (56 Hz if 800x600)
 *      3   72 Hz
 *
 ****************************************************************************/

S3_VIDEO_FREQUENCIES NumberNine928NewFrequencyTable[] = {

    { 8,  640,  60, 0x02, 0x03, 0x00, 0x00 }, // 640x480x8x60 is the default
    { 8,  640,  70, 0x00, 0x03, 0x00, 0x00 },
    { 8,  640,  72, 0x03, 0x03, 0x00, 0x00 },
    { 8,  640,  76, 0x01, 0x03, 0x00, 0x00 },
    { 8,  800,  56, 0x08, 0x0C, 0x00, 0x00 },
    { 8,  800,  70, 0x00, 0x0C, 0x00, 0x00 },
    { 8,  800,  72, 0x0C, 0x0C, 0x00, 0x00 },
    { 8,  800,  76, 0x04, 0x0C, 0x00, 0x00 },
    { 8,  1024, 60, 0x20, 0x30, 0x00, 0x00 },
    { 8,  1024, 70, 0x00, 0x30, 0x00, 0x00 },
    { 8,  1024, 72, 0x30, 0x30, 0x00, 0x00 },
    { 8,  1024, 76, 0x10, 0x30, 0x00, 0x00 },
    { 8,  1280, 60, 0x80, 0xC0, 0x00, 0x00 },
    { 8,  1280, 70, 0x00, 0xC0, 0x00, 0x00 },
    { 8,  1280, 72, 0xC0, 0xC0, 0x00, 0x00 },
    { 8,  1280, 76, 0x40, 0xC0, 0x00, 0x00 },
    { 8,  1600, 60, 0x80, 0xC0, 0x00, 0x00 },
    { 8,  1600, 70, 0x00, 0xC0, 0x00, 0x00 },
    { 8,  1600, 72, 0xC0, 0xC0, 0x00, 0x00 },
    { 8,  1600, 76, 0x40, 0xC0, 0x00, 0x00 },

    { 15, 640,  60, 0x02, 0x03, 0x00, 0x00 },
    { 15, 640,  70, 0x00, 0x03, 0x00, 0x00 },
    { 15, 640,  72, 0x03, 0x03, 0x00, 0x00 },
    { 15, 640,  76, 0x01, 0x03, 0x00, 0x00 },
    { 15, 800,  56, 0x08, 0x0C, 0x00, 0x00 },
    { 15, 800,  70, 0x00, 0x0C, 0x00, 0x00 },
    { 15, 800,  72, 0x0C, 0x0C, 0x00, 0x00 },
    { 15, 800,  76, 0x04, 0x0C, 0x00, 0x00 },
    { 15, 1024, 60, 0x20, 0x30, 0x00, 0x00 },
    { 15, 1024, 70, 0x00, 0x30, 0x00, 0x00 },
    { 15, 1024, 72, 0x30, 0x30, 0x00, 0x00 },
    { 15, 1024, 76, 0x10, 0x30, 0x00, 0x00 },
    { 15, 1280, 60, 0x80, 0xC0, 0x00, 0x00 },
    { 15, 1280, 70, 0x00, 0xC0, 0x00, 0x00 },
    { 15, 1280, 72, 0xC0, 0xC0, 0x00, 0x00 },
    { 15, 1280, 76, 0x40, 0xC0, 0x00, 0x00 },

    { 16, 640,  60, 0x02, 0x03, 0x00, 0x00 },
    { 16, 640,  70, 0x00, 0x03, 0x00, 0x00 },
    { 16, 640,  72, 0x03, 0x03, 0x00, 0x00 },
    { 16, 640,  76, 0x01, 0x03, 0x00, 0x00 },
    { 16, 800,  56, 0x08, 0x0C, 0x00, 0x00 },
    { 16, 800,  70, 0x00, 0x0C, 0x00, 0x00 },
    { 16, 800,  72, 0x0C, 0x0C, 0x00, 0x00 },
    { 16, 800,  76, 0x04, 0x0C, 0x00, 0x00 },
    { 16, 1024, 60, 0x20, 0x30, 0x00, 0x00 },
    { 16, 1024, 70, 0x00, 0x30, 0x00, 0x00 },
    { 16, 1024, 72, 0x30, 0x30, 0x00, 0x00 },
    { 16, 1024, 76, 0x10, 0x30, 0x00, 0x00 },
    { 16, 1280, 60, 0x80, 0xC0, 0x00, 0x00 },
    { 16, 1280, 70, 0x00, 0xC0, 0x00, 0x00 },
    { 16, 1280, 72, 0xC0, 0xC0, 0x00, 0x00 },
    { 16, 1280, 76, 0x40, 0xC0, 0x00, 0x00 },

    { 32, 640,  60, 0x02, 0x03, 0x00, 0x00 },
    { 32, 640,  70, 0x00, 0x03, 0x00, 0x00 },
    { 32, 640,  72, 0x03, 0x03, 0x00, 0x00 },
    { 32, 640,  76, 0x01, 0x03, 0x00, 0x00 },
    { 32, 800,  56, 0x08, 0x0C, 0x00, 0x00 },
    { 32, 800,  70, 0x00, 0x0C, 0x00, 0x00 },
    { 32, 800,  72, 0x0C, 0x0C, 0x00, 0x00 },
    { 32, 800,  76, 0x04, 0x0C, 0x00, 0x00 },
    { 32, 1024, 60, 0x20, 0x30, 0x00, 0x00 },
    { 32, 1024, 70, 0x00, 0x30, 0x00, 0x00 },
    { 32, 1024, 72, 0x30, 0x30, 0x00, 0x00 },
    { 32, 1024, 76, 0x10, 0x30, 0x00, 0x00 },
    { 32, 1280, 60, 0x80, 0xC0, 0x00, 0x00 },
    { 32, 1280, 70, 0x00, 0xC0, 0x00, 0x00 },
    { 32, 1280, 72, 0xC0, 0xC0, 0x00, 0x00 },
    { 32, 1280, 76, 0x40, 0xC0, 0x00, 0x00 },

    { 0 }   // Mark the end
};

/*****************************************************************************
 * Metheus 928 mode set bits table
 *
 *      2   60 Hz
 *      3   72 Hz
 *
 * We don't bother to support interlaced modes.
 *
 ****************************************************************************/

S3_VIDEO_FREQUENCIES Metheus928FrequencyTable[] = {

    { 8,  640,  60, 0x02, 0x03, 0x00, 0x00 }, // 640x480x8x60 is the default
    { 8,  640,  72, 0x03, 0x03, 0x00, 0x00 },
    { 8,  800,  60, 0x08, 0x0C, 0x00, 0x00 },
    { 8,  800,  72, 0x0C, 0x0C, 0x00, 0x00 },
    { 8,  1024, 60, 0x20, 0x30, 0x00, 0x00 },
    { 8,  1024, 72, 0x30, 0x30, 0x00, 0x00 },
    { 8,  1280, 60, 0x80, 0xC0, 0x00, 0x00 },
    { 8,  1280, 72, 0xC0, 0xC0, 0x00, 0x00 },

    // The Metheus Premier 928 ship with DACs that all do 5-6-5 in the 1xx
    // modes, so we won't bother listing any '15bpp' modes that we know
    // won't work.  The Metheus BIOS also only ever does 60 Hz at 16bpp.

    { 16, 640,  60, 0x02, 0x03, 0x00, 0x00 },
    { 16, 800,  60, 0x08, 0x0C, 0x00, 0x00 },
    { 16, 1024, 60, 0x20, 0x30, 0x00, 0x00 },
    { 16, 1280, 60, 0x80, 0xC0, 0x00, 0x00 },

    { 32, 640,  60, 0x02, 0x03, 0x00, 0x00 },
    { 32, 640,  72, 0x03, 0x03, 0x00, 0x00 },
    { 32, 800,  60, 0x08, 0x0C, 0x00, 0x00 },
    { 32, 800,  72, 0x0C, 0x0C, 0x00, 0x00 },
    { 32, 1024, 60, 0x20, 0x30, 0x00, 0x00 },
    { 32, 1024, 72, 0x30, 0x30, 0x00, 0x00 },
    { 32, 1280, 60, 0x80, 0xC0, 0x00, 0x00 },
    { 32, 1280, 72, 0xC0, 0xC0, 0x00, 0x00 },

    { 0 }   // Mark the end
};

/******************************************************************************
 * Streams minimum stretch ratios, multiplied by 1000, for every mode.
 *
 *****************************************************************************/

K2TABLE K2WidthRatio[] = {

    { 1024, 16, 43, 0x10, 40, 1000 },
    { 1024, 16, 60, 0x10, 40, 2700 },
    { 1024, 16, 70, 0x10, 40, 2900 },
    { 1024, 16, 75, 0x10, 40, 2900 },
    { 1024, 16, 43, 0x13, 60, 1000 },
    { 1024, 16, 60, 0x13, 60, 3500 },
    { 1024, 16, 70, 0x13, 60, 3500 },
    { 1024, 16, 75, 0x13, 60, 4000 },
    { 1024, 16, 43, 0x13, 57, 1000 },
    { 1024, 16, 60, 0x13, 57, 3500 },
    { 1024, 16, 70, 0x13, 57, 3500 },
    { 1024, 16, 75, 0x13, 57, 4000 },
    { 1024, 8, 43, 0x00, 40, 1500 },
    { 1024, 8, 43, 0x10, 40, 1500 },
    { 1024, 8, 60, 0x00, 40, 2000 },
    { 1024, 8, 60, 0x10, 40, 1200 },
    { 1024, 8, 70, 0x00, 40, 3000 },
    { 1024, 8, 70, 0x10, 40, 1500 },
    { 1024, 8, 75, 0x00, 40, 3300 },
    { 1024, 8, 75, 0x10, 40, 1500 },
    { 1024, 8, 85, 0x00, 40, 4000 },
    { 1024, 8, 85, 0x10, 40, 1700 },
    { 1024, 8, 43, 0x03, 60, 1000 },
    { 1024, 8, 43, 0x13, 60, 1000 },
    { 1024, 8, 60, 0x03, 60, 3500 },
    { 1024, 8, 60, 0x13, 60, 1300 },
    { 1024, 8, 70, 0x03, 60, 4000 },
    { 1024, 8, 70, 0x13, 60, 1500 },
    { 1024, 8, 75, 0x03, 60, 4300 },
    { 1024, 8, 75, 0x13, 60, 1700 },
    { 1024, 8, 85, 0x03, 60, 4300 },
    { 1024, 8, 85, 0x13, 60, 1700 },
    { 1024, 8, 43, 0x03, 57, 1000 },
    { 1024, 8, 43, 0x13, 57, 1000 },
    { 1024, 8, 60, 0x03, 57, 3500 },
    { 1024, 8, 60, 0x13, 57, 1300 },
    { 1024, 8, 70, 0x03, 57, 4000 },
    { 1024, 8, 70, 0x13, 57, 1500 },
    { 1024, 8, 75, 0x03, 57, 4300 },
    { 1024, 8, 75, 0x13, 57, 1700 },
    { 1024, 8, 85, 0x03, 57, 4300 },
    { 1024, 8, 85, 0x13, 57, 1700 },
    { 800, 16, 60, 0x10, 40, 1000 },
    { 800, 16, 72, 0x10, 40, 1200 },
    { 800, 16, 75, 0x10, 40, 1500 },
    { 800, 16, 85, 0x10, 40, 2000 },
    { 800, 16, 60, 0x13, 60, 1000 },
    { 800, 16, 72, 0x13, 60, 2000 },
    { 800, 16, 75, 0x13, 60, 2000 },
    { 800, 16, 85, 0x13, 60, 2000 },
    { 800, 16, 60, 0x13, 57, 1000 },
    { 800, 16, 72, 0x13, 57, 2000 },
    { 800, 16, 75, 0x13, 57, 2000 },
    { 800, 16, 85, 0x13, 57, 2000 },
    { 800, 8, 60, 0x00, 40, 1100 },
    { 800, 8, 60, 0x10, 40, 1000 },
    { 800, 8, 72, 0x00, 40, 1400 },
    { 800, 8, 72, 0x10, 40, 1000 },
    { 800, 8, 75, 0x00, 40, 1700 },
    { 800, 8, 75, 0x10, 40, 1000 },
    { 800, 8, 85, 0x00, 40, 1800 },
    { 800, 8, 85, 0x10, 40, 1200 },
    { 800, 8, 60, 0x03, 60, 2000 },
    { 800, 8, 60, 0x13, 60, 1000 },
    { 800, 8, 72, 0x03, 60, 2600 },
    { 800, 8, 72, 0x13, 60, 1000 },
    { 800, 8, 75, 0x03, 60, 2600 },
    { 800, 8, 75, 0x13, 60, 1000 },
    { 800, 8, 85, 0x03, 60, 3000 },
    { 800, 8, 85, 0x13, 60, 1000 },
    { 800, 8, 60, 0x03, 57, 2000 },
    { 800, 8, 60, 0x13, 57, 1000 },
    { 800, 8, 72, 0x03, 57, 2600 },
    { 800, 8, 72, 0x13, 57, 1000 },
    { 800, 8, 75, 0x03, 57, 2600 },
    { 800, 8, 75, 0x13, 57, 1000 },
    { 800, 8, 85, 0x13, 57, 1000 },
    { 640, 32, 60, 0x10, 40, 1000 },
    { 640, 32, 72, 0x10, 40, 1300 },
    { 640, 32, 75, 0x10, 40, 1500 },
    { 640, 32, 85, 0x10, 40, 1800 },
    { 640, 32, 60, 0x13, 60, 1000 },
    { 640, 32, 72, 0x13, 60, 2000 },
    { 640, 32, 75, 0x13, 60, 2000 },
    { 640, 32, 85, 0x13, 60, 2000 },
    { 640, 32, 60, 0x13, 57, 1000 },
    { 640, 32, 72, 0x13, 57, 2000 },
    { 640, 32, 75, 0x13, 57, 2000 },
    { 640, 32, 85, 0x13, 57, 2000 },
    { 640, 16, 60, 0x00, 40, 1000 },
    { 640, 16, 60, 0x10, 40, 1000 },
    { 640, 16, 72, 0x00, 40, 1000 },
    { 640, 16, 72, 0x10, 40, 1000 },
    { 640, 16, 75, 0x00, 40, 1300 },
    { 640, 16, 75, 0x10, 40, 1000 },
    { 640, 16, 85, 0x00, 40, 1800 },
    { 640, 16, 85, 0x10, 40, 1000 },
    { 640, 16, 60, 0x03, 60, 1150 },
    { 640, 16, 60, 0x13, 60, 1000 },
    { 640, 16, 72, 0x03, 60, 2200 },
    { 640, 16, 72, 0x13, 60, 1000 },
    { 640, 16, 75, 0x03, 60, 2200 },
    { 640, 16, 75, 0x13, 60, 1000 },
    { 640, 16, 85, 0x03, 60, 3000 },
    { 640, 16, 85, 0x13, 60, 1000 },
    { 640, 16, 60, 0x03, 57, 1150 },
    { 640, 16, 60, 0x13, 57, 1000 },
    { 640, 16, 72, 0x03, 57, 2200 },
    { 640, 16, 72, 0x13, 57, 1000 },
    { 640, 16, 75, 0x03, 57, 2200 },
    { 640, 16, 75, 0x13, 57, 1000 },
    { 640, 16, 85, 0x03, 57, 3000 },
    { 640, 16, 85, 0x13, 57, 1000 },
    { 640, 8, 60, 0x00, 40, 1000 },
    { 640, 8, 60, 0x10, 40, 1000 },
    { 640, 8, 72, 0x00, 40, 1000 },
    { 640, 8, 72, 0x10, 40, 1000 },
    { 640, 8, 75, 0x00, 40, 1000 },
    { 640, 8, 75, 0x10, 40, 1000 },
    { 640, 8, 85, 0x00, 40, 1000 },
    { 640, 8, 85, 0x10, 40, 1000 },
    { 640, 8, 60, 0x03, 60, 1000 },
    { 640, 8, 60, 0x13, 60, 1000 },
    { 640, 8, 72, 0x03, 60, 1300 },
    { 640, 8, 72, 0x13, 60, 1000 },
    { 640, 8, 75, 0x03, 60, 1500 },
    { 640, 8, 75, 0x13, 60, 1000 },
    { 640, 8, 85, 0x03, 60, 1000 },
    { 640, 8, 85, 0x13, 60, 1000 },
    { 640, 8, 60, 0x03, 57, 1000 },
    { 640, 8, 60, 0x13, 57, 1000 },
    { 640, 8, 72, 0x03, 57, 1300 },
    { 640, 8, 72, 0x13, 57, 1000 },
    { 640, 8, 75, 0x03, 57, 1500 },
    { 640, 8, 75, 0x13, 57, 1000 },
    { 640, 8, 85, 0x03, 57, 1000 },
    { 640, 8, 85, 0x13, 57, 1000 },
    { 1024, 16, 43, 0x10, 50, 1000 },
    { 1024, 16, 43, 0x12, 60, 1000 },
    { 1024, 16, 60, 0x10, 50, 2250 },
    { 1024, 16, 60, 0x12, 60, 3500 },
    { 1024, 16, 70, 0x10, 50, 2250 },
    { 1024, 16, 70, 0x12, 60, 3500 },
    { 1024, 16, 75, 0x10, 50, 2250 },
    { 1024, 16, 75, 0x12, 60, 4000 },
    { 1024, 8, 43, 0x00, 50, 1000 },
    { 1024, 8, 43, 0x10, 50, 1000 },
    { 1024, 8, 43, 0x02, 60, 1000 },
    { 1024, 8, 43, 0x12, 60, 1000 },
    { 1024, 8, 60, 0x00, 50, 3500 },
    { 1024, 8, 60, 0x10, 50, 1300 },
    { 1024, 8, 60, 0x02, 60, 3500 },
    { 1024, 8, 60, 0x12, 60, 1300 },
    { 1024, 8, 70, 0x00, 50, 4000 },
    { 1024, 8, 70, 0x10, 50, 1500 },
    { 1024, 8, 70, 0x02, 60, 4000 },
    { 1024, 8, 70, 0x12, 60, 1500 },
    { 1024, 8, 75, 0x00, 50, 4300 },
    { 1024, 8, 75, 0x10, 50, 1700 },
    { 1024, 8, 75, 0x02, 60, 4300 },
    { 1024, 8, 75, 0x12, 60, 1700 },
    { 1024, 8, 85, 0x00, 50, 4300 },
    { 1024, 8, 85, 0x10, 50, 1700 },
    { 1024, 8, 85, 0x02, 60, 4300 },
    { 1024, 8, 85, 0x12, 60, 1700 },
    { 800, 16, 60, 0x10, 50, 1000 },
    { 800, 16, 60, 0x12, 60, 1000 },
    { 800, 16, 72, 0x10, 50, 1600 },
    { 800, 16, 72, 0x12, 60, 2000 },
    { 800, 16, 75, 0x10, 50, 1000 },
    { 800, 16, 75, 0x12, 60, 2000 },
    { 800, 16, 85, 0x10, 50, 2000 },
    { 800, 16, 85, 0x12, 60, 2000 },
    { 800, 8, 60, 0x00, 50, 1300 },
    { 800, 8, 60, 0x10, 50, 1000 },
    { 800, 8, 60, 0x02, 60, 2000 },
    { 800, 8, 60, 0x12, 60, 1000 },
    { 800, 8, 72, 0x00, 50, 2300 },
    { 800, 8, 72, 0x10, 50, 1000 },
    { 800, 8, 72, 0x02, 60, 2600 },
    { 800, 8, 72, 0x12, 60, 1000 },
    { 800, 8, 75, 0x00, 50, 2300 },
    { 800, 8, 75, 0x10, 50, 1000 },
    { 800, 8, 75, 0x02, 60, 2600 },
    { 800, 8, 75, 0x12, 60, 1000 },
    { 800, 8, 85, 0x00, 50, 3000 },
    { 800, 8, 85, 0x10, 50, 1000 },
    { 800, 8, 85, 0x02, 60, 3000 },
    { 800, 8, 85, 0x12, 60, 1000 },
    { 640, 32, 60, 0x10, 50, 1000 },
    { 640, 32, 60, 0x12, 60, 1000 },
    { 640, 32, 72, 0x10, 50, 2000 },
    { 640, 32, 72, 0x12, 60, 2000 },
    { 640, 32, 75, 0x10, 50, 2000 },
    { 640, 32, 75, 0x12, 60, 2000 },
    { 640, 32, 85, 0x10, 50, 2000 },
    { 640, 32, 85, 0x12, 60, 2000 },
    { 640, 16, 60, 0x00, 50, 1000 },
    { 640, 16, 60, 0x10, 50, 1000 },
    { 640, 16, 60, 0x02, 60, 1150 },
    { 640, 16, 60, 0x12, 60, 1000 },
    { 640, 16, 72, 0x00, 50, 1000 },
    { 640, 16, 72, 0x10, 50, 1000 },
    { 640, 16, 72, 0x02, 60, 2200 },
    { 640, 16, 72, 0x12, 60, 1000 },
    { 640, 16, 75, 0x00, 50, 2300 },
    { 640, 16, 75, 0x10, 50, 1000 },
    { 640, 16, 75, 0x02, 60, 2200 },
    { 640, 16, 75, 0x12, 60, 1000 },
    { 640, 16, 85, 0x00, 50, 3000 },
    { 640, 16, 85, 0x10, 50, 1000 },
    { 640, 16, 85, 0x02, 60, 3000 },
    { 640, 16, 85, 0x12, 60, 1000 },
    { 640, 8, 60, 0x00, 50, 1000 },
    { 640, 8, 60, 0x10, 50, 1000 },
    { 640, 8, 60, 0x02, 60, 1000 },
    { 640, 8, 60, 0x12, 60, 1000 },
    { 640, 8, 72, 0x00, 50, 1000 },
    { 640, 8, 72, 0x10, 50, 1000 },
    { 640, 8, 72, 0x02, 60, 1300 },
    { 640, 8, 72, 0x12, 60, 1000 },
    { 640, 8, 75, 0x00, 50, 1000 },
    { 640, 8, 75, 0x10, 50, 1000 },
    { 640, 8, 75, 0x02, 60, 1500 },
    { 640, 8, 75, 0x12, 60, 1000 },
    { 640, 8, 85, 0x00, 50, 1000 },
    { 640, 8, 85, 0x10, 50, 1000 },
    { 640, 8, 85, 0x02, 60, 1000 },
    { 640, 8, 85, 0x12, 60, 1000 },
    { 0 }    // Mark the end
};

/******************************************************************************
 * Streams FIFO values for every mode.
 *
 *****************************************************************************/

K2TABLE K2FifoValue[] = {

    { 1024, 16, 43, 0x10, 40, 0x04a10c },
    { 1024, 16, 60, 0x10, 40, 0x04acc8 },
    { 1024, 16, 70, 0x10, 40, 0x04acc8 },
    { 1024, 16, 75, 0x10, 40, 0x04acc8 },
    { 1024, 16, 85, 0x10, 40, 0x04acc8 },
    { 1024, 16, 43, 0x13, 60, 0x00214c },
    { 1024, 16, 60, 0x13, 60, 0x00214c },
    { 1024, 16, 70, 0x13, 60, 0x00214c },
    { 1024, 16, 75, 0x13, 60, 0x00214c },
    { 1024, 16, 43, 0x13, 57, 0x00214c },
    { 1024, 16, 60, 0x13, 57, 0x00214c },
    { 1024, 16, 70, 0x13, 57, 0x00214c },
    { 1024, 16, 75, 0x13, 57, 0x00214c },
    { 1024, 8, 43, 0x00, 40, 0x00a10c },
    { 1024, 8, 43, 0x10, 40, 0x04a10c },
    { 1024, 8, 60, 0x00, 40, 0x00a10c },
    { 1024, 8, 60, 0x10, 40, 0x04a10c },
    { 1024, 8, 70, 0x00, 40, 0x00a14c },
    { 1024, 8, 70, 0x10, 40, 0x04a10c },
    { 1024, 8, 75, 0x00, 40, 0x01a10c },
    { 1024, 8, 75, 0x10, 40, 0x04a10c },
    { 1024, 8, 85, 0x00, 40, 0x00a10c },
    { 1024, 8, 85, 0x10, 40, 0x04a14c },
    { 1024, 8, 43, 0x03, 60, 0x00290c },
    { 1024, 8, 43, 0x13, 60, 0x00190c },
    { 1024, 8, 60, 0x03, 60, 0x00216c },
    { 1024, 8, 60, 0x13, 60, 0x00214c },
    { 1024, 8, 70, 0x03, 60, 0x00294c },
    { 1024, 8, 70, 0x13, 60, 0x00214c },
    { 1024, 8, 75, 0x03, 60, 0x00254c },
    { 1024, 8, 75, 0x13, 60, 0x00214c },
    { 1024, 8, 85, 0x03, 60, 0x00290c },
    { 1024, 8, 85, 0x13, 60, 0x00250c },
    { 1024, 8, 43, 0x03, 57, 0x00290c },
    { 1024, 8, 43, 0x13, 57, 0x00190c },
    { 1024, 8, 60, 0x03, 57, 0x00216c },
    { 1024, 8, 60, 0x13, 57, 0x00214c },
    { 1024, 8, 70, 0x03, 57, 0x00294c },
    { 1024, 8, 70, 0x13, 57, 0x00214c },
    { 1024, 8, 75, 0x03, 57, 0x00254c },
    { 1024, 8, 75, 0x13, 57, 0x00214c },
    { 1024, 8, 85, 0x03, 57, 0x00290c },
    { 1024, 8, 85, 0x13, 57, 0x00250c },
    { 800, 16, 60, 0x10, 40, 0x04a10c },
    { 800, 16, 72, 0x10, 40, 0x04a14c },
    { 800, 16, 75, 0x10, 40, 0x04a14c },
    { 800, 16, 85, 0x10, 40, 0x04a14c },
    { 800, 16, 60, 0x13, 60, 0x00290c },
    { 800, 16, 72, 0x13, 60, 0x0030c8 },
    { 800, 16, 75, 0x13, 60, 0x0030c8 },
    { 800, 16, 85, 0x13, 60, 0x00250c },
    { 800, 16, 60, 0x13, 57, 0x00290c },
    { 800, 16, 72, 0x13, 57, 0x0030c8 },
    { 800, 16, 75, 0x13, 57, 0x0030c8 },
    { 800, 16, 85, 0x13, 57, 0x00250c },
    { 800, 8, 60, 0x00, 40, 0x00a10c },
    { 800, 8, 60, 0x10, 40, 0x04a10c },
    { 800, 8, 72, 0x00, 40, 0x00a10c },
    { 800, 8, 72, 0x10, 40, 0x04a14c },
    { 800, 8, 75, 0x00, 40, 0x00a10c },
    { 800, 8, 75, 0x10, 40, 0x04ad4c },
    { 800, 8, 85, 0x00, 40, 0x00a10c },
    { 800, 8, 85, 0x10, 40, 0x04a10c },
    { 800, 8, 60, 0x03, 60, 0x00212c },
    { 800, 8, 60, 0x13, 60, 0x00214c },
    { 800, 8, 72, 0x03, 60, 0x00210c },
    { 800, 8, 72, 0x13, 60, 0x00214c },
    { 800, 8, 72, 0x13, 60, 0x00214c },
    { 800, 8, 75, 0x03, 60, 0x00210c },
    { 800, 8, 75, 0x13, 60, 0x00214c },
    { 800, 8, 85, 0x03, 60, 0x00290c },
    { 800, 8, 85, 0x13, 60, 0x00250c },
    { 800, 8, 60, 0x03, 57, 0x00212c },
    { 800, 8, 60, 0x13, 57, 0x00214c },
    { 800, 8, 72, 0x03, 57, 0x00210c },
    { 800, 8, 72, 0x13, 57, 0x00214c },
    { 800, 8, 75, 0x03, 57, 0x00210c },
    { 800, 8, 75, 0x13, 57, 0x00214c },
    { 800, 8, 85, 0x03, 57, 0x00290c },
    { 800, 8, 85, 0x13, 57, 0x00250c },
    { 640, 32, 60, 0x10, 40, 0x04a14c },
    { 640, 32, 72, 0x10, 40, 0x04a14c },
    { 640, 32, 75, 0x10, 40, 0x04b4c8 },
    { 640, 32, 85, 0x10, 40, 0x04acc8 },
    { 640, 32, 60, 0x13, 60, 0x0028c8 },
    { 640, 32, 72, 0x13, 60, 0x00190c },
    { 640, 32, 75, 0x13, 60, 0x0028c8 },
    { 640, 32, 85, 0x13, 60, 0x0028c8 },
    { 640, 32, 60, 0x13, 57, 0x0028c8 },
    { 640, 32, 72, 0x13, 57, 0x00190c },
    { 640, 32, 75, 0x13, 57, 0x0028c8 },
    { 640, 32, 85, 0x13, 57, 0x0028c8 },
    { 640, 16, 60, 0x00, 40, 0x00990c },
    { 640, 16, 60, 0x10, 40, 0x04a10c },
    { 640, 16, 72, 0x00, 40, 0x00a10c },
    { 640, 16, 72, 0x10, 40, 0x04a10c },
    { 640, 16, 75, 0x00, 40, 0x00a10c },
    { 640, 16, 75, 0x10, 40, 0x04a10c },
    { 640, 16, 85, 0x00, 40, 0x00a10c },
    { 640, 16, 85, 0x10, 40, 0x04a10c },
    { 640, 16, 60, 0x03, 60, 0x00190c },
    { 640, 16, 60, 0x13, 60, 0x00214c },
    { 640, 16, 72, 0x03, 60, 0x00190c },
    { 640, 16, 72, 0x13, 60, 0x001910 },
    { 640, 16, 75, 0x03, 60, 0x00190c },
    { 640, 16, 75, 0x13, 60, 0x001910 },
    { 640, 16, 85, 0x03, 60, 0x00190c },
    { 640, 16, 85, 0x13, 60, 0x00250c },
    { 640, 16, 60, 0x03, 57, 0x00190c },
    { 640, 16, 60, 0x13, 57, 0x00214c },
    { 640, 16, 72, 0x03, 57, 0x00190c },
    { 640, 16, 75, 0x03, 57, 0x00190c },
    { 640, 16, 75, 0x13, 57, 0x001910 },
    { 640, 16, 85, 0x03, 57, 0x00190c },
    { 640, 16, 85, 0x13, 57, 0x00250c },
    { 640, 8, 60, 0x00, 40, 0x009910 },
    { 640, 8, 60, 0x10, 40, 0x049910 },
    { 640, 8, 72, 0x00, 40, 0x009910 },
    { 640, 8, 72, 0x10, 40, 0x049910 },
    { 640, 8, 75, 0x00, 40, 0x00a10c },
    { 640, 8, 75, 0x10, 40, 0x049910 },
    { 640, 8, 85, 0x00, 40, 0x00a10c },
    { 640, 8, 85, 0x10, 40, 0x049910 },
    { 640, 8, 60, 0x03, 60, 0x00252c },
    { 640, 8, 60, 0x13, 60, 0x001990 },
    { 640, 8, 72, 0x03, 60, 0x00252c },
    { 640, 8, 72, 0x13, 60, 0x00190c },
    { 640, 8, 75, 0x03, 60, 0x00252c },
    { 640, 8, 75, 0x13, 60, 0x001990 },
    { 640, 8, 85, 0x03, 60, 0x00190c },
    { 640, 8, 85, 0x13, 60, 0x00190c },
    { 640, 8, 60, 0x03, 57, 0x00252c },
    { 640, 8, 60, 0x13, 57, 0x001990 },
    { 640, 8, 72, 0x03, 57, 0x00252c },
    { 640, 8, 72, 0x13, 57, 0x00190c },
    { 640, 8, 75, 0x03, 57, 0x00252c },
    { 640, 8, 75, 0x13, 57, 0x001990 },
    { 640, 8, 85, 0x03, 57, 0x00190c },
    { 640, 8, 85, 0x13, 57, 0x00190c },
    { 1024, 16, 43, 0x10, 50, 0x04a10c },
    { 1024, 16, 43, 0x12, 60, 0x001510 },
    { 1024, 16, 60, 0x10, 50, 0x04acc8 },
    { 1024, 16, 60, 0x12, 60, 0x001510 },
    { 1024, 16, 70, 0x10, 50, 0x04acc8 },
    { 1024, 16, 70, 0x12, 60, 0x001510 },
    { 1024, 16, 75, 0x10, 50, 0x04acc8 },
    { 1024, 16, 75, 0x12, 60, 0x001510 },
    { 1024, 16, 85, 0x10, 50, 0x04acc8 },
    { 1024, 16, 85, 0x12, 60, 0x001510 },
    { 1024, 8, 43, 0x00, 50, 0x00a10c },
    { 1024, 8, 43, 0x02, 60, 0x01a90c },
    { 1024, 8, 43, 0x10, 50, 0x04a10c },
    { 1024, 8, 43, 0x12, 60, 0x001510 },
    { 1024, 8, 60, 0x00, 50, 0x00a10c },
    { 1024, 8, 60, 0x02, 60, 0x00216c },
    { 1024, 8, 60, 0x10, 50, 0x04a14c },
    { 1024, 8, 60, 0x12, 60, 0x00214c },
    { 1024, 8, 70, 0x00, 50, 0x00a10c },
    { 1024, 8, 70, 0x02, 60, 0x00294c },
    { 1024, 8, 70, 0x10, 50, 0x04a14c },
    { 1024, 8, 70, 0x12, 60, 0x00214c },
    { 1024, 8, 75, 0x00, 50, 0x00a14c },
    { 1024, 8, 75, 0x02, 60, 0x00254c },
    { 1024, 8, 75, 0x10, 50, 0x04a14c },
    { 1024, 8, 75, 0x12, 60, 0x00214c },
    { 1024, 8, 85, 0x00, 50, 0x00a10c },
    { 1024, 8, 85, 0x02, 60, 0x01a90c },
    { 1024, 8, 85, 0x10, 50, 0x04a10c },
    { 1024, 8, 85, 0x12, 60, 0x001510 },
    { 800, 16, 60, 0x10, 50, 0x04a10c },
    { 800, 16, 60, 0x12, 60, 0x00290c },
    { 800, 16, 72, 0x10, 50, 0x04a10c },
    { 800, 16, 72, 0x12, 60, 0x0030c8 },
    { 800, 16, 75, 0x10, 50, 0x04a10c },
    { 800, 16, 75, 0x12, 60, 0x0030c8 },
    { 800, 16, 85, 0x10, 50, 0x04acc8 },
    { 800, 16, 85, 0x12, 60, 0x00294c },
    { 800, 8, 60, 0x00, 50, 0x00a12c },
    { 800, 8, 60, 0x02, 60, 0x00212c },
    { 800, 8, 60, 0x10, 50, 0x04990c },
    { 800, 8, 60, 0x12, 60, 0x00214c },
    { 800, 8, 72, 0x00, 50, 0x00a10c },
    { 800, 8, 72, 0x02, 60, 0x00210c },
    { 800, 8, 72, 0x10, 50, 0x04990c },
    { 800, 8, 72, 0x12, 60, 0x00214c },
    { 800, 8, 75, 0x00, 50, 0x00a10c },
    { 800, 8, 75, 0x02, 60, 0x00210c },
    { 800, 8, 75, 0x10, 50, 0x04990c },
    { 800, 8, 75, 0x12, 60, 0x00214c },
    { 800, 8, 85, 0x00, 50, 0x00a10c },
    { 800, 8, 85, 0x02, 60, 0x01a90c },
    { 800, 8, 85, 0x10, 50, 0x04990c },
    { 800, 8, 85, 0x12, 60, 0x001990 },
    { 640, 32, 60, 0x10, 50, 0x04a10c },
    { 640, 32, 60, 0x12, 60, 0x0028c8 },
    { 640, 32, 72, 0x10, 50, 0x04a10c },
    { 640, 32, 72, 0x12, 60, 0x0038c8 },
    { 640, 32, 75, 0x10, 50, 0x04a10c },
    { 640, 32, 75, 0x12, 60, 0x0038c8 },
    { 640, 32, 85, 0x10, 50, 0x04acc8 },
    { 640, 32, 85, 0x12, 60, 0x0038c8 },
    { 640, 16, 60, 0x00, 50, 0x00990c },
    { 640, 16, 60, 0x02, 60, 0x00190c },
    { 640, 16, 60, 0x10, 50, 0x04a10c },
    { 640, 16, 60, 0x12, 60, 0x00214c },
    { 640, 16, 72, 0x00, 50, 0x00990c },
    { 640, 16, 72, 0x02, 60, 0x00190c },
    { 640, 16, 72, 0x10, 50, 0x04a10c },
    { 640, 16, 72, 0x12, 60, 0x00214c },
    { 640, 16, 75, 0x02, 60, 0x00294c },
    { 640, 16, 75, 0x10, 50, 0x04a10c },
    { 640, 16, 75, 0x12, 60, 0x00214c },
    { 640, 16, 85, 0x00, 50, 0x00a10c },
    { 640, 16, 85, 0x02, 60, 0x00294c },
    { 640, 16, 85, 0x10, 50, 0x04a10c },
    { 640, 16, 85, 0x12, 60, 0x00214c },
    { 640, 8, 60, 0x00, 50, 0x00990c },
    { 640, 8, 60, 0x02, 60, 0x00252c },
    { 640, 8, 60, 0x10, 50, 0x049910 },
    { 640, 8, 60, 0x12, 60, 0x001990 },
    { 640, 8, 72, 0x00, 50, 0x00990c },
    { 640, 8, 72, 0x02, 60, 0x00252c },
    { 640, 8, 72, 0x10, 50, 0x049910 },
    { 640, 8, 72, 0x12, 60, 0x00190c },
    { 640, 8, 75, 0x00, 50, 0x00990c },
    { 640, 8, 75, 0x02, 60, 0x00252c },
    { 640, 8, 75, 0x10, 50, 0x049910 },
    { 640, 8, 75, 0x12, 60, 0x001990 },
    { 640, 8, 85, 0x00, 50, 0x00990c },
    { 640, 8, 85, 0x02, 60, 0x001990 },
    { 640, 8, 85, 0x10, 50, 0x049910 },
    { 640, 8, 85, 0x12, 60, 0x001990 },
    { 0 }    // Mark the end
};

/*****************************************************************************
 * Generic S3 hard-wired mode-sets.
 *
 ****************************************************************************/

S3_VIDEO_FREQUENCIES GenericFixedFrequencyTable[] = {

    { 8, 640,  60, 0,   (ULONG_PTR)crtc911_640x60Hz, (ULONG_PTR)crtc801_640x60Hz, (ULONG_PTR)crtc928_640x60Hz, (ULONG_PTR)crtc864_640x60Hz },
    { 8, 640,  72, 0xB, (ULONG_PTR)crtc911_640x70Hz, (ULONG_PTR)crtc801_640x70Hz, (ULONG_PTR)crtc928_640x70Hz, (ULONG_PTR)crtc864_640x70Hz },
    { 8, 800,  60, 0x2, (ULONG_PTR)crtc911_800x60Hz, (ULONG_PTR)crtc801_800x60Hz, (ULONG_PTR)crtc928_800x60Hz, (ULONG_PTR)crtc864_800x60Hz },
    { 8, 800,  72, 0x4, (ULONG_PTR)crtc911_800x70Hz, (ULONG_PTR)crtc801_800x70Hz, (ULONG_PTR)crtc928_800x70Hz, (ULONG_PTR)crtc864_800x70Hz },
    { 8, 1024, 60, 0xD, (ULONG_PTR)crtc911_1024x60Hz, (ULONG_PTR)crtc801_1024x60Hz, (ULONG_PTR)crtc928_1024x60Hz, (ULONG_PTR)crtc864_1024x60Hz },
    { 8, 1024, 72, 0xE, (ULONG_PTR)crtc911_1024x70Hz, (ULONG_PTR)crtc801_1024x70Hz, (ULONG_PTR)crtc928_1024x70Hz, (ULONG_PTR)crtc864_1024x70Hz },

    { 16, 640,  60, 0,   (ULONG_PTR)NULL, (ULONG_PTR)NULL, (ULONG_PTR)NULL, (ULONG_PTR)crtc864_640x60Hz_16bpp  },
    { 16, 640,  72, 0xB, (ULONG_PTR)NULL, (ULONG_PTR)NULL, (ULONG_PTR)NULL, (ULONG_PTR)crtc864_640x70Hz_16bpp  },
    { 16, 800,  60, 0x2, (ULONG_PTR)NULL, (ULONG_PTR)NULL, (ULONG_PTR)NULL, (ULONG_PTR)crtc864_800x60Hz_16bpp  },
    { 16, 800,  72, 0x4, (ULONG_PTR)NULL, (ULONG_PTR)NULL, (ULONG_PTR)NULL, (ULONG_PTR)crtc864_800x70Hz_16bpp  },
    { 16, 1024, 60, 0xD, (ULONG_PTR)NULL, (ULONG_PTR)NULL, (ULONG_PTR)NULL, (ULONG_PTR)crtc864_1024x60Hz_16bpp },
    { 16, 1024, 72, 0xE, (ULONG_PTR)NULL, (ULONG_PTR)NULL, (ULONG_PTR)NULL, (ULONG_PTR)crtc864_1024x70Hz_16bpp },

    { 0 }   // Mark the end
};

/*****************************************************************************
 * Orchid hard-wired mode-sets.
 *
 ****************************************************************************/

S3_VIDEO_FREQUENCIES OrchidFixedFrequencyTable[] = {

    { 8, 640,  60, 0x0, (ULONG_PTR)crtc911_640x60Hz, (ULONG_PTR)crtc801_640x60Hz, (ULONG_PTR)crtc928_640x60Hz,  (ULONG_PTR)NULL },
    { 8, 640,  72, 0x2, (ULONG_PTR)crtc911_640x70Hz, (ULONG_PTR)crtc801_640x70Hz, (ULONG_PTR)crtc928_640x70Hz,  (ULONG_PTR)NULL },
    { 8, 800,  60, 0x4, (ULONG_PTR)crtc911_800x60Hz, (ULONG_PTR)crtc801_800x60Hz, (ULONG_PTR)crtc928_800x60Hz,  (ULONG_PTR)NULL },
    { 8, 800,  72, 0x6, (ULONG_PTR)crtc911_800x70Hz, (ULONG_PTR)crtc801_800x70Hz, (ULONG_PTR)crtc928_800x70Hz,  (ULONG_PTR)NULL },
    { 8, 1024, 60, 0x7, (ULONG_PTR)crtc911_1024x60Hz, (ULONG_PTR)crtc801_1024x60Hz, (ULONG_PTR)crtc928_1024x60Hz, (ULONG_PTR)NULL },
    { 8, 1024, 72, 0xB, (ULONG_PTR)crtc911_1024x70Hz, (ULONG_PTR)crtc801_1024x70Hz, (ULONG_PTR)crtc928_1024x70Hz, (ULONG_PTR)NULL },

    { 0 }   // Mark the end
};

/*****************************************************************************
 * Number 9 hard-wired mode-sets.
 *
 ****************************************************************************/

S3_VIDEO_FREQUENCIES NumberNine928NewFixedFrequencyTable[] = {

    { 8, 640,  60, 25175000, (ULONG_PTR)crtc911_640x60Hz, (ULONG_PTR)crtc801_640x60Hz, (ULONG_PTR)crtc928_640x60Hz, (ULONG_PTR)NULL },
    { 8, 640,  72, 31500000, (ULONG_PTR)crtc911_640x70Hz, (ULONG_PTR)crtc801_640x70Hz, (ULONG_PTR)crtc928_640x70Hz, (ULONG_PTR)NULL },
    { 8, 800,  60, 40000000, (ULONG_PTR)crtc911_800x60Hz, (ULONG_PTR)crtc801_800x60Hz, (ULONG_PTR)crtc928_800x60Hz, (ULONG_PTR)NULL },
    { 8, 800,  72, 50000000, (ULONG_PTR)crtc911_800x70Hz, (ULONG_PTR)crtc801_800x70Hz, (ULONG_PTR)crtc928_800x70Hz, (ULONG_PTR)NULL },
    { 8, 1024, 60, 65000000, (ULONG_PTR)crtc911_1024x60Hz, (ULONG_PTR)crtc801_1024x60Hz, (ULONG_PTR)crtc928_1024x60Hz, (ULONG_PTR)NULL },
    { 8, 1024, 72, 77000000, (ULONG_PTR)crtc911_1024x70Hz, (ULONG_PTR)crtc801_1024x70Hz, (ULONG_PTR)crtc928_1024x70Hz, (ULONG_PTR)NULL },
    { 8, 1280, 60, 55000000, (ULONG_PTR)NULL, (ULONG_PTR)NULL, (ULONG_PTR)crtc928_1280x60Hz, (ULONG_PTR)NULL },
    { 8, 1280, 72, 64000000, (ULONG_PTR)NULL, (ULONG_PTR)NULL, (ULONG_PTR)crtc928_1280x70Hz, (ULONG_PTR)NULL },

    { 0 }   // Mark the end
};


#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\s3\mini\s3.c ===
/*++

Copyright (c) 1990-1997  Microsoft Corporation

Module Name:

    s3.c

Abstract:

    This module contains the code that implements the S3 miniport driver.

Environment:

    Kernel mode

Revision History:

--*/

#include "s3.h"
#include "cmdcnst.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,S3FindAdapter)
#pragma alloc_text(PAGE,S3RegistryCallback)
#pragma alloc_text(PAGE,S3Initialize)
#pragma alloc_text(PAGE,S3StartIO)
#pragma alloc_text(PAGE,S3SetColorLookup)
#pragma alloc_text(PAGE,CompareRom)

#pragma alloc_text(PAGE,LockExtendedRegs)
#pragma alloc_text(PAGE,UnlockExtendedRegs)
#pragma alloc_text(PAGE,S3RecordChipType)
#pragma alloc_text(PAGE,S3IsaDetection)
#pragma alloc_text(PAGE,S3GetInfo)
#pragma alloc_text(PAGE,S3DetermineFrequencyTable)
#pragma alloc_text(PAGE,S3DetermineDACType)
#pragma alloc_text(PAGE,S3DetermineMemorySize)
#pragma alloc_text(PAGE,S3ValidateModes)
#pragma alloc_text(PAGE,AlphaDetermineMemoryUsage)

#pragma alloc_text(PAGE, Set_Oem_Clock)

#pragma alloc_text(PAGE,Set864MemoryTiming)
#pragma alloc_text(PAGE,QueryStreamsParameters)

/*****************************************************************************
 *
 * IMPORTANT:
 *
 * SetHWMode is called from within S3ResetHw.  Paging will be disabled during
 * calls to S3ResetHw.  Because of this S3ResetHw and all of the routines
 * it calls can not be pageable.
 *
 ****************************************************************************/

// #pragma alloc_text(PAGE, S3ResetHW)
// #pragma alloc_text(PAGE, ZeroMemAndDac)
// #pragma alloc_text(PAGE, SetHWMode)
// #pragma alloc_text(PAGE, Wait_Vsync)

#if (_WIN32_WINNT >= 0x500)

#pragma alloc_text(PAGE, S3GetChildDescriptor)
#pragma alloc_text(PAGE, S3GetPowerState)
#pragma alloc_text(PAGE, S3SetPowerState)

#endif


#endif

#define QUERY_MONITOR_ID            0x22446688
#define QUERY_NONDDC_MONITOR_ID     0x11223344


ULONG
DriverEntry (
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    Context1 - First context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

    Context2 - Second context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

Return Value:

    Status from VideoPortInitialize()

--*/

{

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG initializationStatus;
    ULONG status;

    //
    // Zero out structure.
    //

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    //
    // Specify sizes of structure and extension.
    //

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitData.HwFindAdapter = S3FindAdapter;
    hwInitData.HwInitialize = S3Initialize;
    hwInitData.HwInterrupt = NULL;
    hwInitData.HwStartIO = S3StartIO;
    hwInitData.HwResetHw = S3ResetHw;

    //
    // New NT 5.0 EntryPoint
    //

#if (_WIN32_WINNT >= 0x500)

    hwInitData.HwGetVideoChildDescriptor = S3GetChildDescriptor;
    hwInitData.HwGetPowerState = S3GetPowerState;
    hwInitData.HwSetPowerState = S3SetPowerState;

    hwInitData.HwLegacyResourceList  = S3AccessRanges;
    hwInitData.HwLegacyResourceCount = NUM_S3_ACCESS_RANGES;

#endif

    //
    // Determine the size we require for the device extension.
    //

    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    //
    // Always start with parameters for device0 in this case.
    //

//    hwInitData.StartingDeviceNumber = 0;

    //
    // Once all the relevant information has been stored, call the video
    // port driver to do the initialization.
    // For this device we will repeat this call four times, for ISA, EISA
    // Internal and PCI.
    // We will return the minimum of all return values.
    //

    //
    // We will try the PCI bus first so that our ISA detection does'nt claim
    // PCI cards.
    //

    //
    // NOTE: since this driver only supports one adapter, we will return
    // as soon as we find a device, without going on to the following buses.
    // Normally one would call for each bus type and return the smallest
    // value.
    //

    hwInitData.AdapterInterfaceType = PCIBus;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    if (initializationStatus == NO_ERROR)
    {
        return initializationStatus;
    }

    hwInitData.AdapterInterfaceType = MicroChannel;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    //
    // Return immediately instead of checkin for smallest return code.
    //

    if (initializationStatus == NO_ERROR)
    {
        return initializationStatus;
    }


    hwInitData.AdapterInterfaceType = Isa;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    //
    // Return immediately instead of checkin for smallest return code.
    //

    if (initializationStatus == NO_ERROR)
    {
        return initializationStatus;
    }


    hwInitData.AdapterInterfaceType = Eisa;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    //
    // Return immediately instead of checkin for smallest return code.
    //

    if (initializationStatus == NO_ERROR)
    {
        return initializationStatus;
    }



    hwInitData.AdapterInterfaceType = Internal;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    return initializationStatus;

} // end DriverEntry()


ULONG
S3GetChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    )

/*++

Routine Description:

    Enumerate all devices controlled by the ATI graphics chip.
    This includes DDC monitors attached to the board, as well as other devices
    which may be connected to a proprietary bus.

Arguments:

    HwDeviceExtension - Pointer to our hardware device extension structure.

    ChildIndex        - Index of the child the system wants informaion for.

    pChildType        - Type of child we are enumerating - monitor, I2C ...

    pChildDescriptor  - Identification structure of the device (EDID, string)

    ppHwId            - Private unique 32 bit ID to passed back to the miniport

    pMoreChildren     - Should the miniport be called

Return Value:

    TRUE if the child device existed, FALSE if it did not.

Note:

    In the event of a failure return, none of the fields are valid except for
    the return value and the pMoreChildren field.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG                Status;

    switch (ChildEnumInfo->ChildIndex) {
    case 0:

        //
        // Case 0 is used to enumerate devices found by the ACPI firmware.
        //
        // Since we do not support ACPI devices yet, we must return failure.
        //

        Status = ERROR_NO_MORE_DEVICES;
        break;

    case 1:

        //
        // This is the last device we enumerate.  Tell the system we don't
        // have any more.
        //

        *pChildType = Monitor;

        //
        // Obtain the EDID structure via DDC.
        //


        if (GetDdcInformation(HwDeviceExtension,
                              pvChildDescriptor,
                              ChildEnumInfo->ChildDescriptorSize))
        {
            *pHwId = QUERY_MONITOR_ID;

            VideoDebugPrint((1, "S3GetChildDescriptor - successfully read EDID structure\n"));

        } else {

            //
            // Alway return TRUE, since we always have a monitor output
            // on the card and it just may not be a detectable device.
            //

            *pHwId = QUERY_NONDDC_MONITOR_ID;

            VideoDebugPrint((1, "S3GetChildDescriptor - DDC not supported\n"));

        }

        Status = ERROR_MORE_DATA;
        break;

    case DISPLAY_ADAPTER_HW_ID:

        //
        // Special ID to handle return legacy PnP IDs for root enumerated
        // devices.
        //

        *pChildType = VideoChip;
        *pHwId      = DISPLAY_ADAPTER_HW_ID;

        if ( (hwDeviceExtension->ChipID == S3_911) ||
             (hwDeviceExtension->ChipID == S3_928) )
        {
            memcpy(pvChildDescriptor, L"*PNP0909", sizeof(L"*PNP0909"));
        }
        else
        {
            memcpy(pvChildDescriptor, L"*PNP0913", sizeof(L"*PNP0913"));
        }

        Status = ERROR_MORE_DATA;
        break;


    default:

        Status = ERROR_NO_MORE_DEVICES;
        break;
    }


    return Status;
}


VP_STATUS
S3GetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    )

/*++

Routine Description:

    This function is called to see if a given device can go into a given
    power state.

Arguments:

    HwDeviceExtension    - Pointer to our hardware device extension structure.


    HwDeviceId           - Private unique 32 bit ID identifing the device.
                           0xFFFFFFFF indicates the S3 card itself.

    VideoPowerManagement - Pointer to the power management structure which
                           indicates the power state in question.

Return Value:

    NO_ERROR if the device can go into the requested power state,
    otherwise an appropriate error code is returned.

--*/

{
    //
    // We only support power setting for the monitor.  Make sure the
    // HwDeviceId matches one the the monitors we could report.
    //

    if ((HwDeviceId == QUERY_NONDDC_MONITOR_ID) ||
        (HwDeviceId == QUERY_MONITOR_ID)) {

        VIDEO_X86_BIOS_ARGUMENTS biosArguments;

        //
        // We are querying the power support for the monitor.
        //

        if ((VideoPowerManagement->PowerState == VideoPowerOn) ||
            (VideoPowerManagement->PowerState == VideoPowerHibernate) ||
            (VideoPowerManagement->PowerState == VideoPowerShutdown)) {

            return NO_ERROR;
        }

        VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

        biosArguments.Eax = VESA_POWER_FUNCTION;
        biosArguments.Ebx = VESA_GET_POWER_FUNC;

        VideoPortInt10(HwDeviceExtension, &biosArguments);

        if ((biosArguments.Eax & 0xffff) == VESA_STATUS_SUCCESS) {

            switch (VideoPowerManagement->PowerState) {

            case VideoPowerStandBy:
                return (biosArguments.Ebx & VESA_POWER_STANDBY) ?
                       NO_ERROR : ERROR_INVALID_FUNCTION;

            case VideoPowerSuspend:
                return (biosArguments.Ebx & VESA_POWER_SUSPEND) ?
                       NO_ERROR : ERROR_INVALID_FUNCTION;

            case VideoPowerOff:
                return (biosArguments.Ebx & VESA_POWER_OFF) ?
                       NO_ERROR : ERROR_INVALID_FUNCTION;

            default:

                break;
            }
        }

        VideoDebugPrint((1, "This device does not support Power Management.\n"));
        return ERROR_INVALID_FUNCTION;


    } else if (HwDeviceId == DISPLAY_ADAPTER_HW_ID) {

        //
        // We are querying power support for the graphics card.
        //

        switch (VideoPowerManagement->PowerState) {

            case VideoPowerStandBy:
            case VideoPowerOn:
            case VideoPowerHibernate:
            case VideoPowerShutdown:

                return NO_ERROR;

            case VideoPowerOff:
            case VideoPowerSuspend:

                //
                // Indicate that we can't do VideoPowerOff, because
                // we have no way of coming back when power is re-applied
                // to the card.
                //

                return ERROR_INVALID_FUNCTION;

            default:

                ASSERT(FALSE);
                return ERROR_INVALID_PARAMETER;
        }

    } else {

        VideoDebugPrint((1, "Unknown HwDeviceId"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}

VP_STATUS
S3SetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    )

/*++

Routine Description:

    Set the power state for a given device.

Arguments:

    HwDeviceExtension - Pointer to our hardware device extension structure.

    HwDeviceId        - Private unique 32 bit ID identifing the device.

    VideoPowerManagement - Power state information.

Return Value:

    TRUE if power state can be set,
    FALSE otherwise.

--*/

{
    //
    // Make sure we recognize the device.
    //

    if ((HwDeviceId == QUERY_NONDDC_MONITOR_ID) ||
        (HwDeviceId == QUERY_MONITOR_ID)) {

        VIDEO_X86_BIOS_ARGUMENTS biosArguments;

        VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

        biosArguments.Eax = VESA_POWER_FUNCTION;
        biosArguments.Ebx = VESA_SET_POWER_FUNC;

        switch (VideoPowerManagement->PowerState) {

        case VideoPowerOn:
        case VideoPowerHibernate:
            biosArguments.Ebx |= VESA_POWER_ON;
            break;

        case VideoPowerStandBy:
            biosArguments.Ebx |= VESA_POWER_STANDBY;
            break;

        case VideoPowerSuspend:
            biosArguments.Ebx |= VESA_POWER_SUSPEND;
            break;

        case VideoPowerOff:
            biosArguments.Ebx |= VESA_POWER_OFF;
            break;

        case VideoPowerShutdown:
            return NO_ERROR;

        default:
            VideoDebugPrint((1, "Unknown power state.\n"));
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
        }

        VideoPortInt10(HwDeviceExtension, &biosArguments);

        return NO_ERROR;

    } else if (HwDeviceId == DISPLAY_ADAPTER_HW_ID) {

        switch (VideoPowerManagement->PowerState) {
            case VideoPowerOn:
            case VideoPowerHibernate:
            case VideoPowerStandBy:
            case VideoPowerShutdown:

                return NO_ERROR;

            case VideoPowerSuspend:
            case VideoPowerOff:

                return ERROR_INVALID_PARAMETER;

            default:

                //
                // We indicated in S3GetPowerState that we couldn't
                // do VideoPowerOff.  So we should not get a call to
                // do it here.
                //

                ASSERT(FALSE);
                return ERROR_INVALID_PARAMETER;

        }

    } else {

        VideoDebugPrint((1, "Unknown HwDeviceId"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}



VP_STATUS
S3FindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    )

/*++

Routine Description:

    This routine is called to determine if the adapter for this driver
    is present in the system.
    If it is present, the function fills out some information describing
    the adapter.

Arguments:

    HwDeviceExtension - Supplies the miniport driver's adapter storage. This
        storage is initialized to zero before this call.

    HwContext - Supplies the context value which was passed to
        VideoPortInitialize(). Must be NULL for PnP drivers.

    ArgumentString - Suuplies a NULL terminated ASCII string. This string
        originates from the user.

    ConfigInfo - Returns the configuration information structure which is
        filled by the miniport driver. This structure is initialized with
        any knwon configuration information (such as SystemIoBusNumber) by
        the port driver. Where possible, drivers should have one set of
        defaults which do not require any supplied configuration information.

    Again - Indicates if the miniport driver wants the port driver to call
        its VIDEO_HW_FIND_ADAPTER function again with a new device extension
        and the same config info. This is used by the miniport drivers which
        can search for several adapters on a bus.

Return Value:

    This routine must return:

    NO_ERROR - Indicates a host adapter was found and the
        configuration information was successfully determined.

    ERROR_INVALID_PARAMETER - Indicates an adapter was found but there was an
        error obtaining the configuration information. If possible an error
        should be logged.

    ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the
        supplied configuration information.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG i, key=0;
    VP_STATUS status;
    POINTER_CAPABILITY PointerCapability=0;

    VIDEO_ACCESS_RANGE accessRange[NUM_S3_ACCESS_RANGES+NUM_S3_PCI_ACCESS_RANGES];
    ULONG NumAccessRanges = NUM_S3_ACCESS_RANGES;

    //
    // Make sure the size of the structure is at least as large as what we
    // are expecting (check version of the config info structure).
    //

    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO)) {

        return (ERROR_INVALID_PARAMETER);

    }

    //
    // Make a copy of the access ranges so we can modify them before they
    // are mapped.
    //

    VideoPortMoveMemory(accessRange,
                        S3AccessRanges,
                        sizeof(VIDEO_ACCESS_RANGE) * (NUM_S3_ACCESS_RANGES
                                                   + NUM_S3_PCI_ACCESS_RANGES));

    //
    // Detect the PCI card.
    //

    if (ConfigInfo->AdapterInterfaceType == PCIBus)
    {
        ULONG Slot = 0;

        VideoDebugPrint((1, "S3!VgaFindAdapter: "
                            "ConfigInfo->AdapterInterfaceType == PCIBus\n"));

        status = VideoPortGetAccessRanges(HwDeviceExtension,
                                          0,
                                          NULL,
                                          NUM_S3_PCI_ACCESS_RANGES,
                                          &accessRange[LINEAR_FRAME_BUF],
                                          NULL,
                                          NULL,
                                          &Slot);

        //
        // Now we need to determine the Device ID.
        //

        if (status == NO_ERROR) {

            USHORT Id = 0;

            if (VideoPortGetBusData(HwDeviceExtension,
                                    PCIConfiguration,
                                    0,
                                    (PVOID) &Id,
                                    FIELD_OFFSET(
                                        PCI_COMMON_CONFIG,
                                        DeviceID),
                                    sizeof(USHORT)) == 0) {

                //
                // Error getting bus data.
                //
    
                return ERROR_DEV_NOT_EXIST;
            }

            hwDeviceExtension->PCIDeviceID = Id;

            VideoDebugPrint((1, "==> DeviceID = 0x%x\n", Id));

            //
            // I am making the assumption that this driver will only
            // be loaded for legacy class devices.  The INF for
            // newer PCI device should point to the newer driver.
            //

            //
            // If we have an 868 or a 968 then the card requested
            // will request 32 Meg instead of 64 Meg of access ranges.
            // Confirm that the PCI bus enumerator corrected for this.
            //

            if (((Id == 0x8880) || (Id == 0x88F0)) &&
                (accessRange[LINEAR_FRAME_BUF].RangeLength != 0x4000000))
            {
                VideoDebugPrint((1, "This device decodes 64Meg but "
                                    "was only assigned 32Meg.\n"));

                ASSERT(FALSE);
            }

            //
            // We have an additional access range for our linear frame
            // buffer.
            //

            NumAccessRanges++;

        } else {

            //
            // Error getting access ranges.
            //

            return ERROR_DEV_NOT_EXIST;

        }
    }

    //
    // Check to see if there is a hardware resource conflict.
    //

    status = VideoPortVerifyAccessRanges(hwDeviceExtension,
                                         NumAccessRanges,
                                         accessRange);

    if (status != NO_ERROR) {

        VideoDebugPrint((1, "S3: Access Range conflict\n"));

        return status;

    }

    //
    // Get the mapped addresses for the frame buffer, BIOS, and all the
    // registers.  We will not map the linear frame buffer or linear BIOS
    // because the miniport does not need to access it.
    //

    for (i = 0; i < NUM_S3_ACCESS_RANGES_USED; i++) {

        if ( (hwDeviceExtension->MappedAddress[i] =
                  VideoPortGetDeviceBase(hwDeviceExtension,
                                         accessRange[i].RangeStart,
                                         accessRange[i].RangeLength,
                                         accessRange[i].RangeInIoSpace)) == NULL) {

            VideoDebugPrint((1, "S3: DeviceBase mapping failed\n"));
            return ERROR_INVALID_PARAMETER;

        }

    }

    //
    // Is a BIOS available?
    //

    if (VideoPortReadRegisterUshort(hwDeviceExtension->MappedAddress[0])
        == 0xaa55)
    {
        hwDeviceExtension->BiosPresent = TRUE;
    }

    if (ConfigInfo->AdapterInterfaceType != PCIBus)
    {
        //
        // Look for a non-pci S3.
        //

        if (!S3IsaDetection(HwDeviceExtension, &key)) {

            //
            // We failed to find an S3 device, so restore the
            // lock registers.
            //

            if (key) {

                //
                // Only lock the extended registers if
                // we unlocked them.
                //

                LockExtendedRegs(HwDeviceExtension, key);
            }

            return ERROR_DEV_NOT_EXIST;
        }
    }
    else
    {
        //
        // Make sure the chip type we detected is stored in the
        // DeviceExtension.  (We found card on PCI bus.)
        //

        S3RecordChipType(HwDeviceExtension, &key);
    }

    //
    // Get the capabilities, and Chip Name for the detected S3 device.
    //

    S3GetInfo(HwDeviceExtension, &PointerCapability, accessRange);

    //
    // Decide whether the alpha can use sparse or dense space.
    //

    AlphaDetermineMemoryUsage(HwDeviceExtension, accessRange);

    //
    // Get the DAC type.
    //

    S3DetermineDACType(HwDeviceExtension,
                       &PointerCapability);

    //
    // Determine the amount of video memory we have.
    //

    S3DetermineMemorySize(HwDeviceExtension);

    //
    // Determine which Frequency Table to use.
    //

    S3DetermineFrequencyTable(HwDeviceExtension,
                              accessRange,
                              ConfigInfo->AdapterInterfaceType);

    //
    // Determine which modes are valid on this device.
    //

    S3ValidateModes(HwDeviceExtension, &PointerCapability);


    /////////////////////////////////////////////////////////////////////////
    //
    // We have this so that the int10 will also work on the VGA also if we
    // use it in this driver.
    //

    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart  = 0x000A0000;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryLength           = 0x00020000;

    //
    // Clear out the Emulator entries and the state size since this driver
    // does not support them.
    //

    ConfigInfo->NumEmulatorAccessEntries     = 0;
    ConfigInfo->EmulatorAccessEntries        = NULL;
    ConfigInfo->EmulatorAccessEntriesContext = 0;

    //
    // This driver does not do SAVE/RESTORE of hardware state.
    //

    ConfigInfo->HardwareStateSize = 0;

    //
    // Frame buffer and memory-mapped I/O information.
    //

    hwDeviceExtension->PhysicalFrameAddress = accessRange[1].RangeStart;
    hwDeviceExtension->FrameLength          = accessRange[1].RangeLength;

    hwDeviceExtension->PhysicalMmIoAddress  = accessRange[1].RangeStart;
    hwDeviceExtension->MmIoLength           = accessRange[1].RangeLength;
    hwDeviceExtension->MmIoSpace            = accessRange[1].RangeInIoSpace;

    if (hwDeviceExtension->Capabilities & CAPS_NEW_MMIO) {

        //
        // Since we using NEW MMIO, use the values for our linear
        // access ranges.
        //

        hwDeviceExtension->PhysicalFrameAddress = accessRange[LINEAR_FRAME_BUF].RangeStart;
        hwDeviceExtension->FrameLength          = accessRange[LINEAR_FRAME_BUF].RangeLength;

        hwDeviceExtension->PhysicalMmIoAddress  = accessRange[LINEAR_FRAME_BUF].RangeStart;
        hwDeviceExtension->MmIoLength           = accessRange[LINEAR_FRAME_BUF].RangeLength;
        hwDeviceExtension->MmIoSpace            = accessRange[LINEAR_FRAME_BUF].RangeInIoSpace;

        //
        // Adjust the memory map offset so that we can still use our
        // old-style memory-mapped I/O routines, if need be.  Also,
        // fix FrameLength and MmIoLength, since they're both set to
        // 64 MB right now.
        //

        hwDeviceExtension->PhysicalMmIoAddress.LowPart += NEW_MMIO_IO_OFFSET;
        hwDeviceExtension->MmIoLength = NEW_MMIO_IO_LENGTH;
        hwDeviceExtension->FrameLength = hwDeviceExtension->AdapterMemorySize;
    }

    //
    // IO Port information
    // Get the base address, starting at zero and map all registers
    //

    hwDeviceExtension->PhysicalRegisterAddress = accessRange[2].RangeStart;
    hwDeviceExtension->PhysicalRegisterAddress.LowPart &= 0xFFFF0000;

    hwDeviceExtension->RegisterLength = 0x10000;
    hwDeviceExtension->RegisterSpace = accessRange[2].RangeInIoSpace;

    //
    // Free up the ROM since we don't need it anymore.
    //

    VideoPortFreeDeviceBase(hwDeviceExtension,
                            hwDeviceExtension->MappedAddress[0]);

    //
    // Indicate we do not wish to be called over
    //

    *Again = 0;

    //
    // We're done mucking about with the S3 chip, so lock all the registers.
    //

    LockExtendedRegs(HwDeviceExtension, key);

    //
    // Indicate a successful completion status.
    //

    return status;

} // end S3FindAdapter()

ULONG
UnlockExtendedRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine unlocks the extended S3 registers.

Arguments:

    hwDeviceExtension - Pointer to the miniport's device extension.

Return Value:

    ULONG used to restore the register values.

--*/

{
    ULONG key;

    //
    // Save the initial value of the S3 lock registers.
    // It's possible a non-s3 bios may expect them in a state
    // defined in POST.
    //

    key = (ULONG) VideoPortReadPortUchar(CRT_ADDRESS_REG);

    key <<= 8;

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x38);
    key = (ULONG) VideoPortReadPortUchar(CRT_DATA_REG);

    key <<= 8;

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x39);
    key |= (ULONG) VideoPortReadPortUchar(CRT_DATA_REG);

    //
    // Now unlock all the S3 registers, for use in this routine.
    //

    VideoPortWritePortUshort(CRT_ADDRESS_REG, 0x4838);
    VideoPortWritePortUshort(CRT_ADDRESS_REG, 0xA039);

    return key;
}

VOID
LockExtendedRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG key
    )

/*++

Routine Description:

    This routine restores the contents of the s3 lock registers.

Arguments:

    hwDeviceExtension - Pointer to the miniport's device extension.

Return Value:

    None.

--*/

{
    UCHAR val;

    val = (UCHAR) key;
    key >>= 8;

    VideoPortWritePortUshort(
        CRT_ADDRESS_REG, (USHORT)(((USHORT) val << 8) | 0x39));

    val = (UCHAR) key;
    key >>= 8;

    VideoPortWritePortUshort(
        CRT_ADDRESS_REG, (USHORT)(((USHORT) val << 8) | 0x38));

    val = (UCHAR) key;

    VideoPortWritePortUchar(CRT_ADDRESS_REG, val);
}

VOID
AlphaDetermineMemoryUsage(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    VIDEO_ACCESS_RANGE accessRange[]
    )

/*++

Routine Description:

    This routine determines whether or not the ALPHA can map it's frame
    buffer using dense space.

Arguments:

    hwDeviceExtension - Pointer to the miniport's device extension.

Return Value:

    None.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    UCHAR jBus;

    hwDeviceExtension->PhysicalFrameIoSpace = 0;

#if defined(_ALPHA_)

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x36);
    jBus = VideoPortReadPortUchar(CRT_DATA_REG) & 0x3;

    if ((jBus == 0x2) &&
        ((hwDeviceExtension->ChipID >= S3_866) ||
         (hwDeviceExtension->SubTypeID == SUBTYPE_765))) {

        //
        // We want to use a dense space mapping of the frame buffer
        // whenever we can on the Alpha, because that will allow us to
        // support DCI and direct GDI access.
        //
        // Unfortunately, dense space mapping isn't really an option
        // with ISA cards because some of the older Alphas don't support
        // it, and it would be terribly slow on the newer Alphas anyway
        // (because any byte- or word-write requires a read/modify/write
        // operation, and the Alpha can only ever do 64-bit reads when
        // in dense mode -- meaning these operations would always require
        // 4 reads and 2 writes on the ISA bus).
        //
        // Any Alpha that supports PCI, though, can support dense space
        // mapping, and because the bus is wider and faster, the
        // read/modify/write case isn't nearly as painful.  But the
        // problem I've found now is that 64- and 32-bit reads eventually
        // lock-up any S3 chip older than the 866/868/968.
        //

        hwDeviceExtension->PhysicalFrameIoSpace = 4;

        //
        // The new DeskStation Alpha machines don't always support
        // dense space.  Therefore, we should try to map the memory
        // at this point as a test.  If the mapping succeeds then
        // we can use dense space, otherwise we'll use sparse space.
        //

        {
            PULONG MappedSpace=0;
            PHYSICAL_ADDRESS FrameBuffer;
            ULONG FrameLength;
            ULONG inIoSpace;

            VideoDebugPrint((1, "Checking to see if we can use dense space...\n"));

            //
            // We want to try to map the dense memory where it will ultimately
            // be mapped anyway.  If LINEAR_FRAME_BUF is valid, then use this
            // info, else use A000_FRAME_BUF.
            //

            if (accessRange[LINEAR_FRAME_BUF].RangeLength != 0)
            {
                FrameBuffer = accessRange[LINEAR_FRAME_BUF].RangeStart;
                FrameLength = accessRange[LINEAR_FRAME_BUF].RangeLength;
            }
            else
            {
                FrameBuffer = accessRange[A000_FRAME_BUF].RangeStart;
                FrameLength = accessRange[A000_FRAME_BUF].RangeLength;
            }

            inIoSpace = hwDeviceExtension->PhysicalFrameIoSpace;

            MappedSpace = (PULONG)VideoPortGetDeviceBase(hwDeviceExtension,
                                            FrameBuffer,
                                            FrameLength,
                                            (UCHAR)inIoSpace);

            if (MappedSpace == NULL)
            {
                //
                // Well, looks like we can't use dense space to map the
                // range.  Lets use sparse space, and let the display
                // driver know.
                //

                VideoDebugPrint((1, "Can't use dense space!\n"));

                hwDeviceExtension->PhysicalFrameIoSpace = 0;

                hwDeviceExtension->Capabilities |= (CAPS_NO_DIRECT_ACCESS |
                                                    CAPS_SPARSE_SPACE);
            }
            else
            {
                //
                // The mapping worked.  However, we were only mapping to
                // see if dense space was supported.  Free the memory.
                //

                VideoDebugPrint((1, "We can use dense space.\n"));

                VideoPortFreeDeviceBase(hwDeviceExtension,
                                        MappedSpace);
            }
        }


    } else {

        //
        // Gotta use a sparse space mapping, so let the display driver
        // know:
        //

        VideoDebugPrint((1, "We must use sparse space.\n"));

        hwDeviceExtension->Capabilities |= (CAPS_NO_DIRECT_ACCESS |
                                            CAPS_SPARSE_SPACE);
    }

    //
    // The 868/968 report to PCI that they decode
    // 32 Meg, while infact, they decode 64 Meg.
    // PCI attempts to work around this by moving
    // resources.  However, this causes us to move
    // into a dense space region.  So, when we try
    // to map our accelerator registers in sparce
    // space they actually end up in dense space.
    //
    // The 868/968 also have a bug such that if you
    // do a read from certain registers such as
    // BEE8, the chip will hang.  In dense space,
    // USHORT writes are implemented as
    // read-modify-write sequences.  This causes us
    // to hang.
    //
    // To work around this, we will disable NEW_MMIO
    // on the 868/968 and fall back to using
    // standard IO routines.
    //

    if ((hwDeviceExtension->SubTypeID == SUBTYPE_868) ||
        (hwDeviceExtension->SubTypeID == SUBTYPE_968)) {

        hwDeviceExtension->PhysicalFrameIoSpace = 0;

        hwDeviceExtension->Capabilities &= ~CAPS_NEW_MMIO;
        hwDeviceExtension->Capabilities |= (CAPS_NO_DIRECT_ACCESS |
                                            CAPS_SPARSE_SPACE);
    }

#endif


}

VOID
S3RecordChipType(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PULONG key
    )

/*++

Routine Description:

    This routine should only be called if we found a PCI S3 card.
    The routine will fill in the ChipType and SubType fields of the
    HwDeviceExtension.

Arguments:

    hwDeviceExtension - Pointer to the miniport's device extension.

Return Value:

    None.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    UCHAR jRevision, jChipID, jSecondaryID;

    *key = UnlockExtendedRegs(HwDeviceExtension);

    switch (hwDeviceExtension->PCIDeviceID) {

    case 0x8811:

        //
        // We need to examine IO ports to determine between
        // three chips with the same PCI ID.
        //

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x2F);
        jRevision = VideoPortReadPortUchar(CRT_DATA_REG);

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x2E);
        jSecondaryID = VideoPortReadPortUchar(CRT_DATA_REG);

        hwDeviceExtension->ChipID = S3_864;     // Treated as an 864

        if (jSecondaryID == 0x10) {

            //
            // This is an S3 732
            //

            VideoDebugPrint((2, "S3: 732 Chip Set\n"));

            hwDeviceExtension->SubTypeID = SUBTYPE_732;

        } else {

            if (jRevision & 0x40) {

                VideoDebugPrint((2, "S3: 765 Chip Set\n"));

                hwDeviceExtension->SubTypeID = SUBTYPE_765;

            } else {

                VideoDebugPrint((2, "S3: 764 Chip Set\n"));

                hwDeviceExtension->SubTypeID = SUBTYPE_764;
            }
        }

        break;

    case 0x8880:

        hwDeviceExtension->ChipID = S3_866;

        VideoDebugPrint((2, "S3: Vision868 Chip Set\n"));

        hwDeviceExtension->SubTypeID = SUBTYPE_868;

        break;

    case 0x8890:

        hwDeviceExtension->ChipID = S3_866;

        VideoDebugPrint((2, "S3: Vision866 Chip Set\n"));

        hwDeviceExtension->SubTypeID = SUBTYPE_866;

        break;

    case 0x88B0:
    case 0x88F0:

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x30);
        jChipID = VideoPortReadPortUchar(CRT_DATA_REG);

        if (jChipID == 0xB0) {

            //
            // We found a PCI 928
            //

            VideoDebugPrint((2, "S3: 928 Chip Set\n"));

            hwDeviceExtension->ChipID = S3_928;
            hwDeviceExtension->SubTypeID = SUBTYPE_928;


        } else {

            VideoDebugPrint((2, "S3: Vision968 Chip Set\n"));

            hwDeviceExtension->ChipID = S3_866;
            hwDeviceExtension->SubTypeID = SUBTYPE_968;

        }
        break;

    case 0x88C0:
    case 0x88C1:

        hwDeviceExtension->ChipID = S3_864;

        VideoDebugPrint((2, "S3: 864 Chip Set\n"));

        hwDeviceExtension->SubTypeID = SUBTYPE_864;

        break;

    case 0x88D0:
    case 0x88D1:

        hwDeviceExtension->ChipID = S3_864;

        VideoDebugPrint((2, "S3: 964 Chip Set\n"));

        hwDeviceExtension->SubTypeID = SUBTYPE_964;

        break;

    default:

        //
        // It's an S3 we don't recognize.  Don't assume it's
        // backwards-compatible:
        //

        VideoDebugPrint((2, "S3: Unknown Chip Set\n"));

        break;
    }

    //
    // The IBM Mach machine ships with an 868 but we must treat
    // it as an 864 to avoid hanging problems.
    //

    WorkAroundForMach(hwDeviceExtension);
}

BOOLEAN
S3IsaDetection(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PULONG key
    )

/*++

Routine Description:

    This routine will test for the existance of an S3 card by
    directly poking at IO ports.

    NOTE: It is expected that this routine is called from
          S3FindAdapter, and that the IO ports are mapped.

Arguments:

    hwDeviceExtension - Pointer to the miniport's device extension.

Return Value:

    TRUE - If an S3 card was detected,
    FALSE - Otherwise.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    UCHAR jChipID, jRevision;
    ULONG ulSecondaryID;
    UCHAR reg30, reg47, reg49;
    BOOLEAN DetectS3;

    UCHAR jExtendedVideoDacControl;

    //
    // Determine if a BIOS is present.
    //
    // NOTE: At this point we have detected if an S3 was located on the PCI
    // bus.  For other bus types (EISA and ISA) we have not determined
    // yet.  So we do assume that reading from the ROM location will not
    // cause the machine to fault (which could actually happen on the
    // internal bus of RISC machines with no roms).
    //

    if (hwDeviceExtension->BiosPresent == TRUE) {

        //
        // Look for a ROM signature of Trident because our chip detection
        // puts the Trident chip into a sleep state.
        //
        // Search the first 256 bytes of BIOS for signature "TRIDENT"
        //

        if (VideoPortScanRom(HwDeviceExtension,
                             HwDeviceExtension->MappedAddress[0],
                             256,
                             "TRIDENT")) {

            VideoDebugPrint((1, "Trident BIOS found - can not be an S3 !\n"));

            return FALSE;
        }

    }

    *key = UnlockExtendedRegs(HwDeviceExtension);

    //
    // Assume some defaults:
    //

    DetectS3 = TRUE;

    //
    // Make sure we're working with an S3
    // And while were at it, pickup the chip ID
    //

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x30);
    jChipID = VideoPortReadPortUchar(CRT_DATA_REG);

    switch(jChipID & 0xf0) {

    case 0x80: // 911 or 924

        //
        // Note: A lot of 911/924 cards have timing problems in fast
        //       machines when doing monochrome expansions.  We simply
        //       slow down every such transfer by setting the
        //       CAPS_SLOW_MONO_EXPANDS flag.
        //
        //       We also ran into problems with the 911 hardware pointer
        //       when using the HGC_DY register to hide the pointer;
        //       since 911 cards are several generations out of date, we
        //       will simply disable the hardware pointer.
        //

        VideoDebugPrint((2, "S3: 911 Chip Set\n"));

        hwDeviceExtension->ChipID = S3_911;
        hwDeviceExtension->SubTypeID = SUBTYPE_911;

        break;

    case 0x90: // 928
    case 0xB0: // 928PCI

        VideoDebugPrint((2, "S3: 928 Chip Set\n"));

        hwDeviceExtension->ChipID = S3_928;
        hwDeviceExtension->SubTypeID = SUBTYPE_928;

        //
        // Note: We don't enable CAPS_MM_IO on the 928 because all the
        //       display driver's memory-mapped I/O routines assume they
        //       can do 32-bit writes to colour and mask registers,
        //       which the 928 can't do.
        //

        break;

    case 0xA0: // 801/805

        if (jChipID >= 0xA8) {

            //
            // It's an 805i, which appears to us to be pretty much a '928'.
            //

            VideoDebugPrint((2, "S3: 805i Chip Set\n"));

            hwDeviceExtension->ChipID = S3_928;
            hwDeviceExtension->SubTypeID = SUBTYPE_805i;

        } else {

            //
            // The 80x rev 'A' and 'B' chips had bugs that prevented them
            // from being able to do memory-mapped I/O.  I'm not enabling
            // memory-mapped I/O on later versions of the 80x because doing
            // so at this point would be a testing problem.
            //

            VideoDebugPrint((2, "S3: 801/805 Chip Set\n"));

            hwDeviceExtension->ChipID = S3_801;
            hwDeviceExtension->SubTypeID = SUBTYPE_80x;

        }

        break;

    case 0xC0: // 864
    case 0xD0: // 964

        hwDeviceExtension->ChipID = S3_864;

        //
        // Note: The first 896/964 revs have a bug dealing with the pattern
        //       hardware, where we have to draw a 1x8 rectangle before
        //       using a pattern already realized in off-screen memory,
        //       so we set the RE_REALIZE_PATTERN flag.
        //

        if ((jChipID & 0xF0) == 0xC0) {

            VideoDebugPrint((2, "S3: 864 Chip Set\n"));

            hwDeviceExtension->SubTypeID = SUBTYPE_864;

        } else {

            VideoDebugPrint((2, "S3: 964 Chip Set\n"));

            hwDeviceExtension->SubTypeID = SUBTYPE_964;

        }

        break;

    case 0xE0: // Newer than 864/964

        //
        // We can treat the newer chips, for the most part, as compatible
        // with the 864, so use that ChipID.  Also assume some basic
        // capabilities.
        //

        hwDeviceExtension->ChipID = S3_866;

        //
        // Look at the secondary chip ID register to determine the chip
        // type.
        //

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x2D);
        ulSecondaryID = ((ULONG) VideoPortReadPortUchar(CRT_DATA_REG)) << 8;

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x2E);
        ulSecondaryID |= VideoPortReadPortUchar(CRT_DATA_REG);

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x2F);
        jRevision = VideoPortReadPortUchar(CRT_DATA_REG);

        switch (ulSecondaryID) {

        case 0x8811:

            hwDeviceExtension->ChipID = S3_864;     // Treated as an 864

            if (jRevision & 0x40) {

                VideoDebugPrint((2, "S3: 765 Chip Set\n"));

                hwDeviceExtension->SubTypeID = SUBTYPE_765;

            } else {

                VideoDebugPrint((2, "S3: 764 Chip Set\n"));

                hwDeviceExtension->SubTypeID = SUBTYPE_764;

                //
                // Our #9 and Diamond 764 boards occasionally fail the HCT
                // tests when we do dword or word reads from the frame buffer.
                // To get on the HCL lists, cards must pass the HCTs, so we'll
                // revert to byte reads for these chips:
                //

            }

            break;

        case 0x8810:

            VideoDebugPrint((2, "S3: 732 Chip Set\n"));

            hwDeviceExtension->ChipID = S3_864;     // Treated as an 864
            hwDeviceExtension->SubTypeID = SUBTYPE_732;

            break;

        case 0x8880:

            VideoDebugPrint((2, "S3: Vision866 Chip Set\n"));

            hwDeviceExtension->SubTypeID = SUBTYPE_866;

            break;

        case 0x8890:

            VideoDebugPrint((2, "S3: Vision868 Chip Set\n"));

            hwDeviceExtension->SubTypeID = SUBTYPE_868;

            break;

        case 0x88B0:
        case 0x88F0:

            VideoDebugPrint((2, "S3: Vision968 Chip Set\n"));

            hwDeviceExtension->SubTypeID = SUBTYPE_968;

            break;

        default:

            //
            // It's an S3 we don't recognize.  Don't assume it's
            // backwards-compatible:
            //

            VideoDebugPrint((2, "S3: Unknown Chip Set\n"));

            //
            // Since we do not know what type of S3 this is, we
            // can't risk letting the driver load!
            //

            DetectS3 = FALSE;

            break;
        }

        break;

    default:

        DetectS3 = FALSE;
        break;
    }

    //
    // The IBM Mach machine ships with an 868 but we must treat
    // it as an 864 to avoid hanging problems.
    //

    WorkAroundForMach(hwDeviceExtension);

    //
    // Windows NT now autodetects the user's video card in Setup by
    // loading and running every video miniport until it finds one that
    // returns success.  Consequently, our detection code has to be
    // rigorous enough that we don't accidentally recognize a wrong
    // board.
    //
    // Simply checking the chip ID is not sufficient for guaranteeing
    // that we are running on an S3 (it makes us think some Weitek
    // boards are S3 compatible).
    //
    // We make doubly sure we're running on an S3 by checking that
    // the S3 cursor position registers exist, and that the chip ID
    // register can't be changed.
    //

    if (DetectS3) {

        DetectS3 = FALSE;

        //
        // First, make sure 'chip ID' register 0x30 is not modifiable:
        //

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x30);
        if (VideoPortReadPortUchar(CRT_ADDRESS_REG) == 0x30) {

            reg30 = VideoPortReadPortUchar(CRT_DATA_REG);
            VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) (reg30 + 7));
            if (VideoPortReadPortUchar(CRT_DATA_REG) == reg30) {

                //
                // Next, make sure 'cursor origin-x' register 0x47 is
                // modifiable:
                //

                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x47);
                if (VideoPortReadPortUchar(CRT_ADDRESS_REG) == 0x47) {

                    reg47 = VideoPortReadPortUchar(CRT_DATA_REG);
                    VideoPortWritePortUchar(CRT_DATA_REG, 0x55);
                    if (VideoPortReadPortUchar(CRT_DATA_REG) == 0x55) {

                        //
                        // Finally, make sure 'cursor origin-y' register 0x49
                        // is modifiable:
                        //

                        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x49);
                        if (VideoPortReadPortUchar(CRT_ADDRESS_REG) == 0x49) {

                            reg49 = VideoPortReadPortUchar(CRT_DATA_REG);
                            VideoPortWritePortUchar(CRT_DATA_REG, 0xAA);
                            if (VideoPortReadPortUchar(CRT_DATA_REG) == 0xAA) {

                                DetectS3 = TRUE;
                            }

                            VideoPortWritePortUchar(CRT_DATA_REG, reg49);
                        }
                    }

                    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x47);
                    VideoPortWritePortUchar(CRT_DATA_REG, reg47);
                }
            }

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x30);
            VideoPortWritePortUchar(CRT_DATA_REG, reg30);
        }
    }

    return DetectS3;
}

VOID
S3GetInfo(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    POINTER_CAPABILITY *PointerCapability,
    VIDEO_ACCESS_RANGE accessRange[]
    )

/*++

Routine Description:

    For fill in the capabilities bits for the s3 card, and return an
    wide character string representing the chip.

Arguments:

    HwDeviceExtension - Pointer to the miniport's device extension.

Return Value:

    None.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    UCHAR jBus, jChipID;
    PWSTR pwszChip;
    ULONG cbChip;

    //
    // The second register used for setting the refresh rate depends
    // on whether the chip is an 864/964, or newer.  The integrated
    // Trio chips use 41; the other high-end chips use 5B.
    //

    hwDeviceExtension->FrequencySecondaryIndex = 0x5B;

    switch (hwDeviceExtension->SubTypeID) {
    case SUBTYPE_911:

        //
        // Note: A lot of 911/924 cards have timing problems in fast
        //       machines when doing monochrome expansions.  We simply
        //       slow down every such transfer by setting the
        //       CAPS_SLOW_MONO_EXPANDS flag.
        //
        //       We also ran into problems with the 911 hardware pointer
        //       when using the HGC_DY register to hide the pointer;
        //       since 911 cards are several generations out of date, we
        //       will simply disable the hardware pointer.
        //

        VideoDebugPrint((2, "S3: 911 Chip Set\n"));

        pwszChip = L"S3 911/924";
        cbChip = sizeof(L"S3 911/924");

        hwDeviceExtension->Capabilities = (CAPS_SLOW_MONO_EXPANDS  |
                                            CAPS_SW_POINTER);

        break;

    case SUBTYPE_928:

        VideoDebugPrint((2, "S3: 928 Chip Set\n"));

        pwszChip = L"S3 928";
        cbChip = sizeof(L"S3 928");

        //
        // Note: We don't enable CAPS_MM_IO on the 928 because all the
        //       display driver's memory-mapped I/O routines assume they
        //       can do 32-bit writes to colour and mask registers,
        //       which the 928 can't do.
        //

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_MM_GLYPH_EXPAND    |
                                            CAPS_16_ENTRY_FIFO      |
                                            CAPS_NEW_BANK_CONTROL);

        *PointerCapability = (POINTER_BUILT_IN | POINTER_WORKS_ONLY_AT_8BPP);

        break;

    case SUBTYPE_805i:

        //
        // It's an 805i, which appears to us to be pretty much a '928'.
        //

        VideoDebugPrint((2, "S3: 805i Chip Set\n"));

        pwszChip = L"S3 805i";
        cbChip = sizeof(L"S3 805i");

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_MM_GLYPH_EXPAND    |
                                            CAPS_16_ENTRY_FIFO      |
                                            CAPS_NEW_BANK_CONTROL);

        *PointerCapability = (POINTER_BUILT_IN | POINTER_WORKS_ONLY_AT_8BPP);

        break;

    case SUBTYPE_80x:

        //
        // The 80x rev 'A' and 'B' chips had bugs that prevented them
        // from being able to do memory-mapped I/O.  I'm not enabling
        // memory-mapped I/O on later versions of the 80x because doing
        // so at this point would be a testing problem.
        //

        VideoDebugPrint((2, "S3: 801/805 Chip Set\n"));

        pwszChip = L"S3 801/805";
        cbChip = sizeof(L"S3 801/805");

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_NEW_BANK_CONTROL);

        *PointerCapability = (POINTER_BUILT_IN | POINTER_WORKS_ONLY_AT_8BPP);

        break;

    case SUBTYPE_864:

        //
        // Note: The first 896/964 revs have a bug dealing with the pattern
        //       hardware, where we have to draw a 1x8 rectangle before
        //       using a pattern already realized in off-screen memory,
        //       so we set the RE_REALIZE_PATTERN flag.
        //

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_MM_32BIT_TRANSFER  |
                                            CAPS_MM_IO              |
                                            CAPS_MM_GLYPH_EXPAND    |
                                            CAPS_16_ENTRY_FIFO      |
                                            CAPS_NEWER_BANK_CONTROL |
                                            CAPS_RE_REALIZE_PATTERN);


        VideoDebugPrint((2, "S3: 864 Chip Set\n"));

        pwszChip = L"S3 Vision864";
        cbChip = sizeof(L"S3 Vision864");

        *PointerCapability = (POINTER_BUILT_IN | POINTER_NEEDS_SCALING);

        break;

    case SUBTYPE_964:

        //
        // Note: The first 896/964 revs have a bug dealing with the pattern
        //       hardware, where we have to draw a 1x8 rectangle before
        //       using a pattern already realized in off-screen memory,
        //       so we set the RE_REALIZE_PATTERN flag.
        //

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_MM_32BIT_TRANSFER  |
                                            CAPS_MM_IO              |
                                            CAPS_MM_GLYPH_EXPAND    |
                                            CAPS_16_ENTRY_FIFO      |
                                            CAPS_NEWER_BANK_CONTROL |
                                            CAPS_RE_REALIZE_PATTERN);

        VideoDebugPrint((2, "S3: 964 Chip Set\n"));

        pwszChip = L"S3 Vision964";
        cbChip = sizeof(L"S3 Vision964");

        break;

    case SUBTYPE_765:

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_MM_32BIT_TRANSFER  |
                                            CAPS_MM_IO              |
                                            CAPS_MM_GLYPH_EXPAND    |
                                            CAPS_16_ENTRY_FIFO      |
                                            CAPS_NEWER_BANK_CONTROL);

        hwDeviceExtension->FrequencySecondaryIndex = 0x41;

        *PointerCapability = POINTER_BUILT_IN;

        VideoDebugPrint((2, "S3: Trio64V+ Chip Set\n"));

        pwszChip = L"S3 Trio64V+";
        cbChip = sizeof(L"S3 Trio64V+");

        hwDeviceExtension->Capabilities |= (CAPS_NEW_MMIO           |
                                            CAPS_STREAMS_CAPABLE    |
                                            CAPS_PACKED_EXPANDS);

        break;

    case SUBTYPE_764:

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_MM_32BIT_TRANSFER  |
                                            CAPS_MM_IO              |
                                            CAPS_MM_GLYPH_EXPAND    |
                                            CAPS_16_ENTRY_FIFO      |
                                            CAPS_NEWER_BANK_CONTROL);

        hwDeviceExtension->FrequencySecondaryIndex = 0x41;

        *PointerCapability = POINTER_BUILT_IN;

        VideoDebugPrint((2, "S3: 764 Chip Set\n"));

        pwszChip = L"S3 764";
        cbChip = sizeof(L"S3 764");

        //
        // Our #9 and Diamond 764 boards occasionally fail the HCT
        // tests when we do dword or word reads from the frame buffer.
        // To get on the HCL lists, cards must pass the HCTs, so we'll
        // revert to byte reads for these chips:
        //

        hwDeviceExtension->Capabilities |= CAPS_BAD_DWORD_READS;

        break;

    case SUBTYPE_732:

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_MM_32BIT_TRANSFER  |
                                            CAPS_MM_IO              |
                                            CAPS_MM_GLYPH_EXPAND    |
                                            CAPS_16_ENTRY_FIFO      |
                                            CAPS_NEWER_BANK_CONTROL);


        VideoDebugPrint((2, "S3: 732 Chip Set\n"));

        pwszChip = L"S3 732";
        cbChip = sizeof(L"S3 732");

        *PointerCapability = POINTER_BUILT_IN;

        hwDeviceExtension->FrequencySecondaryIndex = 0x41;

        break;

    case SUBTYPE_866:

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_MM_32BIT_TRANSFER  |
                                            CAPS_MM_IO              |
                                            CAPS_MM_GLYPH_EXPAND    |
                                            CAPS_16_ENTRY_FIFO      |
                                            CAPS_NEWER_BANK_CONTROL);

        VideoDebugPrint((2, "S3: Vision866 Chip Set\n"));

        pwszChip = L"S3 Vision866";
        cbChip = sizeof(L"S3 Vision866");

        *PointerCapability = (POINTER_BUILT_IN |
                             POINTER_NEEDS_SCALING);    // Note scaling

        hwDeviceExtension->Capabilities |= (CAPS_NEW_MMIO           |
                                            CAPS_POLYGON            |
                                            CAPS_24BPP              |
                                            CAPS_BAD_24BPP          |
                                            CAPS_PACKED_EXPANDS);
        break;

    case SUBTYPE_868:

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_MM_32BIT_TRANSFER  |
                                            CAPS_MM_IO              |
                                            CAPS_MM_GLYPH_EXPAND    |
                                            CAPS_16_ENTRY_FIFO      |
                                            CAPS_NEWER_BANK_CONTROL);

        VideoDebugPrint((2, "S3: Vision868 Chip Set\n"));

        pwszChip = L"S3 Vision868";
        cbChip = sizeof(L"S3 Vision868");

        *PointerCapability = (POINTER_BUILT_IN |
                             POINTER_NEEDS_SCALING);    // Note scaling

        hwDeviceExtension->Capabilities |= (CAPS_NEW_MMIO           |
                                            CAPS_POLYGON            |
                                            CAPS_24BPP              |
                                            CAPS_BAD_24BPP          |
                                            CAPS_PACKED_EXPANDS     |
                                            CAPS_PIXEL_FORMATTER);
        break;

    case SUBTYPE_968:

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_MM_32BIT_TRANSFER  |
                                            CAPS_MM_IO              |
                                            CAPS_MM_GLYPH_EXPAND    |
                                            CAPS_16_ENTRY_FIFO      |
                                            CAPS_NEWER_BANK_CONTROL);

        VideoDebugPrint((2, "S3: Vision968 Chip Set\n"));

        pwszChip = L"S3 Vision968";
        cbChip = sizeof(L"S3 Vision968");

        hwDeviceExtension->Capabilities |= (CAPS_NEW_MMIO           |
                                            CAPS_POLYGON            |
                                            CAPS_24BPP              |
                                            CAPS_BAD_24BPP          |
                                            CAPS_PACKED_EXPANDS     |
                                            CAPS_PIXEL_FORMATTER);
        break;

    default:

        ASSERT(FALSE);

        VideoDebugPrint((1, "What type of S3 is this???\n"));
        pwszChip = L"S3 Unknown Chip Set";
        cbChip = sizeof(L"S3 Unknown Chip Set");

        break;
    }

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x36);
    jBus = VideoPortReadPortUchar(CRT_DATA_REG) & 0x3;

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x30);
    jChipID = VideoPortReadPortUchar(CRT_DATA_REG);


    if (jBus == 0x3) {

        //
        // Using the buffer expansion method of drawing text is always
        // faster on ISA buses than the glyph expansion method.
        //

        hwDeviceExtension->Capabilities &= ~CAPS_MM_GLYPH_EXPAND;

        //
        // We have to disable memory-mapped I/O in some situations
        // on ISA buses.
        //
        // We can't do any memory-mapped I/O on ISA systems with
        // rev A through D 928's, or rev A or B 801/805's.
        //

        if (((hwDeviceExtension->ChipID == S3_928) && (jChipID < 0x94)) ||
            ((hwDeviceExtension->ChipID == S3_801) && (jChipID < 0xA2))) {

            hwDeviceExtension->Capabilities &= ~(CAPS_MM_TRANSFER | CAPS_MM_IO);
        }

    }

    //
    // We have some weird initialization bug on newer Diamond Stealth
    // 805 and 928 local bus cards where if we enable memory-mapped I/O,
    // even if we don't use it, we'll get all kinds of weird access
    // violations in the system.  The card is sending garbage over the
    // bus?  As a work-around I am simply disabling memory-mappped I/O
    // on newer Diamond 928/928PCI and 805 cards.  It is not a problem
    // with their 964 or newer cards.
    //

    if (hwDeviceExtension->BoardID == S3_DIAMOND) {

        if ((((jChipID & 0xF0) == 0x90) && (jChipID >= 0x94)) ||
            (((jChipID & 0xF0) == 0xB0) && (jChipID >= 0xB0)) ||
            (((jChipID & 0xF0) == 0xA0) && (jChipID >= 0xA2))) {

            hwDeviceExtension->Capabilities
                &= ~(CAPS_MM_TRANSFER | CAPS_MM_IO | CAPS_MM_GLYPH_EXPAND);
            VideoDebugPrint((1, "S3: Disabling Diamond memory-mapped I/O\n"));
        }
    }

    if (hwDeviceExtension->Capabilities & CAPS_NEW_MMIO) {

        //
        // Are we actually using new MMIO? If the length
        // of the range for linear frame buffer entry
        // in the accessRanges array is zero, then we aren't
        // really using NEW_MMIO
        //

        if (accessRange[LINEAR_FRAME_BUF].RangeLength == 0)
        {
            hwDeviceExtension->Capabilities &= ~CAPS_NEW_MMIO;
        }

    }

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.ChipType",
                                   pwszChip,
                                   cbChip);
}

VOID
S3DetermineFrequencyTable(
    PVOID HwDeviceExtension,
    VIDEO_ACCESS_RANGE accessRange[],
    INTERFACE_TYPE AdapterInterfaceType
    )

/*++

Routine Description:

    Try to determine which frequency table to use based on the
    vendor string in the bios.

Arguments:

    HwDeviceExtension - Pointer to the miniport's device extension.

Return Value:

    The accessRange array may have been modified.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PVOID romAddress;
    PWSTR pwszAdapterString = L"S3 Compatible";
    ULONG cbAdapterString = sizeof(L"S3 Compatible");

    //
    // We will try to recognize the boards for which we have special
    // frequency/modeset support.
    //

    //
    // Set the defaults for the board type.
    //

    hwDeviceExtension->BoardID = S3_GENERIC;
    hwDeviceExtension->FixedFrequencyTable = GenericFixedFrequencyTable;

    if (hwDeviceExtension->ChipID <= S3_928) {

        hwDeviceExtension->Int10FrequencyTable = GenericFrequencyTable;

    } else {

        hwDeviceExtension->Int10FrequencyTable = Generic64NewFrequencyTable;
    }

    romAddress = hwDeviceExtension->MappedAddress[0];

    //
    // Look for brand name signatures in the ROM.
    //

    if (VideoPortScanRom(hwDeviceExtension,
                         romAddress,
                         MAX_ROM_SCAN,
                         "Number Nine ")) {

        hwDeviceExtension->BoardID = S3_NUMBER_NINE;

        pwszAdapterString = L"Number Nine";
        cbAdapterString = sizeof(L"Number Nine");

        //
        // We can set the refresh on 864/964 Number Nine boards.
        //

        if (hwDeviceExtension->ChipID >= S3_864) {

            hwDeviceExtension->Int10FrequencyTable = NumberNine64FrequencyTable;

        //
        // We also have frequency tables for 928-based GXE boards.
        //

        } else if (hwDeviceExtension->ChipID == S3_928) {

            UCHAR *pjRefString;
            UCHAR *pjBiosVersion;
            UCHAR offset;
            LONG  iCmpRet;

            hwDeviceExtension->Int10FrequencyTable = NumberNine928OldFrequencyTable;
            hwDeviceExtension->FixedFrequencyTable = NumberNine928NewFixedFrequencyTable;

            //
            // We know (at least we think) this is Number Nine board.
            // There was a bios change at #9 to change the refresh rate
            // mapping.  This change was made at Microsofts request.  The
            // problem is that the change has not make into production at
            // the time this driver was written.  For this reason, we must
            // check the bios version number, before we special case the
            // card as the number nine card.
            //
            // There is a byte in the bios at offset 0x190, that is the
            // offset from the beginning of the bios for the bios version
            // number.  The bios version number is a string.  All the
            // bios versions before 1.10.04 need this special translation.
            // all the other bios's use a translation closer to the s3
            // standard.
            //

            offset = VideoPortReadRegisterUchar(
                            ((PUCHAR) romAddress) + 0x190);

            pjBiosVersion = (PUCHAR) romAddress + offset;

            pjRefString = "1.10.04";
            iCmpRet = CompareRom(pjBiosVersion,
                                 pjRefString);

            if (iCmpRet >= 0) {

                hwDeviceExtension->Int10FrequencyTable = NumberNine928NewFrequencyTable;

            }
        }

    } else if (VideoPortScanRom(hwDeviceExtension,
                                romAddress,
                                MAX_ROM_SCAN,
                                "Orchid Technology Fahrenheit 1280")) {

        hwDeviceExtension->BoardID = S3_ORCHID;

        pwszAdapterString = L"Orchid Technology Fahrenheit 1280";
        cbAdapterString = sizeof(L"Orchid Technology Fahrenheit 1280");

        //
        // Only the 911 Orchid board needs specific init parameters.
        // Otherwise, fall through the generic function.
        //

        if (hwDeviceExtension->ChipID == S3_911) {

            hwDeviceExtension->FixedFrequencyTable = OrchidFixedFrequencyTable;

        }

    } else if (VideoPortScanRom(hwDeviceExtension,
                                romAddress,
                                MAX_ROM_SCAN,
                                "Diamond")) {

        hwDeviceExtension->BoardID = S3_DIAMOND;

        pwszAdapterString = L"Diamond Stealth";
        cbAdapterString = sizeof(L"Diamond Stealth");

        //
        // We can set the frequency on 864 and 964 Diamonds.
        //

        if (hwDeviceExtension->ChipID >= S3_864) {

            hwDeviceExtension->Int10FrequencyTable = Diamond64FrequencyTable;

            //
            // Not only did Diamond decide to have a different
            // frequency convention from S3's standard, they also
            // chose to use a different register than S3 did with
            // the 764:
            //

            if (hwDeviceExtension->FrequencySecondaryIndex == 0x41) {

                hwDeviceExtension->FrequencySecondaryIndex = 0x6B;
            }
        }

    } else if (VideoPortScanRom(hwDeviceExtension,
                                romAddress,
                                MAX_ROM_SCAN,
                                "HP Ultra")) {

        hwDeviceExtension->BoardID = S3_HP;

        pwszAdapterString = L"HP Ultra";
        cbAdapterString = sizeof(L"HP Ultra");

    } else if (VideoPortScanRom(hwDeviceExtension,
                                romAddress,
                                MAX_ROM_SCAN,
                                "DELL")) {

        hwDeviceExtension->BoardID = S3_DELL;

        pwszAdapterString = L"DELL";
        cbAdapterString = sizeof(L"DELL");

        //
        // We only have frequency tables for 805 based DELLs.
        //
        // DELLs with onboard 765s can use the Hercules Frequency Table.
        //

        if (hwDeviceExtension->ChipID == S3_801) {

            hwDeviceExtension->Int10FrequencyTable = Dell805FrequencyTable;

        } else if ((hwDeviceExtension->ChipID >= S3_864) &&
                   (hwDeviceExtension->SubTypeID == SUBTYPE_765)) {

            hwDeviceExtension->Int10FrequencyTable = HerculesFrequencyTable;

        }

    } else if (VideoPortScanRom(hwDeviceExtension,
                                romAddress,
                                MAX_ROM_SCAN,
                                "Metheus")) {

        pwszAdapterString = L"Metheus";
        cbAdapterString = sizeof(L"Metheus");

        hwDeviceExtension->BoardID = S3_METHEUS;

        if (hwDeviceExtension->ChipID == S3_928) {

            hwDeviceExtension->Int10FrequencyTable = Metheus928FrequencyTable;
        }

    } else if (VideoPortScanRom(hwDeviceExtension,
                                romAddress,
                                MAX_ROM_SCAN,
                                "Hercules")) {

        if ((hwDeviceExtension->SubTypeID == SUBTYPE_732) ||
            (hwDeviceExtension->SubTypeID == SUBTYPE_764) ||
            (hwDeviceExtension->SubTypeID == SUBTYPE_765)) {

            hwDeviceExtension->Int10FrequencyTable = HerculesFrequencyTable;

        } else if ((hwDeviceExtension->SubTypeID == SUBTYPE_964) ||
                   (hwDeviceExtension->SubTypeID == SUBTYPE_864)) {

            hwDeviceExtension->Int10FrequencyTable = Hercules64FrequencyTable;

        } else if ((hwDeviceExtension->SubTypeID == SUBTYPE_968) ||
                   (hwDeviceExtension->SubTypeID == SUBTYPE_868)) {

            hwDeviceExtension->Int10FrequencyTable = Hercules68FrequencyTable;

        }

    } else if (VideoPortScanRom(hwDeviceExtension,
                                romAddress,
                                MAX_ROM_SCAN,
                                "Phoenix S3")) {

        pwszAdapterString = L"Phoenix";
        cbAdapterString = sizeof(L"Phoenix");

        if (hwDeviceExtension->ChipID >= S3_864) {

            //
            // The Phoenix 864/964 BIOS is based on S3's sample BIOS.
            // Most of the 1.00 versions subscribe to the old 864/964
            // refresh convention; most newer versions subscribe
            // to the newer refresh convention.  Unfortunately, there
            // are exceptions: the ValuePoint machines have '1.00'
            // versions, but subscribe to the new convention.
            //
            // There are probably other exceptions we don't know about,
            // so we leave 'Use Hardware Default' as a refresh option
            // for the user.
            //

            if (VideoPortScanRom(hwDeviceExtension,
                                  romAddress,
                                  MAX_ROM_SCAN,
                                  "Phoenix S3 Vision") &&
                VideoPortScanRom(hwDeviceExtension,
                                  romAddress,
                                  MAX_ROM_SCAN,
                                  "VGA BIOS. Version 1.00") &&
                !VideoPortScanRom(hwDeviceExtension,
                                 romAddress,
                                 MAX_ROM_SCAN,
                                 "COPYRIGHT IBM")) {

                hwDeviceExtension->Int10FrequencyTable = Generic64OldFrequencyTable;

            } else {

                hwDeviceExtension->Int10FrequencyTable = Generic64NewFrequencyTable;

            }
        }
    }


#if defined(_X86_)

    if ((hwDeviceExtension->BiosPresent == FALSE) &&
        (AdapterInterfaceType == MicroChannel))
    {
        VP_STATUS status;

        //
        // This must be an IBM PS/2 with onboard S3 (no bios)
        //
        // We should release our claim on the video bios.
        //

        accessRange[0].RangeStart.LowPart = 0;
        accessRange[0].RangeStart.HighPart = 0;
        accessRange[0].RangeLength = 0;

        pwszAdapterString = L"IBM MicroChannel";
        cbAdapterString = sizeof(L"IBM MicroChannel");

        hwDeviceExtension->BoardID = S3_IBM_PS2;

        //
        // We have to re-reserve every port.
        //

        status = VideoPortVerifyAccessRanges(hwDeviceExtension,
                                             NUM_S3_ACCESS_RANGES,
                                             accessRange);

        if (status != NO_ERROR) {

            VideoDebugPrint((1, "S3: Access Range conflict after ROM change\n"));
            ASSERT(FALSE);

        }

        //
        // If the machine does not have an S3 BIOS, then we need to
        // restore bits 4, 5, and 6 of CRTC reg 0x5C when returning
        // to a VGA mode.
        //
        // Here we'll store bits 4-6 of CRTC reg 0x5c, and set bit
        // 7.  When restoring the mode we'll reset the high order
        // nibble of 0x5c to this value.
        //

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5c);
        hwDeviceExtension->CR5C = (VideoPortReadPortUchar(CRT_DATA_REG)
                                    & 0x70) | 0x80;

    }

#endif

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.AdapterString",
                                   pwszAdapterString,
                                   cbAdapterString);

    //
    // Is this a multi-card?
    //

    if (VideoPortScanRom(hwDeviceExtension,
                         (PVOID)((PUCHAR)romAddress + 0x7ff0),
                         8,
                         "612167")) {

        VideoDebugPrint((1, "Found a MEGA Lightning, dual S3 968\n"));

        hwDeviceExtension->ChildCount = 1;

    } else if (VideoPortScanRom(hwDeviceExtension,
                         (PVOID)((PUCHAR)romAddress + 0x7ff0),
                         8,
                         "612168")) {

        VideoDebugPrint((1, "Found a Pro Lightning+, dual S3 Trio64V+\n"));

        hwDeviceExtension->ChildCount = 1;

    } else if (VideoPortScanRom(hwDeviceExtension,
                         (PVOID)((PUCHAR)romAddress + 0x7ff0),
                         8,
                         "612167")) {

        VideoDebugPrint((1, "Found Quad Pro Lightning V+, quad S3 Trio64V+\n"));

        hwDeviceExtension->ChildCount = 3;

    }
}

VOID
S3DetermineDACType(
    PVOID HwDeviceExtension,
    POINTER_CAPABILITY *PointerCapability
    )

/*++

Routine Description:

    Determine the DAC type for HwPointer Capabilities.

Arguments:

    HwDeviceExtension - Pointer to the miniport's device extension.

Return Value:

    None.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    UCHAR jBt485Status;
    UCHAR jExtendedVideoDacControl;
    UCHAR jTiIndex;
    UCHAR jGeneralOutput;
    UCHAR jTiDacId;

    PWSTR pwszDAC, pwszAdapterString = L"S3 Compatible";
    ULONG cbDAC, cbAdapterString = sizeof(L"S3 Compatible");

    hwDeviceExtension->DacID = UNKNOWN_DAC;
    pwszDAC = L"Unknown";
    cbDAC = sizeof(L"Unknown");


    //
    // We'll use a software pointer in all modes if the user sets
    // the correct entry in the registry (because I predict that
    // people will have hardware pointer problems on some boards,
    // or won't like our jumpy S3 pointer).
    //

    if (NO_ERROR == VideoPortGetRegistryParameters(hwDeviceExtension,
                                                   L"UseSoftwareCursor",
                                                   FALSE,
                                                   S3RegistryCallback,
                                                   NULL)) {

        hwDeviceExtension->Capabilities |= CAPS_SW_POINTER;
    } else if (!(*PointerCapability & POINTER_BUILT_IN) ||
               (hwDeviceExtension->ChipID == S3_928)) {

        //
        // Check for a TI TVP3020 or 3025 DAC.
        //
        // The TI3025 is sort of Brooktree 485 compatible.  Unfortunately,
        // there is a hardware bug between the TI and the 964 that
        // causes the screen to occasionally jump when the pointer shape
        // is changed.  Consequently, we have to specifically use the
        // TI pointer on the TI DAC.
        //
        // We also encountered some flakey Level 14 Number Nine boards
        // that would show garbage on the screen when we used the S3
        // internal pointer; consequently, we use the TI pointer instead.
        //

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5C);

        jGeneralOutput = VideoPortReadPortUchar(CRT_DATA_REG);

        VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) (jGeneralOutput & ~0x20));
                                        // Select TI mode in the DAC

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x55);
                                        // Set CRTC index to EX_DAC_CT

        jExtendedVideoDacControl = VideoPortReadPortUchar(CRT_DATA_REG);

        VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) ((jExtendedVideoDacControl & 0xfc) | 0x01));

        jTiIndex = VideoPortReadPortUchar(TI025_INDEX_REG);

        VideoPortWritePortUchar(TI025_INDEX_REG, 0x3f);
                                        // Select ID register

        if (VideoPortReadPortUchar(TI025_INDEX_REG) == 0x3f) {

            jTiDacId = VideoPortReadPortUchar(TI025_DATA_REG);

            if ((jTiDacId == 0x25) || (jTiDacId == 0x20)) {

                hwDeviceExtension->Capabilities |= CAPS_TI025_POINTER;
                hwDeviceExtension->DacID = TI_3020; // 3020 compatible

                pwszDAC = L"TI TVP3020/3025";
                cbDAC = sizeof(L"TI TVP3020/3025");
            }
        }

        //
        // Restore all the registers.
        //

        VideoPortWritePortUchar(TI025_INDEX_REG, jTiIndex);

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x55);

        VideoPortWritePortUchar(CRT_DATA_REG, jExtendedVideoDacControl);

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5C);

        VideoPortWritePortUchar(CRT_DATA_REG, jGeneralOutput);

        if (!(hwDeviceExtension->Capabilities & CAPS_DAC_POINTER)) {

            //
            // Check for a TI TVP3026 DAC.
            //
            // The procedure here is courtesy of Diamond Multimedia.
            //

            //
            // This local declaration is extremely ugly, but the problem
            // is that DAC_ADDRESS_WRITE_PORT is a macro that needs to
            // dereference 'HwDeviceExtension' when all we have is a
            // 'hwDeviceExtension'.  I hate macros that take implicit
            // arguments.
            //

            PHW_DEVICE_EXTENSION HwDeviceExtension = hwDeviceExtension;

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x55);
                                            // Set CRTC index to EX_DAC_CT

            jExtendedVideoDacControl = VideoPortReadPortUchar(CRT_DATA_REG);

            VideoPortWritePortUchar(CRT_DATA_REG,
                    (UCHAR) (jExtendedVideoDacControl & 0xfc));

            VideoPortWritePortUchar(DAC_ADDRESS_WRITE_PORT, 0x3f);

            VideoPortWritePortUchar(CRT_DATA_REG,
                    (UCHAR) ((jExtendedVideoDacControl & 0xfc) | 0x2));

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x37);

            jTiDacId = VideoPortReadPortUchar(CRT_DATA_REG);

            if (VideoPortReadPortUchar(DAC_PIXEL_MASK_REG) == 0x26) {

                //
                // The 3026 is Brooktree 485 compatible, except for a
                // hardware bug that causes the hardware pointer to
                // 'sparkle' when setting the palette colours, unless we
                // wait for vertical retrace first:
                //

                hwDeviceExtension->Capabilities
                    |= (CAPS_BT485_POINTER | CAPS_WAIT_ON_PALETTE);

                hwDeviceExtension->DacID = BT_485; // 485 compatible

                pwszDAC = L"TI TVP3026";
                cbDAC = sizeof(L"TI TVP3026");
            }

            //
            // Restore all the registers.
            //

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x55);

            VideoPortWritePortUchar(CRT_DATA_REG, jExtendedVideoDacControl);
        }

        if (!(hwDeviceExtension->Capabilities & CAPS_DAC_POINTER)) {

            //
            // Check for a BrookTree 485 DAC.
            //

            VideoPortWritePortUchar(BT485_ADDR_CMD_REG0, 0xff);
                                            // Output 0xff to BT485 command register 0

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x55);
                                            // Set CRTC index to EX_DAC_CT

            jExtendedVideoDacControl = VideoPortReadPortUchar(CRT_DATA_REG);

            VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) ((jExtendedVideoDacControl & 0xfc) | 0x02));

            jBt485Status = VideoPortReadPortUchar(BT485_ADDR_CMD_REG0);
                                            // Read Bt485 status register 0

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x55);
                                            // Set CRTC index to 0x55

            jExtendedVideoDacControl = VideoPortReadPortUchar(CRT_DATA_REG);

            VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) (jExtendedVideoDacControl & 0xfc));

            if (jBt485Status != 0xff) {

                hwDeviceExtension->Capabilities |= CAPS_BT485_POINTER;

                pwszDAC = L"Brooktree Bt485";
                cbDAC = sizeof(L"Brooktree Bt485");
                hwDeviceExtension->DacID = BT_485;
            }
        }
    }

    //
    // This section looks for an S3 SDAC if another was not detected,
    // for the PPC.
    //

    if (hwDeviceExtension->DacID == UNKNOWN_DAC) {

        //
        // Only try this on an 864 or newer, because Orchid Farhenheit
        // 1280 911 boards would get black screens when in VGA mode and
        // this code was run (such as during initial Setup):
        //

        if ((hwDeviceExtension->ChipID >= S3_864) &&
            FindSDAC(hwDeviceExtension)) {

            //
            // SDAC does not provide a cursor, but we can use the cursor
            // built into the S3 (if there is one).
            //

            pwszDAC = L"S3 SDAC";
            cbDAC = sizeof(L"S3 SDAC");
            hwDeviceExtension->DacID = S3_SDAC;
        }
    }

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.DacType",
                                   pwszDAC,
                                   cbDAC);


}

VOID
S3DetermineMemorySize(
    PVOID HwDeviceExtension
    )
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    UCHAR s3MemSizeCode;

    //
    // Get the size of the video memory.
    //

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x36);
    s3MemSizeCode = (VideoPortReadPortUchar(CRT_DATA_REG) >> 5) & 0x7;

    if (hwDeviceExtension->ChipID == S3_911) {

        if (s3MemSizeCode & 1) {

            hwDeviceExtension->AdapterMemorySize = 0x00080000;

        } else {

            hwDeviceExtension->AdapterMemorySize = 0x00100000;

        }

    } else {

        hwDeviceExtension->AdapterMemorySize = gacjMemorySize[s3MemSizeCode];

    }

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.MemorySize",
                                   &hwDeviceExtension->AdapterMemorySize,
                                   sizeof(ULONG));

}

VOID
S3ValidateModes(
    PVOID HwDeviceExtension,
    POINTER_CAPABILITY *PointerCapability
    )

/*++

Routine Description:

    For fill in the capabilities bits for the s3 card, and return an
    wide character string representing the chip.

Arguments:

    HwDeviceExtension - Pointer to the miniport's device extension.

Return Value:

    None.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    PS3_VIDEO_FREQUENCIES FrequencyEntry;
    PS3_VIDEO_MODES ModeEntry;
    PS3_VIDEO_FREQUENCIES FrequencyTable;

    ULONG i;

    ULONG ModeIndex;

    UCHAR reg67;
    UCHAR jChipID, jRevision;

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x30);
    jChipID = VideoPortReadPortUchar(CRT_DATA_REG);

    /////////////////////////////////////////////////////////////////////////
    // Here we prune valid modes, based on rules according to the chip
    // capabilities and memory requirements.  It would be better if we
    // could make the VESA call to determine the modes that the BIOS
    // supports; however, that requires a buffer and I don't have the
    // time to get it working with our Int 10 support.
    //
    // We prune modes so that we will not annoy the user by presenting
    // modes in the 'Video Applet' which we know the user can't use.
    //

    hwDeviceExtension->NumAvailableModes = 0;
    hwDeviceExtension->NumTotalModes = 0;

    //
    // Since there are a number of frequencies possible for each
    // distinct resolution/colour depth, we cycle through the
    // frequency table and find the appropriate mode entry for that
    // frequency entry.
    //

    if (hwDeviceExtension->BiosPresent) {

        FrequencyTable = hwDeviceExtension->Int10FrequencyTable;

    } else {

        //
        // If there is no BIOS, construct the mode list from whatever
        // fixed frequency tables we have for this chip.
        //

        FrequencyTable = hwDeviceExtension->FixedFrequencyTable;
    }

    ModeIndex = 0;

    for (FrequencyEntry = FrequencyTable;
         FrequencyEntry->BitsPerPel != 0;
         FrequencyEntry++, ModeIndex++) {

        //
        // Find the mode for this entry.  First, assume we won't find one.
        //

        FrequencyEntry->ModeValid = FALSE;
        FrequencyEntry->ModeIndex = ModeIndex;

        for (ModeEntry = S3Modes, i = 0; i < NumS3VideoModes; ModeEntry++, i++) {

            if ((FrequencyEntry->BitsPerPel ==
                    ModeEntry->ModeInformation.BitsPerPlane) &&
                (FrequencyEntry->ScreenWidth ==
                    ModeEntry->ModeInformation.VisScreenWidth)) {

                //
                // We've found a mode table entry that matches this frequency
                // table entry.  Now we'll figure out if we can actually do
                // this mode/frequency combination.  For now, assume we'll
                // succeed.
                //

                FrequencyEntry->ModeEntry = ModeEntry;
                FrequencyEntry->ModeValid = TRUE;

                //
                // Flags for private communication with the S3 display driver.
                //

                ModeEntry->ModeInformation.DriverSpecificAttributeFlags =
                    hwDeviceExtension->Capabilities;

                if (*PointerCapability & POINTER_WORKS_ONLY_AT_8BPP) {

                    //
                    // Rule: On 911, 80x, and 928 chips we always use the
                    //       built-in S3 pointer whenever we can; modes of
                    //       colour depths greater than 8bpp, or resolutions
                    //       of width more than 1024, require a DAC pointer.
                    //

                    if ((ModeEntry->ModeInformation.BitsPerPlane == 8) &&
                        (ModeEntry->ModeInformation.VisScreenWidth <= 1024)) {

                        //
                        // Always use the S3 pointer in lieu of the Brooktree
                        // or TI pointer whenever we can.
                        //

                        ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                            &= ~CAPS_DAC_POINTER;

                        if ((hwDeviceExtension->DacID == TI_3020) &&
                            (hwDeviceExtension->ChipID == S3_928)) {

                            //
                            // There are goofy 4-MB Level 14 #9 boards where
                            // stuff is shown on the screen if we try to use
                            // the built-in S3 pointer, and the hot-spot
                            // is wrong if we try to use the TI pointer.
                            // There are other 928 boards with TI 3020 DACs
                            // where the internal S3 pointer doesn't work.  So
                            // punt to a software pointer for these modes:
                            //

                            ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                                |= CAPS_SW_POINTER;
                        }

                    } else {

                        //
                        // We can't use the built-in S3 pointer; if we don't
                        // have a DAC pointer, use a software pointer.
                        //

                        if (!(ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                            & CAPS_DAC_POINTER)) {

                            ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                                |= CAPS_SW_POINTER;
                        }
                    }

                } else {

                    //
                    // On 864/964 or newer chips, the built-in S3 pointer
                    // either handles all colour depths or none.
                    //

                    if (*PointerCapability & POINTER_BUILT_IN) {

                        if (*PointerCapability & POINTER_NEEDS_SCALING) {

                            //
                            // Check out the type of DAC:
                            //
                            // Note: This I/O should likely be moved out of the
                            //       prune loop.
                            //

                            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x67);
                            reg67 = (UCHAR) VideoPortReadPortUchar(CRT_DATA_REG);

                            //
                            // Newer 864 BIOSes revert to 8-bit DAC mode when
                            // running at 640x480x16bpp even if the DAC is
                            // 16-bits, due to a conflict with the Reel Magic
                            // MPEG board at that resolution.  Unfortunately,
                            // there's not a consistent BIOS version number
                            // that we can look for; we could check the
                            // DAC type after doing the int 10, but
                            // unfortunately, we need this information now
                            // to decide whether we should scale the x-
                            // coordinate or not.
                            //
                            // So simply always use a software pointer when
                            // running at 640x480x16bpp, and there is no
                            // DAC pointer:
                            //

                            if (!(ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                                  & CAPS_DAC_POINTER) &&
                                (ModeEntry->ModeInformation.BitsPerPlane == 16) &&
                                (ModeEntry->ModeInformation.VisScreenWidth == 640)) {

                                ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                                    |= CAPS_SW_POINTER;

                            } else if (reg67 == 8) {

                                //
                                // It's an 8bit DAC.  At 16bpp, we have to
                                // scale the x-coordinate by 2.  At 32bpp,
                                // we have to use a software pointer.
                                //

                                if (ModeEntry->ModeInformation.BitsPerPlane == 16) {

                                    ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                                        |= CAPS_SCALE_POINTER;

                                } else {

                                    ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                                        |= CAPS_SW_POINTER;
                                }

                            } else {

                                //
                                // It's a 16bit DAC.  For 32bpp modes, we have
                                // to scale the pointer position by 2:
                                //

                                if (ModeEntry->ModeInformation.BitsPerPlane == 32) {

                                    ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                                        |= CAPS_SCALE_POINTER;
                                }
                            }
                        }
                    } else {

                        //
                        // There's no built-in S3 pointer.  If we haven't
                        // detected a DAC pointer, we have to use a software
                        // pointer.
                        //

                        if (!(ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                            & CAPS_DAC_POINTER)) {

                            ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                                |= CAPS_SW_POINTER;
                        }
                    }
                }

                //
                // Rule: We allow refresh rates higher than 76 Hz only for
                //       cards that don't have a built-in S3 pointer.  We
                //       do this because we assume that such cards are VRAM
                //       based and have a good external DAC that can properly
                //       handle rates higher than 76 Hz -- because we have
                //       found many Diamond DRAM cards that produce improper
                //       displays at the higher rates, especially on non-x86
                //       machines.
                //

                if ((FrequencyEntry->ScreenFrequency > 76) &&
                    (*PointerCapability & POINTER_BUILT_IN)) {

                    FrequencyEntry->ModeValid = FALSE;

                }

                //
                // Rule: We handle only 8bpp on 911/924 cards.  These chips can also
                //       support only non-contiguous modes.
                //

                if (hwDeviceExtension->ChipID == S3_911) {

                    if (ModeEntry->ModeInformation.BitsPerPlane != 8) {

                        FrequencyEntry->ModeValid = FALSE;

                    } else {

                        ModeEntry->Int10ModeNumberContiguous =
                            ModeEntry->Int10ModeNumberNoncontiguous;

                        ModeEntry->ScreenStrideContiguous =
                            ModeEntry->ModeInformation.ScreenStride;
                    }
                }

                //
                // Rule: The 868/968 cannot do 'new packed 32-bit transfers'
                //       at 8bpp because of a chip bug.
                //

                if ((ModeEntry->ModeInformation.BitsPerPlane == 8) &&
                    ((hwDeviceExtension->SubTypeID == SUBTYPE_868) ||
                     (hwDeviceExtension->SubTypeID == SUBTYPE_968))) {

                    ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                        &= ~CAPS_PACKED_EXPANDS;
                }

                //
                // Rule: The 801/805 cannot do any accelerated modes above
                //       16bpp.
                //

                if ((hwDeviceExtension->ChipID == S3_801) &&
                    (ModeEntry->ModeInformation.BitsPerPlane > 16)) {

                    FrequencyEntry->ModeValid = FALSE;
                }

                //
                // Rule: We use the 2xx non-contiguous modes whenever we can
                //       on 80x/928 boards because some BIOSes have bugs for
                //       the contiguous 8bpp modes.
                //
                //       We don't use the non-contiguous modes on 864 cards
                //       because most 864 BIOSes have a bug where they don't
                //       set the M and N parameters correctly on 1 MB cards,
                //       causing screen noise.
                //

                if ((ModeEntry->ModeInformation.BitsPerPlane == 8) &&
                    (hwDeviceExtension->ChipID <= S3_928)) {

                    //
                    // If we have only 512k, we can't use a non-contiguous
                    // 800x600x256 mode.
                    //

                    if ((ModeEntry->ModeInformation.VisScreenWidth == 640) ||
                        ((ModeEntry->ModeInformation.VisScreenWidth == 800) &&
                         (hwDeviceExtension->AdapterMemorySize > 0x080000))) {

                        ModeEntry->Int10ModeNumberContiguous =
                            ModeEntry->Int10ModeNumberNoncontiguous;

                        ModeEntry->ScreenStrideContiguous =
                            ModeEntry->ModeInformation.ScreenStride;
                    }
                }

                //
                // Rule: Only 964 or 968 or newer boards can handle resolutions
                //       larger than 1280x1024:
                //

                if (ModeEntry->ModeInformation.VisScreenWidth > 1280) {

                    if ((hwDeviceExtension->SubTypeID != SUBTYPE_964) &&
                        (hwDeviceExtension->SubTypeID < SUBTYPE_968)) {

                        FrequencyEntry->ModeValid = FALSE;
                    }
                }

                //
                // Rule: 911s and early revs of 805s and 928s cannot do
                //       1152x864:
                //

                if (ModeEntry->ModeInformation.VisScreenWidth == 1152) {

                    if ((hwDeviceExtension->ChipID == S3_911) ||
                        (jChipID == 0xA0)                     ||
                        (jChipID == 0x90)) {

                        FrequencyEntry->ModeValid = FALSE;
                    }

                    //
                    // Number 9 has different int 10 numbers from
                    // Diamond for 1152x864x16bpp and 1152x864x32bpp.
                    // Later perhaps we should incorporate mode numbers
                    // along with the frequency tables.
                    //

                    if (hwDeviceExtension->BoardID == S3_NUMBER_NINE) {

                        if (ModeEntry->ModeInformation.BitsPerPlane == 16) {

                            ModeEntry->Int10ModeNumberContiguous =
                                ModeEntry->Int10ModeNumberNoncontiguous =
                                    0x126;

                        } else if (ModeEntry->ModeInformation.BitsPerPlane == 32) {

                            ModeEntry->Int10ModeNumberContiguous =
                                ModeEntry->Int10ModeNumberNoncontiguous =
                                    0x127;
                        }

                    }
                }

                //
                // 24bpp support. Need s3 968 and linear space for banks.
                //
                if (ModeEntry->ModeInformation.BitsPerPlane == 24) {

                    //
                    // 24bpp on diamond s3 968 seems to have problems doing ULONG reads.
                    //

                    if (hwDeviceExtension->BoardID == S3_DIAMOND)
                        ModeEntry->ModeInformation.DriverSpecificAttributeFlags |=
                            CAPS_BAD_DWORD_READS;

                    //
                    // Set FALSE for other than 968 and clear CAPS_BAD_DWORD_READS.
                    //

                    if ((hwDeviceExtension->SubTypeID != SUBTYPE_968) ||
                        ((hwDeviceExtension->BoardID != S3_DIAMOND) &&
                         (hwDeviceExtension->BoardID != S3_NUMBER_NINE)) ||           //#9 968 24bpp
                        (!(hwDeviceExtension->Capabilities & CAPS_NEW_MMIO))) {

                        FrequencyEntry->ModeValid = FALSE;

                        ModeEntry->ModeInformation.DriverSpecificAttributeFlags &=
                            ~CAPS_BAD_DWORD_READS;
                    }
                }

                if ((ModeEntry->ModeInformation.VisScreenWidth == 800) &&
                    (ModeEntry->ModeInformation.BitsPerPlane == 32)) {

                    //
                    // Rule: 928 revs A through D can only do 800x600x32 in
                    //       a non-contiguous mode.
                    //

                    if (jChipID == 0x90) {

                        ModeEntry->ScreenStrideContiguous =
                            ModeEntry->ModeInformation.ScreenStride;
                    }
                }

                if (hwDeviceExtension->SubTypeID == SUBTYPE_732) {

                    //
                    // Rule: The 732 Trio32 chip simply can't do 800x600x32bpp.
                    //

                    if ((ModeEntry->ModeInformation.VisScreenWidth == 800) &&
                        (ModeEntry->ModeInformation.BitsPerPlane == 32)) {

                        FrequencyEntry->ModeValid = FALSE;

                    //
                    // Rule: The 732 Trio32 chip simply can't do 1152x864x16bpp.
                    //

                    } else if ((ModeEntry->ModeInformation.VisScreenWidth == 1152) &&
                               (ModeEntry->ModeInformation.BitsPerPlane == 16)) {

                        FrequencyEntry->ModeValid = FALSE;
                    //
                    // Rule: The 732 Trio32 chip simply can't do 1280x1024 modes
                    //

                    } else if ((ModeEntry->ModeInformation.VisScreenWidth) == 1280) {
                        FrequencyEntry->ModeValid = FALSE;
                    }
                }

                //
                // Rule: We have to have enough memory to handle the mode.
                //
                //       Note that we use the contiguous width for this
                //       computation; unfortunately, we don't know at this time
                //       whether we can handle a contiguous mode or not, so we
                //       may err on the side of listing too many possible modes.
                //
                //       We may also list too many possible modes if the card
                //       combines VRAM with a DRAM cache, because it will report
                //       the VRAM + DRAM amount of memory, but only the VRAM can
                //       be used as screen memory.
                //

                if (ModeEntry->ModeInformation.VisScreenHeight *
                    ModeEntry->ScreenStrideContiguous >
                    hwDeviceExtension->AdapterMemorySize) {

                    FrequencyEntry->ModeValid = FALSE;
                }

                //
                // Rule: If we can't use Int 10, restrict 1280x1024 to Number9
                //       cards, because I haven't been able to fix the mode
                //       tables for other cards yet.
                //

                if (FrequencyTable == hwDeviceExtension->FixedFrequencyTable) {

                    if ((ModeEntry->ModeInformation.VisScreenHeight == 1280) &&
                        (hwDeviceExtension->BoardID != S3_NUMBER_NINE)) {

                        FrequencyEntry->ModeValid = FALSE;
                    }

                    //
                    // Rule: If there isn't a table entry for programming the CRTC,
                    //       we can't do this frequency at this mode.
                    //

                    if (FrequencyEntry->Fixed.CRTCTable[hwDeviceExtension->ChipID]
                        == NULL) {

                        FrequencyEntry->ModeValid = FALSE;
                        break;
                    }
                }

                //
                // Don't forget to count it if it's still a valid mode after
                // applying all those rules.
                //

                if (FrequencyEntry->ModeValid) {

                    hwDeviceExtension->NumAvailableModes++;
                }

                //
                // We've found a mode for this frequency entry, so we
                // can break out of the mode loop:
                //

                break;

            }
        }
    }

    hwDeviceExtension->NumTotalModes = ModeIndex;

    VideoDebugPrint((2, "S3: Number of modes = %d\n", ModeIndex));
}

VP_STATUS
S3RegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

/*++

Routine Description:

    This routine determines if the alternate register set was requested via
    the registry.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    Context - Context value passed to the get registry paramters routine.

    ValueName - Name of the value requested.

    ValueData - Pointer to the requested data.

    ValueLength - Length of the requested data.

Return Value:

    returns NO_ERROR if the paramter was TRUE.
    returns ERROR_INVALID_PARAMETER otherwise.

--*/

{

    if (ValueLength && *((PULONG)ValueData)) {

        return NO_ERROR;

    } else {

        return ERROR_INVALID_PARAMETER;

    }

} // end S3RegistryCallback()


BOOLEAN
S3Initialize(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine does one time initialization of the device.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:


    Always returns TRUE since this routine can never fail.

--*/

{
    UNREFERENCED_PARAMETER(HwDeviceExtension);

    return TRUE;

} // end S3Initialize()

BOOLEAN
S3ResetHw(
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    )

/*++

Routine Description:

    This routine preps the S3 card for return to a VGA mode.

    This routine is called during system shutdown.  By returning
    a FALSE we inform the HAL to do an int 10 to go into text
    mode before shutting down.  Shutdown would fail with some S3
    cards without this.

    We do some clean up before returning so that the int 10
    will work.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

    The return value of FALSE informs the hal to go into text mode.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    UNREFERENCED_PARAMETER(Columns);
    UNREFERENCED_PARAMETER(Rows);

    //
    // We don't want to execute this reset code if we are not
    // currently in an S3 mode!
    //

    if (!hwDeviceExtension->bNeedReset)
    {
        return FALSE;
    }

    hwDeviceExtension->bNeedReset = FALSE;

    //
    // Wait for the GP to become idle.
    //

    while (VideoPortReadPortUshort(GP_STAT) & 0x0200);

    //
    // Zero the DAC and the Screen buffer memory.
    //

    ZeroMemAndDac(HwDeviceExtension);

    //
    // Reset the board to a default mode
    //
    // After NT 3.51 ships use the same modetable for all
    // architectures, but just to be sure we don't break
    // something we'll use two for now.  The 'no_bios'
    // version of the modetable is for the IBM PS/2 model
    // 76i.
    //

    if (hwDeviceExtension->BiosPresent == FALSE)
    {
        SetHWMode(HwDeviceExtension, s3_set_vga_mode_no_bios);
    }
    else
    {
        SetHWMode(HwDeviceExtension, s3_set_vga_mode);
    }

    return FALSE;
}


BOOLEAN
S3StartIO(
    PVOID pvHwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

/*++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    acceptss a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    RequestPacket - Pointer to the video request packet. This structure
        contains all the parameters passed to the VideoIoControl function.

Return Value:


--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = pvHwDeviceExtension;
    PHW_DEVICE_EXTENSION HwDeviceExtension = pvHwDeviceExtension;
    VP_STATUS status;
    PVIDEO_MODE_INFORMATION modeInformation;
    PVIDEO_CLUT clutBuffer;
    UCHAR byte;

    ULONG modeNumber;
    PS3_VIDEO_MODES ModeEntry;
    PS3_VIDEO_FREQUENCIES FrequencyEntry;
    PS3_VIDEO_FREQUENCIES FrequencyTable;

    UCHAR ModeControlByte;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;

    PVIDEO_SHARE_MEMORY pShareMemory;
    PVIDEO_SHARE_MEMORY_INFORMATION pShareMemoryInformation;
    PHYSICAL_ADDRESS shareAddress;
    PVOID virtualAddress;
    ULONG sharedViewSize;
    ULONG inIoSpace;

    UCHAR OriginalRegPrimary;
    UCHAR OriginalRegSecondary;

    //
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //

    switch (RequestPacket->IoControlCode) {


    case IOCTL_VIDEO_MAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "S3tartIO - MapVideoMemory\n"));

        {
            PVIDEO_MEMORY_INFORMATION memoryInformation;
            ULONG physicalFrameLength;
            ULONG inIoSpace;

            if ( (RequestPacket->OutputBufferLength <
                  (RequestPacket->StatusBlock->Information =
                                         sizeof(VIDEO_MEMORY_INFORMATION))) ||
                 (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) ) {

                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            memoryInformation = RequestPacket->OutputBuffer;

            memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
                    (RequestPacket->InputBuffer))->RequestedVirtualAddress;

            physicalFrameLength = hwDeviceExtension->FrameLength;

            inIoSpace = hwDeviceExtension->PhysicalFrameIoSpace;

            //
            // IMPORTANT - As a rule we only map the actual amount of memory
            // on the board, not the whole physical address space reported
            // by PCI.  The reason for this is that mapping the memory takes
            // up a lot of resources in the machine, which as quite scarce by
            // default.  Mapping 64MEG of address space would actually always
            // fail in machines that have 32MEG or even 64MEG of RAM.
            //

            //
            // Performance:
            //
            // Enable USWC on the P6 processor.
            // We only do it for the frame buffer - memory mapped registers can
            // not be mapped USWC because write combining the registers would
            // cause very bad things to happen !
            //

            inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;

            //
            // P6 workaround:
            //
            // Because of a current limitation in many P6 machines, USWC only
            // works on sections of 4MEG of memory.  So lets round up the size
            // of memory on the cards that have less than 4MEG up to 4MEG so
            // they can also benefit from this feature.
            //
            // We will only do this for NEW_MMIO cards, which have a large
            // block of address space that is reserved via PCI.  This way
            // we are sure we will not conflict with another device that might
            // have addresses right after us.
            //
            // We do this only for mapping purposes.  We still want to return
            // the real size of memory since the driver can not use memory that
            // is not actually there !
            //

            if ((hwDeviceExtension->Capabilities & CAPS_NEW_MMIO) &&
                (physicalFrameLength < 0x00400000)) {

                physicalFrameLength = 0x00400000;
            }

            status = VideoPortMapMemory(hwDeviceExtension,
                                        hwDeviceExtension->PhysicalFrameAddress,
                                        &physicalFrameLength,
                                        &inIoSpace,
                                        &(memoryInformation->VideoRamBase));

            //
            // The frame buffer and virtual memory are equivalent in this
            // case.
            //

            memoryInformation->FrameBufferBase =
                memoryInformation->VideoRamBase;

            memoryInformation->FrameBufferLength =
                hwDeviceExtension->FrameLength;

            memoryInformation->VideoRamLength =
                hwDeviceExtension->FrameLength;
        }

        break;


    case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "S3StartIO - UnMapVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      ((PVIDEO_MEMORY)
                                       (RequestPacket->InputBuffer))->
                                           RequestedVirtualAddress,
                                      0);

        break;


    case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:

        VideoDebugPrint((2, "S3StartIO - QueryPublicAccessRanges\n"));

        {

           PVIDEO_PUBLIC_ACCESS_RANGES portAccess;
           ULONG physicalPortLength;

           if ( RequestPacket->OutputBufferLength <
                 (RequestPacket->StatusBlock->Information =
                                        2 * sizeof(VIDEO_PUBLIC_ACCESS_RANGES)) ) {

               status = ERROR_INSUFFICIENT_BUFFER;
               break;
           }

           portAccess = RequestPacket->OutputBuffer;

           portAccess->VirtualAddress  = (PVOID) NULL;    // Requested VA
           portAccess->InIoSpace       = hwDeviceExtension->RegisterSpace;
           portAccess->MappedInIoSpace = portAccess->InIoSpace;

           physicalPortLength = hwDeviceExtension->RegisterLength;

           status = VideoPortMapMemory(hwDeviceExtension,
                                       hwDeviceExtension->PhysicalRegisterAddress,
                                       &physicalPortLength,
                                       &(portAccess->MappedInIoSpace),
                                       &(portAccess->VirtualAddress));

           if (status == NO_ERROR) {

               portAccess++;

               portAccess->VirtualAddress  = (PVOID) NULL;    // Requested VA
               portAccess->InIoSpace       = hwDeviceExtension->MmIoSpace;
               portAccess->MappedInIoSpace = portAccess->InIoSpace;

               physicalPortLength = hwDeviceExtension->MmIoLength;

               status = VideoPortMapMemory(hwDeviceExtension,
                                           hwDeviceExtension->PhysicalMmIoAddress,
                                           &physicalPortLength,
                                           &(portAccess->MappedInIoSpace),
                                           &(portAccess->VirtualAddress));
            }
        }

        break;


    case IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES:

        VideoDebugPrint((2, "S3StartIO - FreePublicAccessRanges\n"));

        {
            PVIDEO_MEMORY mappedMemory;

            if (RequestPacket->InputBufferLength < 2 * sizeof(VIDEO_MEMORY)) {

                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            status = NO_ERROR;

            mappedMemory = RequestPacket->InputBuffer;

            if (mappedMemory->RequestedVirtualAddress != NULL) {

                status = VideoPortUnmapMemory(hwDeviceExtension,
                                              mappedMemory->
                                                   RequestedVirtualAddress,
                                              0);
            }

            if (status == NO_ERROR) {

                mappedMemory++;

                status = VideoPortUnmapMemory(hwDeviceExtension,
                                              mappedMemory->
                                                   RequestedVirtualAddress,
                                              0);
            }
        }

        break;


    case IOCTL_VIDEO_QUERY_AVAIL_MODES:

        VideoDebugPrint((2, "S3StartIO - QueryAvailableModes\n"));

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information =
                 hwDeviceExtension->NumAvailableModes
                 * sizeof(VIDEO_MODE_INFORMATION)) ) {

            VideoDebugPrint((1, "\n*** NOT ENOUGH MEMORY FOR OUTPUT ***\n\n"));

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            modeInformation = RequestPacket->OutputBuffer;

            if (hwDeviceExtension->BiosPresent) {

                FrequencyTable = hwDeviceExtension->Int10FrequencyTable;

            } else {

                FrequencyTable = hwDeviceExtension->FixedFrequencyTable;
            }

            for (FrequencyEntry = FrequencyTable;
                 FrequencyEntry->BitsPerPel != 0;
                 FrequencyEntry++) {

                if (FrequencyEntry->ModeValid) {

                    *modeInformation =
                        FrequencyEntry->ModeEntry->ModeInformation;

                    modeInformation->Frequency =
                        FrequencyEntry->ScreenFrequency;

                    modeInformation->ModeIndex =
                        FrequencyEntry->ModeIndex;

                    modeInformation++;
                }
            }

            status = NO_ERROR;
        }

        break;


    case IOCTL_VIDEO_QUERY_CURRENT_MODE:

        VideoDebugPrint((2, "S3StartIO - QueryCurrentModes\n"));

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information =
            sizeof(VIDEO_MODE_INFORMATION)) ) {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            *((PVIDEO_MODE_INFORMATION)RequestPacket->OutputBuffer) =
                hwDeviceExtension->ActiveModeEntry->ModeInformation;

            ((PVIDEO_MODE_INFORMATION)RequestPacket->OutputBuffer)->Frequency =
                hwDeviceExtension->ActiveFrequencyEntry->ScreenFrequency;

            status = NO_ERROR;

        }

        break;


    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        VideoDebugPrint((2, "S3StartIO - QueryNumAvailableModes\n"));

        //
        // Find out the size of the data to be put in the the buffer and
        // return that in the status information (whether or not the
        // information is there). If the buffer passed in is not large
        // enough return an appropriate error code.
        //

        if (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information =
                                                sizeof(VIDEO_NUM_MODES)) ) {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->NumModes =
                hwDeviceExtension->NumAvailableModes;

            ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->ModeInformationLength =
                sizeof(VIDEO_MODE_INFORMATION);

            status = NO_ERROR;
        }

        break;


    case IOCTL_VIDEO_SET_CURRENT_MODE:

        VideoDebugPrint((2, "S3StartIO - SetCurrentMode\n"));

        //
        // Check if the size of the data in the input buffer is large enough.
        //

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MODE)) {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;

        }

        //
        // Assume failure for now.
        //

        status = ERROR_INVALID_PARAMETER;

        //
        // Find the correct entries in the S3_VIDEO_MODES and S3_VIDEO_FREQUENCIES
        // tables that correspond to this mode number.  (Remember that each
        // mode in the S3_VIDEO_MODES table can have a number of possible
        // frequencies associated with it.)
        //

        modeNumber = ((PVIDEO_MODE) RequestPacket->InputBuffer)->RequestedMode;

        if (modeNumber >= hwDeviceExtension->NumTotalModes) {

            break;

        }

        if (hwDeviceExtension->BiosPresent) {

            FrequencyEntry = &hwDeviceExtension->Int10FrequencyTable[modeNumber];

            if (!(FrequencyEntry->ModeValid)) {

                break;

            }

            ModeEntry = FrequencyEntry->ModeEntry;

            //
            // At this point, 'ModeEntry' and 'FrequencyEntry' point to the
            // necessary table entries required for setting the requested mode.
            //

            VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

            //
            // Unlock the S3 registers.
            //

            VideoPortWritePortUshort(CRT_ADDRESS_REG, 0x4838);
            VideoPortWritePortUshort(CRT_ADDRESS_REG, 0xA039);

            //
            // Use register 52 before every Int 10 modeset to set the refresh
            // rate.  If the card doesn't support it, or we don't know what
            // values to use, the requested frequency will be '1', which means
            // 'use the hardware default refresh.'
            //

            if (FrequencyEntry->ScreenFrequency != 1) {

                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x52);

                OriginalRegPrimary =  VideoPortReadPortUchar(CRT_DATA_REG);
                ModeControlByte    =  OriginalRegPrimary;
                ModeControlByte   &= ~FrequencyEntry->Int10.FrequencyPrimaryMask;
                ModeControlByte   |=  FrequencyEntry->Int10.FrequencyPrimarySet;

                VideoPortWritePortUchar(CRT_DATA_REG, ModeControlByte);

                if (FrequencyEntry->Int10.FrequencySecondaryMask != 0) {
                    VideoPortWritePortUchar(CRT_ADDRESS_REG,
                                            hwDeviceExtension->FrequencySecondaryIndex);

                    OriginalRegSecondary =  VideoPortReadPortUchar(CRT_DATA_REG);
                    ModeControlByte      =  OriginalRegSecondary;
                    ModeControlByte     &= ~FrequencyEntry->Int10.FrequencySecondaryMask;
                    ModeControlByte     |=  FrequencyEntry->Int10.FrequencySecondarySet;

                    VideoPortWritePortUchar(CRT_DATA_REG, ModeControlByte);
                }

            }

            //
            // To do 24bpp on the #9 968 set bit 7 in register 41 before every
            // Int 10 modeset. If not doing 24bpp, clear that bit.
            //

            if ((hwDeviceExtension->BoardID == S3_NUMBER_NINE) &&
                (hwDeviceExtension->SubTypeID == SUBTYPE_968)) {

                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x41);

                OriginalRegPrimary =  VideoPortReadPortUchar(CRT_DATA_REG);
                ModeControlByte    =  OriginalRegPrimary;

                if (ModeEntry->ModeInformation.BitsPerPlane == 24) {
                    ModeControlByte   |=  0x80;
                } else {
                    ModeControlByte   &=  ~0x80;
                }

                VideoPortWritePortUchar(CRT_DATA_REG, ModeControlByte);

            }

            //
            // Turn off the screen to work around a bug in some
            // s3 bios's.  (The symptom of the bug is we loop
            // forever in the bios after trying to set a mode.)
            //

            VideoPortWritePortUchar(SEQ_ADDRESS_REG, 0x1);
            VideoPortWritePortUchar(SEQ_DATA_REG,
                (UCHAR)(VideoPortReadPortUchar(SEQ_DATA_REG) | 0x20));

            //
            // First try the modeset with the 'Contiguous' mode:
            //

            biosArguments.Ebx = ModeEntry->Int10ModeNumberContiguous;
            biosArguments.Eax = 0x4f02;

            status = VideoPortInt10(HwDeviceExtension, &biosArguments);

            if (status != NO_ERROR) {
                VideoDebugPrint((1, "S3: first int10 call FAILED\n"));
            }

            if ((status == NO_ERROR) && (biosArguments.Eax & 0xff00) == 0) {

                //
                // The contiguous mode set succeeded.
                //

                ModeEntry->ModeInformation.ScreenStride =
                    ModeEntry->ScreenStrideContiguous;

            } else {

                //
                // Try again with the 'Noncontiguous' mode:
                //

                biosArguments.Ebx = ModeEntry->Int10ModeNumberNoncontiguous;
                biosArguments.Eax = 0x4f02;

                status = VideoPortInt10(HwDeviceExtension, &biosArguments);

                if (status != NO_ERROR)
                {
                    VideoDebugPrint((1, "S3: second int10 call FAILED\n"));
                }

                //
                // If the video port called succeeded, check the register return
                // code.  Some HP BIOSes always return failure even when the
                // int 10 works fine, so we ignore its return code.
                //

                if ((status == NO_ERROR) &&
                    ((hwDeviceExtension->BoardID != S3_HP) &&
                       ((biosArguments.Eax & 0xff00) != 0))) {

                    status = ERROR_INVALID_PARAMETER;
                }
            }

            if (FrequencyEntry->ScreenFrequency != 1) {

                //
                // Unlock the S3 registers.
                //

                VideoPortWritePortUshort(CRT_ADDRESS_REG, 0x4838);
                VideoPortWritePortUshort(CRT_ADDRESS_REG, 0xA039);

                //
                // If the user has been running the Display Applet and we're
                // reverting back to 'hardware default setting,' we have to
                // restore the refresh registers to their original settings.
                //

                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x52);
                VideoPortWritePortUchar(CRT_DATA_REG, OriginalRegPrimary);

                VideoPortWritePortUchar(CRT_ADDRESS_REG,
                    hwDeviceExtension->FrequencySecondaryIndex);
                VideoPortWritePortUchar(CRT_DATA_REG, OriginalRegSecondary);
            }
        }

        if (status != NO_ERROR) {

            VideoDebugPrint((1, "S3: Trying fixed mode-set\n"));

            //
            // A problem occured during the int10.  Let's see if we can recover.
            //

#ifndef S3_USE_FIXED_TABLES

            //
            // If we are only supposed to use int10, then this is total
            // failure.  Just leave.
            //

            break;

#endif

            //
            // Let see if we are using a fixed mode table number
            //

            if (!hwDeviceExtension->BiosPresent) {

                FrequencyEntry = &hwDeviceExtension->FixedFrequencyTable[modeNumber];

            } else {

                PS3_VIDEO_FREQUENCIES oldFrequencyEntry = FrequencyEntry;
                PS3_VIDEO_FREQUENCIES newFrequencyEntry;
                PS3_VIDEO_FREQUENCIES bestFrequencyEntry;

                //
                // Okay, we constructed our original mode list assuming
                // we could use Int 10, but we have just discovered the
                // Int 10 didn't work -- probably because there was a
                // problem with the BIOS emulator.  To recover, we will now
                // try to find the best mode in the Fixed Frequency table to
                // match the requested mode.
                //

                FrequencyEntry = NULL;
                bestFrequencyEntry = NULL;

                for (newFrequencyEntry = &hwDeviceExtension->FixedFrequencyTable[0];
                     newFrequencyEntry->BitsPerPel != 0;
                     newFrequencyEntry++) {

                    //
                    // Check for a matching mode.
                    //

                    if ( (newFrequencyEntry->BitsPerPel ==
                            oldFrequencyEntry->BitsPerPel) &&
                         (newFrequencyEntry->ScreenWidth ==
                            oldFrequencyEntry->ScreenWidth) ) {

                        if (FrequencyEntry == NULL) {

                            //
                            // Remember the first mode that matched, ignoring
                            // the frequency.
                            //

                            FrequencyEntry = newFrequencyEntry;
                        }

                        if (newFrequencyEntry->ScreenFrequency <=
                              oldFrequencyEntry->ScreenFrequency) {

                            //
                            // Ideally, we would like to choose the frequency
                            // that is closest to, but less than or equal to,
                            // the requested frequency.
                            //

                            if ( (bestFrequencyEntry == NULL) ||
                                 (bestFrequencyEntry->ScreenFrequency <
                                     newFrequencyEntry->ScreenFrequency) ) {

                                bestFrequencyEntry = newFrequencyEntry;
                            }
                        }
                    }
                }

                //
                // Use the preferred frequency setting, if there is one.
                //

                if (bestFrequencyEntry != NULL) {

                    FrequencyEntry = bestFrequencyEntry;

                }

                //
                // If we have no valid mode, we must return failure
                //

                if (FrequencyEntry == NULL) {

                    VideoDebugPrint((1, "S3: no valid Fixed Frequency mode\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;

                }

                //
                // Our new ModeEntry is the same as the old.
                //

                FrequencyEntry->ModeEntry = oldFrequencyEntry->ModeEntry;
                FrequencyEntry->ModeValid = TRUE;

                VideoDebugPrint((1, "S3: Selected Fixed Frequency mode from int 10:\n"));
                VideoDebugPrint((1, "    Bits Per Pel: %d\n", FrequencyEntry->BitsPerPel));
                VideoDebugPrint((1, "    Screen Width: %d\n", FrequencyEntry->ScreenWidth));
                VideoDebugPrint((1, "    Frequency: %d\n", FrequencyEntry->ScreenFrequency));

            }

            ModeEntry = FrequencyEntry->ModeEntry;

            //
            // NOTE:
            // We have to set the ActiveFrequencyEntry since the SetHWMode
            // function depends on this variable to set the CRTC registers.
            // So lets set it here, and it will get reset to the same
            // value after we set the mode.
            //

            hwDeviceExtension->ActiveFrequencyEntry = FrequencyEntry;

            //
            // If it failed, we may not be able to perform int10 due
            // to BIOS emulation problems.
            //
            // Then just do a table mode-set.  First we need to find the
            // right mode table in the fixed Frequency tables.
            //

            //
            // Select the Enhanced mode init depending upon the type of
            // chip found.

            if ( (hwDeviceExtension->BoardID == S3_NUMBER_NINE) &&
                 (ModeEntry->ModeInformation.VisScreenWidth == 1280) ) {

                  SetHWMode(hwDeviceExtension, S3_928_1280_Enhanced_Mode);

            } else {

                //
                // Use defaults for all other boards
                //

                switch(hwDeviceExtension->ChipID) {

                case S3_911:

                    SetHWMode(hwDeviceExtension, S3_911_Enhanced_Mode);
                    break;

                case S3_801:

                    SetHWMode(hwDeviceExtension, S3_801_Enhanced_Mode);
                    break;

                case S3_928:

                    SetHWMode(hwDeviceExtension, S3_928_Enhanced_Mode);

                    break;

                case S3_864:

                    SetHWMode(hwDeviceExtension, S3_864_Enhanced_Mode);
                    Set864MemoryTiming(hwDeviceExtension);
                    break;

                default:

                    VideoDebugPrint((1, "S3: Bad chip type for these boards"));
                    break;
                }

            }
        }

        //
        // Call Int 10, function 0x4f06 to obtain the correct screen pitch
        // of all S3's except the 911/924.
        //

        if ((hwDeviceExtension->ChipID != S3_911) &&
            (hwDeviceExtension->BiosPresent)) {

            VideoPortZeroMemory(&biosArguments,sizeof(VIDEO_X86_BIOS_ARGUMENTS));

            biosArguments.Ebx = 0x0001;
            biosArguments.Eax = 0x4f06;

            status = VideoPortInt10(HwDeviceExtension, &biosArguments);

            //
            // Check to see if the Bios supported this function, and if so
            // update the screen stride for this mode.
            //

            if ((status == NO_ERROR) && (biosArguments.Eax & 0xffff) == 0x004f) {

                ModeEntry->ModeInformation.ScreenStride =
                    biosArguments.Ebx;

            } else {

                //
                // We will use the default value in the mode table.
                //
            }
        }

        //
        // Save the mode since we know the rest will work.
        //

        hwDeviceExtension->ActiveModeEntry = ModeEntry;
        hwDeviceExtension->ActiveFrequencyEntry = FrequencyEntry;

        //
        // Record the fact that we are in an S3 mode, and
        // that we need to be reset.
        //

        hwDeviceExtension->bNeedReset = TRUE;

        //////////////////////////////////////////////////////////////////
        // Update VIDEO_MODE_INFORMATION fields
        //
        // Now that we've set the mode, we now know the screen stride, and
        // so can update some fields in the VIDEO_MODE_INFORMATION
        // structure for this mode.  The S3 display driver is expected to
        // call IOCTL_VIDEO_QUERY_CURRENT_MODE to query these corrected
        // values.
        //

        //
        // Calculate the bitmap width.
        // We currently assume the bitmap width is equivalent to the stride.
        //

        {
            LONG x;

            x = ModeEntry->ModeInformation.BitsPerPlane;

            //
            // you waste 16 bps even when you only use 15 for info.
            //

            if( x == 15 )
            {
                x = 16;
            }

            ModeEntry->ModeInformation.VideoMemoryBitmapWidth =
                (ModeEntry->ModeInformation.ScreenStride * 8) / x;
        }

        //
        // If we're in a mode that the BIOS doesn't really support, it may
        // have reported back a bogus screen width.
        //

        if (ModeEntry->ModeInformation.VideoMemoryBitmapWidth <
            ModeEntry->ModeInformation.VisScreenWidth) {

            VideoDebugPrint((1, "S3: BIOS returned invalid screen width\n"));
            status = ERROR_INVALID_PARAMETER;
            break;
        }

        //
        // Calculate the bitmap height.
        //

        ModeEntry->ModeInformation.VideoMemoryBitmapHeight =
            hwDeviceExtension->AdapterMemorySize /
            ModeEntry->ModeInformation.ScreenStride;

        //
        // The current position registers in the current S3 chips are
        // limited to 12 bits of precision, with the range [0, 4095].
        // Consequently, we must clamp the bitmap height so that we don't
        // attempt to do any drawing beyond that range.
        //

        ModeEntry->ModeInformation.VideoMemoryBitmapHeight =
            MIN(4096, ModeEntry->ModeInformation.VideoMemoryBitmapHeight);

        //////////////////////////////////////////////////////////////////
        // Unlock the S3 registers,  we need to unlock the registers a second
        // time since the interperter has them locked when it returns to us.
        //

        VideoPortWritePortUshort(CRT_ADDRESS_REG, 0x4838);
        VideoPortWritePortUshort(CRT_ADDRESS_REG, 0xA039);

        //////////////////////////////////////////////////////////////////
        // Warm up the hardware for the new mode, and work around any
        // BIOS bugs.
        //

        if ((hwDeviceExtension->ChipID == S3_801) &&
            (hwDeviceExtension->AdapterMemorySize == 0x080000)) {

            //
            // On 801/805 chipsets with 512k of memory we must AND
            // register 0x54 with 0x7.
            //

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x54);
            byte = VideoPortReadPortUchar(CRT_DATA_REG);
            byte &= 0x07;
            VideoPortWritePortUchar(CRT_DATA_REG, byte);
        }

        if (ModeEntry->ModeInformation.BitsPerPlane > 8) {

            //
            // Make sure 16-bit memory reads/writes are enabled.
            //

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x31);
            byte = VideoPortReadPortUchar(CRT_DATA_REG);
            byte |= 0x04;
            VideoPortWritePortUchar(CRT_DATA_REG, byte);
        }

        //
        // Set the colours for the built-in S3 pointer.
        //

        VideoPortWritePortUshort(CRT_ADDRESS_REG, 0xff0e);
        VideoPortWritePortUshort(CRT_ADDRESS_REG, 0x000f);

        if (hwDeviceExtension->ChipID >= S3_864) {

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x45);
            VideoPortReadPortUchar(CRT_DATA_REG);
            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x4A);
            VideoPortWritePortUchar(CRT_DATA_REG, 0xFF);
            VideoPortWritePortUchar(CRT_DATA_REG, 0xFF);
            VideoPortWritePortUchar(CRT_DATA_REG, 0xFF);
            VideoPortWritePortUchar(CRT_DATA_REG, 0xFF);

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x45);
            VideoPortReadPortUchar(CRT_DATA_REG);
            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x4B);
            VideoPortWritePortUchar(CRT_DATA_REG, 0x00);
            VideoPortWritePortUchar(CRT_DATA_REG, 0x00);
            VideoPortWritePortUchar(CRT_DATA_REG, 0x00);
            VideoPortWritePortUchar(CRT_DATA_REG, 0x00);
        }

        if (hwDeviceExtension->ChipID > S3_911) {

            //
            // Set the address for the frame buffer window and set the window
            // size.
            //

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x59);
            VideoPortWritePortUchar(CRT_DATA_REG,
                (UCHAR) (hwDeviceExtension->PhysicalFrameAddress.LowPart >> 24));

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5A);
            VideoPortWritePortUchar(CRT_DATA_REG,
                (UCHAR) (hwDeviceExtension->PhysicalFrameAddress.LowPart >> 16));

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x58);
            byte = VideoPortReadPortUchar(CRT_DATA_REG) & ~0x3;

            switch (hwDeviceExtension->FrameLength)
            {
            case 0x400000:
            case 0x800000:
                byte |= 0x3;
                break;
            case 0x200000:
                byte |= 0x2;
                break;
            case 0x100000:
                byte |= 0x1;
                break;
            case 0x010000:
                break;
            default:
                byte |= 0x3;
                break;
            }

            VideoPortWritePortUchar(CRT_DATA_REG, byte);
        }

        if (hwDeviceExtension->Capabilities & CAPS_NEW_MMIO) {

            //
            // Enable 'new memory-mapped I/O':
            //

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x53);
            byte = VideoPortReadPortUchar(CRT_DATA_REG);
            byte |= 0x18;
            VideoPortWritePortUchar(CRT_DATA_REG, byte);
        }

        if ((ModeEntry->ModeInformation.DriverSpecificAttributeFlags &
                CAPS_BT485_POINTER) &&
            (hwDeviceExtension->ChipID == S3_928)) {

            //
            // Some of the Number Nine boards do not set the chip up correctly
            // for an external cursor. We must OR in the bits, because if we
            // don't the Metheus board will not initialize.
            //

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x45);
            byte = VideoPortReadPortUchar(CRT_DATA_REG);
            byte |= 0x20;
            VideoPortWritePortUchar(CRT_DATA_REG, byte);

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x55);
            byte = VideoPortReadPortUchar(CRT_DATA_REG);
            byte |= 0x20;
            VideoPortWritePortUchar(CRT_DATA_REG, byte);
        }

        //
        // Some BIOSes don't disable linear addressing by default, so
        // make sure we do it here.
        //

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x58);
        byte = VideoPortReadPortUchar(CRT_DATA_REG);
        byte &= ~0x10;
        VideoPortWritePortUchar(CRT_DATA_REG, byte);

        //
        // Enable the Graphics engine.
        //

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x40);
        byte = VideoPortReadPortUchar(CRT_DATA_REG);
        byte |= 0x01;
        VideoPortWritePortUchar(CRT_DATA_REG, byte);

        status = NO_ERROR;

        break;

    case IOCTL_VIDEO_SET_COLOR_REGISTERS:

        VideoDebugPrint((2, "S3StartIO - SetColorRegs\n"));

        clutBuffer = RequestPacket->InputBuffer;

        status = S3SetColorLookup(HwDeviceExtension,
                                   (PVIDEO_CLUT) RequestPacket->InputBuffer,
                                   RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_RESET_DEVICE:

        VideoDebugPrint((2, "S3StartIO - RESET_DEVICE\n"));

        //
        // Prep the S3 card to return to a VGA mode
        //

        S3ResetHw(HwDeviceExtension, 0, 0);

        VideoDebugPrint((2, "S3 RESET_DEVICE - About to do int10\n"));

        //
        // Do an Int10 to mode 3 will put the board to a known state.
        //

        VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

        biosArguments.Eax = 0x0003;

        VideoPortInt10(HwDeviceExtension,
                       &biosArguments);

        VideoDebugPrint((2, "S3 RESET_DEVICE - Did int10\n"));

        status = NO_ERROR;
        break;

    case IOCTL_VIDEO_SHARE_VIDEO_MEMORY:

        VideoDebugPrint((2, "S3StartIO - ShareVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength < sizeof(VIDEO_SHARE_MEMORY_INFORMATION)) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) ) {

            VideoDebugPrint((1, "IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        pShareMemory = RequestPacket->InputBuffer;

        if ( (pShareMemory->ViewOffset > hwDeviceExtension->AdapterMemorySize) ||
             ((pShareMemory->ViewOffset + pShareMemory->ViewSize) >
                  hwDeviceExtension->AdapterMemorySize) ) {

            VideoDebugPrint((1, "IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INVALID_PARAMETER\n"));
            status = ERROR_INVALID_PARAMETER;
            break;
        }

        RequestPacket->StatusBlock->Information =
                                    sizeof(VIDEO_SHARE_MEMORY_INFORMATION);

        //
        // Beware: the input buffer and the output buffer are the same
        // buffer, and therefore data should not be copied from one to the
        // other
        //

        virtualAddress = pShareMemory->ProcessHandle;
        sharedViewSize = pShareMemory->ViewSize;

        inIoSpace = hwDeviceExtension->PhysicalFrameIoSpace;

        //
        // NOTE: we are ignoring ViewOffset
        //

        shareAddress.QuadPart =
            hwDeviceExtension->PhysicalFrameAddress.QuadPart;

        if (hwDeviceExtension->Capabilities & CAPS_NEW_MMIO) {

            //
            // With 'new memory-mapped I/O', the frame buffer is always
            // mapped in linearly.
            //

            //
            // Performance:
            //
            // Enable USWC on the P6 processor.
            // We only do it for the frame buffer - memory mapped registers can
            // not be mapped USWC because write combining the registers would
            // cause very bad things to happen !
            //

            inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;

            //
            // Unlike the MAP_MEMORY IOCTL, in this case we can not map extra
            // address space since the application could actually use the
            // pointer we return to it to touch locations in the address space
            // that do not have actual video memory in them.
            //
            // An app doing this would cause the machine to crash.
            //
            // However, because the caching policy for USWC in the P6 is on
            // *physical* addresses, this memory mapping will "piggy back" on
            // the normal frame buffer mapping, and therefore also benefit
            // from USWC ! Cool side-effect !!!
            //

            status = VideoPortMapMemory(hwDeviceExtension,
                                        shareAddress,
                                        &sharedViewSize,
                                        &inIoSpace,
                                        &virtualAddress);

            pShareMemoryInformation = RequestPacket->OutputBuffer;

            pShareMemoryInformation->SharedViewOffset = pShareMemory->ViewOffset;
            pShareMemoryInformation->VirtualAddress = virtualAddress;
            pShareMemoryInformation->SharedViewSize = sharedViewSize;

        } else {

            status = ERROR_INVALID_PARAMETER;
        }

        break;


    case IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY:

        VideoDebugPrint((2, "S3StartIO - UnshareVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_SHARE_MEMORY)) {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;

        }

        pShareMemory = RequestPacket->InputBuffer;

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      pShareMemory->RequestedVirtualAddress,
                                      pShareMemory->ProcessHandle);

        break;

    case IOCTL_VIDEO_S3_QUERY_STREAMS_PARAMETERS:

        VideoDebugPrint((2, "S3StartIO - QueryStreamsParameters\n"));

        //
        // This is a private, non-standard IOCTL so that the display driver
        // can query the appropriate minimum stretch ratio and FIFO value
        // for using the streams overlay processor in a particular mode.
        //

        if ((RequestPacket->InputBufferLength < sizeof(VIDEO_QUERY_STREAMS_MODE)) ||
            (RequestPacket->OutputBufferLength < sizeof(VIDEO_QUERY_STREAMS_PARAMETERS))) {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        status = QueryStreamsParameters(hwDeviceExtension,
                                        RequestPacket->InputBuffer,
                                        RequestPacket->OutputBuffer);

        if (status == NO_ERROR) {

            RequestPacket->StatusBlock->Information =
                sizeof(VIDEO_QUERY_STREAMS_PARAMETERS);
        }

        break;

    case IOCTL_PRIVATE_GET_FUNCTIONAL_UNIT:

        VideoDebugPrint((2, "S3StartIO - GetFunctionalUnit\n"));

        if (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information =
                                                sizeof(FUNCTIONAL_UNIT_INFO)) ) {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            ((PFUNCTIONAL_UNIT_INFO)RequestPacket->OutputBuffer)->FunctionalUnitID =
                hwDeviceExtension->FunctionalUnitID;

            ((PFUNCTIONAL_UNIT_INFO)RequestPacket->OutputBuffer)->Reserved = 0;

            status = NO_ERROR;
        }

        break;

    //
    // if we get here, an invalid IoControlCode was specified.
    //

    default:

        VideoDebugPrint((1, "Fell through S3 startIO routine - invalid command\n"));

        status = ERROR_INVALID_FUNCTION;

        break;

    }

    VideoDebugPrint((2, "Leaving S3 startIO routine\n"));

    RequestPacket->StatusBlock->Status = status;

    return TRUE;

} // end S3StartIO()


VP_STATUS
S3SetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )

/*++

Routine Description:

    This routine sets a specified portion of the color lookup table settings.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ClutBufferSize - Length of the input buffer supplied by the user.

    ClutBuffer - Pointer to the structure containing the color lookup table.

Return Value:

    None.

--*/

{
    USHORT i;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ( (ClutBufferSize < sizeof(VIDEO_CLUT) - sizeof(ULONG)) ||
         (ClutBufferSize < sizeof(VIDEO_CLUT) +
                     (sizeof(ULONG) * (ClutBuffer->NumEntries - 1)) ) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check to see if the parameters are valid.
    //

    if ( (ClutBuffer->NumEntries == 0) ||
         (ClutBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER) ||
         (ClutBuffer->FirstEntry + ClutBuffer->NumEntries >
                                     VIDEO_MAX_COLOR_REGISTER + 1) ) {

        return ERROR_INVALID_PARAMETER;

    }

    if (HwDeviceExtension->Capabilities & CAPS_WAIT_ON_PALETTE) {

        //
        // On some DACs, the hardware pointer 'sparkles' unless we first
        // wait for vertical retrace.
        //

        while (VideoPortReadPortUchar(SYSTEM_CONTROL_REG) & 0x08)
            ;
        while (!(VideoPortReadPortUchar(SYSTEM_CONTROL_REG) & 0x08))
            ;

        //
        // Then pause a little more.  0x400 is the lowest value that made
        // any remaining sparkle disappear on my PCI P90.
        //
        // Unfortunately, I have discovered that this is not a complete
        // solution -- there is still sparkle if the mouse is positioned
        // near the top of the screen.  A more complete solution would
        // probably be to turn the mouse off entirely if it's in that
        // range.
        //

        for (i = 0x400; i != 0; i--) {
            VideoPortReadPortUchar(SYSTEM_CONTROL_REG);
        }
    }

    //
    //  Set CLUT registers directly on the hardware
    //

    for (i = 0; i < ClutBuffer->NumEntries; i++) {

        VideoPortWritePortUchar(DAC_ADDRESS_WRITE_PORT, (UCHAR) (ClutBuffer->FirstEntry + i));
        VideoPortWritePortUchar(DAC_DATA_REG_PORT, (UCHAR) (ClutBuffer->LookupTable[i].RgbArray.Red));
        VideoPortWritePortUchar(DAC_DATA_REG_PORT, (UCHAR) (ClutBuffer->LookupTable[i].RgbArray.Green));
        VideoPortWritePortUchar(DAC_DATA_REG_PORT, (UCHAR) (ClutBuffer->LookupTable[i].RgbArray.Blue));

    }

    return NO_ERROR;

} // end S3SetColorLookup()


VOID
SetHWMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT pusCmdStream
    )

/*++

Routine Description:

    Interprets the appropriate command array to set up VGA registers for the
    requested mode. Typically used to set the VGA into a particular mode by
    programming all of the registers

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    pusCmdStream - pointer to a command stream to execute.

Return Value:

    The status of the operation (can only fail on a bad command); TRUE for
    success, FALSE for failure.

--*/

{
    ULONG ulCmd;
    ULONG ulPort;
    UCHAR jValue;
    USHORT usValue;
    ULONG culCount;
    ULONG ulIndex,
          Microseconds;
    ULONG mappedAddressIndex = 2; // fool Prefix
    ULONG mappedAddressOffset = 0x3c0; // fool Prefix

    //
    // If there is no command string, just return
    //

    if (!pusCmdStream) {

        return;

    }

    while ((ulCmd = *pusCmdStream++) != EOD) {

        //
        // Determine major command type
        //

        switch (ulCmd & 0xF0) {

        case RESET_CR5C:

            if (HwDeviceExtension->BiosPresent == FALSE)
            {
                UCHAR value, oldvalue;

                //
                // Reset the upper four bits of the General Out Port Reg
                // with the value it had after the POST.
                //

                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5c);
                value = VideoPortReadPortUchar(CRT_DATA_REG);
                oldvalue = value;

                value &= 0x0f;
                value |= HwDeviceExtension->CR5C;

                VideoPortWritePortUchar(CRT_DATA_REG, value);

                VideoDebugPrint((2, "S3: CRC5 was 0x%x and we "
                                    "have set it to 0x%x\n",
                                    oldvalue, value));
            }
            break;

        case SELECTACCESSRANGE:

            //
            // Determine which address range to use for commands that follow
            //

            switch (ulCmd & 0x0F) {

            case VARIOUSVGA:

                //
                // Used for registers in the range 0x3c0 - 0x3cf
                //

                mappedAddressIndex  = 2;
                mappedAddressOffset = 0x3c0;

                break;

            case SYSTEMCONTROL:

                //
                // Used for registers in the range 0x3d4 - 0x3df
                //

                mappedAddressIndex  = 3;
                mappedAddressOffset = 0x3d4;

                break;

            case ADVANCEDFUNCTIONCONTROL:

                //
                // Used for registers in the range 0x4ae8-0x4ae9
                //

                mappedAddressIndex  = 5;
                mappedAddressOffset = 0x4ae8;

                break;

            }

            break;


        case OWM:

            ulPort   = *pusCmdStream++;
            culCount = *pusCmdStream++;

            while (culCount--) {
                usValue = *pusCmdStream++;
                VideoPortWritePortUshort((PUSHORT)((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort),
                                         usValue);
            }

            break;


        // Basic input/output command

        case INOUT:

            // Determine type of inout instruction
            if (!(ulCmd & IO)) {

                // Out instruction
                // Single or multiple outs?
                if (!(ulCmd & MULTI)) {

                    // Single out
                    // Byte or word out?
                    if (!(ulCmd & BW)) {

                        // Single byte out
                        ulPort = *pusCmdStream++;
                        jValue = (UCHAR) *pusCmdStream++;
                        VideoPortWritePortUchar((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort,
                                                jValue);

                    } else {

                        // Single word out
                        ulPort = *pusCmdStream++;
                        usValue = *pusCmdStream++;
                        VideoPortWritePortUshort((PUSHORT)((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort),
                                                usValue);

                    }

                } else {

                    // Output a string of values
                    // Byte or word outs?
                    if (!(ulCmd & BW)) {

                        // String byte outs. Do in a loop; can't use
                        // VideoPortWritePortBufferUchar because the data
                        // is in USHORT form
                        ulPort = *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        while (culCount--) {
                            jValue = (UCHAR) *pusCmdStream++;
                            VideoPortWritePortUchar((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort,
                                                    jValue);

                        }

                    } else {

                        // String word outs
                        ulPort = *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        VideoPortWritePortBufferUshort((PUSHORT)((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort),
                                                       pusCmdStream,
                                                       culCount);
                        pusCmdStream += culCount;

                    }
                }

            } else {

                // In instruction

                // Currently, string in instructions aren't supported; all
                // in instructions are handled as single-byte ins

                // Byte or word in?
                if (!(ulCmd & BW)) {

                    // Single byte in
                    ulPort = *pusCmdStream++;

                    jValue = VideoPortReadPortUchar((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort);


                } else {

                    // Single word in
                    ulPort = *pusCmdStream++;
                    usValue = VideoPortReadPortUshort((PUSHORT)((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort));

                }

            }

            break;


        // Higher-level input/output commands

        case METAOUT:

            // Determine type of metaout command, based on minor command field
            switch (ulCmd & 0x0F) {

                // Indexed outs
                case INDXOUT:

                    ulPort = *pusCmdStream++;
                    culCount = *pusCmdStream++;
                    ulIndex = *pusCmdStream++;

                    while (culCount--) {

                        usValue = (USHORT) (ulIndex +
                                  (((ULONG)(*pusCmdStream++)) << 8));
                        VideoPortWritePortUshort((PUSHORT)((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort),
                                             usValue);

                        ulIndex++;

                    }

                    break;


                // Masked out (read, AND, XOR, write)
                case MASKOUT:

                    ulPort = *pusCmdStream++;
                    jValue = VideoPortReadPortUchar((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort);
                    jValue &= *pusCmdStream++;
                    jValue ^= *pusCmdStream++;
                    VideoPortWritePortUchar((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort,
                                            jValue);
                    break;


                // Attribute Controller out
                case ATCOUT:

                    ulPort = *pusCmdStream++;
                    culCount = *pusCmdStream++;
                    ulIndex = *pusCmdStream++;

                    while (culCount--) {

                        // Write Attribute Controller index
                        VideoPortWritePortUchar((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort,
                                                (UCHAR)ulIndex);

                        // Write Attribute Controller data
                        jValue = (UCHAR) *pusCmdStream++;
                        VideoPortWritePortUchar((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort,
                                                jValue);

                        ulIndex++;

                    }

                    break;

                case DELAY:

                    Microseconds = (ULONG) *pusCmdStream++;
                    VideoPortStallExecution(Microseconds);

                    break;

                case VBLANK:

                    Wait_VSync(HwDeviceExtension);

                    break;

                //
                // This function in setmode is pageable !!!
                // it is only used to set high res modes.
                //

                case SETCLK:

                    Set_Oem_Clock(HwDeviceExtension);

                    break;

                case SETCRTC:

                    //
                    // NOTE:
                    // beware: recursive call ...
                    //

                    SetHWMode(HwDeviceExtension,
                              HwDeviceExtension->ActiveFrequencyEntry->
                                  Fixed.CRTCTable[HwDeviceExtension->ChipID]);


                    break;


                // None of the above; error
                default:

                    return;

            }

            break;


        // NOP

        case NCMD:

            break;


        // Unknown command; error

        default:

            return;

        }

    }

    return;

} // end SetHWMode()


LONG
CompareRom(
    PUCHAR Rom,
    PUCHAR String
    )

/*++

Routine Description:

    Compares a string to that in the ROM.  Returns -1 if Rom < String, 0
    if Rom == String, 1 if Rom > String.

Arguments:

    Rom - Rom pointer.

    String - String pointer.

Return Value:

    None

--*/

{
    UCHAR jString;
    UCHAR jRom;

    while (*String) {

        jString = *String;
        jRom = VideoPortReadRegisterUchar(Rom);

        if (jRom != jString) {

            return(jRom < jString ? -1 : 1);

        }

        String++;
        Rom++;
    }

    return(0);
}


VOID
ZeroMemAndDac(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Initialize the DAC to 0 (black).

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

    None

--*/

{
    ULONG i;

    //
    // Turn off the screen at the DAC.
    //

    VideoPortWritePortUchar(DAC_PIXEL_MASK_REG, 0x0);

    for (i = 0; i < 256; i++) {

        VideoPortWritePortUchar(DAC_ADDRESS_WRITE_PORT, (UCHAR)i);
        VideoPortWritePortUchar(DAC_DATA_REG_PORT, 0x0);
        VideoPortWritePortUchar(DAC_DATA_REG_PORT, 0x0);
        VideoPortWritePortUchar(DAC_DATA_REG_PORT, 0x0);

    }

    //
    // Zero the memory.
    //

    //
    // The zeroing of video memory should be implemented at a later time to
    // ensure that no information remains in video memory at shutdown, or
    // while swtiching to fullscren mode (for security reasons).
    //

    //
    // Turn on the screen at the DAC
    //

    VideoPortWritePortUchar(DAC_PIXEL_MASK_REG, 0x0ff);

    return;

}

VP_STATUS
Set_Oem_Clock(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Set the clock chip on each of the supported cards.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    Always TRUE

--*/

{
    ULONG ul;
    ULONG screen_width;
    UCHAR cr5C;
    ULONG clock_numbers;

    switch(HwDeviceExtension->BoardID) {

    case S3_NUMBER_NINE:

        VideoPortStallExecution(1000);

        // Jerry said to make the M clock not multiple of the P clock
        // on the 3 meg (level 12) board.  This solves the shimmy
        // problem.

        if (HwDeviceExtension->AdapterMemorySize == 0x00300000) {

            ul = 49000000;
            clock_numbers = calc_clock(ul, 3);
            set_clock(HwDeviceExtension, clock_numbers);
            VideoPortStallExecution(3000);

        }

        ul = HwDeviceExtension->ActiveFrequencyEntry->Fixed.Clock;
        clock_numbers = calc_clock(ul, 2);
        set_clock(HwDeviceExtension, clock_numbers);

        VideoPortStallExecution(3000);

        break;


    case S3_IBM_PS2:

        // Read the current screen frequency and width
        ul = HwDeviceExtension->ActiveFrequencyEntry->ScreenFrequency;
        screen_width = HwDeviceExtension->ActiveFrequencyEntry->ScreenWidth;

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5C);
        cr5C = VideoPortReadPortUchar( CRT_DATA_REG );
        cr5C &= 0xCF;

        switch (screen_width) {
           case 640:

              if (ul == 60) {
                cr5C |= 0x00;
                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5C);
                VideoPortWritePortUchar(CRT_DATA_REG, cr5C);
              } else { // 72Hz
                cr5C |= 0x20;
                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5C);
                VideoPortWritePortUchar(CRT_DATA_REG, cr5C);
              } /* endif */
              VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x42);
              VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR)0x00);
              VideoPortWritePortUchar(MISC_OUTPUT_REG_WRITE, (UCHAR)0xEF);

              break;

           case 800:

              if (ul == 60) {
                cr5C |= 0x00;
                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5C);
                VideoPortWritePortUchar(CRT_DATA_REG, cr5C);
                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x42);
                VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR)0x05);
              } else { // 72Hz
                cr5C |= 0x10;
                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5C);
                VideoPortWritePortUchar(CRT_DATA_REG, cr5C);
                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x42);
                VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR)0x02);
              } /* endif */
              VideoPortWritePortUchar(MISC_OUTPUT_REG_WRITE, (UCHAR)0x2F);

              break;

           case 1024:

              if (ul == 60) {
                cr5C |= 0x00;
                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5C);
                VideoPortWritePortUchar(CRT_DATA_REG, cr5C);
                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x42);
                VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR)0x05);
                VideoPortWritePortUchar(MISC_OUTPUT_REG_WRITE, (UCHAR)0xEF);
              } else { // 72Hz
                cr5C |= 0x20;
                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5C);
                VideoPortWritePortUchar(CRT_DATA_REG, cr5C);
                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x42);
                VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR)0x05);
                VideoPortWritePortUchar(MISC_OUTPUT_REG_WRITE, (UCHAR)0x2F);
              } /* endif */

              break;

           default:
             break;
        } /* endswitch */

        break;

        //
        // Generic S3 board.
        //

    case S3_GENERIC:
    default:

        //
        // If the board has an SDAC then assume it also has an 864 (for now)
        // this could be made better later by checking ChipID too, it appears
        // that the display driver will need to be made 864 specific to get
        // the best possible performance and this one may need to be specific
        // before this is all done so I am not making it bulletproof yet
        //

        if( HwDeviceExtension->DacID == S3_SDAC ) {
            InitializeSDAC( HwDeviceExtension );
        } else {
            ul = HwDeviceExtension->ActiveFrequencyEntry->Fixed.Clock;
            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x42);
            VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) ul);
        }

        break;

    }

    return TRUE;
}


VP_STATUS
Wait_VSync(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Wait for the vertical blanking interval on the chip

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

    Always TRUE

--*/

{
    ULONG i;
    UCHAR byte;

    // It's real possible that this routine will get called
    // when the 911 is in a zombie state, meaning there is no
    // vertical sync being generated.  This is why we have some long
    // time out loops here.

    // First wait for getting into vertical blanking.

    for (i = 0; i < 0x100000; i++) {

        byte = VideoPortReadPortUchar(SYSTEM_CONTROL_REG);
        if (byte & 0x08)
            break;

    }

    //
    // We are either in a vertical blaning interval or we have timmed out.
    // Wait for the Vertical display interval.
    // This is done to make sure we exit this routine at the beginning
    // of a vertical blanking interval, and not in the middle or near
    // the end of one.
    //

    for (i = 0; i < 0x100000; i++) {

        byte = VideoPortReadPortUchar(SYSTEM_CONTROL_REG);
        if (!(byte & 0x08))
            break;

    }

    //
    // Now wait to get into the vertical blank interval again.
    //

    for (i = 0; i < 0x100000; i++) {

        byte = VideoPortReadPortUchar(SYSTEM_CONTROL_REG);
        if (byte & 0x08)
            break;

    }

    return (TRUE);

}


BOOLEAN
Set864MemoryTiming(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Sets L, M and N timing parameters, also sets and enables the
    Start Display FIFO register

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

    TRUE if success, FALSE if failure

--*/

{

    ULONG  MIndex, ColorDepth, ScreenWidth, failure = 0;
    USHORT data16;
    UCHAR  data8, old38, old39;

    //
    // unlock registers
    //

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x38);
    old38 = VideoPortReadPortUchar( CRT_DATA_REG);
    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x39);
    old39 = VideoPortReadPortUchar( CRT_DATA_REG);
    VideoPortWritePortUshort(CRT_ADDRESS_REG, 0x4838);
    VideoPortWritePortUshort(CRT_ADDRESS_REG, 0xA039);

    //
    // make sure this is an 864
    //

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x30);
    